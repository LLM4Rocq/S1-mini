{
  "statement": "Lemma ker_cprod_by_central : kerHK \\subset 'Z(setX H K).\n",
  "proof": "Proof.\nrewrite -(center_dprod (setX_dprod H K)) -morphim_pairg1 -morphim_pair1g.\nrewrite -!injm_center ?subsetT ?injm_pair1g ?injm_pairg1 //=.\nrewrite morphim_pairg1 morphim_pair1g setX_dprod.\napply/subsetP=> [[x y]] /[1!inE] /andP[Zx /eqP->].\nby rewrite inE /= Zx groupV (subsetP sgzZZ) ?mem_morphim.\nQed."
}
{
  "statement": "Lemma card_preimset (T : finType) (f : T -> T) (A : {set T}) :\n  injective f -> #|f @^-1: A| = #|A|.\n",
  "proof": "Proof.\nmove=> injf; apply: on_card_preimset; apply: onW_bij.\nhave ontof: _ \\in codom f by apply/(subset_cardP (card_codom injf))/subsetP.\nby exists (fun x => iinv (ontof x)) => x; rewrite (f_iinv, iinv_f).\nQed."
}
{
  "statement": "Lemma atrans_acts_in G S :\n  G \\subset D -> [transitive G, on S | to] -> [acts G, on S | to].\n",
  "proof": "Proof.\nmove=> sGD transG; apply/subsetP=> a Ga; rewrite !inE (subsetP sGD) //.\nby apply/subsetP=> x /(atransPin sGD transG) <-; rewrite inE imset_f.\nQed."
}
{
  "statement": "Lemma poly_rV_K p : size p <= d -> rVpoly (poly_rV p) = p.\n",
  "proof": "Proof.\nmove=> le_p_d; apply/polyP=> k; rewrite coef_rVpoly.\ncase: insubP => [i _ <- | ]; first by rewrite mxE.\nby rewrite -ltnNge => le_d_l; rewrite nth_default ?(leq_trans le_p_d).\nQed."
}
{
  "statement": "Lemma root_gcd p q x : root (gcdp p q) x = root p x && root q x.\n",
  "proof": "Proof.\nrewrite /= !root_factor_theorem; apply/idP/andP=> [dg| [dp dq]].\n  by split; apply: dvdp_trans dg _; rewrite ?(dvdp_gcdl, dvdp_gcdr).\nhave:= Bezoutp p q => [[[u v]]]; rewrite eqp_sym=> e.\nby rewrite (eqp_dvdr _ e) dvdp_addl dvdp_mull.\nQed."
}
{
  "statement": "Lemma perm_onV H s : perm_on H s -> perm_on H s^-1.\n",
  "proof": "Proof.\nmove=> /subsetP sH; apply/subsetP => i /[!inE] sVi; apply: sH; rewrite inE.\nby apply: contra_neq sVi => si_id; rewrite -[in LHS]si_id permK.\nQed."
}
{
  "statement": "Lemma bound_meetA : associative bound_meet.\n",
  "proof": "Proof.\ncase=> [? x|[]][? y|[]][? z|[]] //=; rewrite !lexI meetA; congr BSide.\nby case: (lcomparableP x y) => [|||->]; case: (lcomparableP y z) => [|||->];\n  case: (lcomparableP x z) => [|||//<-]; case: (lcomparableP x y);\n  rewrite //= ?andbF ?orbF ?lexx ?orbA //; case: (lcomparableP y z).\nQed."
}
{
  "statement": "Lemma prime_coprime p m : prime p -> coprime p m = ~~ (p %| m).\n",
  "proof": "Proof.\ncase/primeP=> p_gt1 p_pr; apply/eqP/negP=> [d1 | ndv_pm].\n  case/dvdnP=> k def_m; rewrite -(addn0 m) def_m gcdnMDl gcdn0 in d1.\n  by rewrite d1 in p_gt1.\nby apply: gcdn_def => // d /p_pr /orP[] /eqP->.\nQed."
}
{
  "statement": "Lemma rfix_mx_rstabC (H : {set gT}) m (U : 'M[F]_(m, n)) :\n  H \\subset G -> (H \\subset rstab rG U) = (U <= rfix_mx H)%MS.\n",
  "proof": "Proof.\nmove=> sHG; apply/subsetP/rfix_mxP=> cHU x Hx.\n  by rewrite (rstab_act (cHU x Hx)).\nby rewrite !inE (subsetP sHG) //= cHU.\nQed."
}
{
  "statement": "Lemma part_p'nat pi n : pi^'.-nat n -> n`_pi = 1.\n",
  "proof": "Proof.\ncase/andP=> n_gt0 pi'_n; apply: big1_seq => p /andP[pi_p _].\nby have [-> //|] := posnP (logn p n); rewrite logn_gt0; case/(allP pi'_n)/negP.\nQed."
}
{
  "statement": "Lemma nil_class2 G : (nil_class G <= 2) = (G^`(1) \\subset 'Z(G)).\n",
  "proof": "Proof.\nrewrite subsetI der_sub; apply/idP/commG1P=> [clG2 | L3G1].\n  by apply/(lcn_nil_classP 2); rewrite ?small_nil_class ?(leq_trans clG2).\nby apply/(lcn_nil_classP 2) => //; apply/lcnP; exists 2.\nQed."
}
{
  "statement": "Lemma perm_zip_sym (S T : eqType) (s1 s2 : seq S) (t1 t2 : seq T) : \n  perm_eq (zip s1 t1) (zip s2 t2) -> perm_eq (zip t1 s1) (zip t2 s2).\n",
  "proof": "Proof.\nhave swap t s : zip t s = map (fun u => (u.2, u.1)) (zip s t).\n  by elim: s t => [|x s +] [|y t]//= => ->.\nby rewrite [zip t1 s1]swap [zip t2 s2]swap; apply: perm_map.\nQed."
}
{
  "statement": "Lemma mxEmxrow m n (A : 'M[T]_(m, n)) :\n  A = castmx (erefl, big_ord1 _ (fun=> n)) (\\mxrow__ A).\n",
  "proof": "Proof.\napply/matrixP => i j; rewrite castmxE !mxE/= cast_ord_id.\ncongr (A i); set j' := cast_ord _ _.\nsuff -> : j' = (tagnat.Rank 0 j) by apply/val_inj; rewrite tagnat.Rank2K.\nby apply/val_inj; rewrite [RHS]tagnat.RankEsum/= big_pred0_eq add0n.\nQed."
}
{
  "statement": "Lemma eq_mxdiagP (B_ B'_ : forall i, 'M[V]_(p_ i)) :\n  (forall i, B_ i = B'_ i) <-> (\\mxdiag_i B_ i = \\mxdiag_i B'_ i).\n",
  "proof": "Proof.\nrewrite /mxdiag; split; first by move=> e; apply/eq_mxblockP => i j; rewrite e.\nby move=> + i => /eq_mxblockP/(_ i i); rewrite eqxx !conform_mx_id.\nQed."
}
{
  "statement": "Lemma normalField_kAut K M E f :\n  (K <= M <= E)%VS -> normalField K M -> kAut K E f -> kAut K M f.\n",
  "proof": "Proof.\ncase/andP=> sKM sME nKM /kAut_to_gal[x galEx /(sub_in1 (subvP sME))Df].\nhave sKE := subv_trans sKM sME; rewrite gal_kHom // in galEx.\nrewrite (kAut_eq sKM Df) /kAut (kHomSr sME) //= (forall_inP nKM) // inE.\nby rewrite kAutfE; apply/kAHomP; apply: (kAHomP galEx).\nQed."
}
{
  "statement": "Lemma orthogonal_oppr S R : orthogonal form S (map -%R R) = orthogonal form S R.\n",
  "proof": "Proof.\nwlog suffices IH: S R / orthogonal form S R -> orthogonal form S (map -%R R).\n  by apply/idP/idP=> /IH; rewrite ?mapK //; apply: opprK.\nmove/orthogonalP=> oSR; apply/orthogonalP=> xi1 _ Sxi1 /mapP[xi2 Rxi2 ->].\nby rewrite linearNr /= oSR ?oppr0.\nQed."
}
{
  "statement": "Lemma nil_class3 G : (nil_class G <= 3) = ('L_3(G) \\subset 'Z(G)).\n",
  "proof": "Proof.\nrewrite subsetI lcn_sub; apply/idP/commG1P=> [clG3 | L4G1].\n  by apply/(lcn_nil_classP 3); rewrite ?small_nil_class ?(leq_trans clG3).\nby apply/(lcn_nil_classP 3) => //; apply/lcnP; exists 3.\nQed."
}
{
  "statement": "Lemma algid_subproof U :\n  {e | e \\in U\n     & has_algid U ==> (U <= lker (amull e - 1) :&: lker (amulr e - 1))%VS}.\n",
  "proof": "Proof.\napply: sig2W; case: has_algidP => [[e]|]; last by exists 0; rewrite ?mem0v.\ncase=> Ae _ idAe; exists e => //; apply/subvP=> u /idAe[eu_u ue_u].\nby rewrite memv_cap !memv_ker !lfun_simp /= eu_u ue_u subrr eqxx.\nQed."
}
{
  "statement": "Lemma mulg_normal_maximal G M H :\n  M <| G -> maximal M G -> H \\subset G -> ~~ (H \\subset M) -> (M * H = G)%g.\n",
  "proof": "Proof.\ncase/andP=> sMG nMG /maxgroupP[_ maxM] sHG not_sHM.\napply/eqP; rewrite eqEproper mul_subG // -norm_joinEr ?(subset_trans sHG) //.\nby apply: contra not_sHM => /maxM <-; rewrite ?joing_subl ?joing_subr.\nQed."
}
{
  "statement": "Lemma mem_orthovP V u : reflect {in V, forall v, '[u, v] = 0} (u \\in orthov V).\n",
  "proof": "Proof.\napply: (iffP idP) => [/mem_orthovPn orthovNu v vV|/(_ _ _)/eqP orthov_u].\n  by apply/eqP/negP=> /negP Northov_uv; apply: orthovNu; exists v.\nby apply/mem_orthovPn => -[v /orthov_u->].\nQed."
}
{
  "statement": "Lemma leq_rmodp m d : size (rmodp m d) <= size m.\n",
  "proof": "Proof.\nhave [/rmodp_small -> //|h] := ltnP (size m) (size d).\nhave [->|d0] := eqVneq d 0; first by rewrite rmodp0.\nby apply: leq_trans h; apply: ltnW; rewrite ltn_rmodp.\nQed."
}
{
  "statement": "Lemma exchange_big_nat_idem m1 n1 m2 n2 (P Q : pred nat) F :\n  \\big[op/x]_(m1 <= i < n1 | P i) \\big[op/x]_(m2 <= j < n2 | Q j) F i j =\n    \\big[op/x]_(m2 <= j < n2 | Q j) \\big[op/x]_(m1 <= i < n1 | P i) F i j.\n",
  "proof": "Proof.\nrewrite (exchange_big_dep_nat_idem Q) //.\nby under eq_bigr => i Qi do under eq_bigl do rewrite Qi andbT.\nQed."
}
{
  "statement": "Lemma maxrankfun_inj : injective mxf.\n",
  "proof": "Proof.\nmove=> i j eqAij; have /row_free_inj := maxrowsub_free.\nmove=> /(_ 1) /(_ (delta_mx 0 i) (delta_mx 0 j)).\nrewrite -!rowE !row_rowsub eqAij => /(_ erefl) /matrixP /(_ 0 i) /eqP.\nby rewrite !mxE !eqxx/=; case: (i =P j); rewrite // oner_eq0.\nQed."
}
{
  "statement": "Lemma sub_inertia_Ind phi :\n  G \\subset 'N(H) -> 'I_G[phi] \\subset 'I_G['Ind[H, K] phi].\n",
  "proof": "Proof.\nmove=> nHG; apply/subsetP=> y /setIP[Gy /setIdP[nKy /eqP Iphi_y]].\nby rewrite 2!inE Gy cfConjgInd_norm ?(subsetP nHG) ?Iphi_y /=.\nQed."
}
{
  "statement": "Lemma F_s23 :\n  'Fix_to_g[s23] = [set x | (col0 x == col5 x) && (col1 x == col4 x)].\n",
  "proof": "Proof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s23_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //=].\nQed."
}
{
  "statement": "Lemma afixRs_rcosets A G : 'Fix_(rcosets G A | 'Rs)(G) = rcosets G 'N_A(G).\n",
  "proof": "Proof.\napply/setP=> Gx; apply/setIP/rcosetsP=> [[/rcosetsP[x Ax ->]]|[x]].\n  by rewrite sub_afixRs_norm => Nx; exists x; rewrite // inE Ax.\nby case/setIP=> Ax Nx ->; rewrite -{1}rcosetE imset_f // sub_afixRs_norm.\nQed."
}
{
  "statement": "Lemma ltngtP m n :\n  compare_nat m n (minn n m) (minn m n) (maxn n m) (maxn m n)\n                  (n == m) (m == n) (n <= m) (m <= n) (n < m) (m < n).\n",
  "proof": "Proof.\nrewrite !ltn_neqAle [_ == n]eq_sym; have [mn|] := ltnP m n.\n  by rewrite ltnW // gtn_eqF //; constructor.\nrewrite leq_eqVlt; case: ltnP; rewrite ?(orbT, orbF) => //= lt_nm eq_nm.\n  by rewrite ltn_eqF //; constructor.\nby rewrite eq_nm (eqP eq_nm); constructor.\nQed."
}
{
  "statement": "Lemma Clifford_rank_components (W : sH) : (#|sH| * \\rank W)%N = n.\n",
  "proof": "Proof.\nrewrite -{9}(mxrank1 F n) -Clifford_Socle1.\nrewrite (mxdirectP (Socle_direct sH)) /= -sum_nat_const.\napply: eq_bigr => W1 _; have [W0 _ W0G] := imsetP Clifford_atrans.\nhave{} W0G W': W' \\in orbit 'Cl G W0 by rewrite -W0G inE.\nhave [/orbitP[x Gx <-] /orbitP[y Gy <-]] := (W0G W, W0G W1).\nby rewrite !{1}val_Clifford_act // !mxrankMfree // !repr_mx_free.\nQed."
}
{
  "statement": "Lemma chinese_modr r1 r2 : chinese r1 r2 = r2 %[mod m2].\n",
  "proof": "Proof.\nrewrite /chinese; case: (posnP m1) co_m12 => [-> /eqnP | m1_gt0 _].\n  by rewrite gcd0n => ->; rewrite !modn1.\ncase: (egcdnP m2) => // k1 k2 def_m2 _.\nrewrite addnC mulnAC -mulnA def_m2 (eqnP co_m12) mulnDr mulnA muln1.\nby rewrite addnAC (mulnAC _ m2) -mulnDl modnMDl.\nQed."
}
{
  "statement": "Lemma subset_filter p s1 s2 :\n  s1 \\subset s2 -> [seq a <- s1 | p a] \\subset [seq a <- s2 | p a].\n",
  "proof": "Proof.\nby move/subsetP=> s12; apply/subsetP=> x; rewrite !mem_filter=> /andP[-> /s12].\nQed."
}
{
  "statement": "Lemma separable_mul p q :\n  separable (p * q) = [&& separable p, separable q & coprimep p q].\n",
  "proof": "Proof.\napply/idP/and3P => [sep_pq | [sep_p sep_q co_pq]].\n  rewrite !(dvdp_separable _ sep_pq) ?dvdp_mulIr ?dvdp_mulIl //.\n  by rewrite (separable_coprime sep_pq).\nrewrite unlock in sep_p sep_q *.\nrewrite derivM coprimepMl {1}addrC mulrC !coprimep_addl_mul.\nby rewrite !coprimepMr (coprimep_sym q p) co_pq !andbT; apply/andP.\nQed."
}
{
  "statement": "Lemma orbit_lcoset_in A a x :\n    A \\subset D -> a \\in D ->\n  orbit to (a *: A) x = orbit to A (to x a).\n",
  "proof": "Proof.\nmove/subsetP=> sAD Da; apply/setP=> y; apply/imsetP/imsetP=> [] [b Ab ->{y}].\n  by exists (a^-1 * b); rewrite -?actMin ?mulKVg // ?sAD -?mem_lcoset.\nby exists (a * b); rewrite ?mem_mulg ?set11 ?actMin // sAD.\nQed."
}
{
  "statement": "Lemma ler_pXn2r n :\n  (0 < n)%N -> {in nneg & , {mono (@GRing.exp R)^~ n : x y / x <= y}}.\n",
  "proof": "Proof.\ncase: n => // n _ x y; rewrite !qualifE /= =>  x_ge0 y_ge0.\nhave [-> | nzx] := eqVneq x 0; first by rewrite exprS mul0r exprn_ge0.\nrewrite -subr_ge0 subrXX pmulr_lge0 ?subr_ge0 //= big_ord_recr /=.\nrewrite subnn expr0 mul1r /= ltr_pwDr // ?exprn_gt0 ?lt0r ?nzx //.\nby rewrite sumr_ge0 // => i _; rewrite mulr_ge0 ?exprn_ge0.\nQed."
}
{
  "statement": "Lemma injm_cpairg1 : 'injm cpairg1.\n",
  "proof": "Proof.\nrewrite /cpairg1; case: restrmP => _ [_ -> _ _].\nrewrite ker_comp ker_in_cprod; apply/subsetP=> x; rewrite 5!inE /=.\nby case/and3P=> _ Zx; rewrite inE eq_sym (inv_eq invgK) invg1 morph_injm_eq1.\nQed."
}
{
  "statement": "Lemma astabsP S a :\n  reflect (forall x, (to x a \\in S) = (x \\in S)) (a \\in 'N(S | to)).\n",
  "proof": "Proof.\napply: (iffP idP) => [nSa x|nSa]; first exact: astabs_act.\nby rewrite !inE; apply/subsetP=> x; rewrite inE nSa.\nQed."
}
{
  "statement": "Lemma irredp_XsubC (x : R) : irreducible_poly ('X - x%:P).\n",
  "proof": "Proof.\nsplit=> [|d size_d d_dv_Xx]; first by rewrite size_XsubC.\nhave: ~ d %= 1 by apply/negP; rewrite -size_poly_eq1.\nhave [|m /=] := @dvdp_prod_XsubC _ [:: x] id d; first by rewrite big_seq1.\nby case: m => [|[] [|_ _] /=]; rewrite (big_nil, big_seq1).\nQed."
}
{
  "statement": "Lemma astabP S a : reflect (forall x, x \\in S -> to x a = x) (a \\in 'C(S | to)).\n",
  "proof": "Proof.\napply: (iffP idP) => [cSa x|cSa]; first exact: astab_act.\nby rewrite !inE; apply/subsetP=> x Sx; rewrite inE cSa.\nQed."
}
{
  "statement": "Lemma lin_irr_der1 G i :\n   ('chi_i \\is a linear_char) = (G^`(1)%g \\subset cfker 'chi[G]_i).\n",
  "proof": "Proof.\napply/idP/idP=> [|sG'K]; first exact: lin_char_der1.\nhave nsG'G: G^`(1) <| G := der_normal 1 G.\nrewrite qualifE/= irr_char -[i](quo_IirrK nsG'G) // mod_IirrE //=.\nby rewrite cfModE // morph1 lin_char1 //; apply/char_abelianP/der_abelian.\nQed."
}
{
  "statement": "Lemma exprNn_pchar x n : (pchar R).-nat n -> (- x) ^+ n = - (x ^+ n).\n",
  "proof": "Proof.\npose p := pdiv n; have [|n_gt1 pcharRn] := leqP n 1; first by case: (n) => [|[]].\nhave pcharRp: p \\in pchar R by rewrite (pnatPpi pcharRn) // pi_pdiv.\nhave /p_natP[e ->]: p.-nat n by rewrite -(eq_pnat _ (pcharf_eq pcharRp)).\nelim: e => // e IHe; rewrite expnSr !exprM {}IHe.\nby rewrite -pFrobenius_autE pFrobenius_autN.\nQed."
}
{
  "statement": "Lemma setX_gen (H1 : {set gT1}) (H2 : {set gT2}) :\n  1 \\in H1 -> 1 \\in H2 -> <<setX H1 H2>> = setX <<H1>> <<H2>>.\n",
  "proof": "Proof.\nmove=> H1_1 H2_1; apply/eqP.\nrewrite eqEsubset gen_subG setXS ?subset_gen //.\n\nrewrite -[in X in X \\subset _]setX_prod.\nrewrite -morphim_pair1g -morphim_pairg1 !morphim_gen ?subsetT //.\nby rewrite morphim_pair1g morphim_pairg1 mul_subG // genS // setXS ?sub1set.\nQed."
}
{
  "statement": "Lemma count_subseqP s1 s2 :\n  (forall x, count_mem x s1 <= count_mem x s2) <->\n    exists2 s, subseq s s2 & perm_eq s1 s.\n",
  "proof": "Proof.\nsplit=> [/count_maskP[m _]|]; first by exists (mask m s2); rewrite ?mask_subseq.\nby move=> -[_/subseqP[m sm ->] ?]; apply/count_maskP; exists m.\nQed."
}
{
  "statement": "Lemma sum_odd_poly p :\n  \\sum_(i < size p | odd i) p`_i *: 'X^i = (odd_poly p \\Po 'X^2) * 'X.\n",
  "proof": "Proof.\napply/polyP => i; rewrite coefMX coef_comp_poly_Xn// coef_sumMXn coef_odd_poly/=.\ncase: i => [|i]//=; first by rewrite big_andbC big1// => -[[|j]//].\nrewrite big_ord1_cond_eq/= -dvdn2 andbC -muln2.\nby case: dvdnP => //= -[k ->]; rewrite mulnK// if_nth ?leqVgt.\nQed."
}
{
  "statement": "Lemma conjg_inertia phi y : y \\in 'N(H) -> 'I[phi] :^ y = 'I[phi ^ y].\n",
  "proof": "Proof.\nmove=> nHy; apply/setP=> z; rewrite !['I[_]]setIdE conjIg conjGid // !in_setI.\napply/andb_id2l=> nHz; rewrite mem_conjg !inE.\nby rewrite !cfConjgMnorm ?in_group ?(can2_eq (cfConjgKV y) (cfConjgK y)) ?invgK.\nQed."
}
{
  "statement": "Lemma irr_center_scalar : {in 'Z(G), forall x, irr_repr i x = (irr_mode x)%:M}.\n",
  "proof": "Proof.\nrewrite /irr_mode => x /setIP[Gx cGx].\nsuffices [a ->]: exists a, irr_repr i x = a%:M by rewrite mxE eqxx.\napply/is_scalar_mxP; apply: (mx_abs_irr_cent_scalar (splitG (socle_irr i))).\nby apply/centgmxP=> y Gy; rewrite -!{1}repr_mxM 1?(centP cGx).\nQed."
}
{
  "statement": "Lemma class_sub_norm G A x : G \\subset 'N(A) -> (x ^: G \\subset A) = (x \\in A).\n",
  "proof": "Proof.\nmove=> nAG; apply/subsetP/idP=> [-> // | Ax xy]; first exact: class_refl.\nby case/imsetP=> y Gy ->; rewrite memJ_norm ?(subsetP nAG).\nQed."
}
{
  "statement": "Lemma astab_setact S a : 'C(to^* S a | to) = 'C(S | to) :^ a.\n",
  "proof": "Proof.\napply/setP=> b; rewrite mem_conjg.\napply/astabP/astabP=> stab x => [Sx|].\n  by rewrite conjgE invgK !actM stab ?actK //; apply/imsetP; exists x.\nby case/imsetP=> y Sy ->{x}; rewrite -actM conjgCV actM stab.\nQed."
}
{
  "statement": "Lemma perm_cat2l s1 s2 s3 : perm_eq (s1 ++ s2) (s1 ++ s3) = perm_eq s2 s3.\n",
  "proof": "Proof.\napply/permP/permP=> eq23 a; apply/eqP;\n  by move/(_ a)/eqP: eq23; rewrite !count_cat eqn_add2l.\nQed."
}
{
  "statement": "Lemma F_r41 : 'Fix_to_g[r41] =\n  [set x | (col0 x == col2 x) && (col2 x == col3 x) && (col3 x == col5 x)].\n",
  "proof": "Proof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r41_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col2/col0/col5/col3.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma mul_col_mx m1 m2 n p (Au : 'M_(m1, n)) (Ad : 'M_(m2, n)) (B : 'M_(n, p)) :\n  col_mx Au Ad *m B = col_mx (Au *m B) (Ad *m B).\n",
  "proof": "Proof.\napply/matrixP=> i k; rewrite !mxE.\nby case defi: (split i) => /[!mxE]; under eq_bigr do rewrite mxE defi.\nQed."
}
{
  "statement": "Lemma mxminpoly_map : mxminpoly A^f = fp (mxminpoly A).\n",
  "proof": "Proof.\nrewrite rmorphB; congr (_ - _).\n  by rewrite /= map_polyXn degree_mxminpoly_map.\nrewrite degree_mxminpoly_map -rmorphXn /=.\napply/polyP=> i; rewrite coef_map //= !coef_rVpoly degree_mxminpoly_map.\ncase/insub: i => [i|]; last by rewrite rmorph0.\nby rewrite -map_powers_mx -map_pinvmx // -map_mxvec -map_mxM // mxE.\nQed."
}
{
  "statement": "Lemma F_r14 : 'Fix_to_g[r14] =\n  [set x | (col0 x == col2 x) && (col2 x == col3 x) && (col3 x == col5 x)].\n",
  "proof": "Proof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r14_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col2/col0/col5/col3.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma F_r50 : 'Fix_to_g[r50]=\n  [set x | (col1 x == col2 x) && (col2 x == col3 x)\n                                && (col3 x == col4 x)].\n",
  "proof": "Proof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r50_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col2/col3/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma uniq_perm s1 s2 : uniq s1 -> uniq s2 -> s1 =i s2 -> perm_eq s1 s2.\n",
  "proof": "Proof.\nmove=> Us1 Us2 eq12; apply/allP=> x _; apply/eqP.\nby rewrite !count_uniq_mem ?eq12.\nQed."
}
{
  "statement": "Lemma widen_partn m pi n :\n  n <= m -> n`_pi = \\prod_(0 <= p < m.+1 | p \\in pi) p ^ logn p n.\n",
  "proof": "Proof.\nmove=> le_n_m; rewrite big_mkcond /=.\nrewrite [n`_pi](big_nat_widen _ _ m.+1) // big_mkcond /=.\napply: eq_bigr => p _; rewrite ltnS lognE.\nby case: and3P => [[_ n_gt0 p_dv_n]|]; rewrite ?if_same // andbC dvdn_leq.\nQed."
}
{
  "statement": "Lemma unit_is_groupAction : @is_groupAction _ R setT setT unit_action.\n",
  "proof": "Proof.\nmove=> u _ /[1!inE]; apply/andP; split; first by apply/subsetP=> x /[1!inE].\nby apply/morphicP=> x y _ _; rewrite !actpermE /= [_ u]mulrDl.\nQed."
}
{
  "statement": "Lemma allpairsPdep R (f : forall x, T x -> R) s t (z : R) :\n  reflect (exists x y, [/\\ x \\in s, y \\in t x & z = f x y])\n          (z \\in [seq f x y | x <- s, y <- t x]).\n",
  "proof": "Proof.\napply: (iffP flatten_mapP); first by case=> x sx /mapP[y ty ->]; exists x, y.\nby case=> x [y [sx ty ->]]; exists x; last apply: map_f.\nQed."
}
{
  "statement": "Lemma drop_polyMXn m n p :\n  drop_poly m (p * 'X^n) = drop_poly (m - n) p * 'X^(n - m).\n",
  "proof": "Proof.\nhave [->|p_neq0] := eqVneq p 0; first by rewrite mul0r !drop_poly0r mul0r.\napply/polyP => i; rewrite !(coefMXn, coef_drop_poly) ltn_subRL [(m + i)%N]addnC.\nhave [i_small|i_big]// := ltnP; congr nth.\nby have [mn|/ltnW mn] := leqP m n;\n   rewrite (eqP mn) (addn0, subn0) (subnBA, addnBA).\nQed."
}
{
  "statement": "Lemma subset_le_big [I : finType] [A A' P : {pred I}] (F : I -> R) :\n    A \\subset A' ->\n  le (\\big[op/x]_(i in A | P i) F i) (\\big[op/x]_(i in A' | P i) F i).\n",
  "proof": "Proof.\nmove=> AA'; apply: sub_le_big => y /andP[yA yP]; apply/andP; split => //.\nexact: subsetP yA.\nQed."
}
{
  "statement": "Lemma ltmx_sub_trans m1 m2 m3 n\n                     (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A < B)%MS -> (B <= C)%MS -> (A < C)%MS.\n",
  "proof": "Proof.\ncase/andP=> sAB ltAB sBC; rewrite ltmxE (submx_trans sAB) //.\nby apply: contra ltAB; apply: submx_trans.\nQed."
}
{
  "statement": "Lemma Clifford_astab1 (W : sH) : 'C[W | 'Cl] = rstabs rG W.\n",
  "proof": "Proof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nrewrite sub1set inE (sameP eqP socleP) !val_Clifford_act //.\nrewrite andb_idr // => sWxW; rewrite -mxrank_leqif_sup //.\nby rewrite mxrankMfree ?repr_mx_free.\nQed."
}
{
  "statement": "Lemma mulpK p q : q != 0 -> p * q %/ q = lead_coef q ^+ scalp (p * q) q *: p.\n",
  "proof": "Proof.\nmove=> qn0; apply: (rregP qn0); rewrite -scalerAl divp_eq.\nsuff -> : (p * q) %% q = 0 by rewrite addr0.\nrewrite modpE RingComRreg.rmodp_mull ?scaler0 ?if_same //.\n  by red; rewrite mulrC.\nby apply/rregP; rewrite lead_coef_eq0.\nQed."
}
{
  "statement": "Lemma extendDerivation_horner p :\n    p \\is a polyOver K -> separable_element K x ->\n  extendDerivation K p.[x] = (map_poly D p).[x] + p^`().[x] * Dx K.\n",
  "proof": "Proof.\nmove=> Kp sepKx; have:= separable_root_der; rewrite {}sepKx /= => nz_pKx'x.\nrewrite [in RHS](divp_eq p (minPoly K x)) lfunE /= Fadjoin_poly_mod ?raddfD //=.\nrewrite (Derivation_mul_poly derD) ?divp_polyOver ?minPolyOver //.\nrewrite derivM !{1}hornerD !{1}hornerM minPolyxx !{1}mulr0 !{1}add0r.\nrewrite mulrDl addrA [_ + (_ * _ * _)]addrC {2}/Dx -mulrA -/Dx.\nby rewrite [_ / _]mulrC (mulVKf nz_pKx'x) mulrN addKr.\nQed."
}
{
  "statement": "Lemma lker0P f : reflect (injective f) (lker f == 0%VS).\n",
  "proof": "Proof.\nrewrite -subv0; apply: (iffP subvP) => [injf u v eq_fuv | injf u].\n  apply/eqP; rewrite -subr_eq0 -memv0 injf //.\n  by rewrite memv_ker linearB /= eq_fuv subrr.\nby rewrite memv_ker memv0 -(inj_eq injf) linear0.\nQed."
}
{
  "statement": "Lemma formC u v : '[u, v] = (-1) ^+ eps * theta '[v, u].\n",
  "proof": "Proof.\nrewrite /form [M in LHS](sesquiP _) // -mulmxA !mxE rmorph_sum mulr_sumr.\napply: eq_bigr => /= i _; rewrite !(mxE, mulr_sumr, mulr_suml, rmorph_sum).\napply: eq_bigr => /= j _; rewrite !mxE !rmorphM  mulrCA -!mulrA.\nby congr (_ * _); rewrite mulrA mulrC /= thetaK.\nQed."
}
{
  "statement": "Lemma itvP x i : x \\in i -> itv_rewrite i x.\n",
  "proof": "Proof.\ncase: i => [[[]a|[]][[]b|[]]] /andP [] ha hb; rewrite /= ?bound_in_itv;\n  do ![split | apply/negbTE; rewrite (le_gtF, lt_geF)];\n  by [|apply: ltW | move: (lteif_trans ha hb) => //=; exact: ltW].\nQed."
}
{
  "statement": "Lemma subset_eqP A B : reflect (A =i B) ((A \\subset B) && (B \\subset A)).\n",
  "proof": "Proof.\napply: (iffP andP) => [[sAB sBA] x| eqAB]; last by rewrite !eq_subxx.\nby apply/idP/idP; apply: subsetP.\nQed."
}
{
  "statement": "Lemma npolyX_free : free npolyX.\n",
  "proof": "Proof.\napply/freeP=> u /= sum_uX_eq0 i; have /npolyP /(_ i) := sum_uX_eq0.\nrewrite (@big_morph _ _ _ 0%R +%R) // coef_sum coef0.\nrewrite (bigD1 i) ?big1 /= ?addr0 ?coefZ ?(nth_map 0%N) ?size_iota //.\n  by rewrite nth_npolyX npolyXE coefXn eqxx mulr1.\nmove=> j; rewrite -val_eqE /= => neq_ji.\nby rewrite nth_npolyX npolyXE coefZ coefXn eq_sym (negPf neq_ji) mulr0.\nQed."
}
{
  "statement": "Lemma big_allpairs_dep_idem I1 (I2 : I1 -> Type) J (h : forall i1, I2 i1 -> J)\n    (r1 : seq I1) (r2 : forall i1, seq (I2 i1)) (F : J -> R) :\n  \\big[op/x]_(i <- [seq h i1 i2 | i1 <- r1, i2 <- r2 i1]) F i =\n    \\big[op/x]_(i1 <- r1) \\big[op/x]_(i2 <- r2 i1) F (h i1 i2).\n",
  "proof": "Proof.\nelim: r1 => [|i1 r1 IHr1]; first by rewrite !big_nil.\nby rewrite big_cat_idem IHr1 big_cons big_map.\nQed."
}
{
  "statement": "Lemma card_le1_eqP A :\n  reflect {in A &, forall x, all_equal_to x} (#|A| <= 1).\n",
  "proof": "Proof.\napply: (iffP card_le1P) => [Ale1 x y xA yA /=|all_eq x xA y].\n  by apply/eqP; rewrite -[_ == _]/(y \\in pred1 x) -Ale1.\nby rewrite inE; case: (altP (y =P x)) => [->//|]; exact/contra_neqF/all_eq.\nQed."
}
{
  "statement": "Lemma isog_cyclic_card G M : cyclic G -> isog G M = cyclic M && (#|M| == #|G|).\n",
  "proof": "Proof.\nmove=> cycG; apply/idP/idP=> [isoGM | ].\n  by rewrite (card_isog isoGM) -(isog_cyclic isoGM) cycG /=.\ncase/cyclicP: cycG => x ->{G} /andP[/cyclicP[y ->] /eqP oy].\nby apply: isog_trans (isog_symr _) (Zp_isog y); rewrite /order oy Zp_isog.\nQed."
}
{
  "statement": "Lemma restrmP (f : {morphism D >-> rT}) : A \\subset 'dom f ->\n  {g : {morphism A >-> rT} | [/\\ g = f :> (aT -> rT), 'ker g = 'ker_A f,\n                                 forall R, g @*^-1 R = A :&: f @*^-1 R\n                               & forall B, B \\subset A -> g @* B = f @* B]}.\n",
  "proof": "Proof.\nmove=> sAD; exists (restrm_morphism sAD f).\nsplit=> // [|R|B sBA]; first 1 [exact: ker_restrm | exact: morphpre_restrm].\nby rewrite morphim_restrm (setIidPr sBA).\nQed."
}
{
  "statement": "Lemma quotient_TI_subcent K G H :\n    G \\subset 'N(K) -> G \\subset 'N(H) -> K :&: H = 1 ->\n  'C_K(G) / H = 'C_(K / H)(G / H).\n",
  "proof": "Proof.\nmove=> nGK nGH tiKH.\nhave tiHR: H :&: [~: K, G] = 1.\n  by apply/trivgP; rewrite /= setIC -tiKH setSI ?commg_subl.\napply: strongest_coprime_quotient_cent; rewrite ?tiHR ?sub1G ?solvable1 //.\nby rewrite cards1 coprime1n.\nQed."
}
{
  "statement": "Lemma sizeTP (pf : polyF) : sizeT pf ->_e size (eval_poly e pf).\n",
  "proof": "Proof.\nelim: pf=> [|c qf qfP /=]; first by rewrite /= size_poly0.\nmove=> e k; rewrite size_MXaddC qfP -(size_poly_eq0 (eval_poly _ _)).\nby case: (size (eval_poly e qf))=> //=; case: eqP; rewrite // orbF.\nQed."
}
{
  "statement": "Lemma cfResInd j:\n    H <| G ->\n  'Res[H] ('Ind[G] 'chi_j) = #|H|%:R^-1 *: (\\sum_(y in G) 'chi_j ^ y)%CF.\n",
  "proof": "Proof.\ncase/andP=> [sHG /subsetP nHG].\nrewrite (reindex_inj invg_inj); apply/cfun_inP=> x Hx.\nrewrite cfResE // cfIndE // ?cfunE ?sum_cfunE; congr (_ * _).\nby apply: eq_big => [y | y Gy]; rewrite ?cfConjgE ?groupV ?invgK ?nHG.\nQed."
}
{
  "statement": "Lemma divgrM : H \\subset 'C(K) -> {in G &, {morph divgr K H : x y / x * y}}.\n",
  "proof": "Proof.\nmove=> cKH; have /complP[_ defG] := complH_K.\nhave nsKG: K <| G by rewrite -defG -cent_joinEr // normalYl cents_norm.\nmove=> x y Gx Gy; rewrite {1}/divgr remgrM // invMg -!mulgA (mulgA y).\nby congr (_ * _); rewrite -(centsP cKH) ?groupV ?(mem_remgr, mem_divgr, defG).\nQed."
}
{
  "statement": "Lemma restr_perm_commute s : commute (restr_perm s) s.\n",
  "proof": "Proof.\nhave [sC|/triv_restr_perm->] := boolP (s \\in 'N(S | 'P)); last first.\n  exact: (commute_sym (commute1 _)).\napply/permP => x; have /= xsS := astabsP sC x; rewrite !permM.\nhave [xS|xNS] := boolP (x \\in S); first by rewrite ?(restr_permE) ?xsS.\nby rewrite !(out_perm (restr_perm_on _)) ?xsS.\nQed."
}
{
  "statement": "Lemma size_poly_eq1 p : (size p == 1) = (p %= 1).\n",
  "proof": "Proof.\napply/size_poly1P/idP=> [[c cn0 ep] |].\n  by apply/eqpP; exists (1, c); rewrite ?oner_eq0 // alg_polyC scale1r.\nby move/eqp_size; rewrite size_poly1; move/eqP/size_poly1P.\nQed."
}
{
  "statement": "Lemma F_r05 : 'Fix_to_g[r05]=\n  [set x | (col1 x == col2 x) && (col2 x == col3 x)\n                                && (col3 x == col4 x)].\n",
  "proof": "Proof.\napply sym_equal.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r05_inv !ffunE !permE /=.\nrewrite !eqxx /= !andbT /col1/col2/col3/col4/col5/col0.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma big_nat_rev m n P F :\n  \\big[op/x]_(m <= i < n | P i) F i\n     = \\big[op/x]_(m <= i < n | P (m + n - i.+1)) F (m + n - i.+1).\n",
  "proof": "Proof.\ncase: (ltnP m n) => ltmn; last by rewrite !big_geq.\nrewrite -{3 4}(subnK (ltnW ltmn)) addnA.\ndo 2!rewrite (big_addn _ _ 0) big_mkord; rewrite (reindex_inj rev_ord_inj)/=.\nby apply: eq_big => [i | i _]; rewrite /= -addSn subnDr addnC addnBA.\nQed."
}
{
  "statement": "Lemma bound_joinA : associative bound_join.\n",
  "proof": "Proof.\ncase=> [? x|[]][? y|[]][? z|[]] //=; rewrite !leUx joinA; congr BSide.\nby case: (lcomparableP x y) => [|||->]; case: (lcomparableP y z) => [|||->];\n  case: (lcomparableP x z) => [|||//<-]; case: (lcomparableP x y);\n  rewrite //= ?orbT ?andbT ?lexx ?andbA //; case: (lcomparableP y z).\nQed."
}
{
  "statement": "Lemma cfQuo_cfun1 : (1 / B)%CF = 1.\n",
  "proof": "Proof.\napply/cfun_inP=> Hx G_Hx; rewrite cfunElock !cfun1E G_Hx cfker_cfun1 -gen_subG.\nhave [x nHx Gx ->] := morphimP G_Hx.\ncase: subsetP=> [sHG | _]; last by rewrite group1.\nby rewrite val_coset_prim //; case: repr_rcosetP => y /sHG/groupM->.\nQed."
}
{
  "statement": "Lemma perm_small_eq s1 s2 : size s2 <= 1 -> perm_eq s1 s2 -> s1 = s2.\n",
  "proof": "Proof.\nmove=> s2_le1 eqs12; move/perm_size: eqs12 s2_le1 (perm_mem eqs12).\nby case: s2 s1 => [|x []] // [|y []] // _ _ /(_ x) /[!(inE, eqxx)] /eqP->.\nQed."
}
{
  "statement": "Lemma cfRes_Ind_invariant psi :\n  H <| G -> G \\subset 'I[psi] -> 'Res ('Ind[G, H] psi) = #|G : H|%:R *: psi.\n",
  "proof": "Proof.\ncase/andP=> sHG _ /subsetP IGpsi; apply/cfun_inP=> x Hx.\nrewrite cfResE ?cfIndE ?natf_indexg // cfunE -mulrA mulrCA; congr (_ * _).\nby rewrite mulr_natl -sumr_const; apply: eq_bigr => y /IGpsi/inertia_valJ->.\nQed."
}
{
  "statement": "Lemma submxMfree m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  row_free C -> (A *m C <= B *m C)%MS = (A <= B)%MS.\n",
  "proof": "Proof.\ncase/row_freeP=> C' C_C'_1; apply/idP/idP=> sAB; last exact: submxMr.\nby rewrite -[A]mulmx1 -[B]mulmx1 -C_C'_1 !mulmxA submxMr.\nQed."
}
{
  "statement": "Lemma OhmE p G : p.-group G -> 'Ohm_n(G) = <<'Ldiv_(p ^ n)(G)>>.\n",
  "proof": "Proof.\nmove=> pG; congr <<_>>; apply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nhave [-> | ntx] := eqVneq x 1; first by rewrite !expg1n.\nby rewrite (pdiv_p_elt (mem_p_elt pG Gx)).\nQed."
}
{
  "statement": "Lemma classes_gt1 : (#|classes G| > 1) = (G :!=: 1).\n",
  "proof": "Proof.\nrewrite (cardsD1 1) classes1 ltnS lt0n cards_eq0.\napply/set0Pn/trivgPn=> [[xG /setD1P[nt_xG]] | [x Gx ntx]].\n  by case/imsetP=> x Gx def_xG; rewrite def_xG classG_eq1 in nt_xG; exists x.\nby exists (x ^: G); rewrite !inE classG_eq1 ntx; apply: imset_f.\nQed."
}
{
  "statement": "Lemma root_cyclotomic x : root (cyclotomic z n) x = n.-primitive_root x.\n",
  "proof": "Proof.\ntransitivity (x \\in [seq z ^+ i | i : 'I_n in [pred i : 'I_n | coprime i n]]).\n  by rewrite -root_prod_XsubC big_image.\napply/imageP/idP=> [[k co_k_n ->] | prim_x].\n  by rewrite prim_root_exp_coprime.\nhave [k Dx] := prim_rootP prim_z (prim_expr_order prim_x).\nexists (Ordinal (ltn_pmod k n_gt0)) => /=; last by rewrite prim_expr_mod.\nby rewrite inE coprime_modl -(prim_root_exp_coprime k prim_z) -Dx.\nQed."
}
{
  "statement": "Lemma subset_cat2 s1 s2 s3 : s1 \\subset s2 -> s3 ++ s1 \\subset s3 ++ s2.\n",
  "proof": "Proof.\nmove=> /subsetP s12; apply/subsetP => x.\nby rewrite !mem_cat => /orP[->|/s12->]; rewrite ?orbT.\nQed."
}
{
  "statement": "Lemma setXnS (I : finType) (T : I -> finType) (A B : forall i, {set T i}) :\n  (forall i, A i \\subset B i) -> setXn A \\subset setXn B.\n",
  "proof": "Proof.\nmove=> sAB; apply/subsetP => x /setXnP xA.\nby apply/setXnP => i; apply/subsetP: (xA i).\nQed."
}
{
  "statement": "Lemma ltn_divLR m n d : d > 0 -> (m %/ d < n) = (m < n * d).\n",
  "proof": "Proof.\nmove=> d_gt0; apply/idP/idP.\n  by rewrite -(leq_pmul2r d_gt0); apply: leq_trans (ltn_ceil _ _).\nrewrite !ltnNge -(@leq_pmul2r d n) //; apply: contra => le_nd_floor.\nexact: leq_trans le_nd_floor (leq_divM _ _).\nQed."
}
{
  "statement": "Lemma minCpoly_aut nu x : minCpoly (nu x) = minCpoly x.\n",
  "proof": "Proof.\nwlog suffices dvd_nu: nu x / (minCpoly x %| minCpoly (nu x))%R.\n  apply/eqP; rewrite -eqp_monic ?minCpoly_monic //; apply/andP; split=> //.\n  by rewrite -{2}(algC_autK nu x) dvd_nu.\nhave [[q [Dq _] min_q] [q1 [Dq1 _] _]] := (minCpolyP x, minCpolyP (nu x)).\nrewrite Dq Dq1 dvdp_map -min_q -(fmorph_root nu) -map_poly_comp.\nby rewrite (eq_map_poly (fmorph_rat nu)) -Dq1 root_minCpoly.\nQed."
}
{
  "statement": "Lemma mem_unity_roots rs :\n    n > 0 -> all n.-unity_root rs -> uniq rs -> size rs = n ->\n  n.-unity_root =i rs.\n",
  "proof": "Proof.\nmove=> n_gt0 rs_n_1 Urs sz_rs_n x; rewrite -topredE /=.\napply/idP/idP=> xn1; last exact: (allP rs_n_1).\napply: contraFT (ltnn n) => not_rs_x.\nby rewrite -{1}sz_rs_n (@max_unity_roots (x :: rs)) //= ?xn1 ?not_rs_x.\nQed."
}
{
  "statement": "Lemma trigsqmx_ind (P : forall n, 'M[V]_n -> Type) : (P 0 0) ->\n  (forall n x c A, is_trig_mx A -> P n A -> P (1 + n)%N (block_mx x 0 c A)) ->\n  forall n A, is_trig_mx A -> P n A.\n",
  "proof": "Proof.\nmove=> P0 PS n A; elim/sqmx_ind: A => {n} [|n x r c] A PA.\n  by rewrite thinmx0; apply: P0.\nby rewrite is_trig_block_mx => // /and3P[/eqP-> _ Atrig]; apply: PS (PA _).\nQed."
}
{
  "statement": "Lemma pi_add : {morph \\pi : x y / addf x y >-> add x y}.\n",
  "proof": "Proof.\nmove=> x y; unlock add; apply/eqmodP; rewrite /= equivfE /addf /=.\nrewrite !numden_Ratio ?mulf_neq0 ?domP // mulrDr mulrDl; apply/eqP.\nsymmetry; rewrite (AC (2*2) (3*1*2*4)) (AC (2*2) (3*2*1*4))/=.\nby rewrite !equivf_l (ACl ((2*3)*(1*4))) (ACl ((2*3)*(4*1)))/=.\nQed."
}
{
  "statement": "Lemma lcnP G : reflect (exists n, 'L_n.+1(G) = 1) (nilpotent G).\n",
  "proof": "Proof.\napply: (iffP idP) => [nilG | [n Ln1]].\n  by exists (nil_class G); apply/lcn_nil_classP.\napply/forall_inP=> H /subsetIP[sHG sHR]; rewrite -subG1 -{}Ln1.\nby elim: n => // n IHn; rewrite (subset_trans sHR) ?commSg.\nQed."
}
{
  "statement": "Lemma eqperm : forall p1 p2 : {perm cube},\n  (p1 == p2) = all (fun s => p1 s == p2 s) ecubes.\n",
  "proof": "Proof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/permP=> x.\nby apply/eqP; rewrite Ep12 // ecubes_def mem_enum.\nQed."
}
{
  "statement": "Lemma deg2_poly_gt0r x : r2 < x -> 0 < p.[x].\n",
  "proof": "Proof.\nmove=> xgtr2; have [? | dge0] := ltP delta 0; first exact: deg2_poly_gt0.\nhave {}xgtr2 : sqrt delta < x * (2 * a) + b.\n  by rewrite -ltrBlDr addrC -ltr_pdivrMr.\nrewrite [p]deg2_poly_canonical// -/a -/b -/c -/delta !hornerE/=.\nrewrite mulr_gt0// subr_gt0 ltr_pdivrMr// xb4.\nrewrite -ltr_sqrt ?sqrtr_sqr ?(lt_le_trans xgtr2) ?ler_norm//.\nby rewrite exprn_gt0 ?(le_lt_trans _ xgtr2) ?sqrtr_ge0.\nQed."
}
{
  "statement": "Lemma imset2P D1 D2 y : reflect (imset2_spec D1 D2 y) (y \\in imset2 f2 D1 D2).\n",
  "proof": "Proof.\nrewrite [@imset2]unlock inE.\napply: (iffP imageP) => [[[x1 x2] Dx12] | [x1 x2 Dx1 Dx2]] -> {y}.\n  by case/andP: Dx12; exists x1 x2.\nby exists (x1, x2); rewrite //= !inE Dx1.\nQed."
}
{
  "statement": "Lemma p_rank_quotient G H : G \\subset 'N(H) -> 'r_p(G) - 'r_p(H) <= 'r_p(G / H).\n",
  "proof": "Proof.\nmove=> nHG; rewrite leq_subLR.\nhave [E EpE] := p_rank_witness p G; have{EpE} [sEG abelE <-] := pnElemP EpE.\nrewrite -(LagrangeI E H) lognM ?cardG_gt0 //.\nrewrite -card_quotient ?(subset_trans sEG) // leq_add ?logn_le_p_rank // !inE.\n  by rewrite subsetIr (abelemS (subsetIl E H)).\nby rewrite quotientS ?quotient_abelem.\nQed."
}
{
  "statement": "Lemma cfConjgRes_norm phi y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ('Res[K, H] phi ^ y)%CF = 'Res (phi ^ y)%CF.\n",
  "proof": "Proof.\nmove=> nKy nHy; have [sKH | not_sKH] := boolP (K \\subset H); last first.\n  by rewrite !cfResEout // rmorph_alg cfConjg1.\nby apply/cfun_inP=> x Kx; rewrite !(cfConjgE, cfResE) ?memJ_norm ?groupV.\nQed."
}
{
  "statement": "Lemma Frobenius_context :\n  [/\\ K ><| H = G, K :!=: 1, H :!=: 1, K \\proper G & H \\proper G].\n",
  "proof": "Proof.\nhave [/eqP defG neqHG ntH _] := and4P frobG; rewrite setD_eq0 subG1 in ntH.\nhave ntK: K :!=: 1 by apply: contraNneq neqHG => K1; rewrite -defG K1 sdprod1g.\nrewrite properEcard properEneq neqHG; have /mulG_sub[-> ->] := sdprodW defG.\nby rewrite -(sdprod_card defG) ltn_Pmulr ?cardG_gt1.\nQed."
}
{
  "statement": "Lemma subv_sumP {P Us V} :\n  reflect (forall i, P i -> Us i <= V)%VS  (\\sum_(i | P i) Us i <= V)%VS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sUV i Pi | sUV].\n  by apply: subv_trans sUV; apply: sumv_sup Pi _.\nby elim/big_rec: _ => [|i W Pi sWV]; rewrite ?sub0v // subv_add sUV.\nQed."
}
{
  "statement": "Lemma cosetP xbar : {x | x \\in 'N(A) & xbar = coset x}.\n",
  "proof": "Proof.\npose x := repr 'N_xbar(A).\nhave [xbar_x Nx]: x \\in xbar /\\ x \\in 'N(A).\n  apply/setIP; rewrite {}/x; case: xbar => /= _ /rcosetsP[y Ny ->].\n  by apply: (mem_repr y); rewrite inE rcoset_refl.\nby exists x; last rewrite (coset_mem xbar_x).\nQed."
}
{
  "statement": "Lemma astabS S1 S2 : S1 \\subset S2 -> 'C(S2 | to) \\subset 'C(S1 | to).\n",
  "proof": "Proof.\nby move=> sS12; apply/subsetP=> x /[!inE] /andP[->]; apply: subset_trans.\nQed."
}
{
  "statement": "Lemma acts_orbit G x : G \\subset D -> [acts G, on orbit to G x | to].\n",
  "proof": "Proof.\nmove/subsetP=> sGD; apply/subsetP=> a Ga; rewrite !inE sGD //.\napply/subsetP=> _ /imsetP[b Gb ->].\nby rewrite inE -actMin ?sGD // imset_f ?groupM.\nQed."
}
{
  "statement": "Lemma extendible_irr_invariant : G \\subset 'I[theta].\n",
  "proof": "Proof.\napply/subsetP=> y Gy; have nNy := subsetP nNG y Gy.\nrewrite inE nNy; apply/eqP/cfun_inP=> x Nx; rewrite cfConjgE // -cNt.\nby rewrite !cfResE ?memJ_norm ?cfunJ ?groupV.\nQed."
}
{
  "statement": "Lemma deg2_poly_gt0l x : x < r1 -> 0 < p.[x].\n",
  "proof": "Proof.\nmove=> xltr1; have [? | dge0] := ltP delta 0; first exact: deg2_poly_gt0.\nhave {}xltr1 : sqrt delta < - (x * (2 * a) + b).\n  by rewrite ltrNr -ltrBrDr addrC -ltr_pdivlMr.\nrewrite [p]deg2_poly_canonical// -/a -/b -/c -/delta !hornerE/=.\nrewrite mulr_gt0// subr_gt0 ltr_pdivrMr// xb4 -sqrrN.\nrewrite -ltr_sqrt ?sqrtr_sqr ?(lt_le_trans xltr1) ?ler_norm//.\nby rewrite exprn_gt0 ?(le_lt_trans _ xltr1) ?sqrtr_ge0.\nQed."
}
{
  "statement": "Lemma card_uniqP s : reflect (#|s| = size s) (uniq s).\n",
  "proof": "Proof.\nelim: s => [|x s IHs]; first by left; apply: card0.\nrewrite cardU1 /= /addn; case: {+}(x \\in s) => /=.\n  by right=> card_Ssz; have:= card_size s; rewrite card_Ssz ltnn.\nby apply: (iffP IHs) => [<-| [<-]].\nQed."
}
{
  "statement": "Lemma small_nil_class G : nil_class G <= 5 -> nilpotent G.\n",
  "proof": "Proof.\nmove=> leK5; case: (ltnP 5 #|G|) => [lt5G | leG5 {leK5}].\n  by rewrite nilpotent_class (leq_ltn_trans leK5).\napply: pgroup_nil (pdiv #|G|) _ _; apply/andP; split=> //.\nby case: #|G| leG5 => //; do 5!case=> //.\nQed."
}
{
  "statement": "Lemma reindex_dprod R idx (op : Monoid.com_law idx) (F : gT -> R) :\n   \\big[op/idx]_(g in G) F g =\n      \\big[op/idx]_(k in K) \\big[op/idx]_(h in H) F (k * h)%g.\n",
  "proof": "Proof.\nhave /mulgmP/misomP[fM /isomP[injf im_f]] := KxH.\nrewrite pair_big_dep -im_f morphimEdom big_imset; last exact/injmP.\nby apply: eq_big => [][x y]; rewrite ?inE.\nQed."
}
{
  "statement": "Lemma pi_mul: {morph \\pi : x y / x * y >-> mul x y}.\n",
  "proof": "Proof.\nmove=> x y; unlock mul; apply/eqP; rewrite piE equivE.\nrewrite -[_ * _](addrNK (x * repr (\\pi_{quot idealI} y))) -mulrBr.\nrewrite -addrA -mulrBl rpredD //.\n  by rewrite idealMr // idealrDE opprK reprK.\nby rewrite mulrC idealMr // idealrDE opprK reprK.\nQed."
}
{
  "statement": "Lemma sub_ltmx_trans m1 m2 m3 n\n                     (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= B)%MS -> (B < C)%MS -> (A < C)%MS.\n",
  "proof": "Proof.\nmove=> sAB /andP[sBC ltBC]; rewrite ltmxE (submx_trans sAB) //.\nby apply: contra ltBC => sCA; apply: submx_trans sAB.\nQed."
}
{
  "statement": "Lemma rfd_morph : {in 'C_('Sym_T)[x | 'P] &, {morph rfd : y z / y * z}}.\n",
  "proof": "Proof.\nmove=> p q; rewrite !setIA !setIid; move/astab1P=> p_x; move/astab1P=> q_x.\napply/permP=> u; apply: val_inj.\nby rewrite permE /= !permM !permE /= [p x]p_x [q x]q_x eqxx permM /=.\nQed."
}
{
  "statement": "Lemma bigmax_ltP m P F :\n  reflect (x < m /\\ forall i, P i -> F i < m) (\\big[max/x]_(i | P i) F i < m).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[? ?]]; last exact: bigmax_lt.\nrewrite bigmax_idl gt_max => /andP[-> ltFm]; split=> // i Pi.\nby apply: le_lt_trans ltFm; exact: le_bigmax_cond.\nQed."
}
{
  "statement": "Lemma odd_permM : {morph odd_perm : s1 s2 / s1 * s2 >-> s1 (+) s2}.\n",
  "proof": "Proof.\nmove=> s1 s2; case: (prod_tpermP s1) => ts1 ->{s1} dts1.\ncase: (prod_tpermP s2) => ts2 ->{s2} dts2.\nby rewrite -big_cat !odd_perm_prod ?all_cat ?dts1 // size_cat oddD.\nQed."
}
{
  "statement": "Lemma amove_orbit : amove to G x @: orbit to G x = rcosets 'C_G[x | to] G.\n",
  "proof": "Proof.\napply/setP => Ha; apply/imsetP/rcosetsP=> [[y] | [a Ga ->]].\n  by case/imsetP=> b Gb -> ->{Ha y}; exists b => //; rewrite amove_act.\nby rewrite -amove_act //; exists (to x a); first apply: mem_orbit.\nQed."
}
{
  "statement": "Lemma group_set_iso2 : group_set isometries2.\n",
  "proof": "Proof.\napply/group_setP; split => [|x y]; rewrite !inE ?eqxx //.\ndo 2![case/orP; move/eqP->]; rewrite ?(mul1g, mulg1) ?eqxx ?orbT//.\nby rewrite -/sh -{1}sh_inv mulVg eqxx.\nQed."
}
{
  "statement": "Lemma cfker_scale a phi : cfker phi \\subset cfker (a *: phi).\n",
  "proof": "Proof.\napply/subsetP=> x Kphi_x; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE cfkerMl.\nQed."
}
{
  "statement": "Lemma kHom_to_gal K M E f :\n    (K <= M <= E)%VS -> normalField K E -> kHom K M f ->\n  {x | x \\in 'Gal(E / K) & {in M, f =1 x}}.\n",
  "proof": "Proof.\ncase/andP=> /subvP sKM /subvP sME nKE KhomMf.\nhave [[g Df] [_ idKf]] := (kHom_to_AEnd KhomMf, kHomP KhomMf).\nsuffices /kAut_to_gal[x galEx Dg]: kAut K E g.\n  by exists x => //= a Ma; rewrite Df // Dg ?sME.\nhave homKg: kHom K {:L} g by apply/kAHomP=> a Ka; rewrite -Df ?sKM ?idKf.\nby rewrite /kAut (kHomSr (subvf _)) // (forall_inP nKE) // inE kAutfE.\nQed."
}
{
  "statement": "Lemma burnside_app_iso :\n  (square_coloring_number8 * 8 = n ^ 4 + 2 * n ^ 3 + 3 * n ^ 2 + 2 * n)%N.\n",
  "proof": "Proof.\npose iso_list := [:: id1; r1; r2; r3; sh; sv; sd1; sd2].\nrewrite (burnside_formula iso_list) => [||p]; last first.\n- by rewrite /= !inE.\n- apply: map_uniq (fun p : {perm square} => (p c0, p c1)) _ _.\n  by rewrite /= !permE.\nrewrite !big_cons big_nil {1}card_Fid F_r1 F_r2 F_r3 F_Sh F_Sv F_Sd1 F_Sd2.\nrewrite card_n !card_n3 // !card_n2 //= !addnA !addn0.\nby rewrite [LHS]addn.[ACl 1 * 7 * 8 * 3 * 5 * 6 * 2 * 4].\nQed."
}
{
  "statement": "Lemma setI_subnormal G H K : K \\subset G -> H <|<| G -> H :&: K <|<| K.\n",
  "proof": "Proof.\nmove=> sKG /subnormalP[s Hs defG]; apply/subnormalP.\nexists (map (setIgr K) s); first exact: path_setIgr.\nrewrite (last_map (setIgr K)) defG.\nby apply: val_inj; rewrite /= (setIidPr sKG).\nQed."
}
{
  "statement": "Lemma p_rank_Sylow p G H : p.-Sylow(G) H -> 'r_p(H) = 'r_p(G).\n",
  "proof": "Proof.\nmove=> sylH; apply/eqP; rewrite eqn_leq (p_rankS _ (pHall_sub sylH)) /=.\napply/bigmax_leqP=> E /[1!inE] /andP[sEG abelE].\nhave [P sylP sEP] := Sylow_superset sEG (abelem_pgroup abelE).\nhave [x _ ->] := Sylow_trans sylP sylH.\nby rewrite p_rankJ -(p_rank_abelem abelE) (p_rankS _ sEP).\nQed."
}
{
  "statement": "Lemma rootC_ge0 n x : (n > 0)%N -> (0 <= n.-root x) = (0 <= x).\n",
  "proof": "Proof.\nset y := n.-root x => n_gt0.\napply/idP/idP=> [/(exprn_ge0 n) | x_ge0]; first by rewrite rootCK.\nrewrite -(ge_leif (leif_Re_Creal y)).\nhave Ray: `|y| \\is real by apply: normr_real.\nrewrite -(Creal_ReP _ Ray) rootC_Re_max ?(Creal_ImP _ Ray) //.\nby rewrite -normrX rootCK // ger0_norm.\nQed."
}
{
  "statement": "Lemma gring_irr_modeM A B :\n    (A \\in 'Z(R_G))%MS -> (B \\in 'Z(R_G))%MS ->\n  'omega_i[A *m B] = 'omega_i[A] * 'omega_i[B].\n",
  "proof": "Proof.\nmove=> Z_A Z_B; have [[R_A cRA] [R_B cRB]] := (center_mxP Z_A, center_mxP Z_B).\napply: mxZn_inj; rewrite scalar_mxM -!irr_gring_center ?gring_opM //.\napply/center_mxP; split=> [|C R_C]; first exact: envelop_mxM.\nby rewrite mulmxA cRA // -!mulmxA cRB.\nQed."
}
{
  "statement": "Lemma trunc_log2S n : 1 < n -> trunc_log 2 n = (trunc_log 2 n./2).+1.\n",
  "proof": "Proof.\nmove=> n_gt1.\nrewrite -trunc_log2_double ?half_gt0//.\nrewrite -[n in LHS]odd_double_half.\ncase: odd => //; rewrite add1n.\napply: trunc_log_eq => //.\nrewrite leqW ?trunc_logP //= ?double_gt0 ?half_gt0//.\nrewrite trunc_log2_double ?half_gt0// expnS.\nby rewrite -doubleS mul2n leq_double trunc_log_ltn.\nQed."
}
{
  "statement": "Lemma subn_exp m n k :\n  m ^ k - n ^ k = (m - n) * (\\sum_(i < k) m ^ (k.-1 -i) * n ^ i).\n",
  "proof": "Proof.\ncase: k => [|k]; first by rewrite big_ord0 muln0.\nrewrite mulnBl !big_distrr big_ord_recl big_ord_recr /= subn0 muln1.\nrewrite subnn mul1n -!expnS subnDA; congr (_ - _); apply: canRL (addnK _) _.\ncongr (_ + _); apply: eq_bigr => i _.\nby rewrite (mulnCA n) -expnS mulnA -expnS subnSK /=.\nQed."
}
{
  "statement": "Lemma der1_joing_cycles (x y : gT) : \n  let XY := <[x]> <*> <[y]> in let xy := [~ x, y] in\n  xy \\in 'C(XY) -> XY^`(1) = <[xy]>.\n",
  "proof": "Proof.\nrewrite joing_idl joing_idr /= -sub_cent1 => /norms_gen nRxy.\napply/eqP; rewrite eqEsubset cycle_subG mem_commg ?mem_gen ?set21 ?set22 //.\nrewrite der1_min // quotient_gen -1?gen_subG // quotientU abelian_gen.\nrewrite /abelian subUset centU !subsetI andbC centsC -andbA -!abelianE.\nrewrite !quotient_abelian ?(abelianS (subset_gen _) (cycle_abelian _)) //=.\nby rewrite andbb quotient_cents2r ?genS // /commg_set imset2_set1l imset_set1.\nQed."
}
{
  "statement": "Lemma acts_sub_orbit G S x :\n  [acts G, on S | to] -> (orbit to G x \\subset S) = (x \\in S).\n",
  "proof": "Proof.\nmove/acts_act=> GactS.\napply/subsetP/idP=> [| Sx y]; first by apply; apply: orbit_refl.\nby case/orbitP=> a Ga <-{y}; rewrite GactS.\nQed."
}
{
  "statement": "Lemma mulSgGid A x : x \\in A -> A \\subset G -> A * G = G.\n",
  "proof": "Proof.\nmove=> Ax sAG; apply/eqP; rewrite eqEsubset -{2}mulGid mulSg //=.\napply/subsetP=> y Gy; rewrite -(mulKVg x y) mem_mulg // groupMr // groupV.\nexact: (subsetP sAG).\nQed."
}
{
  "statement": "Lemma normr_num_div n d : `|numq (n%:~R / d%:~R)| = numq (`|n|%:~R / `|d|%:~R).\n",
  "proof": "Proof.\nrewrite (normrEsg n) (normrEsg d) !rmorphM /= invfM mulrACA !sgr_def.\nhave [->|n_neq0] := eqVneq; first by rewrite mul0r mulr0.\nhave [->|d_neq0] := eqVneq; first by rewrite invr0 !mulr0.\nrewrite !intr_sign invr_sign -signr_addb numq_sign_mul -numq_div_lt0 //.\nby apply: (canRL (signrMK _)); rewrite mulz_sign_abs.\nQed."
}
{
  "statement": "Lemma mxrank_in_factmod m (W : 'M_(m, n)) :\n  (\\rank (in_factmod W) + \\rank U)%N = \\rank (U + W).\n",
  "proof": "Proof.\nrewrite -in_factmod_addsK in_factmodE; set fU := in_factmod 1%:M.\nsuffices <-: ((U + W) :&: kermx fU :=: U)%MS by rewrite mxrank_mul_ker.\napply: eqmx_trans (capmx_idPr (addsmxSl U W)).\napply: cap_eqmx => //; apply/eqmxP/rV_eqP => u.\nby rewrite (sameP sub_kermxP eqP) -in_factmodE in_factmod_eq0.\nQed."
}
{
  "statement": "Lemma morphim_factm (A : {set aT}) : ff @* (q @* A) = f @* A.\n",
  "proof": "Proof.\nrewrite -morphim_comp /= {1}/morphim /= morphimGK //; last first.\n  by rewrite (subset_trans sKqKf) ?subsetIl.\napply/setP=> y; apply/morphimP/morphimP;\n  by case=> x Gx Ax ->{y}; exists x; rewrite //= factmE.\nQed."
}
{
  "statement": "Lemma imset_cover (T' : finType) P  (f : T -> T') :\n  [set f x | x in cover P] = \\bigcup_(i in P) [set f x | x in i].\n",
  "proof": "Proof.\napply/setP=> y; apply/imsetP/bigcupP => [|[A AP /imsetP[x xA ->]]].\n  by move=> [x /bigcupP[A AP xA] ->]; exists A => //; rewrite imset_f.\nby exists x => //; apply/bigcupP; exists A.\nQed."
}
{
  "statement": "Lemma map_of_seq (T1 : eqType) T2 (s : seq T1) (fs : seq T2) (y0 : T2) :\n  {f | uniq s -> size fs = size s -> map f s = fs}.\n",
  "proof": "Proof.\nexists (fun x => nth y0 fs (index x s)) => uAs eq_sz.\napply/esym/(@eq_from_nth _ y0); rewrite ?size_map eq_sz // => i ltis.\nby have x0 : T1 by [case: (s) ltis]; rewrite (nth_map x0) // index_uniq.\nQed."
}
{
  "statement": "Lemma pgroup_pdiv p G :\n    p.-group G -> G :!=: 1 ->\n  [/\\ prime p, p %| #|G| & exists m, #|G| = p ^ m.+1]%N.\n",
  "proof": "Proof.\nmove=> pG; rewrite trivg_card1; case/p_groupP: (pgroup_p pG) => q q_pr qG.\nmove/implyP: (pgroupP pG q q_pr); case/p_natP: qG => // [[|m] ->] //.\nby rewrite dvdn_exp // => /eqnP <- _; split; rewrite ?dvdn_exp //; exists m.\nQed."
}
{
  "statement": "Lemma sub_pairwise_orthogonal S1 S2 :\n    {subset S1 <= S2} ->  uniq S1 ->\n  pairwise_orthogonal S2 -> pairwise_orthogonal S1.\n",
  "proof": "Proof.\nmove=> sS12 uniqS1 /pairwise_orthogonalP[/andP[notS2_0 _] oS2].\napply/pairwise_orthogonalP; rewrite /= (contra (sS12 0)) //.\nby split=> //; apply: sub_in2 oS2.\nQed."
}
{
  "statement": "Lemma piOhm1 G : \\pi('Ohm_1(G)) = \\pi(G).\n",
  "proof": "Proof.\napply/eq_piP => p; apply/idP/idP; first exact: (piSg (Ohm_sub 1 G)).\nrewrite !mem_primes !cardG_gt0 => /andP[p_pr /Cauchy[] // x Gx oxp].\nby rewrite p_pr -oxp order_dvdG //= Ohm1Eprime mem_gen // inE Gx oxp.\nQed."
}
{
  "statement": "Lemma bigmax_leqP_seq (I : eqType) r (P : pred I) m F :\n  reflect (forall i, i \\in r -> P i -> F i <= m) (\\max_(i <- r | P i) F i <= m).\n",
  "proof": "Proof.\napply: (iffP idP) => leFm => [i ri Pi|].\n  exact/(leq_trans _ leFm)/leq_bigmax_seq.\nrewrite big_seq_cond; elim/big_ind: _ => // [m1 m2|i /andP[ri]].\n  by rewrite geq_max => ->.\nexact: leFm.\nQed."
}
{
  "statement": "Lemma val_factmodK m : cancel (@val_factmod m) (@in_factmod m).\n",
  "proof": "Proof.\nmove=> W /=; rewrite /in_factmod /=; set Uc := cokermx U.\napply: (row_free_inj (row_base_free Uc)); rewrite -mulmxA mulmx_base.\nrewrite /val_factmod /= 2!mulmxA -/Uc mulmxK ?row_ebase_unit //.\nhave /submxP[u ->]: (row_base Uc <= Uc)%MS by rewrite eq_row_base.\nby rewrite -!mulmxA copid_mx_id ?rank_leq_row.\nQed."
}
{
  "statement": "Lemma cfcenter_fful_irr i : cfaithful 'chi[G]_i -> 'Z('chi_i)%CF = 'Z(G).\n",
  "proof": "Proof.\nmove/trivgP=> Ki1; have:= cfcenter_eq_center i; rewrite {}Ki1.\nhave inj1: 'injm (@coset gT 1%g) by rewrite ker_coset.\nby rewrite -injm_center; first apply: injm_morphim_inj; rewrite ?norms1.\nQed."
}
{
  "statement": "Lemma Phi_nongen G X : 'Phi(G) <*> X = G -> <<X>> = G.\n",
  "proof": "Proof.\nmove=> defG; have: <<X>> \\subset G by rewrite -{1}defG genS ?subsetUr.\ncase/maximal_exists=> //= [[M maxM]]; rewrite gen_subG => sXM.\ncase/andP: (maxgroupp maxM) => _ /negP[].\nby rewrite -defG gen_subG subUset Phi_sub_max.\nQed."
}
{
  "statement": "Lemma algR_pfactorR_mul_gt0 (x a b : algC) :\n    x \\is Creal -> a \\is Creal -> b \\is Creal ->\n    a <= b ->\n    ((algC_pfactor x).[a] * (algC_pfactor x).[b] <= 0) =\n  (a <= x <= b).\n",
  "proof": "Proof.\nmove=> xR aR bR ab; rewrite !algC_pfactorRE// !hornerXsubC.\nhave [lt_xa|lt_ax|->]/= := real_ltgtP xR aR; last first.\n- by rewrite subrr mul0r lexx ab.\n- by rewrite nmulr_rle0 ?subr_lt0 ?subr_ge0.\nrewrite pmulr_rle0 ?subr_gt0// subr_le0.\nby apply: negbTE; rewrite -real_ltNge// (lt_le_trans lt_xa).\nQed."
}
{
  "statement": "Lemma bigmin_eq_arg j P F : P j -> (forall i, P i -> F i <= x) ->\n  \\big[min/x]_(i | P i) F i = F [arg min_(i < j | P i) F i].\n",
  "proof": "Proof.\nmove=> Pi0; case: arg_minP => //= i Pi PF PFx.\napply/eqP; rewrite eq_le bigmin_le_cond //=.\nby apply/bigmin_geP; split => //; exact: PFx.\nQed."
}
{
  "statement": "Lemma Vandermonde k l i :\n  \\sum_(j < i.+1) 'C(k, j) * 'C(l, i - j) = 'C(k + l , i).\n",
  "proof": "Proof.\npose f k i := \\sum_(j < i.+1) 'C(k, j) * 'C(l, i - j).\nsuffices{k i} fxx k i: f k.+1 i.+1 = f k i.+1 + f k i.\n  elim: k i => [i | k IHk [|i]]; last by rewrite -/(f _ _) fxx /f !IHk -binS.\n    by rewrite big_ord_recl big1_eq addn0 mul1n subn0.\n  by rewrite big_ord_recl big_ord0 addn0 !bin0 muln1.\nrewrite {}/f big_ord_recl (big_ord_recl (i.+1)) !bin0 !mul1n.\nrewrite -addnA -big_split /=; congr (_ + _).\nby apply: eq_bigr => j _; rewrite -mulnDl.\nQed."
}
{
  "statement": "Lemma bigmax_leP m P F :\n  reflect (x <= m /\\ forall i, P i -> F i <= m)\n          (\\big[max/x]_(i | P i) F i <= m).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[? ?]]; last exact: bigmax_le.\nrewrite bigmax_idl ge_max => /andP[-> leFm]; split=> // i Pi.\nby apply: le_trans leFm; exact: le_bigmax_cond.\nQed."
}
{
  "statement": "Lemma meet_eq1 x y : (x `&` y == \\top) = (x == \\top) && (y == \\top).\n",
  "proof": "Proof.\napply/idP/idP; last by move=> /andP[/eqP-> /eqP->]; rewrite meetx1.\nby move=> /eqP xIy1; rewrite -!le1x -xIy1 leIl leIr.\nQed."
}
{
  "statement": "Lemma rstab_group_set : group_set rstab.\n",
  "proof": "Proof.\napply/group_setP; rewrite inE group1 repr_mx1 mulmx1; split=> //= x y.\ncase/setIdP=> Gx cUx; case/setIdP=> Gy cUy; rewrite inE repr_mxM ?groupM //.\nby rewrite mulmxA (eqP cUx).\nQed."
}
{
  "statement": "Lemma memv_addP {w U V} :\n  reflect (exists2 u, u \\in U & exists2 v, v \\in V & w = u + v)\n          (w \\in U + V)%VS.\n",
  "proof": "Proof.\napply: (iffP idP) => [|[u Uu [v Vv ->]]]; last exact: memv_add.\nrewrite memvK genmxE => /sub_addsmxP[r /(canRL v2rK)->].\nrewrite linearD /=; set u := r2v _; set v := r2v _.\nby exists u; last exists v; rewrite // mem_r2v submxMl.\nQed."
}
{
  "statement": "Lemma mem_allpairs_dep f s1 t1 s2 t2 :\n    s1 =i s2 -> {in s1, forall x, t1 x =i t2 x} ->\n  [seq f x y | x <- s1, y <- t1 x] =i [seq f x y | x <- s2, y <- t2 x].\n",
  "proof": "Proof.\nmove=> eq_s eq_t z; apply/allpairsPdep/allpairsPdep=> -[x [y [sx ty ->]]];\nby exists x, y; rewrite -eq_s in sx *; rewrite eq_t in ty *.\nQed."
}
{
  "statement": "Lemma val_genK : cancel val_gen in_gen.\n",
  "proof": "Proof.\nmove=> W; apply/matrixP=> i j; apply: val_inj; rewrite mxE /= rowK.\ncase/row_freeP: base_free => B' BB'; rewrite -[_ *m _]mulmx1 -BB' mulmxA.\nby rewrite mulmxKpV ?submxMl // -mulmxA BB' mulmx1 mxvecK rowK.\nQed."
}
{
  "statement": "Lemma algC_invaut_subproof nu x : {y | nu y = x}.\n",
  "proof": "Proof.\nhave [r Dp] := closed_field_poly_normal (minCpoly x).\nsuffices /mapP/sig2_eqW[y _ ->]: x \\in map nu r by exists y.\nrewrite -root_prod_XsubC; congr (root _ x): (root_minCpoly x).\nhave [q [Dq _] _] := minCpolyP x; rewrite Dq -(eq_map_poly (fmorph_rat nu)).\nrewrite (map_poly_comp nu) -{q}Dq Dp (monicP (minCpoly_monic x)) scale1r.\nrewrite rmorph_prod big_map /=; apply: eq_bigr => z _.\nby rewrite rmorphB /= map_polyX map_polyC.\nQed."
}
{
  "statement": "Lemma eq_sol f1 f2 :\n  (forall e, holds e f1 <-> holds e f2) -> sol^~ f1 =1 sol^~ f2.\n",
  "proof": "Proof.\nrewrite /sol => /eq_sat eqf12 n.\ndo 2![case: sol_subproof] => //= [f1s f2s | ns1 [s f2s] | [s f1s] []].\n- by apply: eq_xchoose => s; rewrite eqf12.\n- by case: ns1; exists s; rewrite -eqf12.\nby exists s; rewrite eqf12.\nQed."
}
{
  "statement": "Lemma col_mx_sub m3 (C : 'M_(m3, n)) :\n  (col_mx A B <= C)%MS = (A <= C)%MS && (B <= C)%MS.\n",
  "proof": "Proof.\nrewrite !submxE mul_col_mx -col_mx0.\nby apply/eqP/andP; [case/eq_col_mx=> -> -> | case; do 2!move/eqP->].\nQed."
}
{
  "statement": "Lemma le_floor : {homo floor : x y / x <= y}.\n",
  "proof": "Proof.\nmove=> x y lexy; move: (floorP x) (floorP y); rewrite (ger_real lexy).\ncase: ifP => [_ /andP[lefx _] /andP[_] | _ /eqP-> /eqP-> //].\nby move=> /(le_lt_trans lexy) /(le_lt_trans lefx); rewrite ltr_int ltzD1.\nQed."
}
{
  "statement": "Lemma inv_kHomf K f : kHom K {:L} f -> kHom K {:L} f^-1.\n",
  "proof": "Proof.\nmove=> homKf; have [[fM idKf] kerf0] := (kHomP homKf, kAutf_lker0 homKf).\nhave f1K: cancel f^-1%VF f by apply: lker0_lfunVK.\napply/kHomP; split=> [x y _ _ | x Kx]; apply: (lker0P kerf0).\n  by rewrite fM ?memvf ?{1}f1K.\nby rewrite f1K idKf.\nQed."
}
{
  "statement": "Lemma actsP A S : reflect {acts A, on S | to} [acts A, on S | to].\n",
  "proof": "Proof.\napply: (iffP idP) => [nSA x|nSA]; first exact: acts_act.\nby apply/subsetP=> a Aa /[!inE]; apply/subsetP=> x; rewrite inE nSA.\nQed."
}
{
  "statement": "Lemma comm3G1P A B C :\n  reflect {in A & B & C, forall h k l, [~ h, k, l] = 1} ([~: A, B, C] :==: 1).\n",
  "proof": "Proof.\nhave R_C := sameP trivgP commG1P.\nrewrite -subG1 R_C gen_subG -{}R_C gen_subG.\napply: (iffP subsetP) => [cABC x y z Ax By Cz | cABC xyz].\n  by apply/set1P; rewrite cABC // !imset2_f.\nby case/imset2P=> _ z /imset2P[x y Ax By ->] Cz ->; rewrite cABC.\nQed."
}
{
  "statement": "Lemma partnM pi m n : m > 0 -> n > 0 -> (m * n)`_pi = m`_pi * n`_pi.\n",
  "proof": "Proof.\nhave le_pmul m' n': m' > 0 -> n' <= m' * n' by move/prednK <-; apply: leq_addr.\nmove=> mpos npos; rewrite !(@widen_partn (n * m)) 3?(le_pmul, mulnC) //.\nrewrite !big_mkord -big_split; apply: eq_bigr => p _ /=.\nby rewrite lognM // expnD.\nQed."
}
{
  "statement": "Lemma rem_mem y s : y != x -> y \\in s -> y \\in rem s.\n",
  "proof": "Proof.\nmove=> yx; elim: s => [//|z s IHs] /=.\nrewrite inE => /orP[/eqP<-|ys]; first by rewrite (negbTE yx) inE eqxx.\nby case: ifP => _ //; rewrite inE IHs ?orbT.\nQed."
}
{
  "statement": "Lemma order_constt pi (x : gT) : #[x.`_pi] = #[x]`_pi.\n",
  "proof": "Proof.\nrewrite -{2}(consttC pi x) orderM; [|exact: commuteX2|]; last first.\n  by apply: (@pnat_coprime pi); apply: p_elt_constt.\nby rewrite partnM // part_pnat_id ?part_p'nat ?muln1 //; apply: p_elt_constt.\nQed."
}
{
  "statement": "Lemma injmF gT rT (G D : {group gT}) (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* (F gT G) = F rT (f @* G).\n",
  "proof": "Proof.\nmove=> injf sGD; have [sfGD injf'] := (morphimS f sGD, injm_invm injf).\napply/esym/eqP; rewrite eqEsubset -(injmSK injf') ?gFsub_trans //.\nby rewrite !(subset_trans (injmF_sub _ _)) ?morphim_invm // gFsub_trans.\nQed."
}
{
  "statement": "Lemma map_rfix_mx H : (rfix_mx rG H)^f = rfix_mx rGf H.\n",
  "proof": "Proof.\nrewrite map_kermx //; congr (kermx _); apply: map_lin1_mx => //= v.\nrewrite map_mxvec map_mxM; congr (mxvec (_ *m _)); last first.\n  by apply: map_lin1_mx => //= u; rewrite map_mxM map_vec_mx.\nby apply/row_matrixP=> i; rewrite -map_row !rowK map_mxvec map_mxB map_mx1.\nQed."
}
{
  "statement": "Lemma Fadjoin_seqP {K} {rs : seq L} {E} :\n  reflect (K <= E /\\ {subset rs <= E})%VS (<<K & rs>> <= E)%VS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sKrsE | [sKE /span_subvP/(conj sKE)/andP]].\n  split=> [|x rs_x]; first exact: subv_trans (subv_adjoin_seq _ _) sKrsE.\n  by rewrite (subvP sKrsE) ?seqv_sub_adjoin.\nby rewrite -subv_add => /agenvS; rewrite subfield_closed.\nQed."
}
{
  "statement": "Theorem eq_irrelevance (T : eqType) x y : forall e1 e2 : x = y :> T, e1 = e2.\n",
  "proof": "Proof.\npose proj z e := if x =P z is ReflectT e0 then e0 else e.\nsuff: injective (proj y) by rewrite /proj => injp e e'; apply: injp; case: eqP.\npose join (e : x = _) := etrans (esym e).\napply: can_inj (join x y (proj x (erefl x))) _.\nby case: y /; case: _ / (proj x _).\nQed."
}
{
  "statement": "Lemma hom_cyclic_mx u f :\n  (u <= dom_hom_mx f)%MS -> (cyclic_mx u *m f :=: cyclic_mx (u *m f))%MS.\n",
  "proof": "Proof.\nmove=> domf_u; apply/eqmxP; rewrite !(eqmxMr _ (genmxE _)).\napply/genmxP; rewrite genmx_id; congr <<_>>%MS; apply/row_matrixP=> i.\nby rewrite !row_mul !mul_rV_lin1 /= hom_envelop_mxC // vec_mxK row_sub.\nQed."
}
{
  "statement": "Lemma dvdpP_rat_int p q :\n    p %| pZtoQ q ->\n  {p1 : {poly int} & {a | a != 0 & p = a *: pZtoQ p1} & {r | q = p1 * r}}.\n",
  "proof": "Proof.\nhave{p} [p [a nz_a ->]] := rat_poly_scale p.\nrewrite dvdpZl ?invr_eq0 ?intr_eq0 // dvdp_rat_int => dv_p_q.\nexists (zprimitive p); last exact: dvdpP_int.\nhave [-> | nz_p] := eqVneq p 0.\n  by exists 1; rewrite ?oner_eq0 // zprimitive0 map_poly0 !scaler0.\nexists ((zcontents p)%:~R / a%:~R).\n  by rewrite mulf_neq0 ?invr_eq0 ?intr_eq0 ?zcontents_eq0.\nby rewrite mulrC -scalerA -map_polyZ -zpolyEprim.\nQed."
}
{
  "statement": "Lemma cotrigonalization2 n (A B : 'M[C]_n) : A *m B = B *m A ->\n  exists2 P : 'M[C]_n, P \\is unitarymx &\n    similar_trig P A && similar_trig P B.\n",
  "proof": "Proof.\nmove=> AB_comm; have [] := @cotrigonalization _ [:: A; B].\n  by move=> ??; rewrite !inE => /orP[]/eqP->/orP[]/eqP->.\nmove=> P Punitary /allP /= PP; exists P => //.\nby rewrite !PP ?(mem_head, in_cons, orbT).\nQed."
}
{
  "statement": "Lemma component_socle M : mxsimple M -> component_mx M \\in socle_enum.\n",
  "proof": "Proof.\nrewrite /socle_enum; case: sG0 => e0 /= sim_e mem_e simM.\nhave /hasP[M' e0M' isoMM'] := mem_e M simM; apply/mapP; exists M' => //.\nby apply/eqP/component_mx_isoP; [|apply: sim_e | apply/mxsimple_isoP].\nQed."
}
{
  "statement": "Lemma eq_xchoose P Q exP exQ : P =1 Q -> @xchoose P exP = @xchoose Q exQ.\n",
  "proof": "Proof.\nrewrite /xchoose => eqPQ.\ncase: (xchoose_subproof exP) => x; case: (xchoose_subproof exQ) => y /=.\ncase: ex_minnP => n; rewrite -(extensional eqPQ) => Pn minQn.\ncase: ex_minnP => m; rewrite !(extensional eqPQ) => Qm minPm.\nby case: (eqVneq m n) => [-> -> [] //|]; rewrite eqn_leq minQn ?minPm.\nQed."
}
{
  "statement": "Lemma sub_le_big I [s] (P P' : {pred I}) (F : I -> R) :\n    (forall i, P i -> P' i) ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s | P' i) F i).\n",
  "proof": "Proof.\nmove=> PP'; rewrite [X in le _ X](big_AC_mk_monoid opA opC) (bigID P P') /=.\nunder [in X in le _ X]eq_bigl do rewrite (andb_idl (PP' _)).\nrewrite [X in le X _](big_AC_mk_monoid opA opC).\ncase: (bigop _ _ _) (bigop _ _ _) => [y|] [z|]//=.\n  by rewrite -opA [_ y x]opC opA op_incr.\nby rewrite opC op_incr.\nQed."
}
{
  "statement": "Lemma leq_trunc_log p m n : m <= n -> trunc_log p m <= trunc_log p n.\n",
  "proof": "Proof.\nmove=> mlen; case: p => [|[|p]]; rewrite ?trunc_log0n ?trunc_log1n //.\ncase: m mlen => [|m] mlen; first by rewrite trunc_log0.\napply/trunc_log_max => //; apply: leq_trans mlen; exact: trunc_logP.\nQed."
}
{
  "statement": "Lemma kAut_to_gal K E f :\n  kAut K E f -> {x : gal_of E | x \\in 'Gal(E / K) & {in E, f =1 x}}.\n",
  "proof": "Proof.\ncase/andP=> homKf EfE; have [g Df] := kHom_to_AEnd homKf.\nhave{homKf EfE} autEg: kAut (K :&: E) E g.\n  rewrite /kAut -(kHom_eq (capvSr _ _) Df) (kHomSl (capvSl _ _) homKf) /=.\n  by rewrite -(eq_in_limg Df).\nhave FautEg := kAutS (sub1v _) autEg.\nexists (gal E g) => [|a Ea]; last by rewrite {f}Df // galK // -kAut1E.\nby rewrite mem_morphim /= ?subfield_closed ?genGid ?inE.\nQed."
}
{
  "statement": "Lemma trunc_log_eq p n k : 1 < p -> p ^ n <= k < p ^ n.+1 -> trunc_log p k = n.\n",
  "proof": "Proof.\nmove=> p_gt1 /andP[npLk kLpn]; apply/anti_leq.\nrewrite trunc_log_max// andbT -ltnS -(ltn_exp2l _ _ p_gt1).\napply: leq_ltn_trans kLpn; apply: trunc_logP => //.\nby apply: leq_trans npLk; rewrite expn_gt0 ltnW.\nQed."
}
{
  "statement": "Lemma subgmK (A : {set gT}) : A \\subset G -> sgval @* (subg G @* A) = A.\n",
  "proof": "Proof.\nmove=> sAG; apply/eqP; rewrite eqEcard !card_injm ?subsetT //.\nrewrite leqnn andbT -morphim_comp morphimE /= morphpreT.\nby apply/subsetP=> _ /morphimP[v Gv Av ->] /=; rewrite subgK.\nQed."
}
{
  "statement": "Lemma sub_pairwise_orthogonal S1 S2 :\n    {subset S1 <= S2} ->  uniq S1 ->\n  pairwise_orthogonal form S2 -> pairwise_orthogonal form S1.\n",
  "proof": "Proof.\nmove=> sS12 uniqS1 /pairwise_orthogonalP[/andP[notS2_0 _] oS2].\napply/pairwise_orthogonalP; rewrite /= (contra (sS12 0)) //.\nby split=> //; apply: sub_in2 oS2.\nQed."
}
{
  "statement": "Lemma mulsmxS m1 m2 m3 m4 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n))\n                            (R3 : 'A_(m3, n)) (R4 : 'A_(m4, n)) :\n  (R1 <= R3 -> R2 <= R4 -> R1 * R2 <= R3 * R4)%MS.\n",
  "proof": "Proof.\nmove=> sR13 sR24; apply/mulsmx_subP=> A1 A2 R_A1 R_A2.\nby apply: mem_mulsmx; [apply: submx_trans sR13 | apply: submx_trans sR24].\nQed."
}
{
  "statement": "Lemma memmx_addsP m1 m2 n A (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (exists D, [/\\ D.1 \\in R1, D.2 \\in R2 & A = D.1 + D.2])\n          (A \\in R1 + R2)%MS.\n",
  "proof": "Proof.\napply: (iffP sub_addsmxP) => [[u /(canRL mxvecK)->] | [D []]].\n  exists (vec_mx (u.1 *m R1), vec_mx (u.2 *m R2)).\n  by rewrite /= linearD !vec_mxK !submxMl.\ncase/submxP=> u1 defD1 /submxP[u2 defD2] ->.\nby exists (u1, u2); rewrite linearD /= defD1 defD2.\nQed."
}
{
  "statement": "Lemma dvdp_prod_XsubC (I : Type) (r : seq I) (F : I -> R) p :\n    p %| \\prod_(i <- r) ('X - (F i)%:P) ->\n  {m | p %= \\prod_(i <- mask m r) ('X - (F i)%:P)}.\n",
  "proof": "Proof.\nelim: r => [|i r IHr] in p *.\n  by rewrite big_nil dvdp1; exists nil; rewrite // big_nil -size_poly_eq1.\nrewrite big_cons dvdp_mul_XsubC root_factor_theorem -eqp_div_XsubC.\ncase: eqP => [{2}-> | _] /IHr[m Dp]; last by exists (false :: m).\nby exists (true :: m); rewrite /= mulrC big_cons eqp_mul2l ?polyXsubC_eq0.\nQed."
}
{
  "statement": "Lemma dvdn_gcdr m n : gcdn m n %| n.\n",
  "proof": "Proof.\nelim/ltn_ind: m n => -[|m] IHm [|n] //=.\nrewrite gcdnE; case def_p: (_ %% _) => [|p]; first by rewrite /dvdn def_p.\nhave lt_pm: p < m by rewrite -ltnS -def_p ltn_pmod.\nrewrite /= (divn_eq n.+1 m.+1) def_p dvdn_addr ?dvdn_mull //; last exact: IHm.\nby rewrite gcdnE /= IHm // (ltn_trans (ltn_pmod _ _)).\nQed."
}
{
  "statement": "Lemma cent_mxP m n B (R : 'A_(m, n)) :\n  reflect (forall A, A \\in R -> A *m B = B *m A) (B \\in 'C(R))%MS.\n",
  "proof": "Proof.\napply: (iffP cent_rowP) => cEB => [A sAE | i A].\n  rewrite -[A]mxvecK -(mulmxKpV sAE); move: (mxvec A *m _) => u.\n  rewrite !mulmx_sum_row !linear_sum mulmx_suml; apply: eq_bigr => i _ /=.\n  by rewrite 2!linearZ -scalemxAl /= cEB.\nby rewrite cEB // vec_mxK row_sub.\nQed."
}
{
  "statement": "Lemma divzMpl p m d : p > 0 -> (p * m %/ (p * d) = m %/ d)%Z.\n",
  "proof": "Proof.\ncase: p => // p p_gt0; wlog d_gt0: d / d > 0; last case: d => // d in d_gt0 *.\n  by move=> IH; case/intP: d => [|d|d]; rewrite ?mulr0 ?divz0 ?mulrN ?divzN ?IH.\nrewrite {1}(divz_eq m d) mulrDr mulrCA divzMDl ?mulf_neq0 ?gt_eqF // addrC.\nrewrite divz_small ?add0r // PoszM pmulr_rge0 ?modz_ge0 ?gt_eqF //=.\nby rewrite ltr_pM2l ?ltz_pmod.\nQed."
}
{
  "statement": "Lemma diagsqmx_ind (P : forall n, 'M[V]_n -> Type) :\n    (P 0 0) ->\n  (forall n x c A, is_diag_mx A -> P n A -> P (1 + n)%N (block_mx x 0 c A)) ->\n  forall n A, is_diag_mx A -> P n A.\n",
  "proof": "Proof.\nmove=> P0 PS n A; elim/sqmx_ind: A => [|{}n x r c] A PA.\n  by rewrite thinmx0; apply: P0.\nrewrite is_diag_block_mx => // /and4P[/eqP-> /eqP-> _ Adiag].\nexact: PS (PA _).\nQed."
}
{
  "statement": "Lemma polyOver1P p :\n  reflect (exists q, p = map_poly (in_alg aT) q) (p \\is a polyOver 1%VS).\n",
  "proof": "Proof.\napply: (iffP idP) => [/allP/=Qp | [q ->]]; last first.\n  by apply/polyOverP=> j; rewrite coef_map rpredZ ?memv_line.\nexists (map_poly (coord [tuple 1] 0) p).\nrewrite -map_poly_comp map_poly_id // => _ /Qp/vlineP[a ->] /=.\nby rewrite linearZ /= (coord_free 0) ?mulr1 // seq1_free ?oner_eq0.\nQed."
}
{
  "statement": "Lemma p_part p n : n`_p = p ^ logn p n.\n",
  "proof": "Proof.\ncase (posnP (logn p n)) => [log0 |].\n  by rewrite log0 [n`_p]big1_seq // => q /andP [/eqP ->]; rewrite log0.\nrewrite logn_gt0 mem_primes; case/and3P=> _ n_gt0 dv_p_n.\nhave le_p_n: p < n.+1 by rewrite ltnS dvdn_leq.\nby rewrite [n`_p]big_mkord (big_pred1 (Ordinal le_p_n)).\nQed."
}
{
  "statement": "Lemma preim_autE A : A \\subset G -> aut @^-1: A = f @*^-1 A.\n",
  "proof": "Proof.\nmove=> sAG; apply/setP=> x; rewrite !inE permE /=.\nby case Gx: (x \\in G) => //; apply/negP=> Ax; rewrite (subsetP sAG) in Gx.\nQed."
}
{
  "statement": "Theorem dvd_irr1_cardG gT (G : {group gT}) i : ('chi[G]_i 1%g %| #|G|)%C.\n",
  "proof": "Proof.\nrewrite unfold_in -if_neg irr1_neq0 Cint_rat_Aint //=.\n  by rewrite rpred_div ?rpred_nat // rpred_nat_num ?Cnat_irr1.\nrewrite -[n in n / _]/(_ *+ true) -(eqxx i) -mulr_natr.\nrewrite -first_orthogonality_relation mulVKf ?neq0CG //.\nrewrite sum_by_classes => [|x y Gx Gy]; rewrite -?conjVg ?cfunJ //.\nrewrite mulr_suml rpred_sum // => K /repr_classesP[Gx {1}->].\nby rewrite !mulrA mulrAC rpredM ?Aint_irr ?Aint_class_div_irr1.\nQed."
}
{
  "statement": "Lemma homo_sort_map_in\n      (T : Type) (T' : eqType) (P : {pred T}) (f : T -> T') leT leT' :\n  {in P &, antisymmetric (relpre f leT')} ->\n  {in P & &, transitive (relpre f leT')} -> {in P &, total leT} ->\n  {in P &, {homo f : x y / leT x y >-> leT' x y}} ->\n  forall s : seq T, all P s ->\n        sort leT' [seq f x | x <- s] = [seq f x | x <- sort leT s].\n",
  "proof": "Proof.\nmove=> /in2_sig leT'_asym /in3_sig leT'_trans /in2_sig leT_total.\nmove=> /in2_sig f_homo _ /all_sigP[s ->].\nrewrite [in RHS]sort_map -!map_comp /comp.\nby apply: homo_sort_map => // ? ? /leT'_asym /val_inj.\nQed."
}
{
  "statement": "Lemma irr_reprP xi :\n  reflect (exists2 rG : representation _ G, mx_irreducible rG & xi = cfRepr rG)\n          (xi \\in irr G).\n",
  "proof": "Proof.\napply: (iffP (irrP xi)) => [[i ->] | [[n rG] irr_rG ->]].\n  by exists (Representation 'Chi_i); [apply: socle_irr | rewrite irrRepr].\nexists (irr_of_socle (irr_comp sG rG)); rewrite -irrRepr irr_of_socleK /=.\nexact/cfRepr_sim/rsim_irr_comp_pchar.\nQed."
}
{
  "statement": "Lemma Frobenius_subl G K K1 H :\n    K1 :!=: 1 -> K1 \\subset K -> H \\subset 'N(K1) -> [Frobenius G = K ><| H] ->\n  [Frobenius K1 <*> H = K1 ><| H].\n",
  "proof": "Proof.\nmove=> ntK1 sK1K nK1H frobG; have [_ _ ntH _ _] := Frobenius_context frobG.\napply/Frobenius_semiregularP=> //.\n  by rewrite sdprodEY ?coprime_TIg ?(coprimeSg sK1K) ?(Frobenius_coprime frobG).\nby move=> x /(Frobenius_reg_ker frobG) cKx1; apply/trivgP; rewrite -cKx1 setSI.\nQed."
}
{
  "statement": "Lemma sdprod_mulgA : associative sdprod_mul.\n",
  "proof": "Proof.\nmove=> u v w; apply: val_inj; case: u => [[a x]] /=; case/setXP=> Da Rx.\ncase: v w => [[b y]] /=; case/setXP=> Db Ry [[c z]] /=; case/setXP=> Dc Rz.\nby rewrite !(actMin to) // gactM ?gact_stable // !mulgA.\nQed."
}
{
  "statement": "Lemma rdvdp_eqP d p : rdvdp_spec p d (rmodp p d) (rdvdp d p).\n",
  "proof": "Proof.\ncase hdvd: (rdvdp d p); last by move/rmodp_eq0P/eqP/RdvdpN: hdvd.\nmove/rmodp_eq0P: (hdvd)->; apply: (@Rdvdp _ _ _ (rscalp p d) (rdivp p d)).\nby rewrite mulrC mul_polyC rdivp_eq; move/rmodp_eq0P: (hdvd)->; rewrite addr0.\nQed."
}
{
  "statement": "Lemma pmaxElemJ p A E x : ((E :^ x)%G \\in 'E*_p(A :^ x)) = (E \\in 'E*_p(A)).\n",
  "proof": "Proof.\napply/pmaxElemP/pmaxElemP=> [] [EpE maxE].\n  rewrite pElemJ in EpE; split=> //= H EpH sEH; apply: (act_inj 'Js x).\n  by apply: maxE; rewrite ?conjSg ?pElemJ.\nrewrite pElemJ; split=> // H; rewrite -(actKV 'JG x H) pElemJ conjSg => EpHx'.\nby move/maxE=> /= ->.\nQed."
}
{
  "statement": "Lemma mem_pblock P x : (x \\in pblock P x) = (x \\in cover P).\n",
  "proof": "Proof.\nrewrite /pblock; apply/esym/bigcupP.\ncase: pickP => /= [A /andP[PA Ax]| noA]; first by rewrite Ax; exists A.\nby rewrite inE => [[A PA Ax]]; case/andP: (noA A).\nQed."
}
{
  "statement": "Lemma ieexprIz x (x0 : 0 < x) (nx1 : x != 1) : injective (exprz x).\n",
  "proof": "Proof.\napply: wlog_lt=> // m n hmn; first by move=> hmn'; rewrite hmn.\nmove=> /(f_equal ( *%R^~ (x ^ (- n)))).\nrewrite -!expfzDr ?gt_eqF // subrr expr0z=> /eqP.\nby rewrite pexprz_eq1 ?(ltW x0) // (negPf nx1) subr_eq0 orbF=> /eqP.\nQed."
}
{
  "statement": "Lemma pHallP pi G H : reflect (H \\subset G /\\ #|H| = #|G|`_pi) (pi.-Hall(G) H).\n",
  "proof": "Proof.\napply: (iffP idP) => [piH | [sHG oH]].\n  by split; [apply: pHall_sub piH | apply: card_Hall].\nrewrite /pHall sHG -divgS // /pgroup oH.\nby rewrite -{2}(@partnC pi #|G|) ?mulKn ?part_pnat.\nQed."
}
{
  "statement": "Lemma Zisometry_of_cfnorm (tauS : seq 'CF(G)) :\n    pairwise_orthogonal S -> pairwise_orthogonal tauS ->\n    map cfnorm tauS = map cfnorm S -> {subset tauS <= 'Z[irr G]} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | map tau S = tauS\n       & {in 'Z[S], isometry tau, to 'Z[irr G]}}.\n",
  "proof": "Proof.\nmove=> oSS oTT /isometry_of_cfnorm[||tau defT Itau] // Z_T; exists tau => //.\nsplit=> [|_ /zchar_nth_expansion[u Zu ->]].\n  by apply: sub_in2 Itau; apply: zchar_span.\nrewrite big_seq linear_sum rpred_sum // => xi Sxi.\nby rewrite linearZ scale_zchar ?Z_T // -defT map_f ?mem_nth.\nQed."
}
{
  "statement": "Lemma pmorphim_pHall pi G H :\n    G \\subset D -> H \\subset D -> pi.-subgroup(H :&: G) ('ker f) ->\n  pi.-Hall(f @* G) (f @* H) = pi.-Hall(G) H.\n",
  "proof": "Proof.\nmove=> sGD sHD /andP[/subsetIP[sKH sKG] piK]; rewrite !pHallE morphimSGK //.\napply: andb_id2l => sHG; rewrite -(Lagrange sKH) -(Lagrange sKG) partnM //.\nby rewrite (part_pnat_id piK) !card_morphim !(setIidPr _) // eqn_pmul2l.\nQed."
}
{
  "statement": "Lemma dvdpP p : reflect (exists q, p = q * d) (d %| p).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [k ->]]; last by apply/eqP; rewrite modp_mull.\nby rewrite dvdp_eq; move/eqP->; exists (p %/ d).\nQed."
}
{
  "statement": "Lemma coprime_mulpG_Hall pi G K R :\n    K * R = G -> pi.-group K -> pi^'.-group R ->\n  pi.-Hall(G) K /\\ pi^'.-Hall(G) R.\n",
  "proof": "Proof.\nmove=> defG piK pi'R; apply/andP.\nrewrite /pHall piK -!divgS /= -defG ?mulG_subl ?mulg_subr //= pnatNK.\nby rewrite coprime_cardMg ?(pnat_coprime piK) // mulKn ?mulnK //; apply/and3P.\nQed."
}
{
  "statement": "Theorem expnDn a b n :\n  (a + b) ^ n = \\sum_(i < n.+1) 'C(n, i) * (a ^ (n - i) * b ^ i).\n",
  "proof": "Proof.\nelim: n => [|n IHn]; rewrite big_ord_recl muln1 ?big_ord0 //.\nrewrite expnS {}IHn /= mulnDl !big_distrr /= big_ord_recl muln1 subn0.\nrewrite !big_ord_recr /= !binn !subnn bin0 !subn0 !mul1n -!expnS -addnA.\ncongr (_ + _); rewrite addnA -big_split /=; congr (_ + _).\napply: eq_bigr => i _; rewrite mulnCA (mulnA a) -expnS subnSK //=.\nby rewrite (mulnC b) -2!mulnA -expnSr -mulnDl.\nQed."
}
{
  "statement": "Lemma galTrace_fixedField a :\n  a \\in E -> galTrace K E a \\in fixedField 'Gal(E / K).\n",
  "proof": "Proof.\nmove=> Ea; apply/fixedFieldP=> [|x galEx].\n  by apply: rpred_sum => x _; apply: memv_gal.\nrewrite {2}/galTrace (reindex_acts 'R _ galEx) ?astabsR //=.\nby rewrite rmorph_sum; apply: eq_bigr => y _; rewrite galM ?lfunE.\nQed."
}
{
  "statement": "Lemma expfzMl x y n : (x * y) ^ n = x ^ n * y ^ n.\n",
  "proof": "Proof.\nhave [->|/negPf n0] := eqVneq n 0; first by rewrite !expr0z mulr1.\ncase: (boolP ((x * y) == 0)); rewrite ?mulf_eq0.\n  by case/pred2P=> ->; rewrite ?(mul0r, mulr0, exp0rz, n0).\nby case/norP=> x0 y0; rewrite exprzMl ?unitfE.\nQed."
}
{
  "statement": "Lemma galNorm_fixedField a :\n  a \\in E -> galNorm K E a \\in fixedField 'Gal(E / K).\n",
  "proof": "Proof.\nmove=> Ea; apply/fixedFieldP=> [|x galEx].\n  by apply: rpred_prod => x _; apply: memv_gal.\nrewrite {2}/galNorm (reindex_acts 'R _ galEx) ?astabsR //=.\nby rewrite rmorph_prod; apply: eq_bigr => y _; rewrite galM ?lfunE.\nQed."
}
{
  "statement": "Lemma centrals_nil (s : seq {group gT}) G :\n  G.-central.-series 1%G s -> last 1%G s = G -> nilpotent G.\n",
  "proof": "Proof.\nmove=> cGs defG; apply/forall_inP=> H /subsetIP[sHG sHR].\nmove: sHG; rewrite -{}defG -subG1 -[1]/(gval 1%G).\nelim: s 1%G cGs => //= L s IHs K /andP[/and3P[sRK sKL sLG] /IHs sHL] sHs.\nexact: subset_trans sHR (subset_trans (commSg _ (sHL sHs)) sRK).\nQed."
}
{
  "statement": "Lemma prime_subgroupVti G H : prime #|G| -> G \\subset H \\/ H :&: G = 1.\n",
  "proof": "Proof.\nmove=> prG; have [|[p p_pr pG]] := trivgVpdiv (H :&: G); first by right.\nleft; rewrite (sameP setIidPr eqP) eqEcard subsetIr.\nsuffices <-: p = #|G| by rewrite dvdn_leq ?cardG_gt0.\nby apply/eqP; rewrite -dvdn_prime2 // -(LagrangeI G H) setIC dvdn_mulr.\nQed."
}
{
  "statement": "Lemma real_ceil_floor x : x \\is Rreal ->\n  ceil x = floor x + (x \\isn't a int_num).\n",
  "proof": "Proof.\ncase Ix: (x \\is a int_num) => Rx /=.\n  by apply/eqP; rewrite addr0 ceilNfloor eqr_oppLR floorN.\napply/ceil_def; rewrite addrK; move: (real_floor_itv Rx).\nby rewrite le_eqVlt -intrEfloor Ix /= => /andP[-> /ltW].\nQed."
}
{
  "statement": "Lemma F_r1 : 'Fix_to[r1] =\n  [set x | (coin0 x == coin1 x)&&(coin1 x == coin2 x)&&(coin2 x == coin3 x)].\n",
  "proof": "Proof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f r1_inv !ffunE !permE andbC.\nby do 3![case E: {+}(_ == _); rewrite // {E}(eqP E)]; rewrite eqxx.\nQed."
}
{
  "statement": "Lemma morphpre_normal R S :\n  R \\subset f @* D -> S \\subset f @* D -> (f @*^-1 R <| f @*^-1 S) = (R <| S).\n",
  "proof": "Proof.\nmove=> sRfD sSfD; apply/idP/andP=> [|[sRS nSR]].\n  by move/morphim_normal; rewrite !morphpreK //; case/andP.\nby rewrite /(_ <| _) (subset_trans _ (morphpre_norm _)) morphpreS.\nQed."
}
{
  "statement": "Lemma bigdprod_rowg m (I : finType) (P : pred I) A (B : 'M[F]_(m, n)) :\n    let S := (\\sum_(i | P i) A i)%MS in (S :=: B)%MS -> mxdirect S ->\n  \\big[dprod/1%g]_(i | P i) rowg (A i) = rowg B.\n",
  "proof": "Proof.\nmove=> S defS; rewrite mxdirectE defS /= => /eqP rankB.\napply: bigcprod_card_dprod (bigcprod_rowg defS) (eq_leq _).\nby rewrite card_rowg rankB expn_sum; apply: eq_bigr => i; rewrite card_rowg.\nQed."
}
{
  "statement": "Lemma card_gt1P A :\n  reflect (exists x y, [/\\ x \\in A, y \\in A & x != y]) (1 < #|A|).\n",
  "proof": "Proof.\napply: (iffP card_geqP) => [[s] []|[x] [y] [xA yA xDy]].\n  case: s => [|a [|b []]]//= /[!(inE, andbT)] aDb _ subD.\n  by exists a, b; rewrite aDb !subD ?inE ?eqxx ?orbT.\nby exists [:: x; y]; rewrite /= !inE xDy; split=> // z /[!inE] /pred2P[]->.\nQed."
}
{
  "statement": "Lemma irr1_rfix : (1%irr :=: rfix_mx aG G)%MS.\n",
  "proof": "Proof.\nrewrite [1%irr]unlock PackSocleK; apply/eqmxP.\nrewrite (component_mx_id principal_comp_subproof) andbT.\nhave [I [W isoW ->]] := component_mx_def principal_comp_subproof.\napply/sumsmx_subP=> i _; have [f _ hom_f <-]:= isoW i.\n\nby apply/rfix_mxP=> x Gx; rewrite -(hom_mxP hom_f) // (rfix_mxP G _).\nQed."
}
{
  "statement": "Lemma natf_neq0_pchar n : (n%:R != 0 :> R) = (pchar R)^'.-nat n.\n",
  "proof": "Proof.\nhave [-> | /prod_prime_decomp->] := posnP n; first by rewrite eqxx.\nrewrite !big_seq; elim/big_rec: _ => [|[p e] s /=]; first by rewrite oner_eq0.\ncase/mem_prime_decomp=> p_pr _ _; rewrite pnatM pnatX eqn0Ngt orbC => <-.\nby rewrite natrM natrX mulf_eq0 expf_eq0 negb_or negb_and pnatE ?inE p_pr.\nQed."
}
{
  "statement": "Lemma infixPn s1 s2 :\n  reflect (infix_index s1 s2 = (size s2).+1) (~~ infix s1 s2).\n",
  "proof": "Proof.\nrewrite -infixTindex -ltnNge; apply: (iffP idP) => [s2lt|->//].\nby apply/eqP; rewrite eqn_leq s2lt infix_index_le.\nQed."
}
{
  "statement": "Lemma bigmax_eq_arg j P F : P j -> (forall i, P i -> x <= F i) ->\n  \\big[max/x]_(i | P i) F i = F [arg max_(i > j | P i) F i].\n",
  "proof": "Proof.\nmove=> Pi0; case: arg_maxP => //= i Pi PF PxF.\napply/eqP; rewrite eq_le le_bigmax_cond // andbT.\nby apply/bigmax_leP; split => //; exact: PxF.\nQed."
}
{
  "statement": "Lemma bigD1_ord n j (P : pred 'I_n) F :\n  P j -> \\big[op/x]_(i < n | P i) F i\n    = op (F j) (\\big[op/x]_(i < n.-1 | P (lift j i)) F (lift j i)).\n",
  "proof": "Proof.\nmove=> Pj; rewrite (bigD1 j Pj) (reindex_omap (lift j) (unlift j))/=.\n  by under eq_bigl do rewrite liftK eq_sym eqxx neq_lift ?andbT.\nby move=> i; case: unliftP => [k ->|->]; rewrite ?eqxx ?andbF.\nQed."
}
{
  "statement": "Lemma bigcupP x P F :\n  reflect (exists2 i, P i & x \\in F i) (x \\in \\bigcup_(i | P i) F i).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[i Pi]]; last first.\n  by apply: subsetP x; apply: bigcup_sup.\nby elim/big_rec: _ => [|i _ Pi _ /setUP[|//]]; [rewrite inE | exists i].\nQed."
}
{
  "statement": "Lemma ler_weXz2l x (x1 : 1 <= x) : {homo exprz x : x y / x <= y}.\n",
  "proof": "Proof.\nmove=> m n /= hmn; case: (lerP 0 m)=> [|/ltW] hm.\n  by rewrite ler_wpeXz2l // [_ \\in _](le_trans hm).\ncase: (lerP n 0)=> [|/ltW] hn.\n  by rewrite ler_wneXz2l // [_ \\in _](le_trans hmn).\napply: (@le_trans _ _ (x ^ 0)); first by rewrite ler_wneXz2l.\nby rewrite ler_wpeXz2l.\nQed."
}
{
  "statement": "Lemma diag_mxP n (A : 'M[V]_n) :\n  reflect (exists d : 'rV_n, A = diag_mx d) (is_diag_mx A).\n",
  "proof": "Proof.\napply: (iffP (is_diag_mxP A)) => [Adiag|[d ->] i j neq_ij]; last first.\n  by rewrite !mxE -val_eqE (negPf neq_ij).\nexists (\\row_i A i i); apply/matrixP => i j; rewrite !mxE.\nby case: (altP (i =P j)) => [->|/Adiag->].\nQed."
}
{
  "statement": "Lemma subz_ge0 m n : lez 0 (n - m) = lez m n.\n",
  "proof": "Proof.\ncase: (intP m); case: (intP n)=> // {}m {}n /=;\nrewrite ?ltnS -?opprD ?opprB ?subzSS; case: leqP=> // hmn;\nby [ rewrite subzn //\n   | rewrite -opprB subzn ?(ltnW hmn) //;\n      move: hmn; rewrite -subn_gt0; case: (_ - _)%N].\nQed."
}
{
  "statement": "Lemma mulmx_block m1 m2 n1 n2 p1 p2 (Aul : 'M_(m1, n1)) (Aur : 'M_(m1, n2))\n                                    (Adl : 'M_(m2, n1)) (Adr : 'M_(m2, n2))\n                                    (Bul : 'M_(n1, p1)) (Bur : 'M_(n1, p2))\n                                    (Bdl : 'M_(n2, p1)) (Bdr : 'M_(n2, p2)) :\n  block_mx Aul Aur Adl Adr *m block_mx Bul Bur Bdl Bdr\n    = block_mx (Aul *m Bul + Aur *m Bdl) (Aul *m Bur + Aur *m Bdr)\n               (Adl *m Bul + Adr *m Bdl) (Adl *m Bur + Adr *m Bdr).\n",
  "proof": "Proof. by rewrite mul_col_mx !mul_row_block. Qed."
}
{
  "statement": "Lemma dirr_constt_oppI (phi: 'CF(G)) :\n   dirr_constt phi :&: dirr_constt (-phi) = set0.\n",
  "proof": "Proof.\napply/setP=> i; rewrite inE !dirr_consttE cfdotNl inE.\napply/idP=> /andP [L1 L2]; have := ltr_pDl L1 L2.\nby rewrite subrr lt_def eqxx.\nQed."
}
{
  "statement": "Lemma char_poly_det : char_poly`_0 = (- 1) ^+ n * \\det A.\n",
  "proof": "Proof.\nrewrite big_distrr coef_sum [0%N]lock /=; apply: eq_bigr => s _.\nrewrite -{1}rmorphN -rmorphXn mul_polyC coefZ /=.\nrewrite mulrA -exprD addnC exprD -mulrA -lock; congr (_ * _).\ntransitivity (\\prod_(i < n) - A i (s i)); last by rewrite prodrN card_ord.\nelim: (index_enum _) => [|i e IHe]; rewrite !(big_nil, big_cons) ?coef1 //.\nby rewrite coefM big_ord1 IHe !mxE coefB coefC coefMn coefX mul0rn sub0r.\nQed."
}
{
  "statement": "Lemma all_merge (T : Type) (P : {pred T}) (leT : rel T) s1 s2 :\n  all P (merge leT s1 s2) = all P s1 && all P s2.\n",
  "proof": "Proof.\nelim: s1 s2 => //= x s1 IHs1; elim=> [|y s2 IHs2]; rewrite ?andbT //=.\nby case: ifP => _; rewrite /= ?IHs1 ?IHs2 //=; bool_congr.\nQed."
}
{
  "statement": "Lemma leifP x y C : reflect (x <= y ?= iff C) (if C then x == y else x < y).\n",
  "proof": "Proof.\nrewrite /leif le_eqVlt; apply: (iffP idP)=> [|[]].\n  by case: C => [/eqP->|lxy]; rewrite ?eqxx // lxy lt_eqF.\nby move=> /orP[/eqP->|lxy] <-; rewrite ?eqxx // lt_eqF.\nQed."
}
{
  "statement": "Lemma basisEdim X U : basis_of U X = (U <= <<X>>)%VS && (size X <= \\dim U).\n",
  "proof": "Proof.\napply/andP/idP=> [[defU /eqnP <-]| ]; first by rewrite -eqEdim eq_sym.\ncase/andP=> sUX leXU; have leXX := dim_span X.\nrewrite /free eq_sym eqEdim sUX eqn_leq !(leq_trans leXX) //.\nby rewrite (leq_trans leXU) ?dimvS.\nQed."
}
{
  "statement": "Lemma conj_mx_irr : mx_irreducible rGB <-> mx_irreducible rG.\n",
  "proof": "Proof.\nhave Bfree: row_free B by rewrite row_free_unit.\nsplit => /mx_irrP[n_gt0 irrG]; apply/mx_irrP; split=> // U.\n  rewrite -[U](mulmxKV uB) -mxmodule_conj -mxrank_eq0 /row_full mxrankMfree //.\n  by rewrite mxrank_eq0; apply: irrG.\nrewrite -mxrank_eq0 /row_full -(mxrankMfree _ Bfree) mxmodule_conj mxrank_eq0.\nexact: irrG.\nQed."
}
{
  "statement": "Lemma maxainv_exists : K :!=: 1 -> {N : {group rT} | maxainv K N}.\n",
  "proof": "Proof.\nmove=> nt; apply: ex_maxgroup. exists [1 rT]%G.\nrewrite /= normal1 subG1 nt /=.\napply/subsetP=> a Da; rewrite !inE Da /= sub1set !inE.\nby rewrite /= -actmE // morph1 eqxx.\nQed."
}
{
  "statement": "Lemma ler_eXn2l x :\n  1 < x -> {mono GRing.exp x : m n / (m <= n)%N >-> m <= n}.\n",
  "proof": "Proof.\nmove=> xgt1; apply: (le_mono (inj_homo_lt _ _)); last first.\n  by apply: ler_weXn2l; rewrite ltW.\nby apply: ieexprIn; rewrite ?gt_eqF ?gtr_cpable //; apply: lt_trans xgt1.\nQed."
}
{
  "statement": "Lemma common_eigenvector2 {C : numClosedFieldType}n  (A B : 'M[C]_n) :\n  (n > 0)%N -> A *m B = B *m A ->\n  exists2 v : 'rV_n, v != 0 & (stablemx v A) && (stablemx v B).\n",
  "proof": "Proof.\nmove=> n_gt0 AB_comm; have [] := @common_eigenvector _ _ [:: A; B] n_gt0.\n  by move=> A' B'; rewrite !inE => /orP [] /eqP-> /orP [] /eqP->.\nby move=> v v_neq0 /allP vP; exists v; rewrite ?vP ?(mem_head, in_cons, orbT).\nQed."
}
{
  "statement": "Lemma eq_genmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B -> <<A>> = <<B>>)%MS.\n",
  "proof": "Proof.\nmove=> eqAB; rewrite unlock.\nhave{} eqAB: equivmx A (row_full A) =1 equivmx B (row_full B).\n  by move=> C; rewrite /row_full /equivmx !eqAB.\nrewrite (eq_choose eqAB) (choose_id _ (genmx_witnessP B)) //.\nby rewrite -eqAB genmx_witnessP.\nQed."
}
{
  "statement": "Lemma in_segmentDgt0Pr x y z :\n  reflect (forall e, e > 0 -> y \\in `[x - e, z + e]) (y \\in `[x, z]).\n",
  "proof": "Proof.\napply/(iffP idP)=> [xyz e /[dup] e_gt0 /ltW e_ge0 | xyz_e].\n  by rewrite in_itv /= lerBDr !ler_wpDr// (itvP xyz).\nby rewrite in_itv /= ; apply/andP; split; apply/ler_addgt0Pr => ? /xyz_e;\n  rewrite in_itv /= lerBDr => /andP [].\nQed."
}
{
  "statement": "Lemma isom_cast_perm m n eq_m_n : isom setT setT (@cast_perm m n eq_m_n).\n",
  "proof": "Proof.\ncase: {n} _ / eq_m_n; apply/isomP; split.\n  exact/injmP/(in2W (@cast_perm_inj _ _ _)).\nby apply/setP => /= s /[!inE]; apply/imsetP; exists s; rewrite ?inE.\nQed."
}
{
  "statement": "Lemma bigminU (A B : {set I}) F :\n  \\big[min/x]_(i in A :|: B) F i\n  = min (\\big[min/x]_(i in A) F i) (\\big[min/x]_(i in B) F i).\n",
  "proof": "Proof.\napply: le_anti; rewrite le_min bigminUl bigminUr !andbT; apply/bigmin_geP.\nsplit=> [|i /[!in_setU]/orP[iA|iB]]; first by rewrite ge_min bigmin_le_id.\n- by rewrite ge_min bigmin_le_cond.\n- by rewrite ge_min orbC bigmin_le_cond.\nQed."
}
{
  "statement": "Lemma def_pblock P B x : trivIset P -> B \\in P -> x \\in B -> pblock P x = B.\n",
  "proof": "Proof.\nmove/trivIsetP=> tiP PB Bx; have Px: x \\in cover P by apply/bigcupP; exists B.\napply: (contraNeq (tiP _ _ _ PB)); first by rewrite pblock_mem.\nby apply/pred0Pn; exists x; rewrite /= mem_pblock Px.\nQed."
}
{
  "statement": "Lemma eq_bigl_supp (r : seq I) (P1 : pred I) (P2 : pred I) (F : I -> R) :\n  {in [pred x | F x != idx], P1 =1 P2} ->\n  \\big[op/idx]_(i <- r | P1 i) F i = \\big[op/idx]_(i <- r | P2 i) F i.\n",
  "proof": "Proof.\nmove=> P12; rewrite big_mkcond [RHS]big_mkcond; apply: eq_bigr => i _.\nby case: (eqVneq (F i) idx) => [->|/P12->]; rewrite ?if_same.\nQed."
}
{
  "statement": "Lemma astab_setact_in S a : a \\in D -> 'C(to^* S a | to) = 'C(S | to) :^ a.\n",
  "proof": "Proof.\nmove=> Da; apply/setP=> b; rewrite mem_conjg !inE -mem_conjg conjGid //.\napply: andb_id2l => Db; rewrite sub_imset_pre; apply: eq_subset_r => x.\nby rewrite !inE !actMin ?groupM ?groupV // invgK (canF_eq (actKVin Da)).\nQed."
}
{
  "statement": "Lemma mxof_comp (phi : 'Hom(uT, vT)) (psi : 'Hom(vT, wT)) :\n  mxof e g (psi \\o phi)%VF = mxof e f phi *m mxof f g psi.\n",
  "proof": "Proof.\napply/matrixP => i k; rewrite !(mxE, comp_lfunE, lfunE) /=.\nrewrite [phi _](coord_basis f_basis) ?memvf// 2!linear_sum/=.\nby apply: eq_bigr => j _ /=; rewrite !mxE !linearZ/= !vecof_delta.\nQed."
}
{
  "statement": "Lemma dvdCP_nat x y : 0 <= x -> 0 <= y -> (x %| y)%C -> {n | y = n%:R * x}.\n",
  "proof": "Proof.\nmove=> x_ge0 y_ge0 x_dv_y; apply: sig_eqW.\ncase/dvdCP: x_dv_y => z Zz -> in y_ge0 *; move: x_ge0 y_ge0 Zz.\nrewrite le_eqVlt => /predU1P[<- | ]; first by exists 22%N; rewrite !mulr0.\nby move=> /pmulr_lge0-> /intrEge0-> /natrP[n ->]; exists n.\nQed."
}
{
  "statement": "Lemma conjsRg A B x : [~: A, B] :^ x = [~: A :^ x, B :^ x].\n",
  "proof": "Proof.\nwlog suffices: A B x / [~: A, B] :^ x \\subset [~: A :^ x, B :^ x].\n  move=> subJ; apply/eqP; rewrite eqEsubset subJ /= -sub_conjgV.\n  by rewrite -{2}(conjsgK x A) -{2}(conjsgK x B).\nrewrite -genJ gen_subG; apply/subsetP=> _ /imsetP[_ /imset2P[y z Ay Bz ->] ->].\nby rewrite conjRg mem_commg ?memJ_conjg.\nQed."
}
{
  "statement": "Lemma relU_sym e e' :\n  connect_sym e -> connect_sym e' -> connect_sym (relU e e').\n",
  "proof": "Proof.\nmove=> sym_e sym_e'; apply: symmetric_from_pre => x _ /connectP[p e_p ->].\nelim: p x e_p => //= y p IHp x /andP[e_xy /IHp{IHp}/connect_trans]; apply.\ncase/orP: e_xy => /connect1; rewrite (sym_e, sym_e');\n  by apply: connect_sub y x => x y e_xy; rewrite connect1 //= e_xy ?orbT.\nQed."
}
{
  "statement": "Lemma arc_rot i p : uniq p -> {in p, arc (rot i p) =2 arc p}.\n",
  "proof": "Proof.\nmove=> Up x p_x y; congr (fun q => take (index y q) q); move: Up p_x {y}.\nrewrite -{1 2 5 6}(cat_take_drop i p) /rot cat_uniq => /and3P[_ Up12 _].\nrewrite !drop_cat !take_cat !index_cat mem_cat orbC.\ncase p2x: (x \\in drop i p) => /= => [_ | p1x].\n  rewrite index_mem p2x [x \\in _](negbTE (hasPn Up12 _ p2x)) /= addKn.\n  by rewrite ltnNge leq_addr catA.\nby rewrite p1x index_mem p1x addKn ltnNge leq_addr /= catA.\nQed."
}
{
  "statement": "Lemma rank_diag_block_mx m n p q\n    (A : 'M_(m, n)) (B : 'M_(p, q)) :\n  \\rank (block_mx A 0 0 B) = (\\rank A + \\rank B)%N.\n",
  "proof": "Proof.\nrewrite block_mxEv -addsmxE mxrank_disjoint_sum ?rank_row_mx0 ?rank_row_0mx//.\napply/eqP/rowV0P => v; rewrite sub_capmx => /andP[/submxP[x ->]].\nrewrite mul_mx_row mulmx0 => /submxP[y]; rewrite mul_mx_row mulmx0.\nby move=> /eq_row_mx[-> _]; rewrite row_mx0.\nQed."
}
{
  "statement": "Lemma subact_is_action : is_action subact_dom subact.\n",
  "proof": "Proof.\nsplit=> [a u v eq_uv | u a b Na Nb]; apply: val_inj.\n  move/(congr1 val): eq_uv; rewrite !val_subact.\n  by case: (a \\in _); first move/act_inj.\nhave Da := astabs_dom Na; have Db := astabs_dom Nb.\nby rewrite !val_subact Na Nb groupM ?actMin.\nQed."
}
{
  "statement": "Lemma rmodpZ a p : rmodp (a *: p) d = a *: (rmodp p d).\n",
  "proof": "Proof.\ncase: (altP (a =P 0%R)) => [-> | cn0]; first by rewrite !scale0r rmod0p.\nhave -> : ((a *: p) = (a *: (rdivp p d)) * d + a *: (rmodp p d))%R.\n  by rewrite -scalerAl -scalerDr -rdivp_eq.\nrewrite  rmodp_addl_mul_small //.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\n  rewrite size_polyC cn0 addSn add0n /= ltn_rmodp.\nexact: monic_neq0.\nQed."
}
{
  "statement": "Lemma bigmaxU (A B : {set I}) F :\n  \\big[max/x]_(i in A :|: B) F i\n  = max (\\big[max/x]_(i in A) F i) (\\big[max/x]_(i in B) F i).\n",
  "proof": "Proof.\napply: le_anti; rewrite ge_max bigmaxUl bigmaxUr !andbT; apply/bigmax_leP.\nsplit=> [|i /[!in_setU]/orP[iA|iB]]; first by rewrite le_max bigmax_ge_id.\n- by rewrite le_max le_bigmax_cond.\n- by rewrite le_max orbC le_bigmax_cond.\nQed."
}
{
  "statement": "Lemma cfReprReg : cfRepr (regular_repr algC G) = cfReg G.\n",
  "proof": "Proof.\napply/cfun_inP=> x Gx; rewrite cfRegE.\nhave [-> | ntx] := eqVneq x 1%g; first by rewrite cfRepr1.\nrewrite cfunE Gx [\\tr _]big1 // => i _; rewrite 2!mxE /=.\nrewrite -(inj_eq enum_val_inj) gring_indexK ?groupM ?enum_valP //.\nby rewrite eq_mulVg1 mulKg (negbTE ntx).\nQed."
}
{
  "statement": "Lemma truncn_floor x : truncn x = if 0 <= x then `|floor x|%N else 0%N.\n",
  "proof": "Proof.\nmove: (floorP x); rewrite truncEfloor realE.\nhave [/le_floor|_]/= := boolP (0 <= x); first by rewrite floor0; case: floor.\nby case: ifP => [/le_floor|_ /eqP->//]; rewrite floor0; case: floor => [[]|].\nQed."
}
{
  "statement": "Lemma dvdp_exp_sub p q k l: p != 0 ->\n  (p ^+ k %| q * p ^+ l) = (p ^+ (k - l) %| q).\n",
  "proof": "Proof.\nmove=> pn0; case: (leqP k l)=> [|/ltnW] hkl.\n  move: (hkl); rewrite -subn_eq0; move/eqP->; rewrite expr0 dvd1p.\n  exact/dvdp_mull/dvdp_exp2l.\nby rewrite -[in LHS](subnK hkl) exprD dvdp_mul2r // expf_eq0 (negPf pn0) andbF.\nQed."
}
{
  "statement": "Lemma F_s14 :\n   'Fix_to_g[s14]= [set x | (col0 x == col5 x) && (col2 x == col3 x)].\n",
  "proof": "Proof.\nhave s14_inv: s14^-1=s14  by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s14_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //= ].\nQed."
}
{
  "statement": "Lemma primitive_poly_in_qpoly_eq0 p : (in_qpoly h p == 0) = (h %| p).\n",
  "proof": "Proof.\nhave hM : h \\is monic by case/and4P:Hh.\nhave hMi : monic_irreducible_poly h by apply: primitive_mi.\napply/eqP/idP => [/val_eqP /= | hDp].\n  by rewrite -Pdiv.IdomainMonic.modpE mk_monicE.\nby apply/val_eqP; rewrite /= -Pdiv.IdomainMonic.modpE mk_monicE.\nQed."
}
{
  "statement": "Lemma F_s05 :\n  'Fix_to_g[s05] = [set x | (col1 x == col4 x) && (col2 x == col3 x)].\n",
  "proof": "Proof.\nhave s05_inv: s05^-1=s05 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s05_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //= ].\nQed."
}
{
  "statement": "Lemma SCN_max A : A \\in 'SCN(G) -> [max A | A <| G & abelian A].\n",
  "proof": "Proof.\ncase/SCN_P => nAG scA; apply/maxgroupP; split=> [|H].\n  by rewrite nAG /abelian -{1}scA subsetIr.\ndo 2![case/andP]=> sHG _ abelH sAH; apply/eqP.\nby rewrite eqEsubset sAH -scA subsetI sHG centsC (subset_trans sAH).\nQed."
}
{
  "statement": "Lemma coset_splitting_field gT (H : {set gT}) :\n  group_closure_field gT -> group_closure_field (coset_of H).\n",
  "proof": "Proof.\nmove=> split_gT Gbar; have ->: Gbar = (coset H @*^-1 Gbar / H)%G.\n  by apply: val_inj; rewrite /= /quotient morphpreK ?sub_im_coset.\nby apply: quotient_splitting_field; [apply: subsetIl | apply: split_gT].\nQed."
}
{
  "statement": "Lemma all_nthP a s x0 :\n  reflect (forall i, i < size s -> a (nth x0 s i)) (all a s).\n",
  "proof": "Proof.\nrewrite -(eq_all (fun x => negbK (a x))) all_predC.\ncase: (has_nthP _ _ x0) => [na_s | a_s]; [right=> a_s | left=> i lti].\n  by case: na_s => i lti; rewrite a_s.\nby apply/idPn=> na_si; case: a_s; exists i.\nQed."
}
{
  "statement": "Lemma imset_proper (A B : {set aT}) :\n   {in B &, injective f} -> A \\proper B -> f @: A \\proper f @: B.\n",
  "proof": "Proof.\nmove=> injf /properP[sAB [x Bx nAx]]; rewrite properE imsetS //=.\napply: contra nAx => sfBA.\nhave: f x \\in f @: A by rewrite (subsetP sfBA) ?imset_f.\nby case/imsetP=> y Ay /injf-> //; apply: subsetP sAB y Ay.\nQed."
}
{
  "statement": "Lemma cfConjg_eqE phi :\n    H <| G ->\n  {in G &, forall y z, (phi ^ y == phi ^ z)%CF = (z \\in 'I_G[phi] :* y)}.\n",
  "proof": "Proof.\ncase/andP=> _ nHG y z Gy; rewrite -{1 2}[z](mulgKV y) groupMr // mem_rcoset.\nmove: {z}(z * _)%g => z Gz; rewrite 2!inE Gz cfConjgMnorm ?(subsetP nHG) //=.\nby rewrite eq_sym (can_eq (cfConjgK y)).\nQed."
}
{
  "statement": "Lemma cycle_abelem p x : p.-elt x || prime p -> p.-abelem <[x]> = (#[x] %| p).\n",
  "proof": "Proof.\nmove=> p_xVpr; rewrite /abelem cycle_abelian /=.\napply/andP/idP=> [[_ xp1] | x_dvd_p].\n  by rewrite order_dvdn (exponentP xp1) ?cycle_id.\nsplit; last exact: dvdn_trans (exponent_dvdn _) x_dvd_p.\nby case/orP: p_xVpr => // /pnat_id; apply: pnat_dvd.\nQed."
}
{
  "statement": "Lemma transferM : {in G &, {morph transfer : x y / (x * y)%g >-> x + y}}.\n",
  "proof": "Proof.\nmove=> s t Gs Gt /=.\nrewrite [transfer t](reindex_acts 'Rs _ Gs) ?actsRs_rcosets //= -big_split /=.\napply: eq_bigr => _ /rcosetsP[x Gx ->]; rewrite !rcosetE -!rcosetM.\nrewrite -zmodMgE -morphM -?mem_rcoset; first by rewrite !mulgA mulgKV rcosetM.\n  by rewrite rcoset_repr rcosetM mem_rcoset mulgK mem_repr_rcoset.\nby rewrite rcoset_repr (rcosetM _ _ t) mem_rcoset mulgK mem_repr_rcoset.\nQed."
}
{
  "statement": "Lemma intro_closed a : (forall x y, e x y -> x \\in a -> y \\in a) -> closed e a.\n",
  "proof": "Proof.\nmove=> cl_a x y e_xy; apply/idP/idP=> [|a_y]; first exact: cl_a.\nhave{x e_xy} /connectP[p e_p ->]: connect e y x by rewrite sym_e connect1.\nby elim: p y a_y e_p => //= y p IHp x a_x /andP[/cl_a/(_ a_x)]; apply: IHp.\nQed."
}
{
  "statement": "Lemma mx_reducibleS U V :\n    mxmodule U -> (U <= V)%MS ->\n  mx_completely_reducible V -> mx_completely_reducible U.\n",
  "proof": "Proof.\nmove=> modU sUV redV U1 modU1 sU1U.\nhave [W modW defV dxU1W] := redV U1 modU1 (submx_trans sU1U sUV).\nexists (W :&: U)%MS; first exact: capmx_module.\n  by apply/eqmxP; rewrite !matrix_modl // capmxSr sub_capmx defV sUV /=.\nby apply/mxdirect_addsP; rewrite capmxA (mxdirect_addsP dxU1W) cap0mx.\nQed."
}
{
  "statement": "Lemma sub_bigcapmxP P m n (A : 'M_(m, n)) (B_ : I -> 'M_n) :\n  reflect (forall i, P i -> A <= B_ i)%MS (A <= \\bigcap_(i | P i) B_ i)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sAB i Pi | sAB].\n  by apply: (submx_trans sAB); rewrite (bigcapmx_inf Pi).\nby elim/big_rec: _ => [|i Pi C sAC]; rewrite ?submx1 // sub_capmx sAB.\nQed."
}
{
  "statement": "Lemma cfDet_id xi : xi \\is a linear_char -> cfDet xi = xi.\n",
  "proof": "Proof.\nmove=> lin_xi; have /irrP[i Dxi] := lin_char_irr lin_xi.\napply/cfun_inP=> x Gx; rewrite Dxi -irrRepr cfDetRepr !cfunE trace_mx11 mxE.\nmove: lin_xi (_ x) => /andP[_]; rewrite Dxi irr1_degree pnatr_eq1 => /eqP-> X.\nby rewrite {1}[X]mx11_scalar det_scalar1 trace_mx11.\nQed."
}
{
  "statement": "Lemma isometries_iso : forall p, p \\in isometries -> is_iso p.\n",
  "proof": "Proof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> -> a; rewrite !permE; case: a; do 4?case.\nQed."
}
{
  "statement": "Lemma aut_mem_eqP E (x y : coset_of (kAEndf E)) f g : \n  f \\in x -> g \\in y -> reflect {in E, f =1 g} (x == y).\n",
  "proof": "Proof.\nmove=> x_f y_g; rewrite -(coset_mem x_f) -(coset_mem y_g).\nhave [Nf Ng] := (subsetP (coset_norm x) f x_f, subsetP (coset_norm y) g y_g).\nrewrite (sameP eqP (rcoset_kercosetP Nf Ng)) mem_rcoset inE kAutfE.\napply: (iffP kAHomP) => idEfg u Eu.\n  by rewrite -(mulgKV g f) lfunE /= idEfg.\nby rewrite (@lfunE _ _ L) /= idEfg // lker0_lfunK ?AEnd_lker0.\nQed."
}
{
  "statement": "Lemma mx_ind (P : forall m n, 'M[R]_(m, n) -> Type) :\n    (forall m A, P m 0 A) ->\n    (forall n A, P 0 n A) ->\n    (forall m n x r c A, P m n A -> P (1 + m)%N (1 + n)%N (block_mx x r c A)) ->\n  forall m n A, P m n A.\n",
  "proof": "Proof.\nmove=> P0l P0r PS; elim=> [|m IHm] [|n] A; do ?by [apply: P0l|apply: P0r].\nby rewrite -[A](@submxK 1 _ 1); apply: PS.\nQed."
}
{
  "statement": "Lemma prev_cycle p x : cycle e p -> x \\in p -> e (prev p x) x.\n",
  "proof": "Proof.\ncase: p => //= y0 p; rewrite inE orbC.\nelim: p {1 5}y0 => [|z p IHp] y /=; rewrite ?inE.\n  by rewrite andbT; case: (x =P y0) => // ->.\nby case/andP=> eyz /IHp; case: (x =P z) => // ->.\nQed."
}
{
  "statement": "Lemma dir_iso_iso3 : forall p, p \\in dir_iso3  -> is_iso3 p.\n",
  "proof": "Proof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> <- a; rewrite !permE; case: a; do 6?case.\nQed."
}
{
  "statement": "Lemma conjg_is_groupAction : is_groupAction setT conjg_action.\n",
  "proof": "Proof.\nmove=> a _; rewrite inE; apply/andP; split; first by apply/subsetP=> x /[1!inE].\nby apply/morphicP=> x y _ _; rewrite !actpermE /= conjMg.\nQed."
}
{
  "statement": "Lemma map_inj_in_uniq s : {in s &, injective f} -> uniq (map f s) = uniq s.\n",
  "proof": "Proof.\nelim: s => //= x s IHs //= injf; congr (~~ _ && _).\n  apply/mapP/idP=> [[y sy /injf] | ]; last by exists x.\n  by rewrite mem_head mem_behead // => ->.\nby apply: IHs => y z sy sz; apply: injf => //; apply: predU1r.\nQed."
}
{
  "statement": "Lemma rker_norm : G \\subset 'N(rker).\n",
  "proof": "Proof.\napply/subsetP=> x Gx; rewrite inE sub_conjg; apply/subsetP=> y.\ncase/rkerP=> Gy ry1; rewrite mem_conjgV !inE groupJ //=.\nby rewrite !repr_mxM ?groupM ?groupV // ry1 !mulmxA mulmx1 repr_mxKV.\nQed."
}
{
  "statement": "Lemma divnMl p m d : p > 0 -> p * m %/ (p * d) = m %/ d.\n",
  "proof": "Proof.\nmove=> p_gt0; have [->|d_gt0] := posnP d; first by rewrite muln0.\nrewrite [RHS]/divn; case: edivnP; rewrite d_gt0 /= => q r ->{m} lt_rd.\nrewrite mulnDr mulnCA divnMDl; last by rewrite muln_gt0 p_gt0.\nby rewrite addnC divn_small // ltn_pmul2l.\nQed."
}
{
  "statement": "Lemma bigcprod_card_dprod I r (P : pred I) (A : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) A i = G ->\n    \\prod_(i <- r | P i) #|A i| <= #|G| ->\n  \\big[dprod/1]_(i <- r | P i) A i = G.\n",
  "proof": "Proof.\nelim: r G => [|i r IHr]; rewrite !(big_nil, big_cons) //; case: ifP => _ // G.\ncase/cprodP=> [[K H -> defH]]; rewrite defH => <- cKH leKH_G.\nhave /implyP := leq_trans leKH_G (dvdn_leq _ (dvdn_cardMg K H)).\nrewrite muln_gt0 leq_pmul2l !cardG_gt0 //= => /(IHr H defH){}defH.\nby rewrite defH dprodE // cardMg_TI // -(bigdprod_card defH).\nQed."
}
{
  "statement": "Lemma constantP s : reflect (exists x, s = nseq (size s) x) (constant s).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [x ->]]; last exact: constant_nseq.\ncase: s => [|x s] /=; first by exists x0.\nby move/all_pred1P=> def_s; exists x; rewrite -def_s.\nQed."
}
{
  "statement": "Lemma dvdC_nat (p n : nat) : (p %| n)%C = (p %| n)%N.\n",
  "proof": "Proof.\nrewrite unfold_in intrEge0 ?divr_ge0 ?invr_ge0 ?ler0n // !pnatr_eq0.\nhave [-> | nz_p] := eqVneq; first by rewrite dvd0n.\napply/natrP/dvdnP=> [[q def_q] | [q ->]]; exists q.\n  by apply/eqP; rewrite -eqC_nat natrM -def_q divfK ?pnatr_eq0.\nby rewrite [num in num / _]natrM mulfK ?pnatr_eq0.\nQed."
}
{
  "statement": "Lemma egcdpP p q : p != 0 -> q != 0 -> forall (e := egcdp p q),\n  [/\\ size e.1 <= size q, size e.2 <= size p & gcdp p q %= e.1 * p + e.2 * q].\n",
  "proof": "Proof.\nrewrite /egcdp => pn0 qn0; case: (leqP (size q) (size p)) => /= [|/ltnW] hp.\n  exact: egcdp_recP.\ncase: (egcdp_recP pn0 (leqnn (size p)) hp) => h1 h2 h3; split => //.\nby rewrite (eqp_ltrans (gcdpC _ _)) addrC.\nQed."
}
{
  "statement": "Lemma lker0_img_cap f U V : lker f == 0%VS ->\n  (f @: (U :&: V) = f @: U :&: f @: V)%VS.\n",
  "proof": "Proof.\nmove=> kf0; apply/eqP; rewrite eqEsubv limg_cap/=; apply/subvP => x.\nrewrite memv_cap => /andP[/memv_imgP[u uU ->]] /memv_imgP[v vV].\nby move=> /(lker0P _ kf0) eq_uv; rewrite memv_img// memv_cap uU eq_uv vV.\nQed."
}
{
  "statement": "Lemma rV_subP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (forall v : 'rV_n, v <= A -> v <= B)%MS (A <= B)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sAB v Av | sAB]; first exact: submx_trans sAB.\nby apply/row_subP=> i; rewrite sAB ?row_sub.\nQed."
}
{
  "statement": "Lemma leif_trans x1 x2 x3 C12 C23 :\n  x1 <= x2 ?= iff C12 -> x2 <= x3 ?= iff C23 -> x1 <= x3 ?= iff C12 && C23.\n",
  "proof": "Proof.\nmove=> ltx12 ltx23; apply/leifP; rewrite -ltx12.\ncase eqx12: (x1 == x2).\n  by rewrite (eqP eqx12) lt_neqAle !ltx23 andbT; case C23.\nby rewrite (@lt_le_trans x2) ?ltx23 // lt_neqAle eqx12 ltx12.\nQed."
}
{
  "statement": "Lemma F_r23 : 'Fix_to_g[r23] =\n  [set x | (col0 x == col1 x) && (col1 x == col4 x)\n                                && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r23_inv: r23^-1 = r32 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r23_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col0/col5/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma F_r32 : 'Fix_to_g[r32] =\n  [set x | (col0 x == col1 x) && (col1 x == col4 x)\n                                && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r32_inv: r32^-1 = r23 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r32_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col0/col5/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed."
}
{
  "statement": "Lemma remgr_id x : x \\in H -> remgr K H x = x.\n",
  "proof": "Proof.\nmove=> Hx; apply/eqP; rewrite eq_mulgV1 (sameP eqP set1gP) -tiKH inE.\nrewrite -mem_rcoset groupMr ?groupV // -in_setI remgrP.\nby apply: subsetP Hx; apply: mulG_subr.\nQed."
}
{
  "statement": "Lemma sum_mxsimple_direct_sub I W (V : 'M_n) :\n    (forall i : I, mxsimple (W i)) -> (\\sum_i W i :=: V)%MS ->\n  {J : {set I} | let S := \\sum_(i in J) W i in S :=: V /\\ mxdirect S}%MS.\n",
  "proof": "Proof.\nmove=> simW defV.\nhave [|J [defS dxS]] := sum_mxsimple_direct_compl simW (mxmodule0 n).\n  exact: sub0mx.\nexists J; split; last by rewrite mxdirectE /= adds0mx mxrank0 in dxS.\nby apply: eqmx_trans defV; rewrite adds0mx_id in defS.\nQed."
}
{
  "statement": "Lemma morphpre_gen R :\n  1 \\in R -> R \\subset f @* D -> f @*^-1 <<R>> = <<f @*^-1 R>>.\n",
  "proof": "Proof.\nmove=> R1 sRfD; apply/eqP.\nrewrite eqEsubset andbC gen_subG morphpreS; last exact: subset_gen.\nrewrite -{1}(morphpreK sRfD) -morphim_gen ?subsetIl // morphimGK //=.\n  by rewrite sub_gen // setIS // preimsetS ?sub1set.\nby rewrite gen_subG subsetIl.\nQed."
}
{
  "statement": "Lemma abelem_homocyclic p G : p.-abelem G -> homocyclic G.\n",
  "proof": "Proof.\nmove=> abelG; have [_ cGG _] := and3P abelG.\nrewrite /homocyclic cGG (@all_pred1_constant _ p) //.\ncase/abelian_structure: cGG (abelian_type_gt1 G) => b defG <- => b_gt1.\napply/allP=> _ /mapP[x b_x ->] /=; rewrite (abelem_order_p abelG) //.\n  rewrite -cycle_subG -(bigdprodWY defG) ?sub_gen //.\n  by rewrite bigcup_seq (bigcup_sup x).\nby rewrite -order_gt1 [_ > 1](allP b_gt1) ?map_f.\nQed."
}
{
  "statement": "Lemma truncn_def x n : n%:R <= x < n.+1%:R -> truncn x = n.\n",
  "proof": "Proof.\ncase/andP=> lemx ltxm1; apply/eqP; rewrite eqn_leq -ltnS -[(n <= _)%N]ltnS.\nhave/truncn_itv/andP[lefx ltxf1]: 0 <= x by apply: le_trans lemx; apply: ler0n.\nby rewrite -!(ltr_nat R) 2?(@le_lt_trans _ _ x).\nQed."
}
{
  "statement": "Lemma cfdot_Res_conjg psi phi y :\n  y \\in G -> '['Res[H, G] psi, phi ^ y] = '['Res[H] psi, phi].\n",
  "proof": "Proof.\nmove=> Gy; rewrite -(cfConjg_iso y _ phi); congr '[_, _]; apply/cfunP=> x.\nrewrite !cfunElock !genGid; case nHy: (y \\in 'N(H)) => //.\nby rewrite !(fun_if psi) cfunJ ?memJ_norm ?groupV.\nQed."
}
{
  "statement": "Lemma iso3_ndir : forall p, p \\in dir_iso3  -> is_iso3 (s0 * p).\n",
  "proof": "Proof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> <- a; rewrite !(permM, permE); case: a; do 6?case.\nQed."
}
{
  "statement": "Lemma gactP : is_groupAction [set: 'Z_p * 'Z_p] action.\n",
  "proof": "Proof.\nmove=> k _ /[1!inE]; apply/andP; split; first by apply/subsetP=> ij _ /[1!inE].\napply/morphicP=> /= [[i1 j1] [i2 j2] _ _].\nby rewrite !permE /= mulrDr -addrA (addrCA i2) (addrA i1).\nQed."
}
{
  "statement": "Lemma dvdp1 d : (d %| 1) = (size d == 1).\n",
  "proof": "Proof.\nrewrite /dvdp modpE; case ud: (lead_coef d \\in GRing.unit); last exact: rdvdp1.\nrewrite -size_poly_eq0 size_scale; first by rewrite size_poly_eq0 -rdvdp1.\nby rewrite invr_eq0 expf_neq0 //; apply: contraTneq ud => ->; rewrite unitr0.\nQed."
}
{
  "statement": "Lemma fpath_finv_in p x :\n  (x \\in S) && (fpath finv x p) =\n    (last x p \\in S) && (fpath f (last x p) (rev (belast x p))).\n",
  "proof": "Proof.\nelim: p x => //= y p IHp x; rewrite rev_cons rcons_path.\ntransitivity [&& y \\in S, f y == x & fpath finv y p].\n  apply/and3P/and3P => -[xS /eqP<- fxp]; split;\n  by rewrite ?f_finv_in ?finv_f_in ?finv_in ?f_in.\nrewrite andbCA {}IHp !andbA [RHS]andbC -andbA; congr [&& _, _ & _].\nby case: p => //= z p; rewrite rev_cons last_rcons.\nQed."
}
{
  "statement": "Lemma isog_dprod A B G C D L :\n  A \\x B = G -> C \\x D = L -> isog A C -> isog B D -> isog G L.\n",
  "proof": "Proof.\nmove=> defG {C D} /dprodP[[C D -> ->] defL cCD trCD].\ncase/dprodP: defG (defG) => {A B} [[A B -> ->] defG _ _] dG defC defD.\ncase/isogP: defC defL cCD trCD => fA injfA <-{C}.\ncase/isogP: defD => fB injfB <-{D} defL cCD trCD.\napply/isogP; exists (dprodm_morphism dG cCD).\n  by rewrite injm_dprodm injfA injfB trCD eqxx.\nby rewrite /= -{2}defG morphim_dprodm.\nQed."
}
{
  "statement": "Lemma polyOver_subvs {K} {p : {poly L}} :\n  reflect (exists q : {poly subvs_of K}, p = map_poly vsval q)\n          (p \\is a polyOver K).\n",
  "proof": "Proof.\napply: (iffP polyOverP) => [Hp | [q ->] i]; last by rewrite coef_map // subvsP.\nexists (\\poly_(i < size p) (Subvs (Hp i))); rewrite -{1}[p]coefK.\nby apply/polyP=> i; rewrite coef_map !coef_poly; case: ifP.\nQed."
}
{
  "statement": "Lemma splittingFieldForS (K M E : {subfield L}) p :\n    (K <= M)%VS -> (M <= E)%VS ->\n  splittingFieldFor K p E -> splittingFieldFor M p E.\n",
  "proof": "Proof.\nmove=> sKM sKE [rs Dp genL]; exists rs => //; apply/eqP.\nrewrite eqEsubv -[in X in _ && (X <= _)%VS]genL adjoin_seqSl // andbT.\nby apply/Fadjoin_seqP; split; rewrite // -genL; apply: seqv_sub_adjoin.\nQed."
}
{
  "statement": "Lemma dvdp_rat_int p q : (pZtoQ p %| pZtoQ q) = (p %| q).\n",
  "proof": "Proof.\napply/dvdpP/Pdiv.Idomain.dvdpP=> [[/= r1 Dq] | [[/= a r] nz_a Dq]]; last first.\n  exists (a%:~R^-1 *: pZtoQ r).\n  by rewrite -scalerAl -rmorphM -Dq /= linearZ/= scalerK ?intr_eq0.\nhave [r [a nz_a Dr1]] := rat_poly_scale r1; exists (a, r) => //=.\napply: (map_inj_poly _ _ : injective pZtoQ) => //; first exact: intr_inj.\nby rewrite linearZ /= Dq Dr1 -scalerAl -rmorphM scalerKV ?intr_eq0.\nQed."
}
{
  "statement": "Lemma dirrP f :\n  reflect (exists b : bool, exists i, f = (-1) ^+ b *: 'chi_i) (f \\in dirr G).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [b [i ->]]]; last by rewrite dirr_sign irr_dirr.\ncase/orP=> /irrP[i Hf]; first by exists false, i; rewrite scale1r.\nby exists true, i; rewrite scaleN1r -Hf opprK.\nQed."
}
{
  "statement": "Lemma F_s5 : 'Fix_to_g[s5] =\n  [set x | (col0 x == col2 x) && (col1 x == col4  x) && (col3 x == col5 x)].\n",
  "proof": "Proof.\nhave s5_inv: s5^-1 = s5 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s5_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_s6 : 'Fix_to_g[s6] =\n  [set x | (col0 x == col3 x) && (col1 x == col4  x) && (col2 x == col5 x)].\n",
  "proof": "Proof.\nhave s6_inv: s6^-1 = s6 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s6_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma conjC_charAut u (chi : 'CF(G)) x :\n  chi \\is a character -> (u (chi x))^* = u (chi x)^*.\n",
  "proof": "Proof.\nhave [Gx | /cfun0->] := boolP (x \\in G); last by rewrite !rmorph0.\ncase/char_reprP=> rG ->; have [e [_ [en1 _] [-> _] _]] := repr_rsim_diag rG Gx.\nby rewrite !rmorph_sum; apply: eq_bigr => i _; apply: aut_unity_rootC (en1 i).\nQed."
}
{
  "statement": "Lemma cfRes_sub_ker phi : H \\subset cfker phi -> 'Res[H, G] phi = (phi 1%g)%:A.\n",
  "proof": "Proof.\nmove=> kerHphi; have sHG := subset_trans kerHphi (cfker_sub phi).\napply/cfun_inP=> x Hx; have ker_x := subsetP kerHphi x Hx.\nby rewrite cfResE // cfunE cfun1E Hx mulr1 cfker1.\nQed."
}
{
  "statement": "Lemma bigcprodEY I r (P : pred I) (H : I -> {group gT}) G :\n    abelian G -> (forall i, P i -> H i \\subset G) ->\n  \\big[cprod/1]_(i <- r | P i) H i = (\\prod_(i <- r | P i) H i)%G.\n",
  "proof": "Proof.\nmove=> cGG sHG; apply/eqP; rewrite !(big_tnth _ _ r).\nby apply/bigcprodYP=> i j Pi Pj _; rewrite (sub_abelian_cent2 cGG) ?sHG.\nQed."
}
{
  "statement": "Lemma horner_mx_conj m n p (B : 'M[F]_(n.+1, m.+1)) (f : 'M_m.+1) :\n   row_free B -> stablemx B f ->\n   horner_mx (conjmx B f) p = conjmx B (horner_mx f p).\n",
  "proof": "Proof.\nmove=> B_free B_stab; rewrite/conjmx; elim/poly_ind: p => [|p c].\n  by rewrite !rmorph0 mulmx0 mul0mx.\nrewrite !(rmorphD, rmorphM)/= !(horner_mx_X, horner_mx_C) => ->.\nrewrite [_ * _]mulmxA [_ *m (B *m _)]mulmxA mulmxKpV ?horner_mx_stable//.\napply: (row_free_inj B_free); rewrite [_ *m B]mulmxDl.\npose stablemxE := (stablemxD, stablemxM, stablemxC, horner_mx_stable).\nby rewrite !mulmxKpV -?[B *m _ *m _]mulmxA ?stablemxE// mulmxDr -scalar_mxC.\nQed."
}
{
  "statement": "Lemma horner_mx_conj m n p (V : 'M[F]_(n.+1, m.+1)) (f : 'M_m.+1) :\n   row_free V -> stablemx V f ->\n   horner_mx (conjmx V f) p = conjmx V (horner_mx f p).\n",
  "proof": "Proof.\nmove=> V_free V_stab; rewrite/conjmx; elim/poly_ind: p => [|p c].\n  by rewrite !rmorph0 mulmx0 mul0mx.\nrewrite !(rmorphD, rmorphM)/= !(horner_mx_X, horner_mx_C) => ->.\nrewrite [_ * _]mulmxA [_ *m (V *m _)]mulmxA mulmxKpV ?horner_mx_stable//.\napply: (row_free_inj V_free); rewrite [_ *m V]mulmxDl.\npose stablemxE := (stablemxD, stablemxM, stablemxC, horner_mx_stable).\nby rewrite !mulmxKpV -?[V *m _ *m _]mulmxA ?stablemxE// mulmxDr -scalar_mxC.\nQed."
}
{
  "statement": "Lemma Zp_unitmM : {in units_Zp #[a] &, {morph Zp_unitm : u v / u * v}}.\n",
  "proof": "Proof.\nmove=> u v _ _; apply: (eq_Aut (Aut_aut _ _)) => [|x a_x].\n  by rewrite groupM ?Aut_aut.\nrewrite permM !autE ?groupX //= /cyclem -expgM.\nrewrite -expg_mod_order modn_dvdm ?expg_mod_order //.\ncase: (leqP #[a] 1) => [lea1 | lt1a]; last by rewrite Zp_cast ?order_dvdG.\nby rewrite card_le1_trivg // in a_x; rewrite (set1P a_x) order1 dvd1n.\nQed."
}
{
  "statement": "Lemma p'group_quotient_cent_prime :\n  prime p -> #|C| %| p -> p^'.-group (G / 'C_G(C)).\n",
  "proof": "Proof.\nmove=> p_pr pC; have pgC: p.-group C := pnat_dvd pC (pnat_id p_pr).\nhave [_ dv_p] := primeP p_pr; case/pred2P: {dv_p pC}(dv_p _ pC) => [|pC].\n  by move/card1_trivg->; rewrite cent1T setIT trivg_quotient pgroup1.\nhave le_oGC := logn_quotient_cent_cyclic_pgroup pgC.\nrewrite /pgroup -partn_eq1 ?cardG_gt0 // -dvdn1 p_part pfactor_dvdn // logn1.\nby rewrite (leq_trans (le_oGC _)) ?prime_cyclic // pC ?(pfactorK 1).\nQed."
}
{
  "statement": "Lemma semiprimeS K1 K2 A1 A2 :\n  K1 \\subset K2 -> A1 \\subset A2 -> semiprime K2 A2 -> semiprime K1 A1.\n",
  "proof": "Proof.\nmove=> sK12 sA12 prKA2 x /setD1P[ntx A1x].\napply/eqP; rewrite eqEsubset andbC -{1}cent_set1 setIS ?centS ?sub1set //=.\nrewrite -(setIidPl sK12) -!setIA prKA2 ?setIS ?centS //.\nby rewrite !inE ntx (subsetP sA12).\nQed."
}
{
  "statement": "Lemma subGcfker G i : (G \\subset cfker 'chi[G]_i) = (i == 0).\n",
  "proof": "Proof.\nrewrite -irr_eq1; apply/idP/eqP=> [chiG1 | ->]; last by rewrite cfker_cfun1.\napply/cfun_inP=> x Gx; rewrite cfun1E Gx cfker1 ?(subsetP chiG1) ?lin_char1 //.\nby rewrite lin_irr_der1 (subset_trans (der_sub 1 G)).\nQed."
}
{
  "statement": "Lemma sub_normal_Hall pi G H K :\n  pi.-Hall(G) H -> H <| G -> K \\subset G -> (K \\subset H) = pi.-group K.\n",
  "proof": "Proof.\nmove=> hallH nsHG sKG; apply/idP/idP=> [sKH | piK].\n  by rewrite (pgroupS sKH) ?(pHall_pgroup hallH).\napply: norm_sub_max_pgroup (Hall_max hallH) piK _ _ => //.\nexact: subset_trans sKG (normal_norm nsHG).\nQed."
}
{
  "statement": "Lemma mxsimpleP U :\n  [/\\ mxmodule U, U != 0 & ~ mxnonsimple U] <-> mxsimple U.\n",
  "proof": "Proof.\ndo [split => [] [modU nzU simU]; split] => // [V modV sVU nzV | [V]].\n  apply/idPn; rewrite -(ltn_leqif (mxrank_leqif_sup sVU)) => ltVU.\n  by case: simU; exists V; apply/and4P.\nby case/and4P=> modV sVU nzV; apply/negP; rewrite -leqNgt mxrankS ?simU.\nQed."
}
{
  "statement": "Lemma index_morphim_ker G H :\n    H \\subset G -> G \\subset D ->\n  (#|f @* G : f @* H| * #|'ker_G f : H|)%N = #|G : H|.\n",
  "proof": "Proof.\nmove=> sHG sGD; apply/eqP.\nrewrite -(eqn_pmul2l (cardG_gt0 (f @* H))) mulnA Lagrange ?morphimS //.\nrewrite !card_morphim (setIidPr sGD) (setIidPr (subset_trans sHG sGD)).\nrewrite -(eqn_pmul2l (cardG_gt0 ('ker_H f))) /=.\nby rewrite -{1}(setIidPr sHG) setIAC mulnCA mulnC mulnA !LagrangeI Lagrange.\nQed."
}
{
  "statement": "Lemma mxdirect_addsE (S1 : mxsum_expr m1 n) (S2 : mxsum_expr m2 n) :\n   mxdirect (unwrap S1 + unwrap S2)\n    = [&& mxdirect (unwrap S1), mxdirect (unwrap S2)\n        & unwrap S1 :&: unwrap S2 == 0]%MS.\n",
  "proof": "Proof.\nrewrite (@mxdirectE n) /=.\nhave:= leqif_add (mxrank_sum_leqif S1) (mxrank_sum_leqif S2).\nmove/(leqif_trans (mxrank_adds_leqif (unwrap S1) (unwrap S2)))=> ->.\nby rewrite andbC -andbA submx0.\nQed."
}
{
  "statement": "Lemma mask_cat m1 m2 s1 s2 :\n  size m1 = size s1 -> mask (m1 ++ m2) (s1 ++ s2) = mask m1 s1 ++ mask m2 s2.\n",
  "proof": "Proof. by move: m1 s1; apply: seq_ind2 => // -[] m1 x1 s1 /= _ ->. Qed."
}
{
  "statement": "Lemma algC_pfactorCE (x : algC) : x \\isn't Creal ->\n  algC_pfactor x = ('X - x%:P) * ('X - x^*%:P).\n",
  "proof": "Proof.\nmove=> xNR; rewrite algR_pfactorCE//=.\nrewrite rmorphD /= rmorphB/= !map_polyZ !map_polyXn/= map_polyX.\nrewrite (map_polyC algRval)/=.\nrewrite mulrBl !mulrBr -!addrA; congr (_ + _).\nrewrite opprD addrA opprK -opprD -rmorphM/= -normCK; congr (- _ + _).\nrewrite mulrC !mul_polyC -scalerDl.\nrewrite [x in RHS]algCrect conjC_rect ?Creal_Re ?Creal_Im//.\nby rewrite addrACA addNr addr0.\nQed."
}
{
  "statement": "Lemma group_modl A B G : A \\subset G -> A * (B :&: G) = A * B :&: G.\n",
  "proof": "Proof.\nmove=> sAG; apply/eqP; rewrite eqEsubset subsetI mulgS ?subsetIl //.\nrewrite -{2}mulGid mulgSS ?subsetIr //.\napply/subsetP => _ /setIP[/mulsgP[a b Aa Bb ->] Gab].\nby rewrite mem_mulg // inE Bb -(groupMl _ (subsetP sAG _ Aa)).\nQed."
}
{
  "statement": "Lemma pchar_poly : [pchar {poly R}] =i [pchar R].\n",
  "proof": "Proof.\nmove=> p; rewrite !inE; congr (_ && _).\napply/eqP/eqP=> [/(congr1 val) /=|]; last by rewrite -polyC_natr => ->.\nby rewrite polyseq0 -polyC_natr polyseqC; case: eqP.\nQed."
}
{
  "statement": "Lemma bigcup_setU A B F :\n  \\bigcup_(i in A :|: B) F i =\n     (\\bigcup_(i in A) F i) :|: (\\bigcup_ (i in B) F i).\n",
  "proof": "Proof.\napply/setP=> x; apply/bigcupP/setUP=> [[i] | ].\n  by case/setUP; [left | right]; apply/bigcupP; exists i.\nby case=> /bigcupP[i Pi]; exists i; rewrite // inE Pi ?orbT.\nQed."
}
{
  "statement": "Lemma lin_charM : {in G &, {morph xi : x y / (x * y)%g >-> x * y}}.\n",
  "proof": "Proof.\nmove=> x y Gx Gy; case/andP: CFxi => /char_reprP[[n rG] -> /=].\nrewrite cfRepr1 pnatr_eq1 => /eqP n1; rewrite {n}n1 in rG *.\nrewrite !cfunE Gx Gy groupM //= !mulr1n repr_mxM //.\nby rewrite [rG x]mx11_scalar [rG y]mx11_scalar -scalar_mxM !mxtrace_scalar.\nQed."
}
{
  "statement": "Lemma xcprod_subproof :\n  {gz : {morphism 'Z(H) >-> gt_ isob} | isom 'Z(H) 'Z(G_ isob) gz}.\n",
  "proof": "Proof.\ncase: (pickP [pred f : {ffun _} | misom 'Z(H) 'Z(K) f]) => [f isoZ | no_f].\n  rewrite (misom_isog isoZ); case/andP: isoZ => fM isoZ.\n  by exists [morphism of morphm fM].\nmove/pred0P: no_f => not_isoZ; rewrite [isob](congr1 negb not_isoZ).\nby exists (idm_morphism  _); apply/isomP; rewrite injm_idm im_idm.\nQed."
}
{
  "statement": "Lemma rmodpp p : GRing.comm p (lead_coef p)%:P -> rmodp p p = 0.\n",
  "proof": "Proof.\nmove=> hC; rewrite /rmodp unlock; have [-> //|] := eqVneq.\nrewrite -size_poly_eq0 /redivp_rec; case sp: (size p)=> [|n] // _.\nrewrite sp ltnn subnn expr0 hC alg_polyC !simp subrr.\nby case: n sp => [|n] sp; rewrite size_polyC /= eqxx.\nQed."
}
{
  "statement": "Lemma fcard_gt0P (a : {pred T}) : \n  fclosed f a -> reflect (exists x, x \\in a) (0 < fcard f a).\n",
  "proof": "Proof.\nmove=> clfA; apply: (iffP card_gt0P) => [[x /andP[]]|[x xA]]; first by exists x.\nexists (froot f x); rewrite inE roots_root /=; last exact: fconnect_sym.\nby rewrite -(closed_connect clfA (connect_root _ x)).\nQed."
}
{
  "statement": "Lemma mem_zchar_on S A phi :\n  phi \\in 'CF(G, A) -> phi \\in S -> phi \\in 'Z[S, A].\n",
  "proof": "Proof.\nmove=> Aphi /(@tnthP _ _ (in_tuple S))[i Dphi]; rewrite inE /= {}Aphi {phi}Dphi.\napply/sumboolP; exists [ffun j => (j == i)%:Z].\nrewrite (bigD1 i) //= ffunE eqxx (tnth_nth 0) big1 ?addr0 // => j i'j.\nby rewrite ffunE (negPf i'j).\nQed."
}
{
  "statement": "Lemma F_r012 : 'Fix_to_g[r012] =\n  [set x | (col0 x == col2 x) && (col2 x == col1  x) && (col3 x == col4 x)\n       && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r012_inv: r012^-1 = r021 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r012_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r021 : 'Fix_to_g[r021] =\n  [set x | (col0 x == col2 x) && (col2 x == col1  x) && (col3 x == col4 x)\n       && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r021_inv: r021^-1 = r012 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r021_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\ndo 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r034 : 'Fix_to_g[r034] =\n  [set x | (col0 x == col4 x) && (col4 x == col3  x) && (col1 x == col2 x)\n       && (col2 x == col5 x)].\n",
  "proof": "Proof.\nhave r034_inv: r034^-1 = r043 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r034_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r043 : 'Fix_to_g[r043] =\n  [set x | (col0 x == col4 x) && (col4 x == col3  x) && (col1 x == col2 x)\n       && (col2 x == col5 x)].\n",
  "proof": "Proof.\nhave r043_inv: r043^-1 = r034 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r043_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma morphicP : reflect {in A &, {morph f : x y / x * y}} (morphic f).\n",
  "proof": "Proof.\napply: (iffP forallP) => [fM x y Ax Ay | fM [x y] /=].\n  by apply/eqP; have:= fM (x, y); rewrite inE /= Ax Ay.\nby apply/implyP=> /andP[Ax Ay]; rewrite fM.\nQed."
}
{
  "statement": "Lemma F_r013 : 'Fix_to_g[r013] =\n  [set x | (col0 x == col3 x) && (col3 x == col1  x) && (col2 x == col4 x)\n       && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r013_inv: r013^-1 = r031 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r013_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r024 : 'Fix_to_g[r024] =\n  [set x | (col0 x == col4 x) && (col4 x == col2  x) && (col1 x == col3 x)\n       && (col3 x == col5 x) ].\n",
  "proof": "Proof.\nhave r024_inv: r024^-1 = r042 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r024_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r031 : 'Fix_to_g[r031] =\n  [set x | (col0 x == col3 x) && (col3 x == col1  x) && (col2 x == col4 x)\n       && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave r031_inv: r031^-1 = r013 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r031_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_r042 : 'Fix_to_g[r042] =\n  [set x | (col0 x == col4 x) && (col4 x == col2  x) && (col1 x == col3 x)\n       && (col3 x == col5 x)].\n",
  "proof": "Proof.\nhave r042_inv: r042^-1 = r024 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r042_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma F_s4 : 'Fix_to_g[s4] =\n  [set x | (col0 x == col4 x) && (col1 x == col5  x) && (col2 x == col3 x)].\n",
  "proof": "Proof.\nhave s4_inv: s4^-1 = s4 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s4_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma count_sort (p : pred T) s : count p (sort s) = count p s.\n",
  "proof": "Proof.\nrewrite sortE -[RHS]/(sumn [seq count p x | x <- [::]] + count p s).\nelim: s [::] => [|x s ihs] ss.\n  rewrite [LHS]/=; elim: ss [::] => //= s ss ihss t.\n  by rewrite ihss count_merge count_cat addnCA addnA.\nrewrite {}ihs -[in RHS]cat1s count_cat addnA; congr addn; rewrite addnC.\nelim: {x s} ss [:: x] => [|[|x s] ss ihss] t //.\nby rewrite [LHS]/= add0n ihss count_merge count_cat -addnA addnCA.\nQed."
}
{
  "statement": "Lemma sub_in_allrel\n      {T S : Type} (P : {pred T}) (Q : {pred S}) (r r' : T -> S -> bool) :\n  {in P & Q, forall x y, r x y -> r' x y} ->\n  forall xs ys, all P xs -> all Q ys -> allrel r xs ys -> allrel r' xs ys.\n",
  "proof": "Proof.\nmove=> rr' + ys; elim=> //= x xs IHxs /andP [Px Pxs] Qys.\nrewrite !allrel_consl => /andP [+ {}/IHxs-> //]; rewrite andbT.\nby elim: ys Qys => //= y ys IHys /andP [Qy Qys] /andP [/rr'-> // /IHys->].\nQed."
}
{
  "statement": "Lemma exp_orderC x : x ^+ #[x]%C = 1.\n",
  "proof": "Proof.\nrewrite /orderC; case: pickP => //= [] [n _] /= /eqP Dp.\nhave n_gt0: (0 < n)%N.\n  rewrite lt0n; apply: contraTneq (size_minCpoly x) => n0.\n  by rewrite Dp n0 Cyclotomic0 rmorph1 size_poly1.\nhave [z prim_z] := C_prim_root_exists n_gt0.\nrewrite prim_expr_order // -(root_cyclotomic prim_z).\nby rewrite -Cintr_Cyclotomic // -Dp root_minCpoly.\nQed."
}
{
  "statement": "Lemma rot_r1 : forall r, is_rot r -> r = r1 ^+ (r c0).\n",
  "proof": "Proof.\nmove=> r hr; apply: rot_eq_c0 => //; apply/eqP.\n   by symmetry; apply: commuteX.\nby case: (r c0); do 4?case=> //=; rewrite ?permM !permE  /=.\nQed."
}
{
  "statement": "Lemma infixE s1 s2 : infix s1 s2 =\n   (take (size s1) (drop (infix_index s1 s2) s2) == s1).\n",
  "proof": "Proof.\nelim: s2 s1 => [|y s2 +] [|x s1]//= => -> /=.\nby case: ifP => // /andP[/eqP-> ps1s2/=]; rewrite eqseq_cons -prefixE eqxx.\nQed."
}
{
  "statement": "Lemma adjoin_separable : separable_element <<K; y>> x -> separable_element K x.\n",
  "proof": "Proof.\nhave /Derivation_separableP derKy := sepKy => /Derivation_separableP derKy_x.\nhave [z defKz] := Primitive_Element_Theorem.\nsuffices /adjoin_separableP: separable_element K z.\n  by apply; rewrite -defKz memv_adjoin.\napply/Derivation_separableP=> D; rewrite -defKz => derKxyD DK_0.\nsuffices derKyD: Derivation <<K; y>>%VS D by rewrite derKy_x // derKy.\nby apply: DerivationS derKxyD; apply: subv_adjoin.\nQed."
}
{
  "statement": "Lemma injmP : reflect {in D &, injective f} ('injm f).\n",
  "proof": "Proof.\napply: (iffP subsetP) => [injf x y Dx Dy | injf x /= Kx].\n  by case/ker_rcoset=> // z /injf/set1P->; rewrite mul1g.\nhave Dx := dom_ker Kx; apply/set1P/injf => //.\nby apply/rcoset_kerP; rewrite // mulg1.\nQed."
}
{
  "statement": "Lemma dvdpP p q : reflect (exists qq, p = qq * q) (q %| p).\n",
  "proof": "Proof.\nhave [-> | qn0] := eqVneq q 0; last first.\n  by apply: IdomainUnit.dvdpP; rewrite unitfE lead_coef_eq0.\nby rewrite dvd0p; apply: (iffP eqP) => [->| [? ->]]; [exists 1|]; rewrite mulr0.\nQed."
}
{
  "statement": "Lemma orthogonalE us vs : (orthogonal form us vs) = (<<us>> '_|_ <<vs>>)%VS.\n",
  "proof": "Proof.\napply/orthogonalP/orthovP => uvsP u v; last first.\n  by move=> uus vvs; rewrite uvsP // memv_span.\nrewrite -[us]in_tupleE -[vs]in_tupleE => /coord_span-> /coord_span->.\nrewrite linear_sumr big1 //= => i _.\nrewrite linear_sumlz big1 //= => j _.\nby rewrite linearZlr/= uvsP ?mulr0// mem_nth.\nQed."
}
{
  "statement": "Lemma leq_bigmax_seq (I : eqType) r (P : pred I) F i0 :\n  i0 \\in r -> P i0 -> F i0 <= \\max_(i <- r | P i) F i.\n",
  "proof": "Proof.\nmove=> + Pi0; elim: r => // h t ih; rewrite inE big_cons.\nmove=> /predU1P[<-|i0t]; first by rewrite Pi0 leq_maxl.\nby case: ifPn => Ph; [rewrite leq_max ih// orbT|rewrite ih].\nQed."
}
{
  "statement": "Lemma num_itv_add_boundl (x1 x2 : R) b1 b2 :\n  (num_itv_bound R b1 <= BLeft x1)%O -> (num_itv_bound R b2 <= BLeft x2)%O ->\n  (num_itv_bound R (add_boundl b1 b2) <= BLeft (x1 + x2)%R)%O.\n",
  "proof": "Proof.\ncase: b1 b2 => [bb1 b1 |//] [bb2 b2 |//].\ncase: bb1; case: bb2; rewrite /= !bnd_simp mulrzDr.\n- exact: lerD.\n- exact: ler_ltD.\n- exact: ltr_leD.\n- exact: ltrD.\nQed."
}
{
  "statement": "Lemma imsetI (A B : {set aT}) :\n  {in A & B, injective f} -> f @: (A :&: B) = f @: A :&: f @: B.\n",
  "proof": "Proof.\nmove=> injf; apply/eqP; rewrite eqEsubset subsetI.\nrewrite 2?imsetS (andTb, subsetIl, subsetIr) //=.\napply/subsetP=> _ /setIP[/imsetP[x Ax ->] /imsetP[z Bz /injf eqxz]].\nby rewrite imset_f // inE Ax eqxz.\nQed."
}
{
  "statement": "Lemma coprimep_unit (p : {poly %/ h}) : p != 0%R -> coprimep hQ p.\n",
  "proof": "Proof.\nmove=> pNZ.\nrewrite irreducible_poly_coprime //; last first.\n  by case: hI; rewrite mk_monicE.\napply: contra pNZ => H; case: eqP => // /eqP /dvdp_leq /(_ H).\nby rewrite leqNgt size_mk_monic.\nQed."
}
{
  "statement": "Lemma num_itv_add_boundr (x1 x2 : R) b1 b2 :\n  (BRight x1 <= num_itv_bound R b1)%O -> (BRight x2 <= num_itv_bound R b2)%O ->\n  (BRight (x1 + x2)%R <= num_itv_bound R (add_boundr b1 b2))%O.\n",
  "proof": "Proof.\ncase: b1 b2 => [bb1 b1 |//] [bb2 b2 |//].\ncase: bb1; case: bb2; rewrite /= !bnd_simp mulrzDr.\n- exact: ltrD.\n- exact: ltr_leD.\n- exact: ler_ltD.\n- exact: lerD.\nQed."
}
{
  "statement": "Lemma f_finv_in : {in S, cancel finv f}.\n",
  "proof": "Proof.\nmove=> x xS; move: (looping_order x) (orbit_uniq x).\nrewrite /looping /orbit -orderSpred looping_uniq /= /looping; set n := _.-1.\ncase/predU1P=> // /trajectP[i lt_i_n]; rewrite -iterSr.\nby move=> /injf ->; rewrite ?(iter_in _ f_in) //; case/trajectP; exists i.\nQed."
}
{
  "statement": "Lemma exponent_Zgroup G : Zgroup G -> exponent G = #|G|.\n",
  "proof": "Proof.\nmove/forall_inP=> ZgG; apply/eqP; rewrite eqn_dvd exponent_dvdn.\napply/(dvdn_partP _ (cardG_gt0 _)) => p _.\nhave [S sylS] := Sylow_exists p G; rewrite -(card_Hall sylS).\nhave /cyclicP[x defS]: cyclic S by rewrite ZgG ?(p_Sylow sylS).\nby rewrite defS dvdn_exponent // -cycle_subG -defS (pHall_sub sylS).\nQed."
}
{
  "statement": "Lemma Zisometry_of_iso f :\n    free S -> {in S, isometry f, to 'Z[irr G]} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | {in S, tau =1 f}\n       & {in 'Z[S], isometry tau, to 'Z[irr G]}}.\n",
  "proof": "Proof.\nmove=> freeS [If Zf]; have [tau Dtau Itau] := isometry_of_free freeS If.\nexists tau => //; split; first by apply: sub_in2 Itau; apply: zchar_span.\nmove=> _ /zchar_nth_expansion[a Za ->]; rewrite linear_sum rpred_sum // => i _.\nby rewrite linearZ rpredZ_int ?Dtau ?Zf ?mem_nth.\nQed."
}
{
  "statement": "Lemma injm_cyclem : 'injm (cyclem (val u) a).\n",
  "proof": "Proof.\napply/subsetP=> x /setIdP[ax]; rewrite !inE -order_dvdn.\nhave [a1 | nta] := eqVneq a 1; first by rewrite a1 cycle1 inE in ax.\nrewrite -order_eq1 -dvdn1; move/eqnP: (valP u) => /= <-.\nby rewrite dvdn_gcd [in X in X && _]Zp_cast ?order_gt1 // order_dvdG.\nQed."
}
{
  "statement": "Lemma Sylow_setI_normal G H P :\n  G <| H -> p.-Sylow(H) P -> p.-Sylow(G) (G :&: P).\n",
  "proof": "Proof.\ncase/normalP=> sGH nGH sylP; have [Q sylQ] := Sylow_exists p G.\nhave /maxgroupP[/andP[sQG pQ] maxQ] := Hall_max sylQ.\nhave [R sylR sQR] := Sylow_superset (subset_trans sQG sGH) pQ.\nhave [[x Hx ->] pR] := (Sylow_trans sylR sylP, pHall_pgroup sylR).\nrewrite -(nGH x Hx) -conjIg pHallJ2.\nhave /maxQ-> //: Q \\subset G :&: R by rewrite subsetI sQG.\nby rewrite /psubgroup subsetIl (pgroupS _ pR) ?subsetIr.\nQed."
}
{
  "statement": "Lemma Fadjoin_eq_sum : <<K; x>>%VS = sumKx.\n",
  "proof": "Proof.\napply/esym/eqP; rewrite eqEdim eq_leq ?andbT.\n  apply/subv_sumP=> i _; rewrite -agenvM prodvS ?subv_adjoin //.\n  by rewrite -expv_line (subv_trans (subX_agenv _ _)) ?agenvS ?addvSr.\nrewrite dim_Fadjoin -[n]card_ord -sum_nat_const (directvP Fadjoin_sum_direct).\nby apply: eq_bigr => i _; rewrite /= dim_cosetv.\nQed."
}
{
  "statement": "Lemma cfker_add phi psi : cfker phi :&: cfker psi \\subset cfker (phi + psi).\n",
  "proof": "Proof.\napply/subsetP=> x /setIP[Kphi_x Kpsi_x]; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE !cfkerMl.\nQed."
}
{
  "statement": "Lemma cfker_mul phi psi : cfker phi :&: cfker psi \\subset cfker (phi * psi).\n",
  "proof": "Proof.\napply/subsetP=> x /setIP[Kphi_x Kpsi_x]; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE !cfkerMl.\nQed."
}
{
  "statement": "Lemma cfDetIsom aT rT (G : {group aT}) (R : {group rT})\n                (f : {morphism G >-> rT}) (isoGR : isom G R f) phi :\n  cfDet (cfIsom isoGR phi) = cfIsom isoGR (cfDet phi).\n",
  "proof": "Proof.\nrewrite unlock rmorph_prod (reindex (isom_Iirr isoGR)); last first.\n  by exists (isom_Iirr (isom_sym isoGR)) => i; rewrite ?isom_IirrK ?isom_IirrKV.\napply: eq_bigr=> i; rewrite -!cfDetRepr !irrRepr isom_IirrE rmorphXn cfIsom_iso.\nby rewrite /= ![in cfIsom _]unlock cfDetMorph ?cfRes_char ?cfDetRes ?irr_char.\nQed."
}
{
  "statement": "Lemma subset_limgP f U (r : seq rT) :\n  {subset r <= (f @: U)%VS} <-> (exists2 a, all (mem U) a & r = map f a).\n",
  "proof": "Proof.\nsplit => [|[{}r /allP/= rE ->] _ /mapP[x xr ->]]; last by rewrite memv_img ?rE.\nmove=> /(_ _ _)/memv_imgP/sig2_eqW-/(all_sig_cond (0 : aT))[f' f'P].\nexists (map f' r); first by apply/allP => _ /mapP [x /f'P[? ?] ->].\nby symmetry; rewrite -map_comp; apply: map_id_in => x /f'P[].\nQed."
}
{
  "statement": "Lemma normrN1 : `|-1| = 1 :> R.\n  ",
  "proof": "Proof.\n  have: `|-1| ^+ 2 == 1 :> R\n    by rewrite expr2 /= -normM mulrNN mul1r -[1]subr0 -le_def le01.\n  rewrite sqrf_eq1 => /predU1P [] //; rewrite -[-1]subr0 -le_def.\n  have ->: 0 <= -1 = (-1 == 0 :> R) || (0 < -1)\n    by rewrite lt_def; case: eqP => // ->; rewrite lerr.\n  by rewrite oppr_eq0 oner_eq0 => /(addr_gt0 lt01); rewrite subrr ltrr.\n  Qed."
}
{
  "statement": "Lemma gen_mx_irr : mx_irreducible rGA.\n",
  "proof": "Proof.\napply/mx_irrP; split=> [|U Umod nzU]; first exact: gen_dim_gt0.\nrewrite -sub1mx -rowval_genK -submx_rowval_gen submx_full //.\ncase/mx_irrP: irrG => _; apply; first by rewrite mxmodule_rowval_gen.\nrewrite -(inj_eq (can_inj in_genK)) in_gen0.\nby rewrite -mxrank_eq0 rowval_genK mxrank_eq0.\nQed."
}
{
  "statement": "Lemma mxdiag_sum (I : finType) (B_ : forall k i, 'M[V]_(p_ i)) (P : {pred I}) :\n  \\mxdiag_i (\\sum_(k | P k) B_ k i) = \\sum_(k | P k) \\mxdiag_i (B_ k i).\n",
  "proof": "Proof.\nrewrite /mxdiag -mxblock_sum; apply/eq_mxblock => i j.\ncase: eqVneq => [->|]; rewrite ?conform_mx_id//; last by rewrite big1.\nby apply: eq_bigr => k; rewrite conform_mx_id.\nQed."
}
{
  "statement": "Lemma max_pdiv_max n p : p \\in \\pi(n) -> p <= max_pdiv n.\n",
  "proof": "Proof.\nrewrite /max_pdiv !inE => n_p.\ncase/splitPr: n_p (sorted_primes n) => p1 p2; rewrite last_cat -cat_rcons /=.\nrewrite headI /= cat_path -(last_cons 0) -headI last_rcons; case/andP=> _.\nmove/(order_path_min ltn_trans); case/lastP: p2 => //= p2 q.\nby rewrite all_rcons last_rcons ltn_neqAle -andbA => /and3P[].\nQed."
}
{
  "statement": "Lemma ucnSnR n G : 'Z_n.+1(G) = [set x in G | [~: [set x], G] \\subset 'Z_n(G)].\n",
  "proof": "Proof.\n\n\napply/setP=> x; rewrite -(setIidPr (ucn_sub n.+1 G)) [LHS]inE [RHS]inE ucnSn.\ncase Gx: (x \\in G) => //=; have nZG := ucn_norm n G.\nrewrite -sub1set -sub_quotient_pre -?quotient_cents2 ?sub1set ?(subsetP nZG) //.\nby rewrite subsetI quotientS ?sub1set.\nQed."
}
{
  "statement": "Lemma constt_ortho_char (phi psi : 'CF(G)) i j :\n     phi \\is a character -> psi \\is a character ->\n     i \\in irr_constt phi -> j \\in irr_constt psi ->\n  '[phi, psi] = 0 -> '['chi_i, 'chi_j] = 0.\n",
  "proof": "Proof.\nmove=> _ _ /constt_charP[//|phi1 Nphi1 ->] /constt_charP[//|psi1 Npsi1 ->].\nrewrite cfdot_irr; case: eqP => // -> /eqP/idPn[].\nrewrite cfdotDl !cfdotDr cfnorm_irr -addrA gt_eqF ?ltr_wpDr ?ltr01 //.\nby rewrite natr_ge0 ?rpredD ?Cnat_cfdot_char ?irr_char.\nQed."
}
{
  "statement": "Lemma Ohm1_cent_max G E p : E \\in 'E*_p(G) -> p.-group G -> 'Ohm_1('C_G(E)) = E.\n",
  "proof": "Proof.\nmove=> EpmE pG; have [G1 | ntG]:= eqsVneq G 1.\n  case/pmaxElemP: EpmE; case/pElemP; rewrite G1 => /trivgP-> _ _.\n  by apply/trivgP; rewrite cent1T setIT Ohm_sub.\nhave [p_pr _ _] := pgroup_pdiv pG ntG.\nby rewrite (OhmE 1 (pgroupS (subsetIl G _) pG)) (pmaxElem_LdivP _ _) ?genGid.\nQed."
}
{
  "statement": "Lemma cfResIsom phi : 'Res[S] (cfIsom isoG phi) = cfIsom isoH ('Res[H] phi).\n",
  "proof": "Proof.\nhave [[injg defR] [injh defS]] := (isomP isoG, isomP isoH).\nrewrite !morphimEdom in defS defR; apply/cfun_inP=> s.\nrewrite -{1}defS => /imsetP[x Hx ->] {s}; have Gx := subsetP sHG x Hx.\nrewrite {1}eq_hg ?(cfResE, cfIsomE) // -defS -?eq_hg ?imset_f // -defR.\nby rewrite (eq_in_imset eq_hg) imsetS.\nQed."
}
{
  "statement": "Lemma has_nthP a s x0 :\n  reflect (exists2 i, i < size s & a (nth x0 s i)) (has a s).\n",
  "proof": "Proof.\nelim: s => [|x s IHs] /=; first by right; case.\ncase nax: (a x); first by left; exists 0.\nby apply: (iffP IHs) => [[i]|[[|i]]]; [exists i.+1 | rewrite nax | exists i].\nQed."
}
{
  "statement": "Lemma F_s3 : 'Fix_to_g[s3] =\n  [set x | (col0 x == col1 x) && (col2 x == col3  x) && (col4 x == col5 x)].\n",
  "proof": "Proof.\nhave s3_inv: s3^-1 = s3 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s3_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma gacent_mod G M :\n    H \\subset 'C(M | to) -> G \\subset 'N(H) ->\n 'C_(M | mod_groupAction)(G / H) = 'C_(M | to)(G).\n",
  "proof": "Proof.\nmove=> cMH nHG; rewrite -gacentIdom gacentE ?subsetIl // setICA.\nhave sHD: H \\subset D by rewrite (subset_trans cMH) ?subsetIl.\nrewrite -quotientGI // afix_mod ?setIS // setICA -gacentIim (setIC R) -setIA.\nrewrite -gacentE ?subsetIl // gacentIdom setICA (setIidPr _) //.\nby rewrite gacentC // ?(subset_trans cMH) ?astabS ?subsetIl // setICA subsetIl.\nQed."
}
{
  "statement": "Lemma divzMA_ge0 m n p : n >= 0 -> (m %/ (n * p) = (m %/ n)%Z %/ p)%Z.\n",
  "proof": "Proof.\ncase: n => // [[|n]] _; first by rewrite mul0r !divz0 div0z.\nwlog p_gt0: p / p > 0; last case: p => // p in p_gt0 *.\n  by case/intP: p => [|p|p] IH; rewrite ?mulr0 ?divz0 ?mulrN ?divzN // IH.\nrewrite {2}(divz_eq m (n.+1%:Z * p)) mulrA mulrAC !divzMDl // ?gt_eqF //.\nrewrite [rhs in _ + rhs]divz_small ?addr0 // ltz_divLR // divz_ge0 //.\nby rewrite mulrC ltz_pmod ?modz_ge0 ?gt_eqF ?pmulr_lgt0.\nQed."
}
{
  "statement": "Lemma subDset A B C : (A :\\: B \\subset C) = (A \\subset B :|: C).\n",
  "proof": "Proof.\napply/subsetP/subsetP=> sABC x; rewrite !inE.\n  by case Bx: (x \\in B) => // Ax; rewrite sABC ?inE ?Bx.\nby case Bx: (x \\in B) => // /sABC; rewrite inE Bx.\nQed."
}
{
  "statement": "Lemma diagonalizable_conj_diag m n (V : 'M[F]_(m, n)) (d : 'rV[F]_n) :\n  stablemx V (diag_mx d) -> row_free V -> diagonalizable (conjmx V (diag_mx d)).\n",
  "proof": "Proof.\ncase: m n => [|m] [|n] in V d * => Vd rdV; rewrite ?thinmx0.\n- by [].\n- by [].\n- by exfalso; move: rdV; rewrite /row_free mxrank.unlock eqxx orbT.\napply/diagonalizableP; pose u := undup [seq d 0 i | i <- enum 'I_n.+1].\nexists u; first by rewrite undup_uniq.\nby rewrite (dvdp_trans (mxminpoly_conj (f:=diag_mx d) _ _))// mxminpoly_diag.\nQed."
}
{
  "statement": "Lemma cyclic_mx_eq0 u : (cyclic_mx u == 0) = (u == 0).\n",
  "proof": "Proof.\nrewrite -!submx0; apply/idP/idP.\n  by apply: submx_trans; apply: cyclic_mx_id.\nmove/submx0null->; rewrite genmxE; apply/row_subP=> i.\nby rewrite row_mul mul_rV_lin1 /= mul0mx ?sub0mx.\nQed."
}
{
  "statement": "Lemma odd_pgroup_rank1_cyclic gT p (G : {group gT}) :\n  p.-group G -> odd #|G| -> cyclic G = ('r_p(G) <= 1).\n",
  "proof": "Proof.\nmove=> pG oddG; rewrite -rank_pgroup //; apply/idP/idP=> [cycG | dimG1].\n  by rewrite -abelian_rank1_cyclic ?cyclic_abelian.\nhave [X nsXG cXX|//|] := normal_rank1_structure pG; last first.\n  by rewrite (negPf (odd_not_extremal2 oddG)) andbF.\nby rewrite abelian_rank1_cyclic // (leq_trans (rankS (normal_sub nsXG))).\nQed."
}
{
  "statement": "Lemma inv_quotientS :\n  Kbar \\subset G / H -> inv_quotient_spec (fun K => K \\subset G).\n",
  "proof": "Proof.\ncase/andP: nHG => sHG nHG' sKbarG.\nhave sKdH: Kbar \\subset 'N(H) / H by rewrite (subset_trans sKbarG) ?morphimS.\nexists (coset H @*^-1 Kbar)%G; first by rewrite cosetpreK.\n  by rewrite -{1}ker_coset morphpreS ?sub1G.\nby rewrite sub_cosetpre_quo.\nQed."
}
{
  "statement": "Lemma subrXX_comm x y n (cxy : comm x y) :\n  x ^+ n - y ^+ n = (x - y) * (\\sum_(i < n) x ^+ (n.-1 - i) * y ^+ i).\n",
  "proof": "Proof.\ncase: n => [|n]; first by rewrite big_ord0 mulr0 subrr.\nrewrite mulrBl !big_distrr big_ord_recl big_ord_recr /= subnn mulr1 mul1r.\nrewrite subn0 -!exprS opprD -!addrA; congr (_ + _); rewrite addrA -sumrB.\nrewrite big1 ?add0r // => i _; rewrite !mulrA -exprS -subSn ?(valP i) //.\nby rewrite subSS (commrX _ (commr_sym cxy)) -mulrA -exprS subrr.\nQed."
}
{
  "statement": "Lemma sorted_filter_lt x s :\n  sorted <=%O s -> [seq y <- s | y < x] = take (count (< x) s) s.\n",
  "proof": "Proof.\nelim: s => [//|y s IHs]/=; rewrite (path_sortedE le_trans) => /andP[le_y_s ss].\ncase: ifP => [|ltyxF]; rewrite IHs//.\nrewrite (@eq_in_count _ _ pred0) ?count_pred0/= ?take0// => z.\nby move=> /(allP le_y_s) yz; apply: contraFF ltyxF; apply: le_lt_trans.\nQed."
}
{
  "statement": "Lemma expand_det_row n (A : 'M[R]_n) i0 :\n  \\det A = \\sum_j A i0 j * cofactor A i0 j.\n",
  "proof": "Proof.\nrewrite /(\\det A) (partition_big (fun s : 'S_n => s i0) predT) //=.\napply: eq_bigr => j0 _; rewrite expand_cofactor big_distrr /=.\napply: eq_bigr => s /eqP Dsi0.\nrewrite mulrCA (bigID (pred1 i0)) /= big_pred1_eq Dsi0; congr (_ * (_ * _)).\nby apply: eq_bigl => i; rewrite eq_sym.\nQed."
}
{
  "statement": "Lemma logn_prime p q : prime q -> logn p q = (p == q).\n",
  "proof": "Proof.\nmove=> pr_q; have q_gt0 := prime_gt0 pr_q; rewrite lognE q_gt0 /=.\ncase pr_p: (prime p); last by case: eqP pr_p pr_q => // -> ->.\nby rewrite dvdn_prime2 //; case: eqP => // ->; rewrite divnn q_gt0 logn1.\nQed."
}
{
  "statement": "Lemma morphim_trivm (G H : {group aT}) : trivm G @* H = 1.\n",
  "proof": "Proof.\napply/setP=> /= y; rewrite inE; apply/idP/eqP=> [|->]; first by case/morphimP.\nby apply/morphimP; exists (1 : aT); rewrite /= ?group1.\nQed."
}
{
  "statement": "Lemma gact_stable : {acts D, on R | to}.\n",
  "proof": "Proof.\napply: acts_act; apply/subsetP=> a Da; rewrite !inE Da.\napply/subsetP=> x; rewrite inE; apply: contraLR => R'xa.\nby rewrite -(actKin to Da x) gact_out ?groupV.\nQed."
}
{
  "statement": "Lemma pcore_normal G : 'O_pi(G) <| G.\n",
  "proof": "Proof.\nrewrite /(_ <| G) pcore_sub; apply/subsetP=> x Gx.\nrewrite inE; apply/bigcapsP=> M maxM; rewrite sub_conjg.\nby apply: bigcap_inf; apply: max_pgroupJ; rewrite ?groupV.\nQed."
}
{
  "statement": "Lemma rstabS m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U <= V)%MS -> rstab rG V \\subset rstab rG U.\n",
  "proof": "Proof.\ncase/submxP=> u ->; apply/subsetP=> x.\nby rewrite !inE => /andP[-> /= /eqP cVx]; rewrite -mulmxA cVx.\nQed."
}
{
  "statement": "Lemma abelian_rank1_cyclic G : abelian G -> cyclic G = ('r(G) <= 1).\n",
  "proof": "Proof.\nmove=> cGG; have [b defG atypG] := abelian_structure cGG.\napply/idP/idP; first by case/cyclicP=> x ->; rewrite rank_cycle leq_b1.\nrewrite -size_abelian_type // -{}atypG -{}defG unlock.\nby case: b => [|x []] //= _; rewrite ?cyclic1 // dprodg1 cycle_cyclic.\nQed."
}
{
  "statement": "Lemma leqifP m n C : reflect (m <= n ?= iff C) (if C then m == n else m < n).\n",
  "proof": "Proof.\nrewrite ltn_neqAle; apply: (iffP idP) => [|lte]; last by rewrite !lte; case C.\nby case C => [/eqP-> | /andP[/negPf]]; split=> //; apply: eqxx.\nQed."
}
{
  "statement": "Lemma mul_mxrow_mxcol m n\n    (R_ : forall j, 'M[R]_(m, p_ j)) (C_ : forall i, 'M[R]_(p_ i, n)) :\n  \\mxrow_j R_ j *m \\mxcol_i C_ i = \\sum_i (R_ i *m C_ i).\n",
  "proof": "Proof.\napply/matrixP => i j; rewrite !mxE summxE; under [RHS]eq_bigr do rewrite !mxE.\nrewrite sig_big_dep/= (reindex _ tagnat.sig_bij_on)/=.\nby apply: eq_bigr=> l _; rewrite !mxE.\nQed."
}
{
  "statement": "Lemma dvdp_eq_div p q : d %| p -> (q == p %/ d) = (q * d == p).\n",
  "proof": "Proof.\nmove/divpK=> {2}<-; apply/eqP/eqP; first by move->.\napply/mulIf; rewrite -lead_coef_eq0; apply: contraTneq ulcd => ->.\nby rewrite unitr0.\nQed."
}
{
  "statement": "Lemma pcore_psubgroup G : pi.-subgroup(G) 'O_pi(G).\n",
  "proof": "Proof.\nhave [M maxM _]: {M | [max M | pi.-subgroup(G) M] & 1%G \\subset M}.\n  by apply: maxgroup_exists; rewrite /psubgroup sub1G pgroup1.\nhave sOM: 'O_pi(G) \\subset M by apply: bigcap_inf.\nhave /andP[piM sMG] := maxgroupp maxM.\nby rewrite /psubgroup (pgroupS sOM) // (subset_trans sOM).\nQed."
}
{
  "statement": "Lemma sub_in_pairwise {T : Type} (P : {pred T}) (r r' : rel T) :\n  {in P &, subrel r r'} ->\n  forall xs, all P xs -> pairwise r xs -> pairwise r' xs.\n",
  "proof": "Proof.\nmove=> rr'; elim=> //= x xs IHxs /andP [Px Pxs] /andP [+ {}/IHxs->] //.\nrewrite andbT; elim: xs Pxs => //= x' xs IHxs /andP [? ?] /andP [+ /IHxs->] //.\nby rewrite andbT; apply: rr'.\nQed."
}
{
  "statement": "Lemma edivn_eq d q r : r < d -> edivn (q * d + r) d = (q, r).\n",
  "proof": "Proof.\nmove=> lt_rd; have d_gt0: 0 < d by apply: leq_trans lt_rd.\ncase: edivnP lt_rd => q' r'; rewrite d_gt0 /=.\nwlog: q q' r r' / q <= q' by case/orP: (leq_total q q'); last symmetry; eauto.\nhave [||-> _ /addnI ->] //= := ltngtP q q'.\nrewrite -(leq_pmul2r d_gt0) => /leq_add lt_qr _ eq_qr _ /lt_qr {lt_qr}.\nby rewrite addnS ltnNge mulSn -addnA eq_qr addnCA addnA leq_addr.\nQed."
}
{
  "statement": "Lemma sub_in_constt pi1 pi2 x :\n  {in \\pi(#[x]), {subset pi1 <= pi2}} -> x.`_pi2.`_pi1 = x.`_pi1.\n",
  "proof": "Proof.\nmove=> pi12; rewrite -{2}(consttC pi2 x) consttM; last exact: commuteX2.\nrewrite (constt1P _ x.`_pi2^' _) ?mulg1 //.\napply: sub_in_pnat (p_elt_constt _ x) => p; rewrite order_constt => pi_p.\nby apply/contra/pi12; rewrite -[#[x]](partnC pi2^') // primesM // pi_p.\nQed."
}
{
  "statement": "Lemma tperm_proof x y : involutive [fun z => z with x |-> y, y |-> x].\n",
  "proof": "Proof.\nmove=> z /=; case: (z =P x) => [-> | ne_zx]; first by rewrite eqxx; case: eqP.\nby case: (z =P y) => [->| ne_zy]; [rewrite eqxx | do 2?case: eqP].\nQed."
}
{
  "statement": "Lemma eqp_dvdr q p d: p %= q -> d %| p = (d %| q).\n",
  "proof": "Proof.\nsuff Hmn m n: m %= n -> (d %| m) -> (d %| n).\n  by move=> mn; apply/idP/idP; apply: Hmn=> //; rewrite eqp_sym.\nby rewrite /eqp; case/andP=> pq qp dp; apply: (dvdp_trans dp).\nQed."
}
{
  "statement": "Lemma modpZr c p : c \\in GRing.unit -> p %% (c *: d) = (p %% d).\n",
  "proof": "Proof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !modp0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVr // scale1r -(divp_eq ulcd).\nsuff s : size (p %% d) < size (c *: d).\n  by rewrite (modpP _ e s) // -mul_polyC lead_coefM lead_coefC unitrM cn0.\nby rewrite size_scale ?ltn_modp //; apply: contraTneq cn0 => ->; rewrite unitr0.\nQed."
}
{
  "statement": "Lemma row_mx_eq0 (m n1 n2 : nat) (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)):\n  (row_mx A1 A2 == 0) = (A1 == 0) && (A2 == 0).\n",
  "proof": "Proof.\napply/eqP/andP; last by case=> /eqP-> /eqP->; rewrite row_mx0.\nby rewrite -row_mx0 => /eq_row_mx [-> ->].\nQed."
}
{
  "statement": "Lemma set_Frobenius_compl G K H :\n  K ><| H = G -> [Frobenius G with kernel K] -> [Frobenius G = K ><| H].\n",
  "proof": "Proof.\nmove=> defG /Frobenius_kerP[ntK ltKG _ regKG].\napply/Frobenius_semiregularP=> //.\n  by apply: contraTneq ltKG => H_1; rewrite -defG H_1 sdprodg1 properxx.\napply: semiregular_sym => y /regKG sCyK.\nhave [_ sHG _ _ tiKH] := sdprod_context defG.\nby apply/trivgP; rewrite /= -(setIidPr sHG) setIAC -tiKH setSI.\nQed."
}
{
  "statement": "Lemma mxdiagZ a : \\mxdiag_i (a%:M : 'M[R]_(p_ i)) = a%:M.\n",
  "proof": "Proof.\napply/matrixP => s t; rewrite !mxE -(can_eq sigK) /sig1 /sig2.\ncase: (sig s) (sig t) => [/= i j] [/= i' j'].\ncase: eqP => [<-|ni] in j' *; last by rewrite !mxE; case: eqVneq => // -[].\nby rewrite conform_mx_id eq_Tagged/= mxE.\nQed."
}
{
  "statement": "Lemma coprime_index_mulG G H K :\n  H \\subset G -> K \\subset G -> coprime #|G : H| #|G : K| -> H * K = G.\n",
  "proof": "Proof.\nmove=> sHG sKG co_iG_HK; apply/eqP; rewrite eqEcard mul_subG //=.\nrewrite -(@leq_pmul2r #|H :&: K|) ?cardG_gt0 // -mul_cardG.\nrewrite -(Lagrange sHG) -(LagrangeI K H) mulnAC setIC -mulnA.\nrewrite !leq_pmul2l ?cardG_gt0 // dvdn_leq // -(Gauss_dvdr _ co_iG_HK).\nby rewrite -(indexgI K) Lagrange_index ?indexgS ?subsetIl ?subsetIr.\nQed."
}
{
  "statement": "Lemma cent_sub_inertia phi : 'C(H) \\subset 'I[phi].\n",
  "proof": "Proof.\napply/subsetP=> y cHy; have nHy := subsetP (cent_sub H) y cHy.\nrewrite inE nHy; apply/eqP/cfun_inP=> x Hx; rewrite cfConjgE //.\nby rewrite /conjg invgK mulgA (centP cHy) ?mulgK.\nQed."
}
{
  "statement": "Lemma sorted_filter_le x s :\n  sorted <=%O s -> [seq y <- s | y <= x] = take (count (<= x) s) s.\n",
  "proof": "Proof.\nelim: s => [//|y s IHs]/=; rewrite (path_sortedE le_trans) => /andP[le_y_s ss].\ncase: ifP => [|leyxF]; rewrite IHs//.\nrewrite (@eq_in_count _ _ pred0) ?count_pred0/= ?take0// => z.\nby move=> /(allP le_y_s) yz; apply: contraFF leyxF; apply: le_trans.\nQed."
}
{
  "statement": "Lemma mxdirect_sumsE (S_ : I -> mxsum_expr n n) (xunwrap := unwrap) :\n  reflect (and (forall i, P i -> mxdirect (unwrap (S_ i)))\n               (mxdirect (\\sum_(i | P i) (xunwrap (S_ i)))))\n          (mxdirect (\\sum_(i | P i) (unwrap (S_ i)))).\n",
  "proof": "Proof.\napply: (iffP (mxdirect_sums_recP _)) => [dxS | [dxS_ dxS] i Pi].\n  by do [split; last apply/mxdirect_sumsP] => i; case/dxS.\nby split; [apply: dxS_ | apply: mxdirect_sumsP Pi].\nQed."
}
{
  "statement": "Lemma catCA_perm_subst R F :\n    (forall s1 s2 s3, F (s1 ++ s2 ++ s3) = F (s2 ++ s1 ++ s3) :> R) ->\n  (forall s1 s2, perm_eq s1 s2 -> F s1 = F s2).\n",
  "proof": "Proof.\nmove=> FcatCA s1 s2 /catCA_perm_ind => ind_s12.\nby apply: (ind_s12 (eq _ \\o F)) => //= *; rewrite FcatCA.\nQed."
}
{
  "statement": "Lemma divpZr c p : c \\in GRing.unit -> p %/ (c *: d) = c^-1 *: (p %/ d).\n",
  "proof": "Proof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !divp0 scaler0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVr // scale1r -(divp_eq ulcd).\nsuff s : size (p %% d) < size (c *: d).\n  by rewrite (divpP _ e s) // -mul_polyC lead_coefM lead_coefC unitrM cn0.\nby rewrite size_scale ?ltn_modp //; apply: contraTneq cn0 => ->; rewrite unitr0.\nQed."
}
{
  "statement": "Lemma Derivation_exp x m : x \\in E -> D (x ^+ m) = x ^+ m.-1 *+ m * D x.\n",
  "proof": "Proof.\nmove=> Ex; case: m; first by rewrite expr0 mulr0n mul0r Derivation1.\nelim=> [|m IHm]; first by rewrite mul1r.\nrewrite exprS (Derivation_mul derD) //; last by apply: rpredX.\nby rewrite mulrC IHm mulrA mulrnAr -exprS -mulrDl.\nQed."
}
{
  "statement": "Lemma nElemI n G H : 'E^n(G :&: H) = 'E^n(G) :&: subgroups H.\n",
  "proof": "Proof.\napply/setP=> E; apply/nElemP/setIP=> [[p] | []].\n  by rewrite pnElemI; case/setIP; split=> //; apply/nElemP; exists p.\nby case/nElemP=> p EpnG_E sHE; exists p; rewrite pnElemI inE EpnG_E.\nQed."
}
{
  "statement": "Lemma rowgS m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (rowg A \\subset rowg B) = (A <= B)%MS.\n",
  "proof": "Proof.\napply/subsetP/idP=> sAB => [|u /[!inE] suA]; last exact: submx_trans sAB.\nby apply/row_subP=> i; have /[!(inE, row_sub)]-> := sAB (row i A).\nQed."
}
{
  "statement": "Lemma orbit_partition G S :\n  [acts G, on S | to] -> partition (orbit to G @: S) S.\n",
  "proof": "Proof.\nmove=> actsGS; have sGD := acts_dom actsGS.\nhave eqiG: {in S & &, equivalence_rel [rel x y | y \\in orbit to G x]}.\n  by move=> x y z * /=; rewrite orbit_refl; split=> // /orbit_in_eqP->.\ncongr (partition _ _): (equivalence_partitionP eqiG).\napply: eq_in_imset => x Sx; apply/setP=> y.\nby rewrite inE /= andb_idl // => /acts_in_orbit->.\nQed."
}
{
  "statement": "Lemma memv_sumP {P} {Us : I -> {vspace vT}} {v} :\n  reflect (exists2 vs, forall i, P i ->  vs i \\in Us i\n                     & v = \\sum_(i | P i) vs i)\n          (v \\in \\sum_(i | P i) Us i)%VS.\n",
  "proof": "Proof.\napply: (iffP idP) => [|[vs Uv ->]]; last exact: memv_sumr.\nrewrite memvK vs2mx_sum => /sub_sumsmxP[r /(canRL v2rK)->].\npose f i := r2v (r i *m vs2mx (Us i)); rewrite linear_sum /=.\nby exists f => //= i _; rewrite mem_r2v submxMl.\nQed."
}
{
  "statement": "Lemma memmx_subP m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (forall A, A \\in R1 -> A \\in R2) (R1 <= R2)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sR12 A R1_A | sR12]; first exact: submx_trans sR12.\nby apply/rV_subP=> vA; rewrite -(vec_mxK vA); apply: sR12.\nQed."
}
{
  "statement": "Lemma is_diag_mxEtrig m n (A : 'M[V]_(m, n)) :\n  is_diag_mx A = is_trig_mx A && is_trig_mx A^T.\n",
  "proof": "Proof.\napply/is_diag_mxP/andP => [Adiag|[/is_trig_mxP Atrig /is_trig_mxP ATtrig]].\n  by split; apply/is_trig_mxP => i j lt_ij; rewrite ?mxE ?Adiag//;\n     [rewrite ltn_eqF|rewrite gtn_eqF].\nby move=> i j; case: ltngtP => // [/Atrig|/ATtrig]; rewrite ?mxE.\nQed."
}
{
  "statement": "Lemma sd1_inv : sd1^-1 = sd1.\n",
  "proof": "Proof.\napply: (mulIg sd1); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed."
}
{
  "statement": "Lemma sd2_inv : sd2^-1 = sd2.\n",
  "proof": "Proof.\napply: (mulIg sd2); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed."
}
{
  "statement": "Lemma mul_row_col m n1 n2 p (Al : 'M_(m, n1)) (Ar : 'M_(m, n2))\n                            (Bu : 'M_(n1, p)) (Bd : 'M_(n2, p)) :\n  row_mx Al Ar *m col_mx Bu Bd = Al *m Bu + Ar *m Bd.\n",
  "proof": "Proof.\napply/matrixP=> i k; rewrite !mxE big_split_ord /=.\ncongr (_ + _); apply: eq_bigr => j _; first by rewrite row_mxEl col_mxEu.\nby rewrite row_mxEr col_mxEd.\nQed."
}
{
  "statement": "Lemma eqp_dvdl d2 d1 p : d1 %= d2 -> d1 %| p = (d2 %| p).\n",
  "proof": "Proof.\nsuff Hmn m n: m %= n -> (m %| p) -> (n %| p).\n  by move=> ?; apply/idP/idP; apply: Hmn; rewrite // eqp_sym.\nby rewrite /eqp; case/andP=> dd' d'd dp; apply: (dvdp_trans d'd).\nQed."
}
{
  "statement": "Lemma quotient_ucn_add m n G : 'Z_(m + n)(G) / 'Z_n(G) = 'Z_m(G / 'Z_n(G)).\n",
  "proof": "Proof.\nelim: m => [|m IHm]; first exact: trivg_quotient.\napply/setP=> Zx; have [x Nx ->{Zx}] := cosetP Zx.\nhave [sZG nZG] := andP (ucn_normal n G).\nrewrite (ucnSnR m) inE -!sub1set -morphim_set1 //= -quotientR ?sub1set // -IHm.\nrewrite !quotientSGK ?(ucn_sub_geq, leq_addl, comm_subG _ nZG, sub1set) //=.\nby rewrite addSn /= ucnSnR inE.\nQed."
}
{
  "statement": "Lemma sumsmx_subP P m n (A_ : I -> 'M_n) (B : 'M_(m, n)) :\n  reflect (forall i, P i -> A_ i <= B)%MS (\\sum_(i | P i) A_ i <= B)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [sAB i Pi | sAB].\n  by apply: submx_trans sAB; apply: sumsmx_sup Pi _.\nby elim/big_rec: _ => [|i Ai Pi sAiB]; rewrite ?sub0mx // addsmx_sub sAB.\nQed."
}
{
  "statement": "Lemma sv_inv : sv^-1 = sv.\n",
  "proof": "Proof.\napply: (mulIg sv); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed."
}
{
  "statement": "Lemma vbasis1 : exists2 k, k != 0 & vbasis 1 = [:: k%:A] :> seq aT.\n",
  "proof": "Proof.\nmove: (vbasis 1) (@vbasisP K aT 1); rewrite dim_vline oner_neq0.\ncase/tupleP=> x X0; rewrite {X0}tuple0 => defX; have Xx := mem_head x nil.\nhave /vlineP[k def_x] := basis_mem defX Xx; exists k; last by rewrite def_x.\nby have:= basis_not0 defX Xx; rewrite def_x scaler_eq0 oner_eq0 orbF.\nQed."
}
{
  "statement": "Lemma dvd_eqp_divl d p q (dvd_dp : d %| q) (eq_pq : p %= q) :\n  p %/ d %= q %/ d.\n",
  "proof": "Proof.\ncase: (eqVneq q 0) eq_pq=> [->|q_neq0]; first by rewrite eqp0=> /eqP->.\nhave d_neq0: d != 0 by apply: contraTneq dvd_dp=> ->; rewrite dvd0p.\nmove=> eq_pq; rewrite -(@eqp_mul2r d) // !divpK // ?(eqp_dvdr _ eq_pq) //.\nrewrite (eqp_ltrans (eqp_scale _ _)) ?lc_expn_scalp_neq0 //.\nby rewrite (eqp_rtrans (eqp_scale _ _)) ?lc_expn_scalp_neq0.\nQed."
}
{
  "statement": "Lemma im_sdpair_TI : (sdpair1 @* R) :&: (sdpair2 @* D) = 1.\n",
  "proof": "Proof.\napply/trivgP; apply/subsetP=> _ /setIP[/morphimP[x _ Rx ->]].\ncase/morphimP=> a _ Da /eqP; rewrite inE -!val_eqE.\nby rewrite !val_insubd !inE Da Rx !group1 /eq_op /= eqxx; case/andP.\nQed."
}
{
  "statement": "Lemma rank_witness G : {p | prime p & 'r(G) = 'r_p(G)}.\n",
  "proof": "Proof.\nhave [p _ defmG]: {p : 'I_(#|G|.+1) | true & 'r(G) = 'r_p(G)}.\n  by rewrite ['r(G)]big_mkord; apply: eq_bigmax_cond; rewrite card_ord.\ncase: (eqsVneq G 1) => [-> | ]; first by exists 2; rewrite // rank1 p_rank1.\nby rewrite -rank_gt0 defmG p_rank_gt0 mem_primes; case/andP; exists p.\nQed."
}
{
  "statement": "Lemma count_merge (p : pred T) s1 s2 :\n  count p (merge s1 s2) = count p (s1 ++ s2).\n",
  "proof": "Proof.\nrewrite count_cat; elim: s1 s2 => // x s1 IH1.\nelim=> //= [|y s2 IH2]; first by rewrite addn0.\nby case: leT; rewrite /= ?IH1 ?IH2 !addnA [_ + p y]addnAC [p x + p y]addnC.\nQed."
}
{
  "statement": "Lemma lin_mulmxr_is_linear : linear lin_mulmxr.\n",
  "proof": "Proof.\nmove=> a A B; apply/row_matrixP; case/mxvec_indexP=> i j.\nrewrite linearP /= !rowE !mul_rV_lin /= vec_mx_delta -linearP mulmxDr.\ncongr (mxvec (_ + _)); apply/row_matrixP=> k.\nrewrite linearZ /= !row_mul rowE mul_delta_mx_cond.\nby case: (k == i); [rewrite -!rowE linearZ | rewrite !mul0mx raddf0].\nQed."
}
{
  "statement": "Lemma factmE x : x \\in G -> ff (q x) = f x.\n",
  "proof": "Proof.\nrewrite /ff => Gx; have Hx := subsetP sGH x Gx.\nhave /mem_repr: x \\in q @*^-1 [set q x] by rewrite !inE Hx /=.\ncase/morphpreP; move: (repr _) => y Hy /set1P.\nby case/ker_rcoset=> // z Kz ->; rewrite mkerl ?(subsetP sKqKf).\nQed."
}
{
  "statement": "Lemma leq_uniq_countP x s1 s2 : uniq s1 ->\n  reflect (x \\in s1 -> x \\in s2) (count_mem x s1 <= count_mem x s2).\n",
  "proof": "Proof.\nmove/count_uniq_mem->; case: (boolP (_ \\in _)) => //= _; last by constructor.\nby rewrite -has_pred1 has_count; apply: (iffP idP) => //; apply.\nQed."
}
{
  "statement": "Lemma comparable_minA : min x (min y z) = min (min x y) z.\n",
  "proof": "Proof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z) => [xy|xy|xy|<-] [xz|xz|xz|<-]// []//= yz.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\n- by have := lt_trans xy xz; rewrite yz ltxx.\nQed."
}
{
  "statement": "Lemma fracqE x : fracq x = x.1%:Q / x.2%:Q.\n",
  "proof": "Proof.\nmove: x => [m n] /=; apply/val_inj; rewrite val_fracq/=.\ncase: eqVneq => //= [->|n_neq0]; first by rewrite rat0 invr0 mulr0.\nrewrite -[m%:Q]valqK -[n%:Q]valqK.\nrewrite [_^-1]invq_frac ?denq_neq0 ?numq_eq0 ?intq_eq0//=.\nrewrite [X in valq X]mulq_frac val_fracq /invq_subdef !mulq_subdefE/=.\nby rewrite -!/(numq _) -!/(denq _) !numq_int !denq_int mul1r mulr1 n_neq0.\nQed."
}
{
  "statement": "Lemma im_cfclass_Iirr i :\n  H <| G -> perm_eq [seq 'chi_j | j in cfclass_Iirr G i] ('chi_i ^: G)%CF.\n",
  "proof": "Proof.\nmove=> nsHG; have UchiG := cfclass_uniq 'chi_i nsHG.\napply: uniq_perm; rewrite ?(map_inj_uniq irr_inj) ?enum_uniq // => phi.\napply/imageP/idP=> [[j iGj ->] | /cfclassP[y]]; first by rewrite -cfclass_IirrE.\nby exists (conjg_Iirr i y); rewrite ?imset_f ?conjg_IirrE.\nQed."
}
{
  "statement": "Lemma cfInd_cfun1 : H <| G -> 'Ind[G, H] 1 = #|G : H|%:R *: '1_H.\n",
  "proof": "Proof.\nmove=> nsHG; have [sHG nHG] := andP nsHG; rewrite natf_indexg // mulrC.\napply/cfunP=> x; rewrite cfIndE ?cfunE ?cfuniE // -mulrA; congr (_ * _).\nrewrite mulr_natl -sumr_const; apply: eq_bigr => y Gy.\nby rewrite cfun1E -{1}(normsP nHG y Gy) memJ_conjg.\nQed."
}
{
  "statement": "Lemma big_enumP I P : big_enum_spec P (filter P (index_enum I)).\n",
  "proof": "Proof.\nset e := filter P _; have Ue: uniq e by apply/filter_uniq/index_enum_uniq.\nhave mem_e i: i \\in e = P i by rewrite mem_filter mem_index_enum andbT.\nsplit=> // [R idx op F | cP]; first by rewrite big_filter.\nsuffices De: perm_eq e (enum cP) by rewrite (perm_size De) cardE.\nby apply/uniq_perm=> // [|i]; rewrite ?enum_uniq ?mem_enum ?mem_e.\nQed."
}
{
  "statement": "Lemma trivial_Alt_2 (T : finType) : #|T| <= 2 -> 'Alt_T = 1.\n",
  "proof": "Proof.\nrewrite leq_eqVlt => /predU1P[] oT.\n  by apply: card_le1_trivg; rewrite -leq_double -mul2n card_Alt oT.\nsuffices Sym1: 'Sym_T = 1 by apply/trivgP; rewrite -Sym1 subsetT.\nby apply: card1_trivg; rewrite card_Sym; case: #|T| oT; do 2?case.\nQed."
}
{
  "statement": "Lemma comparable_maxA : max x (max y z) = max (max x y) z.\n",
  "proof": "Proof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z) => [xy|xy|xy|<-] [xz|xz|xz|<-]// []//= yz.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\n- by have := lt_trans xy xz; rewrite yz ltxx.\nQed."
}
{
  "statement": "Lemma DnQ_P n : xcprod_spec 'D^n 'Q_8 ('D^n*Q)%type.\n",
  "proof": "Proof.\nhave pQ: 2.-group 'Q_(2 ^ 3) by rewrite /pgroup card_quaternion.\nhave{pQ} oZQ := card_center_extraspecial pQ Q8_extraspecial.\nsuffices oZDn: #|'Z('D^n)| = 2.\n  by apply: xcprodP; rewrite isog_cyclic_card ?prime_cyclic ?oZQ ?oZDn.\nhave [-> | n_gt0] := posnP n; first by rewrite center_ncprod0 card_pX1p2n.\nhave pr2: prime 2 by []; have pDn := pX1p2n_pgroup n pr2.\nexact: card_center_extraspecial (pX1p2n_extraspecial pr2 n_gt0).\nQed."
}
{
  "statement": "Lemma ler_wsqrtr : {homo @sqrt R : a b / a <= b}.\n",
  "proof": "Proof.\nmove=> a b /= le_ab; case: (boolP (0 <= a))=> [pa|]; last first.\n  by rewrite -ltNge; move/ltW; rewrite -sqrtr_eq0; move/eqP->.\nrewrite -(@ler_pXn2r R 2) ?nnegrE ?sqrtr_ge0 //.\nby rewrite !sqr_sqrtr // (le_trans pa).\nQed."
}
{
  "statement": "Lemma subseq_rev s1 s2 : subseq (rev s1) (rev s2) = subseq s1 s2.\n",
  "proof": "Proof.\nwlog suff W : s1 s2 / subseq s1 s2 -> subseq (rev s1) (rev s2).\n  by apply/idP/idP => /W //; rewrite !revK.\nby case/subseqP => m size_m ->; rewrite rev_mask // mask_subseq.\nQed."
}
{
  "statement": "Lemma bigmin_le_cond j P F : P j -> \\big[min/x]_(i | P i) F i <= F j.\n",
  "proof": "Proof.\nhave := mem_index_enum j; rewrite unlock; elim: (index_enum I) => //= i l ih.\nrewrite inE => /orP [/eqP-> ->|/ih leminlfi Pi]; first by rewrite ge_min lexx.\nby case: ifPn => Pj; [rewrite ge_min leminlfi// orbC|exact: leminlfi].\nQed."
}
{
  "statement": "Lemma maxn_minl : left_distributive maxn minn.\n",
  "proof": "Proof.\nmove=> m1 m2 n; wlog le_m21: m1 m2 / m2 <= m1.\n  move=> IH; case/orP: (leq_total m2 m1) => /IH //.\n  by rewrite minnC [in R in _ = R]minnC.\nrewrite (minn_idPr le_m21); apply/esym/minn_idPr.\nby rewrite geq_max leq_maxr leq_max le_m21.\nQed."
}
{
  "statement": "Lemma mulmxA m n p q (A : 'M_(m, n)) (B : 'M_(n, p)) (C : 'M_(p, q)) :\n  A *m (B *m C) = A *m B *m C.\n",
  "proof": "Proof.\napply/matrixP=> i l /[!mxE]; under eq_bigr do rewrite mxE big_distrr/=.\nrewrite exchange_big; apply: eq_bigr => j _; rewrite mxE big_distrl /=.\nby under eq_bigr do rewrite mulrA.\nQed."
}
{
  "statement": "Lemma cfInd_on A phi :\n  H \\subset G -> phi \\in 'CF(H, A) -> 'Ind[G] phi \\in 'CF(G, class_support A G).\n",
  "proof": "Proof.\nmove=> sHG Af; apply/cfun_onP=> g AG'g; rewrite cfIndE ?big1 ?mulr0 // => h Gh.\napply: (cfun_on0 Af); apply: contra AG'g => Agh.\nby rewrite -[g](conjgK h) memJ_class_support // groupV.\nQed."
}
{
  "statement": "Lemma egcdzP m n : egcdz_spec m n (egcdz m n).\n",
  "proof": "Proof.\nrewrite /egcdz; have [-> | m_nz] := eqVneq.\n  by split; [rewrite -abszEsign gcd0z | rewrite coprimezE absz_sign].\nhave m_gt0 : (`|m| > 0)%N by rewrite absz_gt0.\ncase: egcdnP (coprime_egcdn `|n| m_gt0) => //= u v Duv _ co_uv; split.\n  rewrite !mulNr -!mulrA mulrCA -abszEsg mulrCA -abszEsign.\n  by rewrite -!PoszM Duv addnC PoszD addrK.\nby rewrite coprimezE abszM absz_sg m_nz mul1n mulNr abszN abszMsign.\nQed."
}
{
  "statement": "Lemma edivnD m n d (offset := m %% d + n %% d >= d) : 0 < d ->\n   edivn (m + n) d = (m %/ d + n %/ d + offset, m %% d + n %% d - offset * d).\n",
  "proof": "Proof.\nrewrite {}/offset; case: d => // d _; rewrite /divn !modn_def.\ncase: (edivnP m d.+1) (edivnP n d.+1) => [/= q r -> r_lt] [/= p s -> s_lt].\nrewrite addnACA -mulnDl; have [r_le s_le] := (ltnW r_lt, ltnW s_lt).\nhave [d_ge|d_lt] := leqP; first by rewrite addn0 mul0n subn0 edivn_eq.\nrewrite addn1 mul1n -[in LHS](subnKC d_lt) addnA -mulSnr edivn_eq//.\nby rewrite ltn_subLR// -addnS leq_add.\nQed."
}
{
  "statement": "Lemma sh_inv : sh^-1 = sh.\n",
  "proof": "Proof.\napply: (mulIg sh); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed."
}
{
  "statement": "Lemma Sylow_gen G : <<\\bigcup_(P : {group gT} | Sylow G P) P>> = G.\n",
  "proof": "Proof.\nset T := [set P : {group gT} | Sylow G P].\nrewrite -{2}(@Sylow_transversal_gen T G) => [|P | q _].\n- by congr <<_>>; apply: eq_bigl => P; rewrite inE.\n- by rewrite inE => /and3P[].\nby case: (Sylow_exists q G) => P sylP; exists P; rewrite // inE (p_Sylow sylP).\nQed."
}
{
  "statement": "Lemma SymE : Sym S = 'C(~: S | 'P).\n",
  "proof": "Proof.\napply/setP => s; rewrite inE; apply/idP/astabP => [sS x|/= S_id].\n  by rewrite inE /= apermE => /out_perm->.\nby apply/subsetP => x; move=> /(contra_neqN (S_id _)); rewrite inE negbK.\nQed."
}
{
  "statement": "Lemma matrix_of_formK : form_of_matrix theta (matrix_of_form form) =2 form.\n",
  "proof": "Proof.\nset f := (X in X =2 _); have f_eq i j : f 'e_i 'e_j = form 'e_i 'e_j.\n  by rewrite /f rV_formee mxE.\nmove=> u v; rewrite [u]row_sum_delta [v]row_sum_delta /f.\nrewrite !linear_sum/=; apply: eq_bigr => j _.\nrewrite !linear_sumlz/=; apply: eq_bigr => i _.\nby rewrite !linearZlr/= -f_eq.\nQed."
}
{
  "statement": "Lemma cfker_Res phi :\n  H \\subset G -> phi \\is a character -> cfker ('Res[H] phi) = H :&: cfker phi.\n",
  "proof": "Proof.\nmove=> sHG Nphi; apply/setP=> x; rewrite !cfkerEchar ?cfRes_char // !inE.\nby apply/andb_id2l=> Hx; rewrite (subsetP sHG) ?cfResE.\nQed."
}
{
  "statement": "Lemma prodrM_comm {I : eqType} r (P : pred I) (F G : I -> R) :\n    (forall i j, P i -> P j -> comm (F i) (G j)) ->\n  \\prod_(i <- r | P i) (F i * G i) =\n    \\prod_(i <- r | P i) F i * \\prod_(i <- r | P i) G i.\n",
  "proof": "Proof.\nmove=> FG; elim: r => [|i r IHr]; rewrite !(big_nil, big_cons) ?mulr1//.\ncase: ifPn => // Pi; rewrite IHr !mulrA; congr (_ * _); rewrite -!mulrA.\nby rewrite commr_prod // => j Pj; apply/commr_sym/FG.\nQed."
}
{
  "statement": "Lemma rev_reshape sh s :\n  size s = sumn sh -> rev (reshape sh s) = map rev (reshape (rev sh) (rev s)).\n",
  "proof": "Proof.\nmove=> sz_s; apply/(canLR revK)/eq_from_flatten_shape.\n  rewrite reshapeKr ?sz_s // -rev_flatten reshapeKr ?revK //.\n  by rewrite size_rev sumn_rev sz_s.\ntransitivity (rev (shape (reshape (rev sh) (rev s)))).\n  by rewrite !reshapeKl ?revK ?size_rev ?sz_s ?sumn_rev.\nrewrite shape_rev; congr (rev _); rewrite -[RHS]map_comp.\nby under eq_map do rewrite /= size_rev.\nQed."
}
{
  "statement": "Lemma coprimeP n m :\n  n > 0 -> reflect (exists u, u.1 * n - u.2 * m = 1) (coprime n m).\n",
  "proof": "Proof.\nmove=> n_gt0; apply: (iffP eqP) => [<-| [[kn km] /= kn_km_1]].\n  by have [kn km kg _] := egcdnP m n_gt0; exists (kn, km); rewrite kg addKn.\napply gcdn_def; rewrite ?dvd1n // => d dv_d_n dv_d_m.\nby rewrite -kn_km_1 dvdn_subr ?dvdn_mull // ltnW // -subn_gt0 kn_km_1.\nQed."
}
{
  "statement": "Lemma unitrMl x y : y \\is a unit -> (x * y \\is a unit) = (x \\is a unit).\n",
  "proof": "Proof.\nmove=> Uy; wlog Ux: x y Uy / x \\is a unit => [WHxy|].\n  by apply/idP/idP=> Ux; first rewrite -(mulrK Uy x); rewrite WHxy ?unitrV.\nrewrite Ux; apply/unitrP; exists (y^-1 * x^-1).\nby rewrite -!mulrA mulKr ?mulrA ?mulrK ?divrr ?mulVr.\nQed."
}
{
  "statement": "Lemma Fermat's_little_theorem (L : fieldExtType F) (K : {subfield L}) a :\n  (a \\in K) = (a ^+ order K == a).\n",
  "proof": "Proof.\nmove: K a; wlog [{}L -> K a]: L / exists galL : splittingFieldType F, L = galL.\n  by pose galL := FinSplittingFieldType F L => /(_ galL); apply; exists galL.\nhave /galois_fixedField fixLK := finField_galois (subvf K).\nhave [alpha defGalLK Dalpha] := finField_galois_generator (subvf K).\nrewrite -Dalpha ?memvf // -{1}fixLK (('Gal(_ / _) =P _) defGalLK).\nrewrite /cycle -gal_generated (galois_fixedField _) ?fixedField_galois //.\nby apply/fixedFieldP/eqP=> [|-> | alpha_x _ /set1P->]; rewrite ?memvf ?set11.\nQed."
}
{
  "statement": "Lemma tag_enumP : Finite.axiom tag_enum.\n",
  "proof": "Proof.\ncase=> i x; rewrite -(enumP i) /tag_enum -enumT.\nelim: (enum I) => //= j e IHe.\nrewrite count_cat count_map {}IHe; congr (_ + _).\nrewrite -size_filter -cardE /=; case: eqP => [-> | ne_j_i].\n  by apply: (@eq_card1 _ x) => y; rewrite -topredE /= tagged_asE ?eqxx.\nby apply: eq_card0 => y.\nQed."
}
{
  "statement": "Lemma abelem_rowgJ m (A : 'M_(m, n)) x :\n  x \\in G -> rV_E @* rowg (A *m rG x) = (rV_E @* rowg A) :^ x.\n",
  "proof": "Proof.\nmove=> Gx; apply: (canRL (conjsgKV _)); apply/setP=> y.\nrewrite mem_conjgV !morphim_invmE !inE memJ_norm ?(subsetP nEG) //=.\napply: andb_id2l => Ey; rewrite abelem_rV_J //.\nby rewrite submxMfree // row_free_unit (repr_mx_unit rG).\nQed."
}
{
  "statement": "Lemma sizeT_qf (p : polyF) : rpoly p -> qf_cps xpredT (sizeT p).\n",
  "proof": "Proof.\nelim: p => /= [_|c p ihp /andP[rc rq]]; first exact: qf_cps_ret.\napply: qf_cps_bind; first exact: ihp.\nmove=> [|n] //= _; last exact: qf_cps_ret.\nby apply: qf_cps_if; rewrite //= rc.\nQed."
}
{
  "statement": "Lemma trow0 n1 m2 n2 B : @trow n1 0 m2 n2 B = 0.\n",
  "proof": "Proof.\nelim: n1=> //= n1 IH.\nrewrite !mxE scale0r linear0.\nrewrite IH //; apply/matrixP=> i j; rewrite !mxE.\nby case: split=> *; rewrite mxE.\nQed."
}
{
  "statement": "Lemma eqmx_rowsub_comp (m n p q : nat) f (g : 'I_n -> 'I_p) (A : 'M_(m, q)) :\n  p <= n -> injective g -> (rowsub (f \\o g) A :=: rowsub f A)%MS.\n",
  "proof": "Proof.\nmove=> leq_pn g_inj; have eq_np : n == p by rewrite eqn_leq leq_pn (inj_leq g).\nrewrite (eqP eq_np) in g g_inj *.\nrewrite (eq_rowsub (f \\o (perm g_inj))); last by move=> i; rewrite /= permE.\nexact: eqmx_rowsub_comp_perm.\nQed."
}
{
  "statement": "Lemma partnC pi n : n > 0 -> n`_pi * n`_pi^' = n.\n",
  "proof": "Proof.\nmove=> n_gt0; rewrite -[RHS]partnT /partn //.\ndo 2!rewrite mulnC big_mkcond /=; rewrite -big_split; apply: eq_bigr => p _ /=.\nby rewrite mulnC inE /=; case: (p \\in pi); rewrite /= (muln1, mul1n).\nQed."
}
{
  "statement": "Lemma prime_cyclic G : prime #|G| -> cyclic G.\n",
  "proof": "Proof.\ncase/primeP; rewrite ltnNge -trivg_card_le1.\ncase/trivgPn=> x Gx ntx /(_ _ (order_dvdG Gx)).\nrewrite order_eq1 (negbTE ntx) => /eqnP oxG; apply/cyclicP.\nby exists x; apply/eqP; rewrite eq_sym eqEcard -oxG cycle_subG Gx leqnn.\nQed."
}
{
  "statement": "Lemma pnElem0 p G : 'E_p^0(G) = [set 1%G].\n",
  "proof": "Proof.\napply/setP=> E; rewrite !inE -andbA; apply/and3P/idP=> [[_ pE] | /eqP->].\n  apply: contraLR; case/(pgroup_pdiv (abelem_pgroup pE)) => p_pr _ [k ->].\n  by rewrite pfactorK.\nby rewrite sub1G abelem1 cards1 logn1.\nQed."
}
{
  "statement": "Lemma kHom_dim K E f : kHom K E f -> \\dim (f @: E) = \\dim E.\n",
  "proof": "Proof.\nmove=> homKf; have [fM idKf] := kHomP homKf.\napply/limg_dim_eq/eqP; rewrite -subv0; apply/subvP=> v.\nrewrite memv_cap memv0 memv_ker => /andP[Ev]; apply: contraLR => nz_v.\nby rewrite -unitfE unitrE -(kHom_inv homKf) // -fM ?rpredV ?divff ?idKf ?mem1v.\nQed."
}
{
  "statement": "Lemma injm_nil G : 'injm f -> G \\subset D -> nilpotent (f @* G) = nilpotent G.\n",
  "proof": "Proof.\nmove=> injf sGD; apply/idP/idP; last exact: morphim_nil.\ncase/ucnP=> n; rewrite -injm_ucn // => /injm_morphim_inj defZ.\nby apply/ucnP; exists n; rewrite defZ ?gFsub_trans.\nQed."
}
{
  "statement": "Lemma Phi_cprod G H K :\n  p.-group G -> H \\* K = G -> 'Phi(H) \\* 'Phi(K) = 'Phi(G).\n",
  "proof": "Proof.\nmove=> pG defG; have [_ /mulG_sub[sHG sKG] cHK] := cprodP defG.\nrewrite cprodEY /=; last by rewrite (centSS (Phi_sub _) (Phi_sub _)).\nrewrite !(Phi_joing (pgroupS _ pG)) //=.\nhave /cprodP[_ <- /cent_joinEr <-] := der_cprod 1 defG.\nhave /cprodP[_ <- /cent_joinEr <-] := Mho_cprod 1 defG.\nby rewrite !joingA /= -!(joingA H^`(1)) (joingC K^`(1)).\nQed."
}
{
  "statement": "Lemma exprDn_comm x y n (cxy : comm x y) :\n  (x + y) ^+ n = \\sum_(i < n.+1) (x ^+ (n - i) * y ^+ i) *+ 'C(n, i).\n",
  "proof": "Proof.\nelim: n => [|n IHn]; rewrite big_ord_recl mulr1 ?big_ord0 ?addr0 //=.\nrewrite exprS {}IHn /= mulrDl !big_distrr /= big_ord_recl mulr1 subn0.\nrewrite !big_ord_recr /= !binn !subnn !mul1r !subn0 bin0 !exprS -addrA.\ncongr (_ + _); rewrite addrA -big_split /=; congr (_ + _).\napply: eq_bigr => i _; rewrite !mulrnAr !mulrA -exprS -subSn ?(valP i) //.\nby rewrite subSS (commrX _ (commr_sym cxy)) -mulrA -exprS -mulrnDr.\nQed."
}
{
  "statement": "Lemma sumsmxMr_gen P m n A (B : 'M[F]_(m, n)) :\n  ((\\sum_(i | P i) A i)%MS *m B :=: \\sum_(i | P i) <<A i *m B>>)%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split; last first.\n  by apply/sumsmx_subP=> i Pi; rewrite genmxE submxMr ?(sumsmx_sup i).\nhave [u ->] := sub_sumsmxP _ _ _ (submx_refl (\\sum_(i | P i) A i)%MS).\nby rewrite mulmx_suml summx_sub_sums // => i _; rewrite genmxE -mulmxA submxMl.\nQed."
}
{
  "statement": "Lemma minset_exists P C : P C -> {A | minset P A & A \\subset C}.\n",
  "proof": "Proof.\nmove=> PC; have{PC}: exists A, P A && (A \\subset C) by exists C; rewrite PC /=.\ncase/ex_minset=> A /minsetP[/andP[PA sAC] minA]; exists A => //; apply/minsetP.\nby split=> // B PB sBA; rewrite (minA B) // PB (subset_trans sBA).\nQed."
}
{
  "statement": "Lemma rfix_morphpre (H : {set aT}) :\n  H \\subset D -> (rfix_mx rGf H :=: rfix_mx rG (f @* H))%MS.\n",
  "proof": "Proof.\nmove=> sHD; apply/eqmxP/andP; split.\n  by apply/rfix_mxP=> _ /morphimP[x _ Hx ->]; rewrite rfix_mx_id.\nby apply/rfix_mxP=> x Hx; rewrite rfix_mx_id ?mem_morphim ?(subsetP sHD).\nQed."
}
{
  "statement": "Lemma Gauss_dvdpl p q d: coprimep d q -> (d %| p * q) = (d %| p).\n",
  "proof": "Proof.\nmove/Bezout_coprimepP=>[[u v] Puv]; apply/idP/idP; last exact: dvdp_mulr.\nmove/(eqp_mull p): Puv; rewrite mulr1 mulrDr eqp_sym=> peq dpq.\nrewrite (eqp_dvdr _ peq) dvdp_addr; first by rewrite mulrA mulrAC dvdp_mulr.\nby rewrite mulrA dvdp_mull ?dvdpp.\nQed."
}
{
  "statement": "Lemma Cint_span_zmod_closed s : zmod_closed (Cint_span s).\n",
  "proof": "Proof.\nhave sP := Cint_spanP (in_tuple s); split=> [|_ _ /sP[x ->] /sP[y ->]].\n  by apply/sP; exists 0; rewrite big1 // => i; rewrite ffunE.\napply/sP; exists (x - y); rewrite -sumrB; apply: eq_bigr => i _.\nby rewrite !ffunE raddfB.\nQed."
}
{
  "statement": "Lemma cfclassInorm phi : (phi ^: 'N_G(H) =i phi ^: G)%CF.\n",
  "proof": "Proof.\nmove=> xi; apply/cfclassP/cfclassP=> [[x /setIP[Gx _] ->] | [x Gx ->]].\n  by exists x.\nhave [Nx | /cfConjgEout-> //] := boolP (x \\in 'N(H)).\n  by exists x; first apply/setIP.\nby exists 1%g; rewrite ?group1 ?cfConjgJ1.\nQed."
}
{
  "statement": "Lemma map_preim (s : seq T') : {subset s <= codom f} -> map f (preim_seq s) = s.\n",
  "proof": "Proof.\nelim: s => //= y s IHs; case: pickP => [x /eqP fx_y | nfTy] fTs.\n  by rewrite /= fx_y IHs // => z s_z; apply: fTs; apply: predU1r.\nby case/imageP: (fTs y (mem_head y s)) => x _ fx_y; case/eqP: (nfTy x).\nQed."
}
{
  "statement": "Lemma p2Elem_dprodP p A E X Y :\n    E \\in 'E_p^2(A) -> X \\in 'E_p^1(E) -> Y \\in 'E_p^1(E) ->\n  reflect (X \\x Y = E) (X :!=: Y).\n",
  "proof": "Proof.\nmove=> Ep2E EpX EpY; have [_ abelE oE] := pnElemPcard Ep2E.\napply: (iffP (TIp1ElemP EpX EpY)) => [tiXY|]; last by case/dprodP.\nhave [[sXE _ oX] [sYE _ oY]] := (pnElemPcard EpX, pnElemPcard EpY).\nrewrite dprodE ?(sub_abelian_cent2 (abelem_abelian abelE)) //.\nby apply/eqP; rewrite eqEcard mul_subG //= TI_cardMg // oX oY oE.\nQed."
}
{
  "statement": "Lemma big_rem_AC (I : eqType) (r : seq I) z (P : pred I) F : z \\in r ->\n  \\big[op/x]_(y <- r | P y) F y\n    = if P z then op (F z) (\\big[op/x]_(y <- rem z r | P y) F y)\n      else \\big[op/x]_(y <- rem z r | P y) F y.\n",
  "proof": "Proof.\nelim: r =>// i r ih; rewrite big_cons rem_cons inE =>/predU1P[-> /[!eqxx]//|zr].\nby case: eqP => [-> //|]; rewrite ih// big_cons; case: ifPn; case: ifPn.\nQed."
}
{
  "statement": "Lemma eq_maxrowsub : (rowsub mxf A :=: A)%MS.\n",
  "proof": "Proof.\napply/eqmxP; rewrite -(eq_leqif (mxrank_leqif_eq _))//.\n  exact: maxrowsub_free.\napply/row_subP => i; apply/submxP; exists (delta_mx 0 (mxf i)).\nby rewrite -rowE; apply/rowP => j; rewrite !mxE.\nQed."
}
{
  "statement": "Lemma orbit_in_eqP G x y :\n  G \\subset D -> reflect (orbit to G x = orbit to G y) (x \\in orbit to G y).\n",
  "proof": "Proof.\nmove=> sGD; apply: (iffP idP) => [yGx|<-]; last exact: orbit_refl.\nby apply/setP=> z; apply/idP/idP=> /orbit_in_trans-> //; rewrite orbit_in_sym.\nQed."
}
{
  "statement": "Lemma leqif_trans m1 m2 m3 C12 C23 :\n  m1 <= m2 ?= iff C12 -> m2 <= m3 ?= iff C23 -> m1 <= m3 ?= iff C12 && C23.\n",
  "proof": "Proof.\nmove=> ltm12 ltm23; apply/leqifP; rewrite -ltm12.\nhave [->|eqm12] := eqVneq; first by rewrite ltn_neqAle !ltm23 andbT; case C23.\nby rewrite (@leq_trans m2) ?ltm23 // ltn_neqAle eqm12 ltm12.\nQed."
}
{
  "statement": "Lemma pathP x p x0 :\n  reflect (forall i, i < size p -> e (nth x0 (x :: p) i) (nth x0 p i))\n          (path x p).\n",
  "proof": "Proof.\nelim: p x => [|y p IHp] x /=; first by left.\napply: (iffP andP) => [[e_xy /IHp e_p [] //] | e_p].\nby split; [apply: (e_p 0) | apply/(IHp y) => i; apply: e_p i.+1].\nQed."
}
{
  "statement": "Lemma eqp_gdcor p q r : q %= r -> gdcop p q %= gdcop p r.\n",
  "proof": "Proof.\nmove=> eqr; rewrite /gdcop (eqp_size eqr).\nmove: (size r)=> n; elim: n p q r eqr => [|n ihn] p q r; first by rewrite eqpxx.\nmove=> eqr /=; rewrite (eqp_coprimepl p eqr); case: ifP => _ //.\nexact/ihn/eqp_div/eqp_gcdl.\nQed."
}
{
  "statement": "Lemma prodvA : associative prodv.\n",
  "proof": "Proof.\nmove=> U V W; rewrite -(span_basis (vbasisP U)) span_def !big_distrl /=.\napply: eq_bigr => u _; rewrite -(span_basis (vbasisP W)) span_def !big_distrr.\napply: eq_bigr => w _; rewrite -(span_basis (vbasisP V)) span_def /=.\nrewrite !(big_distrl, big_distrr) /=; apply: eq_bigr => v _.\nby rewrite !prodv_line mulrA.\nQed."
}
{
  "statement": "Lemma lead_coef_comp p q : size q > 1 ->\n  lead_coef (p \\Po q) = (lead_coef p) * lead_coef q ^+ (size p).-1.\n",
  "proof": "Proof.\nmove=> q_gt1; rewrite !lead_coefE coef_comp_poly size_comp_poly.\nhave [->|nz_p] := eqVneq p 0; first by rewrite size_poly0 big_ord0 coef0 mul0r.\nrewrite polySpred //= big_ord_recr /= big1 ?add0r => [|i _].\n  by rewrite -!lead_coefE -lead_coef_exp !lead_coefE size_exp mulnC.\nrewrite [X in _ * X]nth_default ?mulr0 ?(leq_trans (size_poly_exp_leq _ _)) //.\nby rewrite mulnC ltn_mul2r -subn1 subn_gt0 q_gt1 /=.\nQed."
}
{
  "statement": "Lemma comm_norm_cent_cent H G K :\n    H \\subset 'N(G) -> H \\subset 'C(K) -> G \\subset 'N(K) ->\n  [~: G, H] \\subset 'C(K).\n",
  "proof": "Proof.\nmove=> nGH /centsP cKH nKG; rewrite commGC gen_subG centsC.\napply/centsP=> x Kx _ /imset2P[y z Hy Gz ->]; red.\nrewrite mulgA -[x * _]cKH ?groupV // -!mulgA; congr (_ * _).\nrewrite (mulgA x) (conjgC x) (conjgCV z) 3!mulgA; congr (_ * _).\nby rewrite -2!mulgA (cKH y) // -mem_conjg (normsP nKG).\nQed."
}
{
  "statement": "Lemma rker_mx_rsim n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> rker rG1 = rker rG2.\n",
  "proof": "Proof.\ncase=> f def_n2; rewrite -{n2}def_n2 in f rG2 *.\nrewrite row_free_unit => injf homf.\napply/setP=> x; rewrite !inE !mul1mx; apply: andb_id2l => Gx.\nby rewrite -(can_eq (mulmxK injf)) homf // -scalar_mxC (can_eq (mulKmx injf)).\nQed."
}
{
  "statement": "Lemma rdvdp_eqP p : rdvdp_spec p d (rmodp p d) (rdvdp d p).\n",
  "proof": "Proof.\ncase hdvd: (rdvdp d p); last by apply: RdvdpN; move/rmodp_eq0P/eqP: hdvd.\nmove/rmodp_eq0P: (hdvd)->; apply: (@Rdvdp _ _ (rscalp p d) (rdivp p d)).\nby rewrite rdivp_eq //; move/rmodp_eq0P: (hdvd)->; rewrite addr0.\nQed."
}
{
  "statement": "Lemma injm_generator G H (f : {morphism G >-> rT}) x :\n    'injm f -> x \\in G -> H \\subset G ->\n  generator (f @* H) (f x) = generator H x.\n",
  "proof": "Proof.\nmove=> injf Gx sHG; apply/idP/idP; last exact: morph_generator.\nrewrite -{2}(morphim_invm injf sHG) -{2}(invmE injf Gx).\nby apply: morph_generator; apply: mem_morphim.\nQed."
}
{
  "statement": "Lemma injm_xcprodm : 'injm xcprodm = 'injm fH && 'injm fK.\n",
  "proof": "Proof.\nrewrite injm_cprodm !ker_ifactm !subG1 !morphim_injm_eq1 ?subsetIl // -!subG1.\napply: andb_id2l => /= injfH; apply: andb_idr => _.\nrewrite !im_ifactm // -(morphimIdom gH) setI_im_cpair -injm_center //.\nrewrite morphim_ifactm // eqEsubset subsetI morphimS //=.\nrewrite {1}injm_center // setIS //=.\nrewrite (eq_in_morphim _ eq_fHK); first by rewrite morphim_comp morphimS.\nby rewrite !(setIidPr _) // -sub_morphim_pre.\nQed."
}
{
  "statement": "Lemma sub_addsmxP m1 m2 m3 n\n                  (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  reflect (exists u, A = u.1 *m B + u.2 *m C) (A <= B + C)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [|[u ->]]; last by rewrite addmx_sub_adds ?submxMl.\nrewrite addsmxE; case/submxP=> u ->; exists (lsubmx u, rsubmx u).\nby rewrite -mul_row_col hsubmxK.\nQed."
}
{
  "statement": "Lemma eq_subG_cyclic G H K :\n  cyclic G -> H \\subset G -> K \\subset G -> (H :==: K) = (#|H| == #|K|).\n",
  "proof": "Proof.\ncase/cyclicP=> x -> sHx sKx; apply/eqP/eqP=> [-> //| eqHK].\nhave def_GHx := cycle_sub_group (cardSg sHx); set GHx := [set _] in def_GHx.\nhave []: H \\in GHx /\\ K \\in GHx by rewrite -def_GHx !inE sHx sKx eqHK /=.\nby do 2!move/set1P->.\nQed."
}
{
  "statement": "Lemma normalC p q (A : 'M_(p, n)) (B : 'M_(q, n)) : (A '_|_ B) = (B '_|_ A).\n",
  "proof": "Proof.\ngen have nC : p q A B / A '_|_ B -> B '_|_ A; last by apply/idP/idP; apply/nC.\nmove=> AnB; apply/normalP => u v ? ?; rewrite normalE.\nrewrite formC mulf_eq0 ?fmorph_eq0 ?signr_eq0 /=.\nby rewrite -normalE (normalP _ _ AnB).\nQed."
}
{
  "statement": "Lemma pcore_modp pi gT (G H : {group gT}) :\n  H <| G -> pi.-group H -> pcore_mod G pi H = 'O_pi(G).\n",
  "proof": "Proof.\nmove=> nsHG piH; have nHG := normal_norm nsHG; apply/eqP.\nrewrite eqEsubset andbC -sub_morphim_pre ?(gFsub_trans, morphim_pcore) //=.\nrewrite -[G in 'O_pi(G)](quotientGK nsHG) pcore_max //.\n  by rewrite -(pquotient_pgroup piH) ?subsetIl // cosetpreK pcore_pgroup.\nby rewrite morphpre_normal ?gFnormal ?gFsub_trans ?morphim_sub.\nQed."
}
{
  "statement": "Lemma mxminpoly_uconj n (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n  V \\in unitmx -> mxminpoly (conjmx V f) = mxminpoly f.\n",
  "proof": "Proof.\nhave simp := (row_free_unit, stablemx_unit, unitmx_inv, unitmx1).\nmove=> Vu; apply/eqP; rewrite -eqp_monic ?mxminpoly_monic// /eqp.\napply/andP; split; first by rewrite mxminpoly_conj ?simp.\nby rewrite -[f in X in X %| _](conjmxK _ Vu) mxminpoly_conj ?simp.\nQed."
}
{
  "statement": "Lemma mxminpoly_uconj n (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n  V \\in unitmx -> mxminpoly (conjmx V f) = mxminpoly f.\n",
  "proof": "Proof.\nhave simp := (row_free_unit, stablemx_unit, unitmx_inv, unitmx1).\nmove=> Vu; apply/eqP; rewrite -eqp_monic ?mxminpoly_monic// /eqp.\napply/andP; split; first by rewrite mxminpoly_conj ?simp.\nby rewrite -[f in X in X %| _](conjmxK _ Vu) mxminpoly_conj ?simp.\nQed."
}
{
  "statement": "Lemma uniqPn s :\n  reflect (exists i j, [/\\ i < j, j < size s & nth s i = nth s j]) (~~ uniq s).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[i [j [ltij ltjs]]]]; last first.\n  by apply: contra_eqN => Us; rewrite nth_uniq ?ltn_eqF // (ltn_trans ltij).\nelim: s => // x s IHs /nandP[/negbNE | /IHs[i [j]]]; last by exists i.+1, j.+1.\nby exists 0, (index x s).+1; rewrite !ltnS index_mem /= nth_index.\nQed."
}
{
  "statement": "Lemma setact_is_action : is_action D to^*.\n",
  "proof": "Proof.\nsplit=> [a R S eqRS | a b Da Db S]; last first.\n  by rewrite /setact /= -imset_comp; apply: eq_imset => x; apply: actMin.\napply/setP=> x; apply/idP/idP=> /(mem_setact a).\n  by rewrite eqRS => /imsetP[y Sy /act_inj->].\nby rewrite -eqRS => /imsetP[y Sy /act_inj->].\nQed."
}
{
  "statement": "Lemma permPl s1 s2 : reflect (perm_eql s1 s2) (perm_eq s1 s2).\n",
  "proof": "Proof.\napply: (iffP idP) => [eq12 s3 | -> //]; apply/idP/idP; last exact: perm_trans.\nby rewrite -!(perm_sym s3) => /perm_trans; apply.\nQed."
}
{
  "statement": "Lemma nth_index_map s x0 x :\n  {in s &, injective f} -> x \\in s -> nth x0 s (index (f x) (map f s)) = x.\n",
  "proof": "Proof.\nelim: s => //= y s IHs inj_f s_x; rewrite (inj_in_eq inj_f) ?mem_head //.\nmove: s_x; rewrite inE; have [-> // | _] := eqVneq; apply: IHs.\nby apply: sub_in2 inj_f => z; apply: predU1r.\nQed."
}
{
  "statement": "Lemma memv_mul U V : {in U & V, forall u v, u * v \\in (U * V)%VS}.\n",
  "proof": "Proof.\nmove=> u v /coord_vbasis-> /coord_vbasis->.\nrewrite mulr_suml; apply: memv_suml => i _.\nrewrite mulr_sumr; apply: memv_suml => j _.\nrewrite -scalerAl -scalerAr !memvZ // [prodv]unlock memv_span //.\nby apply/allpairsP; exists ((vbasis U)`_i, (vbasis V)`_j); rewrite !memt_nth.\nQed."
}
{
  "statement": "Lemma rat_eq x y : (x == y) = (numq x * denq y == numq y * denq x).\n",
  "proof": "Proof.\nsymmetry; rewrite rat_eqE andbC.\nhave [->|] /= := eqVneq (denq _); first by rewrite (inj_eq (mulIf _)).\napply: contraNF => /eqP hxy; rewrite -absz_denq -[eqbRHS]absz_denq.\nrewrite eqz_nat /= eqn_dvd.\nrewrite -(@Gauss_dvdr _ `|numq x|) 1?coprime_sym ?coprime_num_den // andbC.\nrewrite -(@Gauss_dvdr _ `|numq y|) 1?coprime_sym ?coprime_num_den //.\nby rewrite -!abszM hxy -{1}hxy !abszM !dvdn_mull ?dvdnn.\nQed."
}
{
  "statement": "Lemma subset_cons2 s1 s2 x : s1 \\subset s2 -> x :: s1 \\subset x :: s2.\n",
  "proof": "Proof.\nby move=> ?; apply/subsetP => y /[!inE]; case: eqP => // _; apply: subsetP.\nQed."
}
{
  "statement": "Lemma onthPn s x : reflect (forall i, onth s i != Some x) (x \\notin s).\n",
  "proof": "Proof.\napply: (iffP idP); first by move=> /onthP + i; apply: contra_not_neq; exists i.\nby move=> nsix; apply/onthP => -[n /eqP/negPn]; rewrite nsix.\nQed."
}
{
  "statement": "Lemma connect_rev e : connect [rel x y | e y x] =2 [rel x y | connect e y x].\n",
  "proof": "Proof.\nsuff crev e': subrel (connect [rel x y | e' y x]) [rel x y | connect e' y x].\n  by move=> x y; apply/idP/idP; apply: crev.\nmove=> x y /connectP[p e_p p_y]; apply/connectP.\nexists (rev (belast x p)); first by rewrite p_y rev_path.\nby rewrite -(last_cons x) -rev_rcons p_y -lastI rev_cons last_rcons.\nQed."
}
{
  "statement": "Lemma MhoS H G : H \\subset G -> 'Mho^n(H) \\subset 'Mho^n(G).\n",
  "proof": "Proof.\nmove=> sHG; apply: genS; apply: imsetS; apply/subsetP=> x.\nby rewrite !inE => /andP[Hx]; rewrite (subsetP sHG).\nQed."
}
{
  "statement": "Lemma kHom_eq K E f g :\n  (K <= E)%VS -> {in E, f =1 g} -> kHom K E f = kHom K E g.\n",
  "proof": "Proof.\nmove/subvP=> sKE eq_fg; wlog suffices: f g eq_fg / kHom K E f -> kHom K E g.\n  by move=> IH; apply/idP/idP; apply: IH => x /eq_fg.\ncase/kHomP=> fM idKf; apply/kHomP.\nby split=> [x y Ex Ey | x Kx]; rewrite -!eq_fg ?fM ?rpredM // ?idKf ?sKE.\nQed."
}
{
  "statement": "Lemma trunc_log_bounds p n :\n  1 < p -> 0 < n -> let k := trunc_log p n in p ^ k <= n < p ^ k.+1.\n",
  "proof": "Proof.\nrewrite {+}/trunc_log => p_gt1; have p_gt0 := ltnW p_gt1.\nrewrite [p <= 1]leqNgt p_gt1 /=.\nset loop := (loop in loop n n); set m := n; rewrite [in n in loop m n]/m.\nhave: m <= n by []; elim: n m => [|n IHn] [|m] //= /ltnSE-le_m_n _.\nhave [le_p_n | // ] := leqP p _; rewrite 2!expnSr -leq_divRL -?ltn_divLR //.\nby apply: IHn; rewrite ?divn_gt0 // -ltnS (leq_trans (ltn_Pdiv _ _)).\nQed."
}
{
  "statement": "Lemma component_mx_disjoint U V :\n    mxsimple U -> mxsimple V -> component_mx U != component_mx V ->\n  (component_mx U :&: component_mx V = 0)%MS.\n",
  "proof": "Proof.\nmove=> simU simV neUV; apply: contraNeq neUV => ntUV.\napply: (mxsimple_exists _ ntUV) => [|[W simW]].\n  by rewrite capmx_module ?component_mx_module.\nrewrite sub_capmx => /andP[sWU sWV]; apply/component_mx_isoP=> //.\nby apply: mx_iso_trans (_ : mx_iso U W) (mx_iso_sym _); apply: component_mx_iso.\nQed."
}
{
  "statement": "Lemma repr_class x : {y | y \\in G & repr (x ^: G) = x ^ y}.\n",
  "proof": "Proof.\nset z := repr _; have: #|[set y in G | z == x ^ y]| > 0.\n  have: z \\in x ^: G by apply: (mem_repr x).\n  by case/imsetP=> y Gy ->; rewrite (cardD1 y) inE Gy eqxx.\nby move/card_mem_repr; move: (repr _) => y /setIdP[Gy /eqP]; exists y.\nQed."
}
{
  "statement": "Lemma dvdn_pcharf n : (p %| n)%N = (n%:R == 0 :> R).\n",
  "proof": "Proof.\napply/idP/eqP=> [/dvdnP[n' ->]|n0]; first by rewrite natrM pcharf0 mulr0.\napply/idPn; rewrite -prime_coprime // => /eqnP pn1.\nhave [a _ /dvdnP[b]] := Bezoutl n (prime_gt0 pcharf_prime).\nmove/(congr1 (fun m => m%:R : R))/eqP.\nby rewrite natrD !natrM pcharf0 n0 !mulr0 pn1 addr0 oner_eq0.\nQed."
}
{
  "statement": "Lemma ex_maxgroup : (exists G, gP G) -> {G : {group gT} | maxgroup G gP}.\n",
  "proof": "Proof.\nmove=> exP; have [A maxA]: {A | maxgroup A gP}.\n  apply: ex_maxset; case: exP => G gPG.\n  by exists (G : {set gT}); rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (maxsetp maxA).\nQed."
}
{
  "statement": "Lemma ex_mingroup : (exists G, gP G) -> {G : {group gT} | mingroup G gP}.\n",
  "proof": "Proof.\nmove=> exP; have [A minA]: {A | mingroup A gP}.\n  apply: ex_minset; case: exP => G gPG.\n  by exists (G : {set gT}); rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (minsetp minA).\nQed."
}
{
  "statement": "Lemma charP H G :\n  let fixH (f : {morphism G >-> gT}) := 'injm f -> f @* G = G -> f @* H = H in\n  reflect [/\\ H \\subset G & forall f, fixH f] (H \\char G).\n",
  "proof": "Proof.\ndo [apply: (iffP andP) => -[sHG chHG]; split] => // [f injf Gf|].\n  by apply/morphim_fixP; rewrite // -imset_autE ?(forall_inP chHG) ?Aut_aut.\napply/forall_inP=> f Af; rewrite -(autmE Af) -morphimEsub //.\nby rewrite chHG ?injm_autm ?im_autm.\nQed."
}
{
  "statement": "Lemma mxsemisimple_reducible V : mxsemisimple V -> mx_completely_reducible V.\n",
  "proof": "Proof.\ncase=> [I W /= simW defV _] U modU sUV; rewrite -defV in sUV.\nhave [J [defV' dxV]] := sum_mxsimple_direct_compl simW modU sUV.\nexists (\\sum_(i in J) W i)%MS.\n- by apply: sumsmx_module => i _; case: (simW i).\n- exact: eqmx_trans defV' defV.\nby rewrite mxdirect_addsE (sameP eqP mxdirect_addsP) /= in dxV; case/and3P: dxV.\nQed."
}
{
  "statement": "Lemma rdvdp1 d : rdvdp d 1 = (size d == 1).\n",
  "proof": "Proof.\nrewrite /rdvdp; have [->|] := eqVneq d 0.\n  by rewrite rmodp0 size_poly0 (negPf (oner_neq0 _)).\nrewrite -size_poly_leq0 -ltnS; case: ltngtP => // [|/eqP] hd _.\n  by rewrite rmodp_small ?size_poly1 // oner_eq0.\nhave [c cn0 ->] := size_poly1P _ hd.\nrewrite /rmodp unlock -size_poly_eq0 size_poly1 /= size_poly1 size_polyC cn0 /=.\nby rewrite polyC_eq0 (negPf cn0) !lead_coefC !scale1r subrr !size_poly0.\nQed."
}
{
  "statement": "Lemma envelop_mx_ring : mxring (enveloping_algebra_mx rG).\n",
  "proof": "Proof.\napply/andP; split; first by apply/mulsmx_subP; apply: envelop_mxM.\napply/mxring_idP; exists 1%:M; split=> *; rewrite ?mulmx1 ?mul1mx //.\n  by rewrite -mxrank_eq0 mxrank1.\nexact: envelop_mx1.\nQed."
}
{
  "statement": "Lemma orthovP U V : reflect {in U & V, forall u v, '[u, v] = 0} (U '_|_ V)%VS.\n",
  "proof": "Proof.\napply: (iffP subvP); last by move=> H ??; apply/mem_orthovP=> ??; apply: H.\nby move=> /(_ _ _)/mem_orthovP; move=> H ????; apply: H.\nQed."
}
{
  "statement": "Lemma memvV A u : (u^-1 \\in A) = (u \\in A).\n",
  "proof": "Proof.\nsuffices{u} invA: invr_closed A by apply/idP/idP=> /invA; rewrite ?invrK.\nmove=> u Au; have [Uu | /invr_out-> //] := boolP (u \\is a GRing.unit).\nrewrite memvE -(limg_ker0 _ _ (lker0_amulr Uu)) limg_line lfunE /= mulVr //.\nsuff ->: (amulr u @: A)%VS = A by rewrite -memvE -algid_eq1 (unitr_algid1 Au).\nby apply/eqP; rewrite limg_amulr -dimv_leqif_eq ?prodv_sub ?dim_cosetv_unit.\nQed."
}
{
  "statement": "Lemma gcdp_mul2l p q r : gcdp (p * q) (p * r) %= (p * gcdp q r).\n",
  "proof": "Proof.\nhave [->|hp] := eqVneq p 0; first by rewrite !mul0r gcdp0 eqpxx.\nrewrite /eqp !dvdp_gcd !dvdp_mul2l // dvdp_gcdr dvdp_gcdl !andbT.\nmove: (Bezoutp q r) => [[u v]] huv.\nrewrite eqp_sym in huv; rewrite (eqp_dvdr _ (eqp_mull _ huv)).\nrewrite mulrDr ![p * (_ * _)]mulrCA.\nby apply: dvdp_add; rewrite dvdp_mull// (dvdp_gcdr, dvdp_gcdl).\nQed."
}
{
  "statement": "Lemma Bezoutp p q : exists u, u.1 * p + u.2 * q %= (gcdp p q).\n",
  "proof": "Proof.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite gcd0p; exists (0, 1); rewrite mul0r mul1r add0r.\nhave [-> | qn0] := eqVneq q 0.\n  by rewrite gcdp0; exists (1, 0); rewrite mul0r mul1r addr0.\npose e := egcdp p q; exists e; rewrite eqp_sym.\nby case: (egcdpP pn0 qn0).\nQed."
}
{
  "statement": "Lemma card_inj_ffuns_on D T (R : pred T) :\n  #|[set f : {ffun D -> T} in ffun_on R | injectiveb f]| = #|R| ^_ #|D|.\n",
  "proof": "Proof.\nrewrite -card_uniq_tuples.\nhave bijFF: {on (_ : pred _), bijective (@Finfun D T)}.\n  by exists fgraph => x _; [apply: FinfunK | apply: fgraphK].\nrewrite -(on_card_preimset (bijFF _)); apply: eq_card => /= t.\nrewrite !inE -(big_andE predT) -big_image /= big_all.\nby rewrite -[t in RHS]FinfunK -codom_ffun.\nQed."
}
{
  "statement": "Lemma perm_tally s1 s2 : perm_eq s1 s2 -> perm_eq (tally s1) (tally s2).\n",
  "proof": "Proof.\nmove=> eq_s12; apply: (@perm_trans _ [seq (x, count_mem x s2) | x <- undup s1]).\n  by congr perm_eq: (tallyE s1); under eq_map do rewrite (permP eq_s12).\nby rewrite (permPr (tallyE s2)); apply/perm_map/perm_undup/(perm_mem eq_s12).\nQed."
}
{
  "statement": "Lemma morphimV A : f @* A^-1 = (f @* A)^-1.\n",
  "proof": "Proof.\nwlog suffices: A / f @* A^-1 \\subset (f @* A)^-1.\n  by move=> IH; apply/eqP; rewrite eqEsubset IH -invSg invgK -{1}(invgK A) IH.\napply/subsetP=> _ /morphimP[x Dx Ax' ->]; rewrite !inE in Ax' *.\nby rewrite -morphV // imset_f // inE groupV Dx.\nQed."
}
{
  "statement": "Lemma pcharf0P : pchar R =i pred0 <-> (forall n, (n%:R == 0 :> R) = (n == 0)%N).\n",
  "proof": "Proof.\nsplit=> pcharF0 n; last by rewrite !inE pcharF0 andbC; case: eqP => // ->.\nhave [-> | n_gt0] := posnP; first exact: eqxx.\nby apply/negP; case/natf0_pchar=> // p; rewrite pcharF0.\nQed."
}
{
  "statement": "Lemma size_odd_poly_eq p : ~~ odd (size p) -> size (odd_poly p) = (size p)./2.\n",
  "proof": "Proof.\nhave [->|p_neq0] := eqVneq p 0; first by rewrite odd_polyC size_poly0.\nmove=> p_odd; rewrite size_poly_eq// -subn1 doubleB subn2 even_halfK//.\nrewrite prednK ?lead_coef_eq0// ltn_predRL.\nby move: p_neq0 p_odd; rewrite -size_poly_eq0; case: (size p) => [|[]].\nQed."
}
{
  "statement": "Lemma disjointU A B C :\n  [disjoint predU A B & C] = [disjoint A & C] && [disjoint B & C].\n",
  "proof": "Proof.\ncase: [disjoint A & C] / (pred0P (xpredI A C)) => [A0 | nA0] /=.\n  by congr (_ == 0); apply: eq_card => x; rewrite [x \\in _]andb_orl A0.\napply/pred0P=> nABC; case: nA0 => x; apply/idPn=> /=; move/(_ x): nABC.\nby rewrite [_ x]andb_orl; case/norP.\nQed."
}
{
  "statement": "Lemma gcdp_scalel c m n : c != 0 -> gcdp (c *: m) n %= gcdp m n.\n",
  "proof": "Proof.\nmove=> cn0; rewrite /eqp dvdp_gcd [gcdp m n %| _]dvdp_gcd !dvdp_gcdr !andbT.\napply/andP; split; last first.\n  by apply: dvdp_trans (dvdp_gcdl _ _) _; rewrite dvdpZr.\nby apply: dvdp_trans (dvdp_gcdl _ _) _; rewrite dvdpZl.\nQed."
}
{
  "statement": "Lemma size_prod_eq1 (I : finType) (P : pred I) (F : I -> {poly R}) :\n  reflect (forall i, P i -> size (F i) = 1)\n          (size (\\prod_(i | P i) F i) == 1).\n",
  "proof": "Proof.\napply: (iffP (size_prod_seq_eq1 _ _ _)) => Hi i.\n  by move=> Pi; apply: Hi; rewrite Pi /= mem_index_enum.\nby rewrite mem_index_enum andbT; apply: Hi.\nQed."
}
{
  "statement": "Lemma size_poly_prod_leq (I : finType) (P : pred I) (F : I -> {poly R}) :\n  size (\\prod_(i | P i) F i) <= (\\sum_(i | P i) size (F i)).+1 - #|P|.\n",
  "proof": "Proof.\nrewrite -sum1_card.\nelim/big_rec3: _ => [|i n m p _ IHp]; first by rewrite size_poly1.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite mulr0 size_poly0.\nrewrite (leq_trans (size_polyMleq _ _)) // subnS -!subn1 leq_sub2r //.\nrewrite -addnS -addnBA ?leq_add2l // ltnW // -subn_gt0 (leq_trans _ IHp) //.\nby rewrite polySpred.\nQed."
}
{
  "statement": "Lemma gastabsP (S : {set rT}) (a : aT) :\n  a \\in A -> reflect (forall x, (to x a \\in S) = (x \\in S)) (a \\in 'N(S | to)).\n",
  "proof": "Proof.\nmove=> Aa; apply: (iffP idP) => [nSa x|nSa]; first exact: astabs_act.\nby rewrite !inE Aa; apply/subsetP=> x; rewrite inE nSa.\nQed."
}
{
  "statement": "Lemma tfgraphK : pcancel tfgraph tfgraph_inv.\n",
  "proof": "Proof.\nmove=> f; have Dg x: tnth (tfgraph f) (enum_rank x) = total_fun f x.\n  by rewrite tnth_map -[tnth _ _]enum_val_nth enum_rankK.\nrewrite /tfgraph_inv; case: eqfunP => /= [Dtg | [] x]; last by rewrite Dg.\ncongr (Some _); apply/ffunP=> x; rewrite ffunE.\nby rewrite Dg in (Dx := Dtg x) *; rewrite eq_axiomK.\nQed."
}
{
  "statement": "Lemma ler_addgt0Pr x y : reflect (forall e, e > 0 -> x <= y + e) (x <= y).\n",
  "proof": "Proof.\napply/(iffP idP)=> [lexy e e_gt0 | lexye]; first by rewrite ler_wpDr// ltW.\nhave [||ltyx]// := comparable_leP.\n  rewrite (@comparabler_trans _ (y + 1))// /Order.comparable ?lexye ?ltr01//.\n  by rewrite lerDl ler01 orbT.\nhave /midf_lt [_] := ltyx; rewrite le_gtF//.\nrewrite -(@addrK _ y y) (addrAC _ _ x) -addrA 2!mulrDl -splitr lexye//.\nby rewrite divr_gt0// ?ltr0n// subr_gt0.\nQed."
}
{
  "statement": "Lemma sumv_pi_uniq_sum v :\n    uniq (filter P r0) -> v \\in V ->\n  \\sum_(i <- r0 | P i) sumv_pi_for defV i v = v.\n",
  "proof": "Proof.\nrewrite /sumv_pi_for defV -!(big_filter r0 P).\nelim: (filter P r0) v => [|i r IHr] v /= => [_ | /andP[r'i /IHr{}IHr]].\n  by rewrite !big_nil memv0 => /eqP.\nrewrite !big_cons eqxx => /addv_pi1_pi2; congr (_ + _ = v).\nrewrite -[_ v]IHr ?memv_pi2 //; apply: eq_big_seq => j /=.\nby case: eqP => [<- /idPn | _]; rewrite ?lfunE.\nQed."
}
{
  "statement": "Lemma minPoly_XsubC : reflect (minPoly K x = 'X - x%:P) (x \\in K).\n",
  "proof": "Proof.\nset p := minPoly K x; apply: (iffP idP) => [Kx | Dp]; last first.\n  suffices ->: x = - p`_0 by rewrite rpredN (polyOverP minPolyOver).\n  by rewrite Dp coefB coefX coefC add0r opprK.\nrewrite (@all_roots_prod_XsubC _ p [:: x]) /= ?root_minPoly //.\n  by rewrite big_seq1 (monicP (monic_minPoly K x)) scale1r.\nby apply/eqP; rewrite size_minPoly eqSS adjoin_deg_eq1.\nQed."
}
{
  "statement": "Lemma pprimeChar_vectAxiom : Vector.axiom n R.\n",
  "proof": "Proof.\nhave /isog_isom/=[f /isomP[injf im_f]]: [set: R] \\isog [set: 'rV['F_p]_n].\n  rewrite (@isog_abelem_card _ _ p) fin_Fp_lmod_abelem //=.\n  by rewrite !cardsT card_pprimeChar card_mx mul1n card_Fp.\nexists f; last by exists (invm injf) => x; rewrite ?invmE ?invmK ?im_f ?inE.\nmove=> a x y; rewrite [a *: _]mulr_natl morphM ?morphX ?inE // zmodXgE.\nby congr (_ + _); rewrite -scaler_nat natr_Zp.\nQed."
}
{
  "statement": "Lemma gactsP (G : {set rT}) : reflect {acts A, on G | to} [acts A, on G | to].\n",
  "proof": "Proof.\napply: (iffP idP) => [nGA x|nGA]; first exact: acts_act.\napply/subsetP=> a Aa /[!inE]; rewrite Aa.\nby  apply/subsetP=> x; rewrite inE nGA.\nQed."
}
{
  "statement": "Lemma char1_eq0 chi : chi \\is a character -> (chi 1%g == 0) = (chi == 0).\n",
  "proof": "Proof.\ncase/char_sum_irr=> r ->; apply/idP/idP=> [|/eqP->]; last by rewrite cfunE.\ncase: r => [|i r]; rewrite ?big_nil // sum_cfunE big_cons.\nrewrite paddr_eq0 ?sumr_ge0  => // [||j _]; rewrite 1?ltW ?irr1_gt0 //.\nby rewrite (negbTE (irr1_neq0 i)).\nQed."
}
{
  "statement": "Lemma group_setP A :\n  reflect (1 \\in A /\\ {in A & A, forall x y, x * y \\in A}) (group_set A).\n",
  "proof": "Proof.\napply: (iffP andP) => [] [A1 AM]; split=> {A1}//.\n  by move=> x y Ax Ay; apply: (subsetP AM); rewrite mem_mulg.\nby apply/subsetP=> _ /mulsgP[x y Ax Ay ->]; apply: AM.\nQed."
}
{
  "statement": "Lemma comparable_max_minl : max (min x y) z = min (max x z) (max y z).\n",
  "proof": "Proof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z).\nmove=> [xy|xy|xy|<-] [xz|xz|xz|<-] [yz|yz|yz|//->]//= _; rewrite ?ltxx//.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\nQed."
}
{
  "statement": "Lemma trivg_Fitting G : solvable G -> ('F(G) == 1) = (G :==: 1).\n",
  "proof": "Proof.\nmove=> solG; apply/idP/idP=> [F1 | /eqP->]; last by rewrite gF1.\napply/idPn=> /(solvable_norm_abelem solG (normal_refl _))[M [_ nsMG ntM]].\ncase/is_abelemP=> p _ /and3P[pM _ _]; case/negP: ntM.\nby rewrite -subG1 -(eqP F1) Fitting_max ?(pgroup_nil pM).\nQed."
}
{
  "statement": "Lemma next_map p : uniq p -> forall x, next (map h p) (h x) = h (next p x).\n",
  "proof": "Proof.\nmove=> Up x; case p_x: (x \\in p); last by rewrite !next_nth (mem_map Ih) p_x.\ncase/rot_to: p_x => i p' def_p.\nrewrite -(next_rot i Up); rewrite -(map_inj_uniq Ih) in Up.\nrewrite -(next_rot i Up) -map_rot {i p Up}def_p /=.\nby case: p' => [|y p''] //=; rewrite !eqxx.\nQed."
}
{
  "statement": "Lemma map_tnth_enum t : map (tnth t) (enum 'I_n) = t.\n",
  "proof": "Proof.\ncase def_t: {-}(val t) => [|x0 t'].\n  by rewrite [enum _]size0nil // -cardE card_ord -(size_tuple t) def_t.\napply: (@eq_from_nth _ x0) => [|i]; rewrite size_map.\n  by rewrite -cardE size_tuple card_ord.\nmove=> lt_i_e; have lt_i_n: i < n by rewrite -cardE card_ord in lt_i_e.\nby rewrite (nth_map (Ordinal lt_i_n)) // (tnth_nth x0) nth_enum_ord.\nQed."
}
{
  "statement": "Lemma lker_proj U : lker (projv U) = (U^C)%VS.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEdim andbC; apply/andP; split.\n  by rewrite dimv_compl -(limg_ker_dim (projv U) fullv) limg_proj addnK capfv.\nby apply/subvP=> v; rewrite memv_ker -{2}[v]subr0 => /eqP <-; apply: memv_projC.\nQed."
}
{
  "statement": "Lemma coprimep_root p q x : coprimep p q -> root p x -> q.[x] != 0.\n",
  "proof": "Proof.\ncase/Bezout_coprimepP=> [[u v] euv] px0.\nmove/eqpP: euv => [[c1 c2]] /andP /= [c1n0 c2n0 e].\nsuffices: c1 * (v.[x] * q.[x]) != 0.\n  by rewrite !mulf_eq0 !negb_or c1n0 /=; case/andP.\nhave := f_equal (horner^~ x) e; rewrite /= !hornerZ hornerD.\nby rewrite !hornerM (eqP px0) mulr0 add0r hornerC mulr1; move->.\nQed."
}
{
  "statement": "Lemma mxsemisimpleS U V :\n  mxmodule U -> (U <= V)%MS -> mxsemisimple V -> mxsemisimple U.\n",
  "proof": "Proof.\nmove=> modU sUV ssimV.\nhave [W modW defUW dxUW]:= mxsemisimple_reducible ssimV modU sUV.\nmove/mxdirect_addsP: dxUW => dxUW.\nhave defU : (V *m proj_mx U W :=: U)%MS.\n  by apply/eqmxP; rewrite proj_mx_sub -{1}[U](proj_mx_id dxUW) ?submxMr.\napply: eqmx_semisimple defU _; apply: hom_mxsemisimple ssimV _.\nby rewrite -defUW proj_mx_hom.\nQed."
}
{
  "statement": "Lemma cards2P A : reflect (exists x y : T, x != y /\\ A = [set x; y])\n                          (#|A| == 2).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[x] [y] [xy ->]]; last by rewrite cards2 xy.\nhave [[|x [|y []]]//=] := cards_eqP; rewrite !inE andbT => neq_xy.\nby exists x, y; split=> //; apply/setP => z; rewrite !inE.\nQed."
}
{
  "statement": "Lemma deg2_poly_le0m x : 0 <= delta -> r1 <= x <= r2 -> p.[x] <= 0.\n",
  "proof": "Proof.\nmove=> dge0; rewrite le_eqVlt andb_orl => /orP[/andP[/eqP<- _]|].\n  by rewrite le_eqVlt (rootP (deg2_poly_root1 dge0)) eqxx.\nrewrite le_eqVlt andb_orr => /orP[/andP[_ /eqP->]|].\n  by rewrite le_eqVlt (rootP (deg2_poly_root2 dge0)) eqxx.\nby move=> ?; apply/ltW/deg2_poly_lt0m.\nQed."
}
{
  "statement": "Lemma suffixP {s1 s2} :\n  reflect (exists s2' : seq T, s2 = s2' ++ s1) (suffix s1 s2).\n",
  "proof": "Proof.\napply: (iffP prefixP) => [[s2' rev_s2]|[s2' ->]]; exists (rev s2'); last first.\n  by rewrite rev_cat.\nby rewrite -[s2]revK rev_s2 rev_cat revK.\nQed."
}
{
  "statement": "Lemma cfBigdprod_Res_lin chi :\n  chi \\is a linear_char -> cfBigdprod defG (fun i => 'Res[A i] chi) = chi.\n",
  "proof": "Proof.\nmove=> Lchi; apply/cfun_inP=> _ /(mem_bigdprod defG)[x [Ax -> _]].\nrewrite (lin_char_prod Lchi) ?cfBigdprodE // => [|i Pi]; last first.\n  by rewrite (subsetP (sAG Pi)) ?Ax.\nby apply/eq_bigr=> i Pi; rewrite cfResE ?sAG ?Ax.\nQed."
}
{
  "statement": "Lemma mxmodule_eigenvector m (U : 'M_(m, n)) :\n    mxmodule U -> \\rank U = 1 ->\n  {u : 'rV_n & {a | (U :=: u)%MS & {in G, forall x, u *m rG x = a x *: u}}}.\n",
  "proof": "Proof.\nmove=> modU linU; set u := nz_row U; exists u.\nhave defU: (U :=: u)%MS.\n  apply/eqmxP; rewrite andbC -(geq_leqif (mxrank_leqif_eq _)) ?nz_row_sub //.\n  by rewrite linU lt0n mxrank_eq0 nz_row_eq0 -mxrank_eq0 linU.\npose a x := (u *m rG x *m pinvmx u) 0 0; exists a => // x Gx.\nby rewrite -mul_scalar_mx -mx11_scalar mulmxKpV // -defU mxmodule_trans ?defU.\nQed."
}
{
  "statement": "Lemma abelian_type_dvdn_sorted A : sorted [rel m n | n %| m] (abelian_type A).\n",
  "proof": "Proof.\nset R := SimplRel _; pose G := <<A>>%G; pose M := G.\nsuffices: path R (exponent M) (abelian_type A) by case: (_ A) => // m t /andP[].\nrewrite /abelian_type -/G; have: G \\subset M by [].\nelim: {A}#|A| G M => //= n IHn G M sGM.\ncase: andP => //= -[cGG ntG]; rewrite exponentS ?IHn //=.\ncase: (abelian_type_subproof G) => H /= [//| x _] /dprodP[_ /= <- _ _].\nexact: mulG_subr.\nQed."
}
{
  "statement": "Lemma num_spec_add (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 add xi yi) :\n  num_spec r (x%:num + y%:num).\n",
  "proof": "Proof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\nrewrite /Itv.num_sem realD//=; apply/andP.\nby rewrite num_itv_add_boundl ?num_itv_add_boundr.\nQed."
}
{
  "statement": "Lemma kHom_inv K E f : kHom K E f -> {in E, {morph f : x / x^-1}}.\n",
  "proof": "Proof.\ncase/kHomP=> fM idKf x Ex.\nhave [-> | nz_x] := eqVneq x 0; first by rewrite linear0 invr0 linear0.\nhave fxV: f x * f x^-1 = 1 by rewrite -fM ?rpredV ?divff // idKf ?mem1v.\nhave Ufx: f x \\is a GRing.unit by apply/unitrPr; exists (f x^-1).\nby apply: (mulrI Ufx); rewrite divrr.\nQed."
}
{
  "statement": "Lemma eltmE i : eltm dvd_y_x (x ^+ i) = y ^+ i.\n",
  "proof": "Proof.\napply/eqP; rewrite eq_expg_mod_order.\nhave [x_le1 | x_gt1] := leqP #[x] 1.\n  suffices: #[y] %| 1 by rewrite dvdn1 => /eqP->; rewrite !modn1.\n  by rewrite (dvdn_trans dvd_y_x) // dvdn1 order_eq1 -cycle_eq1 trivg_card_le1.\nrewrite -(expg_znat i (cycle_id x)) invmE /=; last by rewrite /Zp x_gt1 inE.\nby rewrite val_Zp_nat // modn_dvdm.\nQed."
}
{
  "statement": "Lemma reindex_irr_class R idx (op : @Monoid.com_law R idx) F :\n  \\big[op/idx]_(xG in classes G) F xG = \\big[op/idx]_i F (c i).\n",
  "proof": "Proof.\nrewrite (reindex c); first by apply: eq_bigl => i; apply: enum_valP.\nby exists iC; [apply: in1W; apply: irr_classK | apply: class_IirrK].\nQed."
}
{
  "statement": "Lemma morphpreSK R S :\n  R \\subset f @* D -> (f @*^-1 R \\subset f @*^-1 S) = (R \\subset S).\n",
  "proof": "Proof.\nmove=> sRfD; apply/idP/idP=> [sf'RS|]; last exact: morphpreS.\nsuffices: R \\subset f @* D :&: S by rewrite subsetI sRfD.\nrewrite -(morphpreK sRfD) -[_ :&: S]morphpreK (morphimS, subsetIl) //.\nby rewrite morphpreI morphimGK ?subsetIl // setIA setIid.\nQed."
}
{
  "statement": "Lemma closed_field_poly_normal p :\n  {r : seq F | p = lead_coef p *: \\prod_(z <- r) ('X - z%:P)}.\n",
  "proof": "Proof.\napply: sig_eqW; have [r [q [->]]] /= := dec_factor_theorem p.\nhave [->|] := eqVneq; first by exists [::]; rewrite mul0r lead_coef0 scale0r.\nhave [[x rqx ? /(_ isT x) /negP /(_ rqx)] //|] := altP (closed_rootP q).\nrewrite negbK => /size_poly1P [c c_neq0-> _ _]; exists r.\nrewrite mul_polyC lead_coefZ (monicP _) ?mulr1 //.\nby rewrite monic_prod => // i; rewrite monicXsubC.\nQed."
}
{
  "statement": "Lemma rreg_div0 q r d :\n    GRing.rreg (lead_coef d) -> size r < size d ->\n  (q * d + r == 0) = (q == 0) && (r == 0).\n",
  "proof": "Proof.\nmove=> reg_d lt_r_d; rewrite addrC addr_eq0.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite mul0r oppr0.\napply: contraTF lt_r_d => /eqP->; rewrite -leqNgt size_polyN.\nrewrite size_proper_mul ?mulIr_eq0 ?lead_coef_eq0 //.\nby rewrite (polySpred nz_q) leq_addl.\nQed."
}
{
  "statement": "Lemma Wedderburn_sum_id_pchar : \\sum_i 'e_i = 1%:M.\n",
  "proof": "Proof.\nrewrite -linear_sum; apply: canLR mxvecK _.\nhave: (1%:M \\in R_G)%MS := envelop_mx1 aG.\nrewrite -Wedderburn_sum_pchar.\ncase/(sub_dsumsmx Wedderburn_direct) => e Re -> _.\napply: eq_bigr => i _; have dxR := mxdirect_sumsP Wedderburn_direct i (erefl _).\nrewrite (bigD1 i) // mulmxDl proj_mx_id ?Re // proj_mx_0 ?addr0 //=.\nby rewrite summx_sub // => j ne_ji; rewrite (sumsmx_sup j) ?Re.\nQed."
}
{
  "statement": "Lemma set_invgM : {morph set_invg : A B / set_mulg A B >-> set_mulg B A}.\n",
  "proof": "Proof.\nmove=> A B; apply/setP=> z; rewrite inE.\napply/imset2P/imset2P=> [[x y Ax By /(canRL invgK)->] | [y x]].\n  by exists y^-1 x^-1; rewrite ?invMg // inE invgK.\nby rewrite !inE => By1 Ax1 ->; exists x^-1 y^-1; rewrite ?invMg.\nQed."
}
{
  "statement": "Lemma rowV0Pn m n (A : 'M_(m, n)) :\n  reflect (exists2 v : 'rV_n, v <= A & v != 0)%MS (A != 0).\n",
  "proof": "Proof.\nrewrite -submx0; apply: (iffP idP) => [| [v svA]]; last first.\n  by rewrite -submx0; apply: contra (submx_trans _).\nby case/row_subPn=> i; rewrite submx0; exists (row i A); rewrite ?row_sub.\nQed."
}
{
  "statement": "Lemma plogp1 (p : {poly F}) : 2 < size p -> plogp p 1 = 0%N.\n",
  "proof": "Proof.\nmove=> sp_gt2; rewrite /plogp; case (boolP (primitive_poly p)) => // i.\nsuff->: in_qpoly p 1 = 1 by apply: qlogp1.\napply/val_eqP/eqP; apply: in_qpoly_small.\nrewrite mk_monicE ?size_poly1 ?(leq_trans _ sp_gt2) //.\nby apply: primitive_mi.\nQed."
}
{
  "statement": "Lemma group_Ldiv G n : abelian G -> group_set 'Ldiv_n(G).\n",
  "proof": "Proof.\nmove=> cGG; apply/group_setP.\nsplit=> [|x y]; rewrite !inE ?group1 ?expg1n //=.\ncase/andP=> Gx /eqP xn /andP[Gy /eqP yn].\nby rewrite groupM //= expgMn ?xn ?yn ?mulg1 //; apply: (centsP cGG).\nQed."
}
{
  "statement": "Lemma card_le1P {A} : reflect {in A, forall x, A =i pred1 x} (#|A| <= 1).\n",
  "proof": "Proof.\napply: (iffP idP) => [A1 x xA y|]; last first.\n  by have [/= x xA /(_ _ xA)/eq_card1->|/eq_card0->//] := pickP [in A].\nmove: A1; rewrite (cardD1 x) xA ltnS leqn0 => /eqP/card0_eq/(_ y).\nby rewrite !inE; have [->|]:= eqP.\nQed."
}
{
  "statement": "Lemma up_log_bounds p n :\n  1 < p -> 1 < n -> let k := up_log p n in p ^ k.-1 < n <= p ^ k.\n",
  "proof": "Proof.\nmove=> p_gt1 n_gt1.\nhave n_gt0 : 0 < n by apply: leq_trans n_gt1.\nrewrite /up_log (leqNgt p 1) p_gt1 /=.\nhave /= /andP[tpLn nLtpS] := trunc_log_bounds p_gt1 n_gt0.\nhave [nLnp|npLn] := leqP n (p ^ trunc_log p n); last by rewrite npLn ltnW.\nrewrite nLnp (leq_trans _ tpLn) // ltn_exp2l // prednK ?leqnn //.\nby case: trunc_log (leq_trans n_gt1 nLnp).\nQed."
}
{
  "statement": "Lemma eq_from_nth s1 s2 :\n    size s1 = size s2 -> (forall i, i < size s1 -> nth s1 i = nth s2 i) ->\n  s1 = s2.\n",
  "proof": "Proof.\nelim: s1 s2 => [|x1 s1 IHs1] [|x2 s2] //= [eq_sz] eq_s12.\nby rewrite [x1](eq_s12 0) // (IHs1 s2) // => i; apply: (eq_s12 i.+1).\nQed."
}
{
  "statement": "Lemma acts_char G M : G \\subset D -> M \\char R -> [acts G, on M | to].\n",
  "proof": "Proof.\nmove=> sGD /charP[sMR charM].\napply/subsetP=> a Ga; have Da := subsetP sGD a Ga; rewrite !inE Da.\napply/subsetP=> x Mx; have Rx := subsetP sMR x Mx.\nby rewrite inE -(charM _ (injm_actm a) (im_actm a)) -actmE // mem_morphim.\nQed."
}
{
  "statement": "Lemma normD1 A : 'N(A^#) = 'N(A).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset normsD1 //.\nrewrite -{2}(setID A 1) setIC normsU //; apply/normsP=> x _; apply/setP=> y.\nby rewrite conjIg conjs1g !inE mem_conjg; case: eqP => // ->; rewrite conj1g.\nQed."
}
{
  "statement": "Lemma trow_is_linear n1 m2 n2 (A : 'rV_n1) : linear (@trow n1 A m2 n2).\n",
  "proof": "Proof.\nelim: n1 A => [|n1 IH] //= A k A1 A2 /=; first by rewrite scaler0 add0r.\nrewrite linearP /=; apply/matrixP=> i j; rewrite !mxE.\nby case: split=> a; rewrite ?IH !mxE.\nQed."
}
{
  "statement": "Lemma in_genK : cancel in_gen val_gen.\n",
  "proof": "Proof.\nmove=> W; apply/row_matrixP=> i; rewrite rowK; set w := row i W.\nhave b_w: (w <= base)%MS by rewrite submx_full ?base_full.\nrewrite -{b_w}(mulmxKpV b_w); congr (_ *m _).\nby apply/rowP; case/mxvec_indexP=> j k; rewrite mxvecE !mxE.\nQed."
}
{
  "statement": "Lemma mingroupP :\n  reflect (gP G /\\ forall H, gP H -> H \\subset G -> H :=: G) (mingroup G gP).\n",
  "proof": "Proof.\napply: (iffP minsetP); rewrite /= groupP genGidG /= => [] [-> minG].\n  by split=> // H gPH sGH; apply: minG; rewrite // groupP genGidG.\nby split=> // A; case/andP=> gA gPA; rewrite -(gen_set_id gA); apply: minG.\nQed."
}
{
  "statement": "Lemma Derivation_mul : {in K &, forall u v, D (u * v) = D u * v + u * D v}.\n",
  "proof": "Proof.\nmove=> u v /coord_vbasis-> /coord_vbasis->.\nrewrite !(mulr_sumr, linear_sum) -big_split; apply: eq_bigr => /= j _.\nrewrite !mulr_suml linear_sum -big_split; apply: eq_bigr => /= i _.\nrewrite !(=^~ scalerAl, linearZZ) -!scalerAr linearZZ -!scalerDr !scalerA /=.\nby congr (_ *: _); apply/eqP/(allrelP derD); exact: memt_nth.\nQed."
}
{
  "statement": "Lemma diag_mxrow (B_ : forall j, 'rV[R]_(p_ j)) :\n  diag_mx (\\mxrow_j B_ j) = \\mxdiag_j (diag_mx (B_ j)).\n",
  "proof": "Proof.\napply/matrixP => s s'; rewrite !mxE/= -(can_eq sigK) /sig1 /sig2.\ncase: (sig s) (sig s') => [/= i j] [/= i' j'].\nrewrite -tag_eqE /tag_eq/=; case: (eqVneq i i') => ii'; rewrite ?mxE//=.\nby case: _ / ii' in j' *; rewrite tagged_asE/= conform_mx_id mxE.\nQed."
}
{
  "statement": "Lemma faithfulP A S :\n  reflect (forall a, a \\in A -> {in S, to^~ a =1 id} -> a = 1)\n          [faithful A, on S | to].\n",
  "proof": "Proof.\napply: (iffP subsetP) => [Cto1 a Aa Ca | Cto1 a].\n  by apply/set1P; rewrite Cto1 // inE Aa; apply/astabP.\nby case/setIP=> Aa /astabP Ca; apply/set1P; apply: Cto1.\nQed."
}
{
  "statement": "Lemma cfAut_char u chi : (cfAut u chi \\is a character) = (chi \\is a character).\n",
  "proof": "Proof.\nwithout loss /char_reprP[rG ->]: u chi / chi \\is a character.\n  by move=> IHu; apply/idP/idP=> ?; first rewrite -(cfAutK u chi); rewrite IHu.\nrewrite cfRepr_char; apply/char_reprP.\nby exists (Representation (map_repr u rG)); rewrite cfRepr_map.\nQed."
}
{
  "statement": "Lemma F_s2 : 'Fix_to_g[s2] =\n  [set x | (col0 x == col5 x) && (col1 x == col3  x) && (col2 x == col4 x)].\n",
  "proof": "Proof.\nhave s2_inv: s2^-1 = s2 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s2_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma num_spec_exprn (i : Itv.t) (x : num_def R i) n (r := Itv.real1 exprn i) :\n  num_spec r (x%:num ^+ n).\n",
  "proof": "Proof.\napply: (@Itv.spec_real1 _ _ (fun x => x^+n) _ _ _ _ (Itv.P x)).\ncase: x => x /= _ [l u] /and3P[xr /= lx xu].\nrewrite /Itv.num_sem realX//=; apply/andP; split.\n- apply: (@num_itv_bound_keep_pos (fun x => x^+n)) lx.\n  + exact: exprn_ge0.\n  + exact: exprn_gt0.\n- exact: num_itv_bound_exprn_le1 lx xu.\nQed."
}
{
  "statement": "Lemma acts_subnorm_fix A : [acts 'N_D(A), on 'Fix_to(D :&: A) | to].\n",
  "proof": "Proof.\napply/subsetP=> a nAa; have [Da _] := setIP nAa; rewrite !inE Da.\napply/subsetP=> x Cx /[1!inE]; apply/afixP=> b DAb.\nhave [Db _]:= setIP DAb; rewrite -actMin // conjgCV  actMin ?groupJ ?groupV //.\nby rewrite /= (afixP Cx) // memJ_norm // groupV (subsetP (normsGI _ _) _ nAa).\nQed."
}
{
  "statement": "Lemma mul_mxdiag_mxcol m\n    (D_ : forall i, 'M[R]_(p_ i)) (C_ : forall i, 'M[R]_(p_ i, m)):\n  \\mxdiag_i D_ i *m \\mxcol_i C_ i = \\mxcol_i (D_ i *m C_ i).\n",
  "proof": "Proof.\nrewrite /mxdiag mxblockEh mul_mxrow_mxcol.\nunder [LHS]eq_bigr do rewrite mxcol_mul; rewrite -mxcol_sum.\napply/eq_mxcol => i; rewrite (bigD1 i)//= eqxx conform_mx_id big1 ?addr0//.\nby move=> j; case: eqVneq => //=; rewrite mul0mx.\nQed."
}
{
  "statement": "Lemma prim_rootP x : x ^+ n = 1 -> {i : 'I_n | x = z ^+ i}.\n",
  "proof": "Proof.\nmove=> xn1; pose logx := [pred i : 'I_n | x == z ^+ i].\ncase: (pickP logx) => [i /eqP-> | no_i]; first by exists i.\ncase: notF; suffices{no_i}: x \\in zn.\n  case/mapP=> i; rewrite mem_index_iota => lt_i_n def_x.\n  by rewrite -(no_i (Ordinal lt_i_n)) /= -def_x.\nrewrite -root_prod_XsubC big_map factor_Xn_sub_1.\nby rewrite [root _ x]unity_rootE xn1.\nQed."
}
{
  "statement": "Lemma maxgroupP :\n  reflect (gP G /\\ forall H, gP H -> G \\subset H -> H :=: G) (maxgroup G gP).\n",
  "proof": "Proof.\napply: (iffP maxsetP); rewrite /= groupP genGidG /= => [] [-> maxG].\n  by split=> // H gPH sGH; apply: maxG; rewrite // groupP genGidG.\nby split=> // A; case/andP=> gA gPA; rewrite -(gen_set_id gA); apply: maxG.\nQed."
}
{
  "statement": "Lemma char_sum_irr chi :\n  chi \\is a character -> {r | chi = \\sum_(i <- r) 'chi_i}.\n",
  "proof": "Proof.\nmove=> Nchi; apply: sig_eqW; case/char_sum_irrP: Nchi => n {chi}->.\nelim/big_rec: _ => [|i _ _ [r ->]]; first by exists nil; rewrite big_nil.\nexists (ncons (n i) i r); rewrite scaler_nat.\nby elim: {n}(n i) => [|n IHn]; rewrite ?add0r //= big_cons mulrS -addrA IHn.\nQed."
}
{
  "statement": "Lemma misom_isog f : misom f -> isog.\n",
  "proof": "Proof.\ncase/andP=> fM iso_f; apply/existsP; exists (finfun f).\napply/andP; split; last by rewrite /misom /isom !(eq_imset _ (ffunE f)).\nby apply/forallP=> u; rewrite !ffunE; apply: forallP fM u.\nQed."
}
{
  "statement": "Lemma gen_tpermn_circular_shift n (i j : 'I_n.+2)\n    (c := perm (addrI 1)) : coprime n.+2 (j - i)%R ->\n  <<[set tperm i j ; c]>>%g = [set: 'S_n.+2].\n",
  "proof": "Proof.\nmove=> jBi_coprime; apply/eqP; rewrite eqEsubset subsetT/=.\nrewrite -(gen_tperm_step jBi_coprime) gen_subG.\napply/subsetP => s /imsetP[/= k _ ->].\nsuff -> : tperm k (k + (j - i)) = (tperm i j ^ c ^+ (k - i)%R)%g.\n  by rewrite groupJ ?groupX ?mem_gen ?inE ?eqxx ?orbT.\nby rewrite tpermJ !perm_addr1X natr_Zp addrNK addrAC addrA.\nQed."
}
{
  "statement": "Lemma pdiv_min_dvd m d : 1 < d -> d %| m -> pdiv m <= d.\n",
  "proof": "Proof.\ncase: (posnP m) => [->|mpos] lt1d dv_d_m; first exact: ltnW.\nrewrite /pdiv; apply: leq_trans (pdiv_leq (ltnW lt1d)).\nhave: pdiv d \\in primes m.\n  by rewrite mem_primes mpos pdiv_prime // (dvdn_trans (pdiv_dvd d)).\ncase: (primes m) (sorted_primes m) => //= p pm ord_pm; rewrite inE.\nby case/predU1P => [-> | /(allP (order_path_min ltn_trans ord_pm)) /ltnW].\nQed."
}
{
  "statement": "Lemma eq_scaled_irr a b i j :\n  (a *: 'chi[G]_i == b *: 'chi_j) = (a == b) && ((a == 0) || (i == j)).\n",
  "proof": "Proof.\napply/eqP/andP=> [|[/eqP-> /pred2P[]-> //]]; last by rewrite !scale0r.\nmove/(congr1 (cfdotr 'chi__)) => /= eq_ai_bj.\nmove: {eq_ai_bj}(eq_ai_bj i) (esym (eq_ai_bj j)); rewrite !cfdotZl !cfdot_irr.\nby rewrite !mulr_natr !mulrb !eqxx eq_sym orbC; case: ifP => _ -> //= ->.\nQed."
}
{
  "statement": "Lemma afix_subact A :\n  A \\subset subact_dom -> 'Fix_subaction(A) = val @^-1: 'Fix_to(A).\n",
  "proof": "Proof.\nmove/subsetP=> sAD; apply/setP=> u.\nrewrite !inE !(sameP setIidPl eqP); congr (_ == A).\napply/setP=> a /[!inE]; apply: andb_id2l => Aa.\nby rewrite -val_eqE val_subact sAD.\n\nQed."
}
{
  "statement": "Lemma group_set_astab S : group_set 'C(S | to).\n",
  "proof": "Proof.\napply/group_setP; split=> [|a b cSa cSb].\n  by rewrite !inE group1; apply/subsetP=> x _; rewrite inE act1.\nrewrite !inE groupM ?(@astab_dom _ _ _ to S) //; apply/subsetP=> x Sx.\nby rewrite inE actMin ?(@astab_dom _ _ _ to S) ?(astab_act _ Sx).\nQed."
}
{
  "statement": "Lemma p_maximal_index : maximal M P -> #|P : M| = p.\n",
  "proof": "Proof.\nmove=> maxM; have nM := p_maximal_normal maxM.\nrewrite -card_quotient ?normal_norm //.\nrewrite -(quotient_maximal _ nM) ?normal_refl // trivg_quotient in maxM.\ncase/maxgroupP: maxM; rewrite properEneq eq_sym sub1G andbT /=.\ncase/(pgroup_pdiv (quotient_pgroup M pP)) => p_pr /Cauchy[] // xq.\nrewrite /order -cycle_subG subEproper => /predU1P[-> // | sxPq oxq_p _].\nby move/(_ _ sxPq (sub1G _)) => xq1; rewrite -oxq_p xq1 cards1 in p_pr.\nQed."
}
{
  "statement": "Lemma rstabs_quo m (U : 'M_(m, n)) : rstabs rGH U = (rstabs rG U / H)%g.\n",
  "proof": "Proof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|] /morphimP[x Nx Gx ->{Hx}].\n  by rewrite quo_repr_coset // => nUx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx nUx; rewrite quo_repr_coset ?mem_morphim.\nQed."
}
{
  "statement": "Lemma group_set_astabs S : group_set 'N(S | to).\n",
  "proof": "Proof.\napply/group_setP; split=> [|a b cSa cSb].\n  by rewrite !inE group1; apply/subsetP=> x Sx; rewrite inE act1.\nrewrite !inE groupM ?(@astabs_dom _ _ _ to S) //; apply/subsetP=> x Sx.\nby rewrite inE actMin ?(@astabs_dom _ _ _ to S) ?astabs_act.\nQed."
}
{
  "statement": "Lemma F_s1 : 'Fix_to_g[s1] =\n  [set x | (col0 x == col5 x) && (col1 x == col2  x) && (col3 x == col4 x)].\n",
  "proof": "Proof.\nhave s1_inv: s1^-1 = s1 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s1_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed."
}
{
  "statement": "Lemma burnside_formula : forall (gT : finGroupType) s (G : {group gT}),\n   uniq s -> s =i G ->\n   forall (sT : finType) (to : {action gT &-> sT}),\n   (#|orbit to G @: setT| * size s)%N = \\sum_(p <- s) #|'Fix_to[p]|.\n",
  "proof": "Proof.\nmove=> gT s G Us sG sT to.\nrewrite big_uniq // -(card_uniqP Us) (eq_card sG) -Frobenius_Cauchy.\n  by apply: eq_big => // p _; rewrite setTI.\nby apply/actsP=> ? _ ?; rewrite !inE.\nQed."
}
{
  "statement": "Lemma and_dnfP e bcs1 bcs2 :\n  qf_eval e (dnf_to_form (and_dnf bcs1 bcs2))\n   = qf_eval e (dnf_to_form bcs1 /\\ dnf_to_form bcs2).\n",
  "proof": "Proof.\nelim: bcs1 => [|bc1 bcs1 IH1] /=; first by rewrite /and_dnf big_nil.\nrewrite /and_dnf big_cons -/(and_dnf bcs1 bcs2) cat_dnfP  /=.\nrewrite {}IH1 /= andb_orl; congr orb.\nelim: bcs2 bc1 {bcs1} => [|bc2 bcs2 IH] bc1 /=; first by rewrite andbF.\nrewrite {}IH /= andb_orr; congr orb => {bcs2}.\nsuffices aux (l1 l2 : seq (term R)) g : let redg := foldr (And \\o g) True in\n  qf_eval e (redg (l1 ++ l2)) = qf_eval e (redg l1 /\\ redg l2)%T.\n+ by rewrite 2!aux /= 2!andbA -andbA -andbCA andbA andbCA andbA.\nby elim: l1 => [| t1 l1 IHl1] //=; rewrite -andbA IHl1.\nQed."
}
{
  "statement": "Lemma injm_sol : 'injm f -> G \\subset D -> solvable (f @* G) = solvable G.\n",
  "proof": "Proof.\nmove=> injf sGD; apply/idP/idP; last exact: morphim_sol.\ncase/derivedP=> n Gn1; apply/derivedP; exists n; apply/trivgP.\nby rewrite -(injmSK injf) ?gFsub_trans ?morphim_der // Gn1 morphim1.\nQed."
}
{
  "statement": "Lemma normalFieldS K M E : (K <= M)%VS -> normalField K E -> normalField M E.\n",
  "proof": "Proof.\nmove=> sKM /normalFieldP nKE; apply/normalFieldP=> a Ea.\nhave [r /allP Er splitKa] := nKE a Ea.\nhave /dvdp_prod_XsubC[m splitMa]: minPoly M a %| \\prod_(b <- r) ('X - b%:P).\n  by rewrite -splitKa minPolyS.\nexists (mask m r); first by apply/allP=> b /mem_mask/Er.\nby apply/eqP; rewrite -eqp_monic ?monic_prod_XsubC ?monic_minPoly.\nQed."
}
{
  "statement": "Lemma card_rowg m (A : 'M_(m, n)) : #|rowg A| = (#|F| ^ \\rank A)%N.\n",
  "proof": "Proof.\nrewrite -[\\rank A]mul1n -card_mx.\nhave injA: injective (mulmxr (row_base A)).\n  have /row_freeP[A' A'K] := row_base_free A.\n  by move=> ?; apply: can_inj (mulmxr A') _ => u; rewrite /= -mulmxA A'K mulmx1.\nrewrite -(card_image (injA _)); apply: eq_card => v.\nby rewrite inE -(eq_row_base A) (sameP submxP codomP).\nQed."
}
{
  "statement": "Lemma mxvec_dotmul m n (A : 'M[R]_(m, n)) u v :\n  mxvec (u^T *m v) *m (mxvec A)^T = u *m A *m v^T.\n",
  "proof": "Proof.\ntransitivity (\\sum_i \\sum_j (u 0 i * A i j *: row j v^T)).\n  apply/rowP=> i; rewrite {i}ord1 mxE (reindex _ (curry_mxvec_bij _ _)) /=.\n  rewrite pair_bigA summxE; apply: eq_bigr => [[i j]] /= _.\n  by rewrite !mxE !mxvecE mxE big_ord1 mxE mulrAC.\nrewrite mulmx_sum_row exchange_big; apply: eq_bigr => j _ /=.\nby rewrite mxE -scaler_suml.\nQed."
}
{
  "statement": "Lemma partn_gcd pi m n : m > 0 -> n > 0 -> (gcdn m n)`_pi = gcdn m`_pi n`_pi.\n",
  "proof": "Proof.\nmove=> m_gt0 n_gt0; have p_gt0: gcdn m n > 0 by rewrite gcdn_gt0 m_gt0.\napply/eqP; rewrite eqn_dvd dvdn_gcd !partn_dvd ?dvdn_gcdl ?dvdn_gcdr //=.\nrewrite -(dvdn_pmul2r (part_gt0 pi^' (gcdn m n))) partnC // dvdn_gcd.\nrewrite -[m in _ %| m](partnC pi m_gt0) andbC -[n in _%| n](partnC pi n_gt0).\nby rewrite !dvdn_mul ?partn_dvd ?dvdn_gcdl ?dvdn_gcdr.\nQed."
}
{
  "statement": "Lemma up_log_eq p n k : 1 < p -> p ^ n < k <= p ^ n.+1 -> up_log p k = n.+1.\n",
  "proof": "Proof.\nmove=> p_gt1 /andP[npLk kLpn]; apply/eqP; rewrite eqn_leq.\napply/andP; split; first by apply: up_log_min.\nrewrite -(ltn_exp2l _ _ p_gt1) //.\nby apply: leq_trans npLk (up_logP _ _).\nQed."
}
{
  "statement": "Lemma zprimitiveM p q : zprimitive (p * q) = zprimitive p * zprimitive q.\n",
  "proof": "Proof.\nhave [pq_0|] := eqVneq (p * q) 0.\n  rewrite pq_0; move/eqP: pq_0; rewrite mulf_eq0.\n  by case/pred2P=> ->; rewrite !zprimitive0 (mul0r, mulr0).\nrewrite -zcontents_eq0 -polyC_eq0 => /mulfI; apply; rewrite !mul_polyC.\nby rewrite -zpolyEprim zcontentsM -scalerA scalerAr scalerAl -!zpolyEprim.\nQed."
}
{
  "statement": "Lemma ltxi_tuplePlt n T (t1 t2 : n.-tuple T) : reflect\n  (exists2 k : 'I_n, forall i : 'I_n, (i < k)%N -> tnth t1 i = tnth t2 i\n                                                 & tnth t1 k < tnth t2 k)\n  (t1 < t2).\n",
  "proof": "Proof.\napply: (iffP (ltxi_tupleP _ _)) => [[k kP]|[k kP ltk12]].\n  exists k => [i i_lt|]; last by rewrite (lt_leif (kP _ _)) ?eqxx ?leqnn.\n  by have /eqTleif->// := kP i (ltnW i_lt); rewrite ltn_eqF.\nby exists k => i; case: ltngtP => //= [/kP-> _|/ord_inj-> _]; apply/leifP.\nQed."
}
{
  "statement": "Lemma sub_in_le_big [I : eqType] (s : seq I) (P P' : {pred I}) (F : I -> R) :\n    {in s, forall i, P i -> P' i} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s | P' i) F i).\n",
  "proof": "Proof.\nmove=> PP'; apply: sub_le_big_seq_cond => i; rewrite leq_count_subseq//.\nrewrite subseq_filter filter_subseq andbT; apply/allP => j.\nby rewrite !mem_filter => /andP[/PP'/[apply]->].\nQed."
}
{
  "statement": "Lemma partn_lcm pi m n : m > 0 -> n > 0 -> (lcmn m n)`_pi = lcmn m`_pi n`_pi.\n",
  "proof": "Proof.\nmove=> m_gt0 n_gt0; have p_gt0: lcmn m n > 0 by rewrite lcmn_gt0 m_gt0.\napply/eqP; rewrite eqn_dvd dvdn_lcm !partn_dvd ?dvdn_lcml ?dvdn_lcmr //.\nrewrite -(dvdn_pmul2r (part_gt0 pi^' (lcmn m n))) partnC // dvdn_lcm !andbT.\nrewrite -[m in m %| _](partnC pi m_gt0) andbC -[n in n %| _](partnC pi n_gt0).\nby rewrite !dvdn_mul ?partn_dvd ?dvdn_lcml ?dvdn_lcmr.\nQed."
}
{
  "statement": "Lemma imset_comp (f : T' -> U) (g : T -> T') (H : {pred T}) :\n  (f \\o g) @: H = f @: (g @: H).\n",
  "proof": "Proof.\napply/setP/subset_eqP/andP.\nsplit; apply/subsetP=> _ /imsetP[x0 Hx0 ->]; apply/imsetP.\n  by exists (g x0); first apply: imset_f.\nby move/imsetP: Hx0 => [x1 Hx1 ->]; exists x1.\nQed."
}
{
  "statement": "Lemma map_orthogonal M (nu : 'CF(G) -> 'CF(M)) S R (A : {pred 'CF(G)}) :\n  {in A &, isometry nu} -> {subset S <= A} -> {subset R <= A} ->\n orthogonal (map nu S) (map nu R) = orthogonal S R.\n",
  "proof": "Proof.\nmove=> Inu sSA sRA; rewrite [orthogonal _ _]all_map.\napply: eq_in_all => phi Sphi; rewrite /= all_map.\nby apply: eq_in_all => psi Rpsi; rewrite /= Inu ?(sSA phi) ?(sRA psi).\nQed."
}
{
  "statement": "Lemma trivIsetU1 A P :\n    {in P, forall B, [disjoint A & B]} -> trivIset P -> set0 \\notin P ->\n  trivIset (A |: P) /\\ A \\notin P.\n",
  "proof": "Proof.\nmove=> tiAP tiP notPset0; split; last first.\n  apply: contra notPset0 => P_A.\n  by have:= tiAP A P_A; rewrite -setI_eq0 setIid => /eqP <-.\napply/trivIsetP=> B1 B2 /setU1P[->|PB1] /setU1P[->|PB2];\n  by [apply: (trivIsetP _ tiP) | rewrite ?eqxx // ?(tiAP, disjoint_sym)].\nQed."
}
{
  "statement": "Lemma coprime_mulGp_Hall pi G K R :\n    K * R = G -> pi^'.-group K -> pi.-group R ->\n  pi^'.-Hall(G) K /\\ pi.-Hall(G) R.\n",
  "proof": "Proof.\nmove=> defG pi'K piR; apply/andP; rewrite andbC; apply/andP.\nby apply: coprime_mulpG_Hall => //; rewrite -(comm_group_setP _) defG ?groupP.\nQed."
}
{
  "statement": "Lemma nat_spec_add (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 add xi yi) :\n  nat_spec r (x%:num + y%:num).\n",
  "proof": "Proof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) natrD.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_add.\nQed."
}
{
  "statement": "Lemma map_cfAut_free S : cfAut_closed u S -> free S -> free (map (cfAut u) S).\n",
  "proof": "Proof.\nset Su := map _ S => sSuS freeS; have uniqS := free_uniq freeS.\nhave uniqSu: uniq Su by rewrite (map_inj_uniq cfAut_inj).\nhave{} sSuS: {subset Su <= S} by move=> _ /mapP[phi Sphi ->]; apply: sSuS.\nhave [|_ eqSuS] := uniq_min_size uniqSu sSuS; first by rewrite size_map.\nby rewrite (perm_free (uniq_perm uniqSu uniqS eqSuS)).\nQed."
}
{
  "statement": "Lemma nat_spec_mul (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 mul xi yi) :\n  nat_spec r (x%:num * y%:num).\n",
  "proof": "Proof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) natrM.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_mul.\nQed."
}
{
  "statement": "Lemma pffun_onP y D R f :\n  reflect (y.-support f \\subset D /\\ {subset image f D <= R})\n          (f \\in pffun_on_mem y (mem D) (mem R)).\n",
  "proof": "Proof.\napply: (iffP (pfamilyP y D (fun _ => R) f)) => [] [-> f_fam]; split=> //.\n  by move=> _ /imageP[x Ax ->]; apply: f_fam.\nby move=> x Ax; apply: f_fam; apply/imageP; exists x.\nQed."
}
{
  "statement": "Lemma infixP {s1 s2} :\n  reflect (exists s s' : seq T, s2 = s ++ s1 ++ s') (infix s1 s2).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[p [s {s2}->]]]//=; rewrite infixE => /eqP<-.\nset k := infix_index _ _; exists (take k s2), (drop (size s1 + k) s2).\nby rewrite -drop_drop !cat_take_drop.\nQed."
}
{
  "statement": "Lemma proof (p s : syntax) : content p = content s ->\n  forall env, eval idx op env p = eval idx op env s.\n",
  "proof": "Proof.\nsuff evalE env t : eval idx op env t = \\big[op/idx]_(i <- t) (pos idx env i).\n  move=> cps e; rewrite !evalE; apply: perm_big.\n  by apply/allP => x _ /=; rewrite !count_memE cps.\nelim: t => //= [n|t -> t' ->]; last by rewrite serial_Op big_cat.\nby rewrite big_cons big_nil Monoid.mulm1.\nQed."
}
{
  "statement": "Lemma injm_minnormal : minnormal (f @* M) (f @* G) = minnormal M G.\n",
  "proof": "Proof.\npose injfm := (morphim_injm_eq1 injf, injm_norms, injmSK injf, subsetIl).\napply/mingroupP/mingroupP; rewrite !injfm // => [[nML minM]].\n  split=> // H nHG sHM; have dH := subset_trans sHM dM.\n  by apply: (injm_morphim_inj injf) => //; apply: minM; rewrite !injfm.\nsplit=> // fH nHG sHM; have dfH := subset_trans sHM (morphim_sub f M).\nby rewrite -(morphpreK dfH) !injfm // in nHG sHM *; rewrite (minM _ nHG).\nQed."
}
{
  "statement": "Lemma kHomExtendP : kHom K <<E; x>> kHomExtend.\n",
  "proof": "Proof.\nhave [fM idKf] := kHomP homKf.\napply/kHomP; split=> [|z Kz]; last by rewrite kHomExtend_id ?(subvP sKE) ?idKf.\nmove=> _ _ /Fadjoin_polyP[p Ep ->] /Fadjoin_polyP[q Eq ->].\nrewrite -hornerM !kHomExtend_poly ?rpredM // -hornerM; congr _.[_].\napply/polyP=> i; rewrite coef_map !coefM /= linear_sum /=.\nby apply: eq_bigr => j _; rewrite !coef_map /= fM ?(polyOverP _).\nQed."
}
{
  "statement": "Lemma rank_geP n G : reflect (exists E, E \\in 'E^n(G)) (n <= 'r(G)).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[E]].\n  have [p _ ->] := rank_witness G; case/p_rank_geP=> E.\n  by rewrite def_pnElem; case/setIP; exists E.\ncase/nElemP=> p /[1!inE] /andP[EpG_E /eqP <-].\nby rewrite (leq_trans (logn_le_p_rank EpG_E)) ?p_rank_le_rank.\nQed."
}
{
  "statement": "Lemma subnormalEl G H : H <|<| G ->\n  H :=: G \\/ (exists K : {group gT}, [/\\ H <| K, K <|<| G & H \\proper K]).\n",
  "proof": "Proof.\ncase/subnormalP=> s Hs <-{G}; elim: s H Hs => /= [|K s IHs] H; first by left.\ncase/andP=> nsHK Ks; have /[1!subEproper] := normal_sub nsHK.\ncase/predU1P=> [-> | prHK]; [exact: IHs | right; exists K; split=> //].\nby apply/subnormalP; exists s.\nQed."
}
{
  "statement": "Lemma eq_cpairZ : {in 'Z(H), cpairg1 =1 cpair1g \\o gz}.\n",
  "proof": "Proof.\nrewrite /cpairg1 /cpair1g => z1 Zz1; set z2 := gz z1.\nhave Zz2: z2 \\in 'Z(K) by rewrite (subsetP sgzZZ) ?mem_morphim.\nhave [[Gz1 _] [/= Gz2 _]]:= (setIP Zz1, setIP Zz2).\ndo 2![case: restrmP => f /= [df _ _ _]; rewrite {f}df].\napply/rcoset_kerP; rewrite ?inE ?group1 ?andbT //.\nby rewrite ker_in_cprod mem_rcoset inE /= invg1 mulg1 mul1g Zz1 /=.\nQed."
}
{
  "statement": "Lemma abelem_pnElem p n G :\n  p.-abelem G -> n <= logn p #|G| -> exists E, E \\in 'E_p^n(G).\n",
  "proof": "Proof.\ncase: n => [|n] abelG lt_nG; first by exists 1%G; rewrite pnElem0 set11.\nhave p_pr: prime p by move: lt_nG; rewrite lognE; case: prime.\ncase/(normal_pgroup (abelem_pgroup abelG)): lt_nG => // E [sEG _ oE].\nby exists E; rewrite pnElemE // !inE oE sEG (abelemS sEG) /=.\nQed."
}
{
  "statement": "Lemma sqrCK_P x : reflect (sqrtC (x ^+ 2) = x) ((0 <= 'Im x) && ~~ (x < 0)).\n",
  "proof": "Proof.\napply: (iffP andP) => [[leI0x not_gt0x] | <-]; last first.\n  by rewrite sqrtC_lt0 Im_rootC_ge0.\nhave /eqP := sqrtCK (x ^+ 2); rewrite eqf_sqr => /pred2P[] // defNx.\napply: sqrCK; rewrite -real_leNgt ?rpred0 // in not_gt0x;\napply/Creal_ImP/le_anti;\nby rewrite leI0x -oppr_ge0 -raddfN -defNx Im_rootC_ge0.\nQed."
}
{
  "statement": "Lemma imsetU (A B : {set aT}) : f @: (A :|: B) = (f @: A) :|: (f @: B).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset subUset.\nrewrite 2?imsetS (andbT, subsetUl, subsetUr) // andbT.\napply/subsetP=> _ /imsetP[x ABx ->]; apply/setUP.\nby case/setUP: ABx => [Ax | Bx]; [left | right]; apply/imsetP; exists x.\nQed."
}
{
  "statement": "Lemma mulmx_delta_companion (R : nzRingType) (p : seq R)\n  (i: 'I_(size p).-1) (i_small : i.+1 < (size p).-1):\n  delta_mx 0 i *m companionmx p = delta_mx 0 (Ordinal i_small) :> 'rV__.\n",
  "proof": "Proof.\napply/rowP => j; rewrite !mxE (bigD1 i) //= ?(=^~val_eqE, mxE) /= eqxx mul1r.\nrewrite ltn_eqF ?big1 ?addr0 1?eq_sym //; last first.\n  by rewrite -ltnS prednK // (leq_trans  _ i_small).\nby move=> k /negPf ki_eqF; rewrite !mxE eqxx ki_eqF mul0r.\nQed."
}
{
  "statement": "Lemma ltr_prod I r (P : pred I) (E1 E2 : I -> R) :\n    has P r -> (forall i, P i -> 0 <= E1 i < E2 i) ->\n  \\prod_(i <- r | P i) E1 i < \\prod_(i <- r | P i) E2 i.\n",
  "proof": "Proof.\nelim: r => //= i r IHr; rewrite !big_cons; case: ifP => {IHr}// Pi _ ltE12.\nhave /andP[le0E1i ltE12i] := ltE12 i Pi; set E2r := \\prod_(j <- r | P j) E2 j.\napply: le_lt_trans (_ : E1 i * E2r < E2 i * E2r).\n  by rewrite ler_wpM2l ?ler_prod // => j /ltE12/andP[-> /ltW].\nby rewrite ltr_pM2r ?prodr_gt0 // => j /ltE12/andP[le0E1j /le_lt_trans->].\nQed."
}
{
  "statement": "Lemma cfResMorph (G H : {group aT}) (phi : 'CF(f @* G)) :\n  H \\subset G -> G \\subset D -> 'Res (cfMorph phi) = cfMorph ('Res[f @* H] phi).\n",
  "proof": "Proof.\nmove=> sHG sGD; have sHD := subset_trans sHG sGD.\napply/cfun_inP=> x Hx; have [Gx Dx] := (subsetP sHG x Hx, subsetP sHD x Hx).\nby rewrite !(cfMorphE, cfResE) ?morphimS ?mem_morphim //.\nQed."
}
{
  "statement": "Lemma bigU_idem (I : finType) (A B : pred I) F :\n    [disjoint A & B] ->\n  \\big[op/x]_(i in [predU A & B]) F i =\n    op (\\big[op/x]_(i in A) F i) (\\big[op/x]_(i in B) F i).\n",
  "proof": "Proof.\nmove=> dAB; rewrite (bigID_idem (mem A)).\ncongr (op : _ -> _); apply: eq_bigl => i; first by rewrite orbK.\nby have:= pred0P dAB i; rewrite andbC /= !inE; case: (i \\in A).\nQed."
}
{
  "statement": "Lemma solvable_norm_abelem L G :\n    solvable G -> G <| L -> G :!=: 1 ->\n  exists H : {group gT}, [/\\ H \\subset G, H <| L, H :!=: 1 & is_abelem H].\n",
  "proof": "Proof.\nmove=> solG /andP[sGL nGL] ntG.\nhave [H minH sHG]: {H : {group gT} | minnormal H L & H \\subset G}.\n  by apply: mingroup_exists; rewrite ntG.\nhave [nHL ntH abH] := minnormal_solvable minH sHG solG.\nby exists H; split; rewrite // /normal (subset_trans sHG).\nQed."
}
{
  "statement": "Lemma rank_pgroup p G : p.-group G -> 'r(G) = 'r_p(G).\n",
  "proof": "Proof.\nmove=> pG; apply/eqP; rewrite eqn_leq p_rank_le_rank andbT.\nrewrite ['r(G)]big_mkord; apply/bigmax_leqP=> [[q /= _] _].\ncase: (posnP 'r_q(G)) => [-> // |]; rewrite p_rank_gt0 mem_primes.\nby case/and3P=> q_pr _ qG; rewrite (eqnP (pgroupP pG q q_pr qG)).\nQed."
}
{
  "statement": "Lemma size_mul_eq1 p q : (size (p * q) == 1) = ((size p == 1) && (size q == 1)).\n",
  "proof": "Proof.\nhave [->|pNZ] := eqVneq p 0; first by rewrite mul0r size_poly0.\nhave [->|qNZ] := eqVneq q 0; first by rewrite mulr0 size_poly0 andbF.\nrewrite size_mul //.\nby move: pNZ qNZ; rewrite -!size_poly_gt0; (do 2 case: size) => //= n [|[|]].\nQed."
}
{
  "statement": "Lemma subseq_filter s1 s2 a :\n  subseq s1 (filter a s2) = all a s1 && subseq s1 s2.\n",
  "proof": "Proof.\nelim: s2 s1 => [|x s2 IHs] [|y s1] //=; rewrite ?andbF ?sub0seq //.\nby case a_x: (a x); rewrite /= !IHs /=; case: eqP => // ->; rewrite a_x.\nQed."
}
{
  "statement": "Lemma rcoset_index2 G H x :\n  H \\subset G -> #|G : H| = 2 -> x \\in G :\\: H -> H :* x = G :\\: H.\n",
  "proof": "Proof.\nmove=> sHG indexHG => /setDP[Gx notHx]; apply/eqP.\nrewrite eqEcard -(leq_add2l #|G :&: H|) cardsID -(LagrangeI G H) indexHG muln2.\nrewrite (setIidPr sHG) card_rcoset addnn leqnn andbT.\napply/subsetP=> _ /rcosetP[y Hy ->]; apply/setDP.\nby rewrite !groupMl // (subsetP sHG).\nQed."
}
{
  "statement": "Lemma in_factmodJ m (W : 'M_(m, n)) x :\n  x \\in G -> in_factmod (W *m rG x) = in_factmod W *m factmod_mx Umod x.\n",
  "proof": "Proof.\nmove=> Gx; rewrite -{1}[W]add_sub_fact_mod mulmxDl linearD /=.\napply: (canLR (subrK _)); apply: etrans (_ : 0 = _).\n  apply/eqP; rewrite in_factmod_eq0 (submx_trans _ (mxmoduleP Umod x Gx)) //.\n  by rewrite submxMr ?val_submodP.\nby rewrite /in_factmod /val_factmod /= !mulmxA mulmx1 ?subrr.\nQed."
}
{
  "statement": "Lemma morphim_cyclic rT G H (f : {morphism G >-> rT}) :\n  cyclic H -> cyclic (f @* H).\n",
  "proof": "Proof.\nmove=> cycH; wlog sHG: H cycH / H \\subset G.\n  by rewrite -morphimIdom; apply; rewrite (cyclicS _ cycH, subsetIl) ?subsetIr.\ncase/cyclicP: cycH sHG => x ->; rewrite gen_subG sub1set => Gx.\nby apply/cyclicP; exists (f x); rewrite morphim_cycle.\nQed."
}
{
  "statement": "Lemma fconnect_sym_in : {in S &, forall x y, fconnect f x y = fconnect f y x}.\n",
  "proof": "Proof.\nsuff Sf : {in S &, forall x y, fconnect f x y -> fconnect f y x}.\n  by move=> *; apply/idP/idP=> /Sf->.\nmove=> x _ xS _ /connectP [p f_p ->]; elim: p => //= y p IHp in x xS f_p *.\ncase/andP: f_p => /eqP <- /(IHp _ (f_in xS)) /connect_trans -> //.\nby apply: (connect_trans (fconnect_finv _)); rewrite finv_f_in.\nQed."
}
{
  "statement": "Lemma lift0_mx_perm s : lift0_mx (perm_mx s) = perm_mx (lift0_perm s).\n",
  "proof": "Proof.\napply/matrixP=> /= i j; rewrite !mxE split1 /=; case: unliftP => [i'|] -> /=.\n  rewrite lift0_perm_lift !mxE split1 /=.\n  by case: unliftP => [j'|] ->; rewrite ?(inj_eq (lift_inj _)) /= !mxE.\nrewrite lift0_perm0 !mxE split1 /=.\nby case: unliftP => [j'|] ->; rewrite /= mxE.\nQed."
}
{
  "statement": "Lemma pX1p2_extraspecial : extraspecial p^{1+2}.\n",
  "proof": "Proof.\napply: (p3group_extraspecial pX1p2_pgroup); last first.\n  by rewrite card_pX1p2 pfactorK.\ncase/existsP: (isoGrp_hom Grp_pX1p2) card_pX1p2 => [[x y]] /=.\ncase/eqP=> <- xp yp _ _ oXY.\napply: contraL (dvdn_cardMg <[x]> <[y]>) => cXY_XY.\nrewrite -cent_joinEl ?(sub_abelian_cent2 cXY_XY) ?joing_subl ?joing_subr //.\nrewrite oXY -!orderE pfactor_dvdn ?muln_gt0 ?order_gt0 // -leqNgt.\nrewrite -(pfactorK 2 p_pr) dvdn_leq_log ?expn_gt0 ?p_gt0 //.\nby rewrite dvdn_mul ?order_dvdn ?xp ?yp.\nQed."
}
{
  "statement": "Lemma Phi_quotient_id G : 'Phi (G / 'Phi(G)) = 1.\n",
  "proof": "Proof.\napply/trivgP; rewrite -cosetpreSK cosetpre1 /=; apply/bigcapsP=> M maxM.\nhave nPhi := Phi_normal G; have nPhiM: 'Phi(G) <| M.\n  by apply: normalS nPhi; [apply: bigcap_inf | case/maximal_eqP: maxM].\nby rewrite sub_cosetpre_quo ?bigcap_inf // quotient_maximal_eq.\nQed."
}
{
  "statement": "Lemma pnatP pi n :\n  n > 0 -> reflect (forall p, prime p -> p %| n -> p \\in pi) (pi.-nat n).\n",
  "proof": "Proof.\nmove=> n_gt0; rewrite /pnat n_gt0.\napply: (iffP allP) => /= pi_n p => [pr_p p_n|].\n  by rewrite pi_n // mem_primes pr_p n_gt0.\nby rewrite mem_primes n_gt0 /=; case/andP; move: p.\nQed."
}
{
  "statement": "Lemma card_pX1p2n n : prime p -> #|p^{1+2*n}| = (p ^ n.*2.+1)%N.\n",
  "proof": "Proof.\nmove=> p_pr; have pG := pX1p2_pgroup p_pr.\nhave oG := card_pX1p2 p_pr; have esG := pX1p2_extraspecial p_pr.\nhave oZ := card_center_extraspecial pG esG.\nelim: n => [|n IHn]; first by rewrite (card_isog (ncprod0 _)) oZ.\ncase: pX1p2S => gz isoZ; rewrite -im_cpair cardMg_divn setI_im_cpair.\nrewrite -injm_center ?{1}card_injm ?injm_cpairg1 ?injm_cpair1g ?center_sub //.\nby rewrite oG oZ IHn -expnD mulKn ?prime_gt0.\nQed."
}
{
  "statement": "Lemma nat_spec_max (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 max xi yi) :\n  nat_spec r (maxn x%:num y%:num).\n",
  "proof": "Proof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) -maxEnat natr_max.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_max.\nQed."
}
{
  "statement": "Lemma val_quotient A : val @: (A / H) = rcosets H 'N_A(H).\n",
  "proof": "Proof.\napply/setP=> B; apply/imsetP/rcosetsP=> [[xbar Axbar]|[x /setIP[Ax Nx]]] ->{B}.\n  case/morphimP: Axbar => x Nx Ax ->{xbar}.\n  by exists x; [rewrite inE Ax | rewrite /= val_coset].\nby exists (coset H x); [apply/morphimP; exists x | rewrite /= val_coset].\nQed."
}
{
  "statement": "Lemma nat_spec_min (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 min xi yi) :\n  nat_spec r (minn x%:num y%:num).\n",
  "proof": "Proof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) -minEnat natr_min.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_min.\nQed."
}
{
  "statement": "Lemma hom_mxsemisimple (V f : 'M_n) :\n  mxsemisimple V -> (V <= dom_hom_mx f)%MS -> mxsemisimple (V *m f).\n",
  "proof": "Proof.\ncase=> I W /= simW defV _; rewrite -defV => /sumsmx_subP homWf.\nhave{defV} defVf: (\\sum_i W i *m f :=: V *m f)%MS.\n  by apply: eqmx_trans (eqmx_sym _) (eqmxMr f defV); apply: sumsmxMr.\napply: (intro_mxsemisimple defVf) => i _ nzWf.\nby apply: mx_iso_simple (simW i); apply: mx_Schur_inj_iso; rewrite ?homWf.\nQed."
}
{
  "statement": "Lemma count_lt_le_mem x s : (count (< x) s < count (<= x) s)%N = (x \\in s).\n",
  "proof": "Proof.\nhave := count_predUI (pred1 x) (< x) s.\nhave -> : count (predI (pred1 x) (< x)) s = 0%N.\n  rewrite (@eq_count _ _ pred0) ?count_pred0 // => y /=.\n  by rewrite lt_def; case: eqP => //= ->; rewrite eqxx.\nhave /eq_count-> : [predU1 x & < x] =1 (<= x) by move=> y /=; rewrite le_eqVlt.\nby rewrite addn0 => ->; rewrite -add1n leq_add2r -has_count has_pred1.\nQed."
}
{
  "statement": "Lemma subset_mapP (s : seq T1) (s' : seq T2) :\n    {subset s' <= map f s} <-> exists2 t, all (mem s) t & s' = map f t.\n",
  "proof": "Proof.\nsplit => [|[r /allP/= rE ->] _ /mapP[x xr ->]]; last by rewrite map_f ?rE.\nelim: s' => [|x s' IHs'] subss'; first by exists [::].\nhave /mapP[y ys ->] := subss' _ (mem_head _ _).\nhave [x' x's'|t st ->] := IHs'; first by rewrite subss'// inE x's' orbT.\nby exists (y :: t); rewrite //= ys st.\nQed."
}
{
  "statement": "Lemma irrEchar chi : (chi \\in irr G) = (chi \\is a character) && ('[chi] == 1).\n",
  "proof": "Proof.\napply/irrP/andP=> [[i ->] | [Nchi]]; first by rewrite irr_char cfnorm_irr.\nrewrite cfdot_sum_irr => /eqP/natr_sum_eq1[i _| i [_ ci1 cj0]].\n  by rewrite rpredM // ?conj_natr ?Cnat_cfdot_char_irr.\nexists i; rewrite [chi]cfun_sum_cfdot (bigD1 i) //=.\nrewrite -(normr_idP (natr_ge0 (Cnat_cfdot_char_irr i Nchi))).\nrewrite normC_def {}ci1 sqrtC1 scale1r big1 ?addr0 // => j neq_ji.\nby rewrite (('[_] =P 0) _) ?scale0r // -normr_eq0 normC_def cj0 ?sqrtC0.\nQed."
}
{
  "statement": "Lemma Bezout_coprimepP p q :\n  reflect (exists u, u.1 * p + u.2 * q %= 1) (coprimep p q).\n",
  "proof": "Proof.\nrewrite -gcdp_eqp1; apply: (iffP idP)=> [g1|].\n  by case: (Bezoutp p q) => [[u v] Puv]; exists (u, v); apply: eqp_trans g1.\ncase=> [[u v]]; rewrite eqp_sym=> Puv; rewrite /eqp (eqp_dvdr _ Puv).\nby rewrite dvdp_addr dvdp_mull ?dvdp_gcdl ?dvdp_gcdr //= dvd1p.\nQed."
}
{
  "statement": "Lemma Wedderburn_closed_pchar i : ('R_i * 'R_i = 'R_i)%MS.\n",
  "proof": "Proof.\nrewrite -{3}['R_i]genmx_id -/'R_i -genmx_muls; apply/genmxP.\nhave [idlRi idrRi] := andP (Wedderburn_ideal i).\napply/andP; split.\n  by apply: submx_trans idrRi; rewrite mulsmxS // genmxE submxMl.\nhave [_ Ri_e ideRi _] := Wedderburn_is_id_pchar i.\nby apply/memmx_subP=> A RiA; rewrite -[A]ideRi ?mem_mulsmx.\nQed."
}
{
  "statement": "Lemma mxrowEblock {q : nat} {q_ : 'I_q -> nat} m\n    (R_ : forall j, 'M[T]_(m, q_ j)) :\n  (\\mxrow_j R_ j) =\n  castmx (big_ord1 _ (fun=> m), erefl) (\\mxblock_(i < 1, j < q) R_ j).\n",
  "proof": "Proof.\nrewrite mxblock_recu castmx_comp.\napply/matrixP => i j; rewrite !castmxE !mxE/=; case: splitP => //=.\n  by move=> k /val_inj->; rewrite ?cast_ord_id ?mxE//=.\nby move=> [k klt]; suff: false by []; rewrite big_ord0 in klt.\nQed."
}
{
  "statement": "Lemma morphim_fixP A : A \\subset G -> reflect (f @* A = A) (f @* A \\subset A).\n",
  "proof": "Proof.\nrewrite /morphim => sAG; have:= eqEcard (f @: A) A.\nrewrite (setIidPr sAG) card_in_imset ?leqnn ?andbT  => [<-|]; first exact: eqP.\nby move/injmP: injf; apply: sub_in2; apply/subsetP.\nQed."
}
{
  "statement": "Lemma subset_dfs n v a : v \\subset foldl (dfs n) v a.\n",
  "proof": "Proof.\nelim: n a v => [|n IHn]; first by elim=> //= *; rewrite if_same.\nelim=> //= x a IHa v; apply: subset_trans {IHa}(IHa _); case: ifP => // _.\nby apply: subset_trans (IHn _ _); apply/subsetP=> y; apply: predU1r.\nQed."
}
{
  "statement": "Lemma redivp_map a b :\n  redivp a^f b^f = (rscalp a b, (rdivp a b)^f, (rmodp a b)^f).\n",
  "proof": "Proof.\nrewrite /rdivp /rscalp /rmodp !unlock map_poly_eq0 size_map_poly.\nhave [// | q_nz] := ifPn; rewrite -(rmorph0 (map_poly f)) //.\nhave [m _] := ubnPeq (size a); elim: m 0%N 0 a => [|m IHm] qq r a /=.\n  rewrite -!mul_polyC !size_map_poly !lead_coef_map // -(map_polyXn f).\n  by rewrite -!(map_polyC f) -!rmorphM -rmorphB -rmorphD; case: (_ < _).\nrewrite -!mul_polyC !size_map_poly !lead_coef_map // -(map_polyXn f).\nby rewrite -!(map_polyC f) -!rmorphM -rmorphB -rmorphD /= IHm; case: (_ < _).\nQed."
}
{
  "statement": "Lemma im_Zpm : Zpm @* Zp #[a] = <[a]>.\n",
  "proof": "Proof.\napply/eqP; rewrite eq_sym eqEcard cycle_subG /= andbC morphimEdom.\nrewrite (leq_trans (leq_imset_card _ _)) ?card_Zp //= /Zp order_gt1.\ncase: eqP => /= [a1 | _]; first by rewrite imset_set1 morph1 a1 set11.\nby apply/imsetP; exists 1%R; rewrite ?expg1 ?inE.\nQed."
}
{
  "statement": "Lemma memmx_sumsP (I : finType) (P : pred I) n (A : 'M_n) R_ :\n  reflect (exists2 A_, A = \\sum_(i | P i) A_ i & forall i, A_ i \\in R_ i)\n          (A \\in \\sum_(i | P i) R_ i)%MS.\n",
  "proof": "Proof.\napply: (iffP sub_sumsmxP) => [[C defA] | [A_ -> R_A] {A}].\n  exists (fun i => vec_mx (C i *m R_ i)) => [|i].\n    by rewrite -linear_sum -defA /= mxvecK.\n  by rewrite vec_mxK submxMl.\nexists (fun i => mxvec (A_ i) *m pinvmx (R_ i)).\nby rewrite linear_sum; apply: eq_bigr => i _; rewrite mulmxKpV.\nQed."
}
{
  "statement": "Lemma coprime_egcdn n m : n > 0 -> coprime (egcdn n m).1 (egcdn n m).2.\n",
  "proof": "Proof.\nmove=> n_gt0; case: (egcdnP m n_gt0) => kn km /= /eqP.\nhave [/dvdnP[u defn] /dvdnP[v defm]] := (dvdn_gcdl n m, dvdn_gcdr n m).\nrewrite -[gcdn n m]mul1n {1}defm {1}defn !mulnA -mulnDl addnC.\nrewrite eqn_pmul2r ?gcdn_gt0 ?n_gt0 //; case: kn => // kn /eqP def_knu _.\nby apply/coprimeP=> //; exists (u, v); rewrite mulnC def_knu mulnC addnK.\nQed."
}
{
  "statement": "Lemma p_rank_geP p n G : reflect (exists E, E \\in 'E_p^n(G)) (n <= 'r_p(G)).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[E]]; last first.\n  by rewrite inE => /andP[Ep_E /eqP <-]; rewrite (bigmax_sup E).\nhave [D /pnElemP[sDG abelD <-]] := p_rank_witness p G.\nby case/abelem_pnElem=> // E; exists E; apply: (subsetP (pnElemS _ _ sDG)).\nQed."
}
{
  "statement": "Lemma all_roots_prod_XsubC p rs :\n    size p = (size rs).+1 -> all (root p) rs -> uniq_roots rs ->\n  p = lead_coef p *: \\prod_(z <- rs) ('X - z%:P).\n",
  "proof": "Proof.\nmove=> size_p /uniq_roots_prod_XsubC def_p Urs.\ncase/def_p: Urs => q -> {p def_p} in size_p *.\nhave [q0 | nz_q] := eqVneq q 0; first by rewrite q0 mul0r size_poly0 in size_p.\nhave{q nz_q size_p} /size_poly1P[c _ ->]: size q == 1.\n  rewrite -(eqn_add2r (size rs)) add1n -size_p.\n  by rewrite size_Mmonic ?monic_prod_XsubC // size_prod_XsubC addnS.\nby rewrite lead_coef_Mmonic ?monic_prod_XsubC // lead_coefC mul_polyC.\nQed."
}
{
  "statement": "Lemma zchar_trans S1 S2 A B :\n  {subset S1 <= 'Z[S2, B]} -> {subset 'Z[S1, A] <= 'Z[S2, A]}.\n",
  "proof": "Proof.\nmove=> sS12 phi; rewrite !(zchar_split _ A) andbC => /andP[->]; rewrite andbT.\ncase/zchar_nth_expansion=> z Zz ->; apply: rpred_sum => i _.\nby rewrite scale_zchar // (@zcharW _ B) ?sS12 ?mem_nth.\nQed."
}
{
  "statement": "Lemma dim_img_form_eq1 u V : u \\notin orthov V -> \\dim (alpha u @: V)%VS = 1%N.\n",
  "proof": "Proof.\nmove=> /mem_orthovPn [v vV Northov_uv]; apply/eqP; rewrite eqn_leq /=.\nrewrite -[1%N as X in (_ <= X)%N](dimvf [the vectType F of F^o]) dimvS ?subvf//=.\nhave := @dimvS _ _ <['[v, u] : F^o]> (alpha u @: V).\nrewrite -memvE dim_vline herm_eq0C Northov_uv; apply.\nby apply/memv_imgP; exists v; rewrite ?memvf// !lfunE /=.\nQed."
}
{
  "statement": "Lemma cfResQuo H K phi :\n     K \\subset cfker phi -> K \\subset H -> H \\subset G ->\n  ('Res[H / K] (phi / K) = 'Res[H] phi / K)%CF.\n",
  "proof": "Proof.\nmove=> kerK sKH sHG; apply/cfun_inP=> xb Hxb; rewrite cfResE ?quotientS //.\nhave{xb Hxb} [x nKx Hx ->] := morphimP Hxb.\nby rewrite !cfQuoEnorm ?cfResE// 1?inE ?Hx ?(subsetP sHG)// sub_cfker_Res.\nQed."
}
{
  "statement": "Lemma cfker_center_normal phi : cfker phi <| 'Z(phi)%CF.\n",
  "proof": "Proof.\napply: normalS (cfcenter_sub phi) (cfker_normal phi).\nrewrite /= /cfcenter; case: ifP => // Hphi; rewrite cfkerEchar //.\napply/subsetP=> x /[!inE] /andP[-> /eqP->] /=.\nby rewrite ger0_norm ?char1_ge0.\nQed."
}
{
  "statement": "Lemma bigcupsP U P F :\n  reflect (forall i, P i -> F i \\subset U) (\\bigcup_(i | P i) F i \\subset U).\n",
  "proof": "Proof.\napply: (iffP idP) => [sFU i Pi| sFU].\n  by apply: subset_trans sFU; apply: bigcup_sup.\nby apply/subsetP=> x /bigcupP[i Pi]; apply: (subsetP (sFU i Pi)).\nQed."
}
{
  "statement": "Lemma swapXY_is_multiplicative : multiplicative swapXY.\n",
  "proof": "Proof.\nsplit=> [u v|]; last by rewrite swapXY_polyC map_polyC.\napply/polyP=> i; apply/polyP=> j; rewrite coef_swapXY !coefM !coef_sum.\nrewrite (eq_bigr _ (fun _ _ => coefM _ _ _)) exchange_big /=.\napply: eq_bigr => j1 _; rewrite coefM; apply: eq_bigr=> i1 _.\nby rewrite !coef_swapXY.\nQed."
}
{
  "statement": "Lemma commrXz x y n : GRing.comm x y -> GRing.comm x (y ^ n).\n",
  "proof": "Proof.\nrewrite /GRing.comm; elim: n x y=> [|n ihn|n ihn] x y com_xy //=.\n* by rewrite expr0z mul1r mulr1.\n* by rewrite -exprnP commrX //.\nrewrite -exprz_inv -exprnP commrX //.\ncase: (boolP (y \\is a GRing.unit))=> uy; last by rewrite invr_out.\nby apply/eqP; rewrite (can2_eq (mulrVK _) (mulrK _)) // -mulrA com_xy mulKr.\nQed."
}
{
  "statement": "Lemma series_sol G H : H <| G -> solvable G = solvable H && solvable (G / H).\n",
  "proof": "Proof.\ncase/andP=> sHG nHG; apply/idP/andP=> [solG | [solH solGH]].\n  by rewrite quotient_sol // (solvableS sHG).\napply/forall_inP=> K /subsetIP[sKG sK'K].\nsuffices sKH: K \\subset H by rewrite (forall_inP solH) // subsetI sKH.\nhave nHK := subset_trans sKG nHG.\nrewrite -quotient_sub1 // subG1 (forall_inP solGH) //.\nby rewrite subsetI -morphimR ?morphimS.\nQed."
}
{
  "statement": "Lemma mask_sort s m :\n  {m_s : bitseq | mask m_s (sort leT s) = sort leT (mask m s)}.\n",
  "proof": "Proof.\ncase Ds: {-}s => [|x s1]; [by rewrite Ds; case: m; exists [::] | clear s1 Ds].\nrewrite -(mkseq_nth x s) -map_mask !sort_map.\nexists [seq i \\in mask m (iota 0 (size s)) |\n            i <- sort (xrelpre (nth x s) leT) (iota 0 (size s))].\nrewrite -map_mask -filter_mask [in RHS]mask_filter ?iota_uniq ?filter_sort //.\nby move=> ? ? ?; exact: leT_tr.\nQed."
}
{
  "statement": "Lemma homg_quotientS (A : {set gT}) :\n  A \\subset 'N(H) -> A \\subset 'N(K) -> H \\subset K -> A / K \\homg A / H.\n",
  "proof": "Proof.\nrewrite -!(gen_subG A) /=; set L := <<A>> => nHL nKL sKH.\nhave sub_ker: 'ker (restrm nHL (coset H)) \\subset 'ker (restrm nKL (coset K)).\n  by rewrite !ker_restrm !ker_coset setIS.\nhave sAL: A \\subset L := subset_gen A; rewrite -(setIidPr sAL).\nrewrite -[_ / H](morphim_restrm nHL) -[_ / K](morphim_restrm nKL) /=.\nby rewrite -(morphim_factm sub_ker (subxx L)) morphim_homg ?morphimS.\nQed."
}
{
  "statement": "Lemma cfclass_uniq phi : H <| G -> uniq (phi ^: G)%CF.\n",
  "proof": "Proof.\nmove=> nsHG; rewrite map_inj_in_uniq ?enum_uniq // => Ty Tz; rewrite !mem_enum.\nmove=> {Ty}/rcosetsP[y Gy ->] {Tz}/rcosetsP[z Gz ->] /eqP.\ncase: repr_rcosetP => u Iphi_u; case: repr_rcosetP => v Iphi_v.\nhave [[Gu _] [Gv _]] := (setIdP Iphi_u, setIdP Iphi_v).\nrewrite cfConjg_eqE ?groupM // => /rcoset_eqP.\nby rewrite !rcosetM (rcoset_id Iphi_v) (rcoset_id Iphi_u).\nQed."
}
{
  "statement": "Lemma nil_comm_properl G H A :\n    nilpotent G -> H \\subset G -> H :!=: 1 -> A \\subset 'N_G(H) ->\n  [~: H, A] \\proper H.\n",
  "proof": "Proof.\nmove=> nilG sHG ntH; rewrite subsetI properE; case/andP=> sAG nHA.\nrewrite (subset_trans (commgS H (subset_gen A))) ?commg_subl ?gen_subG //.\napply: contra ntH => sHR; have:= forallP nilG H; rewrite subsetI sHG.\nby rewrite (subset_trans sHR) ?commgS.\nQed."
}
{
  "statement": "Lemma mxsub_ind\n    (weight : forall m n, 'M[R]_(m, n) -> nat)\n    (sub : forall m n m' n', ('I_m' -> 'I_m) -> ('I_n' -> 'I_n) -> Prop)\n    (P : forall m n, 'M[R]_(m, n) -> Type) :\n    (forall m n (A : 'M[R]_(m, n)),\n      (forall m' n' f g, weight m' n' (mxsub f g A) < weight m n A ->\n                         sub m n m' n' f g ->\n                         P m' n' (mxsub f g A)) -> P m n A) ->\n  forall m n A, P m n A.\n",
  "proof": "Proof.\nmove=> Psub m n A; have [k] := ubnP (weight m n A).\nelim: k => [//|k IHk] in m n A *.\nrewrite ltnS => lt_A_k; apply: Psub => m' n' f g lt_A'_A ?.\nby apply: IHk; apply: leq_trans lt_A_k.\nQed."
}
{
  "statement": "Lemma prev_rev p : uniq p -> prev (rev p) =1 next p.\n",
  "proof": "Proof.\nmove=> Up x; case p_x: (x \\in p); last first.\n  by rewrite next_nth prev_nth mem_rev p_x.\ncase/rot_to: p_x (Up) => [i q def_p] Urp; rewrite -rev_uniq in Urp.\nrewrite -(prev_rotr i Urp); do 2 rewrite -(prev_rotr 1) ?rotr_uniq //.\nrewrite -rev_rot -(next_rot i Up) {i p Up Urp}def_p.\nby case: q => // y q; rewrite !rev_cons !(=^~ rcons_cons, rotr1_rcons) /= eqxx.\nQed."
}
{
  "statement": "Lemma quotient_center_nil G : nilpotent (G / 'Z(G)) = nilpotent G.\n",
  "proof": "Proof.\nrewrite -ucn1; apply/idP/idP; last exact: quotient_nil.\ncase/ucnP=> c nilGq; apply/ucnP; exists c.+1; have nsZ1G := ucn_normal 1 G.\napply: (quotient_inj _ nsZ1G); last by rewrite /= -(addn1 c) quotient_ucn_add.\nby rewrite (normalS _ _ nsZ1G) ?ucn_sub ?ucn_sub_geq.\nQed."
}
{
  "statement": "Lemma normalField_root_minPoly K E a b :\n    (K <= E)%VS -> normalField K E -> a \\in E -> root (minPoly K a) b ->\n  exists2 x, x \\in 'Gal(E / K) & x a = b.\n",
  "proof": "Proof.\nmove=> sKE nKE Ea pKa_b_0; pose f := kHomExtend K \\1 a b.\nhave homKa_f: kHom K <<K; a>> f.\n  by apply: kHomExtendP; rewrite ?kHom1 ?lfun1_poly.\nhave sK_Ka_E: (K <= <<K; a>> <= E)%VS.\n  by rewrite subv_adjoin; apply/FadjoinP; rewrite sKE Ea.\nhave [x galEx Df] := kHom_to_gal sK_Ka_E nKE homKa_f; exists x => //.\nby rewrite -Df ?memv_adjoin // (kHomExtend_val (kHom1 K K)) ?lfun1_poly.\nQed."
}
{
  "statement": "Lemma trivIimset J F (P := F @: J) :\n    {in J &, forall i j, j != i -> [disjoint F i & F j]} -> set0 \\notin P ->\n  trivIset P /\\ {in J &, injective F}.\n",
  "proof": "Proof.\nmove=> tiF notPset0; split=> [|i j Ji Jj /= eqFij].\n  apply/trivIsetP=> _ _ /imsetP[i Ji ->] /imsetP[j Jj ->] neqFij.\n  by rewrite tiF // (contraNneq _ neqFij) // => ->.\napply: contraNeq notPset0 => neq_ij; apply/imsetP; exists i => //; apply/eqP.\nby rewrite eq_sym -[F i]setIid setI_eq0 {1}eqFij tiF.\nQed."
}
{
  "statement": "Lemma minset_fix : minset [pred X | F X == X] fixset.\n",
  "proof": "Proof.\napply/minsetP; rewrite inE fixsetK eqxx; split=> // X /eqP FXeqX Xsubfix.\napply/eqP; rewrite eqEsubset Xsubfix/=.\nsuff: fixset \\subset iter n F X by rewrite iter_fix.\nby rewrite /fixset; elim: n => //= [|m IHm]; rewrite ?sub0set ?F_mono.\nQed."
}
{
  "statement": "Lemma eq_in_pHall pi rho G H :\n  {in \\pi(G), pi =i rho} -> pi.-Hall(G) H = rho.-Hall(G) H.\n",
  "proof": "Proof.\nmove=> eq_pi_rho; apply: andb_id2l => sHG.\ncongr (_ && _); apply: eq_in_pnat => p piHp.\n  by apply: eq_pi_rho; apply: (piSg sHG).\nby congr (~~ _); apply: eq_pi_rho; apply: (pi_of_dvd (dvdn_indexg G H)).\nQed."
}
{
  "statement": "Lemma aspaceOverP (E_F : {subfield L_F}) :\n  {E | [/\\ E_F = aspaceOver E, (F <= E)%VS & E_F =i E]}.\n",
  "proof": "Proof.\nhave [V [defEF modV memV]] := vspaceOverP E_F.\nhave algE: has_algid V && (V * V <= V)%VS.\n  rewrite has_algid1; last by rewrite -memV mem1v.\n  by apply/prodvP=> u v; rewrite -!memV; apply: memvM.\nby exists (ASpace algE); rewrite -sup_field_module; split; first apply: val_inj.\nQed."
}
{
  "statement": "Lemma mup_geq x q n : q != 0 -> (n <= mup x q)%N = (('X - x%:P) ^+ n %| q).\n",
  "proof": "Proof.\nmove=> q_neq0; rewrite /mup; symmetry.\ncase: arg_maxnP; rewrite ?expr0 ?dvd1p//= => i i_dvd gti.\ncase: ltnP => [|/dvdp_exp2l/dvdp_trans]; last exact.\napply: contraTF => dvdq; rewrite -leqNgt.\nsuff n_small : (n < (size q).+1)%N by exact: (gti (Ordinal n_small)).\nby rewrite ltnS ltnW// -(size_exp_XsubC _ x) dvdp_leq.\nQed."
}
{
  "statement": "Lemma isom_restr_perm a : a \\in Aut G -> fHisom (inH a) = infH (fGisom a).\n",
  "proof": "Proof.\nmove=> AutGa; case nHa: (a \\in 'N(H | 'P)); last first.\n  by rewrite !triv_restr_perm ?astabs_Aut_isom ?nHa ?morph1.\napply: (eq_Aut (Aut_Aut_isom injf sHD _)) => [|fx Hfx /=].\n  by rewrite (Aut_restr_perm (morphimS f sHG)) ?Aut_Aut_isom.\nhave [x Dx Hx def_fx] := morphimP Hfx; have Gx := subsetP sHG x Hx.\nrewrite {1}def_fx Aut_isomE ?(Aut_restr_perm sHG) //.\nby rewrite !restr_permE ?astabs_Aut_isom // def_fx Aut_isomE.\nQed."
}
{
  "statement": "Lemma dvdCP x y : reflect (exists2 z, z \\in Num.int & y = z * x) (x %| y)%C.\n",
  "proof": "Proof.\nrewrite unfold_in; have [-> | nz_x] := eqVneq.\n  by apply: (iffP eqP) => [-> | [z _ ->]]; first exists 0; rewrite ?mulr0.\napply: (iffP idP) => [Zyx | [z Zz ->]]; last by rewrite mulfK.\nby exists (y / x); rewrite ?divfK.\nQed."
}
{
  "statement": "Lemma commg_subr G H : ([~: G, H] \\subset H) = (G \\subset 'N(H)).\n",
  "proof": "Proof.\nrewrite gen_subG; apply/subsetP/subsetP=> [sRH x Gx | nGH xy].\n  rewrite inE; apply/subsetP=> _ /imsetP[y Ky ->].\n  by rewrite conjg_Rmul groupMr // sRH // imset2_f ?groupV.\ncase/imset2P=> x y Gx Hy ->{xy}.\nby rewrite commgEr groupMr // memJ_norm (groupV, nGH).\nQed."
}
{
  "statement": "Lemma orthomx_sym p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  (A '_|_ B)%MS = (B '_|_ A)%MS.\n",
  "proof": "Proof.\ngen have nC : p q A B / (A '_|_ B -> B '_|_ A)%MS; last by apply/idP/idP; apply/nC.\nmove=> AnB; apply/orthomxP => u v ? ?; rewrite orthomxE.\nrewrite hermC mulf_eq0 ?fmorph_eq0 ?signr_eq0 /=.\nby rewrite -orthomxE (orthomxP _ _ AnB).\nQed."
}
{
  "statement": "Lemma rV_eqP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (forall u : 'rV_n, (u <= A) = (u <= B))%MS (A == B)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [eqAB u | eqAB]; first by rewrite (eqmxP eqAB).\nby apply/andP; split; apply/rV_subP=> u; rewrite eqAB.\nQed."
}
{
  "statement": "Lemma lcn_nil_classP n G :\n  nilpotent G -> reflect ('L_n.+1(G) = 1) (nil_class G <= n).\n",
  "proof": "Proof.\nrewrite nilpotent_class /nil_class; set s := mkseq _ _.\nset c := index 1 s => lt_c_G; case: leqP => [le_c_n | lt_n_c].\n  have Lc1: nth 1 s c = 1 by rewrite nth_index // -index_mem size_mkseq.\n  by left; apply/trivgP; rewrite -Lc1 nth_mkseq ?lcn_sub_leq.\nright; apply/eqP/negPf; rewrite -(before_find 1 lt_n_c) nth_mkseq //.\nexact: ltn_trans lt_n_c lt_c_G.\nQed."
}
{
  "statement": "Lemma leq_min m n1 n2 : (m <= minn n1 n2) = (m <= n1) && (m <= n2).\n",
  "proof": "Proof.\nwlog le_n21: n1 n2 / n2 <= n1.\n  by case/orP: (leq_total n2 n1) => ?; last rewrite minnC andbC; apply.\nrewrite /minn ltnNge le_n21 /=; case le_m_n1: (m <= n1) => //=.\napply/contraFF: le_m_n1 => /leq_trans; exact.\nQed."
}
{
  "statement": "Lemma normal_sub_max_pgroup pi H M G :\n  [max M | pi.-subgroup(G) M] -> pi.-group H -> H <| G -> H \\subset M.\n",
  "proof": "Proof.\nmove=> maxM piH /andP[sHG nHG].\napply: comm_sub_max_pgroup piH sHG _ => //; apply: commute_sym; apply: normC.\nby apply: subset_trans nHG; case/andP: (maxgroupp maxM).\nQed."
}
{
  "statement": "Lemma le_truncn : {homo truncn : x y / x <= y >-> (x <= y)%N}.\n",
  "proof": "Proof.\nmove=> x y lexy; move: (truncnP x) (truncnP y).\ncase: ifP => [x0 /andP[letx _] | x0 /eqP->//].\ncase: ifP => [y0 /andP[_] | y0 /eqP->]; [|by rewrite (le_trans x0 lexy) in y0].\nby move=> /(le_lt_trans lexy) /(le_lt_trans letx); rewrite ltr_nat ltnS.\nQed."
}
{
  "statement": "Lemma morphpreK R : R \\subset f @* D -> f @* (f @*^-1 R) = R.\n",
  "proof": "Proof.\nmove=> sRfD; apply/setP=> y; apply/morphimP/idP=> [[x _] | Ry].\n  by rewrite !inE; case/andP=> _ Rfx ->.\nhave /morphimP[x Dx _ defy]: y \\in f @* D := subsetP sRfD y Ry.\nby exists x; rewrite // !inE Dx -defy.\nQed."
}
{
  "statement": "Lemma odd_not_extremal2 : odd #|G| -> ~~ extremal2 G.\n",
  "proof": "Proof.\nrewrite /extremal2 /extremal_class; case: logn => // n'.\ncase: andP => [[n_gt1 isoG] | _].\n  by rewrite (card_isog isoG) card_2dihedral ?oddX.\ncase: andP => [[n_gt2 isoG] | _].\n  by rewrite (card_isog isoG) card_quaternion ?oddX.\ncase: andP => [[n_gt3 isoG] | _].\n  by rewrite (card_isog isoG) card_semidihedral ?oddX.\nby case: ifP.\nQed."
}
{
  "statement": "Lemma mul_lin_irr xi chi :\n  xi \\is a linear_char -> chi \\in irr G -> xi * chi \\in irr G.\n",
  "proof": "Proof.\nmove=> Lxi; rewrite !irrEchar => /andP[Nphi /eqP <-].\nrewrite rpredM // ?lin_charW //=; apply/eqP; congr (_ * _).\napply: eq_bigr=> x Gx; rewrite !cfunE rmorphM/= mulrACA -(lin_charV_conj Lxi)//.\nby rewrite -lin_charM ?groupV // mulgV lin_char1 ?mul1r.\nQed."
}
{
  "statement": "Lemma index2_normal G H : H \\subset G -> #|G : H| = 2 -> H <| G.\n",
  "proof": "Proof.\nmove=> sHG indexHG; rewrite /normal sHG; apply/subsetP=> x Gx.\ncase Hx: (x \\in H); first by rewrite inE conjGid.\nrewrite inE conjsgE mulgA -sub_rcosetV -invg_rcoset.\nby rewrite !(rcoset_index2 sHG) ?inE ?groupV ?Hx // invDg !invGid.\nQed."
}
{
  "statement": "Lemma fful_lin_char_inj : cfaithful xi -> {in G &, injective xi}.\n",
  "proof": "Proof.\nmove=> fful_phi x y Gx Gy xi_xy; apply/eqP; rewrite eq_mulgV1 -in_set1.\nrewrite (subsetP fful_phi) // inE groupM ?groupV //=; apply/forallP=> z.\nhave [Gz | G'z] := boolP (z \\in G); last by rewrite !cfun0 ?groupMl ?groupV.\nby rewrite -mulgA lin_charM ?xi_xy -?lin_charM ?groupM ?groupV // mulKVg.\nQed."
}
{
  "statement": "Lemma Ohm1_cyclic_pgroup_prime p G :\n  cyclic G -> p.-group G -> G :!=: 1 -> #|'Ohm_1(G)| = p.\n",
  "proof": "Proof.\nmove=> cycG pG ntG; set K := 'Ohm_1(G).\nhave abelK: p.-abelem K by rewrite Ohm1_abelem ?cyclic_abelian.\nhave sKG: K \\subset G := Ohm_sub 1 G.\ncase/cyclicP: (cyclicS sKG cycG) => x /=; rewrite -/K => defK.\nrewrite defK -orderE (abelem_order_p abelK) //= -/K ?defK ?cycle_id //.\nrewrite -cycle_eq1 -defK -(setIidPr sKG).\nby apply: contraNneq ntG => /TI_Ohm1; rewrite setIid => ->.\nQed."
}
{
  "statement": "Lemma rcent_quo A : rcent rGH A = (rcent rG A / H)%g.\n",
  "proof": "Proof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|]; case/morphimP=> x Nx Gx ->{Hx}.\n  by rewrite quo_repr_coset // => cAx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx cAx; rewrite quo_repr_coset ?mem_morphim.\nQed."
}
{
  "statement": "Lemma commgAC G x y z : x \\in G -> y \\in G -> z \\in G ->\n  commute y z -> abelian [~: [set x], G] -> [~ x, y, z] = [~ x, z, y].\n",
  "proof": "Proof.\nmove=> Gx Gy Gz cyz /centsP cRxG; pose cx' u := [~ x^-1, u].\nhave xR3 u v: [~ x, u, v] = x^-1 * (cx' u * cx' v) * x ^ (u * v).\n  rewrite mulgA -conjg_mulR conjVg [cx' v]commgEl mulgA -invMg.\n  by rewrite -mulgA conjgM -conjMg -!commgEl.\nsuffices RxGcx' u: u \\in G -> cx' u \\in [~: [set x], G].\n  by rewrite !xR3 {}cyz; congr (_ * _ * _); rewrite cRxG ?RxGcx'.\nmove=> Gu; suffices/groupMl <-: [~ x, u] ^ x^-1 \\in [~: [set x], G].\n  by rewrite -commMgJ mulgV comm1g group1.\nby rewrite memJ_norm ?mem_commg ?set11 // groupV (subsetP (commg_normr _ _)).\nQed."
}
{
  "statement": "Lemma pfamilyP (pT : predType rT) y D (F : aT -> pT) f :\n  reflect (y.-support f \\subset D /\\ {in D, forall x, f x \\in F x})\n          (f \\in pfamily_mem y (mem D) (fmem F)).\n",
  "proof": "Proof.\napply: (iffP familyP) => [/= f_pfam | [/supportP f_supp f_fam] x].\n  split=> [|x Ax]; last by have:= f_pfam x; rewrite Ax.\n  by apply/subsetP=> x; case: ifP (f_pfam x) => //= _ fx0 /negP[].\nby case: ifPn => Ax /=; rewrite inE /= (f_fam, f_supp).\nQed."
}
{
  "statement": "Lemma card_classes_abelian : abelian G = (#|classes G| == #|G|).\n",
  "proof": "Proof.\nhave cGgt0 C: C \\in classes G -> 1 <= #|C| ?= iff (#|C| == 1)%N.\n  by case/imsetP=> x _ ->; rewrite eq_sym -index_cent1.\nrewrite -sum_card_class -sum1_card (leqif_sum cGgt0).\napply/abelian_classP/forall_inP=> [cGG _ /imsetP[x Gx ->]| cGG x Gx].\n  by rewrite cGG ?cards1.\napply/esym/eqP; rewrite eqEcard sub1set cards1 class_refl leq_eqVlt cGG //.\nexact: imset_f.\nQed."
}
{
  "statement": "Lemma coprime_cent_mulG A G H :\n     A \\subset 'N(G) -> A \\subset 'N(H) -> G \\subset 'N(H) ->\n     coprime #|H| #|A| -> solvable H ->\n  'C_(H * G)(A) = 'C_H(A) * 'C_G(A).\n",
  "proof": "Proof.\nmove=> nHA nGA nHG coHA solH; rewrite -norm_joinEr //.\nhave nsHG: H <| H <*> G by rewrite /normal joing_subl join_subG normG.\nrewrite -{2}(setIidPr (normal_sub nsHG)) setIAC.\nrewrite group_modr ?setSI ?joing_subr //=; symmetry; apply/setIidPl.\nrewrite -quotientSK ?subIset 1?normal_norm //.\nby rewrite !coprime_norm_quotient_cent ?normsY //= norm_joinEr ?quotientMidl.\nQed."
}
{
  "statement": "Lemma zchar_expansion S A phi : uniq S ->\n    phi \\in 'Z[S, A] ->\n  {z | forall xi, z xi \\in Num.int & phi = \\sum_(xi <- S) z xi *: xi}.\n",
  "proof": "Proof.\nmove=> Suniq /zchar_nth_expansion[z Zz ->] /=.\npose zS xi := oapp z 0 (insub (index xi S)).\nexists zS => [xi | ]; rewrite {}/zS; first by case: (insub _) => /=.\nrewrite (big_nth 0) big_mkord; apply: eq_bigr => i _; congr (_ *: _).\nby rewrite index_uniq // valK.\nQed."
}
{
  "statement": "Lemma cfun_sum_dconstt (phi : 'CF(G)) :\n    phi \\in 'Z[irr G] ->\n  phi = \\sum_(i in dirr_constt phi) '[phi, dchi i] *: dchi i.\n",
  "proof": "Proof.\nmove=> PiZ; rewrite [LHS]cfun_sum_constt.\nrewrite (reindex (to_dirr phi))=> [/= |]; last first.\n  by exists (@of_irr _)=> //; apply: of_irrK .\nby apply: eq_big => i; rewrite ?irr_constt_to_dirr // cfdot_todirrE.\nQed."
}
{
  "statement": "Lemma char_abelianP :\n  reflect (forall i : Iirr G, 'chi_i \\is a linear_char) (abelian G).\n",
  "proof": "Proof.\napply: (iffP idP) => [cGG i | CF_G].\n  rewrite qualifE/= irr_char /= irr1_degree.\n  by rewrite irr_degree_abelian //; last apply: groupC.\nrewrite card_classes_abelian -NirrE -eqC_nat -irr_sum_square //.\nrewrite -{1}[Nirr G]card_ord -sumr_const; apply/eqP/eq_bigr=> i _.\nby rewrite lin_char1 ?expr1n ?CF_G.\nQed."
}
{
  "statement": "Lemma mulmx1_min m n (A : 'M[R]_(m, n)) B : A *m B = 1%:M -> m <= n.\n",
  "proof": "Proof.\nmove=> AB1; rewrite leqNgt; apply/negP=> /subnKC; rewrite addSnnS.\nmove: (_ - _)%N => m' def_m; move: AB1; rewrite -{m}def_m in A B *.\nrewrite -(vsubmxK A) -(hsubmxK B) mul_col_row scalar_mx_block.\ncase/eq_block_mx=> /mulmx1C BlAu1 AuBr0 _ => /eqP/idPn[].\nby rewrite -[_ B]mul1mx -BlAu1 -mulmxA AuBr0 !mulmx0 eq_sym oner_neq0.\nQed."
}
{
  "statement": "Lemma cardU1 x A : #|[predU1 x & A]| = (x \\notin A) + #|A|.\n",
  "proof": "Proof.\ncase Ax: (x \\in A).\n  by apply: eq_card => y /[1!inE]/=; case: eqP => // ->.\nrewrite /= -(card1 x) -cardUI addnC.\nrewrite [#|predI _ _|]eq_card0 => [|y /=]; first exact: eq_card.\nby rewrite !inE; case: eqP => // ->.\nQed."
}
{
  "statement": "Lemma Frobenius_subr G K H H1 :\n    H1 :!=: 1 -> H1 \\subset H -> [Frobenius G = K ><| H] ->\n  [Frobenius K <*> H1 = K ><| H1].\n",
  "proof": "Proof.\nmove=> ntH1 sH1H frobG; have [defG ntK _ _ _] := Frobenius_context frobG.\napply/Frobenius_semiregularP=> //.\n  have [_ _ /(subset_trans sH1H) nH1K tiHK] := sdprodP defG.\n  by rewrite sdprodEY //; apply/trivgP; rewrite -tiHK setIS.\nby apply: sub_in1 (Frobenius_reg_ker frobG); apply/subsetP/setSD.\nQed."
}
{
  "statement": "Lemma diagonalizableP n' (n := n'.+1) (f : 'M[F]_n) :\n  diagonalizable f <->\n  exists2 rs, uniq rs & mxminpoly f %| \\prod_(x <- rs) ('X - x%:P).\n",
  "proof": "Proof.\nsplit=> [[P Punit /similar_diagPex[d /(similarLR Punit)->]]|].\n  rewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\n  by eexists; [|by []]; rewrite undup_uniq.\nmove=> [rs rsU rsP]; apply: diagonalizablePeigen.2.\nexists rs => //.\nrewrite (big_nth 0) big_mkord (eq_bigr _ (fun _ _ => eigenspace_poly _ _)).\napply: (eqmx_trans (eqmx_sym (kermxpoly_prod _ _)) (kermxpoly_min _)).\n  by move=> i j _ _; rewrite coprimep_XsubC root_XsubC nth_uniq.\nby rewrite (big_nth 0) big_mkord in rsP.\nQed."
}
{
  "statement": "Lemma rcent_group_set : group_set rcent.\n",
  "proof": "Proof.\napply/group_setP; rewrite inE group1 repr_mx1 mulmx1 mul1mx; split=> //= x y.\ncase/setIdP=> Gx; move/eqP=> cfx; case/setIdP=> Gy; move/eqP=> cfy.\nby rewrite inE repr_mxM ?groupM //= -mulmxA -cfy !mulmxA cfx.\nQed."
}
{
  "statement": "Lemma mul_pid_mx m n p q r :\n  (pid_mx q : 'M_(m, n)) *m (pid_mx r : 'M_(n, p)) = pid_mx (minn n (minn q r)).\n",
  "proof": "Proof.\napply/matrixP=> i k; rewrite !mxE !leq_min.\nhave [le_n_i | lt_i_n] := leqP n i.\n  rewrite andbF big1 // => j _.\n  by rewrite -pid_mx_minh !mxE leq_min ltnNge le_n_i andbF mul0r.\nrewrite (bigD1 (Ordinal lt_i_n)) //= big1 ?addr0 => [|j].\n  by rewrite !mxE eqxx /= -natrM mulnb andbCA.\nby rewrite -val_eqE /= !mxE eq_sym -natrM => /negPf->.\nQed."
}
{
  "statement": "Lemma addsmxC m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A + B = B + A)%MS.\n",
  "proof": "Proof.\nhave: (A + B == B + A)%MS.\n  by apply/andP; rewrite !addsmx_sub andbC -addsmx_sub andbC -addsmx_sub.\nmove/genmxP; rewrite [@addsmx]unlock -!submx0 !submx0.\nby do 2!case: eqP => [// -> | _]; rewrite ?genmx_id ?addsmx_nop0.\nQed."
}
{
  "statement": "Lemma trivg_comps G s : comps G s -> (G :==: 1) = (s == [::]).\n",
  "proof": "Proof.\ncase/andP=> ls cs; apply/eqP/eqP=> [G1 | s1]; last first.\n  by rewrite s1 /= in ls; apply/eqP.\nby case: s {ls} cs => //= H s /andP[/maxgroupp]; rewrite G1 /proper sub1G andbF.\nQed."
}
{
  "statement": "Lemma cprod_nil A B G : A \\* B = G -> nilpotent G = nilpotent A && nilpotent B.\n",
  "proof": "Proof.\nmove=> defG; case/cprodP: defG (defG) => [[H K -> ->{A B}] defG _] defGc.\napply/idP/andP=> [nilG | [/lcnP[m LmH1] /lcnP[n LnK1]]].\n  by rewrite !(nilpotentS _ nilG) // -defG (mulG_subr, mulG_subl).\napply/lcnP; exists (m + n.+1); apply/trivgP.\ncase/cprodP: (lcn_cprod (m.+1 + n.+1) defGc) => _ <- _.\nby rewrite mulG_subG /= -{1}LmH1 -LnK1 !lcn_sub_leq ?leq_addl ?leq_addr.\nQed."
}
{
  "statement": "Lemma group_set_rot : group_set rot.\n",
  "proof": "Proof.\napply/group_setP; split; first  by rewrite /rot  inE /is_rot mulg1 mul1g.\nmove=> x1 y; rewrite /rot !inE /= /is_rot; move/eqP => hx1; move/eqP => hy.\nby rewrite -mulgA hy !mulgA hx1.\nQed."
}
{
  "statement": "Lemma gal_kAut K E x : (K <= E)%VS -> (x \\in 'Gal(E / K)) = kAut K E x.\n",
  "proof": "Proof.\nmove=> sKE; apply/morphimP/idP=> /= [[g EgE KautEg ->{x}] | KautEx].\n  rewrite genGid !inE kAut1E /= subfield_closed (capv_idPl sKE) in KautEg EgE.\n  by apply: etrans KautEg; apply/(kAut_eq sKE); apply: galK.\nexists (x : 'AEnd(L)); rewrite ?gal_reprK ?gal_AEnd //.\nby rewrite (capv_idPl sKE) mem_gen ?inE.\nQed."
}
{
  "statement": "Lemma orderXgcd a n : #[a ^+ n] = #[a] %/ gcdn #[a] n.\n",
  "proof": "Proof.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  rewrite order_dvdn -expgM -muln_divCA_gcd //.\n  by rewrite expgM expg_order expg1n.\nhave [-> | n_gt0] := posnP n; first by rewrite gcdn0 divnn order_gt0 dvd1n.\nrewrite -(dvdn_pmul2r n_gt0) divn_mulAC ?dvdn_gcdl // dvdn_lcm.\nby rewrite order_dvdn mulnC expgM expg_order eqxx dvdn_mulr.\nQed."
}
{
  "statement": "Lemma mono_sorted_enum d d' (T : finPOrderType d)\n    (T' : porderType d') (f : T -> T') :\n    total (<=%O : rel T) -> {mono f : x y / (x <= y)%O} ->\n  sorted <=%O [seq f x | x <- Order.enum T].\n",
  "proof": "Proof.\nmove=> /sort_sorted ss_sorted lef; wlog [x0 x'0] : / (T * T')%type.\n  by case: (Order.enum T) => // x ? => /(_ (x, f x)).\nrewrite (sorted_pairwise le_trans).\napply/(pairwiseP x'0) => i j; rewrite !inE !size_map -!Order.cardT.\nmove=> ilt jlt ij; rewrite !(nth_map x0) -?Order.cardT// lef.\nby rewrite (sorted_leq_nth le_trans le_refl) ?inE -?Order.cardT// 1?ltnW.\nQed."
}
{
  "statement": "Lemma nElem1P G E :\n  reflect (E \\subset G /\\ exists2 p, prime p & #|E| = p) (E \\in 'E^1(G)).\n",
  "proof": "Proof.\napply: (iffP nElemP) => [[p pE] | [sEG [p p_pr oE]]].\n  have p_pr := pnElem_prime pE; rewrite pnElemE // !inE -andbA in pE.\n  by case/and3P: pE => -> _ /eqP; split; last exists p.\nexists p; rewrite pnElemE // !inE sEG oE eqxx abelemE // -oE exponent_dvdn.\nby rewrite cyclic_abelian // prime_cyclic // oE.\nQed."
}
{
  "statement": "Lemma divpZl c p : (c *: p) %/ d = c *: (p %/ d).\n",
  "proof": "Proof.\nhave [-> | cn0] := eqVneq c 0; first by rewrite !scale0r div0p.\nhave e : (c *: p) = (c *: (p %/ d)) * d + c *: (p %% d).\n  by rewrite -scalerAl -scalerDr -divp_eq.\nsuff s: size (c *: (p %% d)) < size d by case: (edivpP e s) => ->.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\nrewrite size_polyC cn0 addSn add0n /= ltn_modp -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed."
}
{
  "statement": "Lemma modpZl c p : (c *: p) %% d = c *: (p %% d).\n",
  "proof": "Proof.\nhave [-> | cn0] := eqVneq c 0; first by rewrite !scale0r mod0p.\nhave e : (c *: p) = (c *: (p %/ d)) * d + c *: (p %% d).\n  by rewrite -scalerAl -scalerDr -divp_eq.\nsuff s: size (c *: (p %% d)) < size d by case: (edivpP e s) => _ ->.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\nrewrite size_polyC cn0 addSn add0n /= ltn_modp -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed."
}
{
  "statement": "Lemma cfproj_sum_orthogonal P z phi :\n    phi \\in S ->\n  '[\\sum_(xi <- S | P xi) z xi *: nu xi, nu phi]\n    = if P phi then z phi * '[phi] else 0.\n",
  "proof": "Proof.\nmove=> Sphi; have defS := perm_to_rem Sphi.\nrewrite cfdot_suml (perm_big _ defS) big_cons /= cfdotZl Inu ?Z_S //.\nrewrite big1_seq ?addr0 // => xi; rewrite mem_rem_uniq ?inE //.\nby case/and3P=> _ neq_xi Sxi; rewrite cfdotZl Inu ?Z_S // dotSS ?mulr0.\nQed."
}
{
  "statement": "Lemma ker_pprodm : 'ker f = [set x * a^-1 | x in H, a in K & fH x == fK a].\n",
  "proof": "Proof.\napply/setP=> y; rewrite 3!inE {1}norm_joinEr //=.\napply/andP/imset2P=> [[/mulsgP[x a Hx Ka ->{y}]]|[x a Hx]].\n  rewrite pprodmE // => fxa1.\n  by exists x a^-1; rewrite ?invgK // inE groupVr ?morphV // eq_mulgV1 invgK.\ncase/setIdP=> Kx /eqP fx ->{y}.\nby rewrite imset2_f ?pprodmE ?groupV ?morphV // fx mulgV.\nQed."
}
{
  "statement": "Lemma sub_daddsmx : (B1 :&: B2 = 0)%MS -> (A <= B1 + B2)%MS -> sub_daddsmx_spec.\n",
  "proof": "Proof.\nmove=> dxB /sub_addsmxP[u defA].\nexists (u.1 *m B1) (u.2 *m B2); rewrite ?submxMl // => C1 C2 sCB1 sCB2.\nmove/(canLR (addrK _)) => defC1.\nsuffices: (C2 - u.2 *m B2 <= B1 :&: B2)%MS.\n  by rewrite dxB submx0 subr_eq0 -defC1 defA; move/eqP->; rewrite addrK.\nrewrite sub_capmx -opprB -{1}(canLR (addKr _) defA) -addrA defC1.\nby rewrite !(eqmx_opp, addmx_sub) ?submxMl.\nQed."
}
{
  "statement": "Lemma cfclass_Ind phi psi :\n  H <| G -> psi \\in (phi ^: G)%CF -> 'Ind[G] phi = 'Ind[G] psi.\n",
  "proof": "Proof.\nmove=> nsHG /cfclassP[y Gy ->]; have [sHG /subsetP nHG] := andP nsHG.\napply/cfun_inP=> x Hx; rewrite !cfIndE //; congr (_ * _).\nrewrite (reindex_acts 'R _ (groupVr Gy)) ?astabsR //=.\nby apply: eq_bigr => z Gz; rewrite conjgM cfConjgE ?nHG.\nQed."
}
{
  "statement": "Lemma prod_repr_lin n2 (rG1 : reprG 1) (rG2 : reprG n2) :\n  {in G, forall x, let cast_n2 := esym (mul1n n2) in\n      prod_repr rG1 rG2 x = castmx (cast_n2, cast_n2) (rG1 x 0 0 *: rG2 x)}.\n",
  "proof": "Proof.\nmove=> x Gx /=; set cast_n2 := esym _; rewrite /prod_repr /= !mxE !lshift0.\napply/matrixP=> i j; rewrite castmxE /=.\ndo 2![rewrite mxE; case: splitP => [? ? | []//]].\nby congr ((_ *: rG2 x) _ _); apply: val_inj.\nQed."
}
{
  "statement": "Lemma map_sort : {morph map f : s1 / sort leT' s1 >-> sort leT s1}.\n",
  "proof": "Proof.\nmove=> s; rewrite !sortE -[[::] in RHS]/(map (map f) [::]).\nelim: s [::] => /= [|x s ihs] ss; rewrite -/(map f [::]) -/(map f [:: _]);\n  first by elim: ss [::] => //= x ss ihss ?; rewrite ihss map_merge.\nrewrite ihs -/(map f [:: x]); congr sort_rec1.\nby elim: ss [:: x] => {x s ihs} [|[|x s] ss ihss] //= ?; rewrite ihss map_merge.\nQed."
}
{
  "statement": "Lemma regular_module_ideal m (M : 'M_(m, nG)) :\n  mxmodule aG M = right_mx_ideal R_G (M *m R_G).\n",
  "proof": "Proof.\napply/idP/idP=> modM.\n  apply/mulsmx_subP=> A B; rewrite !mem_sub_gring => /andP[R_A M_A] R_B.\n  by rewrite envelop_mxM // gring_row_mul (mxmodule_envelop modM).\napply/mxmoduleP=> x Gx; apply/row_subP=> i; rewrite row_mul -mem_gring_mx.\nrewrite gring_mxJ // (mulsmx_subP modM) ?envelop_mx_id //.\nby rewrite mem_gring_mx row_sub.\nQed."
}
{
  "statement": "Lemma p_rank_gt0 p H : ('r_p(H) > 0) = (p \\in \\pi(H)).\n",
  "proof": "Proof.\nrewrite mem_primes cardG_gt0 /=; apply/p_rank_geP/andP=> [[E] | [p_pr]].\n  case/pnElemP=> sEG _; rewrite lognE; case: and3P => // [[-> _ pE] _].\n  by rewrite (dvdn_trans _ (cardSg sEG)).\ncase/Cauchy=> // x Hx ox; exists <[x]>%G; rewrite 2!inE [#|_|]ox cycle_subG.\nby rewrite Hx (pfactorK 1) ?abelemE // cycle_abelian -ox exponent_dvdn.\nQed."
}
{
  "statement": "Lemma normalField_isom :\n  {f : {morphism ('Gal(E / K) / 'Gal(E / M)) >-> gal_of M} |\n     isom ('Gal(E / K) / 'Gal (E / M)) 'Gal(M / K) f\n   & (forall A, f @* (A / 'Gal(E / M)) = normalField_cast @* A)\n  /\\ {in 'Gal(E / K) & M, forall x, f (coset 'Gal (E / M) x) =1 x} }%g.\n",
  "proof": "Proof.\nhave:= first_isom normalField_cast_morphism; rewrite normalField_ker.\ncase=> f injf Df; exists f; first by apply/isomP; rewrite Df normalField_img.\nsplit=> [//|x a galEx /normalField_cast_eq<- //]; congr ((_ : gal_of M) a).\napply: set1_inj; rewrite -!morphim_set1 ?mem_quotient ?Df //.\nby rewrite (subsetP (normal_norm normalField_normal)).\nQed."
}
{
  "statement": "Lemma comm_prodG I r (G : I -> {group gT}) (P : {pred I}) :\n  {in P &, forall i j, commute (G i) (G j)} ->\n  (\\prod_(i <- r | P i) G i)%G = \\prod_(i <- r | P i) G i :> {set gT}.\n",
  "proof": "Proof.\nelim: r => /= [|i {}r IHr]; rewrite !(big_nil, big_cons)//=.\ncase: ifP => //= Pi Gcomm; rewrite comm_joingE {}IHr// /commute.\nelim: r => [|j r IHr]; first by rewrite big_nil mulg1 mul1g.\nby rewrite big_cons; case: ifP => //= Pj; rewrite mulgA Gcomm// -!mulgA IHr.\nQed."
}
{
  "statement": "Lemma dim_cfun_on_abelian A : abelian G -> A \\subset G -> \\dim 'CF(G, A) = #|A|.\n",
  "proof": "Proof.\nmove/abelian_classP=> cGG sAG; rewrite -(card_imset _ set1_inj) dim_cfun_on.\napply/eq_card=> xG; rewrite !inE.\napply/andP/imsetP=> [[/imsetP[x Gx ->] Ax] | [x Ax ->]] {xG}.\n  by rewrite cGG ?sub1set // in Ax *; exists x.\nby rewrite -{1}(cGG x) ?mem_classes ?(subsetP sAG) ?sub1set.\nQed."
}
{
  "statement": "Lemma vchar_norm1P phi :\n    phi \\in 'Z[irr G] -> '[phi] = 1 ->\n  exists b : bool, exists i : Iirr G, phi = (-1) ^+ b *: 'chi_i.\n",
  "proof": "Proof.\nmove=> Zphi phiN1.\nhave: orthonormal phi by rewrite /orthonormal/= phiN1 eqxx.\ncase/vchar_orthonormalP=> [xi /predU1P[->|] // | I [b def_phi]].\nhave: phi \\in (phi : seq _) := mem_head _ _.\nby rewrite (perm_mem def_phi) => /mapP[i _ ->]; exists (b i), i.\nQed."
}
{
  "statement": "Lemma p_abelem_split1 rT p (A : {group rT}) x :\n     p.-abelem A -> x \\in A ->\n  exists B : {group rT}, [/\\ B \\subset A, #|B| = #|A| %/ #[x] & <[x]> \\x B = A].\n",
  "proof": "Proof.\nmove=> abelA Ax; have sxA: <[x]> \\subset A by rewrite cycle_subG.\nhave [B defA] := abelem_split_dprod abelA sxA.\nhave [_ defxB _ ti_xB] := dprodP defA.\nhave sBA: B \\subset A by rewrite -defxB mulG_subr.\nby exists B; split; rewrite // -defxB (TI_cardMg ti_xB) mulKn ?order_gt0.\nQed."
}
{
  "statement": "Lemma closed_nonrootP p : reflect (exists x, ~~ root p x) (p != 0).\n",
  "proof": "Proof.\napply: (iffP idP) => [nz_p | [x]]; last first.\n  by apply: contraNneq => ->; apply: root0.\nhave [[x /rootP p1x0]|] := altP (closed_rootP (p - 1)).\n  by exists x; rewrite -[p](subrK 1) /root hornerD p1x0 add0r hornerC oner_eq0.\nrewrite negbK => /size_poly1P[c _ /(canRL (subrK 1)) Dp].\nby exists 0; rewrite Dp -raddfD polyC_eq0 rootC in nz_p *.\nQed."
}
{
  "statement": "Lemma cfConjgMorph (phi : 'CF(f @* H)) y :\n  y \\in D -> y \\in 'N(H) -> (cfMorph phi ^ y)%CF = cfMorph (phi ^ f y).\n",
  "proof": "Proof.\nmove=> Dy nHy; have [sHD | not_sHD] := boolP (H \\subset D); last first.\n  by rewrite !cfMorphEout // rmorph_alg cfConjg1.\napply/cfun_inP=> x Gx; rewrite !(cfConjgE, cfMorphE) ?memJ_norm ?groupV //.\n  by rewrite morphJ ?morphV ?groupV // (subsetP sHD).\nby rewrite (subsetP (morphim_norm _ _)) ?mem_morphim.\nQed."
}
{
  "statement": "Lemma count_memE x (t : syntax) :\n  count_mem x t = nat_of_bin (pos N0 (content t) x).\n",
  "proof": "Proof.\nrewrite /content; set loop := (X in X Empty); rewrite -/loop.\nrewrite -[LHS]addn0.\nhave <- : nat_of_bin (pos N0 Empty x) = 0 :> nat by elim: x.\nelim: t Empty => [n|s IHs s' IHs'] e //=; last first.\n  by rewrite serial_Op count_cat -addnA IHs' IHs.\nrewrite ?addn0 set_pos_trecE pos_set_pos; case: (altP eqP) => [->|] //=.\nby rewrite Pos.nat_of_succ_bin.\nQed."
}
{
  "statement": "Lemma eq_in_allpairs_dep f1 f2 s t :\n    {in s, forall x, {in t x, f1 x =1 f2 x}} <->\n  [seq f1 x y : R | x <- s, y <- t x] = [seq f2 x y | x <- s, y <- t x].\n",
  "proof": "Proof.\nsplit=> [eq_f | eq_fst x s_x].\n  by congr flatten; apply/eq_in_map=> x s_x; apply/eq_in_map/eq_f.\napply/eq_in_map; apply/eq_in_map: x s_x; apply/eq_from_flatten_shape => //.\nby rewrite /shape -!map_comp; apply/eq_map=> x /=; rewrite !size_map.\nQed."
}
{
  "statement": "Lemma trigmx_ind (P : forall m n, 'M_(m, n) -> Type) :\n  (forall m, P m 0 0) ->\n  (forall n, P 0 n 0) ->\n  (forall m n x c A, is_trig_mx A ->\n    P m n A -> P (1 + m)%N (1 + n)%N (block_mx x 0 c A)) ->\n  forall m n A, is_trig_mx A -> P m n A.\n",
  "proof": "Proof.\nmove=> P0l P0r PS m n A; elim: A => {m n} [m|n|m n xx r c] A PA;\n  do ?by rewrite (flatmx0, thinmx0); by [apply: P0l|apply: P0r].\nby rewrite is_trig_block_mx => // /and3P[/eqP-> _ Atrig]; apply: PS (PA _).\nQed."
}
{
  "statement": "Lemma trajectP x n y :\n  reflect (exists2 i, i < n & y = iter i f x) (y \\in traject f x n).\n",
  "proof": "Proof.\nelim: n x => [|n IHn] x /=; first by right; case.\nrewrite inE; have [-> | /= neq_xy] := eqP; first by left; exists 0.\napply: {IHn}(iffP (IHn _)) => [[i] | [[|i]]] // lt_i_n ->.\n  by exists i.+1; rewrite ?iterSr.\nby exists i; rewrite ?iterSr.\nQed."
}
{
  "statement": "Lemma cfAutInd (psi : 'CF(H)) : ('Ind[G] psi)^u = 'Ind psi^u.\n",
  "proof": "Proof.\nhave [sHG | not_sHG] := boolP (H \\subset G).\n  apply/cfunP=> x; rewrite !(cfunE, cfIndE) // rmorphM /= fmorphV rmorph_nat.\n  by congr (_ * _); rewrite rmorph_sum; apply: eq_bigr => y; rewrite !cfunE.\nrewrite !cfIndEout // linearZ /= cfAut_cfuni rmorphM rmorph_nat /=.\nrewrite -cfdot_cfAut ?rmorph1 // => _ /imageP[x Hx ->].\nby rewrite cfun1E Hx !rmorph1.\nQed."
}
{
  "statement": "Lemma perm_in_inj : injective (fun x => if x \\in A then f x else x).\n",
  "proof": "Proof.\nmove=> x y /=; wlog Ay: x y / y \\in A.\n  by move=> IH eqfxy; case: ifP (eqfxy); [symmetry | case: ifP => //]; auto.\nrewrite Ay; case: ifP => [Ax | nAx def_x]; first exact: injf.\nby case/negP: nAx; rewrite def_x (subsetP sBf) ?imset_f.\nQed."
}
{
  "statement": "Lemma eqperm_map : forall p1 p2 : col_squares,\n  (p1 == p2) = all (fun s => p1 s == p2 s) [:: c0; c1; c2; c3].\n",
  "proof": "Proof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/ffunP=> x.\nby apply/eqP; apply Ep12; case: x; do 4!case=> //.\nQed."
}
{
  "statement": "Lemma Mho_p_cycle p x : p.-elt x -> 'Mho^n(<[x]>) = <[x ^+ (p ^ n)]>.\n",
  "proof": "Proof.\nmove=> p_x.\napply/eqP; rewrite (MhoE p_x) eqEsubset cycle_subG mem_gen; last first.\n  by apply: imset_f; apply: cycle_id.\nrewrite gen_subG andbT; apply/subsetP=> _ /imsetP[_ /cycleP[k ->] ->].\nby rewrite -expgM mulnC expgM mem_cycle.\nQed."
}
{
  "statement": "Lemma infix_rev s1 s2 : infix (rev s1) (rev s2) = infix s1 s2.\n",
  "proof": "Proof.\ngen have sr : s1 s2 / infix s1 s2 -> infix (rev s1) (rev s2); last first.\n  by apply/idP/idP => /sr; rewrite ?revK.\nby move=> /infixP[s [p ->]]; rewrite !rev_cat -catA.\nQed."
}
{
  "statement": "Lemma char_trans H G K : K \\char H -> H \\char G -> K \\char G.\n",
  "proof": "Proof.\ncase/charP=> sKH chKH; case/charP=> sHG chHG.\napply/charP; split=> [|f injf Gf]; first exact: subset_trans sHG.\nrewrite -{1}(setIidPr sKH) -(morphim_restrm sHG) chKH //.\n  by rewrite ker_restrm; move/trivgP: injf => ->; apply: subsetIr.\nby rewrite morphim_restrm setIid chHG.\nQed."
}
{
  "statement": "Lemma mupMr x q1 q2 : ~~ root q1 x -> mup x (q1 * q2) = mup x q2.\n",
  "proof": "Proof.\nmove=> q1Nx; have q1N0 : q1 != 0 by apply: contraNneq q1Nx => ->; rewrite root0.\nhave [->|q2N0] := eqVneq q2 0; first by rewrite mulr0.\napply/esym/eqP; rewrite eqn_leq mup_geq ?mulf_neq0// dvdp_mull -?mup_geq//=.\nrewrite mup_leq ?mulf_neq0// Gauss_dvdpr -?mup_ltn//.\nby rewrite coprimep_expl// coprimep_sym coprimep_XsubC.\nQed."
}
{
  "statement": "Lemma mxrank_mul_ker m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  (\\rank (A *m B) + \\rank (A :&: kermx B))%N = \\rank A.\n",
  "proof": "Proof.\napply/eqP; set K := kermx B; set C := (A :&: K)%MS.\nrewrite -(eqmxMr B (eq_row_base A)); set K' := _ *m B.\nrewrite -{2}(subnKC (rank_leq_row K')) -mxrank_ker eqn_add2l.\nrewrite -(mxrankMfree _ (row_base_free A)) mxrank_leqif_sup.\n  by rewrite sub_capmx -(eq_row_base A) submxMl sub_kermx -mulmxA mulmx_ker/=.\nhave /submxP[C' defC]: (C <= row_base A)%MS by rewrite eq_row_base capmxSl.\nby rewrite defC submxMr // sub_kermx mulmxA -defC -sub_kermx capmxSr.\nQed."
}
{
  "statement": "Lemma dvdp_comp_poly r p q : (p %| q) -> (p \\Po r) %| (q \\Po r).\n",
  "proof": "Proof.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite comp_poly0 !dvd0p; move/eqP->; rewrite comp_poly0.\nrewrite dvdp_eq; set c := _ ^+ _; set s := _ %/ _; move/eqP=> Hq.\napply: (@eq_dvdp c (s \\Po r)); first by rewrite expf_neq0 // lead_coef_eq0.\nby rewrite -comp_polyZ Hq comp_polyM.\nQed."
}
{
  "statement": "Lemma TI_center_nil G H : nilpotent G -> H <| G -> H :&: 'Z(G) = 1 -> H :=: 1.\n",
  "proof": "Proof.\nmove=> nilG /andP[sHG nHG] tiHZ.\nrewrite -{1}(setIidPl sHG); have{nilG} /ucnP[n <-] := nilG.\nelim: n => [|n IHn]; apply/trivgP; rewrite ?subsetIr // -tiHZ.\nrewrite [H :&: 'Z(G)]setIA subsetI setIS ?ucn_sub //= (sameP commG1P trivgP).\nrewrite -commg_subr commGC in nHG.\nrewrite -IHn subsetI (subset_trans _ nHG) ?commSg ?subsetIl //=.\nby rewrite (subset_trans _ (ucn_comm n G)) ?commSg ?subsetIr.\nQed."
}
{
  "statement": "Lemma mem_vspaceOver V : vspaceOver V =i (F * V)%VS.\n",
  "proof": "Proof.\nmove=> y; apply/idP/idP; last rewrite unlock; move/coord_span->.\n  rewrite (@memv_suml F0 L) // => i _.\n  by rewrite memv_mul ?subvsP // vbasis_mem ?memt_nth.\nrewrite memv_suml // => ij _; rewrite -tnth_nth; set x := tnth _ ij.\nhave/allpairsP[[u z] /= [Fu Vz {x}->]]: x \\in _ := mem_tnth ij _.\nby rewrite scalerAl (memvZ (Subvs _)) ?memvZ ?memv_span //= vbasis_mem.\nQed."
}
{
  "statement": "Lemma isog_xcprod (rT : finGroupType) (GH GK G : {group rT}) :\n    Aut_in (Aut H) 'Z(H) \\isog Aut 'Z(H) ->\n    GH \\isog H -> GK \\isog K -> GH \\* GK = G -> 'Z(GH) = 'Z(GK) ->\n  G \\isog [set: xcprod].\n",
  "proof": "Proof.\nmove=> AutZinH isoGH isoGK defG eqZGHK; have [_ _ cGHK] := cprodP defG.\nhave [|gz isoZ] := xcprodP.\n  have [[fH injfH <-] [fK injfK <-]] := (isogP isoGH, isogP isoGK).\n  rewrite -!injm_center -?(isog_transl _ (sub_isog _ _)) ?center_sub //=.\n  by rewrite eqZGHK sub_isog ?center_sub.\nrewrite (isog_cprod_by _ defG) //.\nby apply/eqP; rewrite eqEsubset setIS // subsetI {2}eqZGHK !center_sub.\nQed."
}
{
  "statement": "Lemma pprodmE x a : x \\in H -> a \\in K -> f (x * a) = fH x * fK a.\n",
  "proof": "Proof.\nmove=> Hx Ka; have: x * a \\in H * K by rewrite mem_mulg.\nrewrite -remgrP inE /f rcoset_sym mem_rcoset /divgr -mulgA groupMl //.\ncase/andP; move: (remgr H K _) => b Hab Kb; rewrite morphM // -mulgA.\nhave Kab: a * b^-1 \\in K by rewrite groupM ?groupV.\nby congr (_ * _); rewrite eqfHK 1?inE ?Hab // -morphM // mulgKV.\nQed."
}
{
  "statement": "Lemma card_lin_irr G :\n  #|[pred i | 'chi[G]_i \\is a linear_char]| = #|G : G^`(1)%g|.\n",
  "proof": "Proof.\nhave nsG'G := der_normal 1 G; rewrite (eq_card (@lin_irr_der1 G)).\nrewrite -(on_card_preimset (mod_Iirr_bij nsG'G)).\nrewrite -card_quotient ?normal_norm //.\nmove: (der_abelian 0 G); rewrite card_classes_abelian; move/eqP<-.\nrewrite -NirrE -[RHS]card_ord.\nby apply: eq_card => i; rewrite !inE mod_IirrE ?cfker_mod.\n\nQed."
}
{
  "statement": "Lemma sub_morphim_pre A R :\n  A \\subset D -> (f @* A \\subset R) = (A \\subset f @*^-1 R).\n",
  "proof": "Proof.\nmove=> sAD; rewrite -morphpreSK (morphimS, morphimK) //.\napply/idP/idP; first by apply: subset_trans; apply: mulG_subr.\nby move/(mulgS ('ker f)); rewrite -morphpreMl ?(sub1G, mul1g).\nQed."
}
{
  "statement": "Lemma eqp_monic : {in monic &, forall p q, (p %= q) = (p == q)}.\n",
  "proof": "Proof.\nmove=> p q monic_p monic_q; apply/idP/eqP=> [|-> //].\ncase/eqpP=> [[a b] /= /andP[a_neq0 _] eq_pq].\napply: (@mulfI _ a%:P); first by rewrite polyC_eq0.\nrewrite !mul_polyC eq_pq; congr (_ *: q); apply: (mulIf (oner_neq0 _)).\nby rewrite -[in LHS](monicP monic_q) -(monicP monic_p) -!lead_coefZ eq_pq.\nQed."
}
{
  "statement": "Lemma map_regular_subseries U i (modU : mx_subseries (regular_repr aF G) U)\n   (modUf : mx_subseries (regular_repr rF G) [seq M^f | M <- U]) :\n  mx_rsim (map_repr f (subseries_repr i modU)) (subseries_repr i modUf).\n",
  "proof": "Proof.\nset mf := map _ in modUf *; rewrite /subseries_repr.\ndo 2!move: (mx_subseries_module' _ _) (mx_subseries_module _ _).\nhave mf_i V: nth 0^f (mf V) i = (V`_i)^f.\n  case: (ltnP i (size V)) => [ltiV | leVi]; first exact: nth_map.\n  by rewrite !nth_default ?size_map.\nrewrite -(map_mx0 f) mf_i (mf_i (0 :: U)) => modUi'f modUif modUi' modUi.\nby apply: map_section_repr; apply: map_regular_repr.\nQed."
}
{
  "statement": "Lemma map_subset {T T' : finType} (s1 s2 : seq T) (f : T -> T') :\n  s1 \\subset s2 -> [seq f x | x <- s1 ] \\subset [seq f x | x <- s2].\n",
  "proof": "Proof.\nmove=> s1s2; apply/subsetP => _ /mapP[y] /[swap] -> ys1.\nby apply/mapP; exists y => //; move/subsetP : s1s2; exact.\nQed."
}
{
  "statement": "Lemma coprimepP p q :\n reflect (forall d, d %| p -> d %| q -> d %= 1) (coprimep p q).\n",
  "proof": "Proof.\nrewrite /coprimep; apply: (iffP idP) => [/eqP hs d dvddp dvddq | h].\n  have/dvdp_eqp1: d %| gcdp p q by rewrite dvdp_gcd dvddp dvddq.\n  by rewrite -size_poly_eq1 hs; exact.\nby rewrite size_poly_eq1; case/andP: (dvdp_gcdlr p q); apply: h.\nQed."
}
{
  "statement": "Lemma diagonalizableP n' (n := n'.+1) (A : 'M[F]_n) :\n  diagonalizable A <->\n  exists2 rs, uniq rs & mxminpoly A %| \\prod_(x <- rs) ('X - x%:P).\n",
  "proof": "Proof.\nsplit=> [[P Punit /diagonalizable_forPex[d /(simmxLR Punit)->]]|].\n  rewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\n  by eexists; [|by []]; rewrite undup_uniq.\nmove=> + /ltac:(apply/diagonalizablePeigen) => -[rs rsu rsP]; exists rs => //.\nrewrite (big_nth 0) [X in (X :=: _)%MS](big_nth 0) !big_mkord in rsP *.\nrewrite (eq_bigr _ (fun _ _ => eigenspace_poly _ _)).\napply: (eqmx_trans (eqmx_sym (kermxpoly_prod _ _)) (kermxpoly_min _)) => //.\nby move=> i j _ _; rewrite coprimep_XsubC root_XsubC nth_uniq.\nQed."
}
{
  "statement": "Lemma big_nat_widen m n1 n2 (P : pred nat) F :\n     n1 <= n2 ->\n  \\big[op/idx]_(m <= i < n1 | P i) F i\n      = \\big[op/idx]_(m <= i < n2 | P i && (i < n1)) F i.\n",
  "proof": "Proof.\nmove=> len12; symmetry; rewrite -big_filter filter_predI big_filter.\nhave [ltn_trans eq_by_mem] := (ltn_trans, irr_sorted_eq ltn_trans ltnn).\ncongr bigop; apply: eq_by_mem; rewrite ?sorted_filter ?iota_ltn_sorted // => i.\nrewrite mem_filter !mem_index_iota andbCA andbA andb_idr => // /andP[_].\nby move/leq_trans->.\nQed."
}
{
  "statement": "Lemma eqperm_map2 : forall p1 p2 : col_cubes,\n  (p1 == p2) = all (fun s => p1 s == p2 s) [:: F0; F1; F2; F3; F4; F5].\n",
  "proof": "Proof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/ffunP=> x.\nby apply/eqP; apply Ep12; case: x; do 6?case.\nQed."
}
{
  "statement": "Lemma unitrM_comm x y :\n  comm x y -> (x * y \\is a unit) = (x \\is a unit) && (y \\is a unit).\n",
  "proof": "Proof.\nmove=> cxy; apply/idP/andP=> [Uxy | [Ux Uy]]; last by rewrite unitrMl.\nsuffices Ux: x \\in unit by rewrite unitrMr in Uxy.\napply/unitrP; case/unitrP: Uxy => z [zxy xyz]; exists (y * z).\nrewrite mulrA xyz -{1}[y]mul1r -{1}zxy cxy -!mulrA (mulrA x) (mulrA _ z) xyz.\nby rewrite mul1r -cxy.\nQed."
}
{
  "statement": "Lemma orthogonal_span S phi :\n    pairwise_orthogonal S -> phi \\in <<S>>%VS ->\n  {z | z = fun xi => '[phi, xi] / '[xi] & phi = \\sum_(xi <- S) z xi *: xi}.\n",
  "proof": "Proof.\nmove=> oSS /free_span[|c -> _]; first exact: orthogonal_free.\nset z := fun _ => _ : algC; exists z => //; apply: eq_big_seq => u Su.\nrewrite /z cfproj_sum_orthogonal // mulfK // cfnorm_eq0.\nby rewrite (memPn _ u Su); case/andP: oSS.\nQed."
}
{
  "statement": "Lemma cfConjgIsom phi y :\n  y \\in G -> y \\in 'N(H) -> (cfIsom isoH phi ^ g y)%CF = cfIsom isoH (phi ^ y).\n",
  "proof": "Proof.\nmove=> Gy nHy; have [_ defS] := isomP isoH.\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\napply/cfun_inP=> gx; rewrite -{1}defS => /morphimP[x Gx Hx ->] {gx}.\nrewrite cfConjgE; last by rewrite -defS inE -morphimJ ?(normP nHy).\nby rewrite -morphV -?morphJ -?eq_hg ?cfIsomE ?cfConjgE ?memJ_norm ?groupV.\nQed."
}
{
  "statement": "Lemma modp_mull p q : (p * q) %% q = 0.\n",
  "proof": "Proof.\nhave [-> | nq0] := eqVneq q 0; first by rewrite modp0 mulr0.\nhave rlcq : GRing.rreg (lead_coef q) by apply/rregP; rewrite lead_coef_eq0.\nhave hC : GRing.comm q (lead_coef q)%:P by red; rewrite mulrC.\nrewrite modpE; case: ifP => ulcq; rewrite RingComRreg.rmodp_mull //.\nexact: scaler0.\nQed."
}
{
  "statement": "Lemma separable_nz_der : separable_element K x = ((minPoly K x)^`() != 0).\n",
  "proof": "Proof.\nrewrite /separable_element unlock.\napply/idP/idP=> [|nzPx'].\n  by apply: contraTneq => ->; rewrite coprimep0 -size_poly_eq1 size_minPoly.\nhave gcdK : gcdp (minPoly K x) (minPoly K x)^`() \\in polyOver K.\n  by rewrite gcdp_polyOver ?polyOver_deriv // minPolyOver.\nrewrite -gcdp_eqp1 -size_poly_eq1 -dvdp1.\nhave /orP[/andP[_]|/andP[]//] := minPoly_irr gcdK (dvdp_gcdl _ _).\nrewrite dvdp_gcd dvdpp /= => /(dvdp_leq nzPx')/leq_trans/(_ (size_poly _ _)).\nby rewrite size_minPoly ltnn.\nQed."
}
{
  "statement": "Lemma rstab_quo m (U : 'M_(m, n)) : rstab rGH U = (rstab rG U / H)%g.\n",
  "proof": "Proof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|]; case/morphimP=> x Nx Gx ->{Hx}.\n  by rewrite quo_repr_coset // => nUx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx nUx; rewrite quo_repr_coset ?mem_morphim.\nQed."
}
{
  "statement": "Lemma OhmPredP (x : gT) :\n  reflect (exists2 p, prime p & x ^+ (p ^ n) = 1) (x ^+ (pdiv #[x] ^ n) == 1).\n",
  "proof": "Proof.\nhave [-> | nt_x] := eqVneq x 1.\n  by rewrite expg1n eqxx; left; exists 2; rewrite ?expg1n.\napply: (iffP idP) => [/eqP | [p p_pr /eqP x_pn]].\n  by exists (pdiv #[x]); rewrite ?pdiv_prime ?order_gt1.\nrewrite (@pdiv_p_elt p) //; rewrite -order_dvdn in x_pn.\nby rewrite [p_elt _ _](pnat_dvd x_pn) // pnatX pnat_id.\nQed."
}
{
  "statement": "Lemma qlogp_eq0 (q : qT) : (qlogp q == 0%N) = (q == 0) || (q == 1).\n",
  "proof": "Proof.\ncase: (q =P 0) => [->|/eqP q_neq0]/=; first by rewrite qlogp0.\ncase: (q =P 1) => [->|/eqP q_neq1]/=; first by rewrite qlogp1.\nrewrite /qlogp; case: pickP => [x|/(_ (Ordinal (qlogp_lt q)))] /=.\n  by case: ((x : nat) =P 0%N) => // ->; rewrite expr0 eq_sym (negPf q_neq1).\nby rewrite qlogp_qX // eqxx.\nQed."
}
{
  "statement": "Lemma mx_abs_irrW : mx_absolutely_irreducible -> mx_irreducible.\n",
  "proof": "Proof.\ncase/mx_abs_irrP=> n_gt0 [a_ a_G]; apply/mx_irrP; split=> // U Umod.\ncase/rowV0Pn=> u Uu; rewrite -mxrank_eq0 -lt0n row_leq_rank -sub1mx.\ncase/submxP: Uu => v ->{u} /row_freeP[u' vK]; apply/row_subP=> i.\nrewrite rowE scalar_mxC -{}vK -2![_ *m _]mulmxA; move: {u' i}(u' *m _) => A.\nrewrite mulmx_sub {v}// [A]a_G linear_sum summx_sub //= => x Gx.\nby rewrite -scalemxAr scalemx_sub // (mxmoduleP Umod).\nQed."
}
{
  "statement": "Lemma lcn_cprod n A B G : A \\* B = G -> 'L_n(A) \\* 'L_n(B) = 'L_n(G).\n",
  "proof": "Proof.\ncase: n => // n /cprodP[[H K -> ->{A B}] defG cHK].\nhave sL := subset_trans (lcn_sub _ _); rewrite cprodE ?(centSS _ _ cHK) ?sL //.\nsymmetry; elim: n => // n; rewrite lcnSn => ->; rewrite commMG /=; last first.\n  by apply: subset_trans (commg_normr _ _); rewrite sL // -defG mulG_subr.\nrewrite -!(commGC G) -defG -{1}(centC cHK).\nrewrite !commMG ?normsR ?lcn_norm ?cents_norm // 1?centsC //.\nby rewrite -!(commGC 'L__(_)) -!lcnSn !(commG1P _) ?mul1g ?sL // centsC.\nQed."
}
{
  "statement": "Lemma cycle_subgroup_char a (H : {group gT}) : H \\subset <[a]> -> H \\char <[a]>.\n",
  "proof": "Proof.\nmove=> sHa; apply: lone_subgroup_char => // J sJa isoJH.\nhave dvHa: #|H| %| #[a] by apply: cardSg.\nhave{dvHa} /setP Huniq := esym (cycle_sub_group dvHa).\nmove: (Huniq H) (Huniq J); rewrite !inE /=.\nby rewrite sHa sJa (card_isog isoJH) eqxx => /eqP<- /eqP<-.\nQed."
}
{
  "statement": "Lemma atrans_supgroup G H S :\n    G \\subset H -> [transitive G, on S | to] ->\n  [transitive H, on S | to] = [acts H, on S | to].\n",
  "proof": "Proof.\nmove=> sGH trG; apply/idP/idP=> [|actH]; first exact: atrans_acts.\ncase/imsetP: trG => x Sx defS; apply/imsetP; exists x => //.\nby apply/eqP; rewrite eqEsubset acts_sub_orbit ?Sx // defS imsetS.\nQed."
}
{
  "statement": "Lemma onth_inj s n m : uniq s -> minn m n < size s ->\n  onth s n = onth s m -> n = m.\n",
  "proof": "Proof.\nelim: s m n => [|x s IHs]//= [|m] [|n]//=; rewrite ?minnSS !ltnS.\n- by move=> /andP[+ _] _ /eqP => /onthPn/(_ _)/negPf->.\n- by move=> /andP[+ _] _ /esym /eqP => /onthPn/(_ _)/negPf->.\nby move=> /andP[xNs /IHs]/[apply]/[apply]->.\nQed."
}
{
  "statement": "Lemma afix_mod G S :\n    H \\subset 'C(S | to) -> G \\subset 'N_D(H) ->\n  'Fix_(S | mod_action)(G / H) = 'Fix_(S | to)(G).\n",
  "proof": "Proof.\nmove=> cSH /subsetIP[sGD nHG].\napply/eqP; rewrite eqEsubset !subsetI !subsetIl /= -!astabCin ?quotientS //.\nhave cfixH F: H \\subset 'C(S :&: F | to).\n  by rewrite (subset_trans cSH) // astabS ?subsetIl.\nrewrite andbC astab_mod ?quotientS //=; last by rewrite astabCin ?subsetIr.\nby rewrite -(quotientSGK nHG) //= -astab_mod // astabCin ?quotientS ?subsetIr.\nQed."
}
{
  "statement": "Lemma mask_filter s m : uniq s -> mask m s = [seq i <- s | i \\in mask m s].\n",
  "proof": "Proof.\nelim: m s => [|[] m IH] [|x s /= /andP[/negP xS uS]]; rewrite ?filter_pred0 //.\n  rewrite inE eqxx /=; congr cons; rewrite [LHS]IH//.\n  by apply/eq_in_filter => ? /[1!inE]; case: eqP => [->|].\nby case: ifP => [/mem_mask //|_]; apply: IH.\nQed."
}
{
  "statement": "Lemma abelian_type_abelem p G : p.-abelem G -> abelian_type G = nseq 'r(G) p.\n",
  "proof": "Proof.\nmove=> abelG; rewrite (abelian_type_homocyclic (abelem_homocyclic abelG)).\nhave [-> | ntG] := eqVneq G 1%G; first by rewrite rank1.\ncongr nseq; apply/eqP; rewrite eqn_dvd; have [pG _ ->] := and3P abelG.\nhave [p_pr] := pgroup_pdiv pG ntG; case/Cauchy=> // x Gx <- _.\nexact: dvdn_exponent.\nQed."
}
{
  "statement": "Lemma coprimep_div_gcd p q : (p != 0) || (q != 0) ->\n  coprimep (p %/ (gcdp p q)) (q %/ gcdp p q).\n",
  "proof": "Proof.\nrewrite -negb_and -gcdp_eq0 -gcdp_eqp1 => gpq0.\nrewrite -(@eqp_mul2r (gcdp p q)) // mul1r (eqp_ltrans (mulp_gcdl _ _ _)).\nhave: gcdp p q %| p by rewrite dvdp_gcdl.\nhave: gcdp p q %| q by rewrite dvdp_gcdr.\nrewrite !dvdp_eq => /eqP <- /eqP <-.\nhave lcn0 k : (lead_coef (gcdp p q)) ^+ k != 0.\n  by rewrite expf_neq0 ?lead_coef_eq0.\nby apply: eqp_gcd; rewrite ?eqp_scale.\nQed."
}
{
  "statement": "Lemma injm_cent A : A \\subset D -> f @* 'C(A) = 'C_(f @* D)(f @* A).\n",
  "proof": "Proof.\nmove=> sAD; apply/eqP; rewrite -morphimIdom eqEsubset morphim_subcent.\napply/subsetP=> fx; case/setIP; case/morphimP=> x Dx _ ->{fx} cAfx.\nrewrite mem_morphim // inE Dx -sub1set centsC cent_set1 -injmSK //.\nby rewrite injm_cent1 // subsetI morphimS // -cent_set1 centsC sub1set.\nQed."
}
{
  "statement": "Lemma partn_part pi rho n : {subset pi <= rho} -> n`_rho`_pi = n`_pi.\n",
  "proof": "Proof.\nmove=> pi_sub_rho; have [->|n_gt0] := posnP n; first by rewrite !partn0 partn1.\nrewrite -[in RHS](partnC rho n_gt0) partnM //.\nsuffices: pi^'.-nat n`_rho^' by move/part_p'nat->; rewrite muln1.\nby apply: sub_in_pnat (part_pnat _ _) => q _; apply/contra/pi_sub_rho.\nQed."
}
{
  "statement": "Lemma finField_genPoly : 'X^#|F| - 'X = \\prod_x ('X - x%:P) :> {poly F}.\n",
  "proof": "Proof.\nset n := #|F|; set oppX := - 'X; set pF := LHS.\nhave le_oppX_n: size oppX <= n by rewrite size_polyN size_polyX finNzRing_gt1.\nhave: size pF = (size (enum F)).+1 by rewrite -cardE size_polyDl size_polyXn.\nmove/all_roots_prod_XsubC->; last by rewrite uniq_rootsE enum_uniq.\n  by rewrite big_enum lead_coefDl ?size_polyXn // lead_coefXn scale1r.\nby apply/allP=> x _; rewrite rootE !hornerE expf_card subrr.\nQed."
}
{
  "statement": "Lemma cycle_all2rel (T : Type) (leT : rel T) :\n  transitive leT -> forall s, cycle leT s = all2rel leT s.\n",
  "proof": "Proof.\nmove=> leT_tr; elim=> //= x s IHs.\nrewrite allrel_cons2 -{}IHs // (path_sortedE leT_tr) /= all_rcons -rev_sorted.\nrewrite rev_rcons /= (path_sortedE (rev_trans leT_tr)) all_rev !andbA.\ncase: (boolP (leT x x && _ && _)) => //=.\ncase: s => //= y s /and3P[/and3P[_ xy _] yx sx].\nrewrite rev_sorted rcons_path /= (leT_tr _ _ _ _ xy) ?andbT //.\nby case: (lastP s) sx => //= {}s z; rewrite all_rcons last_rcons => /andP [->].\nQed."
}
{
  "statement": "Lemma kAEnd_norm K E : kAEnd K E \\subset 'N(kAEndf E)%g.\n",
  "proof": "Proof.\napply/subsetP=> x; rewrite -groupV 2!in_set => /andP[_ /eqP ExE].\napply/subsetP=> _ /imsetP[y homEy ->]; rewrite !in_set !kAutfE in homEy *.\napply/kAHomP=> u Eu; have idEy := kAHomP homEy; rewrite -ExE in idEy.\nrewrite !(@lfunE _ _ L) /= (@lfunE _ _ L) /= idEy ?memv_img //.\nby rewrite lker0_lfunVK ?AEnd_lker0.\nQed."
}
{
  "statement": "Lemma astab_norm S : 'N(S | to) \\subset 'N('C(S | to)).\n",
  "proof": "Proof.\napply/subsetP=> a nSa; rewrite inE sub_conjg; apply/subsetP=> b cSb.\nhave [Da Db] := (astabs_dom nSa, astab_dom cSb).\nrewrite mem_conjgV !inE groupJ //; apply/subsetP=> x Sx.\nrewrite inE !actMin ?groupM ?groupV //.\nby rewrite (astab_act cSb) ?actKVin ?astabs_act ?groupV.\nQed."
}
{
  "statement": "Lemma sdprod_recl n G K H K1 :\n    #|G| <= n -> K ><| H = G -> K1 \\proper K -> H \\subset 'N(K1) ->\n  exists G1 : {group gT}, [/\\ #|G1| < n, G1 \\subset G & K1 ><| H = G1].\n",
  "proof": "Proof.\nmove=> leGn; case/sdprodP=> _ defG nKH tiKH ltK1K nK1H.\nhave tiK1H: K1 :&: H = 1 by apply/trivgP; rewrite -tiKH setSI ?proper_sub.\nexists (K1 <*> H)%G; rewrite /= -defG sdprodE // norm_joinEr //.\nrewrite ?mulSg ?proper_sub ?(leq_trans _ leGn) //=.\nby rewrite -defG ?TI_cardMg // ltn_pmul2r ?proper_card.\nQed."
}
{
  "statement": "Lemma sorted_eq_in s1 s2 :\n  {in s1 & &, transitive leT} -> {in s1 &, antisymmetric leT} ->\n  sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2.\n",
  "proof": "Proof.\nmove=> /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_anti + + /[dup] s1s2.\nhave /all_sigP[s1' ->] := allss s1.\nhave /all_sigP[{s1s2}s2 ->] : all [in s1] s2 by rewrite -(perm_all _ s1s2).\nby rewrite !sorted_map => ss1' ss2 /(perm_map_inj val_inj)/(sorted_eq leT_tr)->.\nQed."
}
{
  "statement": "Lemma cfRepr_inj n1 n2 rG1 rG2 :\n  @cfRepr _ G n1 rG1 = @cfRepr _ G n2 rG2 -> mx_rsim rG1 rG2.\n",
  "proof": "Proof.\nmove=> eq_repr12; pose c i : algC := (standard_irr_coef _ (W i))%:R.\nhave [rsim1 rsim2] := (mx_rsim_standard rG1, mx_rsim_standard rG2).\napply: mx_rsim_trans (rsim1) (mx_rsim_sym _).\nsuffices ->: standard_grepr rG1 = standard_grepr rG2 by [].\napply: eq_bigr => Wi _; congr (muln_grepr _ _); apply/eqP; rewrite -eqC_nat.\nrewrite -[Wi]irr_of_socleK -!/(c _ _ _) -!(coord_sum_free (c _ _) _ irr_free).\nrewrite -!eq_sum_nth_irr -!cfRepr_standard.\nby rewrite -(cfRepr_sim rsim1) -(cfRepr_sim rsim2) eq_repr12.\nQed."
}
{
  "statement": "Lemma homgP rT aT (C : {set rT}) (D : {set aT}) : \n  reflect (exists f : {morphism D >-> rT}, f @* D = C) (homg C D).\n",
  "proof": "Proof.\napply: (iffP exists_eq_inP) => [[f fM <-] | [f <-]].\n  by exists (morphm_morphism fM); rewrite /morphim /= setIid.\nexists (finfun f); first by apply/morphicP=> x y Dx Dy; rewrite !ffunE morphM.\nby rewrite /morphim setIid; apply: eq_imset => x; rewrite ffunE.\nQed."
}
{
  "statement": "Lemma acts_quotient (A : {set aT}) (B : {set rT}) :\n   A \\subset 'N_qact_dom(B | to) -> [acts A, on B / H | quotient_action].\n",
  "proof": "Proof.\nmove=> nBA; apply: subset_trans {A}nBA _; apply/subsetP=> a /setIP[dHa nBa].\nrewrite inE dHa inE; apply/subsetP=> _ /morphimP[x nHx Bx ->].\nrewrite inE /= qactE //.\nby rewrite mem_morphim ?(acts_act acts_qact_dom) ?(astabs_act _ nBa).\nQed."
}
{
  "statement": "Lemma ker_cprod_by_is_group : group_set kerHK.\n",
  "proof": "Proof.\napply/group_setP; rewrite inE /= group1 morph1 invg1 /=.\nsplit=> // [[x1 y1] [x2 y2]].\nrewrite inE /= => /andP[Zx1 /eqP->]; have [_ cGx1] := setIP Zx1.\nrewrite inE /= => /andP[Zx2 /eqP->]; have [Gx2 _] := setIP Zx2.\nby rewrite inE /= groupM //= -invMg (centP cGx1) // morphM.\nQed."
}
{
  "statement": "Lemma perm_to_subseq s1 s2 :\n  subseq s1 s2 -> {s3 | perm_eq s2 (s1 ++ s3)}.\n",
  "proof": "Proof.\nelim Ds2: s2 s1 => [|y s2' IHs] [|x s1] //=; try by exists s2; rewrite Ds2.\ncase: eqP => [-> | _] /IHs[s3 perm_s2] {IHs}.\n  by exists s3; rewrite perm_cons.\nby exists (rcons s3 y); rewrite -cat_cons -perm_rcons -!cats1 catA perm_cat2r.\nQed."
}
{
  "statement": "Lemma uniq_size_uniq s1 s2 :\n  uniq s1 -> s1 =i s2 -> uniq s2 = (size s2 == size s1).\n",
  "proof": "Proof.\nmove=> Us1 eqs12; apply/idP/idP=> [Us2 | /eqP eq_sz12].\n  by rewrite eqn_leq !uniq_leq_size // => y; rewrite eqs12.\nby apply: (leq_size_uniq Us1) => [y|]; rewrite (eqs12, eq_sz12).\nQed."
}
{
  "statement": "Lemma cfker_norm phi : G \\subset 'N(cfker phi).\n",
  "proof": "Proof.\napply/subsetP=> z Gz; have phiJz := cfunJ phi _ (groupVr Gz).\nrewrite inE; apply/subsetP=> _ /imsetP[x /setIdP[Gx /forallP-Kx] ->].\nrewrite inE groupJ //; apply/forallP=> y.\nby rewrite -(phiJz y) -phiJz conjMg conjgK Kx.\nQed."
}
{
  "statement": "Lemma extendDerivationP :\n  separable_element K x -> Derivation <<K; x>> (extendDerivation K).\n",
  "proof": "Proof.\nmove=> sep; apply/allrelP=> u v /vbasis_mem Hu /vbasis_mem Hv; apply/eqP.\nrewrite -(Fadjoin_poly_eq Hu) -(Fadjoin_poly_eq Hv) -hornerM.\nrewrite !{1}extendDerivation_horner ?{1}rpredM ?Fadjoin_polyOver //.\nrewrite (Derivation_mul_poly derD) ?Fadjoin_polyOver //.\nrewrite derivM !{1}hornerD !{1}hornerM !{1}mulrDl !{1}mulrDr -!addrA.\ncongr (_ + _); rewrite [Dx K]lock -!{1}mulrA !{1}addrA; congr (_ + _).\nby rewrite addrC; congr (_ * _ + _); rewrite mulrC.\nQed."
}
{
  "statement": "Lemma DnQ_extraspecial n : extraspecial 'D^n*Q.\n",
  "proof": "Proof.\ncase: DnQ_P (DnQ_pgroup n) => gz isoZ pDnQ.\nhave [injDn injQ] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\nhave [n0 | n_gt0] := posnP n.\n  rewrite -im_cpair mulSGid; first exact: injm_extraspecial Q8_extraspecial.\n  apply/setIidPl; rewrite setI_im_cpair -injm_center //=.\n  by congr (_ @* _); rewrite n0 center_ncprod0.\napply: (cprod_extraspecial pDnQ (im_cpair_cprod isoZ) (setI_im_cpair _)).\n  exact: injm_extraspecial (pX1p2n_extraspecial _ _).\nexact: injm_extraspecial Q8_extraspecial.\nQed."
}
{
  "statement": "Lemma intro_class_fun (G : {group gT}) f :\n    {in G &, forall x y, f (x ^ y) = f x} ->\n    (forall x, x \\notin G -> f x = 0) ->\n  is_class_fun G (finfun f).\n",
  "proof": "Proof.\nmove=> fJ Gf; apply/andP; split; last first.\n  by apply/supportP=> x notAf; rewrite ffunE Gf.\napply/'forall_eqfun_inP=> x y Gy; rewrite !ffunE.\nby have [/fJ-> // | notGx] := boolP (x \\in G); rewrite !Gf ?groupJr.\nQed."
}
{
  "statement": "Lemma det_perm n (s : 'S_n) : \\det (perm_mx s) = (-1) ^+ s :> R.\n",
  "proof": "Proof.\nrewrite [\\det _](bigD1 s) //= big1 => [|i _]; last by rewrite /= !mxE eqxx.\nrewrite mulr1 big1 ?addr0 => //= t Dst.\ncase: (pickP (fun i => s i != t i)) => [i ist | Est].\n  by rewrite (bigD1 i) // mulrCA /= !mxE (negPf ist) mul0r.\nby case/eqP: Dst; apply/permP => i; move/eqP: (Est i).\nQed."
}
{
  "statement": "Lemma astabQ H Abar : 'C(Abar |'Q) = coset H @*^-1 'C(Abar).\n",
  "proof": "Proof.\napply/setP=> x; rewrite inE /= dom_qactJ morphpreE in_setI /=.\napply: andb_id2l => Nx; rewrite !inE -sub1set centsC cent_set1.\napply: eq_subset_r => {Abar} Hy; rewrite inE qactJ Nx (sameP eqP conjg_fixP).\nby rewrite (sameP cent1P eqP) (sameP commgP eqP).\nQed."
}
{
  "statement": "Lemma mulsmx_subP m1 m2 m n\n                 (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) (R : 'A_(m, n)) :\n  reflect (forall A1 A2, A1 \\in R1 -> A2 \\in R2 -> A1 *m A2 \\in R)\n          (R1 * R2 <= R)%MS.\n",
  "proof": "Proof.\napply: (iffP memmx_subP) => [sR12R A1 A2 R_A1 R_A2 | sR12R A].\n  by rewrite sR12R ?mem_mulsmx.\ncase/memmx_sumsP=> A_ -> R_A; rewrite linear_sum summx_sub //= => j _.\nrewrite (submx_trans (R_A _)) // genmxE; apply/row_subP=> i.\nby rewrite row_mul mul_rV_lin sR12R ?vec_mxK ?row_sub.\nQed."
}
{
  "statement": "Lemma Aut_group_set : group_set (Aut G).\n",
  "proof": "Proof.\napply/group_setP; split=> [|a b].\n  by rewrite inE perm_on1; apply/morphicP=> ? *; rewrite !permE.\nrewrite !inE => /andP[Ga aM] /andP[Gb bM]; rewrite perm_onM //=.\napply/morphicP=> x y Gx Gy; rewrite !permM (morphicP aM) //.\nby rewrite (morphicP bM) ?perm_closed.\nQed."
}
{
  "statement": "Lemma rowV0P m n (A : 'M_(m, n)) :\n  reflect (forall v : 'rV_n, v <= A -> v = 0)%MS (A == 0).\n",
  "proof": "Proof.\nrewrite -[A == 0]negbK; case: rowV0Pn => IH.\n  by right; case: IH => v svA nzv IH; case/eqP: nzv; apply: IH.\nby left=> v svA; apply/eqP/idPn=> nzv; case: IH; exists v.\nQed."
}
{
  "statement": "Lemma nil_class1 G : (nil_class G <= 1) = abelian G.\n",
  "proof": "Proof.\nhave [-> | ntG] := eqsVneq G 1.\n  by rewrite abelian1 leq_eqVlt ltnS leqn0 nil_class0 eqxx orbT.\napply/idP/idP=> cGG.\n  apply/commG1P; apply/(lcn_nil_classP 1); rewrite // nilpotent_class.\n  by rewrite (leq_ltn_trans cGG) // cardG_gt1.\nby apply/(lcn_nil_classP 1); rewrite ?abelian_nil //; apply/commG1P.\nQed."
}
{
  "statement": "Lemma morphim_comp (A : {set gT}) : gof @* A = g @* (f @* A).\n",
  "proof": "Proof.\napply/setP=> z; apply/morphimP/morphimP=> [[x]|[y Hy fAy ->{z}]].\n  rewrite !inE => /andP[Gx Hfx]; exists (f x) => //.\n  by apply/morphimP; exists x.\nby case/morphimP: fAy Hy => x Gx Ax ->{y} Hfx; exists x; rewrite ?inE ?Gx.\nQed."
}
{
  "statement": "Lemma mxOver_diagE (S : {pred R}) k (D : 'rV[R]_k) : k > 0 ->\n  (diag_mx D \\is a mxOver S) = ((k > 1) ==> (0 \\in S)) && (D \\is a mxOver S).\n",
  "proof": "Proof.\ncase: k => [|[|k]]//= in D * => _.\n  by rewrite [diag_mx _]mx11_scalar [D in RHS]mx11_scalar !mxE.\napply/idP/andP => [/mxOverP DS|[S0 DS]]; last exact: mxOver_diag.\nsplit; first by have /[!mxE] := DS 0 1.\nby apply/mxOverP => i j; have := DS j j; rewrite ord1 !mxE eqxx.\nQed."
}
{
  "statement": "Lemma subsetP A B : reflect {subset A <= B} (A \\subset B).\n",
  "proof": "Proof.\nrewrite unlock; apply: (iffP (pred0P _)) => [AB0 x | sAB x /=].\n  by apply/implyP; apply/idPn; rewrite negb_imply andbC [_ && _]AB0.\nby rewrite andbC -negb_imply; apply/negbF/implyP; apply: sAB.\nQed."
}
{
  "statement": "Lemma lpreimK f W : (W <= limg f)%VS -> (f @: (f @^-1: W))%VS = W.\n",
  "proof": "Proof.\nmove=> sWf; rewrite limgD (capv_idPl sWf) // -limg_comp.\nhave /eqP->: (f @: lker f == 0)%VS by rewrite -lkerE.\nhave /andP[/eqP defW _] := vbasisP W; rewrite addv0 -defW limg_span.\nrewrite map_id_in // => x Xx; rewrite lfunE /= limg_lfunVK //.\nby apply: span_subvP Xx; rewrite defW.\nQed."
}
{
  "statement": "Lemma coprime_norm_cent A G :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> 'N_G(A) = 'C_G(A).\n",
  "proof": "Proof.\nmove=> nGA coGA; apply/eqP; rewrite eqEsubset andbC setIS ?cent_sub //=.\nrewrite subsetI subsetIl /= (sameP commG1P trivgP) -(coprime_TIg coGA).\nrewrite subsetI commg_subr subsetIr andbT.\nmove: nGA; rewrite -commg_subl; apply: subset_trans.\nby rewrite commSg ?subsetIl.\nQed."
}
{
  "statement": "Lemma coef_comp_poly_Xn p n i : 0 < n ->\n  (p \\Po 'X^n)`_i = if n %| i then p`_(i %/ n) else 0.\n",
  "proof": "Proof.\nmove=> n_gt0; rewrite comp_polyE; under eq_bigr do rewrite -exprM mulnC.\nrewrite coef_sumMXn/=; case: dvdnP => [[j ->]|nD]; last first.\n   by rewrite big1// => j /eqP ?; case: nD; exists j.\nunder eq_bigl do rewrite eqn_mul2r gtn_eqF//.\nby rewrite big_ord1_eq if_nth ?leqVgt ?mulnK.\nQed."
}
{
  "statement": "Lemma is_scalar_mxP A : reflect (exists a, A = a%:M) (is_scalar_mx A).\n",
  "proof": "Proof.\nrewrite /is_scalar_mx; case: insubP => [i _ _ | ].\n  by apply: (iffP eqP) => [|[a ->]]; [exists (A i i) | rewrite mxE eqxx].\nrewrite -eqn0Ngt => /eqP n0; left; exists 0.\nby rewrite raddf0; rewrite n0 in A *; rewrite [A]flatmx0.\nQed."
}
{
  "statement": "Lemma modgactE x a :\n  H \\subset 'C(R | to) -> a \\in 'N_D(H) -> (to %% H)%act x (coset H a) = to x a.\n",
  "proof": "Proof.\nmove=> cRH NDa /=; have [Da Na] := setIP NDa.\nhave [Rx | notRx] := boolP (x \\in R).\n  by rewrite modactE //; apply/afixP=> b /setIP[_ /(subsetP cRH)/astab_act->].\nrewrite gact_out //= /modact; case: ifP => // _; rewrite gact_out //.\nsuffices: a \\in D :&: coset H a by case/mem_repr/setIP.\nby rewrite inE Da val_coset // rcoset_refl.\nQed."
}
{
  "statement": "Lemma Ohm1Eexponent p G :\n  prime p -> exponent 'Ohm_1(G) %| p -> 'Ohm_1(G) = 'Ldiv_p(G).\n",
  "proof": "Proof.\nmove=> p_pr expG1p; have pG: p.-group G.\n  apply: sub_in_pnat (pnat_pi (cardG_gt0 G)) => q _.\n  rewrite -piOhm1 mem_primes; case/and3P=> q_pr _; apply: pgroupP q_pr.\n  by rewrite -pnat_exponent (pnat_dvd expG1p) ?pnat_id.\napply/eqP; rewrite eqEsubset {2}(OhmE 1 pG) subset_gen subsetI Ohm_sub.\nby rewrite sub_LdivT expG1p.\nQed."
}
{
  "statement": "Lemma pprodP A B G :\n  pprod A B = G -> [/\\ are_groups A B, A * B = G & B \\subset 'N(A)].\n",
  "proof": "Proof.\nhave Gnot0 := @group_not0 G; rewrite /pprod; do 2?case: eqP => [-> ->| _].\n- by rewrite mul1g norms1; split; first exists 1%G G.\n- by rewrite mulg1 sub1G; split; first exists G 1%G.\nby case: and3P => // [[gA gB ->]]; split; first exists (Group gA) (Group gB).\nQed."
}
{
  "statement": "Lemma BRight_le_mul_boundr b1 b2 (x1 x2 : R) :\n  (0 <= x1 -> x2 \\in Num.real -> BRight 0%Z <= b2 ->\n   BRight x1 <= num_itv_bound R b1 ->\n   BRight x2 <= num_itv_bound R b2 ->\n   BRight (x1 * x2) <= num_itv_bound R (mul_boundr b1 b2))%O.\n",
  "proof": "Proof.\nmove=> x1ge0 x2r b2ge0 lex1b1 lex2b2.\nhave /orP[x2ge0 | x2le0] := x2r; first exact: num_itv_mul_boundr.\nhave lem0 : (BRight (x1 * x2) <= BRight 0%R)%O.\n  by rewrite bnd_simp mulr_ge0_le0 // ltW.\napply: le_trans lem0 _.\nrewrite -(mulr0z 1) BRight_le_num_itv_bound.\napply: mul_boundr_gt0 => //.\nby rewrite -(@BRight_le_num_itv_bound R) (le_trans _ lex1b1).\nQed."
}
{
  "statement": "Lemma conjCK : involutive (@conj_op C).\n",
  "proof": "Proof.\nhave JE x : x^* = `|x|^+2 / x.\n  have [->|x_neq0] := eqVneq x 0; first by rewrite rmorph0 invr0 mulr0.\n  by apply: (canRL (mulfK _)) => //; rewrite mulrC -normCK.\nmove=> x; have [->|x_neq0] := eqVneq x 0; first by rewrite !rmorph0.\nrewrite !JE normrM normfV exprMn normrX normr_id.\nrewrite invfM exprVn (AC (2*2) (1*(2*3)*4))/= -invfM -exprMn.\nby rewrite divff ?mul1r ?invrK // !expf_eq0 normr_eq0 //.\nQed."
}
{
  "statement": "Lemma prefixP {s1 s2} :\n  reflect (exists s2' : seq T, s2 = s1 ++ s2') (prefix s1 s2).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[{}s2 ->]]; last exact: prefix_prefix.\nby rewrite prefixE => /eqP<-; exists (drop (size s1) s2); rewrite cat_take_drop.\nQed."
}
{
  "statement": "Lemma isometry_of_free S f :\n    free S -> {in S &, isometry form2 form1 f} ->\n  {tau : {linear U1 -> U2} |\n    {in S, tau =1 f} & {in <<S>>%VS &, isometry form2 form1 tau}}.\n",
  "proof": "Proof.\nmove=> freeS If; have defS := free_span freeS.\nhave [tau /(_ freeS (size_map f S))Dtau] := linear_of_free S (map f S).\nhave {}Dtau: {in S, tau =1 f}.\n  by move=> _ /(nthP 0)[i ltiS <-]; rewrite -!(nth_map 0 0) ?Dtau.\nexists tau => // _ _ /defS[a -> _] /defS[b -> _] /=.\nrewrite  2!{1}linear_sum /= !{1}linear_sumlz /=;  apply/eq_big_seq=> xi1 Sxi1.\nrewrite !{1}linear_sumr; apply/eq_big_seq=> xi2 Sxi2 /=.\nby rewrite !linearZ /= !linearZl !Dtau //= If.\nQed."
}
{
  "statement": "Lemma indexed_partition (I T : finType) (J : {pred I}) (B : I -> {set T}) :\n  let P := [set B i | i in J] in\n  {in J &, forall i j : I, j != i -> [disjoint B i & B j]} ->\n  (forall i : I, J i -> B i != set0) -> partition P (cover P) /\\ {in J &, injective B}.\n",
  "proof": "Proof.\nmove=> P disjB inhB; have s0NP : set0 \\notin P.\n  by apply/negP => /imsetP[x xI /eqP]; apply/negP; rewrite eq_sym inhB.\nby rewrite /partition eqxx s0NP andbT /=; apply: trivIimset.\nQed."
}
{
  "statement": "Lemma mx_Schur_inj_iso U f :\n  mxsimple U -> (U <= dom_hom_mx f)%MS -> U *m f != 0 -> mx_iso U (U *m f).\n",
  "proof": "Proof.\nmove=> simU homUf nzUf; have [modU _ _] := simU.\nhave eqUfU: \\rank (U *m f) = \\rank U by apply/mxrank_injP; rewrite mx_Schur_inj.\nhave{eqUfU} [g invg defUf] := complete_unitmx eqUfU.\nsuffices homUg: (U <= dom_hom_mx g)%MS by exists g; rewrite ?defUf.\napply/hom_mxP=> x Gx; have [ux defUx] := submxP (mxmoduleP modU x Gx).\nby rewrite -defUf -(hom_mxP homUf) // defUx -!(mulmxA ux) defUf.\nQed."
}
{
  "statement": "Lemma rank_gt0 G : ('r(G) > 0) = (G :!=: 1).\n",
  "proof": "Proof.\ncase: (eqsVneq G 1) => [-> |]; first by rewrite rank1.\ncase: (trivgVpdiv G) => [/eqP->// | [p p_pr]].\ncase/Cauchy=> // x Gx oxp _; apply: leq_trans (p_rank_le_rank p G).\nhave EpGx: <[x]>%G \\in 'E_p(G).\n  by rewrite inE cycle_subG Gx abelemE // cycle_abelian -oxp exponent_dvdn.\nby apply: leq_trans (logn_le_p_rank EpGx); rewrite -orderE oxp logn_prime ?eqxx.\nQed."
}
{
  "statement": "Lemma acts_qact_dom : [acts qact_dom, on 'N(H) | to].\n",
  "proof": "Proof.\napply/subsetP=> a nNa; rewrite !inE (astabs_dom nNa); apply/subsetP=> x Nx.\nhave: H :* x \\in rcosets H 'N(H) by rewrite -rcosetE imset_f.\nrewrite inE -(astabs_act _ nNa) => /rcosetsP[y Ny defHy].\nhave: to x a \\in H :* y by rewrite -defHy (imset_f (to^~a)) ?rcoset_refl.\nby apply: subsetP; rewrite mul_subG ?sub1set ?normG.\nQed."
}
{
  "statement": "Lemma afix_repr (H : {set gT}) :\n  H \\subset G -> 'Fix_('MR rG)(H) = rowg (rfix_mx rG H).\n",
  "proof": "Proof.\nmove/subsetP=> sHG; apply/setP=> /= u; rewrite !inE.\napply/subsetP/rfix_mxP=> cHu x Hx; have:= cHu x Hx;\n  by rewrite !inE /= => /eqP; rewrite mx_repr_actE ?sHG.\nQed."
}
{
  "statement": "Lemma cormen_lup_upper n A (i j : 'I_n.+1) :\n  j < i -> (cormen_lup A).2 i j = 0 :> F.\n",
  "proof": "Proof.\nelim: n => [|n IHn] /= in A i j *; first by rewrite [i]ord1.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/= Uu.\nrewrite !mxE split1; case: unliftP => [i'|] -> //=; rewrite !mxE split1.\nby case: unliftP => [j'|] ->; [apply: Uu | rewrite /= mxE].\nQed."
}
{
  "statement": "Lemma genD1 A x : x \\in <<A :\\ x>> -> <<A :\\ x>> = <<A>>.\n",
  "proof": "Proof.\nmove=> gA'x; apply/eqP; rewrite eqEsubset genS; last by rewrite subsetDl.\nrewrite gen_subG; apply/subsetP=> y Ay.\nby case: (y =P x) => [-> //|]; move/eqP=> nyx; rewrite mem_gen // !inE nyx.\nQed."
}
{
  "statement": "Lemma expg_order x : x ^+ #[x] = 1.\n",
  "proof": "Proof.\nhave: uniq (traject (mulg x) 1 #[x]).\n  by apply/card_uniqP; rewrite size_traject -(eq_card (cycle_traject x)).\ncase/cyclePmin: (mem_cycle x #[x]) => [] [//|i] ltix.\nrewrite -(subnKC ltix) addSnnS /= expgD; move: (_ - _) => j x_j1.\ncase/andP=> /trajectP[]; exists j; first exact: leq_addl.\nby apply: (mulgI (x ^+ i.+1)); rewrite -iterSr iterS -iteropE -expgS mulg1.\nQed."
}
{
  "statement": "Lemma char_reprP phi :\n  reflect (exists rG : representation algC G, phi = cfRepr rG)\n          (phi \\is a character).\n",
  "proof": "Proof.\napply: (iffP char_sum_irrP) => [[n ->] | [[n rG] ->]]; last first.\n  exists (fun i => standard_irr_coef rG (socle_of_Iirr i)).\n  by rewrite -cfRepr_standard (cfRepr_sim (mx_rsim_standard rG)).\nexists (\\big[dadd_grepr/grepr0]_i muln_grepr (Representation 'Chi_i) (n i)).\nrewrite cfRepr_dsum; apply: eq_bigr => i _.\nby rewrite cfRepr_muln irrRepr scaler_nat.\nQed."
}
{
  "statement": "Lemma telescope_sumn_in n m f : n <= m ->\n    (forall i, n <= i < m -> f i <= f i.+1) ->\n  \\sum_(n <= k < m) (f k.+1 - f k) = f m - f n.\n",
  "proof": "Proof.\nmove=> nm fle; rewrite (telescope_big (fun i j => f j - f i)).\n  by case: ltngtP nm => // ->; rewrite subnn.\nmove=> k /andP[nk km]; rewrite /= addnBAC ?subnKC ?fle ?(ltnW nk)//.\nelim: k nk km => [//| k IHk /[!ltnS]/[1!leq_eqVlt]+ km].\n  move=> /predU1P[/[dup]nk -> | nk]; first by rewrite fle ?nk ?leqnn 1?ltnW.\nby rewrite (leq_trans (IHk _ _) (fle _ _))// ltnW// ltnW.\nQed."
}
{
  "statement": "Lemma nz_row_eq0 m n (A : 'M_(m, n)) : (nz_row A == 0) = (A == 0).\n",
  "proof": "Proof.\nrewrite /nz_row; symmetry; case: pickP => [i /= nzAi | Ai0].\n  by rewrite (negPf nzAi); apply: contraTF nzAi => /eqP->; rewrite row0 eqxx.\nby rewrite eqxx; apply/eqP/row_matrixP=> i; move/eqP: (Ai0 i) ->; rewrite row0.\nQed."
}
{
  "statement": "Lemma is_iso3P : forall p, reflect (is_iso3 p) (p \\in iso3).\n",
  "proof": "Proof.\nmove=> p; apply: (iffP idP); rewrite inE /iso3  /is_iso3b /is_iso3 => e.\n  by move=> fi; rewrite -!permM (eqP e).\nby apply/eqP; apply/permP=> z; rewrite !permM (e z).\nQed."
}
{
  "statement": "Lemma orbit1P G x : reflect (orbit to G x = [set x]) (x \\in 'Fix_to(G)).\n",
  "proof": "Proof.\napply: (iffP afixP) => [xfix | xfix a Ga].\n  apply/eqP; rewrite eq_sym eqEsubset sub1set -{1}[x]act1 imset_f //=.\n  by apply/subsetP=> y; case/imsetP=> a Ga ->; rewrite inE xfix.\nby apply/set1P; rewrite -xfix imset_f.\nQed."
}
{
  "statement": "Lemma codeK : cancel code decode.\n",
  "proof": "Proof.\nelim=> //= v s IHs; rewrite -[_ * _]prednK ?muln_gt0 ?expn_gt0 //=.\nset two := 2; rewrite -[v in RHS]addn0; elim: v 0 => [|v IHv {IHs}] q.\n  rewrite mul1n add0n /= -{}[in RHS]IHs; case: (code s) => // u; pose n := u.+1.\n  by transitivity [rec q, n + u.+1, n.*2]; [rewrite addnn | elim: n => //=].\nrewrite expnS -mulnA mul2n -{1}addnn -[_ * _]prednK ?muln_gt0 ?expn_gt0 //.\nset u := _.-1 in IHv *; set n := u; rewrite [in u1 in _ + u1]/n.\nby rewrite [in RHS]addSnnS -{}IHv; elim: n.\nQed."
}
{
  "statement": "Lemma mxOver_scalarE S c : (n > 0)%N ->\n  (c%:M \\is a @mxOver n n R S) = ((n > 1) ==> (0 \\in S)) && (c \\in S).\n",
  "proof": "Proof.\ncase: n => [|[|k]]//= _.\n   by apply/mxOverP/idP => [/(_ ord0 ord0)|cij i j]; rewrite ?mxE ?ord1.\napply/mxOverP/andP => [cij|[S0 cij] i j]; last by rewrite !mxE; case: eqP.\nby split; [have := cij 0 1|have := cij 0 0]; rewrite !mxE.\nQed."
}
{
  "statement": "Lemma pcore_sub_rstab_mxsimple_pchar M :\n  mxsimple rG M -> 'O_p(G) \\subset rstab rG M.\n",
  "proof": "Proof.\ncase=> modM nzM simM; have sGpG := pcore_sub p G.\nrewrite rfix_mx_rstabC //; set U := rfix_mx _ _.\nhave:= simM (M :&: U)%MS; rewrite sub_capmx submx_refl.\napply; rewrite ?capmxSl //.\n  by rewrite capmx_module // normal_rfix_mx_module ?pcore_normal.\nrewrite -(in_submodK (capmxSl _ _)) val_submod_eq0 -submx0.\nrewrite -(rfix_submod modM) // submx0 rfix_pgroup_pchar ?pcore_pgroup //.\nby rewrite lt0n mxrank_eq0.\nQed."
}
{
  "statement": "Lemma integral_root p u :\n    p != 0 -> root p u -> {in p : seq E, integralRange FtoE} ->\n  integralOver FtoE u.\n",
  "proof": "Proof.\nmove=> nz_p pu0 algFp.\nhave mon_p1: mk_mon p \\is monic.\n  by rewrite monicE lead_coefZ mulVf ?lead_coef_eq0.\nhave p1u0: root (mk_mon p) u by rewrite rootE hornerZ (rootP pu0) mulr0.\napply: integral_root_monic mon_p1 p1u0 _ => _ /(nthP 0)[i ltip <-].\nrewrite coefZ mulrC; rewrite size_scale ?invr_eq0 ?lead_coef_eq0 // in ltip.\nby apply: integral_div; apply/algFp/mem_nth; rewrite -?polySpred.\nQed."
}
{
  "statement": "Lemma Sylow_subnorm p G P : p.-Sylow('N_G(P)) P = p.-Sylow(G) P.\n",
  "proof": "Proof.\napply/idP/idP=> sylP; last first.\n  apply: pHall_subl (subsetIl _ _) (sylP).\n  by rewrite subsetI normG (pHall_sub sylP).\nhave [/subsetIP[sPG sPN] pP _] := and3P sylP.\nhave [Q sylQ sPQ] := Sylow_superset sPG pP; have [sQG pQ _] := and3P sylQ.\nrewrite -(nilpotent_sub_norm (pgroup_nil pQ) sPQ) {sylQ}//.\nrewrite subEproper eq_sym eqEcard subsetI sPQ sPN dvdn_leq //.\nrewrite -(part_pnat_id (pgroupS (subsetIl _ _) pQ)) (card_Hall sylP).\nby rewrite partn_dvd // cardSg ?setSI.\nQed."
}
{
  "statement": "Lemma modact_coset_astab x a :\n  a \\in D -> (to %% 'C(R | to))%act x (coset _ a) = to x a.\n",
  "proof": "Proof.\nmove=> Da; apply: modgactE => {x}//.\nrewrite !inE Da; apply/subsetP=> _ /imsetP[c Cc ->].\nhave Dc := astab_dom Cc; rewrite !inE groupJ //.\napply/subsetP=> x Rx; rewrite inE conjgE !actMin ?groupM ?groupV //.\nby rewrite (astab_act Cc) ?actKVin // gact_stable ?groupV.\nQed."
}
{
  "statement": "Lemma ieexprn_weq1 x n : 0 <= x -> (x ^+ n == 1) = ((n == 0) || (x == 1)).\n",
  "proof": "Proof.\nmove=> xle0; case: n => [|n]; first by rewrite expr0 eqxx.\ncase: (@real_ltgtP x 1); do ?by rewrite ?ger0_real.\n+ by move=> x_lt1; rewrite 1?lt_eqF // exprn_ilt1.\n+ by move=> x_lt1; rewrite 1?gt_eqF // exprn_egt1.\nby move->; rewrite expr1n eqxx.\nQed."
}
{
  "statement": "Lemma sort_pairwise_stable T (leT leT' : rel T) :\n  total leT -> forall s : seq T, pairwise leT' s ->\n  sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (sort leT s).\n",
  "proof": "Proof.\nmove=> leT_total s pairwise_s; case Ds: s => // [x s1].\nrewrite -{s1}Ds -(mkseq_nth x s) sort_map.\napply/homo_sorted_in/sort_iota_stable/(fun _ _ => leT_total _ _)/allss => y z.\nrewrite !mem_sort !mem_iota !leq0n add0n /= => ys zs /andP [->] /=.\nby case: (leT _ _); first apply: pairwiseP.\nQed."
}
{
  "statement": "Lemma commMG G H K :\n  H \\subset 'N([~: G, K]) -> [~: G * H , K] = [~: G, K] * [~: H, K].\n",
  "proof": "Proof.\nmove=> nRH; apply/eqP; rewrite eqEsubset commMGr andbT.\nhave nRHK: [~: H, K] \\subset 'N([~: G, K]) by rewrite comm_subG ?commg_normr.\nhave defM := norm_joinEr nRHK; rewrite -defM gen_subG /=.\napply/subsetP=> _ /imset2P[_ z /imset2P[x y Gx Hy ->] Kz ->].\nby rewrite commMgJ {}defM mem_mulg ?memJ_norm ?mem_commg // (subsetP nRH).\nQed."
}
{
  "statement": "Lemma size_prod (I : finType) (P : pred I) (F : I -> {poly R}) :\n    (forall i, P i -> F i != 0) ->\n  size (\\prod_(i | P i) F i) = ((\\sum_(i | P i) size (F i)).+1 - #|P|)%N.\n",
  "proof": "Proof.\nmove=> nzF; transitivity (\\sum_(i | P i) (size (F i)).-1).+1; last first.\n  apply: canRL (addKn _) _; rewrite addnS -sum1_card -big_split /=.\n  by congr _.+1; apply: eq_bigr => i /nzF/polySpred.\nelim/big_rec2: _ => [|i d p /nzF nzFi IHp]; first by rewrite size_poly1.\nby rewrite size_mul // -?size_poly_eq0 IHp // addnS polySpred.\nQed."
}
{
  "statement": "Lemma tally_seqK : {in wf_tally, cancel tally_seq tally}.\n",
  "proof": "Proof.\nmove=> bs /andP[]; elim: bs => [|[x [|n]] bs IHbs] //= /andP[bs'x Ubs] bs'0.\nrewrite inE /tseq /tally /= -[n.+1]addn1 in bs'0 *.\nelim: n 1 => /= [|n IHn] m; last by rewrite eqxx IHn addnS.\nrewrite -{}[in RHS]IHbs {Ubs bs'0}// /tally /tally_seq add0n.\nelim: bs bs'x [::] => [|[y n] bs IHbs] //= /[1!inE] /norP[y'x bs'x].\nby elim: n => [|n IHn] bs1 /=; [rewrite IHbs | rewrite eq_sym ifN // IHn].\nQed."
}
{
  "statement": "Lemma dvdp_eqp1 p q : p %| q -> q %= 1 -> p %= 1.\n",
  "proof": "Proof.\nmove=> dpq hq.\nhave sizeq : size q == 1 by rewrite size_poly_eq1.\nhave n0q : q != 0 by case: eqP hq => // ->; rewrite eqp01.\nrewrite -size_poly_eq1 eqn_leq -{1}(eqP sizeq) dvdp_leq //= size_poly_gt0.\nby apply/eqP => p0; move: dpq n0q; rewrite p0 dvd0p => ->.\nQed."
}
{
  "statement": "Lemma zprimitive_irr p a q :\n  p != 0 -> zprimitive p = a *: q -> a = sgz (lead_coef q).\n",
  "proof": "Proof.\nmove=> nz_p Dp; have: p = (a * zcontents p) *: q.\n  by rewrite mulrC -scalerA -Dp -zpolyEprim.\ncase/zprimitive_min=> // b <- /eqP.\nrewrite Dp -{1}[q]scale1r scalerA -subr_eq0 -scalerBl scale_poly_eq0 subr_eq0.\nhave{Dp} /negPf->: q != 0.\n  by apply: contraNneq nz_p; rewrite -zprimitive_eq0 Dp => ->; rewrite scaler0.\nby case: b a => [[|[|b]] | [|b]] [[|[|a]] | [|a]] //; rewrite mulr0.\nQed."
}
{
  "statement": "Lemma sort_iota_stable n : sorted lt_lex (sort leN (iota 0 n)).\n",
  "proof": "Proof.\nrewrite sortE.\nhave/andP[]: all (gtn 0) (flatten [::]) && push_invariant [::] by [].\nelim: n 0 [::] => [|n ihn] m ss hss1 hss2; first exact: pop_stable.\napply/ihn/push_stable; last by rewrite /= allrel1l hss1.\nhave: all (gtn m.+1) (flatten ([:: m] :: ss)).\n  by rewrite /= leqnn; apply: sub_all hss1 => ? /leqW.\nelim: ss [:: _] {hss1 hss2} => [|[|? ?] ? ihss] //= ? ?.\nby rewrite ihss //= all_cat all_merge -andbA andbCA -!all_cat.\nQed."
}
{
  "statement": "Lemma inertia_dprod L (phi : 'CF(K)) (psi : 'CF(H)) :\n    L \\subset 'N(K) -> L \\subset 'N(H) -> phi 1%g != 0 -> psi 1%g != 0 ->\n  'I_L[cfDprod KxH phi psi] = 'I_L[phi] :&: 'I_L[psi].\n",
  "proof": "Proof.\nmove=> nKL nHL nz_phi nz_psi; apply/eqP; rewrite eqEsubset subsetI.\nrewrite -{1}(inertia_scale_nz psi nz_phi) -{1}(inertia_scale_nz phi nz_psi).\nrewrite -(cfDprod_Resl KxH) -(cfDprod_Resr KxH) !sub_inertia_Res //=.\nby rewrite -inertia_dprodl -?inertia_dprodr // -setIIr setIS ?inertia_mul.\nQed."
}
{
  "statement": "Lemma coprimepPn p q : p != 0 ->\n  reflect (exists d, (d %| gcdp p q) && ~~ (d %= 1)) (~~ coprimep p q).\n",
  "proof": "Proof.\nmove=> p0; apply: (iffP idP).\n  by rewrite -gcdp_eqp1=> ng1; exists (gcdp p q); rewrite dvdpp /=.\ncase=> d /andP [dg]; apply: contra; rewrite -gcdp_eqp1=> g1.\nby move: dg; rewrite (eqp_dvdr _ g1) dvdp1 size_poly_eq1.\nQed."
}
{
  "statement": "Lemma Ohm_cont rT G (f : {morphism G >-> rT}) :\n  f @* 'Ohm_n(G) \\subset 'Ohm_n(f @* G).\n",
  "proof": "Proof.\nrewrite morphim_gen ?genS //; last by rewrite -gen_subG Ohm_sub.\napply/subsetP=> fx /morphimP[x Gx]; rewrite inE Gx /=.\ncase/OhmPredP=> p p_pr xpn_1 -> {fx}.\nrewrite inE morphimEdom imset_f //=; apply/OhmPredP; exists p => //.\nby rewrite -morphX // xpn_1 morph1.\nQed."
}
{
  "statement": "Lemma fcard_gt1P (A : {pred T}) :\n  fclosed f A ->\n  reflect (exists2 x, x \\in A & exists2 y, y \\in A & ~~ fconnect f x y)\n          (1 < fcard f A).\n",
  "proof": "Proof.\nmove=> clAf; apply: (iffP card_gt1P) => [|[x xA [y yA not_xfy]]].\n  move=> [x [y [/andP [/= rfx xA] /andP[/= rfy yA] xDy]]].\n  by exists x; try exists y; rewrite // -root_connect // (eqP rfx) (eqP rfy).\nexists (froot f x), (froot f y); rewrite !inE !roots_root ?root_connect //=.\nby split => //; rewrite -(closed_connect clAf (connect_root _ _)).\nQed."
}
{
  "statement": "Lemma mxrank_delta m n i j : \\rank (delta_mx i j : 'M_(m, n)) = 1.\n",
  "proof": "Proof.\napply/eqP; rewrite eqn_leq lt0n mxrank_eq0.\nrewrite -{1}(mul_delta_mx (0 : 'I_1)) mulmx_max_rank.\nby apply/eqP; move/matrixP; move/(_ i j); move/eqP; rewrite !mxE !eqxx oner_eq0.\nQed."
}
{
  "statement": "Lemma finField_galois_generator K E :\n   (K <= E)%VS ->\n {alpha | generator 'Gal(E / K) alpha\n        & {in E, forall x, alpha x = x ^+ order K}}.\n",
  "proof": "Proof.\nmove=> sKE; have [alpha defGalLK Dalpha] := galLgen K.\nhave inKL_E: (K <= E <= {:L})%VS by rewrite sKE subvf.\nhave nKE: normalField K E by have/and3P[] := finField_galois sKE.\nhave galLKalpha: alpha \\in 'Gal({:L} / K).\n  by rewrite (('Gal(_ / _) =P _) defGalLK) cycle_id.\nexists (normalField_cast _ alpha) => [|x Ex]; last first.\n  by rewrite (normalField_cast_eq inKL_E).\nrewrite /generator -(morphim_cycle (normalField_cast_morphism inKL_E nKE)) //.\nby rewrite -((_ =P <[alpha]>) defGalLK) normalField_img.\nQed."
}
{
  "statement": "Lemma charsimple_solvable G : charsimple G -> solvable G -> is_abelem G.\n",
  "proof": "Proof.\ncase/charsimple_dprod=> H [sHG simH [I Aut_I defG]] solG.\nhave p_pr: prime #|H| by apply: simple_sol_prime (solvableS sHG solG) simH.\nset p := #|H| in p_pr; apply/is_abelemP; exists p => //.\nelim/big_rec: _ (G) defG => [_ <-|f B If IH_B M defM]; first exact: abelem1.\nhave [Af [[_ K _ defB] _ _ _]] := (subsetP Aut_I f If, dprodP defM).\nrewrite (dprod_abelem p defM) defB IH_B // andbT -(autmE Af) -morphimEsub //=.\nrewrite morphim_abelem ?abelemE // exponent_dvdn.\nby rewrite cyclic_abelian ?prime_cyclic.\nQed."
}
{
  "statement": "Lemma capmxC m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :&: B = B :&: A)%MS.\n",
  "proof": "Proof.\nhave [eqAB|] := eqVneq (qidmx A) (qidmx B).\n  rewrite (capmx_eq_norm eqAB) (capmx_eq_norm (esym eqAB)).\n  apply: capmx_norm_eq; first by rewrite !qidmx_cap andbC.\n  by apply/andP; split; rewrite !sub_capmx andbC -sub_capmx.\nby rewrite negb_eqb !unlock => /addbP <-; case: (qidmx A).\nQed."
}
{
  "statement": "Lemma to_rterm_id t r n : rterm t -> to_rterm t r n = (t, r).\n",
  "proof": "Proof.\nelim: t r n => //.\n- by move=> t1 IHt1 t2 IHt2 r n /= /andP[rt1 rt2]; rewrite {}IHt1 // IHt2.\n- by move=> t IHt r n /= rt; rewrite {}IHt.\n- by move=> t IHt r n m /= rt; rewrite {}IHt.\n- by move=> t1 IHt1 t2 IHt2 r n /= /andP[rt1 rt2]; rewrite {}IHt1 // IHt2.\n- by move=> t IHt r n m /= rt; rewrite {}IHt.\nQed."
}
{
  "statement": "Lemma zprimitive_min p a q :\n    p != 0 -> p = a *: q ->\n  {b | sgz b = sgz (lead_coef q) & q = b *: zprimitive p}.\n",
  "proof": "Proof.\nmove=> nz_p Dp; have /dvdzP/sig_eqW[b Db]: (a %| zcontents p)%Z.\n  by rewrite dvdz_contents; apply/polyOver_dvdzP; exists q.\nsuffices ->: q = b *: zprimitive p.\n  by rewrite lead_coefZ sgzM sgz_lead_primitive nz_p mulr1; exists b.\napply: (@mulfI _ a%:P).\n  by apply: contraNneq nz_p; rewrite Dp -mul_polyC => ->; rewrite mul0r.\nby rewrite !mul_polyC -Dp scalerA mulrC -Db -zpolyEprim.\nQed."
}
{
  "statement": "Lemma rgdcop_recTP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p))))\n  -> forall p q n e, qf_eval e (rgdcop_recT n p q k)\n    = qf_eval e (k (lift (rgdcop_rec (eval_poly e p) (eval_poly e q) n))).\n",
  "proof": "Proof.\nmove=> Pk p q n e; elim: n => [|n Pn] /= in k Pk p q e *.\n  rewrite isnullP /=.\n  by case: (_ == _); rewrite Pk /= mul0r add0r ?(polyC0, polyC1).\nrewrite /rcoprimep rgcdpTP ?sizeTP ?eval_lift => * /=.\n  case: (_ == _);\n  by do ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\ndo ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\ncase: (_ == _);\nby do ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\nQed."
}
{
  "statement": "Lemma ex_elim_qf (x : nat) (pqs : seq tF * seq tF) :\n  GRing.dnf_rterm pqs -> qf (ex_elim x pqs).\n",
  "proof": "Proof.\ncase: pqs => ps qs; case/andP=> /= rps rqs.\napply: ex_elim_seq_qf; first exact: rseq_poly_map.\napply: rabstrX=> /=.\nelim: qs rqs=> [|t ts iht] //=; first by rewrite big_nil.\nby case/andP=> rt rts; rewrite big_cons /= rt /= iht.\nQed."
}
{
  "statement": "Lemma Ohm1Eprime G : 'Ohm_1(G) = <<[set x in G | prime #[x]]>>.\n",
  "proof": "Proof.\nrewrite -['Ohm_1(G)](genD1 (group1 _)); congr <<_>>.\napply/setP=> x; rewrite !inE andbCA -order_dvdn -order_gt1; congr (_ && _).\napply/andP/idP=> [[p_gt1] | p_pr]; last by rewrite prime_gt1 ?pdiv_id.\nset p := pdiv _ => ox_p; have p_pr: prime p by rewrite pdiv_prime.\nby have [_ dv_p] := primeP p_pr; case/pred2P: (dv_p _ ox_p) p_gt1 => ->.\nQed."
}
{
  "statement": "Lemma big_ord_recr n F :\n  \\big[*%M/1]_(i < n.+1) F i =\n     (\\big[*%M/1]_(i < n) F (widen_ord (leqnSn n) i)) * F ord_max.\n",
  "proof": "Proof.\ntransitivity (\\big[*%M/1]_(0 <= i < n.+1) F (inord i)).\n  by rewrite big_mkord; apply: eq_bigr=> i _; rewrite inord_val.\nrewrite big_nat_recr // big_mkord; congr (_ * F _); last first.\n  by apply: val_inj; rewrite /= inordK.\nby apply: eq_bigr => [] i _; congr F; apply: ord_inj; rewrite inordK //= leqW.\nQed."
}
{
  "statement": "Lemma trivIsetU P Q :\n  trivIset Q -> trivIset P -> [disjoint cover Q & cover P] -> trivIset (Q :|: P).\n",
  "proof": "Proof.\nmove => /trivIsetP tQ /trivIsetP tP dQP; apply/trivIsetP => A B.\nmove => /setUP[?|?] /setUP[?|?]; first [exact:tQ|exact:tP|move => _].\n  by apply: disjointW dQP; rewrite bigcup_sup.\nby rewrite disjoint_sym; apply: disjointW dQP; rewrite bigcup_sup.\nQed."
}
{
  "statement": "Lemma aimg_agen (f : ahom aT rT) U : (f @: agenv U)%VS = agenv (f @: U).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  by rewrite limg_sum; apply/subv_sumP => i _; rewrite aimgX subX_agenv.\napply: agenv_sub_modl; first by rewrite -(aimg1 f) limgS // sub1_agenv.\nby rewrite -aimgM limgS // [rhs in (_ <= rhs)%VS]agenvEl addvSr.\nQed."
}
{
  "statement": "Lemma bigcapsP U P F :\n  reflect (forall i, P i -> U \\subset F i) (U \\subset \\bigcap_(i | P i) F i).\n",
  "proof": "Proof.\napply: (iffP idP) => [sUF i Pi | sUF].\n  by apply: subset_trans sUF _; apply: bigcap_inf.\nelim/big_rec: _ => [|i V Pi sUV]; apply/subsetP=> x Ux; rewrite inE //.\nby rewrite !(subsetP _ x Ux) ?sUF.\nQed."
}
{
  "statement": "Lemma neq0 x :\n  unify (fun ix iy => ~~ Itv.sub ix iy) (Itv.Real `[0%Z, 0%Z]) i ->\n  x%:num != 0 :> R.\n",
  "proof": "Proof.\ncase: i x => [//| [l u] [x /= Px]]; apply: contra => /eqP x0 /=.\nmove: Px; rewrite x0 => /and3P[_ /= l0 u0]; apply/andP; split.\n- by case: l l0 => [[] l /= |//]; rewrite !bnd_simp ?lerz0 ?ltrz0.\n- by case: u u0 => [[] u /= |//]; rewrite !bnd_simp ?ler0z ?ltr0z.\nQed."
}
{
  "statement": "Lemma le_irrelevance m n le_mn1 le_mn2 : le_mn1 = le_mn2 :> (m <= n)%coq_nat.\n",
  "proof": "Proof.\nelim/ltn_ind: n => n IHn in le_mn1 le_mn2 *; set n1 := n in le_mn1 *.\npose def_n : n = n1 := erefl n; transitivity (eq_ind _ _ le_mn2 _ def_n) => //.\ncase: n1 / le_mn1 le_mn2 => [|n1 le_mn1] {n}[|n le_mn2] in (def_n) IHn *.\n- by rewrite [def_n]eq_axiomK.\n- by case/leP/idPn: (le_mn2); rewrite -def_n ltnn.\n- by case/leP/idPn: (le_mn1); rewrite def_n ltnn.\ncase: def_n (def_n) => <-{n1} def_n in le_mn1 *.\nby rewrite [def_n]eq_axiomK /=; congr le_S; apply: IHn.\nQed."
}
{
  "statement": "Lemma group_set_gacent A : group_set 'C_(|to)(A).\n",
  "proof": "Proof.\napply/group_setP; split=> [|x y].\n  by rewrite !inE group1; apply/subsetP=> a /setIP[Da _]; rewrite inE gact1.\ncase/setIP=> Rx /afixP cAx /setIP[Ry /afixP cAy].\nrewrite inE groupM //; apply/afixP=> a Aa.\nby rewrite gactM ?cAx ?cAy //; case/setIP: Aa.\nQed."
}
{
  "statement": "Lemma morphimGI G A : 'ker f \\subset G -> f @* (G :&: A) = f @* G :&: f @* A.\n",
  "proof": "Proof.\nmove=> sKG; apply/eqP; rewrite eqEsubset morphimI setIC.\napply/subsetP=> _ /setIP[/morphimP[x Dx Ax ->] /morphimP[z Dz Gz]].\ncase/ker_rcoset=> {Dz}// y Ky def_x.\nhave{z Gz y Ky def_x} Gx: x \\in G by rewrite def_x groupMl // (subsetP sKG).\nby rewrite imset_f ?inE // Dx Gx Ax.\nQed."
}
{
  "statement": "Lemma isometry_of_free S f :\n    free S -> {in S &, isometry f} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} |\n    {in S, tau =1 f} & {in <<S>>%VS &, isometry tau}}.\n",
  "proof": "Proof.\nmove=> freeS If; have defS := free_span freeS.\nhave [tau /(_ freeS (size_map f S))Dtau] := linear_of_free S (map f S).\nhave{} Dtau: {in S, tau =1 f}.\n  by move=> _ /(nthP 0)[i ltiS <-]; rewrite -!(nth_map 0 0) ?Dtau.\nexists tau => // _ _ /defS[a -> _] /defS[b -> _].\nrewrite !{1}linear_sum !{1}cfdot_suml; apply/eq_big_seq=> xi1 Sxi1.\nrewrite !{1}cfdot_sumr; apply/eq_big_seq=> xi2 Sxi2.\nby rewrite !linearZ /= !Dtau // !cfdotZl !cfdotZr If.\nQed."
}
{
  "statement": "Lemma coverD1 P B : trivIset P -> B \\in P -> cover (P :\\ B) = cover P :\\: B.\n",
  "proof": "Proof.\nmove/trivIsetP => tP SP; apply/setP => x; rewrite inE.\napply/bigcupP/idP => [[A /setD1P [ADS AP] xA]|/andP[xNS /bigcupP[A AP xA]]].\n  by rewrite (disjointFr (tP _ _ _ _ ADS)) //=; apply/bigcupP; exists A.\nby exists A; rewrite // !inE AP andbT; apply: contraNneq xNS => <-.\nQed."
}
{
  "statement": "Lemma rotations_is_rot : forall r, r \\in rotations -> is_rot r.\n",
  "proof": "Proof.\nmove=> r Dr; apply/eqP; apply/permP => a; rewrite !inE -!orbA !permM in Dr *.\nby case/or4P: Dr; move/eqP->; rewrite !permE //; case: a; do 4?case.\nQed."
}
{
  "statement": "Lemma filter_pi_of n m : n < m -> filter \\pi(n) (index_iota 0 m) = primes n.\n",
  "proof": "Proof.\nmove=> lt_n_m; have ltnT := ltn_trans; apply: (irr_sorted_eq ltnT ltnn).\n- by rewrite sorted_filter // iota_ltn_sorted.\n- exact: sorted_primes.\nmove=> p; rewrite mem_filter mem_index_iota /= mem_primes; case: and3P => //.\nby case=> _ n_gt0 dv_p_n; apply: leq_ltn_trans lt_n_m; apply: dvdn_leq.\nQed."
}
{
  "statement": "Lemma rstabs_factmod m (W : 'M_(m, \\rank (cokermx U))) :\n  rstabs rU' W = rstabs rG (U + val_factmod W)%MS.\n",
  "proof": "Proof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nrewrite addsmxMr addsmx_sub (submx_trans (mxmoduleP Umod x Gx)) ?addsmxSl //.\nrewrite -val_factmodS val_factmodJ //= val_factmodS; apply/idP/idP=> nWx.\n  rewrite (submx_trans (addsmxSr U _)) // -(in_factmodsK (addsmxSl U _)) //.\n  by rewrite addsmxS // val_factmodS in_factmod_addsK.\nrewrite in_factmodE (submx_trans (submxMr _ nWx)) // -in_factmodE.\nby rewrite in_factmod_addsK val_factmodK.\nQed."
}
{
  "statement": "Lemma gcdp_eq0 p q : gcdp p q == 0 = (p == 0) && (q == 0).\n",
  "proof": "Proof.\napply/idP/idP; last by case/andP => /eqP -> /eqP ->; rewrite gcdp0.\nhave h m n: gcdp m n == 0 -> (m == 0).\n  by rewrite -(dvd0p m); move/eqP<-; rewrite dvdp_gcdl.\nby move=> ?; rewrite (h _ q) // (h _ p) // -eqp0 (eqp_ltrans (gcdpC _ _)) eqp0.\nQed."
}
{
  "statement": "Lemma astabsC S : 'N(~: S | to) = 'N(S | to).\n",
  "proof": "Proof.\napply/setP=> a; apply/idP/idP=> nSa; rewrite !inE (astabs_dom nSa).\n  by rewrite -setCS -preimsetC; apply/subsetP=> x; rewrite inE astabs_act.\nby rewrite preimsetC setCS; apply/subsetP=> x; rewrite inE astabs_act.\nQed."
}
{
  "statement": "Lemma separableP {K E} :\n  reflect (forall y, y \\in E -> separable_element K y) (separable K E).\n",
  "proof": "Proof.\napply/(iffP idP)=> [/allP|] sepK_E; last by apply/allP=> x /vbasis_mem/sepK_E.\nmove=> y /coord_vbasis->; apply/separable_sum=> i _.\nhave: separable_element K (vbasis E)`_i by apply/sepK_E/memt_nth.\nby move/adjoin_separableP; apply; rewrite rpredZ ?memv_adjoin.\nQed."
}
{
  "statement": "Lemma num_itv_bound_keep_pos (op : R -> R) (x : R) b :\n  {homo op : x / 0 <= x} -> {homo op : x / 0 < x} ->\n  (num_itv_bound R b <= BLeft x)%O ->\n  (num_itv_bound R (keep_pos_bound b) <= BLeft (op x))%O.\n",
  "proof": "Proof.\ncase: b => [[] [] [| b] // | []//] hle hlt; rewrite !bnd_simp.\n- exact: hle.\n- by move=> blex; apply: le_lt_trans (hlt _ _) => //; apply: lt_le_trans blex.\n- exact: hlt.\n- by move=> bltx; apply: le_lt_trans (hlt _ _) => //; apply: le_lt_trans bltx.\nQed."
}
{
  "statement": "Lemma mxdirect_kermxpoly n (g : 'M_n) (p q : {poly K}) :\n  coprimep p q -> (kermxpoly g p :&: kermxpoly g q = 0)%MS.\n",
  "proof": "Proof.\ncase: n => [|n] in g *; first by rewrite thinmx0 ?cap0mx ?submx_refl.\nmove=> /Bezout_eq1_coprimepP [[/= u v]]; rewrite mulrC [v * _]mulrC => cpq.\napply/eqP/rowV0P => x.\nrewrite sub_capmx => /andP[/sub_kermxP xgp0 /sub_kermxP xgq0].\nmove: cpq => /(congr1 (mulmx x \\o horner_mx g))/=.\nrewrite !(rmorphM, rmorphD, rmorph1, mulmx1, mulmxDr, mulmxA).\nby rewrite xgp0 xgq0 !mul0mx add0r.\nQed."
}
{
  "statement": "Lemma mxrank_sum_cap m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (\\rank (A + B) + \\rank (A :&: B) = \\rank A + \\rank B)%N.\n",
  "proof": "Proof.\nset C := (A :&: B)%MS; set D := (A :\\: B)%MS.\nhave rDB: \\rank (A + B)%MS = \\rank (D + B)%MS.\n  apply/eqP; rewrite mxrank_leqif_sup; first by rewrite addsmxS ?diffmxSl.\n  by rewrite addsmx_sub addsmxSr -(addsmx_diff_cap_eq A B) addsmxS ?capmxSr.\nrewrite {1}rDB mxrank_disjoint_sum ?capmx_diff //.\nby rewrite addnC addnA mxrank_cap_compl.\nQed."
}
{
  "statement": "Lemma morphim_bigcprod I r (P : pred I) (H : I -> {group gT}) G :\n    G \\subset D -> \\big[cprod/1]_(i <- r | P i) H i = G ->\n  \\big[cprod/1]_(i <- r | P i) f @* H i = f @* G.\n",
  "proof": "Proof.\nelim/big_rec2: _ G => [|i fB B Pi def_fB] G sGD defG.\n  by rewrite -defG morphim1.\ncase/cprodP: defG (defG) => [[Hi Gi -> defB] _ _]; rewrite defB => defG.\nrewrite (def_fB Gi) //; first exact: morphim_cprod.\nby apply: subset_trans sGD; case/cprod_normal2: defG => _ /andP[].\nQed."
}
{
  "statement": "Lemma astab1_set S : 'C[S | set_action] = 'N(S | to).\n",
  "proof": "Proof.\napply/setP=> a; apply/idP/idP=> nSa.\n  case/setIdP: nSa => Da; rewrite !inE Da sub1set inE => /eqP defS.\n  by apply/subsetP=> x Sx; rewrite inE -defS mem_setact.\nby rewrite !inE (astabs_dom nSa) sub1set inE /= astabs_setact.\nQed."
}
{
  "statement": "Lemma sumn_set_nth s x0 n x :\n  sumn (set_nth x0 s n x) =\n    sumn s + x - (nth x0 s n) * (n < size s) + x0 * (n - size s).\n",
  "proof": "Proof.\nrewrite set_nthE; case: ltnP => [nlts|nges]; last first.\n  by rewrite sumn_cat sumn_ncons /= addn0 muln0 subn0 addnAC addnA.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nrewrite -[in sumn s](cat_take_drop n s) [drop n s](drop_nth x0)//.\nby rewrite !sumn_cat /= muln1 muln0 addn0 addnAC !addnA [in RHS]addnAC addnK.\nQed."
}
{
  "statement": "Lemma gen_tperm x : <<[set tperm x y | y in T]>>%g = [set: {perm T}].\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset subsetT/=; apply/subsetP => s _.\nhave [ts -> _] := prod_tpermP s; rewrite group_prod// => -[/= y z] _.\nhave [<-|Nyz] := eqVneq y z; first by rewrite tperm1 group1.\nhave [<-|Nxz] := eqVneq x z; first by rewrite tpermC mem_gen ?imset_f.\nby rewrite -(tpermJ_tperm Nxz Nyz) groupJ ?mem_gen ?imset_f.\nQed."
}
{
  "statement": "Lemma qactEcond x a :\n    x \\in 'N(H) ->\n  quotient_action (coset H x) a\n    = coset H (if a \\in qact_dom then to x a else x).\n",
  "proof": "Proof.\nmove=> Nx; apply: val_inj; rewrite val_subact //= qact_subdomE.\nhave: H :* x \\in rcosets H 'N(H) by rewrite -rcosetE imset_f.\ncase nNa: (a \\in _); rewrite // -(astabs_act _ nNa).\nrewrite !val_coset ?(acts_act acts_qact_dom nNa) //=.\ncase/rcosetsP=> y Ny defHy; rewrite defHy; apply: rcoset_eqP.\nby rewrite rcoset_sym -defHy (imset_f (_^~_)) ?rcoset_refl.\nQed."
}
{
  "statement": "Lemma ltn_pdiv2_prime n : 0 < n -> n < pdiv n ^ 2 -> prime n.\n",
  "proof": "Proof.\ncase def_n: n => [|[|n']] // _; rewrite -def_n => lt_n_p2.\nsuffices ->: n = pdiv n by rewrite pdiv_prime ?def_n.\napply/eqP; rewrite eqn_leq leqNgt andbC pdiv_leq; last by rewrite def_n.\napply/contraL: lt_n_p2 => lt_pm_m; case/dvdnP: (pdiv_dvd n) => q def_q.\nrewrite -leqNgt [leqRHS]def_q leq_pmul2r // pdiv_min_dvd //.\n  by rewrite -[pdiv n]mul1n [ltnRHS]def_q ltn_pmul2r in lt_pm_m.\nby rewrite def_q dvdn_mulr.\nQed."
}
{
  "statement": "Lemma pnat_exponent pi G : pi.-nat (exponent G) = pi.-group G.\n",
  "proof": "Proof.\ncongr (_ && _); first by rewrite cardG_gt0 exponent_gt0.\napply: eq_all_r => p; rewrite !mem_primes cardG_gt0 exponent_gt0 /=.\napply: andb_id2l => p_pr; apply/idP/idP=> pG.\n  exact: dvdn_trans pG (exponent_dvdn G).\nby case/Cauchy: pG => // x Gx <-; apply: dvdn_exponent.\nQed."
}
{
  "statement": "Lemma gcdz_modr m n : gcdz m (n %% m)%Z = gcdz m n.\n",
  "proof": "Proof.\nrewrite -modz_abs /gcdz; move/absz: m => m.\nhave [-> | m_gt0] := posnP m; first by rewrite modz0.\ncase: n => n; first by rewrite modz_nat gcdn_modr.\nrewrite modNz_nat // NegzE abszN {2}(divn_eq n m) -addnS gcdnMDl.\nrewrite -addrA -opprD -intS /=; set m1 := _.+1.\nhave le_m1m: (m1 <= m)%N by apply: ltn_pmod.\nby rewrite subzn // !(gcdnC m) -{2 3}(subnK le_m1m) gcdnDl gcdnDr gcdnC.\nQed."
}
{
  "statement": "Lemma eqseq_pivot2l x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s3 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\n",
  "proof": "Proof.\nmove=> xNs1 xNs3; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\nsuff S : size s1 = size s3 by rewrite eqseq_cat// eqseq_cons eqxx in E.\nby rewrite -(index_pivot s2 xNs1) (eqP E) index_pivot.\nQed."
}
{
  "statement": "Lemma pfactor_dvdn p n m : prime p -> m > 0 -> (p ^ n %| m) = (n <= logn p m).\n",
  "proof": "Proof.\nmove=> p_pr; elim: n m => [|n IHn] m m_gt0; first exact: dvd1n.\nrewrite lognE p_pr m_gt0 /=; case dv_pm: (p %| m); last first.\n  apply/dvdnP=> [] [/= q def_m].\n  by rewrite def_m expnS mulnCA dvdn_mulr in dv_pm.\ncase/dvdnP: dv_pm m_gt0 => q ->{m}; rewrite muln_gt0 => /andP[p_gt0 q_gt0].\nby rewrite expnSr dvdn_pmul2r // mulnK // IHn.\nQed."
}
{
  "statement": "Lemma quaternion_classP :\n  extremal_class G = Quaternion <-> (exists2 n, n > 2 & G \\isog 'Q_(2 ^ n)).\n",
  "proof": "Proof.\nrewrite /extremal_class; split=> [ | [n n_gt2 isoG]].\n  by move: (logn _ _) => n; do 4?case: ifP => //; case/andP; exists n.\nrewrite (card_isog isoG) card_quaternion // -(ltn_predK n_gt2) pdiv_pfactor //.\nrewrite pfactorK // (ltn_predK n_gt2) n_gt2 isoG.\ncase: andP => // [[n_gt1 isoGD]].\nhave [[x y] genG [oy _ _]]:= generators_quaternion n_gt2 isoG.\nhave [_ _ _ X'y] := genG.\nby case/dihedral2_structure: genG oy => // [[_ ->]].\nQed."
}
{
  "statement": "Lemma inertia_injective (chi : 'CF(H)) :\n  {in H &, injective chi} -> 'I[chi] = 'C(H).\n",
  "proof": "Proof.\nmove=> inj_chi; apply/eqP; rewrite eqEsubset cent_sub_inertia andbT.\napply/subsetP=> y Ichi_y; have /setIdP[nHy _] := Ichi_y.\napply/centP=> x Hx; apply/esym/commgP/conjg_fixP.\nby apply/inj_chi; rewrite ?memJ_norm ?(inertia_valJ _ Ichi_y).\nQed."
}
{
  "statement": "Lemma cfInd_is_linear : linear cfInd.\n",
  "proof": "Proof.\nmove=> c phi psi; apply/cfunP=> x; rewrite !cfunElock; case: ifP => _.\n  rewrite mulrCA -mulrDr [c * _]mulr_sumr -big_split /=.\n  by congr (_ * _); apply: eq_bigr => y _; rewrite !cfunE.\nrewrite mulrnAr -mulrnDl !(mulrCA c) -!mulrDr [c * _]mulr_sumr -big_split /=.\nby congr (_ * (_ * _) *+ _); apply: eq_bigr => y; rewrite !cfunE mulrA mulrDl.\nQed."
}
{
  "statement": "Lemma card_DnQ n : #|'D^n*Q| = (2 ^ n.+1.*2.+1)%N.\n",
  "proof": "Proof.\nhave oQ: #|'Q_(2 ^ 3)| = 8 by rewrite card_quaternion.\nhave pQ: 2.-group 'Q_8 by rewrite /pgroup oQ.\ncase: DnQ_P => gz isoZ.\nrewrite -im_cpair cardMg_divn setI_im_cpair cpair_center_id.\nrewrite -injm_center//; last exact: injm_cpair1g.\nrewrite (card_injm (injm_cpairg1 _))// (card_injm (injm_cpair1g _))//.\nrewrite (card_injm (injm_cpair1g _))//; last exact: center_sub.\nrewrite oQ card_pX1p2n // (card_center_extraspecial pQ Q8_extraspecial).\nby rewrite -muln_divA // mulnC -(expnD 2 2).\nQed."
}
{
  "statement": "Lemma pchar_qpoly : [pchar {poly %/ h}] =i [pchar A].\n",
  "proof": "Proof.\nmove=> p; rewrite !inE; congr (_ && _).\napply/eqP/eqP=> [/(congr1 val) /=|pE]; last first.\n  by apply: val_inj => //=; rewrite qpolyC_natr /= -polyC_natr pE.\nrewrite !qpolyC_natr -!polyC_natr => /(congr1 val) /=.\nby rewrite polyseqC polyseq0; case: eqP.\nQed."
}
{
  "statement": "Lemma bigcat_basis Us (U := (\\sum_(i | P i) Us i)%VS) :\n    directv U -> (forall i, P i -> basis_of (Us i) (Xs i)) ->\n  basis_of U (\\big[cat/[::]]_(i | P i) Xs i).\n",
  "proof": "Proof.\nmove=> dxU XsUs; rewrite /basis_of span_bigcat.\nhave defUs i: P i -> span (Xs i) = Us i by case/XsUs/andP=> /eqP.\nrewrite (eq_bigr _ defUs) eqxx bigcat_free // => [|_ /XsUs/andP[]//].\napply/directvP; rewrite /= (eq_bigr _ defUs) (directvP dxU) /=.\nby apply/eq_bigr=> i /defUs->.\nQed."
}
{
  "statement": "Lemma submod_mx_irr : mx_irreducible rU <-> mxsimple rG U.\n",
  "proof": "Proof.\nsplit=> [] [_ nzU simU].\n  rewrite -mxrank_eq0 mxrank1 mxrank_eq0 in nzU; split=> // V modV sVU nzV.\n  rewrite -(in_submodK sVU) -val_submod1 val_submodS.\n  rewrite -(genmxE (in_submod U V)) simU ?genmxE ?submx1 //=.\n    by rewrite (eqmx_module _ (genmxE _)) in_submod_module.\n  by rewrite -submx0 genmxE -val_submodS in_submodK // linear0 eqmx0 submx0.\napply/mx_irrP; rewrite lt0n mxrank_eq0; split=> // V modV.\nrewrite -(inj_eq val_submod_inj) linear0 -(eqmx_eq0 (genmxE _)) => nzV.\nrewrite -sub1mx -val_submodS val_submod1 -(genmxE (val_submod V)).\nrewrite simU ?genmxE ?val_submodP //=.\nby rewrite (eqmx_module _ (genmxE _)) val_submod_module.\nQed."
}
{
  "statement": "Lemma ker_actperm : 'ker actperm = 'C(setT | to).\n",
  "proof": "Proof.\ncongr (_ :&: _); apply/setP=> a /[!inE]/=.\napply/eqP/subsetP=> [a1 x _ | a1]; first by rewrite inE -actpermE a1 perm1.\nby apply/permP=> x; apply/eqP; have:= a1 x; rewrite !inE actpermE perm1 => ->.\nQed."
}
{
  "statement": "Lemma cfdot_add_dirr_eq1 :\n  {in dirr G & &, forall phi1 phi2 psi,\n    '[phi1 + phi2, psi] = 1 -> psi = phi1 \\/ psi = phi2}.\n",
  "proof": "Proof.\nmove=> _ _ _ /dirrP[b1 [i1 ->]] /dirrP[b2 [i2 ->]] /dirrP[c [j ->]] /eqP.\nrewrite cfdotDl !cfdotZl !cfdotZr !rmorph_sign !cfdot_irr !mulrA -!signr_addb.\nrewrite 2!{1}signrE !mulrBl !mul1r -!natrM addrCA -subr_eq0 -!addrA.\nrewrite -!opprD addrA subr_eq0 -mulrSr -!natrD eqr_nat => eq_phi_psi.\napply/pred2P; rewrite /= !eq_signed_irr -!negb_add !(eq_sym j) !(addbC c).\nby case: (i1 == j) eq_phi_psi; case: (i2 == j); do 2!case: (_ (+) c).\nQed."
}
{
  "statement": "Lemma qlogp_qX (p : qT) : p != 0 -> 'qX ^+ (qlogp p) = p.\n",
  "proof": "Proof.\nmove=> p_neq0.\nhave Up : p \\in GRing.unit by rewrite unitfE.\npose gp : {unit qT}:= FinRing.unit _ Up.\nhave /cyclePmin[i iLc iX] : gp \\in <[gX]>%g by rewrite gX_all inE.\nrewrite gX_order in iLc.\nrewrite /qlogp; case: pickP => [j /eqP//|/(_ (Ordinal iLc))] /eqP[].\nby have /val_eqP/eqP/= := iX; rewrite FinRing.val_unitX.\nQed."
}
{
  "statement": "Lemma orbit_uniq x : uniq (orbit x).\n",
  "proof": "Proof.\nrewrite /orbit -orderSpred looping_uniq; set n := (order x).-1.\napply: contraFN (ltnn n) => /trajectP[i lt_i_n eq_fnx_fix].\nrewrite orderSpred -(size_traject f x n).\napply: (leq_trans (subset_leq_card _) (card_size _)); apply/subsetP=> z.\nrewrite inE fconnect_orbit => /trajectP[j le_jn ->{z}].\nrewrite -orderSpred -/n ltnS leq_eqVlt in le_jn.\nby apply/trajectP; case/predU1P: le_jn => [->|]; [exists i | exists j].\nQed."
}
{
  "statement": "Lemma incr_tallyP x : {homo incr_tally^~ x : bs / bs \\in wf_tally}.\n",
  "proof": "Proof.\nmove=> bs /andP[]; rewrite unfold_in.\nelim: bs => [|[y [|n]] bs IHbs] //= /andP[bs'y Ubs] /[1!inE] /= bs'0.\nhave [<- | y'x] /= := eqVneq y; first by rewrite bs'y Ubs.\nrewrite -andbA {}IHbs {Ubs bs'0}// andbT.\nelim: bs bs'y => [|b bs IHbs] /=; rewrite inE ?y'x // => /norP[b'y bs'y].\nby case: ifP => _; rewrite /= inE negb_or ?y'x // b'y IHbs.\nQed."
}
{
  "statement": "Lemma num_spec_natmul (xi ni : Itv.t) (x : num_def R xi) (n : nat_def ni)\n    (r := natmul_itv xi ni) :\n  num_spec r (x%:num *+ n%:num).\n",
  "proof": "Proof.\nrewrite {}/r; case: xi x ni n => [//| xi] x [| ni] n.\n  by apply/and3P; case: n%:num => [|?]; rewrite ?mulr0n ?realrMn.\nhave Pn : num_spec (Itv.Real ni) (n%:num%:R : R).\n  by case: n => /= n; rewrite [Itv.nat_sem ni n](nat_num_spec (Itv.Real ni)).\nrewrite -mulr_natr -[n%:num%:R]/((Itv.Def Pn)%:num).\nby rewrite (@num_spec_mul (Itv.Real xi) (Itv.Real ni)).\nQed."
}
{
  "statement": "Lemma addsmxE : (A + B :=: col_mx A B)%MS.\n",
  "proof": "Proof.\nhave:= submx_refl (col_mx A B); rewrite col_mx_sub; case/andP=> sAS sBS.\nrewrite unlock; do 2?case: eqP => [AB0 | _]; last exact: genmxE.\n  by apply/eqmxP; rewrite !eqmx_sum_nop sBS col_mx_sub AB0 sub0mx /=.\nby apply/eqmxP; rewrite !eqmx_sum_nop sAS col_mx_sub AB0 sub0mx andbT /=.\nQed."
}
{
  "statement": "Lemma dvdp_Pexp2l d k l : 1 < size d -> (d ^+ k %| d ^+ l) = (k <= l).\n",
  "proof": "Proof.\nmove=> sd; case: leqP => [|gt_n_m]; first exact: dvdp_exp2l.\nhave dn0 : d != 0 by rewrite -size_poly_gt0; apply: ltn_trans sd.\nrewrite gtNdvdp ?expf_neq0 // polySpred ?expf_neq0 // size_exp /=.\nrewrite [size (d ^+ k)]polySpred ?expf_neq0 // size_exp ltnS ltn_mul2l.\nby move: sd; rewrite -subn_gt0 subn1; move->.\nQed."
}
{
  "statement": "Lemma pmorphim_pgroup pi G :\n   pi.-group ('ker f) -> G \\subset D -> pi.-group (f @* G) = pi.-group G.\n",
  "proof": "Proof.\nmove=> piker sGD; apply/idP/idP=> [pifG|]; last exact: morphim_pgroup.\napply: (@pgroupS _ _ (f @*^-1 (f @* G))); first by rewrite -sub_morphim_pre.\nby rewrite /pgroup card_morphpre ?morphimS // pnatM; apply/andP.\nQed."
}
{
  "statement": "Lemma acts_irr_mod G M :\n    H \\subset 'C(M | to) -> G \\subset 'N(H) -> acts_irreducibly G M to ->\n  acts_irreducibly (G / H) M mod_groupAction.\n",
  "proof": "Proof.\nmove=> cMH nHG /mingroupP[/andP[ntM nMG] minM].\napply/mingroupP; rewrite ntM astabs_mod ?quotientS //; split=> // L modL ntL.\nhave cLH: H \\subset 'C(L | to) by rewrite (subset_trans cMH) ?astabS //.\napply: minM => //; case/andP: modL => ->; rewrite astabs_mod ?quotientSGK //.\nby rewrite (subset_trans cLH) ?astab_sub.\nQed."
}
{
  "statement": "Lemma merge_stable_sorted s1 s2 :\n  allrel leT' s1 s2 -> sorted leT_lex s1 -> sorted leT_lex s2 ->\n  sorted leT_lex (merge s1 s2).\n",
  "proof": "Proof.\ncase: s1 s2 => [|x s1] [|y s2] //=; rewrite allrel_consl allrel_consr /= -andbA.\ncase/and4P => [xy' xs2 ys1 s1s2] xs1 ys2; rewrite -/(merge (_ :: _)).\nby case: ifP (leT_total x y) => /= xy yx; apply/merge_stable_path;\n  rewrite /= ?(allrel_consl, allrel_consr, xs2, ys1, xy, yx, xy', implybT).\nQed."
}
{
  "statement": "Theorem third_isom : {f : {morphism (G / H) / (K / H) >-> coset_of K} | 'injm f\n   & forall A : {set gT}, A \\subset G -> f @* (A / H / (K / H)) = A / K}.\n",
  "proof": "Proof.\nhave [[sKG nKG] [sHG nHG]] := (andP snKG, andP snHG).\nhave sHker: 'ker (coset H) \\subset 'ker (restrm nKG (coset K)).\n  by rewrite ker_restrm !ker_coset subsetI sHG.\nhave:= first_isom_loc (factm_morphism sHker nHG) (subxx _) => /=.\nrewrite ker_factm_loc ker_restrm ker_coset !(setIidPr sKG) /= -!quotientE.\ncase=> f injf im_f; exists f => // A sAG; rewrite im_f ?morphimS //.\nby rewrite morphim_factm morphim_restrm (setIidPr sAG).\nQed."
}
{
  "statement": "Lemma eqp_gdcol p q r : q %= r -> gdcop q p %= gdcop r p.\n",
  "proof": "Proof.\nmove=> eqr; rewrite /gdcop; move: (size p)=> n.\nelim: n p q r eqr {1 3}p (eqpxx p) => [|n ihn] p q r eqr s esp /=.\n  case: (eqVneq q 0) eqr => [-> | nq0 eqr] /=.\n    by rewrite eqp_sym eqp0 => ->; rewrite eqpxx.\n  by case: (eqVneq r 0) eqr nq0 => [->|]; rewrite ?eqpxx // eqp0 => ->.\nrewrite (eqp_coprimepr _ eqr) (eqp_coprimepl _ esp); case: ifP=> _ //.\nexact/ihn/eqp_div/eqp_gcd.\nQed."
}
{
  "statement": "Lemma subnormalEr G H : H <|<| G -> \n  H :=: G \\/ (exists K : {group gT}, [/\\ H <|<| K, K <| G & K \\proper G]).\n",
  "proof": "Proof.\ncase/subnormalP=> s Hs <-{G}.\nelim/last_ind: s Hs => [|s G IHs]; first by left.\nrewrite last_rcons -cats1 cat_path /= andbT; set K := last H s.\ncase/andP=> Hs nsKG; have /[1!subEproper] := normal_sub nsKG.\ncase/predU1P=> [<- | prKG]; [exact: IHs | right; exists K; split=> //].\nby apply/subnormalP; exists s.\nQed."
}
{
  "statement": "Lemma cprod_abelem p A B G :\n  A \\* B = G -> p.-abelem G = p.-abelem A && p.-abelem B.\n",
  "proof": "Proof.\ncase/cprodP=> [[H K -> ->{A B}] defG cHK].\napply/idP/andP=> [abelG | []].\n  by rewrite !(abelemS _ abelG) // -defG (mulG_subl, mulG_subr).\ncase/and3P=> pH cHH expHp; case/and3P=> pK cKK expKp.\nrewrite -defG /abelem pgroupM pH pK abelianM cHH cKK cHK /=.\napply/exponentP=> _ /imset2P[x y Hx Ky ->].\nrewrite expgMn; last by red; rewrite -(centsP cHK).\nby rewrite (exponentP expHp) // (exponentP expKp) // mul1g.\nQed."
}
{
  "statement": "Lemma cfRepr_gring_center n1 (rG : mx_representation algCfield G n1) A :\n  cfRepr rG = 'chi_i -> (A \\in 'Z(R_G))%MS -> gring_op rG A = 'omega_i[A]%:M.\n",
  "proof": "Proof.\nmove=> def_rG Z_A; rewrite unlock xcfunZl -{2}def_rG xcfun_repr.\nhave irr_rG: mx_irreducible rG.\n  have sim_rG: mx_rsim 'Chi_i rG by apply: cfRepr_inj; rewrite irrRepr.\n  exact: mx_rsim_irr sim_rG (socle_irr _).\nhave /is_scalar_mxP[e ->] := mx_irr_gring_op_center_scalar irr_rG Z_A.\ncongr _%:M; apply: (canRL (mulKf (irr1_neq0 i))).\nby rewrite mulrC -def_rG cfunE repr_mx1 group1 -mxtraceZ scalemx1.\nQed."
}
{
  "statement": "Lemma mxrank_Frobenius m n p q (A : 'M_(m, n)) B (C : 'M_(p, q)) :\n  \\rank (A *m B) + \\rank (B *m C) <= \\rank B + \\rank (A *m B *m C).\n",
  "proof": "Proof.\nrewrite -{2}(mulmx_base (A *m B)) -mulmxA (eqmxMfull _ (col_base_full _)).\nset C2 := row_base _ *m C.\nrewrite -{1}(subnK (rank_leq_row C2)) -(mxrank_ker C2) addnAC leq_add2r.\nrewrite addnC -{1}(mulmx_base B) -mulmxA eqmxMfull //.\nset C1 := _ *m C; rewrite -{2}(subnKC (rank_leq_row C1)) leq_add2l -mxrank_ker.\nrewrite -(mxrankMfree _ (row_base_free (A *m B))).\nhave: (row_base (A *m B) <= row_base B)%MS by rewrite !eq_row_base submxMl.\ncase/submxP=> D defD; rewrite defD mulmxA mxrankMfree ?mxrankS //.\nby rewrite sub_kermx -mulmxA (mulmxA D) -defD -/C2 mulmx_ker.\nQed."
}
{
  "statement": "Lemma irr_comp_envelop_pchar : ('R_iG *m lin_mx (gring_op rG) :=: E_G)%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split; apply/row_subP=> i.\n  by rewrite row_mul mul_rV_lin gring_mxP.\nrewrite rowK /= -gring_opG ?enum_valP // -mul_vec_lin -gring_opG ?enum_valP //.\nrewrite vec_mxK /= -mulmxA mulmx_sub {i}//= -(eqmxMr _ Wedderburn_sum_pchar).\nrewrite (bigD1 iG) //= addsmxMr addsmxC [_ *m _](sub_kermxP _) ?adds0mx //=.\napply/sumsmx_subP => j ne_j_iG; apply/memmx_subP=> A RjA; apply/sub_kermxP.\nby rewrite mul_vec_lin /= (irr_comp'_op0_pchar ne_j_iG RjA) linear0.\nQed."
}
{
  "statement": "Lemma Bezout_eq1_coprimepP p q :\n  reflect (exists u, u.1 * p + u.2 * q = 1) (coprimep p q).\n",
  "proof": "Proof.\napply: (iffP idP)=> [hpq|]; last first.\n  by case=> -[u v] /= e; apply/Bezout_coprimepP; exists (u, v); rewrite e eqpxx.\ncase/Bezout_coprimepP: hpq => [[u v]] /=.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0] e.\nexists (c2^-1 *: (c1 *: u), c2^-1 *: (c1 *: v)); rewrite /= -!scalerAl.\nby rewrite -!scalerDr e scalerA mulVf // scale1r.\nQed."
}
{
  "statement": "Lemma C_prim_root_exists n : (n > 0)%N -> {z : algC | n.-primitive_root z}.\n",
  "proof": "Proof.\npose p : {poly algC} := 'X^n - 1; have [r Dp] := closed_field_poly_normal p.\nmove=> n_gt0; apply/sigW; rewrite (monicP _) ?monicXnsubC // scale1r in Dp.\nhave rn1: all n.-unity_root r by apply/allP=> z; rewrite -root_prod_XsubC -Dp.\nhave sz_r: (n < (size r).+1)%N.\n  by rewrite -(size_prod_XsubC r id) -Dp size_XnsubC.\nhave [|z] := hasP (has_prim_root n_gt0 rn1 _ sz_r); last by exists z.\nby rewrite -separable_prod_XsubC -Dp separable_Xn_sub_1 // pnatr_eq0 -lt0n.\nQed."
}
{
  "statement": "Lemma astab_range : 'C(R | to) = 'C(setT | to).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset andbC astabS ?subsetT //=.\napply/subsetP=> a cRa; have Da := astab_dom cRa; rewrite !inE Da.\napply/subsetP=> x; rewrite -(setUCr R) !inE.\nby case/orP=> ?; [rewrite (astab_act cRa) | rewrite gact_out].\nQed."
}
{
  "statement": "Lemma leif_rootC_AGM (I : finType) (A : {pred I}) (n := #|A|) E :\n    {in A, forall i, 0 <= E i} ->\n  n.-root (\\prod_(i in A) E i) <= (\\sum_(i in A) E i) / n%:R\n                             ?= iff [forall i in A, forall j in A, E i == E j].\n",
  "proof": "Proof.\nmove=> Ege0; have [n0 | n_gt0] := posnP n.\n  rewrite n0 root0C invr0 mulr0; apply/leif_refl/forall_inP=> i.\n  by rewrite (card0_eq n0).\nrewrite -(mono_in_leif (ler_pXn2r n_gt0)) ?rootCK //=; first 1 last.\n- by rewrite qualifE /= rootC_ge0 // prodr_ge0.\n- by rewrite rpred_div ?rpred_nat ?rpred_sum.\nexact: leif_AGM.\nQed."
}
{
  "statement": "Lemma eval_submx e : qf_eval e submx_form = (eval_mx e A <= eval_mx e B)%MS.\n",
  "proof": "Proof.\nrewrite (morphAnd (qf_eval e)) //= big_andE /=.\napply/forallP/idP=> /= [|sAB d]; last first.\n  rewrite !eval_mxrank eval_col_mx -addsmxE; apply/implyP=> /eqP <-.\n  by rewrite mxrank_leqif_sup ?addsmxSr // addsmx_sub sAB /=.\nmove/(_ (inord (\\rank (eval_mx e (col_mx A B))))).\nrewrite inordK ?ltnS ?rank_leq_col // !eval_mxrank eqxx /= eval_col_mx.\nby rewrite -addsmxE mxrank_leqif_sup ?addsmxSr // addsmx_sub; case/andP.\nQed."
}
{
  "statement": "Lemma cprod_exponent A B G :\n  A \\* B = G -> lcmn (exponent A) (exponent B) = (exponent G).\n",
  "proof": "Proof.\ncase/cprodP=> [[K H -> ->{A B}] <- cKH].\napply/eqP; rewrite eqn_dvd dvdn_lcm !exponentS ?mulG_subl ?mulG_subr //=.\napply/exponentP=> _ /imset2P[x y Kx Hy ->].\nrewrite -[1]mulg1 expgMn; last by red; rewrite -(centsP cKH).\ncongr (_ * _); apply/eqP; rewrite -order_dvdn.\n  by rewrite (dvdn_trans (dvdn_exponent Kx)) ?dvdn_lcml.\nby rewrite (dvdn_trans (dvdn_exponent Hy)) ?dvdn_lcmr.\nQed."
}
{
  "statement": "Lemma lfunPn f g : reflect (exists u, f u != g u) (f != g).\n",
  "proof": "Proof.\napply: (iffP idP) => [f'g|[x]]; last by apply: contraNneq => /lfunP->.\nsuffices /subvPn[_ /memv_imgP[u _ ->]]: ~~ (limg (f - g) <= 0)%VS.\n  by rewrite lfunE /= lfunE /= memv0 subr_eq0; exists u.\napply: contra f'g => /subvP fg0; apply/eqP/lfunP=> u; apply/eqP.\nby rewrite -subr_eq0 -opp_lfunE -add_lfunE -memv0 fg0 ?memv_img ?memvf.\nQed."
}
{
  "statement": "Lemma in_iter_fixE (x : T) k : (x \\in iterF k) = (0 < fix_order x <= k).\n",
  "proof": "Proof.\nrewrite /fix_order; case: eqP => //= [x_in|/negP xNin]; last first.\n  by apply: contraNF xNin; apply/subsetP/iter_sub_fix.\ncase: ex_minnP => -[/[!inE]//|m] xm mP.\nby apply/idP/idP=> [/mP//|lt_mk]; apply: subsetP xm; apply: subset_iter.\nQed."
}
{
  "statement": "Lemma modn_partP n a b : 0 < n ->\n  reflect (forall p : nat, p \\in \\pi(n) -> a = b %[mod n`_p]) (a == b %[mod n]).\n",
  "proof": "Proof.\nmove=> n_gt0; wlog le_b_a: a b / b <= a.\n  move=> IH; case: (leqP b a) => [|/ltnW] /IH {IH}// IH.\n  by rewrite eq_sym; apply: (iffP IH) => eqab p /eqab.\nrewrite eqn_mod_dvd //; apply: (iffP (dvdn_partP _ n_gt0)) => eqab p /eqab;\n  by rewrite -eqn_mod_dvd // => /eqP.\nQed."
}
{
  "statement": "Lemma matrix_modl m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= C -> A + (B :&: C) :=: (A + B) :&: C)%MS.\n",
  "proof": "Proof.\nmove=> sAC; set D := ((A + B) :&: C)%MS; apply/eqmxP.\nrewrite sub_capmx addsmxS ?capmxSl // addsmx_sub sAC capmxSr /=.\nhave: (D <= B + A)%MS by rewrite addsmxC capmxSl.\ncase/sub_addsmxP=> u defD; rewrite defD addrC addmx_sub_adds ?submxMl //.\nrewrite sub_capmx submxMl -[_ *m B](addrK (u.2 *m A)) -defD.\nby rewrite addmx_sub ?capmxSr // eqmx_opp mulmx_sub.\nQed."
}
{
  "statement": "Lemma dvdp_order n : (h %| 'X^n - 1) = (gX ^+ n == 1)%g.\n",
  "proof": "Proof.\nhave [hM hI] := primitive_mi.\nhave eqr_add2r (r : nzRingType) (a b c : r) : (a + c == b + c) = (a == b).\n  by apply/eqP/eqP => [H|->//]; rewrite -(addrK c a) H addrK.\nrewrite -val_eqE /= val_unitX /= -val_eqE /=.\nrewrite (poly_of_qpolyX) qpolyXE // mk_monicE //.\nrewrite -[in RHS](subrK 1 'X^n) rmodpD //.\nrewrite [rmodp 1 h]rmodp_small ?size_poly1 //.\nrewrite -[1%:P]add0r polyC1 /= eqr_add2r.\nby rewrite dvdpE /=; apply/rmodp_eq0P/eqP.\nQed."
}
{
  "statement": "Lemma im_Aut_isom : Aut_isom injf sGD @* Aut G = Aut (f @* G).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEcard; apply/andP; split.\n  by apply/subsetP=> _ /morphimP[a _ AutGa ->]; apply: Aut_Aut_isom.\nhave inj_isom' := injm_Aut_isom (injm_invm injf) (morphimS _ sGD).\nrewrite card_injm ?injm_Aut_isom // -(card_injm inj_isom') ?subset_leq_card //.\napply/subsetP=> a /morphimP[a' _ AutfGa' def_a].\nby rewrite -(morphim_invm injf sGD) def_a Aut_Aut_isom.\nQed."
}
{
  "statement": "Lemma natr_prod_eq1 (I : finType) (P : pred I) (F : I -> R) :\n    (forall i, P i -> F i \\is a nat_num) -> \\prod_(i | P i) F i = 1 ->\n  forall i, P i -> F i = 1.\n",
  "proof": "Proof.\nmove=> natF /eqP; rewrite -prod_truncnK// -[1]/1%:R eqr_nat prod_nat_seq_eq1.\nmove/allP => a i Pi; apply/eqP; rewrite -[F i]truncnK ?natF// eqr_nat.\nby apply: implyP Pi; apply: a; apply: mem_index_enum.\nQed."
}
{
  "statement": "Lemma num_spec_sqrt (i : Itv.t) (x : num_def R i) (r := sqrt_itv i) :\n  num_spec r (Num.sqrt x%:num).\n",
  "proof": "Proof.\nhave: Itv.num_sem `[0%Z, +oo[ (Num.sqrt x%:num).\n  by apply/and3P; rewrite /= num_real !bnd_simp sqrtr_ge0.\nrewrite {}/r; case: i x => [//| [[bl [l |//] |//] u]] [x /= +] _.\ncase: bl l => -[| l] /and3P[xr /= bx _]; apply/and3P; split=> //=;\n  move: bx; rewrite !bnd_simp ?sqrtr_ge0// sqrtr_gt0;\n  [exact: lt_le_trans | exact: le_lt_trans..].\nQed."
}
{
  "statement": "Lemma divn_count_dvd d n : n %/ d = \\sum_(1 <= i < n.+1) (d %| i).\n",
  "proof": "Proof.\nhave [-> | d_gt0] := posnP d; first by rewrite big_add1 divn0 big1.\napply: (@addnI (d %| 0)); rewrite -(@big_ltn _ 0 _ 0 _ (dvdn d)) // big_mkord.\nrewrite (partition_big (fun i : 'I_n.+1 => inord (i %/ d)) 'I_(n %/ d).+1) //=.\nrewrite dvdn0 add1n -[_.+1 in LHS]card_ord -sum1_card.\napply: eq_bigr => [[q ?] _].\nrewrite (bigD1 (inord (q * d))) /eq_op /= !inordK ?ltnS -?leq_divRL ?mulnK //.\nrewrite dvdn_mull ?big1 // => [[i /= ?] /andP[/eqP <- /negPf]].\nby rewrite eq_sym dvdn_eq inordK ?ltnS ?leq_div2r // => ->.\nQed."
}
{
  "statement": "Lemma purely_inseparableP {K E} :\n  reflect (forall y, y \\in E -> purely_inseparable_element K y)\n          (purely_inseparable K E).\n",
  "proof": "Proof.\napply/(iffP idP)=> [/allP|] sep'K_E; last by apply/allP=> x /vbasis_mem/sep'K_E.\nmove=> y /coord_vbasis->; apply/inseparable_sum=> i _.\nhave: purely_inseparable_element K (vbasis E)`_i by apply/sep'K_E/memt_nth.\ncase/purely_inseparable_elementP_pchar=> n pcharLn K_Ein.\nby apply/purely_inseparable_elementP_pchar; exists n; rewrite // exprZn rpredZ.\nQed."
}
{
  "statement": "Lemma der1_sub_rker :\n    group_splitting_field G -> mx_irreducible rG ->\n  (G^`(1) \\subset rker rG)%g = (n == 1)%N.\n",
  "proof": "Proof.\nmove=> splitG irrG; apply/idP/idP; last by move/eqP; apply: rker_linear.\nmove/sub_der1_abelian; move/(abelian_abs_irr (kquo_repr rG))=> <-.\nby apply: (quotient_splitting_field (rker_norm _) splitG); apply/quo_mx_irr.\nQed."
}
{
  "statement": "Lemma morphpre_factm (C : {set rT}) : ff @*^-1 C =  q @* (f @*^-1 C).\n",
  "proof": "Proof.\napply/setP=> y /[!inE]/=; apply/andP/morphimP=> [[]|[x Hx]]; last first.\n  by case/morphpreP=> Gx Cfx ->; rewrite factmE ?imset_f ?inE ?Hx.\ncase/morphimP=> x Hx Gx ->; rewrite factmE //.\nby exists x; rewrite // !inE Gx.\nQed."
}
{
  "statement": "Lemma irr_prime_injP G i :\n  prime #|G| -> reflect {in G &, injective 'chi[G]_i} (i != 0).\n",
  "proof": "Proof.\nmove=> pr_G; apply: (iffP idP) => [nz_i | inj_chi].\n  apply: fful_lin_char_inj (irr_prime_lin i pr_G) _.\n  by rewrite cfaithfulE -(setIidPr (cfker_sub _)) prime_TIg // subGcfker.\nhave /trivgPn[x Gx ntx]: G :!=: 1%g by rewrite -cardG_gt1 prime_gt1.\napply: contraNneq ntx => i0; apply/eqP/inj_chi=> //.\nby rewrite i0 irr0 !cfun1E Gx group1.\nQed."
}
{
  "statement": "Lemma Frobenius_reg_ker : semiregular K H.\n",
  "proof": "Proof.\nmove=> x /setD1P[ntx Hx].\napply/trivgP/subsetP=> y /setIP[Ky cxy]; apply: contraR ntx => nty.\nhave K1y: y \\in K^# by rewrite inE nty.\nhave [/eqP/sdprod_context[_ sHG _ _ tiKH] _] := andP frobG.\nsuffices: x \\in K :&: H by rewrite tiKH inE.\nby rewrite inE (subsetP (Frobenius_cent1_ker K1y)) // inE cent1C (subsetP sHG).\nQed."
}
{
  "statement": "Lemma Ohm1_homocyclicP p G : p.-group G -> abelian G ->\n  reflect ('Ohm_1(G) = 'Mho^(logn p (exponent G)).-1(G)) (homocyclic G).\n",
  "proof": "Proof.\nmove=> pG cGG; set e := logn p (exponent G); rewrite -subn1.\napply: (iffP idP) => [homoG | ]; first exact: homocyclic_Ohm_Mho.\ncase: (ltnP 1 e) => [lt1e | ]; first exact: Ohm_Mho_homocyclic.\nrewrite -subn_eq0 => /eqP->; rewrite Mho0 => <-.\nexact: abelem_homocyclic (Ohm1_abelem pG cGG).\nQed."
}
{
  "statement": "Lemma pseries_catl_id pi1s pi2s gT (G : {group gT}) :\n  pseries pi1s (pseries (pi1s ++ pi2s) G) = pseries pi1s G.\n",
  "proof": "Proof.\nelim/last_ind: pi1s => [//|pi1s pi IHpi] in pi2s *.\napply: (@quotient_inj _ (pseries_group pi1s G)).\n- rewrite /= -(IHpi (pi :: pi2s)) cat_rcons /(_ <| _) pseries_norm2.\n  by rewrite -cats1 pseries_sub_catl.\n- by rewrite /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.\nrewrite /= cat_rcons -(IHpi (pi :: pi2s)) {1}quotient_pseries IHpi.\napply/eqP; rewrite quotient_pseries eqEsubset !pcore_max ?pcore_pgroup //=.\n  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.\n  by rewrite -cat_rcons pseries_sub_catl.\nby rewrite gFnormal_trans ?quotient_normal ?gFnormal.\nQed."
}
{
  "statement": "Lemma normal_sylowP G :\n  reflect (exists2 P : {group gT}, p.-Sylow(G) P & P <| G)\n          (#|'Syl_p(G)| == 1%N).\n",
  "proof": "Proof.\napply: (iffP idP) => [syl1 | [P sylP nPG]]; last first.\n  by rewrite (card_Syl sylP) (setIidPl _) (indexgg, normal_norm).\nhave [P sylP] := Sylow_exists p G; exists P => //.\nrewrite /normal (pHall_sub sylP); apply/setIidPl; apply/eqP.\nrewrite eqEcard subsetIl -(LagrangeI G 'N(P)) -indexgI /=.\nby rewrite -(card_Syl sylP) (eqP syl1) muln1.\nQed."
}
{
  "statement": "Lemma freeP n (X : n.-tuple vT) :\n  reflect (forall k, \\sum_(i < n) k i *: X`_i = 0 -> (forall i, k i = 0))\n          (free X).\n",
  "proof": "Proof.\nrewrite free_b2mx; apply: (iffP idP) => [t_free k kt0 i | t_free].\n  suffices /rowP/(_ i): \\row_i k i = 0 by rewrite !mxE.\n  by apply/(row_free_inj t_free)/r2v_inj; rewrite mul0mx -lin_b2mx kt0 linear0.\nrewrite -kermx_eq0; apply/rowV0P=> rk /sub_kermxP kt0.\nby apply/rowP=> i; rewrite mxE {}t_free // mul_b2mx kt0 linear0.\nQed."
}
{
  "statement": "Lemma big_enum_val_cond (I : finType) (A : pred I) (P : pred I) F :\n  \\big[op/x]_(x in A | P x) F x =\n  \\big[op/x]_(i < #|A| | P (enum_val i)) F (enum_val i).\n",
  "proof": "Proof.\nhave [A_eq0|/card_gt0P[x0 x0A]] := posnP #|A|.\n  rewrite !big_pred0 // => i; last by rewrite card0_eq.\n  by have: false by move: i => []; rewrite A_eq0.\nrewrite (reindex (enum_val : 'I_#|A| -> I)).\n  by apply: eq_big => [y|y Py]; rewrite ?enum_valP.\nby apply: subon_bij (enum_val_bij_in x0A) => y /andP[].\nQed."
}
{
  "statement": "Lemma morphim_p_rank_abelian p G : abelian G -> 'r_p(f @* G) <= 'r_p(G).\n",
  "proof": "Proof.\nmove=> cGG; have sHG := subsetIr D G; apply: leq_trans (p_rankS p sHG).\nhave cHH := abelianS sHG cGG; rewrite -morphimIdom /=; set H := D :&: G.\nhave sylP := nilpotent_pcore_Hall p (abelian_nil cHH).\nhave sPH := pHall_sub sylP.\nhave sPD: 'O_p(H) \\subset D by rewrite (subset_trans sPH) ?subsetIl.\nrewrite -(p_rank_Sylow (morphim_pHall f sPD sylP)) -(p_rank_Sylow sylP) //.\nrewrite -!rank_pgroup ?morphim_pgroup ?pcore_pgroup //.\nby rewrite morphim_rank_abelian ?(abelianS sPH).\nQed."
}
{
  "statement": "Lemma uniq_leq_size s1 s2 : uniq s1 -> {subset s1 <= s2} -> size s1 <= size s2.\n",
  "proof": "Proof.\nelim: s1 s2 => //= x s1 IHs s2 /andP[not_s1x Us1] /forall_cons[s2x ss12].\nhave [i s3 def_s2] := rot_to s2x; rewrite -(size_rot i s2) def_s2.\napply: IHs => // y s1y; have:= ss12 y s1y.\nby rewrite -(mem_rot i) def_s2 inE (negPf (memPn _ y s1y)).\nQed."
}
{
  "statement": "Lemma cent_classP x G : reflect (x ^: G = [set x]) (x \\in 'C(G)).\n",
  "proof": "Proof.\napply: (iffP (centP _ _)) => [Cx | Cx1 y Gy].\n  apply/eqP; rewrite eqEsubset sub1set class_refl andbT.\n  by apply/subsetP=> _ /imsetP[y Gy ->]; rewrite !inE conjgE Cx ?mulKg.\nby apply/commgP/conjg_fixP/set1P; rewrite -Cx1; apply/imsetP; exists y.\nQed."
}
{
  "statement": "Lemma eq_expg_mod_order m n : (a ^+ m == a ^+ n) = (m == n %[mod #[a]]).\n",
  "proof": "Proof.\nhave [->|] := eqVneq a 1; first by rewrite order1 !modn1 !expg1n eqxx.\nrewrite -order_gt1 => lt1a; have ZpT: Zp #[a] = setT by rewrite /Zp lt1a.\nhave: injective Zpm by move=> i j; apply (injmP injm_Zpm); rewrite /= ZpT inE.\nmove/inj_eq=> eqZ; symmetry; rewrite -(Zp_cast lt1a).\nby rewrite -[_ == _](eqZ (inZp m) (inZp n)) /Zpm /= Zp_cast ?expg_mod_order.\nQed."
}
{
  "statement": "Lemma quo_mx_quotient : (E_ rGH :=: E_ rG)%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split; apply/row_subP=> i.\n  rewrite rowK; case/morphimP: (enum_valP i) => x _ Gx ->{i}.\n  rewrite quo_repr_coset // (eq_row_sub (enum_rank_in Gx x)) // rowK.\n  by rewrite enum_rankK_in.\nrewrite rowK -(quo_mx_coset krH nHG) ?enum_valP //; set Hx := coset H _.\nhave GHx: Hx \\in (G / H)%g by rewrite mem_quotient ?enum_valP.\nby rewrite (eq_row_sub (enum_rank_in GHx Hx)) // rowK enum_rankK_in.\nQed."
}
{
  "statement": "Lemma is_isoP : forall p, reflect (is_iso p) (p \\in isometries).\n",
  "proof": "Proof.\nmove=> p; apply: (iffP idP) => [|iso_p]; first exact: isometries_iso.\nmove e1: (p c1) (iso_p c1) => k1; move e0: (p c0) (iso_p c0) k1 e1 => k0.\ncase: k0 e0; do 4?[case] => //= ? e0 e2; do 5?[case] => //= ? e1 e3;\n try by [non_inj p c0 c1 e0 e1 | non_inj p c0 c3 e0 e3].\nby is_isoPtac p id1 e0 e1 e2 e3.\nby is_isoPtac p sd1 e0 e1 e2 e3.\nby is_isoPtac p sh e0 e1 e2 e3.\nby is_isoPtac p r1 e0 e1 e2 e3.\nby is_isoPtac p sd2 e0 e1 e2 e3.\nby is_isoPtac p r2 e0 e1 e2 e3.\nby is_isoPtac p r3 e0 e1 e2 e3.\nby is_isoPtac p sv e0 e1 e2 e3.\nQed."
}
{
  "statement": "Lemma Aut_isom_subproof a :\n  {a' | a' \\in Aut (f @* G) & a \\in Aut G -> {in G, a' \\o f =1 f \\o a}}.\n",
  "proof": "Proof.\nset Aut_a := autm (subgP (subg [Aut G] a)).\nhave aDom: 'dom (f \\o Aut_a \\o invm injf) = f @* G.\n  rewrite /dom /= morphpre_invm -morphpreIim; congr (f @* _).\n  by rewrite [_ :&: D](setIidPl _) ?injmK ?injm_autm ?im_autm.\nhave [af [def_af ker_af _ im_af]] := domP _ aDom.\nhave inj_a': 'injm af by rewrite ker_af !injm_comp ?injm_autm ?injm_invm.\nhave im_a': af @* (f @* G) = f @* G.\n  by rewrite im_af !morphim_comp morphim_invm // im_autm.\npose a' := aut inj_a' im_a'; exists a' => [|AutGa x Gx]; first exact: Aut_aut.\nhave Dx := domG Gx; rewrite /= [a' _]autE ?mem_morphim //.\nby rewrite def_af /= invmE // autmE subgK.\nQed."
}
{
  "statement": "Lemma perm_sortP (T : eqType) (leT : rel T) :\n  total leT -> transitive leT -> antisymmetric leT ->\n  forall s1 s2, reflect (sort leT s1 = sort leT s2) (perm_eq s1 s2).\n",
  "proof": "Proof.\nmove=> leT_total leT_tr leT_asym s1 s2.\napply: (iffP idP) => eq12; last by rewrite -(perm_sort leT) eq12 perm_sort.\napply: (sorted_eq leT_tr leT_asym); rewrite ?sort_sorted //.\nby rewrite perm_sort (permPl eq12) -(perm_sort leT).\nQed."
}
{
  "statement": "Lemma max_cfRepr_mx1 n (rG : mx_representation algC G n) x :\n   x \\in G -> cfRepr rG x = cfRepr rG 1%g -> rG x = 1%:M.\n",
  "proof": "Proof.\nmove=> Gx kerGx; have [|c _ def_x] := @max_cfRepr_norm_scalar n rG x Gx.\n  by rewrite kerGx cfRepr1 normr_nat.\nmove/eqP: kerGx; rewrite cfRepr1 cfunE Gx {rG}def_x mxtrace_scalar.\ncase: n => [_|n]; first by rewrite ![_%:M]flatmx0.\nrewrite mulrb -subr_eq0 -mulrnBl -mulr_natl mulf_eq0 pnatr_eq0 /=.\nby rewrite subr_eq0 => /eqP->.\nQed."
}
{
  "statement": "Lemma eq_prim_root_expr i j : (z ^+ i == z ^+ j) = (i == j %[mod n]).\n",
  "proof": "Proof.\nwlog le_ji: i j / j <= i.\n  move=> IH; case: (leqP j i) => [|/ltnW] /IH //.\n  by rewrite eq_sym (eq_sym (j %% n)%N).\nrewrite -{1}(subnKC le_ji) exprD -prim_expr_mod eqn_mod_dvd //.\nrewrite prim_order_dvd; apply/eqP/eqP=> [|->]; last by rewrite mulr1.\nmove/(congr1 ( *%R (z ^+ (n - j %% n)))); rewrite mulrA -exprD.\nby rewrite subnK ?prim_expr_order ?mul1r // ltnW ?ltn_mod.\nQed."
}
{
  "statement": "Lemma Gauss_gcdpr p m n : coprimep p m -> gcdp p (m * n) %= gcdp p n.\n",
  "proof": "Proof.\nmove=> co_pm; apply/eqP; rewrite /eqp !dvdp_gcd !dvdp_gcdl /= andbC.\nrewrite dvdp_mull ?dvdp_gcdr // -(@Gauss_dvdpl _ m).\n  by rewrite mulrC dvdp_gcdr.\napply/coprimepP=> d; rewrite dvdp_gcd; case/andP=> hdp _ hdm.\nby move/coprimepP: co_pm; apply.\nQed."
}
{
  "statement": "Lemma mx_iso_simple U V : mx_iso U V -> mxsimple U -> mxsimple V.\n",
  "proof": "Proof.\nmove=> isoUV [modU nzU simU]; have [f injf homUf defV] := isoUV.\nsplit=> [||W modW sWV nzW]; first by rewrite (mx_iso_module isoUV).\n  by rewrite -(eqmx_eq0 defV) -(mul0mx n f) (can_eq (mulmxK injf)).\nrewrite -defV -[W](mulmxKV injf) submxMr //; set W' := W *m _.\nhave sW'U: (W' <= U)%MS by rewrite -[U](mulmxK injf) submxMr ?defV.\nrewrite (simU W') //; last by rewrite -(can_eq (mulmxK injf)) mul0mx mulmxKV.\nrewrite hom_mxmodule ?dom_hom_invmx // -[W](mulmxKV injf) submxMr //.\nexact: submx_trans sW'U homUf.\nQed."
}
{
  "statement": "Lemma p_index_maximal : M \\subset P -> prime #|P : M| -> maximal M P.\n",
  "proof": "Proof.\nmove=> sMP /primeP[lt1PM pr_PM].\napply/maxgroupP; rewrite properEcard sMP -(Lagrange sMP).\nrewrite -{1}(muln1 #|M|) ltn_pmul2l //; split=> // H sHP sMH.\napply/eqP; rewrite eq_sym eqEcard sMH.\ncase/orP: (pr_PM _ (indexSg sMH (proper_sub sHP))) => /eqP iM.\n  by rewrite -(Lagrange sMH) iM muln1 /=.\nby have:= proper_card sHP; rewrite -(Lagrange sMH) iM Lagrange ?ltnn.\nQed."
}
{
  "statement": "Lemma rker_gen : rker rGA = rker rG.\n",
  "proof": "Proof.\napply/setP=> g; rewrite !inE !mul1mx; case Gg: (g \\in G) => //=.\napply/eqP/eqP=> g1; apply/row_matrixP=> i.\n  by apply: (can_inj in_genK); rewrite rowE in_genJ //= g1 mulmx1 row1.\nby apply: (can_inj val_genK); rewrite rowE val_genJ //= g1 mulmx1 row1.\nQed."
}
{
  "statement": "Lemma totient_gen : totient #[a] = #|[set x | generator <[a]> x]|.\n",
  "proof": "Proof.\nhave [lea1 | lt1a] := leqP #[a] 1.\n  rewrite /order card_le1_trivg // cards1 (@eq_card1 _ 1) // => x.\n  by rewrite !inE -cycle_eq1 eq_sym.\nrewrite -(card_injm (injm_invm (injm_Zpm a))) /= ?im_Zpm; last first.\n  by apply/subsetP=> x /[1!inE]; apply: cycle_generator.\nrewrite -card_units_Zp // cardsE card_sub morphim_invmE; apply: eq_card => /= d.\nby rewrite !inE /= qualifE /= /Zp lt1a inE /= generator_coprime {1}Zp_cast.\nQed."
}
{
  "statement": "Lemma subset_leqif_card A B : A \\subset B -> #|A| <= #|B| ?= iff (B \\subset A).\n",
  "proof": "Proof.\nmove=> sAB; split; [exact: subset_leq_card | apply/eqP/idP].\n  by move/subset_cardP=> sABP; rewrite (eq_subset_r (sABP sAB)).\nby move=> sBA; apply: eq_card; apply/subset_eqP; rewrite sAB.\nQed."
}
{
  "statement": "Lemma addsmxA m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A + (B + C) = A + B + C)%MS.\n",
  "proof": "Proof.\nhave: (A + (B + C) :=: A + B + C)%MS.\n  by apply/eqmxP/andP; rewrite !addsmx_sub -andbA andbA -!addsmx_sub.\nrewrite {1 3}[in @addsmx _ m1]unlock [in @addsmx _ n]unlock !addsmx_nop_id -!submx0.\nrewrite !addsmx_sub ![@addsmx]unlock -!submx0; move/eq_genmx.\nby do 3!case: (_ <= 0)%MS; rewrite //= !genmx_id.\nQed."
}
{
  "statement": "Lemma joins_disjoint (I : finType) (d : L) (P : {pred I}) (F : I -> L) :\n   (forall i : I, P i -> d `&` F i = \\bot) -> d `&` \\join_(i | P i) F i = \\bot.\n",
  "proof": "Proof.\nmove=> d_Fi_disj; have : \\big[andb/true]_(i | P i) (d `&` F i == \\bot).\n  rewrite big_all_cond; apply/allP => i _ /=.\n  by apply/implyP => /d_Fi_disj ->.\nelim/big_rec2: _ => [|i y]; first by rewrite meetx0.\ncase; rewrite (andbF, andbT) // => Pi /(_ isT) dy /eqP dFi.\nby rewrite meetUr dy dFi joinxx.\nQed."
}
{
  "statement": "Lemma aimgM (f : ahom aT rT) U V : (f @: (U * V) = f @: U * f @: V)%VS.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubv; apply/andP; split; last first.\n  apply/prodvP=> _ _ /memv_imgP[u Hu ->] /memv_imgP[v Hv ->].\n  by rewrite -rmorphM memv_img // memv_mul.\napply/subvP=> _ /memv_imgP[w UVw ->]; rewrite memv_preim (subvP _ w UVw) //.\nby apply/prodvP=> u v Uu Vv; rewrite -memv_preim rmorphM memv_mul // memv_img.\nQed."
}
{
  "statement": "Lemma cfker_reg_quo G H : H <| G -> cfker (cfReg (G / H)%g %% H) = H.\n",
  "proof": "Proof.\nmove=> nsHG; have [sHG nHG] := andP nsHG.\napply/setP=> x; rewrite cfkerEchar ?cfMod_char ?cfReg_char //.\nrewrite -[in RHS in _ = RHS](setIidPr sHG) !inE; apply: andb_id2l => Gx.\nrewrite !cfModE // !cfRegE // morph1 eqxx.\nrewrite (sameP eqP (kerP _ (subsetP nHG x Gx))) ker_coset.\nby rewrite -!mulrnA eqr_nat eqn_pmul2l ?cardG_gt0 // (can_eq oddb) eqb_id.\nQed."
}
{
  "statement": "Lemma vsolve_eqP (U : {vspace vT}) :\n  reflect (exists2 u, u \\in U & forall i, tnth lhs i u = tnth rhs i)\n          (vsolve_eq U).\n",
  "proof": "Proof.\nhave lhsZ: linear lhsf by move=> a u v; apply/ffunP=> i; rewrite !ffunE linearP.\npose lhslM := GRing.isLinear.Build _ _ _ _ lhsf lhsZ.\npose lhsL : {linear _ -> _} := HB.pack lhsf lhslM.\napply: (iffP memv_imgP) => [] [u Uu sol_u]; exists u => //.\n  by move=> i; rewrite -[tnth rhs i]ffunE sol_u (lfunE lhsL) ffunE.\nby apply/ffunP=> i; rewrite (lfunE lhsL) !ffunE sol_u.\nQed."
}
{
  "statement": "Lemma num_spec_sub (x y : Itv.t) : Itv.sub x y ->\n  forall z : R, num_spec x z -> num_spec y z.\n",
  "proof": "Proof.\ncase: x y => [| x] [| y] //= x_sub_y z /andP[rz]; rewrite /Itv.num_sem rz/=.\nmove: x y x_sub_y => [lx ux] [ly uy] /andP[lel leu] /=.\nmove=> /andP[lxz zux]; apply/andP; split.\n- by apply: le_trans lxz; rewrite le_num_itv_bound.\n- by apply: le_trans zux _; rewrite le_num_itv_bound.\nQed."
}
{
  "statement": "Lemma fconnect_cycle y : fconnect f x y = (y \\in p).\n",
  "proof": "Proof.\nhave [i q def_p] := rot_to p_x; rewrite -(mem_rot i p) def_p.\nhave{i def_p} /andP[/eqP q_x f_q]: (f (last x q) == x) && fpath f x q.\n  by have:= f_p; rewrite -(rot_cycle i) def_p (cycle_path x).\napply/idP/idP=> [/connectP[_ /fpathP[j ->] ->] | ]; last exact: path_connect.\ncase/fpathP: f_q q_x => n ->; rewrite !last_traject -iterS => def_x.\nby apply: (@loopingP _ f x n.+1); rewrite /looping def_x /= mem_head.\nQed."
}
{
  "statement": "Lemma real_eqr_norml x y :\n  x \\is real -> (`|x| == y) = ((x == y) || (x == -y)) && (0 <= y).\n",
  "proof": "Proof.\nmove=> Rx.\napply/idP/idP=> [|/andP[/pred2P[]-> /ger0_norm/eqP]]; rewrite ?normrE //.\ncase: real_le0P => // hx; rewrite 1?eqr_oppLR => /eqP exy.\n  by move: hx; rewrite exy ?oppr_le0 eqxx orbT //.\nby move: hx=> /ltW; rewrite exy eqxx.\nQed."
}
{
  "statement": "Lemma p_rankElem_max p A : 'E_p^('r_p(A))(A) \\subset 'E*_p(A).\n",
  "proof": "Proof.\napply/subsetP=> E /setIdP[EpE dimE].\napply/pmaxElemP; split=> // F EpF sEF; apply/eqP.\nhave pF: p.-group F by case/pElemP: EpF => _ /and3P[].\nhave pE: p.-group E by case/pElemP: EpE => _ /and3P[].\nrewrite eq_sym eqEcard sEF dvdn_leq // (card_pgroup pE) (card_pgroup pF).\nby rewrite (eqP dimE) dvdn_exp2l // logn_le_p_rank.\nQed."
}
{
  "statement": "Lemma cfcenter_subset_center chi :\n  ('Z(chi)%CF / cfker chi)%g \\subset 'Z(G / cfker chi)%g.\n",
  "proof": "Proof.\ncase Nchi: (chi \\is a character); last first.\n  by rewrite /cfcenter Nchi trivg_quotient sub1G.\nrewrite subsetI quotientS ?cfcenter_sub // quotient_cents2r //=.\ncase/char_reprP: Nchi => rG ->{chi}; rewrite cfker_repr cfcenter_repr gen_subG.\napply/subsetP=> _ /imset2P[x y /setIdP[Gx /is_scalar_mxP[c rGx]] Gy ->].\nrewrite inE groupR //= !repr_mxM ?groupM ?groupV // rGx -(scalar_mxC c) -rGx.\nby rewrite !mulmxA !repr_mxKV.\nQed."
}
{
  "statement": "Lemma normalField_ker : 'ker normalField_cast = 'Gal(E / M).\n",
  "proof": "Proof.\nhave [sKM sME] := andP sKME.\napply/setP=> x; apply/idP/idP=> [kerMx | galEMx].\n  rewrite gal_kHom //; apply/kAHomP=> a Ma.\n  by rewrite -normalField_cast_eq ?(dom_ker kerMx) // (mker kerMx) gal_id.\nhave galEM: x \\in 'Gal(E / K) := subsetP (galS E sKM) x galEMx.\napply/kerP=> //; apply/eqP/gal_eqP=> a Ma.\nby rewrite normalField_cast_eq // gal_id (fixed_gal sME).\nQed."
}
{
  "statement": "Lemma set_mulgA : associative set_mulg.\n",
  "proof": "Proof.\nmove=> A B C; apply/setP=> y.\napply/imset2P/imset2P=> [[x1 z Ax1 /imset2P[x2 x3 Bx2 Cx3 ->] ->]| [z x3]].\n  by exists (x1 * x2) x3; rewrite ?mulgA //; apply/imset2P; exists x1 x2.\ncase/imset2P=> x1 x2 Ax1 Bx2 -> Cx3 ->.\nby exists x1 (x2 * x3); rewrite ?mulgA //; apply/imset2P; exists x2 x3.\nQed."
}
{
  "statement": "Lemma astab_actby S : 'C(S | <[nRA]>) = 'C_A(R :&: S | to).\n",
  "proof": "Proof.\napply/setP=> a; rewrite setIA (setIidPl (acts_dom nRA)) !inE.\ncase Aa: (a \\in A) => //=; apply/subsetP/subsetP=> cRSa x => [|Sx].\n  by case/setIP=> Rx /cRSa; rewrite !inE actbyE.\nby have:= cRSa x; rewrite !inE /= /actby Aa Sx; case: (x \\in R) => //; apply.\nQed."
}
{
  "statement": "Lemma rgcdp_loopT_qf (n : nat) (p : polyF) (q : polyF) :\n  rpoly p -> rpoly q -> qf_cps rpoly (rgcdp_loopT n p q).\n",
  "proof": "Proof.\nelim: n => [|n IHn] in p q * => rp rq /=;\n(apply: qf_cps_bind=> [|rr rrr]; [\n  apply: qf_cps_bind => [|[[a u] v]]; do ?exact: redivpT_qf;\n  by move=> /andP[/= ??]; apply: (@qf_cps_ret _ rpoly)|\napply: qf_cps_bind => [|[] _];\nby [apply: isnull_qf|apply: qf_cps_ret|apply: IHn]]).\nQed."
}
{
  "statement": "Lemma cfnorm_eq0 phi : ('[phi] == 0) = (phi == 0).\n",
  "proof": "Proof.\napply/idP/eqP=> [|->]; last by rewrite cfdot0r.\nrewrite mulf_eq0 invr_eq0 (negbTE (neq0CG G)) /= => /eqP/psumr_eq0P phi0.\napply/cfun_inP=> x Gx; apply/eqP; rewrite cfunE -mul_conjC_eq0.\nby rewrite phi0 // => y _; apply: mul_conjC_ge0.\nQed."
}
{
  "statement": "Lemma rfix_submod (H : {set gT}) :\n  H \\subset G -> (rfix_mx rU H :=: in_submod U (U :&: rfix_mx rG H))%MS.\n",
  "proof": "Proof.\nmove=> sHG; apply/eqmxP/andP; split; last first.\n  apply/rfix_mxP=> x Hx; rewrite -in_submodJ ?capmxSl //.\n  by rewrite (rfix_mxP H _) ?capmxSr.\nrewrite -val_submodS in_submodK ?capmxSl // sub_capmx val_submodP //=.\napply/rfix_mxP=> x Hx.\nby rewrite -(val_submodJ Umod) ?(subsetP sHG) ?rfix_mx_id.\nQed."
}
{
  "statement": "Lemma card_gt2P A :\n  reflect (exists x y z,\n              [/\\ x \\in A, y \\in A & z \\in A] /\\ [/\\ x != y, y != z & z != x])\n          (2 < #|A|).\n",
  "proof": "Proof.\napply: (iffP card_geqP) => [[s] []|[x] [y] [z] [[xD yD zD] [xDy xDz yDz]]].\n  case: s => [|x [|y [|z []]]]//=; rewrite !inE !andbT negb_or -andbA.\n  case/and3P => xDy xDz yDz _ subA.\n  by exists x, y, z; rewrite xDy yDz eq_sym xDz !subA ?inE ?eqxx ?orbT.\nexists [:: x; y; z]; rewrite /= !inE negb_or xDy xDz eq_sym yDz; split=> // u.\nby rewrite !inE => /or3P [] /eqP->.\nQed."
}
{
  "statement": "Lemma morphimMl A B : A \\subset D -> f @* (A * B) = f @* A * f @* B.\n",
  "proof": "Proof.\nmove=> sAD; rewrite /morphim setIC -group_modl // (setIidPr sAD).\napply/setP=> fxy; apply/idP/idP.\n  case/imsetP=> _ /imset2P[x y Ax /setIP[Dy By] ->] ->{fxy}.\n  by rewrite morphM // (subsetP sAD, imset2_f) // imset_f // inE By.\ncase/imset2P=> _ _ /imsetP[x Ax ->] /morphimP[y Dy By ->] ->{fxy}.\nby rewrite -morphM // (subsetP sAD, imset_f) // mem_mulg // inE By.\nQed."
}
{
  "statement": "Lemma commG1P A B : reflect ([~: A, B] = 1) (A \\subset 'C(B)).\n",
  "proof": "Proof.\napply: (iffP (centsP A B)) => [cAB | cAB1 x Ax y By].\n  apply/trivgP; rewrite gen_subG; apply/subsetP=> _ /imset2P[x y Ax Ay ->].\n  by rewrite inE; apply/commgP; apply: cAB.\nby apply/commgP; rewrite -in_set1 -[[set 1]]cAB1 mem_commg.\nQed."
}
{
  "statement": "Lemma max_cfRepr_norm_scalar n (rG : mx_representation algC G n) x :\n     x \\in G -> `|cfRepr rG x| = cfRepr rG 1%g ->\n   exists2 c, `|c| = 1 & rG x = c%:M.\n",
  "proof": "Proof.\nmove=> Gx; have [e [[B uB def_x] [_ e1] [-> _] _]] := repr_rsim_diag rG Gx.\nrewrite cfRepr1 -[n in n%:R]card_ord -sumr_const -(eq_bigr _ (in1W e1)).\ncase/normC_sum_eq1=> [i _ | c /eqP norm_c_1 def_e]; first by rewrite e1.\nhave{} def_e: e = const_mx c by apply/rowP=> i; rewrite mxE def_e ?andbT.\nby exists c => //; rewrite def_x def_e diag_const_mx scalar_mxC mulmxKV.\nQed."
}
{
  "statement": "Lemma block_mxA m1 m2 m3 n1 n2 n3\n   (A11 : 'M_(m1, n1)) (A12 : 'M_(m1, n2)) (A13 : 'M_(m1, n3))\n   (A21 : 'M_(m2, n1)) (A22 : 'M_(m2, n2)) (A23 : 'M_(m2, n3))\n   (A31 : 'M_(m3, n1)) (A32 : 'M_(m3, n2)) (A33 : 'M_(m3, n3)) :\n  let cast := (esym (addnA m1 m2 m3), esym (addnA n1 n2 n3)) in\n  let row1 := row_mx A12 A13 in let col1 := col_mx A21 A31 in\n  let row3 := row_mx A31 A32 in let col3 := col_mx A13 A23 in\n  block_mx A11 row1 col1 (block_mx A22 A23 A32 A33)\n    = castmx cast (block_mx (block_mx A11 A12 A21 A22) col3 row3 A33).\n",
  "proof": "Proof.\nrewrite /= block_mxEh !col_mxA -cast_row_mx -block_mxEv -block_mxEh.\nrewrite block_mxEv block_mxEh !row_mxA -cast_col_mx -block_mxEh -block_mxEv.\nby rewrite castmx_comp etrans_id.\nQed."
}
{
  "statement": "Lemma num_spec_intmul (xi ii : Itv.t) (x : num_def R xi) (i : num_def int ii)\n    (r := natmul_itv xi ii) :\n  num_spec r (x%:num *~ i%:num).\n",
  "proof": "Proof.\nrewrite {}/r; case: xi x ii i => [//| xi] x [| ii] i.\n  by apply/and3P; case: i%:inum => [[|n] | n]; rewrite ?mulr0z ?realN ?realrMn.\nhave Pi : num_spec (Itv.Real ii) (i%:num%:~R : R).\n  by case: i => /= i; rewrite [Itv.num_sem ii i](num_spec_int (Itv.Real ii)).\nrewrite -mulrzr -[i%:num%:~R]/((Itv.Def Pi)%:num).\nby rewrite (@num_spec_mul (Itv.Real xi) (Itv.Real ii)).\nQed."
}
{
  "statement": "Lemma mupM x q1 q2 : q1 != 0 -> q2 != 0 ->\n  mup x (q1 * q2) = (mup x q1 + mup x q2)%N.\n",
  "proof": "Proof.\nmove=> q1N0 q2N0; apply/eqP; rewrite eqn_leq mup_leq ?mulf_neq0//.\nrewrite mup_geq ?mulf_neq0// exprD ?dvdp_mul; do ?by rewrite -mup_geq.\nhave [m1 [r1]] := multiplicity_XsubC q1 x; rewrite q1N0 /= => r1Nx ->.\nhave [m2 [r2]] := multiplicity_XsubC q2 x; rewrite q2N0 /= => r2Nx ->.\nrewrite !mupMr// ?mup_XsubCX eqxx/= mulrACA exprS exprD.\nrewrite dvdp_mul2r ?mulf_neq0 ?expf_neq0 ?polyXsubC_eq0//.\nby rewrite dvdp_XsubCl rootM negb_or r1Nx r2Nx.\nQed."
}
{
  "statement": "Lemma Wedderburn_center_pchar :\n  ('Z(R_G) :=: \\matrix_(i < #|sG|) mxvec 'e_(enum_val i))%MS.\n",
  "proof": "Proof.\nhave:= mxdirect_sums_center\n  Wedderburn_sum_pchar Wedderburn_direct Wedderburn_ideal.\nmove/eqmx_trans; apply; apply/eqmxP/andP; split.\n  apply/sumsmx_subP=> i _; rewrite Wedderburn_subring_center_pchar.\n  by apply: (eq_row_sub (enum_rank i)); rewrite rowK enum_rankK.\napply/row_subP=> i; rewrite rowK -Wedderburn_subring_center_pchar.\nby rewrite (sumsmx_sup (enum_val i)).\nQed."
}
{
  "statement": "Lemma cfConjgBigdprodi i (phi : 'CF(A i)) :\n   (cfBigdprodi defG phi ^ y = cfBigdprodi defG (phi ^ y))%CF.\n",
  "proof": "Proof.\nrewrite cfConjgDprodl; try by case: ifP => [/nAy// | _]; rewrite norm1 inE.\n  congr (cfDprodl _ _); case: ifP => [Pi | _].\n    by rewrite cfConjgRes_norm ?nAy.\n  by apply/cfun_inP=> _ /set1P->; rewrite !(cfRes1, cfConjg1).\nrewrite -sub1set norms_gen ?norms_bigcup // sub1set.\nby apply/bigcapP=> j /andP[/nAy].\nQed."
}
{
  "statement": "Lemma astabs_actby S : 'N(S | <[nRA]>) = 'N_A(R :&: S | to).\n",
  "proof": "Proof.\napply/setP=> a; rewrite setIA (setIidPl (acts_dom nRA)) !inE.\ncase Aa: (a \\in A) => //=; apply/subsetP/subsetP=> nRSa x => [|Sx].\n  by case/setIP=> Rx /nRSa; rewrite !inE actbyE ?(acts_act nRA) ?Rx.\nhave:= nRSa x; rewrite !inE /= /actby Aa Sx ?(acts_act nRA) //.\nby case: (x \\in R) => //; apply.\nQed."
}
{
  "statement": "Lemma sdprod_recr n G K H H1 :\n    #|G| <= n -> K ><| H = G -> H1 \\proper H ->\n  exists G1 : {group gT}, [/\\ #|G1| < n, G1 \\subset G & K ><| H1 = G1].\n",
  "proof": "Proof.\nmove=> leGn; case/sdprodP=> _ defG nKH tiKH ltH1H.\nhave [sH1H _] := andP ltH1H; have nKH1 := subset_trans sH1H nKH.\nhave tiKH1: K :&: H1 = 1 by apply/trivgP; rewrite -tiKH setIS.\nexists (K <*> H1)%G; rewrite /= -defG sdprodE // norm_joinEr //.\nrewrite ?mulgS // ?(leq_trans _ leGn) //=.\nby rewrite -defG ?TI_cardMg // ltn_pmul2l ?proper_card.\nQed."
}
{
  "statement": "Lemma exponent_pX1p2 : odd p -> exponent p^{1+2} %| p.\n",
  "proof": "Proof.\nmove=> p_odd; have pG := pX1p2_pgroup.\nhave ->: p^{1+2} = 'Ohm_1(p^{1+2}).\n  apply/eqP; rewrite eqEsubset Ohm_sub andbT (OhmE 1 pG).\n  case/existsP: (isoGrp_hom Grp_pX1p2) => [[x y]] /=.\n  case/eqP=> <- xp yp _ _; rewrite joing_idl joing_idr genS //.\n  by rewrite subsetI subset_gen subUset !sub1set !inE xp yp!eqxx.\nrewrite exponent_Ohm1_class2 ?card_pX1p2 ?oddX // nil_class2.\nby have [[_ ->] _ ] := pX1p2_extraspecial.\nQed."
}
{
  "statement": "Lemma pX1p2n_extraspecial n : prime p -> n > 0 -> extraspecial p^{1+2*n}.\n",
  "proof": "Proof.\nmove=> p_pr; elim: n => [//|n IHn _].\nhave esG := pX1p2_extraspecial p_pr.\nhave [n0 | n_gt0] := posnP n.\n  by apply: isog_extraspecial esG; rewrite isog_sym n0 pX1p2id.\ncase: pX1p2S (pX1p2n_pgroup n.+1 p_pr) => gz isoZ pGn.\napply: (cprod_extraspecial pGn (im_cpair_cprod isoZ) (setI_im_cpair isoZ)).\n  by apply: injm_extraspecial esG; rewrite ?injm_cpairg1.\nby apply: injm_extraspecial (IHn n_gt0); rewrite ?injm_cpair1g.\nQed."
}
{
  "statement": "Lemma astab_trans_gcore G S u :\n  [transitive G, on S | to] -> u \\in S -> 'C(S | to) = gcore 'C[u | to] G.\n",
  "proof": "Proof.\nmove=> transG Su; apply/eqP; rewrite eqEsubset.\nrewrite gcore_max ?astabS ?sub1set //=; last first.\n  exact: subset_trans (atrans_acts transG) (astab_norm _ _).\napply/subsetP=> x cSx; apply/astabP=> uy.\ncase/(atransP2 transG Su) => y Gy ->{uy}.\nby apply/astab1P; rewrite astab1_act (bigcapP cSx).\nQed."
}
{
  "statement": "Lemma irreducible_poly_coprime (A : idomainType) (p q : {poly A}) :\n  irreducible_poly p -> coprimep p q = ~~(p %| q)%R.\n",
  "proof": "Proof.\ncase => H1 H2; apply/coprimepP/negP.\n  move=> sPq H.\n  by have := sPq p (dvdpp _) H; rewrite -size_poly_eq1; case: size H1 => [|[]].\nmove=> pNDq d dDp dPq.\nrewrite -size_poly_eq1; case: eqP => // /eqP /(H2 _) => /(_ dDp) dEp.\nby case: pNDq; rewrite -(eqp_dvdl _ dEp).\nQed."
}
{
  "statement": "Lemma nilpotent_pcoreC pi G : nilpotent G -> 'O_pi(G) \\x 'O_pi^'(G) = G.\n",
  "proof": "Proof.\nmove=> nilG; have trO: 'O_pi(G) :&: 'O_pi^'(G) = 1.\n  by apply: coprime_TIg; apply: (@pnat_coprime pi); apply: pcore_pgroup.\nrewrite dprodE //.\n  apply/eqP; rewrite eqEcard mul_subG ?pcore_sub // (TI_cardMg trO).\n  by rewrite !(card_Hall (nilpotent_pcore_Hall _ _)) // partnC ?leqnn.\nrewrite (sameP commG1P trivgP) -trO subsetI commg_subl commg_subr.\nby rewrite !gFsub_trans ?gFnorm.\nQed."
}
{
  "statement": "Lemma sizeYE u : sizeY u = size (swapXY u).\n",
  "proof": "Proof.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  apply/bigmax_leqP=> /= i _; apply/leq_sizeP => j /(nth_default 0) u_j_0.\n  by rewrite -coef_swapXY u_j_0 coef0.\napply/leq_sizeP=> j le_uY_j; apply/polyP=> i; rewrite coef_swapXY coef0.\nby rewrite nth_default // (leq_trans _ le_uY_j) ?max_size_coefXY.\nQed."
}
{
  "statement": "Lemma total_homo_mono_in : total aR ->\n    {in D &, {homo f : x y / aR' x y >-> rR' x y}} ->\n   {in D &, {mono f : x y / aR x y >-> rR x y}}.\n",
  "proof": "Proof.\nmove=> aR_tot mf x y xD yD.\nhave [->|neq_xy] := eqVneq x y; first by rewrite ?eqxx ?aR_refl ?rR_refl.\nhave [xy|] := (boolP (aR x y)); first by rewrite rRE mf ?orbT// aR'E neq_xy.\nhave /orP [->//|] := aR_tot x y.\nrewrite aRE eq_sym (negPf neq_xy) /= => /mf -/(_ yD xD).\nrewrite rR'E => /andP[Nfxfy fyfx] _; apply: contra_neqF Nfxfy => fxfy.\nby apply/rR_anti; rewrite fyfx fxfy.\nQed."
}
{
  "statement": "Lemma rfix_gen (H : {set gT}) :\n  H \\subset G -> (rfix_mx rGA H :=: in_gen (rfix_mx rG H))%MS.\n",
  "proof": "Proof.\nmove/subsetP=> sHG; apply/eqmxP/andP; split; last first.\n  by apply/rfix_mxP=> g Hg; rewrite -in_genJ ?sHG ?rfix_mx_id.\nrewrite -[rfix_mx rGA H]val_genK; apply: submx_in_gen.\nby apply/rfix_mxP=> g Hg; rewrite -val_genJ ?rfix_mx_id ?sHG.\nQed."
}
{
  "statement": "Lemma restrict_aut_to_normal_num_field (Qn : splittingFieldType rat)\n  (QnC : {rmorphism Qn -> algC})(nu : {rmorphism algC -> algC}) :\n    {nu0 : {lrmorphism Qn -> Qn} | {morph QnC : x / nu0 x >-> nu x}}.\n",
  "proof": "Proof.\napply: restrict_aut_to_num_field => x.\ncase: (splitting_field_normal 1%AS x) => rs /eqP Hrs.\nhave: root (map_poly (nu \\o QnC) (minPoly 1%AS x)) (nu (QnC x)).\n  by rewrite fmorph_root root_minPoly.\nrewrite map_Qnum_poly ?minPolyOver // Hrs.\nrewrite [map_poly _ _](_:_ = \\prod_(y <- map QnC rs) ('X - y%:P)).\n  by rewrite root_prod_XsubC; case/mapP => y _ ?; exists y.\nby rewrite big_map rmorph_prod /=; apply: eq_bigr => i _; rewrite map_polyXsubC.\nQed."
}
{
  "statement": "Lemma horner_mx_diag (d : 'rV[R]_n) (p : {poly R}) :\n  horner_mx (diag_mx d) p = diag_mx (map_mx (horner p) d).\n",
  "proof": "Proof.\napply/matrixP => i j; rewrite !mxE.\nelim/poly_ind: p => [|p c ihp]; first by rewrite rmorph0 horner0 mxE mul0rn.\nrewrite !hornerE mulrnDl rmorphD rmorphM /= horner_mx_X horner_mx_C !mxE.\nrewrite (bigD1 j)//= ihp mxE eqxx mulr1n -mulrnAl big1 ?addr0.\n  by have [->|_] := eqVneq; rewrite /= !(mulr1n, addr0, mul0r).\nby move=> k /negPf nkF; rewrite mxE nkF mulr0.\nQed."
}
{
  "statement": "Lemma setI_normal_Hall G H K :\n  H <| G -> pi.-Hall(G) H -> K \\subset G -> pi.-Hall(K) (H :&: K).\n",
  "proof": "Proof.\nmove=> nsHG hallH sKG; apply: normal_max_pgroup_Hall; last first.\n  by rewrite /= setIC (normalGI sKG nsHG).\napply/maxgroupP; split=> [|M /andP[sMK piM] sHK_M].\n  by rewrite /psubgroup subsetIr (pgroupS (subsetIl _ _) (pHall_pgroup hallH)).\napply/eqP; rewrite eqEsubset sHK_M subsetI sMK !andbT.\nby rewrite (sub_normal_Hall hallH) // (subset_trans sMK).\nQed."
}
{
  "statement": "Lemma col'Kl m n1 n2 j1 (A1 : 'M_(m, n1.+1)) (A2 : 'M_(m, n2)) :\n  col' (lshift n2 j1) (row_mx A1 A2) = row_mx (col' j1 A1) A2.\n",
  "proof": "Proof.\napply/matrixP=> i /= j; symmetry; rewrite 2!mxE; case: split_ordP => j' ->.\n  by rewrite mxE -(row_mxEl _ A2); congr (row_mx _ _ _); apply: ord_inj.\nrewrite -(row_mxEr A1); congr (row_mx _ _ _); apply: ord_inj => /=.\nby rewrite /bump -ltnS -addSn ltn_addr.\nQed."
}
{
  "statement": "Lemma astabs_Aut_isom a :\n  a \\in Aut G -> (fGisom a \\in 'N(f @* H | 'P)) = (a \\in 'N(H | 'P)).\n",
  "proof": "Proof.\nmove=> AutGa; rewrite !inE sub_morphim_pre // subsetI sHD /= /aperm.\nrewrite !(sameP setIidPl eqP) !eqEsubset !subsetIl; apply: eq_subset_r => x.\nrewrite !inE; apply: andb_id2l => Hx; have Gx: x \\in G := subsetP sHG x Hx.\nhave Dax: a x \\in D by rewrite (subsetP sGD) // Aut_closed.\nby rewrite Aut_isomE // -!sub1set -morphim_set1 // injmSK ?sub1set.\nQed."
}
{
  "statement": "Lemma sub_kermxpoly_conjmx V f p W : stablemx V f -> row_free V ->\n  (W <= kermxpoly (conjmx V f) p)%MS = (W *m V <= kermxpoly f p)%MS.\n",
  "proof": "Proof.\nmove: n m => [|n'] [|m']// in V f W *; rewrite ?thinmx0// => fV rfV.\n- by rewrite /row_free mxrank0 in rfV.\n- by rewrite mul0mx !sub0mx.\n- apply/sub_kermxP/sub_kermxP; rewrite horner_mx_conj//; last first.\n    by move=> /(congr1 (mulmxr (pinvmx V)))/=; rewrite mul0mx !mulmxA.\n  move=> /(congr1 (mulmxr V))/=; rewrite ![W *m _]mulmxA ?mul0mx mulmxKpV//.\n  by rewrite -mulmxA mulmx_sub// horner_mx_stable//.\nQed."
}
{
  "statement": "Lemma irreducible_rat_int p :\n  irreducible_poly (pZtoQ p) <-> irreducible_poly p.\n",
  "proof": "Proof.\nrewrite /irreducible_poly size_rat_int_poly; split=> -[] p1 p_irr; split=> //.\n  move=> q q1; rewrite /eqp -!dvdp_rat_int => rq.\n  by apply/p_irr => //; rewrite size_rat_int_poly.\nmove=> q + /dvdpP_rat_int [] r [] c c0 qE [] s sE.\nrewrite qE size_scale// size_rat_int_poly => r1.\napply/(eqp_trans (eqp_scale _ c0)).\nrewrite /eqp !dvdp_rat_int; apply/p_irr => //.\nby rewrite sE dvdp_mulIl.\nQed."
}
{
  "statement": "Lemma cormen_lup_lower n A (i j : 'I_n.+1) :\n  i <= j -> (cormen_lup A).1.2 i j = (i == j)%:R.\n",
  "proof": "Proof.\nelim: n => [|n IHn] /= in A i j *; first by rewrite [i]ord1 [j]ord1 mxE.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/= Ll.\nrewrite !mxE split1; case: unliftP => [i'|] -> /=; rewrite !mxE split1.\n  by case: unliftP => [j'|] -> //; apply: Ll.\nby case: unliftP => [j'|] ->; rewrite /= mxE.\nQed."
}
{
  "statement": "Lemma mem_mulsmx m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) A1 A2 :\n  (A1 \\in R1 -> A2 \\in R2 -> A1 *m A2 \\in R1 * R2)%MS.\n",
  "proof": "Proof.\nmove=> R_A1 R_A2; rewrite -[A2]mxvecK; case/submxP: R_A2 => a ->{A2}.\nrewrite mulmx_sum_row !linear_sum summx_sub // => i _.\nrewrite 3!linearZ scalemx_sub {a}//= (sumsmx_sup i) // genmxE.\nrewrite -[A1]mxvecK; case/submxP: R_A1 => a ->{A1}.\nby apply/submxP; exists a; rewrite mulmxA mul_rV_lin.\nQed."
}
{
  "statement": "Lemma rot_eq_c0 : forall r s : {perm square},\n  is_rot r -> is_rot s -> r c0 = s c0 -> r = s.\n",
  "proof": "Proof.\nrewrite /is_rot => r s; move/eqP => hr; move/eqP=> hs hrs; apply/permP => a.\nhave ->: a = (r1 ^+ a) c0\n   by apply/eqP; case: a; do 4?case=> //=; rewrite ?permM !permE.\nby rewrite -!permM -!commuteX   //  !permM hrs.\nQed."
}
{
  "statement": "Lemma scaler_unit k x : k \\in unit -> (k *: x \\in unit) = (x \\in unit).\n",
  "proof": "Proof.\nmove=> Uk; apply/idP/idP=> [Ukx | Ux]; apply/unitrP; last first.\n  exists (k^-1 *: x^-1).\n  by rewrite -!scalerAl -!scalerAr !scalerA !mulVr // !mulrV // scale1r.\nexists (k *: (k *: x)^-1); split.\n  apply: (mulrI Ukx).\n  by rewrite mulr1 mulrA -scalerAr mulrV // -scalerAl mul1r.\napply: (mulIr Ukx).\nby rewrite mul1r -mulrA -scalerAl mulVr // -scalerAr mulr1.\nQed."
}
{
  "statement": "Lemma Derivation_horner p x :\n    p \\is a polyOver E -> x \\in E ->\n  D p.[x] = (map_poly D p).[x] + p^`().[x] * D x.\n",
  "proof": "Proof.\nmove=> Ep Ex; elim/poly_ind: p Ep => [|p c IHp] /polyOverP EpXc.\n  by rewrite !(raddf0, horner0) mul0r add0r.\nhave Ep: p \\is a polyOver E.\n  by apply/polyOverP=> i; have:= EpXc i.+1; rewrite coefD coefMX coefC addr0.\nhave->: map_poly D (p * 'X + c%:P) = map_poly D p * 'X + (D c)%:P.\n  apply/polyP=> i; rewrite !(coefD, coefMX, coef_map) /= linearD /= !coefC.\n  by rewrite !(fun_if D) linear0.\nrewrite derivMXaddC !hornerE mulrDl mulrAC addrAC linearD /=; congr (_ + _).\nby rewrite addrCA -mulrDl -IHp // addrC (Derivation_mul derD) ?rpred_horner.\nQed."
}
{
  "statement": "Lemma rowgK m (A : 'M_(m, n)) : (rowg_mx (rowg A) :=: A)%MS.\n",
  "proof": "Proof.\napply/eqmxP; rewrite !genmxE; apply/andP; split.\n  by apply/row_subP=> i; rewrite rowK; have /[!inE] := enum_valP i.\napply/row_subP=> i; set v := row i A.\nhave Av: v \\in rowg A by rewrite inE row_sub.\nby rewrite (eq_row_sub (enum_rank_in Av v)) // rowK enum_rankK_in.\nQed."
}
{
  "statement": "Lemma count_set_nth a s x0 n x :\n  count a (set_nth x0 s n x) =\n    count a s + a x - a (nth x0 s n) * (n < size s) + (a x0) * (n - size s).\n",
  "proof": "Proof.\nrewrite set_nthE; case: ltnP => [nlts|nges]; last first.\n  rewrite -cat_nseq !count_cat count_nseq /=.\n  by rewrite muln0 addn0 subn0 addnAC addnA.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nrewrite -[in count a s](cat_take_drop n s) [drop n s](drop_nth x0)//.\nby rewrite !count_cat/= muln1 muln0 addn0 addnAC !addnA [in RHS]addnAC addnK.\nQed."
}
{
  "statement": "Lemma exists_comps (G : gTg) : exists s, comps G s.\n",
  "proof": "Proof.\nelim: {G} #|G| {1 3}G (leqnn #|G|) => [G | n IHn G cG].\n  by rewrite leqNgt cardG_gt0.\nhave [sG | nsG] := boolP (simple G).\n  by exists [:: 1%G]; rewrite /comps eqxx /=  -simple_maxnormal andbT.\nhave [-> | ntG] := eqVneq G 1%G; first by exists [::]; rewrite /comps eqxx.\nhave [N maxN] := ex_maxnormal_ntrivg ntG.\nhave [|s /andP[ls cs]] := IHn N.\n  by rewrite -ltnS (leq_trans _ cG) // proper_card // (maxnormal_proper maxN).\nby exists (N :: s); apply/and3P.\nQed."
}
{
  "statement": "Lemma morphim_Zgroup G : Zgroup G -> Zgroup (f @* G).\n",
  "proof": "Proof.\nmove=> zgG; wlog sGD: G zgG / G \\subset D.\n  by rewrite -morphimIdom; apply; rewrite (ZgroupS _ zgG, subsetIl) ?subsetIr.\napply/forall_inP=> fV /SylowP[p pr_p sylfV].\nhave [P sylP] := Sylow_exists p G.\nhave [|z _ ->] := @Sylow_trans p _ _ (f @* P)%G _ _ sylfV.\n  by apply: morphim_pHall (sylP); apply: subset_trans (pHall_sub sylP) sGD.\nby rewrite cyclicJ morphim_cyclic ?(forall_inP zgG) //; apply/SylowP; exists p.\nQed."
}
{
  "statement": "Lemma reshape_leq sh i1 i2\n  (r1 := reshape_index sh i1) (c1 := reshape_offset sh i1)\n  (r2 := reshape_index sh i2) (c2 := reshape_offset sh i2) :\n  (i1 <= i2) = ((r1 < r2) || ((r1 == r2) && (c1 <= c2))).\n",
  "proof": "Proof.\nrewrite {}/r1 {}/c1 {}/r2 {}/c2 /reshape_offset /reshape_index.\nelim: sh => [|s0 s IHs] /= in i1 i2 *; rewrite ?subn0 ?subn_eq0 //.\nhave [[] i1s0 [] i2s0] := (ltnP i1 s0, ltnP i2 s0); first by rewrite !subn0.\n- by apply: leq_trans i2s0; apply/ltnW.\n- by apply/negP => /(leq_trans i1s0); rewrite leqNgt i2s0.\nby rewrite !subSn // !eqSS !ltnS !subnDA -IHs leq_subLR subnKC.\nQed."
}
{
  "statement": "Lemma sub_in_partn pi1 pi2 n :\n  {in \\pi(n), {subset pi1 <= pi2}} -> n`_pi1 %| n`_pi2.\n",
  "proof": "Proof.\nmove=> pi12; rewrite ![n`__]big_mkcond /=.\napply (big_ind2 (fun m1 m2 => m1 %| m2)) => // [*|p _]; first exact: dvdn_mul.\nrewrite lognE -mem_primes; case: ifP => pi1p; last exact: dvd1n.\nby case: ifP => pr_p; [rewrite pi12 | rewrite if_same].\nQed."
}
{
  "statement": "Lemma pmaxElemS p A B :\n  A \\subset B -> 'E*_p(B) :&: subgroups A \\subset 'E*_p(A).\n",
  "proof": "Proof.\nmove=> sAB; apply/subsetP=> E /[!inE].\ncase/andP=> /maxgroupP[/pElemP[_ abelE] maxE] sEA.\napply/maxgroupP; rewrite inE sEA; split=> // D EpD.\nby apply: maxE; apply: subsetP EpD; apply: pElemS.\nQed."
}
{
  "statement": "Lemma eq_rdvdp k q1 p:\n  p * ((lead_coef d)^+ k)%:P = q1 * d -> rdvdp d p.\n",
  "proof": "Proof.\nmove=> he.\nhave Hnq0 := rreg_lead0 Rreg; set lq := lead_coef d.\npose v := rscalp p d; pose m := maxn v k.\nrewrite /rdvdp -(rreg_polyMC_eq0 _ (@rregX _ _ (m - v) Rreg)).\nsuff:\n ((rdivp p d) * (lq ^+ (m - v))%:P - q1 * (lq ^+ (m - k))%:P) * d +\n  (rmodp p d) * (lq ^+ (m - v))%:P == 0.\n  rewrite rreg_div0 //; first by case/andP.\n  by rewrite rreg_size ?ltn_rmodp //; exact: rregX.\nrewrite mulrDl addrAC mulNr -!mulrA polyC_exp -(commrX (m-v) Cdl).\nrewrite -polyC_exp mulrA -mulrDl -rdivp_eq // [(_ ^+ (m - k))%:P]polyC_exp.\nrewrite -(commrX (m-k) Cdl) -polyC_exp mulrA -he -!mulrA -!polyCM -/v.\nby rewrite -!exprD addnC subnK ?leq_maxl // addnC subnK ?subrr ?leq_maxr.\nQed."
}
{
  "statement": "Lemma big_imset_idem [I J : finType] (h : I -> J) (A : pred I) F :\n    idempotent_op op ->\n  \\big[op/x]_(j in h @: A) F j = \\big[op/x]_(i in A) F (h i).\n",
  "proof": "Proof.\nrewrite -!big_image => op_idem; rewrite -big_undup// -[RHS]big_undup//.\napply/perm_big/perm_undup => j; apply/imageP.\nhave [mem_j | /imageP mem_j] := boolP (j \\in [seq h j | j in A]).\n- by exists j => //; apply/imsetP; apply: imageP mem_j.\n- by case=> k /imsetP [i j_in_A ->] eq_i; apply: mem_j; exists i.\nQed."
}
{
  "statement": "Lemma Gaussian_elimination_map m n (A : 'M_(m, n)) :\n  Gaussian_elimination_ A^f = ((col_ebase A)^f, (row_ebase A)^f, \\rank A).\n",
  "proof": "Proof.\nrewrite mxrankE /row_ebase /col_ebase unlock.\nelim: m n A => [|m IHm] [|n] A /=; rewrite ?map_mx1 //.\nset pAnz := [pred k | A k.1 k.2 != 0].\nrewrite (@eq_pick _ _ pAnz) => [|k]; last by rewrite /= mxE fmorph_eq0.\ncase: {+}(pick _) => [[i j]|]; last by rewrite !map_mx1.\nrewrite mxE -fmorphV  -map_xcol -map_xrow -map_dlsubmx -map_drsubmx.\nrewrite -map_ursubmx -map_mxZ -map_mxM -map_mxB {}IHm /=.\ncase: {+}(Gaussian_elimination_ _) => [[L U] r] /=; rewrite map_xrow map_xcol.\nby rewrite !(@map_block_mx _ _ f 1 _ 1) !map_mx0 ?map_mx1 ?map_scalar_mx.\nQed."
}
{
  "statement": "Lemma morph_constt pi x : x \\in D -> f x.`_pi = (f x).`_pi.\n",
  "proof": "Proof.\nmove=> Dx; rewrite -{2}(consttC pi x) morphM ?groupX //.\nrewrite consttM; last by rewrite !morphX //; apply: commuteX2.\nhave: pi.-elt (f x.`_pi) by rewrite morph_p_elt ?groupX ?p_elt_constt //.\nhave: pi^'.-elt (f x.`_pi^') by rewrite morph_p_elt ?groupX ?p_elt_constt //.\nby move/constt1P->; move/constt_p_elt->; rewrite mulg1.\nQed."
}
{
  "statement": "Lemma orthogonal_free S : pairwise_orthogonal S -> free S.\n",
  "proof": "Proof.\ncase/pairwise_orthogonalP=> [/=/andP[notS0 uniqS] oSS].\nrewrite -(in_tupleE S); apply/freeP => a aS0 i.\nhave S_i: S`_i \\in S by apply: mem_nth.\nhave /eqP: '[S`_i, 0]_G = 0 := cfdot0r _.\nrewrite -{2}aS0 raddf_sum /= (bigD1 i) //= big1 => [|j neq_ji]; last 1 first.\n  by rewrite cfdotZr oSS ?mulr0 ?mem_nth // eq_sym nth_uniq.\nrewrite addr0 cfdotZr mulf_eq0 conjC_eq0 cfnorm_eq0.\nby case/pred2P=> // Si0; rewrite -Si0 S_i in notS0.\nQed."
}
{
  "statement": "Lemma factor_Xn_sub_1 : \\prod_(0 <= i < n) ('X - (z ^+ i)%:P) = 'X^n - 1.\n",
  "proof": "Proof.\ntransitivity (\\prod_(w <- zn) ('X - w%:P)); first by rewrite big_map.\nhave n_gt0: n > 0 := prim_order_gt0 prim_z.\nrewrite (@all_roots_prod_XsubC _ ('X^n - 1) zn); first 1 last.\n- by rewrite size_XnsubC // size_map size_iota subn0.\n- apply/allP=> _ /mapP[i _ ->] /=; rewrite rootE !hornerE.\n  by rewrite exprAC (prim_expr_order prim_z) expr1n subrr.\n- rewrite uniq_rootsE map_inj_in_uniq ?iota_uniq // => i j.\n  rewrite !mem_index_iota => ltin ltjn /eqP.\n  by rewrite (eq_prim_root_expr prim_z) !modn_small // => /eqP.\nby rewrite (monicP (monicXnsubC 1 n_gt0)) scale1r.\nQed."
}
{
  "statement": "Lemma sub_kermxpoly_conjmx V f p W : stablemx V f -> row_free V ->\n  (W <= kermxpoly (conjmx V f) p)%MS = (W *m V <= kermxpoly f p)%MS.\n",
  "proof": "Proof.\ncase: n m => [|n'] [|m'] in V f W * => fV rfV; rewrite ?thinmx0//.\n  by rewrite /row_free mxrank.unlock in rfV.\n  by rewrite mul0mx !sub0mx.\napply/sub_kermxP/sub_kermxP; rewrite horner_mx_conj//; last first.\n  by move=> /(congr1 (mulmxr (pinvmx V)))/=; rewrite mul0mx !mulmxA.\nmove=> /(congr1 (mulmxr V))/=; rewrite ![W *m _]mulmxA ?mul0mx mulmxKpV//.\nby rewrite -mulmxA mulmx_sub// horner_mx_stable//.\nQed."
}
