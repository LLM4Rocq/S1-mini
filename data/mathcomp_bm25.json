{
  "theorems": [
    "Lemma isoGrp_hom gT (G : {group gT}) p : G \\isog Grp p -> G \\homg Grp p.\nProof. by move <-; apply: homg_refl. Qed.",
    "Lemma isoGrpP gT (G : {group gT}) p rT (H : {group rT}) :\n  G \\isog Grp p -> reflect (#|H| = #|G| /\\ H \\homg Grp p) (H \\isog G).\nProof.\nmove=> isoGp; apply: (iffP idP) => [isoGH | [oH homHp]].\n  by rewrite (card_isog isoGH) -isoGp isog_hom.\nby rewrite isogEcard isoGp homHp /= oH.\nQed.",
    "Lemma homGrp_trans rT gT (H : {set rT}) (G : {group gT}) p :\n  H \\homg G -> G \\homg Grp p -> H \\homg Grp p.\nProof.\ncase/homgP=> h <-{H}; rewrite /hom; move: {p}(p _) => p.\nhave evalG e t: all [in G] e -> eval (map h e) t = h (eval e t).\n  move=> Ge; apply: (@proj2 (eval e t \\in G)); elim: t => /=.\n  - move=> i; case: (leqP (size e) i) => [le_e_i | lt_i_e].\n      by rewrite !nth_default ?size_map ?morph1.\n    by rewrite (nth_map 1) // [_ \\in G](allP Ge) ?mem_nth.\n  - by rewrite morph1.\n  - by move=> t [Gt ->]; rewrite groupV morphV.\n  - by move=> t [Gt ->] n; rewrite groupX ?morphX.\n  - by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupM ?morphM.\n  - by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupJ ?morphJ.\n  by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupR ?morphR.\nhave and_relE xT x1 x2 r: @and_rel xT x1 x2 r = (x1 == x2) && r :> bool.\n  by case: r => //=; rewrite andbT.\nhave rsatG e f: all [in G] e -> rel e f NoRel -> rel (map h e) f NoRel.\n  move=> Ge; have: NoRel -> NoRel by []; move: NoRel {2 4}NoRel.\n  elim: f => [x1 x2 | f1 IH1 f2 IH2] r hr IHr; last by apply: IH1; apply: IH2.\n  by rewrite !and_relE !evalG //; case/andP; move/eqP->; rewrite eqxx.\nset s := env1; set vT := gT : finType in s *.\nset s' := env1; set vT' := rT : finType in s' *.\nhave (v): let: Env A e := s v in\n  A \\subset G -> all [in G] e /\\ exists v', s' v' = Env (h @* A) (map h e).\n- rewrite /= cycle_subG andbT => Gv; rewrite morphim_cycle //.\n  by split; last exists (h v).\nelim: p 1%N vT vT' s s' => /= [p IHp | f] n vT vT' s s' Gs.\n  apply: IHp => [[v x]] /=; case: (s v) {Gs}(Gs v) => A e /= Gs.\n  rewrite join_subG cycle_subG; case/andP=> sAG Gx; rewrite Gx.\n  have [//|-> [v' def_v']] := Gs; split=> //; exists (v', h x); rewrite def_v'.\n  by congr (Env _ _); rewrite morphimY ?cycle_subG // morphim_cycle.\ncase/existsP=> v; case: (s v) {Gs}(Gs v) => /= A e Gs.\nrewrite and_relE => /andP[/eqP defA rel_f].\nhave{Gs} [|Ge [v' def_v']] := Gs; first by rewrite defA.\napply/existsP; exists v'; rewrite def_v' and_relE defA eqxx /=.\nby rewrite -map_rev rsatG ?(eq_all_r (mem_rev e)).\nQed.",
    "Lemma eq_homGrp gT rT (G : {group gT}) (H : {group rT}) p :\n  G \\isog H -> (G \\homg Grp p) = (H \\homg Grp p).\nProof.\nby rewrite isogEhom => /andP[homGH homHG]; apply/idP/idP; apply: homGrp_trans.\nQed.",
    "Lemma isoGrp_trans gT rT (G : {group gT}) (H : {group rT}) p :\n  G \\isog H -> H \\isog Grp p -> G \\isog Grp p.\nProof. by move=> isoGH isoHp kT K; rewrite -isoHp; apply: eq_homgr. Qed.",
    "Lemma intro_isoGrp gT (G : {group gT}) p :\n    G \\homg Grp p -> (forall rT (H : {group rT}), H \\homg Grp p -> H \\homg G) ->\n  G \\isog Grp p.\nProof.\nmove=> homGp freeG rT H.\nby apply/idP/idP=> [homHp|]; [apply: homGrp_trans homGp | apply: freeG].\nQed.",
    "Lemma mk_invgK : involutive invg.\nProof.\nhave mulV21 x: x^-1^-1 * 1 = x by rewrite -(mulVg x) mulgA mulVg mul1g.\nby move=> x; rewrite -[_ ^-1]mulV21 -(mul1g 1) mulgA !mulV21.\nQed.",
    "Lemma mk_invMg : {morph invg : x y / x * y >-> y * x}.\nProof.\nhave mulgV x: x * x^-1 = 1 by rewrite -{1}[x]mk_invgK mulVg.\nmove=> x y /=; rewrite -[y^-1 * _]mul1g -(mulVg (x * y)) -2!mulgA (mulgA y).\nby rewrite mulgV mul1g mulgV -(mulgV (x * y)) mulgA mulVg mul1g.\nQed.",
    "Lemma mulgA : associative mulgT.  Proof. exact: mulgA_subproof. Qed.",
    "Lemma mul1g : left_id 1 mulgT.  Proof. exact: mul1g_subproof. Qed.",
    "Lemma invgK : @involutive T invg. Proof. exact: invgK_subproof. Qed.",
    "Lemma invMg x y : (x * y)^-1 = y^-1 * x^-1. Proof. exact: invMg_subproof. Qed.",
    "Lemma invg_inj : @injective T T invg. Proof. exact: can_inj invgK. Qed.",
    "Lemma eq_invg_sym x y : (x^-1 == y) = (x == y^-1).\nProof. by apply: (inv_eq invgK). Qed.",
    "Lemma invg1 : 1^-1 = 1 :> T.\nProof. by apply: invg_inj; rewrite -{1}[1^-1]mul1g invMg invgK mul1g. Qed.",
    "Lemma eq_invg1 x : (x^-1 == 1) = (x == 1).\nProof. by rewrite eq_invg_sym invg1. Qed.",
    "Lemma mulg1 : right_id 1 mulgT.\nProof. by move=> x; apply: invg_inj; rewrite invMg invg1 mul1g. Qed.",
    "Lemma expgnE x n : x ^+ n = iterop n mulg x 1. Proof. by []. Qed.",
    "Lemma expg0 x : x ^+ 0 = 1. Proof. by []. Qed.",
    "Lemma expg1 x : x ^+ 1 = x. Proof. by []. Qed.",
    "Lemma expgS x n : x ^+ n.+1 = x * x ^+ n.\nProof. by case: n => //; rewrite mulg1. Qed.",
    "Lemma expg1n n : 1 ^+ n = 1 :> T.\nProof. by elim: n => // n IHn; rewrite expgS mul1g. Qed.",
    "Lemma expgD x n m : x ^+ (n + m) = x ^+ n * x ^+ m.\nProof. by elim: n => [|n IHn]; rewrite ?mul1g // !expgS IHn mulgA. Qed.",
    "Lemma expgSr x n : x ^+ n.+1 = x ^+ n * x.\nProof. by rewrite -addn1 expgD expg1. Qed.",
    "Lemma expgM x n m : x ^+ (n * m) = x ^+ n ^+ m.\nProof.\nelim: m => [|m IHm]; first by rewrite muln0 expg0.\nby rewrite mulnS expgD IHm expgS.\nQed.",
    "Lemma expgAC x m n : x ^+ m ^+ n = x ^+ n ^+ m.\nProof. by rewrite -!expgM mulnC. Qed.",
    "Lemma commute_refl x : commute x x.\nProof. by []. Qed.",
    "Lemma commute_sym x y : commute x y -> commute y x.\nProof. by []. Qed.",
    "Lemma commute1 x : commute x 1.\nProof. by rewrite /commute mulg1 mul1g. Qed.",
    "Lemma commuteM x y z : commute x y ->  commute x z ->  commute x (y * z).\nProof. by move=> cxy cxz; rewrite /commute -mulgA -cxz !mulgA cxy. Qed.",
    "Lemma commuteX x y n : commute x y ->  commute x (y ^+ n).\nProof.\nby move=> cxy; case: n; [apply: commute1 | elim=> // n; apply: commuteM].\nQed.",
    "Lemma commuteX2 x y m n : commute x y -> commute (x ^+ m) (y ^+ n).\nProof. by move=> cxy; apply/commuteX/commute_sym/commuteX. Qed.",
    "Lemma expgVn x n : x^-1 ^+ n = x ^- n.\nProof. by elim: n => [|n IHn]; rewrite ?invg1 // expgSr expgS invMg IHn. Qed.",
    "Lemma expgMn x y n : commute x y -> (x * y) ^+ n  = x ^+ n * y ^+ n.\nProof.\nmove=> cxy; elim: n => [|n IHn]; first by rewrite mulg1.\nby rewrite !expgS IHn -mulgA (mulgA y) (commuteX _ (commute_sym cxy)) !mulgA.\nQed.",
    "Lemma mulVg : left_inverse 1 invg mulgT. Proof. exact: mulVg_subproof. Qed.",
    "Lemma mulgV : right_inverse 1 invg mulgT.\nProof. by move=> x; rewrite -{1}(invgK x) mulVg. Qed.",
    "Lemma mulKg : left_loop invg mulgT.\nProof. by move=> x y; rewrite mulgA mulVg mul1g. Qed.",
    "Lemma mulKVg : rev_left_loop invg mulgT.\nProof. by move=> x y; rewrite mulgA mulgV mul1g. Qed.",
    "Lemma mulgI : right_injective mulgT.\nProof. by move=> x; apply: can_inj (mulKg x). Qed.",
    "Lemma mulgK : right_loop invg mulgT.\nProof. by move=> x y; rewrite -mulgA mulgV mulg1. Qed.",
    "Lemma mulgKV : rev_right_loop invg mulgT.\nProof. by move=> x y; rewrite -mulgA mulVg mulg1. Qed.",
    "Lemma mulIg : left_injective mulgT.\nProof. by move=> x; apply: can_inj (mulgK x). Qed.",
    "Lemma eq_invg_mul x y : (x^-1 == y :> T) = (x * y == 1 :> T).\nProof. by rewrite -(inj_eq (@mulgI x)) mulgV eq_sym. Qed.",
    "Lemma eq_mulgV1 x y : (x == y) = (x * y^-1 == 1 :> T).\nProof. by rewrite -(inj_eq invg_inj) eq_invg_mul. Qed.",
    "Lemma eq_mulVg1 x y : (x == y) = (x^-1 * y == 1 :> T).\nProof. by rewrite -eq_invg_mul invgK. Qed.",
    "Lemma commuteV x y : commute x y -> commute x y^-1.\nProof. by move=> cxy; apply: (@mulIg y); rewrite mulgKV -mulgA cxy mulKg. Qed.",
    "Lemma conjgE x y : x ^ y = y^-1 * (x * y). Proof. by []. Qed.",
    "Lemma conjgC x y : x * y = y * x ^ y.\nProof. by rewrite mulKVg. Qed.",
    "Lemma conjgCV x y : x * y = y ^ x^-1 * x.\nProof. by rewrite -mulgA mulgKV invgK. Qed.",
    "Lemma conjg1 x : x ^ 1 = x.\nProof. by rewrite conjgE commute1 mulKg. Qed.",
    "Lemma conj1g x : 1 ^ x = 1.\nProof. by rewrite conjgE mul1g mulVg. Qed.",
    "Lemma conjMg x y z : (x * y) ^ z = x ^ z * y ^ z.\nProof. by rewrite !conjgE !mulgA mulgK. Qed.",
    "Lemma conjgM x y z : x ^ (y * z) = (x ^ y) ^ z.\nProof. by rewrite !conjgE invMg !mulgA. Qed.",
    "Lemma conjVg x y : x^-1 ^ y = (x ^ y)^-1.\nProof. by rewrite !conjgE !invMg invgK mulgA. Qed.",
    "Lemma conjJg x y z : (x ^ y) ^ z = (x ^ z) ^ y ^ z.\nProof. by rewrite 2!conjMg conjVg. Qed.",
    "Lemma conjXg x y n : (x ^+ n) ^ y = (x ^ y) ^+ n.\nProof. by elim: n => [|n IHn]; rewrite ?conj1g // !expgS conjMg IHn. Qed.",
    "Lemma conjgK : @right_loop T T invg conjg.\nProof. by move=> y x; rewrite -conjgM mulgV conjg1. Qed.",
    "Lemma conjgKV : @rev_right_loop T T invg conjg.\nProof. by move=> y x; rewrite -conjgM mulVg conjg1. Qed.",
    "Lemma conjg_inj : @left_injective T T T conjg.\nProof. by move=> y; apply: can_inj (conjgK y). Qed.",
    "Lemma conjg_eq1 x y : (x ^ y == 1) = (x == 1).\nProof. by rewrite (canF_eq (conjgK _)) conj1g. Qed.",
    "Lemma conjg_prod I r (P : pred I) F z :\n  (\\prod_(i <- r | P i) F i) ^ z = \\prod_(i <- r | P i) (F i ^ z).\nProof.\nby apply: (big_morph (conjg^~ z)) => [x y|]; rewrite ?conj1g ?conjMg.\nQed.",
    "Lemma commgEl x y : [~ x, y] = x^-1 * x ^ y. Proof. by []. Qed.",
    "Lemma commgEr x y : [~ x, y] = y^-1 ^ x * y.\nProof. by rewrite -!mulgA. Qed.",
    "Lemma commgC x y : x * y = y * x * [~ x, y].\nProof. by rewrite -mulgA !mulKVg. Qed.",
    "Lemma commgCV x y : x * y = [~ x^-1, y^-1] * (y * x).\nProof. by rewrite commgEl !mulgA !invgK !mulgKV. Qed.",
    "Lemma conjRg x y z : [~ x, y] ^ z = [~ x ^ z, y ^ z].\nProof. by rewrite !conjMg !conjVg. Qed.",
    "Lemma invg_comm x y : [~ x, y]^-1 = [~ y, x].\nProof. by rewrite commgEr conjVg invMg invgK. Qed.",
    "Lemma commgP x y : reflect (commute x y) ([~ x, y] == 1 :> T).\nProof. by rewrite [[~ x, y]]mulgA -invMg -eq_mulVg1 eq_sym; apply: eqP. Qed.",
    "Lemma conjg_fixP x y : reflect (x ^ y = x) ([~ x, y] == 1 :> T).\nProof. by rewrite -eq_mulVg1 eq_sym; apply: eqP. Qed.",
    "Lemma commg1_sym x y : ([~ x, y] == 1 :> T) = ([~ y, x] == 1 :> T).\nProof. by rewrite -invg_comm (inv_eq invgK) invg1. Qed.",
    "Lemma commg1 x : [~ x, 1] = 1.\nProof. exact/eqP/commgP. Qed.",
    "Lemma comm1g x : [~ 1, x] = 1.\nProof. by rewrite -invg_comm commg1 invg1. Qed.",
    "Lemma commgg x : [~ x, x] = 1.\nProof. exact/eqP/commgP. Qed.",
    "Lemma commgXg x n : [~ x, x ^+ n] = 1.\nProof. exact/eqP/commgP/commuteX. Qed.",
    "Lemma commgVg x : [~ x, x^-1] = 1.\nProof. exact/eqP/commgP/commuteV. Qed.",
    "Lemma commgXVg x n : [~ x, x ^- n] = 1.\nProof. exact/eqP/commgP/commuteV/commuteX. Qed.",
    "Lemma mem_repr A x : x \\in A -> repr A \\in A.\nProof.\nby rewrite /repr; case: ifP => // _; case: pickP => // A0; rewrite [x \\in A]A0.\nQed.",
    "Lemma card_mem_repr A : #|A| > 0 -> repr A \\in A.\nProof. by rewrite lt0n => /existsP[x]; apply: mem_repr. Qed.",
    "Lemma repr_set1 x : repr [set x] = x.\nProof. by apply/set1P/card_mem_repr; rewrite cards1. Qed.",
    "Lemma repr_set0 : repr set0 = 1.\nProof. by rewrite /repr; case: pickP => [x|_] /[!inE]. Qed.",
    "Lemma set_mul1g : left_id [set 1] set_mulg.\nProof.\nmove=> A; apply/setP=> y; apply/imset2P/idP=> [[_ x /set1P-> Ax ->] | Ay].\n  by rewrite mul1g.\nby exists (1 : gT) y; rewrite ?(set11, mul1g).\nQed.",
    "Lemma set_mulgA : associative set_mulg.\nProof.\nmove=> A B C; apply/setP=> y.\napply/imset2P/imset2P=> [[x1 z Ax1 /imset2P[x2 x3 Bx2 Cx3 ->] ->]| [z x3]].\n  by exists (x1 * x2) x3; rewrite ?mulgA //; apply/imset2P; exists x1 x2.\ncase/imset2P=> x1 x2 Ax1 Bx2 -> Cx3 ->.\nby exists x1 (x2 * x3); rewrite ?mulgA //; apply/imset2P; exists x2 x3.\nQed.",
    "Lemma set_invgK : involutive set_invg.\nProof. by move=> A; apply/setP=> x; rewrite !inE invgK. Qed.",
    "Lemma set_invgM : {morph set_invg : A B / set_mulg A B >-> set_mulg B A}.\nProof.\nmove=> A B; apply/setP=> z; rewrite inE.\napply/imset2P/imset2P=> [[x y Ax By /(canRL invgK)->] | [y x]].\n  by exists y^-1 x^-1; rewrite ?invMg // inE invgK.\nby rewrite !inE => By1 Ax1 ->; exists x^-1 y^-1; rewrite ?invMg.\nQed.",
    "Lemma mulsgP A B x :\n  reflect (imset2_spec mulg (mem A) (fun _ => mem B) x) (x \\in A * B).\nProof. exact: imset2P. Qed.",
    "Lemma mem_mulg A B x y : x \\in A -> y \\in B -> x * y \\in A * B.\nProof. by move=> Ax By; apply/mulsgP; exists x y. Qed.",
    "Lemma prodsgP (I : finType) (P : pred I) (A : I -> {set gT}) x :\n  reflect (exists2 c, forall i, P i -> c i \\in A i & x = \\prod_(i | P i) c i)\n          (x \\in \\prod_(i | P i) A i).\nProof.\nhave [r big_r [Ur mem_r] _] := big_enumP P.\npose inA c := all (fun i => c i \\in A i); rewrite -big_r; set piAx := x \\in _.\nsuffices{big_r} IHr: reflect (exists2 c, inA c r & x = \\prod_(i <- r) c i) piAx.\n  apply: (iffP IHr) => -[c inAc ->]; do [exists c; last by rewrite big_r].\n    by move=> i Pi; rewrite (allP inAc) ?mem_r.\n  by apply/allP=> i; rewrite mem_r => /inAc.\nelim: {P mem_r}r x @piAx Ur => /= [x _ | i r IHr x /andP[r'i /IHr{}IHr]].\n  by rewrite unlock; apply: (iffP set1P) => [-> | [] //]; exists (fun=> x).\nrewrite big_cons; apply: (iffP idP) => [|[c /andP[Aci Ac] ->]]; last first.\n  by rewrite big_cons mem_mulg //; apply/IHr=> //; exists c.\ncase/mulsgP=> c_i _ Ac_i /IHr[c /allP-inAcr ->] ->{x}.\nexists [eta c with i |-> c_i]; rewrite /= ?big_cons eqxx ?Ac_i.\n  by apply/allP=> j rj; rewrite /= ifN ?(memPn r'i) ?inAcr.\nby congr (_ * _); apply: eq_big_seq => j rj; rewrite ifN ?(memPn r'i).\nQed.",
    "Lemma mem_prodg (I : finType) (P : pred I) (A : I -> {set gT}) c :\n  (forall i, P i -> c i \\in A i) -> \\prod_(i | P i) c i \\in \\prod_(i | P i) A i.\nProof. by move=> Ac; apply/prodsgP; exists c. Qed.",
    "Lemma mulSg A B C : A \\subset B -> A * C \\subset B * C.\nProof. exact: imset2Sl. Qed.",
    "Lemma mulgS A B C : B \\subset C -> A * B \\subset A * C.\nProof. exact: imset2Sr. Qed.",
    "Lemma mulgSS A B C D : A \\subset B -> C \\subset D -> A * C \\subset B * D.\nProof. exact: imset2S. Qed.",
    "Lemma mulg_subl A B : 1 \\in B -> A \\subset A * B.\nProof. by move=> B1; rewrite -{1}(mulg1 A) mulgS ?sub1set. Qed.",
    "Lemma mulg_subr A B : 1 \\in A -> B \\subset A * B.\nProof. by move=> A1; rewrite -{1}(mul1g B) mulSg ?sub1set. Qed.",
    "Lemma mulUg A B C : (A :|: B) * C = (A * C) :|: (B * C).\nProof. exact: imset2Ul. Qed.",
    "Lemma mulgU A B C : A * (B :|: C) = (A * B) :|: (A * C).\nProof. exact: imset2Ur. Qed.",
    "Lemma invUg A B : (A :|: B)^-1 = A^-1 :|: B^-1.\nProof. exact: preimsetU. Qed.",
    "Lemma invIg A B : (A :&: B)^-1 = A^-1 :&: B^-1.\nProof. exact: preimsetI. Qed.",
    "Lemma invDg A B : (A :\\: B)^-1 = A^-1 :\\: B^-1.\nProof. exact: preimsetD. Qed.",
    "Lemma invCg A : (~: A)^-1 = ~: A^-1.\nProof. exact: preimsetC. Qed.",
    "Lemma invSg A B : (A^-1 \\subset B^-1) = (A \\subset B).\nProof. by rewrite !(sameP setIidPl eqP) -invIg (inj_eq invg_inj). Qed.",
    "Lemma mem_invg x A : (x \\in A^-1) = (x^-1 \\in A).\nProof. by rewrite inE. Qed.",
    "Lemma memV_invg x A : (x^-1 \\in A^-1) = (x \\in A).\nProof. by rewrite inE invgK. Qed.",
    "Lemma card_invg A : #|A^-1| = #|A|.\nProof. exact/card_preimset/invg_inj. Qed.",
    "Lemma set1gE : 1 = [set 1] :> {set gT}. Proof. by []. Qed.",
    "Lemma set1gP x : reflect (x = 1) (x \\in [1 gT]).\nProof. exact: set1P. Qed.",
    "Lemma mulg_set1 x y : [set x] :* y = [set x * y].\nProof. by rewrite [_ * _]imset2_set1l imset_set1. Qed.",
    "Lemma invg_set1 x : [set x]^-1 = [set x^-1].\nProof. by apply/setP=> y; rewrite !inE inv_eq //; apply: invgK. Qed.",
    "Lemma lcosetE A x : lcoset A x = x *: A.\nProof. by rewrite [_ * _]imset2_set1l. Qed.",
    "Lemma card_lcoset A x : #|x *: A| = #|A|.\nProof. by rewrite -lcosetE (card_imset _ (mulgI _)). Qed.",
    "Lemma mem_lcoset A x y : (y \\in x *: A) = (x^-1 * y \\in A).\nProof. by rewrite -lcosetE [_ x](can_imset_pre _ (mulKg _)) inE. Qed.",
    "Lemma lcosetP A x y : reflect (exists2 a, a \\in A & y = x * a) (y \\in x *: A).\nProof. by rewrite -lcosetE; apply: imsetP. Qed.",
    "Lemma lcosetsP A B C :\n  reflect (exists2 x, x \\in B & C = x *: A) (C \\in lcosets A B).\nProof. by apply: (iffP imsetP) => [] [x Bx ->]; exists x; rewrite ?lcosetE. Qed.",
    "Lemma lcosetM A x y : (x * y) *: A = x *: (y *: A).\nProof. by rewrite -mulg_set1 mulgA. Qed.",
    "Lemma lcoset1 A : 1 *: A = A.\nProof. exact: mul1g. Qed.",
    "Lemma lcosetK : left_loop invg (fun x A => x *: A).\nProof. by move=> x A; rewrite -lcosetM mulVg mul1g. Qed.",
    "Lemma lcosetKV : rev_left_loop invg (fun x A => x *: A).\nProof. by move=> x A; rewrite -lcosetM mulgV mul1g. Qed.",
    "Lemma lcoset_inj : right_injective (fun x A => x *: A).\nProof. by move=> x; apply: can_inj (lcosetK x). Qed.",
    "Lemma lcosetS x A B : (x *: A \\subset x *: B) = (A \\subset B).\nProof.\napply/idP/idP=> sAB; last exact: mulgS.\nby rewrite -(lcosetK x A) -(lcosetK x B) mulgS.\nQed.",
    "Lemma sub_lcoset x A B : (A \\subset x *: B) = (x^-1 *: A \\subset B).\nProof. by rewrite -(lcosetS x^-1) lcosetK. Qed.",
    "Lemma sub_lcosetV x A B : (A \\subset x^-1 *: B) = (x *: A \\subset B).\nProof. by rewrite sub_lcoset invgK. Qed.",
    "Lemma rcosetE A x : rcoset A x = A :* x.\nProof. by rewrite [_ * _]imset2_set1r. Qed.",
    "Lemma card_rcoset A x : #|A :* x| = #|A|.\nProof. by rewrite -rcosetE (card_imset _ (mulIg _)). Qed.",
    "Lemma mem_rcoset A x y : (y \\in A :* x) = (y * x^-1 \\in A).\nProof. by rewrite -rcosetE  [_ x](can_imset_pre A (mulgK _)) inE. Qed.",
    "Lemma rcosetP A x y : reflect (exists2 a, a \\in A & y = a * x) (y \\in A :* x).\nProof. by rewrite -rcosetE; apply: imsetP. Qed.",
    "Lemma rcosetsP A B C :\n  reflect (exists2 x, x \\in B & C = A :* x) (C \\in rcosets A B).\nProof. by apply: (iffP imsetP) => [] [x Bx ->]; exists x; rewrite ?rcosetE. Qed.",
    "Lemma rcosetM A x y : A :* (x * y) = A :* x :* y.\nProof. by rewrite -mulg_set1 mulgA. Qed.",
    "Lemma rcoset1 A : A :* 1 = A.\nProof. exact: mulg1. Qed.",
    "Lemma rcosetK : right_loop invg (fun A x => A :* x).\nProof. by move=> x A; rewrite -rcosetM mulgV mulg1. Qed.",
    "Lemma rcosetKV : rev_right_loop invg (fun A x => A :* x).\nProof. by move=> x A; rewrite -rcosetM mulVg mulg1. Qed.",
    "Lemma rcoset_inj : left_injective (fun A x => A :* x).\nProof. by move=> x; apply: can_inj (rcosetK x). Qed.",
    "Lemma rcosetS x A B : (A :* x \\subset B :* x) = (A \\subset B).\nProof.\napply/idP/idP=> sAB; last exact: mulSg.\nby rewrite -(rcosetK x A) -(rcosetK x B) mulSg.\nQed.",
    "Lemma sub_rcoset x A B : (A \\subset B :* x) = (A :* x ^-1 \\subset B).\nProof. by rewrite -(rcosetS x^-1) rcosetK. Qed.",
    "Lemma sub_rcosetV x A B : (A \\subset B :* x^-1) = (A :* x \\subset B).\nProof. by rewrite sub_rcoset invgK. Qed.",
    "Lemma invg_lcosets A B : (lcosets A B)^-1 = rcosets A^-1 B^-1.\nProof.\nrewrite /A^-1/= -![_^-1](can_imset_pre _ invgK) -[RHS]imset_comp -imset_comp.\nby apply: eq_imset => x /=; rewrite lcosetE rcosetE invMg invg_set1.\nQed.",
    "Lemma conjg_preim A x : A :^ x = (conjg^~ x^-1) @^-1: A.\nProof. exact: can_imset_pre (conjgK _). Qed.",
    "Lemma mem_conjg A x y : (y \\in A :^ x) = (y ^ x^-1 \\in A).\nProof. by rewrite conjg_preim inE. Qed.",
    "Lemma mem_conjgV A x y : (y \\in A :^ x^-1) = (y ^ x \\in A).\nProof. by rewrite mem_conjg invgK. Qed.",
    "Lemma memJ_conjg A x y : (y ^ x \\in A :^ x) = (y \\in A).\nProof. by rewrite mem_conjg conjgK. Qed.",
    "Lemma conjsgE A x : A :^ x = x^-1 *: (A :* x).\nProof. by apply/setP=> y; rewrite mem_lcoset mem_rcoset -mulgA mem_conjg. Qed.",
    "Lemma conjsg1 A : A :^ 1 = A.\nProof. by rewrite conjsgE invg1 mul1g mulg1. Qed.",
    "Lemma conjsgM A x y : A :^ (x * y) = (A :^ x) :^ y.\nProof. by rewrite !conjsgE invMg -!mulg_set1 !mulgA. Qed.",
    "Lemma conjsgK : @right_loop _ gT invg conjugate.\nProof. by move=> x A; rewrite -conjsgM mulgV conjsg1. Qed.",
    "Lemma conjsgKV : @rev_right_loop _ gT invg conjugate.\nProof. by move=> x A; rewrite -conjsgM mulVg conjsg1. Qed.",
    "Lemma conjsg_inj : @left_injective _ gT _ conjugate.\nProof. by move=> x; apply: can_inj (conjsgK x). Qed.",
    "Lemma cardJg A x : #|A :^ x| = #|A|.\nProof. by rewrite (card_imset _ (conjg_inj x)). Qed.",
    "Lemma conjSg A B x : (A :^ x \\subset B :^ x) = (A \\subset B).\nProof. by rewrite !conjsgE lcosetS rcosetS. Qed.",
    "Lemma properJ A B x : (A :^ x \\proper B :^ x) = (A \\proper B).\nProof. by rewrite /proper !conjSg. Qed.",
    "Lemma sub_conjg A B x : (A :^ x \\subset B) = (A \\subset B :^ x^-1).\nProof. by rewrite -(conjSg A _ x) conjsgKV. Qed.",
    "Lemma sub_conjgV A B x : (A :^ x^-1 \\subset B) = (A \\subset B :^ x).\nProof. by rewrite -(conjSg _ B x) conjsgKV. Qed.",
    "Lemma conjg_set1 x y : [set x] :^ y = [set x ^ y].\nProof. by rewrite [_ :^ _]imset_set1. Qed.",
    "Lemma conjs1g x : 1 :^ x = 1.\nProof. by rewrite conjg_set1 conj1g. Qed.",
    "Lemma conjsg_eq1 A x : (A :^ x == 1%g) = (A == 1%g).\nProof. by rewrite (canF_eq (conjsgK x)) conjs1g. Qed.",
    "Lemma conjsMg A B x : (A * B) :^ x = A :^ x * B :^ x.\nProof. by rewrite !conjsgE !mulgA rcosetK. Qed.",
    "Lemma conjIg A B x : (A :&: B) :^ x = A :^ x :&: B :^ x.\nProof. by rewrite !conjg_preim preimsetI. Qed.",
    "Lemma conj0g x : set0 :^ x = set0.\nProof. exact: imset0. Qed.",
    "Lemma conjTg x : [set: gT] :^ x = [set: gT].\nProof. by rewrite conjg_preim preimsetT. Qed.",
    "Lemma bigcapJ I r (P : pred I) (B : I -> {set gT}) x :\n  \\bigcap_(i <- r | P i) (B i :^ x) = (\\bigcap_(i <- r | P i) B i) :^ x.\nProof.\nby rewrite (big_endo (conjugate^~ x)) => // [B1 B2|]; rewrite (conjTg, conjIg).\nQed.",
    "Lemma conjUg A B x : (A :|: B) :^ x = A :^ x :|: B :^ x.\nProof. by rewrite !conjg_preim preimsetU. Qed.",
    "Lemma bigcupJ I r (P : pred I) (B : I -> {set gT}) x :\n  \\bigcup_(i <- r | P i) (B i :^ x) = (\\bigcup_(i <- r | P i) B i) :^ x.\nProof.\nrewrite (big_endo (conjugate^~ x)) => // [B1 B2|]; first by rewrite conjUg.\nexact: imset0.\nQed.",
    "Lemma conjCg A x : (~: A) :^ x = ~: A :^ x.\nProof. by rewrite !conjg_preim preimsetC. Qed.",
    "Lemma conjDg A B x : (A :\\: B) :^ x = A :^ x :\\: B :^ x.\nProof. by rewrite !setDE !(conjCg, conjIg). Qed.",
    "Lemma conjD1g A x : A^# :^ x = (A :^ x)^#.\nProof. by rewrite conjDg conjs1g. Qed.",
    "Lemma memJ_class x y A : y \\in A -> x ^ y \\in x ^: A.\nProof. exact: imset_f. Qed.",
    "Lemma classS x A B : A \\subset B -> x ^: A \\subset x ^: B.\nProof. exact: imsetS. Qed.",
    "Lemma class_set1 x y :  x ^: [set y] = [set x ^ y].\nProof. exact: imset_set1. Qed.",
    "Lemma class1g x A : x \\in A -> 1 ^: A = 1.\nProof.\nmove=> Ax; apply/setP=> y.\nby apply/imsetP/set1P=> [[a Aa]|] ->; last exists x; rewrite ?conj1g.\nQed.",
    "Lemma classVg x A : x^-1 ^: A = (x ^: A)^-1.\nProof.\napply/setP=> xy; rewrite inE; apply/imsetP/imsetP=> [] [y Ay def_xy].\n  by rewrite def_xy conjVg invgK; exists y.\nby rewrite -[xy]invgK def_xy -conjVg; exists y.\nQed.",
    "Lemma mem_classes x A : x \\in A -> x ^: A \\in classes A.\nProof. exact: imset_f. Qed.",
    "Lemma memJ_class_support A B x y :\n   x \\in A -> y \\in B -> x ^ y \\in class_support A B.\nProof. by move=> Ax By; apply: imset2_f. Qed.",
    "Lemma class_supportM A B C :\n  class_support A (B * C) = class_support (class_support A B) C.\nProof.\napply/setP=> x; apply/imset2P/imset2P=> [[a y Aa] | [y c]].\n  case/mulsgP=> b c Bb Cc -> ->{x y}.\n  by exists (a ^ b) c; rewrite ?(imset2_f, conjgM).\ncase/imset2P=> a b Aa Bb -> Cc ->{x y}.\nby exists a (b * c); rewrite ?(mem_mulg, conjgM).\nQed.",
    "Lemma class_support_set1l A x : class_support [set x] A = x ^: A.\nProof. exact: imset2_set1l. Qed.",
    "Lemma class_support_set1r A x : class_support A [set x] = A :^ x.\nProof. exact: imset2_set1r. Qed.",
    "Lemma classM x A B : x ^: (A * B) = class_support (x ^: A) B.\nProof. by rewrite -!class_support_set1l class_supportM. Qed.",
    "Lemma class_lcoset x y A : x ^: (y *: A) = (x ^ y) ^: A.\nProof. by rewrite classM class_set1 class_support_set1l. Qed.",
    "Lemma class_rcoset x A y : x ^: (A :* y) = (x ^: A) :^ y.\nProof. by rewrite -class_support_set1r classM. Qed.",
    "Lemma conjugatesS A B C : B \\subset C -> A :^: B \\subset A :^: C.\nProof. exact: imsetS. Qed.",
    "Lemma conjugates_set1 A x : A :^: [set x] = [set A :^ x].\nProof. exact: imset_set1. Qed.",
    "Lemma conjugates_conj A x B : (A :^ x) :^: B = A :^: (x *: B).\nProof.\nrewrite /conjugates [x *: B]imset2_set1l -imset_comp.\nby apply: eq_imset => y /=; rewrite conjsgM.\nQed.",
    "Lemma class_supportEl A B : class_support A B = \\bigcup_(x in A) x ^: B.\nProof. exact: curry_imset2l. Qed.",
    "Lemma class_supportEr A B : class_support A B = \\bigcup_(x in B) A :^ x.\nProof. exact: curry_imset2r. Qed.",
    "Lemma group_setP A :\n  reflect (1 \\in A /\\ {in A & A, forall x y, x * y \\in A}) (group_set A).\nProof.\napply: (iffP andP) => [] [A1 AM]; split=> {A1}//.\n  by move=> x y Ax Ay; apply: (subsetP AM); rewrite mem_mulg.\nby apply/subsetP=> _ /mulsgP[x y Ax Ay ->]; apply: AM.\nQed.",
    "Lemma group_inj : injective gval. Proof. exact: val_inj. Qed.",
    "Lemma groupP (G : groupT) : group_set G. Proof. by case: G. Qed.",
    "Lemma congr_group (H K : groupT) : H = K -> H :=: K.\nProof. exact: congr1. Qed.",
    "Lemma isgroupP A : reflect (exists G : groupT, A = G) (group_set A).\nProof. by apply: (iffP idP) => [gA | [[B gB] -> //]]; exists (Group gA). Qed.",
    "Lemma group_set_one : group_set 1.\nProof. by rewrite /group_set set11 mulg1 subxx. Qed.",
    "Lemma group_setT : group_set (setTfor gT).\nProof. by apply/group_setP; split=> [|x y _ _]; rewrite inE. Qed.",
    "Lemma valG : val G = G. Proof. by []. Qed.",
    "Lemma group1 : 1 \\in G. Proof. by case/group_setP: (valP G). Qed.",
    "Lemma group1_contra x : x \\notin G -> x != 1.\nProof. by apply: contraNneq => ->. Qed.",
    "Lemma sub1G : [1 gT] \\subset G. Proof. by rewrite sub1set. Qed.",
    "Lemma subG1 : (G \\subset [1]) = (G :==: 1).\nProof. by rewrite eqEsubset sub1G andbT. Qed.",
    "Lemma setI1g : 1 :&: G = 1. Proof. exact: (setIidPl sub1G). Qed.",
    "Lemma setIg1 : G :&: 1 = 1. Proof. exact: (setIidPr sub1G). Qed.",
    "Lemma subG1_contra H : G \\subset H -> G :!=: 1 -> H :!=: 1.\nProof. by move=> sGH; rewrite -subG1; apply: contraNneq => <-. Qed.",
    "Lemma repr_group : repr G = 1. Proof. by rewrite /repr group1. Qed.",
    "Lemma cardG_gt0 : 0 < #|G|.\nProof. by rewrite lt0n; apply/existsP; exists (1 : gT). Qed.",
    "Lemma indexg_gt0 A : 0 < #|G : A|.\nProof.\nrewrite lt0n; apply/existsP; exists A.\nby rewrite -{2}[A]mulg1 -rcosetE; apply: imset_f.\nQed.",
    "Lemma trivgP : reflect (G :=: 1) (G \\subset [1]).\nProof. by rewrite subG1; apply: eqP. Qed.",
    "Lemma trivGP : reflect (G = 1%G) (G \\subset [1]).\nProof. by rewrite subG1; apply: eqP. Qed.",
    "Lemma proper1G : ([1] \\proper G) = (G :!=: 1).\nProof. by rewrite properEneq sub1G andbT eq_sym. Qed.",
    "Lemma in_one_group x : (x \\in 1%G) = (x == 1).\nProof. by rewrite -[x \\in _]/(x \\in [set 1]) !inE. Qed.",
    "Lemma trivgPn : reflect (exists2 x, x \\in G & x != 1) (G :!=: 1).\nProof.\nrewrite -subG1.\nby apply: (iffP subsetPn) => [] [x Gx x1]; exists x; rewrite ?inE in x1 *.\nQed.",
    "Lemma trivg_card_le1 : (G :==: 1) = (#|G| <= 1).\nProof. by rewrite eq_sym eqEcard cards1 sub1G. Qed.",
    "Lemma trivg_card1 : (G :==: 1) = (#|G| == 1%N).\nProof. by rewrite trivg_card_le1 eqn_leq cardG_gt0 andbT. Qed.",
    "Lemma cardG_gt1 : (#|G| > 1) = (G :!=: 1).\nProof. by rewrite trivg_card_le1 ltnNge. Qed.",
    "Lemma card_le1_trivg : #|G| <= 1 -> G :=: 1.\nProof. by rewrite -trivg_card_le1; move/eqP. Qed.",
    "Lemma card1_trivg : #|G| = 1%N -> G :=: 1.\nProof. by move=> G1; rewrite card_le1_trivg ?G1. Qed.",
    "Lemma mulG_subl A : A \\subset A * G.\nProof. exact: mulg_subl group1. Qed.",
    "Lemma mulG_subr A : A \\subset ((G : {set gT}) * A ).\nProof. exact: mulg_subr group1. Qed.",
    "Lemma mulGid : (G : {set gT}) * G = G.\nProof.\nby apply/eqP; rewrite eqEsubset mulG_subr andbT; case/andP: (valP G).\nQed.",
    "Lemma mulGS A B : (G * A \\subset G * B) = (A \\subset G * B).\nProof.\napply/idP/idP; first exact: subset_trans (mulG_subr A).\nby move/(mulgS G); rewrite mulgA mulGid.\nQed.",
    "Lemma mulSG A B : (A * G \\subset B * G) = (A \\subset B * G).\nProof.\napply/idP/idP; first exact: subset_trans (mulG_subl A).\nby move/(mulSg G); rewrite -mulgA mulGid.\nQed.",
    "Lemma mul_subG A B : A \\subset G -> B \\subset G -> A * B \\subset G.\nProof. by move=> sAG sBG; rewrite -mulGid mulgSS. Qed.",
    "Lemma prod_subG (I : Type) (r : seq I) (P : {pred I}) (F : I -> {set gT}) :\n  (forall i, P i -> F i \\subset G) -> \\prod_(i <- r | P i) F i \\subset G.\nProof.\nmove=> subFG; elim/big_rec: _ => [|/= i A /subFG]; first by rewrite sub1set.\nexact: mul_subG.\nQed.",
    "Lemma groupM x y : x \\in G -> y \\in G -> x * y \\in G.\nProof. by case/group_setP: (valP G) x y. Qed.",
    "Lemma groupX x n : x \\in G -> x ^+ n \\in G.\nProof. by move=> Gx; elim: n => [|n IHn]; rewrite ?group1 // expgS groupM. Qed.",
    "Lemma groupVr x : x \\in G -> x^-1 \\in G.\nProof.\nmove=> Gx; rewrite -(mul1g x^-1) -mem_rcoset ((G :* x =P G) _) //.\nby rewrite eqEcard card_rcoset leqnn mul_subG ?sub1set.\nQed.",
    "Lemma groupVl x : x^-1 \\in G -> x \\in G.\nProof. by move/groupVr; rewrite invgK. Qed.",
    "Lemma groupV x : (x^-1 \\in G) = (x \\in G).\nProof. by apply/idP/idP; [apply: groupVl | apply: groupVr]. Qed.",
    "Lemma groupMl x y : x \\in G -> (x * y \\in G) = (y \\in G).\nProof.\nmove=> Gx; apply/idP/idP=> [Gxy|]; last exact: groupM.\nby rewrite -(mulKg x y) groupM ?groupVr.\nQed.",
    "Lemma groupMr x y : x \\in G -> (y * x \\in G) = (y \\in G).\nProof. by move=> Gx; rewrite -[_ \\in G]groupV invMg groupMl groupV. Qed.",
    "Lemma groupJ x y : x \\in G -> y \\in G -> x ^ y \\in G.\nProof. by move=> Gx Gy; rewrite !in_group. Qed.",
    "Lemma groupJr x y : y \\in G -> (x ^ y \\in G) = (x \\in G).\nProof. by move=> Gy; rewrite groupMl (groupMr, groupV). Qed.",
    "Lemma groupR x y : x \\in G -> y \\in G -> [~ x, y] \\in G.\nProof. by move=> Gx Gy; rewrite !in_group. Qed.",
    "Lemma group_prod I r (P : pred I) F :\n  (forall i, P i -> F i \\in G) -> \\prod_(i <- r | P i) F i \\in G.\nProof. by move=> G_P; elim/big_ind: _ => //; apply: groupM. Qed.",
    "Lemma invGid : G^-1 = G. Proof. by apply/setP=> x; rewrite inE groupV. Qed.",
    "Lemma inv_subG A : (A^-1 \\subset G) = (A \\subset G).\nProof. by rewrite -{1}invGid invSg. Qed.",
    "Lemma invg_lcoset x : (x *: G)^-1 = G :* x^-1.\nProof. by rewrite invMg invGid invg_set1. Qed.",
    "Lemma invg_rcoset x : (G :* x)^-1 = x^-1 *: G.\nProof. by rewrite invMg invGid invg_set1. Qed.",
    "Lemma memV_lcosetV x y : (y^-1 \\in x^-1 *: G) = (y \\in G :* x).\nProof. by rewrite -invg_rcoset memV_invg. Qed.",
    "Lemma memV_rcosetV x y : (y^-1 \\in G :* x^-1) = (y \\in x *: G).\nProof. by rewrite -invg_lcoset memV_invg. Qed.",
    "Lemma mulSgGid A x : x \\in A -> A \\subset G -> A * G = G.\nProof.\nmove=> Ax sAG; apply/eqP; rewrite eqEsubset -{2}mulGid mulSg //=.\napply/subsetP=> y Gy; rewrite -(mulKVg x y) mem_mulg // groupMr // groupV.\nexact: (subsetP sAG).\nQed.",
    "Lemma mulGSgid A x : x \\in A -> A \\subset G -> G * A = G.\nProof.\nrewrite -memV_invg -invSg invGid => Ax sAG.\nby apply: invg_inj; rewrite invMg invGid (mulSgGid Ax).\nQed.",
    "Lemma lcoset_refl x : x \\in x *: G.\nProof. by rewrite mem_lcoset mulVg group1. Qed.",
    "Lemma lcoset_sym x y : (x \\in y *: G) = (y \\in x *: G).\nProof. by rewrite !mem_lcoset -groupV invMg invgK. Qed.",
    "Lemma lcoset_eqP {x y} : reflect (x *: G = y *: G) (x \\in y *: G).\nProof.\nsuffices <-: (x *: G == y *: G) = (x \\in y *: G) by apply: eqP.\nby rewrite eqEsubset !mulSG !sub1set lcoset_sym andbb.\nQed.",
    "Lemma lcoset_transl x y z : x \\in y *: G -> (x \\in z *: G) = (y \\in z *: G).\nProof. by move=> Gyx; rewrite -2!(lcoset_sym z) (lcoset_eqP Gyx). Qed.",
    "Lemma lcoset_trans x y z : x \\in y *: G -> y \\in z *: G -> x \\in z *: G.\nProof. by move/lcoset_transl->. Qed.",
    "Lemma lcoset_id x : x \\in G -> x *: G = G.\nProof. by move=> Gx; rewrite (lcoset_eqP (_ : x \\in 1 *: G)) mul1g. Qed.",
    "Lemma rcoset_refl x : x \\in G :* x.\nProof. by rewrite mem_rcoset mulgV group1. Qed.",
    "Lemma rcoset_sym x y : (x \\in G :* y) = (y \\in G :* x).\nProof. by rewrite -!memV_lcosetV lcoset_sym. Qed.",
    "Lemma rcoset_eqP {x y} : reflect (G :* x = G :* y) (x \\in G :* y).\nProof.\nsuffices <-: (G :* x == G :* y) = (x \\in G :* y) by apply: eqP.\nby rewrite eqEsubset !mulGS !sub1set rcoset_sym andbb.\nQed.",
    "Lemma rcoset_transl x y z : x \\in G :* y -> (x \\in G :* z) = (y \\in G :* z).\nProof. by move=> Gyx; rewrite -2!(rcoset_sym z) (rcoset_eqP Gyx). Qed.",
    "Lemma rcoset_trans x y z : x \\in G :* y -> y \\in G :* z -> x \\in G :* z.\nProof. by move/rcoset_transl->. Qed.",
    "Lemma rcoset_id x : x \\in G -> G :* x = G.\nProof. by move=> Gx; rewrite (rcoset_eqP (_ : x \\in G :* 1)) mulg1. Qed.",
    "Lemma mem_repr_rcoset x : repr (G :* x) \\in G :* x.\nProof. exact: mem_repr (rcoset_refl x). Qed.",
    "Lemma repr_rcosetP x : rcoset_repr_spec x (repr (G :* x)).\nProof.\nby rewrite -[repr _](mulgKV x); split; rewrite -mem_rcoset mem_repr_rcoset.\nQed.",
    "Lemma rcoset_repr x : G :* (repr (G :* x)) = G :* x.\nProof. exact/rcoset_eqP/mem_repr_rcoset. Qed.",
    "Lemma mem_rcosets A x : (G :* x \\in rcosets G A) = (x \\in G * A).\nProof.\napply/rcosetsP/mulsgP=> [[a Aa /rcoset_eqP/rcosetP[g]] | ]; first by exists g a.\nby case=> g a Gg Aa ->{x}; exists a; rewrite // rcosetM rcoset_id.\nQed.",
    "Lemma mem_lcosets A x : (x *: G \\in lcosets G A) = (x \\in A * G).\nProof.\nrewrite -[LHS]memV_invg invg_lcoset invg_lcosets.\nby rewrite -[RHS]memV_invg invMg invGid mem_rcosets.\nQed.",
    "Lemma group_setJ A x : group_set (A :^ x) = group_set A.\nProof. by rewrite /group_set mem_conjg conj1g -conjsMg conjSg. Qed.",
    "Lemma group_set_conjG x : group_set (G :^ x).\nProof. by rewrite group_setJ groupP. Qed.",
    "Lemma conjGid : {in G, normalised G}.\nProof. by move=> x Gx; apply/setP=> y; rewrite mem_conjg groupJr ?groupV. Qed.",
    "Lemma conj_subG x A : x \\in G -> A \\subset G -> A :^ x \\subset G.\nProof. by move=> Gx sAG; rewrite -(conjGid Gx) conjSg. Qed.",
    "Lemma class1G : 1 ^: G = 1. Proof. exact: class1g group1. Qed.",
    "Lemma classes1 : [1] \\in classes G. Proof. by rewrite -class1G mem_classes. Qed.",
    "Lemma classGidl x y : y \\in G -> (x ^ y) ^: G = x ^: G.\nProof. by move=> Gy; rewrite -class_lcoset lcoset_id. Qed.",
    "Lemma classGidr x : {in G, normalised (x ^: G)}.\nProof. by move=> y Gy /=; rewrite -class_rcoset rcoset_id. Qed.",
    "Lemma class_refl x : x \\in x ^: G.\nProof. by apply/imsetP; exists 1; rewrite ?conjg1. Qed.",
    "Lemma class_eqP x y : reflect (x ^: G = y ^: G) (x \\in y ^: G).\nProof.\nby apply: (iffP idP) => [/imsetP[z Gz ->] | <-]; rewrite ?class_refl ?classGidl.\nQed.",
    "Lemma class_sym x y : (x \\in y ^: G) = (y \\in x ^: G).\nProof. by apply/idP/idP=> /class_eqP->. Qed.",
    "Lemma class_transl x y z : x \\in y ^: G -> (x \\in z ^: G) = (y \\in z ^: G).\nProof. by rewrite -!(class_sym z) => /class_eqP->. Qed.",
    "Lemma class_trans x y z : x \\in y ^: G -> y \\in z ^: G -> x \\in z ^: G.\nProof. by move/class_transl->. Qed.",
    "Lemma repr_class x : {y | y \\in G & repr (x ^: G) = x ^ y}.\nProof.\nset z := repr _; have: #|[set y in G | z == x ^ y]| > 0.\n  have: z \\in x ^: G by apply: (mem_repr x).\n  by case/imsetP=> y Gy ->; rewrite (cardD1 y) inE Gy eqxx.\nby move/card_mem_repr; move: (repr _) => y /setIdP[Gy /eqP]; exists y.\nQed.",
    "Lemma classG_eq1 x : (x ^: G == 1) = (x == 1).\nProof.\napply/eqP/eqP=> [xG1 | ->]; last exact: class1G.\nby have:= class_refl x; rewrite xG1 => /set1P.\nQed.",
    "Lemma class_subG x A : x \\in G -> A \\subset G -> x ^: A \\subset G.\nProof.\nmove=> Gx sAG; apply/subsetP=> _ /imsetP[y Ay ->].\nby rewrite groupJ // (subsetP sAG).\nQed.",
    "Lemma repr_classesP xG :\n  reflect (repr xG \\in G /\\ xG = repr xG ^: G) (xG \\in classes G).\nProof.\napply: (iffP imsetP) => [[x Gx ->] | []]; last by exists (repr xG).\nby have [y Gy ->] := repr_class x; rewrite classGidl ?groupJ.\nQed.",
    "Lemma mem_repr_classes xG : xG \\in classes G -> repr xG \\in xG.\nProof. by case/repr_classesP=> _ {2}->; apply: class_refl. Qed.",
    "Lemma classes_gt0 : 0 < #|classes G|.\nProof. by rewrite (cardsD1 1) classes1. Qed.",
    "Lemma classes_gt1 : (#|classes G| > 1) = (G :!=: 1).\nProof.\nrewrite (cardsD1 1) classes1 ltnS lt0n cards_eq0.\napply/set0Pn/trivgPn=> [[xG /setD1P[nt_xG]] | [x Gx ntx]].\n  by case/imsetP=> x Gx def_xG; rewrite def_xG classG_eq1 in nt_xG; exists x.\nby exists (x ^: G); rewrite !inE classG_eq1 ntx; apply: imset_f.\nQed.",
    "Lemma mem_class_support A x : x \\in A -> x \\in class_support A G.\nProof. by move=> Ax; rewrite -[x]conjg1 memJ_class_support. Qed.",
    "Lemma class_supportGidl A x :\n  x \\in G -> class_support (A :^ x) G = class_support A G.\nProof.\nby move=> Gx; rewrite -class_support_set1r -class_supportM lcoset_id.\nQed.",
    "Lemma class_supportGidr A : {in G, normalised (class_support A G)}.\nProof.\nby move=> x Gx /=; rewrite -class_support_set1r -class_supportM rcoset_id.\nQed.",
    "Lemma class_support_subG A : A \\subset G -> class_support A G \\subset G.\nProof.\nby move=> sAG; rewrite class_supportEr; apply/bigcupsP=> x Gx; apply: conj_subG.\nQed.",
    "Lemma sub_class_support A : A \\subset class_support A G.\nProof. by rewrite class_supportEr (bigcup_max 1) ?conjsg1. Qed.",
    "Lemma class_support_id : class_support G G = G.\nProof.\nby apply/eqP; rewrite eqEsubset sub_class_support class_support_subG.\nQed.",
    "Lemma class_supportD1 A : (class_support A G)^# =  cover (A^# :^: G).\nProof.\nrewrite cover_imset class_supportEr setDE big_distrl /=.\nby apply: eq_bigr => x _; rewrite -setDE conjD1g.\nQed.",
    "Lemma subgP u : sgval u \\in G.\nProof. exact: valP. Qed.",
    "Lemma subg_inj : injective sgval.\nProof. exact: val_inj. Qed.",
    "Lemma congr_subg u v : u = v -> sgval u = sgval v.\nProof. exact: congr1. Qed.",
    "Lemma subg_oneP : left_id subg_one subg_mul.\nProof. by move=> u; apply: val_inj; apply: mul1g. Qed.",
    "Lemma subg_invP : left_inverse subg_one subg_inv subg_mul.\nProof. by move=> u; apply: val_inj; apply: mulVg. Qed.",
    "Lemma subg_mulP : associative subg_mul.\nProof. by move=> u v w; apply: val_inj; apply: mulgA. Qed.",
    "Lemma sgvalM : {in setT &, {morph sgval : x y / x * y}}. Proof. by []. Qed.",
    "Lemma valgM : {in setT &, {morph val : x y / (x : subg_of) * y >-> x * y}}.\nProof. by []. Qed.",
    "Lemma subgK x : x \\in G -> val (subg x) = x.\nProof. by move=> Gx; rewrite insubdK. Qed.",
    "Lemma sgvalK : cancel sgval subg.\nProof. by case=> x Gx; apply: val_inj; apply: subgK. Qed.",
    "Lemma subg_default x : (x \\in G) = false -> val (subg x) = 1.\nProof. by move=> Gx; rewrite val_insubd Gx. Qed.",
    "Lemma subgM : {in G &, {morph subg : x y / x * y}}.\nProof. by move=> x y Gx Gy; apply: val_inj; rewrite /= !subgK ?groupM. Qed.",
    "Lemma groupD1_inj G H : G^# = H^# -> G :=: H.\nProof. by move/(congr1 (setU 1)); rewrite !setD1K. Qed.",
    "Lemma invMG G H : (G * H)^-1 = H * G.\nProof. by rewrite invMg !invGid. Qed.",
    "Lemma mulSGid G H : H \\subset G -> H * G = G.\nProof. exact: mulSgGid (group1 H). Qed.",
    "Lemma mulGSid G H : H \\subset G -> G * H = G.\nProof. exact: mulGSgid (group1 H). Qed.",
    "Lemma mulGidPl G H : reflect (G * H = G) (H \\subset G).\nProof. by apply: (iffP idP) => [|<-]; [apply: mulGSid | apply: mulG_subr]. Qed.",
    "Lemma mulGidPr G H : reflect (G * H = H) (G \\subset H).\nProof. by apply: (iffP idP) => [|<-]; [apply: mulSGid | apply: mulG_subl]. Qed.",
    "Lemma comm_group_setP G H : reflect (commute G H) (group_set (G * H)).\nProof.\nrewrite /group_set (subsetP (mulG_subl _ _)) ?group1 // andbC.\nhave <-: #|G * H| <= #|H * G| by rewrite -invMG card_invg.\nby rewrite -mulgA mulGS mulgA mulSG -eqEcard eq_sym; apply: eqP.\nQed.",
    "Lemma card_lcosets G H : #|lcosets H G| = #|G : H|.\nProof. by rewrite -card_invg invg_lcosets !invGid. Qed.",
    "Lemma group_modl A B G : A \\subset G -> A * (B :&: G) = A * B :&: G.\nProof.\nmove=> sAG; apply/eqP; rewrite eqEsubset subsetI mulgS ?subsetIl //.\nrewrite -{2}mulGid mulgSS ?subsetIr //.\napply/subsetP => _ /setIP[/mulsgP[a b Aa Bb ->] Gab].\nby rewrite mem_mulg // inE Bb -(groupMl _ (subsetP sAG _ Aa)).\nQed.",
    "Lemma group_modr A B G : B \\subset G -> (G :&: A) * B = G :&: A * B.\nProof.\nmove=> sBG; apply: invg_inj; rewrite !(invMg, invIg) invGid !(setIC G).\nby rewrite group_modl // -invGid invSg.\nQed.",
    "Lemma group_setI G H : group_set (G :&: H).\nProof.\napply/group_setP; split=> [|x y]; rewrite !inE ?group1 //.\nby case/andP=> Gx Hx; rewrite !groupMl.\nQed.",
    "Lemma group_set_bigcap : group_set (\\bigcap_(i | P i) F i).\nProof.\nby elim/big_rec: _ => [|i G _ gG]; rewrite -1?(insubdK 1%G gG) groupP.\nQed.",
    "Lemma group_set_generated (A : {set gT}) : group_set <<A>>.\nProof. by rewrite unlock group_set_bigcap. Qed.",
    "Lemma order_gt0 (x : gT) : 0 < #[x].\nProof. exact: cardG_gt0. Qed.",
    "Lemma LagrangeI G H : (#|G :&: H| * #|G : H|)%N = #|G|.\nProof.\nrewrite -[#|G|]sum1_card (partition_big_imset (rcoset H)) /=.\nrewrite mulnC -sum_nat_const; apply: eq_bigr => _ /rcosetsP[x Gx ->].\nrewrite -(card_rcoset _ x) -sum1_card; apply: eq_bigl => y.\nby rewrite rcosetE (sameP eqP rcoset_eqP) group_modr ?sub1set // !inE.\nQed.",
    "Lemma divgI G H : #|G| %/ #|G :&: H| = #|G : H|.\nProof. by rewrite -(LagrangeI G H) mulKn ?cardG_gt0. Qed.",
    "Lemma divg_index G H : #|G| %/ #|G : H| = #|G :&: H|.\nProof. by rewrite -(LagrangeI G H) mulnK. Qed.",
    "Lemma dvdn_indexg G H : #|G : H| %| #|G|.\nProof. by rewrite -(LagrangeI G H) dvdn_mull. Qed.",
    "Lemma cardSg G H : H \\subset G -> #|H| %| #|G|.\nProof. by move/Lagrange <-; rewrite dvdn_mulr. Qed.",
    "Lemma lognSg p G H : G \\subset H -> logn p #|G| <= logn p #|H|.\nProof. by move=> sGH; rewrite dvdn_leq_log ?cardSg. Qed.",
    "Lemma piSg G H : G \\subset H -> {subset \\pi(gval G) <= \\pi(gval H)}.\nProof.\nmove=> sGH p; rewrite !mem_primes !cardG_gt0 => /and3P[-> _ pG].\nexact: dvdn_trans (cardSg sGH).\nQed.",
    "Lemma divgS G H : H \\subset G -> #|G| %/ #|H| = #|G : H|.\nProof. by move/Lagrange <-; rewrite mulKn. Qed.",
    "Lemma divg_indexS G H : H \\subset G -> #|G| %/ #|G : H| = #|H|.\nProof. by move/Lagrange <-; rewrite mulnK. Qed.",
    "Lemma coprimeSg G H p : H \\subset G -> coprime #|G| p -> coprime #|H| p.\nProof. by move=> sHG; apply: coprime_dvdl (cardSg sHG). Qed.",
    "Lemma coprimegS G H p : H \\subset G -> coprime p #|G| -> coprime p #|H|.\nProof. by move=> sHG; apply: coprime_dvdr (cardSg sHG). Qed.",
    "Lemma indexJg G H x : #|G :^ x : H :^ x| = #|G : H|.\nProof. by rewrite -!divgI -conjIg !cardJg. Qed.",
    "Lemma indexgg G : #|G : G| = 1%N.\nProof. by rewrite -divgS // divnn cardG_gt0. Qed.",
    "Lemma rcosets_id G : rcosets G G = [set G : {set gT}].\nProof.\napply/esym/eqP; rewrite eqEcard sub1set [#|_|]indexgg cards1 andbT.\nby apply/rcosetsP; exists 1; rewrite ?mulg1.\nQed.",
    "Lemma Lagrange_index G H K :\n  H \\subset G -> K \\subset H -> (#|G : H| * #|H : K|)%N = #|G : K|.\nProof.\nmove=> sHG sKH; apply/eqP; rewrite mulnC -(eqn_pmul2l (cardG_gt0 K)).\nby rewrite mulnA !Lagrange // (subset_trans sKH).\nQed.",
    "Lemma indexgI G H : #|G : G :&: H| = #|G : H|.\nProof. by rewrite -divgI divgS ?subsetIl. Qed.",
    "Lemma indexgS G H K : H \\subset K -> #|G : K| %| #|G : H|.\nProof.\nmove=> sHK; rewrite -(@dvdn_pmul2l #|G :&: K|) ?cardG_gt0 // LagrangeI.\nby rewrite -(Lagrange (setIS G sHK)) mulnAC LagrangeI dvdn_mulr.\nQed.",
    "Lemma indexSg G H K : H \\subset K -> K \\subset G -> #|K : H| %| #|G : H|.\nProof.\nmove=> sHK sKG; rewrite -(@dvdn_pmul2l #|H|) ?cardG_gt0 //.\nby rewrite !Lagrange ?(cardSg, subset_trans sHK).\nQed.",
    "Lemma indexg_eq1 G H : (#|G : H| == 1%N) = (G \\subset H).\nProof.\nrewrite eqn_leq -(leq_pmul2l (cardG_gt0 (G :&: H))) LagrangeI muln1.\nby rewrite indexg_gt0 andbT (sameP setIidPl eqP) eqEcard subsetIl.\nQed.",
    "Lemma indexg_gt1 G H : (#|G : H| > 1) = ~~ (G \\subset H).\nProof. by rewrite -indexg_eq1 eqn_leq indexg_gt0 andbT -ltnNge. Qed.",
    "Lemma index1g G H : H \\subset G -> #|G : H| = 1%N -> H :=: G.\nProof. by move=> sHG iHG; apply/eqP; rewrite eqEsubset sHG -indexg_eq1 iHG. Qed.",
    "Lemma indexg1 G : #|G : 1| = #|G|.\nProof. by rewrite -divgS ?sub1G // cards1 divn1. Qed.",
    "Lemma indexMg G A : #|G * A : G| = #|A : G|.\nProof.\napply/eq_card/setP/eqP; rewrite eqEsubset andbC imsetS ?mulG_subr //.\nby apply/subsetP=> _ /rcosetsP[x GAx ->]; rewrite mem_rcosets.\nQed.",
    "Lemma rcosets_partition_mul G H : partition (rcosets H G) (H * G).\nProof.\nset HG := H * G; have sGHG: {subset G <= HG} by apply/subsetP/mulG_subr.\nhave defHx x: x \\in HG -> [set y in HG | rcoset H x == rcoset H y] = H :* x.\n  move=> HGx; apply/setP=> y; rewrite inE !rcosetE (sameP eqP rcoset_eqP).\n  by rewrite rcoset_sym; apply/andb_idl/subsetP; rewrite mulGS sub1set.\nhave:= preim_partitionP (rcoset H) HG; congr (partition _ _); apply/setP=> Hx.\napply/imsetP/idP=> [[x HGx ->] | ]; first by rewrite defHx // mem_rcosets.\nby case/rcosetsP=> x /sGHG-HGx ->; exists x; rewrite ?defHx.\nQed.",
    "Lemma rcosets_partition G H : H \\subset G -> partition (rcosets H G) G.\nProof. by move=> sHG; have:= rcosets_partition_mul G H; rewrite mulSGid. Qed.",
    "Lemma LagrangeMl G H : (#|G| * #|H : G|)%N = #|G * H|.\nProof.\nrewrite mulnC -(card_uniform_partition _ (rcosets_partition_mul H G)) //.\nby move=> _ /rcosetsP[x Hx ->]; rewrite card_rcoset.\nQed.",
    "Lemma LagrangeMr G H : (#|G : H| * #|H|)%N = #|G * H|.\nProof. by rewrite mulnC LagrangeMl -card_invg invMg !invGid. Qed.",
    "Lemma mul_cardG G H : (#|G| * #|H| = #|G * H|%g * #|G :&: H|)%N.\nProof. by rewrite -LagrangeMr -(LagrangeI G H) -mulnA mulnC. Qed.",
    "Lemma dvdn_cardMg G H : #|G * H| %| #|G| * #|H|.\nProof. by rewrite mul_cardG dvdn_mulr. Qed.",
    "Lemma cardMg_divn G H : #|G * H| = (#|G| * #|H|) %/ #|G :&: H|.\nProof. by rewrite mul_cardG mulnK ?cardG_gt0. Qed.",
    "Lemma cardIg_divn G H : #|G :&: H| = (#|G| * #|H|) %/ #|G * H|.\nProof. by rewrite mul_cardG mulKn // (cardD1 (1 * 1)) mem_mulg. Qed.",
    "Lemma TI_cardMg G H : G :&: H = 1 -> #|G * H| = (#|G| * #|H|)%N.\nProof. by move=> tiGH; rewrite mul_cardG tiGH cards1 muln1. Qed.",
    "Lemma cardMg_TI G H : #|G| * #|H| <= #|G * H| -> G :&: H = 1.\nProof.\nmove=> leGH; apply: card_le1_trivg.\nrewrite -(@leq_pmul2l #|G * H|); first by rewrite -mul_cardG muln1.\nby apply: leq_trans leGH; rewrite muln_gt0 !cardG_gt0.\nQed.",
    "Lemma coprime_TIg G H : coprime #|G| #|H| -> G :&: H = 1.\nProof.\nmove=> coGH; apply/eqP; rewrite trivg_card1 -dvdn1 -{}(eqnP coGH).\nby rewrite dvdn_gcd /= {2}setIC !cardSg ?subsetIl.\nQed.",
    "Lemma prime_TIg G H : prime #|G| -> ~~ (G \\subset H) -> G :&: H = 1.\nProof.\ncase/primeP=> _ /(_ _ (cardSg (subsetIl G H))).\nrewrite (sameP setIidPl eqP) eqEcard subsetIl => /pred2P[/card1_trivg|] //= ->.\nby case/negP.\nQed.",
    "Lemma prime_meetG G H : prime #|G| -> G :&: H != 1 -> G \\subset H.\nProof. by move=> prG; apply: contraR; move/prime_TIg->. Qed.",
    "Lemma coprime_cardMg G H : coprime #|G| #|H| -> #|G * H| = (#|G| * #|H|)%N.\nProof. by move=> coGH; rewrite TI_cardMg ?coprime_TIg. Qed.",
    "Lemma coprime_index_mulG G H K :\n  H \\subset G -> K \\subset G -> coprime #|G : H| #|G : K| -> H * K = G.\nProof.\nmove=> sHG sKG co_iG_HK; apply/eqP; rewrite eqEcard mul_subG //=.\nrewrite -(@leq_pmul2r #|H :&: K|) ?cardG_gt0 // -mul_cardG.\nrewrite -(Lagrange sHG) -(LagrangeI K H) mulnAC setIC -mulnA.\nrewrite !leq_pmul2l ?cardG_gt0 // dvdn_leq // -(Gauss_dvdr _ co_iG_HK).\nby rewrite -(indexgI K) Lagrange_index ?indexgS ?subsetIl ?subsetIr.\nQed.",
    "Lemma subset_gen A : A \\subset <<A>>.\nProof. rewrite [@generated]unlock; exact/bigcapsP. Qed.",
    "Lemma sub_gen A B : A \\subset B -> A \\subset <<B>>.\nProof. by move/subset_trans=> -> //; apply: subset_gen. Qed.",
    "Lemma mem_gen x A : x \\in A -> x \\in <<A>>.\nProof. exact: subsetP (subset_gen A) x. Qed.",
    "Lemma generatedP x A : reflect (forall G, A \\subset G -> x \\in G) (x \\in <<A>>).\nProof. rewrite [@generated]unlock; exact: bigcapP. Qed.",
    "Lemma gen_subG A G : (<<A>> \\subset G) = (A \\subset G).\nProof.\napply/idP/idP=> [|sAG]; first exact: subset_trans (subset_gen A).\nby apply/subsetP=> x /generatedP; apply.\nQed.",
    "Lemma genGid G : <<G>> = G.\nProof. by apply/eqP; rewrite eqEsubset gen_subG subset_gen andbT. Qed.",
    "Lemma genGidG G : <<G>>%G = G.\nProof. by apply: val_inj; apply: genGid. Qed.",
    "Lemma gen_set_id A : group_set A -> <<A>> = A.\nProof. by move=> gA; apply: (genGid (group gA)). Qed.",
    "Lemma genS A B : A \\subset B -> <<A>> \\subset <<B>>.\nProof. by move=> sAB; rewrite gen_subG sub_gen. Qed.",
    "Lemma gen0 : <<set0>> = 1 :> {set gT}.\nProof. by apply/eqP; rewrite eqEsubset sub1G gen_subG sub0set. Qed.",
    "Lemma gen_expgs A : {n | <<A>> = (1 |: A) ^+ n}.\nProof.\nset B := (1 |: A); pose N := #|gT|.\nhave BsubG n : B ^+ n \\subset <<A>>.\n  by elim: n => [|n IHn]; rewrite ?expgS ?mul_subG ?subUset ?sub1G ?subset_gen.\nhave B_1 n : 1 \\in B ^+ n.\n  by elim: n => [|n IHn]; rewrite ?set11 // expgS mulUg mul1g inE IHn.\ncase: (pickP (fun i : 'I_N => B ^+ i.+1 \\subset B ^+ i)) => [n fixBn | no_fix].\n  exists n; apply/eqP; rewrite eqEsubset BsubG andbT.\n  rewrite -[B ^+ n]gen_set_id ?genS ?subsetUr //.\n    by apply: subset_trans fixBn; rewrite expgS mulUg subsetU ?mulg_subl ?orbT.\n  rewrite /group_set B_1 /=.\n  elim: {2}(n : nat) => [|m IHm]; first by rewrite mulg1.\n  by apply: subset_trans fixBn; rewrite !expgSr mulgA mulSg.\nsuffices: N < #|B ^+ N| by rewrite ltnNge max_card.\nhave [] := ubnPgeq N; elim=> [|n IHn] lt_nN; first by rewrite cards1.\napply: leq_ltn_trans (IHn (ltnW lt_nN)) (proper_card _).\nby rewrite /proper (no_fix (Ordinal lt_nN)) expgS mulUg mul1g subsetUl.\nQed.",
    "Lemma gen_prodgP A x :\n  reflect (exists n, exists2 c, forall i : 'I_n, c i \\in A & x = \\prod_i c i)\n          (x \\in <<A>>).\nProof.\napply: (iffP idP) => [|[n [c Ac ->]]]; last first.\n  by apply: group_prod => i _; rewrite mem_gen ?Ac.\nhave [n ->] := gen_expgs A; rewrite /expgn Monoid.iteropE /=.\nrewrite -[n]card_ord -big_const => /prodsgP[/= c Ac def_x]. \nhave{Ac def_x} ->: x = \\prod_(i | c i \\in A) c i.\n  rewrite big_mkcond {x}def_x; apply: eq_bigr => i _.\n  by case/setU1P: (Ac i isT) => -> //; rewrite if_same.\nhave [e <- [_ /= mem_e] _] := big_enumP [preim c of A].\npose t := in_tuple e; rewrite -[e]/(val t) big_tuple.\nby exists (size e), (c \\o tnth t) => // i; rewrite -mem_e mem_tnth.\nQed.",
    "Lemma genD A B : A \\subset <<A :\\: B>> -> <<A :\\: B>> = <<A>>.\nProof.\nby move=> sAB; apply/eqP; rewrite eqEsubset genS (subsetDl, gen_subG).\nQed.",
    "Lemma genV A : <<A^-1>> = <<A>>.\nProof.\napply/eqP; rewrite eqEsubset !gen_subG -!(invSg _ <<_>>) invgK.\nby rewrite !invGid !subset_gen.\nQed.",
    "Lemma genJ A z : <<A :^z>> = <<A>> :^ z.\nProof.\nby apply/eqP; rewrite eqEsubset sub_conjg !gen_subG conjSg -?sub_conjg !sub_gen.\nQed.",
    "Lemma conjYg A B z : (A <*> B) :^z = A :^ z <*> B :^ z.\nProof. by rewrite -genJ conjUg. Qed.",
    "Lemma genD1 A x : x \\in <<A :\\ x>> -> <<A :\\ x>> = <<A>>.\nProof.\nmove=> gA'x; apply/eqP; rewrite eqEsubset genS; last by rewrite subsetDl.\nrewrite gen_subG; apply/subsetP=> y Ay.\nby case: (y =P x) => [-> //|]; move/eqP=> nyx; rewrite mem_gen // !inE nyx.\nQed.",
    "Lemma genD1id A : <<A^#>> = <<A>>.\nProof. by rewrite genD1 ?group1. Qed.",
    "Lemma joingE A B : A <*> B = <<A :|: B>>. Proof. by []. Qed.",
    "Lemma joinGE G H : (G * H)%G = (G <*> H)%G. Proof. by []. Qed.",
    "Lemma joingC : commutative joingT.\nProof. by move=> A B; rewrite /joing setUC. Qed.",
    "Lemma joing_idr A B : A <*> <<B>> = A <*> B.\nProof.\napply/eqP; rewrite eqEsubset gen_subG subUset gen_subG /=.\nby rewrite -subUset subset_gen genS // setUS // subset_gen.\nQed.",
    "Lemma joing_idl A B : <<A>> <*> B = A <*> B.\nProof. by rewrite -!(joingC B) joing_idr. Qed.",
    "Lemma joing_subl A B : A \\subset A <*> B.\nProof. by rewrite sub_gen ?subsetUl. Qed.",
    "Lemma joing_subr A B : B \\subset A <*> B.\nProof. by rewrite sub_gen ?subsetUr. Qed.",
    "Lemma join_subG A B G : (A <*> B \\subset G) = (A \\subset G) && (B \\subset G).\nProof. by rewrite gen_subG subUset. Qed.",
    "Lemma joing_idPl G A : reflect (G <*> A = G) (A \\subset G).\nProof.\napply: (iffP idP) => [sHG | <-]; last by rewrite joing_subr.\nby rewrite joingE (setUidPl sHG) genGid.\nQed.",
    "Lemma joing_idPr A G : reflect (A <*> G = G) (A \\subset G).\nProof. by rewrite joingC; apply: joing_idPl. Qed.",
    "Lemma joing_subP A B G :\n  reflect (A \\subset G /\\ B \\subset G) (A <*> B \\subset G).\nProof. by rewrite join_subG; apply: andP. Qed.",
    "Lemma joing_sub A B C : A <*> B = C -> A \\subset C /\\ B \\subset C.\nProof. by move <-; apply/joing_subP. Qed.",
    "Lemma genDU A B C : A \\subset C -> <<C :\\: A>> = <<B>> -> <<A :|: B>> = <<C>>.\nProof.\nmove=> sAC; rewrite -joingE -joing_idr => <- {B}; rewrite joing_idr.\nby congr <<_>>; rewrite setDE setUIr setUCr setIT; apply/setUidPr.\nQed.",
    "Lemma joingA : associative joingT.\nProof. by move=> A B C; rewrite joing_idl joing_idr /joing setUA. Qed.",
    "Lemma joing1G G : 1 <*> G = G.\nProof. by rewrite -gen0 joing_idl /joing set0U genGid. Qed.",
    "Lemma joingG1 G : G <*> 1 = G.\nProof. by rewrite joingC joing1G. Qed.",
    "Lemma genM_join G H : <<G * H>> = G <*> H.\nProof.\napply/eqP; rewrite eqEsubset gen_subG /= -{1}[G <*> H]mulGid.\nrewrite genS; last by rewrite subUset mulG_subl mulG_subr.\nby rewrite mulgSS ?(sub_gen, subsetUl, subsetUr).\nQed.",
    "Lemma mulG_subG G H K : (G * H \\subset K) = (G \\subset K) && (H \\subset K).\nProof. by rewrite -gen_subG genM_join join_subG. Qed.",
    "Lemma mulGsubP K H G : reflect (K \\subset G /\\ H \\subset G) (K * H \\subset G).\nProof. by rewrite mulG_subG; apply: andP. Qed.",
    "Lemma mulG_sub K H A : K * H = A -> K \\subset A /\\ H \\subset A.\nProof. by move <-; rewrite mulG_subl mulG_subr. Qed.",
    "Lemma trivMg G H : (G * H == 1) = (G :==: 1) && (H :==: 1).\nProof.\nby rewrite !eqEsubset -{2}[1]mulGid mulgSS ?sub1G // !andbT mulG_subG.\nQed.",
    "Lemma comm_joingE G H : commute G H -> G <*> H = G * H.\nProof.\nby move/comm_group_setP=> gGH; rewrite -genM_join; apply: (genGid (group gGH)).\nQed.",
    "Lemma joinGC : commutative joinGT.\nProof. by move=> G H; apply: val_inj; apply: joingC. Qed.",
    "Lemma joinGA : associative joinGT.\nProof. by move=> G H K; apply: val_inj; apply: joingA. Qed.",
    "Lemma join1G : left_id 1%G joinGT.\nProof. by move=> G; apply: val_inj; apply: joing1G. Qed.",
    "Lemma joinG1 : right_id 1%G joinGT.\nProof. by move=> G; apply: val_inj; apply: joingG1. Qed.",
    "Lemma bigprodGEgen I r (P : pred I) (F : I -> {set gT}) :\n  (\\prod_(i <- r | P i) <<F i>>)%G :=: << \\bigcup_(i <- r | P i) F i >>.\nProof.\nelim/big_rec2: _ => /= [|i A _ _ ->]; first by rewrite gen0.\nby rewrite joing_idl joing_idr.\nQed.",
    "Lemma bigprodGE I r (P : pred I) (F : I -> {group gT}) :\n  (\\prod_(i <- r | P i) F i)%G :=: << \\bigcup_(i <- r | P i) F i >>.\nProof.\nrewrite -bigprodGEgen /=; apply: congr_group.\nby apply: eq_bigr => i _; rewrite genGidG.\nQed.",
    "Lemma mem_commg A B x y : x \\in A -> y \\in B -> [~ x, y] \\in [~: A, B].\nProof. by move=> Ax By; rewrite mem_gen ?imset2_f. Qed.",
    "Lemma commSg A B C : A \\subset B -> [~: A, C] \\subset [~: B, C].\nProof. by move=> sAC; rewrite genS ?imset2S. Qed.",
    "Lemma commgS A B C : B \\subset C -> [~: A, B] \\subset [~: A, C].\nProof. by move=> sBC; rewrite genS ?imset2S. Qed.",
    "Lemma commgSS A B C D :\n  A \\subset B -> C \\subset D -> [~: A, C] \\subset [~: B, D].\nProof. by move=> sAB sCD; rewrite genS ?imset2S. Qed.",
    "Lemma der1_subG G : [~: G, G] \\subset G.\nProof.\nby rewrite gen_subG; apply/subsetP=> _ /imset2P[x y Gx Gy ->]; apply: groupR.\nQed.",
    "Lemma comm_subG A B G : A \\subset G -> B \\subset G -> [~: A, B] \\subset G.\nProof.\nby move=> sAG sBG; apply: subset_trans (der1_subG G); apply: commgSS.\nQed.",
    "Lemma commGC A B : [~: A, B] = [~: B, A].\nProof.\nrewrite -[[~: A, B]]genV; congr <<_>>; apply/setP=> z; rewrite inE.\nby apply/imset2P/imset2P=> [] [x y Ax Ay]; last rewrite -{1}(invgK z);\n  rewrite -invg_comm => /invg_inj->; exists y x.\nQed.",
    "Lemma conjsRg A B x : [~: A, B] :^ x = [~: A :^ x, B :^ x].\nProof.\nwlog suffices: A B x / [~: A, B] :^ x \\subset [~: A :^ x, B :^ x].\n  move=> subJ; apply/eqP; rewrite eqEsubset subJ /= -sub_conjgV.\n  by rewrite -{2}(conjsgK x A) -{2}(conjsgK x B).\nrewrite -genJ gen_subG; apply/subsetP=> _ /imsetP[_ /imset2P[y z Ay Bz ->] ->].\nby rewrite conjRg mem_commg ?memJ_conjg.\nQed.",
    "Lemma cycle1 : <[1]> = [1 gT].\nProof. exact: genGid. Qed.",
    "Lemma order1 : #[1 : gT] = 1%N.\nProof. by rewrite /order cycle1 cards1. Qed.",
    "Lemma cycle_id x : x \\in <[x]>.\nProof. by rewrite mem_gen // set11. Qed.",
    "Lemma mem_cycle x i : x ^+ i \\in <[x]>.\nProof. by rewrite groupX // cycle_id. Qed.",
    "Lemma cycle_subG x G : (<[x]> \\subset G) = (x \\in G).\nProof. by rewrite gen_subG sub1set. Qed.",
    "Lemma cycle_eq1 x : (<[x]> == 1) = (x == 1).\nProof. by rewrite eqEsubset sub1G andbT cycle_subG inE. Qed.",
    "Lemma orderE x : #[x] = #|<[x]>|. Proof. by []. Qed.",
    "Lemma order_eq1 x : (#[x] == 1%N) = (x == 1).\nProof. by rewrite -trivg_card1 cycle_eq1. Qed.",
    "Lemma order_gt1 x : (#[x] > 1) = (x != 1).\nProof. by rewrite ltnNge -trivg_card_le1 cycle_eq1. Qed.",
    "Lemma cycle_traject x : <[x]> =i traject (mulg x) 1 #[x].\nProof.\nset t := _ 1; apply: fsym; apply/subset_cardP; last first.\n  by apply/subsetP=> _ /trajectP[i _ ->]; rewrite -iteropE mem_cycle.\nrewrite (card_uniqP _) ?size_traject //; case def_n: #[_] => // [n].\nrewrite looping_uniq; apply: contraL (card_size (t n)) => /loopingP t_xi.\nrewrite -ltnNge size_traject -def_n ?subset_leq_card //.\nrewrite -(eq_subset_r (in_set _)) {}/t; set G := finset _.\nrewrite -[x]mulg1 -[G]gen_set_id ?genS ?sub1set ?inE ?(t_xi 1%N)//.\napply/group_setP; split=> [|y z]; rewrite !inE ?(t_xi 0) //.\nby do 2!case/trajectP=> ? _ ->; rewrite -!iteropE -expgD [x ^+ _]iteropE.\nQed.",
    "Lemma cycle2g x : #[x] = 2 -> <[x]> = [set 1; x].\nProof. by move=> ox; apply/setP=> y; rewrite cycle_traject ox !inE mulg1. Qed.",
    "Lemma cyclePmin x y : y \\in <[x]> -> {i | i < #[x] & y = x ^+ i}.\nProof.\nrewrite cycle_traject; set tx := traject _ _ #[x] => tx_y; pose i := index y tx.\nhave lt_i_x : i < #[x] by rewrite -index_mem size_traject in tx_y.\nby exists i; rewrite // [x ^+ i]iteropE /= -(nth_traject _ lt_i_x) nth_index.\nQed.",
    "Lemma cycleP x y : reflect (exists i, y = x ^+ i) (y \\in <[x]>).\nProof.\nby apply: (iffP idP) => [/cyclePmin[i _]|[i ->]]; [exists i | apply: mem_cycle].\nQed.",
    "Lemma expg_order x : x ^+ #[x] = 1.\nProof.\nhave: uniq (traject (mulg x) 1 #[x]).\n  by apply/card_uniqP; rewrite size_traject -(eq_card (cycle_traject x)).\ncase/cyclePmin: (mem_cycle x #[x]) => [] [//|i] ltix.\nrewrite -(subnKC ltix) addSnnS /= expgD; move: (_ - _) => j x_j1.\ncase/andP=> /trajectP[]; exists j; first exact: leq_addl.\nby apply: (mulgI (x ^+ i.+1)); rewrite -iterSr iterS -iteropE -expgS mulg1.\nQed.",
    "Lemma expg_mod p k x : x ^+ p = 1 -> x ^+ (k %% p) = x ^+ k.\nProof.\nmove=> xp.\nby rewrite {2}(divn_eq k p) expgD mulnC expgM xp expg1n mul1g.\nQed.",
    "Lemma expg_mod_order x i : x ^+ (i %% #[x]) = x ^+ i.\nProof. by rewrite expg_mod // expg_order. Qed.",
    "Lemma invg_expg x : x^-1 = x ^+ #[x].-1.\nProof. by apply/eqP; rewrite eq_invg_mul -expgS prednK ?expg_order. Qed.",
    "Lemma invg2id x : #[x] = 2 -> x^-1 = x.\nProof. by move=> ox; rewrite invg_expg ox. Qed.",
    "Lemma cycleX x i : <[x ^+ i]> \\subset <[x]>.\nProof. by rewrite cycle_subG; apply: mem_cycle. Qed.",
    "Lemma cycleV x : <[x^-1]> = <[x]>.\nProof.\nby apply/eqP; rewrite eq_sym eqEsubset !cycle_subG groupV -groupV !cycle_id.\nQed.",
    "Lemma orderV x : #[x^-1] = #[x].\nProof. by rewrite /order cycleV. Qed.",
    "Lemma cycleJ x y : <[x ^ y]> = <[x]> :^ y.\nProof. by rewrite -genJ conjg_set1. Qed.",
    "Lemma orderJ x y : #[x ^ y] = #[x].\nProof. by rewrite /order cycleJ cardJg. Qed.",
    "Lemma normP x A : reflect (A :^ x = A) (x \\in 'N(A)).\nProof.\nsuffices ->: (x \\in 'N(A)) = (A :^ x == A) by apply: eqP.\nby rewrite eqEcard cardJg leqnn andbT inE.\nQed.",
    "Lemma group_set_normaliser A : group_set 'N(A).\nProof.\napply/group_setP; split=> [|x y Nx Ny]; rewrite inE ?conjsg1 //.\nby rewrite conjsgM !(normP _).\nQed.",
    "Lemma normsP A B : reflect {in A, normalised B} (A \\subset 'N(B)).\nProof.\napply: (iffP subsetP) => nBA x Ax; last by rewrite inE nBA //.\nby apply/normP; apply: nBA.\nQed.",
    "Lemma memJ_norm x y A : x \\in 'N(A) -> (y ^ x \\in A) = (y \\in A).\nProof. by move=> Nx; rewrite -{1}(normP Nx) memJ_conjg. Qed.",
    "Lemma norms_cycle x y : (<[y]> \\subset 'N(<[x]>)) = (x ^ y \\in <[x]>).\nProof. by rewrite cycle_subG inE -cycleJ cycle_subG. Qed.",
    "Lemma norm1 : 'N(1) =  setT :> {set gT}.\nProof. by apply/setP=> x; rewrite !inE conjs1g subxx. Qed.",
    "Lemma norms1 A : A \\subset 'N(1).\nProof. by rewrite norm1 subsetT. Qed.",
    "Lemma normCs A : 'N(~: A) = 'N(A).\nProof. by apply/setP=> x; rewrite -groupV !inE conjCg setCS sub_conjg. Qed.",
    "Lemma normG G : G \\subset 'N(G).\nProof. by apply/normsP; apply: conjGid. Qed.",
    "Lemma normT : 'N([set: gT]) = [set: gT].\nProof. by apply/eqP; rewrite -subTset normG. Qed.",
    "Lemma normsG A G : A \\subset G -> A \\subset 'N(G).\nProof. by move=> sAG; apply: subset_trans (normG G). Qed.",
    "Lemma normC A B : A \\subset 'N(B) -> commute A B.\nProof.\nmove/subsetP=> nBA; apply/setP=> u.\napply/mulsgP/mulsgP=> [[x y Ax By] | [y x By Ax]] -> {u}.\n  by exists (y ^ x^-1) x; rewrite -?conjgCV // memJ_norm // groupV nBA.\nby exists x (y ^ x); rewrite -?conjgC // memJ_norm // nBA.\nQed.",
    "Lemma norm_joinEl G H : G \\subset 'N(H) -> G <*> H = G * H.\nProof. by move/normC/comm_joingE. Qed.",
    "Lemma norm_joinEr G H : H \\subset 'N(G) -> G <*> H = G * H.\nProof. by move/normC=> cHG; apply: comm_joingE. Qed.",
    "Lemma norm_rlcoset G x : x \\in 'N(G) -> G :* x = x *: G.\nProof. by rewrite -sub1set => /normC. Qed.",
    "Lemma rcoset_mul G x y : x \\in 'N(G) -> (G :* x) * (G :* y) = G :* (x * y).\nProof.\nmove/norm_rlcoset=> GxxG.\nby rewrite mulgA -(mulgA _ _ G) -GxxG mulgA mulGid -mulgA mulg_set1.\nQed.",
    "Lemma normJ A x : 'N(A :^ x) = 'N(A) :^ x.\nProof.\nby apply/setP=> y; rewrite mem_conjg !inE -conjsgM conjgCV conjsgM conjSg.\nQed.",
    "Lemma norm_conj_norm x A B :\n  x \\in 'N(A) -> (A \\subset 'N(B :^ x)) = (A \\subset 'N(B)).\nProof. by move=> Nx; rewrite normJ -sub_conjgV (normP _) ?groupV. Qed.",
    "Lemma norm_gen A : 'N(A) \\subset 'N(<<A>>).\nProof. by apply/normsP=> x Nx; rewrite -genJ (normP Nx). Qed.",
    "Lemma class_norm x G : G \\subset 'N(x ^: G).\nProof. by apply/normsP=> y; apply: classGidr. Qed.",
    "Lemma class_normal x G : x \\in G -> x ^: G <| G.\nProof. by move=> Gx; rewrite /normal class_norm class_subG. Qed.",
    "Lemma class_sub_norm G A x : G \\subset 'N(A) -> (x ^: G \\subset A) = (x \\in A).\nProof.\nmove=> nAG; apply/subsetP/idP=> [-> // | Ax xy]; first exact: class_refl.\nby case/imsetP=> y Gy ->; rewrite memJ_norm ?(subsetP nAG).\nQed.",
    "Lemma class_support_norm A G : G \\subset 'N(class_support A G).\nProof. by apply/normsP; apply: class_supportGidr. Qed.",
    "Lemma class_support_sub_norm A B G :\n  A \\subset G -> B \\subset 'N(G) -> class_support A B \\subset G.\nProof.\nmove=> sAG nGB; rewrite class_supportEr.\nby apply/bigcupsP=> x Bx; rewrite -(normsP nGB x Bx) conjSg.\nQed.",
    "Lemma norms_gen : A \\subset 'N(<<B>>).\nProof. exact: subset_trans nBA (norm_gen B). Qed.",
    "Lemma norms_norm : A \\subset 'N('N(B)).\nProof. by apply/normsP=> x Ax; rewrite -normJ (normsP nBA). Qed.",
    "Lemma normsI : A \\subset 'N(B :&: C).\nProof. by apply/normsP=> x Ax; rewrite conjIg !(normsP _ x Ax). Qed.",
    "Lemma normsU : A \\subset 'N(B :|: C).\nProof. by apply/normsP=> x Ax; rewrite conjUg !(normsP _ x Ax). Qed.",
    "Lemma normsIs : B \\subset 'N(D) -> A :&: B \\subset 'N(C :&: D).\nProof.\nmove/normsP=> nDB; apply/normsP=> x; case/setIP=> Ax Bx.\nby rewrite conjIg (normsP nCA) ?nDB.\nQed.",
    "Lemma normsD : A \\subset 'N(B :\\: C).\nProof. by apply/normsP=> x Ax; rewrite conjDg !(normsP _ x Ax). Qed.",
    "Lemma normsM : A \\subset 'N(B * C).\nProof. by apply/normsP=> x Ax; rewrite conjsMg !(normsP _ x Ax). Qed.",
    "Lemma normsY : A \\subset 'N(B <*> C).\nProof. by apply/normsP=> x Ax; rewrite -genJ conjUg !(normsP _ x Ax). Qed.",
    "Lemma normsR : A \\subset 'N([~: B, C]).\nProof. by apply/normsP=> x Ax; rewrite conjsRg !(normsP _ x Ax). Qed.",
    "Lemma norms_class_support : A \\subset 'N(class_support B C).\nProof.\napply/subsetP=> x Ax; rewrite inE sub_conjg class_supportEr.\napply/bigcupsP=> y Cy; rewrite -sub_conjg -conjsgM conjgC conjsgM.\nby rewrite (normsP nBA) // bigcup_sup ?memJ_norm ?(subsetP nCA).\nQed.",
    "Lemma normsIG A B G : A \\subset 'N(B) -> A :&: G \\subset 'N(B :&: G).\nProof. by move/normsIs->; rewrite ?normG. Qed.",
    "Lemma normsGI A B G : A \\subset 'N(B) -> G :&: A \\subset 'N(G :&: B).\nProof. by move=> nBA; rewrite !(setIC G) normsIG. Qed.",
    "Lemma norms_bigcap I r (P : pred I) A (B_ : I -> {set gT}) :\n    A \\subset \\bigcap_(i <- r | P i) 'N(B_ i) ->\n  A \\subset 'N(\\bigcap_(i <- r | P i) B_ i).\nProof.\nelim/big_rec2: _ => [|i B N _ IH /subsetIP[nBiA /IH]]; last exact: normsI.\nby rewrite normT.\nQed.",
    "Lemma norms_bigcup I r (P : pred I) A (B_ : I -> {set gT}) :\n    A \\subset \\bigcap_(i <- r | P i) 'N(B_ i) ->\n  A \\subset 'N(\\bigcup_(i <- r | P i) B_ i).\nProof.\nmove=> nBA; rewrite -normCs setC_bigcup norms_bigcap //.\nby rewrite (eq_bigr _ (fun _ _ => normCs _)).\nQed.",
    "Lemma normsD1 A B : A \\subset 'N(B) -> A \\subset 'N(B^#).\nProof. by move/normsD->; rewrite ?norms1. Qed.",
    "Lemma normD1 A : 'N(A^#) = 'N(A).\nProof.\napply/eqP; rewrite eqEsubset normsD1 //.\nrewrite -{2}(setID A 1) setIC normsU //; apply/normsP=> x _; apply/setP=> y.\nby rewrite conjIg conjs1g !inE mem_conjg; case: eqP => // ->; rewrite conj1g.\nQed.",
    "Lemma normalP A B : reflect (A \\subset B /\\ {in B, normalised A}) (A <| B).\nProof. by apply: (iffP andP)=> [] [sAB]; move/normsP. Qed.",
    "Lemma normal_sub A B : A <| B -> A \\subset B.\nProof. by case/andP. Qed.",
    "Lemma normal_norm A B : A <| B -> B \\subset 'N(A).\nProof. by case/andP. Qed.",
    "Lemma normalS G H K : K \\subset H -> H \\subset G -> K <| G -> K <| H.\nProof.\nby move=> sKH sHG /andP[_ nKG]; rewrite /(K <| _) sKH (subset_trans sHG).\nQed.",
    "Lemma normal1 G : 1 <| G.\nProof. by rewrite /normal sub1set group1 norms1. Qed.",
    "Lemma normal_refl G : G <| G.\nProof. by rewrite /(G <| _) normG subxx. Qed.",
    "Lemma normalG G : G <| 'N(G).\nProof. by rewrite /(G <| _) normG subxx. Qed.",
    "Lemma normalSG G H : H \\subset G -> H <| 'N_G(H).\nProof. by move=> sHG; rewrite /normal subsetI sHG normG subsetIr. Qed.",
    "Lemma normalJ A B x : (A :^ x <| B :^ x) = (A <| B).\nProof. by rewrite /normal normJ !conjSg. Qed.",
    "Lemma normalM G A B : A <| G -> B <| G -> A * B <| G.\nProof.\nby case/andP=> sAG nAG /andP[sBG nBG]; rewrite /normal mul_subG ?normsM.\nQed.",
    "Lemma normalY G A B : A <| G -> B <| G -> A <*> B <| G.\nProof.\nby case/andP=> sAG ? /andP[sBG ?]; rewrite /normal join_subG sAG sBG ?normsY.\nQed.",
    "Lemma normalYl G H : (H <| H <*> G) = (G \\subset 'N(H)).\nProof. by rewrite /normal joing_subl join_subG normG. Qed.",
    "Lemma normalYr G H : (H <| G <*> H) = (G \\subset 'N(H)).\nProof. by rewrite joingC normalYl. Qed.",
    "Lemma normalI G A B : A <| G -> B <| G -> A :&: B <| G.\nProof.\nby case/andP=> sAG nAG /andP[_ nBG]; rewrite /normal subIset ?sAG // normsI.\nQed.",
    "Lemma norm_normalI G A : G \\subset 'N(A) -> G :&: A <| G.\nProof. by move=> nAG; rewrite /normal subsetIl normsI ?normG. Qed.",
    "Lemma normalGI G H A : H \\subset G -> A <| G -> H :&: A <| H.\nProof.\nby move=> sHG /andP[_ nAG]; apply: norm_normalI (subset_trans sHG nAG).\nQed.",
    "Lemma normal_subnorm G H : (H <| 'N_G(H)) = (H \\subset G).\nProof. by rewrite /normal subsetIr subsetI normG !andbT. Qed.",
    "Lemma normalD1 A G : (A^# <| G) = (A <| G).\nProof. by rewrite /normal normD1 subDset (setUidPr (sub1G G)). Qed.",
    "Lemma gcore_sub A G : gcore A G \\subset A.\nProof. by rewrite (bigcap_min 1) ?conjsg1. Qed.",
    "Lemma gcore_norm A G : G \\subset 'N(gcore A G).\nProof.\napply/subsetP=> x Gx; rewrite inE; apply/bigcapsP=> y Gy.\nby rewrite sub_conjg -conjsgM bigcap_inf ?groupM ?groupV.\nQed.",
    "Lemma gcore_normal A G : A \\subset G -> gcore A G <| G.\nProof.\nby move=> sAG; rewrite /normal gcore_norm (subset_trans (gcore_sub A G)).\nQed.",
    "Lemma gcore_max A B G : B \\subset A -> G \\subset 'N(B) -> B \\subset gcore A G.\nProof.\nmove=> sBA nBG; apply/bigcapsP=> y Gy.\nby rewrite -sub_conjgV (normsP nBG) ?groupV.\nQed.",
    "Lemma sub_gcore A B G :\n  G \\subset 'N(B) -> (B \\subset gcore A G) = (B \\subset A).\nProof.\nmove=> nBG; apply/idP/idP=> [sBAG | sBA]; last exact: gcore_max.\nexact: subset_trans (gcore_sub A G).\nQed.",
    "Lemma rcoset_index2 G H x :\n  H \\subset G -> #|G : H| = 2 -> x \\in G :\\: H -> H :* x = G :\\: H.\nProof.\nmove=> sHG indexHG => /setDP[Gx notHx]; apply/eqP.\nrewrite eqEcard -(leq_add2l #|G :&: H|) cardsID -(LagrangeI G H) indexHG muln2.\nrewrite (setIidPr sHG) card_rcoset addnn leqnn andbT.\napply/subsetP=> _ /rcosetP[y Hy ->]; apply/setDP.\nby rewrite !groupMl // (subsetP sHG).\nQed.",
    "Lemma index2_normal G H : H \\subset G -> #|G : H| = 2 -> H <| G.\nProof.\nmove=> sHG indexHG; rewrite /normal sHG; apply/subsetP=> x Gx.\ncase Hx: (x \\in H); first by rewrite inE conjGid.\nrewrite inE conjsgE mulgA -sub_rcosetV -invg_rcoset.\nby rewrite !(rcoset_index2 sHG) ?inE ?groupV ?Hx // invDg !invGid.\nQed.",
    "Lemma cent1P x y : reflect (commute x y) (x \\in 'C[y]).\nProof.\nrewrite [x \\in _]inE conjg_set1 sub1set !inE (sameP eqP conjg_fixP)commg1_sym.\nexact: commgP.\nQed.",
    "Lemma cent1id x : x \\in 'C[x]. Proof. exact/cent1P. Qed.",
    "Lemma cent1E x y : (x \\in 'C[y]) = (x * y == y * x).\nProof. by rewrite (sameP (cent1P x y) eqP). Qed.",
    "Lemma cent1C x y : (x \\in 'C[y]) = (y \\in 'C[x]).\nProof. by rewrite !cent1E eq_sym. Qed.",
    "Lemma cent_set1 x : 'C([set x]) = 'C[x].\nProof. by apply: big_pred1 => y /=; rewrite !inE. Qed.",
    "Lemma cent1J x y : 'C[x ^ y] = 'C[x] :^ y.\nProof. by rewrite -conjg_set1 normJ. Qed.",
    "Lemma centP A x : reflect (centralises x A) (x \\in 'C(A)).\nProof. by apply: (iffP bigcapP) => cxA y /cxA/cent1P. Qed.",
    "Lemma centsP A B : reflect {in A, centralised B} (A \\subset 'C(B)).\nProof. by apply: (iffP subsetP) => cAB x /cAB/centP. Qed.",
    "Lemma centsC A B : (A \\subset 'C(B)) = (B \\subset 'C(A)).\nProof. by apply/centsP/centsP=> cAB x ? y ?; rewrite /commute -cAB. Qed.",
    "Lemma cents1 A : A \\subset 'C(1).\nProof. by rewrite centsC sub1G. Qed.",
    "Lemma cent1T : 'C(1) = setT :> {set gT}.\nProof. by apply/eqP; rewrite -subTset cents1. Qed.",
    "Lemma cent11T : 'C[1] = setT :> {set gT}.\nProof. by rewrite -cent_set1 cent1T. Qed.",
    "Lemma cent_sub A : 'C(A) \\subset 'N(A).\nProof.\napply/subsetP=> x /centP cAx; rewrite inE.\nby apply/subsetP=> _ /imsetP[y Ay ->]; rewrite /conjg -cAx ?mulKg.\nQed.",
    "Lemma cents_norm A B : A \\subset 'C(B) -> A \\subset 'N(B).\nProof. by move=> cAB; apply: subset_trans (cent_sub B). Qed.",
    "Lemma centC A B : A \\subset 'C(B) -> commute A B.\nProof. by move=> cAB; apply: normC (cents_norm cAB). Qed.",
    "Lemma cent_joinEl G H : G \\subset 'C(H) -> G <*> H = G * H.\nProof. by move=> cGH; apply: norm_joinEl (cents_norm cGH). Qed.",
    "Lemma cent_joinEr G H : H \\subset 'C(G) -> G <*> H = G * H.\nProof. by move=> cGH; apply: norm_joinEr (cents_norm cGH). Qed.",
    "Lemma centJ A x : 'C(A :^ x) = 'C(A) :^ x.\nProof.\napply/setP=> y; rewrite mem_conjg; apply/centP/centP=> cAy z Az.\n  by apply: (conjg_inj x); rewrite 2!conjMg conjgKV cAy ?memJ_conjg.\nby apply: (conjg_inj x^-1); rewrite 2!conjMg cAy -?mem_conjg.\nQed.",
    "Lemma cent_norm A : 'N(A) \\subset 'N('C(A)).\nProof. by apply/normsP=> x nCx; rewrite -centJ (normP nCx). Qed.",
    "Lemma norms_cent A B : A \\subset 'N(B) -> A \\subset 'N('C(B)).\nProof. by move=> nBA; apply: subset_trans nBA (cent_norm B). Qed.",
    "Lemma cent_normal A : 'C(A) <| 'N(A).\nProof. by rewrite /(_ <| _) cent_sub cent_norm. Qed.",
    "Lemma centS A B : B \\subset A -> 'C(A) \\subset 'C(B).\nProof. by move=> sAB; rewrite centsC (subset_trans sAB) 1?centsC. Qed.",
    "Lemma centsS A B C : A \\subset B -> C \\subset 'C(B) -> C \\subset 'C(A).\nProof. by move=> sAB cCB; apply: subset_trans cCB (centS sAB). Qed.",
    "Lemma centSS A B C D :\n  A \\subset C -> B \\subset D -> C \\subset 'C(D) -> A \\subset 'C(B).\nProof. by move=> sAC sBD cCD; apply: subset_trans (centsS sBD cCD). Qed.",
    "Lemma centI A B : 'C(A) <*> 'C(B) \\subset 'C(A :&: B).\nProof. by rewrite gen_subG subUset !centS ?(subsetIl, subsetIr). Qed.",
    "Lemma centU A B : 'C(A :|: B) = 'C(A) :&: 'C(B).\nProof.\napply/eqP; rewrite eqEsubset subsetI 2?centS ?(subsetUl, subsetUr) //=.\nby rewrite centsC subUset -centsC subsetIl -centsC subsetIr.\nQed.",
    "Lemma cent_gen A : 'C(<<A>>) = 'C(A).\nProof. by apply/setP=> x; rewrite -!sub1set centsC gen_subG centsC. Qed.",
    "Lemma cent_cycle x : 'C(<[x]>) = 'C[x].\nProof. by rewrite cent_gen cent_set1. Qed.",
    "Lemma sub_cent1 A x : (A \\subset 'C[x]) = (x \\in 'C(A)).\nProof. by rewrite -cent_cycle centsC cycle_subG. Qed.",
    "Lemma cents_cycle x y : commute x y -> <[x]> \\subset 'C(<[y]>).\nProof. by move=> cxy; rewrite cent_cycle cycle_subG; apply/cent1P. Qed.",
    "Lemma cycle_abelian x : abelian <[x]>.\nProof. exact: cents_cycle. Qed.",
    "Lemma centY A B : 'C(A <*> B) = 'C(A) :&: 'C(B).\nProof. by rewrite cent_gen centU. Qed.",
    "Lemma centM G H : 'C(G * H) = 'C(G) :&: 'C(H).\nProof. by rewrite -cent_gen genM_join centY. Qed.",
    "Lemma cent_classP x G : reflect (x ^: G = [set x]) (x \\in 'C(G)).\nProof.\napply: (iffP (centP _ _)) => [Cx | Cx1 y Gy].\n  apply/eqP; rewrite eqEsubset sub1set class_refl andbT.\n  by apply/subsetP=> _ /imsetP[y Gy ->]; rewrite !inE conjgE Cx ?mulKg.\nby apply/commgP/conjg_fixP/set1P; rewrite -Cx1; apply/imsetP; exists y.\nQed.",
    "Lemma commG1P A B : reflect ([~: A, B] = 1) (A \\subset 'C(B)).\nProof.\napply: (iffP (centsP A B)) => [cAB | cAB1 x Ax y By].\n  apply/trivgP; rewrite gen_subG; apply/subsetP=> _ /imset2P[x y Ax Ay ->].\n  by rewrite inE; apply/commgP; apply: cAB.\nby apply/commgP; rewrite -in_set1 -[[set 1]]cAB1 mem_commg.\nQed.",
    "Lemma abelianE A : abelian A = (A \\subset 'C(A)). Proof. by []. Qed.",
    "Lemma abelian1 : abelian [1 gT]. Proof. exact: sub1G. Qed.",
    "Lemma abelianS A B : A \\subset B -> abelian B -> abelian A.\nProof. by move=> sAB; apply: centSS. Qed.",
    "Lemma abelianJ A x : abelian (A :^ x) = abelian A.\nProof. by rewrite /abelian centJ conjSg. Qed.",
    "Lemma abelian_gen A : abelian <<A>> = abelian A.\nProof. by rewrite /abelian cent_gen gen_subG. Qed.",
    "Lemma abelianY A B :\n  abelian (A <*> B) = [&& abelian A, abelian B & B \\subset 'C(A)].\nProof.\nrewrite /abelian join_subG /= centY !subsetI -!andbA; congr (_ && _).\nby rewrite centsC andbA andbb andbC.\nQed.",
    "Lemma abelianM G H :\n  abelian (G * H) = [&& abelian G, abelian H & H \\subset 'C(G)].\nProof. by rewrite -abelian_gen genM_join abelianY. Qed.",
    "Lemma sub_abelian_cent : C \\subset A -> A \\subset 'C(C).\nProof. by move=> sCA; rewrite centsC (subset_trans sCA). Qed.",
    "Lemma sub_abelian_cent2 : B \\subset A -> C \\subset A -> B \\subset 'C(C).\nProof. by move=> sBA; move/sub_abelian_cent; apply: subset_trans. Qed.",
    "Lemma sub_abelian_norm : C \\subset A -> A \\subset 'N(C).\nProof. by move=> sCA; rewrite cents_norm ?sub_abelian_cent. Qed.",
    "Lemma sub_abelian_normal : (C \\subset A) = (C <| A).\nProof.\nby rewrite /normal; case sHG: (C \\subset A); rewrite // sub_abelian_norm.\nQed.",
    "Lemma ex_maxgroup : (exists G, gP G) -> {G : {group gT} | maxgroup G gP}.\nProof.\nmove=> exP; have [A maxA]: {A | maxgroup A gP}.\n  apply: ex_maxset; case: exP => G gPG.\n  by exists (G : {set gT}); rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (maxsetp maxA).\nQed.",
    "Lemma ex_mingroup : (exists G, gP G) -> {G : {group gT} | mingroup G gP}.\nProof.\nmove=> exP; have [A minA]: {A | mingroup A gP}.\n  apply: ex_minset; case: exP => G gPG.\n  by exists (G : {set gT}); rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (minsetp minA).\nQed.",
    "Lemma mingroupP :\n  reflect (gP G /\\ forall H, gP H -> H \\subset G -> H :=: G) (mingroup G gP).\nProof.\napply: (iffP minsetP); rewrite /= groupP genGidG /= => [] [-> minG].\n  by split=> // H gPH sGH; apply: minG; rewrite // groupP genGidG.\nby split=> // A; case/andP=> gA gPA; rewrite -(gen_set_id gA); apply: minG.\nQed.",
    "Lemma maxgroupP :\n  reflect (gP G /\\ forall H, gP H -> G \\subset H -> H :=: G) (maxgroup G gP).\nProof.\napply: (iffP maxsetP); rewrite /= groupP genGidG /= => [] [-> maxG].\n  by split=> // H gPH sGH; apply: maxG; rewrite // groupP genGidG.\nby split=> // A; case/andP=> gA gPA; rewrite -(gen_set_id gA); apply: maxG.\nQed.",
    "Lemma maxgroupp : maxgroup G gP -> gP G. Proof. by case/maxgroupP. Qed.",
    "Lemma mingroupp : mingroup G gP -> gP G. Proof. by case/mingroupP. Qed.",
    "Lemma maxgroup_exists : {H : {group gT} | maxgroup H gP & G \\subset H}.\nProof.\nhave [A maxA sGA]: {A | maxgroup A gP & G \\subset A}.\n  by apply: maxset_exists; rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (maxsetp maxA).\nQed.",
    "Lemma mingroup_exists : {H : {group gT} | mingroup H gP & H \\subset G}.\nProof.\nhave [A maxA sGA]: {A | mingroup A gP & A \\subset G}.\n  by apply: minset_exists; rewrite groupP genGidG.\nby exists <<A>>%G; rewrite /= gen_set_id; case/andP: (minsetp maxA).\nQed.",
    "Lemma pprod1g : left_id 1 pprod.\nProof. by move=> A; rewrite /pprod eqxx. Qed.",
    "Lemma pprodg1 : right_id 1 pprod.\nProof. by move=> A; rewrite /pprod eqxx; case: eqP. Qed.",
    "Lemma group_not0 G : set0 <> G.\nProof. by move/setP/(_ 1); rewrite inE group1. Qed.",
    "Lemma mulg0 : right_zero (@set0 gT) mulg.\nProof.\nby move=> A; apply/setP=> x; rewrite inE; apply/imset2P=> [[y z]]; rewrite inE.\nQed.",
    "Lemma mul0g : left_zero (@set0 gT) mulg.\nProof.\nby move=> A; apply/setP=> x; rewrite inE; apply/imset2P=> [[y z]]; rewrite inE.\nQed.",
    "Lemma pprodP A B G :\n  pprod A B = G -> [/\\ are_groups A B, A * B = G & B \\subset 'N(A)].\nProof.\nhave Gnot0 := @group_not0 G; rewrite /pprod; do 2?case: eqP => [-> ->| _].\n- by rewrite mul1g norms1; split; first exists 1%G G.\n- by rewrite mulg1 sub1G; split; first exists G 1%G.\nby case: and3P => // [[gA gB ->]]; split; first exists (Group gA) (Group gB).\nQed.",
    "Lemma pprodE K H : H \\subset 'N(K) -> pprod K H = K * H.\nProof.\nmove=> nKH; rewrite /pprod nKH !groupP /=.\nby do 2?case: eqP => [-> | _]; rewrite ?mulg1 ?mul1g.\nQed.",
    "Lemma pprodEY K H : H \\subset 'N(K) -> pprod K H = K <*> H.\nProof. by move=> nKH; rewrite pprodE ?norm_joinEr. Qed.",
    "Lemma pprodW A B G : pprod A B = G -> A * B = G. Proof. by case/pprodP. Qed.",
    "Lemma pprodWC A B G : pprod A B = G -> B * A = G.\nProof. by case/pprodP=> _ <- /normC. Qed.",
    "Lemma pprodWY A B G : pprod A B = G -> A <*> B = G.\nProof. by case/pprodP=> [[K H -> ->] <- /norm_joinEr]. Qed.",
    "Lemma pprodJ A B x : pprod A B :^ x = pprod (A :^ x) (B :^ x).\nProof.\nrewrite /pprod !conjsg_eq1 !group_setJ normJ conjSg -conjsMg.\nby do 3?case: ifP => // _; apply: conj0g.\nQed.",
    "Lemma remgrMl K B x y : y \\in K -> remgr K B (y * x) = remgr K B x.\nProof. by move=> Ky; rewrite {1}/remgr rcosetM rcoset_id. Qed.",
    "Lemma remgrP K B x : (remgr K B x \\in K :* x :&: B) = (x \\in K * B).\nProof.\nset y := _ x; apply/idP/mulsgP=> [|[g b Kg Bb x_gb]].\n  rewrite inE rcoset_sym mem_rcoset => /andP[Kxy' By].\n  by exists (x * y^-1) y; rewrite ?mulgKV.\nby apply: (mem_repr b); rewrite inE rcoset_sym mem_rcoset x_gb mulgK Kg.\nQed.",
    "Lemma remgr1 K H x : x \\in K -> remgr K H x = 1.\nProof. by move=> Kx; rewrite /remgr rcoset_id ?repr_group. Qed.",
    "Lemma divgr_eq A B x : x = divgr A B x * remgr A B x.\nProof. by rewrite mulgKV. Qed.",
    "Lemma divgrMl K B x y : x \\in K -> divgr K B (x * y) = x * divgr K B y.\nProof. by move=> Hx; rewrite /divgr remgrMl ?mulgA. Qed.",
    "Lemma divgr_id K H x : x \\in K -> divgr K H x = x.\nProof. by move=> Kx; rewrite /divgr remgr1 // invg1 mulg1. Qed.",
    "Lemma mem_remgr K B x : x \\in K * B -> remgr K B x \\in B.\nProof. by rewrite -remgrP => /setIP[]. Qed.",
    "Lemma mem_divgr K B x : x \\in K * B -> divgr K B x \\in K.\nProof. by rewrite -remgrP inE rcoset_sym mem_rcoset => /andP[]. Qed.",
    "Lemma remgr_id x : x \\in H -> remgr K H x = x.\nProof.\nmove=> Hx; apply/eqP; rewrite eq_mulgV1 (sameP eqP set1gP) -tiKH inE.\nrewrite -mem_rcoset groupMr ?groupV // -in_setI remgrP.\nby apply: subsetP Hx; apply: mulG_subr.\nQed.",
    "Lemma remgrMid x y : x \\in K -> y \\in H -> remgr K H (x * y) = y.\nProof. by move=> Kx Hy; rewrite remgrMl ?remgr_id. Qed.",
    "Lemma divgrMid x y : x \\in K -> y \\in H -> divgr K H (x * y) = x.\nProof. by move=> Kx Hy; rewrite /divgr remgrMid ?mulgK. Qed.",
    "Lemma subcent_TImulg K H A :\n  K :&: H = 1 -> A \\subset 'N(K) :&: 'N(H) -> 'C_K(A) * 'C_H(A) = 'C_(K * H)(A).\nProof.\nmove=> tiKH /subsetIP[nKA nHA]; apply/eqP.\nrewrite group_modl ?subsetIr // eqEsubset setSI ?mulSg ?subsetIl //=.\napply/subsetP=> _ /setIP[/mulsgP[x y Kx Hy ->] cAxy].\nrewrite inE cAxy mem_mulg // inE Kx /=.\napply/centP=> z Az; apply/commgP/conjg_fixP.\nmove/commgP/conjg_fixP/(congr1 (divgr K H)): (centP cAxy z Az).\nby rewrite conjMg !divgrMid ?memJ_norm // (subsetP nKA, subsetP nHA).\nQed.",
    "Lemma complP H A B :\n  reflect (A :&: H = 1 /\\ A * H = B) (H \\in [complements to A in B]).\nProof. by apply: (iffP setIdP); case; split; apply/eqP. Qed.",
    "Lemma splitsP B A :\n  reflect (exists H, H \\in [complements to A in B]) [splits B, over A].\nProof. exact: set0Pn. Qed.",
    "Lemma complgC H K G :\n  (H \\in [complements to K in G]) = (K \\in [complements to H in G]).\nProof.\nrewrite !inE setIC; congr (_ && _).\nby apply/eqP/eqP=> defG; rewrite -(comm_group_setP _) // defG groupP.\nQed.",
    "Lemma remgrM : K <| G -> {in G &, {morph remgr K H : x y / x * y}}.\nProof.\ncase/normalP=> _; case/complP: complH_K => tiKH <- nK_KH x y KHx KHy.\nrewrite {1}(divgr_eq K H y) mulgA (conjgCV x) {2}(divgr_eq K H x) -2!mulgA.\nrewrite mulgA remgrMid //; last by rewrite groupMl mem_remgr.\nby rewrite groupMl !(=^~ mem_conjg, nK_KH, mem_divgr).\nQed.",
    "Lemma divgrM : H \\subset 'C(K) -> {in G &, {morph divgr K H : x y / x * y}}.\nProof.\nmove=> cKH; have /complP[_ defG] := complH_K.\nhave nsKG: K <| G by rewrite -defG -cent_joinEr // normalYl cents_norm.\nmove=> x y Gx Gy; rewrite {1}/divgr remgrM // invMg -!mulgA (mulgA y).\nby congr (_ * _); rewrite -(centsP cKH) ?groupV ?(mem_remgr, mem_divgr, defG).\nQed.",
    "Lemma sdprod1g : left_id 1 sdprod.\nProof. by move=> A; rewrite /sdprod subsetIl pprod1g. Qed.",
    "Lemma sdprodg1 : right_id 1 sdprod.\nProof. by move=> A; rewrite /sdprod subsetIr pprodg1. Qed.",
    "Lemma sdprodP A B G :\n  A ><| B = G -> [/\\ are_groups A B, A * B = G, B \\subset 'N(A) & A :&: B = 1].\nProof.\nrewrite /sdprod; case: ifP => [trAB | _ /group_not0[] //].\ncase/pprodP=> gAB defG nBA; split=> {defG nBA}//.\nby case: gAB trAB => H K -> -> /trivgP.\nQed.",
    "Lemma sdprodE K H : H \\subset 'N(K) -> K :&: H = 1 -> K ><| H = K * H.\nProof. by move=> nKH tiKH; rewrite /sdprod tiKH subxx pprodE. Qed.",
    "Lemma sdprodEY K H : H \\subset 'N(K) -> K :&: H = 1 -> K ><| H = K <*> H.\nProof. by move=> nKH tiKH; rewrite sdprodE ?norm_joinEr. Qed.",
    "Lemma sdprodWpp A B G : A ><| B = G -> pprod A B = G.\nProof. by case/sdprodP=> [[K H -> ->] <- /pprodE]. Qed.",
    "Lemma sdprodW A B G : A ><| B = G -> A * B = G.\nProof. by move/sdprodWpp/pprodW. Qed.",
    "Lemma sdprodWC A B G : A ><| B = G -> B * A = G.\nProof. by move/sdprodWpp/pprodWC. Qed.",
    "Lemma sdprodWY A B G : A ><| B = G -> A <*> B = G.\nProof. by move/sdprodWpp/pprodWY. Qed.",
    "Lemma sdprodJ A B x : (A ><| B) :^ x = A :^ x ><| B :^ x.\nProof.\nrewrite /sdprod -conjIg sub_conjg conjs1g -pprodJ.\nby case: ifP => _ //; apply: imset0.\nQed.",
    "Lemma sdprod_context G K H : K ><| H = G ->\n  [/\\ K <| G, H \\subset G, K * H = G, H \\subset 'N(K) & K :&: H = 1].\nProof.\ncase/sdprodP=> _ <- nKH tiKH.\nby rewrite /normal mulG_subl mulG_subr mulG_subG normG.\nQed.",
    "Lemma sdprod_compl G K H : K ><| H = G -> H \\in [complements to K in G].\nProof. by case/sdprodP=> _ mulKH _ tiKH; apply/complP. Qed.",
    "Lemma sdprod_normal_complP G K H :\n  K <| G -> reflect (K ><| H = G) (K \\in [complements to H in G]).\nProof.\ncase/andP=> _ nKG; rewrite complgC.\napply: (iffP idP); [case/complP=> tiKH mulKH | exact: sdprod_compl].\nby rewrite sdprodE ?(subset_trans _ nKG) // -mulKH mulG_subr.\nQed.",
    "Lemma sdprod_card G A B : A ><| B = G -> (#|A| * #|B|)%N = #|G|.\nProof. by case/sdprodP=> [[H K -> ->] <- _ /TI_cardMg]. Qed.",
    "Lemma sdprod_isom G A B :\n    A ><| B = G ->\n {nAB : B \\subset 'N(A) | isom B (G / A) (restrm nAB (coset A))}.\nProof.\ncase/sdprodP=> [[K H -> ->] <- nKH tiKH].\nby exists nKH; rewrite quotientMidl quotient_isom.\nQed.",
    "Lemma sdprod_isog G A B : A ><| B = G -> B \\isog G / A.\nProof. by case/sdprod_isom=> nAB; apply: isom_isog. Qed.",
    "Lemma sdprod_subr G A B M : A ><| B = G -> M \\subset B -> A ><| M = A <*> M.\nProof.\ncase/sdprodP=> [[K H -> ->] _ nKH tiKH] sMH.\nby rewrite sdprodEY ?(subset_trans sMH) //; apply/trivgP; rewrite -tiKH setIS.\nQed.",
    "Lemma index_sdprod G A B : A ><| B = G -> #|B| = #|G : A|.\nProof.\ncase/sdprodP=> [[K H -> ->] <- _ tiHK].\nby rewrite indexMg -indexgI setIC tiHK indexg1.\nQed.",
    "Lemma index_sdprodr G A B M :\n  A ><| B = G -> M \\subset B -> #|B : M| =  #|G : A <*> M|.\nProof.\nmove=> defG; case/sdprodP: defG (defG) => [[K H -> ->] mulKH nKH _] defG sMH.\nrewrite -!divgS //=; last by rewrite -genM_join gen_subG -mulKH mulgS.\nby rewrite -(sdprod_card defG) -(sdprod_card (sdprod_subr defG sMH)) divnMl.\nQed.",
    "Lemma quotient_sdprodr_isom G A B M :\n    A ><| B = G -> M <| B ->\n  {f : {morphism B / M >-> coset_of (A <*> M)} |\n    isom (B / M) (G / (A <*> M)) f\n  & forall L, L \\subset B -> f @* (L / M) = A <*> L / (A <*> M)}.\nProof.\nmove=> defG nsMH; have [defA defB]: A = <<A>>%G /\\ B = <<B>>%G.\n  by have [[K1 H1 -> ->] _ _ _] := sdprodP defG; rewrite /= !genGid.\ndo [rewrite {}defA {}defB; move: {A}<<A>>%G {B}<<B>>%G => K H] in defG nsMH *.\nhave [[nKH /isomP[injKH imKH]] sMH] := (sdprod_isom defG, normal_sub nsMH).\nhave [[nsKG sHG mulKH _ _] nKM] := (sdprod_context defG, subset_trans sMH nKH).\nhave nsKMG: K <*> M <| G.\n  by rewrite -quotientYK // -mulKH -quotientK ?cosetpre_normal ?quotient_normal.\nhave [/= f inj_f im_f] := third_isom (joing_subl K M) nsKG nsKMG.\nrewrite quotientYidl //= -imKH -(restrm_quotientE nKH sMH) in f inj_f im_f.\nhave /domP[h [_ ker_h _ im_h]]: 'dom (f \\o quotm _ nsMH) = H / M.\n  by rewrite ['dom _]morphpre_quotm injmK.\nhave{} im_h L: L \\subset H -> h @* (L / M) = K <*> L / (K <*> M).\n  move=> sLH; have [sLG sKKM] := (subset_trans sLH sHG, joing_subl K M).\n  rewrite im_h morphim_comp morphim_quotm [_ @* L]restrm_quotientE ?im_f //.\n  rewrite quotientY ?(normsG sKKM) ?(subset_trans sLG) ?normal_norm //.\n  by rewrite (quotientS1 sKKM) joing1G.\nexists h => //; apply/isomP; split; last by rewrite im_h //= (sdprodWY defG).\nby rewrite ker_h injm_comp ?injm_quotm.\nQed.",
    "Lemma quotient_sdprodr_isog G A B M :\n  A ><| B = G -> M <| B -> B / M \\isog G / (A <*> M).\nProof.\nmove=> defG; case/sdprodP: defG (defG) => [[K H -> ->] _ _ _] => defG nsMH.\nby have [h /isom_isog->] := quotient_sdprodr_isom defG nsMH.\nQed.",
    "Lemma sdprod_modl A B G H :\n  A ><| B = G -> A \\subset H -> A ><| (B :&: H) = G :&: H.\nProof.\ncase/sdprodP=> {A B} [[A B -> ->]] <- nAB tiAB sAH.\nrewrite -group_modl ?sdprodE ?subIset ?nAB //.\nby rewrite setIA tiAB (setIidPl _) ?sub1G.\nQed.",
    "Lemma sdprod_modr A B G H :\n  A ><| B = G -> B \\subset H -> (H :&: A) ><| B = H :&: G.\nProof.\ncase/sdprodP=> {A B}[[A B -> ->]] <- nAB tiAB sAH.\nrewrite -group_modr ?sdprodE ?normsI // ?normsG //.\nby rewrite -setIA tiAB (setIidPr _) ?sub1G.\nQed.",
    "Lemma subcent_sdprod B C G A :\n  B ><| C = G -> A \\subset 'N(B) :&: 'N(C) -> 'C_B(A) ><| 'C_C(A) = 'C_G(A).\nProof.\ncase/sdprodP=> [[H K -> ->] <- nHK tiHK] nHKA {B C G}.\nrewrite sdprodE ?subcent_TImulg ?normsIG //.\nby rewrite -setIIl tiHK (setIidPl (sub1G _)).\nQed.",
    "Lemma sdprod_recl n G K H K1 :\n    #|G| <= n -> K ><| H = G -> K1 \\proper K -> H \\subset 'N(K1) ->\n  exists G1 : {group gT}, [/\\ #|G1| < n, G1 \\subset G & K1 ><| H = G1].\nProof.\nmove=> leGn; case/sdprodP=> _ defG nKH tiKH ltK1K nK1H.\nhave tiK1H: K1 :&: H = 1 by apply/trivgP; rewrite -tiKH setSI ?proper_sub.\nexists (K1 <*> H)%G; rewrite /= -defG sdprodE // norm_joinEr //.\nrewrite ?mulSg ?proper_sub ?(leq_trans _ leGn) //=.\nby rewrite -defG ?TI_cardMg // ltn_pmul2r ?proper_card.\nQed.",
    "Lemma sdprod_recr n G K H H1 :\n    #|G| <= n -> K ><| H = G -> H1 \\proper H ->\n  exists G1 : {group gT}, [/\\ #|G1| < n, G1 \\subset G & K ><| H1 = G1].\nProof.\nmove=> leGn; case/sdprodP=> _ defG nKH tiKH ltH1H.\nhave [sH1H _] := andP ltH1H; have nKH1 := subset_trans sH1H nKH.\nhave tiKH1: K :&: H1 = 1 by apply/trivgP; rewrite -tiKH setIS.\nexists (K <*> H1)%G; rewrite /= -defG sdprodE // norm_joinEr //.\nrewrite ?mulgS // ?(leq_trans _ leGn) //=.\nby rewrite -defG ?TI_cardMg // ltn_pmul2l ?proper_card.\nQed.",
    "Lemma mem_sdprod G A B x : A ><| B = G -> x \\in G ->\n  exists y, exists z,\n    [/\\ y \\in A, z \\in B, x = y * z &\n        {in A & B, forall u t, x = u * t -> u = y /\\ t = z}].\nProof.\ncase/sdprodP=> [[K H -> ->{A B}] <- _ tiKH] /mulsgP[y z Ky Hz ->{x}].\nexists y; exists z; split=> // u t Ku Ht eqyzut.\nmove: (congr1 (divgr K H) eqyzut) (congr1 (remgr K H) eqyzut).\nby rewrite !remgrMid // !divgrMid.\nQed.",
    "Lemma cprod1g : left_id 1 cprod.\nProof. by move=> A; rewrite /cprod cents1 pprod1g. Qed.",
    "Lemma cprodg1 : right_id 1 cprod.\nProof. by move=> A; rewrite /cprod sub1G pprodg1. Qed.",
    "Lemma cprodP A B G :\n  A \\* B = G -> [/\\ are_groups A B, A * B = G & B \\subset 'C(A)].\nProof. by rewrite /cprod; case: ifP => [cAB /pprodP[] | _ /group_not0[]]. Qed.",
    "Lemma cprodE G H : H \\subset 'C(G) -> G \\* H = G * H.\nProof. by move=> cGH; rewrite /cprod cGH pprodE ?cents_norm. Qed.",
    "Lemma cprodEY G H : H \\subset 'C(G) -> G \\* H = G <*> H.\nProof. by move=> cGH; rewrite cprodE ?cent_joinEr. Qed.",
    "Lemma cprodWpp A B G : A \\* B = G -> pprod A B = G.\nProof. by case/cprodP=> [[K H -> ->] <- /cents_norm/pprodE]. Qed.",
    "Lemma cprodW A B G : A \\* B = G -> A * B = G.\nProof. by move/cprodWpp/pprodW. Qed.",
    "Lemma cprodWC A B G : A \\* B = G -> B * A = G.\nProof. by move/cprodWpp/pprodWC. Qed.",
    "Lemma cprodWY A B G : A \\* B = G -> A <*> B = G.\nProof. by move/cprodWpp/pprodWY. Qed.",
    "Lemma cprodJ A B x : (A \\* B) :^ x = A :^ x \\* B :^ x.\nProof.\nby rewrite /cprod centJ conjSg -pprodJ; case: ifP => _ //; apply: imset0.\nQed.",
    "Lemma cprod_normal2 A B G : A \\* B = G -> A <| G /\\ B <| G.\nProof.\ncase/cprodP=> [[K H -> ->] <- cKH]; rewrite -cent_joinEr //.\nby rewrite normalYl normalYr !cents_norm // centsC.\nQed.",
    "Lemma bigcprodW I (r : seq I) P F G :\n  \\big[cprod/1]_(i <- r | P i) F i = G -> \\prod_(i <- r | P i) F i = G.\nProof.\nelim/big_rec2: _ G => // i A B _ IH G /cprodP[[_ H _ defB] <- _].\nby rewrite (IH H) defB.\nQed.",
    "Lemma bigcprodWY I (r : seq I) P F G :\n  \\big[cprod/1]_(i <- r | P i) F i = G -> << \\bigcup_(i <- r | P i) F i >> = G.\nProof.\nelim/big_rec2: _ G => [|i A B _ IH G]; first by rewrite gen0.\ncase/cprodP => [[K H -> defB] <- cKH].\nby rewrite -[<<_>>]joing_idr (IH H) ?cent_joinEr -?defB.\nQed.",
    "Lemma triv_cprod A B : (A \\* B == 1) = (A == 1) && (B == 1).\nProof.\ncase A1: (A == 1); first by rewrite (eqP A1) cprod1g.\napply/eqP=> /cprodP[[G H defA ->]] /eqP.\nby rewrite defA trivMg -defA A1.\nQed.",
    "Lemma cprod_ntriv A B : A != 1 -> B != 1 ->\n  A \\* B =\n    if [&& group_set A, group_set B & B \\subset 'C(A)] then A * B else set0.\nProof.\nmove=> A1 B1; rewrite /cprod; case: ifP => cAB; rewrite ?cAB ?andbF //=.\nby rewrite /pprod -if_neg A1 -if_neg B1 cents_norm.\nQed.",
    "Lemma trivg0 : (@set0 gT == 1) = false.\nProof. by rewrite eqEcard cards0 cards1 andbF. Qed.",
    "Lemma group0 : group_set (@set0 gT) = false.\nProof. by rewrite /group_set inE. Qed.",
    "Lemma cprod0g A : set0 \\* A = set0.\nProof. by rewrite /cprod centsC sub0set /pprod group0 trivg0 !if_same. Qed.",
    "Lemma cprodC : commutative cprod.\nProof.\nrewrite /cprod => A B; case: ifP => cAB; rewrite centsC cAB // /pprod.\nby rewrite andbCA normC !cents_norm // 1?centsC //; do 2!case: eqP => // ->.\nQed.",
    "Lemma cprodA : associative cprod.\nProof.\nmove=> A B C; case A1: (A == 1); first by rewrite (eqP A1) !cprod1g.\ncase B1: (B == 1); first by rewrite (eqP B1) cprod1g cprodg1.\ncase C1: (C == 1); first by rewrite (eqP C1) !cprodg1.\nrewrite !(triv_cprod, cprod_ntriv) ?{}A1 ?{}B1 ?{}C1 //.\ncase: isgroupP => [[G ->{A}] | _]; last by rewrite group0.\ncase: (isgroupP B) => [[H ->{B}] | _]; last by rewrite group0.\ncase: (isgroupP C) => [[K ->{C}] | _]; last by rewrite group0 !andbF.\ncase cGH: (H \\subset 'C(G)); case cHK: (K \\subset 'C(H)); last first.\n- by rewrite group0.\n- by rewrite group0 /= mulG_subG cGH andbF.\n- by rewrite group0 /= centM subsetI cHK !andbF.\nrewrite /= mulgA mulG_subG centM subsetI cGH cHK andbT -(cent_joinEr cHK).\nby rewrite -(cent_joinEr cGH) !groupP.\nQed.",
    "Lemma cprod_modl A B G H :\n  A \\* B = G -> A \\subset H -> A \\* (B :&: H) = G :&: H.\nProof.\ncase/cprodP=> [[U V -> -> {A B}]] defG cUV sUH.\nby rewrite cprodE; [rewrite group_modl ?defG | rewrite subIset ?cUV].\nQed.",
    "Lemma cprod_modr A B G H :\n  A \\* B = G -> B \\subset H -> (H :&: A) \\* B = H :&: G.\nProof. by rewrite -!(cprodC B) !(setIC H); apply: cprod_modl. Qed.",
    "Lemma bigcprodYP (I : finType) (P : pred I) (H : I -> {group gT}) :\n  reflect (forall i j, P i -> P j -> i != j -> H i \\subset 'C(H j))\n          (\\big[cprod/1]_(i | P i) H i == (\\prod_(i | P i) H i)%G).\nProof.\napply: (iffP eqP) => [defG i j Pi Pj neq_ij | cHH].\n  rewrite (bigD1 j) // (bigD1 i) /= ?cprodA in defG; last exact/andP.\n  by case/cprodP: defG => [[K _ /cprodP[//]]].\nset Q := P; have sQP: subpred Q P by []; have [n leQn] := ubnP #|Q|.\nelim: n => // n IHn in (Q) leQn sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0.\nrewrite (cardD1x Qi) add1n ltnS !(bigD1 i Qi) /= in leQn *.\nrewrite {}IHn {n leQn}// => [|j /andP[/sQP //]].\nrewrite bigprodGE cprodEY // gen_subG; apply/bigcupsP=> j /andP[neq_ji Qj].\nby rewrite cHH ?sQP.\nQed.",
    "Lemma bigcprodEY I r (P : pred I) (H : I -> {group gT}) G :\n    abelian G -> (forall i, P i -> H i \\subset G) ->\n  \\big[cprod/1]_(i <- r | P i) H i = (\\prod_(i <- r | P i) H i)%G.\nProof.\nmove=> cGG sHG; apply/eqP; rewrite !(big_tnth _ _ r).\nby apply/bigcprodYP=> i j Pi Pj _; rewrite (sub_abelian_cent2 cGG) ?sHG.\nQed.",
    "Lemma perm_bigcprod (I : eqType) r1 r2 (A : I -> {set gT}) G x :\n    \\big[cprod/1]_(i <- r1) A i = G -> {in r1, forall i, x i \\in A i} ->\n    perm_eq r1 r2 ->\n  \\prod_(i <- r1) x i = \\prod_(i <- r2) x i.\nProof.\nelim: r1 r2 G => [|i r1 IHr] r2 G defG Ax eq_r12.\n  by rewrite perm_sym in eq_r12; rewrite (perm_small_eq _ eq_r12) ?big_nil.\nhave /rot_to[n r3 Dr2]: i \\in r2 by rewrite -(perm_mem eq_r12) mem_head.\ntransitivity (\\prod_(j <- rot n r2) x j).\n  rewrite Dr2 !big_cons in defG Ax *; have [[_ G1 _ defG1] _ _] := cprodP defG.\n  rewrite (IHr r3 G1) //; first by case/allP/andP: Ax => _ /allP.\n  by rewrite -(perm_cons i) -Dr2 perm_sym perm_rot perm_sym.\nrewrite -(cat_take_drop n r2) [in LHS]cat_take_drop in eq_r12 *.\nrewrite (perm_big _ eq_r12) !big_cat /= !(big_nth i) !big_mkord in defG *.\nhave /cprodP[[G1 G2 defG1 defG2] _ /centsP-> //] := defG.\n  rewrite defG2 -(bigcprodW defG2) mem_prodg // => k _; apply: Ax.\n  by rewrite (perm_mem eq_r12) mem_cat orbC mem_nth.\nrewrite defG1 -(bigcprodW defG1) mem_prodg // => k _; apply: Ax.\nby rewrite (perm_mem eq_r12) mem_cat mem_nth.\nQed.",
    "Lemma reindex_bigcprod (I J : finType) (h : J -> I) P (A : I -> {set gT}) G x :\n    {on SimplPred P, bijective h} -> \\big[cprod/1]_(i | P i) A i = G ->\n    {in SimplPred P, forall i, x i \\in A i} ->\n  \\prod_(i | P i) x i = \\prod_(j | P (h j)) x (h j).\nProof.\ncase=> h1 hK h1K defG Ax; have [e big_e [Ue mem_e] _] := big_enumP P.\nrewrite -!big_e in defG *; rewrite -(big_map h P x) -[RHS]big_filter filter_map.\napply: perm_bigcprod defG _ _ => [i|]; first by rewrite mem_e => /Ax.\nhave [r _ [Ur /= mem_r] _] := big_enumP; apply: uniq_perm Ue _ _ => [|i].\n  by rewrite map_inj_in_uniq // => i j; rewrite !mem_r ; apply: (can_in_inj hK).\nrewrite mem_e; apply/idP/mapP=> [Pi|[j r_j ->]]; last by rewrite -mem_r.\nby exists (h1 i); rewrite ?mem_r h1K.\nQed.",
    "Lemma dprod1g : left_id 1 dprod.\nProof. by move=> A; rewrite /dprod subsetIl cprod1g. Qed.",
    "Lemma dprodg1 : right_id 1 dprod.\nProof. by move=> A; rewrite /dprod subsetIr cprodg1. Qed.",
    "Lemma dprodP A B G :\n  A \\x B = G -> [/\\ are_groups A B, A * B = G, B \\subset 'C(A) & A :&: B = 1].\nProof.\nrewrite /dprod; case: ifP => trAB; last by case/group_not0.\nby case/cprodP=> gAB; split=> //; case: gAB trAB => ? ? -> -> /trivgP.\nQed.",
    "Lemma dprodE G H : H \\subset 'C(G) -> G :&: H = 1 -> G \\x H = G * H.\nProof. by move=> cGH trGH; rewrite /dprod trGH sub1G cprodE. Qed.",
    "Lemma dprodEY G H : H \\subset 'C(G) -> G :&: H = 1 -> G \\x H = G <*> H.\nProof. by move=> cGH trGH; rewrite /dprod trGH subxx cprodEY. Qed.",
    "Lemma dprodEcp A B : A :&: B = 1 -> A \\x B = A \\* B.\nProof. by move=> trAB; rewrite /dprod trAB subxx. Qed.",
    "Lemma dprodEsd A B : B \\subset 'C(A) -> A \\x B = A ><| B.\nProof. by rewrite /dprod /cprod => ->. Qed.",
    "Lemma dprodWcp A B G : A \\x B = G -> A \\* B = G.\nProof. by move=> defG; have [_ _ _ /dprodEcp <-] := dprodP defG. Qed.",
    "Lemma dprodWsd A B G : A \\x B = G -> A ><| B = G.\nProof. by move=> defG; have [_ _ /dprodEsd <-] := dprodP defG. Qed.",
    "Lemma dprodW A B G : A \\x B = G -> A * B = G.\nProof. by move/dprodWsd/sdprodW. Qed.",
    "Lemma dprodWC A B G : A \\x B = G -> B * A = G.\nProof. by move/dprodWsd/sdprodWC. Qed.",
    "Lemma dprodWY A B G : A \\x B = G -> A <*> B = G.\nProof. by move/dprodWsd/sdprodWY. Qed.",
    "Lemma cprod_card_dprod G A B :\n  A \\* B = G -> #|A| * #|B| <= #|G| -> A \\x B = G.\nProof. by case/cprodP=> [[K H -> ->] <- cKH] /cardMg_TI; apply: dprodE. Qed.",
    "Lemma dprodJ A B x : (A \\x B) :^ x = A :^ x \\x B :^ x.\nProof.\nrewrite /dprod -conjIg sub_conjg conjs1g -cprodJ.\nby case: ifP => _ //; apply: imset0.\nQed.",
    "Lemma dprod_normal2 A B G : A \\x B = G -> A <| G /\\ B <| G.\nProof. by move/dprodWcp/cprod_normal2. Qed.",
    "Lemma dprodYP K H : reflect (K \\x H = K <*> H) (H \\subset 'C(K) :\\: K^#).\nProof.\nrewrite subsetD -setI_eq0 setIDA setD_eq0 setIC subG1 /=.\nby apply: (iffP andP) => [[cKH /eqP/dprodEY->] | /dprodP[_ _ -> ->]].\nQed.",
    "Lemma dprodC : commutative dprod.\nProof. by move=> A B; rewrite /dprod setIC cprodC. Qed.",
    "Lemma dprodWsdC A B G : A \\x B = G -> B ><| A = G.\nProof. by rewrite dprodC => /dprodWsd. Qed.",
    "Lemma dprodA : associative dprod.\nProof.\nmove=> A B C; case A1: (A == 1); first by rewrite (eqP A1) !dprod1g.\ncase B1: (B == 1); first by rewrite (eqP B1) dprod1g dprodg1.\ncase C1: (C == 1); first by rewrite (eqP C1) !dprodg1.\nrewrite /dprod (fun_if (cprod A)) (fun_if (cprod^~ C)) -cprodA.\nrewrite -(cprodC set0) !cprod0g cprod_ntriv ?B1 ?{}C1 //.\ncase: and3P B1 => [[] | _ _]; last by rewrite cprodC cprod0g !if_same.\ncase/isgroupP=> H ->; case/isgroupP=> K -> {B C}; move/cent_joinEr=> eHK H1.\nrewrite cprod_ntriv ?trivMg ?{}A1 ?{}H1 // mulG_subG.\ncase: and4P => [[] | _]; last by rewrite !if_same.\ncase/isgroupP=> G ->{A} _ cGH _; rewrite cprodEY // -eHK.\ncase trGH: (G :&: H \\subset _); case trHK: (H :&: K \\subset _); last first.\n- by rewrite !if_same.\n- rewrite if_same; case: ifP => // trG_HK; case/negP: trGH.\n  by apply: subset_trans trG_HK; rewrite setIS ?joing_subl.\n- rewrite if_same; case: ifP => // trGH_K; case/negP: trHK.\n  by apply: subset_trans trGH_K; rewrite setSI ?joing_subr.\ndo 2![case: ifP] => // trGH_K trG_HK; [case/negP: trGH_K | case/negP: trG_HK].\n  apply: subset_trans trHK; rewrite subsetI subsetIr -{2}(mulg1 H) -mulGS.\n  rewrite setIC group_modl ?joing_subr //= cent_joinEr // -eHK.\n  by rewrite -group_modr ?joing_subl //= setIC -(normC (sub1G _)) mulSg.\napply: subset_trans trGH; rewrite subsetI subsetIl -{2}(mul1g H) -mulSG.\nrewrite setIC group_modr ?joing_subl //= eHK -(cent_joinEr cGH).\nby rewrite -group_modl ?joing_subr //= setIC (normC (sub1G _)) mulgS.\nQed.",
    "Lemma bigdprodWcp I (r : seq I) P F G :\n  \\big[dprod/1]_(i <- r | P i) F i = G -> \\big[cprod/1]_(i <- r | P i) F i = G.\nProof.\nelim/big_rec2: _ G => // i A B _ IH G /dprodP[[K H -> defB] <- cKH _].\nby rewrite (IH H) // cprodE -defB.\nQed.",
    "Lemma bigdprodW I (r : seq I) P F G :\n  \\big[dprod/1]_(i <- r | P i) F i = G -> \\prod_(i <- r | P i) F i = G.\nProof. by move/bigdprodWcp; apply: bigcprodW. Qed.",
    "Lemma bigdprodWY I (r : seq I) P F G :\n  \\big[dprod/1]_(i <- r | P i) F i = G -> << \\bigcup_(i <- r | P i) F i >> = G.\nProof. by move/bigdprodWcp; apply: bigcprodWY. Qed.",
    "Lemma bigdprodYP (I : finType) (P : pred I) (F : I -> {group gT}) :\n  reflect (forall i, P i ->\n             (\\prod_(j | P j && (j != i)) F j)%G \\subset 'C(F i) :\\: (F i)^#)\n          (\\big[dprod/1]_(i | P i) F i == (\\prod_(i | P i) F i)%G).\nProof.\napply: (iffP eqP) => [defG i Pi | dxG].\n  rewrite !(bigD1 i Pi) /= in defG; have [[_ G' _ defG'] _ _ _] := dprodP defG.\n  by apply/dprodYP; rewrite -defG defG' bigprodGE (bigdprodWY defG').\nset Q := P; have sQP: subpred Q P by []; have [n leQn] := ubnP #|Q|.\nelim: n => // n IHn in (Q) leQn sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0.\nrewrite (cardD1x Qi) add1n ltnS !(bigD1 i Qi) /= in leQn *.\nrewrite {}IHn {n leQn}// => [|j /andP[/sQP //]].\napply/dprodYP; apply: subset_trans (dxG i (sQP i Qi)); rewrite !bigprodGE.\nby apply: genS; apply/bigcupsP=> j /andP[Qj ne_ji]; rewrite (bigcup_max j) ?sQP.\nQed.",
    "Lemma dprod_modl A B G H :\n  A \\x B = G -> A \\subset H -> A \\x (B :&: H) = G :&: H.\nProof.\ncase/dprodP=> [[U V -> -> {A B}]] defG cUV trUV sUH.\nrewrite dprodEcp; first by apply: cprod_modl; rewrite ?cprodE.\nby rewrite setIA trUV (setIidPl _) ?sub1G.\nQed.",
    "Lemma dprod_modr A B G H :\n  A \\x B = G -> B \\subset H -> (H :&: A) \\x B = H :&: G.\nProof. by rewrite -!(dprodC B) !(setIC H); apply: dprod_modl. Qed.",
    "Lemma subcent_dprod B C G A :\n   B \\x C = G -> A \\subset 'N(B) :&: 'N(C) -> 'C_B(A) \\x 'C_C(A) = 'C_G(A).\nProof.\nmove=> defG; have [_ _ cBC _] := dprodP defG; move: defG.\nby rewrite !dprodEsd 1?(centSS _ _ cBC) ?subsetIl //; apply: subcent_sdprod.\nQed.",
    "Lemma dprod_card A B G : A \\x B = G -> (#|A| * #|B|)%N = #|G|.\nProof. by case/dprodP=> [[H K -> ->] <- _]; move/TI_cardMg. Qed.",
    "Lemma bigdprod_card I r (P : pred I) E G :\n    \\big[dprod/1]_(i <- r | P i) E i = G ->\n  (\\prod_(i <- r | P i) #|E i|)%N = #|G|.\nProof.\nelim/big_rec2: _ G => [G <- | i A B _ IH G defG]; first by rewrite cards1.\nhave [[_ H _ defH] _ _ _] := dprodP defG.\nby rewrite -(dprod_card defG) (IH H) defH.\nQed.",
    "Lemma bigcprod_card_dprod I r (P : pred I) (A : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) A i = G ->\n    \\prod_(i <- r | P i) #|A i| <= #|G| ->\n  \\big[dprod/1]_(i <- r | P i) A i = G.\nProof.\nelim: r G => [|i r IHr]; rewrite !(big_nil, big_cons) //; case: ifP => _ // G.\ncase/cprodP=> [[K H -> defH]]; rewrite defH => <- cKH leKH_G.\nhave /implyP := leq_trans leKH_G (dvdn_leq _ (dvdn_cardMg K H)).\nrewrite muln_gt0 leq_pmul2l !cardG_gt0 //= => /(IHr H defH){}defH.\nby rewrite defH dprodE // cardMg_TI // -(bigdprod_card defH).\nQed.",
    "Lemma bigcprod_coprime_dprod (I : finType) (P : pred I) (A : I -> {set gT}) G :\n    \\big[cprod/1]_(i | P i) A i = G ->\n    (forall i j, P i -> P j -> i != j -> coprime #|A i| #|A j|) ->\n  \\big[dprod/1]_(i | P i) A i = G.\nProof.\nmove=> defG coA; set Q := P in defG *; have sQP: subpred Q P by [].\nhave [m leQm] := ubnP #|Q|; elim: m => // m IHm in (Q) leQm G defG sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0 in defG *.\nmove: defG; rewrite !(bigD1 i Qi) /= => /cprodP[[Hi Gi defAi defGi] <-].\nrewrite defAi defGi => cHGi.\nhave{} defGi: \\big[dprod/1]_(j | Q j && (j != i)) A j = Gi.\n  by apply: IHm => [||j /andP[/sQP]] //; rewrite (cardD1x Qi) in leQm.\nrewrite defGi dprodE // coprime_TIg // -defAi -(bigdprod_card defGi).\nelim/big_rec: _ => [|j n /andP[neq_ji Qj] IHn]; first exact: coprimen1.\nby rewrite coprimeMr coprime_sym coA ?sQP.\nQed.",
    "Lemma mem_dprod G A B x : A \\x B = G -> x \\in G ->\n  exists y, exists z,\n    [/\\ y \\in A, z \\in B, x = y * z &\n        {in A & B, forall u t, x = u * t -> u = y /\\ t = z}].\nProof.\nmove=> defG; have [_ _ cBA _] := dprodP defG.\nby apply: mem_sdprod; rewrite -dprodEsd.\nQed.",
    "Lemma mem_bigdprod (I : finType) (P : pred I) F G x :\n    \\big[dprod/1]_(i | P i) F i = G -> x \\in G ->\n  exists c, [/\\ forall i, P i -> c i \\in F i, x = \\prod_(i | P i) c i\n              & forall e, (forall i, P i -> e i \\in F i) ->\n                          x = \\prod_(i | P i) e i ->\n                forall i, P i -> e i = c i].\nProof.\nmove=> defG; rewrite -(bigdprodW defG) => /prodsgP[c Fc ->].\nhave [r big_r [_ mem_r] _] := big_enumP P.\nexists c; split=> // e Fe eq_ce i Pi; rewrite -!{}big_r in defG eq_ce.\nhave{Pi}: i \\in r by rewrite mem_r.\nhave{mem_r}: all P r by apply/allP=> j; rewrite mem_r.\nelim: r G defG eq_ce => // j r IHr G.\nrewrite !big_cons inE /= => /dprodP[[K H defK defH] _ _].\nrewrite defK defH => tiFjH eq_ce /andP[Pj Pr].\nsuffices{i IHr} eq_cej: c j = e j.\n  case/predU1P=> [-> //|]; apply: IHr defH _ Pr.\n  by apply: (mulgI (c j)); rewrite eq_ce eq_cej.\nrewrite !(big_nth j) !big_mkord in defH eq_ce.\nmove/(congr1 (divgr K H)): eq_ce; move/bigdprodW: defH => defH.\nmove/(all_nthP j) in Pr.\nby rewrite !divgrMid // -?defK -?defH ?mem_prodg // => *; rewrite ?Fc ?Fe ?Pr.\nQed.",
    "Lemma comm_prodG I r (G : I -> {group gT}) (P : {pred I}) :\n  {in P &, forall i j, commute (G i) (G j)} ->\n  (\\prod_(i <- r | P i) G i)%G = \\prod_(i <- r | P i) G i :> {set gT}.\nProof.\nelim: r => /= [|i {}r IHr]; rewrite !(big_nil, big_cons)//=.\ncase: ifP => //= Pi Gcomm; rewrite comm_joingE {}IHr// /commute.\nelim: r => [|j r IHr]; first by rewrite big_nil mulg1 mul1g.\nby rewrite big_cons; case: ifP => //= Pj; rewrite mulgA Gcomm// -!mulgA IHr.\nQed.",
    "Lemma morphim_pprod : pprod K H = G -> pprod (f @* K) (f @* H) = f @* G.\nProof.\ncase/pprodP=> _ defG mKH; rewrite pprodE ?morphim_norms //.\nby rewrite -morphimMl ?(subset_trans _ sGD) -?defG // mulG_subl.\nQed.",
    "Lemma morphim_coprime_sdprod :\n  K ><| H = G -> coprime #|K| #|H| -> f @* K ><| f @* H = f @* G.\nProof.\nrewrite /sdprod => defG coHK; move: defG.\nby rewrite !coprime_TIg ?coprime_morph // !subxx; apply: morphim_pprod.\nQed.",
    "Lemma injm_sdprod : 'injm f -> K ><| H = G -> f @* K ><| f @* H = f @* G.\nProof.\nmove=> inj_f; case/sdprodP=> _ defG nKH tiKH.\nby rewrite /sdprod -injmI // tiKH morphim1 subxx morphim_pprod // pprodE.\nQed.",
    "Lemma morphim_cprod : K \\* H = G -> f @* K \\* f @* H = f @* G.\nProof.\ncase/cprodP=> _ defG cKH; rewrite /cprod morphim_cents // morphim_pprod //.\nby rewrite pprodE // cents_norm // centsC.\nQed.",
    "Lemma injm_dprod : 'injm f -> K \\x H = G -> f @* K \\x f @* H = f @* G.\nProof.\nmove=> inj_f; case/dprodP=> _ defG cHK tiKH.\nby rewrite /dprod -injmI // tiKH morphim1 subxx morphim_cprod // cprodE.\nQed.",
    "Lemma morphim_coprime_dprod :\n  K \\x H = G -> coprime #|K| #|H| -> f @* K \\x f @* H = f @* G.\nProof.\nrewrite /dprod => defG coHK; move: defG.\nby rewrite !coprime_TIg ?coprime_morph // !subxx; apply: morphim_cprod.\nQed.",
    "Lemma morphim_bigcprod I r (P : pred I) (H : I -> {group gT}) G :\n    G \\subset D -> \\big[cprod/1]_(i <- r | P i) H i = G ->\n  \\big[cprod/1]_(i <- r | P i) f @* H i = f @* G.\nProof.\nelim/big_rec2: _ G => [|i fB B Pi def_fB] G sGD defG.\n  by rewrite -defG morphim1.\ncase/cprodP: defG (defG) => [[Hi Gi -> defB] _ _]; rewrite defB => defG.\nrewrite (def_fB Gi) //; first exact: morphim_cprod.\nby apply: subset_trans sGD; case/cprod_normal2: defG => _ /andP[].\nQed.",
    "Lemma injm_bigdprod I r (P : pred I) (H : I -> {group gT}) G :\n    G \\subset D -> 'injm f -> \\big[dprod/1]_(i <- r | P i) H i = G ->\n  \\big[dprod/1]_(i <- r | P i) f @* H i = f @* G.\nProof.\nmove=> sGD injf; elim/big_rec2: _ G sGD => [|i fB B Pi def_fB] G sGD defG.\n  by rewrite -defG morphim1.\ncase/dprodP: defG (defG) => [[Hi Gi -> defB] _ _ _]; rewrite defB => defG.\nrewrite (def_fB Gi) //; first exact: injm_dprod.\nby apply: subset_trans sGD; case/dprod_normal2: defG => _ /andP[].\nQed.",
    "Lemma morphim_coprime_bigdprod (I : finType) P (H : I -> {group gT}) G :\n    G \\subset D -> \\big[dprod/1]_(i | P i) H i = G ->\n    (forall i j, P i -> P j -> i != j -> coprime #|H i| #|H j|) ->\n  \\big[dprod/1]_(i | P i) f @* H i = f @* G.\nProof.\nmove=> sGD /bigdprodWcp defG coH; have def_fG := morphim_bigcprod sGD defG.\nby apply: bigcprod_coprime_dprod => // i j *; rewrite coprime_morph ?coH.\nQed.",
    "Lemma quotient_pprod : pprod K H = G -> pprod (K / M) (H / M) = G / M.\nProof. exact: morphim_pprod. Qed.",
    "Lemma quotient_coprime_sdprod :\n  K ><| H = G -> coprime #|K| #|H| -> (K / M) ><| (H / M) = G / M.\nProof. exact: morphim_coprime_sdprod. Qed.",
    "Lemma quotient_cprod : K \\* H = G -> (K / M) \\* (H / M) = G / M.\nProof. exact: morphim_cprod. Qed.",
    "Lemma quotient_coprime_dprod :\n  K \\x H = G -> coprime #|K| #|H| -> (K / M) \\x (H / M) = G / M.\nProof. exact: morphim_coprime_dprod. Qed.",
    "Lemma extprod_mul1g : left_id (1, 1) extprod_mulg.\nProof. by case=> x1 x2; congr (_, _); apply: mul1g. Qed.",
    "Lemma extprod_mulVg : left_inverse (1, 1) extprod_invg extprod_mulg.\nProof. by move=> x; congr (_, _); apply: mulVg. Qed.",
    "Lemma extprod_mulgA : associative extprod_mulg.\nProof. by move=> x y z; congr (_, _); apply: mulgA. Qed.",
    "Lemma group_setX (H1 : {group gT1}) (H2 : {group gT2}) : group_set (setX H1 H2).\nProof.\napply/group_setP; split; first by rewrite !inE !group1.\nby case=> [x1 x2] [y1 y2] /[!inE] /andP[Hx1 Hx2] /andP[Hy1 Hy2] /[!groupM].\nQed.",
    "Lemma pairg1_morphM : {morph pairg1 : x y / x * y}.\nProof. by move=> x y /=; rewrite {2}/mulg /= /extprod_mulg /= mul1g. Qed.",
    "Lemma pair1g_morphM : {morph pair1g : x y / x * y}.\nProof. by move=> x y /=; rewrite {2}/mulg /= /extprod_mulg /= mul1g. Qed.",
    "Lemma fst_morphM : {morph (@fst gT1 gT2) : x y / x * y}.\nProof. by move=> x y. Qed.",
    "Lemma snd_morphM : {morph (@snd gT1 gT2) : x y / x * y}.\nProof. by move=> x y. Qed.",
    "Lemma injm_pair1g : 'injm pair1g.\nProof. by apply/subsetP=> x /morphpreP[_ /set1P[->]]; apply: set11. Qed.",
    "Lemma injm_pairg1 : 'injm pairg1.\nProof. by apply/subsetP=> x /morphpreP[_ /set1P[->]]; apply: set11. Qed.",
    "Lemma morphim_pairg1 (H1 : {set gT1}) : pairg1 @* H1 = setX H1 1.\nProof. by rewrite -imset2_pair imset2_set1r morphimEsub ?subsetT. Qed.",
    "Lemma morphim_pair1g (H2 : {set gT2}) : pair1g @* H2 = setX 1 H2.\nProof. by rewrite -imset2_pair imset2_set1l morphimEsub ?subsetT. Qed.",
    "Lemma morphim_fstX (H1: {set gT1}) (H2 : {group gT2}) :\n  [morphism of fun x => x.1] @* setX H1 H2 = H1.\nProof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP=> x0 /[1!inE] /andP[Hx1 _] ->.\nmove=> Hx1; apply/imsetP; exists (x, 1); last by trivial.\nby rewrite in_setX Hx1 /=.\nQed.",
    "Lemma morphim_sndX (H1: {group gT1}) (H2 : {set gT2}) :\n  [morphism of fun x => x.2] @* setX H1 H2 = H2.\nProof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP=> x0 /[1!inE] /andP[_ Hx2] ->.\nmove=> Hx2; apply/imsetP; exists (1, x); last by [].\nby rewrite in_setX Hx2 andbT.\nQed.",
    "Lemma setX_prod (H1 : {set gT1}) (H2 : {set gT2}) :\n  setX H1 1 * setX 1 H2 = setX H1 H2.\nProof.\napply/setP=> [[x y]]; rewrite !inE /=.\napply/imset2P/andP=> [[[x1 u1] [v1 y1]] | [Hx Hy]].\n  rewrite !inE /= => /andP[Hx1 /eqP->] /andP[/eqP-> Hx] [-> ->].\n  by rewrite mulg1 mul1g.\nexists (x, 1 : gT2) (1 : gT1, y); rewrite ?inE ?Hx ?eqxx //.\nby rewrite /mulg /= /extprod_mulg /= mulg1 mul1g.\nQed.",
    "Lemma setX_dprod (H1 : {group gT1}) (H2 : {group gT2}) :\n  setX H1 1 \\x setX 1 H2 = setX H1 H2.\nProof.\nrewrite dprodE ?setX_prod //.\n  apply/centsP=> [[x u]] /[!inE]/= /andP[/eqP-> _] [v y].\n  by rewrite !inE /= => /andP[_ /eqP->]; congr (_, _); rewrite ?mul1g ?mulg1.\napply/trivgP; apply/subsetP=> [[x y]]; rewrite !inE /= -!andbA.\nby case/and4P=> _ /eqP-> /eqP->; rewrite eqxx.\nQed.",
    "Lemma isog_setX1 (H1 : {group gT1}) : isog H1 (setX H1 1).\nProof.\napply/isogP; exists [morphism of restrm (subsetT H1) pairg1].\n  by rewrite injm_restrm ?injm_pairg1.\nby rewrite morphim_restrm morphim_pairg1 setIid.\nQed.",
    "Lemma isog_set1X (H2 : {group gT2}) : isog H2 (setX 1 H2).\nProof.\napply/isogP; exists [morphism of restrm (subsetT H2) pair1g].\n  by rewrite injm_restrm ?injm_pair1g.\nby rewrite morphim_restrm morphim_pair1g setIid.\nQed.",
    "Lemma setX_gen (H1 : {set gT1}) (H2 : {set gT2}) :\n  1 \\in H1 -> 1 \\in H2 -> <<setX H1 H2>> = setX <<H1>> <<H2>>.\nProof.\nmove=> H1_1 H2_1; apply/eqP.\nrewrite eqEsubset gen_subG setXS ?subset_gen //.\n\nrewrite -[in X in X \\subset _]setX_prod.\nrewrite -morphim_pair1g -morphim_pairg1 !morphim_gen ?subsetT //.\nby rewrite morphim_pair1g morphim_pairg1 mul_subG // genS // setXS ?sub1set.\nQed.",
    "Lemma extnprod_mul1g : left_id [ffun=> 1%g] extnprod_mulg.\nProof. by move=> x; apply/ffunP => i; rewrite !ffunE mul1g. Qed.",
    "Lemma extnprod_mulVg : left_inverse [ffun=> 1%g] extnprod_invg extnprod_mulg.\nProof. by move=> x; apply/ffunP => i; rewrite !ffunE mulVg. Qed.",
    "Lemma extnprod_mulgA : associative extnprod_mulg.\nProof. by move=> x y z; apply/ffunP => i; rewrite !ffunE mulgA. Qed.",
    "Lemma oneg_ffun i : (1 : gTn) i = 1. Proof. by rewrite ffunE. Qed.",
    "Lemma mulg_ffun i (x y : gTn) : (x * y) i = x i * y i.\nProof. by rewrite ffunE. Qed.",
    "Lemma invg_ffun i (x : gTn) : x^-1 i = (x i)^-1.\nProof. by rewrite ffunE. Qed.",
    "Lemma prodg_ffun T (r : seq T) (F : T -> gTn) (P : {pred T}) i :\n  (\\prod_(t <- r | P t) F t) i = \\prod_(t <- r | P t) F t i.\nProof. exact: (big_morph _ (@mulg_ffun i) (@oneg_ffun i)). Qed.",
    "Lemma group_setXn H : group_set (setXn H).\nProof.\nby apply/group_setP; split=> [|x y] /[!inE]/= => [|/forallP xH /forallP yH];\n   apply/forallP => i; rewrite ?ffunE (group1, groupM)// ?xH ?yH.\nQed.",
    "Lemma dfung1_id i (g : gT i) : dfung1 g i = g.\nProof. by rewrite ffunE dfwith_in. Qed.",
    "Lemma dfung1_dflt i (g : gT i) j : i != j -> dfung1 g j = 1.\nProof. by move=> ij; rewrite ffunE dfwith_out. Qed.",
    "Lemma dfung1_morphM i : {morph @dfung1 i : g h / g * h}.\nProof.\nmove=> g h; apply/ffunP=> j; have [{j}<-|nij] := eqVneq i j.\n  by rewrite !(dfung1_id, ffunE).\nby rewrite !(dfung1_dflt, ffunE)// mulg1.\nQed.",
    "Lemma dffunM i : {morph (fun x => x i) : x y / x * y}.\nProof. by move=> x y; rewrite !ffunE. Qed.",
    "Lemma injm_dfung1 i : 'injm (@dfung1 i).\nProof. \napply/subsetP => x /morphpreP[_ /set1P /ffunP/=/(_ i)].\nby rewrite !(ffunE, dfung1_id) => ->; apply: set11.\nQed.",
    "Lemma group_set_dfwith H i (G : {group gT i}) j :\n  group_set (dfwith (H : forall k, {set gT k}) (G : {set _}) j).\nProof.\nhave [<-|ij] := eqVneq i j; first by rewrite !dfwith_in// groupP.\nby rewrite !dfwith_out // groupP.\nQed.",
    "Lemma group_dfwithE H i G j : @group_dfwith H i G j = dfwith H G j.\nProof.\nby apply/val_inj; have [<-|nij]/= := eqVneq i j;\n   [rewrite !dfwith_in|rewrite !dfwith_out].\nQed.",
    "Lemma set1gXnE {i} (H : {set gT i}) :\n  set1gXn H = setXn (dfwith (fun i0 : I => [1 gT _]%g) H).\nProof. by rewrite /set1gXn unlock. Qed.",
    "Lemma set1gXnP {i} (H : {set gT i}) x :\n  reflect (exists2 h, h \\in H & x = dfung1 h) (x \\in set1gXn H).\nProof.\nrewrite set1gXnE/=; apply: (iffP setXnP) => [xP|[h hH ->] j]; last first.\n  by rewrite ffunE; case: dfwithP => [|k ?]; rewrite (dfwith_in, dfwith_out).\nexists (x i); first by have := xP i; rewrite dfwith_in.\napply/ffunP => j; have := xP j; rewrite ffunE.\ncase: dfwithP => // [xiH|k neq_ik]; first by rewrite dfwith_in.\nby move=> /set1gP->; rewrite dfwith_out.\nQed.",
    "Lemma morphim_dfung1 i (G : {set gT i}) : @dfung1 i @* G = set1gXn G.\nProof.\nby rewrite morphimEsub//=; apply/setP=> /= x; apply/imsetP/set1gXnP.\nQed.",
    "Lemma morphim_dffunXn i H : dffun_morphism i @* setXn H = H i.\nProof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP => x0 /[1!inE] /forallP/(_ i)/= ? ->.\nmove=> Hx1; apply/imsetP; exists (dfung1 x); last by rewrite dfung1_id.\nby rewrite in_setXn; apply/forallP => j /[!ffunE]; case: dfwithP.\nQed.",
    "Lemma set1gXn_group_set {i} (H : {group gT i}) : group_set (set1gXn H).\nProof. by rewrite set1gXnE; exact: group_setXn. Qed.",
    "Lemma setXn_prod H : \\prod_i set1gXn (H i) = setXn H.\nProof.\napply/setP => /= x; apply/prodsgP /setXnP => [[/= f fH {x}-> i]|xH /=].\n  rewrite prodg_ffun group_prod// => j _.\n  by have /set1gXnP[x xH ->] := fH j isT; rewrite ffunE; case: dfwithP.\nexists (fun i => dfung1 (x i)) => [i _|]; first by apply/set1gXnP; exists (x i).\napply/ffunP => i; rewrite prodg_ffun (big_only1 i) ?dfung1_id//.\nby move=> j ij _; rewrite dfung1_dflt.\nQed.",
    "Lemma set1gXn_commute (H : forall i, {group gT i}) i j :\n  commute (set1gXn (H i)) (set1gXn (H j)).\nProof.\nhave [-> //|neqij] := eqVneq j i.\napply/centC/centsP => _ /set1gXnP [hi hiH ->] _ /set1gXnP [hj hjH ->].\napply/ffunP => k; rewrite !ffunE.\nby case: dfwithP => [|?]; rewrite ?mulg1 ?mul1g// dfwith_out// mulg1 mul1g.\nQed.",
    "Lemma setXn_dprod H : \\big[dprod/1]_i set1gXn (H i) = setXn H.\nProof.\nrewrite -setXn_prod//=.\nsuff -> : \\big[dprod/1]_i groupXn1 (H i) = (\\prod_i groupXn1 (H i))%G.\n  by rewrite comm_prodG//=; apply: in2W; apply: set1gXn_commute.\napply/eqP; apply/bigdprodYP => i //= _; rewrite subsetD.\napply/andP; split.\n  rewrite comm_prodG; last by apply: in2W; apply: set1gXn_commute.\n  apply/centsP => _ /prodsgP[/= h_ h_P ->] _ /set1gXnP [h hH ->].\n  apply/ffunP => j; rewrite !ffunE/=.\n  rewrite (big_morph _ (@dffunM j) (_ : _ = 1)) ?ffunE//.\n  case: dfwithP => {j} [|? ?]; last by rewrite mulg1 mul1g.\n  rewrite big1 ?mulg1 ?mul1g// => j neq_ji.\n  by have /set1gXnP[? _ ->] := h_P j neq_ji; rewrite ffunE dfwith_out.\nrewrite -setI_eq0 -subset0; apply/subsetP => /= x; rewrite !inE.\nrewrite comm_prodG; last by apply: in2W; apply: set1gXn_commute.\nmove=> /and3P[+ + /set1gXnP [h _ x_h]]; rewrite {x}x_h.\nmove=> /prodsgP[x_ x_P /ffunP/(_ i)]; rewrite ffunE dfwith_in => {h}->.\napply: contra_neqT => _; apply/ffunP => j; rewrite !ffunE/=.\ncase: dfwithP => // {j}; rewrite (big_morph _ (@dffunM i) (_ : _ = 1)) ?ffunE//.\nrewrite big1// => j neq_ji.\nby have /set1gXnP[g gH /ffunP->] := x_P _ neq_ji; rewrite ffunE dfwith_out.\nQed.",
    "Lemma isog_setXn i (G : {group gT i}) : G \\isog set1gXn G.\nProof.\napply/(@isogP _ _ G); exists [morphism of restrm (subsetT G) (@dfung1 i)].\n  by rewrite injm_restrm ?injm_dfung1.\nby rewrite morphim_restrm morphim_dfung1 setIid.\nQed.",
    "Lemma setXn_gen H : (forall i, 1 \\in H i) -> \n  <<setXn H>> = setXn (fun i => <<H i>>).\nProof.\nmove=> H1; apply/eqP; rewrite eqEsubset gen_subG setXnS/=; last first.\n  by move=> ?; rewrite subset_gen.\nrewrite -[in X in X \\subset _]setXn_prod; under eq_bigr do\n   rewrite -morphim_dfung1 morphim_gen ?subsetT// morphim_dfung1.\nrewrite prod_subG// => i; rewrite genS // set1gXnE setXnS // => j.\nby case: dfwithP => // k _; rewrite sub1set.\nQed.",
    "Lemma groupX0 (gT : 'I_0 -> finGroupType) (G : forall i, {group gT i}) :\n  setXn G = 1%g.\nProof.\nby apply/setP => ?; apply/setXnP/set1P => [_|_ []//]; apply/ffunP => -[].\nQed.",
    "Lemma sdprod_inv_proof (u : sdT) : (u.1^-1, to u.2^-1 u.1^-1) \\in setX D R.\nProof.\nby case: u => [[a x]] /= /setXP[Da Rx]; rewrite inE gact_stable !groupV ?Da.\nQed.",
    "Lemma sdprod_mul_proof (u v : sdT) :\n  (u.1 * v.1, to u.2 v.1 * v.2) \\in setX D R.\nProof.\ncase: u v => [[a x] /= /setXP[Da Rx]] [[b y] /= /setXP[Db Ry]].\nby rewrite inE !groupM //= gact_stable.\nQed.",
    "Lemma sdprod_mul1g : left_id sdprod_one sdprod_mul.\nProof.\nmove=> u; apply: val_inj; case: u => [[a x] /=]; case/setXP=> Da _.\nby rewrite gact1 // !mul1g.\nQed.",
    "Lemma sdprod_mulVg : left_inverse sdprod_one sdprod_inv sdprod_mul.\nProof.\nmove=> u; apply: val_inj; case: u => [[a x] /=]; case/setXP=> Da _.\nby rewrite actKVin ?mulVg.\nQed.",
    "Lemma sdprod_mulgA : associative sdprod_mul.\nProof.\nmove=> u v w; apply: val_inj; case: u => [[a x]] /=; case/setXP=> Da Rx.\ncase: v w => [[b y]] /=; case/setXP=> Db Ry [[c z]] /=; case/setXP=> Dc Rz.\nby rewrite !(actMin to) // gactM ?gact_stable // !mulgA.\nQed.",
    "Lemma sdpair1_morphM : {in R &, {morph sdpair1 : x y / x * y}}.\nProof.\nmove=> x y Rx Ry; apply: val_inj.\nby rewrite /= !val_insubd !inE !group1 !groupM ?Rx ?Ry //= mulg1 act1.\nQed.",
    "Lemma sdpair2_morphM : {in D &, {morph sdpair2 : a b / a * b}}.\nProof.\nmove=> a b Da Db; apply: val_inj.\nby rewrite /= !val_insubd !inE !group1 !groupM ?Da ?Db //= mulg1 gact1.\nQed.",
    "Lemma injm_sdpair1 : 'injm sdpair1.\nProof.\napply/subsetP=> x /setIP[Rx].\nby rewrite !inE -val_eqE val_insubd inE Rx group1 /=; case/andP.\nQed.",
    "Lemma injm_sdpair2 : 'injm sdpair2.\nProof.\napply/subsetP=> a /setIP[Da].\nby rewrite !inE -val_eqE val_insubd inE Da group1 /=; case/andP.\nQed.",
    "Lemma sdpairE (u : sdT) : u = sdpair2 u.1 * sdpair1 u.2.\nProof.\napply: val_inj; case: u => [[a x] /= /setXP[Da Rx]].\nby rewrite !val_insubd !inE Da Rx !(group1, gact1) // mulg1 mul1g.\nQed.",
    "Lemma sdpair_act : {in R & D,\n  forall x a, sdpair1 (to x a) = sdpair1 x ^ sdpair2 a}.\nProof.\nmove=> x a Rx Da; apply: val_inj.\nrewrite /= !val_insubd !inE !group1 gact_stable ?Da ?Rx //=.\nby rewrite !mul1g mulVg invg1 mulg1 actKVin ?mul1g.\nQed.",
    "Lemma sdpair_setact (G : {set rT}) a : G \\subset R -> a \\in D ->\n  sdpair1 @* (to^~ a @: G) = (sdpair1 @* G) :^ sdpair2 a.\nProof.\nmove=> sGR Da; have GtoR := subsetP sGR; apply/eqP.\nrewrite eqEcard cardJg !(card_injm injm_sdpair1) //; last first.\n  by apply/subsetP=> _ /imsetP[x Gx ->]; rewrite gact_stable ?GtoR.\nrewrite (card_imset _ (act_inj _ _)) leqnn andbT.\napply/subsetP=> _ /morphimP[xa Rxa /imsetP[x Gx def_xa ->]].\nrewrite mem_conjg -morphV // -sdpair_act ?groupV // def_xa actKin //.\nby rewrite mem_morphim ?GtoR.\nQed.",
    "Lemma im_sdpair_norm : sdpair2 @* D \\subset 'N(sdpair1 @* R).\nProof.\napply/subsetP=> _ /morphimP[a _ Da ->].\nrewrite inE -sdpair_setact // morphimS //.\nby apply/subsetP=> _ /imsetP[x Rx ->]; rewrite gact_stable.\nQed.",
    "Lemma im_sdpair_TI : (sdpair1 @* R) :&: (sdpair2 @* D) = 1.\nProof.\napply/trivgP; apply/subsetP=> _ /setIP[/morphimP[x _ Rx ->]].\ncase/morphimP=> a _ Da /eqP; rewrite inE -!val_eqE.\nby rewrite !val_insubd !inE Da Rx !group1 /eq_op /= eqxx; case/andP.\nQed.",
    "Lemma im_sdpair : (sdpair1 @* R) * (sdpair2 @* D) = setT.\nProof.\napply/eqP; rewrite -subTset -(normC im_sdpair_norm).\napply/subsetP=> /= u _; rewrite [u]sdpairE.\nby case: u => [[a x] /= /setXP[Da Rx]]; rewrite mem_mulg ?mem_morphim.\nQed.",
    "Lemma sdprod_sdpair : sdpair1 @* R ><| sdpair2 @* D = setT.\nProof. by rewrite sdprodE ?(im_sdpair_norm, im_sdpair, im_sdpair_TI). Qed.",
    "Lemma gacentEsd : 'C_(|to)(A) = sdpair1 @*^-1 'C(sdpair2 @* A).\nProof.\napply/setP=> x; apply/idP/idP.\n  case/setIP=> Rx /afixP cDAx; rewrite mem_morphpre //.\n  apply/centP=> _ /morphimP[a Da Aa ->]; red.\n  by rewrite conjgC -sdpair_act // cDAx // inE Da.\ncase/morphpreP=> Rx cAx; rewrite inE Rx; apply/afixP=> a /setIP[Da Aa].\napply: (injmP injm_sdpair1); rewrite ?gact_stable /= ?sdpair_act //=.\nby rewrite /conjg (centP cAx) ?mulKg ?mem_morphim.\nQed.",
    "Lemma astabEsd : 'C(G | to) = sdpair2 @*^-1 'C(sdpair1 @* G).\nProof.\nhave ssGR := subsetP sGR; apply/setP=> a; apply/idP/idP=> [cGa|].\n  rewrite mem_morphpre ?(astab_dom cGa) //.\n  apply/centP=> _ /morphimP[x Rx Gx ->]; symmetry.\n  by rewrite conjgC -sdpair_act ?(astab_act cGa)  ?(astab_dom cGa).\ncase/morphpreP=> Da cGa; rewrite !inE Da; apply/subsetP=> x Gx; rewrite inE.\napply/eqP; apply: (injmP injm_sdpair1); rewrite ?gact_stable ?ssGR //=.\nby rewrite sdpair_act ?ssGR // /conjg -(centP cGa) ?mulKg ?mem_morphim ?ssGR.\nQed.",
    "Lemma astabsEsd : 'N(G | to) = sdpair2 @*^-1 'N(sdpair1 @* G).\nProof.\napply/setP=> a; apply/idP/idP=> [nGa|].\n  have Da := astabs_dom nGa; rewrite mem_morphpre // inE sub_conjg.\n  apply/subsetP=> _ /morphimP[x Rx Gx ->].\n  by rewrite mem_conjgV -sdpair_act // mem_morphim ?gact_stable ?astabs_act.\ncase/morphpreP=> Da nGa; rewrite !inE Da; apply/subsetP=> x Gx.\nhave Rx := subsetP sGR _ Gx; have Rxa: to x a \\in R by rewrite gact_stable.\nrewrite inE -sub1set -(injmSK injm_sdpair1) ?morphim_set1 ?sub1set //=.\nby rewrite sdpair_act ?memJ_norm ?mem_morphim.\nQed.",
    "Lemma actsEsd : [acts A, on G | to] = (sdpair2 @* A \\subset 'N(sdpair1 @* G)).\nProof. by rewrite sub_morphim_pre -?astabsEsd. Qed.",
    "Lemma pprodmE x a : x \\in H -> a \\in K -> f (x * a) = fH x * fK a.\nProof.\nmove=> Hx Ka; have: x * a \\in H * K by rewrite mem_mulg.\nrewrite -remgrP inE /f rcoset_sym mem_rcoset /divgr -mulgA groupMl //.\ncase/andP; move: (remgr H K _) => b Hab Kb; rewrite morphM // -mulgA.\nhave Kab: a * b^-1 \\in K by rewrite groupM ?groupV.\nby congr (_ * _); rewrite eqfHK 1?inE ?Hab // -morphM // mulgKV.\nQed.",
    "Lemma pprodmEl : {in H, f =1 fH}.\nProof. by move=> x Hx; rewrite -(mulg1 x) pprodmE // morph1 !mulg1. Qed.",
    "Lemma pprodmEr : {in K, f =1 fK}.\nProof. by move=> a Ka; rewrite -(mul1g a) pprodmE // morph1 !mul1g. Qed.",
    "Lemma pprodmM : {in H <*> K &, {morph f: x y / x * y}}.\nProof.\nmove=> xa yb; rewrite norm_joinEr //.\nmove=> /imset2P[x a Ha Ka ->{xa}] /imset2P[y b Hy Kb ->{yb}].\nhave Hya: y ^ a^-1 \\in H by rewrite -mem_conjg (normsP nHK).\nrewrite mulgA -(mulgA x) (conjgCV a y) (mulgA x) -mulgA !pprodmE 1?groupMl //.\nby rewrite morphM // actf ?groupV ?morphV // morphM // !mulgA mulgKV invgK.\nQed.",
    "Lemma morphim_pprodm A B :\n  A \\subset H -> B \\subset K -> f @* (A * B) = fH @* A * fK @* B.\nProof.\nmove=> sAH sBK; rewrite [f @* _]morphimEsub /=; last first.\n  by rewrite norm_joinEr // mulgSS.\napply/setP=> y; apply/imsetP/idP=> [[_ /mulsgP[x a Ax Ba ->] ->{y}] |].\n  have Hx := subsetP sAH x Ax; have Ka := subsetP sBK a Ba.\n  by rewrite pprodmE // imset2_f ?mem_morphim.\ncase/mulsgP=> _ _ /morphimP[x Hx Ax ->] /morphimP[a Ka Ba ->] ->{y}.\nby exists (x * a); rewrite ?mem_mulg ?pprodmE.\nQed.",
    "Lemma morphim_pprodml A : A \\subset H -> f @* A = fH @* A.\nProof.\nby move=> sAH; rewrite -{1}(mulg1 A) morphim_pprodm ?sub1G // morphim1 mulg1.\nQed.",
    "Lemma morphim_pprodmr B : B \\subset K -> f @* B = fK @* B.\nProof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_pprodm ?sub1G // morphim1 mul1g.\nQed.",
    "Lemma ker_pprodm : 'ker f = [set x * a^-1 | x in H, a in K & fH x == fK a].\nProof.\napply/setP=> y; rewrite 3!inE {1}norm_joinEr //=.\napply/andP/imset2P=> [[/mulsgP[x a Hx Ka ->{y}]]|[x a Hx]].\n  rewrite pprodmE // => fxa1.\n  by exists x a^-1; rewrite ?invgK // inE groupVr ?morphV // eq_mulgV1 invgK.\ncase/setIdP=> Kx /eqP fx ->{y}.\nby rewrite imset2_f ?pprodmE ?groupV ?morphV // fx mulgV.\nQed.",
    "Lemma injm_pprodm :\n  'injm f = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == fH @* K].\nProof.\napply/idP/and3P=> [injf | [injfH injfK]].\n  rewrite eq_sym -{1}morphimIdom -(morphim_pprodml (subsetIl _ _)) injmI //.\n  rewrite morphim_pprodml // morphim_pprodmr //=; split=> //.\n    apply/injmP=> x y Hx Hy /=; rewrite -!pprodmEl //.\n    by apply: (injmP injf); rewrite ?mem_gen ?inE ?Hx ?Hy.\n  apply/injmP=> a b Ka Kb /=; rewrite -!pprodmEr //.\n  by apply: (injmP injf); rewrite ?mem_gen //; apply/setUP; right.\nmove/eqP=> fHK; rewrite ker_pprodm; apply/subsetP=> y.\ncase/imset2P=> x a Hx /setIdP[Ka /eqP fxa] ->.\nhave: fH x \\in fH @* K by rewrite -fHK inE {2}fxa !mem_morphim.\ncase/morphimP=> z Hz Kz /(injmP injfH) def_x.\nrewrite def_x // eqfHK ?inE ?Hz // in fxa.\nby rewrite def_x // (injmP injfK _ _ Kz Ka fxa) mulgV set11.\nQed.",
    "Lemma sdprodm_norm : K \\subset 'N(H).\nProof. by case/sdprodP: eqHK_G. Qed.",
    "Lemma sdprodm_sub : G \\subset H <*> K.\nProof. by case/sdprodP: eqHK_G => _ <- nHK _; rewrite norm_joinEr. Qed.",
    "Lemma sdprodm_eqf : {in H :&: K, fH =1 fK}.\nProof.\nby case/sdprodP: eqHK_G => _ _ _ -> _ /set1P->; rewrite !morph1.\nQed.",
    "Lemma sdprodmE a b : a \\in H -> b \\in K -> sdprodm (a * b) = fH a * fK b.\nProof. exact: pprodmE. Qed.",
    "Lemma sdprodmEl a : a \\in H -> sdprodm a = fH a.\nProof. exact: pprodmEl. Qed.",
    "Lemma sdprodmEr b : b \\in K -> sdprodm b = fK b.\nProof. exact: pprodmEr. Qed.",
    "Lemma morphim_sdprodm A B :\n  A \\subset H -> B \\subset K -> sdprodm @* (A * B) = fH @* A * fK @* B.\nProof.\nmove=> sAH sBK; rewrite morphim_restrm /= (setIidPr _) ?morphim_pprodm //.\nby case/sdprodP: eqHK_G => _ <- _ _; apply: mulgSS.\nQed.",
    "Lemma im_sdprodm : sdprodm @* G = fH @* H * fK @* K.\nProof. by rewrite -morphim_sdprodm //; case/sdprodP: eqHK_G => _ ->. Qed.",
    "Lemma morphim_sdprodml A : A \\subset H -> sdprodm @* A = fH @* A.\nProof.\nby move=> sHA; rewrite -{1}(mulg1 A) morphim_sdprodm ?sub1G // morphim1 mulg1.\nQed.",
    "Lemma morphim_sdprodmr B : B \\subset K -> sdprodm @* B = fK @* B.\nProof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_sdprodm ?sub1G // morphim1 mul1g.\nQed.",
    "Lemma ker_sdprodm :\n  'ker sdprodm = [set a * b^-1 | a in H, b in K & fH a == fK b].\nProof.\nrewrite ker_restrm (setIidPr _) ?subIset ?ker_pprodm //; apply/orP; left.\nby case/sdprodP: eqHK_G => _ <- nHK _; rewrite norm_joinEr.\nQed.",
    "Lemma injm_sdprodm :\n  'injm sdprodm = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == 1].\nProof.\nrewrite ker_sdprodm -(ker_pprodm sdprodm_norm actf sdprodm_eqf) injm_pprodm.\ncongr [&& _, _ & _ == _]; have [_ _ _ tiHK] := sdprodP eqHK_G.\nby rewrite -morphimIdom tiHK morphim1.\nQed.",
    "Lemma cprodm_norm : K \\subset 'N(H).\nProof. by rewrite cents_norm //; case/cprodP: eqHK_G. Qed.",
    "Lemma cprodm_sub : G \\subset H <*> K.\nProof. by case/cprodP: eqHK_G => _ <- cHK; rewrite cent_joinEr. Qed.",
    "Lemma cprodm_actf : {in H & K, morph_act 'J 'J fH fK}.\nProof.\ncase/cprodP: eqHK_G => _ _ cHK a b Ha Kb /=.\nby rewrite /conjg -(centsP cHK b) // -(centsP cfHK (fK b)) ?mulKg ?mem_morphim.\nQed.",
    "Lemma cprodmE a b : a \\in H -> b \\in K -> cprodm (a * b) = fH a * fK b.\nProof. exact: pprodmE. Qed.",
    "Lemma cprodmEl a : a \\in H -> cprodm a = fH a.\nProof. exact: pprodmEl. Qed.",
    "Lemma cprodmEr b : b \\in K -> cprodm b = fK b.\nProof. exact: pprodmEr. Qed.",
    "Lemma morphim_cprodm A B :\n  A \\subset H -> B \\subset K -> cprodm @* (A * B) = fH @* A * fK @* B.\nProof.\nmove=> sAH sBK; rewrite morphim_restrm /= (setIidPr _) ?morphim_pprodm //.\nby case/cprodP: eqHK_G => _ <- _; apply: mulgSS.\nQed.",
    "Lemma im_cprodm : cprodm @* G = fH @* H * fK @* K.\nProof.\nby have [_ defHK _] := cprodP eqHK_G; rewrite -{2}defHK morphim_cprodm.\nQed.",
    "Lemma morphim_cprodml A : A \\subset H -> cprodm @* A = fH @* A.\nProof.\nby move=> sHA; rewrite -{1}(mulg1 A) morphim_cprodm ?sub1G // morphim1 mulg1.\nQed.",
    "Lemma morphim_cprodmr B : B \\subset K -> cprodm @* B = fK @* B.\nProof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_cprodm ?sub1G // morphim1 mul1g.\nQed.",
    "Lemma ker_cprodm : 'ker cprodm = [set a * b^-1 | a in H, b in K & fH a == fK b].\nProof.\nrewrite ker_restrm (setIidPr _) ?subIset ?ker_pprodm //; apply/orP; left.\nby case/cprodP: eqHK_G => _ <- cHK; rewrite cent_joinEr.\nQed.",
    "Lemma injm_cprodm :\n  'injm cprodm = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == fH @* K].\nProof.\nby rewrite ker_cprodm -(ker_pprodm cprodm_norm cprodm_actf eqfHK) injm_pprodm.\nQed.",
    "Lemma dprodm_cprod : H \\* K = G.\nProof.\nby rewrite -eqHK_G /dprod; case/dprodP: eqHK_G => _ _ _ ->; rewrite subxx.\nQed.",
    "Lemma dprodm_eqf : {in H :&: K, fH =1 fK}.\nProof. by case/dprodP: eqHK_G => _ _ _ -> _ /set1P->; rewrite !morph1. Qed.",
    "Lemma dprodmE a b : a \\in H -> b \\in K -> dprodm (a * b) = fH a * fK b.\nProof. exact: pprodmE. Qed.",
    "Lemma dprodmEl a : a \\in H -> dprodm a = fH a.\nProof. exact: pprodmEl. Qed.",
    "Lemma dprodmEr b : b \\in K -> dprodm b = fK b.\nProof. exact: pprodmEr. Qed.",
    "Lemma morphim_dprodm A B :\n  A \\subset H -> B \\subset K -> dprodm @* (A * B) = fH @* A * fK @* B.\nProof. exact: morphim_cprodm. Qed.",
    "Lemma im_dprodm : dprodm @* G = fH @* H * fK @* K.\nProof. exact: im_cprodm. Qed.",
    "Lemma morphim_dprodml A : A \\subset H -> dprodm @* A = fH @* A.\nProof. exact: morphim_cprodml. Qed.",
    "Lemma morphim_dprodmr B : B \\subset K -> dprodm @* B = fK @* B.\nProof. exact: morphim_cprodmr. Qed.",
    "Lemma ker_dprodm : 'ker dprodm = [set a * b^-1 | a in H, b in K & fH a == fK b].\nProof. exact: ker_cprodm. Qed.",
    "Lemma injm_dprodm :\n  'injm dprodm = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == 1].\nProof.\nrewrite injm_cprodm -(morphimIdom fH K).\nby case/dprodP: eqHK_G => _ _ _ ->; rewrite morphim1.\nQed.",
    "Lemma isog_dprod A B G C D L :\n  A \\x B = G -> C \\x D = L -> isog A C -> isog B D -> isog G L.\nProof.\nmove=> defG {C D} /dprodP[[C D -> ->] defL cCD trCD].\ncase/dprodP: defG (defG) => {A B} [[A B -> ->] defG _ _] dG defC defD.\ncase/isogP: defC defL cCD trCD => fA injfA <-{C}.\ncase/isogP: defD => fB injfB <-{D} defL cCD trCD.\napply/isogP; exists (dprodm_morphism dG cCD).\n  by rewrite injm_dprodm injfA injfB trCD eqxx.\nby rewrite /= -{2}defG morphim_dprodm.\nQed.",
    "Lemma xsdprodm_dom1 : DgH \\subset 'dom fsH.\nProof. by rewrite ['dom _]morphpre_invm. Qed.",
    "Lemma xsdprodm_dom2 : DgK \\subset 'dom fsK.\nProof. by rewrite ['dom _]morphpre_invm. Qed.",
    "Lemma im_sdprodm1 : gH @* DgH = fH @* H.\nProof. by rewrite morphim_restrm setIid morphim_comp im_invm. Qed.",
    "Lemma im_sdprodm2 : gK @* DgK = fK @* K.\nProof. by rewrite morphim_restrm setIid morphim_comp im_invm. Qed.",
    "Lemma xsdprodm_act : {in DgH & DgK, morph_act 'J 'J gH gK}.\nProof.\nmove=> fh fk; case/morphimP=> h _ Hh ->{fh}; case/morphimP=> k _ Kk ->{fk}.\nby rewrite /= -sdpair_act // /restrm /= !invmE ?actf ?gact_stable.\nQed.",
    "Lemma im_xsdprodm : xsdprodm @* setT = fH @* H * fK @* K.\nProof. by rewrite -im_sdpair morphim_sdprodm // im_sdprodm1 im_sdprodm2. Qed.",
    "Lemma injm_xsdprodm :\n  'injm xsdprodm = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == 1].\nProof.\nrewrite injm_sdprodm im_sdprodm1 im_sdprodm2 !subG1 /= !ker_restrm !ker_comp.\nrewrite !morphpre_invm !morphimIim.\nby rewrite !morphim_injm_eq1 ?subsetIl ?injm_sdpair1 ?injm_sdpair2.\nQed.",
    "Lemma imset_mulgm (A B : {set gT}) : mulgm @: setX A B = A * B.\nProof. by rewrite -curry_imset2X. Qed.",
    "Lemma mulgmP H1 H2 G : reflect (H1 \\x H2 = G) (misom (setX H1 H2) G mulgm).\nProof.\napply: (iffP misomP) => [[pM /isomP[injf /= <-]] | ].\n  have /dprodP[_ /= defX cH12] := setX_dprod H1 H2.\n  rewrite -{4}defX {}defX => /(congr1 (fun A => morphm pM @* A)).\n  move/(morphimS (morphm_morphism pM)): cH12 => /=.\n  have sH1H: setX H1 1 \\subset setX H1 H2 by rewrite setXS ?sub1G.\n  have sH2H: setX 1 H2 \\subset setX H1 H2 by rewrite setXS ?sub1G.\n  rewrite morphim1 injm_cent ?injmI //= subsetI => /andP[_].\n  by rewrite !morphimEsub //= !imset_mulgm mulg1 mul1g; apply: dprodE.\ncase/dprodP=> _ defG cH12 trH12.\nhave fM: morphic (setX H1 H2) mulgm.\n  apply/morphicP=> [[x1 x2] [y1 y2] /setXP[_ Hx2] /setXP[Hy1 _]].\n  by rewrite /= mulgA -(mulgA x1) -(centsP cH12 x2) ?mulgA.\nexists fM; apply/isomP; split; last by rewrite morphimEsub //= imset_mulgm.\napply/subsetP=> [[x1 x2]]; rewrite !inE /= andbC -eq_invg_mul.\ncase: eqP => //= <-; rewrite groupV -in_setI trH12 => /set1P->.\nby rewrite invg1 eqxx.\nQed.",
    "Lemma coset_one_proof : coset_range H.\nProof. by apply/rcosetsP; exists (1 : gT); rewrite (group1, mulg1). Qed.",
    "Lemma coset_range_mul (B C : coset_of) : coset_range (B * C).\nProof.\ncase: B C => _ /= /rcosetsP[x Nx ->] [_ /= /rcosetsP[y Ny ->]].\nby apply/rcosetsP; exists (x * y); rewrite !(groupM, rcoset_mul, nNH).\nQed.",
    "Lemma coset_range_inv (B : coset_of) : coset_range B^-1.\nProof.\ncase: B => _ /= /rcosetsP[x Nx ->]; rewrite norm_rlcoset ?nNH // invg_lcoset.\nby apply/rcosetsP; exists x^-1; rewrite ?groupV.\nQed.",
    "Lemma coset_mulP : associative coset_mul.\nProof. by move=> B C D; apply: val_inj; rewrite /= mulgA. Qed.",
    "Lemma coset_oneP : left_id coset_one coset_mul.\nProof.\ncase=> B coB; apply: val_inj => /=; case/rcosetsP: coB => x Hx ->{B}.\nby rewrite mulgA mulGid.\nQed.",
    "Lemma coset_invP : left_inverse coset_one coset_inv coset_mul.\nProof.\ncase=> B coB; apply: val_inj => /=; case/rcosetsP: coB => x Hx ->{B}.\nrewrite invg_rcoset -mulgA (mulgA H) mulGid.\nby rewrite norm_rlcoset ?nNH // -lcosetM mulVg mul1g.\nQed.",
    "Lemma val_coset_prim x : x \\in 'N(A) -> coset x :=: H :* x.\nProof.\nby move=> Nx; rewrite val_insubd /= mem_rcosets -{1}(mul1g x) mem_mulg.\nQed.",
    "Lemma coset_morphM : {in 'N(A) &, {morph coset : x y / x * y}}.\nProof.\nmove=> x y Nx Ny; apply: val_inj.\nby rewrite /= !val_coset_prim ?groupM //= rcoset_mul ?nNH.\nQed.",
    "Lemma ker_coset_prim : 'ker coset = 'N_H(A).\nProof.\napply/setP=> z; rewrite !in_setI andbC 2!inE -val_eqE /=.\ncase Nz: (z \\in 'N(A)); rewrite ?andbF ?val_coset_prim // !andbT.\nby apply/eqP/idP=> [<-| Az]; rewrite (rcoset_refl, rcoset_id).\nQed.",
    "Lemma coset_mem y xbar : y \\in xbar -> coset y = xbar.\nProof.\ncase: xbar => /= Hx NHx Hxy; apply: val_inj=> /=.\ncase/rcosetsP: NHx (NHx) Hxy => x Nx -> NHx Hxy.\nby rewrite val_insubd /= (rcoset_eqP Hxy) NHx.\nQed.",
    "Lemma mem_repr_coset xbar : repr xbar \\in xbar.\nProof. by case: xbar => /= _ /rcosetsP[x _ ->]; apply: mem_repr_rcoset. Qed.",
    "Lemma repr_coset1 : repr (1 : coset_of) = 1.\nProof. exact: repr_group. Qed.",
    "Lemma coset_reprK : cancel (fun xbar => repr xbar) coset.\nProof. by move=> xbar; apply: coset_mem (mem_repr_coset xbar). Qed.",
    "Lemma cosetP xbar : {x | x \\in 'N(A) & xbar = coset x}.\nProof.\npose x := repr 'N_xbar(A).\nhave [xbar_x Nx]: x \\in xbar /\\ x \\in 'N(A).\n  apply/setIP; rewrite {}/x; case: xbar => /= _ /rcosetsP[y Ny ->].\n  by apply: (mem_repr y); rewrite inE rcoset_refl.\nby exists x; last rewrite (coset_mem xbar_x).\nQed.",
    "Lemma coset_id x : x \\in A -> coset x = 1.\nProof. by move=> Ax; apply: coset_mem; apply: mem_gen. Qed.",
    "Lemma im_coset : coset @* 'N(A) = setT.\nProof.\nby apply/setP=> xbar; case: (cosetP xbar) => x Nx ->; rewrite inE mem_morphim.\nQed.",
    "Lemma sub_im_coset (C : {set coset_of}) : C \\subset coset @* 'N(A).\nProof. by rewrite im_coset subsetT. Qed.",
    "Lemma cosetpre_proper C D :\n  (coset @*^-1 C \\proper coset @*^-1 D) = (C \\proper D).\nProof. by rewrite morphpre_proper ?sub_im_coset. Qed.",
    "Lemma quotientE : quotient = coset @* Q. Proof. by []. Qed.",
    "Lemma val_coset x : x \\in 'N(H) -> coset H x :=: H :* x.\nProof. by move=> Nx; rewrite val_coset_prim // genGid. Qed.",
    "Lemma coset_default x : (x \\in 'N(H)) = false -> coset H x = 1.\nProof.\nmove=> Nx; apply: val_inj.\nby rewrite val_insubd /= mem_rcosets /= genGid mulSGid ?normG ?Nx.\nQed.",
    "Lemma coset_norm xbar : xbar \\subset 'N(H).\nProof.\ncase: xbar => /= _ /rcosetsP[x Nx ->].\nby rewrite genGid mul_subG ?sub1set ?normG.\nQed.",
    "Lemma ker_coset : 'ker (coset H) = H.\nProof. by rewrite ker_coset_prim genGid (setIidPl _) ?normG. Qed.",
    "Lemma coset_idr x : x \\in 'N(H) -> coset H x = 1 -> x \\in H.\nProof. by move=> Nx Hx1; rewrite -ker_coset mem_morphpre //= Hx1 set11. Qed.",
    "Lemma repr_coset_norm xbar : repr xbar \\in 'N(H).\nProof. exact: subsetP (coset_norm _) _ (mem_repr_coset _). Qed.",
    "Lemma imset_coset G : coset H @: G = G / H.\nProof.\napply/eqP; rewrite eqEsubset andbC imsetS ?subsetIr //=.\napply/subsetP=> _ /imsetP[x Gx ->].\nby case Nx: (x \\in 'N(H)); rewrite ?(coset_default Nx) ?mem_morphim ?group1.\nQed.",
    "Lemma val_quotient A : val @: (A / H) = rcosets H 'N_A(H).\nProof.\napply/setP=> B; apply/imsetP/rcosetsP=> [[xbar Axbar]|[x /setIP[Ax Nx]]] ->{B}.\n  case/morphimP: Axbar => x Nx Ax ->{xbar}.\n  by exists x; [rewrite inE Ax | rewrite /= val_coset].\nby exists (coset H x); [apply/morphimP; exists x | rewrite /= val_coset].\nQed.",
    "Lemma card_quotient_subnorm A : #|A / H| = #|'N_A(H) : H|.\nProof. by rewrite -(card_imset _ val_inj) val_quotient. Qed.",
    "Lemma leq_quotient A : #|A / H| <= #|A|.\nProof. exact: leq_morphim. Qed.",
    "Lemma ltn_quotient A : H :!=: 1 -> H \\subset A -> #|A / H| < #|A|.\nProof.\nby move=> ntH sHA; rewrite ltn_morphim // ker_coset (setIidPr sHA) proper1G.\nQed.",
    "Lemma card_quotient A : A \\subset 'N(H) -> #|A / H| = #|A : H|.\nProof. by move=> nHA; rewrite card_quotient_subnorm (setIidPl nHA). Qed.",
    "Lemma divg_normal G : H <| G -> #|G| %/ #|H| = #|G / H|.\nProof. by case/andP=> sHG nHG; rewrite divgS ?card_quotient. Qed.",
    "Lemma coset1 : coset H 1 :=: H.\nProof. by rewrite morph1 /= genGid. Qed.",
    "Lemma cosetpre1 : coset H @*^-1 1 = H.\nProof. by rewrite -kerE ker_coset. Qed.",
    "Lemma im_quotient : 'N(H) / H = setT.\nProof. exact: im_coset. Qed.",
    "Lemma quotientT : setT / H = setT.\nProof. by rewrite -im_quotient; apply: morphimT. Qed.",
    "Lemma quotientInorm A : 'N_A(H) / H = A / H.\nProof. by rewrite /quotient setIC morphimIdom. Qed.",
    "Lemma quotient_setIpre A D : (A :&: coset H @*^-1 D) / H = A / H :&: D.\nProof. exact: morphim_setIpre. Qed.",
    "Lemma mem_quotient x G : x \\in G -> coset H x \\in G / H.\nProof. by move=> Gx; rewrite -imset_coset imset_f. Qed.",
    "Lemma quotientS A B : A \\subset B -> A / H \\subset B / H.\nProof. exact: morphimS. Qed.",
    "Lemma quotient0 : set0 / H = set0.\nProof. exact: morphim0. Qed.",
    "Lemma quotient_set1 x : x \\in 'N(H) -> [set x] / H = [set coset H x].\nProof. exact: morphim_set1. Qed.",
    "Lemma quotient1 : 1 / H = 1.\nProof. exact: morphim1. Qed.",
    "Lemma quotientV A : A^-1 / H = (A / H)^-1.\nProof. exact: morphimV. Qed.",
    "Lemma quotientMl A B : A \\subset 'N(H) -> A * B / H = (A / H) * (B / H).\nProof. exact: morphimMl. Qed.",
    "Lemma quotientMr A B : B \\subset 'N(H) -> A * B / H = (A / H) * (B / H).\nProof. exact: morphimMr. Qed.",
    "Lemma cosetpreM C D : coset H @*^-1 (C * D) = coset H @*^-1 C * coset H @*^-1 D.\nProof. by rewrite morphpreMl ?sub_im_coset. Qed.",
    "Lemma quotientJ A x : x \\in 'N(H) -> A :^ x / H = (A / H) :^ coset H x.\nProof. exact: morphimJ. Qed.",
    "Lemma quotientU A B : (A :|: B) / H = A / H :|: B / H.\nProof. exact: morphimU. Qed.",
    "Lemma quotientI A B : (A :&: B) / H \\subset A / H :&: B / H.\nProof. exact: morphimI. Qed.",
    "Lemma quotientY A B :\n  A \\subset 'N(H) -> B \\subset 'N(H) -> (A <*> B) / H = (A / H) <*> (B / H).\nProof. exact: morphimY. Qed.",
    "Lemma quotient_homg A : A \\subset 'N(H) -> homg (A / H) A.\nProof. exact: morphim_homg. Qed.",
    "Lemma coset_kerl x y : x \\in H -> coset H (x * y) = coset H y.\nProof.\nmove=> Hx; case Ny: (y \\in 'N(H)); first by rewrite mkerl ?ker_coset.\nby rewrite !coset_default ?groupMl // (subsetP (normG H)).\nQed.",
    "Lemma coset_kerr x y : y \\in H -> coset H (x * y) = coset H x.\nProof.\nmove=> Hy; case Nx: (x \\in 'N(H)); first by rewrite mkerr ?ker_coset.\nby rewrite !coset_default ?groupMr // (subsetP (normG H)).\nQed.",
    "Lemma rcoset_kercosetP x y :\n  x \\in 'N(H) -> y \\in 'N(H) -> reflect (coset H x = coset H y) (x \\in H :* y).\nProof. by rewrite -{6}ker_coset; apply: rcoset_kerP. Qed.",
    "Lemma kercoset_rcoset x y :\n    x \\in 'N(H) -> y \\in 'N(H) ->\n  coset H x = coset H y -> exists2 z, z \\in H & x = z * y.\nProof. by move=> Nx Ny eqfxy; rewrite -ker_coset; apply: ker_rcoset. Qed.",
    "Lemma quotientGI G A : H \\subset G -> (G :&: A) / H = G / H :&: A / H.\nProof. by rewrite -{1}ker_coset; apply: morphimGI. Qed.",
    "Lemma quotientIG A G : H \\subset G -> (A :&: G) / H = A / H :&: G / H.\nProof. by rewrite -{1}ker_coset; apply: morphimIG. Qed.",
    "Lemma quotientD A B : A / H :\\: B / H \\subset (A :\\: B) / H.\nProof. exact: morphimD. Qed.",
    "Lemma quotientD1 A : (A / H)^# \\subset A^# / H.\nProof. exact: morphimD1. Qed.",
    "Lemma quotientDG A G : H \\subset G -> (A :\\: G) / H = A / H :\\: G / H.\nProof. by rewrite -{1}ker_coset; apply: morphimDG. Qed.",
    "Lemma quotientK A : A \\subset 'N(H) -> coset H @*^-1 (A / H) = H * A.\nProof. by rewrite -{8}ker_coset; apply: morphimK. Qed.",
    "Lemma quotientYK G : G \\subset 'N(H) -> coset H @*^-1 (G / H) = H <*> G.\nProof. by move=> nHG; rewrite quotientK ?norm_joinEr. Qed.",
    "Lemma quotientGK G : H <| G -> coset H @*^-1 (G / H) = G.\nProof. by case/andP; rewrite -{1}ker_coset; apply: morphimGK. Qed.",
    "Lemma quotient_class x A :\n  x \\in 'N(H) -> A \\subset 'N(H) -> x ^: A / H  = coset H x ^: (A / H).\nProof. exact: morphim_class. Qed.",
    "Lemma classes_quotient A :\n  A \\subset 'N(H) -> classes (A / H) = [set xA / H | xA in classes A].\nProof. exact: classes_morphim. Qed.",
    "Lemma cosetpre_set1 x :\n  x \\in 'N(H) -> coset H @*^-1 [set coset H x] = H :* x.\nProof. by rewrite -{9}ker_coset; apply: morphpre_set1. Qed.",
    "Lemma cosetpre_set1_coset xbar : coset H @*^-1 [set xbar] = xbar.\nProof. by case: (cosetP xbar) => x Nx ->; rewrite cosetpre_set1 ?val_coset. Qed.",
    "Lemma cosetpreK C : coset H @*^-1 C / H = C.\nProof. by rewrite /quotient morphpreK ?sub_im_coset. Qed.",
    "Lemma trivg_quotient : H / H = 1.\nProof. by rewrite -[X in X / _]ker_coset /quotient morphim_ker. Qed.",
    "Lemma quotientS1 G : G \\subset H -> G / H = 1.\nProof. by move=> sGH; apply/trivgP; rewrite -trivg_quotient quotientS. Qed.",
    "Lemma sub_cosetpre M : H \\subset coset H @*^-1 M.\nProof. by rewrite -{1}ker_coset; apply: ker_sub_pre. Qed.",
    "Lemma quotient_proper G K :\n  H <| G -> H <| K -> (G / H \\proper K / H) = (G \\proper K).\nProof. by move=> nHG nHK; rewrite -cosetpre_proper ?quotientGK. Qed.",
    "Lemma normal_cosetpre M : H <| coset H @*^-1 M.\nProof. by rewrite -{1}ker_coset; apply: ker_normal_pre. Qed.",
    "Lemma cosetpreSK C D :\n  (coset H @*^-1 C \\subset coset H @*^-1 D) = (C \\subset D).\nProof. by rewrite morphpreSK ?sub_im_coset. Qed.",
    "Lemma sub_quotient_pre A C :\n  A \\subset 'N(H) -> (A / H \\subset C) = (A \\subset coset H @*^-1 C).\nProof. exact: sub_morphim_pre. Qed.",
    "Lemma sub_cosetpre_quo C G :\n  H <| G -> (coset H @*^-1 C \\subset G) = (C \\subset G / H).\nProof. by move=> nHG; rewrite -cosetpreSK quotientGK. Qed.",
    "Lemma quotient_sub1 A : A \\subset 'N(H) -> (A / H \\subset [1]) = (A \\subset H).\nProof.\nby move=> nHA /=; rewrite -[gval H in RHS]ker_coset ker_trivg_morphim nHA.\nQed.",
    "Lemma quotientSK A B :\n  A \\subset 'N(H) -> (A / H \\subset B / H) = (A \\subset H * B).\nProof. by move=> nHA; rewrite morphimSK ?ker_coset. Qed.",
    "Lemma quotientSGK A G :\n  A \\subset 'N(H) -> H \\subset G -> (A / H \\subset G / H) = (A \\subset G).\nProof. by rewrite -{2}ker_coset; apply: morphimSGK. Qed.",
    "Lemma quotient_injG :\n  {in [pred G : {group gT} | H <| G] &, injective (fun G => G / H)}.\nProof. by rewrite /normal -{1}ker_coset; apply: morphim_injG. Qed.",
    "Lemma quotient_inj G1 G2 :\n   H <| G1 -> H <| G2 -> G1 / H = G2 / H -> G1 :=: G2.\nProof. by rewrite /normal -[in mem H]ker_coset; apply: morphim_inj. Qed.",
    "Lemma quotient_neq1 A : H <| A -> (A / H != 1) = (H \\proper A).\nProof.\ncase/andP=> sHA  nHA; rewrite /proper sHA -trivg_quotient eqEsubset andbC.\nby rewrite quotientS //= quotientSGK.\nQed.",
    "Lemma quotient_gen A : A \\subset 'N(H) -> <<A>> / H = <<A / H>>.\nProof. exact: morphim_gen. Qed.",
    "Lemma cosetpre_gen C :\n  1 \\in C -> coset H @*^-1 <<C>> = <<coset H @*^-1 C>>.\nProof. by move=> C1; rewrite morphpre_gen ?sub_im_coset. Qed.",
    "Lemma quotientR A B :\n  A \\subset 'N(H) -> B \\subset 'N(H) -> [~: A, B] / H = [~: A / H, B / H].\nProof. exact: morphimR. Qed.",
    "Lemma quotient_norm A : 'N(A) / H \\subset 'N(A / H).\nProof. exact: morphim_norm. Qed.",
    "Lemma quotient_norms A B : A \\subset 'N(B) -> A / H \\subset 'N(B / H).\nProof. exact: morphim_norms. Qed.",
    "Lemma quotient_subnorm A B : 'N_A(B) / H \\subset 'N_(A / H)(B / H).\nProof. exact: morphim_subnorm. Qed.",
    "Lemma quotient_normal A B : A <| B -> A / H <| B / H.\nProof. exact: morphim_normal. Qed.",
    "Lemma quotient_cent1 x : 'C[x] / H \\subset 'C[coset H x].\nProof.\ncase Nx: (x \\in 'N(H)); first exact: morphim_cent1.\nby rewrite coset_default // cent11T subsetT.\nQed.",
    "Lemma quotient_cent1s A x : A \\subset 'C[x] -> A / H \\subset 'C[coset H x].\nProof.\nby move=> sAC; apply: subset_trans (quotientS sAC) (quotient_cent1 x).\nQed.",
    "Lemma quotient_subcent1 A x : 'C_A[x] / H \\subset 'C_(A / H)[coset H x].\nProof. exact: subset_trans (quotientI _ _) (setIS _ (quotient_cent1 x)). Qed.",
    "Lemma quotient_cent A : 'C(A) / H \\subset 'C(A / H).\nProof. exact: morphim_cent. Qed.",
    "Lemma quotient_cents A B : A \\subset 'C(B) -> A / H \\subset 'C(B / H).\nProof. exact: morphim_cents. Qed.",
    "Lemma quotient_abelian A : abelian A -> abelian (A / H).\nProof. exact: morphim_abelian. Qed.",
    "Lemma quotient_subcent A B : 'C_A(B) / H \\subset 'C_(A / H)(B / H).\nProof. exact: morphim_subcent. Qed.",
    "Lemma norm_quotient_pre A C :\n  A \\subset 'N(H) -> A / H \\subset 'N(C) -> A \\subset 'N(coset H @*^-1 C).\nProof.\nby move/sub_quotient_pre=> -> /subset_trans-> //; apply: morphpre_norm.\nQed.",
    "Lemma cosetpre_normal C D : (coset H @*^-1 C <| coset H @*^-1 D) = (C <| D).\nProof. by rewrite morphpre_normal ?sub_im_coset. Qed.",
    "Lemma quotient_normG G : H <| G -> 'N(G) / H = 'N(G / H).\nProof.\ncase/andP=> sHG nHG.\nby rewrite [_ / _]morphim_normG ?ker_coset // im_coset setTI.\nQed.",
    "Lemma quotient_subnormG A G : H <| G -> 'N_A(G) / H = 'N_(A / H)(G / H).\nProof. by case/andP=> sHG nHG; rewrite -morphim_subnormG ?ker_coset. Qed.",
    "Lemma cosetpre_cent1 x : 'C_('N(H))[x] \\subset coset H @*^-1 'C[coset H x].\nProof.\ncase Nx: (x \\in 'N(H)); first by rewrite morphpre_cent1.\nby rewrite coset_default // cent11T morphpreT subsetIl.\nQed.",
    "Lemma cosetpre_cent1s C x :\n  coset H @*^-1 C \\subset 'C[x] -> C \\subset 'C[coset H x].\nProof.\nmove=> sC; rewrite -cosetpreSK; apply: subset_trans (cosetpre_cent1 x).\nby rewrite subsetI subsetIl.\nQed.",
    "Lemma cosetpre_subcent1 C x :\n  'C_(coset H @*^-1 C)[x] \\subset coset H @*^-1 'C_C[coset H x].\nProof.\nby rewrite -morphpreIdom -setIA setICA morphpreI setIS // cosetpre_cent1.\nQed.",
    "Lemma cosetpre_cent A : 'C_('N(H))(A) \\subset coset H @*^-1 'C(A / H).\nProof. exact: morphpre_cent. Qed.",
    "Lemma cosetpre_cents A C : coset H @*^-1 C \\subset 'C(A) -> C \\subset 'C(A / H).\nProof. by apply: morphpre_cents; rewrite ?sub_im_coset. Qed.",
    "Lemma cosetpre_subcent C A :\n  'C_(coset H @*^-1 C)(A) \\subset coset H @*^-1 'C_C(A / H).\nProof. exact: morphpre_subcent. Qed.",
    "Lemma restrm_quotientE G A (nHG : G \\subset 'N(H)) :\n  A \\subset G -> restrm nHG (coset H) @* A = A / H.\nProof. exact: restrmEsub. Qed.",
    "Lemma inv_quotientS :\n  Kbar \\subset G / H -> inv_quotient_spec (fun K => K \\subset G).\nProof.\ncase/andP: nHG => sHG nHG' sKbarG.\nhave sKdH: Kbar \\subset 'N(H) / H by rewrite (subset_trans sKbarG) ?morphimS.\nexists (coset H @*^-1 Kbar)%G; first by rewrite cosetpreK.\n  by rewrite -{1}ker_coset morphpreS ?sub1G.\nby rewrite sub_cosetpre_quo.\nQed.",
    "Lemma inv_quotientN : Kbar <| G / H -> inv_quotient_spec (fun K => K <| G).\nProof.\nmove=> nKbar; case/inv_quotientS: (normal_sub nKbar) => K defKbar sHK sKG.\nexists K => //; rewrite defKbar -cosetpre_normal !quotientGK // in nKbar.\nexact: normalS nHG.\nQed.",
    "Lemma quotientMidr A : A * H / H = A / H.\nProof.\nby rewrite [_ /_]morphimMr ?normG //= -!quotientE trivg_quotient mulg1.\nQed.",
    "Lemma quotientMidl A : H * A / H = A / H.\nProof.\nby rewrite [_ /_]morphimMl ?normG //= -!quotientE trivg_quotient mul1g.\nQed.",
    "Lemma quotientYidr G : G \\subset 'N(H) -> G <*> H / H = G / H.\nProof.\nmove=> nHG; rewrite -genM_join quotient_gen ?mul_subG ?normG //.\nby rewrite quotientMidr genGid.\nQed.",
    "Lemma quotientYidl G : G \\subset 'N(H) -> H <*> G / H = G / H.\nProof. by move=> nHG; rewrite joingC quotientYidr. Qed.",
    "Lemma quotient_isom : isom G (G / H) (restrm nHG (coset H)).\nProof. by apply/isomP; rewrite ker_restrm setIC ker_coset tiHG im_restrm. Qed.",
    "Lemma quotient_isog : isog G (G / H).\nProof. exact: isom_isog quotient_isom. Qed.",
    "Lemma coset1_injm : 'injm (@coset gT 1).\nProof. by rewrite ker_coset /=. Qed.",
    "Lemma quotient1_isom : isom A (A / 1) (coset 1).\nProof. by apply: sub_isom coset1_injm; rewrite ?norms1. Qed.",
    "Lemma quotient1_isog : isog A (A / 1).\nProof. by apply: isom_isog quotient1_isom; apply: norms1. Qed.",
    "Lemma quotm_dom_proof : G \\subset 'dom fH.\nProof. by rewrite -sub_morphim_pre. Qed.",
    "Lemma quotm_ker_proof : 'ker (coset H) \\subset 'ker fH_G.\nProof.\nby rewrite ker_restrm ker_comp !ker_coset morphpreIdom morphimK ?mulG_subr.\nQed.",
    "Lemma quotmE x : x \\in G -> quotm (coset H x) = coset (f @* H) (f x).\nProof. exact: factmE. Qed.",
    "Lemma morphim_quotm A : quotm @* (A / H) = f @* A / f @* H.\nProof. by rewrite morphim_factm morphim_restrm morphim_comp morphimIdom. Qed.",
    "Lemma morphpre_quotm Abar : quotm @*^-1 (Abar / f @* H) = f @*^-1 Abar / H.\nProof.\nrewrite morphpre_factm morphpre_restrm morphpre_comp /=.\nrewrite morphpreIdom -[Abar / _]quotientInorm quotientK ?subsetIr //=.\nrewrite morphpreMl ?morphimS // morphimK // [_ * H]normC ?subIset ?nHG //.\nrewrite -quotientE -mulgA quotientMidl /= setIC -morphpreIim setIA.\nby rewrite (setIidPl nfHfG) morphpreIim -morphpreMl ?sub1G ?mul1g.\nQed.",
    "Lemma ker_quotm : 'ker quotm = 'ker f / H.\nProof. by rewrite -morphpre_quotm /quotient morphim1. Qed.",
    "Lemma injm_quotm : 'injm f -> 'injm quotm.\nProof. by move/trivgP=> /= kf1; rewrite ker_quotm kf1 quotientE morphim1. Qed.",
    "Lemma im_qisom_proof : 'N(H) \\subset 'N(G). Proof. by rewrite eqGH. Qed.",
    "Lemma qisom_ker_proof : 'ker (coset G) \\subset 'ker (coset H).\nProof. by rewrite eqGH. Qed.",
    "Lemma qisom_restr_proof : setT \\subset 'N(H) / G.\nProof. by rewrite eqGH im_quotient. Qed.",
    "Lemma qisomE x : qisom (coset G x) = coset H x.\nProof.\ncase Nx: (x \\in 'N(H)); first exact: factmE.\nby rewrite !coset_default ?eqGH ?morph1.\nQed.",
    "Lemma val_qisom Gx : val (qisom Gx) = val Gx.\nProof.\nby case: (cosetP Gx) => x Nx ->{Gx}; rewrite qisomE /= !val_coset -?eqGH.\nQed.",
    "Lemma morphim_qisom A : qisom @* (A / G) = A / H.\nProof. by rewrite morphim_restrm setTI morphim_factm. Qed.",
    "Lemma morphpre_qisom A : qisom @*^-1 (A / H) = A / G.\nProof.\nrewrite morphpre_restrm setTI morphpre_factm eqGH.\nby rewrite morphpreK // im_coset subsetT.\nQed.",
    "Lemma injm_qisom : 'injm qisom.\nProof. by rewrite -quotient1 -morphpre_qisom morphpreS ?sub1G. Qed.",
    "Lemma im_qisom : qisom @* setT = setT.\nProof. by rewrite -{2}im_quotient morphim_qisom eqGH im_quotient. Qed.",
    "Lemma qisom_isom : isom setT setT qisom.\nProof. by apply/isomP; rewrite injm_qisom im_qisom. Qed.",
    "Lemma qisom_isog : [set: coset_of G] \\isog [set: coset_of H].\nProof. exact: isom_isog qisom_isom. Qed.",
    "Lemma qisom_inj : injective qisom.\nProof. by move=> x y; apply: (injmP injm_qisom); rewrite inE. Qed.",
    "Lemma morphim_qisom_inj : injective (fun Gx => qisom @* Gx).\nProof.\nby move=> Gx Gy; apply: injm_morphim_inj; rewrite (injm_qisom, subsetT).\nQed.",
    "Lemma first_isom (G : {group aT}) (f : {morphism G >-> rT}) :\n  {g : {morphism G / 'ker f >-> rT} | 'injm g &\n      forall A : {set aT}, g @* (A / 'ker f) = f @* A}.\nProof.\nhave nkG := ker_norm f.\nhave skk: 'ker (coset ('ker f)) \\subset 'ker f by rewrite ker_coset.\nexists (factm_morphism skk nkG) => /=; last exact: morphim_factm.\nby rewrite ker_factm -quotientE trivg_quotient.\nQed.",
    "Lemma first_isog : (G / 'ker f) \\isog (f @* G).\nProof.\nby case: (first_isom f) => g injg im_g; apply/isogP; exists g; rewrite ?im_g.\nQed.",
    "Lemma first_isom_loc : {g : {morphism H / 'ker_H f >-> rT} |\n 'injm g & forall A : {set aT}, A \\subset H -> g @* (A / 'ker_H f) = f @* A}.\nProof.\ncase: (first_isom (restrm_morphism sHG f)).\nrewrite ker_restrm => g injg im_g; exists g => // A sAH.\nby rewrite im_g morphim_restrm (setIidPr sAH).\nQed.",
    "Lemma first_isog_loc : (H / 'ker_H f) \\isog (f @* H).\nProof.\nby case: first_isom_loc => g injg im_g; apply/isogP; exists g; rewrite ?im_g.\nQed.",
    "Lemma second_isom : {f : {morphism H / (K :&: H) >-> coset_of K} |\n  'injm f & forall A : {set gT}, A \\subset H -> f @* (A / (K :&: H)) = A / K}.\nProof.\nhave ->: K :&: H = 'ker_H (coset K) by rewrite ker_coset setIC.\nexact: first_isom_loc.\nQed.",
    "Lemma second_isog : H / (K :&: H) \\isog H / K.\nProof. by rewrite setIC -{1 3}(ker_coset K); apply: first_isog_loc. Qed.",
    "Lemma weak_second_isog : H / (K :&: H) \\isog H * K / K.\nProof. by rewrite quotientMidr; apply: second_isog. Qed.",
    "Lemma homg_quotientS (A : {set gT}) :\n  A \\subset 'N(H) -> A \\subset 'N(K) -> H \\subset K -> A / K \\homg A / H.\nProof.\nrewrite -!(gen_subG A) /=; set L := <<A>> => nHL nKL sKH.\nhave sub_ker: 'ker (restrm nHL (coset H)) \\subset 'ker (restrm nKL (coset K)).\n  by rewrite !ker_restrm !ker_coset setIS.\nhave sAL: A \\subset L := subset_gen A; rewrite -(setIidPr sAL).\nrewrite -[_ / H](morphim_restrm nHL) -[_ / K](morphim_restrm nKL) /=.\nby rewrite -(morphim_factm sub_ker (subxx L)) morphim_homg ?morphimS.\nQed.",
    "Lemma char_from_quotient (gT : finGroupType) (G H K : {group gT}) :\n  H <| K -> H \\char G -> K / H \\char G / H -> K \\char G.\nProof.\ncase/andP=> sHK nHK chHG.\nhave nsHG := char_normal chHG; have [sHG nHG] := andP nsHG.\ncase/charP; rewrite quotientSGK // => sKG /= chKG.\napply/charP; split=> // f injf Gf; apply/morphim_fixP => //.\nrewrite -(quotientSGK _ sHK); last by rewrite -morphimIim Gf subIset ?nHG.\nhave{chHG} Hf: f @* H = H by case/charP: chHG => _; apply.\nset q := quotm_morphism f nsHG; have{injf}: 'injm q by apply: injm_quotm.\nhave: q @* _ = _ := morphim_quotm _ _ _; move: q; rewrite Hf => q im_q injq.\nby rewrite -im_q chKG // im_q Gf.\nQed.",
    "Lemma card_morphim G : #|f @* G| = #|D :&: G : 'ker f|.\nProof.\nrewrite -morphimIdom -indexgI -card_quotient; last first.\n  by rewrite normsI ?normG ?subIset ?ker_norm.\nby apply: esym (card_isog _); rewrite first_isog_loc ?subsetIl.\nQed.",
    "Lemma dvdn_morphim G : #|f @* G| %| #|G|.\nProof.\nrewrite card_morphim (dvdn_trans (dvdn_indexg _ _)) //.\nby rewrite cardSg ?subsetIr.\nQed.",
    "Lemma logn_morphim p G : logn p #|f @* G| <= logn p #|G|.\nProof. by rewrite dvdn_leq_log ?dvdn_morphim. Qed.",
    "Lemma coprime_morphl G p : coprime #|G| p -> coprime #|f @* G| p.\nProof. exact: coprime_dvdl (dvdn_morphim G). Qed.",
    "Lemma coprime_morphr G p : coprime p #|G| -> coprime p #|f @* G|.\nProof. exact: coprime_dvdr (dvdn_morphim G). Qed.",
    "Lemma coprime_morph G H : coprime #|G| #|H| -> coprime #|f @* G| #|f @* H|.\nProof. by move=> coGH; rewrite coprime_morphl // coprime_morphr. Qed.",
    "Lemma index_morphim_ker G H :\n    H \\subset G -> G \\subset D ->\n  (#|f @* G : f @* H| * #|'ker_G f : H|)%N = #|G : H|.\nProof.\nmove=> sHG sGD; apply/eqP.\nrewrite -(eqn_pmul2l (cardG_gt0 (f @* H))) mulnA Lagrange ?morphimS //.\nrewrite !card_morphim (setIidPr sGD) (setIidPr (subset_trans sHG sGD)).\nrewrite -(eqn_pmul2l (cardG_gt0 ('ker_H f))) /=.\nby rewrite -{1}(setIidPr sHG) setIAC mulnCA mulnC mulnA !LagrangeI Lagrange.\nQed.",
    "Lemma index_morphim G H : G :&: H \\subset D -> #|f @* G : f @* H| %| #|G : H|.\nProof.\nmove=> dGH; rewrite -(indexgI G) -(setIidPr dGH) setIA.\napply: dvdn_trans (indexSg (subsetIl _ H) (subsetIr D G)).\nrewrite -index_morphim_ker ?subsetIl ?subsetIr ?dvdn_mulr //= morphimIdom.\nby rewrite indexgS ?morphimS ?subsetIr.\nQed.",
    "Lemma index_injm G H : 'injm f -> G \\subset D -> #|f @* G : f @* H| = #|G : H|.\nProof.\nmove=> injf dG; rewrite -{2}(setIidPr dG) -(indexgI _ H) /=.\nrewrite -index_morphim_ker ?subsetIl ?subsetIr //= setIAC morphimIdom setIC.\nrewrite injmI ?subsetIr // indexgI /= morphimIdom setIC ker_injm //.\nby rewrite -(indexgI (1 :&: _)) /= -setIA !(setIidPl (sub1G _)) indexgg muln1.\nQed.",
    "Lemma card_morphpre L : L \\subset f @* D -> #|f @*^-1 L| = (#|'ker f| * #|L|)%N.\nProof.\nmove/morphpreK=> {2} <-; rewrite card_morphim morphpreIdom.\nby rewrite Lagrange // morphpreS ?sub1G.\nQed.",
    "Lemma index_morphpre L M :\n  L \\subset f @* D -> #|f @*^-1 L : f @*^-1 M| = #|L : M|.\nProof.\nmove=> dL; rewrite -!divgI -morphpreI card_morphpre //.\nhave: L :&: M \\subset f @* D by rewrite subIset ?dL.\nby move/card_morphpre->; rewrite divnMl ?cardG_gt0.\nQed.",
    "Lemma card_homg (aT rT : finGroupType) (G : {group aT}) (R : {group rT}) :\n  G \\homg R -> #|G| %| #|R|.\nProof. by case/homgP=> f <-; rewrite card_morphim setIid dvdn_indexg. Qed.",
    "Lemma dvdn_quotient : #|G / H| %| #|G|.\nProof. exact: dvdn_morphim. Qed.",
    "Lemma index_quotient_ker :\n     K \\subset G -> G \\subset 'N(H) ->\n  (#|G / H : K / H| * #|G :&: H : K|)%N = #|G : K|.\nProof. by rewrite -{5}(ker_coset H); apply: index_morphim_ker. Qed.",
    "Lemma index_quotient : G :&: K \\subset 'N(H) -> #|G / H : K / H| %| #|G : K|.\nProof. exact: index_morphim. Qed.",
    "Lemma index_quotient_eq :\n    G :&: H \\subset K -> K \\subset G -> G \\subset 'N(H) ->\n  #|G / H : K / H| = #|G : K|.\nProof.\nmove=> sGH_K sKG sGN; rewrite -index_quotient_ker {sKG sGN}//.\nby rewrite -(indexgI _ K) (setIidPl sGH_K) indexgg muln1.\nQed.",
    "Lemma card_cosetpre : #|coset H @*^-1 L| = (#|H| * #|L|)%N.\nProof. by rewrite card_morphpre ?ker_coset ?sub_im_coset. Qed.",
    "Lemma index_cosetpre : #|coset H @*^-1 L : coset H @*^-1 M| = #|L : M|.\nProof. by rewrite index_morphpre ?sub_im_coset. Qed.",
    "Lemma Aut_morphic A a : a \\in Aut A -> morphic A a.\nProof. by case/setIdP. Qed.",
    "Lemma out_Aut A a x : a \\in Aut A -> x \\notin A -> a x = x.\nProof. by case/setIdP=> Aa _; apply: out_perm. Qed.",
    "Lemma eq_Aut A : {in Aut A &, forall a b, {in A, a =1 b} -> a = b}.\nProof.\nmove=> a g Aa Ag /= eqag; apply/permP=> x.\nby have [/eqag // | /out_Aut out] := boolP (x \\in A); rewrite !out.\nQed.",
    "Lemma autmE A a (AutAa : a \\in Aut A) : autm AutAa = a.\nProof. by []. Qed.",
    "Lemma Aut_group_set : group_set (Aut G).\nProof.\napply/group_setP; split=> [|a b].\n  by rewrite inE perm_on1; apply/morphicP=> ? *; rewrite !permE.\nrewrite !inE => /andP[Ga aM] /andP[Gb bM]; rewrite perm_onM //=.\napply/morphicP=> x y Gx Gy; rewrite !permM (morphicP aM) //.\nby rewrite (morphicP bM) ?perm_closed.\nQed.",
    "Lemma injm_autm : 'injm f.\nProof. by apply/injmP; apply: in2W; apply: perm_inj. Qed.",
    "Lemma ker_autm : 'ker f = 1. Proof. by move/trivgP: injm_autm. Qed.",
    "Lemma im_autm : f @* G = G.\nProof.\napply/setP=> x; rewrite morphimEdom (can_imset_pre _ (permK a)) inE.\nby have /[1!inE] /andP[/perm_closed <-] := AutGa; rewrite permKV.\nQed.",
    "Lemma Aut_closed x : x \\in G -> a x \\in G.\nProof. by move=> Gx; rewrite -im_autm; apply: mem_morphim. Qed.",
    "Lemma Aut1 : Aut 1 = 1.\nProof.\napply/trivgP/subsetP=> a /= AutGa; apply/set1P.\napply: eq_Aut (AutGa) (group1 _) _ => _ /set1P->.\nby rewrite -(autmE AutGa) morph1 perm1.\nQed.",
    "Lemma perm_in_inj : injective (fun x => if x \\in A then f x else x).\nProof.\nmove=> x y /=; wlog Ay: x y / y \\in A.\n  by move=> IH eqfxy; case: ifP (eqfxy); [symmetry | case: ifP => //]; auto.\nrewrite Ay; case: ifP => [Ax | nAx def_x]; first exact: injf.\nby case/negP: nAx; rewrite def_x (subsetP sBf) ?imset_f.\nQed.",
    "Lemma perm_in_on : perm_on A perm_in.\nProof.\nby apply/subsetP=> x; rewrite inE /= permE; case: ifP => // _; case/eqP.\nQed.",
    "Lemma perm_inE : {in A, perm_in =1 f}.\nProof. by move=> x Ax; rewrite /= permE Ax. Qed.",
    "Lemma morphim_fixP A : A \\subset G -> reflect (f @* A = A) (f @* A \\subset A).\nProof.\nrewrite /morphim => sAG; have:= eqEcard (f @: A) A.\nrewrite (setIidPr sAG) card_in_imset ?leqnn ?andbT  => [<-|]; first exact: eqP.\nby move/injmP: injf; apply: sub_in2; apply/subsetP.\nQed.",
    "Lemma aut_closed : f @: G \\subset G.\nProof. by rewrite -morphimEdom; apply/morphim_fixP. Qed.",
    "Lemma autE : {in G, aut =1 f}.\nProof. exact: perm_inE. Qed.",
    "Lemma morphic_aut : morphic G aut.\nProof. by apply/morphicP=> x y Gx Gy /=; rewrite !autE ?groupM // morphM. Qed.",
    "Lemma Aut_aut : aut \\in Aut G.\nProof. by rewrite inE morphic_aut perm_in_on. Qed.",
    "Lemma imset_autE A : A \\subset G -> aut @: A = f @* A.\nProof.\nmove=> sAG; rewrite /morphim (setIidPr sAG).\nby apply: eq_in_imset; apply: sub_in1 autE; apply/subsetP.\nQed.",
    "Lemma preim_autE A : A \\subset G -> aut @^-1: A = f @*^-1 A.\nProof.\nmove=> sAG; apply/setP=> x; rewrite !inE permE /=.\nby case Gx: (x \\in G) => //; apply/negP=> Ax; rewrite (subsetP sAG) in Gx.\nQed.",
    "Lemma Aut_isom_subproof a :\n  {a' | a' \\in Aut (f @* G) & a \\in Aut G -> {in G, a' \\o f =1 f \\o a}}.\nProof.\nset Aut_a := autm (subgP (subg [Aut G] a)).\nhave aDom: 'dom (f \\o Aut_a \\o invm injf) = f @* G.\n  rewrite /dom /= morphpre_invm -morphpreIim; congr (f @* _).\n  by rewrite [_ :&: D](setIidPl _) ?injmK ?injm_autm ?im_autm.\nhave [af [def_af ker_af _ im_af]] := domP _ aDom.\nhave inj_a': 'injm af by rewrite ker_af !injm_comp ?injm_autm ?injm_invm.\nhave im_a': af @* (f @* G) = f @* G.\n  by rewrite im_af !morphim_comp morphim_invm // im_autm.\npose a' := aut inj_a' im_a'; exists a' => [|AutGa x Gx]; first exact: Aut_aut.\nhave Dx := domG Gx; rewrite /= [a' _]autE ?mem_morphim //.\nby rewrite def_af /= invmE // autmE subgK.\nQed.",
    "Lemma Aut_Aut_isom a : Aut_isom a \\in Aut (f @* G).\nProof. by rewrite /Aut_isom; case: (Aut_isom_subproof a). Qed.",
    "Lemma Aut_isomE a : a \\in Aut G -> {in G, forall x, Aut_isom a (f x) = f (a x)}.\nProof. by rewrite /Aut_isom; case: (Aut_isom_subproof a). Qed.",
    "Lemma Aut_isomM : {in Aut G &, {morph Aut_isom: x y / x * y}}.\nProof.\nmove=> a b AutGa AutGb.\napply: (eq_Aut (Aut_Aut_isom _)); rewrite ?groupM ?Aut_Aut_isom // => fx.\ncase/morphimP=> x Dx Gx ->{fx}.\nby rewrite permM !Aut_isomE ?groupM /= ?permM ?Aut_closed.\nQed.",
    "Lemma injm_Aut_isom : 'injm Aut_isom.\nProof.\napply/injmP=> a b AutGa AutGb eq_ab'; apply: (eq_Aut AutGa AutGb) => x Gx.\nby apply: (injmP injf); rewrite ?domG ?Aut_closed // -!Aut_isomE //= eq_ab'.\nQed.",
    "Lemma im_Aut_isom : Aut_isom injf sGD @* Aut G = Aut (f @* G).\nProof.\napply/eqP; rewrite eqEcard; apply/andP; split.\n  by apply/subsetP=> _ /morphimP[a _ AutGa ->]; apply: Aut_Aut_isom.\nhave inj_isom' := injm_Aut_isom (injm_invm injf) (morphimS _ sGD).\nrewrite card_injm ?injm_Aut_isom // -(card_injm inj_isom') ?subset_leq_card //.\napply/subsetP=> a /morphimP[a' _ AutfGa' def_a].\nby rewrite -(morphim_invm injf sGD) def_a Aut_Aut_isom.\nQed.",
    "Lemma Aut_isomP : isom (Aut G) (Aut (f @* G)) (Aut_isom injf sGD).\nProof. by apply/isomP; split; [apply: injm_Aut_isom | apply: im_Aut_isom]. Qed.",
    "Lemma injm_Aut : Aut (f @* G) \\isog Aut G.\nProof. by rewrite isog_sym (isom_isog _ _ Aut_isomP). Qed.",
    "Lemma conjgmE A x y : conjgm A x y = y ^ x. Proof. by []. Qed.",
    "Lemma morphim_conj A x B : conjgm A x @* B = (A :&: B) :^ x.\nProof. by []. Qed.",
    "Lemma injm_conj x : 'injm (conjgm G x).\nProof. by apply/injmP; apply: in2W; apply: conjg_inj. Qed.",
    "Lemma conj_isom x : isom G (G :^ x) (conjgm G x).\nProof. by apply/isomP; rewrite morphim_conj setIid injm_conj. Qed.",
    "Lemma conj_isog x : G \\isog G :^ x.\nProof. exact: isom_isog (conj_isom x). Qed.",
    "Lemma norm_conjg_im x : x \\in 'N(G) -> conjgm G x @* G = G.\nProof. by rewrite morphimEdom; apply: normP. Qed.",
    "Lemma norm_conj_isom x : x \\in 'N(G) -> isom G G (conjgm G x).\nProof. by move/norm_conjg_im/restr_isom_to/(_ (conj_isom x))->. Qed.",
    "Lemma norm_conj_autE : {in 'N(G) & G, forall x y, conj_aut x y = y ^ x}.\nProof. by move=> x y nGx Gy; rewrite /= autE //= subgK. Qed.",
    "Lemma conj_autE : {in G &, forall x y, conj_aut x y = y ^ x}.\nProof. by apply: sub_in11 norm_conj_autE => //; apply: subsetP (normG G). Qed.",
    "Lemma conj_aut_morphM : {in 'N(G) &, {morph conj_aut : x y / x * y}}.\nProof.\nmove=> x y nGx nGy; apply/permP=> z /=; rewrite permM.\ncase Gz: (z \\in G); last by rewrite !permE /= !Gz.\nby rewrite !norm_conj_autE // (conjgM, memJ_norm, groupM).\nQed.",
    "Lemma ker_conj_aut : 'ker conj_aut = 'C(G).\nProof.\napply/setP=> x /[1!inE]; case nGx: (x \\in 'N(G)); last first.\n  by symmetry; apply/idP=> cGx; rewrite (subsetP (cent_sub G)) in nGx.\nrewrite 2!inE /=; apply/eqP/centP=> [cx1 y Gy | cGx].\n  by rewrite /commute (conjgC y) -norm_conj_autE // cx1 perm1.\napply/permP=> y; case Gy: (y \\in G); last by rewrite !permE Gy.\nby rewrite perm1 norm_conj_autE // conjgE -cGx ?mulKg.\nQed.",
    "Lemma Aut_conj_aut A : conj_aut @* A \\subset Aut G.\nProof. by apply/subsetP=> _ /imsetP[x _ ->]; apply: Aut_aut. Qed.",
    "Lemma charP H G :\n  let fixH (f : {morphism G >-> gT}) := 'injm f -> f @* G = G -> f @* H = H in\n  reflect [/\\ H \\subset G & forall f, fixH f] (H \\char G).\nProof.\ndo [apply: (iffP andP) => -[sHG chHG]; split] => // [f injf Gf|].\n  by apply/morphim_fixP; rewrite // -imset_autE ?(forall_inP chHG) ?Aut_aut.\napply/forall_inP=> f Af; rewrite -(autmE Af) -morphimEsub //.\nby rewrite chHG ?injm_autm ?im_autm.\nQed.",
    "Lemma char1 G : 1 \\char G.\nProof. by apply/charP; split=> [|f _ _]; rewrite (sub1G, morphim1). Qed.",
    "Lemma char_refl G : G \\char G.\nProof. exact/charP. Qed.",
    "Lemma char_trans H G K : K \\char H -> H \\char G -> K \\char G.\nProof.\ncase/charP=> sKH chKH; case/charP=> sHG chHG.\napply/charP; split=> [|f injf Gf]; first exact: subset_trans sHG.\nrewrite -{1}(setIidPr sKH) -(morphim_restrm sHG) chKH //.\n  by rewrite ker_restrm; move/trivgP: injf => ->; apply: subsetIr.\nby rewrite morphim_restrm setIid chHG.\nQed.",
    "Lemma char_norms H G : H \\char G -> 'N(G) \\subset 'N(H).\nProof.\ncase/charP=> sHG chHG; apply/normsP=> x /normP-Nx.\nhave:= chHG [morphism of conjgm G x] => /=.\nby rewrite !morphimEsub //=; apply; rewrite // injm_conj.\nQed.",
    "Lemma char_sub A B : A \\char B -> A \\subset B.\nProof. by case/andP. Qed.",
    "Lemma char_norm_trans H G A : H \\char G -> A \\subset 'N(G) -> A \\subset 'N(H).\nProof. by move/char_norms=> nHnG nGA; apply: subset_trans nHnG. Qed.",
    "Lemma char_normal_trans H G K : K \\char H -> H <| G -> K <| G.\nProof.\nmove=> chKH /andP[sHG nHG].\nby rewrite /normal (subset_trans (char_sub chKH)) // (char_norm_trans chKH).\nQed.",
    "Lemma char_normal H G : H \\char G -> H <| G.\nProof. by move/char_normal_trans; apply; apply/andP; rewrite normG. Qed.",
    "Lemma char_norm H G : H \\char G -> G \\subset 'N(H).\nProof. by case/char_normal/andP. Qed.",
    "Lemma charI G H K : H \\char G -> K \\char G -> H :&: K \\char G.\nProof.\ncase/charP=> sHG chHG; case/charP=> _ chKG.\napply/charP; split=> [|f injf Gf]; first by rewrite subIset // sHG.\nby rewrite morphimGI ?(chHG, chKG) //; apply: subset_trans (sub1G H).\nQed.",
    "Lemma charY G H K : H \\char G -> K \\char G -> H <*> K \\char G.\nProof.\ncase/charP=> sHG chHG; case/charP=> sKG chKG.\napply/charP; split=> [|f injf Gf]; first by rewrite gen_subG subUset sHG.\nby rewrite morphim_gen ?(morphimU, subUset, sHG, chHG, chKG).\nQed.",
    "Lemma charM G H K : H \\char G -> K \\char G -> H * K \\char G.\nProof.\nmove=> chHG chKG; rewrite -norm_joinEl ?charY //.\nexact: subset_trans (char_sub chHG) (char_norm chKG).\nQed.",
    "Lemma lone_subgroup_char G H :\n  H \\subset G -> (forall K, K \\subset G -> K \\isog H -> K \\subset H) ->\n  H \\char G.\nProof.\nmove=> sHG Huniq; apply/charP; split=> // f injf Gf; apply/eqP.\nhave{} injf: {in H &, injective f}.\n  by move/injmP: injf; apply: sub_in2; apply/subsetP.\nhave fH: f @* H = f @: H by rewrite /morphim (setIidPr sHG).\nrewrite eqEcard {2}fH card_in_imset ?{}Huniq //=.\n  by rewrite -{3}Gf morphimS.\nrewrite isog_sym; apply/isogP.\nexists [morphism of restrm sHG f] => //=; first exact/injmP.\nby rewrite morphimEdom fH.\nQed.",
    "Lemma injm_char (G H : {group aT}) :\n  G \\subset D -> H \\char G -> f @* H \\char f @* G.\nProof.\nmove=> sGD /charP[sHG charH].\napply/charP; split=> [|g injg gfG]; first exact: morphimS.\nhave /domP[h [_ ker_h _ im_h]]: 'dom (invm injf \\o g \\o f) = G.\n  by rewrite /dom /= -(morphpreIim g) (setIidPl _) ?injmK // gfG morphimS.\nhave hH: h @* H = H.\n  apply: charH; first by rewrite ker_h !injm_comp ?injm_invm.\n  by rewrite im_h !morphim_comp gfG morphim_invm.\nrewrite /= -{2}hH im_h !morphim_comp morphim_invmE morphpreK //.\nby rewrite (subset_trans _ (morphimS f sGD)) //= -{3}gfG !morphimS.\nQed.",
    "Lemma char_injm (G H : {group aT}) :\n  G \\subset D -> H \\subset D -> (f @* H \\char f @* G) = (H \\char G).\nProof.\nmove=> sGD sHD; apply/idP/idP; last exact: injm_char.\nby move/(injm_char (injm_invm injf)); rewrite !morphim_invm ?morphimS // => ->.\nQed.",
    "Lemma perm_proof (f : T -> T) : injective f -> injectiveb (finfun f).\nProof.\nby move=> f_inj; apply/injectiveP; apply: eq_inj f_inj _ => x; rewrite ffunE.\nQed.",
    "Lemma permP s t : s =1 t <-> s = t.\nProof. by split=> [| -> //]; rewrite unlock => eq_sv; apply/val_inj/ffunP. Qed.",
    "Lemma pvalE s : pval s = s :> (T -> T).\nProof. by rewrite [@fun_of_perm]unlock. Qed.",
    "Lemma permE f f_inj : @perm T f f_inj =1 f.\nProof. by move=> x; rewrite -pvalE [@perm]unlock ffunE. Qed.",
    "Lemma perm_inj {s} : injective s.\nProof. by rewrite -!pvalE; apply: (injectiveP _ (valP s)). Qed.",
    "Lemma perm_onto s : codom s =i predT.\nProof. by apply/subset_cardP; rewrite ?card_codom ?subset_predT. Qed.",
    "Lemma perm_invK s : cancel (fun x => iinv (perm_onto s x)) s.\nProof. by move=> x /=; rewrite f_iinv. Qed.",
    "Lemma perm_oneP : left_id perm_one perm_mul.\nProof. by move=> s; apply/permP => x; rewrite permE /= permE. Qed.",
    "Lemma perm_invP : left_inverse perm_one perm_inv perm_mul.\nProof. by move=> s; apply/permP=> x; rewrite !permE /= permE f_iinv. Qed.",
    "Lemma perm_mulP : associative perm_mul.\nProof. by move=> s t u; apply/permP=> x; do !rewrite permE /=. Qed.",
    "Lemma perm1 x : (1 : {perm T}) x = x.\nProof. by rewrite permE. Qed.",
    "Lemma permM s t x : (s * t) x = t (s x).\nProof. by rewrite permE. Qed.",
    "Lemma permK s : cancel s s^-1.\nProof. by move=> x; rewrite -permM mulgV perm1. Qed.",
    "Lemma permKV s : cancel s^-1 s.\nProof. by have:= permK s^-1; rewrite invgK. Qed.",
    "Lemma permJ s t x : (s ^ t) (t x) = t (s x).\nProof. by rewrite !permM permK. Qed.",
    "Lemma permX s x n : (s ^+ n) x = iter n s x.\nProof. by elim: n => [|n /= <-]; rewrite ?perm1 // -permM expgSr. Qed.",
    "Lemma permX_fix s x n : s x = x -> (s ^+ n) x = x.\nProof.\nmove=> Hs; elim: n => [|n IHn]; first by rewrite expg0 perm1.\nby rewrite expgS permM Hs.\nQed.",
    "Lemma im_permV s S : s^-1 @: S = s @^-1: S.\nProof. exact: can2_imset_pre (permKV s) (permK s). Qed.",
    "Lemma preim_permV s S : s^-1 @^-1: S = s @: S.\nProof. by rewrite -im_permV invgK. Qed.",
    "Lemma perm_closed S s x : perm_on S s -> (s x \\in S) = (x \\in S).\nProof.\nmove/subsetP=> s_on_S; have [-> // | nfix_s_x] := eqVneq (s x) x.\nby rewrite !s_on_S // inE /= ?(inj_eq perm_inj).\nQed.",
    "Lemma perm_on1 H : perm_on H 1.\nProof. by apply/subsetP=> x; rewrite inE /= perm1 eqxx. Qed.",
    "Lemma perm_onM H s t : perm_on H s -> perm_on H t -> perm_on H (s * t).\nProof.\nmove/subsetP=> sH /subsetP tH; apply/subsetP => x; rewrite inE /= permM.\nby have [-> /tH | /sH] := eqVneq (s x) x.\nQed.",
    "Lemma perm_onV H s : perm_on H s -> perm_on H s^-1.\nProof.\nmove=> /subsetP sH; apply/subsetP => i /[!inE] sVi; apply: sH; rewrite inE.\nby apply: contra_neq sVi => si_id; rewrite -[in LHS]si_id permK.\nQed.",
    "Lemma out_perm S u x : perm_on S u -> x \\notin S -> u x = x.\nProof. by move=> uS; apply: contraNeq (subsetP uS x). Qed.",
    "Lemma im_perm_on u S : perm_on S u -> u @: S = S.\nProof.\nmove=> Su; rewrite -preim_permV; apply/setP=> x.\nby rewrite !inE -(perm_closed _ Su) permKV.\nQed.",
    "Lemma perm_on_id u S : perm_on S u -> #|S| <= 1 -> u = 1%g.\nProof.\nrewrite leq_eqVlt ltnS leqn0 => pSu S10; apply/permP => t; rewrite perm1.\ncase/orP : S10; last first.\n  by move/eqP/cards0_eq => S0; apply: (out_perm pSu); rewrite S0 inE.\nmove=> /cards1P[x Sx].\nhave [-> | ntx] := eqVneq t x; last by apply: (out_perm pSu); rewrite Sx inE.\nby apply/eqP; have := perm_closed x pSu; rewrite Sx !inE => ->.\nQed.",
    "Lemma perm_onC (S1 S2 : {set T}) (u1 u2 : {perm T}) :\n    perm_on S1 u1 -> perm_on S2 u2 ->\n    [disjoint S1 & S2] ->\n  commute u1 u2.\nProof.\nmove=> pS1 pS2 S12; apply/permP => t; rewrite !permM.\ncase/boolP : (t \\in S1) => tS1.\n  have /[!disjoint_subset] /subsetP {}S12 := S12.\n  by rewrite !(out_perm pS2) //; apply: S12; rewrite // perm_closed.\ncase/boolP : (t \\in S2) => tS2.\n  have /[1!disjoint_sym] /[!disjoint_subset] /subsetP {}S12 := S12.\n  by rewrite !(out_perm pS1) //; apply: S12; rewrite // perm_closed.\nby rewrite (out_perm pS1) // (out_perm pS2) // (out_perm pS1).\nQed.",
    "Lemma imset_perm1 (S : {set T}) : [set (1 : {perm T}) x | x in S] = S.\nProof. apply: im_perm_on; exact: perm_on1. Qed.",
    "Lemma tperm_proof x y : involutive [fun z => z with x |-> y, y |-> x].\nProof.\nmove=> z /=; case: (z =P x) => [-> | ne_zx]; first by rewrite eqxx; case: eqP.\nby case: (z =P y) => [->| ne_zy]; [rewrite eqxx | do 2?case: eqP].\nQed.",
    "Lemma tpermP x y z : tperm_spec x y z (tperm x y z).\nProof. by rewrite permE /=; do 2?[case: eqP => /=]; constructor; auto. Qed.",
    "Lemma tpermL x y : tperm x y x = y.\nProof. by case: tpermP. Qed.",
    "Lemma tpermR x y : tperm x y y = x.\nProof. by case: tpermP. Qed.",
    "Lemma tpermD x y z : x != z -> y != z -> tperm x y z = z.\nProof. by case: tpermP => // ->; rewrite eqxx. Qed.",
    "Lemma tpermC x y : tperm x y = tperm y x.\nProof. by apply/permP => z; do 2![case: tpermP => //] => ->. Qed.",
    "Lemma tperm1 x : tperm x x = 1.\nProof. by apply/permP => z; rewrite perm1; case: tpermP. Qed.",
    "Lemma tpermK x y : involutive (tperm x y).\nProof. by move=> z; rewrite !permE tperm_proof. Qed.",
    "Lemma tpermKg x y : involutive (mulg (tperm x y)).\nProof. by move=> s; apply/permP=> z; rewrite !permM tpermK. Qed.",
    "Lemma tpermV x y : (tperm x y)^-1 = tperm x y.\nProof. by set t := tperm x y; rewrite -{2}(mulgK t t) -mulgA tpermKg. Qed.",
    "Lemma tperm2 x y : tperm x y * tperm x y = 1.\nProof. by rewrite -{1}tpermV mulVg. Qed.",
    "Lemma tperm_on x y : perm_on [set x; y] (tperm x y).\nProof.\nby apply/subsetP => z /[!inE]; case: tpermP => [->|->|]; rewrite eqxx // orbT.\nQed.",
    "Lemma card_perm A : #|perm_on A| = (#|A|)`!.\nProof.\npose ffA := {ffun {x | x \\in A} -> T}.\nrewrite -ffactnn -{2}(card_sig [in A]) /= -card_inj_ffuns_on.\npose fT (f : ffA) := [ffun x => oapp f x (insub x)].\npose pfT f := insubd (1 : {perm T}) (fT f).\npose fA s : ffA := [ffun u => s (val u)].\nrewrite -!sum1dep_card -sum1_card (reindex_onto fA pfT) => [|f].\n  apply: eq_bigl => p; rewrite andbC; apply/idP/and3P=> [onA | []]; first split.\n  - apply/eqP; suffices fTAp: fT (fA p) = pval p.\n      by apply/permP=> x; rewrite -!pvalE insubdK fTAp //; apply: (valP p).\n    apply/ffunP=> x; rewrite ffunE pvalE.\n    by case: insubP => [u _ <- | /out_perm->] //=; rewrite ffunE.\n  - by apply/forallP=> [[x Ax]]; rewrite ffunE /= perm_closed.\n  - by apply/injectiveP=> u v; rewrite !ffunE => /perm_inj; apply: val_inj.\n  move/eqP=> <- _ _; apply/subsetP=> x; rewrite !inE -pvalE val_insubd fun_if.\n  by rewrite if_arg ffunE; case: insubP; rewrite // pvalE perm1 if_same eqxx.\ncase/andP=> /forallP-onA /injectiveP-f_inj.\napply/ffunP=> u; rewrite ffunE -pvalE insubdK; first by rewrite ffunE valK.\napply/injectiveP=> {u} x y; rewrite !ffunE.\ncase: insubP => [u _ <-|]; case: insubP => [v _ <-|] //=; first by move/f_inj->.\n  by move=> Ay' def_y; rewrite -def_y [_ \\in A]onA in Ay'.\nby move=> Ax' def_x; rewrite def_x [_ \\in A]onA in Ax'.\nQed.",
    "Lemma inj_tperm (T T' : finType) (f : T -> T') x y z :\n  injective f -> f (tperm x y z) = tperm (f x) (f y) (f z).\nProof. by move=> injf; rewrite !permE /= !(inj_eq injf) !(fun_if f). Qed.",
    "Lemma tpermJ x y s : (tperm x y) ^ s = tperm (s x) (s y).\nProof.\nby apply/permP => z; rewrite -(permKV s z) permJ; apply/inj_tperm/perm_inj.\nQed.",
    "Lemma tpermJ_tperm x y z :\n  x != z -> y != z -> tperm x z ^ tperm x y = tperm y z.\nProof. by move=> nxz nyz; rewrite tpermJ tpermL [tperm _ _ z]tpermD. Qed.",
    "Lemma tuple_permP {T : eqType} {n} {s : seq T} {t : n.-tuple T} :\n  reflect (exists p : 'S_n, s = [tuple tnth t (p i) | i < n]) (perm_eq s t).\nProof.\napply: (iffP idP) => [|[p ->]]; last first.\n  rewrite /= (map_comp (tnth t)) -{1}(map_tnth_enum t) perm_map //.\n  apply: uniq_perm => [||i]; rewrite ?enum_uniq //.\n    by apply/injectiveP; apply: perm_inj.\n  by rewrite mem_enum -[i](permKV p) image_f.\ncase: n => [|n] in t *; last have x0 := tnth t ord0.\n  rewrite tuple0 => /perm_small_eq-> //.\n  by exists 1; rewrite [mktuple _]tuple0.\ncase/(perm_iotaP x0); rewrite size_tuple => Is eqIst ->{s}.\nhave uniqIs: uniq Is by rewrite (perm_uniq eqIst) iota_uniq.\nhave szIs: size Is == n.+1 by rewrite (perm_size eqIst) !size_tuple.\nhave pP i : tnth (Tuple szIs) i < n.+1.\n  by rewrite -[_ < _](mem_iota 0) -(perm_mem eqIst) mem_tnth.\nhave inj_p: injective (fun i => Ordinal (pP i)).\n  by apply/injectiveP/(@map_uniq _ _ val); rewrite -map_comp map_tnth_enum.\nexists (perm inj_p); rewrite -[Is]/(tval (Tuple szIs)); congr (tval _).\nby apply: eq_from_tnth => i; rewrite tnth_map tnth_mktuple permE (tnth_nth x0).\nQed.",
    "Lemma apermE x s : aperm x s = s x. Proof. by []. Qed.",
    "Lemma mem_porbit s i x : (s ^+ i) x \\in porbit s x.\nProof. by rewrite [@porbit]unlock (imset_f (aperm x)) ?mem_cycle. Qed.",
    "Lemma porbit_id s x : x \\in porbit s x.\nProof. by rewrite -{1}[x]perm1 (mem_porbit s 0). Qed.",
    "Lemma card_porbit_neq0 s x : #|porbit s x| != 0.\nProof.\nby rewrite -lt0n card_gt0; apply/set0Pn; exists x; exact: porbit_id.\nQed.",
    "Lemma uniq_traject_porbit s x : uniq (traject s x #|porbit s x|).\nProof.\ncase def_n: #|_| => // [n]; rewrite looping_uniq.\napply: contraL (card_size (traject s x n)) => /loopingP t_sx.\nrewrite -ltnNge size_traject -def_n ?subset_leq_card // porbit.unlock.\nby apply/subsetP=> _ /imsetP[_ /cycleP[i ->] ->]; rewrite /aperm permX t_sx.\nQed.",
    "Lemma porbit_traject s x : porbit s x =i traject s x #|porbit s x|.\nProof.\napply: fsym; apply/subset_cardP.\n  by rewrite (card_uniqP _) ?size_traject ?uniq_traject_porbit.\nby apply/subsetP=> _ /trajectP[i _ ->]; rewrite -permX mem_porbit.\nQed.",
    "Lemma iter_porbit s x : iter #|porbit s x| s x = x.\nProof.\ncase def_n: #|_| (uniq_traject_porbit s x) => [//|n] Ut.\nhave: looping s x n.+1.\n  by rewrite -def_n -[looping _ _ _]porbit_traject -permX mem_porbit.\nrewrite /looping => /trajectP[[|i] //= lt_i_n /perm_inj eq_i_n_sx].\nmove: lt_i_n; rewrite ltnS ltn_neqAle andbC => /andP[le_i_n /negP[]].\nby rewrite -(nth_uniq x _ _ Ut) ?size_traject ?nth_traject // eq_i_n_sx.\nQed.",
    "Lemma eq_porbit_mem s x y : (porbit s x == porbit s y) = (x \\in porbit s y).\nProof.\napply/eqP/idP; first by move<-; exact: porbit_id.\nrewrite porbit.unlock => /imsetP[si s_si ->].\napply/setP => z; apply/imsetP/imsetP=> [] [sj s_sj ->].\n  by exists (si * sj); rewrite ?groupM /aperm ?permM.\nexists (si^-1 * sj); first by rewrite groupM ?groupV.\nby rewrite /aperm permM permK.\nQed.",
    "Lemma porbit_sym s x y : (x \\in porbit s y) = (y \\in porbit s x).\nProof. by rewrite -!eq_porbit_mem eq_sym. Qed.",
    "Lemma porbit_perm s i x : porbit s ((s ^+ i) x) = porbit s x.\nProof. by apply/eqP; rewrite eq_porbit_mem mem_porbit. Qed.",
    "Lemma porbitPmin s x y :\n  y \\in porbit s x -> exists2 i, i < #[s] & y = (s ^+ i) x.\nProof.\nby rewrite porbit.unlock=> /imsetP [z /cyclePmin[ i Hi ->{z}] ->{y}]; exists i.\nQed.",
    "Lemma porbitP s x y :\n  reflect (exists i, y = (s ^+ i) x) (y \\in porbit s x).\nProof.\napply (iffP idP) => [/porbitPmin [i _ ->]| [i ->]]; last exact: mem_porbit.\nby exists i.\nQed.",
    "Lemma porbitV s : porbit s^-1 =1 porbit s.\nProof.\nmove=> x; apply/setP => y; rewrite porbit_sym.\nby apply/porbitP/porbitP => -[i ->]; exists i; rewrite expgVn ?permK ?permKV.\nQed.",
    "Lemma porbitsV s : porbits s^-1 = porbits s.\nProof.\nrewrite /porbits; apply/setP => y.\nby apply/imsetP/imsetP => -[x _ ->{y}]; exists x; rewrite // porbitV.\nQed.",
    "Lemma porbit_setP s t x : porbit s x =i porbit t x <-> porbit s x = porbit t x.\nProof. by rewrite porbit.unlock; exact: setP. Qed.",
    "Lemma porbits_mul_tperm s x y : let t := tperm x y in\n  #|porbits (t * s)| + (x \\notin porbit s y).*2 = #|porbits s| + (x != y).\nProof.\npose xf a b u := seq.find (pred2 a b) (traject u (u a) #|porbit u a|).\nhave xf_size a b u: xf a b u <= #|porbit u a|.\n  by rewrite (leq_trans (find_size _ _)) ?size_traject.\nhave lt_xf a b u n : n < xf a b u -> ~~ pred2 a b ((u ^+ n.+1) a).\n  move=> lt_n; apply: contraFN (before_find (u a) lt_n).\n  by rewrite permX iterSr nth_traject // (leq_trans lt_n).\npose t a b u := tperm a b * u.\nhave tC a b u : t a b u = t b a u by rewrite /t tpermC.\nhave tK a b: involutive (t a b) by move=> u; apply: tpermKg.\nhave tXC a b u n: n <= xf a b u -> (t a b u ^+ n.+1) b = (u ^+ n.+1) a.\n  elim: n => [|n IHn] lt_n_f; first by rewrite permM tpermR.\n  rewrite !(expgSr _ n.+1) !permM {}IHn 1?ltnW //; congr (u _).\n  by case/lt_xf/norP: lt_n_f => ne_a ne_b; rewrite tpermD // eq_sym.\nhave eq_xf a b u: pred2 a b ((u ^+ (xf a b u).+1) a).\n  have ua_a: a \\in porbit u (u a) by rewrite porbit_sym (mem_porbit _ 1).\n  have has_f: has (pred2 a b) (traject u (u a) #|porbit u (u a)|).\n    by apply/hasP; exists a; rewrite /= ?eqxx -?porbit_traject.\n  have:= nth_find (u a) has_f; rewrite has_find size_traject in has_f.\n  rewrite -eq_porbit_mem in ua_a.\n  by rewrite nth_traject // -iterSr -permX -(eqP ua_a).\nhave xfC a b u: xf b a (t a b u) = xf a b u.\n  without loss lt_a: a b u / xf b a (t a b u) < xf a b u.\n    move=> IHab; set m := xf b a _; set n := xf a b u.\n    by case: (ltngtP m n) => // ltx; [apply: IHab | rewrite -[m]IHab tC tK].\n  by move/lt_xf: (lt_a); rewrite -(tXC a b) 1?ltnW //= orbC [_ || _]eq_xf.\npose ts := t x y s; rewrite /= -[_ * s]/ts.\npose dp u := #|porbits u :\\ porbit u y :\\ porbit u x|.\nrewrite !(addnC #|_|) (cardsD1 (porbit ts y)) imset_f ?inE //.\nrewrite (cardsD1 (porbit ts x)) inE imset_f ?inE //= -/(dp ts) {}/ts.\nrewrite (cardsD1 (porbit s y)) (cardsD1 (porbit s x)) !(imset_f, inE) //.\nrewrite -/(dp s) !addnA !eq_porbit_mem andbT; congr (_ + _); last first.\n  wlog suffices: s / dp s <= dp (t x y s).\n    by move=> IHs; apply/eqP; rewrite eqn_leq -{2}(tK x y s) !IHs.\n  apply/subset_leq_card/subsetP=> {dp} C.\n  rewrite !inE andbA andbC !(eq_sym C) => /and3P[/imsetP[z _ ->{C}]].\n  rewrite 2!eq_porbit_mem => sxz syz.\n  suffices ts_z: porbit (t x y s) z = porbit s z.\n    by rewrite -ts_z !eq_porbit_mem {1 2}ts_z sxz syz imset_f ?inE.\n  suffices exp_id n: ((t x y s) ^+ n) z = (s ^+ n) z.\n    apply/porbit_setP => u; apply/idP/idP=> /porbitP[i ->].\n      by rewrite /aperm exp_id mem_porbit. \n    by rewrite /aperm -exp_id mem_porbit.\n  elim: n => // n IHn; rewrite !expgSr !permM {}IHn tpermD //.\n    by apply: contraNneq sxz => ->; apply: mem_porbit.\n  by apply: contraNneq syz => ->; apply: mem_porbit.\ncase: eqP {dp} => [<- | ne_xy]; first by rewrite /t tperm1 mul1g porbit_id.\nsuff ->: (x \\in porbit (t x y s) y) = (x \\notin porbit s y) by case: (x \\in _).\nwithout loss xf_x: s x y ne_xy / (s ^+ (xf x y s).+1) x = x.\n  move=> IHs; have ne_yx := nesym ne_xy; have:= eq_xf x y s; set n := xf x y s.\n  case/pred2P=> [|snx]; first exact: IHs.\n  by rewrite -[x \\in _]negbK ![x \\in _]porbit_sym -{}IHs ?xfC ?tXC // tC tK.\nrewrite -{1}xf_x -(tXC _ _ _ _ (leqnn _)) mem_porbit; symmetry.\nrewrite -eq_porbit_mem eq_sym eq_porbit_mem porbit_traject.\napply/trajectP=> [[n _ snx]].\nhave: looping s x (xf x y s).+1 by rewrite /looping -permX xf_x inE eqxx.\nmove/loopingP/(_ n); rewrite -{n}snx.\ncase/trajectP=> [[_|i]]; first exact: nesym; rewrite ltnS -permX => lt_i def_y.\nby move/lt_xf: lt_i; rewrite def_y /= eqxx orbT.\nQed.",
    "Lemma odd_perm1 : odd_perm 1 = false.\nProof.\nrewrite /odd_perm card_imset ?addbb // => x y; move/eqP; rewrite eq_porbit_mem.\nby rewrite porbit.unlock cycle1 imset_set1 /aperm perm1 inE=> /eqP.\nQed.",
    "Lemma odd_mul_tperm x y s : odd_perm (tperm x y * s) = (x != y) (+) odd_perm s.\nProof.\nrewrite addbC -addbA -[~~ _]oddb -oddD -porbits_mul_tperm.\nby rewrite oddD odd_double addbF.\nQed.",
    "Lemma odd_tperm x y : odd_perm (tperm x y) = (x != y).\nProof. by rewrite -[_ y]mulg1 odd_mul_tperm odd_perm1 addbF. Qed.",
    "Lemma prod_tpermP s :\n  {ts : seq (T * T) | s = \\prod_(t <- ts) tperm t.1 t.2 & all dpair ts}.\nProof.\nhave [n] := ubnP #|[pred x | s x != x]|; elim: n s => // n IHn s /ltnSE-le_s_n.\ncase: (pickP (fun x => s x != x)) => [x s_x | s_id]; last first.\n  exists nil; rewrite // big_nil; apply/permP=> x.\n  by apply/eqP/idPn; rewrite perm1 s_id.\nhave [|ts def_s ne_ts] := IHn (tperm x (s^-1 x) * s); last first.\n  exists ((x, s^-1 x) :: ts); last by rewrite /= -(canF_eq (permK _)) s_x.\n  by rewrite big_cons -def_s mulgA tperm2 mul1g.\nrewrite (cardD1 x) !inE s_x in le_s_n; apply: leq_ltn_trans le_s_n.\napply: subset_leq_card; apply/subsetP=> y.\nrewrite !inE permM permE /= -(canF_eq (permK _)).\nhave [-> | ne_yx] := eqVneq y x; first by rewrite permKV eqxx.\nby case: (s y =P x) => // -> _; rewrite eq_sym.\nQed.",
    "Lemma odd_perm_prod ts :\n  all dpair ts -> odd_perm (\\prod_(t <- ts) tperm t.1 t.2) = odd (size ts).\nProof.\nelim: ts => [_|t ts IHts] /=; first by rewrite big_nil odd_perm1.\nby case/andP=> dt12 dts; rewrite big_cons odd_mul_tperm dt12 IHts.\nQed.",
    "Lemma odd_permM : {morph odd_perm : s1 s2 / s1 * s2 >-> s1 (+) s2}.\nProof.\nmove=> s1 s2; case: (prod_tpermP s1) => ts1 ->{s1} dts1.\ncase: (prod_tpermP s2) => ts2 ->{s2} dts2.\nby rewrite -big_cat !odd_perm_prod ?all_cat ?dts1 // size_cat oddD.\nQed.",
    "Lemma odd_permV s : odd_perm s^-1 = odd_perm s.\nProof. by rewrite -{2}(mulgK s s) !odd_permM -addbA addKb. Qed.",
    "Lemma odd_permJ s1 s2 : odd_perm (s1 ^ s2) = odd_perm s1.\nProof. by rewrite !odd_permM odd_permV addbC addbK. Qed.",
    "Lemma gen_tperm x : <<[set tperm x y | y in T]>>%g = [set: {perm T}].\nProof.\napply/eqP; rewrite eqEsubset subsetT/=; apply/subsetP => s _.\nhave [ts -> _] := prod_tpermP s; rewrite group_prod// => -[/= y z] _.\nhave [<-|Nyz] := eqVneq y z; first by rewrite tperm1 group1.\nhave [<-|Nxz] := eqVneq x z; first by rewrite tpermC mem_gen ?imset_f.\nby rewrite -(tpermJ_tperm Nxz Nyz) groupJ ?mem_gen ?imset_f.\nQed.",
    "Lemma Sym_group_set : group_set Sym.\nProof.\napply/group_setP; split => [|s t] /[!inE]; [exact: perm_on1 | exact: perm_onM].\nQed.",
    "Lemma card_Sym : #|Sym| = #|S|`!.\nProof. by rewrite cardsE /= card_perm. Qed.",
    "Lemma card_Sn : #|'S_(n)| = n`!.\nProof.\nrewrite (eq_card (B := perm_on [set : 'I_n])).\n  by rewrite card_perm /= cardsE /= card_ord.\nmove=> p; rewrite inE unfold_in /perm_on /=.\nby apply/esym/subsetP => i _; rewrite in_set.\nQed.",
    "Lemma lift_permK i j s :\n  cancel (lift_perm_fun i j s) (lift_perm_fun j i s^-1).\nProof.\nrewrite /lift_perm_fun => k.\nby case: (unliftP i k) => [j'|] ->; rewrite (liftK, unlift_none) ?permK.\nQed.",
    "Lemma lift_perm_id i j s : lift_perm i j s i = j.\nProof. by rewrite permE /lift_perm_fun unlift_none. Qed.",
    "Lemma lift_perm_lift i j s k' :\n  lift_perm i j s (lift i k') = lift j (s k') :> 'I_n.+1.\nProof. by rewrite permE /lift_perm_fun liftK. Qed.",
    "Lemma lift_permM i j k s t :\n  lift_perm i j s * lift_perm j k t = lift_perm i k (s * t).\nProof.\napply/permP=> i1; case: (unliftP i i1) => [i2|] ->{i1}.\n  by rewrite !(permM, lift_perm_lift).\nby rewrite permM !lift_perm_id.\nQed.",
    "Lemma lift_perm1 i : lift_perm i i 1 = 1.\nProof. by apply: (mulgI (lift_perm i i 1)); rewrite lift_permM !mulg1. Qed.",
    "Lemma lift_permV i j s : (lift_perm i j s)^-1 = lift_perm j i s^-1.\nProof. by apply/eqP; rewrite eq_invg_mul lift_permM mulgV lift_perm1. Qed.",
    "Lemma odd_lift_perm i j s : lift_perm i j s = odd i (+) odd j (+) s :> bool.\nProof.\nrewrite -{1}(mul1g s) -(lift_permM _ j) odd_permM.\ncongr (_ (+) _); last first.\n  case: (prod_tpermP s) => ts ->{s} _.\n  elim: ts => [|t ts IHts] /=; first by rewrite big_nil lift_perm1 !odd_perm1.\n  rewrite big_cons odd_mul_tperm -(lift_permM _ j) odd_permM {}IHts //.\n  congr (_ (+) _); transitivity (tperm (lift j t.1) (lift j t.2)); last first.\n     by rewrite odd_tperm (inj_eq (pcan_inj (liftK j))).\n  congr odd_perm; apply/permP=> k; case: (unliftP j k) => [k'|] ->.\n    by rewrite lift_perm_lift inj_tperm //; apply: lift_inj.\n  by rewrite lift_perm_id tpermD // eq_sym neq_lift.\nsuff{i j s} odd_lift0 (k : 'I_n.+1): lift_perm ord0 k 1 = odd k :> bool.\n  rewrite -!odd_lift0 -{2}invg1 -lift_permV odd_permV -odd_permM.\n  by rewrite lift_permM mulg1.\nelim: {k}(k : nat) {1 3}k (erefl (k : nat)) => [|m IHm] k def_k.\n  by rewrite (_ : k = ord0) ?lift_perm1 ?odd_perm1 //; apply: val_inj.\nhave le_mn: m < n.+1 by [rewrite -def_k ltnW]; pose j := Ordinal le_mn.\nrewrite -(mulg1 1)%g -(lift_permM _ j) odd_permM {}IHm // addbC.\nrewrite (_ : _ 1 = tperm j k); first by rewrite odd_tperm neq_ltn/= def_k leqnn.\napply/permP=> i; case: (unliftP j i) => [i'|] ->; last first.\n  by rewrite lift_perm_id tpermL.\napply: ord_inj; rewrite lift_perm_lift !permE /= eq_sym -if_neg neq_lift.\nrewrite fun_if -val_eqE /= def_k /bump ltn_neqAle andbC.\ncase: leqP => [_ | lt_i'm] /=; last by rewrite -if_neg neq_ltn leqW.\nby rewrite add1n eqSS; case: eqVneq.\nQed.",
    "Lemma permS0 : all_equal_to (1 : 'S_0).\nProof. by move=> g; apply/permP; case. Qed.",
    "Lemma permS1 : all_equal_to (1 : 'S_1).\nProof. by move=> g; apply/permP => i; rewrite !ord1. Qed.",
    "Lemma permS01 n : n <= 1 -> all_equal_to (1 : 'S_n).\nProof. by case: n => [|[|]//=] _ g; rewrite (permS0, permS1). Qed.",
    "Lemma cast_perm_id n eq_n s : cast_perm eq_n s = s :> 'S_n.\nProof. by apply/permP => i; rewrite /cast_perm /= eq_axiomK. Qed.",
    "Lemma cast_ord_permE m n eq_m_n (s : 'S_m) i :\n  @cast_ord m n eq_m_n (s i) = (cast_perm eq_m_n s) (cast_ord eq_m_n i).\nProof. by subst m; rewrite cast_perm_id !cast_ord_id. Qed.",
    "Lemma cast_permE m n (eq_m_n : m = n) (s : 'S_m) (i : 'I_n) :\n  cast_perm eq_m_n s i = cast_ord eq_m_n (s (cast_ord (esym eq_m_n) i)).\nProof. by rewrite cast_ord_permE cast_ordKV. Qed.",
    "Lemma cast_perm_comp m n p (eq_m_n : m = n) (eq_n_p : n = p) s :\n  cast_perm eq_n_p (cast_perm eq_m_n s) = cast_perm (etrans eq_m_n eq_n_p) s.\nProof. by case: _ / eq_n_p. Qed.",
    "Lemma cast_permK m n eq_m_n :\n  cancel (@cast_perm m n eq_m_n) (cast_perm (esym eq_m_n)).\nProof. by subst m. Qed.",
    "Lemma cast_permKV m n eq_m_n :\n  cancel (cast_perm (esym eq_m_n)) (@cast_perm m n eq_m_n).\nProof. by subst m. Qed.",
    "Lemma cast_perm_sym m n (eq_m_n : m = n) s t :\n  s = cast_perm eq_m_n t -> t = cast_perm (esym eq_m_n) s.\nProof. by move/(canLR (cast_permK _)). Qed.",
    "Lemma cast_perm_inj m n eq_m_n : injective (@cast_perm m n eq_m_n).\nProof. exact: can_inj (cast_permK eq_m_n). Qed.",
    "Lemma cast_perm_morphM m n eq_m_n :\n  {morph @cast_perm m n eq_m_n : x y / x * y >-> x * y}.\nProof. by subst m. Qed.",
    "Lemma isom_cast_perm m n eq_m_n : isom setT setT (@cast_perm m n eq_m_n).\nProof.\ncase: {n} _ / eq_m_n; apply/isomP; split.\n  exact/injmP/(in2W (@cast_perm_inj _ _ _)).\nby apply/setP => /= s /[!inE]; apply/imsetP; exists s; rewrite ?inE.\nQed.",
    "Lemma morphimP : reflect morphim_spec (y \\in f @: (D :&: A)).\nProof.\napply: (iffP imsetP) => [] [z]; first by case/setIP; exists z.\nby exists z; first apply/setIP.\nQed.",
    "Lemma morphpreP : reflect (x \\in D /\\ f x \\in R) (x \\in D :&: f @^-1: R).\nProof. by rewrite !inE; apply: andP. Qed.",
    "Lemma morphM : {in D &, {morph f : x y / x * y}}.\nProof. by case f. Qed.",
    "Lemma morph1 : f 1 = 1.\nProof. by apply: (mulgI (f 1)); rewrite -morphM ?mulg1. Qed.",
    "Lemma morph_prod I r (P : pred I) F :\n    (forall i, P i -> F i \\in D) ->\n  f (\\prod_(i <- r | P i) F i) = \\prod_( i <- r | P i) f (F i).\nProof.\nmove=> D_F; elim/(big_load (fun x => x \\in D)): _.\nelim/big_rec2: _ => [|i _ x Pi [Dx <-]]; first by rewrite morph1.\nby rewrite groupM ?morphM // D_F.\nQed.",
    "Lemma morphV : {in D, {morph f : x / x^-1}}.\nProof.\nmove=> x Dx; apply: (mulgI (f x)).\nby rewrite -morphM ?groupV // !mulgV morph1.\nQed.",
    "Lemma morphJ : {in D &, {morph f : x y / x ^ y}}.\nProof. by move=> * /=; rewrite !morphM ?morphV // ?groupM ?groupV. Qed.",
    "Lemma morphX n : {in D, {morph f : x / x ^+ n}}.\nProof.\nby elim: n => [|n IHn] x Dx; rewrite ?morph1 // !expgS morphM ?(groupX, IHn).\nQed.",
    "Lemma morphR : {in D &, {morph f : x y / [~ x, y]}}.\nProof. by move=> * /=; rewrite morphM ?(groupV, groupJ) // morphJ ?morphV. Qed.",
    "Lemma morphimE A : f @* A = f @: (D :&: A). Proof. by []. Qed.",
    "Lemma morphpreE R : f @*^-1 R = D :&: f @^-1: R. Proof. by []. Qed.",
    "Lemma kerE : 'ker f = f @*^-1 1. Proof. by []. Qed.",
    "Lemma morphimEsub A : A \\subset D -> f @* A = f @: A.\nProof. by move=> sAD; rewrite /morphim (setIidPr sAD). Qed.",
    "Lemma morphimEdom : f @* D = f @: D.\nProof. exact: morphimEsub. Qed.",
    "Lemma morphimIdom A : f @* (D :&: A) = f @* A.\nProof. by rewrite /morphim setIA setIid. Qed.",
    "Lemma morphpreIdom R : D :&: f @*^-1 R = f @*^-1 R.\nProof. by rewrite /morphim setIA setIid. Qed.",
    "Lemma morphpreIim R : f @*^-1 (f @* D :&: R) = f @*^-1 R.\nProof.\napply/setP=> x; rewrite morphimEdom !inE.\nby case Dx: (x \\in D); rewrite // imset_f.\nQed.",
    "Lemma morphimIim A : f @* D :&: f @* A = f @* A.\nProof. by apply/setIidPr; rewrite imsetS // setIid subsetIl. Qed.",
    "Lemma mem_morphim A x : x \\in D -> x \\in A -> f x \\in f @* A.\nProof. by move=> Dx Ax; apply/morphimP; exists x. Qed.",
    "Lemma mem_morphpre R x : x \\in D -> f x \\in R -> x \\in f @*^-1 R.\nProof. by move=> Dx Rfx; apply/morphpreP. Qed.",
    "Lemma morphimS A B : A \\subset B -> f @* A \\subset f @* B.\nProof. by move=> sAB; rewrite imsetS ?setIS. Qed.",
    "Lemma morphim_sub A : f @* A \\subset f @* D.\nProof. by rewrite imsetS // setIid subsetIl. Qed.",
    "Lemma leq_morphim A : #|f @* A| <= #|A|.\nProof.\nby apply: (leq_trans (leq_imset_card _ _)); rewrite subset_leq_card ?subsetIr.\nQed.",
    "Lemma morphpreS R S : R \\subset S -> f @*^-1 R \\subset f @*^-1 S.\nProof. by move=> sRS; rewrite setIS ?preimsetS. Qed.",
    "Lemma morphpre_sub R : f @*^-1 R \\subset D.\nProof. exact: subsetIl. Qed.",
    "Lemma morphim_setIpre A R : f @* (A :&: f @*^-1 R) = f @* A :&: R.\nProof.\napply/setP=> fa; apply/morphimP/setIP=> [[a Da] | [/morphimP[a Da Aa ->] Rfa]].\n  by rewrite !inE Da /= => /andP[Aa Rfa] ->; rewrite mem_morphim.\nby exists a; rewrite // !inE Aa Da.\nQed.",
    "Lemma morphim0 : f @* set0 = set0.\nProof. by rewrite morphimE setI0 imset0. Qed.",
    "Lemma morphim_eq0 A : A \\subset D -> (f @* A == set0) = (A == set0).\nProof. by rewrite imset_eq0 => /setIidPr->. Qed.",
    "Lemma morphim_set1 x : x \\in D -> f @* [set x] = [set f x].\nProof. by rewrite /morphim -sub1set => /setIidPr->; apply: imset_set1. Qed.",
    "Lemma morphim1 : f @* 1 = 1.\nProof. by rewrite morphim_set1 ?morph1. Qed.",
    "Lemma morphimV A : f @* A^-1 = (f @* A)^-1.\nProof.\nwlog suffices: A / f @* A^-1 \\subset (f @* A)^-1.\n  by move=> IH; apply/eqP; rewrite eqEsubset IH -invSg invgK -{1}(invgK A) IH.\napply/subsetP=> _ /morphimP[x Dx Ax' ->]; rewrite !inE in Ax' *.\nby rewrite -morphV // imset_f // inE groupV Dx.\nQed.",
    "Lemma morphpreV R : f @*^-1 R^-1 = (f @*^-1 R)^-1.\nProof.\napply/setP=> x; rewrite !inE groupV; case Dx: (x \\in D) => //=.\nby rewrite morphV.\nQed.",
    "Lemma morphimMl A B : A \\subset D -> f @* (A * B) = f @* A * f @* B.\nProof.\nmove=> sAD; rewrite /morphim setIC -group_modl // (setIidPr sAD).\napply/setP=> fxy; apply/idP/idP.\n  case/imsetP=> _ /imset2P[x y Ax /setIP[Dy By] ->] ->{fxy}.\n  by rewrite morphM // (subsetP sAD, imset2_f) // imset_f // inE By.\ncase/imset2P=> _ _ /imsetP[x Ax ->] /morphimP[y Dy By ->] ->{fxy}.\nby rewrite -morphM // (subsetP sAD, imset_f) // mem_mulg // inE By.\nQed.",
    "Lemma morphimMr A B : B \\subset D -> f @* (A * B) = f @* A * f @* B.\nProof.\nmove=> sBD; apply: invg_inj.\nby rewrite invMg -!morphimV invMg morphimMl // -invGid invSg.\nQed.",
    "Lemma morphpreMl R S :\n  R \\subset f @* D -> f @*^-1 (R * S) = f @*^-1 R * f @*^-1 S.\nProof.\nmove=> sRfD; apply/setP=> x; rewrite !inE.\napply/andP/imset2P=> [[Dx] | [y z]]; last first.\n  rewrite !inE => /andP[Dy Rfy] /andP[Dz Rfz] ->.\n  by rewrite ?(groupM, morphM, imset2_f).\ncase/imset2P=> fy fz Rfy Rfz def_fx.\nhave /morphimP[y Dy _ def_fy]: fy \\in f @* D := subsetP sRfD fy Rfy.\nexists y (y^-1 * x); last by rewrite mulKVg.\n  by rewrite !inE Dy -def_fy.\nby rewrite !inE groupM ?(morphM, morphV, groupV) // def_fx -def_fy mulKg.\nQed.",
    "Lemma morphimJ A x : x \\in D -> f @* (A :^ x) = f @* A :^ f x.\nProof.\nmove=> Dx; rewrite !conjsgE morphimMl ?(morphimMr, sub1set, groupV) //.\nby rewrite !(morphim_set1, groupV, morphV).\nQed.",
    "Lemma morphpreJ R x : x \\in D -> f @*^-1 (R :^ f x) = f @*^-1 R :^ x.\nProof.\nmove=> Dx; apply/setP=> y; rewrite conjIg !inE conjGid // !mem_conjg inE.\nby case Dy: (y \\in D); rewrite // morphJ ?(morphV, groupV).\nQed.",
    "Lemma morphim_class x A :\n  x \\in D -> A \\subset D -> f @* (x ^: A) = f x ^: f @* A.\nProof.\nmove=> Dx sAD; rewrite !morphimEsub ?class_subG // /class -!imset_comp.\nby apply: eq_in_imset => y Ay /=; rewrite morphJ // (subsetP sAD).\nQed.",
    "Lemma classes_morphim A :\n  A \\subset D -> classes (f @* A) = [set f @* xA | xA in classes A].\nProof.\nmove=> sAD; rewrite morphimEsub // /classes -!imset_comp.\napply: eq_in_imset => x /(subsetP sAD) Dx /=.\nby rewrite morphim_class ?morphimEsub.\nQed.",
    "Lemma morphimT : f @* setT = f @* D.\nProof. by rewrite -morphimIdom setIT. Qed.",
    "Lemma morphimU A B : f @* (A :|: B) = f @* A :|: f @* B.\nProof. by rewrite -imsetU -setIUr. Qed.",
    "Lemma morphimI A B : f @* (A :&: B) \\subset f @* A :&: f @* B.\nProof. by rewrite subsetI // ?morphimS ?(subsetIl, subsetIr). Qed.",
    "Lemma morphpre0 : f @*^-1 set0 = set0.\nProof. by rewrite morphpreE preimset0 setI0. Qed.",
    "Lemma morphpreT : f @*^-1 setT = D.\nProof. by rewrite morphpreE preimsetT setIT. Qed.",
    "Lemma morphpreU R S : f @*^-1 (R :|: S) = f @*^-1 R :|: f @*^-1 S.\nProof. by rewrite -setIUr -preimsetU. Qed.",
    "Lemma morphpreI R S : f @*^-1 (R :&: S) = f @*^-1 R :&: f @*^-1 S.\nProof. by rewrite -setIIr -preimsetI. Qed.",
    "Lemma morphpreD R S : f @*^-1 (R :\\: S) = f @*^-1 R :\\: f @*^-1 S.\nProof. by apply/setP=> x /[!inE]; case: (x \\in D). Qed.",
    "Lemma kerP x : x \\in D -> reflect (f x = 1) (x \\in 'ker f).\nProof. by move=> Dx; rewrite 2!inE Dx; apply: set1P. Qed.",
    "Lemma dom_ker : {subset 'ker f <= D}.\nProof. by move=> x /morphpreP[]. Qed.",
    "Lemma mker x : x \\in 'ker f -> f x = 1.\nProof. by move=> Kx; apply/kerP=> //; apply: dom_ker. Qed.",
    "Lemma mkerl x y : x \\in 'ker f -> y \\in D -> f (x * y) = f y.\nProof. by move=> Kx Dy; rewrite morphM // ?(dom_ker, mker Kx, mul1g). Qed.",
    "Lemma mkerr x y : x \\in D -> y \\in 'ker f -> f (x * y) = f x.\nProof. by move=> Dx Ky; rewrite morphM // ?(dom_ker, mker Ky, mulg1). Qed.",
    "Lemma rcoset_kerP x y :\n  x \\in D -> y \\in D -> reflect (f x = f y) (x \\in 'ker f :* y).\nProof.\nmove=> Dx Dy; rewrite mem_rcoset !inE groupM ?morphM ?groupV //=.\nby rewrite morphV // -eq_mulgV1; apply: eqP.\nQed.",
    "Lemma ker_rcoset x y :\n  x \\in D -> y \\in D -> f x = f y -> exists2 z, z \\in 'ker f & x = z * y.\nProof. by move=> Dx Dy eqfxy; apply/rcosetP; apply/rcoset_kerP. Qed.",
    "Lemma ker_norm : D \\subset 'N('ker f).\nProof.\napply/subsetP=> x Dx /[1!inE]; apply/subsetP=> _ /imsetP[y Ky ->].\nby rewrite !inE groupJ ?morphJ // ?dom_ker //= mker ?conj1g.\nQed.",
    "Lemma ker_normal : 'ker f <| D.\nProof. by rewrite /(_ <| D) subsetIl ker_norm. Qed.",
    "Lemma morphimGI G A : 'ker f \\subset G -> f @* (G :&: A) = f @* G :&: f @* A.\nProof.\nmove=> sKG; apply/eqP; rewrite eqEsubset morphimI setIC.\napply/subsetP=> _ /setIP[/morphimP[x Dx Ax ->] /morphimP[z Dz Gz]].\ncase/ker_rcoset=> {Dz}// y Ky def_x.\nhave{z Gz y Ky def_x} Gx: x \\in G by rewrite def_x groupMl // (subsetP sKG).\nby rewrite imset_f ?inE // Dx Gx Ax.\nQed.",
    "Lemma morphimIG A G : 'ker f \\subset G -> f @* (A :&: G) = f @* A :&: f @* G.\nProof. by move=> sKG; rewrite setIC morphimGI // setIC. Qed.",
    "Lemma morphimD A B : f @* A :\\: f @* B \\subset f @* (A :\\: B).\nProof.\nrewrite subDset -morphimU morphimS //.\nby rewrite setDE setUIr setUCr setIT subsetUr.\nQed.",
    "Lemma morphimDG A G : 'ker f \\subset G -> f @* (A :\\: G) = f @* A :\\: f @* G.\nProof.\nmove=> sKG; apply/eqP; rewrite eqEsubset morphimD andbT !setDE subsetI.\nrewrite morphimS ?subsetIl // -[~: f @* G]setU0 -subDset setDE setCK.\nby rewrite -morphimIG //= setIAC -setIA setICr setI0 morphim0.\nQed.",
    "Lemma morphimD1 A : (f @* A)^# \\subset f @* A^#.\nProof. by rewrite -!set1gE -morphim1 morphimD. Qed.",
    "Lemma morphpre_groupset M : group_set (f @*^-1 M).\nProof.\napply/group_setP; split=> [|x y]; rewrite !inE ?(morph1, group1) //.\nby case/andP=> Dx Mfx /andP[Dy Mfy]; rewrite morphM ?groupM.\nQed.",
    "Lemma morphim_groupset G : group_set (f @* G).\nProof.\napply/group_setP; split=> [|_ _ /morphimP[x Dx Gx ->] /morphimP[y Dy Gy ->]].\n  by rewrite -morph1 imset_f ?group1.\nby rewrite -morphM ?imset_f ?inE ?groupM.\nQed.",
    "Lemma morph_dom_groupset : group_set (f @: D).\nProof. by rewrite -morphimEdom groupP. Qed.",
    "Lemma morphpreMr R S :\n  S \\subset f @* D -> f @*^-1 (R * S) = f @*^-1 R * f @*^-1 S.\nProof.\nmove=> sSfD; apply: invg_inj.\nby rewrite invMg -!morphpreV invMg morphpreMl // -invSg invgK invGid.\nQed.",
    "Lemma morphimK A : A \\subset D -> f @*^-1 (f @* A) = 'ker f * A.\nProof.\nmove=> sAD; apply/setP=> x; rewrite !inE.\napply/idP/idP=> [/andP[Dx /morphimP[y Dy Ay eqxy]] | /imset2P[z y Kz Ay ->{x}]].\n  rewrite -(mulgKV y x) mem_mulg // !inE !(groupM, morphM, groupV) //.\n  by rewrite morphV //= eqxy mulgV.\nhave [Dy Dz]: y \\in D /\\ z \\in D by rewrite (subsetP sAD) // dom_ker.\nby rewrite groupM // morphM // mker // mul1g imset_f // inE Dy.\nQed.",
    "Lemma morphimGK G : 'ker f \\subset G -> G \\subset D -> f @*^-1 (f @* G) = G.\nProof. by move=> sKG sGD; rewrite morphimK // mulSGid. Qed.",
    "Lemma morphpre_set1 x : x \\in D -> f @*^-1 [set f x] = 'ker f :* x.\nProof. by move=> Dx; rewrite -morphim_set1 // morphimK ?sub1set. Qed.",
    "Lemma morphpreK R : R \\subset f @* D -> f @* (f @*^-1 R) = R.\nProof.\nmove=> sRfD; apply/setP=> y; apply/morphimP/idP=> [[x _] | Ry].\n  by rewrite !inE; case/andP=> _ Rfx ->.\nhave /morphimP[x Dx _ defy]: y \\in f @* D := subsetP sRfD y Ry.\nby exists x; rewrite // !inE Dx -defy.\nQed.",
    "Lemma morphim_ker : f @* 'ker f = 1.\nProof. by rewrite morphpreK ?sub1G. Qed.",
    "Lemma ker_sub_pre M : 'ker f \\subset f @*^-1 M.\nProof. by rewrite morphpreS ?sub1G. Qed.",
    "Lemma ker_normal_pre M : 'ker f <| f @*^-1 M.\nProof. by rewrite /normal ker_sub_pre subIset ?ker_norm. Qed.",
    "Lemma morphpreSK R S :\n  R \\subset f @* D -> (f @*^-1 R \\subset f @*^-1 S) = (R \\subset S).\nProof.\nmove=> sRfD; apply/idP/idP=> [sf'RS|]; last exact: morphpreS.\nsuffices: R \\subset f @* D :&: S by rewrite subsetI sRfD.\nrewrite -(morphpreK sRfD) -[_ :&: S]morphpreK (morphimS, subsetIl) //.\nby rewrite morphpreI morphimGK ?subsetIl // setIA setIid.\nQed.",
    "Lemma sub_morphim_pre A R :\n  A \\subset D -> (f @* A \\subset R) = (A \\subset f @*^-1 R).\nProof.\nmove=> sAD; rewrite -morphpreSK (morphimS, morphimK) //.\napply/idP/idP; first by apply: subset_trans; apply: mulG_subr.\nby move/(mulgS ('ker f)); rewrite -morphpreMl ?(sub1G, mul1g).\nQed.",
    "Lemma morphpre_proper R S :\n    R \\subset f @* D -> S \\subset f @* D ->\n  (f @*^-1 R \\proper f @*^-1 S) = (R \\proper S).\nProof. by move=> dQ dR; rewrite /proper !morphpreSK. Qed.",
    "Lemma sub_morphpre_im R G :\n    'ker f \\subset G -> G \\subset D -> R \\subset f @* D ->\n  (f @*^-1 R \\subset G) = (R \\subset f @* G).\nProof. by symmetry; rewrite -morphpreSK ?morphimGK. Qed.",
    "Lemma ker_trivg_morphim A :\n  (A \\subset 'ker f) = (A \\subset D) && (f @* A \\subset [1]).\nProof.\ncase sAD: (A \\subset D); first by rewrite sub_morphim_pre.\nby rewrite subsetI sAD.\nQed.",
    "Lemma morphimSK A B :\n  A \\subset D -> (f @* A \\subset f @* B) = (A \\subset 'ker f * B).\nProof.\nmove=> sAD; transitivity (A \\subset 'ker f * (D :&: B)).\n  by rewrite -morphimK ?subsetIl // -sub_morphim_pre // /morphim setIA setIid.\nby rewrite setIC group_modl (subsetIl, subsetI) // andbC sAD.\nQed.",
    "Lemma morphimSGK A G :\n  A \\subset D -> 'ker f \\subset G -> (f @* A \\subset f @* G) = (A \\subset G).\nProof. by move=> sGD skfK; rewrite morphimSK // mulSGid. Qed.",
    "Lemma ltn_morphim A : [1] \\proper 'ker_A f -> #|f @* A| < #|A|.\nProof.\ncase/properP; rewrite sub1set => /setIP[A1 _] [x /setIP[Ax kx] x1].\nrewrite (cardsD1 1 A) A1 ltnS -{1}(setD1K A1) morphimU morphim1.\nrewrite (setUidPr _) ?sub1set; last first.\n  by rewrite -(mker kx) mem_morphim ?(dom_ker kx) // inE x1.\nby rewrite (leq_trans (leq_imset_card _ _)) ?subset_leq_card ?subsetIr.\nQed.",
    "Lemma morphpre_inj :\n  {in [pred R : {set rT} | R \\subset f @* D] &, injective (fun R => f @*^-1 R)}.\nProof. exact: can_in_inj morphpreK. Qed.",
    "Lemma morphim_injG :\n  {in [pred G : {group aT} | 'ker f \\subset G & G \\subset D] &,\n     injective (fun G => f @* G)}.\nProof.\nmove=> G H /andP[sKG sGD] /andP[sKH sHD] eqfGH.\nby apply: val_inj; rewrite /= -(morphimGK sKG sGD) eqfGH morphimGK.\nQed.",
    "Lemma morphim_inj G H :\n    ('ker f \\subset G) && (G \\subset D) ->\n    ('ker f \\subset H) && (H \\subset D) ->\n  f @* G = f @* H -> G :=: H.\nProof. by move=> nsGf nsHf /morphim_injG->. Qed.",
    "Lemma morphim_gen A : A \\subset D -> f @* <<A>> = <<f @* A>>.\nProof.\nmove=> sAD; apply/eqP.\nrewrite eqEsubset andbC gen_subG morphimS; last exact: subset_gen.\nby rewrite sub_morphim_pre gen_subG // -sub_morphim_pre // subset_gen.\nQed.",
    "Lemma morphim_cycle x : x \\in D -> f @* <[x]> = <[f x]>.\nProof. by move=> Dx; rewrite morphim_gen (sub1set, morphim_set1). Qed.",
    "Lemma morphimY A B :\n  A \\subset D -> B \\subset D -> f @* (A <*> B) = f @* A <*> f @* B.\nProof. by move=> sAD sBD; rewrite morphim_gen ?morphimU // subUset sAD. Qed.",
    "Lemma morphpre_gen R :\n  1 \\in R -> R \\subset f @* D -> f @*^-1 <<R>> = <<f @*^-1 R>>.\nProof.\nmove=> R1 sRfD; apply/eqP.\nrewrite eqEsubset andbC gen_subG morphpreS; last exact: subset_gen.\nrewrite -{1}(morphpreK sRfD) -morphim_gen ?subsetIl // morphimGK //=.\n  by rewrite sub_gen // setIS // preimsetS ?sub1set.\nby rewrite gen_subG subsetIl.\nQed.",
    "Lemma morphimR A B :\n  A \\subset D -> B \\subset D -> f @* [~: A, B] = [~: f @* A, f @* B].\nProof.\nmove/subsetP=> sAD /subsetP sBD.\nrewrite morphim_gen; last first; last congr <<_>>.\n  by apply/subsetP=> _ /imset2P[x y Ax By ->]; rewrite groupR; auto.\napply/setP=> fz; apply/morphimP/imset2P=> [[z _] | [fx fy]].\n  case/imset2P=> x y Ax By -> -> {z fz}.\n  have Dx := sAD x Ax; have Dy := sBD y By.\n  by exists (f x) (f y); rewrite ?(imset_f, morphR) // ?(inE, Dx, Dy).\ncase/morphimP=> x Dx Ax ->{fx}; case/morphimP=> y Dy By ->{fy} -> {fz}.\nby exists [~ x, y]; rewrite ?(inE, morphR, groupR, imset2_f).\nQed.",
    "Lemma morphim_norm A : f @* 'N(A) \\subset 'N(f @* A).\nProof.\napply/subsetP=> fx; case/morphimP=> x Dx Nx -> {fx}.\nby rewrite inE -morphimJ ?(normP Nx).\nQed.",
    "Lemma morphim_norms A B : A \\subset 'N(B) -> f @* A \\subset 'N(f @* B).\nProof.\nby move=> nBA; apply: subset_trans (morphim_norm B); apply: morphimS.\nQed.",
    "Lemma morphim_subnorm A B : f @* 'N_A(B) \\subset 'N_(f @* A)(f @* B).\nProof. exact: subset_trans (morphimI A _) (setIS _ (morphim_norm B)). Qed.",
    "Lemma morphim_normal A B : A <| B -> f @* A <| f @* B.\nProof. by case/andP=> sAB nAB; rewrite /(_ <| _) morphimS // morphim_norms. Qed.",
    "Lemma morphim_cent1 x : x \\in D -> f @* 'C[x] \\subset 'C[f x].\nProof. by move=> Dx; rewrite -(morphim_set1 Dx) morphim_norm. Qed.",
    "Lemma morphim_cent1s A x : x \\in D -> A \\subset 'C[x] -> f @* A \\subset 'C[f x].\nProof.\nby move=> Dx cAx; apply: subset_trans (morphim_cent1 Dx); apply: morphimS.\nQed.",
    "Lemma morphim_subcent1 A x : x \\in D -> f @* 'C_A[x] \\subset 'C_(f @* A)[f x].\nProof. by move=> Dx; rewrite -(morphim_set1 Dx) morphim_subnorm. Qed.",
    "Lemma morphim_cent A : f @* 'C(A) \\subset 'C(f @* A).\nProof.\napply/bigcapsP=> fx; case/morphimP=> x Dx Ax ->{fx}.\nby apply: subset_trans (morphim_cent1 Dx); apply: morphimS; apply: bigcap_inf.\nQed.",
    "Lemma morphim_cents A B : A \\subset 'C(B) -> f @* A \\subset 'C(f @* B).\nProof.\nby move=> cBA; apply: subset_trans (morphim_cent B); apply: morphimS.\nQed.",
    "Lemma morphim_subcent A B : f @* 'C_A(B) \\subset 'C_(f @* A)(f @* B).\nProof. exact: subset_trans (morphimI A _) (setIS _ (morphim_cent B)). Qed.",
    "Lemma morphim_abelian A : abelian A -> abelian (f @* A).\nProof. exact: morphim_cents. Qed.",
    "Lemma morphpre_norm R : f @*^-1 'N(R) \\subset 'N(f @*^-1 R).\nProof.\nby apply/subsetP=> x /[!inE] /andP[Dx Nfx]; rewrite -morphpreJ ?morphpreS.\nQed.",
    "Lemma morphpre_norms R S : R \\subset 'N(S) -> f @*^-1 R \\subset 'N(f @*^-1 S).\nProof.\nby move=> nSR; apply: subset_trans (morphpre_norm S); apply: morphpreS.\nQed.",
    "Lemma morphpre_normal R S :\n  R \\subset f @* D -> S \\subset f @* D -> (f @*^-1 R <| f @*^-1 S) = (R <| S).\nProof.\nmove=> sRfD sSfD; apply/idP/andP=> [|[sRS nSR]].\n  by move/morphim_normal; rewrite !morphpreK //; case/andP.\nby rewrite /(_ <| _) (subset_trans _ (morphpre_norm _)) morphpreS.\nQed.",
    "Lemma morphpre_subnorm R S : f @*^-1 'N_R(S) \\subset 'N_(f @*^-1 R)(f @*^-1 S).\nProof. by rewrite morphpreI setIS ?morphpre_norm. Qed.",
    "Lemma morphim_normG G :\n  'ker f \\subset G -> G \\subset D -> f @* 'N(G) = 'N_(f @* D)(f @* G).\nProof.\nmove=> sKG sGD; apply/eqP; rewrite eqEsubset -{1}morphimIdom morphim_subnorm.\nrewrite -(morphpreK (subsetIl _ _)) morphimS //= morphpreI subIset // orbC.\nby rewrite -{2}(morphimGK sKG sGD) morphpre_norm.\nQed.",
    "Lemma morphim_subnormG A G :\n  'ker f \\subset G -> G \\subset D -> f @* 'N_A(G) = 'N_(f @* A)(f @* G).\nProof.\nmove=> sKB sBD; rewrite morphimIG ?normsG // morphim_normG //.\nby rewrite setICA setIA morphimIim.\nQed.",
    "Lemma morphpre_cent1 x : x \\in D -> 'C_D[x] \\subset f @*^-1 'C[f x].\nProof.\nmove=> Dx; rewrite -sub_morphim_pre ?subsetIl //.\nby apply: subset_trans (morphim_cent1 Dx); rewrite morphimS ?subsetIr.\nQed.",
    "Lemma morphpre_cent1s R x :\n  x \\in D -> R \\subset f @* D -> f @*^-1 R \\subset 'C[x] -> R \\subset 'C[f x].\nProof. by move=> Dx sRfD; move/(morphim_cent1s Dx); rewrite morphpreK. Qed.",
    "Lemma morphpre_subcent1 R x :\n  x \\in D -> 'C_(f @*^-1 R)[x] \\subset f @*^-1 'C_R[f x].\nProof.\nmove=> Dx; rewrite -morphpreIdom -setIA setICA morphpreI setIS //.\nexact: morphpre_cent1.\nQed.",
    "Lemma morphpre_cent A : 'C_D(A) \\subset f @*^-1 'C(f @* A).\nProof.\nrewrite -sub_morphim_pre ?subsetIl // morphimGI ?(subsetIl, subIset) // orbC.\nby rewrite (subset_trans (morphim_cent _)).\nQed.",
    "Lemma morphpre_cents A R :\n  R \\subset f @* D -> f @*^-1 R \\subset 'C(A) -> R \\subset 'C(f @* A).\nProof. by move=> sRfD; move/morphim_cents; rewrite morphpreK. Qed.",
    "Lemma morphpre_subcent R A : 'C_(f @*^-1 R)(A) \\subset f @*^-1 'C_R(f @* A).\nProof.\nby rewrite -morphpreIdom -setIA setICA morphpreI setIS //; apply: morphpre_cent.\nQed.",
    "Lemma injmP : reflect {in D &, injective f} ('injm f).\nProof.\napply: (iffP subsetP) => [injf x y Dx Dy | injf x /= Kx].\n  by case/ker_rcoset=> // z /injf/set1P->; rewrite mul1g.\nhave Dx := dom_ker Kx; apply/set1P/injf => //.\nby apply/rcoset_kerP; rewrite // mulg1.\nQed.",
    "Lemma card_im_injm : (#|f @* D| == #|D|) = 'injm f.\nProof. by rewrite morphimEdom (sameP imset_injP injmP). Qed.",
    "Lemma ker_injm : 'ker f = 1.\nProof. exact/trivgP. Qed.",
    "Lemma injmK A : A \\subset D -> f @*^-1 (f @* A) = A.\nProof. by move=> sAD; rewrite morphimK // ker_injm // mul1g. Qed.",
    "Lemma injm_morphim_inj A B :\n  A \\subset D -> B \\subset D -> f @* A = f @* B -> A = B.\nProof. by move=> sAD sBD eqAB; rewrite -(injmK sAD) eqAB injmK. Qed.",
    "Lemma card_injm A : A \\subset D -> #|f @* A| = #|A|.\nProof.\nmove=> sAD; rewrite morphimEsub // card_in_imset //.\nexact: (sub_in2 (subsetP sAD) (injmP injf)).\nQed.",
    "Lemma order_injm x : x \\in D -> #[f x] = #[x].\nProof.\nby move=> Dx; rewrite orderE -morphim_cycle // card_injm ?cycle_subG.\nQed.",
    "Lemma injm1 x : x \\in D -> f x = 1 -> x = 1.\nProof. by move=> Dx; move/(kerP Dx); rewrite ker_injm; move/set1P. Qed.",
    "Lemma morph_injm_eq1 x : x \\in D -> (f x == 1) = (x == 1).\nProof. by move=> Dx; rewrite -morph1 (inj_in_eq (injmP injf)) ?group1. Qed.",
    "Lemma injmSK A B :\n  A \\subset D -> (f @* A \\subset f @* B) = (A \\subset B).\nProof. by move=> sAD; rewrite morphimSK // ker_injm mul1g. Qed.",
    "Lemma sub_morphpre_injm R A :\n    A \\subset D -> R \\subset f @* D ->\n  (f @*^-1 R \\subset A) = (R \\subset f @* A).\nProof. by move=> sAD sRfD; rewrite -morphpreSK ?injmK. Qed.",
    "Lemma injm_eq A B : A \\subset D -> B \\subset D -> (f @* A == f @* B) = (A == B).\nProof. by move=> sAD sBD; rewrite !eqEsubset !injmSK. Qed.",
    "Lemma morphim_injm_eq1 A : A \\subset D -> (f @* A == 1) = (A == 1).\nProof. by move=> sAD; rewrite -morphim1 injm_eq ?sub1G. Qed.",
    "Lemma injmI A B : f @* (A :&: B) = f @* A :&: f @* B.\nProof.\nrewrite -morphimIdom setIIr -4!(injmK (subsetIl D _), =^~ morphimIdom).\nby rewrite -morphpreI morphpreK // subIset ?morphim_sub.\nQed.",
    "Lemma injmD1 A : f @* A^# = (f @* A)^#.\nProof. by have:= morphimDG A injf; rewrite morphim1. Qed.",
    "Lemma nclasses_injm A : A \\subset D -> #|classes (f @* A)| = #|classes A|.\nProof.\nmove=> sAD; rewrite classes_morphim // card_in_imset //.\nmove=> _ _ /imsetP[x Ax ->] /imsetP[y Ay ->].\nby apply: injm_morphim_inj; rewrite // class_subG ?(subsetP sAD).\nQed.",
    "Lemma injm_norm A : A \\subset D -> f @* 'N(A) = 'N_(f @* D)(f @* A).\nProof.\nmove=> sAD; apply/eqP; rewrite -morphimIdom eqEsubset morphim_subnorm.\nrewrite -sub_morphpre_injm ?subsetIl // morphpreI injmK // setIS //.\nby rewrite -{2}(injmK sAD) morphpre_norm.\nQed.",
    "Lemma injm_norms A B :\n  A \\subset D -> B \\subset D -> (f @* A \\subset 'N(f @* B)) = (A \\subset 'N(B)).\nProof. by move=> sAD sBD; rewrite -injmSK // injm_norm // subsetI morphimS. Qed.",
    "Lemma injm_normal A B :\n  A \\subset D -> B \\subset D -> (f @* A <| f @* B) = (A <| B).\nProof. by move=> sAD sBD; rewrite /normal injmSK ?injm_norms. Qed.",
    "Lemma injm_subnorm A B : B \\subset D -> f @* 'N_A(B) = 'N_(f @* A)(f @* B).\nProof. by move=> sBD; rewrite injmI injm_norm // setICA setIA morphimIim. Qed.",
    "Lemma injm_cent1 x : x \\in D -> f @* 'C[x] = 'C_(f @* D)[f x].\nProof. by move=> Dx; rewrite injm_norm ?morphim_set1 ?sub1set. Qed.",
    "Lemma injm_subcent1 A x : x \\in D -> f @* 'C_A[x] = 'C_(f @* A)[f x].\nProof. by move=> Dx; rewrite injm_subnorm ?morphim_set1 ?sub1set. Qed.",
    "Lemma injm_cent A : A \\subset D -> f @* 'C(A) = 'C_(f @* D)(f @* A).\nProof.\nmove=> sAD; apply/eqP; rewrite -morphimIdom eqEsubset morphim_subcent.\napply/subsetP=> fx; case/setIP; case/morphimP=> x Dx _ ->{fx} cAfx.\nrewrite mem_morphim // inE Dx -sub1set centsC cent_set1 -injmSK //.\nby rewrite injm_cent1 // subsetI morphimS // -cent_set1 centsC sub1set.\nQed.",
    "Lemma injm_cents A B :\n  A \\subset D -> B \\subset D -> (f @* A \\subset 'C(f @* B)) = (A \\subset 'C(B)).\nProof. by move=> sAD sBD; rewrite -injmSK // injm_cent // subsetI morphimS. Qed.",
    "Lemma injm_subcent A B : B \\subset D -> f @* 'C_A(B) = 'C_(f @* A)(f @* B).\nProof. by move=> sBD; rewrite injmI injm_cent // setICA setIA morphimIim. Qed.",
    "Lemma injm_abelian A : A \\subset D -> abelian (f @* A) = abelian A.\nProof.\nby move=> sAD; rewrite /abelian -subsetIidl -injm_subcent // injmSK ?subsetIidl.\nQed.",
    "Lemma eq_morphim (g : {morphism D >-> rT}):\n  {in D, f =1 g} -> forall A, f @* A = g @* A.\nProof.\nby move=> efg A; apply: eq_in_imset; apply: sub_in1 efg => x /setIP[].\nQed.",
    "Lemma eq_in_morphim B A (g : {morphism B >-> rT}) :\n  D :&: A = B :&: A -> {in A, f =1 g} -> f @* A = g @* A.\nProof.\nmove=> eqDBA eqAfg; rewrite /morphim /= eqDBA.\nby apply: eq_in_imset => x /setIP[_]/eqAfg.\nQed.",
    "Lemma idm_morphM A : {in A & , {morph idm A : x y / x * y}}.\nProof. by []. Qed.",
    "Lemma injm_idm G : 'injm (idm G).\nProof. by apply/injmP=> x y _ _. Qed.",
    "Lemma ker_idm G : 'ker (idm G) = 1.\nProof. by apply/trivgP; apply: injm_idm. Qed.",
    "Lemma morphim_idm A B : B \\subset A -> idm A @* B = B.\nProof.\nrewrite /morphim /= /idm => /setIidPr->.\nby apply/setP=> x; apply/imsetP/idP=> [[y By ->]|Bx]; last exists x.\nQed.",
    "Lemma morphpre_idm A B : idm A @*^-1 B = A :&: B.\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma im_idm A : idm A @* A = A.\nProof. exact: morphim_idm. Qed.",
    "Lemma morphim_restrm B : fA @* B = f @* (A :&: B).\nProof. by rewrite {2}/morphim setIA (setIidPr sAD). Qed.",
    "Lemma restrmEsub B : B \\subset A -> fA @* B = f @* B.\nProof. by rewrite morphim_restrm => /setIidPr->. Qed.",
    "Lemma im_restrm : fA @* A = f @* A.\nProof. exact: restrmEsub. Qed.",
    "Lemma morphpre_restrm R : fA @*^-1 R = A :&: f @*^-1 R.\nProof. by rewrite setIA (setIidPl sAD). Qed.",
    "Lemma ker_restrm : 'ker fA = 'ker_A f.\nProof. exact: morphpre_restrm. Qed.",
    "Lemma injm_restrm : 'injm f -> 'injm fA.\nProof. by apply: subset_trans; rewrite ker_restrm subsetIr. Qed.",
    "Lemma restrmP (f : {morphism D >-> rT}) : A \\subset 'dom f ->\n  {g : {morphism A >-> rT} | [/\\ g = f :> (aT -> rT), 'ker g = 'ker_A f,\n                                 forall R, g @*^-1 R = A :&: f @*^-1 R\n                               & forall B, B \\subset A -> g @* B = f @* B]}.\nProof.\nmove=> sAD; exists (restrm_morphism sAD f).\nsplit=> // [|R|B sBA]; first 1 [exact: ker_restrm | exact: morphpre_restrm].\nby rewrite morphim_restrm (setIidPr sBA).\nQed.",
    "Lemma domP (f : {morphism D >-> rT}) : 'dom f = A ->\n  {g : {morphism A >-> rT} | [/\\ g = f :> (aT -> rT), 'ker g = 'ker f,\n                                 forall R, g @*^-1 R = f @*^-1 R\n                               & forall B, g @* B = f @* B]}.\nProof. by move <-; exists f. Qed.",
    "Lemma trivm_morphM (A : {set aT}) : {in A &, {morph trivm A : x y / x * y}}.\nProof. by move=> x y /=; rewrite mulg1. Qed.",
    "Lemma morphim_trivm (G H : {group aT}) : trivm G @* H = 1.\nProof.\napply/setP=> /= y; rewrite inE; apply/idP/eqP=> [|->]; first by case/morphimP.\nby apply/morphimP; exists (1 : aT); rewrite /= ?group1.\nQed.",
    "Lemma ker_trivm (G : {group aT}) : 'ker (trivm G) = G.\nProof. by apply/setIidPl/subsetP=> x _; rewrite !inE /=. Qed.",
    "Lemma comp_morphM : {in f @*^-1 H &, {morph gof: x y / x * y}}.\nProof.\nby move=> x y; rewrite /= !inE => /andP[? ?] /andP[? ?]; rewrite !morphM.\nQed.",
    "Lemma ker_comp : 'ker gof = f @*^-1 'ker g.\nProof. by apply/setP=> x; rewrite !inE andbA. Qed.",
    "Lemma injm_comp : 'injm f -> 'injm g -> 'injm gof.\nProof. by move=> injf; rewrite ker_comp; move/trivgP=> ->. Qed.",
    "Lemma morphim_comp (A : {set gT}) : gof @* A = g @* (f @* A).\nProof.\napply/setP=> z; apply/morphimP/morphimP=> [[x]|[y Hy fAy ->{z}]].\n  rewrite !inE => /andP[Gx Hfx]; exists (f x) => //.\n  by apply/morphimP; exists x.\nby case/morphimP: fAy Hy => x Gx Ax ->{y} Hfx; exists x; rewrite ?inE ?Gx.\nQed.",
    "Lemma morphpre_comp (C : {set rT}) : gof @*^-1 C = f @*^-1 (g @*^-1 C).\nProof. by apply/setP=> z; rewrite !inE andbA. Qed.",
    "Lemma factmE x : x \\in G -> ff (q x) = f x.\nProof.\nrewrite /ff => Gx; have Hx := subsetP sGH x Gx.\nhave /mem_repr: x \\in q @*^-1 [set q x] by rewrite !inE Hx /=.\ncase/morphpreP; move: (repr _) => y Hy /set1P.\nby case/ker_rcoset=> // z Kz ->; rewrite mkerl ?(subsetP sKqKf).\nQed.",
    "Lemma factm_morphM : {in q @* G &, {morph ff : x y / x * y}}.\nProof.\nmove=> _ _ /morphimP[x Hx Gx ->] /morphimP[y Hy Gy ->].\nby rewrite -morphM ?factmE ?groupM // morphM.\nQed.",
    "Lemma morphim_factm (A : {set aT}) : ff @* (q @* A) = f @* A.\nProof.\nrewrite -morphim_comp /= {1}/morphim /= morphimGK //; last first.\n  by rewrite (subset_trans sKqKf) ?subsetIl.\napply/setP=> y; apply/morphimP/morphimP;\n  by case=> x Gx Ax ->{y}; exists x; rewrite //= factmE.\nQed.",
    "Lemma morphpre_factm (C : {set rT}) : ff @*^-1 C =  q @* (f @*^-1 C).\nProof.\napply/setP=> y /[!inE]/=; apply/andP/morphimP=> [[]|[x Hx]]; last first.\n  by case/morphpreP=> Gx Cfx ->; rewrite factmE ?imset_f ?inE ?Hx.\ncase/morphimP=> x Hx Gx ->; rewrite factmE //.\nby exists x; rewrite // !inE Gx.\nQed.",
    "Lemma ker_factm : 'ker ff = q @* 'ker f.\nProof. exact: morphpre_factm. Qed.",
    "Lemma injm_factm : 'injm f -> 'injm ff.\nProof. by rewrite ker_factm => /trivgP->; rewrite morphim1. Qed.",
    "Lemma injm_factmP : reflect ('ker f = 'ker q) ('injm ff).\nProof.\nrewrite ker_factm -morphimIdom sub_morphim_pre ?subsetIl //.\nrewrite setIA (setIidPr sGH) (sameP setIidPr eqP) (setIidPl _) // eq_sym.\nexact: eqP.\nQed.",
    "Lemma ker_factm_loc (K : {group aT}) : 'ker_(q @* K) ff = q @* 'ker_K f.\nProof. by rewrite ker_factm -morphimIG. Qed.",
    "Lemma invm_subker : 'ker f \\subset 'ker (idm G).\nProof. by rewrite ker_idm. Qed.",
    "Lemma invmE : {in G, cancel f invm}.\nProof. exact: factmE. Qed.",
    "Lemma invmK : {in f @* G, cancel invm f}.\nProof. by move=> fx; case/morphimP=> x _ Gx ->; rewrite invmE. Qed.",
    "Lemma morphpre_invm A : invm @*^-1 A = f @* A.\nProof. by rewrite morphpre_factm morphpre_idm morphimIdom. Qed.",
    "Lemma morphim_invm A : A \\subset G -> invm @* (f @* A) = A.\nProof. by move=> sAG; rewrite morphim_factm morphim_idm. Qed.",
    "Lemma morphim_invmE C : invm @* C = f @*^-1 C.\nProof.\nrewrite -morphpreIdom -(morphim_invm (subsetIl _ _)).\nby rewrite morphimIdom -morphpreIim morphpreK (subsetIl, morphimIdom).\nQed.",
    "Lemma injm_proper A B :\n  A \\subset G -> B \\subset G -> (f @* A \\proper f @* B) = (A \\proper B).\nProof.\nmove=> dA dB; rewrite -morphpre_invm -(morphpre_invm B).\nby rewrite morphpre_proper ?morphim_invm.\nQed.",
    "Lemma injm_invm : 'injm invm.\nProof. by move/can_in_inj/injmP: invmK. Qed.",
    "Lemma ker_invm : 'ker invm = 1.\nProof. by move/trivgP: injm_invm. Qed.",
    "Lemma im_invm : invm @* (f @* G) = G.\nProof. exact: morphim_invm. Qed.",
    "Lemma ifactmE : {in D, forall x, ifactm (f x) = g x}.\nProof.\nrewrite /ifactm => x Dx; case: domP => f' /= [def_f' _ _ _].\nby rewrite {f'}def_f' //= invmE.\nQed.",
    "Lemma morphim_ifactm (A : {set gT}) :\n   A \\subset D -> ifactm @* (f @* A) = g @* A.\nProof.\nrewrite /ifactm => sAD; case: domP => _ /= [_ _ _ ->].\nby rewrite morphim_comp morphim_invm.\nQed.",
    "Lemma im_ifactm : G \\subset D -> ifactm @* (f @* G) = g @* G.\nProof. exact: morphim_ifactm. Qed.",
    "Lemma morphpre_ifactm C : ifactm @*^-1 C = f @* (g @*^-1 C).\nProof.\nrewrite /ifactm; case: domP => _ /= [_ _ -> _].\nby rewrite morphpre_comp morphpre_invm.\nQed.",
    "Lemma ker_ifactm : 'ker ifactm = f @* 'ker g.\nProof. exact: morphpre_ifactm. Qed.",
    "Lemma injm_ifactm : 'injm g -> 'injm ifactm.\nProof. by rewrite ker_ifactm => /trivgP->; rewrite morphim1. Qed.",
    "Lemma morphicP : reflect {in A &, {morph f : x y / x * y}} (morphic f).\nProof.\napply: (iffP forallP) => [fM x y Ax Ay | fM [x y] /=].\n  by apply/eqP; have:= fM (x, y); rewrite inE /= Ax Ay.\nby apply/implyP=> /andP[Ax Ay]; rewrite fM.\nQed.",
    "Lemma morphmE fM : morphm fM = f. Proof. by []. Qed.",
    "Lemma misomP f : reflect {fM : morphic f & isom (morphm fM)} (misom f).\nProof. by apply: (iffP andP) => [] [fM fiso] //; exists fM. Qed.",
    "Lemma misom_isog f : misom f -> isog.\nProof.\ncase/andP=> fM iso_f; apply/existsP; exists (finfun f).\napply/andP; split; last by rewrite /misom /isom !(eq_imset _ (ffunE f)).\nby apply/forallP=> u; rewrite !ffunE; apply: forallP fM u.\nQed.",
    "Lemma isom_isog (D : {group aT}) (f : {morphism D >-> rT}) :\n  A \\subset D -> isom f -> isog.\nProof.\nmove=> sAD isof; apply: (@misom_isog f); rewrite /misom isof andbT.\nby apply/morphicP; apply: (sub_in2 (subsetP sAD) (morphM f)).\nQed.",
    "Lemma isog_isom : isog -> {f : {morphism A >-> rT} | isom f}.\nProof.\nby case/existsP/sigW=> f /misomP[fM isom_f]; exists (morphm_morphism fM).\nQed.",
    "Lemma isomP (f : {morphism G >-> rT}) :\n  reflect ('injm f /\\ f @* G = H) (isom G H f).\nProof.\napply: (iffP eqP) => [eqfGH | [injf <-]]; last first.\n  by rewrite -injmD1 // morphimEsub ?subsetDl.\nsplit.\n  apply/subsetP=> x /morphpreP[Gx fx1]; have: f x \\notin H^# by rewrite inE fx1.\n  by apply: contraR => ntx; rewrite -eqfGH imset_f // inE ntx.\nrewrite morphimEdom -{2}(setD1K (group1 G)) imsetU eqfGH.\nby rewrite imset_set1 morph1 setD1K.\nQed.",
    "Lemma isogP :\n  reflect (exists2 f : {morphism G >-> rT}, 'injm f & f @* G = H) (G \\isog H).\nProof.\napply: (iffP idP) => [/isog_isom[f /isomP[]] | [f injf fG]]; first by exists f.\nby apply: (isom_isog f) => //; apply/isomP.\nQed.",
    "Lemma isom_inj : 'injm f. Proof. by have /isomP[] := isoGH. Qed.",
    "Lemma isom_im : f @* G = H. Proof. by have /isomP[] := isoGH. Qed.",
    "Lemma isom_card : #|G| = #|H|.\nProof. by rewrite -isom_im card_injm ?isom_inj. Qed.",
    "Lemma isom_sub_im : H \\subset f @* G. Proof. by rewrite isom_im. Qed.",
    "Lemma morphim_isom (H : {group aT}) (K : {group rT}) :\n  H \\subset G -> isom H K f -> f @* H = K.\nProof. by case/(restrmP f)=> g [gf _ _ <- //]; rewrite -gf; case/isomP. Qed.",
    "Lemma sub_isom (A : {set aT}) (C : {set rT}) :\n  A \\subset G -> f @* A = C -> 'injm f -> isom A C f.\nProof.\nmove=> sAG; case: (restrmP f sAG) => g [_ _ _ img] <-{C} injf.\nrewrite /isom -morphimEsub ?morphimDG ?morphim1 //.\nby rewrite subDset setUC subsetU ?sAG.\nQed.",
    "Lemma sub_isog (A : {set aT}) : A \\subset G -> 'injm f -> isog A (f @* A).\nProof. by move=> sAG injf; apply: (isom_isog f sAG); apply: sub_isom. Qed.",
    "Lemma restr_isom_to (A : {set aT}) (C R : {group rT}) (sAG : A \\subset G) :\n   f @* A = C -> isom G R f -> isom A C (restrm sAG f).\nProof. by move=> defC /isomP[inj_f _]; apply: sub_isom. Qed.",
    "Lemma restr_isom (A : {group aT}) (R : {group rT}) (sAG : A \\subset G) :\n  isom G R f -> isom A (f @* A) (restrm sAG f).\nProof. exact: restr_isom_to. Qed.",
    "Lemma idm_isom : isom G G (idm G).\nProof. exact: sub_isom (im_idm G) (injm_idm G). Qed.",
    "Lemma isog_refl : G \\isog G. Proof. exact: isom_isog idm_isom. Qed.",
    "Lemma card_isog : G \\isog H -> #|G| = #|H|.\nProof. by case/isogP=> f injf <-; apply: isom_card (f) _; apply/isomP. Qed.",
    "Lemma isog_abelian :  G \\isog H -> abelian G = abelian H.\nProof. by case/isogP=> f injf <-; rewrite injm_abelian. Qed.",
    "Lemma trivial_isog : G :=: 1 -> H :=: 1 -> G \\isog H.\nProof.\nmove=> -> ->; apply/isogP.\nexists [morphism of @trivm gT hT 1]; rewrite /= ?morphim1 //.\nby rewrite ker_trivm; apply: subxx.\nQed.",
    "Lemma isog_eq1 : G \\isog H -> (G :==: 1) = (H :==: 1).\nProof. by move=> isoGH; rewrite !trivg_card1 card_isog. Qed.",
    "Lemma isom_sym (f : {morphism G >-> hT}) (isoGH : isom G H f) :\n  isom H G (isom_inv isoGH).\nProof.\nrewrite sub_isom 1?injm_restrm ?injm_invm // im_restrm.\nby rewrite -(isom_im isoGH) im_invm.\nQed.",
    "Lemma isog_symr : G \\isog H -> H \\isog G.\nProof. by case/isog_isom=> f /isom_sym/isom_isog->. Qed.",
    "Lemma isog_trans : G \\isog H -> H \\isog K -> G \\isog K.\nProof.\ncase/isogP=> f injf <-; case/isogP=> g injg <-.\nhave defG: f @*^-1 (f @* G) = G by rewrite morphimGK ?subsetIl.\nrewrite -morphim_comp -{1 8}defG.\nby apply/isogP; exists [morphism of g \\o f]; rewrite ?injm_comp.\nQed.",
    "Lemma nclasses_isog : G \\isog H -> #|classes G| = #|classes H|.\nProof. by case/isogP=> f injf <-; rewrite nclasses_injm. Qed.",
    "Lemma isog_sym : (G \\isog H) = (H \\isog G).\nProof. by apply/idP/idP; apply: isog_symr. Qed.",
    "Lemma isog_transl : G \\isog H -> (G \\isog K) = (H \\isog K).\nProof.\nby move=> iso; apply/idP/idP; apply: isog_trans; rewrite // -isog_sym.\nQed.",
    "Lemma isog_transr : G \\isog H -> (K \\isog G) = (K \\isog H).\nProof.\nby move=> iso; apply/idP/idP; move/isog_trans; apply; rewrite // -isog_sym.\nQed.",
    "Lemma homgP rT aT (C : {set rT}) (D : {set aT}) : \n  reflect (exists f : {morphism D >-> rT}, f @* D = C) (homg C D).\nProof.\napply: (iffP exists_eq_inP) => [[f fM <-] | [f <-]].\n  by exists (morphm_morphism fM); rewrite /morphim /= setIid.\nexists (finfun f); first by apply/morphicP=> x y Dx Dy; rewrite !ffunE morphM.\nby rewrite /morphim setIid; apply: eq_imset => x; rewrite ffunE.\nQed.",
    "Lemma morphim_homg aT rT (A D : {set aT}) (f : {morphism D >-> rT}) :\n  A \\subset D -> homg (f @* A) A.\nProof.\nmove=> sAD; apply/homgP; exists (restrm_morphism sAD f).\nby rewrite morphim_restrm setIid.\nQed.",
    "Lemma leq_homg rT aT (C : {set rT}) (G : {group aT}) :\n  homg C G -> #|C| <= #|G|.\nProof. by case/homgP=> f <-; apply: leq_morphim. Qed.",
    "Lemma homg_refl aT (A : {set aT}) : homg A A.\nProof. by apply/homgP; exists (idm_morphism A); rewrite im_idm. Qed.",
    "Lemma homg_trans aT (B : {set aT}) rT (C : {set rT}) gT (G : {group gT}) :\n  homg C B -> homg B G -> homg C G.\nProof.\nmove=> homCB homBG; case/homgP: homBG homCB => fG <- /homgP[fK <-].\nby rewrite -morphim_comp morphim_homg // -sub_morphim_pre.\nQed.",
    "Lemma isogEcard rT aT (G : {group rT}) (H : {group aT}) :\n  (G \\isog H) = (homg G H) && (#|H| <= #|G|).\nProof.\nrewrite isog_sym; apply/isogP/andP=> [[f injf <-] | []].\n  by rewrite leq_eqVlt eq_sym card_im_injm injf morphim_homg.\ncase/homgP=> f <-; rewrite leq_eqVlt eq_sym card_im_injm.\nby rewrite ltnNge leq_morphim orbF; exists f.\nQed.",
    "Lemma isog_hom rT aT (G : {group rT}) (H : {group aT}) : G \\isog H -> homg G H.\nProof. by rewrite isogEcard; case/andP. Qed.",
    "Lemma isogEhom rT aT (G : {group rT}) (H : {group aT}) :\n  (G \\isog H) = homg G H && homg H G.\nProof.\napply/idP/andP=> [isoGH | [homGH homHG]].\n  by rewrite !isog_hom // isog_sym.\nby rewrite isogEcard homGH leq_homg.\nQed.",
    "Lemma eq_homgl gT aT rT (G : {group gT}) (H : {group aT}) (K : {group rT}) :\n  G \\isog H -> homg G K = homg H K.\nProof.\nby rewrite isogEhom => /andP[homGH homHG]; apply/idP/idP; apply: homg_trans.\nQed.",
    "Lemma eq_homgr gT rT aT (G : {group gT}) (H : {group rT}) (K : {group aT}) :\n  G \\isog H -> homg K G = homg K H.\nProof.\nrewrite isogEhom => /andP[homGH homHG].\nby apply/idP/idP=> homK; apply: homg_trans homK _.\nQed.",
    "Lemma injm_sgval : 'injm sgval.\nProof. exact/injmP/(in2W subg_inj). Qed.",
    "Lemma injm_subg : 'injm (subg G).\nProof. exact/injmP/(can_in_inj subgK). Qed.",
    "Lemma ker_sgval : 'ker sgval = 1. Proof. exact/trivgP. Qed.",
    "Lemma ker_subg : 'ker (subg G) = 1. Proof. exact/trivgP. Qed.",
    "Lemma im_subg : subg G @* G = [subg G].\nProof.\napply/eqP; rewrite -subTset morphimEdom.\nby apply/subsetP=> u _; rewrite -(sgvalK u) imset_f ?subgP.\nQed.",
    "Lemma sgval_sub A : sgval @* A \\subset G.\nProof. by apply/subsetP=> x; case/imsetP=> u _ ->; apply: subgP. Qed.",
    "Lemma sgvalmK A : subg G @* (sgval @* A) = A.\nProof.\napply/eqP; rewrite eqEcard !card_injm ?subsetT ?sgval_sub // leqnn andbT.\nrewrite -morphim_comp; apply/subsetP=> _ /morphimP[v _ Av ->] /=.\nby rewrite sgvalK.\nQed.",
    "Lemma subgmK (A : {set gT}) : A \\subset G -> sgval @* (subg G @* A) = A.\nProof.\nmove=> sAG; apply/eqP; rewrite eqEcard !card_injm ?subsetT //.\nrewrite leqnn andbT -morphim_comp morphimE /= morphpreT.\nby apply/subsetP=> _ /morphimP[v Gv Av ->] /=; rewrite subgK.\nQed.",
    "Lemma im_sgval : sgval @* [subg G] = G.\nProof. by rewrite -{2}im_subg subgmK. Qed.",
    "Lemma isom_subg : isom G [subg G] (subg G).\nProof. by apply/isomP; rewrite im_subg. Qed.",
    "Lemma isom_sgval : isom [subg G] G sgval.\nProof. by apply/isomP; rewrite im_sgval. Qed.",
    "Lemma isog_subg : isog G [subg G].\nProof. exact: isom_isog isom_subg. Qed.",
    "Lemma is_total_action : is_action setT to.\nProof.\nsplit=> [a | x a b _ _] /=; last by rewrite toM.\nby apply: can_inj (to^~ a^-1) _ => x; rewrite -toM ?mulgV.\nQed.",
    "Lemma act_inj : left_injective to. Proof. by case: to => ? []. Qed.",
    "Lemma actMin x : {in D &, act_morph to x}.\nProof. by case: to => ? []. Qed.",
    "Lemma actmEfun a : a \\in D -> actm to a = to^~ a.\nProof. by rewrite /actm => ->. Qed.",
    "Lemma actmE a : a \\in D -> actm to a =1 to^~ a.\nProof. by move=> Da; rewrite actmEfun. Qed.",
    "Lemma setactE S a : to^* S a = [set to x a | x in S].\nProof. by []. Qed.",
    "Lemma mem_setact S a x : x \\in S -> to x a \\in to^* S a.\nProof. exact: imset_f. Qed.",
    "Lemma card_setact S a : #|to^* S a| = #|S|.\nProof. by apply: card_imset; apply: act_inj. Qed.",
    "Lemma setact_is_action : is_action D to^*.\nProof.\nsplit=> [a R S eqRS | a b Da Db S]; last first.\n  by rewrite /setact /= -imset_comp; apply: eq_imset => x; apply: actMin.\napply/setP=> x; apply/idP/idP=> /(mem_setact a).\n  by rewrite eqRS => /imsetP[y Sy /act_inj->].\nby rewrite -eqRS => /imsetP[y Sy /act_inj->].\nQed.",
    "Lemma orbitE A x : orbit to A x = to x @: A. Proof. by []. Qed.",
    "Lemma orbitP A x y :\n  reflect (exists2 a, a \\in A & to x a = y) (y \\in orbit to A x).\nProof. by apply: (iffP imsetP) => [] [a]; exists a. Qed.",
    "Lemma mem_orbit A x a : a \\in A -> to x a \\in orbit to A x.\nProof. exact: imset_f. Qed.",
    "Lemma afixP A x : reflect (forall a, a \\in A -> to x a = x) (x \\in 'Fix_to(A)).\nProof.\nrewrite inE; apply: (iffP subsetP) => [xfix a /xfix | xfix a Aa].\n  by rewrite inE => /eqP.\nby rewrite inE xfix.\nQed.",
    "Lemma afixS A B : A \\subset B -> 'Fix_to(B) \\subset 'Fix_to(A).\nProof. by move=> sAB; apply/subsetP=> u /[!inE]; apply: subset_trans. Qed.",
    "Lemma afixU A B : 'Fix_to(A :|: B) = 'Fix_to(A) :&: 'Fix_to(B).\nProof. by apply/setP=> x; rewrite !inE subUset. Qed.",
    "Lemma afix1P a x : reflect (to x a = x) (x \\in 'Fix_to[a]).\nProof. by rewrite inE sub1set inE; apply: eqP. Qed.",
    "Lemma astabIdom S : 'C_D(S | to) = 'C(S | to).\nProof. by rewrite setIA setIid. Qed.",
    "Lemma astab_dom S : {subset 'C(S | to) <= D}.\nProof. by move=> a /setIP[]. Qed.",
    "Lemma astab_act S a x : a \\in 'C(S | to) -> x \\in S -> to x a = x.\nProof.\nrewrite 2!inE => /andP[_ cSa] Sx; apply/eqP.\nby have /[1!inE] := subsetP cSa x Sx.\nQed.",
    "Lemma astabS S1 S2 : S1 \\subset S2 -> 'C(S2 | to) \\subset 'C(S1 | to).\nProof.\nby move=> sS12; apply/subsetP=> x /[!inE] /andP[->]; apply: subset_trans.\nQed.",
    "Lemma astabsIdom S : 'N_D(S | to) = 'N(S | to).\nProof. by rewrite setIA setIid. Qed.",
    "Lemma astabs_dom S : {subset 'N(S | to) <= D}.\nProof. by move=> a /setIdP[]. Qed.",
    "Lemma astabs_act S a x : a \\in 'N(S | to) -> (to x a \\in S) = (x \\in S).\nProof.\nrewrite 2!inE subEproper properEcard => /andP[_].\nrewrite (card_preimset _ (act_inj _)) ltnn andbF orbF => /eqP{2}->.\nby rewrite inE.\nQed.",
    "Lemma astab_sub S : 'C(S | to) \\subset 'N(S | to).\nProof.\napply/subsetP=> a cSa; rewrite !inE (astab_dom cSa).\nby apply/subsetP=> x Sx; rewrite inE (astab_act cSa).\nQed.",
    "Lemma astabsC S : 'N(~: S | to) = 'N(S | to).\nProof.\napply/setP=> a; apply/idP/idP=> nSa; rewrite !inE (astabs_dom nSa).\n  by rewrite -setCS -preimsetC; apply/subsetP=> x; rewrite inE astabs_act.\nby rewrite preimsetC setCS; apply/subsetP=> x; rewrite inE astabs_act.\nQed.",
    "Lemma astabsI S T : 'N(S | to) :&: 'N(T | to) \\subset 'N(S :&: T | to).\nProof.\napply/subsetP=> a; rewrite !inE -!andbA preimsetI => /and4P[-> nSa _ nTa] /=.\nby rewrite setISS.\nQed.",
    "Lemma astabs_setact S a : a \\in 'N(S | to) -> to^* S a = S.\nProof.\nmove=> nSa; apply/eqP; rewrite eqEcard card_setact leqnn andbT.\nby apply/subsetP=> _ /imsetP[x Sx ->]; rewrite astabs_act.\nQed.",
    "Lemma astab1_set S : 'C[S | set_action] = 'N(S | to).\nProof.\napply/setP=> a; apply/idP/idP=> nSa.\n  case/setIdP: nSa => Da; rewrite !inE Da sub1set inE => /eqP defS.\n  by apply/subsetP=> x Sx; rewrite inE -defS mem_setact.\nby rewrite !inE (astabs_dom nSa) sub1set inE /= astabs_setact.\nQed.",
    "Lemma astabs_set1 x : 'N([set x] | to) = 'C[x | to].\nProof.\napply/eqP; rewrite eqEsubset astab_sub andbC setIS //.\nby apply/subsetP=> a; rewrite ?(inE,sub1set).\nQed.",
    "Lemma acts_dom A S : [acts A, on S | to] -> A \\subset D.\nProof. by move=> nSA; rewrite (subset_trans nSA) ?subsetIl. Qed.",
    "Lemma acts_act A S : [acts A, on S | to] -> {acts A, on S | to}.\nProof. by move=> nAS a Aa x; rewrite astabs_act ?(subsetP nAS). Qed.",
    "Lemma astabCin A S :\n  A \\subset D -> (A \\subset 'C(S | to)) = (S \\subset 'Fix_to(A)).\nProof.\nmove=> sAD; apply/subsetP/subsetP=> [sAC x xS | sSF a aA].\n  by apply/afixP=> a aA; apply: astab_act (sAC _ aA) xS.\nrewrite !inE (subsetP sAD _ aA); apply/subsetP=> x xS.\nby move/afixP/(_ _ aA): (sSF _ xS) => /[1!inE] ->.\nQed.",
    "Lemma astabU : 'C(S :|: T | to) = 'C(S | to) :&: 'C(T | to).\nProof. by apply/setP=> a; rewrite !inE subUset; case: (a \\in D). Qed.",
    "Lemma astabsU : 'N(S | to) :&: 'N(T | to) \\subset 'N(S :|: T | to).\nProof.\nby rewrite -(astabsC S) -(astabsC T) -(astabsC (S :|: T)) setCU astabsI.\nQed.",
    "Lemma astabsD : 'N(S | to) :&: 'N(T | to) \\subset 'N(S :\\: T| to).\nProof. by rewrite setDE -(astabsC T) astabsI. Qed.",
    "Lemma actsI : [acts A, on S :&: T | to].\nProof. by apply: subset_trans (astabsI S T); rewrite subsetI AactS. Qed.",
    "Lemma actsU : [acts A, on S :|: T | to].\nProof. by apply: subset_trans astabsU; rewrite subsetI AactS. Qed.",
    "Lemma actsD : [acts A, on S :\\: T | to].\nProof. by apply: subset_trans astabsD; rewrite subsetI AactS. Qed.",
    "Lemma acts_in_orbit A S x y :\n  [acts A, on S | to] -> y \\in orbit to A x -> x \\in S -> y \\in S.\nProof.\nby move=> nSA/imsetP[a Aa ->{y}] Sx; rewrite (astabs_act _ (subsetP nSA a Aa)).\nQed.",
    "Lemma subset_faithful A B S :\n  B \\subset A -> [faithful A, on S | to] -> [faithful B, on S | to].\nProof. by move=> sAB; apply: subset_trans; apply: setSI. Qed.",
    "Lemma reindex_astabs a F : a \\in 'N(S | to) ->\n  \\big[op/idx]_(i in S) F i = \\big[op/idx]_(i in S) F (to i a).\nProof.\nmove=> nSa; rewrite (reindex_inj (act_inj a)); apply: eq_bigl => x.\nexact: astabs_act.\nQed.",
    "Lemma reindex_acts A a F : [acts A, on S | to] -> a \\in A ->\n  \\big[op/idx]_(i in S) F i = \\big[op/idx]_(i in S) F (to i a).\nProof. by move=> nSA /(subsetP nSA); apply: reindex_astabs. Qed.",
    "Lemma act1 x : to x 1 = x.\nProof. by apply: (act_inj to 1); rewrite -actMin ?mulg1. Qed.",
    "Lemma actKin : {in D, right_loop invg to}.\nProof. by move=> a Da /= x; rewrite -actMin ?groupV // mulgV act1. Qed.",
    "Lemma actKVin : {in D, rev_right_loop invg to}.\nProof. by move=> a Da /= x; rewrite -{2}(invgK a) actKin ?groupV. Qed.",
    "Lemma setactVin S a : a \\in D -> to^* S a^-1 = to^~ a @^-1: S.\nProof.\nby move=> Da; apply: can2_imset_pre; [apply: actKVin | apply: actKin].\nQed.",
    "Lemma actXin x a i : a \\in D -> to x (a ^+ i) = iter i (to^~ a) x.\nProof.\nmove=> Da; elim: i => /= [|i <-]; first by rewrite act1.\nby rewrite expgSr actMin ?groupX.\nQed.",
    "Lemma afix1 : 'Fix_to(1) = setT.\nProof. by apply/setP=> x; rewrite !inE sub1set inE act1 eqxx. Qed.",
    "Lemma afixD1 G : 'Fix_to(G^#) = 'Fix_to(G).\nProof. by rewrite -{2}(setD1K (group1 G)) afixU afix1 setTI. Qed.",
    "Lemma orbit_refl G x : x \\in orbit to G x.\nProof. by rewrite -{1}[x]act1 mem_orbit. Qed.",
    "Lemma contra_orbit G x y : x \\notin orbit to G y -> x != y.\nProof. by apply: contraNneq => ->; apply: orbit_refl. Qed.",
    "Lemma orbit_in_sym G : G \\subset D -> symmetric (orbit_rel G).\nProof.\nmove=> sGD; apply: symmetric_from_pre => x y /imsetP[a Ga].\nby move/(canLR (actKin (subsetP sGD a Ga))) <-; rewrite mem_orbit ?groupV.\nQed.",
    "Lemma orbit_in_trans G : G \\subset D -> transitive (orbit_rel G).\nProof.\nmove=> sGD _ _ z /imsetP[a Ga ->] /imsetP[b Gb ->].\nby rewrite -actMin ?mem_orbit ?groupM // (subsetP sGD).\nQed.",
    "Lemma orbit_in_eqP G x y :\n  G \\subset D -> reflect (orbit to G x = orbit to G y) (x \\in orbit to G y).\nProof.\nmove=> sGD; apply: (iffP idP) => [yGx|<-]; last exact: orbit_refl.\nby apply/setP=> z; apply/idP/idP=> /orbit_in_trans-> //; rewrite orbit_in_sym.\nQed.",
    "Lemma orbit_in_transl G x y z :\n    G \\subset D -> y \\in orbit to G x ->\n  (y \\in orbit to G z) = (x \\in orbit to G z).\nProof.\nby move=> sGD Gxy; rewrite !(orbit_in_sym sGD _ z) (orbit_in_eqP y x sGD Gxy).\nQed.",
    "Lemma orbit_act_in x a G :\n  G \\subset D -> a \\in G -> orbit to G (to x a) = orbit to G x.\nProof. by move=> sGD /mem_orbit/orbit_in_eqP->. Qed.",
    "Lemma orbit_actr_in x a G y :\n  G \\subset D -> a \\in G -> (to y a \\in orbit to G x) = (y \\in orbit to G x).\nProof. by move=> sGD /mem_orbit/orbit_in_transl->. Qed.",
    "Lemma orbit_inv_in A x y :\n  A \\subset D -> (y \\in orbit to A^-1 x) = (x \\in orbit to A y).\nProof.\nmove/subsetP=> sAD; apply/imsetP/imsetP=> [] [a Aa ->].\n  by exists a^-1; rewrite -?mem_invg ?actKin // -groupV sAD -?mem_invg.\nby exists a^-1; rewrite ?memV_invg ?actKin // sAD.\nQed.",
    "Lemma orbit_lcoset_in A a x :\n    A \\subset D -> a \\in D ->\n  orbit to (a *: A) x = orbit to A (to x a).\nProof.\nmove/subsetP=> sAD Da; apply/setP=> y; apply/imsetP/imsetP=> [] [b Ab ->{y}].\n  by exists (a^-1 * b); rewrite -?actMin ?mulKVg // ?sAD -?mem_lcoset.\nby exists (a * b); rewrite ?mem_mulg ?set11 ?actMin // sAD.\nQed.",
    "Lemma orbit_rcoset_in A a x y :\n    A \\subset D -> a \\in D ->\n  (to y a \\in orbit to (A :* a) x) = (y \\in orbit to A x).\nProof.\nmove=> sAD Da; rewrite -orbit_inv_in ?mul_subG ?sub1set // invMg.\nby rewrite invg_set1 orbit_lcoset_in ?inv_subG ?groupV ?actKin ?orbit_inv_in.\nQed.",
    "Lemma orbit_conjsg_in A a x y :\n    A \\subset D -> a \\in D ->\n  (to y a \\in orbit to (A :^ a) (to x a)) = (y \\in orbit to A x).\nProof.\nmove=> sAD Da; rewrite conjsgE.\nby rewrite orbit_lcoset_in ?groupV ?mul_subG ?sub1set ?actKin ?orbit_rcoset_in.\nQed.",
    "Lemma orbit1P G x : reflect (orbit to G x = [set x]) (x \\in 'Fix_to(G)).\nProof.\napply: (iffP afixP) => [xfix | xfix a Ga].\n  apply/eqP; rewrite eq_sym eqEsubset sub1set -{1}[x]act1 imset_f //=.\n  by apply/subsetP=> y; case/imsetP=> a Ga ->; rewrite inE xfix.\nby apply/set1P; rewrite -xfix imset_f.\nQed.",
    "Lemma card_orbit1 G x : #|orbit to G x| = 1%N -> orbit to G x = [set x].\nProof.\nmove=> orb1; apply/eqP; rewrite eq_sym eqEcard {}orb1 cards1.\nby rewrite sub1set orbit_refl.\nQed.",
    "Lemma orbit_partition G S :\n  [acts G, on S | to] -> partition (orbit to G @: S) S.\nProof.\nmove=> actsGS; have sGD := acts_dom actsGS.\nhave eqiG: {in S & &, equivalence_rel [rel x y | y \\in orbit to G x]}.\n  by move=> x y z * /=; rewrite orbit_refl; split=> // /orbit_in_eqP->.\ncongr (partition _ _): (equivalence_partitionP eqiG).\napply: eq_in_imset => x Sx; apply/setP=> y.\nby rewrite inE /= andb_idl // => /acts_in_orbit->.\nQed.",
    "Lemma orbit_transversalP G S (P := orbit to G @: S)\n                             (X := orbit_transversal G S) :\n  [acts G, on S | to] ->\n [/\\ is_transversal X P S, X \\subset S,\n     {in X &, forall x y, (y \\in orbit to G x) = (x == y)}\n   & forall x, x \\in S -> exists2 a, a \\in G & to x a \\in X].\nProof.\nmove/orbit_partition; rewrite -/P => partP.\nhave [/eqP defS tiP _] := and3P partP.\nhave trXP: is_transversal X P S := transversalP partP.\nhave sXS: X \\subset S := transversal_sub trXP.\nsplit=> // [x y Xx Xy /= | x Sx].\n  have Sx := subsetP sXS x Xx.\n  rewrite -(inj_in_eq (pblock_inj trXP)) // eq_pblock ?defS //.\n  by rewrite (def_pblock tiP (imset_f _ Sx)) ?orbit_refl.\nhave /imsetP[y Xy defxG]: orbit to G x \\in pblock P @: X.\n  by rewrite (pblock_transversal trXP) ?imset_f.\nsuffices /orbitP[a Ga def_y]: y \\in orbit to G x by exists a; rewrite ?def_y.\nby rewrite defxG mem_pblock defS (subsetP sXS).\nQed.",
    "Lemma group_set_astab S : group_set 'C(S | to).\nProof.\napply/group_setP; split=> [|a b cSa cSb].\n  by rewrite !inE group1; apply/subsetP=> x _; rewrite inE act1.\nrewrite !inE groupM ?(@astab_dom _ _ _ to S) //; apply/subsetP=> x Sx.\nby rewrite inE actMin ?(@astab_dom _ _ _ to S) ?(astab_act _ Sx).\nQed.",
    "Lemma afix_gen_in A : A \\subset D -> 'Fix_to(<<A>>) = 'Fix_to(A).\nProof.\nmove=> sAD; apply/eqP; rewrite eqEsubset afixS ?sub_gen //=.\nby rewrite -astabCin gen_subG ?astabCin.\nQed.",
    "Lemma afix_cycle_in a : a \\in D -> 'Fix_to(<[a]>) = 'Fix_to[a].\nProof. by move=> Da; rewrite afix_gen_in ?sub1set. Qed.",
    "Lemma afixYin A B :\n  A \\subset D -> B \\subset D -> 'Fix_to(A <*> B) = 'Fix_to(A) :&: 'Fix_to(B).\nProof. by move=> sAD sBD; rewrite afix_gen_in ?afixU // subUset sAD. Qed.",
    "Lemma afixMin G H :\n  G \\subset D -> H \\subset D -> 'Fix_to(G * H) = 'Fix_to(G) :&: 'Fix_to(H).\nProof.\nby move=> sGD sHD; rewrite -afix_gen_in ?mul_subG // genM_join afixYin.\nQed.",
    "Lemma sub_astab1_in A x :\n  A \\subset D -> (A \\subset 'C[x | to]) = (x \\in 'Fix_to(A)).\nProof. by move=> sAD; rewrite astabCin ?sub1set. Qed.",
    "Lemma group_set_astabs S : group_set 'N(S | to).\nProof.\napply/group_setP; split=> [|a b cSa cSb].\n  by rewrite !inE group1; apply/subsetP=> x Sx; rewrite inE act1.\nrewrite !inE groupM ?(@astabs_dom _ _ _ to S) //; apply/subsetP=> x Sx.\nby rewrite inE actMin ?(@astabs_dom _ _ _ to S) ?astabs_act.\nQed.",
    "Lemma astab_norm S : 'N(S | to) \\subset 'N('C(S | to)).\nProof.\napply/subsetP=> a nSa; rewrite inE sub_conjg; apply/subsetP=> b cSb.\nhave [Da Db] := (astabs_dom nSa, astab_dom cSb).\nrewrite mem_conjgV !inE groupJ //; apply/subsetP=> x Sx.\nrewrite inE !actMin ?groupM ?groupV //.\nby rewrite (astab_act cSb) ?actKVin ?astabs_act ?groupV.\nQed.",
    "Lemma astab_normal S : 'C(S | to) <| 'N(S | to).\nProof. by rewrite /normal astab_sub astab_norm. Qed.",
    "Lemma acts_sub_orbit G S x :\n  [acts G, on S | to] -> (orbit to G x \\subset S) = (x \\in S).\nProof.\nmove/acts_act=> GactS.\napply/subsetP/idP=> [| Sx y]; first by apply; apply: orbit_refl.\nby case/orbitP=> a Ga <-{y}; rewrite GactS.\nQed.",
    "Lemma acts_orbit G x : G \\subset D -> [acts G, on orbit to G x | to].\nProof.\nmove/subsetP=> sGD; apply/subsetP=> a Ga; rewrite !inE sGD //.\napply/subsetP=> _ /imsetP[b Gb ->].\nby rewrite inE -actMin ?sGD // imset_f ?groupM.\nQed.",
    "Lemma acts_subnorm_fix A : [acts 'N_D(A), on 'Fix_to(D :&: A) | to].\nProof.\napply/subsetP=> a nAa; have [Da _] := setIP nAa; rewrite !inE Da.\napply/subsetP=> x Cx /[1!inE]; apply/afixP=> b DAb.\nhave [Db _]:= setIP DAb; rewrite -actMin // conjgCV  actMin ?groupJ ?groupV //.\nby rewrite /= (afixP Cx) // memJ_norm // groupV (subsetP (normsGI _ _) _ nAa).\nQed.",
    "Lemma atrans_orbit G x : [transitive G, on orbit to G x | to].\nProof. by apply: imset_f; apply: orbit_refl. Qed.",
    "Lemma amove_act a : a \\in G -> amove to G x (to x a) = 'C_G[x | to] :* a.\nProof.\nmove=> Ga; apply/setP=> b; have Da := ssGD Ga.\nrewrite mem_rcoset !(inE, sub1set) !groupMr ?groupV //.\nby case Gb: (b \\in G); rewrite //= actMin ?groupV ?ssGD ?(canF_eq (actKVin Da)).\nQed.",
    "Lemma amove_orbit : amove to G x @: orbit to G x = rcosets 'C_G[x | to] G.\nProof.\napply/setP => Ha; apply/imsetP/rcosetsP=> [[y] | [a Ga ->]].\n  by case/imsetP=> b Gb -> ->{Ha y}; exists b => //; rewrite amove_act.\nby rewrite -amove_act //; exists (to x a); first apply: mem_orbit.\nQed.",
    "Lemma amoveK :\n  {in orbit to G x, cancel (amove to G x) (fun Ca => to x (repr Ca))}.\nProof.\nmove=> _ /orbitP[a Ga <-]; rewrite amove_act //= -[G :&: _]/(gval _).\ncase: repr_rcosetP => b; rewrite !(inE, sub1set)=> /and3P[Gb _ xbx].\nby rewrite actMin ?ssGD ?(eqP xbx).\nQed.",
    "Lemma orbit_stabilizer :\n  orbit to G x = [set to x (repr Ca) | Ca in rcosets 'C_G[x | to] G].\nProof.\nrewrite -amove_orbit -imset_comp /=; apply/setP=> z.\nby apply/idP/imsetP=> [xGz | [y xGy ->]]; first exists z; rewrite /= ?amoveK.\nQed.",
    "Lemma act_reprK :\n  {in rcosets 'C_G[x | to] G, cancel (to x \\o repr) (amove to G x)}.\nProof.\nmove=> _ /rcosetsP[a Ga ->] /=; rewrite amove_act ?rcoset_repr //.\nrewrite -[G :&: _]/(gval _); case: repr_rcosetP => b /setIP[Gb _].\nexact: groupM.\nQed.",
    "Lemma card_orbit_in G x : G \\subset D -> #|orbit to G x| = #|G : 'C_G[x | to]|.\nProof.\nmove=> sGD; rewrite orbit_stabilizer 1?card_in_imset //.\nexact: can_in_inj (act_reprK _).\nQed.",
    "Lemma card_orbit_in_stab G x :\n  G \\subset D -> (#|orbit to G x| * #|'C_G[x | to]|)%N = #|G|.\nProof. by move=> sGD; rewrite mulnC card_orbit_in ?Lagrange ?subsetIl. Qed.",
    "Lemma acts_sum_card_orbit G S :\n  [acts G, on S | to] -> \\sum_(T in orbit to G @: S) #|T| = #|S|.\nProof. by move/orbit_partition/card_partition. Qed.",
    "Lemma astab_setact_in S a : a \\in D -> 'C(to^* S a | to) = 'C(S | to) :^ a.\nProof.\nmove=> Da; apply/setP=> b; rewrite mem_conjg !inE -mem_conjg conjGid //.\napply: andb_id2l => Db; rewrite sub_imset_pre; apply: eq_subset_r => x.\nby rewrite !inE !actMin ?groupM ?groupV // invgK (canF_eq (actKVin Da)).\nQed.",
    "Lemma astab1_act_in x a : a \\in D -> 'C[to x a | to] = 'C[x | to] :^ a.\nProof. by move=> Da; rewrite -astab_setact_in // /setact imset_set1. Qed.",
    "Lemma atrans_dvd_index_in G S :\n  G \\subset D -> [transitive G, on S | to] -> #|S| %| #|G : 'C_G(S | to)|.\nProof.\nmove=> sGD /imsetP[x Sx {1}->]; rewrite card_orbit_in //.\nby rewrite indexgS // setIS // astabS // sub1set.\nQed.",
    "Lemma atrans_dvd_in G S :\n  G \\subset D -> [transitive G, on S | to] -> #|S| %| #|G|.\nProof.\nmove=> sGD transG; apply: dvdn_trans (atrans_dvd_index_in sGD transG) _.\nexact: dvdn_indexg.\nQed.",
    "Lemma atransPin G S :\n     G \\subset D -> [transitive G, on S | to] ->\n  forall x, x \\in S -> orbit to G x = S.\nProof. by move=> sGD /imsetP[y _ ->] x; apply/orbit_in_eqP. Qed.",
    "Lemma atransP2in G S :\n    G \\subset D -> [transitive G, on S | to] ->\n  {in S &, forall x y, exists2 a, a \\in G & y = to x a}.\nProof. by move=> sGD transG x y /(atransPin sGD transG) <- /imsetP. Qed.",
    "Lemma atrans_acts_in G S :\n  G \\subset D -> [transitive G, on S | to] -> [acts G, on S | to].\nProof.\nmove=> sGD transG; apply/subsetP=> a Ga; rewrite !inE (subsetP sGD) //.\nby apply/subsetP=> x /(atransPin sGD transG) <-; rewrite inE imset_f.\nQed.",
    "Lemma subgroup_transitivePin G H S x :\n     x \\in S -> H \\subset G -> G \\subset D -> [transitive G, on S | to] ->\n  reflect ('C_G[x | to] * H = G) [transitive H, on S | to].\nProof.\nmove=> Sx sHG sGD trG; have sHD := subset_trans sHG sGD.\napply: (iffP idP) => [trH | defG].\n  rewrite group_modr //; apply/setIidPl/subsetP=> a Ga.\n  have Sxa: to x a \\in S by rewrite (acts_act (atrans_acts_in sGD trG)).\n  have [b Hb xab]:= atransP2in sHD trH Sxa Sx.\n  have Da := subsetP sGD a Ga; have Db := subsetP sHD b Hb.\n  rewrite -(mulgK b a) mem_mulg ?groupV // !inE groupM //= sub1set inE.\n  by rewrite actMin -?xab.\napply/imsetP; exists x => //; apply/setP=> y; rewrite -(atransPin sGD trG Sx).\napply/imsetP/imsetP=> [] [a]; last by exists a; first apply: (subsetP sHG).\nrewrite -defG => /imset2P[c b /setIP[_ cxc] Hb ->] ->.\nexists b; rewrite ?actMin ?(astab_dom cxc) ?(subsetP sHD) //.\nby rewrite (astab_act cxc) ?inE.\nQed.",
    "Lemma actM x a b : to x (a * b) = to (to x a) b.\nProof. by rewrite actMin ?inE. Qed.",
    "Lemma actK : right_loop invg to.\nProof. by move=> a; apply: actKin; rewrite inE. Qed.",
    "Lemma actKV : rev_right_loop invg to.\nProof. by move=> a; apply: actKVin; rewrite inE. Qed.",
    "Lemma actX x a n : to x (a ^+ n) = iter n (to^~ a) x.\nProof. by elim: n => [|n /= <-]; rewrite ?act1 // -actM expgSr. Qed.",
    "Lemma actCJ a b x : to (to x a) b = to (to x b) (a ^ b).\nProof. by rewrite !actM actK. Qed.",
    "Lemma actCJV a b x : to (to x a) b = to (to x (b ^ a^-1)) a.\nProof. by rewrite (actCJ _ a) conjgKV. Qed.",
    "Lemma orbit_sym G x y : (x \\in orbit to G y) = (y \\in orbit to G x).\nProof. exact/orbit_in_sym/subsetT. Qed.",
    "Lemma orbit_trans G x y z :\n  x \\in orbit to G y -> y \\in orbit to G z -> x \\in orbit to G z.\nProof. exact/orbit_in_trans/subsetT. Qed.",
    "Lemma orbit_eqP G x y :\n  reflect (orbit to G x = orbit to G y) (x \\in orbit to G y).\nProof. exact/orbit_in_eqP/subsetT. Qed.",
    "Lemma orbit_transl G x y z :\n  y \\in orbit to G x -> (y \\in orbit to G z) = (x \\in orbit to G z).\nProof. exact/orbit_in_transl/subsetT. Qed.",
    "Lemma orbit_act G a x: a \\in G -> orbit to G (to x a) = orbit to G x.\nProof. exact/orbit_act_in/subsetT. Qed.",
    "Lemma orbit_actr G a x y :\n  a \\in G -> (to y a \\in orbit to G x) = (y \\in orbit to G x).\nProof. by move/mem_orbit/orbit_transl; apply. Qed.",
    "Lemma orbit_eq_mem G x y :\n  (orbit to G x == orbit to G y) = (x \\in orbit to G y).\nProof. exact: sameP eqP (orbit_eqP G x y). Qed.",
    "Lemma orbit_inv A x y : (y \\in orbit to A^-1 x) = (x \\in orbit to A y).\nProof. by rewrite orbit_inv_in ?subsetT. Qed.",
    "Lemma orbit_lcoset A a x : orbit to (a *: A) x = orbit to A (to x a).\nProof. by rewrite orbit_lcoset_in ?subsetT ?inE. Qed.",
    "Lemma orbit_rcoset A a x y :\n  (to y a \\in orbit to (A :* a) x) = (y \\in orbit to A x).\nProof. by rewrite orbit_rcoset_in ?subsetT ?inE. Qed.",
    "Lemma orbit_conjsg A a x y :\n  (to y a \\in orbit to (A :^ a) (to x a)) = (y \\in orbit to A x).\nProof. by rewrite orbit_conjsg_in ?subsetT ?inE. Qed.",
    "Lemma astabP S a : reflect (forall x, x \\in S -> to x a = x) (a \\in 'C(S | to)).\nProof.\napply: (iffP idP) => [cSa x|cSa]; first exact: astab_act.\nby rewrite !inE; apply/subsetP=> x Sx; rewrite inE cSa.\nQed.",
    "Lemma astab1P x a : reflect (to x a = x) (a \\in 'C[x | to]).\nProof. by rewrite !inE sub1set inE; apply: eqP. Qed.",
    "Lemma sub_astab1 A x : (A \\subset 'C[x | to]) = (x \\in 'Fix_to(A)).\nProof. by rewrite sub_astab1_in ?subsetT. Qed.",
    "Lemma astabC A S : (A \\subset 'C(S | to)) = (S \\subset 'Fix_to(A)).\nProof. by rewrite astabCin ?subsetT. Qed.",
    "Lemma afix_cycle a : 'Fix_to(<[a]>) = 'Fix_to[a].\nProof. by rewrite afix_cycle_in ?inE. Qed.",
    "Lemma afix_gen A : 'Fix_to(<<A>>) = 'Fix_to(A).\nProof. by rewrite afix_gen_in ?subsetT. Qed.",
    "Lemma afixM G H : 'Fix_to(G * H) = 'Fix_to(G) :&: 'Fix_to(H).\nProof. by rewrite afixMin ?subsetT. Qed.",
    "Lemma astabsP S a :\n  reflect (forall x, (to x a \\in S) = (x \\in S)) (a \\in 'N(S | to)).\nProof.\napply: (iffP idP) => [nSa x|nSa]; first exact: astabs_act.\nby rewrite !inE; apply/subsetP=> x; rewrite inE nSa.\nQed.",
    "Lemma card_orbit G x : #|orbit to G x| = #|G : 'C_G[x | to]|.\nProof. by rewrite card_orbit_in ?subsetT. Qed.",
    "Lemma dvdn_orbit G x : #|orbit to G x| %| #|G|.\nProof. by rewrite card_orbit dvdn_indexg. Qed.",
    "Lemma card_orbit_stab G x : (#|orbit to G x| * #|'C_G[x | to]|)%N = #|G|.\nProof. by rewrite mulnC card_orbit Lagrange ?subsetIl. Qed.",
    "Lemma actsP A S : reflect {acts A, on S | to} [acts A, on S | to].\nProof.\napply: (iffP idP) => [nSA x|nSA]; first exact: acts_act.\nby apply/subsetP=> a Aa /[!inE]; apply/subsetP=> x; rewrite inE nSA.\nQed.",
    "Lemma setact_orbit A x b : to^* (orbit to A x) b = orbit to (A :^ b) (to x b).\nProof.\napply/setP=> y; apply/idP/idP=> /imsetP[_ /imsetP[a Aa ->] ->{y}].\n  by rewrite actCJ mem_orbit ?memJ_conjg.\nby rewrite -actCJ mem_setact ?mem_orbit.\nQed.",
    "Lemma astab_setact S a : 'C(to^* S a | to) = 'C(S | to) :^ a.\nProof.\napply/setP=> b; rewrite mem_conjg.\napply/astabP/astabP=> stab x => [Sx|].\n  by rewrite conjgE invgK !actM stab ?actK //; apply/imsetP; exists x.\nby case/imsetP=> y Sy ->{x}; rewrite -actM conjgCV actM stab.\nQed.",
    "Lemma astab1_act x a : 'C[to x a | to] = 'C[x | to] :^ a.\nProof. by rewrite -astab_setact /setact imset_set1. Qed.",
    "Lemma atransP G S : [transitive G, on S | to] ->\n  forall x, x \\in S -> orbit to G x = S.\nProof. by case/imsetP=> x _ -> y; apply/orbit_eqP. Qed.",
    "Lemma atransP2 G S : [transitive G, on S | to] ->\n  {in S &, forall x y, exists2 a, a \\in G & y = to x a}.\nProof. by move=> GtrS x y /(atransP GtrS) <- /imsetP. Qed.",
    "Lemma atrans_acts G S : [transitive G, on S | to] -> [acts G, on S | to].\nProof.\nmove=> GtrS; apply/subsetP=> a Ga; rewrite !inE.\nby apply/subsetP=> x /(atransP GtrS) <-; rewrite inE imset_f.\nQed.",
    "Lemma atrans_supgroup G H S :\n    G \\subset H -> [transitive G, on S | to] ->\n  [transitive H, on S | to] = [acts H, on S | to].\nProof.\nmove=> sGH trG; apply/idP/idP=> [|actH]; first exact: atrans_acts.\ncase/imsetP: trG => x Sx defS; apply/imsetP; exists x => //.\nby apply/eqP; rewrite eqEsubset acts_sub_orbit ?Sx // defS imsetS.\nQed.",
    "Lemma atrans_acts_card G S :\n  [transitive G, on S | to] =\n     [acts G, on S | to] && (#|orbit to G @: S| == 1%N).\nProof.\napply/idP/andP=> [GtrS | [nSG]].\n  split; first exact: atrans_acts.\n  rewrite ((_ @: S =P [set S]) _) ?cards1 // eqEsubset sub1set.\n  apply/andP; split=> //; apply/subsetP=> _ /imsetP[x Sx ->].\n  by rewrite inE (atransP GtrS).\nrewrite eqn_leq andbC lt0n => /andP[/existsP[X /imsetP[x Sx X_Gx]]].\nrewrite (cardD1 X) {X}X_Gx imset_f // ltnS leqn0 => /eqP GtrS.\napply/imsetP; exists x => //; apply/eqP.\nrewrite eqEsubset acts_sub_orbit // Sx andbT.\napply/subsetP=> y Sy; have:= card0_eq GtrS (orbit to G y).\nby rewrite !inE /= imset_f // andbT => /eqP <-; apply: orbit_refl.\nQed.",
    "Lemma atrans_dvd G S : [transitive G, on S | to] -> #|S| %| #|G|.\nProof. by case/imsetP=> x _ ->; apply: dvdn_orbit. Qed.",
    "Lemma acts_fix_norm A B : A \\subset 'N(B) -> [acts A, on 'Fix_to(B) | to].\nProof.\nmove=> nAB; have:= acts_subnorm_fix to B; rewrite !setTI.\nexact: subset_trans.\nQed.",
    "Lemma faithfulP A S :\n  reflect (forall a, a \\in A -> {in S, to^~ a =1 id} -> a = 1)\n          [faithful A, on S | to].\nProof.\napply: (iffP subsetP) => [Cto1 a Aa Ca | Cto1 a].\n  by apply/set1P; rewrite Cto1 // inE Aa; apply/astabP.\nby case/setIP=> Aa /astabP Ca; apply/set1P; apply: Cto1.\nQed.",
    "Lemma astab_trans_gcore G S u :\n  [transitive G, on S | to] -> u \\in S -> 'C(S | to) = gcore 'C[u | to] G.\nProof.\nmove=> transG Su; apply/eqP; rewrite eqEsubset.\nrewrite gcore_max ?astabS ?sub1set //=; last first.\n  exact: subset_trans (atrans_acts transG) (astab_norm _ _).\napply/subsetP=> x cSx; apply/astabP=> uy.\ncase/(atransP2 transG Su) => y Gy ->{uy}.\nby apply/astab1P; rewrite astab1_act (bigcapP cSx).\nQed.",
    "Lemma trans_subnorm_fixP x G H S :\n  let C := 'C_G[x | to] in let T := 'Fix_(S | to)(H) in\n    [transitive G, on S | to] -> x \\in S -> H \\subset C ->\n  reflect ((H :^: G) ::&: C = H :^: C) [transitive 'N_G(H), on T | to].\nProof.\nmove=> C T trGS Sx sHC; have actGS := acts_act (atrans_acts trGS).\nhave:= sHC; rewrite subsetI sub_astab1 => /andP[sHG cHx].\nhave Tx: x \\in T by rewrite inE Sx.\napply: (iffP idP) => [trN | trC].\n  apply/setP=> Ha; apply/setIdP/imsetP=> [[]|[a Ca ->{Ha}]]; last first.\n    by rewrite conj_subG //; case/setIP: Ca => Ga _; rewrite imset_f.\n  case/imsetP=> a Ga ->{Ha}; rewrite subsetI !sub_conjg => /andP[_ sHCa].\n  have Txa: to x a^-1 \\in T.\n    by rewrite inE -sub_astab1 astab1_act actGS ?Sx ?groupV.\n  have [b] := atransP2 trN Tx Txa; case/setIP=> Gb nHb cxba.\n  exists (b * a); last by rewrite conjsgM (normP nHb).\n  by rewrite inE groupM //; apply/astab1P; rewrite actM -cxba actKV.\napply/imsetP; exists x => //; apply/setP=> y; apply/idP/idP=> [Ty|].\n  have [Sy cHy]:= setIP Ty; have [a Ga defy] := atransP2 trGS Sx Sy.\n  have: H :^ a^-1 \\in H :^: C.\n    rewrite -trC inE subsetI imset_f 1?conj_subG ?groupV // sub_conjgV.\n    by rewrite -astab1_act -defy sub_astab1.\n  case/imsetP=> b /setIP[Gb /astab1P cxb] defHb.\n  rewrite defy -{1}cxb -actM mem_orbit // inE groupM //.\n  by apply/normP; rewrite conjsgM -defHb conjsgKV.\ncase/imsetP=> a /setIP[Ga nHa] ->{y}.\nby rewrite inE actGS // Sx (acts_act (acts_fix_norm _) nHa).\nQed.",
    "Lemma ract_is_action : is_action A (ract sAD).\nProof.\nrewrite /ract; case: to => f [injf fM].\nby split=> // x; apply: (sub_in2 (subsetP sAD)).\nQed.",
    "Lemma ractE : raction =1 to. Proof. by []. Qed.",
    "Lemma actby_is_action : is_action A (actby nRA).\nProof.\nrewrite /actby; split=> [a x y | x a b Aa Ab /=]; last first.\n  rewrite Aa Ab groupM // !andbT actMin ?(subsetP (acts_dom nRA)) //.\n  by case Rx: (x \\in R); rewrite ?(acts_act nRA) ?Rx.\ncase Aa: (a \\in A); rewrite ?andbF ?andbT //.\ncase Rx: (x \\in R); case Ry: (y \\in R) => // eqxy; first exact: act_inj eqxy.\n  by rewrite -eqxy (acts_act nRA Aa) Rx in Ry.\nby rewrite eqxy (acts_act nRA Aa) Ry in Rx.\nQed.",
    "Lemma actbyE x a : x \\in R -> a \\in A -> <[nRA]>%act x a = to x a.\nProof. by rewrite /= /actby => -> ->. Qed.",
    "Lemma afix_actby B : 'Fix_<[nRA]>(B) = ~: R :|: 'Fix_to(A :&: B).\nProof.\napply/setP=> x; rewrite !inE /= /actby.\ncase: (x \\in R); last by apply/subsetP=> a _ /[!inE].\napply/subsetP/subsetP=> [cBx a | cABx a Ba] /[!inE].\n  by case/andP=> Aa /cBx; rewrite inE Aa.\nby case: ifP => //= Aa; have:= cABx a; rewrite !inE Aa => ->.\nQed.",
    "Lemma astab_actby S : 'C(S | <[nRA]>) = 'C_A(R :&: S | to).\nProof.\napply/setP=> a; rewrite setIA (setIidPl (acts_dom nRA)) !inE.\ncase Aa: (a \\in A) => //=; apply/subsetP/subsetP=> cRSa x => [|Sx].\n  by case/setIP=> Rx /cRSa; rewrite !inE actbyE.\nby have:= cRSa x; rewrite !inE /= /actby Aa Sx; case: (x \\in R) => //; apply.\nQed.",
    "Lemma astabs_actby S : 'N(S | <[nRA]>) = 'N_A(R :&: S | to).\nProof.\napply/setP=> a; rewrite setIA (setIidPl (acts_dom nRA)) !inE.\ncase Aa: (a \\in A) => //=; apply/subsetP/subsetP=> nRSa x => [|Sx].\n  by case/setIP=> Rx /nRSa; rewrite !inE actbyE ?(acts_act nRA) ?Rx.\nhave:= nRSa x; rewrite !inE /= /actby Aa Sx ?(acts_act nRA) //.\nby case: (x \\in R) => //; apply.\nQed.",
    "Lemma acts_actby (B : {set aT}) S :\n  [acts B, on S | <[nRA]>] = (B \\subset A) && [acts B, on R :&: S | to].\nProof. by rewrite astabs_actby subsetI. Qed.",
    "Lemma sub_act_proof u Na : sP (to (val u) (val Na)).\nProof. by case: Na => a /= /(astabs_act (val u)); rewrite !inE valP. Qed.",
    "Lemma val_subact u a :\n  val (subact u a) = if a \\in subact_dom then to (val u) a else val u.\nProof.\nby rewrite /subact -if_neg; case: insubP => [Na|] -> //=; rewrite SubK => ->.\nQed.",
    "Lemma subact_is_action : is_action subact_dom subact.\nProof.\nsplit=> [a u v eq_uv | u a b Na Nb]; apply: val_inj.\n  move/(congr1 val): eq_uv; rewrite !val_subact.\n  by case: (a \\in _); first move/act_inj.\nhave Da := astabs_dom Na; have Db := astabs_dom Nb.\nby rewrite !val_subact Na Nb groupM ?actMin.\nQed.",
    "Lemma astab_subact S : 'C(S | subaction) = subact_dom :&: 'C(val @: S | to).\nProof.\napply/setP=> a; rewrite inE in_setI; apply: andb_id2l => sDa.\nhave [Da _] := setIP sDa; rewrite !inE Da.\napply/subsetP/subsetP=> [cSa _ /imsetP[x Sx ->] | cSa x Sx] /[!inE].\n  by have:= cSa x Sx; rewrite inE -val_eqE val_subact sDa.\nby have:= cSa _ (imset_f val Sx); rewrite inE -val_eqE val_subact sDa.\nQed.",
    "Lemma astabs_subact S : 'N(S | subaction) = subact_dom :&: 'N(val @: S | to).\nProof.\napply/setP=> a; rewrite inE in_setI; apply: andb_id2l => sDa.\nhave [Da _] := setIP sDa; rewrite !inE Da.\napply/subsetP/subsetP=> [nSa _ /imsetP[x Sx ->] | nSa x Sx] /[!inE].\n  by have /[1!inE]/(imset_f val) := nSa x Sx; rewrite val_subact sDa.\nhave /[1!inE]/imsetP[y Sy def_y] := nSa _ (imset_f val Sx).\nby rewrite ((_ a =P y) _) // -val_eqE val_subact sDa def_y.\nQed.",
    "Lemma afix_subact A :\n  A \\subset subact_dom -> 'Fix_subaction(A) = val @^-1: 'Fix_to(A).\nProof.\nmove/subsetP=> sAD; apply/setP=> u.\nrewrite !inE !(sameP setIidPl eqP); congr (_ == A).\napply/setP=> a /[!inE]; apply: andb_id2l => Aa.\nby rewrite -val_eqE val_subact sAD.\n\nQed.",
    "Lemma qact_proof : qact_dom \\subset subdom.\nProof. by rewrite qact_subdomE. Qed.",
    "Lemma acts_qact_dom : [acts qact_dom, on 'N(H) | to].\nProof.\napply/subsetP=> a nNa; rewrite !inE (astabs_dom nNa); apply/subsetP=> x Nx.\nhave: H :* x \\in rcosets H 'N(H) by rewrite -rcosetE imset_f.\nrewrite inE -(astabs_act _ nNa) => /rcosetsP[y Ny defHy].\nhave: to x a \\in H :* y by rewrite -defHy (imset_f (to^~a)) ?rcoset_refl.\nby apply: subsetP; rewrite mul_subG ?sub1set ?normG.\nQed.",
    "Lemma qactEcond x a :\n    x \\in 'N(H) ->\n  quotient_action (coset H x) a\n    = coset H (if a \\in qact_dom then to x a else x).\nProof.\nmove=> Nx; apply: val_inj; rewrite val_subact //= qact_subdomE.\nhave: H :* x \\in rcosets H 'N(H) by rewrite -rcosetE imset_f.\ncase nNa: (a \\in _); rewrite // -(astabs_act _ nNa).\nrewrite !val_coset ?(acts_act acts_qact_dom nNa) //=.\ncase/rcosetsP=> y Ny defHy; rewrite defHy; apply: rcoset_eqP.\nby rewrite rcoset_sym -defHy (imset_f (_^~_)) ?rcoset_refl.\nQed.",
    "Lemma qactE x a :\n    x \\in 'N(H) -> a \\in qact_dom ->\n  quotient_action (coset H x) a = coset H (to x a).\nProof. by move=> Nx nNa; rewrite qactEcond ?nNa. Qed.",
    "Lemma acts_quotient (A : {set aT}) (B : {set rT}) :\n   A \\subset 'N_qact_dom(B | to) -> [acts A, on B / H | quotient_action].\nProof.\nmove=> nBA; apply: subset_trans {A}nBA _; apply/subsetP=> a /setIP[dHa nBa].\nrewrite inE dHa inE; apply/subsetP=> _ /morphimP[x nHx Bx ->].\nrewrite inE /= qactE //.\nby rewrite mem_morphim ?(acts_act acts_qact_dom) ?(astabs_act _ nBa).\nQed.",
    "Lemma astabs_quotient (G : {group rT}) :\n   H <| G -> 'N(G / H | quotient_action) = 'N_qact_dom(G | to).\nProof.\nmove=> nsHG; have [_ nHG] := andP nsHG.\napply/eqP; rewrite eqEsubset acts_quotient // andbT.\napply/subsetP=> a nGa; have dHa := astabs_dom nGa; have [Da _]:= setIdP dHa.\nrewrite inE dHa 2!inE Da; apply/subsetP=> x Gx; have nHx := subsetP nHG x Gx.\nrewrite -(quotientGK nsHG) 2!inE (acts_act acts_qact_dom) ?nHx //= inE.\nby rewrite -qactE // (astabs_act _ nGa) mem_morphim.\nQed.",
    "Lemma modactEcond x a :\n  a \\in dom -> modact x (coset H a) = (if x \\in range then to x a else x).\nProof.\ncase/setIP=> Da Na; case: ifP => Cx; rewrite /modact Cx //.\nrewrite val_coset // -group_modr ?sub1set //.\ncase: (repr _) / (repr_rcosetP (D :&: H) a) => a' Ha'.\nby rewrite actMin ?(afixP Cx _ Ha') //; case/setIP: Ha'.\nQed.",
    "Lemma modactE x a :\n  a \\in D -> a \\in 'N(H) -> x \\in range ->  modact x (coset H a) = to x a.\nProof. by move=> Da Na Rx; rewrite modactEcond ?Rx // inE Da. Qed.",
    "Lemma modact_is_action : is_action (D / H) modact.\nProof.\nsplit=> [Ha x y | x Ha Hb]; last first.\n  case/morphimP=> a Na Da ->{Ha}; case/morphimP=> b Nb Db ->{Hb}.\n  rewrite -morphM //= !modactEcond // ?groupM ?(introT setIP _) //.\n  by case: ifP => Cx; rewrite ?(acts_dom, Cx, actMin, introT setIP _).\ncase: (set_0Vmem (D :&: Ha)) => [Da0 | [a /setIP[Da NHa]]].\n  by rewrite /modact Da0 repr_set0 !act1 !if_same.\nhave Na := subsetP (coset_norm _) _ NHa.\nhave NDa: a \\in 'N_D(H) by rewrite inE Da.\nrewrite -(coset_mem NHa) !modactEcond //.\ndo 2![case: ifP]=> Cy Cx // eqxy; first exact: act_inj eqxy.\n  by rewrite -eqxy acts_dom ?Cx in Cy.\nby rewrite eqxy acts_dom ?Cy in Cx.\nQed.",
    "Lemma astabs_mod : 'N(S | mod_action) = 'N(S | to) / H.\nProof.\napply/setP=> Ha; apply/idP/morphimP=> [nSa | [a nHa nSa ->]].\n  case/morphimP: (astabs_dom nSa) => a nHa Da defHa.\n  exists a => //; rewrite !inE Da; apply/subsetP=> x Sx; rewrite !inE.\n  by have:= Sx; rewrite -(astabs_act x nSa) defHa /= modactE ?(subsetP fixSH).\nhave Da := astabs_dom nSa; rewrite !inE mem_quotient //; apply/subsetP=> x Sx.\nby rewrite !inE /= modactE ?(astabs_act x nSa) ?(subsetP fixSH).\nQed.",
    "Lemma astab_mod : 'C(S | mod_action) = 'C(S | to) / H.\nProof.\napply/setP=> Ha; apply/idP/morphimP=> [cSa | [a nHa cSa ->]].\n  case/morphimP: (astab_dom cSa) => a nHa Da defHa.\n  exists a => //; rewrite !inE Da; apply/subsetP=> x Sx; rewrite !inE.\n  by rewrite -{2}[x](astab_act cSa) // defHa /= modactE ?(subsetP fixSH).\nhave Da := astab_dom cSa; rewrite !inE mem_quotient //; apply/subsetP=> x Sx.\nby rewrite !inE /= modactE ?(astab_act cSa) ?(subsetP fixSH).\nQed.",
    "Lemma afix_mod G S :\n    H \\subset 'C(S | to) -> G \\subset 'N_D(H) ->\n  'Fix_(S | mod_action)(G / H) = 'Fix_(S | to)(G).\nProof.\nmove=> cSH /subsetIP[sGD nHG].\napply/eqP; rewrite eqEsubset !subsetI !subsetIl /= -!astabCin ?quotientS //.\nhave cfixH F: H \\subset 'C(S :&: F | to).\n  by rewrite (subset_trans cSH) // astabS ?subsetIl.\nrewrite andbC astab_mod ?quotientS //=; last by rewrite astabCin ?subsetIr.\nby rewrite -(quotientSGK nHG) //= -astab_mod // astabCin ?quotientS ?subsetIr.\nQed.",
    "Lemma modact_faithful G S :\n  [faithful G / 'C_G(S | to), on S | mod_action 'C_G(S | to)].\nProof.\nrewrite /faithful astab_mod ?subsetIr //=.\nby rewrite -quotientIG ?subsetIr ?trivg_quotient.\nQed.",
    "Lemma actpermM : {in D &, {morph actperm : a b / a * b}}.\nProof. by move=> a b Da Db; apply/permP=> x; rewrite permM !permE actMin. Qed.",
    "Lemma actpermE a x : actperm a x = to x a.\nProof. by rewrite permE. Qed.",
    "Lemma actpermK x a : aperm x (actperm a) = to x a.\nProof. exact: actpermE. Qed.",
    "Lemma ker_actperm : 'ker actperm = 'C(setT | to).\nProof.\ncongr (_ :&: _); apply/setP=> a /[!inE]/=.\napply/eqP/subsetP=> [a1 x _ | a1]; first by rewrite inE -actpermE a1 perm1.\nby apply/permP=> x; apply/eqP; have:= a1 x; rewrite !inE actpermE perm1 => ->.\nQed.",
    "Lemma faithful_isom (A : {group aT}) S (nSA : actby_cond A S to) :\n   [faithful A, on S | to] -> isom A (actperm <[nSA]> @* A) (actperm <[nSA]>).\nProof.\nby move=> ffulAS; apply/isomP; rewrite ker_actperm astab_actby setIT.\nQed.",
    "Lemma ractpermE : actperm (to \\ sAD) =1 actperm to.\nProof. by move=> a; apply/permP=> x; rewrite !permE. Qed.",
    "Lemma afix_ract B : 'Fix_(to \\ sAD)(B) = 'Fix_to(B). Proof. by []. Qed.",
    "Lemma astab_ract S : 'C(S | to \\ sAD) = 'C_A(S | to).\nProof. by rewrite setIA (setIidPl sAD). Qed.",
    "Lemma astabs_ract S : 'N(S | to \\ sAD) = 'N_A(S | to).\nProof. by rewrite setIA (setIidPl sAD). Qed.",
    "Lemma acts_ract (B : {set aT}) S :\n  [acts B, on S | to \\ sAD] = (B \\subset A) && [acts B, on S | to].\nProof. by rewrite astabs_ract subsetI. Qed.",
    "Lemma mact_is_action : is_action D mact.\nProof.\nsplit=> [a x y | x a b Da Db]; first exact: perm_inj.\nby rewrite /mact morphM //= permM.\nQed.",
    "Lemma mactE x a : morph_action x a = phi a x. Proof. by []. Qed.",
    "Lemma injm_faithful : 'injm phi -> [faithful D, on setT | morph_action].\nProof.\nmove/injmP=> phi_inj; apply/subsetP=> a /setIP[Da /astab_act a1].\napply/set1P/phi_inj => //; apply/permP=> x.\nby rewrite morph1 perm1 -mactE a1 ?inE.\nQed.",
    "Lemma perm_mact a : actperm morph_action a = phi a.\nProof. by apply/permP=> x; rewrite permE. Qed.",
    "Lemma comp_is_action : is_action (f @*^-1 D) comp_act.\nProof.\nsplit=> [e | x e1 e2]; first exact: act_inj.\nmove=> /morphpreP[Be1 Dfe1] /morphpreP[Be2 Dfe2].\nby rewrite /comp_act morphM ?actMin.\nQed.",
    "Lemma comp_actE x e : comp_action x e = to x (f e). Proof. by []. Qed.",
    "Lemma afix_comp (A : {set gT}) :\n  A \\subset B -> 'Fix_comp_action(A) = 'Fix_to(f @* A).\nProof.\nmove=> sAB; apply/setP=> x; rewrite !inE /morphim (setIidPr sAB).\napply/subsetP/subsetP; first by move=> + _ /imsetP[a + ->] => /[apply]/[!inE].\nby move=> + a Aa => /(_ (f a)); rewrite !inE imset_f// => ->.\nQed.",
    "Lemma astab_comp S : 'C(S | comp_action) = f @*^-1 'C(S | to).\nProof. by apply/setP=> x; rewrite !inE -andbA. Qed.",
    "Lemma astabs_comp S : 'N(S | comp_action) = f @*^-1 'N(S | to).\nProof. by apply/setP=> x; rewrite !inE -andbA. Qed.",
    "Lemma aperm_is_action : is_action setT (@aperm rT).\nProof.\nby apply: is_total_action => [x|x a b]; rewrite apermE (perm1, permM).\nQed.",
    "Lemma porbitE a : porbit a = orbit perm_action <[a]>%g.\nProof. by rewrite unlock. Qed.",
    "Lemma perm_act1P a : reflect (forall x, aperm x a = x) (a == 1).\nProof.\napply: (iffP eqP) => [-> x | a1]; first exact: act1.\nby apply/permP=> x; rewrite -apermE a1 perm1.\nQed.",
    "Lemma perm_faithful A : [faithful A, on setT | perm_action].\nProof.\napply/subsetP=> a /setIP[Da crTa].\nby apply/set1P; apply/permP=> x; rewrite -apermE perm1 (astabP crTa) ?inE.\nQed.",
    "Lemma actperm_id p : actperm perm_action p = p.\nProof. by apply/permP=> x; rewrite permE. Qed.",
    "Lemma orbit_morphim_actperm (A : {set aT}) :\n  A \\subset D -> orbit 'P (actperm to @* A) =1 orbit to A.\nProof.\nmove=> sAD x; rewrite morphimEsub // /orbit -imset_comp.\nby apply: eq_imset => a //=; rewrite actpermK.\nQed.",
    "Lemma porbit_actperm (a : aT) :\n   a \\in D -> porbit (actperm to a) =1 orbit to <[a]>.\nProof.\nmove=> Da x.\nby rewrite porbitE -orbit_morphim_actperm ?cycle_subG ?morphim_cycle.\nQed.",
    "Lemma restr_perm_on p : perm_on S (restr_perm p).\nProof.\napply/subsetP=> x; apply: contraR => notSx.\nby rewrite permE /= /actby (negPf notSx).\nQed.",
    "Lemma triv_restr_perm p : p \\notin 'N(S | 'P) -> restr_perm p = 1.\nProof.\nmove=> not_nSp; apply/permP=> x.\nby rewrite !permE /= /actby (negPf not_nSp) andbF.\nQed.",
    "Lemma restr_permE : {in 'N(S | 'P) & S, forall p, restr_perm p =1 p}.\nProof. by move=> y x nSp Sx; rewrite /= actpermE actbyE. Qed.",
    "Lemma ker_restr_perm : 'ker restr_perm = 'C(S | 'P).\nProof. by rewrite ker_actperm astab_actby setIT (setIidPr (astab_sub _ _)). Qed.",
    "Lemma im_restr_perm p : restr_perm p @: S = S.\nProof. exact: im_perm_on (restr_perm_on p). Qed.",
    "Lemma restr_perm_commute s : commute (restr_perm s) s.\nProof.\nhave [sC|/triv_restr_perm->] := boolP (s \\in 'N(S | 'P)); last first.\n  exact: (commute_sym (commute1 _)).\napply/permP => x; have /= xsS := astabsP sC x; rewrite !permM.\nhave [xS|xNS] := boolP (x \\in S); first by rewrite ?(restr_permE) ?xsS.\nby rewrite !(out_perm (restr_perm_on _)) ?xsS.\nQed.",
    "Lemma SymE : Sym S = 'C(~: S | 'P).\nProof.\napply/setP => s; rewrite inE; apply/idP/astabP => [sS x|/= S_id].\n  by rewrite inE /= apermE => /out_perm->.\nby apply/subsetP => x; move=> /(contra_neqN (S_id _)); rewrite inE negbK.\nQed.",
    "Lemma Aut_restr_perm a : a \\in Aut G -> restr_perm H a \\in Aut H.\nProof.\nmove=> AutGa.\ncase nHa: (a \\in 'N(H | 'P)); last by rewrite triv_restr_perm ?nHa ?group1.\nrewrite inE restr_perm_on; apply/morphicP=> x y Hx Hy /=.\nby rewrite !restr_permE ?groupM // -(autmE AutGa) morphM ?(subsetP sHG).\nQed.",
    "Lemma restr_perm_Aut : restr_perm H @* Aut G \\subset Aut H.\nProof.\nby apply/subsetP=> a'; case/morphimP=> a _ AutGa ->{a'}; apply: Aut_restr_perm.\nQed.",
    "Lemma Aut_in_isog : Aut_in (Aut G) H \\isog restr_perm H @* Aut G.\nProof.\nrewrite /Aut_in -ker_restr_perm kerE -morphpreIdom -morphimIdom -kerE /=.\nby rewrite setIA (setIC _ (Aut G)) first_isog_loc ?subsetIr.\nQed.",
    "Lemma Aut_sub_fullP :\n  reflect (forall h : {morphism H >-> gT}, 'injm h -> h @* H = H ->\n             exists g : {morphism G >-> gT},\n             [/\\ 'injm g, g @* G = G & {in H, g =1 h}])\n          (Aut_in (Aut G) H \\isog Aut H).\nProof.\nrewrite (isog_transl _ Aut_in_isog) /=; set rG := _ @* _.\napply: (iffP idP) => [iso_rG h injh hH| AutHinG].\n  have: aut injh hH \\in rG; last case/morphimP=> g nHg AutGg def_g.\n    suffices ->: rG = Aut H by apply: Aut_aut.\n    by apply/eqP; rewrite eqEcard restr_perm_Aut /= (card_isog iso_rG).\n  exists (autm_morphism AutGg); rewrite injm_autm im_autm; split=> // x Hx.\n  by rewrite -(autE injh hH Hx) def_g actpermE actbyE.\nsuffices ->: rG = Aut H by apply: isog_refl.\napply/eqP; rewrite eqEsubset restr_perm_Aut /=.\napply/subsetP=> h AutHh; have hH := im_autm AutHh.\nhave [g [injg gG eq_gh]] := AutHinG _ (injm_autm AutHh) hH.\nhave [Ng AutGg]: aut injg gG \\in 'N(H | 'P) /\\ aut injg gG \\in Aut G.\n  rewrite Aut_aut !inE; split=> //; apply/subsetP=> x Hx.\n  by rewrite inE /= /aperm autE ?(subsetP sHG) // -hH eq_gh ?mem_morphim.\napply/morphimP; exists (aut injg gG) => //; apply: (eq_Aut AutHh) => [|x Hx].\n  by rewrite (subsetP restr_perm_Aut) // mem_morphim.\nby rewrite restr_permE //= /aperm autE ?eq_gh ?(subsetP sHG).\nQed.",
    "Lemma astabs_Aut_isom a :\n  a \\in Aut G -> (fGisom a \\in 'N(f @* H | 'P)) = (a \\in 'N(H | 'P)).\nProof.\nmove=> AutGa; rewrite !inE sub_morphim_pre // subsetI sHD /= /aperm.\nrewrite !(sameP setIidPl eqP) !eqEsubset !subsetIl; apply: eq_subset_r => x.\nrewrite !inE; apply: andb_id2l => Hx; have Gx: x \\in G := subsetP sHG x Hx.\nhave Dax: a x \\in D by rewrite (subsetP sGD) // Aut_closed.\nby rewrite Aut_isomE // -!sub1set -morphim_set1 // injmSK ?sub1set.\nQed.",
    "Lemma isom_restr_perm a : a \\in Aut G -> fHisom (inH a) = infH (fGisom a).\nProof.\nmove=> AutGa; case nHa: (a \\in 'N(H | 'P)); last first.\n  by rewrite !triv_restr_perm ?astabs_Aut_isom ?nHa ?morph1.\napply: (eq_Aut (Aut_Aut_isom injf sHD _)) => [|fx Hfx /=].\n  by rewrite (Aut_restr_perm (morphimS f sHG)) ?Aut_Aut_isom.\nhave [x Dx Hx def_fx] := morphimP Hfx; have Gx := subsetP sHG x Hx.\nrewrite {1}def_fx Aut_isomE ?(Aut_restr_perm sHG) //.\nby rewrite !restr_permE ?astabs_Aut_isom // def_fx Aut_isomE.\nQed.",
    "Lemma restr_perm_isom : isom (inH @* Aut G) (infH @* Aut (f @* G)) fHisom.\nProof.\napply: sub_isom; rewrite ?restr_perm_Aut ?injm_Aut_isom //=.\nrewrite -(im_Aut_isom injf sGD) -!morphim_comp.\napply: eq_in_morphim; last exact: isom_restr_perm.\n\napply/setP=> a; rewrite in_setI [in RHS]in_setI; apply: andb_id2r => AutGa.\n\nrewrite /= inE andbC inE (Aut_restr_perm sHG) //=.\nby symmetry; rewrite inE AutGa inE astabs_Aut_isom.\nQed.",
    "Lemma injm_Aut_sub : Aut_in (Aut (f @* G)) (f @* H) \\isog Aut_in (Aut G) H.\nProof.\ndo 2!rewrite isog_sym (isog_transl _ (Aut_in_isog _ _)).\nby rewrite isog_sym (isom_isog _ _ restr_perm_isom) // restr_perm_Aut.\nQed.",
    "Lemma injm_Aut_full :\n  (Aut_in (Aut (f @* G)) (f @* H) \\isog Aut (f @* H))\n      = (Aut_in (Aut G) H \\isog Aut H).\nProof.\nby rewrite (isog_transl _ injm_Aut_sub) (isog_transr _ (injm_Aut injf sHD)).\nQed.",
    "Lemma actperm_Aut : is_groupAction R to. Proof. by case: to. Qed.",
    "Lemma im_actperm_Aut : actperm to @* D \\subset Aut R.\nProof. by apply/subsetP=> _ /morphimP[a _ Da ->]; apply: actperm_Aut. Qed.",
    "Lemma gact_out x a : a \\in D -> x \\notin R -> to x a = x.\nProof. by move=> Da Rx; rewrite -actpermE (out_Aut _ Rx) ?actperm_Aut. Qed.",
    "Lemma gactM : {in D, forall a, {in R &, {morph to^~ a : x y / x * y}}}.\nProof.\nmove=> a Da /= x y; rewrite -!(actpermE to); apply: morphicP x y.\nby rewrite Aut_morphic ?actperm_Aut.\nQed.",
    "Lemma actmM a : {in R &, {morph actm to a : x y / x * y}}.\nProof. by rewrite /actm; case: ifP => //; apply: gactM. Qed.",
    "Lemma morphim_actm :\n  {in D, forall a (S : {set rT}), S \\subset R -> actm to a @* S = to^* S a}.\nProof. by move=> a Da /= S sSR; rewrite /morphim /= actmEfun ?(setIidPr _). Qed.",
    "Lemma gacentIdom : 'C_(|to)(D :&: A) = 'C_(|to)(A).\nProof. by rewrite /gacent setIA setIid. Qed.",
    "Lemma gacentIim : 'C_(R | to)(A) = 'C_(|to)(A).\nProof. by rewrite setIA setIid. Qed.",
    "Lemma gacentS : A \\subset B -> 'C_(|to)(B) \\subset 'C_(|to)(A).\nProof. by move=> sAB; rewrite !(setIS, afixS). Qed.",
    "Lemma gacentU : 'C_(|to)(A :|: B) = 'C_(|to)(A) :&: 'C_(|to)(B).\nProof. by rewrite -setIIr -afixU -setIUr. Qed.",
    "Lemma gacentE : 'C_(|to)(A) = 'Fix_(R | to)(A).\nProof. by rewrite -{2}(setIidPr sAD). Qed.",
    "Lemma gacent1E : 'C_(|to)[a] = 'Fix_(R | to)[a].\nProof. by rewrite /gacent [D :&: _](setIidPr _) ?sub1set. Qed.",
    "Lemma subgacentE : 'C_(S | to)(A) = 'Fix_(S | to)(A).\nProof. by rewrite gacentE setIA (setIidPl sSR). Qed.",
    "Lemma subgacent1E : 'C_(S | to)[a] = 'Fix_(S | to)[a].\nProof. by rewrite gacent1E setIA (setIidPl sSR). Qed.",
    "Lemma gact1 : {in D, forall a, to 1 a = 1}.\nProof. by move=> a Da; rewrite /= -actmE ?morph1. Qed.",
    "Lemma gactV : {in D, forall a, {in R, {morph to^~ a : x / x^-1}}}.\nProof. by move=> a Da /= x Rx; move; rewrite -!actmE ?morphV. Qed.",
    "Lemma gactX : {in D, forall a n, {in R, {morph to^~ a : x / x ^+ n}}}.\nProof. by move=> a Da /= n x Rx; rewrite -!actmE // morphX. Qed.",
    "Lemma gactJ : {in D, forall a, {in R &, {morph to^~ a : x y / x ^ y}}}.\nProof. by move=> a Da /= x Rx y Ry; rewrite -!actmE // morphJ. Qed.",
    "Lemma gactR : {in D, forall a, {in R &, {morph to^~ a : x y / [~ x, y]}}}.\nProof. by move=> a Da /= x Rx y Ry; rewrite -!actmE // morphR. Qed.",
    "Lemma gact_stable : {acts D, on R | to}.\nProof.\napply: acts_act; apply/subsetP=> a Da; rewrite !inE Da.\napply/subsetP=> x; rewrite inE; apply: contraLR => R'xa.\nby rewrite -(actKin to Da x) gact_out ?groupV.\nQed.",
    "Lemma group_set_gacent A : group_set 'C_(|to)(A).\nProof.\napply/group_setP; split=> [|x y].\n  by rewrite !inE group1; apply/subsetP=> a /setIP[Da _]; rewrite inE gact1.\ncase/setIP=> Rx /afixP cAx /setIP[Ry /afixP cAy].\nrewrite inE groupM //; apply/afixP=> a Aa.\nby rewrite gactM ?cAx ?cAy //; case/setIP: Aa.\nQed.",
    "Lemma gacent1 : 'C_(|to)(1) = R.\nProof. by rewrite /gacent (setIidPr (sub1G _)) afix1 setIT. Qed.",
    "Lemma gacent_gen A : A \\subset D -> 'C_(|to)(<<A>>) = 'C_(|to)(A).\nProof.\nby move=> sAD; rewrite /gacent ![D :&: _](setIidPr _) ?gen_subG ?afix_gen_in.\nQed.",
    "Lemma gacentD1 A : 'C_(|to)(A^#) = 'C_(|to)(A).\nProof.\nrewrite -gacentIdom -gacent_gen ?subsetIl // setIDA genD1 ?group1 //.\nby rewrite gacent_gen ?subsetIl // gacentIdom.\nQed.",
    "Lemma gacent_cycle a : a \\in D -> 'C_(|to)(<[a]>) = 'C_(|to)[a].\nProof. by move=> Da; rewrite gacent_gen ?sub1set. Qed.",
    "Lemma gacentY A B :\n  A \\subset D -> B \\subset D -> 'C_(|to)(A <*> B) = 'C_(|to)(A) :&: 'C_(|to)(B).\nProof. by move=> sAD sBD; rewrite gacent_gen ?gacentU // subUset sAD. Qed.",
    "Lemma gacentM G H :\n  G \\subset D -> H \\subset D -> 'C_(|to)(G * H) = 'C_(|to)(G) :&: 'C_(|to)(H).\nProof.\nby move=> sGD sHB; rewrite -gacent_gen ?mul_subG // genM_join gacentY.\nQed.",
    "Lemma astab1 : 'C(1 | to) = D.\nProof.\nby apply/setP=> x; rewrite ?(inE, sub1set) andb_idr //; move/gact1=> ->.\nQed.",
    "Lemma astab_range : 'C(R | to) = 'C(setT | to).\nProof.\napply/eqP; rewrite eqEsubset andbC astabS ?subsetT //=.\napply/subsetP=> a cRa; have Da := astab_dom cRa; rewrite !inE Da.\napply/subsetP=> x; rewrite -(setUCr R) !inE.\nby case/orP=> ?; [rewrite (astab_act cRa) | rewrite gact_out].\nQed.",
    "Lemma gacentC A S :\n    A \\subset D -> S \\subset R ->\n  (S \\subset 'C_(|to)(A)) = (A \\subset 'C(S | to)).\nProof. by move=> sAD sSR; rewrite subsetI sSR astabCin // (setIidPr sAD). Qed.",
    "Lemma astab_gen S : S \\subset R -> 'C(<<S>> | to) = 'C(S | to).\nProof.\nmove=> sSR; apply/setP=> a; case Da: (a \\in D); last by rewrite !inE Da.\nby rewrite -!sub1set -!gacentC ?sub1set ?gen_subG.\nQed.",
    "Lemma astabM M N :\n  M \\subset R -> N \\subset R -> 'C(M * N | to) = 'C(M | to) :&: 'C(N | to).\nProof.\nmove=> sMR sNR; rewrite -astabU -astab_gen ?mul_subG // genM_join.\nby rewrite astab_gen // subUset sMR.\nQed.",
    "Lemma astabs1 : 'N(1 | to) = D.\nProof. by rewrite astabs_set1 astab1. Qed.",
    "Lemma astabs_range : 'N(R | to) = D.\nProof.\napply/setIidPl; apply/subsetP=> a Da; rewrite inE.\nby apply/subsetP=> x Rx; rewrite inE gact_stable.\nQed.",
    "Lemma astabsD1 S : 'N(S^# | to) = 'N(S | to).\nProof.\ncase S1: (1 \\in S); last first.\n  by rewrite (setDidPl _) // disjoint_sym disjoints_subset sub1set inE S1.\napply/eqP; rewrite eqEsubset andbC -{1}astabsIdom -{1}astabs1 setIC astabsD /=.\nby rewrite -{2}(setD1K S1) -astabsIdom -{1}astabs1 astabsU.\nQed.",
    "Lemma gacts_range A : A \\subset D -> {acts A, on group R | to}.\nProof. by move=> sAD; split; rewrite ?astabs_range. Qed.",
    "Lemma acts_subnorm_gacent A : A \\subset D ->\n  [acts 'N_D(A), on 'C_(| to)(A) | to].\nProof.\nmove=> sAD; rewrite gacentE // actsI ?astabs_range ?subsetIl //.\nby rewrite -{2}(setIidPr sAD) acts_subnorm_fix.\nQed.",
    "Lemma acts_subnorm_subgacent A B S :\n  A \\subset D -> [acts B, on S | to] -> [acts 'N_B(A), on 'C_(S | to)(A) | to].\nProof.\nmove=> sAD actsB; rewrite actsI //; first by rewrite subIset ?actsB.\nby rewrite (subset_trans _ (acts_subnorm_gacent sAD)) ?setSI ?(acts_dom actsB).\nQed.",
    "Lemma acts_gen A S :\n  S \\subset R -> [acts A, on S | to] -> [acts A, on <<S>> | to].\nProof.\nmove=> sSR actsA; apply: {A}subset_trans actsA _.\napply/subsetP=> a nSa; have Da := astabs_dom nSa; rewrite !inE Da.\napply: subset_trans (_ : <<S>> \\subset actm to a @*^-1 <<S>>) _.\n  rewrite gen_subG subsetI sSR; apply/subsetP=> x Sx.\n  by rewrite inE /= actmE ?mem_gen // astabs_act.\nby apply/subsetP=> x /[!inE]; case/andP=> Rx; rewrite /= actmE.\nQed.",
    "Lemma acts_joing A M N :\n    M \\subset R -> N \\subset R -> [acts A, on M | to] -> [acts A, on N | to] ->\n  [acts A, on M <*> N | to].\nProof. by move=> sMR sNR nMA nNA; rewrite acts_gen ?actsU // subUset sMR. Qed.",
    "Lemma injm_actm a : 'injm (actm to a).\nProof.\napply/injmP=> x y Rx Ry; rewrite /= /actm; case: ifP => Da //.\nexact: act_inj.\nQed.",
    "Lemma im_actm a : actm to a @* R = R.\nProof.\napply/eqP; rewrite eqEcard (card_injm (injm_actm a)) // leqnn andbT.\napply/subsetP=> _ /morphimP[x Rx _ ->] /=.\nby rewrite /actm; case: ifP => // Da; rewrite gact_stable.\nQed.",
    "Lemma acts_char G M : G \\subset D -> M \\char R -> [acts G, on M | to].\nProof.\nmove=> sGD /charP[sMR charM].\napply/subsetP=> a Ga; have Da := subsetP sGD a Ga; rewrite !inE Da.\napply/subsetP=> x Mx; have Rx := subsetP sMR x Mx.\nby rewrite inE -(charM _ (injm_actm a) (im_actm a)) -actmE // mem_morphim.\nQed.",
    "Lemma gacts_char G M :\n  G \\subset D -> M \\char R -> {acts G, on group M | to}.\n\nProof. by move=> sGD charM; split; rewrite ?acts_char// char_sub. Qed.",
    "Lemma ract_is_groupAction : is_groupAction R (to \\ sAD).\nProof. by move=> a Aa /=; rewrite ractpermE actperm_Aut ?(subsetP sAD). Qed.",
    "Lemma gacent_ract B : 'C_(|ract_groupAction)(B) = 'C_(|to)(A :&: B).\nProof. by rewrite /gacent afix_ract setIA (setIidPr sAD). Qed.",
    "Lemma actby_is_groupAction : is_groupAction G <[nGAg]>.\nProof.\nmove=> a Aa; rewrite /= inE; apply/andP; split.\n  apply/subsetP=> x; apply: contraR => Gx.\n  by rewrite actpermE /= /actby (negbTE Gx).\napply/morphicP=> x y Gx Gy; rewrite !actpermE /= /actby Aa groupM ?Gx ?Gy //=.\nby case nGAg; move/acts_dom; do 2!move/subsetP=> ?; rewrite gactM; auto.\nQed.",
    "Lemma gacent_actby B :\n  'C_(|actby_groupAction)(B) = 'C_(G | to)(A :&: B).\nProof.\nrewrite /gacent afix_actby !setIA setIid setIUr setICr set0U.\nby have [nAG sGR] := nGAg; rewrite (setIidPr (acts_dom nAG)) (setIidPl sGR).\nQed.",
    "Lemma acts_qact_dom_norm : {acts qact_dom to H, on 'N(H) | to}.\nProof.\nmove=> a HDa /= x; rewrite {2}(('N(H) =P to^~ a @^-1: 'N(H)) _) ?inE {x}//.\nrewrite eqEcard (card_preimset _ (act_inj _ _)) leqnn andbT.\napply/subsetP=> x Nx; rewrite inE; move/(astabs_act (H :* x)): HDa.\nrewrite mem_rcosets mulSGid ?normG // Nx => /rcosetsP[y Ny defHy].\nsuffices: to x a \\in H :* y by apply: subsetP; rewrite mul_subG ?sub1set ?normG.\nby rewrite -defHy; apply: imset_f; apply: rcoset_refl.\nQed.",
    "Lemma qact_is_groupAction : is_groupAction (R / H) (to / H).\nProof.\nmove=> a HDa /=; have Da := astabs_dom HDa.\nrewrite inE; apply/andP; split.\n  apply/subsetP=> Hx /=; case: (cosetP Hx) => x Nx ->{Hx}.\n  apply: contraR => R'Hx; rewrite actpermE qactE // gact_out //.\n  by apply: contra R'Hx; apply: mem_morphim.\napply/morphicP=> Hx Hy; rewrite !actpermE.\ncase/morphimP=> x Nx Gx ->{Hx}; case/morphimP=> y Ny Gy ->{Hy}.\nby rewrite -morphM ?qactE ?groupM ?gactM // morphM ?acts_qact_dom_norm.\nQed.",
    "Lemma qact_domE : H \\subset R -> qact_dom to H = 'N(H | to).\nProof.\nmove=> sHR; apply/setP=> a; apply/idP/idP=> nHa; have Da := astabs_dom nHa.\n  rewrite !inE Da; apply/subsetP=> x Hx; rewrite inE -(rcoset1 H).\n  have /rcosetsP[y Ny defHy]: to^~ a @: H \\in rcosets H 'N(H).\n    by rewrite (astabs_act _ nHa); apply/rcosetsP; exists 1; rewrite ?mulg1.\n  by rewrite (rcoset_eqP (_ : 1 \\in H :* y)) -defHy -1?(gact1 Da) mem_setact.\nrewrite !inE Da; apply/subsetP=> Hx /[1!inE] /rcosetsP[x Nx ->{Hx}].\napply/imsetP; exists (to x a).\n  case Rx: (x \\in R); last by rewrite gact_out ?Rx.\n  rewrite inE; apply/subsetP=> _ /imsetP[y Hy ->].\n  rewrite -(actKVin to Da y) -gactJ // ?(subsetP sHR, astabs_act, groupV) //.\n  by rewrite memJ_norm // astabs_act ?groupV.\napply/eqP; rewrite rcosetE eqEcard.\nrewrite (card_imset _ (act_inj _ _)) !card_rcoset leqnn andbT.\napply/subsetP=> _ /imsetP[y Hxy ->]; rewrite !mem_rcoset in Hxy *.\nhave Rxy := subsetP sHR _ Hxy; rewrite -(mulgKV x y).\ncase Rx: (x \\in R); last by rewrite !gact_out ?mulgK // 1?groupMl ?Rx.\nby rewrite -gactV // -gactM 1?groupMr ?groupV // mulgK astabs_act.\nQed.",
    "Lemma modact_is_groupAction : is_groupAction 'C_(|to)(H) (to %% H).\nProof.\nmove=> Ha /morphimP[a Na Da ->]; have NDa: a \\in 'N_D(H) by apply/setIP.\nrewrite inE; apply/andP; split.\n  apply/subsetP=> x; rewrite 2!inE andbC actpermE /= modactEcond //.\n  by apply: contraR; case: ifP => // E Rx; rewrite gact_out.\napply/morphicP=> x y /setIP[Rx cHx] /setIP[Ry cHy].\nrewrite /= !actpermE /= !modactE ?gactM //.\nsuffices: x * y \\in 'C_(|to)(H) by case/setIP.\nby rewrite groupM //; apply/setIP.\nQed.",
    "Lemma modgactE x a :\n  H \\subset 'C(R | to) -> a \\in 'N_D(H) -> (to %% H)%act x (coset H a) = to x a.\nProof.\nmove=> cRH NDa /=; have [Da Na] := setIP NDa.\nhave [Rx | notRx] := boolP (x \\in R).\n  by rewrite modactE //; apply/afixP=> b /setIP[_ /(subsetP cRH)/astab_act->].\nrewrite gact_out //= /modact; case: ifP => // _; rewrite gact_out //.\nsuffices: a \\in D :&: coset H a by case/mem_repr/setIP.\nby rewrite inE Da val_coset // rcoset_refl.\nQed.",
    "Lemma gacent_mod G M :\n    H \\subset 'C(M | to) -> G \\subset 'N(H) ->\n 'C_(M | mod_groupAction)(G / H) = 'C_(M | to)(G).\nProof.\nmove=> cMH nHG; rewrite -gacentIdom gacentE ?subsetIl // setICA.\nhave sHD: H \\subset D by rewrite (subset_trans cMH) ?subsetIl.\nrewrite -quotientGI // afix_mod ?setIS // setICA -gacentIim (setIC R) -setIA.\nrewrite -gacentE ?subsetIl // gacentIdom setICA (setIidPr _) //.\nby rewrite gacentC // ?(subset_trans cMH) ?astabS ?subsetIl // setICA subsetIl.\nQed.",
    "Lemma acts_irr_mod G M :\n    H \\subset 'C(M | to) -> G \\subset 'N(H) -> acts_irreducibly G M to ->\n  acts_irreducibly (G / H) M mod_groupAction.\nProof.\nmove=> cMH nHG /mingroupP[/andP[ntM nMG] minM].\napply/mingroupP; rewrite ntM astabs_mod ?quotientS //; split=> // L modL ntL.\nhave cLH: H \\subset 'C(L | to) by rewrite (subset_trans cMH) ?astabS //.\napply: minM => //; case/andP: modL => ->; rewrite astabs_mod ?quotientSGK //.\nby rewrite (subset_trans cLH) ?astab_sub.\nQed.",
    "Lemma modact_coset_astab x a :\n  a \\in D -> (to %% 'C(R | to))%act x (coset _ a) = to x a.\nProof.\nmove=> Da; apply: modgactE => {x}//.\nrewrite !inE Da; apply/subsetP=> _ /imsetP[c Cc ->].\nhave Dc := astab_dom Cc; rewrite !inE groupJ //.\napply/subsetP=> x Rx; rewrite inE conjgE !actMin ?groupM ?groupV //.\nby rewrite (astab_act Cc) ?actKVin // gact_stable ?groupV.\nQed.",
    "Lemma acts_irr_mod_astab G M :\n    acts_irreducibly G M to ->\n  acts_irreducibly (G / 'C_G(M | to)) M (mod_groupAction _).\nProof.\nmove=> irrG; have /andP[_ nMG] := mingroupp irrG.\napply: acts_irr_mod irrG; first exact: subsetIr.\nby rewrite normsI ?normG // (subset_trans nMG) // astab_norm.\nQed.",
    "Lemma comp_is_groupAction : is_groupAction R (comp_action to f).\nProof.\nmove=> a /morphpreP[Ba Dfa]; apply: etrans (actperm_Aut to Dfa).\nby congr (_ \\in Aut R); apply/permP=> x; rewrite !actpermE.\nQed.",
    "Lemma gacent_comp U : 'C_(|comp_groupAction)(U) = 'C_(|to)(f @* U).\nProof.\nrewrite /gacent afix_comp ?subIset ?subxx //.\nby rewrite -(setIC U) (setIC D) morphim_setIpre.\nQed.",
    "Lemma morph_astabs : f @* 'N(S | to1) = 'N(h @: S | to2).\nProof.\napply/setP=> fx; apply/morphimP/idP=> [[x D1x nSx ->] | nSx].\n  rewrite 2!inE -{1}defD2 mem_morphim //=; apply/subsetP=> _ /imsetP[u Su ->].\n  by rewrite inE -hfJ ?imset_f // (astabs_act _ nSx).\nhave [|x D1x _ def_fx] := morphimP (_ : fx \\in f @* D1).\n  by rewrite defD2 (astabs_dom nSx).\nexists x => //; rewrite !inE D1x; apply/subsetP=> u Su.\nhave /imsetP[u' Su' /injh def_u']: h (to1 u x) \\in h @: S.\n  by rewrite hfJ // -def_fx (astabs_act _ nSx) imset_f.\nby rewrite inE def_u' ?actsDR ?(subsetP sSR).\nQed.",
    "Lemma morph_astab : f @* 'C(S | to1) = 'C(h @: S | to2).\nProof.\napply/setP=> fx; apply/morphimP/idP=> [[x D1x cSx ->] | cSx].\n  rewrite 2!inE -{1}defD2 mem_morphim //=; apply/subsetP=> _ /imsetP[u Su ->].\n  by rewrite inE -hfJ // (astab_act cSx).\nhave [|x D1x _ def_fx] := morphimP (_ : fx \\in f @* D1).\n  by rewrite defD2 (astab_dom cSx).\nexists x => //; rewrite !inE D1x; apply/subsetP=> u Su.\nrewrite inE -(inj_in_eq injh) ?actsDR ?(subsetP sSR) ?hfJ //.\nby rewrite -def_fx (astab_act cSx) ?imset_f.\nQed.",
    "Lemma morph_afix : h @: 'Fix_(S | to1)(A) = 'Fix_(h @: S | to2)(f @* A).\nProof.\napply/setP=> hu; apply/imsetP/setIP=> [[u /setIP[Su cAu] ->]|].\n  split; first by rewrite imset_f.\n  by apply/afixP=> _ /morphimP[x D1x Ax ->]; rewrite -hfJ ?(afixP cAu).\ncase=> /imsetP[u Su ->] /afixP c_hu_fA; exists u; rewrite // inE Su.\napply/afixP=> x Ax; have Dx := subsetP sAD1 x Ax.\nby apply: injh; rewrite ?actsDR ?(subsetP sSR) ?hfJ // c_hu_fA ?mem_morphim.\nQed.",
    "Lemma morph_gastabs S : S \\subset R1 -> f @* 'N(S | to1) = 'N(h @* S | to2).\nProof.\nhave [[_ defD2] [injh _]] := (isomP iso_f, isomP iso_h).\nmove=> sSR1; rewrite (morphimEsub _ sSR1).\napply: (morph_astabs (gact_stable to1) (injmP injh)) => // u x.\nby move/(subsetP sSR1); apply: hfJ.\nQed.",
    "Lemma morph_gastab S : S \\subset R1 -> f @* 'C(S | to1) = 'C(h @* S | to2).\nProof.\nhave [[_ defD2] [injh _]] := (isomP iso_f, isomP iso_h).\nmove=> sSR1; rewrite (morphimEsub _ sSR1).\napply: (morph_astab (gact_stable to1) (injmP injh)) => // u x.\nby move/(subsetP sSR1); apply: hfJ.\nQed.",
    "Lemma morph_gacent A : A \\subset D1 -> h @* 'C_(|to1)(A) = 'C_(|to2)(f @* A).\nProof.\nhave [[_ defD2] [injh defR2]] := (isomP iso_f, isomP iso_h).\nmove=> sAD1; rewrite !gacentE //; last by rewrite -defD2 morphimS.\nrewrite morphimEsub ?subsetIl // -{1}defR2 morphimEdom.\nexact: (morph_afix (gact_stable to1) (injmP injh)).\nQed.",
    "Lemma morph_gact_irr A M :\n    A \\subset D1 -> M \\subset R1 ->\n  acts_irreducibly (f @* A) (h @* M) to2 = acts_irreducibly A M to1.\nProof.\nmove=> sAD1 sMR1.\nhave [[injf defD2] [injh defR2]] := (isomP iso_f, isomP iso_h).\nhave h_eq1 := morphim_injm_eq1 injh.\napply/mingroupP/mingroupP=> [] [/andP[ntM actAM] minM].\n  split=> [|U]; first by rewrite -h_eq1 // ntM -(injmSK injf) ?morph_gastabs.\n  case/andP=> ntU acts_fAU sUM; have sUR1 := subset_trans sUM sMR1.\n  apply: (injm_morphim_inj injh) => //; apply: minM; last exact: morphimS.\n  by rewrite h_eq1 // ntU -morph_gastabs ?morphimS.\nsplit=> [|U]; first by rewrite h_eq1 // ntM -morph_gastabs ?morphimS.\ncase/andP=> ntU acts_fAU sUhM.\nhave sUhR1 := subset_trans sUhM (morphimS h sMR1).\nhave sU'M: h @*^-1 U \\subset M by rewrite sub_morphpre_injm.\nrewrite /= -(minM _ _ sU'M) ?morphpreK // -h_eq1 ?subsetIl // -(injmSK injf) //.\nby rewrite morph_gastabs ?(subset_trans sU'M) // morphpreK ?ntU.\nQed.",
    "Lemma conjg_is_groupAction : is_groupAction setT conjg_action.\nProof.\nmove=> a _; rewrite inE; apply/andP; split; first by apply/subsetP=> x /[1!inE].\nby apply/morphicP=> x y _ _; rewrite !actpermE /= conjMg.\nQed.",
    "Lemma rcoset_is_action : is_action setT (@rcoset gT).\nProof.\nby apply: is_total_action => [A|A x y]; rewrite !rcosetE (mulg1, rcosetM).\nQed.",
    "Lemma conjG_is_action : is_action setT (@conjG_group gT).\nProof.\napply: is_total_action => [G | G x y]; apply: val_inj; rewrite /= ?act1 //.\nexact: actM.\nQed.",
    "Lemma orbitR G x : orbit 'R G x = x *: G.\nProof. by rewrite -lcosetE. Qed.",
    "Lemma astab1R x : 'C[x | 'R] = 1.\nProof.\napply/trivgP/subsetP=> y cxy.\nby rewrite -(mulKg x y) [x * y](astab1P cxy) mulVg set11.\nQed.",
    "Lemma astabR G : 'C(G | 'R) = 1.\nProof.\napply/trivgP/subsetP=> x cGx.\nby rewrite -(mul1g x) [1 * x](astabP cGx) group1.\nQed.",
    "Lemma astabsR G : 'N(G | 'R) = G.\nProof.\napply/setP=> x; rewrite !inE -setactVin ?inE //=.\nby rewrite -groupV -{1 3}(mulg1 G) rcoset_sym -sub1set -mulGS -!rcosetE.\nQed.",
    "Lemma atransR G : [transitive G, on G | 'R].\nProof. by rewrite /atrans -{1}(mul1g G) -orbitR imset_f. Qed.",
    "Lemma faithfulR G : [faithful G, on G | 'R].\nProof. by rewrite /faithful astabR subsetIr. Qed.",
    "Lemma orbitJ G x : orbit 'J G x = x ^: G. Proof. by []. Qed.",
    "Lemma afixJ A : 'Fix_('J)(A) = 'C(A).\nProof.\napply/setP=> x; apply/afixP/centP=> cAx y Ay /=.\n  by rewrite /commute conjgC cAx.\nby rewrite conjgE cAx ?mulKg.\nQed.",
    "Lemma astabJ A : 'C(A |'J) = 'C(A).\nProof.\napply/setP=> x; apply/astabP/centP=> cAx y Ay /=.\n  by apply: esym; rewrite conjgC cAx.\nby rewrite conjgE -cAx ?mulKg.\nQed.",
    "Lemma astab1J x : 'C[x |'J] = 'C[x].\nProof. by rewrite astabJ cent_set1. Qed.",
    "Lemma astabsJ A : 'N(A | 'J) = 'N(A).\nProof. by apply/setP=> x; rewrite -2!groupV !inE -conjg_preim -sub_conjg. Qed.",
    "Lemma setactJ A x : 'J^*%act A x = A :^ x. Proof. by []. Qed.",
    "Lemma gacentJ A : 'C_(|'J)(A) = 'C(A).\nProof. by rewrite gacentE ?setTI ?subsetT ?afixJ. Qed.",
    "Lemma orbitRs G A : orbit 'Rs G A = rcosets A G. Proof. by []. Qed.",
    "Lemma sub_afixRs_norms G x A : (G :* x \\in 'Fix_('Rs)(A)) = (A \\subset G :^ x).\nProof.\nrewrite inE /=; apply: eq_subset_r => a.\nrewrite inE rcosetE -(can2_eq (rcosetKV x) (rcosetK x)) -!rcosetM.\nrewrite eqEcard card_rcoset leqnn andbT mulgA (conjgCV x) mulgK.\nby rewrite -{2 3}(mulGid G) mulGS sub1set -mem_conjg.\nQed.",
    "Lemma sub_afixRs_norm G x : (G :* x \\in 'Fix_('Rs)(G)) = (x \\in 'N(G)).\nProof. by rewrite sub_afixRs_norms -groupV inE sub_conjgV. Qed.",
    "Lemma afixRs_rcosets A G : 'Fix_(rcosets G A | 'Rs)(G) = rcosets G 'N_A(G).\nProof.\napply/setP=> Gx; apply/setIP/rcosetsP=> [[/rcosetsP[x Ax ->]]|[x]].\n  by rewrite sub_afixRs_norm => Nx; exists x; rewrite // inE Ax.\nby case/setIP=> Ax Nx ->; rewrite -{1}rcosetE imset_f // sub_afixRs_norm.\nQed.",
    "Lemma astab1Rs G : 'C[G : {set gT} | 'Rs] = G.\nProof.\napply/setP=> x.\nby apply/astab1P/idP=> /= [<- | Gx]; rewrite rcosetE ?rcoset_refl ?rcoset_id.\nQed.",
    "Lemma actsRs_rcosets H G : [acts G, on rcosets H G | 'Rs].\nProof. by rewrite -orbitRs acts_orbit ?subsetT. Qed.",
    "Lemma transRs_rcosets H G : [transitive G, on rcosets H G | 'Rs].\nProof. by rewrite -orbitRs atrans_orbit. Qed.",
    "Lemma astabRs_rcosets H G : 'C(rcosets H G | 'Rs) = gcore H G.\nProof.\nhave transGH := transRs_rcosets H G.\nby rewrite (astab_trans_gcore transGH (orbit_refl _ G _)) astab1Rs.\nQed.",
    "Lemma orbitJs G A : orbit 'Js G A = A :^: G. Proof. by []. Qed.",
    "Lemma astab1Js A : 'C[A | 'Js] = 'N(A).\nProof. by apply/setP=> x; apply/astab1P/normP. Qed.",
    "Lemma card_conjugates A G : #|A :^: G| = #|G : 'N_G(A)|.\nProof. by rewrite card_orbit astab1Js. Qed.",
    "Lemma afixJG G A : (G \\in 'Fix_('JG)(A)) = (A \\subset 'N(G)).\nProof. by apply/afixP/normsP=> nG x Ax; apply/eqP; move/eqP: (nG x Ax). Qed.",
    "Lemma astab1JG G : 'C[G | 'JG] = 'N(G).\nProof.\nby apply/setP=> x; apply/astab1P/normP=> [/congr_group | /group_inj].\nQed.",
    "Lemma dom_qactJ H : qact_dom 'J H = 'N(H).\nProof. by rewrite qact_domE ?subsetT ?astabsJ. Qed.",
    "Lemma qactJ H (Hy : coset_of H) x :\n  'Q%act Hy x = if x \\in 'N(H) then Hy ^ coset H x else Hy.\nProof.\ncase: (cosetP Hy) => y Ny ->{Hy}.\nby rewrite qactEcond // dom_qactJ; case Nx: (x \\in 'N(H)); rewrite ?morphJ.\nQed.",
    "Lemma actsQ A B H :\n  A \\subset 'N(H) -> A \\subset 'N(B) -> [acts A, on B / H | 'Q].\nProof.\nby move=> nHA nBA; rewrite acts_quotient // subsetI dom_qactJ nHA astabsJ.\nQed.",
    "Lemma astabsQ G H : H <| G -> 'N(G / H | 'Q) = 'N(H) :&: 'N(G).\nProof. by move=> nsHG; rewrite astabs_quotient // dom_qactJ astabsJ. Qed.",
    "Lemma astabQ H Abar : 'C(Abar |'Q) = coset H @*^-1 'C(Abar).\nProof.\napply/setP=> x; rewrite inE /= dom_qactJ morphpreE in_setI /=.\napply: andb_id2l => Nx; rewrite !inE -sub1set centsC cent_set1.\napply: eq_subset_r => {Abar} Hy; rewrite inE qactJ Nx (sameP eqP conjg_fixP).\nby rewrite (sameP cent1P eqP) (sameP commgP eqP).\nQed.",
    "Lemma sub_astabQ A H Bbar :\n  (A \\subset 'C(Bbar | 'Q)) = (A \\subset 'N(H)) && (A / H \\subset 'C(Bbar)).\nProof.\nrewrite astabQ -morphpreIdom subsetI; apply: andb_id2l => nHA.\nby rewrite -sub_quotient_pre.\nQed.",
    "Lemma sub_astabQR A B H :\n     A \\subset 'N(H) -> B \\subset 'N(H) ->\n  (A \\subset 'C(B / H | 'Q)) = ([~: A, B] \\subset H).\nProof.\nmove=> nHA nHB; rewrite sub_astabQ nHA /= (sameP commG1P eqP).\nby rewrite eqEsubset sub1G andbT -quotientR // quotient_sub1 // comm_subG.\nQed.",
    "Lemma astabQR A H : A \\subset 'N(H) ->\n  'C(A / H | 'Q) = [set x in 'N(H) | [~: [set x], A] \\subset H].\nProof.\nmove=> nHA; apply/setP=> x; rewrite astabQ -morphpreIdom 2!inE -astabQ.\nby case nHx: (x \\in _); rewrite //= -sub1set sub_astabQR ?sub1set.\nQed.",
    "Lemma quotient_astabQ H Abar : 'C(Abar | 'Q) / H = 'C(Abar).\nProof. by rewrite astabQ cosetpreK. Qed.",
    "Lemma conj_astabQ A H x :\n  x \\in 'N(H) -> 'C(A / H | 'Q) :^ x = 'C(A :^ x / H | 'Q).\nProof.\nmove=> nHx; apply/setP=> y; rewrite !astabQ mem_conjg !in_setI -mem_conjg.\nrewrite -normJ (normP nHx) quotientJ //; apply/andb_id2l => nHy.\nby rewrite !inE centJ morphJ ?groupV ?morphV // -mem_conjg.\nQed.",
    "Lemma index_cent1 x : #|G : 'C_G[x]| = #|x ^: G|.\nProof. by rewrite -astab1J -card_orbit. Qed.",
    "Lemma classes_partition : partition (classes G) G.\nProof. by apply: orbit_partition; apply/actsP=> x Gx y; apply: groupJr. Qed.",
    "Lemma sum_card_class : \\sum_(C in classes G) #|C| = #|G|.\nProof. by apply: acts_sum_card_orbit; apply/actsP=> x Gx y; apply: groupJr. Qed.",
    "Lemma class_formula : \\sum_(C in classes G) #|G : 'C_G[repr C]| = #|G|.\nProof.\nrewrite -sum_card_class; apply: eq_bigr => _ /imsetP[x Gx ->].\nhave: x \\in x ^: G by rewrite -{1}(conjg1 x) imset_f.\nby case/mem_repr/imsetP=> y Gy ->; rewrite index_cent1 classGidl.\nQed.",
    "Lemma abelian_classP : reflect {in G, forall x, x ^: G = [set x]} (abelian G).\nProof.\nrewrite /abelian -astabJ astabC.\nby apply: (iffP subsetP) => cGG x Gx; apply/orbit1P; apply: cGG.\nQed.",
    "Lemma card_classes_abelian : abelian G = (#|classes G| == #|G|).\nProof.\nhave cGgt0 C: C \\in classes G -> 1 <= #|C| ?= iff (#|C| == 1)%N.\n  by case/imsetP=> x _ ->; rewrite eq_sym -index_cent1.\nrewrite -sum_card_class -sum1_card (leqif_sum cGgt0).\napply/abelian_classP/forall_inP=> [cGG _ /imsetP[x Gx ->]| cGG x Gx].\n  by rewrite cGG ?cards1.\napply/esym/eqP; rewrite eqEcard sub1set cards1 class_refl leq_eqVlt cGG //.\nexact: imset_f.\nQed.",
    "Lemma gacentQ (gT : finGroupType) (H : {group gT}) (A : {set gT}) :\n  'C_(|'Q)(A) = 'C(A / H).\nProof.\napply/setP=> Hx; case: (cosetP Hx) => x Nx ->{Hx}.\nrewrite -sub_cent1 -astab1J astabC sub1set -(quotientInorm H A).\nhave defD: qact_dom 'J H = 'N(H) by rewrite qact_domE ?subsetT ?astabsJ.\nrewrite !(inE, mem_quotient) //= defD setIC.\napply/subsetP/subsetP=> [cAx _ /morphimP[a Na Aa ->] | cAx a Aa].\n  by move/cAx: Aa; rewrite !inE qactE ?defD ?morphJ.\nhave [_ Na] := setIP Aa; move/implyP: (cAx (coset H a)); rewrite mem_morphim //.\nby rewrite !inE qactE ?defD ?morphJ.\nQed.",
    "Lemma autactK a : actperm aut_action a = a.\nProof. by apply/permP=> x; rewrite permE. Qed.",
    "Lemma autact_is_groupAction : is_groupAction G aut_action.\nProof. by move=> a Aa /=; rewrite autactK. Qed.",
    "Lemma perm_prime_atrans : [transitive <[c]>, on setT | 'P].\nProof.\napply/imsetP; suff /existsP[x] : [exists x, ~~ (#|orbit 'P <[c]> x| < #[c])].\n  move=> oxT; suff /eqP orbit_x : orbit 'P <[c]> x == setT by exists x.\n  by rewrite eqEcard subsetT cardsT -cc leqNgt.\napply/forallP => olT; have o1 x : #|orbit 'P <[c]> x| == 1%N.\n  by case/primeP: cp => _ /(_ _ (dvdn_orbit 'P _ x))/orP[]//; rewrite ltn_eqF.\nsuff c1 : c = 1%g by rewrite c1 ?order1 in (cp).\napply/permP => x; rewrite perm1; apply/set1P.\nby rewrite -(card_orbit1 (eqP (o1 _))) (mem_orbit 'P) ?cycle_id.\nQed.",
    "Lemma perm_prime_orbit x : orbit 'P <[c]> x = [set: T].\nProof. by apply: atransP => //; apply: perm_prime_atrans. Qed.",
    "Lemma perm_prime_astab x : 'C_<[c]>[x | 'P]%g = 1%g.\nProof.\nby apply/card1_trivg/eqP; rewrite -(@eqn_pmul2l #|orbit 'P <[c]> x|)\n   ?card_orbit_stab ?perm_prime_orbit ?cardsT ?muln1 ?prime_gt0// -cc.\nQed.",
    "Lemma cfun0_zchar : 0 \\in Zchar.\nProof.\nrewrite inE mem0v; apply/sumboolP; exists 0.\nby rewrite big1 // => i _; rewrite ffunE.\nQed.",
    "Lemma scale_zchar a phi : a \\in Num.int -> phi \\in Zchar -> a *: phi \\in Zchar.\nProof. by case/intrP=> m -> Zphi; rewrite scaler_int rpredMz. Qed.",
    "Lemma zchar_split S A phi :\n  phi \\in 'Z[S, A] = (phi \\in 'Z[S]) && (phi \\in 'CF(G, A)).\nProof. by rewrite !inE cfun_onT andbC. Qed.",
    "Lemma zcharD1E phi S : (phi \\in 'Z[S, G^#]) = (phi \\in 'Z[S]) && (phi 1%g == 0).\nProof. by rewrite zchar_split cfunD1E. Qed.",
    "Lemma zcharD1 phi S A :\n  (phi \\in 'Z[S, A^#]) = (phi \\in 'Z[S, A]) && (phi 1%g == 0).\nProof. by rewrite zchar_split cfun_onD1 andbA -zchar_split. Qed.",
    "Lemma zcharW S A : {subset 'Z[S, A] <= 'Z[S]}.\nProof. by move=> phi; rewrite zchar_split => /andP[]. Qed.",
    "Lemma zchar_on S A : {subset 'Z[S, A] <= 'CF(G, A)}.\nProof. by move=> phi /andP[]. Qed.",
    "Lemma zchar_onS A B S : A \\subset B -> {subset 'Z[S, A] <= 'Z[S, B]}.\nProof.\nmove=> sAB phi; rewrite zchar_split (zchar_split _ B) => /andP[->].\nexact: cfun_onS.\nQed.",
    "Lemma zchar_onG S : 'Z[S, G] =i 'Z[S].\nProof. by move=> phi; rewrite zchar_split cfun_onG andbT. Qed.",
    "Lemma irr_vchar_on A : {subset 'Z[irr G, A] <= 'CF(G, A)}.\nProof. exact: zchar_on. Qed.",
    "Lemma support_zchar S A phi : phi \\in 'Z[S, A] -> support phi \\subset A.\nProof. by move/zchar_on; rewrite cfun_onE. Qed.",
    "Lemma mem_zchar_on S A phi :\n  phi \\in 'CF(G, A) -> phi \\in S -> phi \\in 'Z[S, A].\nProof.\nmove=> Aphi /(@tnthP _ _ (in_tuple S))[i Dphi]; rewrite inE /= {}Aphi {phi}Dphi.\napply/sumboolP; exists [ffun j => (j == i)%:Z].\nrewrite (bigD1 i) //= ffunE eqxx (tnth_nth 0) big1 ?addr0 // => j i'j.\nby rewrite ffunE (negPf i'j).\nQed.",
    "Lemma mem_zchar S phi : phi \\in S -> phi \\in 'Z[S].\nProof. by move=> Sphi; rewrite mem_zchar_on ?cfun_onT. Qed.",
    "Lemma zchar_nth_expansion S A phi :\n    phi \\in 'Z[S, A] ->\n  {z | forall i, z i \\in Num.int & phi = \\sum_(i < size S) z i *: S`_i}.\nProof.\ncase/andP=> _ /sumboolP/sig_eqW[/= z ->]; exists (intr \\o z) => //=.\nby apply: eq_bigr => i _; rewrite scaler_int.\nQed.",
    "Lemma zchar_tuple_expansion n (S : n.-tuple 'CF(G)) A phi :\n    phi \\in 'Z[S, A] ->\n  {z | forall i, z i \\in Num.int & phi = \\sum_(i < n) z i *: S`_i}.\nProof. by move/zchar_nth_expansion; rewrite size_tuple. Qed.",
    "Lemma zchar_expansion S A phi : uniq S ->\n    phi \\in 'Z[S, A] ->\n  {z | forall xi, z xi \\in Num.int & phi = \\sum_(xi <- S) z xi *: xi}.\nProof.\nmove=> Suniq /zchar_nth_expansion[z Zz ->] /=.\npose zS xi := oapp z 0 (insub (index xi S)).\nexists zS => [xi | ]; rewrite {}/zS; first by case: (insub _) => /=.\nrewrite (big_nth 0) big_mkord; apply: eq_bigr => i _; congr (_ *: _).\nby rewrite index_uniq // valK.\nQed.",
    "Lemma zchar_span S A : {subset 'Z[S, A] <= <<S>>%VS}.\nProof.\nmove=> _ /zchar_nth_expansion[z Zz ->] /=.\nby apply: rpred_sum => i _; rewrite rpredZ // memv_span ?mem_nth.\nQed.",
    "Lemma zchar_trans S1 S2 A B :\n  {subset S1 <= 'Z[S2, B]} -> {subset 'Z[S1, A] <= 'Z[S2, A]}.\nProof.\nmove=> sS12 phi; rewrite !(zchar_split _ A) andbC => /andP[->]; rewrite andbT.\ncase/zchar_nth_expansion=> z Zz ->; apply: rpred_sum => i _.\nby rewrite scale_zchar // (@zcharW _ B) ?sS12 ?mem_nth.\nQed.",
    "Lemma zchar_trans_on S1 S2 A :\n  {subset S1 <= 'Z[S2, A]} -> {subset 'Z[S1] <= 'Z[S2, A]}.\nProof.\nmove=> sS12 _ /zchar_nth_expansion[z Zz ->]; apply: rpred_sum => i _.\nby rewrite scale_zchar // sS12 ?mem_nth.\nQed.",
    "Lemma zchar_sub_irr S A :\n  {subset S <= 'Z[irr G]} -> {subset 'Z[S, A] <= 'Z[irr G, A]}.\nProof. exact: zchar_trans. Qed.",
    "Lemma zchar_subset S1 S2 A :\n  {subset S1 <= S2} -> {subset 'Z[S1, A] <= 'Z[S2, A]}.\nProof.\nmove=> sS12; apply: zchar_trans setT _ => // f /sS12 S2f.\nby rewrite mem_zchar.\nQed.",
    "Lemma zchar_subseq S1 S2 A :\n  subseq S1 S2 -> {subset 'Z[S1, A] <= 'Z[S2, A]}.\nProof. by move/mem_subseq; apply: zchar_subset. Qed.",
    "Lemma zchar_filter S A (p : pred 'CF(G)) :\n  {subset 'Z[filter p S, A] <= 'Z[S, A]}.\nProof. by apply: zchar_subset=> f; apply/mem_subseq/filter_subseq. Qed.",
    "Lemma char_vchar chi : chi \\is a character -> chi \\in 'Z[irr G].\nProof.\ncase/char_sum_irr=> r ->; apply: rpred_sum => i _.\nby rewrite mem_zchar ?mem_tnth.\nQed.",
    "Lemma irr_vchar i : 'chi[G]_i \\in 'Z[irr G].\nProof. exact/char_vchar/irr_char. Qed.",
    "Lemma cfun1_vchar : 1 \\in 'Z[irr G]. Proof. by rewrite -irr0 irr_vchar. Qed.",
    "Lemma vcharP phi :\n  reflect (exists2 chi1, chi1 \\is a character\n            & exists2 chi2, chi2 \\is a character & phi = chi1 - chi2)\n          (phi \\in 'Z[irr G]).\nProof.\napply: (iffP idP) => [| [a Na [b Nb ->]]]; last by rewrite rpredB ?char_vchar.\ncase/zchar_tuple_expansion=> z Zz ->; rewrite (bigID (fun i => 0 <= z i)) /=.\nset chi1 := \\sum_(i | _) _; set nchi2 := \\sum_(i | _) _.\nexists chi1; last exists (- nchi2); last by rewrite opprK.\n  apply: rpred_sum => i zi_ge0; rewrite -tnth_nth rpredZ_nat ?irr_char //.\n  by rewrite natrEint Zz.\nrewrite -sumrN rpred_sum // => i zi_lt0; rewrite -scaleNr -tnth_nth.\nrewrite rpredZ_nat ?irr_char // natrEint rpredN Zz oppr_ge0 ltW //.\nby rewrite real_ltNge ?Rreal_int.\nQed.",
    "Lemma Aint_vchar phi x : phi \\in 'Z[irr G] -> phi x \\in Aint.\nProof.\ncase/vcharP=> [chi1 Nchi1 [chi2 Nchi2 ->]].\nby rewrite !cfunE rpredB ?Aint_char.\nQed.",
    "Lemma Cint_vchar1 phi : phi \\in 'Z[irr G] -> phi 1%g \\in Num.int.\nProof.\ncase/vcharP=> phi1 Nphi1 [phi2 Nphi2 ->].\nby rewrite !cfunE rpredB // rpred_nat_num ?Cnat_char1.\nQed.",
    "Lemma Cint_cfdot_vchar_irr i phi :\n  phi \\in 'Z[irr G] -> '[phi, 'chi_i] \\in Num.int.\nProof.\ncase/vcharP=> chi1 Nchi1 [chi2 Nchi2 ->].\nby rewrite cfdotBl rpredB // rpred_nat_num ?Cnat_cfdot_char_irr.\nQed.",
    "Lemma cfdot_vchar_r phi psi :\n  psi \\in 'Z[irr G] -> '[phi, psi] = \\sum_i '[phi, 'chi_i] * '[psi, 'chi_i].\nProof.\nmove=> Zpsi; rewrite cfdot_sum_irr; apply: eq_bigr => i _; congr (_ * _).\nby rewrite aut_intr ?Cint_cfdot_vchar_irr.\nQed.",
    "Lemma Cint_cfdot_vchar :\n  {in 'Z[irr G] &, forall phi psi, '[phi, psi] \\in Num.int}.\nProof.\nmove=> phi psi Zphi Zpsi; rewrite /= cfdot_vchar_r // rpred_sum // => k _.\nby rewrite rpredM ?Cint_cfdot_vchar_irr.\nQed.",
    "Lemma Cnat_cfnorm_vchar : {in 'Z[irr G], forall phi, '[phi] \\in Num.nat}.\nProof. by move=> phi Zphi; rewrite /= natrEint cfnorm_ge0 Cint_cfdot_vchar. Qed.",
    "Lemma mul_vchar A :\n  {in 'Z[irr G, A] &, forall phi psi, phi * psi \\in 'Z[irr G, A]}.\nProof.\nmove=> phi psi; rewrite zchar_split => /andP[Zphi Aphi] /zcharW Zpsi.\nrewrite zchar_split rpredM //; apply/cfun_onP=> x A'x.\nby rewrite cfunE (cfun_onP Aphi) ?mul0r.\nQed.",
    "Lemma map_pairwise_orthogonal : pairwise_orthogonal (map nu S).\nProof.\nhave inj_nu: {in S &, injective nu}.\n  move=> phi psi Sphi Spsi /= eq_nu; apply: contraNeq (memPn notS0 _ Sphi).\n  by rewrite -cfnorm_eq0 -Inu ?Z_S // {2}eq_nu Inu ?Z_S // => /dotSS->.\nhave notSnu0: 0 \\notin map nu S.\n  apply: contra notS0 => /mapP[phi Sphi /esym/eqP].\n  by rewrite -cfnorm_eq0 Inu ?Z_S // cfnorm_eq0 => /eqP <-.\napply/pairwise_orthogonalP; split; first by rewrite /= notSnu0 map_inj_in_uniq.\nmove=> _ _ /mapP[phi Sphi ->] /mapP[psi Spsi ->].\nby rewrite (inj_in_eq inj_nu) // Inu ?Z_S //; apply: dotSS.\nQed.",
    "Lemma cfproj_sum_orthogonal P z phi :\n    phi \\in S ->\n  '[\\sum_(xi <- S | P xi) z xi *: nu xi, nu phi]\n    = if P phi then z phi * '[phi] else 0.\nProof.\nmove=> Sphi; have defS := perm_to_rem Sphi.\nrewrite cfdot_suml (perm_big _ defS) big_cons /= cfdotZl Inu ?Z_S //.\nrewrite big1_seq ?addr0 // => xi; rewrite mem_rem_uniq ?inE //.\nby case/and3P=> _ neq_xi Sxi; rewrite cfdotZl Inu ?Z_S // dotSS ?mulr0.\nQed.",
    "Lemma cfdot_sum_orthogonal z1 z2 :\n  '[\\sum_(xi <- S) z1 xi *: nu xi, \\sum_(xi <- S) z2 xi *: nu xi]\n    = \\sum_(xi <- S) z1 xi * (z2 xi)^* * '[xi].\nProof.\nrewrite cfdot_sumr; apply: eq_big_seq => phi Sphi.\nby rewrite cfdotZr cfproj_sum_orthogonal // mulrCA mulrA.\nQed.",
    "Lemma cfnorm_sum_orthogonal z :\n  '[\\sum_(xi <- S) z xi *: nu xi] = \\sum_(xi <- S) `|z xi| ^+ 2 * '[xi].\nProof.\nby rewrite cfdot_sum_orthogonal; apply: eq_bigr => xi _; rewrite normCK.\nQed.",
    "Lemma cfnorm_orthogonal : '[\\sum_(xi <- S) nu xi] = \\sum_(xi <- S) '[xi].\nProof.\nrewrite -(eq_bigr _ (fun _ _ => scale1r _)) cfnorm_sum_orthogonal.\nby apply: eq_bigr => xi; rewrite normCK conjC1 !mul1r.\nQed.",
    "Lemma orthogonal_span S phi :\n    pairwise_orthogonal S -> phi \\in <<S>>%VS ->\n  {z | z = fun xi => '[phi, xi] / '[xi] & phi = \\sum_(xi <- S) z xi *: xi}.\nProof.\nmove=> oSS /free_span[|c -> _]; first exact: orthogonal_free.\nset z := fun _ => _ : algC; exists z => //; apply: eq_big_seq => u Su.\nrewrite /z cfproj_sum_orthogonal // mulfK // cfnorm_eq0.\nby rewrite (memPn _ u Su); case/andP: oSS.\nQed.",
    "Lemma map_orthonormal : orthonormal (map nu S).\nProof.\nrewrite !orthonormalE map_pairwise_orthogonal // andbT.\nby apply/allP=> _ /mapP[xi Sxi ->]; rewrite /= Inu ?nS1 // mem_zchar.\nQed.",
    "Lemma cfproj_sum_orthonormal z phi :\n  phi \\in S -> '[\\sum_(xi <- S) z xi *: nu xi, nu phi] = z phi.\nProof. by move=> Sphi; rewrite cfproj_sum_orthogonal // nS1 // mulr1. Qed.",
    "Lemma cfdot_sum_orthonormal z1 z2 :\n  '[\\sum_(xi <- S) z1 xi *: xi, \\sum_(xi <- S) z2 xi *: xi]\n     = \\sum_(xi <- S) z1 xi * (z2 xi)^*.\nProof.\nrewrite cfdot_sum_orthogonal //; apply: eq_big_seq => phi /nS1->.\nby rewrite mulr1.\nQed.",
    "Lemma cfnorm_sum_orthonormal z :\n  '[\\sum_(xi <- S) z xi *: nu xi] = \\sum_(xi <- S) `|z xi| ^+ 2.\nProof.\nrewrite cfnorm_sum_orthogonal //.\nby apply: eq_big_seq => xi /nS1->; rewrite mulr1.\nQed.",
    "Lemma cfnorm_map_orthonormal : '[\\sum_(xi <- S) nu xi] = (size S)%:R.\nProof.\nby rewrite cfnorm_orthogonal // (eq_big_seq _ nS1) big_tnth sumr_const card_ord.\nQed.",
    "Lemma orthonormal_span phi :\n    phi \\in <<S>>%VS ->\n  {z | z = fun xi => '[phi, xi] & phi = \\sum_(xi <- S) z xi *: xi}.\nProof.\ncase/orthogonal_span=> // _ -> {2}->; set z := fun _ => _ : algC.\nby exists z => //; apply: eq_big_seq => xi /nS1->; rewrite divr1.\nQed.",
    "Lemma cfnorm_orthonormal S :\n  orthonormal S -> '[\\sum_(xi <- S) xi] = (size S)%:R.\nProof. exact: cfnorm_map_orthonormal. Qed.",
    "Lemma vchar_orthonormalP S :\n    {subset S <= 'Z[irr G]} ->\n  reflect (exists I : {set Iirr G}, exists b : Iirr G -> bool,\n           perm_eq S [seq (-1) ^+ b i *: 'chi_i | i in I])\n          (orthonormal S).\nProof.\nmove=> vcS; apply: (equivP orthonormalP).\nsplit=> [[uniqS oSS] | [I [b defS]]]; last first.\n  split=> [|xi1 xi2]; rewrite ?(perm_mem defS).\n    rewrite (perm_uniq defS) map_inj_uniq ?enum_uniq // => i j /eqP.\n    by rewrite eq_signed_irr => /andP[_ /eqP].\n  case/mapP=> [i _ ->] /mapP[j _ ->]; rewrite eq_signed_irr.\n  rewrite cfdotZl cfdotZr rmorph_sign mulrA cfdot_irr -signr_addb mulr_natr.\n  by rewrite mulrb andbC; case: eqP => //= ->; rewrite addbb eqxx.\npose I := [set i | ('chi_i \\in S) || (- 'chi_i \\in S)].\npose b i := - 'chi_i \\in S; exists I, b.\napply: uniq_perm => // [|xi].\n  rewrite map_inj_uniq ?enum_uniq // => i j /eqP.\n  by rewrite eq_signed_irr => /andP[_ /eqP].\napply/idP/mapP=> [Sxi | [i Ii ->{xi}]]; last first.\n  move: Ii; rewrite mem_enum inE orbC -/(b i).\n  by case b_i: (b i); rewrite (scale1r, scaleN1r).\nhave: '[xi] = 1 by rewrite oSS ?eqxx.\nhave vc_xi := vcS _ Sxi; rewrite cfdot_sum_irr.\ncase/natr_sum_eq1 => [i _ | i [_ /eqP norm_xi_i xi_i'_0]].\n  by rewrite -normCK rpredX // natr_norm_int ?Cint_cfdot_vchar_irr.\nsuffices def_xi: xi = (-1) ^+ b i *: 'chi_i.\n  exists i; rewrite // mem_enum inE -/(b i) orbC.\n  by case: (b i) def_xi Sxi => // ->; rewrite scale1r.\nmove: Sxi; rewrite [xi]cfun_sum_cfdot (bigD1 i) //.\nrewrite big1 //= ?addr0 => [|j ne_ji]; last first.\n  apply/eqP; rewrite scaler_eq0 -normr_eq0 -[_ == 0](expf_eq0 _ 2) normCK.\n  by rewrite xi_i'_0 ?eqxx.\nhave:= norm_xi_i; rewrite (aut_intr _ (Cint_cfdot_vchar_irr _ _)) //.\nrewrite -subr_eq0 subr_sqr_1 mulf_eq0 subr_eq0 addr_eq0 /b scaler_sign.\ncase/pred2P=> ->; last by rewrite scaleN1r => ->.\nrewrite scale1r => Sxi; case: ifP => // SNxi.\nhave:= oSS _ _ Sxi SNxi; rewrite cfdotNr cfdot_irr eqxx; case: eqP => // _.\nby move/eqP; rewrite oppr_eq0 oner_eq0.\nQed.",
    "Lemma vchar_norm1P phi :\n    phi \\in 'Z[irr G] -> '[phi] = 1 ->\n  exists b : bool, exists i : Iirr G, phi = (-1) ^+ b *: 'chi_i.\nProof.\nmove=> Zphi phiN1.\nhave: orthonormal phi by rewrite /orthonormal/= phiN1 eqxx.\ncase/vchar_orthonormalP=> [xi /predU1P[->|] // | I [b def_phi]].\nhave: phi \\in (phi : seq _) := mem_head _ _.\nby rewrite (perm_mem def_phi) => /mapP[i _ ->]; exists (b i), i.\nQed.",
    "Lemma zchar_small_norm phi n :\n    phi \\in 'Z[irr G] -> '[phi] = n%:R -> (n < 4)%N ->\n  {S : n.-tuple 'CF(G) |\n    [/\\ orthonormal S, {subset S <= 'Z[irr G]} & phi = \\sum_(xi <- S) xi]}.\nProof.\nmove=> Zphi def_n lt_n_4.\npose S := [seq '[phi, 'chi_i] *: 'chi_i | i in irr_constt phi].\nhave def_phi: phi = \\sum_(xi <- S) xi.\n  rewrite big_image big_mkcond {1}[phi]cfun_sum_cfdot.\n  by apply: eq_bigr => i _; rewrite if_neg; case: eqP => // ->; rewrite scale0r.\nhave orthS: orthonormal S.\n  apply/orthonormalP; split=> [|_ _ /mapP[i phi_i ->] /mapP[j _ ->]].\n    rewrite map_inj_in_uniq ?enum_uniq // => i j; rewrite mem_enum => phi_i _.\n    by move/eqP; rewrite eq_scaled_irr (negbTE phi_i) => /andP[_ /= /eqP].\n  rewrite eq_scaled_irr cfdotZl cfdotZr cfdot_irr mulrA mulr_natr mulrb.\n  rewrite mem_enum in phi_i; rewrite (negbTE phi_i) andbC; case: eqP => // <-.\n  have /natrP[m def_m] := natr_norm_int (Cint_cfdot_vchar_irr i Zphi).\n  apply/eqP; rewrite eqxx /= -normCK def_m -natrX eqr_nat eqn_leq lt0n.\n  rewrite expn_eq0 andbT -eqC_nat -def_m normr_eq0 [~~ _]phi_i andbT.\n  rewrite (leq_exp2r _ 1) // -ltnS -(@ltn_exp2r _ _ 2) //.\n  apply: leq_ltn_trans lt_n_4; rewrite -leC_nat -def_n natrX.\n  rewrite cfdot_sum_irr (bigD1 i) //= -normCK def_m addrC -subr_ge0 addrK.\n  by rewrite sumr_ge0 // => ? _; apply: mul_conjC_ge0.\nhave <-: size S = n.\n  by apply/eqP; rewrite -eqC_nat -def_n def_phi cfnorm_orthonormal.\nexists (in_tuple S); split=> // _ /mapP[i _ ->].\nby rewrite scale_zchar ?irr_vchar // Cint_cfdot_vchar_irr.\nQed.",
    "Lemma vchar_norm2 phi :\n    phi \\in 'Z[irr G, G^#] -> '[phi] = 2 ->\n  exists i, exists2 j, j != i & phi = 'chi_i - 'chi_j.\nProof.\nrewrite zchar_split cfunD1E => /andP[Zphi phi1_0].\ncase/zchar_small_norm => // [[[|chi [|xi [|?]]] //= S2]].\ncase=> /andP[/and3P[Nchi Nxi _] /= ochi] /allP/and3P[Zchi Zxi _].\nrewrite big_cons big_seq1 => def_phi.\nhave [b [i def_chi]] := vchar_norm1P Zchi (eqP Nchi).\nhave [c [j def_xi]] := vchar_norm1P Zxi (eqP Nxi).\nhave neq_ji: j != i.\n  apply: contraTneq ochi; rewrite !andbT def_chi def_xi => ->.\n  rewrite cfdotZl cfdotZr rmorph_sign cfnorm_irr mulr1 -signr_addb.\n  by rewrite signr_eq0.\nhave neq_bc: b != c.\n  apply: contraTneq phi1_0; rewrite def_phi def_chi def_xi => ->.\n  rewrite -scalerDr !cfunE mulf_eq0 signr_eq0 eq_le lt_geF //.\n  by rewrite ltr_pDl ?irr1_gt0.\nrewrite {}def_phi {}def_chi {}def_xi !scaler_sign.\ncase: b c neq_bc => [|] [|] // _; last by exists i, j.\nby exists j, i; rewrite 1?eq_sym // addrC.\nQed.",
    "Lemma Zisometry_of_cfnorm (tauS : seq 'CF(G)) :\n    pairwise_orthogonal S -> pairwise_orthogonal tauS ->\n    map cfnorm tauS = map cfnorm S -> {subset tauS <= 'Z[irr G]} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | map tau S = tauS\n       & {in 'Z[S], isometry tau, to 'Z[irr G]}}.\nProof.\nmove=> oSS oTT /isometry_of_cfnorm[||tau defT Itau] // Z_T; exists tau => //.\nsplit=> [|_ /zchar_nth_expansion[u Zu ->]].\n  by apply: sub_in2 Itau; apply: zchar_span.\nrewrite big_seq linear_sum rpred_sum // => xi Sxi.\nby rewrite linearZ scale_zchar ?Z_T // -defT map_f ?mem_nth.\nQed.",
    "Lemma Zisometry_of_iso f :\n    free S -> {in S, isometry f, to 'Z[irr G]} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | {in S, tau =1 f}\n       & {in 'Z[S], isometry tau, to 'Z[irr G]}}.\nProof.\nmove=> freeS [If Zf]; have [tau Dtau Itau] := isometry_of_free freeS If.\nexists tau => //; split; first by apply: sub_in2 Itau; apply: zchar_span.\nmove=> _ /zchar_nth_expansion[a Za ->]; rewrite linear_sum rpred_sum // => i _.\nby rewrite linearZ rpredZ_int ?Dtau ?Zf ?mem_nth.\nQed.",
    "Lemma Zisometry_inj A nu :\n  {in 'Z[S, A] &, isometry nu} -> {in 'Z[S, A] &, injective nu}.\nProof. by move/isometry_raddf_inj; apply; apply: rpredB. Qed.",
    "Lemma isometry_in_zchar nu : {in S &, isometry nu} -> {in 'Z[S] &, isometry nu}.\nProof.\nmove=> Inu _ _ /zchar_nth_expansion[u Zu ->] /zchar_nth_expansion[v Zv ->].\nrewrite !raddf_sum; apply: eq_bigr => j _ /=.\nrewrite !cfdot_suml; apply: eq_bigr => i _.\nby rewrite !raddfZ_int //= !cfdotZl !cfdotZr Inu ?mem_nth.\nQed.",
    "Lemma cfAut_zchar S A psi :\n  cfAut_closed u S -> psi \\in 'Z[S, A] -> psi^u \\in 'Z[S, A].\nProof.\nrewrite zchar_split => SuS /andP[/zchar_nth_expansion[z Zz Dpsi] Apsi].\nrewrite zchar_split cfAut_on {}Apsi {psi}Dpsi rmorph_sum rpred_sum //= => i _.\nby rewrite cfAutZ_Cint // scale_zchar // mem_zchar ?SuS ?mem_nth.\nQed.",
    "Lemma cfAut_vchar A psi : psi \\in 'Z[irr G, A] -> psi^u \\in 'Z[irr G, A].\nProof. by apply: cfAut_zchar; apply: irr_aut_closed. Qed.",
    "Lemma sub_aut_zchar S A psi :\n   {subset S <= 'Z[irr G]} -> psi \\in 'Z[S, A] -> psi^u \\in 'Z[S, A] ->\n  psi - psi^u \\in 'Z[S, A^#].\nProof.\nmove=> Z_S Spsi Spsi_u; rewrite zcharD1 !cfunE subr_eq0 rpredB //=.\nby rewrite aut_intr // Cint_vchar1 // (zchar_trans Z_S) ?(zcharW Spsi).\nQed.",
    "Lemma conjC_vcharAut chi x : chi \\in 'Z[irr G] -> (u (chi x))^* = u (chi x)^*.\nProof.\ncase/vcharP=> chi1 Nchi1 [chi2 Nchi2 ->].\nby rewrite !cfunE !rmorphB !conjC_charAut.\nQed.",
    "Lemma cfdot_aut_vchar phi chi :\n  chi \\in 'Z[irr G] -> '[phi^u , chi^u] = u '[phi, chi].\nProof.\nby case/vcharP=> chi1 Nchi1 [chi2 Nchi2 ->]; rewrite !raddfB /= !cfdot_aut_char.\nQed.",
    "Lemma vchar_aut A chi : (chi^u \\in 'Z[irr G, A]) = (chi \\in 'Z[irr G, A]).\nProof.\nrewrite !(zchar_split _ A) cfAut_on; congr (_ && _).\napply/idP/idP=> [Zuchi|]; last exact: cfAut_vchar.\nrewrite [chi]cfun_sum_cfdot rpred_sum // => i _.\nrewrite scale_zchar ?irr_vchar //.\nby rewrite -(intr_aut u) -cfdot_aut_irr -aut_IirrE Cint_cfdot_vchar_irr.\nQed.",
    "Lemma cfRes_vchar phi : phi \\in 'Z[irr G] -> 'Res[H] phi \\in 'Z[irr H].\nProof.\ncase/vcharP=> xi1 Nx1 [xi2 Nxi2 ->].\nby rewrite raddfB rpredB ?char_vchar ?cfRes_char.\nQed.",
    "Lemma cfRes_vchar_on A phi :\n  H \\subset G -> phi \\in 'Z[irr G, A] -> 'Res[H] phi \\in 'Z[irr H, A].\nProof.\nrewrite zchar_split => sHG /andP[Zphi Aphi]; rewrite zchar_split cfRes_vchar //.\napply/cfun_onP=> x /(cfun_onP Aphi); rewrite !cfunElock !genGid sHG => ->.\nexact: mul0rn.\nQed.",
    "Lemma cfInd_vchar phi : phi \\in 'Z[irr H] -> 'Ind[G] phi \\in 'Z[irr G].\nProof.\nmove=> /vcharP[xi1 Nx1 [xi2 Nxi2 ->]].\nby rewrite raddfB rpredB ?char_vchar ?cfInd_char.\nQed.",
    "Lemma sub_conjC_vchar A phi :\n  phi \\in 'Z[irr G, A] -> phi - (phi^*)%CF \\in 'Z[irr G, A^#].\nProof.\nmove=> Zphi; rewrite sub_aut_zchar ?cfAut_zchar // => _ /irrP[i ->].\n  exact: irr_vchar.\nexact: cfConjC_irr.\nQed.",
    "Lemma Frobenius_kernel_exists :\n  [Frobenius G with complement H] -> {K : {group gT} | [Frobenius G = K ><| H]}.\nProof.\nmove=> frobG; have [_ ntiHG] := andP frobG.\nhave [[_ sHG regGH][_ tiHG /eqP defNH]] := (normedTI_memJ_P ntiHG, and3P ntiHG).\nsuffices /sigW[K defG]: exists K, gval K ><| H == G by exists K; apply/andP.\npose K1 := G :\\: cover (H^# :^: G).\nhave oK1: #|K1| = #|G : H|.\n  rewrite cardsD (setIidPr _); last first.\n    rewrite cover_imset; apply/bigcupsP=> x Gx.\n    by rewrite sub_conjg conjGid ?groupV // (subset_trans (subsetDl _ _)).\n  rewrite (cover_partition (partition_normedTI ntiHG)) -(Lagrange sHG).\n  by rewrite (card_support_normedTI ntiHG) (cardsD1 1%g) group1 mulSn addnK.\nsuffices extG i: {j | {in H, 'chi[G]_j =1 'chi[H]_i} & K1 \\subset cfker 'chi_j}.\n  pose K := [group of \\bigcap_i cfker 'chi_(s2val (extG i))].\n  have nKH: H \\subset 'N(K).\n    by apply/norms_bigcap/bigcapsP=> i _; apply: subset_trans (cfker_norm _).\n  have tiKH: K :&: H = 1%g.\n    apply/trivgP; rewrite -(TI_cfker_irr H) /= setIC; apply/bigcapsP=> i _.\n    apply/subsetP=> x /setIP[Hx /bigcapP/(_ i isT)/=]; rewrite !cfkerEirr !inE.\n    by case: (extG i) => /= j def_j _; rewrite !def_j.\n  exists K; rewrite sdprodE // eqEcard TI_cardMg // mul_subG //=; last first.\n    by rewrite (bigcap_min (0 : Iirr H)) ?cfker_sub.\n  rewrite -(Lagrange sHG) mulnC leq_pmul2r // -oK1 subset_leq_card //.\n  by apply/bigcapsP=> i _; case: (extG i).\ncase i0: (i == 0).\n  exists 0 => [x Hx|]; last by rewrite irr0 cfker_cfun1 subsetDl.\n  by rewrite (eqP i0) !irr0 !cfun1E // (subsetP sHG) ?Hx.\nhave ochi1: '['chi_i, 1] = 0 by rewrite -irr0 cfdot_irr i0.\npose a := 'chi_i 1%g; have Za: a \\in Num.int by rewrite intrE Cnat_irr1.\npose theta := 'chi_i - a%:A; pose phi := 'Ind[G] theta + a%:A.\nhave /cfun_onP theta0: theta \\in 'CF(H, H^#).\n  by rewrite cfunD1E !cfunE cfun11 mulr1 subrr.\nhave RItheta: 'Res ('Ind[G] theta) = theta.\n  apply/cfun_inP=> x Hx; rewrite cfResE ?cfIndE // (big_setID H) /= addrC.\n  apply: canLR (mulKf (neq0CG H)) _; rewrite (setIidPr sHG) mulr_natl.\n  rewrite big1 ?add0r => [|y /setDP[/regGH tiHy H'y]]; last first.\n    have [-> | ntx] := eqVneq x 1%g; first by rewrite conj1g theta0 ?inE ?eqxx.\n    by rewrite theta0 ?tiHy // !inE ntx.\n  by rewrite -sumr_const; apply: eq_bigr => y Hy; rewrite cfunJ.\nhave ophi1: '[phi, 1] = 0.\n  rewrite cfdotDl -cfdot_Res_r cfRes_cfun1 // cfdotBl !cfdotZl !cfnorm1.\n  by rewrite ochi1 add0r addNr.\nhave{ochi1} n1phi: '[phi] = 1.\n  have: '[phi - a%:A] = '[theta] by rewrite addrK -cfdot_Res_l RItheta.\n  rewrite !cfnormBd ?cfnormZ ?cfdotZr ?ophi1 ?ochi1 ?mulr0 //.\n  by rewrite !cfnorm1 cfnorm_irr => /addIr.\nhave Zphi: phi \\in 'Z[irr G].\n  by rewrite rpredD ?cfInd_vchar ?rpredB ?irr_vchar // scale_zchar ?rpred1.\nhave def_phi: {in H, phi =1 'chi_i}.\n  move=> x Hx /=; rewrite !cfunE -[_ x](cfResE _ sHG) ?RItheta //.\n  by rewrite !cfunE !cfun1E ?(subsetP sHG) ?Hx ?subrK.\nhave [j def_chi_j]: {j | 'chi_j = phi}.\n  apply/sig_eqW; have [[] [j]] := vchar_norm1P Zphi n1phi; last first.\n    by rewrite scale1r; exists j.\n  move/cfunP/(_ 1%g)/eqP; rewrite scaleN1r def_phi // cfunE -addr_eq0 eq_le.\n  by rewrite lt_geF // ltr_pDl ?irr1_gt0.\nexists j; rewrite ?cfkerEirr def_chi_j //; apply/subsetP => x /setDP[Gx notHx].\nrewrite inE cfunE def_phi // cfunE -/a cfun1E // Gx mulr1 cfIndE //.\nrewrite big1 ?mulr0 ?add0r // => y Gy; apply/theta0/(contra _ notHx) => Hxy.\nby rewrite -(conjgK y x) cover_imset -class_supportEr imset2_f ?groupV.\nQed.",
    "Lemma dirr_opp v : (- v \\in dirr G) = (v \\in dirr G). Proof. exact: rpredN. Qed.",
    "Lemma dirr_sign n v : ((-1)^+ n *: v \\in dirr G) = (v \\in dirr G).\nProof. exact: rpredZsign. Qed.",
    "Lemma irr_dirr i : 'chi_i \\in dirr G.\nProof. by rewrite !inE mem_irr. Qed.",
    "Lemma dirrP f :\n  reflect (exists b : bool, exists i, f = (-1) ^+ b *: 'chi_i) (f \\in dirr G).\nProof.\napply: (iffP idP) => [| [b [i ->]]]; last by rewrite dirr_sign irr_dirr.\ncase/orP=> /irrP[i Hf]; first by exists false, i; rewrite scale1r.\nby exists true, i; rewrite scaleN1r -Hf opprK.\nQed.",
    "Lemma dirrE phi : phi \\in dirr G = (phi \\in 'Z[irr G]) && ('[phi] == 1).\nProof.\napply/dirrP/andP=> [[b [i ->]] | [Zphi /eqP/vchar_norm1P]]; last exact.\nby rewrite rpredZsign irr_vchar cfnorm_sign cfnorm_irr.\nQed.",
    "Lemma cfdot_dirr f g : f \\in dirr G -> g \\in dirr G ->\n  '[f, g] = (if f == - g then -1 else (f == g)%:R).\nProof.\ncase/dirrP=> [b1 [i1 ->]] /dirrP[b2 [i2 ->]].\nrewrite cfdotZl cfdotZr rmorph_sign mulrA -signr_addb cfdot_irr.\nrewrite -scaleNr -signrN !eq_scaled_irr signr_eq0 !(inj_eq signr_inj) /=.\nby rewrite -!negb_add addbN mulr_sign -mulNrn mulrb; case: ifP.\nQed.",
    "Lemma dirr_norm1 phi : phi \\in 'Z[irr G] -> '[phi] = 1 -> phi \\in dirr G.\nProof. by rewrite dirrE => -> -> /=. Qed.",
    "Lemma dirr_aut u phi : (cfAut u phi \\in dirr G) = (phi \\in dirr G).\nProof.\nrewrite !dirrE vchar_aut; apply: andb_id2l => /cfdot_aut_vchar->.\nexact: fmorph_eq1.\nQed.",
    "Lemma ndirr_diff (i : dIirr G) : ndirr i != i.\nProof. by case: i => [] [|] i. Qed.",
    "Lemma ndirrK : involutive (@ndirr G).\nProof. by move=> [b i]; rewrite /ndirr /= negbK. Qed.",
    "Lemma ndirr_inj : injective (@ndirr G).\nProof. exact: (inv_inj ndirrK). Qed.",
    "Lemma dchi1 : dchi (dirr1 G) = 1.\nProof. by rewrite /dchi scale1r irr0. Qed.",
    "Lemma dirr_dchi i : dchi i \\in dirr G.\nProof. by apply/dirrP; exists i.1; exists i.2. Qed.",
    "Lemma dIrrP phi : reflect (exists i, phi = dchi i) (phi \\in dirr G).\nProof.\nby apply: (iffP idP)=> [/dirrP[b]|] [i ->]; [exists (b, i) | apply: dirr_dchi].\nQed.",
    "Lemma dchi_ndirrE (i : dIirr G) : dchi (ndirr i) = - dchi i.\nProof. by case: i => [b i]; rewrite /ndirr /dchi signrN scaleNr. Qed.",
    "Lemma cfdot_dchi (i j : dIirr G) : \n  '[dchi i, dchi j] = (i == j)%:R - (i == ndirr j)%:R.\nProof.\ncase: i => bi i; case: j => bj j; rewrite cfdot_dirr ?dirr_dchi // !xpair_eqE.\nrewrite -dchi_ndirrE !eq_scaled_irr signr_eq0 !(inj_eq signr_inj) /=.\nby rewrite -!negb_add addbN negbK; case: andP => [[->]|]; rewrite ?subr0 ?add0r.\nQed.",
    "Lemma dchi_vchar i : dchi i \\in 'Z[irr G].\nProof. by case: i => b i; rewrite rpredZsign irr_vchar. Qed.",
    "Lemma cfnorm_dchi (i : dIirr G) : '[dchi i] = 1.\nProof.  by case: i => b i; rewrite cfnorm_sign cfnorm_irr. Qed.",
    "Lemma dirr_inj : injective (@dchi G).\nProof.\ncase=> b1 i1 [b2 i2] /eqP; rewrite eq_scaled_irr (inj_eq signr_inj) /=.\nby rewrite signr_eq0 -xpair_eqE => /eqP.\nQed.",
    "Lemma dirr_dIirrPE J (f : J -> 'CF(G)) (P : pred J) :\n    (forall j, P j -> f j \\in dirr G) ->\n  forall j, P j -> dchi (dirr_dIirr f j) = f j.\nProof.\nrewrite /dirr_dIirr => dirrGf j Pj; case: pickP => [i /eqP //|].\nby have /dIrrP[i-> /(_ i)/eqP] := dirrGf j Pj.\nQed.",
    "Lemma dirr_dIirrE J (f : J -> 'CF(G)) :\n  (forall j, f j \\in dirr G) -> forall j, dchi (dirr_dIirr f j) = f j.\nProof. by move=> dirrGf j; apply: (@dirr_dIirrPE _ _ xpredT). Qed.",
    "Lemma dirr_consttE (phi : 'CF(G)) (i : dIirr G) :\n  (i \\in dirr_constt phi) = (0 < '[phi, dchi i]).\nProof. by rewrite inE. Qed.",
    "Lemma Cnat_dirr (phi : 'CF(G)) i :\n  phi \\in 'Z[irr G] -> i \\in dirr_constt phi -> '[phi, dchi i] \\in Num.nat.\nProof.\nmove=> PiZ; rewrite natrEint dirr_consttE andbC => /ltW -> /=.\nby case: i => b i; rewrite cfdotZr rmorph_sign rpredMsign Cint_cfdot_vchar_irr.\nQed.",
    "Lemma dirr_constt_oppr (i : dIirr G) (phi : 'CF(G)) :\n  (i \\in dirr_constt (-phi)) = (ndirr i \\in dirr_constt phi).\nProof. by rewrite !dirr_consttE dchi_ndirrE cfdotNl cfdotNr. Qed.",
    "Lemma dirr_constt_oppI (phi: 'CF(G)) :\n   dirr_constt phi :&: dirr_constt (-phi) = set0.\nProof.\napply/setP=> i; rewrite inE !dirr_consttE cfdotNl inE.\napply/idP=> /andP [L1 L2]; have := ltr_pDl L1 L2.\nby rewrite subrr lt_def eqxx.\nQed.",
    "Lemma dirr_constt_oppl (phi: 'CF(G)) i :\n  i \\in dirr_constt phi -> (ndirr i) \\notin dirr_constt phi.\nProof.\nby rewrite !dirr_consttE dchi_ndirrE cfdotNr oppr_gt0 => /ltW /le_gtF ->.\nQed.",
    "Lemma irr_constt_to_dirr (phi: 'CF(G)) i : phi \\in 'Z[irr G] ->\n  (i \\in irr_constt phi) = (to_dirr phi i \\in dirr_constt phi).\nProof.\nmove=> Zphi; rewrite irr_consttE dirr_consttE cfdotZr rmorph_sign /=.\nby rewrite -real_normrEsign ?normr_gt0 ?Rreal_int // Cint_cfdot_vchar_irr.\nQed.",
    "Lemma to_dirrK (phi: 'CF(G)) : cancel (to_dirr phi) (@of_irr G).\nProof. by []. Qed.",
    "Lemma of_irrK (phi: 'CF(G)) :\n  {in dirr_constt phi, cancel (@of_irr G) (to_dirr phi)}.\nProof.\ncase=> b i; rewrite dirr_consttE cfdotZr rmorph_sign /= /to_dirr mulr_sign.\nby rewrite fun_if oppr_gt0; case: b => [|/ltW/le_gtF] ->.\nQed.",
    "Lemma cfdot_todirrE (phi: 'CF(G)) i (phi_i := dchi (to_dirr phi i)) :\n  '[phi, phi_i] *: phi_i = '[phi, 'chi_i] *: 'chi_i.\nProof. by rewrite cfdotZr rmorph_sign mulrC -scalerA signrZK. Qed.",
    "Lemma cfun_sum_dconstt (phi : 'CF(G)) :\n    phi \\in 'Z[irr G] ->\n  phi = \\sum_(i in dirr_constt phi) '[phi, dchi i] *: dchi i.\nProof.\nmove=> PiZ; rewrite [LHS]cfun_sum_constt.\nrewrite (reindex (to_dirr phi))=> [/= |]; last first.\n  by exists (@of_irr _)=> //; apply: of_irrK .\nby apply: eq_big => i; rewrite ?irr_constt_to_dirr // cfdot_todirrE.\nQed.",
    "Lemma cnorm_dconstt (phi : 'CF(G)) :\n  phi \\in 'Z[irr G] ->\n  '[phi] = \\sum_(i in dirr_constt phi) '[phi, dchi i] ^+ 2.\nProof.\nmove=> PiZ; rewrite {1 2}(cfun_sum_dconstt PiZ).\nrewrite cfdot_suml; apply: eq_bigr=> i IiD.\nrewrite cfdot_sumr (bigD1 i) //= big1 ?addr0 => [|j /andP [JiD IdJ]].\n  rewrite cfdotZr cfdotZl cfdot_dchi eqxx eq_sym (negPf (ndirr_diff i)).\n  by rewrite subr0 mulr1 aut_natr ?Cnat_dirr.\nrewrite cfdotZr cfdotZl cfdot_dchi eq_sym (negPf IdJ) -natrB ?mulr0 //.\nby rewrite (negPf (contraNneq _ (dirr_constt_oppl JiD))) => // <-.\nQed.",
    "Lemma dirr_small_norm (phi : 'CF(G)) n :\n  phi \\in 'Z[irr G] -> '[phi] = n%:R -> (n < 4)%N ->\n  [/\\ #|dirr_constt phi| = n, dirr_constt phi :&: dirr_constt (- phi) = set0 &\n      phi = \\sum_(i in dirr_constt phi) dchi i].\nProof.\nmove=> PiZ Pln; rewrite ltnNge -leC_nat => Nl4.\nsuffices Fd i: i \\in dirr_constt phi -> '[phi, dchi i] = 1.\n  split; last 2 [by apply/setP=> u; rewrite !inE cfdotNl oppr_gt0 lt_asym].\n    apply/eqP; rewrite -eqC_nat -sumr_const -Pln (cnorm_dconstt PiZ).\n    by apply/eqP/eq_bigr=> i Hi; rewrite Fd // expr1n.\n  rewrite {1}[phi]cfun_sum_dconstt //.\n  by apply: eq_bigr => i /Fd->; rewrite scale1r.\nmove=> IiD; apply: contraNeq Nl4 => phi_i_neq1.\nrewrite -Pln cnorm_dconstt // (bigD1 i) ?ler_wpDr ?sumr_ge0 //=.\n  by move=> j /andP[JiD _]; rewrite exprn_ge0 ?natr_ge0 ?Cnat_dirr.\nhave /natrP[m Dm] := Cnat_dirr PiZ IiD; rewrite Dm -natrX ler_nat (leq_sqr 2).\nby rewrite ltn_neqAle eq_sym -eqC_nat -ltC_nat -Dm phi_i_neq1 -dirr_consttE.\nQed.",
    "Lemma cfdot_sum_dchi (phi1 phi2 : 'CF(G)) :\n  '[\\sum_(i in dirr_constt phi1) dchi i,\n    \\sum_(i in dirr_constt phi2) dchi i] =\n  #|dirr_constt phi1 :&: dirr_constt phi2|%:R -\n    #|dirr_constt phi1 :&: dirr_constt (- phi2)|%:R.\nProof.\nrewrite addrC (big_setID (dirr_constt (- phi2))) /= cfdotDl; congr (_ + _).\n  rewrite cfdot_suml -sumr_const -sumrN; apply: eq_bigr => i /setIP[p1i p2i].\n  rewrite cfdot_sumr (bigD1 (ndirr i)) -?dirr_constt_oppr //= dchi_ndirrE.\n  rewrite cfdotNr cfnorm_dchi big1 ?addr0 // => j /andP[p2j i'j].\n  rewrite cfdot_dchi -(inv_eq ndirrK) [in rhs in - rhs]eq_sym (negPf i'j) subr0.\n  rewrite (negPf (contraTneq _ p2i)) // => ->.\n  by rewrite dirr_constt_oppr dirr_constt_oppl.\nrewrite cfdot_sumr (big_setID (dirr_constt phi1)) setIC /= addrC.\nrewrite big1 ?add0r => [|j /setDP[p2j p1'j]]; last first.\n  rewrite cfdot_suml big1 // => i /setDP[p1i p2'i].\n  rewrite cfdot_dchi (negPf (contraTneq _ p1i)) => [|-> //].\n  rewrite (negPf (contraNneq _ p2'i)) ?subrr // => ->.\n  by rewrite dirr_constt_oppr ndirrK.\nrewrite -sumr_const; apply: eq_bigr => i /setIP[p1i p2i]; rewrite cfdot_suml.\nrewrite (bigD1 i) /=; last by rewrite inE dirr_constt_oppr dirr_constt_oppl.\nrewrite cfnorm_dchi big1 ?addr0 // => j /andP[/setDP[p1j _] i'j].\nrewrite cfdot_dchi (negPf i'j) (negPf (contraTneq _ p1j)) ?subrr // => ->.\nexact: dirr_constt_oppl.\nQed.",
    "Lemma cfdot_dirr_eq1 :\n  {in dirr G &, forall phi psi, ('[phi, psi] == 1) = (phi == psi)}.\nProof.\nmove=> _ _ /dirrP[b1 [i1 ->]] /dirrP[b2 [i2 ->]].\nrewrite eq_signed_irr cfdotZl cfdotZr rmorph_sign cfdot_irr mulrA -signr_addb.\nrewrite pmulrn -rmorphMsign (eqr_int _ _ 1) -negb_add.\nby case: (b1 (+) b2) (i1 == i2) => [] [].\nQed.",
    "Lemma cfdot_add_dirr_eq1 :\n  {in dirr G & &, forall phi1 phi2 psi,\n    '[phi1 + phi2, psi] = 1 -> psi = phi1 \\/ psi = phi2}.\nProof.\nmove=> _ _ _ /dirrP[b1 [i1 ->]] /dirrP[b2 [i2 ->]] /dirrP[c [j ->]] /eqP.\nrewrite cfdotDl !cfdotZl !cfdotZr !rmorph_sign !cfdot_irr !mulrA -!signr_addb.\nrewrite 2!{1}signrE !mulrBl !mul1r -!natrM addrCA -subr_eq0 -!addrA.\nrewrite -!opprD addrA subr_eq0 -mulrSr -!natrD eqr_nat => eq_phi_psi.\napply/pred2P; rewrite /= !eq_signed_irr -!negb_add !(eq_sym j) !(addbC c).\nby case: (i1 == j) eq_phi_psi; case: (i2 == j); do 2!case: (_ (+) c).\nQed.",
    "Lemma neq0CG G : (#|G|)%:R != 0 :> algC. Proof. exact: natrG_neq0. Qed.",
    "Lemma neq0CiG G B : (#|G : B|)%:R != 0 :> algC.\nProof. exact: natr_indexg_neq0. Qed.",
    "Lemma gt0CG G : 0 < #|G|%:R :> algC. Proof. exact: natrG_gt0. Qed.",
    "Lemma gt0CiG G B : 0 < #|G : B|%:R :> algC. Proof. exact: natr_indexg_gt0. Qed.",
    "Lemma algC'G_pchar G : [pchar algC]^'.-group G.\nProof. by apply/pgroupP=> p _; rewrite inE /= pchar_num. Qed.",
    "Lemma intro_class_fun (G : {group gT}) f :\n    {in G &, forall x y, f (x ^ y) = f x} ->\n    (forall x, x \\notin G -> f x = 0) ->\n  is_class_fun G (finfun f).\nProof.\nmove=> fJ Gf; apply/andP; split; last first.\n  by apply/supportP=> x notAf; rewrite ffunE Gf.\napply/'forall_eqfun_inP=> x y Gy; rewrite !ffunE.\nby have [/fJ-> // | notGx] := boolP (x \\in G); rewrite !Gf ?groupJr.\nQed.",
    "Lemma cfunElock k f fP : @Cfun k (finfun f) fP =1 f.\nProof. by rewrite locked_withE; apply: ffunE. Qed.",
    "Lemma cfunE f fP : @Cfun 0 (finfun f) fP =1 f.\nProof. exact: cfunElock. Qed.",
    "Lemma cfunP phi psi : phi =1 psi <-> phi = psi.\nProof. by split=> [/ffunP/val_inj | ->]. Qed.",
    "Lemma cfun0gen phi x : x \\notin G -> phi x = 0.\nProof. by case: phi => f fP; case: (andP fP) => _ /supportP; apply. Qed.",
    "Lemma cfun_in_genP phi psi : {in G, phi =1 psi} -> phi = psi.\nProof.\nmove=> eq_phi; apply/cfunP=> x.\nby have [/eq_phi-> // | notAx] := boolP (x \\in G); rewrite !cfun0gen.\nQed.",
    "Lemma cfunJgen phi x y : y \\in G -> phi (x ^ y) = phi x.\nProof.\ncase: phi => f fP Gy; apply/eqP.\nby case: (andP fP) => /'forall_forall_inP->.\nQed.",
    "Lemma cfun1Egen x : '1_G x = (x \\in G)%:R.\nProof. by rewrite cfunElock andb_idr // => /class_subG->. Qed.",
    "Lemma muln_cfunE phi n x : (phi *+ n) x = phi x *+ n.\nProof. by elim: n => [|n IHn]; rewrite ?mulrS !cfunE ?IHn. Qed.",
    "Lemma sum_cfunE I r (P : pred I) (phi : I -> classfun) x :\n  (\\sum_(i <- r | P i) phi i) x = \\sum_(i <- r | P i) (phi i) x.\nProof. by elim/big_rec2: _ => [|i _ psi _ <-]; rewrite cfunE. Qed.",
    "Lemma expS_cfunE phi n x : (phi ^+ n.+1) x = phi x ^+ n.+1.\nProof. by elim: n => //= n IHn; rewrite !cfunE IHn. Qed.",
    "Lemma cfAut_cfun1i A : cfAut '1_A = '1_A.\nProof. by apply/cfunP=> x; rewrite !cfunElock rmorph_nat. Qed.",
    "Lemma cfAutZ a phi : cfAut (a *: phi) = u a *: cfAut phi.\nProof. by apply/cfunP=> x; rewrite !cfunE rmorphM. Qed.",
    "Lemma cfAut_is_additive : additive cfAut.\nProof.\nby move=> phi psi; apply/cfunP=> x; rewrite ?cfAut_cfun1i // !cfunE /= rmorphB.\nQed.",
    "Lemma cfAut_is_multiplicative : multiplicative cfAut.\nProof.\nby split=> [phi psi|]; apply/cfunP=> x; rewrite ?cfAut_cfun1i // !cfunE rmorphM.\nQed.",
    "Lemma cfAut_cfun1 : cfAut 1 = 1. Proof. exact: rmorph1. Qed.",
    "Lemma cfAut_scalable : scalable_for (u \\; *:%R) cfAut.\nProof. by move=> a phi; apply/cfunP=> x; rewrite !cfunE rmorphM. Qed.",
    "Lemma cfun0 phi x : x \\notin G -> phi x = 0.\nProof. by rewrite -{1}(genGid G) => /(cfun0gen phi). Qed.",
    "Lemma support_cfun phi : support phi \\subset G.\nProof. by apply/subsetP=> g; apply: contraR => /cfun0->. Qed.",
    "Lemma cfunJ phi x y : y \\in G -> phi (x ^ y) = phi x.\nProof. by rewrite -{1}(genGid G) => /(cfunJgen phi)->. Qed.",
    "Lemma cfun_repr phi x : phi (repr (x ^: G)) = phi x.\nProof. by have [y Gy ->] := repr_class G x; apply: cfunJ. Qed.",
    "Lemma cfun_inP phi psi : {in G, phi =1 psi} -> phi = psi.\nProof. by rewrite -{1}genGid => /cfun_in_genP. Qed.",
    "Lemma cfuniE A x : A <| G -> '1_A x = (x \\in A)%:R.\nProof.\ncase/andP=> sAG nAG; rewrite cfunElock genGid.\nby rewrite class_sub_norm // andb_idl // => /(subsetP sAG).\nQed.",
    "Lemma support_cfuni A : A <| G -> support '1_A =i A.\nProof. by move=> nsAG x; rewrite !inE cfuniE // pnatr_eq0 -lt0n lt0b. Qed.",
    "Lemma eq_mul_cfuni A phi : A <| G -> {in A, phi * '1_A =1 phi}.\nProof. by move=> nsAG x Ax; rewrite cfunE cfuniE // Ax mulr1. Qed.",
    "Lemma eq_cfuni A : A <| G -> {in A, '1_A =1 (1 : 'CF(G))}.\nProof. by rewrite -['1_A]mul1r; apply: eq_mul_cfuni. Qed.",
    "Lemma cfuniG : '1_G = 1.\nProof. by rewrite -[G in '1_G]genGid. Qed.",
    "Lemma cfun1E g : (1 : 'CF(G)) g = (g \\in G)%:R.\nProof. by rewrite -cfuniG cfuniE. Qed.",
    "Lemma cfun11 : (1 : 'CF(G)) 1%g = 1.\nProof. by rewrite cfun1E group1. Qed.",
    "Lemma prod_cfunE I r (P : pred I) (phi : I -> 'CF(G)) x :\n  x \\in G -> (\\prod_(i <- r | P i) phi i) x = \\prod_(i <- r | P i) (phi i) x.\nProof.\nby move=> Gx; elim/big_rec2: _ => [|i _ psi _ <-]; rewrite ?cfunE ?cfun1E ?Gx.\nQed.",
    "Lemma exp_cfunE phi n x : x \\in G -> (phi ^+ n) x = phi x ^+ n.\nProof. by rewrite -[n]card_ord -!prodr_const; apply: prod_cfunE. Qed.",
    "Lemma mul_cfuni A B : '1_A * '1_B = '1_(A :&: B) :> 'CF(G).\nProof.\napply/cfunP=> g; rewrite !cfunElock -natrM mulnb subsetI.\nby rewrite andbCA !andbA andbb.\nQed.",
    "Lemma cfun_classE x y : '1_(x ^: G) y = ((x \\in G) && (y \\in x ^: G))%:R.\nProof.\nrewrite cfunElock genGid class_sub_norm ?class_norm //; congr (_ : bool)%:R.\nby apply: andb_id2r => /imsetP[z Gz ->]; rewrite groupJr.\nQed.",
    "Lemma cfun_on_sum A :\n  'CF(G, A) = (\\sum_(xG in classes G | xG \\subset A) <['1_xG]>)%VS.\nProof.\nby rewrite ['CF(G, A)]span_def big_image; apply: eq_bigl => xG; rewrite !inE.\nQed.",
    "Lemma cfun_onP A phi :\n  reflect (forall x, x \\notin A -> phi x = 0) (phi \\in 'CF(G, A)).\nProof.\napply: (iffP idP) => [/coord_span-> x notAx | Aphi].\n  set b := cfun_base G A; rewrite sum_cfunE big1 // => i _; rewrite cfunE.\n  have /mapP[xG]: b`_i \\in b by rewrite -tnth_nth mem_tnth.\n  rewrite mem_enum => /setIdP[/imsetP[y Gy ->] Ay] ->.\n  by rewrite cfun_classE Gy (contraNF (subsetP Ay x)) ?mulr0.\nsuffices <-: \\sum_(xG in classes G) phi (repr xG) *: '1_xG = phi.\n  apply: memv_suml => _ /imsetP[x Gx ->]; rewrite rpredZeq cfun_repr.\n  have [s_xG_A | /subsetPn[_ /imsetP[y Gy ->]]] := boolP (x ^: G \\subset A).\n    by rewrite cfun_on_sum [_ \\in _](sumv_sup (x ^: G)) ?mem_classes ?orbT.\n  by move/Aphi; rewrite cfunJ // => ->; rewrite eqxx.\napply/cfun_inP=> x Gx; rewrite sum_cfunE (bigD1 (x ^: G)) ?mem_classes //=.\nrewrite cfunE cfun_repr cfun_classE Gx class_refl mulr1.\nrewrite big1 ?addr0 // => _ /andP[/imsetP[y Gy ->]]; apply: contraNeq.\nrewrite cfunE cfun_repr cfun_classE Gy mulf_eq0 => /norP[_].\nby rewrite pnatr_eq0 -lt0n lt0b => /class_eqP->.\nQed.",
    "Lemma cfun_on0 A phi x : phi \\in 'CF(G, A) -> x \\notin A -> phi x = 0.\nProof. by move/cfun_onP; apply. Qed.",
    "Lemma sum_by_classes (R : nzRingType) (F : gT -> R) :\n    {in G &, forall g h, F (g ^ h) = F g} ->\n  \\sum_(g in G) F g = \\sum_(xG in classes G) #|xG|%:R * F (repr xG).\nProof.\nmove=> FJ; rewrite {1}(partition_big _  _ ((@mem_classes gT)^~ G)) /=.\napply: eq_bigr => _ /imsetP[x Gx ->]; have [y Gy ->] := repr_class G x.\nrewrite mulr_natl -sumr_const FJ {y Gy}//; apply/esym/eq_big=> y /=.\n  apply/idP/andP=> [xGy | [Gy /eqP<-]]; last exact: class_refl.\n  by rewrite (class_eqP xGy) (subsetP (class_subG Gx (subxx _))).\nby case/imsetP=> z Gz ->; rewrite FJ.\nQed.",
    "Lemma cfun_base_free A : free (cfun_base G A).\nProof.\nhave b_i (i : 'I_#|classes G ::&: A|) : (cfun_base G A)`_i = '1_(enum_val i).\n  by rewrite /enum_val -!tnth_nth tnth_map.\napply/freeP => s S0 i; move/cfunP/(_ (repr (enum_val i))): S0.\nrewrite sum_cfunE (bigD1 i) //= big1 ?addr0 => [|j].\n  rewrite b_i !cfunE; have /setIdP[/imsetP[x Gx ->] _] := enum_valP i.\n  by rewrite cfun_repr cfun_classE Gx class_refl mulr1.\napply: contraNeq; rewrite b_i !cfunE mulf_eq0 => /norP[_].\nrewrite -(inj_eq enum_val_inj).\nhave /setIdP[/imsetP[x _ ->] _] := enum_valP i; rewrite cfun_repr.\nhave /setIdP[/imsetP[y Gy ->] _] := enum_valP j; rewrite cfun_classE Gy.\nby rewrite pnatr_eq0 -lt0n lt0b => /class_eqP->.\nQed.",
    "Lemma dim_cfun : \\dim 'CF(G) = #|classes G|.\nProof. by rewrite dimvf /dim /= genGid. Qed.",
    "Lemma dim_cfun_on A : \\dim 'CF(G, A) = #|classes G ::&: A|.\nProof. by rewrite (eqnP (cfun_base_free A)) size_tuple. Qed.",
    "Lemma dim_cfun_on_abelian A : abelian G -> A \\subset G -> \\dim 'CF(G, A) = #|A|.\nProof.\nmove/abelian_classP=> cGG sAG; rewrite -(card_imset _ set1_inj) dim_cfun_on.\napply/eq_card=> xG; rewrite !inE.\napply/andP/imsetP=> [[/imsetP[x Gx ->] Ax] | [x Ax ->]] {xG}.\n  by rewrite cGG ?sub1set // in Ax *; exists x.\nby rewrite -{1}(cGG x) ?mem_classes ?(subsetP sAG) ?sub1set.\nQed.",
    "Lemma cfuni_on A : '1_A \\in 'CF(G, A).\nProof.\napply/cfun_onP=> x notAx; rewrite cfunElock genGid.\nby case: andP => // [[_ s_xG_A]]; rewrite (subsetP s_xG_A) ?class_refl in notAx.\nQed.",
    "Lemma mul_cfuni_on A phi : phi * '1_A \\in 'CF(G, A).\nProof.\nby apply/cfun_onP=> x /(cfun_onP (cfuni_on A)) Ax0; rewrite cfunE Ax0 mulr0.\nQed.",
    "Lemma cfun_onE phi A : (phi \\in 'CF(G, A)) = (support phi \\subset A).\nProof. exact: (sameP cfun_onP supportP). Qed.",
    "Lemma cfun_onT phi : phi \\in 'CF(G, [set: gT]).\nProof. by rewrite cfun_onE. Qed.",
    "Lemma cfun_onD1 phi A :\n  (phi \\in 'CF(G, A^#)) = (phi \\in 'CF(G, A)) && (phi 1%g == 0).\nProof.\nby rewrite !cfun_onE -!(eq_subset (in_set (support _))) subsetD1 !inE negbK.\nQed.",
    "Lemma cfun_onG phi : phi \\in 'CF(G, G).\nProof. by rewrite cfun_onE support_cfun. Qed.",
    "Lemma cfunD1E phi : (phi \\in 'CF(G, G^#)) = (phi 1%g == 0).\nProof. by rewrite cfun_onD1 cfun_onG. Qed.",
    "Lemma cfunGid : 'CF(G, G) = 'CF(G)%VS.\nProof. by apply/vspaceP=> phi; rewrite cfun_onG memvf. Qed.",
    "Lemma cfun_onS A B phi : B \\subset A -> phi \\in 'CF(G, B) -> phi \\in 'CF(G, A).\nProof. by rewrite !cfun_onE => sBA /subset_trans->. Qed.",
    "Lemma cfun_complement A :\n  A <| G -> ('CF(G, A) + 'CF(G, G :\\: A)%SET = 'CF(G))%VS.\nProof.\ncase/andP=> sAG nAG; rewrite -cfunGid [rhs in _ = rhs]cfun_on_sum.\nrewrite (bigID (fun B => B \\subset A)) /=.\ncongr (_ + _)%VS; rewrite cfun_on_sum; apply: eq_bigl => /= xG.\n  rewrite andbAC; apply/esym/andb_idr=> /andP[/imsetP[x Gx ->] _].\n  by rewrite class_subG.\nrewrite -andbA; apply: andb_id2l => /imsetP[x Gx ->].\nby rewrite !class_sub_norm ?normsD ?normG // inE andbC.\nQed.",
    "Lemma cfConjCE phi x : ( phi^* )%CF x = (phi x)^*.\nProof. by rewrite cfunE. Qed.",
    "Lemma cfConjCK : involutive (fun phi => phi^* )%CF.\nProof. by move=> phi; apply/cfunP=> x; rewrite !cfunE /= conjCK. Qed.",
    "Lemma cfConjC_cfun1 : ( 1^* )%CF = 1 :> 'CF(G).\nProof. exact: rmorph1. Qed.",
    "Lemma cfker_sub phi : cfker phi \\subset G.\nProof. by rewrite /cfker setIdE subsetIl. Qed.",
    "Lemma cfker_norm phi : G \\subset 'N(cfker phi).\nProof.\napply/subsetP=> z Gz; have phiJz := cfunJ phi _ (groupVr Gz).\nrewrite inE; apply/subsetP=> _ /imsetP[x /setIdP[Gx /forallP-Kx] ->].\nrewrite inE groupJ //; apply/forallP=> y.\nby rewrite -(phiJz y) -phiJz conjMg conjgK Kx.\nQed.",
    "Lemma cfker_normal phi : cfker phi <| G.\nProof. by rewrite /normal cfker_sub cfker_norm. Qed.",
    "Lemma cfkerMl phi x y : x \\in cfker phi -> phi (x * y)%g = phi y.\nProof. by case/setIdP=> _ /eqfunP->. Qed.",
    "Lemma cfkerMr phi x y : x \\in cfker phi -> phi (y * x)%g = phi y.\nProof.\nby move=> Kx; rewrite conjgC cfkerMl ?cfunJ ?(subsetP (cfker_sub phi)).\nQed.",
    "Lemma cfker1 phi x : x \\in cfker phi -> phi x = phi 1%g.\nProof. by move=> Kx; rewrite -[x]mulg1 cfkerMl. Qed.",
    "Lemma cfker_cfun0 : @cfker _ G 0 = G.\nProof.\napply/setP=> x; rewrite !inE andb_idr // => Gx; apply/forallP=> y.\nby rewrite !cfunE.\nQed.",
    "Lemma cfker_add phi psi : cfker phi :&: cfker psi \\subset cfker (phi + psi).\nProof.\napply/subsetP=> x /setIP[Kphi_x Kpsi_x]; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE !cfkerMl.\nQed.",
    "Lemma cfker_sum I r (P : pred I) (Phi : I -> 'CF(G)) :\n  G :&: \\bigcap_(i <- r | P i) cfker (Phi i)\n   \\subset cfker (\\sum_(i <- r | P i) Phi i).\nProof.\nelim/big_rec2: _ => [|i K psi Pi sK_psi]; first by rewrite setIT cfker_cfun0.\nby rewrite setICA; apply: subset_trans (setIS _ sK_psi) (cfker_add _ _).\nQed.",
    "Lemma cfker_scale a phi : cfker phi \\subset cfker (a *: phi).\nProof.\napply/subsetP=> x Kphi_x; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE cfkerMl.\nQed.",
    "Lemma cfker_scale_nz a phi : a != 0 -> cfker (a *: phi) = cfker phi.\nProof.\nmove=> nz_a; apply/eqP.\nby rewrite eqEsubset -{2}(scalerK nz_a phi) !cfker_scale.\nQed.",
    "Lemma cfker_opp phi : cfker (- phi) = cfker phi.\nProof. by rewrite -scaleN1r cfker_scale_nz // oppr_eq0 oner_eq0. Qed.",
    "Lemma cfker_cfun1 : @cfker _ G 1 = G.\nProof.\napply/setP=> x; rewrite !inE andb_idr // => Gx; apply/forallP=> y.\nby rewrite !cfun1E groupMl.\nQed.",
    "Lemma cfker_mul phi psi : cfker phi :&: cfker psi \\subset cfker (phi * psi).\nProof.\napply/subsetP=> x /setIP[Kphi_x Kpsi_x]; have [Gx _] := setIdP Kphi_x.\nby rewrite inE Gx; apply/forallP=> y; rewrite !cfunE !cfkerMl.\nQed.",
    "Lemma cfker_prod I r (P : pred I) (Phi : I -> 'CF(G)) :\n  G :&: \\bigcap_(i <- r | P i) cfker (Phi i)\n   \\subset cfker (\\prod_(i <- r | P i) Phi i).\nProof.\nelim/big_rec2: _ => [|i K psi Pi sK_psi]; first by rewrite setIT cfker_cfun1.\nby rewrite setICA; apply: subset_trans (setIS _ sK_psi) (cfker_mul _ _).\nQed.",
    "Lemma cfaithfulE phi : cfaithful phi = (cfker phi \\subset [1]).\nProof. by []. Qed.",
    "Lemma cfdotE phi psi :\n  '[phi, psi] = #|G|%:R^-1 * \\sum_(x in G) phi x * (psi x)^*.\nProof. by []. Qed.",
    "Lemma cfdotElr A B phi psi :\n     phi \\in 'CF(G, A) -> psi \\in 'CF(G, B) ->\n  '[phi, psi] = #|G|%:R^-1 * \\sum_(x in A :&: B) phi x * (psi x)^*.\nProof.\nmove=> Aphi Bpsi; rewrite (big_setID G)/= cfdotE (big_setID (A :&: B))/= setIC.\ncongr (_ * (_ + _)); rewrite !big1 // => x /setDP[_].\n  by move/cfun0->; rewrite mul0r.\nrewrite inE; case/nandP=> notABx; first by rewrite (cfun_on0 Aphi) ?mul0r.\nby rewrite (cfun_on0 Bpsi) // rmorph0 mulr0.\nQed.",
    "Lemma cfdotEl A phi psi :\n     phi \\in 'CF(G, A) ->\n  '[phi, psi] = #|G|%:R^-1 * \\sum_(x in A) phi x * (psi x)^*.\nProof. by move=> Aphi; rewrite (cfdotElr Aphi (cfun_onT psi)) setIT. Qed.",
    "Lemma cfdotEr A phi psi :\n     psi \\in 'CF(G, A) ->\n  '[phi, psi] = #|G|%:R^-1 * \\sum_(x in A) phi x * (psi x)^*.\nProof. by move=> Apsi; rewrite (cfdotElr (cfun_onT phi) Apsi) setTI. Qed.",
    "Lemma cfdot_complement A phi psi :\n  phi \\in 'CF(G, A) -> psi \\in 'CF(G, G :\\: A) -> '[phi, psi] = 0.\nProof.\nmove=> Aphi A'psi; rewrite (cfdotElr Aphi A'psi).\nby rewrite setDE setICA setICr setI0 big_set0 mulr0.\nQed.",
    "Lemma cfnormE A phi :\n  phi \\in 'CF(G, A) -> '[phi] = #|G|%:R^-1 * (\\sum_(x in A) `|phi x| ^+ 2).\nProof.  by move/cfdotEl->; rewrite (eq_bigr _ (fun _ _ => normCK _)). Qed.",
    "Lemma eq_cfdotl A phi1 phi2 psi :\n  psi \\in 'CF(G, A) -> {in A, phi1 =1 phi2} -> '[phi1, psi] = '[phi2, psi].\nProof.\nmove/cfdotEr=> eq_dot eq_phi; rewrite !eq_dot; congr (_ * _).\nby apply: eq_bigr => x Ax; rewrite eq_phi.\nQed.",
    "Lemma cfdot_cfuni A B :\n  A <| G -> B <| G -> '['1_A, '1_B]_G = #|A :&: B|%:R / #|G|%:R.\nProof.\nmove=> nsAG nsBG; rewrite (cfdotElr (cfuni_on G A) (cfuni_on G B)) mulrC.\ncongr (_ / _); rewrite -sumr_const; apply: eq_bigr => x /setIP[Ax Bx].\nby rewrite !cfuniE // Ax Bx mul1r rmorph1.\nQed.",
    "Lemma cfnorm1 : '[1]_G = 1.\nProof. by rewrite cfdot_cfuni ?genGid // setIid divff ?neq0CG. Qed.",
    "Lemma cfdotrE psi phi : cfdotr psi phi = '[phi, psi]. Proof. by []. Qed.",
    "Lemma cfdotr_is_linear xi : linear (cfdotr xi : 'CF(G) -> algC^o).\nProof.\nmove=> a phi psi; rewrite scalerAr -mulrDr; congr (_ * _).\nrewrite linear_sum -big_split; apply: eq_bigr => x _ /=.\nby rewrite !cfunE mulrDl -mulrA.\nQed.",
    "Lemma cfdot0l xi : '[0, xi] = 0.\nProof. by rewrite -cfdotrE linear0. Qed.",
    "Lemma cfdotNl xi phi : '[- phi, xi] = - '[phi, xi].\nProof. by rewrite -!cfdotrE linearN. Qed.",
    "Lemma cfdotDl xi phi psi : '[phi + psi, xi] = '[phi, xi] + '[psi, xi].\nProof. by rewrite -!cfdotrE linearD. Qed.",
    "Lemma cfdotBl xi phi psi : '[phi - psi, xi] = '[phi, xi] - '[psi, xi].\nProof. by rewrite -!cfdotrE linearB. Qed.",
    "Lemma cfdotMnl xi phi n : '[phi *+ n, xi] = '[phi, xi] *+ n.\nProof. by rewrite -!cfdotrE linearMn. Qed.",
    "Lemma cfdot_suml xi I r (P : pred I) (phi : I -> 'CF(G)) :\n  '[\\sum_(i <- r | P i) phi i, xi] = \\sum_(i <- r | P i) '[phi i, xi].\nProof. by rewrite -!cfdotrE linear_sum. Qed.",
    "Lemma cfdotZl xi a phi : '[a *: phi, xi] = a * '[phi, xi].\nProof. by rewrite -!cfdotrE linearZ. Qed.",
    "Lemma cfdotC phi psi : '[phi, psi] = ('[psi, phi])^*.\nProof.\nrewrite /cfdot rmorphM /= fmorphV rmorph_nat rmorph_sum; congr (_ * _).\nby apply: eq_bigr=> x _; rewrite rmorphM /= conjCK mulrC.\nQed.",
    "Lemma eq_cfdotr A phi psi1 psi2 :\n  phi \\in 'CF(G, A) -> {in A, psi1 =1 psi2} -> '[phi, psi1] = '[phi, psi2].\nProof. by move=> Aphi /eq_cfdotl eq_dot; rewrite cfdotC eq_dot // -cfdotC. Qed.",
    "Lemma cfdotBr xi phi psi : '[xi, phi - psi] = '[xi, phi] - '[xi, psi].\nProof. by rewrite !(cfdotC xi) -rmorphB cfdotBl. Qed.",
    "Lemma cfdot0r xi : '[xi, 0] = 0. Proof. exact: raddf0. Qed.",
    "Lemma cfdotNr xi phi : '[xi, - phi] = - '[xi, phi].\nProof. exact: raddfN. Qed.",
    "Lemma cfdotDr xi phi psi : '[xi, phi + psi] = '[xi, phi] + '[xi, psi].\nProof. exact: raddfD. Qed.",
    "Lemma cfdotMnr xi phi n : '[xi, phi *+ n] = '[xi, phi] *+ n.\nProof. exact: raddfMn. Qed.",
    "Lemma cfdot_sumr xi I r (P : pred I) (phi : I -> 'CF(G)) :\n  '[xi, \\sum_(i <- r | P i) phi i] = \\sum_(i <- r | P i) '[xi, phi i].\nProof. exact: raddf_sum. Qed.",
    "Lemma cfdotZr a xi phi : '[xi, a *: phi] = a^* * '[xi, phi].\nProof. by rewrite !(cfdotC xi) cfdotZl rmorphM. Qed.",
    "Lemma cfdot_cfAut (u : {rmorphism algC -> algC}) phi psi :\n    {in image psi G, {morph u : x / x^*}} ->\n  '[cfAut u phi, cfAut u psi] = u '[phi, psi].\nProof.\nmove=> uC; rewrite rmorphM /= fmorphV rmorph_nat rmorph_sum; congr (_ * _).\nby apply: eq_bigr => x Gx; rewrite !cfunE rmorphM /= uC ?map_f ?mem_enum.\nQed.",
    "Lemma cfdot_conjC phi psi : '[phi^*, psi^*] = '[phi, psi]^*.\nProof. by rewrite cfdot_cfAut. Qed.",
    "Lemma cfdot_conjCl phi psi : '[phi^*, psi] = '[phi, psi^*]^*.\nProof. by rewrite -cfdot_conjC cfConjCK. Qed.",
    "Lemma cfdot_conjCr phi psi : '[phi, psi^*] = '[phi^*, psi]^*.\nProof. by rewrite -cfdot_conjC cfConjCK. Qed.",
    "Lemma cfnorm_ge0 phi : 0 <= '[phi].\nProof.\nby rewrite mulr_ge0 ?invr_ge0 ?ler0n ?sumr_ge0 // => x _; apply: mul_conjC_ge0.\nQed.",
    "Lemma cfnorm_eq0 phi : ('[phi] == 0) = (phi == 0).\nProof.\napply/idP/eqP=> [|->]; last by rewrite cfdot0r.\nrewrite mulf_eq0 invr_eq0 (negbTE (neq0CG G)) /= => /eqP/psumr_eq0P phi0.\napply/cfun_inP=> x Gx; apply/eqP; rewrite cfunE -mul_conjC_eq0.\nby rewrite phi0 // => y _; apply: mul_conjC_ge0.\nQed.",
    "Lemma cfnorm_gt0 phi : ('[phi] > 0) = (phi != 0).\nProof. by rewrite lt_def cfnorm_ge0 cfnorm_eq0 andbT. Qed.",
    "Lemma sqrt_cfnorm_ge0 phi : 0 <= sqrtC '[phi].\nProof. by rewrite sqrtC_ge0 cfnorm_ge0. Qed.",
    "Lemma sqrt_cfnorm_eq0 phi : (sqrtC '[phi] == 0) = (phi == 0).\nProof. by rewrite sqrtC_eq0 cfnorm_eq0. Qed.",
    "Lemma sqrt_cfnorm_gt0 phi : (sqrtC '[phi] > 0) = (phi != 0).\nProof. by rewrite sqrtC_gt0 cfnorm_gt0. Qed.",
    "Lemma cfnormZ a phi : '[a *: phi]= `|a| ^+ 2 * '[phi]_G.\nProof. by rewrite cfdotZl cfdotZr mulrA normCK. Qed.",
    "Lemma cfnormN phi : '[- phi] = '[phi].\nProof. by rewrite cfdotNl raddfN opprK. Qed.",
    "Lemma cfnorm_sign n phi : '[(-1) ^+ n *: phi] = '[phi].\nProof. by rewrite -signr_odd scaler_sign; case: (odd n); rewrite ?cfnormN. Qed.",
    "Lemma cfnormD phi psi :\n  let d := '[phi, psi] in '[phi + psi] = '[phi] + '[psi] + ( d + d^* ).\nProof. by rewrite /= addrAC -cfdotC cfdotDl !cfdotDr !addrA. Qed.",
    "Lemma cfnormB phi psi :\n  let d := '[phi, psi] in '[phi - psi] = '[phi] + '[psi] - ( d + d^* ).\nProof. by rewrite /= cfnormD cfnormN cfdotNr rmorphN -opprD. Qed.",
    "Lemma cfnormDd phi psi : '[phi, psi] = 0 -> '[phi + psi] = '[phi] + '[psi].\nProof. by move=> ophipsi; rewrite cfnormD ophipsi rmorph0 !addr0. Qed.",
    "Lemma cfnormBd phi psi : '[phi, psi] = 0 -> '[phi - psi] = '[phi] + '[psi].\nProof.\nby move=> ophipsi; rewrite cfnormDd ?cfnormN // cfdotNr ophipsi oppr0.\nQed.",
    "Lemma cfnorm_conjC phi : '[phi^*] = '[phi].\nProof. by rewrite cfdot_conjC geC0_conj // cfnorm_ge0. Qed.",
    "Lemma cfCauchySchwarz phi psi :\n  `|'[phi, psi]| ^+ 2 <= '[phi] * '[psi] ?= iff ~~ free (phi :: psi).\nProof.\nrewrite free_cons span_seq1 seq1_free -negb_or negbK orbC.\nhave [-> | nz_psi] /= := eqVneq psi 0.\n  by apply/leifP; rewrite !cfdot0r normCK mul0r mulr0.\nwithout loss ophi: phi / '[phi, psi] = 0.\n  move=> IHo; pose a := '[phi, psi] / '[psi]; pose phi1 := phi - a *: psi.\n  have ophi: '[phi1, psi] = 0.\n    by rewrite cfdotBl cfdotZl divfK ?cfnorm_eq0 ?subrr.\n  rewrite (canRL (subrK _) (erefl phi1)) rpredDr ?rpredZ ?memv_line //.\n  rewrite cfdotDl ophi add0r cfdotZl normrM (ger0_norm (cfnorm_ge0 _)).\n  rewrite exprMn mulrA -cfnormZ cfnormDd; last by rewrite cfdotZr ophi mulr0.\n  by have:= IHo _ ophi; rewrite mulrDl -leifBLR subrr ophi normCK mul0r.\nrewrite ophi normCK mul0r; split; first by rewrite mulr_ge0 ?cfnorm_ge0.\nrewrite eq_sym mulf_eq0 orbC cfnorm_eq0 (negPf nz_psi) /=.\napply/idP/idP=> [|/vlineP[a {2}->]]; last by rewrite cfdotZr ophi mulr0.\nby rewrite cfnorm_eq0 => /eqP->; apply: rpred0.\nQed.",
    "Lemma cfCauchySchwarz_sqrt phi psi :\n  `|'[phi, psi]| <= sqrtC '[phi] * sqrtC '[psi] ?= iff ~~ free (phi :: psi).\nProof.\nrewrite -(sqrCK (normr_ge0 _)) -sqrtCM ?qualifE/= ?cfnorm_ge0 //.\nrewrite (mono_in_leif (@ler_sqrtC _)) 1?rpredM ?qualifE/= ?cfnorm_ge0 //;\n  [ exact: cfCauchySchwarz | exact: O.. ].\nQed.",
    "Lemma cf_triangle_leif phi psi :\n  sqrtC '[phi + psi] <= sqrtC '[phi] + sqrtC '[psi]\n           ?= iff ~~ free (phi :: psi) && (0 <= coord [tuple psi] 0 phi).\nProof.\nrewrite -(mono_in_leif ler_sqr) ?rpredD ?qualifE/= ?sqrtC_ge0 ?cfnorm_ge0 //;\n  [| exact: O.. ].\nrewrite andbC sqrrD !sqrtCK addrAC cfnormD (mono_leif (lerD2l _)).\nrewrite -mulr_natr -[_ + _](divfK (negbT (eqC_nat 2 0))) -/('Re _).\nrewrite (mono_leif (ler_pM2r _)) ?ltr0n //.\nhave:= leif_trans (leif_Re_Creal '[phi, psi]) (cfCauchySchwarz_sqrt phi psi).\ncongr (_ <= _ ?= iff _); first by rewrite ReE.\napply: andb_id2r; rewrite free_cons span_seq1 seq1_free -negb_or negbK orbC /=.\nhave [-> | nz_psi] := eqVneq psi 0; first by rewrite cfdot0r coord0.\ncase/vlineP=> [x ->]; rewrite cfdotZl linearZ pmulr_lge0 ?cfnorm_gt0 //=.\nby rewrite (coord_free 0) ?seq1_free // eqxx mulr1.\nQed.",
    "Lemma orthogonal_cons phi R S :\n  orthogonal (phi :: R) S = orthogonal phi S && orthogonal R S.\nProof. by rewrite /orthogonal /= andbT. Qed.",
    "Lemma orthoP phi psi : reflect ('[phi, psi] = 0) (orthogonal phi psi).\nProof. by rewrite /orthogonal /= !andbT; apply: eqP. Qed.",
    "Lemma orthogonalP S R :\n  reflect {in S & R, forall phi psi, '[phi, psi] = 0} (orthogonal S R).\nProof.\napply: (iffP allP) => oSR phi => [psi /oSR/allP opS /opS/eqP // | /oSR opS].\nby apply/allP=> psi /= /opS->.\nQed.",
    "Lemma orthoPl phi S :\n  reflect {in S, forall psi, '[phi, psi] = 0} (orthogonal phi S).\nProof.\nby rewrite [orthogonal _ S]andbT /=; apply: (iffP allP) => ophiS ? /ophiS/eqP.\nQed.",
    "Lemma orthogonal_sym : symmetric (@orthogonal _ G).\nProof.\napply: symmetric_from_pre => R S /orthogonalP oRS.\nby apply/orthogonalP=> phi psi Rpsi Sphi; rewrite cfdotC oRS ?rmorph0.\nQed.",
    "Lemma orthoPr S psi :\n  reflect {in S, forall phi, '[phi, psi] = 0} (orthogonal S psi).\nProof.\nrewrite orthogonal_sym.\nby apply: (iffP orthoPl) => oSpsi phi Sphi; rewrite cfdotC oSpsi ?conjC0.\nQed.",
    "Lemma eq_orthogonal R1 R2 S1 S2 :\n  R1 =i R2 -> S1 =i S2 -> orthogonal R1 S1 = orthogonal R2 S2.\nProof.\nmove=> eqR eqS; rewrite [orthogonal _ _](eq_all_r eqR).\nby apply: eq_all => psi /=; apply: eq_all_r.\nQed.",
    "Lemma orthogonal_catl R1 R2 S :\n  orthogonal (R1 ++ R2) S = orthogonal R1 S && orthogonal R2 S.\nProof. exact: all_cat. Qed.",
    "Lemma orthogonal_catr R S1 S2 :\n  orthogonal R (S1 ++ S2) = orthogonal R S1 && orthogonal R S2.\nProof. by rewrite !(orthogonal_sym R) orthogonal_catl. Qed.",
    "Lemma span_orthogonal S1 S2 phi1 phi2 :\n    orthogonal S1 S2 -> phi1 \\in <<S1>>%VS -> phi2 \\in <<S2>>%VS ->\n '[phi1, phi2] = 0.\nProof.\nmove/orthogonalP=> oS12; do 2!move/(@coord_span _ _ _ (in_tuple _))->.\nrewrite cfdot_suml big1 // => i _; rewrite cfdot_sumr big1 // => j _.\nby rewrite cfdotZl cfdotZr oS12 ?mem_nth ?mulr0.\nQed.",
    "Lemma orthogonal_split S beta :\n  {X : 'CF(G) & X \\in <<S>>%VS &\n      {Y | [/\\ beta = X + Y, '[X, Y] = 0 & orthogonal Y S]}}.\nProof.\nsuffices [X S_X [Y -> oYS]]:\n  {X : _ & X \\in <<S>>%VS & {Y | beta = X + Y & orthogonal Y S}}.\n- exists X => //; exists Y.\n  by rewrite cfdotC (span_orthogonal oYS) ?memv_span1 ?conjC0.\nelim: S beta => [|phi S IHS] beta.\n  by exists 0; last exists beta; rewrite ?mem0v ?add0r.\nhave [[U S_U [V -> oVS]] [X S_X [Y -> oYS]]] := (IHS phi, IHS beta).\npose Z := '[Y, V] / '[V] *: V; exists (X + Z).\n  rewrite /Z -{4}(addKr U V) scalerDr scalerN addrA addrC span_cons.\n  by rewrite memv_add ?memvB ?memvZ ?memv_line.\nexists (Y - Z); first by rewrite addrCA !addrA addrK addrC.\napply/orthoPl=> psi /[!inE] /predU1P[-> | Spsi]; last first.\n  by rewrite cfdotBl cfdotZl (orthoPl oVS _ Spsi) mulr0 subr0 (orthoPl oYS).\nrewrite cfdotBl !cfdotDr (span_orthogonal oYS) // ?memv_span ?mem_head //.\nrewrite !cfdotZl (span_orthogonal oVS _ S_U) ?mulr0 ?memv_span ?mem_head //.\nhave [-> | nzV] := eqVneq V 0; first by rewrite cfdot0r !mul0r subrr.\nby rewrite divfK ?cfnorm_eq0 ?subrr.\nQed.",
    "Lemma map_orthogonal M (nu : 'CF(G) -> 'CF(M)) S R (A : {pred 'CF(G)}) :\n  {in A &, isometry nu} -> {subset S <= A} -> {subset R <= A} ->\n orthogonal (map nu S) (map nu R) = orthogonal S R.\nProof.\nmove=> Inu sSA sRA; rewrite [orthogonal _ _]all_map.\napply: eq_in_all => phi Sphi; rewrite /= all_map.\nby apply: eq_in_all => psi Rpsi; rewrite /= Inu ?(sSA phi) ?(sRA psi).\nQed.",
    "Lemma orthogonal_oppr S R : orthogonal S (map -%R R) = orthogonal S R.\nProof.\nwlog suffices IH: S R / orthogonal S R -> orthogonal S (map -%R R).\n  by apply/idP/idP=> /IH; rewrite ?mapK //; apply: opprK.\nmove/orthogonalP=> oSR; apply/orthogonalP=> xi1 _ Sxi1 /mapP[xi2 Rxi2 ->].\nby rewrite cfdotNr oSR ?oppr0.\nQed.",
    "Lemma orthogonal_oppl S R : orthogonal (map -%R S) R = orthogonal S R.\nProof. by rewrite -!(orthogonal_sym R) orthogonal_oppr. Qed.",
    "Lemma pairwise_orthogonalP S :\n  reflect (uniq (0 :: S)\n             /\\ {in S &, forall phi psi, phi != psi -> '[phi, psi] = 0})\n          (pairwise_orthogonal S).\nProof.\nrewrite /pairwise_orthogonal /=; case notS0: (~~ _); last by right; case.\nelim: S notS0 => [|phi S IH] /=; first by left.\nrewrite inE eq_sym andbT => /norP[nz_phi /IH{}IH].\nhave [opS | not_opS] := allP; last first.\n  right=> [[/andP[notSp _] opS]]; case: not_opS => psi Spsi /=.\n  by rewrite opS ?mem_head 1?mem_behead // (memPnC notSp).\nrewrite (contra (opS _)) /= ?cfnorm_eq0 //.\napply: (iffP IH) => [] [uniqS oSS]; last first.\n  by split=> //; apply: sub_in2 oSS => psi Spsi; apply: mem_behead.\nsplit=> // psi xi /[!inE] /predU1P[-> // | Spsi].\n  by case/predU1P=> [-> | /opS] /eqP.\ncase/predU1P=> [-> _ | Sxi /oSS-> //].\nby apply/eqP; rewrite cfdotC conjC_eq0 [_ == 0]opS.\nQed.",
    "Lemma pairwise_orthogonal_cat R S :\n  pairwise_orthogonal (R ++ S) =\n    [&& pairwise_orthogonal R, pairwise_orthogonal S & orthogonal R S].\nProof.\nrewrite /pairwise_orthogonal mem_cat negb_or -!andbA; do !bool_congr.\nelim: R => [|phi R /= ->]; rewrite ?andbT // orthogonal_cons all_cat -!andbA /=.\nby do !bool_congr.\nQed.",
    "Lemma eq_pairwise_orthogonal R S :\n  perm_eq R S -> pairwise_orthogonal R = pairwise_orthogonal S.\nProof.\napply: catCA_perm_subst R S => R S S'.\nrewrite !pairwise_orthogonal_cat !orthogonal_catr (orthogonal_sym R S) -!andbA.\nby do !bool_congr.\nQed.",
    "Lemma sub_pairwise_orthogonal S1 S2 :\n    {subset S1 <= S2} ->  uniq S1 ->\n  pairwise_orthogonal S2 -> pairwise_orthogonal S1.\nProof.\nmove=> sS12 uniqS1 /pairwise_orthogonalP[/andP[notS2_0 _] oS2].\napply/pairwise_orthogonalP; rewrite /= (contra (sS12 0)) //.\nby split=> //; apply: sub_in2 oS2.\nQed.",
    "Lemma orthogonal_free S : pairwise_orthogonal S -> free S.\nProof.\ncase/pairwise_orthogonalP=> [/=/andP[notS0 uniqS] oSS].\nrewrite -(in_tupleE S); apply/freeP => a aS0 i.\nhave S_i: S`_i \\in S by apply: mem_nth.\nhave /eqP: '[S`_i, 0]_G = 0 := cfdot0r _.\nrewrite -{2}aS0 raddf_sum /= (bigD1 i) //= big1 => [|j neq_ji]; last 1 first.\n  by rewrite cfdotZr oSS ?mulr0 ?mem_nth // eq_sym nth_uniq.\nrewrite addr0 cfdotZr mulf_eq0 conjC_eq0 cfnorm_eq0.\nby case/pred2P=> // Si0; rewrite -Si0 S_i in notS0.\nQed.",
    "Lemma filter_pairwise_orthogonal S p :\n  pairwise_orthogonal S -> pairwise_orthogonal (filter p S).\nProof.\nmove=> orthoS; apply: sub_pairwise_orthogonal (orthoS).\n  exact: mem_subseq (filter_subseq p S).\nexact/filter_uniq/free_uniq/orthogonal_free.\nQed.",
    "Lemma orthonormal_not0 S : orthonormal S -> 0 \\notin S.\nProof.\nby case/andP=> /allP S1 _; rewrite (contra (S1 _)) //= cfdot0r eq_sym oner_eq0.\nQed.",
    "Lemma orthonormalE S :\n  orthonormal S = all [pred phi | '[phi] == 1] S && pairwise_orthogonal S.\nProof. by rewrite -(andb_idl (@orthonormal_not0 S)) andbCA. Qed.",
    "Lemma orthonormal_orthogonal S : orthonormal S -> pairwise_orthogonal S.\nProof. by rewrite orthonormalE => /andP[_]. Qed.",
    "Lemma orthonormal_cat R S :\n  orthonormal (R ++ S) = [&& orthonormal R, orthonormal S & orthogonal R S].\nProof.\nrewrite !orthonormalE pairwise_orthogonal_cat all_cat -!andbA.\nby do !bool_congr.\nQed.",
    "Lemma eq_orthonormal R S : perm_eq R S -> orthonormal R = orthonormal S.\nProof.\nmove=> eqRS; rewrite !orthonormalE (eq_all_r (perm_mem eqRS)).\nby rewrite (eq_pairwise_orthogonal eqRS).\nQed.",
    "Lemma orthonormal_free S : orthonormal S -> free S.\nProof. by move/orthonormal_orthogonal/orthogonal_free. Qed.",
    "Lemma orthonormalP S :\n  reflect (uniq S /\\ {in S &, forall phi psi, '[phi, psi]_G = (phi == psi)%:R})\n          (orthonormal S).\nProof.\nrewrite orthonormalE; have [/= normS | not_normS] := allP; last first.\n  by right=> [[_ o1S]]; case: not_normS => phi Sphi; rewrite /= o1S ?eqxx.\napply: (iffP (pairwise_orthogonalP S)) => [] [uniqS oSS].\n  split=> // [|phi psi]; first by case/andP: uniqS.\n  by have [-> _ /normS/eqP | /oSS] := eqVneq.\nsplit=> // [|phi psi Sphi Spsi /negbTE]; last by rewrite oSS // => ->.\nby rewrite /= (contra (normS _)) // cfdot0r eq_sym oner_eq0.\nQed.",
    "Lemma sub_orthonormal S1 S2 :\n  {subset S1 <= S2} -> uniq S1 -> orthonormal S2 -> orthonormal S1.\nProof.\nmove=> sS12 uniqS1 /orthonormalP[_ oS1].\nby apply/orthonormalP; split; last apply: sub_in2 sS12 _ _.\nQed.",
    "Lemma orthonormal2P phi psi :\n  reflect [/\\ '[phi, psi] = 0, '[phi] = 1 & '[psi] = 1]\n          (orthonormal [:: phi; psi]).\nProof.\nrewrite /orthonormal /= !andbT andbC.\nby apply: (iffP and3P) => [] []; do 3!move/eqP->.\nQed.",
    "Lemma conjC_pair_orthogonal S chi :\n    cfConjC_closed S -> ~~ has cfReal S -> pairwise_orthogonal S -> chi \\in S ->\n  pairwise_orthogonal (chi :: chi^*%CF).\nProof.\nmove=> ccS /hasPn nrS oSS Schi; apply: sub_pairwise_orthogonal oSS.\n  by apply/allP; rewrite /= Schi ccS.\nby rewrite /= inE eq_sym nrS.\nQed.",
    "Lemma cfdot_real_conjC phi psi : cfReal phi -> '[phi, psi^*]_G = '[phi, psi]^*.\nProof. by rewrite -cfdot_conjC => /eqcfP->. Qed.",
    "Lemma extend_cfConjC_subset S X phi :\n    cfConjC_closed S -> ~~ has cfReal S -> phi \\in S -> phi \\notin X ->\n  cfConjC_subset X S -> cfConjC_subset [:: phi, phi^* & X]%CF S.\nProof.\nmove=> ccS nrS Sphi X'phi [uniqX /allP-sXS ccX].\nsplit; last 1 [by apply/allP; rewrite /= Sphi ccS | apply/allP]; rewrite /= inE.\n  by rewrite negb_or X'phi eq_sym (hasPn nrS) // (contra (ccX _)) ?cfConjCK.\nby rewrite cfConjCK !mem_head orbT; apply/allP=> xi Xxi; rewrite !inE ccX ?orbT.\nQed.",
    "Lemma dvdn_cforderP n :\n  reflect {in G, forall x, phi x ^+ n = 1} (#[phi]%CF %| n)%N.\nProof.\napply: (iffP (dvdn_biglcmP _ _ _)); rewrite genGid => phiG1 x Gx.\n  by apply/eqP; rewrite -dvdn_orderC phiG1.\nby rewrite dvdn_orderC phiG1.\nQed.",
    "Lemma dvdn_cforder n : (#[phi]%CF %| n) = (phi ^+ n == 1).\nProof.\napply/dvdn_cforderP/eqP=> phi_n_1 => [|x Gx].\n  by apply/cfun_inP=> x Gx; rewrite exp_cfunE // cfun1E Gx phi_n_1.\nby rewrite -exp_cfunE // phi_n_1 // cfun1E Gx.\nQed.",
    "Lemma exp_cforder : phi ^+ #[phi]%CF = 1.\nProof. by apply/eqP; rewrite -dvdn_cforder. Qed.",
    "Lemma cforder_rmorph phi : #[f phi]%CF %| #[phi]%CF.\nProof. by rewrite dvdn_cforder -rmorphXn exp_cforder rmorph1. Qed.",
    "Lemma cforder_inj_rmorph phi : injective f -> #[f phi]%CF = #[phi]%CF.\nProof.\nmove=> inj_f; apply/eqP; rewrite eqn_dvd cforder_rmorph dvdn_cforder /=.\nby rewrite -(rmorph_eq1 _ inj_f) rmorphXn exp_cforder.\nQed.",
    "Lemma sub_iso_to U1 U2 W1 W2 tau :\n    {subset U2 <= U1} -> {subset W1 <= W2} ->\n  {in U1, isometry tau, to W1} -> {in U2, isometry tau, to W2}.\nProof.\nby move=> sU sW [Itau Wtau]; split=> [|u /sU/Wtau/sW //]; apply: sub_in2 Itau.\nQed.",
    "Lemma isometry_of_free S f :\n    free S -> {in S &, isometry f} ->\n  {tau : {linear 'CF(L) -> 'CF(G)} |\n    {in S, tau =1 f} & {in <<S>>%VS &, isometry tau}}.\nProof.\nmove=> freeS If; have defS := free_span freeS.\nhave [tau /(_ freeS (size_map f S))Dtau] := linear_of_free S (map f S).\nhave{} Dtau: {in S, tau =1 f}.\n  by move=> _ /(nthP 0)[i ltiS <-]; rewrite -!(nth_map 0 0) ?Dtau.\nexists tau => // _ _ /defS[a -> _] /defS[b -> _].\nrewrite !{1}linear_sum !{1}cfdot_suml; apply/eq_big_seq=> xi1 Sxi1.\nrewrite !{1}cfdot_sumr; apply/eq_big_seq=> xi2 Sxi2.\nby rewrite !linearZ /= !Dtau // !cfdotZl !cfdotZr If.\nQed.",
    "Lemma isometry_of_cfnorm S tauS :\n    pairwise_orthogonal S -> pairwise_orthogonal tauS ->\n    map cfnorm tauS = map cfnorm S ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | map tau S = tauS\n                                   & {in <<S>>%VS &, isometry tau}}.\nProof.\nmove=> oS oT eq_nST; have freeS := orthogonal_free oS.\nhave eq_sz: size tauS = size S by have:= congr1 size eq_nST; rewrite !size_map.\nhave [tau defT] := linear_of_free S tauS; rewrite -[S]/(tval (in_tuple S)).\nexists tau => [|u v /coord_span-> /coord_span->]; rewrite ?raddf_sum ?defT //=.\napply: eq_bigr => i _ /=; rewrite linearZ !cfdotZr !cfdot_suml; congr (_ * _).\napply: eq_bigr => j _ /=; rewrite linearZ !cfdotZl; congr (_ * _).\nrewrite -!(nth_map 0 0 tau) ?{}defT //; have [-> | neq_ji] := eqVneq j i.\n  by rewrite -!['[_]](nth_map 0 0 cfnorm) ?eq_sz // eq_nST.\nhave{oS} [/=/andP[_ uS] oS] := pairwise_orthogonalP oS.\nhave{oT} [/=/andP[_ uT] oT] := pairwise_orthogonalP oT.\nby rewrite oS ?oT ?mem_nth ?nth_uniq ?eq_sz.\nQed.",
    "Lemma isometry_raddf_inj U (tau : {additive 'CF(L) -> 'CF(G)}) :\n    {in U &, isometry tau} -> {in U &, forall u v, u - v \\in U} ->\n  {in U &, injective tau}.\nProof.\nmove=> Itau linU phi psi Uphi Upsi /eqP; rewrite -subr_eq0 -raddfB.\nby rewrite -cfnorm_eq0 Itau ?linU // cfnorm_eq0 subr_eq0 => /eqP.\nQed.",
    "Lemma opp_isometry : @isometry _ _ G G -%R.\nProof. by move=> x y; rewrite cfdotNl cfdotNr opprK. Qed.",
    "Lemma cfResE phi : A \\subset B -> {in A, cfRes phi =1 phi}.\nProof. by move=> sAB x Ax; rewrite cfunElock mem_gen ?genS. Qed.",
    "Lemma cfRes1 phi : cfRes phi 1%g = phi 1%g.\nProof. by rewrite cfunElock if_same group1. Qed.",
    "Lemma cfRes_is_linear : linear cfRes.\nProof.\nby move=> a phi psi; apply/cfunP=> x; rewrite !cfunElock mulrnAr mulrnDl.\nQed.",
    "Lemma cfRes_cfun1 : cfRes 1 = 1.\nProof.\napply: cfun_in_genP => x Hx; rewrite cfunElock Hx !cfun1Egen Hx.\nby case: subsetP => [-> // | _]; rewrite group1.\nQed.",
    "Lemma cfRes_is_multiplicative : multiplicative cfRes.\nProof.\nsplit=> [phi psi|]; [apply/cfunP=> x | exact: cfRes_cfun1].\nby rewrite !cfunElock mulrnAr mulrnAl -mulrnA mulnb andbb.\nQed.",
    "Lemma cfResEout phi : ~~ (H \\subset G) -> 'Res[H] phi = (phi 1%g)%:A.\nProof.\nmove/negPf=> not_sHG; apply/cfunP=> x.\nby rewrite cfunE cfun1E mulr_natr cfunElock !genGid not_sHG.\nQed.",
    "Lemma cfResRes A phi :\n  A \\subset H -> H \\subset G -> 'Res[A] ('Res[H] phi) = 'Res[A] phi.\nProof.\nmove=> sAH sHG; apply/cfunP=> x; rewrite !cfunElock !genGid !gen_subG sAH sHG.\nby rewrite (subset_trans sAH) // -mulrnA mulnb -in_setI (setIidPr _) ?gen_subG.\nQed.",
    "Lemma cfRes_id A psi : 'Res[A] psi = psi.\nProof. by apply/cfun_in_genP=> x Ax; rewrite cfunElock Ax subxx. Qed.",
    "Lemma sub_cfker_Res A phi :\n  A \\subset H -> A \\subset cfker phi -> A \\subset cfker ('Res[H, G] phi).\nProof.\nmove=> sAH kerA; apply/subsetP=> x Ax; have Hx := subsetP sAH x Ax.\nrewrite inE Hx; apply/forallP=> y; rewrite !cfunElock !genGid groupMl //.\nby rewrite !(fun_if phi) cfkerMl // (subsetP kerA).\nQed.",
    "Lemma eq_cfker_Res phi : H \\subset cfker phi -> cfker ('Res[H, G] phi) = H.\nProof. by move=> kH; apply/eqP; rewrite eqEsubset cfker_sub sub_cfker_Res. Qed.",
    "Lemma cfRes_sub_ker phi : H \\subset cfker phi -> 'Res[H, G] phi = (phi 1%g)%:A.\nProof.\nmove=> kerHphi; have sHG := subset_trans kerHphi (cfker_sub phi).\napply/cfun_inP=> x Hx; have ker_x := subsetP kerHphi x Hx.\nby rewrite cfResE // cfunE cfun1E Hx mulr1 cfker1.\nQed.",
    "Lemma cforder_Res phi : #['Res[H] phi]%CF %| #[phi]%CF.\nProof. exact: cforder_rmorph. Qed.",
    "Lemma cfMorphE phi x : G \\subset D -> x \\in G -> cfMorph phi x = phi (f x).\nProof. by rewrite cfunElock => -> ->. Qed.",
    "Lemma cfMorph1 phi : cfMorph phi 1%g = phi 1%g.\nProof. by rewrite cfunElock morph1 if_same group1. Qed.",
    "Lemma cfMorphEout phi : ~~ (G \\subset D) -> cfMorph phi = (phi 1%g)%:A.\nProof.\nmove/negPf=> not_sGD; apply/cfunP=> x; rewrite cfunE cfun1E mulr_natr.\nby rewrite cfunElock not_sGD.\nQed.",
    "Lemma cfMorph_cfun1 : cfMorph 1 = 1.\nProof.\napply/cfun_inP=> x Gx; rewrite cfunElock !cfun1E Gx.\nby case: subsetP => [sGD | _]; rewrite ?group1 // mem_morphim ?sGD.\nQed.",
    "Lemma cfMorph_inj : injective cfMorph.\nProof.\nmove=> phi1 phi2 eq_phi; apply/cfun_inP=> _ /morphimP[x Dx Gx ->].\nby rewrite -!cfMorphE // eq_phi.\nQed.",
    "Lemma cfMorph_eq1 phi : (cfMorph phi == 1) = (phi == 1).\nProof. exact/rmorph_eq1/cfMorph_inj. Qed.",
    "Lemma cfker_morph phi : cfker (cfMorph phi) = G :&: f @*^-1 (cfker phi).\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nhave Dx := subsetP sGD x Gx; rewrite Dx mem_morphim //=.\napply/forallP/forallP=> Kx y.\n  have [{y} /morphimP[y Dy Gy ->] | fG'y] := boolP (y \\in f @* G).\n    by rewrite -morphM // -!(cfMorphE phi) ?groupM.\n  by rewrite !cfun0 ?groupMl // mem_morphim.\nhave [Gy | G'y] := boolP (y \\in G); last by rewrite !cfun0 ?groupMl.\nby rewrite !cfMorphE ?groupM ?morphM // (subsetP sGD).\nQed.",
    "Lemma cfker_morph_im phi : f @* cfker (cfMorph phi) = cfker phi.\nProof. by rewrite cfker_morph // morphim_setIpre (setIidPr (cfker_sub _)). Qed.",
    "Lemma sub_cfker_morph phi (A : {set aT}) :\n  (A \\subset cfker (cfMorph phi)) = (A \\subset G) && (f @* A \\subset cfker phi).\nProof.\nrewrite cfker_morph // subsetI; apply: andb_id2l => sAG.\nby rewrite sub_morphim_pre // (subset_trans sAG).\nQed.",
    "Lemma sub_morphim_cfker phi (A : {set aT}) :\n  A \\subset G -> (f @* A \\subset cfker phi) = (A \\subset cfker (cfMorph phi)).\nProof. by move=> sAG; rewrite sub_cfker_morph ?sAG. Qed.",
    "Lemma cforder_morph phi : #[cfMorph phi]%CF = #[phi]%CF.\nProof. exact/cforder_inj_rmorph/cfMorph_inj. Qed.",
    "Lemma cfResMorph (G H : {group aT}) (phi : 'CF(f @* G)) :\n  H \\subset G -> G \\subset D -> 'Res (cfMorph phi) = cfMorph ('Res[f @* H] phi).\nProof.\nmove=> sHG sGD; have sHD := subset_trans sHG sGD.\napply/cfun_inP=> x Hx; have [Gx Dx] := (subsetP sHG x Hx, subsetP sHD x Hx).\nby rewrite !(cfMorphE, cfResE) ?morphimS ?mem_morphim //.\nQed.",
    "Lemma cfIsomE phi (x : aT : finType) : x \\in G -> cfIsom phi (f x) = phi x.\nProof.\nmove=> Gx; rewrite unlock cfMorphE //= /restrm ?defG ?cfRes_id ?invmE //.\nby rewrite -defR mem_morphim.\nQed.",
    "Lemma cfIsom1 phi : cfIsom phi 1%g = phi 1%g.\nProof. by rewrite -(morph1 f) cfIsomE. Qed.",
    "Lemma cfIsom_is_additive : additive cfIsom.\nProof. rewrite unlock; exact: raddfB. Qed.",
    "Lemma cfIsom_is_multiplicative : multiplicative cfIsom.\nProof. rewrite unlock; exact: (rmorphM _, rmorph1 _). Qed.",
    "Lemma cfIsom_is_scalable : scalable cfIsom.\nProof. rewrite unlock; exact: linearZ_LR. Qed.",
    "Lemma cfIsom_cfun1 : cfIsom 1 = 1. Proof. exact: rmorph1. Qed.",
    "Lemma cfker_isom phi : cfker (cfIsom phi) = f @* cfker phi.\nProof.\nrewrite unlock cfker_morph // defG cfRes_id morphpre_restrm morphpre_invm.\nby rewrite -defR !morphimIim.\nQed.",
    "Lemma cfIsomK : cancel (cfIsom isoGR) (cfIsom (isom_sym isoGR)).\nProof.\nmove=> phi; apply/cfun_inP=> x Gx; rewrite -{1}(invmE (isom_inj isoGR) Gx).\nby rewrite !cfIsomE // -(isom_im isoGR) mem_morphim.\nQed.",
    "Lemma cfIsomKV : cancel (cfIsom (isom_sym isoGR)) (cfIsom isoGR).\nProof.\nmove=> phi; apply/cfun_inP=> y Ry; pose injGR := isom_inj isoGR.\nrewrite -{1}[y](invmK injGR) ?(isom_im isoGR) //.\nsuffices /morphpreP[fGy Gf'y]: y \\in invm injGR @*^-1 G by rewrite !cfIsomE.\nby rewrite morphpre_invm (isom_im isoGR).\nQed.",
    "Lemma cfIsom_inj : injective (cfIsom isoGR). Proof. exact: can_inj cfIsomK. Qed.",
    "Lemma cfIsom_eq1 phi : (cfIsom isoGR phi == 1) = (phi == 1).\nProof. exact/rmorph_eq1/cfIsom_inj. Qed.",
    "Lemma cforder_isom phi : #[cfIsom isoGR phi]%CF = #[phi]%CF.\nProof. exact: cforder_inj_rmorph cfIsom_inj. Qed.",
    "Lemma cfModE phi x : B <| G -> x \\in G -> (phi %% B)%CF x = phi (coset B x).\nProof. by move/normal_norm=> nBG; apply: cfMorphE. Qed.",
    "Lemma cfMod1 phi : (phi %% B)%CF 1%g = phi 1%g. Proof. exact: cfMorph1. Qed.",
    "Lemma cfMod_cfun1 : (1 %% B)%CF = 1. Proof. exact: rmorph1. Qed.",
    "Lemma cfker_mod phi : B <| G -> B \\subset cfker (phi %% B).\nProof.\ncase/andP=> sBG nBG; rewrite cfker_morph // subsetI sBG.\napply: subset_trans _ (ker_sub_pre _ _); rewrite ker_coset_prim subsetI.\nby rewrite (subset_trans sBG nBG) sub_gen.\nQed.",
    "Lemma cfQuoEnorm (phi : 'CF(G)) x :\n  B \\subset cfker phi -> x \\in 'N_G(B) -> (phi / B)%CF (coset B x) = phi x.\nProof.\nrewrite cfunElock -gen_subG => sHK /setIP[Gx nHx]; rewrite sHK /=.\nrewrite mem_morphim // val_coset_prim //.\nby case: repr_rcosetP => _ /(subsetP sHK)/cfkerMl->.\nQed.",
    "Lemma cfQuoE (phi : 'CF(G)) x :\n  B <| G -> B \\subset cfker phi -> x \\in G -> (phi / B)%CF (coset B x) = phi x.\nProof. by case/andP=> _ nBG sBK Gx; rewrite cfQuoEnorm // (setIidPl _). Qed.",
    "Lemma cfQuo1 (phi : 'CF(G)) : (phi / B)%CF 1%g = phi 1%g.\nProof. by rewrite cfunElock repr_coset1 group1 if_same. Qed.",
    "Lemma cfQuoEout (phi : 'CF(G)) :\n  ~~ (B \\subset cfker phi) -> (phi / B)%CF = (phi 1%g)%:A.\nProof.\nmove/negPf=> not_kerB; apply/cfunP=> x; rewrite cfunE cfun1E mulr_natr.\nby rewrite cfunElock not_kerB.\nQed.",
    "Lemma cfQuo_cfun1 : (1 / B)%CF = 1.\nProof.\napply/cfun_inP=> Hx G_Hx; rewrite cfunElock !cfun1E G_Hx cfker_cfun1 -gen_subG.\nhave [x nHx Gx ->] := morphimP G_Hx.\ncase: subsetP=> [sHG | _]; last by rewrite group1.\nby rewrite val_coset_prim //; case: repr_rcosetP => y /sHG/groupM->.\nQed.",
    "Lemma cfModK : B <| G -> cancel cfMod cfQuo.\nProof.\nmove=> nsBG phi; apply/cfun_inP=> _ /morphimP[x Nx Gx ->] //.\nby rewrite cfQuoE ?cfker_mod ?cfModE.\nQed.",
    "Lemma cfQuoK :\n  B <| G -> forall phi, B \\subset cfker phi -> (phi / B %% B)%CF = phi.\nProof.\nby move=> nsHG phi sHK; apply/cfun_inP=> x Gx; rewrite cfModE ?cfQuoE.\nQed.",
    "Lemma cfMod_eq1 psi : B <| G -> (psi %% B == 1)%CF = (psi == 1).\nProof. by move/cfModK/can_eq <-; rewrite rmorph1. Qed.",
    "Lemma cfQuo_eq1 phi :\n  B <| G -> B \\subset cfker phi -> (phi / B == 1)%CF = (phi == 1).\nProof. by move=> nsBG kerH; rewrite -cfMod_eq1 // cfQuoK. Qed.",
    "Lemma cfResMod H K (psi : 'CF(G / K)) :\n  H \\subset G -> K <| G -> ('Res (psi %% K) = 'Res[H / K] psi %% K)%CF.\nProof. by move=> sHG /andP[_]; apply: cfResMorph. Qed.",
    "Lemma quotient_cfker_mod (A : {set gT}) K (psi : 'CF(G / K)) :\n  K <| G -> (cfker (psi %% K) / K)%g = cfker psi.\nProof. by case/andP=> _ /cfker_morph_im <-. Qed.",
    "Lemma sub_cfker_mod (A : {set gT}) K (psi : 'CF(G / K)) :\n    K <| G -> A \\subset 'N(K) ->\n  (A \\subset cfker (psi %% K)) = (A / K \\subset cfker psi)%g.\nProof.\nby move=> nsKG nKA; rewrite -(quotientSGK nKA) ?quotient_cfker_mod// cfker_mod.\nQed.",
    "Lemma cfker_quo H phi :\n  H <| G -> H \\subset cfker (phi) -> cfker (phi / H) = (cfker phi / H)%g.\nProof.\nmove=> nsHG /cfQuoK {2}<- //; have [sHG nHG] := andP nsHG.\nby rewrite cfker_morph 1?quotientGI // cosetpreK (setIidPr _) ?cfker_sub.\nQed.",
    "Lemma cfQuoEker phi x :\n  x \\in G -> (phi / cfker phi)%CF (coset (cfker phi) x) = phi x.\nProof. by move/cfQuoE->; rewrite ?cfker_normal. Qed.",
    "Lemma cfaithful_quo phi : cfaithful (phi / cfker phi).\nProof. by rewrite cfaithfulE cfker_quo ?cfker_normal ?trivg_quotient. Qed.",
    "Lemma cfResQuo H K phi :\n     K \\subset cfker phi -> K \\subset H -> H \\subset G ->\n  ('Res[H / K] (phi / K) = 'Res[H] phi / K)%CF.\nProof.\nmove=> kerK sKH sHG; apply/cfun_inP=> xb Hxb; rewrite cfResE ?quotientS //.\nhave{xb Hxb} [x nKx Hx ->] := morphimP Hxb.\nby rewrite !cfQuoEnorm ?cfResE// 1?inE ?Hx ?(subsetP sHG)// sub_cfker_Res.\nQed.",
    "Lemma cfQuoInorm K phi :\n  K \\subset cfker phi -> (phi / K)%CF = 'Res ('Res['N_G(K)] phi / K)%CF.\nProof.\nmove=> kerK; rewrite -cfResQuo ?subsetIl ?quotientInorm ?cfRes_id //.\nby rewrite subsetI normG (subset_trans kerK) ?cfker_sub.\nQed.",
    "Lemma cforder_mod H (psi : 'CF(G / H)) : H <| G -> #[psi %% H]%CF = #[psi]%CF.\nProof. by move/cfModK/can_inj/cforder_inj_rmorph->. Qed.",
    "Lemma cforder_quo H phi :\n  H <| G -> H \\subset cfker phi -> #[phi / H]%CF = #[phi]%CF.\nProof. by move=> nsHG kerHphi; rewrite -cforder_mod ?cfQuoK. Qed.",
    "Lemma cfunM_onI A B phi psi :\n  phi \\in 'CF(G, A) -> psi \\in 'CF(G, B) -> phi * psi \\in 'CF(G, A :&: B).\nProof.\nrewrite !cfun_onE => Aphi Bpsi; apply/subsetP=> x; rewrite !inE cfunE mulf_eq0.\nby case/norP=> /(subsetP Aphi)-> /(subsetP Bpsi).\nQed.",
    "Lemma cfunM_on A phi psi :\n  phi \\in 'CF(G, A) -> psi \\in 'CF(G, A) -> phi * psi \\in 'CF(G, A).\nProof. by move=> Aphi Bpsi; rewrite -[A]setIid cfunM_onI. Qed.",
    "Lemma cfSdprod_is_additive : additive cfSdprod.\nProof. rewrite unlock; exact: raddfB. Qed.",
    "Lemma cfSdprod_is_multiplicative : multiplicative cfSdprod.\nProof. rewrite unlock; exact: (rmorphM _, rmorph1 _). Qed.",
    "Lemma cfSdprod_is_scalable : scalable cfSdprod.\nProof. rewrite unlock; exact: linearZ_LR. Qed.",
    "Lemma cfSdprod1 phi : cfSdprod phi 1%g = phi 1%g.\nProof. by rewrite unlock /= cfMorph1 cfIsom1. Qed.",
    "Lemma cfker_sdprod phi : K \\subset cfker (cfSdprod phi).\nProof. by rewrite unlock_with cfker_mod. Qed.",
    "Lemma cfSdprodEr phi : {in H, cfSdprod phi =1 phi}.\nProof. by move=> y Hy; rewrite unlock cfModE ?cfIsomE ?(subsetP sHG). Qed.",
    "Lemma cfSdprodE phi : {in K & H, forall x y, cfSdprod phi (x * y)%g = phi y}.\nProof.\nby move=> x y Kx Hy; rewrite /= cfkerMl ?(subsetP (cfker_sdprod _)) ?cfSdprodEr.\nQed.",
    "Lemma cfSdprodK : cancel cfSdprod 'Res[H].\nProof. by move=> phi; apply/cfun_inP=> x Hx; rewrite cfResE ?cfSdprodEr. Qed.",
    "Lemma cfSdprod_inj : injective cfSdprod. Proof. exact: can_inj cfSdprodK. Qed.",
    "Lemma cfSdprod_eq1 phi : (cfSdprod phi == 1) = (phi == 1).\nProof. exact: rmorph_eq1 cfSdprod_inj. Qed.",
    "Lemma cfRes_sdprodK phi : K \\subset cfker phi -> cfSdprod ('Res[H] phi) = phi.\nProof.\nmove=> kerK; apply/cfun_inP=> _ /(mem_sdprod defG)[x [y [Kx Hy -> _]]].\nby rewrite cfSdprodE // cfResE // cfkerMl ?(subsetP kerK).\nQed.",
    "Lemma sdprod_cfker phi : K ><| cfker phi = cfker (cfSdprod phi).\nProof.\nhave [skerH [_ _ nKH tiKH]] := (cfker_sub phi, sdprodP defG).\nrewrite unlock cfker_morph ?normal_norm // cfker_isom restrmEsub //=.\nrewrite -(sdprod_modl defG) ?sub_cosetpre //=; congr (_ ><| _).\nby rewrite quotientK ?(subset_trans skerH) // -group_modr //= setIC tiKH mul1g.\nQed.",
    "Lemma cforder_sdprod phi : #[cfSdprod phi]%CF = #[phi]%CF.\nProof. exact: cforder_inj_rmorph cfSdprod_inj. Qed.",
    "Lemma reindex_dprod R idx (op : Monoid.com_law idx) (F : gT -> R) :\n   \\big[op/idx]_(g in G) F g =\n      \\big[op/idx]_(k in K) \\big[op/idx]_(h in H) F (k * h)%g.\nProof.\nhave /mulgmP/misomP[fM /isomP[injf im_f]] := KxH.\nrewrite pair_big_dep -im_f morphimEdom big_imset; last exact/injmP.\nby apply: eq_big => [][x y]; rewrite ?inE.\nQed.",
    "Lemma cfDprodl1 phi : cfDprodl phi 1%g = phi 1%g. Proof. exact: cfSdprod1. Qed.",
    "Lemma cfDprodr1 psi : cfDprodr psi 1%g = psi 1%g. Proof. exact: cfSdprod1. Qed.",
    "Lemma cfDprod1 phi psi : cfDprod phi psi 1%g = phi 1%g * psi 1%g.\nProof. by rewrite cfunE /= !cfSdprod1. Qed.",
    "Lemma cfDprodl_eq1 phi : (cfDprodl phi == 1) = (phi == 1).\nProof. exact: cfSdprod_eq1. Qed.",
    "Lemma cfDprodr_eq1 psi : (cfDprodr psi == 1) = (psi == 1).\nProof. exact: cfSdprod_eq1. Qed.",
    "Lemma cfDprod_cfun1r phi : cfDprod phi 1 = cfDprodl phi.\nProof. by rewrite /cfDprod rmorph1 mulr1. Qed.",
    "Lemma cfDprod_cfun1l psi : cfDprod 1 psi = cfDprodr psi.\nProof. by rewrite /cfDprod rmorph1 mul1r. Qed.",
    "Lemma cfDprod_cfun1 : cfDprod 1 1 = 1.\nProof. by rewrite cfDprod_cfun1l rmorph1. Qed.",
    "Lemma cfDprod_split phi psi : cfDprod phi psi = cfDprod phi 1 * cfDprod 1 psi.\nProof. by rewrite cfDprod_cfun1l cfDprod_cfun1r. Qed.",
    "Lemma cfDprodlK : cancel cfDprodl 'Res[K]. Proof. exact: cfSdprodK. Qed.",
    "Lemma cfDprodrK : cancel cfDprodr 'Res[H]. Proof. exact: cfSdprodK. Qed.",
    "Lemma cfker_dprodl phi : cfker phi \\x H = cfker (cfDprodl phi).\nProof.\nby rewrite dprodC -sdprod_cfker dprodEsd // centsC (centsS (cfker_sub _)).\nQed.",
    "Lemma cfker_dprodr psi : K \\x cfker psi = cfker (cfDprodr psi).\nProof. by rewrite -sdprod_cfker dprodEsd // (subset_trans (cfker_sub _)). Qed.",
    "Lemma cfDprodEl phi : {in K & H, forall k h, cfDprodl phi (k * h)%g = phi k}.\nProof. by move=> k h Kk Hh /=; rewrite -(centsP cKH) // cfSdprodE. Qed.",
    "Lemma cfDprodEr psi : {in K & H, forall k h, cfDprodr psi (k * h)%g = psi h}.\nProof. exact: cfSdprodE. Qed.",
    "Lemma cfDprodE phi psi :\n  {in K & H, forall h k, cfDprod phi psi (h * k)%g = phi h * psi k}.\nProof. by move=> k h Kk Hh /=; rewrite cfunE cfDprodEl ?cfDprodEr. Qed.",
    "Lemma cfDprod_Resl phi psi : 'Res[K] (cfDprod phi psi) = psi 1%g *: phi.\nProof.\nby apply/cfun_inP=> x Kx; rewrite cfunE cfResE // -{1}[x]mulg1 mulrC cfDprodE.\nQed.",
    "Lemma cfDprod_Resr phi psi : 'Res[H] (cfDprod phi psi) = phi 1%g *: psi.\nProof.\nby apply/cfun_inP=> y Hy; rewrite cfunE cfResE // -{1}[y]mul1g cfDprodE.\nQed.",
    "Lemma cfDprodKl (psi : 'CF(H)) : psi 1%g = 1 -> cancel (cfDprod^~ psi) 'Res.\nProof. by move=> psi1 phi; rewrite cfDprod_Resl psi1 scale1r. Qed.",
    "Lemma cfDprodKr (phi : 'CF(K)) : phi 1%g = 1 -> cancel (cfDprod phi) 'Res.\nProof. by move=> phi1 psi; rewrite cfDprod_Resr phi1 scale1r. Qed.",
    "Lemma cfker_dprod phi psi :\n  cfker phi <*> cfker psi \\subset cfker (cfDprod phi psi).\nProof.\nrewrite -genM_join gen_subG; apply/subsetP=> _ /mulsgP[x y kKx kHy ->] /=.\nhave [[Kx _] [Hy _]] := (setIdP kKx, setIdP kHy).\nhave Gxy: (x * y)%g \\in G by rewrite -(dprodW KxH) mem_mulg.\nrewrite inE Gxy; apply/forallP=> g.\nhave [Gg | G'g] := boolP (g \\in G); last by rewrite !cfun0 1?groupMl.\nhave{g Gg} [k [h [Kk Hh -> _]]] := mem_dprod KxH Gg.\nrewrite mulgA -(mulgA x) (centsP cKH y) // mulgA -mulgA !cfDprodE ?groupM //.\nby rewrite !cfkerMl.\nQed.",
    "Lemma cfdot_dprod phi1 phi2 psi1 psi2 :\n  '[cfDprod phi1 psi1, cfDprod phi2 psi2] = '[phi1, phi2] * '[psi1, psi2].\nProof.\nrewrite !cfdotE mulrCA -mulrA mulrCA mulrA -invfM -natrM (dprod_card KxH).\ncongr (_ * _); rewrite big_distrl reindex_dprod /=; apply: eq_bigr => k Kk.\nrewrite big_distrr; apply: eq_bigr => h Hh /=.\nby rewrite mulrCA -mulrA -rmorphM mulrCA mulrA !cfDprodE.\nQed.",
    "Lemma cfDprodl_iso : isometry cfDprodl.\nProof.\nby move=> phi1 phi2; rewrite -!cfDprod_cfun1r cfdot_dprod cfnorm1 mulr1.\nQed.",
    "Lemma cfDprodr_iso : isometry cfDprodr.\nProof.\nby move=> psi1 psi2; rewrite -!cfDprod_cfun1l cfdot_dprod cfnorm1 mul1r.\nQed.",
    "Lemma cforder_dprodl phi : #[cfDprodl phi]%CF = #[phi]%CF.\nProof. exact: cforder_sdprod. Qed.",
    "Lemma cforder_dprodr psi : #[cfDprodr psi]%CF = #[psi]%CF.\nProof. exact: cforder_sdprod. Qed.",
    "Lemma cfDprodC (gT : finGroupType) (G K H : {group gT})\n               (KxH : K \\x H = G) (HxK : H \\x K = G) chi psi :\n  cfDprod KxH chi psi = cfDprod HxK psi chi.\nProof.\nrewrite /cfDprod mulrC.\nby congr (_ * _); congr (cfSdprod _ _); apply: eq_irrelevance.\nQed.",
    "Lemma cfBigdprodi1 i (phi : 'CF(A i)) : cfBigdprodi phi 1%g = phi 1%g.\nProof. by rewrite cfDprodl1 cfRes1. Qed.",
    "Lemma cfBigdprodi_eq1 i (phi : 'CF(A i)) :\n  P i -> (cfBigdprodi phi == 1) = (phi == 1).\nProof. by move=> Pi; rewrite cfSdprod_eq1 Pi cfRes_id. Qed.",
    "Lemma cfBigdprodiK i : P i -> cancel (@cfBigdprodi i) 'Res[A i].\nProof.\nmove=> Pi phi; have:= cfDprodlK (cfBigdprodi_subproof i) ('Res phi).\nby rewrite -[cfDprodl _ _]/(cfBigdprodi phi) Pi cfRes_id.\nQed.",
    "Lemma cfBigdprodi_inj i : P i -> injective (@cfBigdprodi i).\nProof. by move/cfBigdprodiK; apply: can_inj. Qed.",
    "Lemma cfBigdprodEi i (phi : 'CF(A i)) x :\n    P i -> (forall j, P j -> x j \\in A j) ->\n  cfBigdprodi phi (\\prod_(j | P j) x j)%g = phi (x i).\nProof.\nhave [r big_r [Ur mem_r] _] := big_enumP P => Pi AxP.\nhave:= bigdprodWcp defG; rewrite -!big_r => defGr.\nhave{AxP} [r_i Axr]: i \\in r /\\ {in r, forall j, x j \\in A j}.\n  by split=> [|j]; rewrite mem_r // => /AxP.\nrewrite (perm_bigcprod defGr Axr (perm_to_rem r_i)) big_cons.\nrewrite cfDprodEl ?Pi ?cfRes_id ?Axr // big_seq group_prod // => j.\nrewrite mem_rem_uniq // => /andP[i'j /= r_j].\nby apply/mem_gen/bigcupP; exists j; [rewrite -mem_r r_j | apply: Axr].\nQed.",
    "Lemma cfBigdprodi_iso i : P i -> isometry (@cfBigdprodi i).\nProof. by move=> Pi phi psi; rewrite cfDprodl_iso Pi !cfRes_id. Qed.",
    "Lemma cfBigdprodE phi x :\n    (forall i, P i -> x i \\in A i) ->\n  cfBigdprod phi (\\prod_(i | P i) x i)%g = \\prod_(i | P i) phi i (x i).\nProof.\nmove=> Ax; rewrite prod_cfunE; last by rewrite -(bigdprodW defG) mem_prodg.\nby apply: eq_bigr => i Pi; rewrite cfBigdprodEi.\nQed.",
    "Lemma cfBigdprod1 phi : cfBigdprod phi 1%g = \\prod_(i | P i) phi i 1%g.\nProof. by rewrite prod_cfunE //; apply/eq_bigr=> i _; apply: cfBigdprodi1. Qed.",
    "Lemma cfBigdprodK phi (Phi := cfBigdprod phi) i (a := phi i 1%g / Phi 1%g) :\n  Phi 1%g != 0 -> P i -> a != 0 /\\ a *: 'Res[A i] Phi = phi i.\nProof.\nmove=> nzPhi Pi; split.\n  rewrite mulf_neq0 ?invr_eq0 // (contraNneq _ nzPhi) // => phi_i0.\n  by rewrite cfBigdprod1 (bigD1 i) //= phi_i0 mul0r.\napply/cfun_inP=> x Aix; rewrite cfunE cfResE ?sAG // mulrAC.\nhave {1}->: x = (\\prod_(j | P j) (if j == i then x else 1))%g.\n  rewrite -big_mkcondr (big_pred1 i) ?eqxx // => j /=.\n  by apply: andb_idl => /eqP->.\nrewrite cfBigdprodE => [|j _]; last by case: eqP => // ->.\napply: canLR (mulfK nzPhi) _; rewrite cfBigdprod1 !(bigD1 i Pi) /= eqxx.\nby rewrite mulrCA !mulrA; congr (_ * _); apply: eq_bigr => j /andP[_ /negPf->].\nQed.",
    "Lemma cfdot_bigdprod phi psi :\n  '[cfBigdprod phi, cfBigdprod psi] = \\prod_(i | P i) '[phi i, psi i].\nProof.\napply: canLR (mulKf (neq0CG G)) _; rewrite -(bigdprod_card defG).\nrewrite (big_morph _ (@natrM _) (erefl _)) -big_split /=.\nrewrite (eq_bigr _ (fun i _ => mulVKf (neq0CG _) _)) (big_distr_big_dep 1%g) /=.\nset F := pfamily _ _ _; pose h (f : {ffun I -> gT}) := (\\prod_(i | P i) f i)%g.\npose is_hK x f := forall f1, (f1 \\in F) && (h f1 == x) = (f == f1).\nhave /fin_all_exists[h1 Dh1] x: exists f, x \\in G -> is_hK x f.\n  case Gx: (x \\in G); last by exists [ffun _ => x].\n  have [f [Af fK Uf]] := mem_bigdprod defG Gx.\n  exists [ffun i => if P i then f i else 1%g] => _ f1.\n  apply/andP/eqP=> [[/pfamilyP[Pf1 Af1] /eqP Dx] | <-].\n    by apply/ffunP=> i; rewrite ffunE; case: ifPn => [/Uf-> | /(supportP Pf1)].\n  split; last by rewrite fK; apply/eqP/eq_bigr=> i Pi; rewrite ffunE Pi.\n  by apply/familyP=> i; rewrite ffunE !unfold_in; case: ifP => //= /Af.\nrewrite (reindex_onto h h1) /= => [|x /Dh1/(_ (h1 x))]; last first.\n  by rewrite eqxx => /andP[_ /eqP].\napply/eq_big => [f | f /andP[/Dh1<- /andP[/pfamilyP[_ Af] _]]]; last first.\n  by rewrite !cfBigdprodE // rmorph_prod -big_split /=.\napply/idP/idP=> [/andP[/Dh1<-] | Ff]; first by rewrite eqxx andbT.\nhave /pfamilyP[_ Af] := Ff; suffices Ghf: h f \\in G by rewrite -Dh1 ?Ghf ?Ff /=.\nby apply/group_prod=> i Pi; rewrite (subsetP (sAG Pi)) ?Af.\nQed.",
    "Lemma cfMorph_iso aT rT (G D : {group aT}) (f : {morphism D >-> rT}) :\n  G \\subset D -> isometry (cfMorph : 'CF(f @* G) -> 'CF(G)).\nProof.\nmove=> sGD phi psi; rewrite !cfdotE card_morphim (setIidPr sGD).\nrewrite -(LagrangeI G ('ker f)) /= mulnC natrM invfM -mulrA.\ncongr (_ * _); apply: (canLR (mulKf (neq0CG _))).\nrewrite mulr_sumr (partition_big_imset f) /= -morphimEsub //.\napply: eq_bigr => _ /morphimP[x Dx Gx ->].\nrewrite -(card_rcoset _ x) mulr_natl -sumr_const.\napply/eq_big => [y | y /andP[Gy /eqP <-]]; last by rewrite !cfMorphE.\nrewrite mem_rcoset inE groupMr ?groupV // -mem_rcoset.\nby apply: andb_id2l => /(subsetP sGD) Dy; apply: sameP eqP (rcoset_kerP f _ _).\nQed.",
    "Lemma cfIsom_iso rT G (R : {group rT}) (f : {morphism G >-> rT}) :\n  forall isoG : isom G R f, isometry (cfIsom isoG).\nProof.\nmove=> isoG phi psi; rewrite unlock cfMorph_iso //; set G1 := _ @* R.\nby rewrite -(isom_im (isom_sym isoG)) -/G1 in phi psi *; rewrite !cfRes_id.\nQed.",
    "Lemma cfMod_iso H G : H <| G -> isometry (@cfMod _ G H).\nProof. by case/andP=> _; apply: cfMorph_iso. Qed.",
    "Lemma cfQuo_iso H G :\n  H <| G -> {in [pred phi | H \\subset cfker phi] &, isometry (@cfQuo _ G H)}.\nProof.\nby move=> nsHG phi psi sHkphi sHkpsi; rewrite -(cfMod_iso nsHG) !cfQuoK.\nQed.",
    "Lemma cfnorm_quo H G phi :\n  H <| G -> H \\subset cfker phi -> '[phi / H] = '[phi]_G.\nProof. by move=> nsHG sHker; apply: cfQuo_iso. Qed.",
    "Lemma cfSdprod_iso K H G (defG : K ><| H = G) : isometry (cfSdprod defG).\nProof.\nmove=> phi psi; have [/andP[_ nKG] _ _ _ _] := sdprod_context defG.\nby rewrite [cfSdprod _]locked_withE cfMorph_iso ?cfIsom_iso.\nQed.",
    "Lemma cfInd_is_linear : linear cfInd.\nProof.\nmove=> c phi psi; apply/cfunP=> x; rewrite !cfunElock; case: ifP => _.\n  rewrite mulrCA -mulrDr [c * _]mulr_sumr -big_split /=.\n  by congr (_ * _); apply: eq_bigr => y _; rewrite !cfunE.\nrewrite mulrnAr -mulrnDl !(mulrCA c) -!mulrDr [c * _]mulr_sumr -big_split /=.\nby congr (_ * (_ * _) *+ _); apply: eq_bigr => y; rewrite !cfunE mulrA mulrDl.\nQed.",
    "Lemma cfIndE (G H : {group gT}) phi x :\n  H \\subset G -> 'Ind[G, H] phi x = #|H|%:R^-1 * (\\sum_(y in G) phi (x ^ y)).\nProof. by rewrite cfunElock !genGid => ->. Qed.",
    "Lemma cfIndEout phi :\n  ~~ (H \\subset G) -> 'Ind[G] phi = (#|G|%:R * '[phi, 1]) *: '1_1%G.\nProof.\nmove/negPf=> not_sHG; apply/cfunP=> x; rewrite cfunE cfuniE ?normal1 // inE.\nby rewrite mulr_natr cfunElock !genGid not_sHG.\nQed.",
    "Lemma cfIndEsdprod (phi : 'CF(K)) x :\n  K ><| H = G -> 'Ind[G] phi x = \\sum_(w in H) phi (x ^ w)%g.\nProof.\nmove=> defG; have [/andP[sKG _] _ mulKH nKH _] := sdprod_context defG.\nrewrite cfIndE //; apply: canLR (mulKf (neq0CG _)) _; rewrite -mulKH mulr_sumr.\nrewrite (set_partition_big _ (rcosets_partition_mul H K)) ?big_imset /=.\n  apply: eq_bigr => y Hy; rewrite rcosetE norm_rlcoset ?(subsetP nKH) //.\n  rewrite -lcosetE mulr_natl big_imset /=; last exact: in2W (mulgI _).\n  by rewrite -sumr_const; apply: eq_bigr => z Kz; rewrite conjgM cfunJ.\nhave [{}nKH /isomP[injf _]] := sdprod_isom defG.\napply: can_in_inj (fun Ky => invm injf (coset K (repr Ky))) _ => y Hy.\nby rewrite rcosetE -val_coset ?(subsetP nKH) // coset_reprK invmE.\nQed.",
    "Lemma cfInd_on A phi :\n  H \\subset G -> phi \\in 'CF(H, A) -> 'Ind[G] phi \\in 'CF(G, class_support A G).\nProof.\nmove=> sHG Af; apply/cfun_onP=> g AG'g; rewrite cfIndE ?big1 ?mulr0 // => h Gh.\napply: (cfun_on0 Af); apply: contra AG'g => Agh.\nby rewrite -[g](conjgK h) memJ_class_support // groupV.\nQed.",
    "Lemma cfInd_id phi : 'Ind[H] phi = phi.\nProof.\napply/cfun_inP=> x Hx; rewrite cfIndE // (eq_bigr _ (cfunJ phi x)) sumr_const.\nby rewrite -[phi x *+ _]mulr_natl mulKf ?neq0CG.\nQed.",
    "Lemma cfInd_normal phi : H <| G -> 'Ind[G] phi \\in 'CF(G, H).\nProof.\ncase/andP=> sHG nHG; apply: (cfun_onS (class_support_sub_norm (subxx _) nHG)).\nby rewrite cfInd_on ?cfun_onG.\nQed.",
    "Lemma cfInd1 phi : H \\subset G -> 'Ind[G] phi 1%g = #|G : H|%:R * phi 1%g.\nProof.\nmove=> sHG; rewrite cfIndE // natf_indexg // -mulrA mulrCA; congr (_ * _).\nby rewrite mulr_natl -sumr_const; apply: eq_bigr => x; rewrite conj1g.\nQed.",
    "Lemma cfInd_cfun1 : H <| G -> 'Ind[G, H] 1 = #|G : H|%:R *: '1_H.\nProof.\nmove=> nsHG; have [sHG nHG] := andP nsHG; rewrite natf_indexg // mulrC.\napply/cfunP=> x; rewrite cfIndE ?cfunE ?cfuniE // -mulrA; congr (_ * _).\nrewrite mulr_natl -sumr_const; apply: eq_bigr => y Gy.\nby rewrite cfun1E -{1}(normsP nHG y Gy) memJ_conjg.\nQed.",
    "Lemma cfnorm_Ind_cfun1 : H <| G -> '['Ind[G, H] 1] = #|G : H|%:R.\nProof.\nmove=> nsHG; rewrite cfInd_cfun1 // cfnormZ normr_nat cfdot_cfuni // setIid.\nby rewrite expr2 {2}natf_indexg ?normal_sub // !mulrA divfK ?mulfK ?neq0CG.\nQed.",
    "Lemma cfIndInd phi :\n  K \\subset G -> H \\subset K -> 'Ind[G] ('Ind[K] phi) = 'Ind[G] phi.\nProof.\nmove=> sKG sHK; apply/cfun_inP=> x Gx; rewrite !cfIndE ?(subset_trans sHK) //.\napply: canLR (mulKf (neq0CG K)) _; rewrite mulr_sumr mulr_natl.\ntransitivity (\\sum_(y in G) \\sum_(z in K) #|H|%:R^-1 * phi ((x ^ y) ^ z)).\n  by apply: eq_bigr => y Gy; rewrite cfIndE // -mulr_sumr.\nsymmetry; rewrite exchange_big /= -sumr_const; apply: eq_bigr => z Kz.\nrewrite (reindex_inj (mulIg z)).\nby apply: eq_big => [y | y _]; rewrite ?conjgM // groupMr // (subsetP sKG).\nQed.",
    "Lemma Frobenius_reciprocity phi psi : '[phi, 'Res[H] psi] = '['Ind[G] phi, psi].\nProof.\nhave [sHG | not_sHG] := boolP (H \\subset G); last first.\n  rewrite cfResEout // cfIndEout // cfdotZr cfdotZl mulrAC; congr (_ * _).\n  rewrite (cfdotEl _ (cfuni_on _ _)) mulVKf ?neq0CG // big_set1.\n  by rewrite cfuniE ?normal1 ?set11 ?mul1r.\ntransitivity (#|H|%:R^-1 * \\sum_(x in G) phi x * (psi x)^* ).\n  rewrite (big_setID H) /= (setIidPr sHG) addrC big1 ?add0r; last first.\n    by move=> x /setDP[_ /cfun0->]; rewrite mul0r.\n  by congr (_ * _); apply: eq_bigr => x Hx; rewrite cfResE.\nset h' := _^-1; apply: canRL (mulKf (neq0CG G)) _.\ntransitivity (h' * \\sum_(y in G) \\sum_(x in G) phi (x ^ y) * (psi (x ^ y))^* ).\n  rewrite mulrCA mulr_natl -sumr_const; congr (_ * _); apply: eq_bigr => y Gy.\n  by rewrite (reindex_acts 'J _ Gy) ?astabsJ ?normG.\nrewrite exchange_big mulr_sumr; apply: eq_bigr => x _; rewrite cfIndE //=.\nby rewrite -mulrA mulr_suml; congr (_ * _); apply: eq_bigr => y /(cfunJ psi)->.\nQed.",
    "Lemma cfdot_Res_l psi phi : '['Res[H] psi, phi] = '[psi, 'Ind[G] phi].\nProof. by rewrite cfdotC cfdot_Res_r -cfdotC. Qed.",
    "Lemma cfIndM phi psi:  H \\subset G ->\n     'Ind[G] (phi * ('Res[H] psi)) = 'Ind[G] phi * psi.\nProof.\nmove=> HsG; apply/cfun_inP=> x Gx; rewrite !cfIndE // !cfunE !cfIndE // -mulrA.\ncongr (_ * _); rewrite mulr_suml; apply: eq_bigr=> i iG; rewrite !cfunE.\ncase: (boolP (x ^ i \\in H)) => xJi; last by rewrite cfun0gen ?mul0r ?genGid.\nby rewrite !cfResE //; congr (_ * _); rewrite cfunJgen ?genGid.\nQed.",
    "Lemma cfIndMorph (f : {morphism D >-> rT}) (phi : 'CF(f @* H)) :\n    'ker f \\subset H -> H \\subset G -> G \\subset D ->\n  'Ind[G] (cfMorph phi) = cfMorph ('Ind[f @* G] phi).\nProof.\nmove=> sKH sHG sGD; have [sHD inD] := (subset_trans sHG sGD, subsetP sGD).\napply/cfun_inP=> /= x Gx; have [Dx sKG] := (inD x Gx, subset_trans sKH sHG).\nrewrite cfMorphE ?cfIndE ?morphimS // (partition_big_imset f) -morphimEsub //=.\nrewrite card_morphim (setIidPr sHD) natf_indexg // invfM invrK -mulrA.\ncongr (_ * _); rewrite mulr_sumr; apply: eq_bigr => _ /morphimP[y Dy Gy ->].\nrewrite -(card_rcoset _ y) mulr_natl -sumr_const.\napply: eq_big => [z | z /andP[Gz /eqP <-]].\n  have [Gz | G'z] := boolP (z \\in G).\n    by rewrite (sameP eqP (rcoset_kerP _ _ _)) ?inD.\n  by case: rcosetP G'z => // [[t Kt ->]]; rewrite groupM // (subsetP sKG).\nhave [Dz Dxz] := (inD z Gz, inD (x ^ z) (groupJ Gx Gz)); rewrite -morphJ //.\nhave [Hxz | notHxz] := boolP (x ^ z \\in H); first by rewrite cfMorphE.\nby rewrite !cfun0 // -sub1set -morphim_set1 // morphimSGK ?sub1set.\nQed.",
    "Lemma cfResIsom phi : 'Res[S] (cfIsom isoG phi) = cfIsom isoH ('Res[H] phi).\nProof.\nhave [[injg defR] [injh defS]] := (isomP isoG, isomP isoH).\nrewrite !morphimEdom in defS defR; apply/cfun_inP=> s.\nrewrite -{1}defS => /imsetP[x Hx ->] {s}; have Gx := subsetP sHG x Hx.\nrewrite {1}eq_hg ?(cfResE, cfIsomE) // -defS -?eq_hg ?imset_f // -defR.\nby rewrite (eq_in_imset eq_hg) imsetS.\nQed.",
    "Lemma cfIndIsom phi : 'Ind[R] (cfIsom isoH phi) = cfIsom isoG ('Ind[G] phi).\nProof.\nhave [[injg defR] [_ defS]] := (isomP isoG, isomP isoH).\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\napply/cfun_inP=> s; rewrite -{1}defR => /morphimP[x _ Gx ->]{s}.\nrewrite cfIsomE ?cfIndE // -defR -{1}defS ?morphimS ?card_injm // morphimEdom.\ncongr (_ * _); rewrite big_imset //=; last exact/injmP.\napply: eq_bigr => y Gy; rewrite -morphJ //.\nhave [Hxy | H'xy] := boolP (x ^ y \\in H); first by rewrite -eq_hg ?cfIsomE.\nby rewrite !cfun0 -?defS // -sub1set -morphim_set1 ?injmSK ?sub1set // groupJ.\nQed.",
    "Lemma cfAutZ_nat n phi : (n%:R *: phi)^u = n%:R *: phi^u.\nProof. exact: raddfZnat. Qed.",
    "Lemma cfAutZ_Cnat z phi : z \\in Num.nat -> (z *: phi)^u = z *: phi^u.\nProof. exact: raddfZ_nat. Qed.",
    "Lemma cfAutZ_Cint z phi : z \\in Num.int -> (z *: phi)^u = z *: phi^u.\nProof. exact: raddfZ_int. Qed.",
    "Lemma cfAutK : cancel (@cfAut gT G u) (cfAut (algC_invaut u)).\nProof. by move=> phi; apply/cfunP=> x; rewrite !cfunE /= algC_autK. Qed.",
    "Lemma cfAutVK : cancel (cfAut (algC_invaut u)) (@cfAut gT G u).\nProof. by move=> phi; apply/cfunP=> x; rewrite !cfunE /= algC_invautK. Qed.",
    "Lemma cfAut_inj : injective (@cfAut gT G u).\nProof. exact: can_inj cfAutK. Qed.",
    "Lemma cfAut_eq1 phi : (cfAut u phi == 1) = (phi == 1).\nProof. by rewrite rmorph_eq1 //; apply: cfAut_inj. Qed.",
    "Lemma support_cfAut phi : support phi^u =i support phi.\nProof. by move=> x; rewrite !inE cfunE fmorph_eq0. Qed.",
    "Lemma map_cfAut_free S : cfAut_closed u S -> free S -> free (map (cfAut u) S).\nProof.\nset Su := map _ S => sSuS freeS; have uniqS := free_uniq freeS.\nhave uniqSu: uniq Su by rewrite (map_inj_uniq cfAut_inj).\nhave{} sSuS: {subset Su <= S} by move=> _ /mapP[phi Sphi ->]; apply: sSuS.\nhave [|_ eqSuS] := uniq_min_size uniqSu sSuS; first by rewrite size_map.\nby rewrite (perm_free (uniq_perm uniqSu uniqS eqSuS)).\nQed.",
    "Lemma cfAut_on A phi : (phi^u \\in 'CF(G, A)) = (phi \\in 'CF(G, A)).\nProof. by rewrite !cfun_onE (eq_subset (support_cfAut phi)). Qed.",
    "Lemma cfker_aut phi : cfker phi^u = cfker phi.\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nby apply/forallP/forallP=> Kx y;\n  have:= Kx y; rewrite !cfunE (inj_eq (fmorph_inj u)).\nQed.",
    "Lemma cfAut_cfuni A : ('1_A)^u = '1_A :> 'CF(G).\nProof. by apply/cfunP=> x; rewrite !cfunElock rmorph_nat. Qed.",
    "Lemma cforder_aut phi : #[phi^u]%CF = #[phi]%CF.\nProof. exact: cforder_inj_rmorph cfAut_inj. Qed.",
    "Lemma cfAutRes phi : ('Res[H] phi)^u = 'Res phi^u.\nProof. by apply/cfunP=> x; rewrite !cfunElock rmorphMn. Qed.",
    "Lemma cfAutMorph (psi : 'CF(f @* H)) : (cfMorph psi)^u = cfMorph psi^u.\nProof. by apply/cfun_inP=> x Hx; rewrite !cfunElock Hx. Qed.",
    "Lemma cfAutIsom (isoGR : isom G R f) phi :\n  (cfIsom isoGR phi)^u = cfIsom isoGR phi^u.\nProof.\napply/cfun_inP=> y; have [_ {1}<-] := isomP isoGR => /morphimP[x _ Gx ->{y}].\nby rewrite !(cfunE, cfIsomE).\nQed.",
    "Lemma cfAutQuo phi : (phi / H)^u = (phi^u / H)%CF.\nProof. by apply/cfunP=> Hx; rewrite !cfunElock cfker_aut rmorphMn. Qed.",
    "Lemma cfAutMod (psi : 'CF(G / H)) : (psi %% H)^u = (psi^u %% H)%CF.\nProof. by apply/cfunP=> x; rewrite !cfunElock rmorphMn. Qed.",
    "Lemma cfAutInd (psi : 'CF(H)) : ('Ind[G] psi)^u = 'Ind psi^u.\nProof.\nhave [sHG | not_sHG] := boolP (H \\subset G).\n  apply/cfunP=> x; rewrite !(cfunE, cfIndE) // rmorphM /= fmorphV rmorph_nat.\n  by congr (_ * _); rewrite rmorph_sum; apply: eq_bigr => y; rewrite !cfunE.\nrewrite !cfIndEout // linearZ /= cfAut_cfuni rmorphM rmorph_nat /=.\nrewrite -cfdot_cfAut ?rmorph1 // => _ /imageP[x Hx ->].\nby rewrite cfun1E Hx !rmorph1.\nQed.",
    "Lemma cfAutDprodl (phi : 'CF(K)) : (cfDprodl KxH phi)^u = cfDprodl KxH phi^u.\nProof.\napply/cfun_inP=> _ /(mem_dprod KxH)[x [y [Kx Hy -> _]]].\nby rewrite !(cfunE, cfDprodEl).\nQed.",
    "Lemma cfAutDprodr (psi : 'CF(H)) : (cfDprodr KxH psi)^u = cfDprodr KxH psi^u.\nProof.\napply/cfun_inP=> _ /(mem_dprod KxH)[x [y [Kx Hy -> _]]].\nby rewrite !(cfunE, cfDprodEr).\nQed.",
    "Lemma cfAutDprod (phi : 'CF(K)) (psi : 'CF(H)) :\n  (cfDprod KxH phi psi)^u = cfDprod KxH phi^u psi^u.\nProof. by rewrite rmorphM /= cfAutDprodl cfAutDprodr. Qed.",
    "Lemma cfConjgE phi y x : y \\in 'N(G) -> (phi ^ y)%CF x = phi (x ^ y^-1)%g.\nProof. by rewrite cfunElock genGid => ->. Qed.",
    "Lemma cfConjgEJ phi y x : y \\in 'N(G) -> (phi ^ y)%CF (x ^ y) = phi x.\nProof. by move/cfConjgE->; rewrite conjgK. Qed.",
    "Lemma cfConjgEout phi y : y \\notin 'N(G) -> (phi ^ y = phi)%CF.\nProof.\nby move/negbTE=> notNy; apply/cfunP=> x; rewrite !cfunElock genGid notNy.\nQed.",
    "Lemma cfConjgEin phi y (nGy : y \\in 'N(G)) :\n  (phi ^ y)%CF = cfIsom (norm_conj_isom nGy) phi.\nProof.\napply/cfun_inP=> x Gx.\nby rewrite cfConjgE // -{2}[x](conjgKV y) cfIsomE ?memJ_norm ?groupV.\nQed.",
    "Lemma cfConjgMnorm phi :\n  {in 'N(G) &, forall y z, phi ^ (y * z) = (phi ^ y) ^ z}%CF.\nProof.\nmove=> y z nGy nGz.\nby apply/cfunP=> x; rewrite !cfConjgE ?groupM // invMg conjgM.\nQed.",
    "Lemma cfConjg_id phi y : y \\in G -> (phi ^ y)%CF = phi.\nProof.\nmove=> Gy; apply/cfunP=> x; have nGy := subsetP (normG G) y Gy.\nby rewrite -(cfunJ _ _ Gy) cfConjgEJ.\nQed.",
    "Lemma cfConjgM L phi :\n  G <| L -> {in L &, forall y z, phi ^ (y * z) = (phi ^ y) ^ z}%CF.\nProof. by case/andP=> _ /subsetP nGL; apply: sub_in2 (cfConjgMnorm phi). Qed.",
    "Lemma cfConjgJ1 phi : (phi ^ 1)%CF = phi.\nProof. by apply/cfunP=> x; rewrite cfConjgE ?group1 // invg1 conjg1. Qed.",
    "Lemma cfConjgK y : cancel (cfConjg y) (cfConjg y^-1 : 'CF(G) -> 'CF(G)).\nProof.\nmove=> phi; apply/cfunP=> x; rewrite !cfunElock groupV /=.\nby case: ifP => -> //; rewrite conjgKV.\nQed.",
    "Lemma cfConjgKV y : cancel (cfConjg y^-1) (cfConjg y : 'CF(G) -> 'CF(G)).\nProof. by move=> phi /=; rewrite -{1}[y]invgK cfConjgK. Qed.",
    "Lemma cfConjg1 phi y : (phi ^ y)%CF 1%g = phi 1%g.\nProof. by rewrite cfunElock conj1g if_same. Qed.",
    "Lemma cfConjg_cfuniJ A y : y \\in 'N(G) -> ('1_A ^ y)%CF = '1_(A :^ y) :> 'CF(G).\nProof.\nmove=> nGy; apply/cfunP=> x; rewrite !cfunElock genGid nGy -sub_conjgV.\nby rewrite -class_lcoset -class_rcoset norm_rlcoset ?memJ_norm ?groupV.\nQed.",
    "Lemma cfConjg_cfuni A y : y \\in 'N(A) -> ('1_A ^ y)%CF = '1_A :> 'CF(G).\nProof.\nby have [/cfConjg_cfuniJ-> /normP-> | /cfConjgEout] := boolP (y \\in 'N(G)).\nQed.",
    "Lemma cfConjg_cfun1 y : (1 ^ y)%CF = 1 :> 'CF(G).\nProof.\nby rewrite -cfuniG; have [/cfConjg_cfuni|/cfConjgEout] := boolP (y \\in 'N(G)).\nQed.",
    "Lemma cfConjg_eq1 phi y : ((phi ^ y)%CF == 1) = (phi == 1).\nProof. by apply: rmorph_eq1; apply: can_inj (cfConjgK y). Qed.",
    "Lemma cfAutConjg phi u y : cfAut u (phi ^ y) = (cfAut u phi ^ y)%CF.\nProof. by apply/cfunP=> x; rewrite !cfunElock. Qed.",
    "Lemma conj_cfConjg phi y : (phi ^ y)^*%CF = (phi^* ^ y)%CF.\nProof. exact: cfAutConjg. Qed.",
    "Lemma cfker_conjg phi y : y \\in 'N(G) -> cfker (phi ^ y) = cfker phi :^ y.\nProof.\nmove=> nGy; rewrite cfConjgEin // cfker_isom.\nby rewrite morphim_conj (setIidPr (cfker_sub _)).\nQed.",
    "Lemma cfDetConjg phi y : cfDet (phi ^ y) = (cfDet phi ^ y)%CF.\nProof.\nhave [nGy | not_nGy] := boolP (y \\in 'N(G)); last by rewrite !cfConjgEout.\nby rewrite !cfConjgEin cfDetIsom.\nQed.",
    "Lemma inertiaJ phi y : y \\in 'I[phi] -> (phi ^ y)%CF = phi.\nProof. by case/setIdP=> _ /eqP->. Qed.",
    "Lemma inertia_valJ phi x y : y \\in 'I[phi] -> phi (x ^ y)%g = phi x.\nProof. by case/setIdP=> nHy /eqP {1}<-; rewrite cfConjgEJ. Qed.",
    "Lemma Inertia_sub phi : 'I_G[phi] \\subset G.\nProof. exact: subsetIl. Qed.",
    "Lemma norm_inertia phi : 'I[phi] \\subset 'N(H).\nProof. by rewrite ['I[_]]setIdE subsetIl. Qed.",
    "Lemma sub_inertia phi : H \\subset 'I[phi].\nProof.\nby apply/subsetP=> y Hy; rewrite inE cfConjg_id ?(subsetP (normG H)) /=.\nQed.",
    "Lemma normal_inertia phi : H <| 'I[phi].\nProof. by rewrite /normal sub_inertia norm_inertia. Qed.",
    "Lemma sub_Inertia phi : H \\subset G -> H \\subset 'I_G[phi].\nProof. by rewrite subsetI sub_inertia andbT. Qed.",
    "Lemma norm_Inertia phi : 'I_G[phi] \\subset 'N(H).\nProof. by rewrite setIC subIset ?norm_inertia. Qed.",
    "Lemma normal_Inertia phi : H \\subset G -> H <| 'I_G[phi].\nProof. by rewrite /normal norm_Inertia andbT; apply: sub_Inertia. Qed.",
    "Lemma cfConjg_eqE phi :\n    H <| G ->\n  {in G &, forall y z, (phi ^ y == phi ^ z)%CF = (z \\in 'I_G[phi] :* y)}.\nProof.\ncase/andP=> _ nHG y z Gy; rewrite -{1 2}[z](mulgKV y) groupMr // mem_rcoset.\nmove: {z}(z * _)%g => z Gz; rewrite 2!inE Gz cfConjgMnorm ?(subsetP nHG) //=.\nby rewrite eq_sym (can_eq (cfConjgK y)).\nQed.",
    "Lemma cent_sub_inertia phi : 'C(H) \\subset 'I[phi].\nProof.\napply/subsetP=> y cHy; have nHy := subsetP (cent_sub H) y cHy.\nrewrite inE nHy; apply/eqP/cfun_inP=> x Hx; rewrite cfConjgE //.\nby rewrite /conjg invgK mulgA (centP cHy) ?mulgK.\nQed.",
    "Lemma cent_sub_Inertia phi : 'C_G(H) \\subset 'I_G[phi].\nProof. exact: setIS (cent_sub_inertia phi). Qed.",
    "Lemma center_sub_Inertia phi : H \\subset G -> 'Z(G) \\subset 'I_G[phi].\nProof.\nby move/centS=> sHG; rewrite setIS // (subset_trans sHG) // cent_sub_inertia.\nQed.",
    "Lemma conjg_inertia phi y : y \\in 'N(H) -> 'I[phi] :^ y = 'I[phi ^ y].\nProof.\nmove=> nHy; apply/setP=> z; rewrite !['I[_]]setIdE conjIg conjGid // !in_setI.\napply/andb_id2l=> nHz; rewrite mem_conjg !inE.\nby rewrite !cfConjgMnorm ?in_group ?(can2_eq (cfConjgKV y) (cfConjgK y)) ?invgK.\nQed.",
    "Lemma inertia0 : 'I[0 : 'CF(H)] = 'N(H).\nProof. by apply/setP=> x; rewrite !inE linear0 eqxx andbT. Qed.",
    "Lemma inertia_add phi psi : 'I[phi] :&: 'I[psi] \\subset 'I[phi + psi].\nProof.\nrewrite !['I[_]]setIdE -setIIr setIS //.\nby apply/subsetP=> x /[!(inE, linearD)]/= /andP[/eqP-> /eqP->].\nQed.",
    "Lemma inertia_sum I r (P : pred I) (Phi : I -> 'CF(H)) :\n  'N(H) :&: \\bigcap_(i <- r | P i) 'I[Phi i]\n     \\subset 'I[\\sum_(i <- r | P i) Phi i].\nProof.\nelim/big_rec2: _ => [|i K psi Pi sK_Ipsi]; first by rewrite setIT inertia0.\nby rewrite setICA; apply: subset_trans (setIS _ sK_Ipsi) (inertia_add _ _).\nQed.",
    "Lemma inertia_scale a phi : 'I[phi] \\subset 'I[a *: phi].\nProof.\napply/subsetP=> x /setIdP[nHx /eqP Iphi_x].\nby rewrite inE nHx linearZ /= Iphi_x.\nQed.",
    "Lemma inertia_scale_nz a phi : a != 0 -> 'I[a *: phi] = 'I[phi].\nProof.\nmove=> nz_a; apply/eqP.\nby rewrite eqEsubset -{2}(scalerK nz_a phi) !inertia_scale.\nQed.",
    "Lemma inertia_opp phi : 'I[- phi] = 'I[phi].\nProof. by rewrite -scaleN1r inertia_scale_nz // oppr_eq0 oner_eq0. Qed.",
    "Lemma inertia1 : 'I[1 : 'CF(H)] = 'N(H).\nProof. by apply/setP=> x; rewrite inE rmorph1 eqxx andbT. Qed.",
    "Lemma Inertia1 : H <| G -> 'I_G[1 : 'CF(H)] = G.\nProof. by rewrite inertia1 => /normal_norm/setIidPl. Qed.",
    "Lemma inertia_mul phi psi : 'I[phi] :&: 'I[psi] \\subset 'I[phi * psi].\nProof.\nrewrite !['I[_]]setIdE -setIIr setIS //.\nby apply/subsetP=> x /[!(inE, rmorphM)]/= /andP[/eqP-> /eqP->].\nQed.",
    "Lemma inertia_prod I r (P : pred I) (Phi : I -> 'CF(H)) :\n  'N(H) :&: \\bigcap_(i <- r | P i) 'I[Phi i]\n     \\subset 'I[\\prod_(i <- r | P i) Phi i].\nProof.\nelim/big_rec2: _ => [|i K psi Pi sK_psi]; first by rewrite inertia1 setIT.\nby rewrite setICA; apply: subset_trans (setIS _ sK_psi) (inertia_mul _ _).\nQed.",
    "Lemma inertia_injective (chi : 'CF(H)) :\n  {in H &, injective chi} -> 'I[chi] = 'C(H).\nProof.\nmove=> inj_chi; apply/eqP; rewrite eqEsubset cent_sub_inertia andbT.\napply/subsetP=> y Ichi_y; have /setIdP[nHy _] := Ichi_y.\napply/centP=> x Hx; apply/esym/commgP/conjg_fixP.\nby apply/inj_chi; rewrite ?memJ_norm ?(inertia_valJ _ Ichi_y).\nQed.",
    "Lemma inertia_irr_prime p i :\n  #|H| = p -> prime p -> i != 0 -> 'I['chi[H]_i] = 'C(H).\nProof. by move=> <- pr_H /(irr_prime_injP pr_H); apply: inertia_injective. Qed.",
    "Lemma inertia_irr0 : 'I['chi[H]_0] = 'N(H).\nProof. by rewrite irr0 inertia1. Qed.",
    "Lemma cfConjg_iso y : isometry (cfConjg y : 'CF(H) -> 'CF(H)).\nProof.\nmove=> phi psi; congr (_ * _).\nhave [nHy | not_nHy] := boolP (y \\in 'N(H)); last by rewrite !cfConjgEout.\nrewrite (reindex_astabs 'J y) ?astabsJ //=.\nby apply: eq_bigr=> x _; rewrite !cfConjgEJ.\nQed.",
    "Lemma cfdot_Res_conjg psi phi y :\n  y \\in G -> '['Res[H, G] psi, phi ^ y] = '['Res[H] psi, phi].\nProof.\nmove=> Gy; rewrite -(cfConjg_iso y _ phi); congr '[_, _]; apply/cfunP=> x.\nrewrite !cfunElock !genGid; case nHy: (y \\in 'N(H)) => //.\nby rewrite !(fun_if psi) cfunJ ?memJ_norm ?groupV.\nQed.",
    "Lemma cfConjg_char (chi : 'CF(H)) y :\n  chi \\is a character -> (chi ^ y)%CF \\is a character.\nProof.\nhave [nHy Nchi | /cfConjgEout-> //] := boolP (y \\in 'N(H)).\nby rewrite cfConjgEin cfIsom_char.\nQed.",
    "Lemma cfConjg_lin_char (chi : 'CF(H)) y :\n  chi \\is a linear_char -> (chi ^ y)%CF \\is a linear_char.\nProof. by case/andP=> Nchi chi1; rewrite qualifE/= cfConjg1 cfConjg_char. Qed.",
    "Lemma cfConjg_irr y chi : chi \\in irr H -> (chi ^ y)%CF \\in irr H.\nProof. by rewrite !irrEchar cfConjg_iso => /andP[/cfConjg_char->]. Qed.",
    "Lemma conjg_IirrE i y : 'chi_(conjg_Iirr i y) = ('chi_i ^ y)%CF.\nProof. by rewrite cfIirrE ?cfConjg_irr ?mem_irr. Qed.",
    "Lemma conjg_IirrK y : cancel (conjg_Iirr^~ y) (conjg_Iirr^~ y^-1%g).\nProof. by move=> i; apply/irr_inj; rewrite !conjg_IirrE cfConjgK. Qed.",
    "Lemma conjg_IirrKV y : cancel (conjg_Iirr^~ y^-1%g) (conjg_Iirr^~ y).\nProof. by rewrite -{2}[y]invgK; apply: conjg_IirrK. Qed.",
    "Lemma conjg_Iirr_inj y : injective (conjg_Iirr^~ y).\nProof. exact: can_inj (conjg_IirrK y). Qed.",
    "Lemma conjg_Iirr_eq0 i y : (conjg_Iirr i y == 0) = (i == 0).\nProof. by rewrite -!irr_eq1 conjg_IirrE cfConjg_eq1. Qed.",
    "Lemma conjg_Iirr0 x : conjg_Iirr 0 x = 0.\nProof. by apply/eqP; rewrite conjg_Iirr_eq0. Qed.",
    "Lemma cfdot_irr_conjg i y :\n  H <| G -> y \\in G -> '['chi_i, 'chi_i ^ y]_H = (y \\in 'I_G['chi_i])%:R.\nProof.\nmove=> nsHG Gy; rewrite -conjg_IirrE cfdot_irr -(inj_eq irr_inj) conjg_IirrE.\nby rewrite -{1}['chi_i]cfConjgJ1 cfConjg_eqE ?mulg1.\nQed.",
    "Lemma size_cfclass i : size ('chi[H]_i ^: G)%CF = #|G : 'I_G['chi_i]|.\nProof. by rewrite size_map -cardE. Qed.",
    "Lemma cfclassP (A : {group gT}) phi psi :\n  reflect (exists2 y, y \\in A & psi = phi ^ y)%CF (psi \\in phi ^: A)%CF.\nProof.\napply: (iffP imageP) => [[_ /rcosetsP[y Ay ->] ->] | [y Ay ->]].\n  by case: repr_rcosetP => z /setIdP[Az _]; exists (z * y)%g; rewrite ?groupM.\nwithout loss nHy: y Ay / y \\in 'N(H).\n  have [nHy | /cfConjgEout->] := boolP (y \\in 'N(H)); first exact.\n  by move/(_ 1%g); rewrite !group1 !cfConjgJ1; apply.\nexists ('I_A[phi] :* y); first by rewrite -rcosetE imset_f.\ncase: repr_rcosetP => z /setIP[_ /setIdP[nHz /eqP Tz]].\nby rewrite cfConjgMnorm ?Tz.\nQed.",
    "Lemma cfclassInorm phi : (phi ^: 'N_G(H) =i phi ^: G)%CF.\nProof.\nmove=> xi; apply/cfclassP/cfclassP=> [[x /setIP[Gx _] ->] | [x Gx ->]].\n  by exists x.\nhave [Nx | /cfConjgEout-> //] := boolP (x \\in 'N(H)).\n  by exists x; first apply/setIP.\nby exists 1%g; rewrite ?group1 ?cfConjgJ1.\nQed.",
    "Lemma cfclass_refl phi : phi \\in (phi ^: G)%CF.\nProof. by apply/cfclassP; exists 1%g => //; rewrite cfConjgJ1. Qed.",
    "Lemma cfclass_transr phi psi :\n  (psi \\in phi ^: G)%CF -> (phi ^: G =i psi ^: G)%CF.\nProof.\nrewrite -cfclassInorm; case/cfclassP=> x Gx -> xi; rewrite -!cfclassInorm.\nhave nHN: {subset 'N_G(H) <= 'N(H)} by apply/subsetP; apply: subsetIr.\napply/cfclassP/cfclassP=> [[y Gy ->] | [y Gy ->]].\n  by exists (x^-1 * y)%g; rewrite -?cfConjgMnorm ?groupM ?groupV ?nHN // mulKVg.\nby exists (x * y)%g; rewrite -?cfConjgMnorm ?groupM ?nHN.\nQed.",
    "Lemma cfclass_sym phi psi : (psi \\in phi ^: G)%CF = (phi \\in psi ^: G)%CF.\nProof. by apply/idP/idP=> /cfclass_transr <-; apply: cfclass_refl. Qed.",
    "Lemma cfclass_uniq phi : H <| G -> uniq (phi ^: G)%CF.\nProof.\nmove=> nsHG; rewrite map_inj_in_uniq ?enum_uniq // => Ty Tz; rewrite !mem_enum.\nmove=> {Ty}/rcosetsP[y Gy ->] {Tz}/rcosetsP[z Gz ->] /eqP.\ncase: repr_rcosetP => u Iphi_u; case: repr_rcosetP => v Iphi_v.\nhave [[Gu _] [Gv _]] := (setIdP Iphi_u, setIdP Iphi_v).\nrewrite cfConjg_eqE ?groupM // => /rcoset_eqP.\nby rewrite !rcosetM (rcoset_id Iphi_v) (rcoset_id Iphi_u).\nQed.",
    "Lemma cfclass_invariant phi : G \\subset 'I[phi] -> (phi ^: G)%CF = phi.\nProof.\nmove/setIidPl=> IGphi; rewrite /cfclass IGphi // rcosets_id.\nby rewrite /(image _ _) enum_set1 /= repr_group cfConjgJ1.\nQed.",
    "Lemma cfclass1 : H <| G -> (1 ^: G)%CF = [:: 1 : 'CF(H)].\nProof. by move/normal_norm=> nHG; rewrite cfclass_invariant ?inertia1.  Qed.",
    "Lemma cfclass_IirrE i j :\n  (j \\in cfclass_Iirr G i) = ('chi_j \\in 'chi_i ^: G)%CF.\nProof.\napply/imsetP/cfclassP=> [[y Gy ->] | [y]]; exists y; rewrite ?conjg_IirrE //.\nby apply: irr_inj; rewrite conjg_IirrE.\nQed.",
    "Lemma eq_cfclass_IirrE i j :\n  (cfclass_Iirr G j == cfclass_Iirr G i) = (j \\in cfclass_Iirr G i).\nProof.\napply/eqP/idP=> [<- | iGj]; first by rewrite cfclass_IirrE cfclass_refl.\nby apply/setP=> k; rewrite !cfclass_IirrE in iGj *; apply/esym/cfclass_transr.\nQed.",
    "Lemma im_cfclass_Iirr i :\n  H <| G -> perm_eq [seq 'chi_j | j in cfclass_Iirr G i] ('chi_i ^: G)%CF.\nProof.\nmove=> nsHG; have UchiG := cfclass_uniq 'chi_i nsHG.\napply: uniq_perm; rewrite ?(map_inj_uniq irr_inj) ?enum_uniq // => phi.\napply/imageP/idP=> [[j iGj ->] | /cfclassP[y]]; first by rewrite -cfclass_IirrE.\nby exists (conjg_Iirr i y); rewrite ?imset_f ?conjg_IirrE.\nQed.",
    "Lemma card_cfclass_Iirr i : H <| G -> #|cfclass_Iirr G i| = #|G : 'I_G['chi_i]|.\nProof.\nmove=> nsHG; rewrite -size_cfclass -(perm_size (im_cfclass_Iirr i nsHG)).\nby rewrite size_map -cardE.\nQed.",
    "Lemma reindex_cfclass R idx (op : Monoid.com_law idx) (F : 'CF(H) -> R) i :\n     H <| G ->\n  \\big[op/idx]_(chi <- ('chi_i ^: G)%CF) F chi\n     = \\big[op/idx]_(j | 'chi_j \\in ('chi_i ^: G)%CF) F 'chi_j.\nProof.\nmove/im_cfclass_Iirr/(perm_big _) <-; rewrite big_image /=.\nby apply: eq_bigl => j; rewrite cfclass_IirrE.\nQed.",
    "Lemma cfResInd j:\n    H <| G ->\n  'Res[H] ('Ind[G] 'chi_j) = #|H|%:R^-1 *: (\\sum_(y in G) 'chi_j ^ y)%CF.\nProof.\ncase/andP=> [sHG /subsetP nHG].\nrewrite (reindex_inj invg_inj); apply/cfun_inP=> x Hx.\nrewrite cfResE // cfIndE // ?cfunE ?sum_cfunE; congr (_ * _).\nby apply: eq_big => [y | y Gy]; rewrite ?cfConjgE ?groupV ?invgK ?nHG.\nQed.",
    "Lemma Clifford_Res_sum_cfclass i j :\n     H <| G -> j \\in irr_constt ('Res[H, G] 'chi_i) ->\n  'Res[H] 'chi_i =\n     '['Res[H] 'chi_i, 'chi_j] *: (\\sum_(chi <- ('chi_j ^: G)%CF) chi).\nProof.\nmove=> nsHG chiHj; have [sHG /subsetP nHG] := andP nsHG.\nrewrite reindex_cfclass //= big_mkcond.\nrewrite {1}['Res _]cfun_sum_cfdot linear_sum /=; apply: eq_bigr => k _.\nhave [[y Gy ->] | ] := altP (cfclassP _ _ _); first by rewrite cfdot_Res_conjg.\napply: contraNeq; rewrite scaler0 scaler_eq0 orbC => /norP[_ chiHk].\nhave{chiHk chiHj}: '['Res[H] ('Ind[G] 'chi_j), 'chi_k] != 0.\n  rewrite !inE !cfdot_Res_l in chiHj chiHk *.\n  apply: contraNneq chiHk; rewrite cfdot_sum_irr => /psumr_eq0P/(_ i isT)/eqP.\n  rewrite -cfdotC cfdotC mulf_eq0 conjC_eq0 (negbTE chiHj) /= => -> // i1.\n  by rewrite -cfdotC natr_ge0 // rpredM ?Cnat_cfdot_char ?cfInd_char ?irr_char.\nrewrite cfResInd // cfdotZl mulf_eq0 cfdot_suml => /norP[_].\napply: contraR => chiGk'j; rewrite big1 // => x Gx; apply: contraNeq chiGk'j.\nrewrite -conjg_IirrE cfdot_irr pnatr_eq0; case: (_ =P k) => // <- _.\nby rewrite conjg_IirrE; apply/cfclassP; exists x.\nQed.",
    "Lemma cfRes_Ind_invariant psi :\n  H <| G -> G \\subset 'I[psi] -> 'Res ('Ind[G, H] psi) = #|G : H|%:R *: psi.\nProof.\ncase/andP=> sHG _ /subsetP IGpsi; apply/cfun_inP=> x Hx.\nrewrite cfResE ?cfIndE ?natf_indexg // cfunE -mulrA mulrCA; congr (_ * _).\nby rewrite mulr_natl -sumr_const; apply: eq_bigr => y /IGpsi/inertia_valJ->.\nQed.",
    "Lemma dvdn_constt_Res1_irr1 i j :\n    H <| G -> j \\in irr_constt ('Res[H, G] 'chi_i) ->\n  exists n, 'chi_i 1%g = n%:R * 'chi_j 1%g.\nProof.\nmove=> nsHG chiHj; have [sHG nHG] := andP nsHG; rewrite -(cfResE _ sHG) //.\nrewrite {1}(Clifford_Res_sum_cfclass nsHG chiHj) cfunE sum_cfunE.\nhave /natrP[n ->]: '['Res[H] 'chi_i, 'chi_j] \\in Num.nat.\n  by rewrite Cnat_cfdot_char ?cfRes_char ?irr_char.\nexists (n * size ('chi_j ^: G)%CF)%N; rewrite natrM -mulrA; congr (_ * _).\nrewrite mulr_natl -[size _]card_ord big_tnth -sumr_const; apply: eq_bigr => k _.\nby have /cfclassP[y Gy ->]:=  mem_tnth k (in_tuple _); rewrite cfConjg1.\nQed.",
    "Lemma cfclass_Ind phi psi :\n  H <| G -> psi \\in (phi ^: G)%CF -> 'Ind[G] phi = 'Ind[G] psi.\nProof.\nmove=> nsHG /cfclassP[y Gy ->]; have [sHG /subsetP nHG] := andP nsHG.\napply/cfun_inP=> x Hx; rewrite !cfIndE //; congr (_ * _).\nrewrite (reindex_acts 'R _ (groupVr Gy)) ?astabsR //=.\nby apply: eq_bigr => z Gz; rewrite conjgM cfConjgE ?nHG.\nQed.",
    "Lemma cfConjgRes_norm phi y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ('Res[K, H] phi ^ y)%CF = 'Res (phi ^ y)%CF.\nProof.\nmove=> nKy nHy; have [sKH | not_sKH] := boolP (K \\subset H); last first.\n  by rewrite !cfResEout // rmorph_alg cfConjg1.\nby apply/cfun_inP=> x Kx; rewrite !(cfConjgE, cfResE) ?memJ_norm ?groupV.\nQed.",
    "Lemma cfConjgRes phi y :\n  H <| G -> K <| G -> y \\in G -> ('Res[K, H] phi ^ y)%CF = 'Res (phi ^ y)%CF.\nProof.\nmove=> /andP[_ nHG] /andP[_ nKG] Gy.\nby rewrite cfConjgRes_norm ?(subsetP nHG) ?(subsetP nKG).\nQed.",
    "Lemma sub_inertia_Res phi :\n  G \\subset 'N(K) -> 'I_G[phi] \\subset 'I_G['Res[K, H] phi].\nProof.\nmove=> nKG; apply/subsetP=> y /setIP[Gy /setIdP[nHy /eqP Iphi_y]].\nby rewrite 2!inE Gy cfConjgRes_norm ?(subsetP nKG) ?Iphi_y /=.\nQed.",
    "Lemma cfConjgInd_norm phi y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ('Ind[H, K] phi ^ y)%CF = 'Ind (phi ^ y)%CF.\nProof.\nmove=> nKy nHy; have [sKH | not_sKH] := boolP (K \\subset H).\n  by rewrite !cfConjgEin (cfIndIsom (norm_conj_isom nHy)).\nrewrite !cfIndEout // linearZ -(cfConjg_iso y) rmorph1 /=; congr (_ *: _).\nby rewrite cfConjg_cfuni ?norm1 ?inE.\nQed.",
    "Lemma cfConjgInd phi y :\n  H <| G -> K <| G -> y \\in G -> ('Ind[H, K] phi ^ y)%CF = 'Ind (phi ^ y)%CF.\nProof.\nmove=> /andP[_ nHG] /andP[_ nKG] Gy.\nby rewrite cfConjgInd_norm ?(subsetP nHG) ?(subsetP nKG).\nQed.",
    "Lemma sub_inertia_Ind phi :\n  G \\subset 'N(H) -> 'I_G[phi] \\subset 'I_G['Ind[H, K] phi].\nProof.\nmove=> nHG; apply/subsetP=> y /setIP[Gy /setIdP[nKy /eqP Iphi_y]].\nby rewrite 2!inE Gy cfConjgInd_norm ?(subsetP nHG) ?Iphi_y /=.\nQed.",
    "Lemma inertia_id : 'I_T['chi_i] = T. Proof. by rewrite -setIA setIid. Qed.",
    "Lemma cfclass_inertia : ('chi[H]_i ^: T)%CF = [:: 'chi_i].\nProof.\nrewrite /cfclass inertia_id rcosets_id /(image _ _) enum_set1 /=.\nby rewrite repr_group cfConjgJ1.\nQed.",
    "Lemma cfConjgMorph (phi : 'CF(f @* H)) y :\n  y \\in D -> y \\in 'N(H) -> (cfMorph phi ^ y)%CF = cfMorph (phi ^ f y).\nProof.\nmove=> Dy nHy; have [sHD | not_sHD] := boolP (H \\subset D); last first.\n  by rewrite !cfMorphEout // rmorph_alg cfConjg1.\napply/cfun_inP=> x Gx; rewrite !(cfConjgE, cfMorphE) ?memJ_norm ?groupV //.\n  by rewrite morphJ ?morphV ?groupV // (subsetP sHD).\nby rewrite (subsetP (morphim_norm _ _)) ?mem_morphim.\nQed.",
    "Lemma inertia_morph_pre (phi : 'CF(f @* H)) :\n  H <| G -> G \\subset D -> 'I_G[cfMorph phi] = G :&: f @*^-1 'I_(f @* G)[phi].\nProof.\ncase/andP=> sHG nHG sGD; have sHD := subset_trans sHG sGD.\napply/setP=> y; rewrite !in_setI; apply: andb_id2l => Gy.\nhave [Dy nHy] := (subsetP sGD y Gy, subsetP nHG y Gy).\nrewrite Dy inE nHy 4!inE mem_morphim // -morphimJ ?(normP nHy) // subxx /=.\nrewrite cfConjgMorph //; apply/eqP/eqP=> [Iphi_y | -> //].\nby apply/cfun_inP=> _ /morphimP[x Dx Hx ->]; rewrite -!cfMorphE ?Iphi_y.\nQed.",
    "Lemma inertia_morph_im (phi : 'CF(f @* H)) :\n  H <| G -> G \\subset D -> f @* 'I_G[cfMorph phi] = 'I_(f @* G)[phi].\nProof.\nmove=> nsHG sGD; rewrite inertia_morph_pre // morphim_setIpre.\nby rewrite (setIidPr _) ?Inertia_sub.\nQed.",
    "Lemma cfConjgIsom phi y :\n  y \\in G -> y \\in 'N(H) -> (cfIsom isoH phi ^ g y)%CF = cfIsom isoH (phi ^ y).\nProof.\nmove=> Gy nHy; have [_ defS] := isomP isoH.\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\napply/cfun_inP=> gx; rewrite -{1}defS => /morphimP[x Gx Hx ->] {gx}.\nrewrite cfConjgE; last by rewrite -defS inE -morphimJ ?(normP nHy).\nby rewrite -morphV -?morphJ -?eq_hg ?cfIsomE ?cfConjgE ?memJ_norm ?groupV.\nQed.",
    "Lemma inertia_isom phi : 'I_R[cfIsom isoH phi] = g @* 'I_G[phi].\nProof.\nhave [[_ defS] [injg <-]] := (isomP isoH, isomP isoG).\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\nrewrite /inertia !setIdE morphimIdom setIA -{1}defS -injm_norm ?injmI //.\napply/setP=> gy /[!inE]; apply: andb_id2l => /morphimP[y Gy nHy ->] {gy}.\nrewrite cfConjgIsom // -sub1set -morphim_set1 // injmSK ?sub1set //= inE.\napply/eqP/eqP=> [Iphi_y | -> //].\nby apply/cfun_inP=> x Hx; rewrite -!(cfIsomE isoH) ?Iphi_y.\nQed.",
    "Lemma cfConjgMod_norm H K (phi : 'CF(H / K)) y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ((phi %% K) ^ y)%CF = (phi ^ coset K y %% K)%CF.\nProof. exact: cfConjgMorph. Qed.",
    "Lemma cfConjgMod G H K (phi : 'CF(H / K)) y :\n    H <| G -> K <| G -> y \\in G ->\n  ((phi %% K) ^ y)%CF = (phi ^ coset K y %% K)%CF.\nProof.\nmove=> /andP[_ nHG] /andP[_ nKG] Gy.\nby rewrite cfConjgMod_norm ?(subsetP nHG) ?(subsetP nKG).\nQed.",
    "Lemma cfConjgQuo_norm H K (phi : 'CF(H)) y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ((phi / K) ^ coset K y)%CF = (phi ^ y / K)%CF.\nProof.\nmove=> nKy nHy; have keryK: (K \\subset cfker (phi ^ y)) = (K \\subset cfker phi).\n  by rewrite cfker_conjg // -{1}(normP nKy) conjSg.\nhave [kerK | not_kerK] := boolP (K \\subset cfker phi); last first.\n  by rewrite !cfQuoEout ?rmorph_alg ?cfConjg1 ?keryK.\napply/cfun_inP=> _ /morphimP[x nKx Hx ->].\nhave nHyb: coset K y \\in 'N(H / K) by rewrite inE -morphimJ ?(normP nHy).\nrewrite !(cfConjgE, cfQuoEnorm) ?keryK // ?in_setI ?Hx //.\nrewrite -morphV -?morphJ ?groupV // cfQuoEnorm //.\nby rewrite inE memJ_norm ?Hx ?groupJ ?groupV.\nQed.",
    "Lemma cfConjgQuo G H K (phi : 'CF(H)) y :\n    H <| G -> K <| G -> y \\in G ->\n  ((phi / K) ^ coset K y)%CF = (phi ^ y / K)%CF.\nProof.\nmove=> /andP[_ nHG] /andP[_ nKG] Gy.\nby rewrite cfConjgQuo_norm ?(subsetP nHG) ?(subsetP nKG).\nQed.",
    "Lemma inertia_mod_pre G H K (phi : 'CF(H / K)) :\n  H <| G -> K <| G -> 'I_G[phi %% K] = G :&: coset K @*^-1 'I_(G / K)[phi].\nProof. by move=> nsHG /andP[_]; apply: inertia_morph_pre. Qed.",
    "Lemma inertia_mod_quo G H K (phi : 'CF(H / K)) :\n  H <| G -> K <| G -> ('I_G[phi %% K] / K)%g = 'I_(G / K)[phi].\nProof. by move=> nsHG /andP[_]; apply: inertia_morph_im. Qed.",
    "Lemma inertia_quo G H K (phi : 'CF(H)) :\n    H <| G -> K <| G -> K \\subset cfker phi ->\n  'I_(G / K)[phi / K] = ('I_G[phi] / K)%g.\nProof.\nmove=> nsHG nsKG kerK; rewrite -inertia_mod_quo ?cfQuoK //.\nby rewrite (normalS _ (normal_sub nsHG)) // (subset_trans _ (cfker_sub phi)).\nQed.",
    "Lemma cfConjgSdprod phi y :\n    y \\in 'N(K) -> y \\in 'N(H) ->\n  (cfSdprod defG phi ^ y = cfSdprod defG (phi ^ y))%CF.\nProof.\nmove=> nKy nHy.\nhave nGy: y \\in 'N(G) by rewrite -sub1set -(sdprodW defG) normsM ?sub1set.\nrewrite -{2}[phi](cfSdprodK defG) cfConjgRes_norm // cfRes_sdprodK //.\nby rewrite cfker_conjg // -{1}(normP nKy) conjSg cfker_sdprod.\nQed.",
    "Lemma inertia_sdprod (L : {group gT}) phi :\n  L \\subset 'N(K) -> L \\subset 'N(H) -> 'I_L[cfSdprod defG phi] = 'I_L[phi].\nProof.\nmove=> nKL nHL; have nGL: L \\subset 'N(G) by rewrite -(sdprodW defG) normsM.\napply/setP=> z; rewrite !in_setI ![z \\in 'I[_]]inE; apply: andb_id2l => Lz.\nrewrite cfConjgSdprod ?(subsetP nKL) ?(subsetP nHL) ?(subsetP nGL) //=.\nby rewrite (can_eq (cfSdprodK defG)).\nQed.",
    "Lemma cfConjgDprodl phi y :\n    y \\in 'N(K) -> y \\in 'N(H) ->\n  (cfDprodl KxH phi ^ y = cfDprodl KxH (phi ^ y))%CF.\nProof. by move=> nKy nHy; apply: cfConjgSdprod. Qed.",
    "Lemma cfConjgDprodr psi y :\n    y \\in 'N(K) -> y \\in 'N(H) ->\n  (cfDprodr KxH psi ^ y = cfDprodr KxH (psi ^ y))%CF.\nProof. by move=> nKy nHy; apply: cfConjgSdprod. Qed.",
    "Lemma cfConjgDprod phi psi y :\n    y \\in 'N(K) -> y \\in 'N(H) ->\n  (cfDprod KxH phi psi ^ y = cfDprod KxH (phi ^ y) (psi ^ y))%CF.\nProof. by move=> nKy nHy; rewrite rmorphM /= cfConjgDprodl ?cfConjgDprodr. Qed.",
    "Lemma inertia_dprodl L phi :\n  L \\subset 'N(K) -> L \\subset 'N(H) -> 'I_L[cfDprodl KxH phi] = 'I_L[phi].\nProof. by move=> nKL nHL; apply: inertia_sdprod. Qed.",
    "Lemma inertia_dprodr L psi :\n  L \\subset 'N(K) -> L \\subset 'N(H) -> 'I_L[cfDprodr KxH psi] = 'I_L[psi].\nProof. by move=> nKL nHL; apply: inertia_sdprod. Qed.",
    "Lemma inertia_dprod L (phi : 'CF(K)) (psi : 'CF(H)) :\n    L \\subset 'N(K) -> L \\subset 'N(H) -> phi 1%g != 0 -> psi 1%g != 0 ->\n  'I_L[cfDprod KxH phi psi] = 'I_L[phi] :&: 'I_L[psi].\nProof.\nmove=> nKL nHL nz_phi nz_psi; apply/eqP; rewrite eqEsubset subsetI.\nrewrite -{1}(inertia_scale_nz psi nz_phi) -{1}(inertia_scale_nz phi nz_psi).\nrewrite -(cfDprod_Resl KxH) -(cfDprod_Resr KxH) !sub_inertia_Res //=.\nby rewrite -inertia_dprodl -?inertia_dprodr // -setIIr setIS ?inertia_mul.\nQed.",
    "Lemma inertia_dprod_irr L i j :\n    L \\subset 'N(K) -> L \\subset 'N(H) ->\n  'I_L[cfDprod KxH 'chi_i 'chi_j] = 'I_L['chi_i] :&: 'I_L['chi_j].\nProof. by move=> nKL nHL; rewrite inertia_dprod ?irr1_neq0. Qed.",
    "Lemma cfConjgBigdprodi i (phi : 'CF(A i)) :\n   (cfBigdprodi defG phi ^ y = cfBigdprodi defG (phi ^ y))%CF.\nProof.\nrewrite cfConjgDprodl; try by case: ifP => [/nAy// | _]; rewrite norm1 inE.\n  congr (cfDprodl _ _); case: ifP => [Pi | _].\n    by rewrite cfConjgRes_norm ?nAy.\n  by apply/cfun_inP=> _ /set1P->; rewrite !(cfRes1, cfConjg1).\nrewrite -sub1set norms_gen ?norms_bigcup // sub1set.\nby apply/bigcapP=> j /andP[/nAy].\nQed.",
    "Lemma cfConjgBigdprod phi :\n  (cfBigdprod defG phi ^ y = cfBigdprod defG (fun i => phi i ^ y))%CF.\nProof.\nby rewrite rmorph_prod /=; apply: eq_bigr => i _; apply: cfConjgBigdprodi.\nQed.",
    "Lemma inertia_bigdprodi i (phi : 'CF(A i)) :\n  P i -> 'I_L[cfBigdprodi defG phi] = 'I_L[phi].\nProof.\nmove=> Pi; rewrite inertia_dprodl ?Pi ?cfRes_id ?nAL //.\nby apply/norms_gen/norms_bigcup/bigcapsP=> j /andP[/nAL].\nQed.",
    "Lemma inertia_bigdprod phi (Phi := cfBigdprod defG phi) :\n  Phi 1%g != 0 -> 'I_L[Phi] = L :&: \\bigcap_(i | P i) 'I_L[phi i].\nProof.\nmove=> nz_Phi; apply/eqP; rewrite eqEsubset; apply/andP; split.\n  rewrite subsetI Inertia_sub; apply/bigcapsP=> i Pi.\n  have [] := cfBigdprodK nz_Phi Pi; move: (_ / _) => a nz_a <-.\n  by rewrite inertia_scale_nz ?sub_inertia_Res //= ?nAL.\nrewrite subsetI subsetIl; apply: subset_trans (inertia_prod _ _ _).\napply: setISS.\n  by rewrite -(bigdprodWY defG) norms_gen ?norms_bigcup //; apply/bigcapsP.\napply/bigcapsP=> i Pi; rewrite (bigcap_min i) //.\nby rewrite -inertia_bigdprodi ?subsetIr.\nQed.",
    "Lemma inertia_bigdprod_irr Iphi (phi := fun i => 'chi_(Iphi i)) :\n  'I_L[cfBigdprod defG phi] = L :&: \\bigcap_(i | P i) 'I_L[phi i].\nProof.\nrewrite inertia_bigdprod // -[cfBigdprod _ _]cfIirrE ?irr1_neq0 //.\nby apply: cfBigdprod_irr => i _; apply: mem_irr.\nQed.",
    "Lemma extendible_irr_invariant : G \\subset 'I[theta].\nProof.\napply/subsetP=> y Gy; have nNy := subsetP nNG y Gy.\nrewrite inE nNy; apply/eqP/cfun_inP=> x Nx; rewrite cfConjgE // -cNt.\nby rewrite !cfResE ?memJ_norm ?cfunJ ?groupV.\nQed.",
    "Lemma extend_to_cfdet G N s c0 u :\n    let theta := 'chi_s in let lambda := cfDet theta in let mu := 'chi_u in\n    N <| G -> coprime #|G : N| (Num.truncn (theta 1%g)) ->\n    'Res[N, G] 'chi_c0 = theta -> 'Res[N, G] mu = lambda ->\n  exists2 c, 'Res 'chi_c = theta /\\ cfDet 'chi_c = mu\n          & forall c1, 'Res 'chi_c1 = theta -> cfDet 'chi_c1 = mu -> c1 = c.\nProof.\nmove=> theta lambda mu nsNG; set e := #|G : N|; set f := Num.truncn _.\nset eta := 'chi_c0 => co_e_f etaNth muNlam; have [sNG nNG] := andP nsNG.\nhave fE: f%:R = theta 1%g by rewrite truncnK ?Cnat_irr1.\npose nu := cfDet eta; have lin_nu: nu \\is a linear_char := cfDet_lin_char _.\nhave nuNlam: 'Res nu = lambda by rewrite -cfDetRes ?irr_char ?etaNth.\nhave lin_lam: lambda \\is a linear_char := cfDet_lin_char _.\nhave lin_mu: mu \\is a linear_char.\n  by have:= lin_lam; rewrite -muNlam; apply: cfRes_lin_lin; apply: irr_char.\nhave [Unu Ulam] := (lin_char_unitr lin_nu, lin_char_unitr lin_lam).\npose alpha := mu / nu.\nhave alphaN_1: 'Res[N] alpha = 1 by rewrite rmorph_div //= muNlam nuNlam divrr.\nhave lin_alpha: alpha \\is a linear_char by apply: rpred_div.\nhave alpha_e: alpha ^+ e = 1.\n  have kerNalpha: N \\subset cfker alpha.\n    by rewrite -subsetIidl -cfker_Res ?lin_charW // alphaN_1 cfker_cfun1.\n  apply/eqP; rewrite -(cfQuoK nsNG kerNalpha) -rmorphXn cfMod_eq1 //.\n  rewrite -dvdn_cforder /e -card_quotient //.\n  by rewrite cforder_lin_char_dvdG ?cfQuo_lin_char.\nhave det_alphaXeta b: cfDet (alpha ^+ b * eta) = alpha ^+ (b * f) * nu.\n  by rewrite cfDet_mul_lin ?rpredX ?irr_char // -exprM -(cfRes1 N) etaNth.\nhave [b bf_mod_e]: exists b, b * f = 1 %[mod e].\n  rewrite -(chinese_modl co_e_f 1 0) /chinese !mul0n addn0 !mul1n mulnC.\n  by exists (egcdn f e).1.\nhave alpha_bf: alpha ^+ (b * f) = alpha.\n  by rewrite -(expr_mod _ alpha_e) bf_mod_e expr_mod.\nhave /irrP[c Dc]: alpha ^+ b * eta \\in irr G.\n  by rewrite mul_lin_irr ?rpredX ?mem_irr.\nhave chiN: 'Res 'chi_c = theta.\n  by rewrite -Dc rmorphM rmorphXn /= alphaN_1 expr1n mul1r.\nhave det_chi: cfDet 'chi_c = mu by rewrite -Dc det_alphaXeta alpha_bf divrK.\nexists c => // c2 c2Nth det_c2_mu; apply: irr_inj.\nhave [irrMc _ imMc _] := constt_Ind_ext nsNG chiN.\nhave /codomP[s2 Dc2]: c2 \\in codom (@mul_mod_Iirr G N c).\n  by rewrite -imMc constt_Ind_Res c2Nth constt_irr ?inE.\nhave{} Dc2: 'chi_c2 = ('chi_s2 %% N)%CF * 'chi_c.\n  by rewrite Dc2 cfIirrE // mod_IirrE.\nhave s2_lin: 'chi_s2 \\is a linear_char.\n  rewrite qualifE/= irr_char; apply/eqP/(mulIf (irr1_neq0 c)).\n  rewrite mul1r -[in RHS](cfRes1 N) chiN -c2Nth cfRes1.\n  by rewrite Dc2 cfunE cfMod1.\nhave s2Xf_1: 'chi_s2 ^+ f = 1.\n  apply/(can_inj (cfModK nsNG))/(mulIr (lin_char_unitr lin_mu))/esym.\n  rewrite rmorph1 rmorphXn /= mul1r -{1}det_c2_mu Dc2 -det_chi.\n  by rewrite cfDet_mul_lin ?cfMod_lin_char ?irr_char // -(cfRes1 N) chiN.\nsuffices /eqP s2_1: 'chi_s2 == 1 by rewrite Dc2 s2_1 rmorph1 mul1r.\nrewrite -['chi_s2]expr1 -dvdn_cforder -(eqnP co_e_f) dvdn_gcd.\nby rewrite /e -card_quotient ?cforder_lin_char_dvdG //= dvdn_cforder s2Xf_1.\nQed.",
    "Lemma group_num_field_exists (gT : finGroupType) (G : {group gT}) :\n  {Qn : splittingFieldType rat & galois 1 {:Qn} &\n    {QnC : {rmorphism Qn -> algC}\n         & forall nuQn : argumentType [in 'Gal({:Qn} / 1)],\n              {nu : {rmorphism algC -> algC} |\n                 {morph QnC: a / nuQn a >-> nu a}}\n         & {w : Qn & #|G|.-primitive_root w /\\ <<1; w>>%VS = fullv\n              & forall (hT : finGroupType) (H : {group hT}) (phi : 'CF(H)),\n                       phi \\is a character ->\n                       forall x, (#[x] %| #|G|)%N -> {a | QnC a = phi x}}}}.\nProof.\nhave [z prim_z] := C_prim_root_exists (cardG_gt0 G); set n := #|G| in prim_z *.\nhave [Qn [QnC [[|w []] // [Dz] genQn]]] := num_field_exists [:: z].\nhave prim_w: n.-primitive_root w by rewrite -Dz fmorph_primitive_root in prim_z.\nhave Q_Xn1: ('X^n - 1 : {poly Qn}) \\is a polyOver 1%AS.\n  by rewrite rpredB ?rpred1 ?rpredX //= polyOverX.\nhave splitXn1: splittingFieldFor 1 ('X^n - 1) {:Qn}.\n  pose r := codom (fun i : 'I_n => w ^+ i).\n  have Dr: 'X^n - 1 = \\prod_(y <- r) ('X - y%:P).\n    by rewrite -(factor_Xn_sub_1 prim_w) big_mkord big_image.\n  exists r; first by rewrite -Dr eqpxx.\n  apply/eqP; rewrite eqEsubv subvf -genQn adjoin_seqSr //; apply/allP=> /=.\n  by rewrite andbT -root_prod_XsubC -Dr; apply/unity_rootP/prim_expr_order.\nhave Qn_ax : FieldExt_isSplittingField _ Qn by constructor; exists ('X^n - 1).\nexists (HB.pack_for (splittingFieldType rat) Qn Qn_ax).\n  apply/splitting_galoisField.\n  exists ('X^n - 1); split => //.\n  apply: separable_Xn_sub_1; rewrite -(fmorph_eq0 QnC) rmorph_nat.\n  by rewrite pnatr_eq0 -lt0n cardG_gt0.\nexists QnC => [// nuQn|]; first exact: (extend_algC_subfield_aut QnC nuQn).\nrewrite span_seq1 in genQn.\nexists w => // hT H phi Nphi x x_dv_n.\napply: sig_eqW; have [rH ->] := char_reprP Nphi.\nhave [Hx | /cfun0->] := boolP (x \\in H); last by exists 0; rewrite rmorph0.\nhave [e [_ [enx1 _] [-> _] _]] := repr_rsim_diag rH Hx.\nhave /fin_all_exists[k Dk] i: exists k, e 0 i = z ^+ k.\n  have [|k ->] := (prim_rootP prim_z) (e 0 i); last by exists k.\n  by have /dvdnP[q ->] := x_dv_n; rewrite mulnC exprM enx1 expr1n.\nexists (\\sum_i w ^+ k i); rewrite rmorph_sum; apply/eq_bigr => i _.\nby rewrite rmorphXn /= Dz Dk.\nQed.",
    "Lemma gring_class_sum_central i : ('K_i \\in 'Z(group_ring F G))%MS.\nProof. by rewrite -classg_base_center (eq_row_sub i) // rowK. Qed.",
    "Lemma set_gring_classM_coef (i j k : 'I_#|classes G|) g :\n    g \\in enum_val k ->\n  a i j k = #|gring_classM_coef_set (enum_val i) (enum_val j) g|.\nProof.\nrewrite /a; have /repr_classesP[] := enum_valP k; move: (repr _) => g1 Gg1 ->.\nhave [/imsetP[zi Gzi ->] /imsetP[zj Gzj ->]] := (enum_valP i, enum_valP j).\nmove=> g1Gg; have Gg := subsetP (class_subG Gg1 (subxx _)) _ g1Gg.\nset Aij := gring_classM_coef_set _ _.\nwithout loss suffices IH: g g1 Gg Gg1 g1Gg / (#|Aij g1| <= #|Aij g|)%N.\n  by apply/eqP; rewrite eqn_leq !IH // class_sym.\nhave [w Gw Dg] := imsetP g1Gg; pose J2 (v : gT) xy := (xy.1 ^ v, xy.2 ^ v)%g.\nhave J2inj: injective (J2 w).\n  by apply: can_inj (J2 w^-1)%g _ => [[x y]]; rewrite /J2 /= !conjgK.\nrewrite -(card_imset _ J2inj) subset_leq_card //; apply/subsetP.\nmove=> _ /imsetP[[x y] /setIdP[/andP[/= x1Gx y1Gy] Dxy1] ->] /[!inE]/=.\nrewrite !(class_sym _ (_ ^ _)) !classGidl // class_sym x1Gx class_sym y1Gy.\nby rewrite -conjMg (eqP Dxy1) /= -Dg.\nQed.",
    "Lemma Aint_char (chi : 'CF(G)) x : chi \\is a character -> chi x \\in Aint.\nProof.\nhave [Gx /char_reprP[rG ->] {chi} | /cfun0->//] := boolP (x \\in G).\nhave [e [_ [unit_e _] [-> _] _]] := repr_rsim_diag rG Gx.\nrewrite rpred_sum // => i _; apply: (@Aint_unity_root #[x]) => //.\nexact/unity_rootP.\nQed.",
    "Lemma Aint_irr i x : 'chi[G]_i x \\in Aint.\nProof. exact/Aint_char/irr_char. Qed.",
    "Lemma mx_irr_gring_op_center_scalar n (rG : mx_representation algCfield G n) A :\n  mx_irreducible rG -> (A \\in 'Z(R_G))%MS -> is_scalar_mx (gring_op rG A).\nProof.\nmove/groupC=> irrG /center_mxP[R_A cGA].\napply: mx_abs_irr_cent_scalar irrG _ _; apply/centgmxP => x Gx.\nby rewrite -(gring_opG rG Gx) -!gring_opM ?cGA // envelop_mx_id.\nQed.",
    "Lemma cfRepr_gring_center n1 (rG : mx_representation algCfield G n1) A :\n  cfRepr rG = 'chi_i -> (A \\in 'Z(R_G))%MS -> gring_op rG A = 'omega_i[A]%:M.\nProof.\nmove=> def_rG Z_A; rewrite unlock xcfunZl -{2}def_rG xcfun_repr.\nhave irr_rG: mx_irreducible rG.\n  have sim_rG: mx_rsim 'Chi_i rG by apply: cfRepr_inj; rewrite irrRepr.\n  exact: mx_rsim_irr sim_rG (socle_irr _).\nhave /is_scalar_mxP[e ->] := mx_irr_gring_op_center_scalar irr_rG Z_A.\ncongr _%:M; apply: (canRL (mulKf (irr1_neq0 i))).\nby rewrite mulrC -def_rG cfunE repr_mx1 group1 -mxtraceZ scalemx1.\nQed.",
    "Lemma irr_gring_center A :\n  (A \\in 'Z(R_G))%MS -> gring_op 'Chi_i A = 'omega_i[A]%:M.\nProof. exact: cfRepr_gring_center (irrRepr i). Qed.",
    "Lemma gring_irr_modeM A B :\n    (A \\in 'Z(R_G))%MS -> (B \\in 'Z(R_G))%MS ->\n  'omega_i[A *m B] = 'omega_i[A] * 'omega_i[B].\nProof.\nmove=> Z_A Z_B; have [[R_A cRA] [R_B cRB]] := (center_mxP Z_A, center_mxP Z_B).\napply: mxZn_inj; rewrite scalar_mxM -!irr_gring_center ?gring_opM //.\napply/center_mxP; split=> [|C R_C]; first exact: envelop_mxM.\nby rewrite mulmxA cRA // -!mulmxA cRB.\nQed.",
    "Lemma gring_mode_class_sum_eq (k : 'I_#|classes G|) g :\n  g \\in enum_val k -> 'omega_i['K_k] = #|g ^: G|%:R * 'chi_i g / 'chi_i 1%g.\nProof.\nhave /imsetP[x Gx DxG] := enum_valP k; rewrite DxG => /imsetP[u Gu ->{g}].\nrewrite unlock classGidl ?cfunJ {u Gu}// mulrC mulr_natl.\nrewrite xcfunZl raddf_sum DxG -sumr_const /=; congr (_ * _).\nby apply: eq_bigr => _ /imsetP[u Gu ->]; rewrite xcfunG ?groupJ ?cfunJ.\nQed.",
    "Lemma Aint_gring_mode_class_sum k : 'omega_i['K_k] \\in Aint.\nProof.\nmove: k; pose X := [tuple 'omega_i['K_k] | k < #|classes G| ].\nhave memX k: 'omega_i['K_k] \\in X by apply: image_f.\nhave S_P := Cint_spanP X; set S := Cint_span X in S_P.\nhave S_X: {subset X <= S} by apply: mem_Cint_span.\nhave S_1: 1 \\in S.\n  apply: S_X; apply/codomP; exists (enum_rank_in (classes1 G) 1%g).\n  rewrite (@gring_mode_class_sum_eq _ 1%g) ?enum_rankK_in ?classes1 //.\n  by rewrite mulfK ?irr1_neq0 // class1G cards1.\nsuffices Smul: mulr_closed S.\n  by move=> k; apply: fin_Csubring_Aint S_P _ _; rewrite ?S_X.\nsplit=> // _ _ /S_P[x ->] /S_P[y ->].\nrewrite mulr_sumr rpred_sum // => j _.\nrewrite mulrzAr mulr_suml rpredMz ?rpred_sum // => k _.\nrewrite mulrzAl rpredMz {x y}// !nth_mktuple.\nrewrite -gring_irr_modeM ?gring_class_sum_central //.\nrewrite gring_classM_expansion raddf_sum rpred_sum // => jk _.\nby rewrite scaler_nat raddfMn rpredMn ?S_X ?memX.\nQed.",
    "Lemma gring_classM_coef_sum_eq gT (G : {group gT}) j1 j2 k g1 g2 g :\n   let a := @gring_classM_coef gT G j1 j2 in let a_k := a k in\n   g1 \\in enum_val j1 -> g2 \\in enum_val j2 -> g \\in enum_val k ->\n   let sum12g := \\sum_i 'chi[G]_i g1 * 'chi_i g2 * ('chi_i g)^* / 'chi_i 1%g in\n  a_k%:R = (#|enum_val j1| * #|enum_val j2|)%:R / #|G|%:R * sum12g.\nProof.\nmove=> a /= Kg1 Kg2 Kg; rewrite mulrAC; apply: canRL (mulfK (neq0CG G)) _.\ntransitivity (\\sum_j (#|G| * a j)%:R *+ (j == k) : algC).\n  by rewrite (bigD1 k) //= eqxx -natrM mulnC big1 ?addr0 // => j /negPf->.\nhave defK (j : 'I_#|classes G|) x: x \\in enum_val j -> enum_val j = x ^: G.\n  by have /imsetP[y Gy ->] := enum_valP j => /class_eqP.\nhave Gg: g \\in G.\n  by case/imsetP: (enum_valP k) Kg => x Gx -> /imsetP[y Gy ->]; apply: groupJ.\ntransitivity (\\sum_j \\sum_i 'omega_i['K_j] * 'chi_i 1%g * ('chi_i g)^* *+ a j).\n  apply: eq_bigr => j _; have /imsetP[z Gz Dj] := enum_valP j.\n  have Kz: z \\in enum_val j by rewrite Dj class_refl.\n  rewrite -(Lagrange (subsetIl G 'C[z])) index_cent1 -mulnA natrM -mulrnAl.\n  have ->: (j == k) = (z \\in enum_val k).\n    by rewrite -(inj_eq enum_val_inj); apply/eqP/idP=> [<-|/defK->].\n  rewrite (defK _ g) // -second_orthogonality_relation // mulr_suml.\n  apply: eq_bigr=> i _; rewrite natrM mulrA mulr_natr mulrC mulrA.\n  by rewrite (gring_mode_class_sum_eq i Kz) divfK ?irr1_neq0.\nrewrite exchange_big /= mulr_sumr; apply: eq_bigr => i _.\ntransitivity ('omega_i['K_j1 *m 'K_j2] * 'chi_i 1%g * ('chi_i g)^*).\n  rewrite gring_classM_expansion -/a raddf_sum !mulr_suml /=.\n  by apply: eq_bigr => j _; rewrite xcfunZr -!mulrA mulr_natl.\nrewrite !mulrA 2![_ / _]mulrAC (defK _ _ Kg1) (defK _ _ Kg2); congr (_ * _).\nrewrite gring_irr_modeM ?gring_class_sum_central // mulnC natrM.\nrewrite (gring_mode_class_sum_eq i Kg2) !mulrA divfK ?irr1_neq0 //.\nby congr (_ * _); rewrite [_ * _]mulrC (gring_mode_class_sum_eq i Kg1) !mulrA.\nQed.",
    "Lemma index_support_dvd_degree gT (G H : {group gT}) chi :\n    H \\subset G -> chi \\is a character -> chi \\in 'CF(G, H) ->\n    (H :==: 1%g) || abelian G ->\n  (#|G : H| %| chi 1%g)%C.\nProof.\nmove=> sHG Nchi Hchi ZHG.\nsuffices: (#|G : H| %| 'Res[H] chi 1%g)%C by rewrite cfResE ?group1.\nrewrite ['Res _]cfun_sum_cfdot sum_cfunE rpred_sum // => i _.\nrewrite cfunE dvdC_mulr ?intr_nat ?Cnat_irr1 //.\nhave [j ->]: exists j, 'chi_i = 'Res 'chi[G]_j.\n  case/predU1P: ZHG => [-> | cGG] in i *.\n    suffices ->: i = 0 by exists 0; rewrite !irr0 cfRes_cfun1 ?sub1G.\n    apply/val_inj; case: i => [[|i] //=]; rewrite ltnNge NirrE.\n    by rewrite (@leq_trans 1) // leqNgt classes_gt1 eqxx.\n  have linG := char_abelianP G cGG; have linG1 j := eqP (proj2 (andP (linG j))).\n  have /fin_all_exists[rH DrH] j: exists k, 'Res[H, G] 'chi_j = 'chi_k.\n    apply/irrP/lin_char_irr/andP.\n    by rewrite cfRes_char ?irr_char // cfRes1 ?linG1.\n  suffices{i} all_rH: codom rH =i Iirr H.\n    by exists (iinv (all_rH i)); rewrite DrH f_iinv.\n  apply/subset_cardP; last exact/subsetP; apply/esym/eqP.\n  rewrite card_Iirr_abelian ?(abelianS sHG) //.\n  rewrite -(eqn_pmul2r (indexg_gt0 G H)) Lagrange //; apply/eqP.\n  rewrite -sum_nat_const -card_Iirr_abelian // -sum1_card.\n  rewrite (partition_big rH [in codom rH]) /=; last exact: image_f.\n  have nsHG: H <| G by rewrite -sub_abelian_normal.\n  apply: eq_bigr => _ /codomP[i ->]; rewrite -card_quotient ?normal_norm //.\n  rewrite -card_Iirr_abelian ?quotient_abelian //.\n  have Mlin j1 j2: exists k, 'chi_j1 * 'chi_j2 = 'chi[G]_k.\n    exact/irrP/lin_char_irr/rpredM.\n  have /fin_all_exists[rQ DrQ] (j : Iirr (G / H)) := Mlin i (mod_Iirr j).\n  have mulJi: ('chi[G]_i)^*%CF * 'chi_i = 1.\n    apply/cfun_inP=> x Gx; rewrite !cfunE /= -lin_charV_conj ?linG // cfun1E Gx.\n    by rewrite lin_charV ?mulVf ?lin_char_neq0 ?linG.\n  have inj_rQ: injective rQ.\n    move=> j1 j2 /(congr1 (fun k => (('chi_i)^*%CF * 'chi_k) / H)%CF).\n    by rewrite -!DrQ !mulrA mulJi !mul1r !mod_IirrE ?cfModK // => /irr_inj.\n  rewrite -(card_imset _ inj_rQ) -sum1_card; apply: eq_bigl => j.\n  rewrite -(inj_eq irr_inj) -!DrH; apply/eqP/imsetP=> [eq_ij | [k _ ->]].\n    have [k Dk] := Mlin (conjC_Iirr i) j; exists (quo_Iirr H k) => //.\n    apply/irr_inj; rewrite -DrQ quo_IirrK //.\n      by rewrite -Dk conjC_IirrE mulrCA mulrA mulJi mul1r.\n    apply/subsetP=> x Hx; have Gx := subsetP sHG x Hx.\n    rewrite cfkerEirr inE linG1 -Dk conjC_IirrE; apply/eqP.\n    transitivity ((1 : 'CF(G)) x); last by rewrite cfun1E Gx.\n    by rewrite -mulJi !cfunE -!(cfResE _ sHG Hx) eq_ij.\n  rewrite -DrQ; apply/cfun_inP=> x Hx; rewrite !cfResE // cfunE mulrC.\n  by rewrite cfker1 ?linG1 ?mul1r ?(subsetP _ x Hx) // mod_IirrE ?cfker_mod.\nhave: (#|G : H| %| #|G : H|%:R * '[chi, 'chi_j])%C.\n  by rewrite dvdC_mulr ?intr_nat ?Cnat_cfdot_char_irr.\ncongr (_ %| _)%C; rewrite (cfdotEl _ Hchi) -(Lagrange sHG) mulnC natrM.\nrewrite invfM -mulrA mulVKf ?neq0CiG //; congr (_ * _).\nby apply: eq_bigr => x Hx; rewrite !cfResE.\nQed.",
    "Lemma sum_norm2_char_generators gT (G : {group gT}) (chi : 'CF(G)) :\n    let S := [pred s | generator G s] in\n    chi \\is a character -> {in S, forall s, chi s != 0} ->\n  \\sum_(s in S) `|chi s| ^+ 2 >= #|S|%:R.\nProof.\nmove=> S Nchi nz_chi_S; pose n := #|G|.\nhave [g Sg | S_0] := pickP (generator G); last first.\n  by rewrite eq_card0 // big_pred0 ?lerr.\nhave defG: <[g]> = G by apply/esym/eqP.\nhave [cycG Gg]: cyclic G /\\ g \\in G by rewrite -defG cycle_cyclic cycle_id.\npose I := {k : 'I_n | coprime n k}; pose ItoS (k : I) := (g ^+ sval k)%g.\nhave imItoS: codom ItoS =i S.\n  move=> s; rewrite inE /= /ItoS /I /n /S -defG -orderE.\n  apply/codomP/idP=> [[[i cogi] ->] | Ss]; first by rewrite generator_coprime.\n  have [m ltmg Ds] := cyclePmin (cycle_generator Ss).\n  by rewrite Ds generator_coprime in Ss; apply: ex_intro (Sub (Sub m _) _) _.\nhave /injectiveP injItoS: injective ItoS.\n  move=> k1 k2 /eqP; apply: contraTeq.\n  by rewrite eq_expg_mod_order orderE defG -/n !modn_small.\nhave [Qn galQn [QnC gQnC [eps [pr_eps defQn] QnG]]] := group_num_field_exists G.\nhave{QnG} QnGg := QnG _ G _ _ g (order_dvdG Gg).\npose calG := 'Gal({:Qn} / 1).\nhave /fin_all_exists2[ItoQ inItoQ defItoQ] (k : I):\n  exists2 nu, nu \\in calG & nu eps = eps ^+ val k.\n- case: k => [[m _] /=]; rewrite coprime_sym => /Qn_aut_exists[nuC DnuC].\n  have [nuQ DnuQ] := restrict_aut_to_normal_num_field QnC nuC.\n  have hom_nu: kHom 1 {:Qn} (linfun nuQ).\n    rewrite k1HomE; apply/ahom_inP.\n    by split=> [u v | ]; rewrite !lfunE ?rmorphM ?rmorph1.\n  have [|nu cGnu Dnu] := kHom_to_gal _ (normalFieldf 1) hom_nu.\n    by rewrite !subvf.\n  exists nu => //; apply: (fmorph_inj QnC).\n  rewrite -Dnu ?memvf // lfunE DnuQ rmorphXn DnuC //.\n  by rewrite prim_expr_order // fmorph_primitive_root.\nhave{defQn} imItoQ: calG = ItoQ @: {:I}.\n  apply/setP=> nu; apply/idP/imsetP=> [cGnu | [k _ ->] //].\n  have pr_nu_e: n.-primitive_root (nu eps) by rewrite fmorph_primitive_root.\n  have [i Dnue] := prim_rootP pr_eps (prim_expr_order pr_nu_e).\n  rewrite Dnue prim_root_exp_coprime // coprime_sym in pr_nu_e.\n  apply: ex_intro2 (Sub i _) _ _ => //; apply/eqP.\n  rewrite /calG /= -defQn in ItoQ inItoQ defItoQ nu cGnu Dnue *.\n  by rewrite gal_adjoin_eq // defItoQ -Dnue.\nhave injItoQ: {in {:I} &, injective ItoQ}.\n  move=> k1 k2 _ _ /(congr1 (fun nu : gal_of _ => nu eps))/eqP.\n  by apply: contraTeq; rewrite !defItoQ (eq_prim_root_expr pr_eps) !modn_small.\npose pi1 := \\prod_(s in S) chi s; pose pi2 := \\prod_(s in S) `|chi s| ^+ 2.\nhave Qpi1: pi1 \\in Crat.\n  have [a Da] := QnGg _ Nchi; suffices ->: pi1 = QnC (galNorm 1 {:Qn} a).\n    have /vlineP[q ->] := mem_galNorm galQn (memvf a).\n    by rewrite rmorphZ_num rmorph1 mulr1 Crat_rat.\n  rewrite /galNorm rmorph_prod -/calG imItoQ big_imset //=.\n  rewrite /pi1 -(eq_bigl _ _ imItoS) -big_uniq // big_image /=.\n  apply: eq_bigr => k _; have [nuC DnuC] := gQnC (ItoQ k); rewrite DnuC Da.\n  have [r ->] := char_sum_irr Nchi; rewrite !sum_cfunE rmorph_sum.\n  apply: eq_bigr => i _; have /QnGg[b Db] := irr_char i.\n  have Lchi_i: 'chi_i \\is a linear_char by rewrite irr_cyclic_lin.\n  have /(prim_rootP pr_eps)[m Dem]: b ^+ n = 1.\n    apply/eqP; rewrite -(fmorph_eq1 QnC) rmorphXn /= Db -lin_charX //.\n    by rewrite -expg_mod_order orderE defG modnn lin_char1.\n  rewrite -Db /= -DnuC Dem rmorphXn /= defItoQ exprAC -{m}Dem rmorphXn /= {b}Db.\n  by rewrite lin_charX.\nclear I ItoS imItoS injItoS ItoQ inItoQ defItoQ imItoQ injItoQ.\nclear Qn galQn QnC gQnC eps pr_eps QnGg calG.\nhave{Qpi1} Zpi1: pi1 \\in Num.int.\n  by rewrite Cint_rat_Aint // rpred_prod // => s _; apply: Aint_char.\nhave{pi1 Zpi1} pi2_ge1: 1 <= pi2.\n  have ->: pi2 = `|pi1| ^+ 2.\n    by rewrite (big_morph Num.norm (@normrM _) (@normr1 _)) -prodrXl.\n  by rewrite intr_normK // sqr_intr_ge1 //; apply/prodf_neq0.\nhave Sgt0: (#|S| > 0)%N by rewrite (cardD1 g) [g \\in S]Sg.\nrewrite -mulr_natr -ler_pdivlMr ?ltr0n //.\nhave n2chi_ge0 s: s \\in S -> 0 <= `|chi s| ^+ 2 by rewrite exprn_ge0.\nrewrite -(expr_ge1 Sgt0); last by rewrite divr_ge0 ?ler0n ?sumr_ge0.\nby rewrite (le_trans pi2_ge1) // leif_AGM.\nQed.",
    "Lemma repr_mx1 : rG 1 = 1%:M.\nProof. by case: rG => r []. Qed.",
    "Lemma repr_mxM : {in G &, {morph rG : x y / (x * y)%g >-> x *m y}}.\nProof. by case: rG => r []. Qed.",
    "Lemma repr_mxK m x :\n  x \\in G ->  cancel ((@mulmx R m n n)^~ (rG x)) (mulmx^~ (rG x^-1)).\nProof.\nby move=> Gx U; rewrite -mulmxA -repr_mxM ?groupV // mulgV repr_mx1 mulmx1.\nQed.",
    "Lemma repr_mxKV m x :\n  x \\in G -> cancel ((@mulmx R m n n)^~ (rG x^-1)) (mulmx^~ (rG x)).\nProof. by rewrite -groupV -{3}[x]invgK; apply: repr_mxK. Qed.",
    "Lemma repr_mx_unit x : x \\in G -> rG x \\in unitmx.\nProof. by move=> Gx; case/mulmx1_unit: (repr_mxKV Gx 1%:M). Qed.",
    "Lemma repr_mxV : {in G, {morph rG : x / x^-1%g >-> invmx x}}.\nProof.\nby move=> x Gx /=; rewrite -[rG x^-1](mulKmx (repr_mx_unit Gx)) mulmxA repr_mxK.\nQed.",
    "Lemma rstab_sub : rstab \\subset G.\nProof. by apply/subsetP=> x; case/setIdP. Qed.",
    "Lemma rstab_group_set : group_set rstab.\nProof.\napply/group_setP; rewrite inE group1 repr_mx1 mulmx1; split=> //= x y.\ncase/setIdP=> Gx cUx; case/setIdP=> Gy cUy; rewrite inE repr_mxM ?groupM //.\nby rewrite mulmxA (eqP cUx).\nQed.",
    "Lemma rcent_sub : rcent \\subset G.\nProof. by apply/subsetP=> x; case/setIdP. Qed.",
    "Lemma rcent_group_set : group_set rcent.\nProof.\napply/group_setP; rewrite inE group1 repr_mx1 mulmx1 mul1mx; split=> //= x y.\ncase/setIdP=> Gx; move/eqP=> cfx; case/setIdP=> Gy; move/eqP=> cfy.\nby rewrite inE repr_mxM ?groupM //= -mulmxA -cfy !mulmxA cfx.\nQed.",
    "Lemma centgmxP : reflect (forall x, x \\in G -> f *m rG x = rG x *m f) centgmx.\nProof.\nby apply: (iffP subsetP) => cGf x Gx; have /[!(inE, Gx)] /eqP := cGf x Gx.\nQed.",
    "Lemma rkerP x : reflect (x \\in G /\\ rG x = 1%:M) (x \\in rker).\nProof. by apply: (iffP setIdP) => [] [->]; move/eqP; rewrite mul1mx. Qed.",
    "Lemma rker_norm : G \\subset 'N(rker).\nProof.\napply/subsetP=> x Gx; rewrite inE sub_conjg; apply/subsetP=> y.\ncase/rkerP=> Gy ry1; rewrite mem_conjgV !inE groupJ //=.\nby rewrite !repr_mxM ?groupM ?groupV // ry1 !mulmxA mulmx1 repr_mxKV.\nQed.",
    "Lemma rker_normal : rker <| G.\nProof. by rewrite /normal rstab_sub rker_norm. Qed.",
    "Lemma mx_faithful_inj : mx_faithful -> {in G &, injective rG}.\nProof.\nmove=> ffulG x y Gx Gy eq_rGxy; apply/eqP; rewrite eq_mulgV1 -in_set1.\nrewrite (subsetP ffulG) // inE groupM ?repr_mxM ?groupV //= eq_rGxy.\nby rewrite mulmxA repr_mxK.\nQed.",
    "Lemma rker_linear : n = 1 -> G^`(1)%g \\subset rker.\nProof.\nmove=> n1; rewrite gen_subG; apply/subsetP=> xy; case/imset2P=> x y Gx Gy ->.\nrewrite !inE groupR //= /commg mulgA -invMg repr_mxM ?groupV ?groupM //.\nrewrite mulmxA (can2_eq (repr_mxK _) (repr_mxKV _)) ?groupM //.\nrewrite !repr_mxV ?repr_mxM ?groupM //; move: (rG x) (rG y).\nby rewrite n1 => rx ry; rewrite (mx11_scalar rx) scalar_mxC.\nQed.",
    "Lemma rcenter_normal : rcenter <| G.\nProof.\nrewrite /normal /rcenter {1}setIdE subsetIl; apply/subsetP=> x Gx /[1!inE].\napply/subsetP=> _ /imsetP[y /setIdP[Gy /is_scalar_mxP[c rGy]] ->].\nrewrite inE !repr_mxM ?groupM ?groupV //= mulmxA rGy scalar_mxC repr_mxKV //.\nexact: scalar_mx_is_scalar.\nQed.",
    "Lemma repr_mxMr : {in G &, {morph rG : x y / (x * y)%g >-> x * y}}.\nProof. exact: repr_mxM. Qed.",
    "Lemma repr_mxVr : {in G, {morph rG : x / (x^-1)%g >-> x^-1}}.\nProof. exact: repr_mxV. Qed.",
    "Lemma repr_mx_unitr x : x \\in G -> rG x \\is a GRing.unit.\nProof. exact: repr_mx_unit. Qed.",
    "Lemma repr_mxX m : {in G, {morph rG : x / (x ^+ m)%g >-> x ^+ m}}.\nProof.\nelim: m => [|m IHm] x Gx; rewrite /= ?repr_mx1 // expgS exprS -IHm //.\nby rewrite repr_mxM ?groupX.\nQed.",
    "Lemma subg_mx_repr : mx_repr H rG.\nProof.\nby split=> [|x y Hx Hy]; rewrite (repr_mx1, repr_mxM) ?(subsetP sHG).\nQed.",
    "Lemma rcent_subg U : rcent rH U = H :&: rcent rG U.\nProof. by apply/setP=> x; rewrite !inE andbA -in_setI (setIidPl sHG). Qed.",
    "Lemma rstab_subg : rstab rH U = H :&: rstab rG U.\nProof. by apply/setP=> x; rewrite !inE andbA -in_setI (setIidPl sHG). Qed.",
    "Lemma rker_subg : rker rH = H :&: rker rG. Proof. exact: rstab_subg. Qed.",
    "Lemma subg_mx_faithful : mx_faithful rG -> mx_faithful rH.\nProof. by apply: subset_trans; rewrite rker_subg subsetIr. Qed.",
    "Lemma eqg_repr_proof : H \\subset G. Proof. by rewrite (eqP eqGH). Qed.",
    "Lemma rcent_eqg U : rcent rH U = rcent rG U.\nProof. by rewrite rcent_subg -(eqP eqGH) (setIidPr _) ?rcent_sub. Qed.",
    "Lemma rstab_eqg : rstab rH U = rstab rG U.\nProof. by rewrite rstab_subg -(eqP eqGH) (setIidPr _) ?rstab_sub. Qed.",
    "Lemma rker_eqg : rker rH = rker rG. Proof. exact: rstab_eqg. Qed.",
    "Lemma eqg_mx_faithful : mx_faithful rH = mx_faithful rG.\nProof. by rewrite /mx_faithful rker_eqg. Qed.",
    "Lemma morphpre_mx_repr : mx_repr (f @*^-1 G) (rG \\o f).\nProof.\nsplit=> [|x y]; first by rewrite /= morph1 repr_mx1.\ncase/morphpreP=> Dx Gfx; case/morphpreP=> Dy Gfy.\nby rewrite /= morphM ?repr_mxM.\nQed.",
    "Lemma rstab_morphpre : rstab rGf U = f @*^-1 (rstab rG U).\nProof. by apply/setP=> x; rewrite !inE andbA. Qed.",
    "Lemma rker_morphpre : rker rGf = f @*^-1 (rker rG).\nProof. exact: rstab_morphpre. Qed.",
    "Lemma morphim_mxE x : morphim_mx sGD x = rGf (f x). Proof. by []. Qed.",
    "Lemma morphim_mx_repr : mx_repr G (morphim_mx sGD).\nProof. exact: subg_mx_repr (morphpre_repr f rGf) sG_f'fG. Qed.",
    "Lemma rstab_morphim : rstab rG U = G :&: f @*^-1 rstab rGf U.\nProof. by rewrite -rstab_morphpre -(rstab_subg _ sG_f'fG). Qed.",
    "Lemma rker_morphim : rker rG = G :&: f @*^-1 (rker rGf).\nProof. exact: rstab_morphim. Qed.",
    "Lemma rconj_mx_repr : mx_repr G (rconj_mx uB).\nProof.\nsplit=> [|x y Gx Gy]; rewrite /rconj_mx ?repr_mx1 ?mulmx1 ?mulmxV ?repr_mxM //.\nby rewrite !mulmxA mulmxKV.\nQed.",
    "Lemma rconj_mxE x : rGB x = B *m rG x *m invmx B.\nProof. by []. Qed.",
    "Lemma rconj_mxJ m (W : 'M_(m, n)) x : W *m rGB x *m B = W *m B *m rG x.\nProof. by rewrite !mulmxA mulmxKV. Qed.",
    "Lemma rcent_conj A : rcent rGB A = rcent rG (invmx B *m A *m B).\nProof.\napply/setP=> x; rewrite !inE /= rconj_mxE !mulmxA.\nrewrite (can2_eq (mulmxKV uB) (mulmxK uB)) -!mulmxA.\nby rewrite -(can2_eq (mulKVmx uB) (mulKmx uB)).\nQed.",
    "Lemma rstab_conj m (U : 'M_(m, n)) : rstab rGB U = rstab rG (U *m B).\nProof.\napply/setP=> x; rewrite !inE /= rconj_mxE !mulmxA.\nby rewrite (can2_eq (mulmxKV uB) (mulmxK uB)).\nQed.",
    "Lemma rker_conj : rker rGB = rker rG.\nProof.\napply/setP=> x; rewrite !inE /= mulmxA (can2_eq (mulmxKV uB) (mulmxK uB)).\nby rewrite mul1mx -scalar_mxC (inj_eq (can_inj (mulKmx uB))) mul1mx.\nQed.",
    "Lemma conj_mx_faithful : mx_faithful rGB = mx_faithful rG.\nProof. by rewrite /mx_faithful rker_conj. Qed.",
    "Lemma quo_mx_coset x : x \\in G -> quo_mx krH nHG (coset H x) = rG x.\nProof.\nmove=> Gx; rewrite /quo_mx val_coset ?nHGs //; case: repr_rcosetP => z Hz.\nby case/rkerP: (subsetP krH z Hz) => Gz rz1; rewrite repr_mxM // rz1 mul1mx.\nQed.",
    "Lemma quo_mx_repr : mx_repr (G / H)%g (quo_mx krH nHG).\nProof.\nsplit=> [|Hx Hy]; first by rewrite /quo_mx repr_coset1 repr_mx1.\ncase/morphimP=> x Nx Gx ->{Hx}; case/morphimP=> y Ny Gy ->{Hy}.\nby rewrite -morphM // !quo_mx_coset ?groupM ?repr_mxM.\nQed.",
    "Lemma quo_repr_coset x : x \\in G -> rGH (coset H x) = rG x.\nProof. exact: quo_mx_coset. Qed.",
    "Lemma rcent_quo A : rcent rGH A = (rcent rG A / H)%g.\nProof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|]; case/morphimP=> x Nx Gx ->{Hx}.\n  by rewrite quo_repr_coset // => cAx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx cAx; rewrite quo_repr_coset ?mem_morphim.\nQed.",
    "Lemma rstab_quo m (U : 'M_(m, n)) : rstab rGH U = (rstab rG U / H)%g.\nProof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|]; case/morphimP=> x Nx Gx ->{Hx}.\n  by rewrite quo_repr_coset // => nUx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx nUx; rewrite quo_repr_coset ?mem_morphim.\nQed.",
    "Lemma rker_quo : rker rGH = (rker rG / H)%g.\nProof. exact: rstab_quo. Qed.",
    "Lemma kquo_mxE : kquo_mx = quo_mx (subxx (rker rG)) (rker_norm rG).\nProof. by []. Qed.",
    "Lemma kquo_repr_coset x :\n  x \\in G -> kquo_repr (coset (rker rG) x) = rG x.\nProof. exact: quo_repr_coset. Qed.",
    "Lemma kquo_mx_faithful : mx_faithful kquo_repr.\nProof. by rewrite /mx_faithful rker_quo trivg_quotient. Qed.",
    "Lemma gring_valK : cancel enum_val gring_index.\nProof. exact: enum_valK_in. Qed.",
    "Lemma gring_indexK : {in G, cancel gring_index enum_val}.\nProof. exact: enum_rankK_in. Qed.",
    "Lemma regular_mx_repr : mx_repr G regular_mx.\nProof.\nsplit=> [|x y Gx Gy]; apply/row_matrixP=> i; rewrite !rowK.\n  by rewrite mulg1 row1 gring_valK.\nby rewrite row_mul rowK -rowE rowK mulgA gring_indexK // groupM ?enum_valP.\nQed.",
    "Lemma gring_row_mul A B : gring_row (A *m B) = gring_row A *m B.\nProof. exact: row_mul. Qed.",
    "Lemma gring_projE : {in G &, forall x y, gring_proj x (aG y) = (x == y)%:R}.\nProof.\nmove=> x y Gx Gy; rewrite /gring_proj /= /gring_row rowK gring_indexK //=.\nrewrite mul1g trmx_delta rowE mul_delta_mx_cond [delta_mx 0 0]mx11_scalar !mxE.\nby rewrite /= -(inj_eq (can_inj gring_valK)) !gring_indexK.\nQed.",
    "Lemma regular_mx_faithful : mx_faithful aG.\nProof.\napply/subsetP=> x /setIdP[Gx].\nrewrite mul1mx inE => /eqP/(congr1 (gring_proj 1%g)).\nrewrite -(repr_mx1 aG) !gring_projE ?group1 // eqxx eq_sym.\nby case: (x == _) => // /eqP; rewrite eq_sym oner_eq0.\nQed.",
    "Lemma gring_mxJ a x :\n  x \\in G -> gring_mx (a *m aG x) = gring_mx a *m rG x.\nProof.\nmove=> Gx; rewrite /gring_mx /= ![a *m _]mulmx_sum_row.\nrewrite !(mulmx_suml, linear_sum); apply: eq_bigr => i _.\nrewrite linearZ -!scalemxAl linearZ /=; congr (_ *: _) => {a}.\nrewrite !rowK /= !mxvecK -rowE rowK mxvecK.\nby rewrite gring_indexK ?groupM ?repr_mxM ?enum_valP.\nQed.",
    "Lemma gring_mxK : cancel (gring_mx aG) gring_row.\nProof.\nmove=> a; rewrite /gring_mx /= mulmx_sum_row !linear_sum /= [RHS]row_sum_delta.\napply: eq_bigr => i _; rewrite 2!linearZ /= /gring_row !(rowK, mxvecK).\nby rewrite gring_indexK // mul1g gring_valK.\nQed.",
    "Lemma gring_opE a : gring_op a = gring_mx rG (gring_row a).\nProof. by []. Qed.",
    "Lemma gring_opG x : x \\in G -> gring_op (aG x) = rG x.\nProof.\nmove=> Gx; rewrite gring_opE /gring_row rowK gring_indexK // mul1g.\nby rewrite /gring_mx /= -rowE rowK mxvecK gring_indexK.\nQed.",
    "Lemma gring_op1 : gring_op 1%:M = 1%:M.\nProof. by rewrite -(repr_mx1 aG) gring_opG ?repr_mx1. Qed.",
    "Lemma gring_opJ A b :\n  gring_op (A *m gring_mx aG b) = gring_op A *m gring_mx rG b.\nProof.\nrewrite /gring_mx /= ![b *m _]mulmx_sum_row !linear_sum.\napply: eq_bigr => i _; rewrite !linearZ /= !rowK !mxvecK.\nby rewrite gring_opE gring_row_mul gring_mxJ ?enum_valP.\nQed.",
    "Lemma gring_op_mx b : gring_op (gring_mx aG b) = gring_mx rG b.\nProof. by rewrite -[_ b]mul1mx gring_opJ gring_op1 mul1mx. Qed.",
    "Lemma gring_mxA a b :\n  gring_mx rG (a *m gring_mx aG b) = gring_mx rG a *m gring_mx rG b.\nProof.\nby rewrite -(gring_op_mx a) -gring_opJ gring_opE gring_row_mul gring_mxK.\nQed.",
    "Lemma map_regular_mx x : (regular_mx aR G x)^f = regular_mx rR G x.\nProof. by apply/matrixP=> i j; rewrite !mxE rmorph_nat. Qed.",
    "Lemma map_gring_row (A : 'M_#|G|) : (gring_row A)^f = gring_row A^f.\nProof. by rewrite map_row. Qed.",
    "Lemma map_gring_proj x (A : 'M_#|G|) : (gring_proj x A)^f = gring_proj x A^f.\nProof. by rewrite map_row -map_trmx map_gring_row. Qed.",
    "Lemma map_mx_repr : mx_repr G (map_repr_mx f rG).\nProof.\nsplit=> [|x y Gx Gy]; first by rewrite /map_repr_mx repr_mx1 map_mx1.\nby rewrite -map_mxM -repr_mxM.\nQed.",
    "Lemma map_reprE x : rGf x = (rG x)^f. Proof. by []. Qed.",
    "Lemma map_reprJ m (A : 'M_(m, n)) x : (A *m rG x)^f = A^f *m rGf x.\nProof. exact: map_mxM. Qed.",
    "Lemma map_enveloping_algebra_mx :\n  (enveloping_algebra_mx rG)^f = enveloping_algebra_mx rGf.\nProof. by apply/row_matrixP=> i; rewrite -map_row !rowK map_mxvec. Qed.",
    "Lemma map_gring_mx a : (gring_mx rG a)^f = gring_mx rGf a^f.\nProof. by rewrite map_vec_mx map_mxM map_enveloping_algebra_mx. Qed.",
    "Lemma map_gring_op A : (gring_op rG A)^f = gring_op rGf A^f.\nProof. by rewrite map_gring_mx map_gring_row. Qed.",
    "Lemma map_regular_repr : map_repr (regular_repr aR G) =1 regular_repr rR G.\nProof. exact: map_regular_mx. Qed.",
    "Lemma map_group_ring : (group_ring aR G)^f = group_ring rR G.\nProof.\nrewrite map_enveloping_algebra_mx; apply/row_matrixP=> i.\nby rewrite !rowK map_regular_repr.\nQed.",
    "Lemma repr_mx_free x : x \\in G -> row_free (rG x).\nProof. by move=> Gx; rewrite row_free_unit repr_mx_unit. Qed.",
    "Lemma rstabs_sub : rstabs \\subset G.\nProof. by apply/subsetP=> x /setIdP[]. Qed.",
    "Lemma rstabs_group_set : group_set rstabs.\nProof.\napply/group_setP; rewrite inE group1 repr_mx1 mulmx1.\nsplit=> //= x y /setIdP[Gx nUx] /setIdP[Gy]; rewrite inE repr_mxM ?groupM //.\nby apply: submx_trans; rewrite mulmxA submxMr.\nQed.",
    "Lemma rstab_act x m1 (W : 'M_(m1, n)) :\n  x \\in rstab rG U -> (W <= U)%MS -> W *m rG x = W.\nProof. by case/setIdP=> _ /eqP cUx /submxP[w ->]; rewrite -mulmxA cUx. Qed.",
    "Lemma rstabs_act x m1 (W : 'M_(m1, n)) :\n  x \\in rstabs -> (W <= U)%MS -> (W *m rG x <= U)%MS.\nProof.\nby case/setIdP=> [_ nUx] sWU; apply: submx_trans nUx; apply: submxMr.\nQed.",
    "Lemma mxmoduleP : reflect {in G, forall x, U *m rG x <= U}%MS mxmodule.\nProof.\nby apply: (iffP subsetP) => modU x Gx; have:= modU x Gx; rewrite !inE ?Gx.\nQed.",
    "Lemma rstabS m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U <= V)%MS -> rstab rG V \\subset rstab rG U.\nProof.\ncase/submxP=> u ->; apply/subsetP=> x.\nby rewrite !inE => /andP[-> /= /eqP cVx]; rewrite -mulmxA cVx.\nQed.",
    "Lemma eqmx_rstab m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U :=: V)%MS -> rstab rG U = rstab rG V.\nProof. by move=> eqUV; apply/eqP; rewrite eqEsubset !rstabS ?eqUV. Qed.",
    "Lemma eqmx_rstabs m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U :=: V)%MS -> rstabs U = rstabs V.\nProof. by move=> eqUV; apply/setP=> x; rewrite !inE eqUV (eqmxMr _ eqUV). Qed.",
    "Lemma eqmx_module m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U :=: V)%MS -> mxmodule U = mxmodule V.\nProof. by move=> eqUV; rewrite /mxmodule (eqmx_rstabs eqUV). Qed.",
    "Lemma mxmodule0 m : mxmodule (0 : 'M_(m, n)).\nProof. by apply/mxmoduleP=> x _; rewrite mul0mx. Qed.",
    "Lemma mxmodule1 : mxmodule 1%:M.\nProof. by apply/mxmoduleP=> x _; rewrite submx1. Qed.",
    "Lemma mxmodule_trans m1 m2 (U : 'M_(m1, n)) (W : 'M_(m2, n)) x :\n  mxmodule U -> x \\in G -> (W <= U -> W *m rG x <= U)%MS.\nProof.\nby move=> modU Gx sWU; apply: submx_trans (mxmoduleP modU x Gx); apply: submxMr.\nQed.",
    "Lemma mxmodule_eigenvector m (U : 'M_(m, n)) :\n    mxmodule U -> \\rank U = 1 ->\n  {u : 'rV_n & {a | (U :=: u)%MS & {in G, forall x, u *m rG x = a x *: u}}}.\nProof.\nmove=> modU linU; set u := nz_row U; exists u.\nhave defU: (U :=: u)%MS.\n  apply/eqmxP; rewrite andbC -(geq_leqif (mxrank_leqif_eq _)) ?nz_row_sub //.\n  by rewrite linU lt0n mxrank_eq0 nz_row_eq0 -mxrank_eq0 linU.\npose a x := (u *m rG x *m pinvmx u) 0 0; exists a => // x Gx.\nby rewrite -mul_scalar_mx -mx11_scalar mulmxKpV // -defU mxmodule_trans ?defU.\nQed.",
    "Lemma addsmx_module m1 m2 U V :\n  @mxmodule m1 U -> @mxmodule m2 V -> mxmodule (U + V)%MS.\nProof.\nmove=> modU modV; apply/mxmoduleP=> x Gx.\nby rewrite addsmxMr addsmxS ?(mxmoduleP _ x Gx).\nQed.",
    "Lemma sumsmx_module I r (P : pred I) U :\n  (forall i, P i -> mxmodule (U i)) -> mxmodule (\\sum_(i <- r | P i) U i)%MS.\nProof.\nby move=> modU; elim/big_ind: _; [apply: mxmodule0 | apply: addsmx_module | ].\nQed.",
    "Lemma capmx_module m1 m2 U V :\n  @mxmodule m1 U -> @mxmodule m2 V -> mxmodule (U :&: V)%MS.\nProof.\nmove=> modU modV; apply/mxmoduleP=> x Gx.\nby rewrite sub_capmx !mxmodule_trans ?capmxSl ?capmxSr.\nQed.",
    "Lemma bigcapmx_module I r (P : pred I) U :\n  (forall i, P i -> mxmodule (U i)) -> mxmodule (\\bigcap_(i <- r | P i) U i)%MS.\nProof.\nby move=> modU; elim/big_ind: _; [apply: mxmodule1 | apply: capmx_module | ].\nQed.",
    "Lemma val_submodE m W : @val_submod m W = W *m val_submod 1%:M.\nProof. by rewrite mulmxA mulmx1. Qed.",
    "Lemma in_submodE m W : @in_submod m W = W *m in_submod 1%:M.\nProof. by rewrite mulmxA mulmx1. Qed.",
    "Lemma val_submod1 : (val_submod 1%:M :=: U)%MS.\nProof. by rewrite /val_submod /= mul1mx; apply: eq_row_base. Qed.",
    "Lemma val_submodP m W : (@val_submod m W <= U)%MS.\nProof. by rewrite mulmx_sub ?eq_row_base. Qed.",
    "Lemma val_submodK m : cancel (@val_submod m) (@in_submod m).\nProof.\nmove=> W; rewrite /in_submod /= -!mulmxA mulKVmx ?row_ebase_unit //.\nby rewrite pid_mx_id ?rank_leq_row // pid_mx_1 mulmx1.\nQed.",
    "Lemma val_submod_inj m : injective (@val_submod m).\nProof. exact: can_inj (@val_submodK m). Qed.",
    "Lemma val_submodS m1 m2 (V : 'M_(m1, \\rank U)) (W : 'M_(m2, \\rank U)) :\n  (val_submod V <= val_submod W)%MS = (V <= W)%MS.\nProof.\napply/idP/idP=> sVW; last exact: submxMr.\nby rewrite -[V]val_submodK -[W]val_submodK submxMr.\nQed.",
    "Lemma in_submodK m W : (W <= U)%MS -> val_submod (@in_submod m W) = W.\nProof.\ncase/submxP=> w ->; rewrite /val_submod /= -!mulmxA.\ncongr (_ *m _); rewrite -{1}[U]mulmx_ebase !mulmxA mulmxK ?row_ebase_unit //.\nby rewrite -2!(mulmxA (col_ebase U)) !pid_mx_id ?rank_leq_row // mulmx_ebase.\nQed.",
    "Lemma val_submod_eq0 m W : (@val_submod m W == 0) = (W == 0).\nProof. by rewrite -!submx0 -val_submodS linear0 !(submx0, eqmx0). Qed.",
    "Lemma in_submod_eq0 m W : (@in_submod m W == 0) = (W <= U^C)%MS.\nProof.\napply/eqP/submxP=> [W_U0 | [w ->{W}]].\n  exists (W *m invmx (row_ebase U)).\n  rewrite mulmxA mulmxBr mulmx1 -(pid_mx_id _ _ _ (leqnn _)).\n  rewrite mulmxA -(mulmxA W) [W *m (_ *m _)]W_U0 mul0mx subr0.\n  by rewrite mulmxKV ?row_ebase_unit.\nrewrite /in_submod /= -!mulmxA mulKVmx ?row_ebase_unit //.\nby rewrite mul_copid_mx_pid ?rank_leq_row ?mulmx0.\nQed.",
    "Lemma mxrank_in_submod m (W : 'M_(m, n)) :\n  (W <= U)%MS -> \\rank (in_submod W) = \\rank W.\nProof.\nby move=> sWU; apply/eqP; rewrite eqn_leq -{3}(in_submodK sWU) !mxrankM_maxl.\nQed.",
    "Lemma val_factmodE m W : @val_factmod m W = W *m val_factmod 1%:M.\nProof. by rewrite mulmxA mulmx1. Qed.",
    "Lemma in_factmodE m W : @in_factmod m W = W *m in_factmod 1%:M.\nProof. by rewrite mulmxA mulmx1. Qed.",
    "Lemma val_factmodP m W : (@val_factmod m W <= U^C)%MS.\nProof.\nby rewrite mulmx_sub {m W}// (eqmxMr _ (eq_row_base _)) -mulmxA submxMl.\nQed.",
    "Lemma val_factmodK m : cancel (@val_factmod m) (@in_factmod m).\nProof.\nmove=> W /=; rewrite /in_factmod /=; set Uc := cokermx U.\napply: (row_free_inj (row_base_free Uc)); rewrite -mulmxA mulmx_base.\nrewrite /val_factmod /= 2!mulmxA -/Uc mulmxK ?row_ebase_unit //.\nhave /submxP[u ->]: (row_base Uc <= Uc)%MS by rewrite eq_row_base.\nby rewrite -!mulmxA copid_mx_id ?rank_leq_row.\nQed.",
    "Lemma val_factmod_inj m : injective (@val_factmod m).\nProof. exact: can_inj (@val_factmodK m). Qed.",
    "Lemma val_factmodS m1 m2 (V : 'M_(m1, _)) (W : 'M_(m2, _)) :\n  (val_factmod V <= val_factmod W)%MS = (V <= W)%MS.\nProof.\napply/idP/idP=> sVW; last exact: submxMr.\nby rewrite -[V]val_factmodK -[W]val_factmodK submxMr.\nQed.",
    "Lemma val_factmod_eq0 m W : (@val_factmod m W == 0) = (W == 0).\nProof. by rewrite -!submx0 -val_factmodS linear0 !(submx0, eqmx0). Qed.",
    "Lemma in_factmod_eq0 m (W : 'M_(m, n)) : (in_factmod W == 0) = (W <= U)%MS.\nProof.\nrewrite submxE -!mxrank_eq0 -{2}[_ U]mulmx_base mulmxA.\nby rewrite (mxrankMfree _ (row_base_free _)).\nQed.",
    "Lemma in_factmodK m (W : 'M_(m, n)) :\n  (W <= U^C)%MS -> val_factmod (in_factmod W) = W.\nProof.\ncase/submxP=> w ->{W}; rewrite /val_factmod /= -2!mulmxA.\ncongr (_ *m _); rewrite (mulmxA (col_base _)) mulmx_base -2!mulmxA.\nby rewrite mulKVmx ?row_ebase_unit // mulmxA copid_mx_id ?rank_leq_row.\nQed.",
    "Lemma in_factmod_addsK m (W : 'M_(m, n)) :\n  (in_factmod (U + W)%MS :=: in_factmod W)%MS.\nProof.\napply: eqmx_trans (addsmxMr _ _ _) _.\nby rewrite ((_ *m _ =P 0) _) ?in_factmod_eq0 //; apply: adds0mx.\nQed.",
    "Lemma add_sub_fact_mod m (W : 'M_(m, n)) :\n  val_submod (in_submod W) + val_factmod (in_factmod W) = W.\nProof.\nrewrite /val_submod /val_factmod /= -!mulmxA -mulmxDr.\nrewrite addrC ![in X in X + _](mulmxA (pid_mx _)) pid_mx_id //.\nrewrite (mulmxA (col_ebase _)) (mulmxA _ _ (row_ebase _)) mulmx_ebase.\nrewrite (mulmxA (pid_mx _)) pid_mx_id // mulmxA -mulmxDl -mulmxDr.\nby rewrite subrK mulmx1 mulmxA mulmxKV ?row_ebase_unit.\nQed.",
    "Lemma proj_factmodS m (W : 'M_(m, n)) :\n  (val_factmod (in_factmod W) <= U + W)%MS.\nProof.\nby rewrite -{2}[W]add_sub_fact_mod addsmx_addKl ?val_submodP ?addsmxSr.\nQed.",
    "Lemma in_factmodsK m (W : 'M_(m, n)) :\n  (U <= W)%MS -> (U + val_factmod (in_factmod W) :=: W)%MS.\nProof.\nmove/addsmx_idPr; apply: eqmx_trans (eqmx_sym _).\nby rewrite -{1}[W]add_sub_fact_mod; apply: addsmx_addKl; apply: val_submodP.\nQed.",
    "Lemma mxrank_in_factmod m (W : 'M_(m, n)) :\n  (\\rank (in_factmod W) + \\rank U)%N = \\rank (U + W).\nProof.\nrewrite -in_factmod_addsK in_factmodE; set fU := in_factmod 1%:M.\nsuffices <-: ((U + W) :&: kermx fU :=: U)%MS by rewrite mxrank_mul_ker.\napply: eqmx_trans (capmx_idPr (addsmxSl U W)).\napply: cap_eqmx => //; apply/eqmxP/rV_eqP => u.\nby rewrite (sameP sub_kermxP eqP) -in_factmodE in_factmod_eq0.\nQed.",
    "Lemma in_submodJ m (W : 'M_(m, n)) x :\n  (W <= U)%MS -> in_submod (W *m rG x) = in_submod W *m submod_mx Umod x.\nProof.\nmove=> sWU; rewrite mulmxA; congr (in_submod _).\nby rewrite mulmxA -val_submodE in_submodK.\nQed.",
    "Lemma val_submodJ m (W : 'M_(m, \\rank U)) x :\n  x \\in G -> val_submod (W *m submod_mx Umod x) = val_submod W *m rG x.\nProof.\nmove=> Gx; rewrite 2!(mulmxA W) -val_submodE in_submodK //.\nby rewrite mxmodule_trans ?val_submodP.\nQed.",
    "Lemma submod_mx_repr : mx_repr G (submod_mx Umod).\nProof.\nrewrite /submod_mx; split=> [|x y Gx Gy /=].\n  by rewrite repr_mx1 mulmx1 val_submodK.\nrewrite -in_submodJ; first by rewrite repr_mxM ?mulmxA.\nby rewrite mxmodule_trans ?val_submodP.\nQed.",
    "Lemma in_factmodJ m (W : 'M_(m, n)) x :\n  x \\in G -> in_factmod (W *m rG x) = in_factmod W *m factmod_mx Umod x.\nProof.\nmove=> Gx; rewrite -{1}[W]add_sub_fact_mod mulmxDl linearD /=.\napply: (canLR (subrK _)); apply: etrans (_ : 0 = _).\n  apply/eqP; rewrite in_factmod_eq0 (submx_trans _ (mxmoduleP Umod x Gx)) //.\n  by rewrite submxMr ?val_submodP.\nby rewrite /in_factmod /val_factmod /= !mulmxA mulmx1 ?subrr.\nQed.",
    "Lemma val_factmodJ m (W : 'M_(m, \\rank (cokermx U))) x :\n  x \\in G ->\n  val_factmod (W *m factmod_mx Umod x) =\n     val_factmod (in_factmod (val_factmod W *m rG x)).\nProof. by move=> Gx; rewrite -{1}[W]val_factmodK -in_factmodJ. Qed.",
    "Lemma factmod_mx_repr : mx_repr G (factmod_mx Umod).\nProof.\nsplit=> [|x y Gx Gy /=].\n  by rewrite /factmod_mx repr_mx1 mulmx1 val_factmodK.\nby rewrite -in_factmodJ // -mulmxA -repr_mxM.\nQed.",
    "Lemma mxtrace_sub_fact_mod x :\n  \\tr (submod_repr x) + \\tr (factmod_repr x) = \\tr (rG x).\nProof.\nrewrite -[submod_repr x]mulmxA mxtrace_mulC -val_submodE addrC.\nrewrite -[factmod_repr x]mulmxA mxtrace_mulC -val_factmodE addrC.\nby rewrite -mxtraceD add_sub_fact_mod.\nQed.",
    "Lemma envelop_mx_id x : x \\in G -> (rG x \\in E_G)%MS.\nProof.\nby move=> Gx; rewrite (eq_row_sub (enum_rank_in Gx x)) // rowK enum_rankK_in.\nQed.",
    "Lemma envelop_mx1 : (1%:M \\in E_G)%MS.\nProof. by rewrite -(repr_mx1 rG) envelop_mx_id. Qed.",
    "Lemma envelop_mxP A :\n  reflect (exists a, A = \\sum_(x in G) a x *: rG x) (A \\in E_G)%MS.\nProof.\nhave G_1 := group1 G; have bijG := enum_val_bij_in G_1.\nset h := enum_val in bijG; have Gh: h _ \\in G by apply: enum_valP.\napply: (iffP submxP) => [[u defA] | [a ->]].\n  exists (fun x => u 0 (enum_rank_in G_1 x)); apply: (can_inj mxvecK).\n  rewrite defA mulmx_sum_row linear_sum (reindex h) //=.\n  by apply: eq_big => [i | i _]; rewrite ?Gh // rowK linearZ enum_valK_in.\nexists (\\row_i a (h i)); rewrite mulmx_sum_row linear_sum (reindex h) //=.\nby apply: eq_big => [i | i _]; rewrite ?Gh // mxE rowK linearZ.\nQed.",
    "Lemma envelop_mxM A B : (A \\in E_G -> B \\in E_G -> A *m B \\in E_G)%MS.\nProof.\nmove=> {A B} /envelop_mxP[a ->] /envelop_mxP[b ->].\nrewrite mulmx_suml !linear_sum summx_sub //= => x Gx.\nrewrite !linear_sum summx_sub //= => y Gy.\nrewrite -scalemxAl 3!linearZ !scalemx_sub//= -repr_mxM //.\nby rewrite envelop_mx_id ?groupM.\nQed.",
    "Lemma mxmodule_envelop m1 m2 (U : 'M_(m1, n)) (W : 'M_(m2, n)) A :\n  (mxmodule U -> mxvec A <= E_G -> W <= U -> W *m A <= U)%MS.\nProof.\nmove=> modU /envelop_mxP[a ->] sWU; rewrite linear_sum summx_sub //= => x Gx.\nby rewrite -scalemxAr scalemx_sub ?mxmodule_trans.\nQed.",
    "Lemma hom_mxP m f (W : 'M_(m, n)) :\n  reflect (forall x, x \\in G -> W *m rG x *m f = W *m f *m rG x)\n          (W <= dom_hom_mx f)%MS.\nProof.\napply: (iffP row_subP) => [cGf x Gx | cGf i].\n  apply/row_matrixP=> i; apply/eqP; rewrite -subr_eq0 -!mulmxA -!linearB /=.\n  have:= sub_kermxP (cGf i); rewrite mul_rV_lin1 /=.\n  move/(canRL mxvecK)/row_matrixP/(_ (enum_rank_in Gx x))/eqP; rewrite !linear0.\n  by rewrite !row_mul rowK mul_vec_lin /= mul_vec_lin_row enum_rankK_in.\napply/sub_kermxP; rewrite mul_rV_lin1 /=; apply: (canLR vec_mxK).\napply/row_matrixP=> j; rewrite !row_mul rowK mul_vec_lin /= mul_vec_lin_row.\nby rewrite -!row_mul mulmxBr !mulmxA cGf ?enum_valP // subrr !linear0.\nQed.",
    "Lemma hom_envelop_mxC m f (W : 'M_(m, n)) A :\n  (W <= dom_hom_mx f -> A \\in E_G -> W *m A *m f = W *m f *m A)%MS.\nProof.\nmove/hom_mxP=> cWfG /envelop_mxP[a ->]; rewrite !linear_sum mulmx_suml.\nby apply: eq_bigr => x Gx /=; rewrite -2!scalemxAr -scalemxAl cWfG.\nQed.",
    "Lemma dom_hom_invmx f :\n  f \\in unitmx -> (dom_hom_mx (invmx f) :=: dom_hom_mx f *m f)%MS.\nProof.\nmove=> injf; set U := dom_hom_mx _; apply/eqmxP.\nrewrite -{1}[U](mulmxKV injf) submxMr; apply/hom_mxP=> x Gx.\n  by rewrite -[_ *m rG x](hom_mxP _) ?mulmxK.\nby rewrite -[_ *m rG x](hom_mxP _) ?mulmxKV.\nQed.",
    "Lemma dom_hom_mx_module f : mxmodule (dom_hom_mx f).\nProof.\napply/mxmoduleP=> x Gx; apply/hom_mxP=> y Gy.\nrewrite -[_ *m rG y]mulmxA -repr_mxM // 2?(hom_mxP _) ?groupM //.\nby rewrite repr_mxM ?mulmxA.\nQed.",
    "Lemma hom_mxmodule m (U : 'M_(m, n)) f :\n  (U <= dom_hom_mx f)%MS -> mxmodule U -> mxmodule (U *m f).\nProof.\nmove/hom_mxP=> cGfU modU; apply/mxmoduleP=> x Gx.\nby rewrite -cGfU // submxMr // (mxmoduleP modU).\nQed.",
    "Lemma kermx_hom_module m (U : 'M_(m, n)) f :\n  (U <= dom_hom_mx f)%MS -> mxmodule U -> mxmodule (U :&: kermx f)%MS.\nProof.\nmove=> homUf modU; apply/mxmoduleP=> x Gx.\nrewrite sub_capmx mxmodule_trans ?capmxSl //=.\napply/sub_kermxP; rewrite (hom_mxP _) ?(submx_trans (capmxSl _ _)) //.\nby rewrite (sub_kermxP (capmxSr _ _)) mul0mx.\nQed.",
    "Lemma scalar_mx_hom a m (U : 'M_(m, n)) : (U <= dom_hom_mx a%:M)%MS.\nProof. by apply/hom_mxP=> x Gx; rewrite -!mulmxA scalar_mxC. Qed.",
    "Lemma proj_mx_hom (U V : 'M_n) :\n    (U :&: V = 0)%MS -> mxmodule U -> mxmodule V ->\n  (U + V <= dom_hom_mx (proj_mx U V))%MS.\nProof.\nmove=> dxUV modU modV; apply/hom_mxP=> x Gx.\nrewrite -{1}(add_proj_mx dxUV (submx_refl _)) !mulmxDl addrC.\nrewrite {1}[_ *m _]proj_mx_0 ?add0r //; last first.\n  by rewrite mxmodule_trans ?proj_mx_sub.\nby rewrite [_ *m _](proj_mx_id dxUV) // mxmodule_trans ?proj_mx_sub.\nQed.",
    "Lemma rfix_mxP m (W : 'M_(m, n)) (H : {set gT}) :\n  reflect (forall x, x \\in H -> W *m rG x = W) (W <= rfix_mx H)%MS.\nProof.\nrewrite /rfix_mx; set C := \\matrix_i _.\napply: (iffP row_subP) => [cHW x Hx | cHW j].\n  apply/row_matrixP=> j; apply/eqP; rewrite -subr_eq0 row_mul.\n  move/sub_kermxP: {cHW}(cHW j); rewrite mul_rV_lin1 /=; move/(canRL mxvecK).\n  move/row_matrixP/(_ (enum_rank_in Hx x)); rewrite row_mul rowK !linear0.\n  by rewrite enum_rankK_in // mul_vec_lin_row mulmxBr mulmx1 => ->.\napply/sub_kermxP; rewrite mul_rV_lin1 /=; apply: (canLR vec_mxK).\napply/row_matrixP=> i; rewrite row_mul rowK mul_vec_lin_row -row_mul.\nby rewrite mulmxBr mulmx1 cHW ?enum_valP // subrr !linear0.\nQed.",
    "Lemma rfix_mx_id (H : {set gT}) x : x \\in H -> rfix_mx H *m rG x = rfix_mx H.\nProof. exact/rfix_mxP. Qed.",
    "Lemma rfix_mxS (H K : {set gT}) : H \\subset K -> (rfix_mx K <= rfix_mx H)%MS.\nProof.\nby move=> sHK; apply/rfix_mxP=> x Hx; apply: rfix_mxP (subsetP sHK x Hx).\nQed.",
    "Lemma rfix_mx_conjsg (H : {set gT}) x :\n  x \\in G -> H \\subset G -> (rfix_mx (H :^ x) :=: rfix_mx H *m rG x)%MS.\nProof.\nmove=> Gx sHG; pose rf y := rfix_mx (H :^ y).\nsuffices{x Gx} IH: {in G &, forall y z, rf y *m rG z <= rf (y * z)%g}%MS.\n  apply/eqmxP; rewrite -/(rf x) -[H]conjsg1 -/(rf 1%g).\n  rewrite -{4}[x] mul1g -{1}[rf x](repr_mxKV rG Gx) -{1}(mulgV x).\n  by rewrite submxMr IH ?groupV.\nmove=> x y Gx Gy; apply/rfix_mxP=> zxy; rewrite actM => /imsetP[zx Hzx ->].\nhave Gzx: zx \\in G by apply: subsetP Hzx; rewrite conj_subG.\nrewrite -mulmxA -repr_mxM ?groupM ?groupV // -conjgC repr_mxM // mulmxA.\nby rewrite rfix_mx_id.\nQed.",
    "Lemma norm_sub_rstabs_rfix_mx (H : {set gT}) :\n  H \\subset G -> 'N_G(H) \\subset rstabs (rfix_mx H).\nProof.\nmove=> sHG; apply/subsetP=> x /setIP[Gx nHx]; rewrite inE Gx.\napply/rfix_mxP=> y Hy; have Gy := subsetP sHG y Hy.\nhave Hyx: (y ^ x^-1)%g \\in H by rewrite memJ_norm ?groupV.\nrewrite -mulmxA -repr_mxM // conjgCV repr_mxM ?(subsetP sHG _ Hyx) // mulmxA.\nby rewrite (rfix_mx_id Hyx).\nQed.",
    "Lemma normal_rfix_mx_module H : H <| G -> mxmodule (rfix_mx H).\nProof.\ncase/andP=> sHG nHG.\nby rewrite /mxmodule -{1}(setIidPl nHG) norm_sub_rstabs_rfix_mx.\nQed.",
    "Lemma rfix_mx_module : mxmodule (rfix_mx G).\nProof. exact: normal_rfix_mx_module. Qed.",
    "Lemma rfix_mx_rstabC (H : {set gT}) m (U : 'M[F]_(m, n)) :\n  H \\subset G -> (H \\subset rstab rG U) = (U <= rfix_mx H)%MS.\nProof.\nmove=> sHG; apply/subsetP/rfix_mxP=> cHU x Hx.\n  by rewrite (rstab_act (cHU x Hx)).\nby rewrite !inE (subsetP sHG) //= cHU.\nQed.",
    "Lemma cyclic_mxP u v :\n  reflect (exists2 A, A \\in E_G & v = u *m A)%MS (v <= cyclic_mx u)%MS.\nProof.\nrewrite genmxE; apply: (iffP submxP) => [[a] | [A /submxP[a defA]]] -> {v}.\n  exists (vec_mx (a *m E_G)); last by rewrite mulmxA mul_rV_lin1.\n  by rewrite vec_mxK submxMl.\nby exists a; rewrite mulmxA mul_rV_lin1 /= -defA mxvecK.\nQed.",
    "Lemma cyclic_mx_id u : (u <= cyclic_mx u)%MS.\nProof. by apply/cyclic_mxP; exists 1%:M; rewrite ?mulmx1 ?envelop_mx1. Qed.",
    "Lemma cyclic_mx_eq0 u : (cyclic_mx u == 0) = (u == 0).\nProof.\nrewrite -!submx0; apply/idP/idP.\n  by apply: submx_trans; apply: cyclic_mx_id.\nmove/submx0null->; rewrite genmxE; apply/row_subP=> i.\nby rewrite row_mul mul_rV_lin1 /= mul0mx ?sub0mx.\nQed.",
    "Lemma cyclic_mx_module u : mxmodule (cyclic_mx u).\nProof.\napply/mxmoduleP=> x Gx; apply/row_subP=> i; rewrite row_mul.\nhave [A E_A ->{i}] := @cyclic_mxP u _ (row_sub i _); rewrite -mulmxA.\nby apply/cyclic_mxP; exists (A *m rG x); rewrite ?envelop_mxM ?envelop_mx_id.\nQed.",
    "Lemma cyclic_mx_sub m u (W : 'M_(m, n)) :\n  mxmodule W -> (u <= W)%MS -> (cyclic_mx u <= W)%MS.\nProof.\nmove=> modU Wu; rewrite genmxE; apply/row_subP=> i.\nby rewrite row_mul mul_rV_lin1 /= mxmodule_envelop // vec_mxK row_sub.\nQed.",
    "Lemma hom_cyclic_mx u f :\n  (u <= dom_hom_mx f)%MS -> (cyclic_mx u *m f :=: cyclic_mx (u *m f))%MS.\nProof.\nmove=> domf_u; apply/eqmxP; rewrite !(eqmxMr _ (genmxE _)).\napply/genmxP; rewrite genmx_id; congr <<_>>%MS; apply/row_matrixP=> i.\nby rewrite !row_mul !mul_rV_lin1 /= hom_envelop_mxC // vec_mxK row_sub.\nQed.",
    "Lemma annihilator_mxP u A :\n  reflect (A \\in E_G /\\ u *m A = 0)%MS (A \\in annihilator_mx u)%MS.\nProof.\nrewrite sub_capmx; apply: (iffP andP) => [[-> /sub_kermxP]|[-> uA0]].\n  by rewrite mul_rV_lin1 /= mxvecK.\nby split=> //; apply/sub_kermxP; rewrite mul_rV_lin1 /= mxvecK.\nQed.",
    "Lemma row_hom_mxP u v :\n  reflect (exists2 f, u <= dom_hom_mx f & u *m f = v)%MS (v <= row_hom_mx u)%MS.\nProof.\napply: (iffP sub_bigcapmxP) => [iso_uv | [f hom_uf <-] i _].\n  have{iso_uv} uv0 A: (A \\in E_G)%MS /\\ u *m A = 0 -> v *m A = 0.\n    move/annihilator_mxP=> /submxP[a defA].\n    rewrite -[A]mxvecK {A}defA [a *m _]mulmx_sum_row !linear_sum big1 // => i _.\n    by rewrite !linearZ /= (sub_kermxP _) ?scaler0 ?iso_uv.\n  pose U := E_G *m lin_mul_row u; pose V :=  E_G *m lin_mul_row v.\n  pose f := pinvmx U *m V.\n  have hom_uv_f x: x \\in G -> u *m rG x *m f = v *m rG x.\n    move=> Gx; apply/eqP; rewrite 2!mulmxA mul_rV_lin1 -subr_eq0 -mulmxBr /=.\n    rewrite uv0 // linearB /= mulmxBr vec_mxK; split. \n      by rewrite addmx_sub ?submxMl // eqmx_opp envelop_mx_id.\n    have Uux: (u *m rG x <= U)%MS.\n      by rewrite -(genmxE U) mxmodule_trans ?cyclic_mx_id ?cyclic_mx_module.\n    by rewrite -{2}(mulmxKpV Uux) [_ *m U]mulmxA mul_rV_lin1 subrr.\n  have def_uf: u *m f = v.\n    by rewrite -[u]mulmx1 -[v]mulmx1 -(repr_mx1 rG) hom_uv_f.\n  by exists f => //; apply/hom_mxP=> x Gx; rewrite def_uf hom_uv_f.\napply/sub_kermxP; set A := vec_mx _.\nhave: (A \\in annihilator_mx u)%MS by rewrite vec_mxK row_sub.\nby case/annihilator_mxP => E_A uA0; rewrite -hom_envelop_mxC // uA0 mul0mx.\nQed.",
    "Lemma eqmx_iso U V : (U :=: V)%MS -> mx_iso U V.\nProof.\nby move=> eqUV; exists 1%:M; rewrite ?unitmx1 ?scalar_mx_hom ?mulmx1.\nQed.",
    "Lemma mx_iso_refl U : mx_iso U U.\nProof. exact: eqmx_iso. Qed.",
    "Lemma mx_iso_sym U V : mx_iso U V -> mx_iso V U.\nProof.\ncase=> f injf homUf defV; exists (invmx f); first by rewrite unitmx_inv.\n  by rewrite dom_hom_invmx // -defV submxMr.\nby rewrite -[U](mulmxK injf); apply: eqmxMr (eqmx_sym _).\nQed.",
    "Lemma mx_iso_trans U V W : mx_iso U V -> mx_iso V W -> mx_iso U W.\nProof.\ncase=> f injf homUf defV [g injg homVg defW].\nexists (f *m g); first by rewrite unitmx_mul injf.\n  by apply/hom_mxP=> x Gx; rewrite !mulmxA 2?(hom_mxP _) ?defV.\nby rewrite mulmxA; apply: eqmx_trans (eqmxMr g defV) defW.\nQed.",
    "Lemma mxrank_iso U V : mx_iso U V -> \\rank U = \\rank V.\nProof. by case=> f injf _ <-; rewrite mxrankMfree ?row_free_unit. Qed.",
    "Lemma mx_iso_module U V : mx_iso U V -> mxmodule U -> mxmodule V.\nProof.\nby case=> f _ homUf defV; rewrite -(eqmx_module defV); apply: hom_mxmodule.\nQed.",
    "Lemma mxsimpleP U :\n  [/\\ mxmodule U, U != 0 & ~ mxnonsimple U] <-> mxsimple U.\nProof.\ndo [split => [] [modU nzU simU]; split] => // [V modV sVU nzV | [V]].\n  apply/idPn; rewrite -(ltn_leqif (mxrank_leqif_sup sVU)) => ltVU.\n  by case: simU; exists V; apply/and4P.\nby case/and4P=> modV sVU nzV; apply/negP; rewrite -leqNgt mxrankS ?simU.\nQed.",
    "Lemma mxsimple_module U : mxsimple U -> mxmodule U.\nProof. by case. Qed.",
    "Lemma mxsimple_exists m (U : 'M_(m, n)) :\n  mxmodule U -> U != 0 -> classically (exists2 V, mxsimple V & V <= U)%MS.\nProof.\nmove=> modU nzU [] // simU; move: {2}_.+1 (ltnSn (\\rank U)) => r leUr.\nelim: r => // r IHr in m U leUr modU nzU simU.\nhave genU := genmxE U; apply: (simU); exists <<U>>%MS; last by rewrite genU.\napply/mxsimpleP; split; rewrite ?(eqmx_eq0 genU) ?(eqmx_module genU) //.\ncase=> V; rewrite !genU=> /and4P[modV sVU nzV ltVU]; case: notF.\napply: IHr nzV _ => // [|[W simW sWV]]; first exact: leq_trans ltVU _.\nby apply: simU; exists W => //; apply: submx_trans sWV sVU.\nQed.",
    "Lemma mx_iso_simple U V : mx_iso U V -> mxsimple U -> mxsimple V.\nProof.\nmove=> isoUV [modU nzU simU]; have [f injf homUf defV] := isoUV.\nsplit=> [||W modW sWV nzW]; first by rewrite (mx_iso_module isoUV).\n  by rewrite -(eqmx_eq0 defV) -(mul0mx n f) (can_eq (mulmxK injf)).\nrewrite -defV -[W](mulmxKV injf) submxMr //; set W' := W *m _.\nhave sW'U: (W' <= U)%MS by rewrite -[U](mulmxK injf) submxMr ?defV.\nrewrite (simU W') //; last by rewrite -(can_eq (mulmxK injf)) mul0mx mulmxKV.\nrewrite hom_mxmodule ?dom_hom_invmx // -[W](mulmxKV injf) submxMr //.\nexact: submx_trans sW'U homUf.\nQed.",
    "Lemma mxsimple_cyclic u U :\n  mxsimple U -> u != 0 -> (u <= U)%MS -> (U :=: cyclic_mx u)%MS.\nProof.\ncase=> [modU _ simU] nz_u Uu; apply/eqmxP; set uG := cyclic_mx u.\nhave s_uG_U: (uG <= U)%MS by rewrite cyclic_mx_sub.\nby rewrite simU ?cyclic_mx_eq0 ?submx_refl // cyclic_mx_module.\nQed.",
    "Lemma mx_Schur_onto m (U : 'M_(m, n)) V f :\n    mxmodule U -> mxsimple V -> (U <= dom_hom_mx f)%MS ->\n  (U *m f <= V)%MS -> U *m f != 0 -> (U *m f :=: V)%MS.\nProof.\nmove=> modU [modV _ simV] homUf sUfV nzUf.\napply/eqmxP; rewrite sUfV -(genmxE (U *m f)).\nrewrite simV ?(eqmx_eq0 (genmxE _)) ?genmxE //.\nby rewrite (eqmx_module (genmxE _)) hom_mxmodule.\nQed.",
    "Lemma mx_Schur_inj U f :\n  mxsimple U -> (U <= dom_hom_mx f)%MS -> U *m f != 0 -> (U :&: kermx f)%MS = 0.\nProof.\ncase=> [modU _ simU] homUf nzUf; apply/eqP; apply: contraR nzUf => nz_ker.\nrewrite (sameP eqP sub_kermxP) (sameP capmx_idPl eqmxP) simU ?capmxSl //.\nexact: kermx_hom_module.\nQed.",
    "Lemma mx_Schur_inj_iso U f :\n  mxsimple U -> (U <= dom_hom_mx f)%MS -> U *m f != 0 -> mx_iso U (U *m f).\nProof.\nmove=> simU homUf nzUf; have [modU _ _] := simU.\nhave eqUfU: \\rank (U *m f) = \\rank U by apply/mxrank_injP; rewrite mx_Schur_inj.\nhave{eqUfU} [g invg defUf] := complete_unitmx eqUfU.\nsuffices homUg: (U <= dom_hom_mx g)%MS by exists g; rewrite ?defUf.\napply/hom_mxP=> x Gx; have [ux defUx] := submxP (mxmoduleP modU x Gx).\nby rewrite -defUf -(hom_mxP homUf) // defUx -!(mulmxA ux) defUf.\nQed.",
    "Lemma mx_Schur_iso U V f :\n    mxsimple U -> mxsimple V -> (U <= dom_hom_mx f)%MS ->\n  (U *m f <= V)%MS -> U *m f != 0 -> mx_iso U V.\nProof.\nmove=> simU simV homUf sUfV nzUf; have [modU _ _] := simU.\nhave [g invg homUg defUg] := mx_Schur_inj_iso simU homUf nzUf.\nexists g => //; apply: mx_Schur_onto; rewrite ?defUg //.\nby rewrite -!submx0 defUg in nzUf *.\nQed.",
    "Lemma nz_row_mxsimple U : mxsimple U -> nz_row U != 0.\nProof. by case=> _ nzU _; rewrite nz_row_eq0. Qed.",
    "Lemma mxsimple_isoP U V :\n  mxsimple U -> reflect (mx_iso U V) (mxsimple_iso U V).\nProof.\nmove=> simU; pose u := nz_row U.\nhave [Uu nz_u]: (u <= U)%MS /\\ u != 0 by rewrite nz_row_sub nz_row_mxsimple.\napply: (iffP and3P) => [[modV] | isoUV]; last first.\n  split; last by rewrite (mxrank_iso isoUV).\n    by case: (mx_iso_simple isoUV simU).\n  have [f injf homUf defV] := isoUV; apply/rowV0Pn; exists (u *m f).\n    rewrite sub_capmx -defV submxMr //.\n    by apply/row_hom_mxP; exists f; first apply: (submx_trans Uu).\n  by rewrite -(mul0mx _ f) (can_eq (mulmxK injf)) nz_u.\ncase/rowV0Pn=> v; rewrite sub_capmx => /andP[Vv].\ncase/row_hom_mxP => f homMf def_v nz_v eqrUV.\npose uG := cyclic_mx u; pose vG := cyclic_mx v.\nhave def_vG: (uG *m f :=: vG)%MS by rewrite /vG -def_v; apply: hom_cyclic_mx.\nhave defU: (U :=: uG)%MS by apply: mxsimple_cyclic.\nhave mod_uG: mxmodule uG by rewrite cyclic_mx_module.\nhave homUf: (U <= dom_hom_mx f)%MS.\n  by rewrite defU cyclic_mx_sub ?dom_hom_mx_module.\nhave isoUf: mx_iso U (U *m f).\n  apply: mx_Schur_inj_iso => //; apply: contra nz_v; rewrite -!submx0.\n  by rewrite (eqmxMr f defU) def_vG; apply: submx_trans (cyclic_mx_id v).\napply: mx_iso_trans (isoUf) (eqmx_iso _); apply/eqmxP.\nhave sUfV: (U *m f <= V)%MS by rewrite (eqmxMr f defU) def_vG cyclic_mx_sub.\nby rewrite -mxrank_leqif_eq ?eqn_leq 1?mxrankS // -(mxrank_iso isoUf).\nQed.",
    "Lemma mxsimple_iso_simple U V :\n  mxsimple_iso U V -> mxsimple U -> mxsimple V.\nProof.\nby move=> isoUV simU; apply: mx_iso_simple (simU); apply/mxsimple_isoP.\nQed.",
    "Lemma sum_mxsimple_direct_compl m I W (U : 'M_(m, n)) :\n    let V := (\\sum_(i : I) W i)%MS in\n    (forall i : I, mxsimple (W i)) -> mxmodule U -> (U <= V)%MS ->\n  {J : {set I} | let S := U + \\sum_(i in J) W i in S :=: V /\\ mxdirect S}%MS.\nProof.\nmove=> V simW modU sUV; pose V_ (J : {set I}) := (\\sum_(i in J) W i)%MS.\npose dxU (J : {set I}) := mxdirect (U + V_ J).\nhave [J maxJ]: {J | maxset dxU J}; last case/maxsetP: maxJ => dxUVJ maxJ.\n  apply: ex_maxset; exists set0.\n  by rewrite /dxU mxdirectE /V_ /= !big_set0 addn0 addsmx0 /=.\nhave modWJ: mxmodule (V_ J) by apply: sumsmx_module => i _; case: (simW i).\nexists J; split=> //; apply/eqmxP; rewrite addsmx_sub sUV; apply/andP; split.\n  by apply/sumsmx_subP=> i Ji; rewrite (sumsmx_sup i).\nrewrite -/(V_ J); apply/sumsmx_subP=> i _.\ncase Ji: (i \\in J).\n  by apply: submx_trans (addsmxSr _ _); apply: (sumsmx_sup i).\nhave [modWi nzWi simWi] := simW i.\nrewrite (sameP capmx_idPl eqmxP) simWi ?capmxSl ?capmx_module ?addsmx_module //.\napply: contraFT (Ji); rewrite negbK => dxWiUVJ.\nrewrite -(maxJ (i |: J)) ?setU11 ?subsetUr // /dxU.\nrewrite mxdirectE /= !big_setU1 ?Ji //=.\nrewrite addnCA addsmxA (addsmxC U) -addsmxA -mxdirectE /=.\nby rewrite mxdirect_addsE /= mxdirect_trivial -/(dxU _) dxUVJ.\nQed.",
    "Lemma sum_mxsimple_direct_sub I W (V : 'M_n) :\n    (forall i : I, mxsimple (W i)) -> (\\sum_i W i :=: V)%MS ->\n  {J : {set I} | let S := \\sum_(i in J) W i in S :=: V /\\ mxdirect S}%MS.\nProof.\nmove=> simW defV.\nhave [|J [defS dxS]] := sum_mxsimple_direct_compl simW (mxmodule0 n).\n  exact: sub0mx.\nexists J; split; last by rewrite mxdirectE /= adds0mx mxrank0 in dxS.\nby apply: eqmx_trans defV; rewrite adds0mx_id in defS.\nQed.",
    "Lemma mxsemisimple0 : mxsemisimple 0.\nProof.\nexists 'I_0 (fun _ => 0); [by case | by rewrite big_ord0 | ].\nby rewrite mxdirectE /= !big_ord0 mxrank0.\nQed.",
    "Lemma intro_mxsemisimple (I : Type) r (P : pred I) W V :\n    (\\sum_(i <- r | P i) W i :=: V)%MS ->\n    (forall i, P i -> W i != 0 -> mxsimple (W i)) ->\n  mxsemisimple V.\nProof.\nmove=> defV simW; pose W_0 := [pred i | W i == 0].\nhave [-> | nzV] := eqVneq V 0; first exact: mxsemisimple0.\ncase def_r: r => [| i0 r'] => [|{r' def_r}].\n  by rewrite -mxrank_eq0 -defV def_r big_nil mxrank0 in nzV.\nmove: defV; rewrite (bigID W_0) /= addsmxC -big_filter !(big_nth i0) !big_mkord.\nrewrite addsmxC big1 ?adds0mx_id => [|i /andP[_ /eqP] //].\nset tI := 'I_(_); set r_ := nth _ _ => defV.\nhave{simW} simWr (i : tI) : mxsimple (W (r_ i)).\n  case: i => m /=; set Pr := fun i => _ => lt_m_r /=.\n  suffices: (Pr (r_ m)) by case/andP; apply: simW.\n  apply: all_nthP m lt_m_r; apply/all_filterP.\n  by rewrite -filter_predI; apply: eq_filter => i; rewrite /= andbb.\nhave [J []] := sum_mxsimple_direct_sub simWr defV.\ncase: (set_0Vmem J) => [-> V0 | [j0 Jj0]].\n  by rewrite -mxrank_eq0 -V0 big_set0 mxrank0 in nzV.\npose K := {j | j \\in J}; pose k0 : K := Sub j0 Jj0.\nhave bij_KJ: {on J, bijective (sval : K -> _)}.\n  by exists (insubd k0) => [k _ | j Jj]; rewrite ?valKd ?insubdK.\nhave J_K (k : K) : sval k \\in J by apply: valP k.\nrewrite mxdirectE /= !(reindex _ bij_KJ) !(eq_bigl _ _ J_K) -mxdirectE /= -/tI.\nexact: MxSemisimple.\nQed.",
    "Lemma mxsimple_semisimple U : mxsimple U -> mxsemisimple U.\nProof.\nmove=> simU; apply: (intro_mxsemisimple (_ : \\sum_(i < 1) U :=: U))%MS => //.\nby rewrite big_ord1.\nQed.",
    "Lemma addsmx_semisimple U V :\n  mxsemisimple U -> mxsemisimple V -> mxsemisimple (U + V)%MS.\nProof.\ncase=> [I W /= simW defU _] [J T /= simT defV _].\nhave defUV: (\\sum_ij sum_rect (fun _ => 'M_n) W T ij :=: U + V)%MS.\n  by rewrite big_sumType /=; apply: adds_eqmx.\nby apply: intro_mxsemisimple defUV _; case=> /=.\nQed.",
    "Lemma sumsmx_semisimple (I : finType) (P : pred I) V :\n  (forall i, P i -> mxsemisimple (V i)) -> mxsemisimple (\\sum_(i | P i) V i)%MS.\nProof.\nmove=> ssimV; elim/big_ind: _ => //; first exact: mxsemisimple0.\nexact: addsmx_semisimple.\nQed.",
    "Lemma eqmx_semisimple U V : (U :=: V)%MS -> mxsemisimple U -> mxsemisimple V.\nProof.\nby move=> eqUV [I W S simW defU dxS]; exists I W => //; apply: eqmx_trans eqUV.\nQed.",
    "Lemma hom_mxsemisimple (V f : 'M_n) :\n  mxsemisimple V -> (V <= dom_hom_mx f)%MS -> mxsemisimple (V *m f).\nProof.\ncase=> I W /= simW defV _; rewrite -defV => /sumsmx_subP homWf.\nhave{defV} defVf: (\\sum_i W i *m f :=: V *m f)%MS.\n  by apply: eqmx_trans (eqmx_sym _) (eqmxMr f defV); apply: sumsmxMr.\napply: (intro_mxsemisimple defVf) => i _ nzWf.\nby apply: mx_iso_simple (simW i); apply: mx_Schur_inj_iso; rewrite ?homWf.\nQed.",
    "Lemma mxsemisimple_module U : mxsemisimple U -> mxmodule U.\nProof.\ncase=> I W /= simW defU _.\nby rewrite -(eqmx_module defU) sumsmx_module // => i _; case: (simW i).\nQed.",
    "Lemma mx_reducibleS U V :\n    mxmodule U -> (U <= V)%MS ->\n  mx_completely_reducible V -> mx_completely_reducible U.\nProof.\nmove=> modU sUV redV U1 modU1 sU1U.\nhave [W modW defV dxU1W] := redV U1 modU1 (submx_trans sU1U sUV).\nexists (W :&: U)%MS; first exact: capmx_module.\n  by apply/eqmxP; rewrite !matrix_modl // capmxSr sub_capmx defV sUV /=.\nby apply/mxdirect_addsP; rewrite capmxA (mxdirect_addsP dxU1W) cap0mx.\nQed.",
    "Lemma mx_Maschke_pchar : [pchar F]^'.-group G -> mx_completely_reducible 1%:M.\nProof.\nrewrite /pgroup pcharf'_nat; set nG := _%:R => nzG U => /mxmoduleP Umod _.\npose phi := nG^-1 *: (\\sum_(x in G) rG x^-1 *m pinvmx U *m U *m rG x).\nhave phiG x: x \\in G -> phi *m rG x = rG x *m phi.\n  move=> Gx; rewrite -scalemxAl -scalemxAr; congr (_ *: _).\n  rewrite {2}(reindex_acts 'R _ Gx) ?astabsR //= mulmx_suml mulmx_sumr.\n  apply: eq_bigr => y Gy; rewrite !mulmxA -repr_mxM ?groupV ?groupM //.\n  by rewrite invMg mulKVg repr_mxM ?mulmxA.\nhave Uphi: U *m phi = U.\n  rewrite -scalemxAr mulmx_sumr (eq_bigr (fun _ => U)) => [|x Gx].\n    by rewrite sumr_const -scaler_nat !scalerA  mulVf ?scale1r.\n  by rewrite 3!mulmxA mulmxKpV ?repr_mxKV ?Umod ?groupV.\nhave tiUker: (U :&: kermx phi = 0)%MS.\n  apply/eqP/rowV0P=> v; rewrite sub_capmx => /andP[/submxP[u ->] /sub_kermxP].\n  by rewrite -mulmxA Uphi.\nexists (kermx phi); last exact/mxdirect_addsP.\n  apply/mxmoduleP=> x Gx; apply/sub_kermxP.\n  by rewrite -mulmxA -phiG // mulmxA mulmx_ker mul0mx.\napply/eqmxP; rewrite submx1 sub1mx.\nrewrite /row_full mxrank_disjoint_sum //= mxrank_ker.\nsuffices ->: (U :=: phi)%MS by rewrite subnKC ?rank_leq_row.\napply/eqmxP; rewrite -{1}Uphi submxMl scalemx_sub //.\nby rewrite summx_sub // => x Gx; rewrite -mulmxA mulmx_sub ?Umod.\nQed.",
    "Lemma mxsemisimple_reducible V : mxsemisimple V -> mx_completely_reducible V.\nProof.\ncase=> [I W /= simW defV _] U modU sUV; rewrite -defV in sUV.\nhave [J [defV' dxV]] := sum_mxsimple_direct_compl simW modU sUV.\nexists (\\sum_(i in J) W i)%MS.\n- by apply: sumsmx_module => i _; case: (simW i).\n- exact: eqmx_trans defV' defV.\nby rewrite mxdirect_addsE (sameP eqP mxdirect_addsP) /= in dxV; case/and3P: dxV.\nQed.",
    "Lemma mx_reducible_semisimple V :\n  mxmodule V -> mx_completely_reducible V -> classically (mxsemisimple V).\nProof.\nmove=> modV redV [] // nssimV; have [r leVr] := ubnP (\\rank V).\nelim: r => // r IHr in V leVr modV redV nssimV.\nhave [V0 | nzV] := eqVneq V 0.\n  by rewrite nssimV ?V0 //; apply: mxsemisimple0.\napply: (mxsimple_exists modV nzV) => [[U simU sUV]]; have [modU nzU _] := simU.\nhave [W modW defUW dxUW] := redV U modU sUV.\nhave sWV: (W <= V)%MS by rewrite -defUW addsmxSr.\napply: IHr (mx_reducibleS modW sWV redV) _ => // [|ssimW].\n  rewrite ltnS -defUW (mxdirectP dxUW) /= in leVr; apply: leq_trans leVr.\n  by rewrite -add1n leq_add2r lt0n mxrank_eq0.\napply: nssimV (eqmx_semisimple defUW (addsmx_semisimple _ ssimW)).\nexact: mxsimple_semisimple.\nQed.",
    "Lemma mxsemisimpleS U V :\n  mxmodule U -> (U <= V)%MS -> mxsemisimple V -> mxsemisimple U.\nProof.\nmove=> modU sUV ssimV.\nhave [W modW defUW dxUW]:= mxsemisimple_reducible ssimV modU sUV.\nmove/mxdirect_addsP: dxUW => dxUW.\nhave defU : (V *m proj_mx U W :=: U)%MS.\n  by apply/eqmxP; rewrite proj_mx_sub -{1}[U](proj_mx_id dxUW) ?submxMr.\napply: eqmx_semisimple defU _; apply: hom_mxsemisimple ssimV _.\nby rewrite -defUW proj_mx_hom.\nQed.",
    "Lemma hom_mxsemisimple_iso I P U W f :\n  let V := (\\sum_(i : I |  P i) W i)%MS in\n  mxsimple U -> (forall i, P i -> W i != 0 -> mxsimple (W i)) ->\n  (V <= dom_hom_mx f)%MS -> (U <= V *m f)%MS ->\n  {i | P i & mx_iso (W i) U}.\nProof.\nmove=> V simU simW homVf sUVf; have [modU nzU _] := simU.\nhave ssimVf: mxsemisimple (V *m f).\n  exact: hom_mxsemisimple (intro_mxsemisimple (eqmx_refl V) simW) homVf.\nhave [U' modU' defVf] := mxsemisimple_reducible ssimVf modU sUVf.\nmove/mxdirect_addsP=> dxUU'; pose p := f *m proj_mx U U'.\ncase: (pickP (fun i => P i && (W i *m p != 0))) => [i /andP[Pi nzWip] | no_i].\n  have sWiV: (W i <= V)%MS by rewrite (sumsmx_sup i).\n  have sWipU: (W i *m p <= U)%MS by rewrite mulmxA proj_mx_sub.\n  exists i => //; apply: (mx_Schur_iso (simW i Pi _) simU _ sWipU nzWip).\n    by apply: contraNneq nzWip => ->; rewrite mul0mx.\n  apply: (submx_trans sWiV); apply/hom_mxP=> x Gx.\n  by rewrite mulmxA [_ *m p]mulmxA 2?(hom_mxP _) -?defVf ?proj_mx_hom.\ncase/negP: nzU; rewrite -submx0 -[U](proj_mx_id dxUU') //.\nrewrite (submx_trans (submxMr _ sUVf)) // -mulmxA -/p sumsmxMr.\nby apply/sumsmx_subP=> i Pi; move/negbT: (no_i i); rewrite Pi negbK submx0.\nQed.",
    "Lemma component_mx_module : mxmodule compU.\nProof.\nby rewrite unlock sumsmx_module // => i; rewrite cyclic_mx_module.\nQed.",
    "Lemma genmx_component : <<compU>>%MS = compU.\nProof.\nby rewrite [in compU]unlock genmx_sums; apply: eq_bigr => i; rewrite genmx_id.\nQed.",
    "Lemma component_mx_def : {I : finType & {W : I -> 'M_n |\n  forall i, mx_iso U (W i) & compU = \\sum_i W i}}%MS.\nProof.\npose r i := row i iso_u; pose r_nz i := r i != 0; pose I := {i | r_nz i}.\nexists I; exists (fun i => cyclic_mx (r (sval i))) => [i|].\n  apply/mxsimple_isoP=> //; apply/and3P.\n  split; first by rewrite cyclic_mx_module.\n    apply/rowV0Pn; exists (r (sval i)); last exact: (svalP i).\n    by rewrite sub_capmx cyclic_mx_id row_sub.\n  have [f hom_u_f <-] := @row_hom_mxP u (r (sval i)) (row_sub _ _).\n  by rewrite defU -hom_cyclic_mx ?mxrankM_maxl.\nrewrite -(eq_bigr _ (fun _ _ => genmx_id _)) -genmx_sums -genmx_component.\nrewrite [in compU]unlock; apply/genmxP/andP; split; last first.\n  by apply/sumsmx_subP => i _; rewrite (sumsmx_sup (sval i)).\napply/sumsmx_subP => i _.\ncase i0: (r_nz i); first by rewrite (sumsmx_sup (Sub i i0)).\nby move/negbFE: i0; rewrite -cyclic_mx_eq0 => /eqP->; apply: sub0mx.\nQed.",
    "Lemma component_mx_semisimple : mxsemisimple compU.\nProof.\nhave [I [W isoUW ->]] := component_mx_def.\napply: intro_mxsemisimple (eqmx_refl _) _ => i _ _.\nexact: mx_iso_simple (isoUW i) simU.\nQed.",
    "Lemma mx_iso_component V : mx_iso U V -> (V <= compU)%MS.\nProof.\nmove=> isoUV; have [f injf homUf defV] := isoUV.\nhave simV := mx_iso_simple isoUV simU.\nhave hom_u_f := submx_trans Uu homUf.\nhave ->: (V :=: cyclic_mx (u *m f))%MS.\n  apply: eqmx_trans (hom_cyclic_mx hom_u_f).\n  exact: eqmx_trans (eqmx_sym defV) (eqmxMr _ defU).\nhave iso_uf: (u *m f <= iso_u)%MS by apply/row_hom_mxP; exists f.\nrewrite genmxE; apply/row_subP=> j; rewrite row_mul mul_rV_lin1 /=.\nset a := vec_mx _; apply: submx_trans (submxMr _ iso_uf) _.\napply/row_subP=> i; rewrite row_mul [in compU]unlock (sumsmx_sup i) //.\nby apply/cyclic_mxP; exists a; rewrite // vec_mxK row_sub.\nQed.",
    "Lemma component_mx_id : (U <= compU)%MS.\nProof. exact: mx_iso_component (mx_iso_refl U). Qed.",
    "Lemma hom_component_mx_iso f V :\n    mxsimple V -> (compU <= dom_hom_mx f)%MS -> (V <= compU *m f)%MS ->\n  mx_iso U V.\nProof.\nhave [I [W isoUW ->]] := component_mx_def => simV homWf sVWf.\nhave [i _ _|i _ ] := hom_mxsemisimple_iso simV _ homWf sVWf.\n  exact: mx_iso_simple (simU).\nexact: mx_iso_trans.\nQed.",
    "Lemma component_mx_iso V : mxsimple V -> (V <= compU)%MS -> mx_iso U V.\nProof.\nmove=> simV; rewrite -[compU]mulmx1.\nexact: hom_component_mx_iso (scalar_mx_hom _ _).\nQed.",
    "Lemma hom_component_mx f :\n  (compU <= dom_hom_mx f)%MS -> (compU *m f <= compU)%MS.\nProof.\nmove=> hom_f.\nhave [I W /= simW defW _] := hom_mxsemisimple component_mx_semisimple hom_f.\nrewrite -defW; apply/sumsmx_subP=> i _; apply: mx_iso_component.\nby apply: hom_component_mx_iso hom_f _ => //; rewrite -defW (sumsmx_sup i).\nQed.",
    "Lemma component_mx_isoP U V :\n    mxsimple U -> mxsimple V ->\n  reflect (mx_iso U V) (component_mx U == component_mx V).\nProof.\nmove=> simU simV; apply: (iffP eqP) => isoUV.\n  by apply: component_mx_iso; rewrite ?isoUV ?component_mx_id.\nrewrite -(genmx_component U) -(genmx_component V); apply/genmxP.\nwlog suffices: U V simU simV isoUV / (component_mx U <= component_mx V)%MS.\n  by move=> IH; rewrite !IH //; apply: mx_iso_sym.\nhave [I [W isoWU ->]] := component_mx_def simU.\napply/sumsmx_subP => i _; apply: mx_iso_component => //.\nexact: mx_iso_trans (mx_iso_sym isoUV) (isoWU i).\nQed.",
    "Lemma component_mx_disjoint U V :\n    mxsimple U -> mxsimple V -> component_mx U != component_mx V ->\n  (component_mx U :&: component_mx V = 0)%MS.\nProof.\nmove=> simU simV neUV; apply: contraNeq neUV => ntUV.\napply: (mxsimple_exists _ ntUV) => [|[W simW]].\n  by rewrite capmx_module ?component_mx_module.\nrewrite sub_capmx => /andP[sWU sWV]; apply/component_mx_isoP=> //.\nby apply: mx_iso_trans (_ : mx_iso U W) (mx_iso_sym _); apply: component_mx_iso.\nQed.",
    "Lemma socle_exists : classically socleType.\nProof.\npose V : 'M[F]_n := 0; have: mxsemisimple V by apply: mxsemisimple0.\nhave: n - \\rank V < n.+1 by rewrite mxrank0 subn0.\nelim: _.+1 V => // n' IHn' V; rewrite ltnS => le_nV_n' ssimV.\ncase=> // maxV; apply: (maxV); have [I /= U simU defV _] := ssimV.\nexists (codom U) => [M | M simM]; first by case/mapP=> i _ ->.\nsuffices sMV: (M <= V)%MS.\n  rewrite -defV -(mulmx1 (\\sum_i _)%MS) in sMV.\n  have [//| i _] := hom_mxsemisimple_iso simM _ (scalar_mx_hom _ _) sMV.\n  move/mx_iso_sym=> isoM; apply/hasP.\n  by exists (U i); [apply: codom_f | apply/mxsimple_isoP].\nhave ssimMV := addsmx_semisimple (mxsimple_semisimple simM) ssimV.\napply: contraLR isT => nsMV; apply: IHn' ssimMV _ maxV.\napply: leq_trans le_nV_n'; rewrite ltn_sub2l //.\n  rewrite ltn_neqAle rank_leq_row andbT -[_ == _]sub1mx.\n  by apply: contra nsMV; apply: submx_trans; apply: submx1.\nrewrite (ltn_leqif (mxrank_leqif_sup _)) ?addsmxSr //.\nby rewrite addsmx_sub submx_refl andbT.\nQed.",
    "Lemma component_socle M : mxsimple M -> component_mx M \\in socle_enum.\nProof.\nrewrite /socle_enum; case: sG0 => e0 /= sim_e mem_e simM.\nhave /hasP[M' e0M' isoMM'] := mem_e M simM; apply/mapP; exists M' => //.\nby apply/eqP/component_mx_isoP; [|apply: sim_e | apply/mxsimple_isoP].\nQed.",
    "Lemma socle_simple W : mxsimple (socle_base W).\nProof.\ncase: W => M /=; rewrite /= /socle_enum /=; case: sG0 => e sim_e _ /= e_M.\nby apply: sim_e; rewrite mem_nth // -(size_map component_mx) index_mem.\nQed.",
    "Lemma nz_socle (W : sG) : W != 0 :> 'M_n.\nProof.\nhave simW := socle_simple W; have [_ nzW _] := simW; apply: contra nzW.\nby rewrite -!submx0; apply: submx_trans (component_mx_id simW).\nQed.",
    "Lemma socle_mem (W : sG) : (W : 'M_n) \\in socle_enum.\nProof. exact: component_socle (socle_simple _). Qed.",
    "Lemma PackSocleK W e0W : @PackSocle W e0W = W :> 'M_n.\nProof.\nrewrite /socle_val /= in e0W *; rewrite -(nth_map _ 0) ?nth_index //.\nby rewrite -(size_map component_mx) index_mem.\nQed.",
    "Lemma socleP (W W' : sG) : reflect (W = W') (W == W')%MS.\nProof. by rewrite (sameP genmxP eqP) !{1}genmx_component; apply: (W =P _). Qed.",
    "Lemma subSocle_module : mxmodule S.\nProof. by rewrite sumsmx_module // => W _; apply: component_mx_module. Qed.",
    "Lemma subSocle_semisimple : mxsemisimple S.\nProof.\napply: sumsmx_semisimple => W _; apply: component_mx_semisimple.\nexact: socle_simple.\nQed.",
    "Lemma subSocle_iso M :\n  mxsimple M -> (M <= S)%MS -> {W : sG | P W & mx_iso (socle_base W) M}.\nProof.\nmove=> simM sMS; have [modM nzM _] := simM.\nhave [V /= modV defMV] := mxsemisimple_reducible ssimS modM sMS.\nmove/mxdirect_addsP=> dxMV; pose p := proj_mx M V; pose Sp (W : sG) := W *m p.\ncase: (pickP [pred i | P i & Sp i != 0]) => [/= W | Sp0]; last first.\n  case/negP: nzM; rewrite -submx0 -[M](proj_mx_id dxMV) //.\n  rewrite (submx_trans (submxMr _ sMS)) // sumsmxMr big1 // => W P_W.\n  by apply/eqP; move/negbT: (Sp0 W); rewrite /= P_W negbK.\nrewrite {}/Sp /= => /andP[P_W nzSp]; exists W => //.\nhave homWp: (W <= dom_hom_mx p)%MS.\n  apply: submx_trans (proj_mx_hom dxMV modM modV).\n  by rewrite defMV (sumsmx_sup W).\nhave simWP := socle_simple W; apply: hom_component_mx_iso (homWp) _ => //.\nby rewrite (mx_Schur_onto _ simM) ?proj_mx_sub ?component_mx_module.\nQed.",
    "Lemma capmx_subSocle m (M : 'M_(m, n)) :\n  mxmodule M -> (M :&: S :=: \\sum_(W : sG | P W) (M :&: W))%MS.\nProof.\nmove=> modM; apply/eqmxP/andP; split; last first.\n  by apply/sumsmx_subP=> W P_W; rewrite capmxS // (sumsmx_sup W).\nhave modMS: mxmodule (M :&: S)%MS by rewrite capmx_module ?subSocle_module.\nhave [J /= U simU defMS _] := mxsemisimpleS modMS (capmxSr M S) ssimS.\nrewrite -defMS; apply/sumsmx_subP=> j _.\nhave [sUjV sUjS]: (U j <= M /\\ U j <= S)%MS.\n  by apply/andP; rewrite -sub_capmx -defMS (sumsmx_sup j).\nhave [W P_W isoWU] := subSocle_iso (simU j) sUjS.\nrewrite (sumsmx_sup W) // sub_capmx sUjV mx_iso_component //.\nexact: socle_simple.\nQed.",
    "Lemma subSocle_direct P : mxdirect (\\sum_(W : sG | P W) W).\nProof.\napply/mxdirect_sumsP=> W _; apply/eqP.\nrewrite -submx0 capmx_subSocle ?component_mx_module //.\napply/sumsmx_subP=> W' /andP[_ neWW'].\nby rewrite capmxC component_mx_disjoint //; apply: socle_simple.\nQed.",
    "Lemma simple_Socle M : mxsimple M -> (M <= Socle)%MS.\nProof.\nmove=> simM; have socM := component_socle sG simM.\nby rewrite (sumsmx_sup (PackSocle socM)) // PackSocleK component_mx_id.\nQed.",
    "Lemma semisimple_Socle U : mxsemisimple U -> (U <= Socle)%MS.\nProof.\nby case=> I M /= simM <- _; apply/sumsmx_subP=> i _; apply: simple_Socle.\nQed.",
    "Lemma reducible_Socle U :\n  mxmodule U -> mx_completely_reducible U -> (U <= Socle)%MS.\nProof.\nmove=> modU redU; apply: (mx_reducible_semisimple modU redU).\nexact: semisimple_Socle.\nQed.",
    "Lemma genmx_Socle : <<Socle>>%MS = Socle.\nProof. by rewrite genmx_sums; apply: eq_bigr => W; rewrite genmx_component. Qed.",
    "Lemma reducible_Socle1 : mx_completely_reducible 1%:M -> Socle = 1%:M.\nProof.\nmove=> redG; rewrite -genmx1 -genmx_Socle; apply/genmxP.\nby rewrite submx1 reducible_Socle ?mxmodule1.\nQed.",
    "Lemma Socle_module : mxmodule Socle. Proof. exact: subSocle_module. Qed.",
    "Lemma Socle_semisimple : mxsemisimple Socle.\nProof. exact: subSocle_semisimple. Qed.",
    "Lemma Socle_direct : mxdirect Socle. Proof. exact: subSocle_direct. Qed.",
    "Lemma Socle_iso M : mxsimple M -> {W : sG | mx_iso (socle_base W) M}.\nProof.\nby move=> simM; case/subSocle_iso: (simple_Socle simM) => // W _; exists W.\nQed.",
    "Lemma row_full_dom_hom : row_full (dom_hom_mx f) = centgmx rG f.\nProof.\nby rewrite -sub1mx; apply/hom_mxP/centgmxP=> cfG x /cfG; rewrite !mul1mx.\nQed.",
    "Lemma memmx_cent_envelop : (f \\in 'C(E_G))%MS = centgmx rG f.\nProof.\napply/cent_rowP/centgmxP=> [cfG x Gx | cfG i].\n  by have:= cfG (enum_rank_in Gx x); rewrite rowK mxvecK enum_rankK_in.\nby rewrite rowK mxvecK /= cfG ?enum_valP.\nQed.",
    "Lemma kermx_centg_module : centgmx rG f -> mxmodule (kermx f).\nProof.\nmove/centgmxP=> cGf; apply/mxmoduleP=> x Gx; apply/sub_kermxP.\nby rewrite -mulmxA -cGf // mulmxA mulmx_ker mul0mx.\nQed.",
    "Lemma centgmx_hom m (U : 'M_(m, n)) : centgmx rG f -> (U <= dom_hom_mx f)%MS.\nProof. by rewrite -row_full_dom_hom -sub1mx; apply: submx_trans (submx1 _). Qed.",
    "Lemma mx_irrP :\n  mx_irreducible <-> n > 0 /\\ (forall U, @mxmodule n U -> U != 0 -> row_full U).\nProof.\nrewrite /mx_irreducible /mxsimple mxmodule1 -mxrank_eq0 mxrank1 -lt0n.\ndo [split=> [[_ -> irrG] | [-> irrG]]; split=> // U] => [modU | modU _] nzU.\n  by rewrite -sub1mx (irrG U) ?submx1.\nby rewrite sub1mx irrG.\nQed.",
    "Lemma mx_Schur :\n  mx_irreducible -> forall f, centgmx rG f -> f != 0 -> f \\in unitmx.\nProof.\nmove/mx_Schur_onto=> irrG f.\nrewrite -row_full_dom_hom -!row_full_unit -!sub1mx => cGf nz.\nby rewrite -[f]mul1mx irrG ?submx1 ?mxmodule1 ?mul1mx.\nQed.",
    "Lemma mx_abs_irrP :\n  reflect (n > 0 /\\ exists a_, forall A, A = \\sum_(x in G) a_ x A *: rG x)\n          mx_absolutely_irreducible.\nProof.\nhave G_1 := group1 G; have bijG := enum_val_bij_in G_1.\nset h := enum_val in bijG; have Gh : h _ \\in G by apply: enum_valP.\nrewrite /mx_absolutely_irreducible; case: (n > 0); last by right; case.\napply: (iffP row_fullP) => [[E' E'G] | [_ [a_ a_G]]].\n  split=> //; exists (fun x B => (mxvec B *m E') 0 (enum_rank_in G_1 x)) => B.\n  apply: (can_inj mxvecK); rewrite -{1}[mxvec B]mulmx1 -{}E'G mulmxA.\n  move: {B E'}(_ *m E') => u; apply/rowP=> j.\n  rewrite linear_sum (reindex h) //= mxE summxE.\n  by apply: eq_big => [k| k _]; rewrite ?Gh // enum_valK_in linearZ !mxE.\nexists (\\matrix_(j, i) a_ (h i) (vec_mx (row j 1%:M))).\napply/row_matrixP=> i; rewrite -[row i 1%:M]vec_mxK {}[vec_mx _]a_G.\napply/rowP=> j; rewrite linear_sum (reindex h) //= 2!mxE summxE.\nby apply: eq_big => [k| k _]; [rewrite Gh | rewrite linearZ !mxE].\nQed.",
    "Lemma mx_abs_irr_cent_scalar :\n  mx_absolutely_irreducible -> forall A, centgmx rG A -> is_scalar_mx A.\nProof.\ncase/mx_abs_irrP=> n_gt0 [a_ a_G] A /centgmxP cGA.\nhave{cGA a_G} cMA B: A *m B = B *m A.\n  rewrite {}[B]a_G mulmx_suml mulmx_sumr.\n  by apply: eq_bigr => x Gx; rewrite -scalemxAl -scalemxAr cGA.\npose i0 := Ordinal n_gt0; apply/is_scalar_mxP; exists (A i0 i0).\napply/matrixP=> i j; move/matrixP/(_ i0 j): (esym (cMA (delta_mx i0 i))).\nrewrite -[A *m _]trmxK trmx_mul trmx_delta -!(@mul_delta_mx _ n 1 n 0) -!mulmxA.\nby rewrite -!rowE !mxE !big_ord1 !mxE !eqxx !mulr_natl /= andbT eq_sym.\nQed.",
    "Lemma mx_abs_irrW : mx_absolutely_irreducible -> mx_irreducible.\nProof.\ncase/mx_abs_irrP=> n_gt0 [a_ a_G]; apply/mx_irrP; split=> // U Umod.\ncase/rowV0Pn=> u Uu; rewrite -mxrank_eq0 -lt0n row_leq_rank -sub1mx.\ncase/submxP: Uu => v ->{u} /row_freeP[u' vK]; apply/row_subP=> i.\nrewrite rowE scalar_mxC -{}vK -2![_ *m _]mulmxA; move: {u' i}(u' *m _) => A.\nrewrite mulmx_sub {v}// [A]a_G linear_sum summx_sub //= => x Gx.\nby rewrite -scalemxAr scalemx_sub // (mxmoduleP Umod).\nQed.",
    "Lemma linear_mx_abs_irr : n = 1 -> mx_absolutely_irreducible.\nProof.\nmove=> n1; rewrite /mx_absolutely_irreducible /row_full eqn_leq rank_leq_col.\nrewrite {1 2 3}n1 /= lt0n mxrank_eq0; apply: contraTneq envelop_mx1 => ->.\nby rewrite eqmx0 submx0 mxvec_eq0 -mxrank_eq0 mxrank1 n1.\nQed.",
    "Lemma abelian_abs_irr : abelian G -> mx_absolutely_irreducible = (n == 1).\nProof.\nmove=> cGG; apply/idP/eqP=> [absG|]; last exact: linear_mx_abs_irr.\nhave [n_gt0 _] := andP absG.\npose M := <<delta_mx 0 (Ordinal n_gt0) : 'rV[F]_n>>%MS.\nhave rM: \\rank M = 1 by rewrite genmxE mxrank_delta.\nsuffices defM: (M == 1%:M)%MS by rewrite (eqmxP defM) mxrank1 in rM.\ncase: (mx_abs_irrW absG) => _ _ ->; rewrite ?submx1 -?mxrank_eq0 ?rM //.\napply/mxmoduleP=> x Gx; suffices: is_scalar_mx (rG x).\n  by case/is_scalar_mxP=> a ->; rewrite mul_mx_scalar scalemx_sub.\napply: (mx_abs_irr_cent_scalar absG).\nby apply/centgmxP=> y Gy; rewrite -!repr_mxM // (centsP cGG).\nQed.",
    "Lemma envelop_mx_ring : mxring (enveloping_algebra_mx rG).\nProof.\napply/andP; split; first by apply/mulsmx_subP; apply: envelop_mxM.\napply/mxring_idP; exists 1%:M; split=> *; rewrite ?mulmx1 ?mul1mx //.\n  by rewrite -mxrank_eq0 mxrank1.\nexact: envelop_mx1.\nQed.",
    "Lemma mx_Jacobson_density : ('C(Hom_G) <= E_G)%MS.\nProof.\napply/row_subP=> iB; rewrite -[row iB _]vec_mxK; move defB: (vec_mx _) => B.\nhave{defB} cBcE: (B \\in 'C(Hom_G))%MS by rewrite -defB vec_mxK row_sub.\nhave rGnP: mx_repr G (fun x => lin_mx (mulmxr (rG x)) : 'A_n).\n  split=> [|x y Gx Gy]; apply/row_matrixP=> i.\n    by rewrite !rowE mul_rV_lin repr_mx1 /= !mulmx1 vec_mxK.\n  by rewrite !rowE mulmxA !mul_rV_lin repr_mxM //= mxvecK mulmxA.\nmove def_rGn: (MxRepresentation rGnP) => rGn.\npose E_Gn := enveloping_algebra_mx rGn.\npose e1 : 'rV[F]_(n ^ 2) := mxvec 1%:M; pose U := cyclic_mx rGn e1.\nhave U_e1: (e1 <= U)%MS by rewrite cyclic_mx_id.\nhave modU: mxmodule rGn U by rewrite cyclic_mx_module.\npose Bn : 'M_(n ^ 2) := lin_mx (mulmxr B).\nsuffices U_e1Bn: (e1 *m Bn <= U)%MS.\n  rewrite mul_vec_lin /= mul1mx in U_e1Bn; apply: submx_trans U_e1Bn _.\n  rewrite genmxE; apply/row_subP=> i; rewrite row_mul rowK mul_vec_lin_row.\n  by rewrite -def_rGn mul_vec_lin /= mul1mx (eq_row_sub i) ?rowK.\nhave{cBcE} cBncEn A: centgmx rGn A -> A *m Bn = Bn *m A.\n  rewrite -def_rGn => cAG; apply/row_matrixP; case/mxvec_indexP=> j k /=.\n  rewrite !rowE !mulmxA -mxvec_delta -(mul_delta_mx (0 : 'I_1)).\n  rewrite mul_rV_lin mul_vec_lin /= -mulmxA; apply: (canLR vec_mxK).\n  apply/row_matrixP=> i; set dj0 := delta_mx j 0.\n  have /= defAij :=\n    mul_rV_lin1 (row i \\o vec_mx \\o mulmxr A \\o mxvec \\o mulmx dj0).\n  rewrite -defAij row_mul -defAij -!mulmxA (cent_mxP cBcE) {k}//.\n  rewrite memmx_cent_envelop; apply/centgmxP=> x Gx; apply/row_matrixP=> k.\n  rewrite !row_mul !rowE !{}defAij /= -row_mul mulmxA mul_delta_mx.\n  congr (row i _); rewrite -(mul_vec_lin (mulmxr (rG x))) -mulmxA.\n  by rewrite -(centgmxP cAG) // mulmxA mx_rV_lin.\nsuffices redGn: mx_completely_reducible rGn 1%:M.\n  have [V modV defUV] := redGn _ modU (submx1 _); move/mxdirect_addsP=> dxUV.\n  rewrite -(proj_mx_id dxUV U_e1) -mulmxA {}cBncEn 1?mulmxA ?proj_mx_sub //.\n  by rewrite -row_full_dom_hom -sub1mx -defUV proj_mx_hom.\npose W i : 'M[F]_(n ^ 2) := <<lin1_mx (mxvec \\o mulmx (delta_mx i 0))>>%MS.\nhave defW: (\\sum_i W i :=: 1%:M)%MS.\n  apply/eqmxP; rewrite submx1; apply/row_subP; case/mxvec_indexP=> i j.\n  rewrite row1 -mxvec_delta (sumsmx_sup i) // genmxE; apply/submxP.\n  by exists (delta_mx 0 j); rewrite mul_rV_lin1 /= mul_delta_mx.\napply: mxsemisimple_reducible; apply: (intro_mxsemisimple defW) => i _ nzWi.\nsplit=> // [|Vi modVi sViWi nzVi].\n  apply/mxmoduleP=> x Gx; rewrite genmxE (eqmxMr _ (genmxE _)) -def_rGn.\n  apply/row_subP=> j; rewrite rowE mulmxA !mul_rV_lin1 /= mxvecK -mulmxA.\n  by apply/submxP; move: (_ *m rG x) => v; exists v; rewrite mul_rV_lin1.\ndo [rewrite !genmxE; set f := lin1_mx _] in sViWi *.\nhave f_free: row_free f.\n  apply/row_freeP; exists (lin1_mx (row i \\o vec_mx)); apply/row_matrixP=> j.\n  by rewrite row1 rowE mulmxA !mul_rV_lin1 /= mxvecK rowE !mul_delta_mx.\npose V := <<Vi *m pinvmx f>>%MS; have Vidf := mulmxKpV sViWi.\nsuffices: (1%:M <= V)%MS by rewrite genmxE -(submxMfree _ _ f_free) mul1mx Vidf.\ncase: irrG => _ _ ->; rewrite ?submx1 //; last first.\n  by rewrite -mxrank_eq0 genmxE -(mxrankMfree _ f_free) Vidf mxrank_eq0.\napply/mxmoduleP=> x Gx; rewrite genmxE (eqmxMr _ (genmxE _)).\nrewrite -(submxMfree _ _ f_free) Vidf.\napply: submx_trans (mxmoduleP modVi x Gx); rewrite -{2}Vidf.\napply/row_subP=> j; apply: (eq_row_sub j); rewrite row_mul -def_rGn.\nby rewrite !(row_mul _ _ f) !mul_rV_lin1 /= mxvecK !row_mul !mulmxA.\nQed.",
    "Lemma cent_mx_scalar_abs_irr : \\rank Hom_G <= 1 -> mx_absolutely_irreducible rG.\nProof.\nrewrite leqNgt => /(has_non_scalar_mxP (scalar_mx_cent _ _)) scal_cE.\napply/andP; split; first by case/mx_irrP: irrG.\nrewrite -sub1mx; apply: submx_trans mx_Jacobson_density.\napply/memmx_subP=> B _; apply/cent_mxP=> A cGA.\ncase scalA: (is_scalar_mx A); last by case: scal_cE; exists A; rewrite ?scalA.\nby case/is_scalar_mxP: scalA => a ->; rewrite scalar_mxC.\nQed.",
    "Lemma rfix_subg : rfix_mx rH = rfix_mx rG. Proof. by []. Qed.",
    "Lemma rstabs_subg : rstabs rH U = H :&: rstabs rG U.\nProof. by apply/setP=> x; rewrite !inE andbA -in_setI (setIidPl sHG). Qed.",
    "Lemma mxmodule_subg : mxmodule rG U -> mxmodule rH U.\nProof. by rewrite /mxmodule rstabs_subg subsetI subxx; apply: subset_trans. Qed.",
    "Lemma mxsimple_subg M : mxmodule rG M -> mxsimple rH M -> mxsimple rG M.\nProof.\nby move=> modM [_ nzM minM]; split=> // U /mxmodule_subg; apply: minM.\nQed.",
    "Lemma subg_mx_irr : mx_irreducible rH -> mx_irreducible rG.\nProof. by apply: mxsimple_subg; apply: mxmodule1. Qed.",
    "Lemma subg_mx_abs_irr :\n   mx_absolutely_irreducible rH -> mx_absolutely_irreducible rG.\nProof.\nrewrite /mx_absolutely_irreducible -!sub1mx => /andP[-> /submx_trans-> //].\napply/row_subP=> i; rewrite rowK /= envelop_mx_id //.\nby rewrite (subsetP sHG) ?enum_valP.\nQed.",
    "Lemma rfix_eqg : rfix_mx rH = rfix_mx rG. Proof. by []. Qed.",
    "Lemma rstabs_eqg : rstabs rH U = rstabs rG U.\nProof. by rewrite rstabs_subg -(eqP eqGH) (setIidPr _) ?rstabs_sub. Qed.",
    "Lemma mxmodule_eqg : mxmodule rH U = mxmodule rG U.\nProof. by rewrite /mxmodule rstabs_eqg -(eqP eqGH). Qed.",
    "Lemma mxsimple_eqg M : mxsimple rH M <-> mxsimple rG M.\nProof.\nrewrite /mxsimple mxmodule_eqg.\nsplit=> [] [-> -> minM]; split=> // U modU;\n by apply: minM; rewrite mxmodule_eqg in modU *.\nQed.",
    "Lemma eqg_mx_irr : mx_irreducible rH <-> mx_irreducible rG.\nProof. exact: mxsimple_eqg. Qed.",
    "Lemma eqg_mx_abs_irr :\n  mx_absolutely_irreducible rH = mx_absolutely_irreducible rG.\nProof.\nby congr (_ && (_ == _)); rewrite /enveloping_algebra_mx /= -(eqP eqGH).\nQed.",
    "Lemma rstabs_morphpre : rstabs rGf U = f @*^-1 (rstabs rG U).\nProof. by apply/setP=> x; rewrite !inE andbA. Qed.",
    "Lemma mxmodule_morphpre : G \\subset f @* D -> mxmodule rGf U = mxmodule rG U.\nProof. by move=> sGf; rewrite /mxmodule rstabs_morphpre morphpreSK. Qed.",
    "Lemma rfix_morphpre (H : {set aT}) :\n  H \\subset D -> (rfix_mx rGf H :=: rfix_mx rG (f @* H))%MS.\nProof.\nmove=> sHD; apply/eqmxP/andP; split.\n  by apply/rfix_mxP=> _ /morphimP[x _ Hx ->]; rewrite rfix_mx_id.\nby apply/rfix_mxP=> x Hx; rewrite rfix_mx_id ?mem_morphim ?(subsetP sHD).\nQed.",
    "Lemma morphpre_mx_irr :\n  G \\subset f @* D -> (mx_irreducible rGf <-> mx_irreducible rG).\nProof.\nmove/mxmodule_morphpre=> modG; split=> /mx_irrP[n_gt0 irrG];\n by apply/mx_irrP; split=> // U modU; apply: irrG; rewrite modG in modU *.\nQed.",
    "Lemma morphpre_mx_abs_irr :\n    G \\subset f @* D ->\n  mx_absolutely_irreducible rGf = mx_absolutely_irreducible rG.\nProof.\nmove=> sGfD; congr (_ && (_ == _)); apply/eqP; rewrite mxrank_leqif_sup //.\n  apply/row_subP=> i; rewrite rowK.\n  case/morphimP: (subsetP sGfD _ (enum_valP i)) => x Dx _ def_i.\n  by rewrite def_i (envelop_mx_id rGf) // !inE Dx -def_i enum_valP.\napply/row_subP=> i; rewrite rowK (envelop_mx_id rG) //.\nby case/morphpreP: (enum_valP i).\nQed.",
    "Lemma rstabs_morphim : rstabs rG U = G :&: f @*^-1 rstabs rGf U.\nProof. by rewrite -rstabs_morphpre -(rstabs_subg _ sG_f'fG). Qed.",
    "Lemma mxmodule_morphim : mxmodule rG U = mxmodule rGf U.\nProof. by rewrite /mxmodule rstabs_morphim subsetI subxx -sub_morphim_pre. Qed.",
    "Lemma rfix_morphim (H : {set aT}) :\n  H \\subset D -> (rfix_mx rG H :=: rfix_mx rGf (f @* H))%MS.\nProof. exact: rfix_morphpre. Qed.",
    "Lemma mxsimple_morphim M : mxsimple rG M <-> mxsimple rGf M.\nProof.\nrewrite /mxsimple mxmodule_morphim.\nsplit=> [] [-> -> minM]; split=> // U modU;\n  by apply: minM; rewrite mxmodule_morphim in modU *.\nQed.",
    "Lemma morphim_mx_irr : (mx_irreducible rG <-> mx_irreducible rGf).\nProof. exact: mxsimple_morphim. Qed.",
    "Lemma morphim_mx_abs_irr :\n  mx_absolutely_irreducible rG = mx_absolutely_irreducible rGf.\nProof.\nhave fG_onto: f @* G \\subset restrm sGD f @* G.\n  by rewrite morphim_restrm setIid.\nrewrite -(morphpre_mx_abs_irr _ fG_onto); congr (_ && (_ == _)).\nby rewrite /enveloping_algebra_mx /= morphpre_restrm (setIidPl _).\nQed.",
    "Lemma rfix_submod (H : {set gT}) :\n  H \\subset G -> (rfix_mx rU H :=: in_submod U (U :&: rfix_mx rG H))%MS.\nProof.\nmove=> sHG; apply/eqmxP/andP; split; last first.\n  apply/rfix_mxP=> x Hx; rewrite -in_submodJ ?capmxSl //.\n  by rewrite (rfix_mxP H _) ?capmxSr.\nrewrite -val_submodS in_submodK ?capmxSl // sub_capmx val_submodP //=.\napply/rfix_mxP=> x Hx.\nby rewrite -(val_submodJ Umod) ?(subsetP sHG) ?rfix_mx_id.\nQed.",
    "Lemma rfix_factmod (H : {set gT}) :\n  H \\subset G -> (in_factmod U (rfix_mx rG H) <= rfix_mx rU' H)%MS.\nProof.\nmove=> sHG; apply/rfix_mxP=> x Hx.\nby rewrite -(in_factmodJ Umod) ?(subsetP sHG) ?rfix_mx_id.\nQed.",
    "Lemma rstab_submod m (W : 'M_(m, \\rank U)) :\n  rstab rU W = rstab rG (val_submod W).\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nby rewrite -(inj_eq val_submod_inj) val_submodJ.\nQed.",
    "Lemma rstabs_submod m (W : 'M_(m, \\rank U)) :\n  rstabs rU W = rstabs rG (val_submod W).\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nby rewrite -val_submodS val_submodJ.\nQed.",
    "Lemma val_submod_module m (W : 'M_(m, \\rank U)) :\n   mxmodule rG (val_submod W) = mxmodule rU W.\nProof. by rewrite /mxmodule rstabs_submod. Qed.",
    "Lemma in_submod_module m (V : 'M_(m, n)) :\n  (V <= U)%MS -> mxmodule rU (in_submod U V) = mxmodule rG V.\nProof. by move=> sVU; rewrite -val_submod_module in_submodK. Qed.",
    "Lemma rstab_factmod m (W : 'M_(m, n)) :\n  rstab rG W \\subset rstab rU' (in_factmod U W).\nProof.\nby apply/subsetP=> x /setIdP[Gx /eqP cUW]; rewrite inE Gx -in_factmodJ //= cUW.\nQed.",
    "Lemma rstabs_factmod m (W : 'M_(m, \\rank (cokermx U))) :\n  rstabs rU' W = rstabs rG (U + val_factmod W)%MS.\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nrewrite addsmxMr addsmx_sub (submx_trans (mxmoduleP Umod x Gx)) ?addsmxSl //.\nrewrite -val_factmodS val_factmodJ //= val_factmodS; apply/idP/idP=> nWx.\n  rewrite (submx_trans (addsmxSr U _)) // -(in_factmodsK (addsmxSl U _)) //.\n  by rewrite addsmxS // val_factmodS in_factmod_addsK.\nrewrite in_factmodE (submx_trans (submxMr _ nWx)) // -in_factmodE.\nby rewrite in_factmod_addsK val_factmodK.\nQed.",
    "Lemma val_factmod_module m (W : 'M_(m, \\rank (cokermx U))) :\n  mxmodule rG (U + val_factmod W)%MS = mxmodule rU' W.\nProof. by rewrite /mxmodule rstabs_factmod. Qed.",
    "Lemma in_factmod_module m (V : 'M_(m, n)) :\n  mxmodule rU' (in_factmod U V) = mxmodule rG (U + V)%MS.\nProof.\nrewrite -(eqmx_module _ (in_factmodsK (addsmxSl U V))).\nby rewrite val_factmod_module (eqmx_module _ (in_factmod_addsK _ _)).\nQed.",
    "Lemma rker_submod : rker rU = rstab rG U.\nProof. by rewrite /rker rstab_submod; apply: eqmx_rstab (val_submod1 U). Qed.",
    "Lemma rstab_norm : G \\subset 'N(rstab rG U).\nProof. by rewrite -rker_submod rker_norm. Qed.",
    "Lemma rstab_normal : rstab rG U <| G.\nProof. by rewrite -rker_submod rker_normal. Qed.",
    "Lemma submod_mx_faithful : mx_faithful rU -> mx_faithful rG.\nProof. by apply: subset_trans; rewrite rker_submod rstabS ?submx1. Qed.",
    "Lemma rker_factmod : rker rG \\subset rker rU'.\nProof.\napply/subsetP=> x /rkerP[Gx cVx].\nby rewrite inE Gx /= /factmod_mx cVx mul1mx mulmx1 val_factmodK.\nQed.",
    "Lemma factmod_mx_faithful : mx_faithful rU' -> mx_faithful rG.\nProof. exact: subset_trans rker_factmod. Qed.",
    "Lemma submod_mx_irr : mx_irreducible rU <-> mxsimple rG U.\nProof.\nsplit=> [] [_ nzU simU].\n  rewrite -mxrank_eq0 mxrank1 mxrank_eq0 in nzU; split=> // V modV sVU nzV.\n  rewrite -(in_submodK sVU) -val_submod1 val_submodS.\n  rewrite -(genmxE (in_submod U V)) simU ?genmxE ?submx1 //=.\n    by rewrite (eqmx_module _ (genmxE _)) in_submod_module.\n  by rewrite -submx0 genmxE -val_submodS in_submodK // linear0 eqmx0 submx0.\napply/mx_irrP; rewrite lt0n mxrank_eq0; split=> // V modV.\nrewrite -(inj_eq val_submod_inj) linear0 -(eqmx_eq0 (genmxE _)) => nzV.\nrewrite -sub1mx -val_submodS val_submod1 -(genmxE (val_submod V)).\nrewrite simU ?genmxE ?val_submodP //=.\nby rewrite (eqmx_module _ (genmxE _)) val_submod_module.\nQed.",
    "Lemma rfix_conj (H : {set gT}) :\n   (rfix_mx rGB H :=: B *m rfix_mx rG H *m invmx B)%MS.\nProof.\napply/eqmxP/andP; split.\n  rewrite -mulmxA (eqmxMfull (_ *m _)) ?row_full_unit //.\n  rewrite -[rfix_mx rGB H](mulmxK uB) submxMr //; apply/rfix_mxP=> x Hx.\n  apply: (canRL (mulmxKV uB)); rewrite -(rconj_mxJ _ uB) mulmxK //.\n  by rewrite rfix_mx_id.\napply/rfix_mxP=> x Gx; rewrite -3!mulmxA; congr (_ *m _).\nby rewrite !mulmxA mulmxKV // rfix_mx_id.\nQed.",
    "Lemma rstabs_conj m (U : 'M_(m, n)) : rstabs rGB U = rstabs rG (U *m B).\nProof.\napply/setP=> x; rewrite !inE rconj_mxE !mulmxA.\nby rewrite -{2}[U](mulmxK uB) submxMfree // row_free_unit unitmx_inv.\nQed.",
    "Lemma mxmodule_conj m (U : 'M_(m, n)) : mxmodule rGB U = mxmodule rG (U *m B).\nProof. by rewrite /mxmodule rstabs_conj. Qed.",
    "Lemma conj_mx_irr : mx_irreducible rGB <-> mx_irreducible rG.\nProof.\nhave Bfree: row_free B by rewrite row_free_unit.\nsplit => /mx_irrP[n_gt0 irrG]; apply/mx_irrP; split=> // U.\n  rewrite -[U](mulmxKV uB) -mxmodule_conj -mxrank_eq0 /row_full mxrankMfree //.\n  by rewrite mxrank_eq0; apply: irrG.\nrewrite -mxrank_eq0 /row_full -(mxrankMfree _ Bfree) mxmodule_conj mxrank_eq0.\nexact: irrG.\nQed.",
    "Lemma quo_mx_quotient : (E_ rGH :=: E_ rG)%MS.\nProof.\napply/eqmxP/andP; split; apply/row_subP=> i.\n  rewrite rowK; case/morphimP: (enum_valP i) => x _ Gx ->{i}.\n  rewrite quo_repr_coset // (eq_row_sub (enum_rank_in Gx x)) // rowK.\n  by rewrite enum_rankK_in.\nrewrite rowK -(quo_mx_coset krH nHG) ?enum_valP //; set Hx := coset H _.\nhave GHx: Hx \\in (G / H)%g by rewrite mem_quotient ?enum_valP.\nby rewrite (eq_row_sub (enum_rank_in GHx Hx)) // rowK enum_rankK_in.\nQed.",
    "Lemma rfix_quo (K : {group gT}) :\n  K \\subset G -> (rfix_mx rGH (K / H)%g :=: rfix_mx rG K)%MS.\nProof.\nmove=> sKG; apply/eqmxP/andP; (split; apply/rfix_mxP) => [x Kx | Hx].\n  have Gx := subsetP sKG x Kx; rewrite -(quo_mx_coset krH nHG) // rfix_mx_id //.\n  by rewrite mem_morphim ?(subsetP nHG).\ncase/morphimP=> x _ Kx ->; have Gx := subsetP sKG x Kx.\nby rewrite quo_repr_coset ?rfix_mx_id.\nQed.",
    "Lemma rstabs_quo m (U : 'M_(m, n)) : rstabs rGH U = (rstabs rG U / H)%g.\nProof.\napply/setP=> Hx /[!inE]; apply/andP/idP=> [[]|] /morphimP[x Nx Gx ->{Hx}].\n  by rewrite quo_repr_coset // => nUx; rewrite mem_morphim // inE Gx.\nby case/setIdP: Gx => Gx nUx; rewrite quo_repr_coset ?mem_morphim.\nQed.",
    "Lemma mxmodule_quo m (U : 'M_(m, n)) : mxmodule rGH U = mxmodule rG U.\nProof.\nrewrite /mxmodule rstabs_quo quotientSGK // ?(subset_trans krH) //.\nby apply/subsetP=> x /[!inE]/andP[-> /[1!mul1mx]/eqP->/=]; rewrite mulmx1.\nQed.",
    "Lemma quo_mx_irr : mx_irreducible rGH <-> mx_irreducible rG.\nProof.\nsplit; case/mx_irrP=> n_gt0 irrG; apply/mx_irrP; split=> // U modU;\n  by apply: irrG; rewrite mxmodule_quo in modU *.\nQed.",
    "Lemma quotient_splitting_field gT (G : {group gT}) (H : {set gT}) :\n  G \\subset 'N(H) -> group_splitting_field G -> group_splitting_field (G / H).\nProof.\nmove=> nHG splitG n rGH irrGH.\nby rewrite -(morphim_mx_abs_irr _ nHG) splitG //; apply/morphim_mx_irr.\nQed.",
    "Lemma coset_splitting_field gT (H : {set gT}) :\n  group_closure_field gT -> group_closure_field (coset_of H).\nProof.\nmove=> split_gT Gbar; have ->: Gbar = (coset H @*^-1 Gbar / H)%G.\n  by apply: val_inj; rewrite /= /quotient morphpreK ?sub_im_coset.\nby apply: quotient_splitting_field; [apply: subsetIl | apply: split_gT].\nQed.",
    "Lemma mx_faithful_irr_center_cyclic n (rG : mx_representation F G n) :\n  mx_faithful rG -> mx_irreducible rG -> cyclic 'Z(G).\nProof.\ncase: n rG => [|n] rG injG irrG; first by case/mx_irrP: irrG.\nmove/trivgP: injG => KrG1; pose rZ := subg_repr rG (center_sub _).\napply: (div_ring_mul_group_cyclic (repr_mx1 rZ)) (repr_mxM rZ) _ _; last first.\n  exact: center_abelian.\nmove=> x; rewrite -[[set _]]KrG1 !inE mul1mx -subr_eq0 andbC; set U := _ - _.\ndo 2![case/andP]=> Gx cGx; rewrite Gx /=; apply: (mx_Schur irrG).\napply/centgmxP=> y Gy; rewrite mulmxBl mulmxBr mulmx1 mul1mx.\nby rewrite -!repr_mxM // (centP cGx).\nQed.",
    "Lemma mx_faithful_irr_abelian_cyclic n (rG : mx_representation F G n) :\n  mx_faithful rG -> mx_irreducible rG -> abelian G -> cyclic G.\nProof.\nmove=> injG irrG cGG; rewrite -(setIidPl cGG).\nexact: mx_faithful_irr_center_cyclic injG irrG.\nQed.",
    "Lemma mx_irr_abelian_linear n (rG : mx_representation F G n) :\n  mx_irreducible rG -> abelian G -> n = 1.\nProof.\nby move=> irrG cGG; apply/eqP; rewrite -(abelian_abs_irr rG) ?splitG.\nQed.",
    "Lemma mxsimple_abelian_linear n (rG : mx_representation F G n) M :\n  abelian G -> mxsimple rG M -> \\rank M = 1.\nProof.\nmove=> cGG simM; have [modM _ _] := simM.\nby move/(submod_mx_irr modM)/mx_irr_abelian_linear: simM => ->.\nQed.",
    "Lemma linear_mxsimple n (rG : mx_representation F G n) (M : 'M_n) :\n  mxmodule rG M -> \\rank M = 1 -> mxsimple rG M.\nProof.\nmove=> modM rM1; apply/(submod_mx_irr modM).\nby apply: mx_abs_irrW; rewrite linear_mx_abs_irr.\nQed.",
    "Lemma center_kquo_cyclic : mx_irreducible rG -> cyclic 'Z(G / rker rG)%g.\nProof.\nmove=> irrG; apply: mx_faithful_irr_center_cyclic (kquo_mx_faithful rG) _.\nexact/quo_mx_irr.\nQed.",
    "Lemma der1_sub_rker :\n    group_splitting_field G -> mx_irreducible rG ->\n  (G^`(1) \\subset rker rG)%g = (n == 1)%N.\nProof.\nmove=> splitG irrG; apply/idP/idP; last by move/eqP; apply: rker_linear.\nmove/sub_der1_abelian; move/(abelian_abs_irr (kquo_repr rG))=> <-.\nby apply: (quotient_splitting_field (rker_norm _) splitG); apply/quo_mx_irr.\nQed.",
    "Lemma mxrank_rsim n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> n1 = n2.\nProof. by case. Qed.",
    "Lemma mx_rsim_refl n (rG : reprG n) : mx_rsim rG rG.\nProof.\nexists 1%:M => // [|x _]; first by rewrite row_free_unit unitmx1.\nby rewrite mulmx1 mul1mx.\nQed.",
    "Lemma mx_rsim_sym n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 ->  mx_rsim rG2 rG1.\nProof.\ncase=> B def_n1; rewrite def_n1 in rG1 B *.\nrewrite row_free_unit => injB homB; exists (invmx B) => // [|x Gx].\n  by rewrite row_free_unit unitmx_inv.\nby apply: canRL (mulKmx injB) _; rewrite mulmxA -homB ?mulmxK.\nQed.",
    "Lemma mx_rsim_trans n1 n2 n3\n                    (rG1 : reprG n1) (rG2 : reprG n2) (rG3 : reprG n3) :\n  mx_rsim rG1 rG2 -> mx_rsim rG2 rG3 -> mx_rsim rG1 rG3.\nProof.\ncase=> [B1 defn1 freeB1 homB1] [B2 defn2 freeB2 homB2].\nexists (B1 *m B2); rewrite /row_free ?mxrankMfree 1?defn1 // => x Gx.\nby rewrite mulmxA homB1 // -!mulmxA homB2.\nQed.",
    "Lemma mx_rsim_def n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n    mx_rsim rG1 rG2 ->\n  exists B, exists2 B', B' *m B = 1%:M &\n    forall x, x \\in G -> rG1 x = B *m rG2 x *m B'.\nProof.\ncase=> B def_n1; rewrite def_n1 in rG1 B *; rewrite row_free_unit => injB homB.\nby exists B, (invmx B) => [|x Gx]; rewrite ?mulVmx // -homB // mulmxK.\nQed.",
    "Lemma mx_rsim_iso n (rG : reprG n) (U V : 'M_n)\n                  (modU : mxmodule rG U) (modV : mxmodule rG V) :\n  mx_rsim (submod_repr modU) (submod_repr modV) <-> mx_iso rG U V.\nProof.\nsplit=> [[B eqrUV injB homB] | [f injf homf defV]].\n  have: \\rank (U *m val_submod (in_submod U 1%:M *m B)) = \\rank U.\n    do 2!rewrite mulmxA mxrankMfree ?row_base_free //.\n    by rewrite -(eqmxMr _ (val_submod1 U)) -in_submodE val_submodK mxrank1.\n  case/complete_unitmx => f injf defUf; exists f => //.\n    apply/hom_mxP=> x Gx; rewrite -defUf -2!mulmxA -(val_submodJ modV) //.\n    rewrite -(mulmxA _ B) -homB // val_submodE 3!(mulmxA U) (mulmxA _ _ B).\n    rewrite -in_submodE -in_submodJ //.\n    have [u ->] := submxP (mxmoduleP modU x Gx).\n    by rewrite in_submodE -mulmxA -defUf !mulmxA !mulmx1.\n  apply/eqmxP; rewrite -mxrank_leqif_eq.\n    by rewrite mxrankMfree ?eqrUV ?row_free_unit.\n  by rewrite -defUf mulmxA val_submodP.\nhave eqrUV: \\rank U = \\rank V by rewrite -defV mxrankMfree ?row_free_unit.\nexists (in_submod V (val_submod 1%:M *m f)) => // [|x Gx].\n  rewrite /row_free {6}eqrUV -[_ == _]sub1mx -val_submodS.\n  rewrite in_submodK; last by rewrite -defV submxMr ?val_submodP.\n  by rewrite val_submod1 -defV submxMr ?val_submod1.\nrewrite -in_submodJ; last by rewrite -defV submxMr ?val_submodP.\nrewrite -(hom_mxP (submx_trans (val_submodP _) homf)) // -(val_submodJ modU) //.\nby rewrite  mul1mx 2!(mulmxA ((submod_repr _) x)) -val_submodE.\nQed.",
    "Lemma mx_rsim_irr n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> mx_irreducible rG1 -> mx_irreducible rG2.\nProof.\ncase/mx_rsim_sym=> f def_n2; rewrite {n2}def_n2 in f rG2 * => injf homf.\ncase/mx_irrP=> n1_gt0 minG; apply/mx_irrP; split=> // U modU nzU.\nrewrite /row_full -(mxrankMfree _ injf) -genmxE.\napply: minG; last by rewrite -mxrank_eq0 genmxE mxrankMfree // mxrank_eq0.\nrewrite (eqmx_module _ (genmxE _)); apply/mxmoduleP=> x Gx.\nby rewrite -mulmxA -homf // mulmxA submxMr // (mxmoduleP modU).\nQed.",
    "Lemma mx_rsim_abs_irr n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n    mx_rsim rG1 rG2 ->\n  mx_absolutely_irreducible rG1 = mx_absolutely_irreducible rG2.\nProof.\ncase=> f def_n2; rewrite -{n2}def_n2 in f rG2 *.\nrewrite row_free_unit => injf homf; congr (_ && (_ == _)).\npose Eg (g : 'M[F]_n1) := lin_mx (mulmxr (invmx g) \\o mulmx g).\nhave free_Ef: row_free (Eg f).\n  apply/row_freeP; exists (Eg (invmx f)); apply/row_matrixP=> i.\n  rewrite rowE row1 mulmxA mul_rV_lin mx_rV_lin /=.\n  by rewrite invmxK !{1}mulmxA mulmxKV // -mulmxA mulKmx // vec_mxK.\nsymmetry; rewrite -(mxrankMfree _ free_Ef); congr (\\rank _).\napply/row_matrixP=> i; rewrite row_mul !rowK mul_vec_lin /=.\nby rewrite -homf ?enum_valP // mulmxK.\nQed.",
    "Lemma rker_mx_rsim n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> rker rG1 = rker rG2.\nProof.\ncase=> f def_n2; rewrite -{n2}def_n2 in f rG2 *.\nrewrite row_free_unit => injf homf.\napply/setP=> x; rewrite !inE !mul1mx; apply: andb_id2l => Gx.\nby rewrite -(can_eq (mulmxK injf)) homf // -scalar_mxC (can_eq (mulKmx injf)).\nQed.",
    "Lemma mx_rsim_faithful n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> mx_faithful rG1 = mx_faithful rG2.\nProof. by move=> simG12; rewrite /mx_faithful (rker_mx_rsim simG12). Qed.",
    "Lemma mx_rsim_factmod n (rG : reprG n) U V\n                     (modU : mxmodule rG U) (modV : mxmodule rG V) :\n    (U + V :=: 1%:M)%MS -> mxdirect (U + V) ->\n  mx_rsim (factmod_repr modV) (submod_repr modU).\nProof.\nmove=> addUV dxUV.\nhave eqUV: \\rank U = \\rank (cokermx V).\n  by rewrite mxrank_coker -{3}(mxrank1 F n) -addUV (mxdirectP dxUV) addnK.\nhave{} dxUV: (U :&: V = 0)%MS by apply/mxdirect_addsP.\nexists (in_submod U (val_factmod 1%:M *m proj_mx U V)) => // [|x Gx].\n  rewrite /row_free -{6}eqUV -[_ == _]sub1mx -val_submodS val_submod1.\n  rewrite in_submodK ?proj_mx_sub // -{1}[U](proj_mx_id dxUV) //.\n  rewrite -{1}(add_sub_fact_mod V U) mulmxDl proj_mx_0 ?val_submodP // add0r.\n  by rewrite submxMr // val_factmodS submx1.\nrewrite -in_submodJ ?proj_mx_sub // -(hom_mxP _) //; last first.\n  by apply: submx_trans (submx1 _) _; rewrite -addUV proj_mx_hom.\nrewrite mulmxA; congr (_ *m _); rewrite mulmxA -val_factmodE; apply/eqP.\nrewrite eq_sym -subr_eq0 -mulmxBl proj_mx_0 //.\nby rewrite -[_ *m rG x](add_sub_fact_mod V) addrK val_submodP.\nQed.",
    "Lemma mxtrace_rsim n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  mx_rsim rG1 rG2 -> {in G, forall x, \\tr (rG1 x) = \\tr (rG2 x)}.\nProof.\ncase/mx_rsim_def=> B [B' B'B def_rG1] x Gx.\nby rewrite def_rG1 // mxtrace_mulC mulmxA B'B mul1mx.\nQed.",
    "Lemma mx_rsim_scalar n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) x c :\n   x \\in G -> mx_rsim rG1 rG2 -> rG1 x = c%:M -> rG2 x = c%:M.\nProof.\nmove=> Gx /mx_rsim_sym[B _ Bfree rG2_B] rG1x.\nby apply: (row_free_inj Bfree); rewrite rG2_B // rG1x scalar_mxC.\nQed.",
    "Lemma socle_irr (W : sG) : mx_irreducible (socle_repr W).\nProof. by apply/submod_mx_irr; apply: socle_simple. Qed.",
    "Lemma socle_rsimP (W1 W2 : sG) :\n  reflect (mx_rsim (socle_repr W1) (socle_repr W2)) (W1 == W2).\nProof.\nhave [simW1 simW2] := (socle_simple W1, socle_simple W2).\nby apply: (iffP (component_mx_isoP simW1 simW2)); move/mx_rsim_iso; apply.\nQed.",
    "Lemma mx_rsim_in_submod U V (modU : mG U) (modV : mG V) :\n  let U' := <<in_submod V U>>%MS in\n    (U <= V)%MS ->\n  exists modU' : mxmodule (sr modV) U', mx_rsim (sr modU) (sr modU').\nProof.\nmove=> U' sUV; have modU': mxmodule (sr modV) U'.\n  by rewrite (eqmx_module _ (genmxE _)) in_submod_module.\nhave rankU': \\rank U = \\rank U' by rewrite genmxE mxrank_in_submod.\npose v1 := val_submod 1%:M; pose U1 := v1 _ U.\nhave sU1V: (U1 <= V)%MS by rewrite val_submod1.\nhave sU1U': (in_submod V U1 <= U')%MS by rewrite genmxE submxMr ?val_submod1.\nexists modU', (in_submod U' (in_submod V U1)) => // [|x Gx].\n  apply/row_freeP; exists (v1 _ _ *m v1 _ _ *m in_submod U 1%:M).\n  rewrite mulmxA [X in X *m _]mulmxA -in_submodE.\n  by rewrite -!val_submodE !in_submodK ?val_submodK.\nrewrite -!in_submodJ // -(val_submodJ modU) // mul1mx.\nby rewrite 2!{1}in_submodE mulmxA (mulmxA _ U1) -val_submodE -!in_submodE.\nQed.",
    "Lemma rsim_submod1 U (modU : mG U) : (U :=: 1%:M)%MS -> mx_rsim (sr modU) rG.\nProof.\nmove=> U1; exists (val_submod 1%:M) => [||x Gx]; first by rewrite U1 mxrank1.\n  by rewrite /row_free val_submod1.\nby rewrite -(val_submodJ modU) // mul1mx -val_submodE.\nQed.",
    "Lemma mxtrace_submod1 U (modU : mG U) :\n  (U :=: 1%:M)%MS -> {in G, forall x, \\tr (sr modU x) = \\tr (rG x)}.\nProof. by move=> defU; apply: mxtrace_rsim (rsim_submod1 modU defU). Qed.",
    "Lemma mxtrace_dadd_mod U V W (modU : mG U) (modV : mG V) (modW : mG W) :\n    (U + V :=: W)%MS -> mxdirect (U + V) ->\n  {in G, forall x, \\tr (sr modU x) + \\tr (sr modV x) = \\tr (sr modW x)}.\nProof.\nmove=> defW dxW x Gx; have [sUW sVW]: (U <= W)%MS /\\ (V <= W)%MS.\n  by apply/andP; rewrite -addsmx_sub defW.\npose U' := <<in_submod W U>>%MS; pose V' := <<in_submod W V>>%MS.\nhave addUV': (U' + V' :=: 1%:M)%MS.\n  apply/eqmxP; rewrite submx1 /= (adds_eqmx (genmxE _) (genmxE _)).\n  by rewrite -addsmxMr -val_submodS val_submod1 in_submodK ?defW.\nhave dxUV': mxdirect (U' + V').\n  apply/eqnP; rewrite /= addUV' mxrank1 !genmxE !mxrank_in_submod //.\n  by rewrite -(mxdirectP dxW) /= defW.\nhave [modU' simU] := mx_rsim_in_submod modU modW sUW.\nhave [modV' simV] := mx_rsim_in_submod modV modW sVW.\nrewrite (mxtrace_rsim simU) // (mxtrace_rsim simV) //.\nrewrite -(mxtrace_sub_fact_mod modV') addrC; congr (_ + _).\nby rewrite (mxtrace_rsim (mx_rsim_factmod modU' modV' addUV' dxUV')).\nQed.",
    "Lemma mxtrace_dsum_mod (I : finType) (P : pred I) U W\n                       (modU : forall i, mG (U i)) (modW : mG W) :\n    let S := (\\sum_(i | P i) U i)%MS in (S :=: W)%MS -> mxdirect S ->\n  {in G, forall x, \\sum_(i | P i) \\tr (sr (modU i) x) = \\tr (sr modW x)}.\nProof.\nmove=> /= sumS dxS x Gx; have [m lePm] := ubnP #|P|.\nelim: m => // m IHm in P lePm W modW sumS dxS *.\nhave [j /= Pj | P0] := pickP P; last first.\n  case: sumS (_ x); rewrite !big_pred0 // mxrank0 => <- _ rWx.\n  by rewrite [rWx]flatmx0 linear0.\nrewrite ltnS (cardD1x Pj) in lePm.\nrewrite mxdirectE /= !(bigD1 j Pj) -mxdirectE mxdirect_addsE /= in dxS sumS *.\nhave [_ dxW' dxW] := and3P dxS; rewrite (sameP eqP mxdirect_addsP) in dxW.\nrewrite (IHm _ _ _ (sumsmx_module _ (fun i _ => modU i)) (eqmx_refl _)) //.\nexact: mxtrace_dadd_mod.\nQed.",
    "Lemma mxtrace_component U (simU : mxsimple rG U) :\n   let V := component_mx rG U in\n   let modV := component_mx_module rG U in let modU := mxsimple_module simU in\n  {in G, forall x, \\tr (sr modV x) = \\tr (sr modU x) *+ (\\rank V %/ \\rank U)}.\nProof.\nmove=> V modV modU x Gx.\nhave [I W S simW defV dxV] := component_mx_semisimple simU.\nrewrite -(mxtrace_dsum_mod (fun i => mxsimple_module (simW i)) modV defV) //.\nhave rankU_gt0: \\rank U > 0 by rewrite lt0n mxrank_eq0; case simU.\nhave isoW i: mx_iso rG U (W i).\n  by apply: component_mx_iso; rewrite ?simU // -defV (sumsmx_sup i).\nhave ->: (\\rank V %/ \\rank U)%N = #|I|.\n  symmetry; rewrite -(mulnK #|I| rankU_gt0); congr (_ %/ _)%N.\n  rewrite -defV (mxdirectP dxV) /= -sum_nat_const.\n  by apply: eq_bigr => i _; apply: mxrank_iso.\nrewrite -sumr_const; apply: eq_bigr => i _; symmetry.\nby apply: mxtrace_rsim Gx; apply/mx_rsim_iso; apply: isoW.\nQed.",
    "Lemma mxtrace_Socle : let modS := Socle_module sG in\n  {in G, forall x,\n    \\tr (sr modS x) = \\sum_(W : sG) \\tr (socle_repr W x) *+ socle_mult W}.\nProof.\nmove=> /= x Gx /=; pose modW (W : sG) := component_mx_module rG (socle_base W).\nrewrite -(mxtrace_dsum_mod modW _ (eqmx_refl _) (Socle_direct sG)) //.\nby apply: eq_bigr => W _; rewrite (mxtrace_component (socle_simple W)).\nQed.",
    "Lemma Clifford_simple M x : mxsimple rH M -> x \\in G -> mxsimple rH (M *m rG x).\nProof.\nhave modmG m U y: y \\in G -> (mxmodule rH) m U -> mxmodule rH (U *m rG y).\n  move=> Gy modU; apply/mxmoduleP=> h Hh; have Gh := subsetP sHG h Hh.\n  rewrite -mulmxA -repr_mxM // conjgCV repr_mxM ?groupJ ?groupV // mulmxA.\n  by rewrite submxMr ?(mxmoduleP modU) // -mem_conjg (normsP nHG).\nhave nzmG m y (U : 'M_(m, n)): y \\in G -> (U *m rG y == 0) = (U == 0).\n  by move=> Gy; rewrite -{1}(mul0mx m (rG y)) (can_eq (repr_mxK rG Gy)).\ncase=> [modM nzM simM] Gx; have Gx' := groupVr Gx.\nsplit=> [||U modU sUMx nzU]; rewrite ?modmG ?nzmG //.\nrewrite -(repr_mxKV rG Gx U) submxMr //.\nby rewrite (simM (U *m _)) ?modmG ?nzmG // -(repr_mxK rG Gx M) submxMr.\nQed.",
    "Lemma Clifford_hom x m (U : 'M_(m, n)) :\n  x \\in 'C_G(H) -> (U <= dom_hom_mx rH (rG x))%MS.\nProof.\ncase/setIP=> Gx cHx; apply/rV_subP=> v _{U}.\napply/hom_mxP=> h Hh; have Gh := subsetP sHG h Hh.\nby rewrite -!mulmxA /= -!repr_mxM // (centP cHx).\nQed.",
    "Lemma Clifford_iso x U : x \\in 'C_G(H) -> mx_iso rH U (U *m rG x).\nProof.\nmove=> cHx; have [Gx _] := setIP cHx.\nby exists (rG x); rewrite ?repr_mx_unit ?Clifford_hom.\nQed.",
    "Lemma Clifford_iso2 x U V :\n  mx_iso rH U V -> x \\in G -> mx_iso rH (U *m rG x) (V *m rG x).\nProof.\ncase=> [f injf homUf defV] Gx; have Gx' := groupVr Gx.\npose fx := rG (x^-1)%g *m f *m rG x; exists fx; last 1 first.\n- by rewrite !mulmxA repr_mxK //; apply: eqmxMr.\n- by rewrite !unitmx_mul andbC !repr_mx_unit.\napply/hom_mxP=> h Hh; have Gh := subsetP sHG h Hh.\nrewrite -(mulmxA U) -repr_mxM // conjgCV repr_mxM ?groupJ // !mulmxA.\nrewrite !repr_mxK // (hom_mxP homUf) -?mem_conjg ?(normsP nHG) //=.\nby rewrite !repr_mxM ?invgK ?groupM // !mulmxA repr_mxKV.\nQed.",
    "Lemma Clifford_componentJ M x :\n    mxsimple rH M -> x \\in G ->\n  (component_mx rH (M *m rG x) :=: component_mx rH M *m rG x)%MS.\nProof.\nset simH := mxsimple rH; set cH := component_mx rH.\nhave actG: {in G, forall y M, simH M -> cH M *m rG y <= cH (M *m rG y)}%MS.\n  move=> {M} y Gy /= M simM; have [I [U isoU def_cHM]] := component_mx_def simM.\n  rewrite /cH def_cHM sumsmxMr; apply/sumsmx_subP=> i _.\n  by apply: mx_iso_component; [apply: Clifford_simple | apply: Clifford_iso2].\nmove=> simM Gx; apply/eqmxP; rewrite actG // -/cH.\nrewrite -{1}[cH _](repr_mxKV rG Gx) submxMr // -{2}[M](repr_mxK rG Gx).\nby rewrite actG ?groupV //; apply: Clifford_simple.\nQed.",
    "Lemma Clifford_basis M : mxsimple rH M ->\n  {X : {set gT} | X \\subset G &\n    let S := \\sum_(x in X) M *m rG x in S :=: 1%:M /\\ mxdirect S}%MS.\nProof.\nmove=> simM. have simMG (g : [subg G]) : mxsimple rH (M *m rG (val g)).\n  by case: g => x Gx; apply: Clifford_simple.\nhave [|XG [defX1 dxX1]] := sum_mxsimple_direct_sub simMG (_ : _ :=: 1%:M)%MS.\n  apply/eqmxP; case irrG => _ _ ->; rewrite ?submx1 //; last first.\n    rewrite -submx0; apply/sumsmx_subP; move/(_ 1%g (erefl _)); apply: negP.\n    by rewrite submx0 repr_mx1 mulmx1; case simM.\n  apply/mxmoduleP=> x Gx; rewrite sumsmxMr; apply/sumsmx_subP=> [[y Gy]] /= _.\n  by rewrite (sumsmx_sup (subg G (y * x)))// subgK ?groupM// -mulmxA repr_mxM.\nexists (val @: XG); first by apply/subsetP=> ?; case/imsetP=> [[x Gx]] _ ->.\nhave bij_val: {on val @: XG, bijective (@sgval _ G)}.\n  exists (subg G) => [g _ | x]; first exact: sgvalK.\n  by case/imsetP=> [[x' Gx]] _ ->; rewrite subgK.\nhave defXG g: (val g \\in val @: XG) = (g \\in XG).\n  by apply/imsetP/idP=> [[h XGh] | XGg]; [move/val_inj-> | exists g].\nby rewrite /= mxdirectE /= !(reindex _ bij_val) !(eq_bigl _ _ defXG).\nQed.",
    "Lemma val_Clifford_act W x : x \\in G -> ('Cl%act W x :=: W *m rG x)%MS.\nProof. by move=> Gx; apply: eqmx_trans (valWact _ _) _; rewrite subgK. Qed.",
    "Lemma Clifford_atrans : [transitive G, on [set: sH] | 'Cl].\nProof.\nhave [_ nz1 _] := irrG.\napply: mxsimple_exists (mxmodule1 rH) nz1 _ _ => [[M simM _]].\npose W1 := PackSocle (component_socle sH simM).\nhave [X sXG [def1 _]] := Clifford_basis simM; move/subsetP: sXG => sXG.\napply/imsetP; exists W1; first by rewrite inE.\nsymmetry; apply/setP=> W /[1!inE]; have simW := socle_simple W.\nhave:= submx1 (socle_base W); rewrite -def1 -[(\\sum_(x in X) _)%MS]mulmx1.\ncase/(hom_mxsemisimple_iso simW) => [x Xx _ | | x Xx isoMxW].\n- by apply: Clifford_simple; rewrite ?sXG.\n- exact: scalar_mx_hom.\nhave Gx := sXG x Xx; apply/imsetP; exists x => //; apply/socleP/eqmxP/eqmx_sym.\napply: eqmx_trans (val_Clifford_act _ Gx) _; rewrite PackSocleK.\napply: eqmx_trans (eqmx_sym (Clifford_componentJ simM Gx)) _.\napply/eqmxP; rewrite (sameP genmxP eqP) !{1}genmx_component.\nby apply/component_mx_isoP=> //; apply: Clifford_simple.\nQed.",
    "Lemma Clifford_Socle1 : Socle sH = 1%:M.\nProof.\ncase/imsetP: Clifford_atrans => W _ _; have simW := socle_simple W.\nhave [X sXG [def1 _]] := Clifford_basis simW.\nrewrite reducible_Socle1 //; apply: mxsemisimple_reducible.\napply: intro_mxsemisimple def1 _ => x /(subsetP sXG) Gx _.\nexact: Clifford_simple.\nQed.",
    "Lemma Clifford_rank_components (W : sH) : (#|sH| * \\rank W)%N = n.\nProof.\nrewrite -{9}(mxrank1 F n) -Clifford_Socle1.\nrewrite (mxdirectP (Socle_direct sH)) /= -sum_nat_const.\napply: eq_bigr => W1 _; have [W0 _ W0G] := imsetP Clifford_atrans.\nhave{} W0G W': W' \\in orbit 'Cl G W0 by rewrite -W0G inE.\nhave [/orbitP[x Gx <-] /orbitP[y Gy <-]] := (W0G W, W0G W1).\nby rewrite !{1}val_Clifford_act // !mxrankMfree // !repr_mx_free.\nQed.",
    "Lemma Clifford_astab : H <*> 'C_G(H) \\subset 'C([set: sH] | 'Cl).\nProof.\nrewrite join_subG !subsetI sHG subsetIl /=; apply/andP; split.\n  apply/subsetP=> h Hh /[1!inE]; have Gh := subsetP sHG h Hh.\n  apply/subsetP=> W _; have simW := socle_simple W; have [modW _ _] := simW.\n  have simWh: mxsimple rH (socle_base W *m rG h) by apply: Clifford_simple.\n  rewrite inE -val_eqE /= PackSocleK eq_sym.\n  apply/component_mx_isoP; rewrite ?subgK //; apply: component_mx_iso => //.\n  by apply: submx_trans (component_mx_id simW); move/mxmoduleP: modW => ->.\napply/subsetP=> z cHz /[1!inE]; have [Gz _] := setIP cHz.\napply/subsetP=> W _; have simW := socle_simple W; have [modW _ _] := simW.\nhave simWz: mxsimple rH (socle_base W *m rG z) by apply: Clifford_simple.\nrewrite inE -val_eqE /= PackSocleK eq_sym.\nby apply/component_mx_isoP; rewrite ?subgK //; apply: Clifford_iso.\nQed.",
    "Lemma Clifford_astab1 (W : sH) : 'C[W | 'Cl] = rstabs rG W.\nProof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nrewrite sub1set inE (sameP eqP socleP) !val_Clifford_act //.\nrewrite andb_idr // => sWxW; rewrite -mxrank_leqif_sup //.\nby rewrite mxrankMfree ?repr_mx_free.\nQed.",
    "Lemma Clifford_rstabs_simple (W : sH) :\n  mxsimple (subg_repr rG (rstabs_sub rG W)) W.\nProof.\nsplit => [||U modU sUW nzU]; last 2 [exact: nz_socle].\n  by rewrite /mxmodule rstabs_subg setIid.\nhave modUH: mxmodule rH U.\n  apply/mxmoduleP=> h Hh; rewrite (mxmoduleP modU) //.\n  rewrite /= -Clifford_astab1 !(inE, sub1set) (subsetP sHG) //.\n  rewrite (astab_act (subsetP Clifford_astab h _)) ?inE //=.\n  by rewrite mem_gen // inE Hh.\napply: (mxsimple_exists modUH nzU) => [[M simM sMU]].\nhave [t [x_ /(_ W)[Gx_ defW _]]] := Clifford_component_basis simM.\nrewrite -defW; apply/sumsmx_subP=> j _; set x := x_ W j.\nhave{Gx_} Gx: x \\in G by rewrite Gx_.\napply: submx_trans (submxMr _ sMU) _; apply: (mxmoduleP modU).\nrewrite inE -val_Clifford_act Gx //; set Wx := 'Cl%act W x.\ncase: (eqVneq Wx W) (simM) => [-> //=|] neWxW [_ /negP[]]; rewrite -submx0.\nrewrite (canF_eq (actKin 'Cl Gx)) in neWxW.\nrewrite -(component_mx_disjoint _ _ neWxW); try exact: socle_simple.\nrewrite sub_capmx {1}(submx_trans sMU sUW) val_Clifford_act ?groupV //.\nby rewrite -(eqmxMr _ defW) sumsmxMr (sumsmx_sup j) ?repr_mxK.\nQed.",
    "Lemma section_module (U V : 'M_n) (modU : modG U) (modV : modG V) :\n  mxmodule (factmod_repr modU) <<in_factmod U V>>%MS.\nProof.\nby rewrite (eqmx_module _ (genmxE _)) in_factmod_module addsmx_module.\nQed.",
    "Lemma mx_factmod_sub U modU :\n  mx_rsim (@section_repr U _ modU (mxmodule1 rG)) (factmod_repr modU).\nProof.\nexists (val_submod 1%:M) => [||x Gx].\n- apply: (@addIn (\\rank U)); rewrite genmxE mxrank_in_factmod mxrank_coker.\n  by rewrite (addsmx_idPr (submx1 U)) mxrank1 subnK ?rank_leq_row.\n- by rewrite /row_free val_submod1.\nby rewrite -[_ x]mul1mx -val_submodE val_submodJ.\nQed.",
    "Lemma max_submodP U V (modU : modG U) (modV : modG V) :\n  (U <= V)%MS -> (max_submod U V <-> mx_irreducible (section_repr modU modV)).\nProof.\nmove=> sUV; split=> [[ltUV maxU] | ].\n  apply/mx_irrP; split=> [|WU modWU nzWU].\n    by rewrite genmxE lt0n mxrank_eq0 in_factmod_eq0; case/andP: ltUV.\n  rewrite -sub1mx -val_submodS val_submod1 genmxE.\n  pose W := (U + val_factmod (val_submod WU))%MS.\n  suffices sVW: (V <= W)%MS.\n    rewrite {2}in_factmodE (submx_trans (submxMr _ sVW)) //.\n    rewrite addsmxMr -!in_factmodE val_factmodK.\n    by rewrite ((in_factmod U U =P 0) _) ?adds0mx ?in_factmod_eq0.\n  move/and3P: {maxU}(maxU W); apply: contraR; rewrite /ltmx addsmxSl => -> /=.\n  move: modWU; rewrite /mxmodule rstabs_submod rstabs_factmod => -> /=.\n  rewrite addsmx_sub submx_refl -in_factmod_eq0 val_factmodK.\n  move: nzWU; rewrite -[_ == 0](inj_eq val_submod_inj) linear0 => ->.\n  rewrite -(in_factmodsK sUV) addsmxS // val_factmodS.\n  by rewrite -(genmxE (in_factmod U V)) val_submodP.\ncase/mx_irrP; rewrite lt0n {1}genmxE mxrank_eq0 in_factmod_eq0 => ltUV maxV.\nsplit=> // [|W [modW /andP[sUW ltUW] /andP[sWV /negP[]]]]; first exact/andP.\nrewrite -(in_factmodsK sUV) -(in_factmodsK sUW) addsmxS // val_factmodS.\nrewrite -genmxE -val_submod1; set VU := <<_>>%MS.\nhave sW_VU: (in_factmod U W <= VU)%MS.\n  by rewrite genmxE -val_factmodS !submxMr.\nrewrite -(in_submodK sW_VU) val_submodS -(genmxE (in_submod _ _)).\nrewrite sub1mx maxV //.\n  rewrite (eqmx_module _ (genmxE _)) in_submod_module ?genmxE ?submxMr //.\n  by rewrite in_factmod_module addsmx_module.\nrewrite -submx0 [(_ <= 0)%MS]genmxE -val_submodS linear0 in_submodK //.\nby rewrite eqmx0 submx0 in_factmod_eq0.\nQed.",
    "Lemma max_submod_eqmx U1 U2 V1 V2 :\n  (U1 :=: U2)%MS -> (V1 :=: V2)%MS -> max_submod U1 V1 -> max_submod U2 V2.\nProof.\nmove=> eqU12 eqV12 [ltUV1 maxU1].\nby split=> [|W]; rewrite -(lt_eqmx eqU12) -(lt_eqmx eqV12).\nQed.",
    "Lemma mx_series_lt V : mx_composition_series V -> path ltmx 0 V.\nProof. by case=> _ compV; apply/(pathP 0)=> i /compV[]. Qed.",
    "Lemma max_size_mx_series (V : seq 'M[F]_n) :\n   path ltmx 0 V -> size V <= \\rank (last 0 V).\nProof.\nrewrite -[size V]addn0 -(mxrank0 F n n); elim: V 0 => //= V1 V IHV V0.\nrewrite ltmxErank -andbA => /and3P[_ ltV01 ltV].\nby apply: leq_trans (IHV _ ltV); rewrite addSnnS leq_add2l.\nQed.",
    "Lemma mx_series_repr_irr V i (compV : mx_composition_series V) :\n  i < size V -> mx_irreducible (series_repr i compV).\nProof.\ncase: compV => modV compV /compV maxVi; apply/max_submodP => //.\nby apply: ltmxW; case: maxVi.\nQed.",
    "Lemma mx_series_rcons U V :\n  mx_series (rcons U V) <-> [/\\ mx_series U, modG V & max_submod (last 0 U) V].\nProof.\nrewrite /mx_series /mx_subseries all_rcons size_rcons -rcons_cons.\nsplit=> [ [/andP[modU modV] maxU] | [[modU maxU] modV maxV]].\n  split=> //; last first.\n    by have:= maxU _ (leqnn _); rewrite !nth_rcons leqnn ltnn eqxx -last_nth.\n  by split=> // i ltiU; have:= maxU i (ltnW ltiU); rewrite !nth_rcons leqW ltiU.\nrewrite modV; split=> // i; rewrite !nth_rcons ltnS leq_eqVlt.\ncase: eqP => [-> _ | /= _ ltiU]; first by rewrite ltnn ?eqxx -last_nth.\nby rewrite ltiU; apply: maxU.\nQed.",
    "Lemma mx_second_rsim U V (modU : modG U) (modV : modG V) :\n  let modI := capmx_module modU modV in let modA := addsmx_module modU modV in\n  mx_rsim (section_repr modI modU) (section_repr modV modA).\nProof.\nmove=> modI modA; set nI := {1}(\\rank _).\nhave sIU := capmxSl U V; have sVA := addsmxSr U V.\npose valI := val_factmod (val_submod (1%:M : 'M_nI)).\nhave UvalI: (valI <= U)%MS.\n  rewrite -(addsmx_idPr sIU) (submx_trans _ (proj_factmodS _ _)) //.\n  by rewrite submxMr // val_submod1 genmxE.\nexists (valI *m in_factmod _ 1%:M *m in_submod _ 1%:M) => [||x Gx].\n- apply: (@addIn (\\rank (U :&: V) + \\rank V)%N); rewrite genmxE addnA addnCA.\n  rewrite /nI genmxE !{1}mxrank_in_factmod 2?(addsmx_idPr _) //.\n  by rewrite -mxrank_sum_cap addnC.\n- rewrite -kermx_eq0; apply/rowV0P=> u; rewrite (sameP sub_kermxP eqP).\n  rewrite mulmxA -in_submodE mulmxA -in_factmodE -(inj_eq val_submod_inj).\n  rewrite linear0 in_submodK ?in_factmod_eq0 => [Vvu|]; last first.\n    by rewrite genmxE addsmxC in_factmod_addsK submxMr // mulmx_sub.\n  apply: val_submod_inj; apply/eqP; rewrite linear0 -[val_submod u]val_factmodK.\n  rewrite val_submodE val_factmodE -mulmxA -val_factmodE -/valI.\n  by rewrite in_factmod_eq0 sub_capmx mulmx_sub.\nsymmetry; rewrite -{1}in_submodE -{1}in_submodJ; last first.\n   by rewrite genmxE addsmxC in_factmod_addsK -in_factmodE submxMr.\nrewrite -{1}in_factmodE -{1}in_factmodJ // mulmxA in_submodE; congr (_ *m _).\napply/eqP; rewrite mulmxA -in_factmodE -subr_eq0 -linearB in_factmod_eq0.\napply: submx_trans (capmxSr U V); rewrite -in_factmod_eq0 linearB /=.\nrewrite subr_eq0 {1}(in_factmodJ modI) // val_factmodK eq_sym.\nrewrite /valI val_factmodE mulmxA -val_factmodE val_factmodK.\nby rewrite -[submod_mx _ _]mul1mx -val_submodE val_submodJ.\nQed.",
    "Lemma section_eqmx_add U1 U2 V1 V2 modU1 modU2 modV1 modV2 :\n    (U1 :=: U2)%MS -> (U1 + V1 :=: U2 + V2)%MS ->\n  mx_rsim (@section_repr U1 V1 modU1 modV1) (@section_repr U2 V2 modU2 modV2).\nProof.\nmove=> eqU12 eqV12; set n1 := {1}(\\rank _).\npose v1 := val_factmod (val_submod (1%:M : 'M_n1)).\nhave sv12: (v1 <= U2 + V2)%MS.\n  rewrite -eqV12 (submx_trans _ (proj_factmodS _ _)) //.\n  by rewrite submxMr // val_submod1 genmxE.\nexists (v1 *m in_factmod _ 1%:M *m in_submod _ 1%:M) => [||x Gx].\n- apply: (@addIn (\\rank U1)); rewrite {2}eqU12 /n1 !{1}genmxE.\n  by rewrite !{1}mxrank_in_factmod eqV12.\n- rewrite -kermx_eq0; apply/rowV0P=> u; rewrite (sameP sub_kermxP eqP) mulmxA.\n  rewrite -in_submodE mulmxA -in_factmodE -(inj_eq val_submod_inj) linear0.\n  rewrite in_submodK ?in_factmod_eq0 -?eqU12 => [U1uv1|]; last first.\n    by rewrite genmxE -(in_factmod_addsK U2 V2) submxMr // mulmx_sub.\n  apply: val_submod_inj; apply/eqP; rewrite linear0 -[val_submod _]val_factmodK.\n  by rewrite in_factmod_eq0 val_factmodE val_submodE -mulmxA -val_factmodE.\nsymmetry; rewrite -{1}in_submodE -{1}in_factmodE -{1}in_submodJ; last first.\n  by rewrite genmxE -(in_factmod_addsK U2 V2) submxMr.\nrewrite -{1}in_factmodJ // mulmxA in_submodE; congr (_ *m _); apply/eqP.\nrewrite mulmxA -in_factmodE -subr_eq0 -linearB in_factmod_eq0 -eqU12.\nrewrite -in_factmod_eq0 linearB /= subr_eq0 {1}(in_factmodJ modU1) //.\nrewrite val_factmodK /v1 val_factmodE eq_sym mulmxA -val_factmodE val_factmodK.\nby rewrite -[_ *m _]mul1mx mulmxA -val_submodE val_submodJ.\nQed.",
    "Lemma section_eqmx U1 U2 V1 V2 modU1 modU2 modV1 modV2\n                   (eqU : (U1 :=: U2)%MS) (eqV : (V1 :=: V2)%MS) :\n  mx_rsim (@section_repr U1 V1 modU1 modV1) (@section_repr U2 V2 modU2 modV2).\nProof. by apply: section_eqmx_add => //; apply: adds_eqmx. Qed.",
    "Lemma mx_butterfly U V W modU modV modW :\n    ~~ (U == V)%MS -> max_submod U W -> max_submod V W ->\n  let modUV := capmx_module modU modV in\n     max_submod (U :&: V)%MS U\n  /\\ mx_rsim (@section_repr V W modV modW) (@section_repr _ U modUV modU).\nProof.\nmove=> neUV maxU maxV modUV; have{neUV maxU} defW: (U + V :=: W)%MS.\n  wlog{neUV modUV} ltUV: U V modU modV maxU maxV / ~~ (V <= U)%MS.\n    by case/nandP: neUV => ?; first rewrite addsmxC; apply.\n  apply/eqmxP/idPn=> neUVW; case: maxU => ltUW; case/(_ (U + V)%MS).\n  rewrite addsmx_module // ltmxE ltmxEneq neUVW addsmxSl !addsmx_sub.\n  by have [ltVW _] := maxV; rewrite submx_refl andbT ltUV !ltmxW.\nhave sUV_U := capmxSl U V; have sVW: (V <= W)%MS by rewrite -defW addsmxSr.\nset goal := mx_rsim _ _; suffices{maxV} simUV: goal.\n  split=> //; apply/(max_submodP modUV modU sUV_U).\n  by apply: mx_rsim_irr simUV _; apply/max_submodP.\napply: {goal}mx_rsim_sym.\nby apply: mx_rsim_trans (mx_second_rsim modU modV) _; apply: section_eqmx.\nQed.",
    "Lemma mx_JordanHolder_exists U V :\n    mx_composition_series U -> modG V -> max_submod V (last 0 U) ->\n  {W : seq 'M_n | mx_composition_series W & last 0 W = V}.\nProof.\nelim/last_ind: U V => [|U Um IHU] V compU modV; first by case; rewrite ltmx0.\nrewrite last_rcons => maxV; case/mx_series_rcons: compU => compU modUm maxUm.\ncase eqUV: (last 0 U == V)%MS.\n  case/lastP: U eqUV compU {maxUm IHU} => [|U' Um'].\n    by rewrite andbC; move/eqmx0P->; exists [::].\n  rewrite last_rcons; move/eqmxP=> eqU'V; case/mx_series_rcons=> compU _ maxUm'.\n  exists (rcons U' V); last by rewrite last_rcons.\n  by apply/mx_series_rcons; split => //; apply: max_submod_eqmx maxUm'.\nset Um' := last 0 U in maxUm eqUV; have [modU _] := compU.\nhave modUm': modG Um' by rewrite /Um' (last_nth 0) mx_subseries_module'.\nhave [|||W compW lastW] := IHU (V :&: Um')%MS; rewrite ?capmx_module //.\n  by case: (mx_butterfly modUm' modV modUm); rewrite ?eqUV // {1}capmxC.\nexists (rcons W V); last by rewrite last_rcons.\napply/mx_series_rcons; split; rewrite // lastW.\nby case: (mx_butterfly modV modUm' modUm); rewrite // andbC eqUV.\nQed.",
    "Lemma mx_JordanHolder U V compU compV :\n  let m := size U in (last 0 U :=: last 0 V)%MS ->\n  m = size V  /\\ (exists p : 'S_m, forall i : 'I_m,\n     mx_rsim (@series_repr U i compU) (@series_repr V (p i) compV)).\nProof.\nmove Dr: {-}(size U) => r; move/eqP in Dr.\nelim: r U V Dr compU compV => /= [|r IHr] U V.\n  move/nilP->; case/lastP: V => [|V Vm] /= ? compVm; rewrite ?last_rcons => Vm0.\n    by split=> //; exists 1%g; case.\n  by case/mx_series_rcons: (compVm) => _ _ []; rewrite -(lt_eqmx Vm0) ltmx0.\ncase/lastP: U => // [U Um]; rewrite size_rcons eqSS => szUr compUm.\ncase/mx_series_rcons: (compUm); set Um' := last 0 U => compU modUm maxUm.\ncase/lastP: V => [|V Vm] compVm; rewrite ?last_rcons ?size_rcons /= => eqUVm.\n  by case/mx_series_rcons: (compUm) => _ _ []; rewrite (lt_eqmx eqUVm) ltmx0.\ncase/mx_series_rcons: (compVm); set Vm' := last 0 V => compV modVm maxVm.\nhave [modUm' modVm']: modG Um' * modG Vm' := (last_mod compU, last_mod compV).\npose i_m := @ord_max (size U).\nhave [eqUVm' | neqUVm'] := altP (@eqmxP _ _ _ _ Um' Vm').\n  have [szV [p sim_p]] := IHr U V szUr compU compV eqUVm'.\n  split; first by rewrite szV.\n  exists (lift_perm i_m i_m p) => i; case: (unliftP i_m i) => [j|] ->{i}.\n    apply: rsimT (rsimC _) (rsimT (sim_p j) _).\n      by rewrite lift_max; apply: rsim_rcons.\n    by rewrite lift_perm_lift lift_max; apply: rsim_rcons; rewrite -szV.\n  have simUVm := section_eqmx modUm' modVm' modUm modVm eqUVm' eqUVm.\n  apply: rsimT (rsimC _) (rsimT simUVm _); first exact: rsim_last.\n  by rewrite lift_perm_id /= szV; apply: rsim_last.\nhave maxVUm: max_submod Vm' Um by apply: max_submod_eqmx (eqmx_sym _) maxVm.\nhave:= mx_butterfly modUm' modVm' modUm neqUVm' maxUm maxVUm.\nmove: (capmx_module _ _); set Wm := (Um' :&: Vm')%MS => modWm [maxWUm simWVm].\nhave:= mx_butterfly modVm' modUm' modUm _ maxVUm maxUm.\nmove: (capmx_module _ _); rewrite andbC capmxC -/Wm => modWmV [// | maxWVm].\nrewrite {modWmV}(bool_irrelevance modWmV modWm) => simWUm.\nhave [W compW lastW] := mx_JordanHolder_exists compU modWm maxWUm.\nhave compWU: mx_series (rcons W Um') by apply/mx_series_rcons; rewrite lastW.\nhave compWV: mx_series (rcons W Vm') by apply/mx_series_rcons; rewrite lastW.\nhave [|szW [pU pUW]] := IHr U _ szUr compU compWU; first by rewrite last_rcons.\nrewrite size_rcons in szW; have ltWU: size W < size U by rewrite -szW.\nhave{IHr} := IHr _ V _ compWV compV; rewrite last_rcons size_rcons -szW.\ncase=> {r szUr}// szV [pV pWV]; split; first by rewrite szV.\npose j_m := Ordinal ltWU; pose i_m' := lift i_m j_m.\nexists (lift_perm i_m i_m pU * tperm i_m i_m' * lift_perm i_m i_m pV)%g => i.\nrewrite !permM; case: (unliftP i_m i) => [j {simWUm}|] ->{i}; last first.\n  rewrite lift_perm_id tpermL lift_perm_lift lift_max {simWVm}.\n  apply: rsimT (rsimT (pWV j_m) _); last by apply: rsim_rcons; rewrite -szV.\n  apply: rsimT (rsimC _) {simWUm}(rsimT simWUm _); first exact: rsim_last.\n  by rewrite -lastW in modWm *; apply: rsim_last.\napply: rsimT (rsimC _) {pUW}(rsimT (pUW j) _).\n  by rewrite lift_max; apply: rsim_rcons.\nrewrite lift_perm_lift; case: (unliftP j_m (pU j)) => [k|] ->{j pU}.\n  rewrite tpermD ?(inj_eq lift_inj) ?neq_lift //.\n  rewrite lift_perm_lift !lift_max; set j := lift j_m k.\n  have ltjW: j < size W by have:= ltn_ord k; rewrite -(lift_max k) /= {1 3}szW.\n  apply: rsimT (rsimT (pWV j) _); last by apply: rsim_rcons; rewrite -szV.\n  by apply: rsimT (rsimC _) (rsim_rcons compW _ _); first apply: rsim_rcons.\napply: rsimT {simWVm}(rsimC (rsimT simWVm _)) _.\n  by rewrite -lastW in modWm *; apply: rsim_last.\nrewrite tpermR lift_perm_id /= szV.\nby apply: rsimT (rsim_last modVm' modVm _); apply: section_eqmx.\nQed.",
    "Lemma mx_JordanHolder_max U (m := size U) V compU modV :\n    (last 0 U :=: 1%:M)%MS -> mx_irreducible (@factmod_repr _ G n rG V modV) ->\n  exists i : 'I_m, mx_rsim (factmod_repr modV) (@series_repr U i compU).\nProof.\nrewrite {}/m; set Um := last 0 U => Um1 irrV.\nhave modUm: modG Um := last_mod compU; have simV := rsimC (mx_factmod_sub modV).\nhave maxV: max_submod V Um.\n  move/max_submodP: (mx_rsim_irr simV irrV) => /(_ (submx1 _)).\n  by apply: max_submod_eqmx; last apply: eqmx_sym.\nhave [W compW lastW] := mx_JordanHolder_exists compU modV maxV.\nhave compWU: mx_series (rcons W Um) by apply/mx_series_rcons; rewrite lastW.\nhave:= mx_JordanHolder compU compWU; rewrite last_rcons size_rcons.\ncase=> // szW [p pUW]; have ltWU: size W < size U by rewrite szW.\npose i := Ordinal ltWU; exists ((p^-1)%g i).\napply: rsimT simV (rsimT _ (rsimC (pUW _))); rewrite permKV.\napply: rsimT (rsimC _) (rsim_last (last_mod compW) modUm _).\nby apply: section_eqmx; rewrite ?lastW.\nQed.",
    "Lemma gring_free : row_free R_G.\nProof.\napply/row_freeP; exists (lin1_mx (row (gring_index G 1) \\o vec_mx)).\napply/row_matrixP=> i; rewrite row_mul rowK mul_rV_lin1 /= mxvecK rowK row1.\nby rewrite gring_indexK // mul1g gring_valK.\nQed.",
    "Lemma gring_op_id A : (A \\in R_G)%MS -> gring_op aG A = A.\nProof.\ncase/envelop_mxP=> a ->{A}; rewrite linear_sum.\nby apply: eq_bigr => x Gx; rewrite linearZ /= gring_opG.\nQed.",
    "Lemma gring_rowK A : (A \\in R_G)%MS -> gring_mx aG (gring_row A) = A.\nProof. exact: gring_op_id. Qed.",
    "Lemma mem_gring_mx m a (M : 'M_(m, nG)) :\n  (gring_mx aG a \\in M *m R_G)%MS = (a <= M)%MS.\nProof. by rewrite vec_mxK submxMfree ?gring_free. Qed.",
    "Lemma mem_sub_gring m A (M : 'M_(m, nG)) :\n  (A \\in M *m R_G)%MS = (A \\in R_G)%MS && (gring_row A <= M)%MS.\nProof.\nrewrite -(andb_idl (memmx_subP (submxMl _ _) A)); apply: andb_id2l => R_A.\nby rewrite -mem_gring_mx gring_rowK.\nQed.",
    "Lemma gring_mxP a : (gring_mx rG a \\in enveloping_algebra_mx rG)%MS.\nProof. by rewrite vec_mxK submxMl. Qed.",
    "Lemma gring_opM A B :\n  (B \\in R_G)%MS -> gring_op rG (A *m B) = gring_op rG A *m gring_op rG B.\nProof. by move=> R_B; rewrite -gring_opJ gring_rowK. Qed.",
    "Lemma rsim_regular_factmod :\n  {U : 'M_nG & {modU : mxmodule aG U & mx_rsim rG (factmod_repr modU)}}.\nProof.\npose v : 'rV[F]_n := nz_row 1%:M.\npose fU := lin1_mx (mulmx v \\o gring_mx rG); pose U := kermx fU.\nhave modU: mxmodule aG U.\n  apply/mxmoduleP => x Gx; apply/sub_kermxP/row_matrixP=> i.\n  rewrite 2!row_mul row0; move: (row i U) (sub_kermxP (row_sub i U)) => u.\n  by rewrite !mul_rV_lin1 /= gring_mxJ // mulmxA => ->; rewrite mul0mx.\nhave def_n: \\rank (cokermx U) = n.\n  apply/eqP; rewrite mxrank_coker mxrank_ker subKn ?rank_leq_row // -genmxE.\n  rewrite -[_ == _]sub1mx; have [_ _ ->] := irrG; rewrite ?submx1 //.\n    rewrite (eqmx_module _ (genmxE _)); apply/mxmoduleP=> x Gx.\n    apply/row_subP=> i; apply: eq_row_sub (gring_index G (enum_val i * x)) _.\n    rewrite !rowE mulmxA !mul_rV_lin1 /= -mulmxA -gring_mxJ //.\n    by rewrite -rowE rowK.\n  rewrite (eqmx_eq0 (genmxE _)); apply/rowV0Pn.\n  exists v; last exact: (nz_row_mxsimple irrG).\n  apply/submxP; exists (gring_row (aG 1%g)); rewrite mul_rV_lin1 /=.\n  by rewrite -gring_opE gring_opG // repr_mx1 mulmx1.\nexists U; exists modU; apply: mx_rsim_sym.\nexists (val_factmod 1%:M *m fU) => // [|x Gx].\n  rewrite /row_free eqn_leq rank_leq_row /= -subn_eq0 -mxrank_ker mxrank_eq0.\n  apply/rowV0P=> u /sub_kermxP; rewrite mulmxA => /sub_kermxP.\n  by rewrite -/U -in_factmod_eq0 mulmxA mulmx1 val_factmodK => /eqP.\nrewrite mulmxA -val_factmodE (canRL (addKr _) (add_sub_fact_mod U _)).\nrewrite mulmxDl mulNmx (sub_kermxP (val_submodP _)) oppr0 add0r.\napply/row_matrixP=> i; move: (val_factmod _) => zz.\nby rewrite !row_mul !mul_rV_lin1 /= gring_mxJ // mulmxA.\nQed.",
    "Lemma rsim_regular_series U (compU : mx_composition_series aG U) :\n    (last 0 U :=: 1%:M)%MS ->\n  exists i : 'I_(size U), mx_rsim rG (series_repr i compU).\nProof.\nmove=> lastU; have [V [modV simGV]] := rsim_regular_factmod.\nhave irrV := mx_rsim_irr simGV irrG.\nhave [i simVU] := mx_JordanHolder_max compU lastU irrV.\nby exists i; apply: mx_rsim_trans simGV simVU.\nQed.",
    "Lemma rsim_regular_submod_pchar :\n  {U : 'M_nG & {modU : mxmodule aG U & mx_rsim rG (submod_repr modU)}}.\nProof.\nhave [V [modV eqG'V]] := rsim_regular_factmod.\nhave [U modU defVU dxVU] := mx_Maschke_pchar F'G modV (submx1 V).\nexists U; exists modU; apply: mx_rsim_trans eqG'V _.\nby apply: mx_rsim_factmod; rewrite ?mxdirectE /= addsmxC // addnC.\nQed.",
    "Lemma classg_base_free : row_free classg_base.\nProof.\nrewrite -kermx_eq0; apply/rowV0P=> v /sub_kermxP; rewrite mulmx_sum_row => v0.\napply/rowP=> k /[1!mxE].\nhave [x Gx def_k] := imsetP (enum_valP k).\ntransitivity (@gring_proj F _ G x (vec_mx 0) 0 0); last first.\n  by rewrite !linear0 !mxE.\nrewrite -{}v0 !linear_sum (bigD1 k) //= 2!linearZ /= rowK mxvecK def_k.\nrewrite linear_sum (bigD1 x) ?class_refl //= gring_projE // eqxx.\nrewrite !big1 ?addr0 ?mxE ?mulr1 // => [k' | y /andP[xGy ne_yx]]; first 1 last.\n  by rewrite gring_projE ?(groupCl Gx xGy) // eq_sym (negPf ne_yx).\nrewrite rowK 2!linearZ /= mxvecK -(inj_eq enum_val_inj) def_k eq_sym.\nhave [z Gz ->] := imsetP (enum_valP k').\nmove/eqP=> not_Gxz; rewrite linear_sum big1 ?scaler0 //= => y zGy.\nrewrite gring_projE ?(groupCl Gz zGy) //.\nby case: eqP zGy => // <- /class_eqP.\nQed.",
    "Lemma classg_base_center : (classg_base :=: 'Z(R_G))%MS.\nProof.\napply/eqmxP/andP; split.\n  apply/row_subP=> k; rewrite rowK /gset_mx sub_capmx {1}linear_sum.\n  have [x Gx ->{k}] := imsetP (enum_valP k); have sxGG := groupCl Gx.\n  rewrite summx_sub => [|y xGy]; last by rewrite envelop_mx_id ?sxGG.\n  rewrite memmx_cent_envelop; apply/centgmxP=> y Gy.\n  rewrite {2}(reindex_acts 'J _ Gy) ?astabsJ ?class_norm //=.\n  rewrite mulmx_suml mulmx_sumr; apply: eq_bigr => z; move/sxGG=> Gz.\n  by rewrite -!repr_mxM ?groupJ -?conjgC.\napply/memmx_subP=> A; rewrite sub_capmx memmx_cent_envelop.\ncase/andP=> /envelop_mxP[a ->{A}] cGa.\nrewrite (partition_big_imset (class^~ G)) -/(classes G) /=.\nrewrite linear_sum summx_sub //= => xG GxG; have [x Gx def_xG] := imsetP GxG.\napply: submx_trans (scalemx_sub (a x) (submx_refl _)).\nrewrite (eq_row_sub (enum_rank_in GxG xG)) // linearZ /= rowK enum_rankK_in //.\nrewrite !linear_sum {xG GxG}def_xG; apply: eq_big  => [y | xy] /=.\n  apply/idP/andP=> [| [_ xGy]]; last by rewrite -(eqP xGy) class_refl.\n  by case/imsetP=> z Gz ->; rewrite groupJ // classGidl.\ncase/imsetP=> y Gy ->{xy}; rewrite linearZ; congr (_ *: _).\nmove/(canRL (repr_mxK aG Gy)): (centgmxP cGa y Gy); have Gy' := groupVr Gy.\nmove/(congr1 (gring_proj x)); rewrite -mulmxA mulmx_suml !linear_sum.\nrewrite (bigD1 x Gx) big1 => [|z /andP[Gz]]; rewrite linearZ /=; last first.\n  by rewrite eq_sym gring_projE // => /negPf->; rewrite scaler0.\nrewrite gring_projE // eqxx scalemx1 (bigD1 (x ^ y)%g) ?groupJ //=.\nrewrite big1 => [|z /andP[Gz]]; rewrite -scalemxAl 2!linearZ /=.\n  rewrite !addr0 -!repr_mxM ?groupM // mulgA mulKVg mulgK => /rowP/(_ 0).\n  by rewrite gring_projE // eqxx scalemx1 !mxE.\nrewrite eq_sym -(can_eq (conjgKV y)) conjgK conjgE invgK.\nby rewrite -!repr_mxM ?gring_projE ?groupM // => /negPf->; rewrite scaler0.\nQed.",
    "Lemma regular_module_ideal m (M : 'M_(m, nG)) :\n  mxmodule aG M = right_mx_ideal R_G (M *m R_G).\nProof.\napply/idP/idP=> modM.\n  apply/mulsmx_subP=> A B; rewrite !mem_sub_gring => /andP[R_A M_A] R_B.\n  by rewrite envelop_mxM // gring_row_mul (mxmodule_envelop modM).\napply/mxmoduleP=> x Gx; apply/row_subP=> i; rewrite row_mul -mem_gring_mx.\nrewrite gring_mxJ // (mulsmx_subP modM) ?envelop_mx_id //.\nby rewrite mem_gring_mx row_sub.\nQed.",
    "Lemma irr_degreeE i : 'n_i = \\rank (socle_base i). Proof. by []. Qed.",
    "Lemma irr_degree_gt0 i : 'n_i > 0.\nProof. by rewrite lt0n mxrank_eq0; case: (socle_simple i). Qed.",
    "Lemma irr_reprE i x : irr_repr i x = submod_mx (socle_module i) x.\nProof. by []. Qed.",
    "Lemma rfix_regular : (rfix_mx aG G :=: gring_row (gset_mx G))%MS.\nProof.\napply/eqmxP/andP; split; last first.\n  apply/rfix_mxP => x Gx; rewrite -gring_row_mul; congr gring_row.\n  rewrite {2}/gset_mx (reindex_astabs 'R x) ?astabsR //= mulmx_suml.\n  by apply: eq_bigr => y Gy; rewrite repr_mxM.\napply/rV_subP=> v /rfix_mxP cGv.\nhave /envelop_mxP[a def_v]: (gring_mx aG v \\in R_G)%MS.\n  by rewrite vec_mxK submxMl.\nsuffices ->: v = a 1%g *: gring_row (gset_mx G) by rewrite scalemx_sub.\nrewrite -linearZ scaler_sumr -[v]gring_mxK def_v; congr (gring_row _).\napply: eq_bigr => x Gx; congr (_ *: _).\nmove/rowP/(_ 0): (congr1 (gring_proj x \\o gring_mx aG) (cGv x Gx)).\nrewrite /= gring_mxJ // def_v mulmx_suml !linear_sum (bigD1 1%g) //=.\nrewrite repr_mx1 -scalemxAl mul1mx linearZ /= gring_projE // eqxx scalemx1.\nrewrite big1 ?addr0 ?mxE /= => [ | y /andP[Gy nt_y]]; last first.\n  rewrite -scalemxAl linearZ -repr_mxM //= gring_projE ?groupM //.\n  by rewrite eq_sym eq_mulgV1 mulgK (negPf nt_y) scaler0.\nrewrite (bigD1 x) //= linearZ /= gring_projE // eqxx scalemx1.\nrewrite big1 ?addr0 ?mxE // => y /andP[Gy ne_yx].\nby rewrite linearZ /= gring_projE // eq_sym (negPf ne_yx) scaler0.\nQed.",
    "Lemma principal_comp_subproof : mxsimple aG (rfix_mx aG G).\nProof.\napply: linear_mxsimple; first exact: rfix_mx_module.\napply/eqP; rewrite rfix_regular eqn_leq rank_leq_row lt0n mxrank_eq0.\napply/eqP => /(congr1 (gring_proj 1 \\o gring_mx aG)); apply/eqP.\nrewrite /= -[gring_mx _ _]/(gring_op _ _) !linear0 !linear_sum (bigD1 1%g) //=.\nrewrite gring_opG ?gring_projE // eqxx big1 ?addr0 ?oner_eq0 // => x.\nby case/andP=> Gx nt_x; rewrite gring_opG // gring_projE // eq_sym (negPf nt_x).\nQed.",
    "Lemma irr1_rfix : (1%irr :=: rfix_mx aG G)%MS.\nProof.\nrewrite [1%irr]unlock PackSocleK; apply/eqmxP.\nrewrite (component_mx_id principal_comp_subproof) andbT.\nhave [I [W isoW ->]] := component_mx_def principal_comp_subproof.\napply/sumsmx_subP=> i _; have [f _ hom_f <-]:= isoW i.\n\nby apply/rfix_mxP=> x Gx; rewrite -(hom_mxP hom_f) // (rfix_mxP G _).\nQed.",
    "Lemma rank_irr1 : \\rank 1%irr = 1.\nProof.\napply/eqP; rewrite eqn_leq lt0n mxrank_eq0 nz_socle andbT.\nby rewrite irr1_rfix rfix_regular rank_leq_row.\nQed.",
    "Lemma degree_irr1 : 'n_1 = 1.\nProof.\napply/eqP; rewrite eqn_leq irr_degree_gt0 -rank_irr1.\nby rewrite mxrankS ?component_mx_id //; apply: socle_simple.\nQed.",
    "Lemma Wedderburn_ideal i : mx_ideal R_G 'R_i.\nProof.\napply/andP; split; last first.\n  rewrite /right_mx_ideal genmxE (muls_eqmx (genmxE _) (eqmx_refl _)).\n  by rewrite -[(_ <= _)%MS]regular_module_ideal component_mx_module.\napply/mulsmx_subP=> A B R_A; rewrite !genmxE !mem_sub_gring => /andP[R_B SiB].\nrewrite envelop_mxM {R_A}// gring_row_mul -{R_B}(gring_rowK R_B).\npose f := mulmx (gring_row A) \\o gring_mx aG.\nrewrite -[_ *m _](mul_rV_lin1 f).\nsuffices: (i *m lin1_mx f <= i)%MS by apply: submx_trans; rewrite submxMr.\napply: hom_component_mx; first exact: socle_simple.\napply/rV_subP=> v _; apply/hom_mxP=> x Gx.\nby rewrite !mul_rV_lin1 /f /= gring_mxJ ?mulmxA.\nQed.",
    "Lemma Wedderburn_direct : mxdirect (\\sum_i 'R_i)%MS.\nProof.\napply/mxdirectP; rewrite /= sums_R mxrankMfree ?gring_free //.\nrewrite (mxdirectP (Socle_direct sG)); apply: eq_bigr=> i _ /=.\nby rewrite genmxE mxrankMfree ?gring_free.\nQed.",
    "Lemma Wedderburn_disjoint i j : i != j -> ('R_i :&: 'R_j)%MS = 0.\nProof.\nmove=> ne_ij; apply/eqP; rewrite -submx0 capmxC.\nby rewrite -(mxdirect_sumsP Wedderburn_direct j) // capmxS // (sumsmx_sup i).\nQed.",
    "Lemma Wedderburn_annihilate i j : i != j -> ('R_i * 'R_j)%MS = 0.\nProof.\nmove=> ne_ij; apply/eqP; rewrite -submx0 -(Wedderburn_disjoint ne_ij).\nrewrite sub_capmx; apply/andP; split.\n  case/andP: (Wedderburn_ideal i) => _; apply: submx_trans.\n  by rewrite mulsmxS // genmxE submxMl.\ncase/andP: (Wedderburn_ideal j) => idlRj _; apply: submx_trans idlRj.\nby rewrite mulsmxS // genmxE submxMl.\nQed.",
    "Lemma Wedderburn_mulmx0 i j A B :\n  i != j -> (A \\in 'R_i)%MS -> (B \\in 'R_j)%MS -> A *m B = 0.\nProof.\nmove=> ne_ij RiA RjB; apply: memmx0.\nby rewrite -(Wedderburn_annihilate ne_ij) mem_mulsmx.\nQed.",
    "Lemma irr_mx_sum_pchar : (\\sum_(i : sG) i = 1%:M)%MS.\nProof. by apply: reducible_Socle1; apply: mx_Maschke_pchar. Qed.",
    "Lemma Wedderburn_sum_pchar : (\\sum_i 'R_i :=: R_G)%MS.\nProof.\nby apply: eqmx_trans sums_R _; rewrite /Socle irr_mx_sum_pchar mul1mx.\nQed.",
    "Lemma Wedderburn_sum_id_pchar : \\sum_i 'e_i = 1%:M.\nProof.\nrewrite -linear_sum; apply: canLR mxvecK _.\nhave: (1%:M \\in R_G)%MS := envelop_mx1 aG.\nrewrite -Wedderburn_sum_pchar.\ncase/(sub_dsumsmx Wedderburn_direct) => e Re -> _.\napply: eq_bigr => i _; have dxR := mxdirect_sumsP Wedderburn_direct i (erefl _).\nrewrite (bigD1 i) // mulmxDl proj_mx_id ?Re // proj_mx_0 ?addr0 //=.\nby rewrite summx_sub // => j ne_ji; rewrite (sumsmx_sup j) ?Re.\nQed.",
    "Lemma Wedderburn_id_mem i : ('e_i \\in 'R_i)%MS.\nProof. by rewrite vec_mxK proj_mx_sub. Qed.",
    "Lemma Wedderburn_is_id_pchar i : mxring_id 'R_i 'e_i.\nProof.\nhave ideRi A: (A \\in 'R_i)%MS -> 'e_i *m A = A.\n  move=> RiA; rewrite -{2}[A]mul1mx -Wedderburn_sum_id_pchar mulmx_suml.\n  rewrite (bigD1 i) //= big1 ?addr0 // => j ne_ji.\n  by rewrite (Wedderburn_mulmx0 ne_ji) ?Wedderburn_id_mem.\n  split=> // [||A RiA]; first 2 [exact: Wedderburn_id_mem].\n  apply: contraNneq (nz_socle i) => e0.\n  apply/rowV0P=> v; rewrite -mem_gring_mx -(genmxE (i *m _)) => /ideRi.\n  by rewrite e0 mul0mx => /(canLR gring_mxK); rewrite linear0.\nrewrite -{2}[A]mulmx1 -Wedderburn_sum_id_pchar mulmx_sumr (bigD1 i) //=.\nrewrite big1 ?addr0 // => j; rewrite eq_sym => ne_ij.\nby rewrite (Wedderburn_mulmx0 ne_ij) ?Wedderburn_id_mem.\nQed.",
    "Lemma Wedderburn_closed_pchar i : ('R_i * 'R_i = 'R_i)%MS.\nProof.\nrewrite -{3}['R_i]genmx_id -/'R_i -genmx_muls; apply/genmxP.\nhave [idlRi idrRi] := andP (Wedderburn_ideal i).\napply/andP; split.\n  by apply: submx_trans idrRi; rewrite mulsmxS // genmxE submxMl.\nhave [_ Ri_e ideRi _] := Wedderburn_is_id_pchar i.\nby apply/memmx_subP=> A RiA; rewrite -[A]ideRi ?mem_mulsmx.\nQed.",
    "Lemma Wedderburn_is_ring_pchar i : mxring 'R_i.\nProof.\nrewrite /mxring /left_mx_ideal Wedderburn_closed_pchar submx_refl.\nby apply/mxring_idP; exists 'e_i; apply: Wedderburn_is_id_pchar.\nQed.",
    "Lemma Wedderburn_min_ideal_pchar m i (E : 'A_(m, nG)) :\n  E != 0 -> (E <= 'R_i)%MS -> mx_ideal R_G E -> (E :=: 'R_i)%MS.\nProof.\nmove=> nzE sE_Ri /andP[idlE idrE]; apply/eqmxP; rewrite sE_Ri.\npose M := E *m pinvmx R_G; have defE: E = M *m R_G.\n  by rewrite mulmxKpV // (submx_trans sE_Ri) // genmxE submxMl.\nhave modM: mxmodule aG M by rewrite regular_module_ideal -defE.\nhave simSi := socle_simple i; set Si := socle_base i in simSi.\nhave [I [W isoW defW]]:= component_mx_def simSi.\nrewrite /'R_i /socle_val /= defW genmxE defE submxMr //.\napply/sumsmx_subP=> j _.\nhave simW := mx_iso_simple (isoW j) simSi; have [modW _ minW] := simW.\nhave [{minW}dxWE | nzWE] := eqVneq (W j :&: M)%MS 0; last first.\n  by rewrite (sameP capmx_idPl eqmxP) minW ?capmxSl ?capmx_module.\nhave [_ Rei ideRi _] := Wedderburn_is_id_pchar i.\nhave:= nzE; rewrite -submx0 => /memmx_subP[A E_A].\nrewrite -(ideRi _ (memmx_subP sE_Ri _ E_A)).\nhave:= E_A; rewrite defE mem_sub_gring => /andP[R_A M_A].\nhave:= Rei; rewrite genmxE mem_sub_gring => /andP[Re].\nrewrite -{2}(gring_rowK Re) /socle_val defW => /sub_sumsmxP[e ->].\nrewrite !(linear_sum, mulmx_suml) summx_sub //= => k _.\nrewrite -(gring_rowK R_A) -gring_mxA -mulmxA gring_rowK //.\nrewrite ((W k *m _ =P 0) _) ?linear0 ?sub0mx //.\nhave [f _ homWf defWk] := mx_iso_trans (mx_iso_sym (isoW j)) (isoW k).\nrewrite -submx0 -{k defWk}(eqmxMr _ defWk) -(hom_envelop_mxC homWf) //.\nrewrite -(mul0mx _ f) submxMr {f homWf}// -dxWE sub_capmx.\nrewrite (mxmodule_envelop modW) //=; apply/row_subP=> k.\nrewrite row_mul -mem_gring_mx -(gring_rowK R_A) gring_mxA gring_rowK //.\nby rewrite -defE (memmx_subP idlE) // mem_mulsmx ?gring_mxP.\nQed.",
    "Lemma rsim_irr_comp_pchar : mx_rsim rG (irr_repr iG).\nProof.\nhave [M [modM rsimM]] := rsim_regular_submod_pchar irrG F'G.\nhave simM: mxsimple aG M.\n  case/mx_irrP: irrG => n_gt0 minG.\n  have [f def_n injf homf] := mx_rsim_sym rsimM.\n  apply/(submod_mx_irr modM)/mx_irrP.\n  split=> [|U modU nzU]; first by rewrite def_n.\n  rewrite /row_full -(mxrankMfree _ injf) -genmxE {4}def_n.\n  apply: minG; last by rewrite -mxrank_eq0 genmxE mxrankMfree // mxrank_eq0.\n  rewrite (eqmx_module _ (genmxE _)); apply/mxmoduleP=> x Gx.\n  by rewrite -mulmxA -homf // mulmxA submxMr // (mxmoduleP modU).\npose i := PackSocle (component_socle sG simM).\nhave{modM} rsimM: mx_rsim rG (socle_repr i).\n  apply: mx_rsim_trans rsimM (mx_rsim_sym _); apply/mx_rsim_iso.\n  apply: (component_mx_iso (socle_simple _)) => //.\n  by rewrite [component_mx _ _]PackSocleK component_mx_id.\nhave [<- // | ne_i_iG] := eqVneq i iG.\nsuffices {i M simM ne_i_iG rsimM}: gring_op rG 'e_iG != 0.\n  by rewrite (not_rsim_op0_pchar rsimM ne_i_iG) ?Wedderburn_id_mem ?eqxx.\nrewrite /iG; case: pickP => //= G0.\nsuffices: rG 1%g == 0.\n  by case/idPn; rewrite -mxrank_eq0 repr_mx1 mxrank1 -lt0n; case/mx_irrP: irrG.\nrewrite -gring_opG // repr_mx1 -Wedderburn_sum_id_pchar linear_sum big1 //.\nby move=> j _; move/eqP: (G0 j).\nQed.",
    "Lemma irr_comp'_op0_pchar j A : j != iG -> (A \\in 'R_j)%MS -> gring_op rG A = 0.\nProof. by rewrite eq_sym; apply: not_rsim_op0_pchar rsim_irr_comp_pchar. Qed.",
    "Lemma irr_comp_envelop_pchar : ('R_iG *m lin_mx (gring_op rG) :=: E_G)%MS.\nProof.\napply/eqmxP/andP; split; apply/row_subP=> i.\n  by rewrite row_mul mul_rV_lin gring_mxP.\nrewrite rowK /= -gring_opG ?enum_valP // -mul_vec_lin -gring_opG ?enum_valP //.\nrewrite vec_mxK /= -mulmxA mulmx_sub {i}//= -(eqmxMr _ Wedderburn_sum_pchar).\nrewrite (bigD1 iG) //= addsmxMr addsmxC [_ *m _](sub_kermxP _) ?adds0mx //=.\napply/sumsmx_subP => j ne_j_iG; apply/memmx_subP=> A RjA; apply/sub_kermxP.\nby rewrite mul_vec_lin /= (irr_comp'_op0_pchar ne_j_iG RjA) linear0.\nQed.",
    "Lemma ker_irr_comp_op_pchar : ('R_iG :&: kermx (lin_mx (gring_op rG)))%MS = 0.\nProof.\napply/eqP; rewrite -submx0; apply/memmx_subP=> A.\nrewrite sub_capmx /= submx0 mxvec_eq0 => /andP[R_A].\nrewrite (sameP sub_kermxP eqP) mul_vec_lin mxvec_eq0 /= => opA0.\nhave [_ Re ideR _] := Wedderburn_is_id_pchar iG; rewrite -[A]ideR {ideR}//.\nmove: Re; rewrite genmxE mem_sub_gring /socle_val => /andP[Re].\nrewrite -{2}(gring_rowK Re) -submx0.\npose simMi := socle_simple iG; have [J [M isoM ->]] := component_mx_def simMi.\ncase/sub_sumsmxP=> e ->; rewrite linear_sum mulmx_suml summx_sub // => j _.\nrewrite -(in_submodK (submxMl _ (M j))); move: (in_submod _ _) => v.\nhave modMj: mxmodule aG (M j) by apply: mx_iso_module (isoM j) _; case: simMi.\nhave rsimMj: mx_rsim rG (submod_repr modMj).\n  by apply: mx_rsim_trans rsim_irr_comp_pchar _; apply/mx_rsim_iso.\nhave [f [f' _ hom_f]] := mx_rsim_def (mx_rsim_sym rsimMj); rewrite submx0.\nhave <-: (gring_mx aG (val_submod (v *m (f *m gring_op rG A *m f')))) = 0.\n  by rewrite (eqP opA0) !(mul0mx, linear0).\nhave: (A \\in R_G)%MS by rewrite -Wedderburn_sum_pchar (sumsmx_sup iG).\ncase/envelop_mxP=> a ->; rewrite !(linear_sum, mulmx_suml) /=; apply/eqP.\napply: eq_bigr=> x Gx; rewrite 3!linearZ -scalemxAl 3!linearZ /=.\nby rewrite gring_opG // -hom_f // val_submodJ // gring_mxJ.\nQed.",
    "Lemma regular_op_inj_pchar :\n  {in [pred A | (A \\in 'R_iG)%MS] &, injective (gring_op rG)}.\nProof.\nmove=> A B RnA RnB /= eqAB; apply/eqP; rewrite -subr_eq0 -mxvec_eq0 -submx0.\nrewrite -ker_irr_comp_op_pchar sub_capmx (sameP sub_kermxP eqP) mul_vec_lin.\nby rewrite 2!raddfB /= eqAB subrr linear0 addmx_sub ?eqmx_opp /=.\nQed.",
    "Lemma rank_irr_comp_pchar : \\rank 'R_iG = \\rank E_G.\nProof.\nrewrite -irr_comp_envelop_pchar; apply/esym/mxrank_injP.\nby rewrite ker_irr_comp_op_pchar.\nQed.",
    "Lemma irr_comp_rsim_pchar n1 n2 rG1 rG2 :\n  @mx_rsim _ G n1 rG1 n2 rG2 -> irr_comp rG1 = irr_comp rG2.\nProof.\ncase=> f eq_n12; rewrite -eq_n12 in rG2 f * => inj_f hom_f.\nrewrite /irr_comp; apply/f_equal/eq_pick => i; rewrite -!mxrank_eq0.\n\nrewrite -(mxrankMfree _ inj_f); symmetry; rewrite -(eqmxMfull _ inj_f).\nhave /envelop_mxP[e ->{i}]: ('e_i \\in R_G)%MS.\n  by rewrite -Wedderburn_sum_pchar (sumsmx_sup i) ?Wedderburn_id_mem.\ncongr (\\rank _ != _); rewrite !(mulmx_suml, linear_sum); apply: eq_bigr => x Gx.\nby rewrite 3!linearZ -scalemxAl /= !gring_opG ?hom_f.\nQed.",
    "Lemma irr_reprK_pchar  i : irr_comp (irr_repr i) = i.\nProof.\napply/eqP; apply/component_mx_isoP; try exact: socle_simple.\nby move/mx_rsim_iso: (rsim_irr_comp_pchar (socle_irr i)); apply: mx_iso_sym.\nQed.",
    "Lemma irr_repr'_op0_pchar i j A :\n  j != i -> (A \\in 'R_j)%MS -> gring_op (irr_repr i) A = 0.\nProof.\nmove=> neq_ij /(irr_comp'_op0_pchar _).\nby move=> ->; [|apply: socle_irr|rewrite irr_reprK_pchar].\nQed.",
    "Lemma op_Wedderburn_id_pchar i : gring_op (irr_repr i) 'e_i = 1%:M.\nProof.\nrewrite -(gring_op1 (irr_repr i)) -Wedderburn_sum_id_pchar. \nrewrite linear_sum (bigD1 i) //= addrC big1 ?add0r // => j neq_ji.\nexact: irr_repr'_op0_pchar (Wedderburn_id_mem j).\nQed.",
    "Lemma irr_comp_id_pchar (M : 'M_nG) (modM : mxmodule aG M) (iM : sG) :\n  mxsimple aG M -> (M <= iM)%MS -> irr_comp (submod_repr modM) = iM.\nProof.\nmove=> simM sMiM; rewrite -[iM]irr_reprK_pchar.\napply/esym/irr_comp_rsim_pchar/mx_rsim_iso/component_mx_iso => //.\nexact: socle_simple.\nQed.",
    "Lemma irr1_repr x : x \\in G -> irr_repr 1 x = 1%:M.\nProof.\nmove=> Gx; suffices: x \\in rker (irr_repr 1) by case/rkerP.\napply: subsetP x Gx; rewrite rker_submod rfix_mx_rstabC // -irr1_rfix.\nby apply: component_mx_id; apply: socle_simple.\nQed.",
    "Lemma rank_Wedderburn_subring_pchar i : \\rank 'R_i = ('n_i ^ 2)%N.\nProof.\napply/eqP; rewrite -{1}[i]irr_reprK_pchar; have irrSi := socle_irr i.\nby case/andP: (splitG irrSi) => _; rewrite rank_irr_comp_pchar.\nQed.",
    "Lemma sum_irr_degree_pchar : (\\sum_i 'n_i ^ 2 = nG)%N.\nProof.\napply: etrans (eqnP gring_free).\nrewrite -Wedderburn_sum_pchar (mxdirectP Wedderburn_direct) /=.\nby apply: eq_bigr => i _; rewrite rank_Wedderburn_subring_pchar.\nQed.",
    "Lemma irr_mx_mult_pchar i : socle_mult i = 'n_i.\nProof.\nrewrite /socle_mult -(mxrankMfree _ gring_free) -genmxE.\nby rewrite rank_Wedderburn_subring_pchar mulKn ?irr_degree_gt0.\nQed.",
    "Lemma mxtrace_regular_pchar :\n  {in G, forall x, \\tr (aG x) = \\sum_i \\tr (socle_repr i x) *+ 'n_i}.\nProof.\nmove=> x Gx; have soc1: (Socle sG :=: 1%:M)%MS by rewrite -irr_mx_sum_pchar.\nrewrite -(mxtrace_submod1 (Socle_module sG) soc1) // mxtrace_Socle //.\nby apply: eq_bigr => i _; rewrite irr_mx_mult_pchar.\nQed.",
    "Lemma irr_degree_abelian : abelian G -> forall i, 'n_i = 1.\nProof. by move=> cGG i; apply: mxsimple_abelian_linear (socle_simple i). Qed.",
    "Lemma linear_irr_comp_pchar i : 'n_i = 1 -> (i :=: socle_base i)%MS.\nProof.\nmove=> ni1; apply/eqmxP; rewrite andbC -mxrank_leqif_eq -/'n_i.\n  rewrite -(mxrankMfree _ gring_free) -genmxE.\n  by rewrite rank_Wedderburn_subring_pchar ni1.\nexact: component_mx_id (socle_simple i).\nQed.",
    "Lemma Wedderburn_subring_center_pchar i : ('Z('R_i) :=: mxvec 'e_i)%MS.\nProof.\nhave [nz_e Re ideR idRe] := Wedderburn_is_id_pchar i.\nhave Ze: (mxvec 'e_i <= 'Z('R_i))%MS.\n  rewrite sub_capmx [(_ <= _)%MS]Re.\n  by apply/cent_mxP=> A R_A; rewrite ideR // idRe.\npose irrG := socle_irr i; set rG := socle_repr i in irrG.\npose E_G := enveloping_algebra_mx rG; have absG := splitG irrG.\napply/eqmxP; rewrite andbC -(geq_leqif (mxrank_leqif_eq Ze)).\nhave ->: \\rank (mxvec 'e_i) = (0 + 1)%N.\n  by apply/eqP; rewrite eqn_leq rank_leq_row lt0n mxrank_eq0 mxvec_eq0.\nrewrite -(mxrank_mul_ker _ (lin_mx (gring_op rG))) addnC leq_add //.\n  rewrite leqn0 mxrank_eq0 -submx0 -(ker_irr_comp_op_pchar irrG) capmxS //.\n  by rewrite irr_reprK_pchar capmxSl.\napply: leq_trans (mxrankS _) (rank_leq_row (mxvec 1%:M)).\napply/memmx_subP=> Ar; case/submxP=> a ->{Ar}.\nrewrite mulmxA mul_rV_lin /=; set A := vec_mx _.\nrewrite memmx1 (mx_abs_irr_cent_scalar absG) // -memmx_cent_envelop.\napply/cent_mxP=> Br; rewrite -(irr_comp_envelop_pchar irrG) irr_reprK_pchar.\ncase/submxP=> b /(canRL mxvecK) ->{Br}; rewrite mulmxA mx_rV_lin /=.\nset B := vec_mx _; have RiB: (B \\in 'R_i)%MS by rewrite vec_mxK submxMl.\nhave sRiR: ('R_i <= R_G)%MS by rewrite -Wedderburn_sum_pchar (sumsmx_sup i).\nhave: (A \\in 'Z('R_i))%MS by rewrite vec_mxK submxMl.\nrewrite sub_capmx => /andP[RiA /cent_mxP cRiA].\nby rewrite -!gring_opM ?(memmx_subP sRiR) 1?cRiA.\nQed.",
    "Lemma Wedderburn_center_pchar :\n  ('Z(R_G) :=: \\matrix_(i < #|sG|) mxvec 'e_(enum_val i))%MS.\nProof.\nhave:= mxdirect_sums_center\n  Wedderburn_sum_pchar Wedderburn_direct Wedderburn_ideal.\nmove/eqmx_trans; apply; apply/eqmxP/andP; split.\n  apply/sumsmx_subP=> i _; rewrite Wedderburn_subring_center_pchar.\n  by apply: (eq_row_sub (enum_rank i)); rewrite rowK enum_rankK.\napply/row_subP=> i; rewrite rowK -Wedderburn_subring_center_pchar.\nby rewrite (sumsmx_sup (enum_val i)).\nQed.",
    "Lemma card_irr_pchar : #|sG| = tG.\nProof.\nrewrite -(eqnP classg_base_free) classg_base_center.\nhave:= mxdirect_sums_center\n  Wedderburn_sum_pchar Wedderburn_direct Wedderburn_ideal.\nmove->; rewrite (mxdirectP _) /=; last first.\n  apply/mxdirect_sumsP=> i _; apply/eqP; rewrite -submx0.\n  rewrite -{2}(mxdirect_sumsP Wedderburn_direct i) // capmxS ?capmxSl //=.\n  by apply/sumsmx_subP=> j neji; rewrite (sumsmx_sup j) ?capmxSl.\nrewrite -sum1_card; apply: eq_bigr => i _; apply/eqP.\nrewrite Wedderburn_subring_center_pchar eqn_leq rank_leq_row lt0n mxrank_eq0.\nby rewrite andbT mxvec_eq0; case: (Wedderburn_is_id_pchar i).\nQed.",
    "Lemma irr_mode1 : irr_mode 1 = 1.\nProof. by rewrite /irr_mode repr_mx1 mxE eqxx. Qed.",
    "Lemma irr_center_scalar : {in 'Z(G), forall x, irr_repr i x = (irr_mode x)%:M}.\nProof.\nrewrite /irr_mode => x /setIP[Gx cGx].\nsuffices [a ->]: exists a, irr_repr i x = a%:M by rewrite mxE eqxx.\napply/is_scalar_mxP; apply: (mx_abs_irr_cent_scalar (splitG (socle_irr i))).\nby apply/centgmxP=> y Gy; rewrite -!{1}repr_mxM 1?(centP cGx).\nQed.",
    "Lemma irr_modeM : {in 'Z(G) &, {morph irr_mode : x y / (x * y)%g >-> x * y}}.\nProof.\nmove=> x y Zx Zy; rewrite {1}/irr_mode repr_mxM ?(subsetP (center_sub G)) //.\nby rewrite !irr_center_scalar // -scalar_mxM mxE eqxx.\nQed.",
    "Lemma irr_modeX n : {in 'Z(G), {morph irr_mode : x / (x ^+ n)%g >-> x ^+ n}}.\nProof.\nelim: n => [|n IHn] x Zx; first exact: irr_mode1.\nby rewrite expgS irr_modeM ?groupX // exprS IHn.\nQed.",
    "Lemma irr_mode_unit : {in 'Z(G), forall x, irr_mode x \\is a GRing.unit}.\nProof.\nmove=> x Zx /=; have:= unitr1 F.\nby rewrite -irr_mode1 -(mulVg x) irr_modeM ?groupV // unitrM; case/andP=> _.\nQed.",
    "Lemma irr_mode_neq0 : {in 'Z(G), forall x, irr_mode x != 0}.\nProof. by move=> x /irr_mode_unit; rewrite unitfE. Qed.",
    "Lemma irr_modeV : {in 'Z(G), {morph irr_mode : x / (x^-1)%g >-> x^-1}}.\nProof.\nmove=> x Zx /=; rewrite -[_^-1]mul1r; apply: canRL (mulrK (irr_mode_unit Zx)) _.\nby rewrite -irr_modeM ?groupV // mulVg irr_mode1.\nQed.",
    "Lemma irr1_mode x : x \\in G -> irr_mode 1 x = 1.\nProof. by move=> Gx; rewrite /irr_mode irr1_repr ?mxE. Qed.",
    "Lemma card_linear_irr (sG : irrType G) :\n    [pchar F]^'.-group G -> group_splitting_field G ->\n  #|linear_irr sG| = #|G : G^`(1)|%g.\nProof.\nmove=> F'G splitG; apply/eqP.\nwlog sGq: / irrType (G / G^`(1))%G by apply: socle_exists.\nhave [_ nG'G] := andP (der_normal 1 G); apply/eqP; rewrite -card_quotient //.\nhave cGqGq: abelian (G / G^`(1))%g by apply: sub_der1_abelian.\nhave F'Gq: [pchar F]^'.-group (G / G^`(1))%g by apply: morphim_pgroup.\nhave splitGq: group_splitting_field (G / G^`(1))%G.\n  exact: quotient_splitting_field.\nrewrite -(sum_irr_degree_pchar sGq) // -sum1_card.\npose rG (j : sGq) := morphim_repr (socle_repr j) nG'G.\nhave irrG j: mx_irreducible (rG j) by apply/morphim_mx_irr; apply: socle_irr.\nrewrite (reindex (fun j => irr_comp sG (rG j))) /=.\n  apply: eq_big => [j | j _]; last by rewrite irr_degree_abelian.\n  have [_ lin_j _ _] := rsim_irr_comp_pchar sG F'G (irrG j).\n  by rewrite inE -lin_j -irr_degreeE irr_degree_abelian.\npose sGlin := {i | i \\in linear_irr sG}.\nhave sG'k (i : sGlin) : G^`(1)%g \\subset rker (irr_repr (val i)).\n  by case: i => i /= /[!inE] lin; rewrite rker_linear //=; apply/eqP.\npose h' u := irr_comp sGq (quo_repr (sG'k u) nG'G).\nhave irrGq u: mx_irreducible (quo_repr (sG'k u) nG'G).\n  by apply/quo_mx_irr; apply: socle_irr.\nexists (fun i => oapp h' [1 sGq]%irr (insub i)) => [j | i] lin_i.\n  rewrite (insubT [in _] lin_i) /=; apply/esym/eqP/socle_rsimP.\n  apply: mx_rsim_trans (rsim_irr_comp_pchar sGq F'Gq (irrGq _)).\n  have [g lin_g inj_g hom_g] := rsim_irr_comp_pchar sG F'G (irrG j).\n  exists g => [||G'x]; last 1 [case/morphimP=> x _ Gx ->] || by [].\n  by rewrite quo_repr_coset ?hom_g.\nrewrite (insubT (mem _) lin_i) /=; apply/esym/eqP/socle_rsimP.\nset u := Sub i lin_i.\napply: mx_rsim_trans (rsim_irr_comp_pchar sG F'G (irrG _)).\nhave [g lin_g inj_g hom_g] := rsim_irr_comp_pchar sGq F'Gq (irrGq u).\nexists g => [||x Gx]; last 1 [have:= hom_g (coset _ x)] || by [].\nby rewrite quo_repr_coset; first by apply; rewrite mem_quotient.\nQed.",
    "Lemma primitive_root_splitting_abelian (z : F) :\n  #|G|.-primitive_root z -> abelian G -> group_splitting_field G.\nProof.\nmove=> ozG cGG [|n] rG irrG; first by case/mx_irrP: irrG.\ncase: (pickP [pred x in G | ~~ is_scalar_mx (rG x)]) => [x | scalG].\n  case/andP=> Gx nscal_rGx; have: horner_mx (rG x) ('X^#|G| - 1) == 0.\n    rewrite rmorphB rmorphXn /= horner_mx_C horner_mx_X.\n    rewrite -repr_mxX ?inE // ((_ ^+ _ =P 1)%g _) ?repr_mx1 ?subrr //.\n    by rewrite -order_dvdn order_dvdG.\n  case/idPn; rewrite -mxrank_eq0 -(factor_Xn_sub_1 ozG).\n  elim: #|G| => [|i IHi]; first by rewrite big_nil horner_mx_C mxrank1.\n  rewrite big_nat_recr => [|//]; rewrite rmorphM mxrankMfree {IHi}//=.\n  rewrite row_free_unit rmorphB /= horner_mx_X horner_mx_C.\n  rewrite (mx_Schur irrG) ?subr_eq0 //; last first.\n    by apply: contraNneq nscal_rGx => ->; apply: scalar_mx_is_scalar.\n  rewrite -memmx_cent_envelop raddfB.\n  rewrite addmx_sub ?eqmx_opp ?scalar_mx_cent //= memmx_cent_envelop.\n  by apply/centgmxP=> j Zh_j; rewrite -!repr_mxM // (centsP cGG).\npose M := <<delta_mx 0 0 : 'rV[F]_n.+1>>%MS.\nhave linM: \\rank M = 1 by rewrite genmxE mxrank_delta.\nhave modM: mxmodule rG M.\n  apply/mxmoduleP=> x Gx; move/idPn: (scalG x); rewrite /= Gx negbK.\n  by case/is_scalar_mxP=> ? ->; rewrite scalar_mxC submxMl.\napply: linear_mx_abs_irr; apply/eqP; rewrite eq_sym -linM.\nby case/mx_irrP: irrG => _; apply; rewrite // -mxrank_eq0 linM.\nQed.",
    "Lemma cycle_repr_structure_pchar x (sG : irrType G) :\n    G :=: <[x]> -> [pchar F]^'.-group G -> group_splitting_field G ->\n  exists2 w : F, #|G|.-primitive_root w &\n  exists iphi : 'I_#|G| -> sG,\n  [/\\ bijective iphi,\n      #|sG| = #|G|,\n      forall i, irr_mode (iphi i) x = w ^+ i\n    & forall i, irr_repr (iphi i) x = (w ^+ i)%:M].\nProof.\nmove=> defG; rewrite {defG}(group_inj defG) -/#[x] in sG * => F'X splitF.\nhave Xx := cycle_id x; have cXX := cycle_abelian x.\nhave card_sG: #|sG| = #[x].\n  by rewrite card_irr_pchar //; apply/eqP; rewrite -card_classes_abelian.\nhave linX := irr_degree_abelian splitF cXX (_ : sG).\npose r (W : sG) := irr_mode W x.\nhave scalX W: irr_repr W x = (r W)%:M.\n  by apply: irr_center_scalar; rewrite ?(center_idP _).\nhave inj_r: injective r.\n  move=> V W eqVW; rewrite -(irr_reprK_pchar F'X V) -(irr_reprK_pchar F'X W).\n  move: (irr_repr V) (irr_repr W) (scalX V) (scalX W).\n  rewrite !linX {}eqVW => rV rW <- rWx; apply: irr_comp_rsim_pchar => //.\n  exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => xk; case/cycleP=> k ->{xk}.\n  by rewrite mulmx1 mul1mx !repr_mxX // rWx.\nhave rx1 W: r W ^+ #[x] = 1.\n  by rewrite -irr_modeX ?(center_idP _) // expg_order irr_mode1.\nhave /hasP[w _ prim_w]: has #[x].-primitive_root (map r (enum sG)).\n  rewrite has_prim_root 1?map_inj_uniq ?enum_uniq //; first 1 last.\n    by rewrite size_map -cardE card_sG.\n  by apply/allP=> _ /mapP[W _ ->]; rewrite unity_rootE rx1.\nhave iphi'P := prim_rootP prim_w (rx1 _); pose iphi' := sval (iphi'P _).\nhave def_r W: r W = w ^+ iphi' W by apply: svalP (iphi'P W).\nhave inj_iphi': injective iphi'.\n  by move=> i j eq_ij; apply: inj_r; rewrite !def_r eq_ij.\nhave iphiP: codom iphi' =i 'I_#[x].\n  by apply/subset_cardP; rewrite ?subset_predT // card_ord card_image.\npose iphi i := iinv (iphiP i); exists w => //; exists iphi.\nhave iphiK: cancel iphi iphi' by move=> i; apply: f_iinv.\nhave r_iphi i: r (iphi i) = w ^+ i by rewrite def_r iphiK.\nsplit=> // [|i]; last by rewrite scalX r_iphi.\nby exists iphi' => // W; rewrite /iphi iinv_f.\nQed.",
    "Lemma splitting_cyclic_primitive_root_pchar :\n    cyclic G -> [pchar F]^'.-group G -> group_splitting_field G ->\n  classically {z : F | #|G|.-primitive_root z}.\nProof.\ncase/cyclicP=> x defG F'G splitF; case=> // IH.\nwlog sG: / irrType G by apply: socle_exists.\nhave [w prim_w _] := cycle_repr_structure_pchar sG defG F'G splitF.\nby apply: IH; exists w.\nQed.",
    "Lemma mxmodule_form_qf U : qf_form (mxmodule_form U).\nProof.\nby rewrite (morphAnd (@qf_form _)) ?big1 //= => x _; rewrite submx_form_qf.\nQed.",
    "Lemma eval_mxmodule U e :\n  qf_eval e (mxmodule_form U) = mxmodule rG (eval_mx e U).\nProof.\nrewrite (morphAnd (qf_eval e)) //= big_andE /=.\napply/forallP/mxmoduleP=> Umod x; move/implyP: (Umod x);\n  by rewrite eval_submx eval_mulmx eval_mx_term.\nQed.",
    "Lemma mxnonsimpleP U :\n  U != 0 -> reflect (mxnonsimple rG U) (mxnonsimple_sat U).\nProof.\nrewrite /mxnonsimple_sat {1}/mxnonsimple_form; set Vt := vec_mx _ => /= nzU.\npose nsim V := [&& mxmodule rG V, (V <= U)%MS, V != 0 & \\rank V < \\rank U].\nset nsimUt := (_ /\\ _)%T; have: qf_form nsimUt.\n  by rewrite /= mxmodule_form_qf !mxrank_form_qf !submx_form_qf.\nmove/GRing.qf_evalP; set qev := @GRing.qf_eval _ => qevP.\nhave qev_nsim u: qev (row_env [:: u]) nsimUt = nsim n (vec_mx u).\n  rewrite /nsim -mxrank_eq0 /qev /= eval_mxmodule eval_mxrank.\n  rewrite !eval_submx eval_mx_term eval_vec_mx eval_row_var /=.\n  do 2!bool_congr; apply: andb_id2l => sUV.\n  by rewrite ltn_neqAle andbC !mxrank_leqif_sup.\nhave n2gt0: n ^ 2 > 0.\n  by move: nzU; rewrite muln_gt0 -mxrank_eq0 unlock; case: posnP (U) => // ->.\napply: (iffP satP) => [|[V nsimV]].\n  by case/Exists_rowP=> // v; move/qevP; rewrite qev_nsim; exists (vec_mx v).\napply/Exists_rowP=> //; exists (mxvec V); apply/qevP.\nby rewrite qev_nsim mxvecK.\nQed.",
    "Lemma dec_mxsimple_exists (U : 'M_n) :\n  mxmodule rG U -> U != 0 -> {V | mxsimple rG V & V <= U}%MS.\nProof.\nhave [m] := ubnP (\\rank U); elim: m U => // m IHm U leUm modU nzU.\nhave [nsimU | simU] := mxnonsimpleP nzU; last first.\n  by exists U; first apply/mxsimpleP.\nmove: (xchooseP nsimU); move: (xchoose _) => W /and4P[modW sWU nzW ltWU].\ncase: (IHm W) => // [|V simV sVW]; first exact: leq_trans ltWU _.\nby exists V; last apply: submx_trans sVW sWU.\nQed.",
    "Lemma dec_mx_reducible_semisimple U :\n  mxmodule rG U -> mx_completely_reducible rG U -> mxsemisimple rG U.\nProof.\nhave [m] := ubnP (\\rank U); elim: m U => // m IHm U leUm modU redU.\nhave [U0 | nzU] := eqVneq U 0.\n  have{} U0: (\\sum_(i < 0) 0 :=: U)%MS by rewrite big_ord0 U0.\n  by apply: (intro_mxsemisimple U0); case.\nhave [V simV sVU] := dec_mxsimple_exists modU nzU; have [modV nzV _] := simV.\nhave [W modW defVW dxVW] := redU V modV sVU.\nhave [||I W_ /= simW defW _] := IHm W _ modW.\n- rewrite ltnS in leUm; apply: leq_trans leUm.\n  by rewrite -defVW (mxdirectP dxVW) /= -add1n leq_add2r lt0n mxrank_eq0.\n- by apply: mx_reducibleS redU; rewrite // -defVW addsmxSr.\nsuffices defU: (\\sum_i oapp W_ V i :=: U)%MS.\n  by apply: (intro_mxsemisimple defU) => [] [|i] //=.\napply: eqmx_trans defVW; rewrite (bigD1 None) //=; apply/eqmxP.\nhave [i0 _ | I0] := pickP I.\n  by rewrite (reindex some) ?addsmxS ?defW //; exists (odflt i0) => //; case.\nrewrite big_pred0 //; last by case=> // /I0.\nby rewrite !addsmxS ?sub0mx // -defW big_pred0.\nQed.",
    "Lemma DecSocleType : socleType rG.\nProof.\nhave [n0 | n_gt0] := posnP n.\n  by exists [::] => // M [_]; rewrite -mxrank_eq0 -leqn0 -n0 rank_leq_row.\nhave n2_gt0: n ^ 2 > 0 by rewrite muln_gt0 n_gt0.\npose span Ms := (\\sum_(M <- Ms) component_mx rG M)%MS.\nhave: {in [::], forall M, mxsimple rG M} by [].\nhave [m] := ubnP (n - \\rank (span [::])).\nelim: m [::] => // m IHm Ms /ltnSE-Ms_ge_n simMs.\npose V := span Ms; pose Vt := mx_term V.\npose Ut i := vec_mx (row_var F (n * n) i); pose Zt := mx_term (0 : 'M[F]_n).\npose exU i f := Exists_row_form (n * n) i (~ submx_form (Ut i) Zt /\\ f (Ut i)).\npose meetUVf U := exU 1 (fun W => submx_form W Vt /\\ submx_form W U)%T.\npose mx_sat := GRing.sat (@row_env F (n * n) [::]).\nhave ev_sub0 := GRing.qf_evalP _ (submx_form_qf _ Zt).\nhave ev_mod := GRing.qf_evalP _ (mxmodule_form_qf rG _).\npose ev := (eval_mxmodule, eval_submx, eval_vec_mx, eval_row_var, eval_mx_term).\ncase haveU: (mx_sat (exU 0 (fun U => mxmodule_form rG U /\\ ~ meetUVf _ U)%T)).\n  have [U modU]: {U : 'M_n | mxmodule rG U & (U != 0) && ((U :&: V)%MS == 0)}.\n    apply: sig2W; case/Exists_rowP: (satP haveU) => //= u [nzU [modU tiUV]].\n    exists (vec_mx u); first by move/ev_mod: modU; rewrite !ev.\n    set W := (_ :&: V)%MS; move/ev_sub0: nzU; rewrite !ev -!submx0 => -> /=.\n    apply/idPn=> nzW; case: tiUV; apply/Exists_rowP=> //; exists (mxvec W).\n    apply/GRing.qf_evalP; rewrite /= ?submx_form_qf // !ev mxvecK nzW /=.\n    by rewrite andbC -sub_capmx.\n  case/andP=> nzU tiUV; have [M simM sMU] := dec_mxsimple_exists modU nzU.\n  apply: (IHm (M :: Ms)) => [|M']; last first.\n    by case/predU1P=> [-> //|]; apply: simMs.\n  have [_ nzM _] := simM.\n  suffices ltVMV: \\rank V < \\rank (span (M :: Ms)).\n    rewrite (leq_trans _ Ms_ge_n) // ltn_sub2l ?(leq_trans ltVMV) //.\n    exact: rank_leq_row.\n  rewrite /span big_cons (ltn_leqif (mxrank_leqif_sup (addsmxSr _ _))).\n  apply: contra nzM; rewrite addsmx_sub -submx0 -(eqP tiUV) sub_capmx sMU.\n  by case/andP=> sMV _; rewrite (submx_trans _ sMV) ?component_mx_id.\nexists Ms => // M simM; have [modM nzM minM] := simM.\nhave sMV: (M <= V)%MS.\n  apply: contraFT haveU => not_sMV; apply/satP/Exists_rowP=> //.\n  exists (mxvec M); split; first by apply/ev_sub0; rewrite !ev mxvecK submx0.\n  split; first by apply/ev_mod; rewrite !ev mxvecK.\n  apply/Exists_rowP=> // [[w]].\n  apply/GRing.qf_evalP; rewrite /= ?submx_form_qf // !ev /= mxvecK submx0.\n  rewrite -nz_row_eq0 -(cyclic_mx_eq0 rG); set W := cyclic_mx _ _.\n  apply: contra not_sMV => /and3P[nzW Vw Mw].\n  have{Vw Mw} [sWV sWM]: (W <= V /\\ W <= M)%MS.\n    rewrite !cyclic_mx_sub ?(submx_trans (nz_row_sub _)) //.\n    by rewrite sumsmx_module // => M' _; apply: component_mx_module.\n  by rewrite (submx_trans _ sWV) // minM ?cyclic_mx_module.\nwlog sG: / socleType rG by apply: socle_exists.\nhave sVS: (V <= \\sum_(W : sG | has (fun Mi => Mi <= W) Ms) W)%MS.\n  rewrite [V](big_nth 0) big_mkord; apply/sumsmx_subP=> i _.\n  set Mi := Ms`_i; have MsMi: Mi \\in Ms by apply: mem_nth.\n  have simMi := simMs _ MsMi; have S_Mi := component_socle sG simMi.\n  rewrite (sumsmx_sup (PackSocle S_Mi)) ?PackSocleK //.\n  by apply/hasP; exists Mi; rewrite ?component_mx_id.\nhave [W MsW isoWM] := subSocle_iso simM (submx_trans sMV sVS).\nhave [Mi MsMi sMiW] := hasP MsW; apply/hasP; exists Mi => //.\nhave [simMi simW] := (simMs _ MsMi, socle_simple W); apply/mxsimple_isoP=> //.\nexact: mx_iso_trans (mx_iso_sym isoWM) (component_mx_iso simW simMi sMiW).\nQed.",
    "Lemma map_rfix_mx H : (rfix_mx rG H)^f = rfix_mx rGf H.\nProof.\nrewrite map_kermx //; congr (kermx _); apply: map_lin1_mx => //= v.\nrewrite map_mxvec map_mxM; congr (mxvec (_ *m _)); last first.\n  by apply: map_lin1_mx => //= u; rewrite map_mxM map_vec_mx.\nby apply/row_matrixP=> i; rewrite -map_row !rowK map_mxvec map_mxB map_mx1.\nQed.",
    "Lemma rcent_map A : rcent rGf A^f = rcent rG A.\nProof.\nby apply/setP=> x; rewrite !inE -!map_mxM inj_eq //; apply: map_mx_inj.\nQed.",
    "Lemma rstab_map m (U : 'M_(m, n)) : rstab rGf U^f = rstab rG U.\nProof.\nby apply/setP=> x; rewrite !inE -!map_mxM inj_eq //; apply: map_mx_inj.\nQed.",
    "Lemma rstabs_map m (U : 'M_(m, n)) : rstabs rGf U^f = rstabs rG U.\nProof. by apply/setP=> x; rewrite !inE -!map_mxM ?map_submx. Qed.",
    "Lemma centgmx_map A : centgmx rGf A^f = centgmx rG A.\nProof. by rewrite /centgmx rcent_map. Qed.",
    "Lemma mxmodule_map m (U : 'M_(m, n)) : mxmodule rGf U^f = mxmodule rG U.\nProof. by rewrite /mxmodule rstabs_map. Qed.",
    "Lemma mxsimple_map (U : 'M_n) : mxsimple rGf U^f -> mxsimple rG U.\nProof.\ncase; rewrite map_mx_eq0 // mxmodule_map // => modU nzU minU.\nsplit=> // V modV sVU nzV; rewrite -(map_submx f).\nby rewrite (minU V^f) //= ?mxmodule_map ?map_mx_eq0 // map_submx.\nQed.",
    "Lemma mx_irr_map : mx_irreducible rGf -> mx_irreducible rG.\nProof. by move=> irrGf; apply: mxsimple_map; rewrite map_mx1. Qed.",
    "Lemma rker_map : rker rGf = rker rG.\nProof. by rewrite /rker -rstab_map map_mx1. Qed.",
    "Lemma map_mx_faithful : mx_faithful rGf = mx_faithful rG.\nProof. by rewrite /mx_faithful rker_map. Qed.",
    "Lemma map_mx_abs_irr :\n  mx_absolutely_irreducible rGf = mx_absolutely_irreducible rG.\nProof.\nby rewrite /mx_absolutely_irreducible -map_enveloping_algebra_mx row_full_map.\nQed.",
    "Lemma mx_rsim_map n1 n2 rG1 rG2 :\n  @mx_rsim _ _ G n1 rG1 n2 rG2 -> mx_rsim (map_repr f rG1) (map_repr f rG2).\nProof.\ncase=> g eqn12 inj_g hom_g.\nby exists g^f => // [|x Gx]; rewrite ?row_free_map // -!map_mxM ?hom_g.\nQed.",
    "Lemma map_section_repr n (rG : mx_representation aF G n) rGf U V\n                       (modU : mxmodule rG U) (modV : mxmodule rG V)\n                       (modUf : mxmodule rGf U^f) (modVf : mxmodule rGf V^f) :\n    map_repr f rG =1 rGf ->\n  mx_rsim (map_repr f (section_repr modU modV)) (section_repr modUf modVf).\nProof.\nmove=> def_rGf; set VU := <<_>>%MS.\npose valUV := val_factmod (val_submod (1%:M : 'M[aF]_(\\rank VU))).\nhave sUV_Uf: (valUV^f <= U^f + V^f)%MS.\n  rewrite -map_addsmx map_submx; apply: submx_trans (proj_factmodS _ _).\n  by rewrite val_factmodS val_submod1 genmxE.\nexists (in_submod _ (in_factmod U^f valUV^f)) => [||x Gx].\n- rewrite !genmxE -(mxrank_map f) map_mxM map_col_base.\n  by case: (\\rank (cokermx U)) / (mxrank_map _ _); rewrite map_cokermx.\n- rewrite -kermx_eq0 -submx0; apply/rV_subP=> u.\n  rewrite (sameP sub_kermxP eqP) submx0 -val_submod_eq0.\n  rewrite val_submodE -mulmxA -val_submodE in_submodK; last first.\n    by rewrite genmxE -(in_factmod_addsK _ V^f) submxMr.\n  rewrite in_factmodE mulmxA -in_factmodE in_factmod_eq0.\n  move/(submxMr (in_factmod U 1%:M *m in_submod VU 1%:M)^f).\n  rewrite -mulmxA -!map_mxM //; do 2!rewrite mulmxA -in_factmodE -in_submodE.\n  rewrite val_factmodK val_submodK map_mx1 mulmx1.\n  have ->: in_factmod U U = 0 by apply/eqP; rewrite in_factmod_eq0.\n  by rewrite linear0 map_mx0 eqmx0 submx0.\nrewrite {1}in_submodE mulmxA -in_submodE -in_submodJ; last first.\n  by rewrite genmxE -(in_factmod_addsK _ V^f) submxMr.\ncongr (in_submod _ _); rewrite -in_factmodJ // in_factmodE mulmxA -in_factmodE.\napply/eqP; rewrite -subr_eq0 -def_rGf -!map_mxM -linearB in_factmod_eq0.\nrewrite -map_mxB map_submx -in_factmod_eq0 linearB.\nrewrite /= (in_factmodJ modU) // val_factmodK.\nrewrite [valUV]val_factmodE mulmxA -val_factmodE val_factmodK.\nrewrite -val_submodE in_submodK ?subrr //.\nby rewrite mxmodule_trans ?section_module // val_submod1.\nQed.",
    "Lemma map_regular_subseries U i (modU : mx_subseries (regular_repr aF G) U)\n   (modUf : mx_subseries (regular_repr rF G) [seq M^f | M <- U]) :\n  mx_rsim (map_repr f (subseries_repr i modU)) (subseries_repr i modUf).\nProof.\nset mf := map _ in modUf *; rewrite /subseries_repr.\ndo 2!move: (mx_subseries_module' _ _) (mx_subseries_module _ _).\nhave mf_i V: nth 0^f (mf V) i = (V`_i)^f.\n  case: (ltnP i (size V)) => [ltiV | leVi]; first exact: nth_map.\n  by rewrite !nth_default ?size_map.\nrewrite -(map_mx0 f) mf_i (mf_i (0 :: U)) => modUi'f modUif modUi' modUi.\nby apply: map_section_repr; apply: map_regular_repr.\nQed.",
    "Lemma extend_group_splitting_field :\n  group_splitting_field aF G -> group_splitting_field rF G.\nProof.\nmove=> splitG n rG irrG.\nhave modU0: all ((mxmodule (regular_repr aF G)) #|G|) [::] by [].\napply: (mx_Schreier modU0 _) => // [[U [compU lastU _]]]; have [modU _]:= compU.\npose Uf := map (map_mx f) U.\nhave{lastU} lastUf: (last 0 Uf :=: 1%:M)%MS.\n  by rewrite -(map_mx0 f) -(map_mx1 f) last_map; apply/map_eqmx.\nhave modUf: mx_subseries (regular_repr rF G) Uf.\n  rewrite /mx_subseries all_map; apply: etrans modU; apply: eq_all => Ui /=.\n  rewrite -mxmodule_map; apply: eq_subset_r => x.\n  by rewrite !inE map_regular_repr.\nhave absUf i: i < size U -> mx_absolutely_irreducible (subseries_repr i modUf).\n  move=> lt_i_U; rewrite -(mx_rsim_abs_irr (map_regular_subseries i modU _)).\n  rewrite map_mx_abs_irr; apply: splitG.\n  by apply: mx_rsim_irr (mx_series_repr_irr compU lt_i_U); apply: section_eqmx.\nhave compUf: mx_composition_series (regular_repr rF G) Uf.\n  split=> // i; rewrite size_map => ltiU.\n  move/max_submodP: (mx_abs_irrW (absUf i ltiU)); apply.\n  rewrite -{2}(map_mx0 f) -map_cons !(nth_map 0) ?leqW //.\n  by rewrite map_submx // ltmxW // (pathP _ (mx_series_lt compU)).\nhave [[i ltiU] simUi] := rsim_regular_series irrG compUf lastUf.\nhave{} simUi: mx_rsim rG (subseries_repr i modUf).\n  by apply: mx_rsim_trans simUi _; apply: section_eqmx.\nby rewrite (mx_rsim_abs_irr simUi) absUf; rewrite size_map in ltiU.\nQed.",
    "Lemma gen_addA : associative genD.\nProof. by move=> x y z; apply: val_inj; rewrite /= addrA. Qed.",
    "Lemma gen_addC : commutative genD.\nProof. by move=> x y; apply: val_inj; rewrite /= addrC. Qed.",
    "Lemma gen_add0r : left_id gen0 genD.\nProof. by move=> x; apply: val_inj; rewrite /= add0r. Qed.",
    "Lemma gen_addNr : left_inverse gen0 genN genD.\nProof. by move=> x; apply: val_inj; rewrite /= addNr. Qed.",
    "Lemma genK x : mxval (gen x) = x%:M.\nProof.\nby rewrite /mxval [pval _]poly_rV_K ?horner_mx_C // size_polyC; case: (x != 0).\nQed.",
    "Lemma mxval_inj : injective mxval.\nProof. exact: inj_comp horner_rVpoly_inj val_inj. Qed.",
    "Lemma mxval0 : mxval 0 = 0.\nProof. by rewrite /mxval [pval _]raddf0 rmorph0. Qed.",
    "Lemma mxvalN : {morph mxval : x / - x}.\nProof. by move=> x; rewrite /mxval [pval _](@raddfN 'rV[F]_d) rmorphN. Qed.",
    "Lemma mxvalD : {morph mxval : x y / x + y}.\nProof. by move=> x y; rewrite /mxval [pval _]raddfD rmorphD. Qed.",
    "Lemma mxval_gen1 : mxval gen1 = 1%:M.\nProof. by rewrite /mxval [pval _]poly_rV_K ?size_poly1 // horner_mx_C. Qed.",
    "Lemma mxval_genM : {morph mxval : x y / genM x y >-> x *m y}.\nProof.\nmove=> x y; rewrite /mxval [pval _]poly_rV_K ?size_mod_mxminpoly //.\nby rewrite -horner_mxK mx_inv_hornerK ?horner_mx_mem // rmorphM.\nQed.",
    "Lemma mxval_genV : {morph mxval : x / genV x >-> invmx x}.\nProof.\nmove=> x; rewrite /mxval [pval _]poly_rV_K ?size_poly ?mx_inv_hornerK //.\npose m B : 'M[F]_(n * n) := lin_mx (mulmxr B); set B := mxval x.\ncase uB: (B \\is a GRing.unit); last by rewrite invr_out ?uB ?horner_mx_mem.\nhave defAd: Ad = Ad *m m B *m m B^-1.\n  apply/row_matrixP=> i.\n  by rewrite !row_mul mul_rV_lin /= mx_rV_lin /= mulmxK ?vec_mxK.\nrewrite -[B^-1]mul1mx -(mul_vec_lin (mulmxr B^-1)) defAd submxMr //.\nrewrite -mxval_gen1 (submx_trans (horner_mx_mem _ _)) // {1}defAd.\nrewrite -(geq_leqif (mxrank_leqif_sup _)) ?mxrankM_maxl // -{}defAd.\napply/row_subP=> i; rewrite row_mul rowK mul_vec_lin /= -{2}[A]horner_mx_X.\nby rewrite -rmorphXn mulmxE -rmorphM horner_mx_mem.\nQed.",
    "Lemma gen_mulA : associative genM.\nProof. by move=> x y z; apply: mxval_inj; rewrite !mxval_genM mulmxA. Qed.",
    "Lemma gen_mulC : commutative genM.\nProof. by move=> x y; rewrite /genM mulrC. Qed.",
    "Lemma gen_mul1r : left_id gen1 genM.\nProof. by move=> x; apply: mxval_inj; rewrite mxval_genM mxval_gen1 mul1mx. Qed.",
    "Lemma gen_mulDr : left_distributive genM +%R.\nProof.\nby move=> x y z; apply: mxval_inj; rewrite !(mxvalD, mxval_genM) mulmxDl.\nQed.",
    "Lemma gen_ntriv : gen1 != 0.\nProof. by rewrite -(inj_eq mxval_inj) mxval_gen1 mxval0 oner_eq0. Qed.",
    "Lemma mxval1 : mxval 1 = 1%:M. Proof. exact: mxval_gen1. Qed.",
    "Lemma mxvalM : {morph mxval : x y / x * y >-> x *m y}.\nProof. exact: mxval_genM. Qed.",
    "Lemma mxval_sub : additive mxval.\nProof. by move=> x y; rewrite mxvalD mxvalN. Qed.",
    "Lemma mxval_is_multiplicative : multiplicative mxval.\nProof. by split; [apply: mxvalM | apply: mxval1]. Qed.",
    "Lemma mxval_centg x : centgmx rG (mxval x).\nProof.\nrewrite [mxval _]horner_rVpoly -memmx_cent_envelop vec_mxK {x}mulmx_sub //.\napply/row_subP=> k; rewrite rowK memmx_cent_envelop; apply/centgmxP => g Gg /=.\nby rewrite !mulmxE commrX // /GRing.comm -mulmxE (centgmxP cGA).\nQed.",
    "Lemma gen_mulVr x : x != 0 -> genV x * x = 1.\nProof.\nrewrite -(inj_eq mxval_inj) mxval0.\nmove/(mx_Schur irrG (mxval_centg x)) => u_x.\nby apply: mxval_inj; rewrite mxvalM mxval_genV mxval1 mulVmx.\nQed.",
    "Lemma gen_invr0 : genV 0 = 0.\nProof. by apply: mxval_inj; rewrite mxval_genV !mxval0 -{2}invr0. Qed.",
    "Lemma mxvalV : {morph mxval : x / x^-1 >-> invmx x}.\nProof. exact: mxval_genV. Qed.",
    "Lemma gen_is_additive : additive gen.\nProof. by move=> x y; apply: mxval_inj; rewrite genK !rmorphB /= !genK. Qed.",
    "Lemma gen_is_multiplicative : multiplicative gen.\nProof. by split=> // x y; apply: mxval_inj; rewrite genK !rmorphM /= !genK. Qed.",
    "Lemma mxval_groot : mxval groot = A.\nProof.\nrewrite /mxval [pval _]poly_rV_K ?size_mod_mxminpoly // -horner_mxK.\nby rewrite mx_inv_hornerK ?horner_mx_mem // horner_mx_X.\nQed.",
    "Lemma mxval_grootXn k : mxval (groot ^+ k) = A ^+ k.\nProof. by rewrite rmorphXn /= mxval_groot. Qed.",
    "Lemma map_mxminpoly_groot : (map_poly gen pA).[groot] = 0.\nProof. \napply: mxval_inj; rewrite -horner_map [_ groot]/= mxval_groot mxval0.\nrewrite -(mx_root_minpoly A); congr ((_ : {poly _}).[A]).\nby apply/polyP=> i; rewrite 3!coef_map; apply: genK.\nQed.",
    "Lemma non_linear_gen_reducible : d > 1 -> mxnonsimple (map_repr gen rG) 1%:M.\nProof.\nrewrite ltnNge mxminpoly_linear_is_scalar => Anscal.\npose Af := map_mx gen A; exists (kermx (Af - groot%:M)).\nrewrite submx1 kermx_centg_module /=; last first.\n  apply/centgmxP=> z Gz; rewrite mulmxBl mulmxBr scalar_mxC.\n  by rewrite -!map_mxM 1?(centgmxP cGA).\nrewrite andbC mxrank_ker -subn_gt0 mxrank1 subKn ?rank_leq_row // lt0n.\nrewrite mxrank_eq0 subr_eq0; case: eqP => [defAf | _].\n  rewrite -(map_mx_is_scalar gen) -/Af in Anscal.\n  by case/is_scalar_mxP: Anscal; exists groot.\nrewrite -mxrank_eq0 mxrank_ker subn_eq0 row_leq_rank.\napply/row_freeP=> [[XA' XAK]].\nhave pAf0: (mxminpoly Af).[groot] == 0.\n  by rewrite mxminpoly_map ?map_mxminpoly_groot.\nhave{pAf0} [q def_pAf]:= factor_theorem _ _ pAf0.\nhave q_nz: q != 0.\n  case: eqP (congr1 (fun p : {poly _} => size p) def_pAf) => // ->.\n  by rewrite size_mxminpoly mul0r size_poly0.\nhave qAf0: horner_mx Af q = 0.\n  rewrite -[_ q]mulr1 -[1]XAK mulrA -{2}(horner_mx_X Af) -(horner_mx_C Af).\n  by rewrite -rmorphB -rmorphM -def_pAf /= mx_root_minpoly mul0r.\nhave{qAf0} := dvdp_leq q_nz (mxminpoly_min qAf0); rewrite def_pAf.\nby rewrite size_Mmonic ?monicXsubC // polyseqXsubC addn2 ltnn.\nQed.",
    "Lemma gen_dim_ex_proof : exists nA, [exists B : 'rV_nA, row_free (subbase B)].\nProof. by exists 0; apply/existsP; exists 0; rewrite /row_free unlock. Qed.",
    "Lemma gen_dim_ub_proof nA :\n  [exists B : 'rV_nA, row_free (subbase B)] -> (nA <= n)%N.\nProof.\ncase/existsP=> B /eqnP def_nAd.\nby rewrite (leq_trans _ (rank_leq_col (subbase B))) // def_nAd leq_pmulr.\nQed.",
    "Lemma base_free : row_free base.\nProof.\nrewrite /base /gen_base /nA; case: pickP => //; case: ex_maxnP => nA_max.\nby case/existsP=> B Bfree _ no_free; rewrite no_free in Bfree.\nQed.",
    "Lemma base_full : row_full base.\nProof.\nrewrite /row_full (eqnP base_free) /nA; case: ex_maxnP => nA.\ncase/existsP=> /= B /eqnP Bfree nA_max; rewrite -Bfree eqn_leq rank_leq_col.\nrewrite -{1}(mxrank1 F n) mxrankS //; apply/row_subP=> j; set u := row _ _.\nmove/implyP: {nA_max}(nA_max nA.+1); rewrite ltnn implybF.\napply: contraR => nBj; apply/existsP.\nexists (row_mx (const_mx j : 'M_1) B); rewrite -row_leq_rank.\npose Bj := Ad *m lin1_mx (mulmx u \\o vec_mx).\nhave rBj: \\rank Bj = d.\n  apply/eqP; rewrite eqn_leq rank_leq_row -subn_eq0 -mxrank_ker mxrank_eq0 /=.\n  apply/rowV0P=> v /sub_kermxP; rewrite mulmxA mul_rV_lin1 /=.\n  rewrite -horner_rVpoly; pose x := inFA v; rewrite -/(mxval x).\n  have [[] // | nzx /(congr1 (mulmx^~ (mxval x^-1)))] := eqVneq x 0.\n  rewrite mul0mx /= -mulmxA -mxvalM divff // mxval1 mulmx1.\n  by move/rowP/(_ j)/eqP; rewrite !mxE !eqxx oner_eq0.\nrewrite {1}mulSn -Bfree -{1}rBj {rBj} -mxrank_disjoint_sum.\n  rewrite mxrankS // addsmx_sub -[nA.+1]/(1 + nA)%N; apply/andP; split.\n    apply/row_subP=> k; rewrite row_mul mul_rV_lin1 /=.\n    apply: eq_row_sub (mxvec_index (lshift _ 0) k)  _.\n    by rewrite !rowK mxvecK mxvecE mxE row_mxEl mxE -row_mul mul1mx.\n  apply/row_subP; case/mxvec_indexP=> i k.\n  apply: eq_row_sub (mxvec_index (rshift 1 i) k) _.\n  by rewrite !rowK !mxvecE 2!mxE row_mxEr.\napply/eqP/rowV0P=> v; rewrite sub_capmx => /andP[/submxP[w]].\nset x := inFA w; rewrite {Bj}mulmxA mul_rV_lin1 /= -horner_rVpoly -/(mxval x).\nhave [-> | nzx ->] := eqVneq x 0; first by rewrite mxval0 mulmx0.\nmove/(submxMr (mxval x^-1)); rewrite -mulmxA -mxvalM divff {nzx}//.\nrewrite mxval1 mulmx1 => Bx'j; rewrite (submx_trans Bx'j) in nBj => {Bx'j} //.\napply/row_subP; case/mxvec_indexP=> i k.\nrewrite row_mul rowK mxvecE mxE rowE -mulmxA.\nhave ->: A ^+ k *m mxval x^-1 = mxval (groot ^+ k / x).\n  by rewrite mxvalM rmorphXn /= mxval_groot.\nrewrite [mxval _]horner_rVpoly; move: {k u x}(val _) => u.\nrewrite (mulmx_sum_row u) !linear_sum summx_sub //= => k _.\nrewrite 2!linearZ scalemx_sub //= rowK mxvecK -rowE.\nby apply: eq_row_sub (mxvec_index i k) _; rewrite rowK mxvecE mxE.\nQed.",
    "Lemma gen_dim_factor : (nA * d)%N = n.\nProof. by rewrite -(eqnP base_free) (eqnP base_full). Qed.",
    "Lemma gen_dim_gt0 : nA > 0.\nProof. by case: posnP gen_dim_factor => // ->. Qed.",
    "Lemma in_genK : cancel in_gen val_gen.\nProof.\nmove=> W; apply/row_matrixP=> i; rewrite rowK; set w := row i W.\nhave b_w: (w <= base)%MS by rewrite submx_full ?base_full.\nrewrite -{b_w}(mulmxKpV b_w); congr (_ *m _).\nby apply/rowP; case/mxvec_indexP=> j k; rewrite mxvecE !mxE.\nQed.",
    "Lemma val_genK : cancel val_gen in_gen.\nProof.\nmove=> W; apply/matrixP=> i j; apply: val_inj; rewrite mxE /= rowK.\ncase/row_freeP: base_free => B' BB'; rewrite -[_ *m _]mulmx1 -BB' mulmxA.\nby rewrite mulmxKpV ?submxMl // -mulmxA BB' mulmx1 mxvecK rowK.\nQed.",
    "Lemma in_gen0 : in_gen 0 = 0.\nProof. by apply/matrixP=> i j; rewrite !mxE !(mul0mx, linear0). Qed.",
    "Lemma val_gen0 : val_gen 0 = 0.\nProof. by apply: (canLR in_genK); rewrite in_gen0. Qed.",
    "Lemma in_genD : {morph in_gen : U V / U + V}.\nProof.\nby move=> U V; apply/matrixP=> i j; rewrite !mxE 4!(mulmxDl, linearD).\nQed.",
    "Lemma val_genD : {morph val_gen : U V / U + V}.\nProof. by move=> U V; apply: (canLR in_genK); rewrite in_genD !val_genK. Qed.",
    "Lemma in_genN : {morph in_gen : W / - W}.\nProof. by move=> W; apply/esym/addr0_eq; rewrite -in_genD subrr in_gen0. Qed.",
    "Lemma val_genN : {morph val_gen : W / - W}.\nProof. by move=> W; apply: (canLR in_genK); rewrite in_genN val_genK. Qed.",
    "Lemma in_genZ a : {morph in_gen : W / a *: W >-> gen a *: W}.\nProof.\nmove=> W; apply/matrixP=> i j; apply: mxval_inj.\nrewrite !mxE mxvalM genK ![mxval _]horner_rVpoly /=.\nby rewrite mul_scalar_mx !(I, scalemxAl, linearZ).\nQed.",
    "Lemma val_gen_rV (w : 'rV_nA) :\n  val_gen w = mxvec (\\matrix_j val (w 0 j)) *m base.\nProof. by apply/rowP=> j /[1!mxE]. Qed.",
    "Lemma val_gen_row W (i : 'I_m) : val_gen (row i W) = row i (val_gen W).\nProof.\nrewrite val_gen_rV rowK; congr (mxvec _ *m _).\nby apply/matrixP=> j k /[!mxE].\nQed.",
    "Lemma in_gen_row W (i : 'I_m) : in_gen (row i W) = row i (in_gen W).\nProof. by apply: (canLR val_genK); rewrite val_gen_row in_genK. Qed.",
    "Lemma row_gen_sum_mxval W (i : 'I_m) :\n  row i (val_gen W) = \\sum_j row (gen_base 0 j) (mxval (W i j)).\nProof.\nrewrite -val_gen_row [row i W]row_sum_delta val_gen_sum.\napply: eq_bigr => /= j _ /[1!mxE]; move: {W i}(W i j) => x.\nhave ->: x = \\sum_k gen (val x 0 k) * inFA (delta_mx 0 k).\n  case: x => u; apply: mxval_inj; rewrite {1}[u]row_sum_delta.\n  rewrite mxval_sum [mxval _]horner_rVpoly mulmx_suml linear_sum /=.\n  apply: eq_bigr => k _; rewrite mxvalM genK [mxval _]horner_rVpoly /=.\n  by rewrite mul_scalar_mx -scalemxAl linearZ.\nrewrite scaler_suml val_gen_sum mxval_sum linear_sum; apply: eq_bigr => k _.\nrewrite mxvalM genK mul_scalar_mx linearZ [mxval _]horner_rVpoly /=.\nrewrite -scalerA; apply: (canLR in_genK); rewrite in_genZ; congr (_ *: _).\napply: (canRL val_genK); transitivity (row (mxvec_index j k) base); last first.\n  by rewrite -rowE rowK mxvecE mxE rowK mxvecK.\nrewrite rowE -mxvec_delta -[val_gen _](row_id 0) rowK /=; congr (mxvec _ *m _).\napply/row_matrixP=> j'; rewrite rowK !mxE mulr_natr rowE mul_delta_mx_cond.\nby rewrite !mulrb (fun_if rVval).\nQed.",
    "Lemma val_genZ x : {morph @val_gen m : W / x *: W >-> W *m mxval x}.\nProof.\nmove=> W; apply/row_matrixP=> i; rewrite row_mul !row_gen_sum_mxval.\nby rewrite mulmx_suml; apply: eq_bigr => j _; rewrite mxE mulrC mxvalM row_mul.\nQed.",
    "Lemma submx_in_gen m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (U <= V -> in_gen U <= in_gen V)%MS.\nProof.\nmove=> sUV; apply/row_subP=> i; rewrite -in_gen_row.\ncase/submxP: (row_subP sUV i) => u ->{i}.\nrewrite mulmx_sum_row in_gen_sum summx_sub // => j _.\nby rewrite in_genZ in_gen_row scalemx_sub ?row_sub.\nQed.",
    "Lemma submx_in_gen_eq m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (V *m A <= V -> (in_gen U <= in_gen V) = (U <= V))%MS.\nProof.\nmove=> sVA_V; apply/idP/idP=> siUV; last exact: submx_in_gen.\napply/row_subP=> i; rewrite -[row i U]in_genK in_gen_row.\ncase/submxP: (row_subP siUV i) => u ->{i U siUV}.\nrewrite mulmx_sum_row val_gen_sum summx_sub // => j _.\nrewrite val_genZ val_gen_row in_genK rowE -mulmxA mulmx_sub //.\nrewrite [mxval _]horner_poly mulmx_sumr summx_sub // => [[k _]] _ /=.\nrewrite mulmxA mul_mx_scalar -scalemxAl scalemx_sub {u j}//.\nelim: k => [|k IHk]; first by rewrite mulmx1.\nby rewrite exprSr mulmxA (submx_trans (submxMr A IHk)).\nQed.",
    "Lemma gen_mx_repr : mx_repr G gen_mx.\nProof.\nsplit=> [|g h Gg Gh]; apply: (can_inj val_genK).\n  by rewrite -[gen_mx 1]mul1mx val_genJmx // repr_mx1 mulmx1.\nrewrite {1}[val_gen]lock -[gen_mx g]mul1mx !val_genJmx // -mulmxA -repr_mxM //.\nby rewrite -val_genJmx ?groupM ?mul1mx -?lock.\nQed.",
    "Lemma val_genJ m :\n  {in G, forall g, {morph @val_gen m : W / W *m rGA g >-> W *m rG g}}.\nProof. exact: val_genJmx. Qed.",
    "Lemma in_genJ m :\n  {in G, forall g, {morph @in_gen m : v / v *m rG g >-> v *m rGA g}}.\nProof.\nby move=> g Gg /= v; apply: (canLR val_genK); rewrite val_genJ ?in_genK.\nQed.",
    "Lemma rfix_gen (H : {set gT}) :\n  H \\subset G -> (rfix_mx rGA H :=: in_gen (rfix_mx rG H))%MS.\nProof.\nmove/subsetP=> sHG; apply/eqmxP/andP; split; last first.\n  by apply/rfix_mxP=> g Hg; rewrite -in_genJ ?sHG ?rfix_mx_id.\nrewrite -[rfix_mx rGA H]val_genK; apply: submx_in_gen.\nby apply/rfix_mxP=> g Hg; rewrite -val_genJ ?rfix_mx_id ?sHG.\nQed.",
    "Lemma submx_rowval_gen m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, nA)) :\n  (U <= rowval_gen V)%MS = (in_gen U <= V)%MS.\nProof.\nrewrite genmxE; apply/idP/idP=> sUV.\n  apply: submx_trans (submx_in_gen sUV) _.\n  apply/row_subP; case/mxvec_indexP=> i k; rewrite -in_gen_row rowK mxvecE mxE.\n  rewrite -mxval_grootXn -val_gen_row -val_genZ val_genK scalemx_sub //.\n  exact: row_sub.\nrewrite -[U]in_genK; case/submxP: sUV => u ->{U}.\napply/row_subP=> i0; rewrite -val_gen_row row_mul; move: {i0 u}(row _ u) => u.\nrewrite mulmx_sum_row val_gen_sum summx_sub // => i _.\nrewrite val_genZ [mxval _]horner_rVpoly [_ *m Ad]mulmx_sum_row.\nrewrite !linear_sum summx_sub // => k _.\nrewrite 2!linearZ scalemx_sub {u}//= rowK mxvecK val_gen_row.\nby apply: (eq_row_sub (mxvec_index i k)); rewrite rowK mxvecE mxE.\nQed.",
    "Lemma rowval_genK m (U : 'M_(m,  nA)) : (in_gen (rowval_gen U) :=: U)%MS.\nProof.\napply/eqmxP; rewrite -submx_rowval_gen submx_refl /=.\nby rewrite -{1}[U]val_genK submx_in_gen // submx_rowval_gen val_genK.\nQed.",
    "Lemma rowval_gen_stable m (U : 'M_(m, nA)) :\n  (rowval_gen U *m A <= rowval_gen U)%MS.\nProof.\nrewrite -[A]mxval_groot -{1}[_ U]in_genK -val_genZ.\nby rewrite submx_rowval_gen val_genK scalemx_sub // rowval_genK.\nQed.",
    "Lemma rstab_in_gen m (U : 'M_(m, n)) : rstab rGA (in_gen U) = rstab rG U.\nProof.\napply/setP=> x /[!inE]; case Gx: (x \\in G) => //=.\nby rewrite -in_genJ // (inj_eq (can_inj in_genK)).\nQed.",
    "Lemma rstabs_in_gen m (U : 'M_(m, n)) :\n  rstabs rG U \\subset rstabs rGA (in_gen U).\nProof.\nby apply/subsetP=> x /[!inE] /andP[Gx nUx]; rewrite -in_genJ Gx // submx_in_gen.\nQed.",
    "Lemma rstabs_rowval_gen m (U : 'M_(m, nA)) :\n  rstabs rG (rowval_gen U) = rstabs rGA U.\nProof.\napply/setP=> x /[!inE]; case Gx: (x \\in G) => //=.\nby rewrite submx_rowval_gen in_genJ // (eqmxMr _ (rowval_genK U)).\nQed.",
    "Lemma mxmodule_rowval_gen m (U : 'M_(m, nA)) :\n  mxmodule rG (rowval_gen U) = mxmodule rGA U.\nProof. by rewrite /mxmodule rstabs_rowval_gen. Qed.",
    "Lemma gen_mx_irr : mx_irreducible rGA.\nProof.\napply/mx_irrP; split=> [|U Umod nzU]; first exact: gen_dim_gt0.\nrewrite -sub1mx -rowval_genK -submx_rowval_gen submx_full //.\ncase/mx_irrP: irrG => _; apply; first by rewrite mxmodule_rowval_gen.\nrewrite -(inj_eq (can_inj in_genK)) in_gen0.\nby rewrite -mxrank_eq0 rowval_genK mxrank_eq0.\nQed.",
    "Lemma rker_gen : rker rGA = rker rG.\nProof.\napply/setP=> g; rewrite !inE !mul1mx; case Gg: (g \\in G) => //=.\napply/eqP/eqP=> g1; apply/row_matrixP=> i.\n  by apply: (can_inj in_genK); rewrite rowE in_genJ //= g1 mulmx1 row1.\nby apply: (can_inj val_genK); rewrite rowE val_genJ //= g1 mulmx1 row1.\nQed.",
    "Lemma gen_mx_faithful : mx_faithful rGA = mx_faithful rG.\nProof. by rewrite /mx_faithful rker_gen. Qed.",
    "Lemma eval_mulT e u v :\n  eval_mx e (mulT u v) = val (inFA (eval_mx e u) * inFA (eval_mx e v)).\nProof.\nrewrite !(eval_mulmx, eval_mxvec) !eval_mxT eval_mx_term.\nby apply: (can_inj rVpolyK); rewrite -mxvalM [rVpoly _]horner_rVpolyK.\nQed.",
    "Lemma nth_map_rVval (e : seq FA) j : (map val e)`_j = val e`_j.\nProof.\ncase: (ltnP j (size e)) => [| leej]; first exact: (nth_map 0 0).\nby rewrite !nth_default ?size_map.\nQed.",
    "Lemma set_nth_map_rVval (e : seq FA) j v :\n  set_nth 0 (map val e) j v = map val (set_nth 0 e j (inFA v)).\nProof.\napply: (@eq_from_nth _ 0) => [|k _]; first by rewrite !(size_set_nth, size_map).\nby rewrite !(nth_map_rVval, nth_set_nth) /= nth_map_rVval [rVval _]fun_if.\nQed.",
    "Lemma eval_gen_term e t :\n  GRing.rterm t -> eval_mx (gen_env e) (gen_term t) = val (GRing.eval e t).\nProof.\nelim: t => //=.\n- by move=> k _; apply/rowP=> i; rewrite !mxE /= nth_row_env nth_map_rVval.\n- by move=> x _; rewrite eval_mx_term.\n- by move=> x _; rewrite eval_mx_term.\n- by move=> t1 + t2 + /andP[rt1 rt2] => <-// <-//; apply/rowP => k /[!mxE].\n- by move=> t1 + rt1 => <-//; apply/rowP=> k /[!mxE].\n- move=> t1 IH1 n1 rt1; rewrite eval_mulmx eval_mx_term mul_scalar_mx.\n  by rewrite scaler_nat {}IH1 //; elim: n1 => //= n1 IHn1; rewrite !mulrS IHn1.\n- by move=> t1 IH1 t2 IH2 /andP[rt1 rt2]; rewrite eval_mulT IH1 ?IH2.\nmove=> t1 + n1 => /[apply] IH1.\nelim: n1 => [|n1 IHn1] /=; first by rewrite eval_mx_term.\nby rewrite eval_mulT exprS IH1 IHn1.\nQed.",
    "Lemma sat_gen_form e f : GRing.rformula f ->\n  reflect (GRing.holds e f) (GRing.sat (gen_env e) (gen_form f)).\nProof.\nhave ExP := Exists_rowP; have set_val := set_nth_map_rVval.\nelim: f e => //.\n- by move=> b e _; apply: (iffP satP).\n- rewrite /gen_form => t1 t2 e rt_t; set t := (_ - _)%T.\n  have:= GRing.qf_evalP (gen_env e) (mxrank_form_qf 0 (gen_term t)).\n  rewrite eval_mxrank mxrank_eq0 eval_gen_term // => tP.\n  by rewrite (sameP satP tP) /= subr_eq0 val_eqE; apply: eqP.\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => [[/satP/f1P ? /satP/f2P] | [/f1P/satP ? /f2P/satP]].\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => /= [] [];\n    try move/satP; do [move/f1P | move/f2P]; try move/satP; auto.\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => /= implP;\n    try move/satP; move/f1P; try move/satP; move/implP;\n    try move/satP; move/f2P; try move/satP.\n- move=> f1 IH1 s /= /(IH1 s) f1P.\n  by apply: (iffP satP) => /= notP; try move/satP; move/f1P; try move/satP.\n- move=> k f1 IHf1 s /IHf1 f1P; apply: (iffP satP) => /= [|[[v f1v]]].\n    by case/ExP=> // x /satP; rewrite set_val => /f1P; exists (inFA x).\n  by apply/ExP=> //; exists v; rewrite set_val; apply/satP/f1P.\nmove=> i f1 IHf1 s /IHf1 f1P; apply: (iffP satP) => /= allf1 => [[v]|].\n  apply/f1P; case: satP => // notf1x; case: allf1; apply/ExP=> //.\n  by exists v; rewrite set_val.\nby case/ExP=> //= v []; apply/satP; rewrite set_val; apply/f1P.\nQed.",
    "Lemma gen_satP :\n  GRing.MathCompCompatDecidableField.DecidableField.axiom gen_sat.\nProof.\nmove=> e f; have [tor rto] := GRing.to_rformP e f.\nexact: (iffP (sat_gen_form e (GRing.to_rform_rformula f))).\nQed.",
    "Lemma card_gen : #|{:FA}| = (#|F| ^ degree_mxminpoly A)%N.\nProof. by rewrite card_sub card_mx mul1n. Qed.",
    "Lemma group_splitting_field_exists gT (G : {group gT}) F :\n  classically {Fs : fieldType & {rmorphism F -> Fs}\n                              & group_splitting_field Fs G}.\nProof.\nmove: F => F0 [] // nosplit; pose nG := #|G|; pose aG F := regular_repr F G.\npose m := nG.+1; pose F := F0; pose U : seq 'M[F]_nG := [::].\nsuffices: size U + m <= nG by rewrite ltnn.\nhave: mx_subseries (aG F) U /\\ path ltmx 0 U by [].\npose f : {rmorphism F0 -> F} := idfun.\nelim: m F U f => [|m IHm] F U f [modU ltU].\n  by rewrite addn0 (leq_trans (max_size_mx_series ltU)) ?rank_leq_row.\nrewrite addnS ltnNge -implybF; apply/implyP=> le_nG_Um; apply: nosplit.\nexists F => //; case=> [|n] rG irrG; first by case/mx_irrP: irrG.\napply/idPn=> nabsG; pose cG := ('C(enveloping_algebra_mx rG))%MS.\nhave{nabsG} [A]: exists2 A, (A \\in cG)%MS & ~~ is_scalar_mx A.\n  apply/has_non_scalar_mxP; rewrite ?scalar_mx_cent // ltnNge.\n  by apply: contra nabsG; apply: cent_mx_scalar_abs_irr.\nrewrite {cG}memmx_cent_envelop -mxminpoly_linear_is_scalar -ltnNge => cGA.\nmove/(non_linear_gen_reducible irrG cGA).\n\nset F' := _ irrG cGA; set rG' := @map_repr _ F' _ _ _ _ rG.\nmove: F' (gen _ _ : {rmorphism F -> F'}) => F' f' in rG' * => irrG'.\npose U' := [seq map_mx f' Ui | Ui <- U].\nhave modU': mx_subseries (aG F') U'.\n  apply: etrans modU; rewrite /mx_subseries all_map; apply: eq_all => Ui.\n  rewrite -(mxmodule_map f'); apply: eq_subset_r => x.\n  by rewrite !inE map_regular_repr.\ncase: notF; apply: (mx_Schreier modU ltU) => [[V [compV lastV sUV]]].\nhave{lastV} [] := rsim_regular_series irrG compV lastV.\nhave{sUV} defV: V = U.\n  apply/eqP; rewrite eq_sym -(geq_leqif (size_subseq_leqif sUV)).\n  rewrite -(leq_add2r m); apply: leq_trans le_nG_Um.\n  by apply: IHm f _; rewrite (mx_series_lt compV); case: compV.\nrewrite {V}defV in compV * => i rsimVi.\napply: (mx_Schreier modU') => [|[V' [compV' _ sUV']]].\n  rewrite {modU' compV modU i le_nG_Um rsimVi}/U' -(map_mx0 f').\n  by apply: etrans ltU; elim: U 0 => //= Ui U IHU Ui'; rewrite IHU map_ltmx.\nhave{sUV'} defV': V' = U'; last rewrite {V'}defV' in compV'.\n  apply/eqP; rewrite eq_sym -(geq_leqif (size_subseq_leqif sUV')) size_map.\n  rewrite -(leq_add2r m); apply: leq_trans le_nG_Um.\n  apply: IHm (f' \\o f) _.\n  by rewrite (mx_series_lt compV'); case: compV'.\nsuffices{irrG'}: mx_irreducible rG' by case/mxsimpleP=> _ _ [].\nhave ltiU': i < size U' by rewrite size_map.\napply: mx_rsim_irr (mx_rsim_sym _ ) (mx_series_repr_irr compV' ltiU').\nby apply: mx_rsim_trans (mx_rsim_map f' rsimVi) _; apply: map_regular_subseries.\nQed.",
    "Lemma group_closure_field_exists gT F :\n  classically {Fs : fieldType & {rmorphism F -> Fs}\n                              & group_closure_field Fs gT}.\nProof.\nset n := #|{group gT}|.\nsuffices: classically {Fs : fieldType & {rmorphism F -> Fs}\n   & forall G : {group gT}, enum_rank G < n -> group_splitting_field Fs G}.\n- apply: classic_bind => [[Fs f splitFs]] _ -> //.\n  by exists Fs => // G; apply: splitFs.\nelim: (n) => [|i IHi]; first by move=> _ -> //; exists F => //; exists id.\napply: classic_bind IHi => [[F' f splitF']].\nhave [le_n_i _ -> // | lt_i_n] := leqP n i.\n  by exists F' => // G _; apply: splitF'; apply: leq_trans le_n_i.\nhave:= @group_splitting_field_exists _ (enum_val (Ordinal lt_i_n)) F'.\napply: classic_bind => [[Fs f' splitFs]] _ -> //.\nexists Fs => [|G]; first exact: (f' \\o f).\nrewrite ltnS leq_eqVlt -{1}[i]/(val (Ordinal lt_i_n)) val_eqE.\ncase/predU1P=> [defG | ltGi]; first by rewrite -[G]enum_rankK defG.\nby apply: (extend_group_splitting_field f'); apply: splitF'.\nQed.",
    "Lemma group_closure_closed_field (F : closedFieldType) gT :\n  group_closure_field F gT.\nProof.\nmove=> G [|n] rG irrG; first by case/mx_irrP: irrG.\napply: cent_mx_scalar_abs_irr => //; rewrite leqNgt.\napply/(has_non_scalar_mxP (scalar_mx_cent _ _)) => [[A cGA nscalA]].\nhave [a]: exists a, eigenvalue A a.\n  pose P := mxminpoly A; pose d := degree_mxminpoly A.\n  have Pd1: P`_d = 1.\n    by rewrite -(eqP (mxminpoly_monic A)) /lead_coef size_mxminpoly.\n  have d_gt0: d > 0 := mxminpoly_nonconstant A.\n  have [a def_ad] := solve_monicpoly (nth 0 (- P)) d_gt0.\n  exists a; rewrite eigenvalue_root_min -/P /root -oppr_eq0 -hornerN.\n  rewrite horner_coef size_polyN size_mxminpoly -/d big_ord_recr -def_ad.\n  by rewrite coefN Pd1 mulN1r /= subrr.\ncase/negP; rewrite kermx_eq0 row_free_unit (mx_Schur irrG) ?subr_eq0 //.\n  by rewrite -memmx_cent_envelop -raddfN linearD addmx_sub ?scalar_mx_cent.\nby apply: contraNneq nscalA => ->; exact: scalar_mx_is_scalar.\nQed.",
    "Lemma groupC : group_closure_field algC gT.\nProof. exact: group_closure_closed_field. Qed.",
    "Lemma trow0 n1 m2 n2 B : @trow n1 0 m2 n2 B = 0.\nProof.\nelim: n1=> //= n1 IH.\nrewrite !mxE scale0r linear0.\nrewrite IH //; apply/matrixP=> i j; rewrite !mxE.\nby case: split=> *; rewrite mxE.\nQed.",
    "Lemma trowbE n1 m2 n2 A B : trowb B A = @trow n1 A m2 n2 B.\nProof. by []. Qed.",
    "Lemma trowb_is_linear n1 m2 n2 (B : 'M_(m2,n2)) : linear (@trowb n1 m2 n2 B).\nProof.\nelim: n1=> [|n1 IH] //= k A1 A2 /=; first by rewrite scaler0 add0r.\nrewrite !linearD /= !linearZ /= IH 2!mxE.\nby rewrite scalerDl -scalerA -add_row_mx -scale_row_mx.\nQed.",
    "Lemma trow_is_linear n1 m2 n2 (A : 'rV_n1) : linear (@trow n1 A m2 n2).\nProof.\nelim: n1 A => [|n1 IH] //= A k A1 A2 /=; first by rewrite scaler0 add0r.\nrewrite linearP /=; apply/matrixP=> i j; rewrite !mxE.\nby case: split=> a; rewrite ?IH !mxE.\nQed.",
    "Lemma dsumx_mul m1 m2 n p A B :\n  dsubmx ((A *m B) : 'M[F]_(m1 + m2, n)) = dsubmx (A : 'M_(m1 + m2, p)) *m B.\nProof.\napply/matrixP=> i j /[!mxE]; apply: eq_bigr=> k _.\nby rewrite !mxE.\nQed.",
    "Lemma usumx_mul m1 m2 n p A B :\n  usubmx ((A *m B) : 'M[F]_(m1 + m2, n)) = usubmx (A : 'M_(m1 + m2, p)) *m B.\nProof.\nby apply/matrixP=> i j /[!mxE]; apply: eq_bigr=> k _ /[!mxE].\nQed.",
    "Lemma tprodE m1 n1 p1 (A1 :'M[F]_(m1,n1)) (A2 :'M[F]_(n1,p1))\n             m2 n2 p2 (B1 :'M[F]_(m2,n2)) (B2 :'M[F]_(n2,p2)) :\n  tprod (A1 *m A2) (B1 *m B2) = (tprod A1 B1) *m (tprod A2 B2).\nProof.\nelim: m1 n1 p1 A1 A2 m2 n2 p2 B1 B2 => /= [|m1 IH].\n  by move=> *; rewrite mul0mx.\nmove=> n1 p1 A1 A2 m2 n2 p2 B1 B2.\nrewrite mul_col_mx -IH.\ncongr col_mx; last by rewrite dsumx_mul.\nrewrite usumx_mul.\nelim: n1 {A1}(usubmx (A1: 'M_(1 + m1, n1))) p1 A2=> //= [u p1 A2|].\n  by rewrite [A2](flatmx0) !mulmx0 -trowbE linear0.\nmove=> n1 IH1 A p1 A2 //=.\nset Al := lsubmx _; set Ar := rsubmx _.\nset Su := usubmx _; set Sd := dsubmx _.\nrewrite mul_row_col -IH1.\nrewrite -{1}(@hsubmxK F 1 1 n1 A).\nrewrite -{1}(@vsubmxK F 1 n1 p1 A2).\nrewrite (@mul_row_col F 1 1 n1 p1).\nrewrite -trowbE linearD /= trowbE -/Al.\ncongr (_ + _).\nrewrite {1}[Al]mx11_scalar mul_scalar_mx.\nby rewrite -trowbE linearZ /= trowbE -/Su trow_mul scalemxAl.\nQed.",
    "Lemma tprod1 m n : tprod (1%:M : 'M[F]_(m,m)) (1%:M : 'M[F]_(n,n)) = 1%:M.\nProof.\nelim: m n => [|m IH] n //=; first by rewrite [1%:M]flatmx0.\nrewrite tprod_tr.\nset u := rsubmx _; have->: u = 0.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j=> /= j Hj; case.\nset v := lsubmx (dsubmx _); have->: v = 0.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j; case.\nset w := rsubmx _; have->: w = 1%:M.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j; case.\nrewrite IH -!trowbE !linear0.\nrewrite -block_mxEv.\nset z := (lsubmx _) 0 0; have->: z = 1.\n  by rewrite /z !mxE eqxx.\nby rewrite scale1r scalar_mx_block.\nQed.",
    "Lemma mxtrace_prod m n (A :'M[F]_(m)) (B :'M[F]_(n)) :\n  \\tr (tprod A B) =  \\tr A * \\tr B.\nProof.\nelim: m n A B => [|m IH] n A B //=.\n  by rewrite [A]flatmx0 mxtrace0 mul0r.\nrewrite tprod_tr -block_mxEv mxtrace_block IH.\nrewrite linearZ/= -mulrDl -trace_mx11; congr (_ * _).\npose A1 := A : 'M_(1 + m).\nrewrite -[A in RHS](@submxK _ 1 m 1 m A1).\nby rewrite (@mxtrace_block _ _ _ (ulsubmx A1)).\nQed.",
    "Lemma mx_repr0 : mx_repr G (fun _ : gT => 1%:M : 'M[R]_0).\nProof. by split=> // g h Hg Hx; rewrite mulmx1. Qed.",
    "Lemma add_mx_repr (rG1 rG2 : representation) :\n  mx_repr G (fun g => block_mx (rG1 g) 0 0 (rG2 g)).\nProof.\nsplit=> [|x y Hx Hy]; first by rewrite !repr_mx1 -scalar_mx_block.\nby rewrite mulmx_block !(mulmx0, mul0mx, addr0, add0r, repr_mxM).\nQed.",
    "Lemma mx_rsim_dadd  (U V W : 'M_n) (rU rV : representation)\n    (modU : mxmodule rG U) (modV : mxmodule rG V) (modW : mxmodule rG W) :\n    (U + V :=: W)%MS -> mxdirect (U + V) ->\n    mx_rsim (submod_repr modU) rU -> mx_rsim (submod_repr modV) rV ->\n  mx_rsim (submod_repr modW) (dadd_grepr rU rV).\nProof.\ncase: rU; case: rV=> nV rV nU rU defW dxUV /=.\nhave tiUV := mxdirect_addsP dxUV.\nmove=> [fU def_nU]; rewrite -{nU}def_nU in rU fU * => inv_fU hom_fU.\nmove=> [fV def_nV]; rewrite -{nV}def_nV in rV fV * => inv_fV hom_fV.\npose pU := in_submod U (proj_mx U V) *m fU.\npose pV := in_submod V (proj_mx V U) *m fV.\nexists (val_submod 1%:M *m row_mx pU pV) => [||g Gg].\n- by rewrite -defW (mxdirectP dxUV).\n- apply/row_freeP.\n  pose pU' := invmx fU *m val_submod 1%:M.\n  pose pV' := invmx fV *m val_submod 1%:M.\n  exists (in_submod _ (col_mx pU' pV')).\n  rewrite in_submodE mulmxA -in_submodE -mulmxA mul_row_col mulmxDr.\n  rewrite -[pU *m _]mulmxA -[pV *m _]mulmxA !mulKVmx -?row_free_unit //.\n  rewrite addrC (in_submodE V) 2![val_submod 1%:M *m _]mulmxA -in_submodE.\n  rewrite addrC (in_submodE U) 2![val_submod 1%:M *m _ in X in X + _]mulmxA.\n  rewrite -in_submodE -!val_submodE !in_submodK ?proj_mx_sub //.\n  by rewrite add_proj_mx ?val_submodK // val_submod1 defW.\nrewrite mulmxA -val_submodE -[submod_repr _ g]mul1mx val_submodJ //.\nrewrite -(mulmxA _ (rG g)) mul_mx_row -[in RHS]mulmxA mul_row_block.\nrewrite !mulmx0 addr0 add0r !mul_mx_row.\nset W' := val_submod 1%:M; congr (row_mx _ _).\n  rewrite 3!mulmxA in_submodE mulmxA.\n  have hom_pU: (W' <= dom_hom_mx rG (proj_mx U V))%MS.\n    by rewrite val_submod1 -defW proj_mx_hom.\n  rewrite (hom_mxP hom_pU) // -in_submodE (in_submodJ modU) ?proj_mx_sub //.\n  rewrite -(mulmxA _ _ fU) hom_fU // in_submodE -2!(mulmxA W') -in_submodE.\n  by rewrite -mulmxA (mulmxA _ fU).\nrewrite 3!mulmxA in_submodE mulmxA.\nhave hom_pV: (W' <= dom_hom_mx rG (proj_mx V U))%MS.\n  by rewrite val_submod1 -defW addsmxC proj_mx_hom // capmxC.\nrewrite (hom_mxP hom_pV) // -in_submodE (in_submodJ modV) ?proj_mx_sub //.\nrewrite -(mulmxA _ _ fV) hom_fV // in_submodE -2!(mulmxA W') -in_submodE.\nby rewrite -mulmxA (mulmxA _ fV).\nQed.",
    "Lemma mx_rsim_dsum (I : finType) (P : pred I) U rU (W : 'M_n)\n    (modU : forall i, mxmodule rG (U i)) (modW : mxmodule rG W) :\n    let S := (\\sum_(i | P i) U i)%MS in (S :=: W)%MS -> mxdirect S ->\n    (forall i, mx_rsim (submod_repr (modU i)) (rU i : representation)) ->\n  mx_rsim (submod_repr modW) (\\big[dadd_grepr/grepr0]_(i | P i) rU i).\nProof.\nmove=> /= defW dxW rsimU.\nrewrite mxdirectE /= -!(big_filter _ P) in dxW defW *.\nelim: {P}(filter P _) => [|i e IHe] in W modW dxW defW *.\n  rewrite !big_nil /= in defW *.\n  by exists 0 => [||? _]; rewrite ?mul0mx ?mulmx0 // /row_free -defW !mxrank0.\nrewrite !big_cons /= in dxW defW *.\nrewrite 2!(big_nth i) !big_mkord /= in IHe dxW defW.\nset Wi := (\\sum_i _)%MS in defW dxW IHe.\nrewrite -mxdirectE mxdirect_addsE !mxdirectE eqxx /= -/Wi in dxW.\nhave modWi: mxmodule rG Wi by apply: sumsmx_module.\ncase/andP: dxW; move/(IHe Wi modWi) {IHe}; move/(_ (eqmx_refl _))=> rsimWi.\nby move/eqP; move/mxdirect_addsP=> dxUiWi; apply: mx_rsim_dadd (rsimU i) rsimWi.\nQed.",
    "Lemma mx_rsim_socle (sG : socleType rG) (W : sG) (rW : representation) :\n    let modW : mxmodule rG W := component_mx_module rG (socle_base W) in\n    mx_rsim (socle_repr W) rW ->\n  mx_rsim (submod_repr modW) (muln_grepr rW (socle_mult W)).\nProof.\nset M := socle_base W => modW rsimM.\nhave simM: mxsimple rG M := socle_simple W.\nhave rankM_gt0: (\\rank M > 0)%N by rewrite lt0n mxrank_eq0; case: simM.\nhave [I /= U_I simU]: mxsemisimple rG W by apply: component_mx_semisimple.\npose U (i : 'I_#|I|) := U_I (enum_val i).\nhave reindexI := reindex _ (onW_bij I (enum_val_bij I)).\nrewrite mxdirectE /= !reindexI -mxdirectE /= => defW dxW.\nhave isoU: forall i, mx_iso rG M (U i).\n  move=> i; have sUiW: (U i <= W)%MS  by rewrite -defW (sumsmx_sup i).\n  exact: component_mx_iso (simU _) sUiW.\nhave ->: socle_mult W = #|I|.\n  rewrite -(mulnK #|I| rankM_gt0); congr (_ %/ _)%N.\n  rewrite -defW (mxdirectP dxW) /= -sum_nat_const reindexI /=.\n  by apply: eq_bigr => i _; rewrite -(mxrank_iso (isoU i)).\nhave modU: mxmodule rG (U _) := mxsimple_module (simU _).\nsuff: mx_rsim (submod_repr (modU _)) rW by apply: mx_rsim_dsum defW dxW.\nby move=> i; apply: mx_rsim_trans (mx_rsim_sym _) rsimM; apply/mx_rsim_iso.\nQed.",
    "Lemma prod_mx_repr : mx_repr G (fun g => tprod (rG1 g) (rG2 g)).\nProof.\nsplit=>[|i j InG JnG]; first by rewrite !repr_mx1 tprod1.\nby rewrite !repr_mxM // tprodE.\nQed.",
    "Lemma prod_repr_lin n2 (rG1 : reprG 1) (rG2 : reprG n2) :\n  {in G, forall x, let cast_n2 := esym (mul1n n2) in\n      prod_repr rG1 rG2 x = castmx (cast_n2, cast_n2) (rG1 x 0 0 *: rG2 x)}.\nProof.\nmove=> x Gx /=; set cast_n2 := esym _; rewrite /prod_repr /= !mxE !lshift0.\napply/matrixP=> i j; rewrite castmxE /=.\ndo 2![rewrite mxE; case: splitP => [? ? | []//]].\nby congr ((_ *: rG2 x) _ _); apply: val_inj.\nQed.",
    "Lemma cfRepr1 n rG : @cfRepr n rG 1%g = n%:R.\nProof. by rewrite cfunE group1 repr_mx1 mxtrace1. Qed.",
    "Lemma cfRepr_sim n1 n2 rG1 rG2 :\n  mx_rsim rG1 rG2 -> @cfRepr n1 rG1 = @cfRepr n2 rG2.\nProof.\ncase/mx_rsim_def=> f12 [f21] fK def_rG1; apply/cfun_inP=> x Gx.\nby rewrite !cfunE def_rG1 // mxtrace_mulC mulmxA fK mul1mx.\nQed.",
    "Lemma cfRepr0 : cfRepr grepr0 = 0.\nProof. by apply/cfun_inP=> x Gx; rewrite !cfunE Gx mxtrace1. Qed.",
    "Lemma cfRepr_dadd rG1 rG2 :\n  cfRepr (dadd_grepr rG1 rG2) = cfRepr rG1 + cfRepr rG2.\nProof. by apply/cfun_inP=> x Gx; rewrite !cfunE Gx mxtrace_block. Qed.",
    "Lemma cfRepr_dsum I r (P : pred I) rG :\n  cfRepr (\\big[dadd_grepr/grepr0]_(i <- r | P i) rG i)\n    = \\sum_(i <- r | P i) cfRepr (rG i).\nProof. exact: (big_morph _ cfRepr_dadd cfRepr0). Qed.",
    "Lemma cfRepr_muln rG k : cfRepr (muln_grepr rG k) = cfRepr rG *+ k.\nProof. by rewrite cfRepr_dsum /= sumr_const card_ord. Qed.",
    "Lemma mx_rsim_standard : mx_rsim rG standard_grepr.\nProof.\npose W i := oapp val 0 (soc i); pose S := (\\sum_i W i)%MS.\nhave C'G: [pchar algC]^'.-group G := algC'G_pchar G.\nhave [defS dxS]: (S :=: 1%:M)%MS /\\ mxdirect S.\n  rewrite /S mxdirectE /= !(bigID soc xpredT) /=.\n  rewrite addsmxC big1 => [|i]; last by rewrite /W; case (soc i).\n  rewrite adds0mx_id addnC (@big1 nat) ?add0n => [|i]; last first.\n    by rewrite /W; case: (soc i); rewrite ?mxrank0.\n  have <-: Socle sG = 1%:M := reducible_Socle1 sG (mx_Maschke_pchar rG C'G).\n  have [W0 _ | noW] := pickP sG; last first.\n    suff no_i: (soc : pred iG) =1 xpred0 by rewrite /Socle !big_pred0 ?mxrank0.\n    by move=> i; rewrite /soc; case: pickP => // W0; have:= noW W0.\n  have irrK Wi: soc (standard_irr Wi) = Some Wi.\n    rewrite /soc; case: pickP => [W' | /(_ Wi)] /= /eqP // eqWi.\n    apply/eqP/socle_rsimP.\n    apply: mx_rsim_trans\n      (rsim_irr_comp_pchar iG C'G (socle_irr _)) (mx_rsim_sym _).\n    by rewrite [irr_comp _ _]eqWi; apply: rsim_irr_comp_pchar (socle_irr _).\n  have bij_irr: {on [pred i | soc i], bijective standard_irr}.\n    exists (odflt W0 \\o soc) => [Wi _ | i]; first by rewrite /= irrK.\n    by rewrite inE /soc /=; case: pickP => //= Wi; move/eqP.\n  rewrite !(reindex standard_irr) {bij_irr}//=.\n  have all_soc Wi: soc (standard_irr Wi) by rewrite irrK.\n  rewrite (eq_bigr val) => [|Wi _]; last by rewrite /W irrK.\n  rewrite !(eq_bigl _ _ all_soc); split=> //.\n  rewrite (eq_bigr (mxrank \\o val)) => [|Wi _]; last by rewrite /W irrK.\n  by rewrite -mxdirectE /= Socle_direct.\npose modW i : mxmodule rG (W i) :=\n  if soc i is Some Wi as oWi return mxmodule rG (oapp val 0 oWi) then\n    component_mx_module rG (socle_base Wi)\n  else mxmodule0 rG n.\napply: mx_rsim_trans (mx_rsim_sym (rsim_submod1 (mxmodule1 rG) _)) _ => //.\napply: mx_rsim_dsum (modW) _ defS dxS _ => i.\nrewrite /W /standard_irr_coef /modW /soc; case: pickP => [Wi|_] /=; last first.\n  rewrite /muln_grepr big_ord0.\n  by exists 0 => [||x _]; rewrite /row_free ?mxrank0 ?mulmx0 ?mul0mx.\nmove/eqP=> <-; apply: mx_rsim_socle.\nexact: rsim_irr_comp_pchar (socle_irr Wi).\nQed.",
    "Lemma cfRegE x : @cfReg G x = #|G|%:R *+ (x == 1%g).\nProof. by rewrite cfunE cfuniE ?normal1 // inE mulr_natr. Qed.",
    "Lemma cfReprReg : cfRepr (regular_repr algC G) = cfReg G.\nProof.\napply/cfun_inP=> x Gx; rewrite cfRegE.\nhave [-> | ntx] := eqVneq x 1%g; first by rewrite cfRepr1.\nrewrite cfunE Gx [\\tr _]big1 // => i _; rewrite 2!mxE /=.\nrewrite -(inj_eq enum_val_inj) gring_indexK ?groupM ?enum_valP //.\nby rewrite eq_mulVg1 mulKg (negbTE ntx).\nQed.",
    "Lemma xcfun_is_additive phi : additive (xcfun phi).\nProof. by move=> A B; rewrite /xcfun [gring_row _]linearB mulmxBl !mxE. Qed.",
    "Lemma xcfunZr a phi A : xcfun phi (a *: A) = a * xcfun phi A.\nProof. by rewrite /xcfun linearZ -scalemxAl mxE. Qed.",
    "Lemma xcfun_rE A chi : xcfun_r A chi = xcfun chi A. Proof. by []. Qed.",
    "Lemma xcfunZl a phi A : xcfun (a *: phi) A = a * xcfun phi A.\nProof.\nrewrite /xcfun !mxE big_distrr; apply: eq_bigr => i _ /=.\nby rewrite !mxE cfunE mulrCA.\nQed.",
    "Lemma xcfun_repr n rG A : xcfun (@cfRepr n rG) A = \\tr (gring_op rG A).\nProof.\nrewrite gring_opE [gring_row A]row_sum_delta !linear_sum /xcfun !mxE.\napply: eq_bigr => i _; rewrite !mxE /= !linearZ cfunE enum_valP /=.\nby congr (_ * \\tr _); rewrite {A}/gring_mx /= -rowE rowK mxvecK.\nQed.",
    "Lemma NirrE : Nirr G = #|classes G|.\nProof. by rewrite /pred_Nirr (cardD1 [1]) classes1. Qed.",
    "Lemma socle_Iirr0 : W 0 = [1 sG]%irr.\nProof. by rewrite /W add0r cast_ordKV enum_rankK. Qed.",
    "Lemma socle_of_IirrK : cancel W irr_of_socle.\nProof. by move=> i; rewrite /irr_of_socle enum_valK cast_ordK addrK. Qed.",
    "Lemma irr_of_socleK : cancel irr_of_socle W.\nProof. by move=> Wi; rewrite /W subrK cast_ordKV enum_rankK. Qed.",
    "Lemma irr_of_socle_bij (A : {pred (Iirr G)}) : {on A, bijective irr_of_socle}.\nProof. by apply: onW_bij; exists W. Qed.",
    "Lemma socle_of_Iirr_bij (A : {pred sG}) : {on A, bijective W}.\nProof. by apply: onW_bij; exists irr_of_socle. Qed.",
    "Lemma congr_irr i1 i2 : i1 = i2 -> 'chi_i1 = 'chi_i2. Proof. by move->. Qed.",
    "Lemma Iirr1_neq0 : G :!=: 1%g -> inord 1 != 0 :> Iirr G.\nProof. by rewrite -classes_gt1 -NirrE -val_eqE /= => /inordK->. Qed.",
    "Lemma has_nonprincipal_irr : G :!=: 1%g -> {i : Iirr G | i != 0}.\nProof. by move/Iirr1_neq0; exists (inord 1). Qed.",
    "Lemma irrRepr i : cfRepr 'Chi_i = 'chi_i.\nProof.\nrewrite irr.unlock (tnth_nth 0) nth_mkseq // -[<<G>>]/(gval _) genGidG.\nby rewrite cfRes_id inord_val.\nQed.",
    "Lemma irr0 : 'chi[G]_0 = 1.\nProof.\napply/cfun_inP=> x Gx; rewrite -irrRepr cfun1E cfunE Gx.\nby rewrite socle_Iirr0 irr1_repr // mxtrace1 degree_irr1.\nQed.",
    "Lemma cfun1_irr : 1 \\in irr G.\nProof. by rewrite -irr0 mem_tnth. Qed.",
    "Lemma mem_irr i : 'chi_i \\in irr G.\nProof. exact: mem_tnth. Qed.",
    "Lemma irrP xi : reflect (exists i, xi = 'chi_i) (xi \\in irr G).\nProof.\napply: (iffP idP) => [/(nthP 0)[i] | [i ->]]; last exact: mem_irr.\nrewrite size_tuple => lt_i_G <-.\nby exists (Ordinal lt_i_G); rewrite (tnth_nth 0).\nQed.",
    "Lemma irr1_degree i : 'chi_i 1%g = ('n_i)%:R.\nProof. by rewrite -irrRepr cfRepr1. Qed.",
    "Lemma Cnat_irr1 i : 'chi_i 1%g \\in Num.nat.\nProof. by rewrite irr1_degree rpred_nat. Qed.",
    "Lemma irr1_gt0 i : 0 < 'chi_i 1%g.\nProof. by rewrite irr1_degree ltr0n irr_degree_gt0. Qed.",
    "Lemma irr1_neq0 i : 'chi_i 1%g != 0.\nProof. by rewrite eq_le lt_geF ?irr1_gt0. Qed.",
    "Lemma irr_neq0 i : 'chi_i != 0.\nProof. by apply: contraNneq (irr1_neq0 i) => ->; rewrite cfunE. Qed.",
    "Lemma cfIirrE chi : chi \\in irr G -> 'chi_(cfIirr chi) = chi.\nProof.\nmove=> chi_irr; rewrite (tnth_nth 0) [cfIirr]unlock inordK ?nth_index //.\nby rewrite -index_mem size_tuple in chi_irr.\nQed.",
    "Lemma cfIirrPE J (f : J -> 'CF(G)) (P : pred J) :\n    (forall j, P j -> f j \\in irr G) ->\n  forall j, P j -> 'chi_(cfIirr (f j)) = f j.\nProof. by move=> irr_f j /irr_f; apply: cfIirrE. Qed.",
    "Lemma cfReg_sum : cfReg G = \\sum_i 'chi_i 1%g *: 'chi_i.\nProof.\napply/cfun_inP=> x Gx.\nrewrite -cfReprReg cfunE Gx (mxtrace_regular_pchar sG) //=.\nrewrite sum_cfunE (reindex _ (socle_of_Iirr_bij _)); apply: eq_bigr => i _.\nby rewrite -irrRepr cfRepr1 !cfunE Gx mulr_natl.\nQed.",
    "Lemma xcfun_annihilate i j A : i != j -> (A \\in 'R_j)%MS -> ('chi_i).[A]%CF = 0.\nProof.\nmove=> neq_ij RjA; rewrite -irrRepr xcfun_repr.\nrewrite (irr_repr'_op0_pchar _ _ RjA) ?raddf0 //.\nby rewrite eq_sym (can_eq socle_of_IirrK).\nQed.",
    "Lemma xcfunG phi x : x \\in G -> phi.[aG x]%CF = phi x.\nProof.\nby move=> Gx; rewrite /xcfun /gring_row rowK -rowE !mxE !(gring_indexK, mul1g).\nQed.",
    "Lemma xcfun_mul_id i A :\n  (A \\in R_G)%MS -> ('chi_i).['e_i *m A]%CF = ('chi_i).[A]%CF.\nProof.\nmove=> RG_A; rewrite -irrRepr !xcfun_repr gring_opM //.\nby rewrite op_Wedderburn_id_pchar ?mul1mx.\nQed.",
    "Lemma xcfun_id i j : ('chi_i).['e_j]%CF = 'chi_i 1%g *+ (i == j).\nProof.\nhave [<-{j} | /xcfun_annihilate->//] := eqVneq; last exact: Wedderburn_id_mem.\nby rewrite -xcfunG // repr_mx1 -(xcfun_mul_id _ (envelop_mx1 _)) mulmx1.\nQed.",
    "Lemma irr_free : free (irr G).\nProof.\napply/freeP=> s s0 i; apply: (mulIf (irr1_neq0 i)).\nrewrite mul0r -(raddf0 (xcfun_r 'e_i)) -{}s0 raddf_sum /=.\nrewrite (bigD1 i)//= -tnth_nth xcfunZl xcfun_id eqxx big1 ?addr0 // => j ne_ji.\nby rewrite -tnth_nth xcfunZl xcfun_id (negbTE ne_ji) mulr0.\nQed.",
    "Lemma irr_inj : injective (tnth (irr G)).\nProof. by apply/injectiveP/free_uniq; rewrite map_tnth_enum irr_free. Qed.",
    "Lemma irrK : cancel (tnth (irr G)) (@cfIirr G).\nProof. by move=> i; apply: irr_inj; rewrite cfIirrE ?mem_irr. Qed.",
    "Lemma irr_eq1 i : ('chi_i == 1) = (i == 0).\nProof. by rewrite -irr0 (inj_eq irr_inj). Qed.",
    "Lemma cforder_irr_eq1 i : (#['chi_i]%CF == 1) = (i == 0).\nProof. by rewrite -dvdn1 dvdn_cforder irr_eq1. Qed.",
    "Lemma irr_basis : basis_of 'CF(G)%VS (irr G).\nProof.\nrewrite /basis_of irr_free andbT -dimv_leqif_eq ?subvf //.\nby rewrite dim_cfun (eqnP irr_free) size_tuple NirrE.\nQed.",
    "Lemma eq_sum_nth_irr a : \\sum_i a i *: 'chi[G]_i = \\sum_i a i *: (irr G)`_i.\nProof. by apply: eq_bigr => i; rewrite -tnth_nth. Qed.",
    "Lemma cfRepr_standard n (rG : mx_representation algC G n) :\n  cfRepr (standard_grepr rG)\n    = \\sum_i (standard_irr_coef rG (W i))%:R *: 'chi_i.\nProof.\nrewrite cfRepr_dsum (reindex _ (socle_of_Iirr_bij _)).\nby apply: eq_bigr => i _; rewrite scaler_nat cfRepr_muln irrRepr.\nQed.",
    "Lemma cfRepr_inj n1 n2 rG1 rG2 :\n  @cfRepr _ G n1 rG1 = @cfRepr _ G n2 rG2 -> mx_rsim rG1 rG2.\nProof.\nmove=> eq_repr12; pose c i : algC := (standard_irr_coef _ (W i))%:R.\nhave [rsim1 rsim2] := (mx_rsim_standard rG1, mx_rsim_standard rG2).\napply: mx_rsim_trans (rsim1) (mx_rsim_sym _).\nsuffices ->: standard_grepr rG1 = standard_grepr rG2 by [].\napply: eq_bigr => Wi _; congr (muln_grepr _ _); apply/eqP; rewrite -eqC_nat.\nrewrite -[Wi]irr_of_socleK -!/(c _ _ _) -!(coord_sum_free (c _ _) _ irr_free).\nrewrite -!eq_sum_nth_irr -!cfRepr_standard.\nby rewrite -(cfRepr_sim rsim1) -(cfRepr_sim rsim2) eq_repr12.\nQed.",
    "Lemma cfRepr_rsimP n1 n2 rG1 rG2 :\n  reflect (mx_rsim rG1 rG2) (@cfRepr _ G n1 rG1 == @cfRepr _ G n2 rG2).\nProof. by apply: (iffP eqP) => [/cfRepr_inj | /cfRepr_sim]. Qed.",
    "Lemma irr_reprP xi :\n  reflect (exists2 rG : representation _ G, mx_irreducible rG & xi = cfRepr rG)\n          (xi \\in irr G).\nProof.\napply: (iffP (irrP xi)) => [[i ->] | [[n rG] irr_rG ->]].\n  by exists (Representation 'Chi_i); [apply: socle_irr | rewrite irrRepr].\nexists (irr_of_socle (irr_comp sG rG)); rewrite -irrRepr irr_of_socleK /=.\nexact/cfRepr_sim/rsim_irr_comp_pchar.\nQed.",
    "Lemma Wedderburn_id_expansion i :\n  'e_i = #|G|%:R^-1 *: \\sum_(x in G) 'chi_i 1%g * 'chi_i x^-1%g *: aG x.\nProof.\nhave Rei: ('e_i \\in 'R_i)%MS by apply: Wedderburn_id_mem.\nhave /envelop_mxP[a def_e]: ('e_i \\in R_G)%MS; last rewrite -/aG in def_e.\n  by move: Rei; rewrite genmxE mem_sub_gring => /andP[].\napply: canRL (scalerK (neq0CG _)) _; rewrite def_e linear_sum /=.\napply: eq_bigr => x Gx; have Gx' := groupVr Gx; rewrite scalerA; congr (_ *: _).\ntransitivity (cfReg G).['e_i *m aG x^-1%g]%CF.\n  rewrite def_e mulmx_suml raddf_sum (bigD1 x) //= -scalemxAl xcfunZr.\n  rewrite -repr_mxM // mulgV xcfunG // cfRegE eqxx mulrC big1 ?addr0 //.\n  move=> y /andP[Gy /negbTE neq_xy]; rewrite -scalemxAl xcfunZr -repr_mxM //.\n  by rewrite xcfunG ?groupM // cfRegE -eq_mulgV1 neq_xy mulr0.\nrewrite cfReg_sum -xcfun_rE raddf_sum /= (bigD1 i) //= xcfunZl.\nrewrite xcfun_mul_id ?envelop_mx_id ?xcfunG ?groupV ?big1 ?addr0 // => j ne_ji.\nrewrite xcfunZl (xcfun_annihilate ne_ji) ?mulr0 //.\nhave /andP[_ /(submx_trans _)-> //] := Wedderburn_ideal (W i).\nby rewrite mem_mulsmx // envelop_mx_id ?groupV.\nQed.",
    "Lemma irr_char i : 'chi_i \\is a character.\nProof. by apply/forallP=> j; rewrite (tnth_nth 0) coord_free ?irr_free. Qed.",
    "Lemma cfun1_char : (1 : 'CF(G)) \\is a character.\nProof. by rewrite -irr0 irr_char. Qed.",
    "Lemma cfun0_char : (0 : 'CF(G)) \\is a character.\nProof. by apply/forallP=> i; rewrite linear0 rpred0. Qed.",
    "Lemma char_sum_irrP {phi} :\n  reflect (exists n, phi = \\sum_i (n i)%:R *: 'chi_i) (phi \\is a character).\nProof.\napply: (iffP idP)=> [/forallP-Nphi | [n ->]]; last first.\n  by apply: rpred_sum => i _; rewrite scaler_nat rpredMn // irr_char.\ndo [have [a ->] := cfun_irr_sum phi] in Nphi *; exists (Num.truncn \\o a).\napply: eq_bigr => i _; congr (_ *: _); have:= eqP (Nphi i).\nby rewrite eq_sum_nth_irr coord_sum_free ?irr_free.\nQed.",
    "Lemma char_sum_irr chi :\n  chi \\is a character -> {r | chi = \\sum_(i <- r) 'chi_i}.\nProof.\nmove=> Nchi; apply: sig_eqW; case/char_sum_irrP: Nchi => n {chi}->.\nelim/big_rec: _ => [|i _ _ [r ->]]; first by exists nil; rewrite big_nil.\nexists (ncons (n i) i r); rewrite scaler_nat.\nby elim: {n}(n i) => [|n IHn]; rewrite ?add0r //= big_cons mulrS -addrA IHn.\nQed.",
    "Lemma Cnat_char1 chi : chi \\is a character -> chi 1%g \\in Num.nat.\nProof.\ncase/char_sum_irr=> r ->{chi}.\nby elim/big_rec: _ => [|i chi _ Nchi1]; rewrite cfunE ?rpredD // Cnat_irr1.\nQed.",
    "Lemma char1_ge0 chi : chi \\is a character -> 0 <= chi 1%g.\nProof. by move/Cnat_char1/natr_ge0. Qed.",
    "Lemma char1_eq0 chi : chi \\is a character -> (chi 1%g == 0) = (chi == 0).\nProof.\ncase/char_sum_irr=> r ->; apply/idP/idP=> [|/eqP->]; last by rewrite cfunE.\ncase: r => [|i r]; rewrite ?big_nil // sum_cfunE big_cons.\nrewrite paddr_eq0 ?sumr_ge0  => // [||j _]; rewrite 1?ltW ?irr1_gt0 //.\nby rewrite (negbTE (irr1_neq0 i)).\nQed.",
    "Lemma char1_gt0 chi : chi \\is a character -> (0 < chi 1%g) = (chi != 0).\nProof. by move=> Nchi; rewrite -char1_eq0 // natr_gt0 ?Cnat_char1. Qed.",
    "Lemma char_reprP phi :\n  reflect (exists rG : representation algC G, phi = cfRepr rG)\n          (phi \\is a character).\nProof.\napply: (iffP char_sum_irrP) => [[n ->] | [[n rG] ->]]; last first.\n  exists (fun i => standard_irr_coef rG (socle_of_Iirr i)).\n  by rewrite -cfRepr_standard (cfRepr_sim (mx_rsim_standard rG)).\nexists (\\big[dadd_grepr/grepr0]_i muln_grepr (Representation 'Chi_i) (n i)).\nrewrite cfRepr_dsum; apply: eq_bigr => i _.\nby rewrite cfRepr_muln irrRepr scaler_nat.\nQed.",
    "Lemma cfRepr_char n (rG : reprG n) : cfRepr rG \\is a character.\nProof. by apply/char_reprP; exists (Representation rG). Qed.",
    "Lemma cfReg_char : cfReg G \\is a character.\nProof. by rewrite -cfReprReg cfRepr_char. Qed.",
    "Lemma cfRepr_prod n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n  cfRepr rG1 * cfRepr rG2 = cfRepr (prod_repr rG1 rG2).\nProof. by apply/cfun_inP=> x Gx; rewrite !cfunE /= Gx mxtrace_prod. Qed.",
    "Lemma mul_char : mulr_closed (@character G).\nProof.\nsplit=> [|_ _ /char_reprP[rG1 ->] /char_reprP[rG2 ->]]; first exact: cfun1_char.\napply/char_reprP; exists (Representation (prod_repr rG1 rG2)).\nby rewrite cfRepr_prod.\nQed.",
    "Lemma cfRepr_map u n (rG : mx_representation algC G n) :\n  cfRepr (map_repr u rG) = cfAut u (cfRepr rG).\nProof. by apply/cfun_inP=> x Gx; rewrite !cfunE Gx map_reprE trace_map_mx. Qed.",
    "Lemma cfAut_char u chi : (cfAut u chi \\is a character) = (chi \\is a character).\nProof.\nwithout loss /char_reprP[rG ->]: u chi / chi \\is a character.\n  by move=> IHu; apply/idP/idP=> ?; first rewrite -(cfAutK u chi); rewrite IHu.\nrewrite cfRepr_char; apply/char_reprP.\nby exists (Representation (map_repr u rG)); rewrite cfRepr_map.\nQed.",
    "Lemma cfConjC_char chi : (chi^*%CF \\is a character) = (chi \\is a character).\nProof. exact: cfAut_char. Qed.",
    "Lemma cfAut_char1 u (chi : 'CF(G)) :\n  chi \\is a character -> cfAut u chi 1%g = chi 1%g.\nProof. by move/Cnat_char1=> Nchi1; rewrite cfunE /= aut_natr. Qed.",
    "Lemma cfAut_irr1 u i : (cfAut u 'chi[G]_i) 1%g = 'chi_i 1%g.\nProof. exact: cfAut_char1 (irr_char i). Qed.",
    "Lemma cfConjC_char1 (chi : 'CF(G)) :\n  chi \\is a character -> chi^*%CF 1%g = chi 1%g.\nProof. exact: cfAut_char1. Qed.",
    "Lemma cfConjC_irr1 u i : ('chi[G]_i)^*%CF 1%g = 'chi_i 1%g.\nProof. exact: cfAut_irr1. Qed.",
    "Lemma lin_char1: xi 1%g = 1.\nProof. by case/andP: CFxi => _ /eqP. Qed.",
    "Lemma lin_charW : xi \\is a character.\nProof. by case/andP: CFxi. Qed.",
    "Lemma cfun1_lin_char : (1 : 'CF(G)) \\is a linear_char.\nProof. by rewrite qualifE/= cfun1_char /= cfun11. Qed.",
    "Lemma lin_charM : {in G &, {morph xi : x y / (x * y)%g >-> x * y}}.\nProof.\nmove=> x y Gx Gy; case/andP: CFxi => /char_reprP[[n rG] -> /=].\nrewrite cfRepr1 pnatr_eq1 => /eqP n1; rewrite {n}n1 in rG *.\nrewrite !cfunE Gx Gy groupM //= !mulr1n repr_mxM //.\nby rewrite [rG x]mx11_scalar [rG y]mx11_scalar -scalar_mxM !mxtrace_scalar.\nQed.",
    "Lemma lin_char_prod I r (P : pred I) (x : I -> gT) :\n    (forall i, P i -> x i \\in G) ->\n  xi (\\prod_(i <- r | P i) x i)%g = \\prod_(i <- r | P i) xi (x i).\nProof.\nmove=> Gx; elim/(big_load (fun y => y \\in G)): _.\nelim/big_rec2: _ => [|i a y Pi [Gy <-]]; first by rewrite lin_char1.\nby rewrite groupM ?lin_charM ?Gx.\nQed.",
    "Lemma lin_char_neq0 x : x \\in G -> xi x != 0.\nProof.\nby move/xiMV/(congr1 (predC1 0)); rewrite /= oner_eq0 mulf_eq0 => /norP[].\nQed.",
    "Lemma lin_charV x : x \\in G -> xi x^-1%g = (xi x)^-1.\nProof. by move=> Gx; rewrite -[_^-1]mulr1 -(xiMV Gx) mulKf ?lin_char_neq0. Qed.",
    "Lemma lin_charX x n : x \\in G -> xi (x ^+ n)%g = xi x ^+ n.\nProof.\nmove=> Gx; elim: n => [|n IHn]; first exact: lin_char1.\nby rewrite expgS exprS lin_charM ?groupX ?IHn.\nQed.",
    "Lemma lin_char_unity_root x : x \\in G -> xi x ^+ #[x] = 1.\nProof. by move=> Gx; rewrite -lin_charX // expg_order lin_char1. Qed.",
    "Lemma normC_lin_char x : x \\in G -> `|xi x| = 1.\nProof.\nmove=> Gx; apply/eqP; rewrite -(@pexpr_eq1 _ _ #[x]) //.\nby rewrite -normrX // lin_char_unity_root ?normr1.\nQed.",
    "Lemma lin_charV_conj x : x \\in G -> xi x^-1%g = (xi x)^*.\nProof.\nmove=> Gx; rewrite lin_charV // invC_norm mulrC normC_lin_char //.\nby rewrite expr1n divr1.\nQed.",
    "Lemma lin_char_irr : xi \\in irr G.\nProof.\ncase/andP: CFxi => /char_reprP[rG ->]; rewrite cfRepr1 pnatr_eq1 => /eqP n1.\nby apply/irr_reprP; exists rG => //; apply/mx_abs_irrW/linear_mx_abs_irr.\nQed.",
    "Lemma mul_conjC_lin_char : xi * xi^*%CF = 1.\nProof.\napply/cfun_inP=> x Gx.\nby rewrite !cfunE cfun1E Gx -normCK normC_lin_char ?expr1n.\nQed.",
    "Lemma lin_char_unitr : xi \\in GRing.unit.\nProof. by apply/unitrPr; exists xi^*%CF; apply: mul_conjC_lin_char. Qed.",
    "Lemma invr_lin_char : xi^-1 = xi^*%CF.\nProof. by rewrite -[_^-1]mulr1 -mul_conjC_lin_char mulKr ?lin_char_unitr. Qed.",
    "Lemma fful_lin_char_inj : cfaithful xi -> {in G &, injective xi}.\nProof.\nmove=> fful_phi x y Gx Gy xi_xy; apply/eqP; rewrite eq_mulgV1 -in_set1.\nrewrite (subsetP fful_phi) // inE groupM ?groupV //=; apply/forallP=> z.\nhave [Gz | G'z] := boolP (z \\in G); last by rewrite !cfun0 ?groupMl ?groupV.\nby rewrite -mulgA lin_charM ?xi_xy -?lin_charM ?groupM ?groupV // mulKVg.\nQed.",
    "Lemma cfAut_lin_char u (xi : 'CF(G)) :\n  (cfAut u xi \\is a linear_char) = (xi \\is a linear_char).\nProof. by rewrite qualifE/= cfAut_char; apply/andb_id2l=> /cfAut_char1->. Qed.",
    "Lemma cfConjC_lin_char (xi : 'CF(G)) :\n  (xi^*%CF \\is a linear_char) = (xi \\is a linear_char).\nProof. exact: cfAut_lin_char. Qed.",
    "Lemma card_Iirr_abelian : abelian G -> #|Iirr G| = #|G|.\nProof. by rewrite card_ord NirrE card_classes_abelian => /eqP. Qed.",
    "Lemma card_Iirr_cyclic : cyclic G -> #|Iirr G| = #|G|.\nProof. by move/cyclic_abelian/card_Iirr_abelian. Qed.",
    "Lemma char_abelianP :\n  reflect (forall i : Iirr G, 'chi_i \\is a linear_char) (abelian G).\nProof.\napply: (iffP idP) => [cGG i | CF_G].\n  rewrite qualifE/= irr_char /= irr1_degree.\n  by rewrite irr_degree_abelian //; last apply: groupC.\nrewrite card_classes_abelian -NirrE -eqC_nat -irr_sum_square //.\nrewrite -{1}[Nirr G]card_ord -sumr_const; apply/eqP/eq_bigr=> i _.\nby rewrite lin_char1 ?expr1n ?CF_G.\nQed.",
    "Lemma irr_repr_lin_char (i : Iirr G) x :\n    x \\in G -> 'chi_i \\is a linear_char ->\n  irr_repr (socle_of_Iirr i) x = ('chi_i x)%:M.\nProof.\nmove=> Gx CFi; rewrite -irrRepr cfunE Gx.\nmove: (_ x); rewrite -[irr_degree _](@natrK algC) -irr1_degree lin_char1 //.\nby rewrite (natrK 1) => A; rewrite trace_mx11 -mx11_scalar.\nQed.",
    "Lemma irr_cyclic_lin i : cyclic G -> 'chi[G]_i \\is a linear_char.\nProof. by move/cyclic_abelian/char_abelianP. Qed.",
    "Lemma irr_prime_lin i : prime #|G| -> 'chi[G]_i \\is a linear_char.\nProof. by move/prime_cyclic/irr_cyclic_lin. Qed.",
    "Lemma repr_rsim_diag (G : {group gT}) f (rG : mx_representation algC G f) x :\n    x \\in G -> let chi := cfRepr rG in\n  exists e,\n [/\\  exists2 B, B \\in unitmx & rG x = invmx B *m diag_mx e *m B,\n      (forall i, e 0 i ^+ #[x] = 1) /\\ (forall i, `|e 0 i| = 1),\n      chi x = \\sum_i e 0 i /\\ `|chi x| <= chi 1%g\n   &  chi x^-1%g = (chi x)^*].\nProof.\nmove=> Gx; without loss cGG: G rG Gx / abelian G.\n  have sXG: <[x]> \\subset G by rewrite cycle_subG.\n  move/(_ _ (subg_repr rG sXG) (cycle_id x) (cycle_abelian x)).\n  by rewrite /= !cfunE !groupV Gx (cycle_id x) !group1.\nhave [I U W simU W1 dxW]: mxsemisimple rG 1%:M.\n  rewrite -(reducible_Socle1 (DecSocleType rG)\n    (mx_Maschke_pchar _ (algC'G_pchar G))).\n  exact: Socle_semisimple.\nhave linU i: \\rank (U i) = 1.\n  by apply: mxsimple_abelian_linear cGG (simU i); apply: groupC.\nhave castI: f = #|I|.\n  by rewrite -(mxrank1 algC f) -W1 (eqnP dxW) /= -sum1_card; apply/eq_bigr.\npose B := \\matrix_j nz_row (U (enum_val (cast_ord castI j))).\nhave rowU i: (nz_row (U i) :=: U i)%MS.\n  apply/eqmxP; rewrite -(geq_leqif (mxrank_leqif_eq (nz_row_sub _))) linU.\n  by rewrite lt0n mxrank_eq0 (nz_row_mxsimple (simU i)).\nhave unitB: B \\in unitmx.\n  rewrite -row_full_unit -sub1mx -W1; apply/sumsmx_subP=> i _.\n  pose j := cast_ord (esym castI) (enum_rank i).\n  by rewrite (submx_trans _ (row_sub j B)) // rowK cast_ordKV enum_rankK rowU.\npose e := \\row_j row j (B *m rG x *m invmx B) 0 j.\nhave rGx: rG x = invmx B *m diag_mx e *m B.\n  rewrite -mulmxA; apply: canRL (mulKmx unitB) _.\n  apply/row_matrixP=> j; rewrite 2!row_mul; set u := row j B.\n  have /sub_rVP[a def_ux]: (u *m rG x <= u)%MS.\n    rewrite /u rowK rowU (eqmxMr _ (rowU _)).\n    exact: (mxmoduleP (mxsimple_module (simU _))).\n  rewrite def_ux [u]rowE scalemxAl; congr (_ *m _).\n  apply/rowP=> k; rewrite 5!mxE !row_mul def_ux [u]rowE scalemxAl mulmxK //.\n  by rewrite !mxE !eqxx !mulr_natr eq_sym.\nhave exp_e j: e 0 j ^+ #[x] = 1.\n  suffices: (diag_mx e j j) ^+ #[x] = (B *m rG (x ^+ #[x])%g *m invmx B) j j.\n    by rewrite expg_order repr_mx1 mulmx1 mulmxV // [e]lock !mxE eqxx.\n  elim: #[x] => [|n IHn]; first by rewrite repr_mx1 mulmx1 mulmxV // !mxE eqxx.\n  rewrite expgS repr_mxM ?groupX // {1}rGx -!mulmxA mulKVmx //.\n  by rewrite mul_diag_mx mulmxA [M in _ = M]mxE -IHn exprS {1}mxE eqxx.\nhave norm1_e j: `|e 0 j| = 1.\n  by apply/eqP; rewrite -(@pexpr_eq1 _ _ #[x]) // -normrX exp_e normr1.\nexists e; split=> //; first by exists B.\n  rewrite cfRepr1 !cfunE Gx rGx mxtrace_mulC mulKVmx // mxtrace_diag.\n  split=> //=; apply: (le_trans (ler_norm_sum _ _ _)).\n  by rewrite (eq_bigr _ (in1W norm1_e)) sumr_const card_ord lexx.\nrewrite !cfunE groupV !mulrb Gx rGx mxtrace_mulC mulKVmx //.\nrewrite -trace_map_mx map_diag_mx; set d' := diag_mx _.\nrewrite -[d'](mulKVmx unitB) mxtrace_mulC -[_ *m _](repr_mxK rG Gx) rGx.\nrewrite -!mulmxA mulKVmx // (mulmxA d').\nsuffices->: d' *m diag_mx e = 1%:M by rewrite mul1mx mulKmx.\nrewrite mulmx_diag -diag_const_mx; congr diag_mx; apply/rowP=> j.\nby rewrite [e]lock !mxE mulrC -normCK -lock norm1_e expr1n.\nQed.",
    "Lemma char_inv (chi : 'CF(G)) x : chi \\is a character -> chi x^-1%g = (chi x)^*.\nProof.\ncase Gx: (x \\in G); last by rewrite !cfun0 ?rmorph0 ?groupV ?Gx.\nby case/char_reprP=> rG ->; have [e [_ _ _]] := repr_rsim_diag rG Gx.\nQed.",
    "Lemma irr_inv i x : 'chi[G]_i x^-1%g = ('chi_i x)^*.\nProof. exact/char_inv/irr_char. Qed.",
    "Lemma irr_classP i : c i \\in classes G.\nProof. exact: enum_valP. Qed.",
    "Lemma repr_irr_classK i : g i ^: G = c i.\nProof. by case/repr_classesP: (irr_classP i). Qed.",
    "Lemma irr_classK : cancel c iC.\nProof. by move=> i; rewrite /iC enum_valK_in cast_ordK. Qed.",
    "Lemma class_IirrK : {in classes G, cancel iC c}.\nProof. by move=> xG GxG; rewrite /c cast_ordKV enum_rankK_in. Qed.",
    "Lemma reindex_irr_class R idx (op : @Monoid.com_law R idx) F :\n  \\big[op/idx]_(xG in classes G) F xG = \\big[op/idx]_i F (c i).\nProof.\nrewrite (reindex c); first by apply: eq_bigl => i; apply: enum_valP.\nby exists iC; [apply: in1W; apply: irr_classK | apply: class_IirrK].\nQed.",
    "Lemma character_table_unit : X \\in unitmx.\nProof. by case/mulmx1_unit: XX'_1. Qed.",
    "Lemma eq_irr_mem_classP x y :\n  y \\in G -> reflect (forall i, 'chi[G]_i x = 'chi_i y) (x \\in y ^: G).\nProof.\nmove=> Gy; apply: (iffP idP) => [/imsetP[z Gz ->] i | xGy]; first exact: cfunJ.\nhave Gx: x \\in G.\n  congr is_true: Gy; apply/eqP; rewrite -(can_eq oddb) -eqC_nat -!cfun1E.\n  by rewrite -irr0 xGy.\ncongr is_true: (class_refl G x); apply/eqP; rewrite -(can_eq oddb).\nrewrite -(eqn_pmul2l (cardG_gt0 'C_G[x])) -eqC_nat !mulrnA; apply/eqP.\nby rewrite -!second_orthogonality_relation //; apply/eq_bigr=> i _; rewrite xGy.\nQed.",
    "Lemma card_afix_irr_classes (ito : action A (Iirr G)) (cto : action A _) a :\n    a \\in A -> [acts A, on classes G | cto] ->\n    (forall i x y, x \\in G -> y \\in cto (x ^: G) a ->\n      'chi_i x = 'chi_(ito i a) y) ->\n  #|'Fix_ito[a]| = #|'Fix_(classes G | cto)[a]|.\nProof.\nmove=> Aa actsAG stabAchi; apply/eqP; rewrite -eqC_nat; apply/eqP.\nhave [[cP cK] iCK] := (irr_classP, irr_classK, class_IirrK).\npose icto b i := iC (cto (c i) b).\nhave Gca i: cto (c i) a \\in classes G by rewrite (acts_act actsAG).\nhave inj_qa: injective (icto a).\n  by apply: can_inj (icto a^-1%g) _ => i; rewrite /icto iCK ?actKin ?cK.\npose Pa : 'M[algC]_(Nirr G) := perm_mx (actperm ito a).\npose qa := perm inj_qa; pose Qa : 'M[algC]_(Nirr G) := perm_mx qa^-1^-1%g.\ntransitivity (\\tr Pa).\n  rewrite -sumr_const big_mkcond; apply: eq_bigr => i _.\n  by rewrite !mxE permE inE sub1set inE; case: ifP.\nsymmetry; transitivity (\\tr Qa).\n  rewrite cardsE -sumr_const -big_filter_cond big_mkcond big_filter /=.\n  rewrite reindex_irr_class; apply: eq_bigr => i _; rewrite !mxE invgK permE.\n  by rewrite inE sub1set inE -(can_eq cK) iCK //; case: ifP.\nrewrite -[Pa](mulmxK uX) -[Qa](mulKmx uX) mxtrace_mulC; congr (\\tr(_ *m _)).\nrewrite -row_permE -col_permE; apply/matrixP=> i j; rewrite !mxE.\nrewrite -{2}[j](permKV qa); move: {j}(_ j) => j; rewrite !permE iCK //.\napply: stabAchi; first by case/repr_classesP: (cP j).\nby rewrite repr_irr_classK (mem_repr_classes (Gca _)).\nQed.",
    "Lemma cfdot_irr i j : '['chi_i, 'chi_j]_G = (i == j)%:R.\nProof.\nrewrite -first_orthogonality_relation; congr (_ * _).\nby apply: eq_bigr => x Gx; rewrite irr_inv.\nQed.",
    "Lemma cfnorm_irr i : '['chi[G]_i] = 1.\nProof. by rewrite cfdot_irr eqxx. Qed.",
    "Lemma irr_orthonormal : orthonormal (irr G).\nProof.\napply/orthonormalP; split; first exact: free_uniq (irr_free G).\nmove=> _ _ /irrP[i ->] /irrP[j ->].\nby rewrite cfdot_irr (inj_eq irr_inj).\nQed.",
    "Lemma coord_cfdot phi i : coord (irr G) i phi = '[phi, 'chi_i].\nProof.\nrewrite {2}(coord_basis (irr_basis G) (memvf phi)).\nrewrite cfdot_suml (bigD1 i) // cfdotZl /= -tnth_nth cfdot_irr eqxx mulr1.\nrewrite big1 ?addr0 // => j neq_ji; rewrite cfdotZl /= -tnth_nth cfdot_irr.\nby rewrite (negbTE neq_ji) mulr0.\nQed.",
    "Lemma cfun_sum_cfdot phi : phi = \\sum_i '[phi, 'chi_i]_G *: 'chi_i.\nProof.\nrewrite {1}(coord_basis (irr_basis G) (memvf phi)).\nby apply: eq_bigr => i _; rewrite coord_cfdot -tnth_nth.\nQed.",
    "Lemma cfdot_sum_irr phi psi :\n  '[phi, psi]_G = \\sum_i '[phi, 'chi_i] * '[psi, 'chi_i]^*.\nProof.\nrewrite {1}[phi]cfun_sum_cfdot cfdot_suml; apply: eq_bigr => i _.\nby rewrite cfdotZl -cfdotC.\nQed.",
    "Lemma Cnat_cfdot_char_irr i phi :\n  phi \\is a character -> '[phi, 'chi_i]_G \\in Num.nat.\nProof. by move/forallP/(_ i); rewrite coord_cfdot. Qed.",
    "Lemma cfdot_char_r phi chi :\n  chi \\is a character -> '[phi, chi]_G = \\sum_i '[phi, 'chi_i] * '[chi, 'chi_i].\nProof.\nmove=> Nchi; rewrite cfdot_sum_irr; apply: eq_bigr => i _; congr (_ * _).\nby rewrite conj_natr ?Cnat_cfdot_char_irr.\nQed.",
    "Lemma Cnat_cfdot_char chi xi :\n  chi \\is a character -> xi \\is a character -> '[chi, xi]_G \\in Num.nat.\nProof.\nmove=> Nchi Nxi; rewrite cfdot_char_r ?rpred_sum // => i _.\nby rewrite rpredM ?Cnat_cfdot_char_irr.\nQed.",
    "Lemma cfdotC_char chi xi :\n  chi \\is a character-> xi \\is a character -> '[chi, xi]_G = '[xi, chi].\nProof. by move=> Nchi Nxi; rewrite cfdotC conj_natr ?Cnat_cfdot_char. Qed.",
    "Lemma irrEchar chi : (chi \\in irr G) = (chi \\is a character) && ('[chi] == 1).\nProof.\napply/irrP/andP=> [[i ->] | [Nchi]]; first by rewrite irr_char cfnorm_irr.\nrewrite cfdot_sum_irr => /eqP/natr_sum_eq1[i _| i [_ ci1 cj0]].\n  by rewrite rpredM // ?conj_natr ?Cnat_cfdot_char_irr.\nexists i; rewrite [chi]cfun_sum_cfdot (bigD1 i) //=.\nrewrite -(normr_idP (natr_ge0 (Cnat_cfdot_char_irr i Nchi))).\nrewrite normC_def {}ci1 sqrtC1 scale1r big1 ?addr0 // => j neq_ji.\nby rewrite (('[_] =P 0) _) ?scale0r // -normr_eq0 normC_def cj0 ?sqrtC0.\nQed.",
    "Lemma irrWchar chi : chi \\in irr G -> chi \\is a character.\nProof. by rewrite irrEchar => /andP[]. Qed.",
    "Lemma irrWnorm chi : chi \\in irr G -> '[chi] = 1.\nProof. by rewrite irrEchar => /andP[_ /eqP]. Qed.",
    "Lemma mul_lin_irr xi chi :\n  xi \\is a linear_char -> chi \\in irr G -> xi * chi \\in irr G.\nProof.\nmove=> Lxi; rewrite !irrEchar => /andP[Nphi /eqP <-].\nrewrite rpredM // ?lin_charW //=; apply/eqP; congr (_ * _).\napply: eq_bigr=> x Gx; rewrite !cfunE rmorphM/= mulrACA -(lin_charV_conj Lxi)//.\nby rewrite -lin_charM ?groupV // mulgV lin_char1 ?mul1r.\nQed.",
    "Lemma eq_scaled_irr a b i j :\n  (a *: 'chi[G]_i == b *: 'chi_j) = (a == b) && ((a == 0) || (i == j)).\nProof.\napply/eqP/andP=> [|[/eqP-> /pred2P[]-> //]]; last by rewrite !scale0r.\nmove/(congr1 (cfdotr 'chi__)) => /= eq_ai_bj.\nmove: {eq_ai_bj}(eq_ai_bj i) (esym (eq_ai_bj j)); rewrite !cfdotZl !cfdot_irr.\nby rewrite !mulr_natr !mulrb !eqxx eq_sym orbC; case: ifP => _ -> //= ->.\nQed.",
    "Lemma eq_signed_irr (s t : bool) i j :\n  ((-1) ^+ s *: 'chi[G]_i == (-1) ^+ t *: 'chi_j) = (s == t) && (i == j).\nProof. by rewrite eq_scaled_irr signr_eq0 (inj_eq signr_inj). Qed.",
    "Lemma eq_scale_irr a (i j : Iirr G) :\n  (a *: 'chi_i == a *: 'chi_j) = (a == 0) || (i == j).\nProof. by rewrite eq_scaled_irr eqxx. Qed.",
    "Lemma eq_addZ_irr a b (i j r t : Iirr G) :\n  (a *: 'chi_i + b *: 'chi_j == a *: 'chi_r + b *: 'chi_t)\n   = [|| [&& (a == 0) || (i == r) & (b == 0) || (j == t)],\n         [&& i == t, j == r & a == b] | [&& i == j, r == t & a == - b]].\nProof.\nrewrite -!eq_scale_irr; apply/eqP/idP; last first.\n  case/orP; first by case/andP=> /eqP-> /eqP->.\n  case/orP=> /and3P[/eqP-> /eqP-> /eqP->]; first by rewrite addrC.\n  by rewrite !scaleNr !addNr.\nhave [-> /addrI/eqP-> // | /=] := eqVneq.\nrewrite eq_scale_irr => /norP[/negP nz_a /negPf neq_ir].\nmove/(congr1 (cfdotr 'chi__))/esym/eqP => /= eq_cfdot.\nmove: {eq_cfdot}(eq_cfdot i) (eq_cfdot r); rewrite eq_sym !cfdotDl !cfdotZl.\nrewrite !cfdot_irr !mulr_natr !mulrb !eqxx -!(eq_sym i) neq_ir !add0r.\nhave [<- _ | _] := i =P t; first by rewrite neq_ir addr0; case: ifP => // _ ->.\nrewrite 2!fun_if if_arg addr0 addr_eq0; case: eqP => //= <- ->.\nby rewrite neq_ir 2!fun_if if_arg eq_sym addr0; case: ifP.\nQed.",
    "Lemma eq_subZnat_irr (a b : nat) (i j r t : Iirr G) :\n  (a%:R *: 'chi_i - b%:R *: 'chi_j == a%:R *: 'chi_r - b%:R *: 'chi_t)\n    = [|| a == 0 | i == r] && [|| b == 0 | j == t]\n      || [&& i == j, r == t & a == b].\nProof.\nrewrite -!scaleNr eq_addZ_irr oppr_eq0 opprK -addr_eq0 -natrD eqr_nat.\nby rewrite !pnatr_eq0 addn_eq0; case: a b => [|a] [|b]; rewrite ?andbF.\nQed.",
    "Lemma char1_ge_norm (chi : 'CF(G)) x :\n  chi \\is a character -> `|chi x| <= chi 1%g.\nProof.\ncase/char_reprP=> rG ->; case Gx: (x \\in G); last first.\n  by rewrite cfunE cfRepr1 Gx normr0 ler0n.\nby have [e [_ _ []]] := repr_rsim_diag rG Gx.\nQed.",
    "Lemma max_cfRepr_norm_scalar n (rG : mx_representation algC G n) x :\n     x \\in G -> `|cfRepr rG x| = cfRepr rG 1%g ->\n   exists2 c, `|c| = 1 & rG x = c%:M.\nProof.\nmove=> Gx; have [e [[B uB def_x] [_ e1] [-> _] _]] := repr_rsim_diag rG Gx.\nrewrite cfRepr1 -[n in n%:R]card_ord -sumr_const -(eq_bigr _ (in1W e1)).\ncase/normC_sum_eq1=> [i _ | c /eqP norm_c_1 def_e]; first by rewrite e1.\nhave{} def_e: e = const_mx c by apply/rowP=> i; rewrite mxE def_e ?andbT.\nby exists c => //; rewrite def_x def_e diag_const_mx scalar_mxC mulmxKV.\nQed.",
    "Lemma max_cfRepr_mx1 n (rG : mx_representation algC G n) x :\n   x \\in G -> cfRepr rG x = cfRepr rG 1%g -> rG x = 1%:M.\nProof.\nmove=> Gx kerGx; have [|c _ def_x] := @max_cfRepr_norm_scalar n rG x Gx.\n  by rewrite kerGx cfRepr1 normr_nat.\nmove/eqP: kerGx; rewrite cfRepr1 cfunE Gx {rG}def_x mxtrace_scalar.\ncase: n => [_|n]; first by rewrite ![_%:M]flatmx0.\nrewrite mulrb -subr_eq0 -mulrnBl -mulr_natl mulf_eq0 pnatr_eq0 /=.\nby rewrite subr_eq0 => /eqP->.\nQed.",
    "Lemma irr_consttE i phi : (i \\in irr_constt phi) = ('[phi, 'chi_i]_G != 0).\nProof. by []. Qed.",
    "Lemma constt_charP (i : Iirr G) chi :\n    chi \\is a character ->\n  reflect (exists2 chi', chi' \\is a character & chi = 'chi_i + chi')\n          (i \\in irr_constt chi).\nProof.\nmove=> Nchi; apply: (iffP idP) => [i_in_chi| [chi' Nchi' ->]]; last first.\n  rewrite inE /= cfdotDl cfdot_irr eqxx -(eqP (Cnat_cfdot_char_irr i Nchi')).\n  by rewrite -natrD pnatr_eq0.\nexists (chi - 'chi_i); last by rewrite addrC subrK.\napply/forallP=> j; rewrite coord_cfdot cfdotBl cfdot_irr.\nhave [<- | _] := eqP; last by rewrite subr0 Cnat_cfdot_char_irr.\nmove: i_in_chi; rewrite inE; case/natrP: (Cnat_cfdot_char_irr i Nchi) => n ->.\nby rewrite pnatr_eq0 -lt0n => /natrB <-; apply: rpred_nat.\nQed.",
    "Lemma cfun_sum_constt (phi : 'CF(G)) :\n  phi = \\sum_(i in irr_constt phi) '[phi, 'chi_i] *: 'chi_i.\nProof.\nrewrite {1}[phi]cfun_sum_cfdot (bigID [pred i | '[phi, 'chi_i] == 0]) /=.\nby rewrite big1 ?add0r // => i /eqP->; rewrite scale0r.\nQed.",
    "Lemma neq0_has_constt (phi : 'CF(G)) :\n  phi != 0 -> exists i, i \\in irr_constt phi.\nProof.\nmove=> nz_phi; apply/existsP; apply: contra nz_phi => /pred0P phi0.\nby rewrite [phi]cfun_sum_constt big_pred0.\nQed.",
    "Lemma constt_irr i : irr_constt 'chi[G]_i =i pred1 i.\nProof.\nby move=> j; rewrite !inE cfdot_irr pnatr_eq0 (eq_sym j); case: (i == j).\nQed.",
    "Lemma char1_ge_constt (i : Iirr G) chi :\n  chi \\is a character -> i \\in irr_constt chi -> 'chi_i 1%g <= chi 1%g.\nProof.\nmove=> {chi} _ /constt_charP[// | chi Nchi ->].\nby rewrite cfunE addrC -subr_ge0 addrK char1_ge0.\nQed.",
    "Lemma constt_ortho_char (phi psi : 'CF(G)) i j :\n     phi \\is a character -> psi \\is a character ->\n     i \\in irr_constt phi -> j \\in irr_constt psi ->\n  '[phi, psi] = 0 -> '['chi_i, 'chi_j] = 0.\nProof.\nmove=> _ _ /constt_charP[//|phi1 Nphi1 ->] /constt_charP[//|psi1 Npsi1 ->].\nrewrite cfdot_irr; case: eqP => // -> /eqP/idPn[].\nrewrite cfdotDl !cfdotDr cfnorm_irr -addrA gt_eqF ?ltr_wpDr ?ltr01 //.\nby rewrite natr_ge0 ?rpredD ?Cnat_cfdot_char ?irr_char.\nQed.",
    "Lemma cfker_repr n (rG : mx_representation algC G n) :\n  cfker (cfRepr rG) = rker rG.\nProof.\napply/esym/setP=> x; rewrite inE mul1mx /=.\ncase Gx: (x \\in G); last by rewrite inE Gx.\napply/eqP/idP=> Kx; last by rewrite max_cfRepr_mx1 // cfker1.\nrewrite inE Gx; apply/forallP=> y; rewrite !cfunE !mulrb groupMl //.\nby case: ifP => // Gy; rewrite repr_mxM // Kx mul1mx.\nQed.",
    "Lemma cfkerEchar chi :\n  chi \\is a character -> cfker chi = [set x in G | chi x == chi 1%g].\nProof.\nmove=> Nchi; apply/setP=> x; apply/idP/setIdP=> [Kx | [Gx /eqP chi_x]].\n  by rewrite (subsetP (cfker_sub chi)) // cfker1.\ncase/char_reprP: Nchi => rG -> in chi_x *; rewrite inE Gx; apply/forallP=> y.\nrewrite !cfunE groupMl // !mulrb; case: ifP => // Gy.\nby rewrite repr_mxM // max_cfRepr_mx1 ?mul1mx.\nQed.",
    "Lemma cfker_nzcharE chi :\n  chi \\is a character -> chi != 0 -> cfker chi = [set x | chi x == chi 1%g].\nProof.\nmove=> Nchi nzchi; apply/setP=> x; rewrite cfkerEchar // !inE andb_idl //.\nby apply: contraLR => /cfun0-> //; rewrite eq_sym char1_eq0.\nQed.",
    "Lemma cfkerEirr i : cfker 'chi[G]_i = [set x | 'chi_i x == 'chi_i 1%g].\nProof. by rewrite cfker_nzcharE ?irr_char ?irr_neq0. Qed.",
    "Lemma cfker_irr0 : cfker 'chi[G]_0 = G.\nProof. by rewrite irr0 cfker_cfun1. Qed.",
    "Lemma cfaithful_reg : cfaithful (cfReg G).\nProof.\napply/subsetP=> x; rewrite cfkerEchar ?cfReg_char // !inE !cfRegE eqxx.\nby case/andP=> _; apply: contraLR => /negbTE->; rewrite eq_sym neq0CG.\nQed.",
    "Lemma cfkerE chi :\n    chi \\is a character ->\n  cfker chi = G :&: \\bigcap_(i in irr_constt chi) cfker 'chi_i.\nProof.\nmove=> Nchi; rewrite cfkerEchar //; apply/setP=> x; rewrite !inE.\napply: andb_id2l => Gx; rewrite {1 2}[chi]cfun_sum_constt !sum_cfunE.\napply/eqP/bigcapP=> [Kx i Ci | Kx]; last first.\n  by apply: eq_bigr => i /Kx Kx_i; rewrite !cfunE cfker1.\nrewrite cfkerEirr inE /= -(inj_eq (mulfI Ci)).\nhave:= (normC_sum_upper _ Kx) i; rewrite !cfunE => -> // {Ci}i _.\nhave chi_i_ge0: 0 <= '[chi, 'chi_i].\n  by rewrite natr_ge0 ?Cnat_cfdot_char_irr.\nby rewrite !cfunE normrM (normr_idP _) ?ler_wpM2l ?char1_ge_norm ?irr_char.\nQed.",
    "Lemma TI_cfker_irr : \\bigcap_i cfker 'chi[G]_i = [1].\nProof.\napply/trivgP; apply: subset_trans cfaithful_reg; rewrite cfkerE ?cfReg_char //.\nrewrite subsetI (bigcap_min 0) //=; last by rewrite cfker_irr0.\nby apply/bigcapsP=> i _; rewrite bigcap_inf.\nQed.",
    "Lemma cfker_constt i chi :\n    chi \\is a character -> i \\in irr_constt chi ->\n  cfker chi \\subset cfker 'chi[G]_i.\nProof. by move=> Nchi Ci; rewrite cfkerE ?subIset ?(bigcap_min i) ?orbT. Qed.",
    "Lemma lin_char_der1 : G^`(1)%g \\subset cfker xi.\nProof.\nrewrite gen_subG /=; apply/subsetP=> _ /imset2P[x y Gx Gy ->].\nrewrite cfkerEchar // inE groupR //= !lin_charM ?lin_charV ?in_group //.\nby rewrite mulrCA mulKf ?mulVf ?lin_char_neq0 // lin_char1.\nQed.",
    "Lemma cforder_lin_char : #[xi]%CF = exponent (G / cfker xi)%g.\nProof.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  apply/dvdn_cforderP=> x Gx; rewrite -lin_charX // -cfQuoEker ?groupX //.\n  rewrite morphX ?(subsetP (cfker_norm xi)) //= expg_exponent ?mem_quotient //.\n  by rewrite cfQuo1 ?cfker_normal ?lin_char1.\nhave abGbar: abelian (G / cfker xi) := sub_der1_abelian lin_char_der1.\nhave [_ /morphimP[x Nx Gx ->] ->] := exponent_witness (abelian_nil abGbar).\nrewrite order_dvdn -morphX //= coset_id cfkerEchar // !inE groupX //=.\nby rewrite lin_charX ?lin_char1 // (dvdn_cforderP _ _ _).\nQed.",
    "Lemma cforder_lin_char_dvdG : #[xi]%CF %| #|G|.\nProof.\nby rewrite cforder_lin_char (dvdn_trans (exponent_dvdn _)) ?dvdn_morphim.\nQed.",
    "Lemma cforder_lin_char_gt0 : (0 < #[xi]%CF)%N.\nProof. by rewrite cforder_lin_char exponent_gt0. Qed.",
    "Lemma cfRepr_sub n (rG : mx_representation algC G n) (sHG : H \\subset G) :\n  cfRepr (subg_repr rG sHG) = 'Res[H] (cfRepr rG).\nProof.\nby apply/cfun_inP => x Hx; rewrite cfResE // !cfunE Hx (subsetP sHG).\nQed.",
    "Lemma cfRes_char chi : chi \\is a character -> 'Res[H, G] chi \\is a character.\nProof.\nhave [sHG | not_sHG] := boolP (H \\subset G).\n  by case/char_reprP=> rG ->; rewrite -(cfRepr_sub rG sHG) cfRepr_char.\nby move/Cnat_char1=> Nchi1; rewrite cfResEout // rpredZ_nat ?rpred1.\nQed.",
    "Lemma cfRes_eq0 phi : phi \\is a character -> ('Res[H, G] phi == 0) = (phi == 0).\nProof. by move=> Nchi; rewrite -!char1_eq0 ?cfRes_char // cfRes1. Qed.",
    "Lemma cfRes_lin_char chi :\n  chi \\is a linear_char -> 'Res[H, G] chi \\is a linear_char.\nProof. by case/andP=> Nchi; rewrite qualifE/= cfRes_char ?cfRes1. Qed.",
    "Lemma Res_irr_neq0 i : 'Res[H, G] 'chi_i != 0.\nProof. by rewrite cfRes_eq0 ?irr_neq0 ?irr_char. Qed.",
    "Lemma cfRes_lin_lin (chi : 'CF(G)) :\n  chi \\is a character -> 'Res[H] chi \\is a linear_char -> chi \\is a linear_char.\nProof. by rewrite !qualifE/= !qualifE/= cfRes1 => -> /andP[]. Qed.",
    "Lemma cfRes_irr_irr chi :\n  chi \\is a character -> 'Res[H] chi \\in irr H -> chi \\in irr G.\nProof.\nhave [sHG /char_reprP[rG ->] | not_sHG Nchi] := boolP (H \\subset G).\n  rewrite -(cfRepr_sub _ sHG) => /irr_reprP[rH irrH def_rH]; apply/irr_reprP.\n  suffices /subg_mx_irr: mx_irreducible (subg_repr rG sHG) by exists rG.\n  by apply: mx_rsim_irr irrH; apply/cfRepr_rsimP/eqP.\nrewrite cfResEout // => /irrP[j Dchi_j]; apply/lin_char_irr/cfRes_lin_lin=> //.\nsuffices j0: j = 0 by rewrite cfResEout // Dchi_j j0 irr0 rpred1.\napply: contraNeq (irr1_neq0 j) => nz_j.\nhave:= xcfun_id j 0; rewrite -Dchi_j cfunE xcfunZl -irr0 xcfun_id eqxx => ->.\nby rewrite (negPf nz_j).\nQed.",
    "Lemma Res_Iirr0 : Res_Iirr H (0 : Iirr G) = 0.\nProof. by rewrite /Res_Iirr irr0 rmorph1 -irr0 irrK. Qed.",
    "Lemma lin_Res_IirrE i : 'chi[G]_i 1%g = 1 -> 'chi_(Res_Iirr H i) = 'Res 'chi_i.\nProof.\nmove=> chi1; rewrite cfIirrE ?lin_char_irr ?cfRes_lin_char //.\nby rewrite qualifE/= irr_char /= chi1.\nQed.",
    "Lemma constt_Ind_Res i j :\n  i \\in irr_constt ('Ind[G] 'chi_j) =  (j \\in irr_constt ('Res[H] 'chi_i)).\nProof. by rewrite !irr_consttE cfdotC conjC_eq0 -cfdot_Res_l. Qed.",
    "Lemma cfdot_Res_ge_constt i j psi :\n    psi \\is a character -> j \\in irr_constt psi ->\n  '['Res[H, G] 'chi_j, 'chi_i] <= '['Res[H] psi, 'chi_i].\nProof.\nmove=> {psi} _ /constt_charP[// | psi Npsi ->].\nrewrite linearD cfdotDl addrC -subr_ge0 addrK natr_ge0 //=.\nby rewrite Cnat_cfdot_char_irr // cfRes_char.\nQed.",
    "Lemma constt_Res_trans j psi :\n    psi \\is a character -> j \\in irr_constt psi ->\n  {subset irr_constt ('Res[H, G] 'chi_j) <= irr_constt ('Res[H] psi)}.\nProof.\nmove=> Npsi Cj i; apply: contraNneq; rewrite eq_le => {1}<-.\nrewrite cfdot_Res_ge_constt ?natr_ge0 ?Cnat_cfdot_char_irr //.\nby rewrite cfRes_char ?irr_char.\nQed.",
    "Lemma cfRepr_morphim n (rfG : mx_representation algC (f @* G) n) sGD :\n  cfRepr (morphim_repr rfG sGD) = cfMorph (cfRepr rfG).\nProof.\napply/cfun_inP=> x Gx; have Dx: x \\in D := subsetP sGD x Gx.\nby rewrite cfMorphE // !cfunE ?mem_morphim ?Gx.\nQed.",
    "Lemma cfMorph_char chi : chi \\is a character -> cfMorph chi \\is a character.\nProof.\nhave [sGD /char_reprP[rfG ->] | outGD Nchi] := boolP (G \\subset D); last first.\n  by rewrite cfMorphEout // rpredZ_nat ?rpred1 ?Cnat_char1.\napply/char_reprP; exists (Representation (morphim_repr rfG sGD)).\nby rewrite cfRepr_morphim.\nQed.",
    "Lemma cfMorph_lin_char chi :\n  chi \\is a linear_char -> cfMorph chi \\is a linear_char.\nProof. by case/andP=> Nchi; rewrite qualifE/= cfMorph1 cfMorph_char. Qed.",
    "Lemma cfMorph_charE chi :\n  G \\subset D -> (cfMorph chi \\is a character) = (chi \\is a character).\nProof.\nmove=> sGD; apply/idP/idP=> [/char_reprP[[n rG] /=Dfchi] | /cfMorph_char//].\npose H := 'ker_G f; have kerH: H \\subset rker rG.\n  by rewrite -cfker_repr -Dfchi cfker_morph // setIS // ker_sub_pre.\nhave nHG: G \\subset 'N(H) by rewrite normsI // (subset_trans sGD) ?ker_norm.\nhave [h injh im_h] := first_isom_loc f sGD; rewrite -/H in h injh im_h.\nhave DfG: invm injh @*^-1 (G / H) == (f @* G)%g by rewrite morphpre_invm im_h.\npose rfG := eqg_repr (morphpre_repr _ (quo_repr kerH nHG)) DfG.\napply/char_reprP; exists (Representation rfG).\napply/cfun_inP=> _ /morphimP[x Dx Gx ->]; rewrite -cfMorphE // Dfchi !cfunE Gx.\npose xH := coset H x; have GxH: xH \\in (G / H)%g by apply: mem_quotient.\nsuffices Dfx: f x = h xH by rewrite mem_morphim //= Dfx invmE ?quo_repr_coset.\nby apply/set1_inj; rewrite -?morphim_set1 ?im_h ?(subsetP nHG) ?sub1set.\nQed.",
    "Lemma cfMorph_lin_charE chi :\n  G \\subset D -> (cfMorph chi \\is a linear_char) = (chi \\is a linear_char).\nProof. by rewrite qualifE/= cfMorph1 => /cfMorph_charE->. Qed.",
    "Lemma cfMorph_irr chi :\n  G \\subset D -> (cfMorph chi \\in irr G) = (chi \\in irr (f @* G)).\nProof. by move=> sGD; rewrite !irrEchar cfMorph_charE // cfMorph_iso. Qed.",
    "Lemma morph_Iirr0 : morph_Iirr 0 = 0.\nProof. by rewrite /morph_Iirr irr0 rmorph1 -irr0 irrK. Qed.",
    "Lemma morph_IirrE i : 'chi_(morph_Iirr i) = cfMorph 'chi_i.\nProof. by rewrite cfIirrE ?cfMorph_irr ?mem_irr. Qed.",
    "Lemma morph_Iirr_inj : injective morph_Iirr.\nProof.\nby move=> i j eq_ij; apply/irr_inj/cfMorph_inj; rewrite // -!morph_IirrE eq_ij.\nQed.",
    "Lemma morph_Iirr_eq0 i : (morph_Iirr i == 0) = (i == 0).\nProof. by rewrite -!irr_eq1 morph_IirrE cfMorph_eq1. Qed.",
    "Lemma cfIsom_char chi :\n  (cfIsom isoGR chi \\is a character) = (chi \\is a character).\nProof.\nrewrite [cfIsom _]locked_withE cfMorph_charE //.\nby rewrite (isom_im (isom_sym _)) cfRes_id.\nQed.",
    "Lemma cfIsom_lin_char chi :\n  (cfIsom isoGR chi \\is a linear_char) = (chi \\is a linear_char).\nProof. by rewrite qualifE/= cfIsom_char cfIsom1. Qed.",
    "Lemma cfIsom_irr chi : (cfIsom isoGR chi \\in irr R) = (chi \\in irr G).\nProof. by rewrite !irrEchar cfIsom_char cfIsom_iso. Qed.",
    "Lemma isom_IirrE i : 'chi_(isom_Iirr i) = cfIsom isoGR 'chi_i.\nProof. by rewrite cfIirrE ?cfIsom_irr ?mem_irr. Qed.",
    "Lemma isom_Iirr_inj : injective isom_Iirr.\nProof.\nby move=> i j eqij; apply/irr_inj/(cfIsom_inj isoGR); rewrite -!isom_IirrE eqij.\nQed.",
    "Lemma isom_Iirr_eq0 i : (isom_Iirr i == 0) = (i == 0).\nProof. by rewrite -!irr_eq1 isom_IirrE cfIsom_eq1. Qed.",
    "Lemma isom_Iirr0 : isom_Iirr 0 = 0.\nProof. by apply/eqP; rewrite isom_Iirr_eq0. Qed.",
    "Lemma isom_IirrK : cancel (isom_Iirr isoGR) (isom_Iirr (isom_sym isoGR)).\nProof. by move=> i; apply: irr_inj; rewrite !isom_IirrE cfIsomK. Qed.",
    "Lemma isom_IirrKV : cancel (isom_Iirr (isom_sym isoGR)) (isom_Iirr isoGR).\nProof. by move=> i; apply: irr_inj; rewrite !isom_IirrE cfIsomKV. Qed.",
    "Lemma cfSdprod_char chi :\n (cfSdprod defG chi \\is a character) = (chi \\is a character).\nProof. by rewrite unlock cfMorph_charE // cfIsom_char. Qed.",
    "Lemma cfSdprod_lin_char chi :\n (cfSdprod defG chi \\is a linear_char) = (chi \\is a linear_char).\nProof. by rewrite qualifE/= cfSdprod_char cfSdprod1. Qed.",
    "Lemma cfSdprod_irr chi : (cfSdprod defG chi \\in irr G) = (chi \\in irr H).\nProof. by rewrite !irrEchar cfSdprod_char cfSdprod_iso. Qed.",
    "Lemma sdprod_IirrE j : 'chi_(sdprod_Iirr j) = cfSdprod defG 'chi_j.\nProof. by rewrite cfIirrE ?cfSdprod_irr ?mem_irr. Qed.",
    "Lemma sdprod_IirrK : cancel sdprod_Iirr (Res_Iirr H).\nProof. by move=> j; rewrite /Res_Iirr sdprod_IirrE cfSdprodK irrK. Qed.",
    "Lemma sdprod_Iirr_inj : injective sdprod_Iirr.\nProof. exact: can_inj sdprod_IirrK. Qed.",
    "Lemma sdprod_Iirr_eq0 i : (sdprod_Iirr i == 0) = (i == 0).\nProof. by rewrite -!irr_eq1 sdprod_IirrE cfSdprod_eq1. Qed.",
    "Lemma sdprod_Iirr0 : sdprod_Iirr 0 = 0.\nProof. by apply/eqP; rewrite sdprod_Iirr_eq0. Qed.",
    "Lemma Res_sdprod_irr phi :\n  K \\subset cfker phi -> phi \\in irr G -> 'Res phi \\in irr H.\nProof.\nmove=> kerK /irrP[i Dphi]; rewrite irrEchar -(cfSdprod_iso defG).\nby rewrite cfRes_sdprodK // Dphi cfnorm_irr cfRes_char ?irr_char /=.\nQed.",
    "Lemma sdprod_Res_IirrE i :\n  K \\subset cfker 'chi[G]_i -> 'chi_(Res_Iirr H i) = 'Res 'chi_i.\nProof. by move=> kerK; rewrite cfIirrE ?Res_sdprod_irr ?mem_irr. Qed.",
    "Lemma sdprod_Res_IirrK i :\n  K \\subset cfker 'chi_i -> sdprod_Iirr (Res_Iirr H i) = i.\nProof.\nby move=> kerK; rewrite /sdprod_Iirr sdprod_Res_IirrE ?cfRes_sdprodK ?irrK.\nQed.",
    "Lemma cfDprodKl_abelian j : abelian H -> cancel ((cfDprod KxH)^~ 'chi_j) 'Res.\nProof. by move=> cHH; apply: cfDprodKl; apply/lin_char1/char_abelianP. Qed.",
    "Lemma cfDprodKr_abelian i : abelian K -> cancel (cfDprod KxH 'chi_i) 'Res.\nProof. by move=> cKK; apply: cfDprodKr; apply/lin_char1/char_abelianP. Qed.",
    "Lemma cfDprodl_char phi :\n  (cfDprodl KxH phi \\is a character) = (phi \\is a character).\nProof. exact: cfSdprod_char. Qed.",
    "Lemma cfDprodr_char psi :\n  (cfDprodr KxH psi \\is a character) = (psi \\is a character).\nProof. exact: cfSdprod_char. Qed.",
    "Lemma cfDprod_char phi psi :\n     phi \\is a character -> psi \\is a character ->\n  cfDprod KxH phi psi \\is a character.\nProof. by move=> Nphi Npsi; rewrite rpredM ?cfDprodl_char ?cfDprodr_char. Qed.",
    "Lemma cfDprod_eq1 phi psi :\n    phi \\is a character -> psi \\is a character ->\n  (cfDprod KxH phi psi == 1) = (phi == 1) && (psi == 1).\nProof.\nmove=> /Cnat_char1 Nphi /Cnat_char1 Npsi.\napply/eqP/andP=> [phi_psi_1 | [/eqP-> /eqP->]]; last by rewrite cfDprod_cfun1.\nhave /andP[/eqP phi1 /eqP psi1]: (phi 1%g == 1) && (psi 1%g == 1).\n  by rewrite -natr_mul_eq1 // -(cfDprod1 KxH) phi_psi_1 cfun11.\nrewrite -[phi](cfDprodKl KxH psi1) -{2}[psi](cfDprodKr KxH phi1) phi_psi_1.\nby rewrite !rmorph1.\nQed.",
    "Lemma cfDprodl_lin_char phi :\n  (cfDprodl KxH phi \\is a linear_char) = (phi \\is a linear_char).\nProof. exact: cfSdprod_lin_char. Qed.",
    "Lemma cfDprodr_lin_char psi :\n  (cfDprodr KxH psi \\is a linear_char) = (psi \\is a linear_char).\nProof. exact: cfSdprod_lin_char. Qed.",
    "Lemma cfDprod_lin_char phi psi :\n     phi \\is a linear_char -> psi \\is a linear_char ->\n  cfDprod KxH phi psi \\is a linear_char.\nProof. by move=> Nphi Npsi; rewrite rpredM ?cfSdprod_lin_char. Qed.",
    "Lemma cfDprodl_irr chi : (cfDprodl KxH chi \\in irr G) = (chi \\in irr K).\nProof. exact: cfSdprod_irr. Qed.",
    "Lemma cfDprodr_irr chi : (cfDprodr  KxH chi \\in irr G) = (chi \\in irr H).\nProof. exact: cfSdprod_irr. Qed.",
    "Lemma dprodl_IirrE i : 'chi_(dprodl_Iirr i) = cfDprodl KxH 'chi_i.\nProof. exact: sdprod_IirrE. Qed.",
    "Lemma dprodl_IirrK : cancel dprodl_Iirr (Res_Iirr K).\nProof. exact: sdprod_IirrK. Qed.",
    "Lemma dprodl_Iirr_eq0 i : (dprodl_Iirr i == 0) = (i == 0).\nProof. exact: sdprod_Iirr_eq0. Qed.",
    "Lemma dprodl_Iirr0 : dprodl_Iirr 0 = 0.\nProof. exact: sdprod_Iirr0. Qed.",
    "Lemma dprodr_IirrE j : 'chi_(dprodr_Iirr j) = cfDprodr KxH 'chi_j.\nProof. exact: sdprod_IirrE. Qed.",
    "Lemma dprodr_IirrK : cancel dprodr_Iirr (Res_Iirr H).\nProof. exact: sdprod_IirrK. Qed.",
    "Lemma dprodr_Iirr_eq0 j : (dprodr_Iirr j == 0) = (j == 0).\nProof. exact: sdprod_Iirr_eq0. Qed.",
    "Lemma dprodr_Iirr0 : dprodr_Iirr 0 = 0.\nProof. exact: sdprod_Iirr0. Qed.",
    "Lemma cfDprod_irr i j : cfDprod KxH 'chi_i 'chi_j \\in irr G.\nProof.\nrewrite irrEchar cfDprod_char ?irr_char //=.\nby rewrite cfdot_dprod !cfdot_irr !eqxx mul1r.\nQed.",
    "Lemma dprod_IirrE i j : 'chi_(dprod_Iirr (i, j)) = cfDprod KxH 'chi_i 'chi_j.\nProof. by rewrite cfIirrE ?cfDprod_irr. Qed.",
    "Lemma dprod_IirrEl i : 'chi_(dprod_Iirr (i, 0)) = cfDprodl KxH 'chi_i.\nProof. by rewrite dprod_IirrE /cfDprod irr0 rmorph1 mulr1. Qed.",
    "Lemma dprod_IirrEr j : 'chi_(dprod_Iirr (0, j)) = cfDprodr KxH 'chi_j.\nProof. by rewrite dprod_IirrE /cfDprod irr0 rmorph1 mul1r. Qed.",
    "Lemma dprod_Iirr_inj : injective dprod_Iirr.\nProof.\nmove=> [i1 j1] [i2 j2] /eqP; rewrite -[_ == _]oddb -(@natrK algC (_ == _)).\nrewrite -cfdot_irr !dprod_IirrE cfdot_dprod !cfdot_irr -natrM mulnb.\nby rewrite natrK oddb -xpair_eqE => /eqP.\nQed.",
    "Lemma dprod_Iirr0 : dprod_Iirr (0, 0) = 0.\nProof. by apply/irr_inj; rewrite dprod_IirrE !irr0 cfDprod_cfun1. Qed.",
    "Lemma dprod_Iirr0l j : dprod_Iirr (0, j) = dprodr_Iirr j.\nProof.\nby apply/irr_inj; rewrite dprod_IirrE irr0 dprodr_IirrE cfDprod_cfun1l.\nQed.",
    "Lemma dprod_Iirr0r i : dprod_Iirr (i, 0) = dprodl_Iirr i.\nProof.\nby apply/irr_inj; rewrite dprod_IirrE irr0 dprodl_IirrE cfDprod_cfun1r.\nQed.",
    "Lemma dprod_Iirr_eq0 i j : (dprod_Iirr (i, j) == 0) = (i == 0) && (j == 0).\nProof. by rewrite -xpair_eqE -(inj_eq dprod_Iirr_inj) dprod_Iirr0. Qed.",
    "Lemma cfdot_dprod_irr i1 i2 j1 j2 :\n  '['chi_(dprod_Iirr (i1, j1)), 'chi_(dprod_Iirr (i2, j2))]\n     = ((i1 == i2) && (j1 == j2))%:R.\nProof. by rewrite cfdot_irr (inj_eq dprod_Iirr_inj). Qed.",
    "Lemma dprod_Iirr_onto k : k \\in codom dprod_Iirr.\nProof.\nset D := codom _; have Df: dprod_Iirr _ \\in D := codom_f dprod_Iirr _.\nhave: 'chi_k 1%g ^+ 2 != 0 by rewrite mulf_neq0 ?irr1_neq0.\napply: contraR => notDk; move/eqP: (irr_sum_square G).\nrewrite (bigID [in D]) (reindex _ (bij_on_codom dprod_Iirr_inj (0, 0))) /=.\nhave ->: #|G|%:R = \\sum_i \\sum_j 'chi_(dprod_Iirr (i, j)) 1%g ^+ 2.\n  rewrite -(dprod_card KxH) natrM.\n  do 2![rewrite -irr_sum_square (mulr_suml, mulr_sumr); apply: eq_bigr => ? _].\n  by rewrite dprod_IirrE -exprMn -{3}(mulg1 1%g) cfDprodE.\nrewrite (eq_bigl _ _ Df) pair_bigA addrC -subr_eq0 addrK.\nby move/eqP/psumr_eq0P=> -> //= i _; rewrite irr1_degree -natrX ler0n.\nQed.",
    "Lemma dprod_IirrK : cancel dprod_Iirr inv_dprod_Iirr.\nProof. by move=> p; apply: (iinv_f dprod_Iirr_inj). Qed.",
    "Lemma inv_dprod_IirrK : cancel inv_dprod_Iirr dprod_Iirr.\nProof. by move=> i; apply: f_iinv. Qed.",
    "Lemma inv_dprod_Iirr0 : inv_dprod_Iirr 0 = (0, 0).\nProof. by apply/(canLR dprod_IirrK); rewrite dprod_Iirr0. Qed.",
    "Lemma dprod_IirrC (gT : finGroupType) (G K H : {group gT})\n                  (KxH : K \\x H = G) (HxK : H \\x K = G) i j :\n  dprod_Iirr KxH (i, j) = dprod_Iirr HxK (j, i).\nProof. by apply: irr_inj; rewrite !dprod_IirrE; apply: cfDprodC. Qed.",
    "Lemma cfBigdprodi_char i (phi : 'CF(A i)) :\n  phi \\is a character -> cfBigdprodi defG phi \\is a character.\nProof. by move=> Nphi; rewrite cfDprodl_char cfRes_char. Qed.",
    "Lemma cfBigdprodi_charE i (phi : 'CF(A i)) :\n  P i -> (cfBigdprodi defG phi \\is a character) = (phi \\is a character).\nProof. by move=> Pi; rewrite cfDprodl_char Pi cfRes_id. Qed.",
    "Lemma cfBigdprod_char phi :\n    (forall i, P i -> phi i \\is a character) ->\n  cfBigdprod defG phi \\is a character.\nProof.\nby move=> Nphi; apply: rpred_prod => i /Nphi; apply: cfBigdprodi_char.\nQed.",
    "Lemma cfBigdprodi_lin_char i (phi : 'CF(A i)) :\n  phi \\is a linear_char -> cfBigdprodi defG phi \\is a linear_char.\nProof. by move=> Lphi; rewrite cfDprodl_lin_char ?cfRes_lin_char. Qed.",
    "Lemma cfBigdprodi_lin_charE i (phi : 'CF(A i)) :\n  P i -> (cfBigdprodi defG phi \\is a linear_char) = (phi \\is a linear_char).\nProof. by move=> Pi; rewrite qualifE/= cfBigdprodi_charE // cfBigdprodi1. Qed.",
    "Lemma cfBigdprod_lin_char phi :\n    (forall i, P i -> phi i \\is a linear_char) ->\n  cfBigdprod defG phi \\is a linear_char.\nProof.\nby move=> Lphi; apply/rpred_prod=> i /Lphi; apply: cfBigdprodi_lin_char.\nQed.",
    "Lemma cfBigdprodi_irr i chi :\n  P i -> (cfBigdprodi defG chi \\in irr G) = (chi \\in irr (A i)).\nProof. by move=> Pi; rewrite !irrEchar cfBigdprodi_charE ?cfBigdprodi_iso. Qed.",
    "Lemma cfBigdprod_irr chi :\n  (forall i, P i -> chi i \\in irr (A i)) -> cfBigdprod defG chi \\in irr G.\nProof.\nmove=> Nchi; rewrite irrEchar cfBigdprod_char => [|i /Nchi/irrWchar] //=.\nby rewrite cfdot_bigdprod big1 // => i /Nchi/irrWnorm.\nQed.",
    "Lemma cfBigdprod_eq1 phi :\n    (forall i, P i -> phi i \\is a character) ->\n  (cfBigdprod defG phi == 1) = [forall (i | P i), phi i == 1].\nProof.\nmove=> Nphi; set Phi := cfBigdprod defG phi.\napply/eqP/eqfun_inP=> [Phi1 i Pi | phi1]; last first.\n  by apply: big1 => i /phi1->; rewrite rmorph1.\nhave Phi1_1: Phi 1%g = 1 by rewrite Phi1 cfun1E group1.\nhave nz_Phi1: Phi 1%g != 0 by rewrite Phi1_1 oner_eq0.\nhave [_ <-] := cfBigdprodK nz_Phi1 Pi.\nrewrite Phi1_1 divr1 -/Phi Phi1 rmorph1.\nrewrite prod_cfunE // in Phi1_1; have := natr_prod_eq1 _ Phi1_1 Pi.\nrewrite -(cfRes1 (A i)) cfBigdprodiK // => ->; first by rewrite scale1r.\nby move=> {i Pi} j /Nphi Nphi_j; rewrite Cnat_char1 ?cfBigdprodi_char.\nQed.",
    "Lemma cfBigdprod_Res_lin chi :\n  chi \\is a linear_char -> cfBigdprod defG (fun i => 'Res[A i] chi) = chi.\nProof.\nmove=> Lchi; apply/cfun_inP=> _ /(mem_bigdprod defG)[x [Ax -> _]].\nrewrite (lin_char_prod Lchi) ?cfBigdprodE // => [|i Pi]; last first.\n  by rewrite (subsetP (sAG Pi)) ?Ax.\nby apply/eq_bigr=> i Pi; rewrite cfResE ?sAG ?Ax.\nQed.",
    "Lemma cfBigdprodKlin phi :\n  (forall i, P i -> phi i \\is a linear_char) ->\n  forall i, P i -> 'Res (cfBigdprod defG phi) = phi i.\nProof.\nmove=> Lphi i Pi; have Lpsi := cfBigdprod_lin_char Lphi.\nhave [_ <-] := cfBigdprodK (lin_char_neq0 Lpsi (group1 G)) Pi.\nby rewrite !lin_char1 ?Lphi // divr1 scale1r.\nQed.",
    "Lemma cfBigdprodKabelian Iphi (phi := fun i => 'chi_(Iphi i)) :\n  abelian G -> forall i, P i -> 'Res (cfBigdprod defG phi) = 'chi_(Iphi i).\nProof.\nmove=> /(abelianS _) cGG.\nby apply: cfBigdprodKlin => i /sAG/cGG/char_abelianP->.\nQed.",
    "Lemma conjC_charAut u (chi : 'CF(G)) x :\n  chi \\is a character -> (u (chi x))^* = u (chi x)^*.\nProof.\nhave [Gx | /cfun0->] := boolP (x \\in G); last by rewrite !rmorph0.\ncase/char_reprP=> rG ->; have [e [_ [en1 _] [-> _] _]] := repr_rsim_diag rG Gx.\nby rewrite !rmorph_sum; apply: eq_bigr => i _; apply: aut_unity_rootC (en1 i).\nQed.",
    "Lemma conjC_irrAut u i x : (u ('chi[G]_i x))^* = u ('chi_i x)^*.\nProof. exact: conjC_charAut (irr_char i). Qed.",
    "Lemma cfdot_aut_char u (phi chi : 'CF(G)) :\n  chi \\is a character -> '[cfAut u phi, cfAut u chi] = u '[phi, chi].\nProof. by move/conjC_charAut=> Nchi; apply: cfdot_cfAut => _ /mapP[x _ ->]. Qed.",
    "Lemma cfdot_aut_irr u phi i :\n  '[cfAut u phi, cfAut u 'chi[G]_i] = u '[phi, 'chi_i].\nProof. exact: cfdot_aut_char (irr_char i). Qed.",
    "Lemma cfAut_irr u chi : (cfAut u chi \\in irr G) = (chi \\in irr G).\nProof.\nrewrite !irrEchar cfAut_char; apply/andb_id2l=> /cfdot_aut_char->.\nexact: fmorph_eq1.\nQed.",
    "Lemma cfConjC_irr i : (('chi_i)^*)%CF \\in irr G.\nProof. by rewrite cfAut_irr mem_irr. Qed.",
    "Lemma irr_aut_closed u : cfAut_closed u (irr G).\nProof. by move=> chi; rewrite /= cfAut_irr. Qed.",
    "Lemma aut_IirrE u i : 'chi_(aut_Iirr u i) = cfAut u 'chi_i.\nProof. by rewrite cfIirrE ?cfAut_irr ?mem_irr. Qed.",
    "Lemma conjC_IirrE i : 'chi[G]_(conjC_Iirr i) = ('chi_i)^*%CF.\nProof. exact: aut_IirrE. Qed.",
    "Lemma conjC_IirrK : involutive conjC_Iirr.\nProof. by move=> i; apply: irr_inj; rewrite !conjC_IirrE cfConjCK. Qed.",
    "Lemma aut_Iirr0 u : aut_Iirr u 0 = 0 :> Iirr G.\nProof. by apply/irr_inj; rewrite aut_IirrE irr0 cfAut_cfun1. Qed.",
    "Lemma conjC_Iirr0 : conjC_Iirr 0 = 0 :> Iirr G.\nProof. exact: aut_Iirr0. Qed.",
    "Lemma aut_Iirr_eq0 u i : (aut_Iirr u i == 0) = (i == 0).\nProof. by rewrite -!irr_eq1 aut_IirrE cfAut_eq1. Qed.",
    "Lemma conjC_Iirr_eq0 i : (conjC_Iirr i == 0 :> Iirr G) = (i == 0).\nProof. exact: aut_Iirr_eq0. Qed.",
    "Lemma aut_Iirr_inj u : injective (aut_Iirr u).\nProof.\nby move=> i j eq_ij; apply/irr_inj/(cfAut_inj u); rewrite -!aut_IirrE eq_ij.\nQed.",
    "Lemma cfQuo_char G H (chi : 'CF(G)) :\n  chi \\is a character -> (chi / H)%CF \\is a character.\nProof.\nmove=> Nchi; without loss kerH: / H \\subset cfker chi.\n  move/contraNF=> IHchi; apply/wlog_neg=> N'chiH.\n  suffices ->: (chi / H)%CF = (chi 1%g)%:A.\n    by rewrite rpredZ_nat ?Cnat_char1 ?rpred1.\n  by apply/cfunP=> x; rewrite cfunE cfun1E mulr_natr cfunElock IHchi.\nwithout loss nsHG: G chi Nchi kerH / H <| G.\n  move=> IHchi; have nsHN := normalSG (subset_trans kerH (cfker_sub chi)).\n  rewrite cfQuoInorm//; apply/cfRes_char/IHchi => //; first exact: cfRes_char. \n  by apply: sub_cfker_Res => //; apply: normal_sub.\nhave [rG Dchi] := char_reprP Nchi; rewrite Dchi cfker_repr in kerH.\napply/char_reprP; exists (Representation (quo_repr kerH (normal_norm nsHG))).\napply/cfun_inP=> _ /morphimP[x nHx Gx ->]; rewrite Dchi cfQuoE ?cfker_repr //=.\nby rewrite !cfunE Gx quo_repr_coset ?mem_quotient.\nQed.",
    "Lemma cfQuo_lin_char G H (chi : 'CF(G)) :\n  chi \\is a linear_char -> (chi / H)%CF \\is a linear_char.\nProof. by case/andP=> Nchi; rewrite qualifE/= cfQuo_char ?cfQuo1. Qed.",
    "Lemma cfMod_char G H (chi : 'CF(G / H)) :\n  chi \\is a character -> (chi %% H)%CF \\is a character.\nProof. exact: cfMorph_char. Qed.",
    "Lemma cfMod_lin_char G H (chi : 'CF(G / H)) :\n  chi \\is a linear_char -> (chi %% H)%CF \\is a linear_char.\nProof. exact: cfMorph_lin_char. Qed.",
    "Lemma cfMod_charE G H (chi : 'CF(G / H)) :\n  H <| G -> (chi %% H \\is a character)%CF = (chi \\is a character).\nProof. by case/andP=> _; apply: cfMorph_charE. Qed.",
    "Lemma cfMod_lin_charE G H (chi : 'CF(G / H)) :\n  H <| G -> (chi %% H \\is a linear_char)%CF = (chi \\is a linear_char).\nProof. by case/andP=> _; apply: cfMorph_lin_charE. Qed.",
    "Lemma cfQuo_charE G H (chi : 'CF(G)) :\n   H <| G -> H \\subset cfker chi ->\n (chi / H \\is a character)%CF = (chi \\is a character).\nProof. by move=> nsHG kerH; rewrite -cfMod_charE ?cfQuoK. Qed.",
    "Lemma cfQuo_lin_charE G H (chi : 'CF(G)) :\n   H <| G -> H \\subset cfker chi ->\n (chi / H \\is a linear_char)%CF = (chi \\is a linear_char).\nProof. by move=> nsHG kerH; rewrite -cfMod_lin_charE ?cfQuoK. Qed.",
    "Lemma cfMod_irr G H chi :\n  H <| G -> (chi %% H \\in irr G)%CF = (chi \\in irr (G / H)).\nProof. by case/andP=> _; apply: cfMorph_irr. Qed.",
    "Lemma mod_Iirr0 G H : mod_Iirr (0 : Iirr (G / H)) = 0.\nProof. exact: morph_Iirr0. Qed.",
    "Lemma mod_IirrE G H i : H <| G -> 'chi_(mod_Iirr i) = ('chi[G / H]_i %% H)%CF.\nProof. by move=> nsHG; rewrite cfIirrE ?cfMod_irr ?mem_irr. Qed.",
    "Lemma mod_Iirr_eq0 G H i :\n  H <| G -> (mod_Iirr i == 0) = (i == 0 :> Iirr (G / H)).\nProof. by case/andP=> _ /morph_Iirr_eq0->. Qed.",
    "Lemma cfQuo_irr G H chi :\n     H <| G -> H \\subset cfker chi ->\n  ((chi / H)%CF \\in irr (G / H)) = (chi \\in irr G).\nProof. by move=> nsHG kerH; rewrite -cfMod_irr ?cfQuoK. Qed.",
    "Lemma quo_Iirr0 G H : quo_Iirr H (0 : Iirr G) = 0.\nProof. by rewrite /quo_Iirr irr0 cfQuo_cfun1 -irr0 irrK. Qed.",
    "Lemma quo_IirrE G H i :\n  H <| G -> H \\subset cfker 'chi[G]_i -> 'chi_(quo_Iirr H i) = ('chi_i / H)%CF.\nProof. by move=> nsHG kerH; rewrite cfIirrE ?cfQuo_irr ?mem_irr. Qed.",
    "Lemma quo_Iirr_eq0 G H i :\n  H <| G -> H \\subset cfker 'chi[G]_i -> (quo_Iirr H i == 0) = (i == 0).\nProof. by move=> nsHG kerH; rewrite -!irr_eq1 quo_IirrE ?cfQuo_eq1. Qed.",
    "Lemma mod_IirrK G H : H <| G -> cancel (@mod_Iirr G H) (@quo_Iirr G H).\nProof.\nmove=> nsHG i; apply: irr_inj.\nby rewrite quo_IirrE ?mod_IirrE ?cfker_mod // cfModK.\nQed.",
    "Lemma quo_IirrK G H i :\n  H <| G -> H \\subset cfker 'chi[G]_i -> mod_Iirr (quo_Iirr H i) = i.\nProof.\nby move=> nsHG kerH; apply: irr_inj; rewrite mod_IirrE ?quo_IirrE ?cfQuoK.\nQed.",
    "Lemma quo_IirrKeq G H :\n    H <| G ->\n  forall i, (mod_Iirr (quo_Iirr H i) == i) = (H \\subset cfker 'chi[G]_i).\nProof.\nmove=> nsHG i; apply/eqP/idP=> [<- | ]; last exact: quo_IirrK.\nby rewrite mod_IirrE ?cfker_mod.\nQed.",
    "Lemma mod_Iirr_bij H G :\n  H <| G -> {on [pred i | H \\subset cfker 'chi_i], bijective (@mod_Iirr G H)}.\nProof.\nby exists (quo_Iirr H) => [i _ | i]; [apply: mod_IirrK | apply: quo_IirrK].\nQed.",
    "Lemma sum_norm_irr_quo H G x :\n    x \\in G ->  H <| G ->\n  \\sum_i `|'chi[G / H]_i (coset H x)| ^+ 2\n    = \\sum_(i | H \\subset cfker 'chi_i) `|'chi[G]_i x| ^+ 2.\nProof.\nmove=> Gx nsHG; rewrite (reindex _ (mod_Iirr_bij nsHG)) /=.\nby apply/esym/eq_big=> [i | i _]; rewrite mod_IirrE ?cfker_mod ?cfModE.\nQed.",
    "Lemma cap_cfker_normal G H :\n  H <| G -> \\bigcap_(i | H \\subset cfker 'chi[G]_i) (cfker 'chi_i) = H.\nProof.\nmove=> nsHG; have [sHG nHG] := andP nsHG; set lhs := \\bigcap_(i | _) _.\nhave nHlhs: lhs \\subset 'N(H) by rewrite (bigcap_min 0) ?cfker_irr0.\napply/esym/eqP; rewrite eqEsubset (introT bigcapsP) //= -quotient_sub1 //.\nrewrite -(TI_cfker_irr (G / H)); apply/bigcapsP=> i _.\nrewrite sub_quotient_pre // (bigcap_min (mod_Iirr i)) ?mod_IirrE ?cfker_mod //.\nby rewrite cfker_morph ?subsetIr.\nQed.",
    "Lemma cfker_reg_quo G H : H <| G -> cfker (cfReg (G / H)%g %% H) = H.\nProof.\nmove=> nsHG; have [sHG nHG] := andP nsHG.\napply/setP=> x; rewrite cfkerEchar ?cfMod_char ?cfReg_char //.\nrewrite -[in RHS in _ = RHS](setIidPr sHG) !inE; apply: andb_id2l => Gx.\nrewrite !cfModE // !cfRegE // morph1 eqxx.\nrewrite (sameP eqP (kerP _ (subsetP nHG x Gx))) ker_coset.\nby rewrite -!mulrnA eqr_nat eqn_pmul2l ?cardG_gt0 // (can_eq oddb) eqb_id.\nQed.",
    "Lemma lin_irr_der1 G i :\n   ('chi_i \\is a linear_char) = (G^`(1)%g \\subset cfker 'chi[G]_i).\nProof.\napply/idP/idP=> [|sG'K]; first exact: lin_char_der1.\nhave nsG'G: G^`(1) <| G := der_normal 1 G.\nrewrite qualifE/= irr_char -[i](quo_IirrK nsG'G) // mod_IirrE //=.\nby rewrite cfModE // morph1 lin_char1 //; apply/char_abelianP/der_abelian.\nQed.",
    "Lemma subGcfker G i : (G \\subset cfker 'chi[G]_i) = (i == 0).\nProof.\nrewrite -irr_eq1; apply/idP/eqP=> [chiG1 | ->]; last by rewrite cfker_cfun1.\napply/cfun_inP=> x Gx; rewrite cfun1E Gx cfker1 ?(subsetP chiG1) ?lin_char1 //.\nby rewrite lin_irr_der1 (subset_trans (der_sub 1 G)).\nQed.",
    "Lemma irr_prime_injP G i :\n  prime #|G| -> reflect {in G &, injective 'chi[G]_i} (i != 0).\nProof.\nmove=> pr_G; apply: (iffP idP) => [nz_i | inj_chi].\n  apply: fful_lin_char_inj (irr_prime_lin i pr_G) _.\n  by rewrite cfaithfulE -(setIidPr (cfker_sub _)) prime_TIg // subGcfker.\nhave /trivgPn[x Gx ntx]: G :!=: 1%g by rewrite -cardG_gt1 prime_gt1.\napply: contraNneq ntx => i0; apply/eqP/inj_chi=> //.\nby rewrite i0 irr0 !cfun1E Gx group1.\nQed.",
    "Lemma cap_cfker_lin_irr G :\n  \\bigcap_(i | 'chi[G]_i \\is a linear_char) (cfker 'chi_i) = G^`(1)%g.\nProof.\nrewrite -(cap_cfker_normal (der_normal 1 G)).\nby apply: eq_bigl => i; rewrite lin_irr_der1.\nQed.",
    "Lemma card_lin_irr G :\n  #|[pred i | 'chi[G]_i \\is a linear_char]| = #|G : G^`(1)%g|.\nProof.\nhave nsG'G := der_normal 1 G; rewrite (eq_card (@lin_irr_der1 G)).\nrewrite -(on_card_preimset (mod_Iirr_bij nsG'G)).\nrewrite -card_quotient ?normal_norm //.\nmove: (der_abelian 0 G); rewrite card_classes_abelian; move/eqP<-.\nrewrite -NirrE -[RHS]card_ord.\nby apply: eq_card => i; rewrite !inE mod_IirrE ?cfker_mod.\n\nQed.",
    "Lemma solvable_has_lin_char G :\n    G :!=: 1%g -> solvable G ->\n  exists2 i, 'chi[G]_i \\is a linear_char & 'chi_i != 1.\nProof.\nmove=> ntG solG.\nsuff /subsetPn[i]: ~~ ([pred i | 'chi[G]_i \\is a linear_char] \\subset pred1 0).\n  by rewrite !inE -(inj_eq irr_inj) irr0; exists i.\nrewrite (contra (@subset_leq_card _ _ _)) // -ltnNge card1 card_lin_irr.\nby rewrite indexg_gt1 proper_subn // (sol_der1_proper solG).\nQed.",
    "Lemma lin_char_group G :\n  {linG : finGroupType & {cF : linG -> 'CF(G) |\n         [/\\ injective cF, #|linG| = #|G : G^`(1)|,\n             forall u, cF u \\is a linear_char\n           & forall phi, phi \\is a linear_char -> exists u, phi = cF u]\n       & [/\\ cF 1%g = 1%R,\n             {morph cF : u v / (u * v)%g >-> (u * v)%R},\n             forall k, {morph cF : u / (u^+ k)%g >-> u ^+ k},\n             {morph cF: u / u^-1%g >-> u^-1%CF}\n           & {mono cF: u / #[u]%g >-> #[u]%CF} ]}}.\nProof.\npose linT := {i : Iirr G | 'chi_i \\is a linear_char}.\npose cF (u : linT) := 'chi_(sval u).\nhave cFlin u: cF u \\is a linear_char := svalP u.\nhave cFinj: injective cF := inj_comp irr_inj val_inj.\nhave inT xi : xi \\is a linear_char -> {u | cF u = xi}.\n  move=> lin_xi; have /irrP/sig_eqW[i Dxi] := lin_char_irr lin_xi.\n  by apply: (exist _ (Sub i _)) => //; rewrite -Dxi.\nhave [one cFone] := inT 1 (rpred1 _).\npose inv u := sval (inT _ (rpredVr (cFlin u))).\npose mul u v := sval (inT _ (rpredM (cFlin u) (cFlin v))).\nhave cFmul u v: cF (mul u v) = cF u * cF v := svalP (inT _ _).\nhave cFinv u: cF (inv u) = (cF u)^-1 := svalP (inT _ _).\nhave mulA: associative mul by move=> u v w; apply: cFinj; rewrite !cFmul mulrA.\nhave mul1: left_id one mul by move=> u; apply: cFinj; rewrite cFmul cFone mul1r.\nhave mulV: left_inverse one inv mul.\n  by move=> u; apply: cFinj; rewrite cFmul cFinv cFone mulVr ?lin_char_unitr.\npose imA := isMulGroup.Build linT mulA mul1 mulV.\npose linG : finGroupType := HB.pack linT imA.\nhave cFexp k: {morph cF : u / ((u : linG) ^+ k)%g >-> u ^+ k}.\n  by move=> u; elim: k => // k IHk; rewrite expgS exprS cFmul IHk.\ndo [exists linG, cF; split=> //] => [|xi /inT[u <-]|u]; first 2 [by exists u].\n  have inj_cFI: injective (cfIirr \\o cF).\n    apply: can_inj (insubd one) _ => u; apply: val_inj.\n    by rewrite insubdK /= ?irrK //; apply: cFlin.\n  rewrite -(card_image inj_cFI) -card_lin_irr.\n  apply/eq_card=> i /[1!inE]; apply/codomP/idP=> [[u ->] | /inT[u Du]].\n    by rewrite /= irrK; apply: cFlin.\n  by exists u; apply: irr_inj; rewrite /= irrK.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  by rewrite dvdn_cforder; rewrite -cFexp expg_order cFone.\nby rewrite order_dvdn -(inj_eq cFinj) cFone cFexp exp_cforder.\nQed.",
    "Lemma cfExp_prime_transitive G (i j : Iirr G) :\n    prime #|G| -> i != 0 -> j != 0 ->\n  exists2 k, coprime k #['chi_i]%CF & 'chi_j = 'chi_i ^+ k.\nProof.\nset p := #|G| => pr_p nz_i nz_j; have cycG := prime_cyclic pr_p.\nhave [L [h [injh oL Lh h_ontoL]] [h1 hM hX _ o_h]] := lin_char_group G.\nrewrite (derG1P (cyclic_abelian cycG)) indexg1 -/p in oL.\nhave /fin_all_exists[h' h'K] := h_ontoL _ (irr_cyclic_lin _ cycG).\nhave o_h' k: k != 0 -> #[h' k] = p.\n  rewrite -cforder_irr_eq1 h'K -o_h => nt_h'k.\n  by apply/prime_nt_dvdP=> //; rewrite cforder_lin_char_dvdG.\nhave{oL} genL k: k != 0 -> generator [set: L] (h' k).\n  move=> /o_h' o_h'k; rewrite /generator eq_sym eqEcard subsetT /=.\n  by rewrite cardsT oL -o_h'k.\nhave [/(_ =P <[_]>)-> gen_j] := (genL i nz_i, genL j nz_j).\nhave /cycleP[k Dj] := cycle_generator gen_j.\nby rewrite !h'K Dj o_h hX generator_coprime coprime_sym in gen_j *; exists k.\nQed.",
    "Lemma card_subcent1_coset G H x :\n  x \\in G -> H <| G -> (#|'C_(G / H)[coset H x]| <= #|'C_G[x]|)%N.\nProof.\nmove=> Gx nsHG; rewrite -leC_nat.\nmove: (second_orthogonality_relation x Gx); rewrite mulrb class_refl => <-.\nhave GHx: coset H x \\in (G / H)%g by apply: mem_quotient.\nmove: (second_orthogonality_relation (coset H x) GHx).\nrewrite mulrb class_refl => <-.\nrewrite -2!(eq_bigr _ (fun _ _ => normCK _)) sum_norm_irr_quo // -subr_ge0.\nrewrite (bigID (fun i => H \\subset cfker 'chi[G]_i)) //= addrC addKr.\nby apply: sumr_ge0 => i _; rewrite normCK mul_conjC_ge0.\nQed.",
    "Lemma detRepr_lin_char : detRepr \\is a linear_char.\nProof.\nby rewrite qualifE/= cfRepr_char cfunE group1 repr_mx1 mxtrace1 mulr1n /=.\nQed.",
    "Lemma cfDet_lin_char phi : cfDet phi \\is a linear_char.\nProof.\nrewrite unlock; apply: rpred_prod => i _; apply: rpredX.\nexact: detRepr_lin_char.\nQed.",
    "Lemma cfDetD :\n  {in character &, {morph cfDet : phi psi / phi + psi >-> phi * psi}}.\nProof.\nmove=> phi psi Nphi Npsi; rewrite unlock /= -big_split; apply: eq_bigr => i _ /=.\nby rewrite -exprD cfdotDl truncnD ?nnegrE ?natr_ge0 // Cnat_cfdot_char_irr.\nQed.",
    "Lemma cfDet0 : cfDet 0 = 1.\nProof. by rewrite unlock big1 // => i _; rewrite cfdot0l truncn0. Qed.",
    "Lemma cfDetMn k :\n  {in character, {morph cfDet : phi / phi *+ k >-> phi ^+ k}}.\nProof.\nmove=> phi Nphi; elim: k => [|k IHk]; rewrite ?cfDet0 // mulrS exprS -{}IHk.\nby rewrite cfDetD ?rpredMn.\nQed.",
    "Lemma cfDetRepr n rG : cfDet (cfRepr rG) = @detRepr _ _ n rG.\nProof.\ntransitivity (\\prod_W detRepr (socle_repr W) ^+ standard_irr_coef rG W).\n  rewrite (reindex _ (socle_of_Iirr_bij _)) unlock /=.\n  apply: eq_bigr => i _; congr (_ ^+ _).\n  rewrite (cfRepr_sim (mx_rsim_standard rG)) cfRepr_standard.\n  rewrite cfdot_suml (bigD1 i) ?big1 //= => [|j i'j]; last first.\n    by rewrite cfdotZl cfdot_irr (negPf i'j) mulr0.\n  by rewrite cfdotZl cfnorm_irr mulr1 addr0 natrK.\napply/cfun_inP=> x Gx; rewrite prod_cfunE //.\ntransitivity (detRepr (standard_grepr rG) x); last first.\n  rewrite !cfunE Gx !trace_mx11 !mxE eqxx !mulrb.\n  case: (standard_grepr rG) (mx_rsim_standard rG) => /= n1 rG1 [B Dn1].\n  rewrite -{n1}Dn1 in rG1 B *; rewrite row_free_unit => uB rG_B.\n  by rewrite -[rG x](mulmxK uB) rG_B // !det_mulmx mulrC -!det_mulmx mulKmx.\nrewrite /standard_grepr; elim/big_rec2: _ => [|W y _ _ ->].\n  by rewrite cfunE trace_mx11 mxE Gx det1.\nrewrite !cfunE Gx /= !{1}trace_mx11 !{1}mxE det_ublock; congr (_ * _).\nrewrite exp_cfunE //; elim: (standard_irr_coef rG W) => /= [|k IHk].\n  by rewrite /muln_grepr big_ord0 det1.\nrewrite exprS /muln_grepr big_ord_recl det_ublock -IHk; congr (_ * _).\nby rewrite cfunE trace_mx11 mxE Gx.\nQed.",
    "Lemma cfDet_id xi : xi \\is a linear_char -> cfDet xi = xi.\nProof.\nmove=> lin_xi; have /irrP[i Dxi] := lin_char_irr lin_xi.\napply/cfun_inP=> x Gx; rewrite Dxi -irrRepr cfDetRepr !cfunE trace_mx11 mxE.\nmove: lin_xi (_ x) => /andP[_]; rewrite Dxi irr1_degree pnatr_eq1 => /eqP-> X.\nby rewrite {1}[X]mx11_scalar det_scalar1 trace_mx11.\nQed.",
    "Lemma cfDetRes gT (G H : {group gT}) phi :\n  phi \\is a character -> cfDet ('Res[H, G] phi) = 'Res (cfDet phi).\nProof.\nmove=> Nphi; have [sGH | not_sHG] := boolP (H \\subset G); last first.\n  have /natrP[n Dphi1] := Cnat_char1 Nphi.\n  rewrite !cfResEout // Dphi1 lin_char1 ?cfDet_lin_char // scale1r.\n  by rewrite scaler_nat cfDetMn ?cfDet_id ?rpred1 // expr1n.\nhave [rG ->] := char_reprP Nphi; rewrite !(=^~ cfRepr_sub, cfDetRepr) //.\napply: cfRepr_sim; exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => x Hx.\nby rewrite mulmx1 mul1mx.\nQed.",
    "Lemma cfDetMorph aT rT (D G : {group aT}) (f : {morphism D >-> rT})\n                (phi : 'CF(f @* G)) :\n  phi \\is a character -> cfDet (cfMorph phi) = cfMorph (cfDet phi).\nProof.\nmove=> Nphi; have [sGD | not_sGD] := boolP (G \\subset D); last first.\n  have /natrP[n Dphi1] := Cnat_char1 Nphi.\n  rewrite !cfMorphEout // Dphi1 lin_char1 ?cfDet_lin_char // scale1r.\n  by rewrite scaler_nat cfDetMn ?cfDet_id ?rpred1 // expr1n.\nhave [rG ->] := char_reprP Nphi; rewrite !(=^~ cfRepr_morphim, cfDetRepr) //.\napply: cfRepr_sim; exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => x Hx.\nby rewrite mulmx1 mul1mx.\nQed.",
    "Lemma cfDetIsom aT rT (G : {group aT}) (R : {group rT})\n                (f : {morphism G >-> rT}) (isoGR : isom G R f) phi :\n  cfDet (cfIsom isoGR phi) = cfIsom isoGR (cfDet phi).\nProof.\nrewrite unlock rmorph_prod (reindex (isom_Iirr isoGR)); last first.\n  by exists (isom_Iirr (isom_sym isoGR)) => i; rewrite ?isom_IirrK ?isom_IirrKV.\napply: eq_bigr=> i; rewrite -!cfDetRepr !irrRepr isom_IirrE rmorphXn cfIsom_iso.\nby rewrite /= ![in cfIsom _]unlock cfDetMorph ?cfRes_char ?cfDetRes ?irr_char.\nQed.",
    "Lemma cfDet_mul_lin gT (G : {group gT}) (lambda phi : 'CF(G)) :\n    lambda \\is a linear_char -> phi \\is a character ->\n  cfDet (lambda * phi) = lambda ^+ Num.truncn (phi 1%g) * cfDet phi.\nProof.\ncase/andP=> /char_reprP[[n1 rG1] ->] /= n1_1 /char_reprP[[n2 rG2] ->] /=.\ndo [rewrite !cfRepr1 pnatr_eq1 natrK; move/eqP] in n1_1 *.\nrewrite {n1}n1_1 in rG1 *; rewrite cfRepr_prod cfDetRepr.\napply/cfun_inP=> x Gx; rewrite !cfunE cfDetRepr cfunE Gx !mulrb !trace_mx11.\nrewrite !mxE prod_repr_lin ?mulrb //=; case: _ / (esym _); rewrite detZ.\ncongr (_ * _); case: {rG2}n2 => [|n2]; first by rewrite cfun1E Gx.\nby rewrite expS_cfunE //= cfunE Gx trace_mx11.\nQed.",
    "Lemma cfcenter_repr n (rG : mx_representation algC G n) :\n  'Z(cfRepr rG)%CF = rcenter rG.\nProof.\nrewrite /cfcenter /rcenter cfRepr_char /=.\napply/setP=> x /[!inE]; apply/andb_id2l=> Gx.\napply/eqP/is_scalar_mxP=> [|[c rG_c]].\n  by case/max_cfRepr_norm_scalar=> // c; exists c.\nrewrite -(sqrCK (char1_ge0 (cfRepr_char rG))) normC_def; congr (sqrtC _).\nrewrite expr2 -{2}(mulgV x) -char_inv ?cfRepr_char ?cfunE ?groupM ?groupV //.\nrewrite Gx group1 repr_mx1 repr_mxM ?repr_mxV ?groupV // !mulrb rG_c.\nby rewrite invmx_scalar -scalar_mxM !mxtrace_scalar mulrnAr mulrnAl mulr_natl.\nQed.",
    "Lemma char_cfcenterE chi x :\n    chi \\is a character -> x \\in G ->\n  (x \\in ('Z(chi))%CF) = (`|chi x| == chi 1%g).\nProof. by move=> Nchi Gx; rewrite /cfcenter Nchi inE Gx. Qed.",
    "Lemma irr_cfcenterE i x :\n  x \\in G -> (x \\in 'Z('chi[G]_i)%CF) = (`|'chi_i x| == 'chi_i 1%g).\nProof. by move/char_cfcenterE->; rewrite ?irr_char. Qed.",
    "Lemma cfcenter_sub phi : ('Z(phi))%CF \\subset G.\nProof. by rewrite /cfcenter /cfker !setIdE -fun_if subsetIl. Qed.",
    "Lemma cfker_center_normal phi : cfker phi <| 'Z(phi)%CF.\nProof.\napply: normalS (cfcenter_sub phi) (cfker_normal phi).\nrewrite /= /cfcenter; case: ifP => // Hphi; rewrite cfkerEchar //.\napply/subsetP=> x /[!inE] /andP[-> /eqP->] /=.\nby rewrite ger0_norm ?char1_ge0.\nQed.",
    "Lemma cfcenter_normal phi : 'Z(phi)%CF <| G.\nProof.\nhave [[rG ->] | /negbTE notNphi] := altP (@char_reprP _ _ phi).\n  by rewrite cfcenter_repr rcenter_normal.\nby rewrite /cfcenter notNphi cfker_normal.\nQed.",
    "Lemma cfcenter_Res chi :\n  exists2 chi1, chi1 \\is a linear_char & 'Res['Z(chi)%CF] chi = chi 1%g *: chi1.\nProof.\nhave [[rG ->] | /negbTE notNphi] := altP (@char_reprP _ _ chi); last first.\n  exists 1; first exact: cfun1_lin_char.\n  rewrite /cfcenter notNphi; apply/cfun_inP=> x Kx.\n  by rewrite cfunE cfun1E Kx mulr1 cfResE ?cfker_sub // cfker1.\nrewrite cfcenter_repr -(cfRepr_sub _ (normal_sub (rcenter_normal _))).\ncase: rG => [[|n] rG] /=; rewrite cfRepr1.\n  exists 1; first exact: cfun1_lin_char.\n  by apply/cfun_inP=> x Zx; rewrite scale0r !cfunE flatmx0 raddf0 Zx.\npose rZmx x := ((rG x 0 0)%:M : 'M_(1,1)).\nhave rZmxP: mx_repr [group of rcenter rG] rZmx.\n  split=> [|x y]; first by rewrite /rZmx repr_mx1 mxE eqxx.\n  move=> /setIdP[Gx /is_scalar_mxP[a rGx]] /setIdP[Gy /is_scalar_mxP[b rGy]].\n  by rewrite /rZmx repr_mxM // rGx rGy -!scalar_mxM !mxE.\nexists (cfRepr (MxRepresentation rZmxP)).\n  by rewrite qualifE/= cfRepr_char cfRepr1 eqxx.\napply/cfun_inP=> x Zx; rewrite !cfunE Zx /= /rZmx mulr_natl.\nby case/setIdP: Zx => Gx /is_scalar_mxP[a ->]; rewrite mxE !mxtrace_scalar.\nQed.",
    "Lemma cfcenter_cyclic chi : cyclic ('Z(chi)%CF / cfker chi)%g.\nProof.\ncase Nchi: (chi \\is a character); last first.\n  by rewrite /cfcenter Nchi trivg_quotient cyclic1.\nhave [-> | nz_chi] := eqVneq chi 0.\n  rewrite quotientS1 ?cyclic1 //= /cfcenter cfkerEchar ?cfun0_char //.\n  by apply/subsetP=> x /setIdP[Gx _]; rewrite inE Gx /= !cfunE.\nhave [xi Lxi def_chi] := cfcenter_Res chi.\nset Z := ('Z(_))%CF in xi Lxi def_chi *.\nhave sZG: Z \\subset G by apply: cfcenter_sub.\nhave ->: cfker chi = cfker xi.\n  rewrite -(setIidPr (normal_sub (cfker_center_normal _))) -/Z.\n  rewrite !cfkerEchar // ?lin_charW //= -/Z.\n  apply/setP=> x /[!inE]; apply: andb_id2l => Zx.\n  rewrite (subsetP sZG) //= -!(cfResE chi sZG) ?group1 // def_chi !cfunE.\n  by rewrite (inj_eq (mulfI _)) ?char1_eq0.\nhave: abelian (Z / cfker xi) by rewrite sub_der1_abelian ?lin_char_der1.\nhave /irr_reprP[rG irrG ->] := lin_char_irr Lxi; rewrite cfker_repr.\napply: mx_faithful_irr_abelian_cyclic (kquo_mx_faithful rG) _.\nexact/quo_mx_irr.\nQed.",
    "Lemma cfcenter_subset_center chi :\n  ('Z(chi)%CF / cfker chi)%g \\subset 'Z(G / cfker chi)%g.\nProof.\ncase Nchi: (chi \\is a character); last first.\n  by rewrite /cfcenter Nchi trivg_quotient sub1G.\nrewrite subsetI quotientS ?cfcenter_sub // quotient_cents2r //=.\ncase/char_reprP: Nchi => rG ->{chi}; rewrite cfker_repr cfcenter_repr gen_subG.\napply/subsetP=> _ /imset2P[x y /setIdP[Gx /is_scalar_mxP[c rGx]] Gy ->].\nrewrite inE groupR //= !repr_mxM ?groupM ?groupV // rGx -(scalar_mxC c) -rGx.\nby rewrite !mulmxA !repr_mxKV.\nQed.",
    "Lemma cfcenter_eq_center (i : Iirr G) :\n  ('Z('chi_i)%CF / cfker 'chi_i)%g = 'Z(G / cfker 'chi_i)%g.\nProof.\napply/eqP; rewrite eqEsubset; rewrite cfcenter_subset_center ?irr_char //.\napply/subsetP=> _ /setIP[/morphimP[x /= _ Gx ->] cGx]; rewrite mem_quotient //=.\nrewrite -irrRepr cfker_repr cfcenter_repr inE Gx in cGx *.\napply: mx_abs_irr_cent_scalar 'Chi_i _ _ _; first exact/groupC/socle_irr.\nhave nKG: G \\subset 'N(rker 'Chi_i) by apply: rker_norm.\n\napply/centgmxP=> y Gy; rewrite [eq]lock -2?(quo_repr_coset (subxx _) nKG) //.\nmove: (quo_repr _ _) => rG; rewrite -2?repr_mxM ?mem_quotient // -lock.\nby rewrite (centP cGx) // mem_quotient.\nQed.",
    "Lemma cap_cfcenter_irr : \\bigcap_i 'Z('chi[G]_i)%CF = 'Z(G).\nProof.\napply/esym/eqP; rewrite eqEsubset (introT bigcapsP) /= => [|i _]; last first.\n  rewrite -(quotientSGK _ (normal_sub (cfker_center_normal _))).\n    by rewrite cfcenter_eq_center morphim_center.\n  by rewrite subIset // normal_norm // cfker_normal.\nset Z := \\bigcap_i _.\nhave sZG: Z \\subset G by rewrite (bigcap_min 0) ?cfcenter_sub.\nrewrite subsetI sZG (sameP commG1P trivgP) -(TI_cfker_irr G).\napply/bigcapsP=> i _; have nKiG := normal_norm (cfker_normal 'chi_i).\nrewrite -quotient_cents2 ?(subset_trans sZG) //.\nrewrite (subset_trans (quotientS _ (bigcap_inf i _))) //.\nby rewrite cfcenter_eq_center subsetIr.\nQed.",
    "Lemma cfnorm_Res_leif H phi :\n    H \\subset G ->\n  '['Res[H] phi] <= #|G : H|%:R * '[phi] ?= iff (phi \\in 'CF(G, H)).\nProof.\nmove=> sHG; rewrite cfun_onE mulrCA natf_indexg // -mulrA mulKf ?neq0CG //.\nrewrite (big_setID H) (setIidPr sHG) /= addrC.\nrewrite (mono_leif (ler_pM2l _)) ?invr_gt0 ?gt0CG // -leifBLR -sumrB.\nrewrite big1 => [|x Hx]; last by rewrite !cfResE ?subrr.\nhave ->: (support phi \\subset H) = (G :\\: H \\subset [set x | phi x == 0]).\n  rewrite subDset setUC -subDset; apply: eq_subset => x.\n  by rewrite !inE (andb_idr (contraR _)) // => /cfun0->.\nrewrite (sameP subsetP forall_inP); apply: leif_0_sum => x _.\nby rewrite !inE /<?=%R mul_conjC_ge0 eq_sym mul_conjC_eq0.\nQed.",
    "Lemma irr1_bound (i : Iirr G) :\n  ('chi_i 1%g) ^+ 2 <= #|G : 'Z('chi_i)%CF|%:R\n                    ?= iff ('chi_i \\in 'CF(G, 'Z('chi_i)%CF)).\nProof.\ncongr (_ <= _ ?= iff _): (cfnorm_Res_leif 'chi_i (cfcenter_sub 'chi_i)).\n  have [xi Lxi ->] := cfcenter_Res 'chi_i.\n  have /irrP[j ->] := lin_char_irr Lxi; rewrite cfdotZl cfdotZr cfdot_irr eqxx.\n  by rewrite mulr1 irr1_degree conjC_nat.\nby rewrite cfdot_irr eqxx mulr1.\nQed.",
    "Lemma irr1_abelian_bound (i : Iirr G) :\n  abelian (G / 'Z('chi_i)%CF) -> ('chi_i 1%g) ^+ 2 = #|G : 'Z('chi_i)%CF|%:R.\nProof.\nmove=> AbGc; apply/eqP; rewrite irr1_bound cfun_onE; apply/subsetP=> x nz_chi_x.\nhave Gx: x \\in G by apply: contraR nz_chi_x => /cfun0->.\nhave nKx := subsetP (normal_norm (cfker_normal 'chi_i)) _ Gx.\nrewrite -(quotientGK (cfker_center_normal _)) inE nKx inE /=.\nrewrite cfcenter_eq_center inE mem_quotient //=.\napply/centP=> _ /morphimP[y nKy Gy ->]; apply/commgP; rewrite -morphR //=.\nset z := [~ x, y]; rewrite coset_id //.\nhave: z \\in 'Z('chi_i)%CF.\n  apply: subsetP (mem_commg Gx Gy).\n  by rewrite der1_min // normal_norm ?cfcenter_normal.\nrewrite -irrRepr cfker_repr cfcenter_repr !inE in nz_chi_x *.\ncase/andP=> Gz /is_scalar_mxP[c Chi_z]; rewrite Gz Chi_z mul1mx /=.\napply/eqP; congr _%:M; apply: (mulIf nz_chi_x); rewrite mul1r.\nrewrite -{2}(cfunJ _ x Gy) conjg_mulR -/z !cfunE Gx groupM // !{1}mulrb.\nby rewrite repr_mxM // Chi_z mul_mx_scalar mxtraceZ.\nQed.",
    "Lemma irr_faithful_center i : cfaithful 'chi[G]_i -> cyclic 'Z(G).\nProof.\nrewrite (isog_cyclic (isog_center (quotient1_isog G))) /=.\nby move/trivgP <-; rewrite -cfcenter_eq_center cfcenter_cyclic.\nQed.",
    "Lemma cfcenter_fful_irr i : cfaithful 'chi[G]_i -> 'Z('chi_i)%CF = 'Z(G).\nProof.\nmove/trivgP=> Ki1; have:= cfcenter_eq_center i; rewrite {}Ki1.\nhave inj1: 'injm (@coset gT 1%g) by rewrite ker_coset.\nby rewrite -injm_center; first apply: injm_morphim_inj; rewrite ?norms1.\nQed.",
    "Lemma pgroup_cyclic_faithful (p : nat) :\n  p.-group G -> cyclic 'Z(G) -> exists i, cfaithful 'chi[G]_i.\nProof.\npose Z := 'Ohm_1('Z(G)) => pG cycZG; have nilG := pgroup_nil pG.\nhave [-> | ntG] := eqsVneq G [1]; first by exists 0; apply: cfker_sub.\nhave{pG} [[p_pr _ _] pZ] := (pgroup_pdiv pG ntG, pgroupS (center_sub G) pG).\nhave ntZ: 'Z(G) != [1] by rewrite center_nil_eq1.\nhave{pZ} oZ: #|Z| = p by apply: Ohm1_cyclic_pgroup_prime.\napply/existsP; apply: contraR ntZ => /existsPn-not_ffulG.\nrewrite -Ohm1_eq1 -subG1 /= -/Z -(TI_cfker_irr G); apply/bigcapsP=> i _.\nrewrite prime_meetG ?oZ // setIC meet_Ohm1 // meet_center_nil ?cfker_normal //.\nby rewrite -subG1 not_ffulG.\nQed.",
    "Lemma cfInd_char chi : chi \\is a character -> 'Ind[G] chi \\is a character.\nProof.\nmove=> Nchi; apply/forallP=> i; rewrite coord_cfdot -Frobenius_reciprocity //.\nby rewrite Cnat_cfdot_char ?cfRes_char ?irr_char.\nQed.",
    "Lemma cfInd_eq0 chi :\n  H \\subset G -> chi \\is a character -> ('Ind[G] chi == 0) = (chi == 0).\nProof.\nmove=> sHG Nchi; rewrite -!(char1_eq0) ?cfInd_char // cfInd1 //.\nby rewrite (mulrI_eq0 _ (mulfI _)) ?neq0CiG.\nQed.",
    "Lemma Ind_irr_neq0 i : H \\subset G -> 'Ind[G, H] 'chi_i != 0.\nProof. by move/cfInd_eq0->; rewrite ?irr_neq0 ?irr_char. Qed.",
    "Lemma constt_cfRes_irr i : {j | j \\in irr_constt ('Res[H, G] 'chi_i)}.\nProof. apply/sigW/neq0_has_constt/Res_irr_neq0. Qed.",
    "Lemma constt_cfInd_irr i :\n  H \\subset G -> {j | j \\in irr_constt ('Ind[G, H] 'chi_i)}.\nProof. by move=> sHG; apply/sigW/neq0_has_constt/Ind_irr_neq0. Qed.",
    "Lemma cfker_Res phi :\n  H \\subset G -> phi \\is a character -> cfker ('Res[H] phi) = H :&: cfker phi.\nProof.\nmove=> sHG Nphi; apply/setP=> x; rewrite !cfkerEchar ?cfRes_char // !inE.\nby apply/andb_id2l=> Hx; rewrite (subsetP sHG) ?cfResE.\nQed.",
    "Lemma cfker_Ind chi :\n    H \\subset G -> chi \\is a character -> chi != 0 ->\n  cfker ('Ind[G, H] chi) = gcore (cfker chi) G.\nProof.\nmove=> sHG Nchi nzchi; rewrite !cfker_nzcharE ?cfInd_char ?cfInd_eq0 //.\napply/setP=> x; rewrite inE cfIndE // (can2_eq (mulVKf _) (mulKf _)) ?neq0CG //.\nrewrite cfInd1 // mulrA -natrM Lagrange // mulr_natl -sumr_const.\napply/eqP/bigcapP=> [/normC_sum_upper ker_chiG_x y Gy | ker_chiG_x].\n  by rewrite mem_conjg inE ker_chiG_x ?groupV // => z _; apply: char1_ge_norm.\nby apply: eq_bigr => y /groupVr/ker_chiG_x; rewrite mem_conjgV inE => /eqP.\nQed.",
    "Lemma cfker_Ind_irr i :\n  H \\subset G -> cfker ('Ind[G, H] 'chi_i) = gcore (cfker 'chi_i) G.\nProof. by move/cfker_Ind->; rewrite ?irr_neq0 ?irr_char. Qed.",
    "Lemma mx_repr_actE u x : x \\in G -> mx_repr_act u x = u *m rG x.\nProof. by move=> Gx; rewrite /mx_repr_act /= subgK. Qed.",
    "Lemma scale_actE A a : scale_act A a = val a *: A. Proof. by []. Qed.",
    "Lemma astab1_scale_act A : A != 0 -> 'C[A | scale_action] = 1%g.\nProof.\nrewrite -mxrank_eq0=> nzA; apply/trivgP/subsetP=> a; apply: contraLR.\nrewrite !inE -val_eqE -subr_eq0 sub1set !inE => nz_a1.\nby rewrite -subr_eq0 -scaleN1r -scalerDl -mxrank_eq0 eqmx_scale.\nQed.",
    "Lemma mem_rowg m A v : (v \\in @rowg m A) = (v <= A)%MS.\nProof. by rewrite inE. Qed.",
    "Lemma rowg_stable m (A : 'M_(m, n)) : [acts setT, on rowg A | 'Zm].\nProof. by apply/actsP=> a _ v; rewrite !inE eqmx_scale // -unitfE (valP a). Qed.",
    "Lemma rowgS m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (rowg A \\subset rowg B) = (A <= B)%MS.\nProof.\napply/subsetP/idP=> sAB => [|u /[!inE] suA]; last exact: submx_trans sAB.\nby apply/row_subP=> i; have /[!(inE, row_sub)]-> := sAB (row i A).\nQed.",
    "Lemma eq_rowg m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B)%MS -> rowg A = rowg B.\nProof. by move=> eqAB; apply/eqP; rewrite eqEsubset !rowgS !eqAB andbb. Qed.",
    "Lemma rowg0 m : rowg (0 : 'M_(m, n)) = 1%g.\nProof. by apply/trivgP/subsetP=> v; rewrite !inE eqmx0 submx0. Qed.",
    "Lemma rowg1 : rowg 1%:M = setT.\nProof. by apply/setP=> x; rewrite !inE submx1. Qed.",
    "Lemma trivg_rowg m (A : 'M_(m, n)) : (rowg A == 1%g) = (A == 0).\nProof. by rewrite -submx0 -rowgS rowg0 (sameP trivgP eqP). Qed.",
    "Lemma rowgK m (A : 'M_(m, n)) : (rowg_mx (rowg A) :=: A)%MS.\nProof.\napply/eqmxP; rewrite !genmxE; apply/andP; split.\n  by apply/row_subP=> i; rewrite rowK; have /[!inE] := enum_valP i.\napply/row_subP=> i; set v := row i A.\nhave Av: v \\in rowg A by rewrite inE row_sub.\nby rewrite (eq_row_sub (enum_rank_in Av v)) // rowK enum_rankK_in.\nQed.",
    "Lemma rowg_mxS (L M : {set 'rV[F]_n}) :\n  L \\subset M -> (rowg_mx L <= rowg_mx M)%MS.\nProof.\nmove/subsetP=> sLM; rewrite !genmxE; apply/row_subP=> i.\nrewrite rowK; move: (enum_val i) (sLM _ (enum_valP i)) => v Mv.\nby rewrite (eq_row_sub (enum_rank_in Mv v)) // rowK enum_rankK_in.\nQed.",
    "Lemma sub_rowg_mx (L : {set rVn}) : L \\subset rowg (rowg_mx L).\nProof.\napply/subsetP=> v Lv; rewrite inE genmxE.\nby rewrite (eq_row_sub (enum_rank_in Lv v)) // rowK enum_rankK_in.\nQed.",
    "Lemma stable_rowg_mxK (L : {group rVn}) :\n  [acts setT, on L | 'Zm] -> rowg (rowg_mx L) = L.\nProof.\nmove=> linL; apply/eqP; rewrite eqEsubset sub_rowg_mx andbT.\napply/subsetP=> v; rewrite inE genmxE => /submxP[u ->{v}].\nrewrite mulmx_sum_row group_prod // => i _.\nrewrite rowK; move: (enum_val i) (enum_valP i) => v Lv.\nhave [->|] := eqVneq (u 0 i) 0; first by rewrite scale0r group1.\nby rewrite -unitfE => aP; rewrite ((actsP linL) (FinRing.Unit aP)) ?inE.\nQed.",
    "Lemma rowg_mx1 : rowg_mx 1%g = 0.\nProof. by apply/eqP; rewrite -submx0 -(rowg0 0) rowgK sub0mx. Qed.",
    "Lemma rowg_mx_eq0 (L : {group rVn}) : (rowg_mx L == 0) = (L :==: 1%g).\nProof.\nrewrite -trivg_rowg; apply/idP/eqP=> [|->]; last by rewrite rowg_mx1 rowg0.\nexact/contraTeq/subG1_contra/sub_rowg_mx.\nQed.",
    "Lemma rowgI m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  rowg (A :&: B)%MS = rowg A :&: rowg B.\nProof. by apply/setP=> u; rewrite !inE sub_capmx. Qed.",
    "Lemma card_rowg m (A : 'M_(m, n)) : #|rowg A| = (#|F| ^ \\rank A)%N.\nProof.\nrewrite -[\\rank A]mul1n -card_mx.\nhave injA: injective (mulmxr (row_base A)).\n  have /row_freeP[A' A'K] := row_base_free A.\n  by move=> ?; apply: can_inj (mulmxr A') _ => u; rewrite /= -mulmxA A'K mulmx1.\nrewrite -(card_image (injA _)); apply: eq_card => v.\nby rewrite inE -(eq_row_base A) (sameP submxP codomP).\nQed.",
    "Lemma rowgD m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  rowg (A + B)%MS = (rowg A * rowg B)%g.\nProof.\napply/eqP; rewrite eq_sym eqEcard mulG_subG /= !rowgS.\nrewrite addsmxSl addsmxSr -(@leq_pmul2r #|rowg A :&: rowg B|) ?cardG_gt0 //=.\nby rewrite -mul_cardG -rowgI !card_rowg -!expnD mxrank_sum_cap.\nQed.",
    "Lemma cprod_rowg m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (rowg A \\* rowg B)%g = rowg (A + B)%MS.\nProof. by rewrite rowgD cprodE // (sub_abelian_cent2 (zmod_abelian setT)). Qed.",
    "Lemma dprod_rowg  m1 m2 (A : 'M[F]_(m1, n)) (B : 'M[F]_(m2, n)) :\n  mxdirect (A + B) -> rowg A \\x rowg B = rowg (A + B)%MS.\nProof.\nrewrite (sameP mxdirect_addsP eqP) -trivg_rowg rowgI => /eqP tiAB.\nby rewrite -cprod_rowg dprodEcp.\nQed.",
    "Lemma bigcprod_rowg m I r (P : pred I) (A : I -> 'M[F]_n) (B : 'M[F]_(m, n)) :\n    (\\sum_(i <- r | P i) A i :=: B)%MS ->\n  \\big[cprod/1%g]_(i <- r | P i) rowg (A i) = rowg B.\nProof.\nby move/eq_rowg <-; apply/esym/big_morph=> [? ?|]; rewrite (rowg0, cprod_rowg).\nQed.",
    "Lemma bigdprod_rowg m (I : finType) (P : pred I) A (B : 'M[F]_(m, n)) :\n    let S := (\\sum_(i | P i) A i)%MS in (S :=: B)%MS -> mxdirect S ->\n  \\big[dprod/1%g]_(i | P i) rowg (A i) = rowg B.\nProof.\nmove=> S defS; rewrite mxdirectE defS /= => /eqP rankB.\napply: bigcprod_card_dprod (bigcprod_rowg defS) (eq_leq _).\nby rewrite card_rowg rankB expn_sum; apply: eq_bigr => i; rewrite card_rowg.\nQed.",
    "Lemma GLmx_faithful : mx_faithful GLrepr.\nProof. by apply/subsetP=> A; rewrite !inE mul1mx. Qed.",
    "Lemma val_reprGLm x : x \\in G -> val (reprGLm x) = rG x.\nProof. by move=> Gx; rewrite val_insubd (repr_mx_unitr rG). Qed.",
    "Lemma comp_reprGLm : {in G, GLval \\o reprGLm =1 rG}.\nProof. exact: val_reprGLm. Qed.",
    "Lemma reprGLmM : {in G &, {morph reprGLm : x y / x * y}}%g.\nProof.\nby move=> x y Gx Gy; apply: val_inj; rewrite /= !val_reprGLm ?groupM ?repr_mxM.\nQed.",
    "Lemma ker_reprGLm : 'ker reprGLm = rker rG.\nProof.\napply/setP=> x; rewrite !inE mul1mx; apply: andb_id2l => Gx.\nby rewrite -val_eqE val_reprGLm.\nQed.",
    "Lemma astab_rowg_repr m (A : 'M_(m, n)) : 'C(rowg A | 'MR rG) = rstab rG A.\nProof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx.\napply/subsetP/eqP=> cAx => [|u]; last first.\n  by rewrite !inE mx_repr_actE // => /submxP[u' ->]; rewrite -mulmxA cAx.\napply/row_matrixP=> i; apply/eqP; move/implyP: (cAx (row i A)).\nby rewrite !inE row_sub mx_repr_actE //= row_mul.\nQed.",
    "Lemma astabs_rowg_repr m (A : 'M_(m, n)) : 'N(rowg A | 'MR rG) = rstabs rG A.\nProof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx.\napply/subsetP/idP=> nAx => [|u]; last first.\n  by rewrite !inE mx_repr_actE // => Au; apply: (submx_trans (submxMr _ Au)).\napply/row_subP=> i; move/implyP: (nAx (row i A)).\nby rewrite !inE row_sub mx_repr_actE //= row_mul.\nQed.",
    "Lemma acts_rowg (A : 'M_n) : [acts G, on rowg A | 'MR rG] = mxmodule rG A.\nProof. by rewrite astabs_rowg_repr. Qed.",
    "Lemma astab_setT_repr : 'C(setT | 'MR rG) = rker rG.\nProof. by rewrite -rowg1 astab_rowg_repr. Qed.",
    "Lemma mx_repr_action_faithful :\n  [faithful G, on setT | 'MR rG] = mx_faithful rG.\nProof.\nby rewrite /faithful astab_setT_repr (setIidPr _) // [rker _]setIdE subsetIl.\nQed.",
    "Lemma afix_repr (H : {set gT}) :\n  H \\subset G -> 'Fix_('MR rG)(H) = rowg (rfix_mx rG H).\nProof.\nmove/subsetP=> sHG; apply/setP=> /= u; rewrite !inE.\napply/subsetP/rfix_mxP=> cHu x Hx; have:= cHu x Hx;\n  by rewrite !inE /= => /eqP; rewrite mx_repr_actE ?sHG.\nQed.",
    "Lemma gacent_repr (H : {set gT}) :\n  H \\subset G -> 'C_(| 'MR rG)(H) = rowg (rfix_mx rG H).\nProof. by move=> sHG; rewrite gacentE // setTI afix_repr. Qed.",
    "Lemma exponent_mx_group m n q :\n  m > 0 -> n > 0 -> q > 1 -> exponent [set: 'M['Z_q]_(m, n)] = q.\nProof.\nmove=> m_gt0 n_gt0 q_gt1; apply/eqP; rewrite eqn_dvd; apply/andP; split.\n  apply/exponentP=> x _; apply/matrixP=> i j; rewrite mulmxnE !mxE.\n  by rewrite -mulr_natr -Zp_nat_mod // modnn mulr0.\npose cmx1 := const_mx 1%R : 'M['Z_q]_(m, n).\napply: dvdn_trans (dvdn_exponent (in_setT cmx1)).\nhave/matrixP/(_ (Ordinal m_gt0))/(_ (Ordinal n_gt0))/eqP := expg_order cmx1.\nby rewrite mulmxnE !mxE -order_dvdn order_Zp1 Zp_cast.\nQed.",
    "Lemma rank_mx_group m n q : 'r([set: 'M['Z_q]_(m, n)]) = (m * n)%N.\nProof.\nwlog q_gt1: q / q > 1 by case: q => [|[|q -> //]] /(_ 2)->.\nset G := setT; have cGG: abelian G := zmod_abelian _.\nhave [mn0 | ] := posnP (m * n).\n  by rewrite [G](card1_trivg _) ?rank1 // cardsT card_mx mn0.\nrewrite muln_gt0 => /andP[m_gt0 n_gt0].\nhave expG: exponent G = q := exponent_mx_group m_gt0 n_gt0 q_gt1.\napply/eqP; rewrite eqn_leq andbC -(leq_exp2l _ _ q_gt1) -{2}expG.\nhave ->: (q ^ (m * n))%N = #|G| by rewrite cardsT card_mx card_ord Zp_cast.\nrewrite max_card_abelian //= -grank_abelian //= -/G.\npose B : {set 'M['Z_q]_(m, n)} := [set delta_mx ij.1 ij.2 | ij : 'I_m * 'I_n].\nsuffices ->: G = <<B>>.\n  have ->: (m * n)%N = #|{: 'I_m * 'I_n}| by rewrite card_prod !card_ord.\n  exact: leq_trans (grank_min _) (leq_imset_card _ _).\napply/setP=> v; rewrite inE (matrix_sum_delta v).\nrewrite group_prod // => i _; rewrite group_prod // => j _.\nrewrite -[v i j]natr_Zp scaler_nat groupX // mem_gen //.\nby apply/imsetP; exists (i, j).\nQed.",
    "Lemma mx_group_homocyclic m n q : homocyclic [set: 'M['Z_q]_(m, n)].\nProof.\nwlog q_gt1: q / q > 1 by case: q => [|[|q -> //]] /(_ 2)->.\nset G := setT; have cGG: abelian G := zmod_abelian _.\nrewrite -max_card_abelian //= rank_mx_group cardsT card_mx card_ord -/G.\nrewrite {1}Zp_cast //; have [-> // | ] := posnP (m * n).\nby rewrite muln_gt0 => /andP[m_gt0 n_gt0]; rewrite exponent_mx_group.\nQed.",
    "Lemma abelian_type_mx_group m n q :\n  q > 1 -> abelian_type [set: 'M['Z_q]_(m, n)] = nseq (m * n) q.\nProof.\nrewrite (abelian_type_homocyclic (mx_group_homocyclic m n q)) rank_mx_group.\nhave [-> // | ] := posnP (m * n); rewrite muln_gt0 => /andP[m_gt0 n_gt0] q_gt1.\nby rewrite exponent_mx_group.\nQed.",
    "Lemma mx_Fp_abelem : prime p -> p.-abelem [set: Mmn].\nProof. exact: fin_Fp_lmod_abelem. Qed.",
    "Lemma mx_Fp_stable (L : {group Mmn}) : [acts setT, on L | 'Zm].\nProof.\napply/subsetP=> a _ /[!inE]; apply/subsetP=> A L_A.\nby rewrite inE /= /scale_act -[val _]natr_Zp scaler_nat groupX.\nQed.",
    "Lemma rowg_mxK (L : {group rVn}) : rowg (rowg_mx L) = L.\nProof. by apply: stable_rowg_mxK; apply: mx_Fp_stable. Qed.",
    "Lemma rowg_mxSK (L : {set rVn}) (M : {group rVn}) :\n  (rowg_mx L <= rowg_mx M)%MS = (L \\subset M).\nProof.\napply/idP/idP; last exact: rowg_mxS.\nby rewrite -rowgS rowg_mxK; apply/subset_trans/sub_rowg_mx.\nQed.",
    "Lemma mxrank_rowg (L : {group rVn}) :\n  prime p -> \\rank (rowg_mx L) = logn p #|L|.\nProof.\nby move=> p_pr; rewrite -{2}(rowg_mxK L) card_rowg card_Fp ?pfactorK.\nQed.",
    "Lemma dim_abelemE : n = logn p #|E|.\nProof.\nrewrite /n'; have [_ _ [k ->]] :=  pgroup_pdiv pE ntE.\nby rewrite /pdiv primesX ?primes_prime // pfactorK.\nQed.",
    "Lemma card_abelem_rV : #|rVn| = #|E|.\nProof.\nby rewrite dim_abelemE card_mx mul1n card_Fp // -p_part part_pnat_id.\nQed.",
    "Lemma isog_abelem_rV : E \\isog [set: rVn].\nProof.\nby rewrite (isog_abelem_card _ abelE) cardsT card_abelem_rV mx_Fp_abelem /=.\nQed.",
    "Lemma abelem_rV_M : {in E &, {morph ErV : x y / (x * y)%g >-> x + y}}.\nProof. by case/misomP: (xchooseP ab_rV_P) => fM _; move/morphicP: fM. Qed.",
    "Lemma abelem_rV_isom : isom E setT ErV.\nProof. by case/misomP: (xchooseP ab_rV_P). Qed.",
    "Lemma abelem_rV_injm : 'injm ErV. Proof. by case/isomP: abelem_rV_isom. Qed.",
    "Lemma abelem_rV_inj : {in E &, injective ErV}.\nProof. by apply/injmP; apply: abelem_rV_injm. Qed.",
    "Lemma im_abelem_rV : ErV @* E = setT. Proof. by case/isomP: abelem_rV_isom. Qed.",
    "Lemma mem_im_abelem_rV u : u \\in ErV @* E.\nProof. by rewrite im_abelem_rV inE. Qed.",
    "Lemma sub_im_abelem_rV mA : subset mA (mem (ErV @* E)).\nProof. by rewrite unlock; apply/pred0P=> v /=; rewrite mem_im_abelem_rV. Qed.",
    "Lemma abelem_rV_1 : ErV 1 = 0%R. Proof. by rewrite morph1. Qed.",
    "Lemma abelem_rV_X x i : x \\in E -> ErV (x ^+ i) = i%:R *: ErV x.\nProof. by move=> Ex; rewrite morphX // scaler_nat. Qed.",
    "Lemma abelem_rV_V x : x \\in E -> ErV x^-1 = - ErV x.\nProof. by move=> Ex; rewrite morphV. Qed.",
    "Lemma rVabelem0 : rV_E 0 = 1%g. Proof. exact: morph1. Qed.",
    "Lemma rVabelemD : {morph rV_E : u v / u + v >-> (u * v)%g}.\nProof. by move=> u v /=; rewrite -morphM. Qed.",
    "Lemma rVabelemN : {morph rV_E: u / - u >-> (u^-1)%g}.\nProof. by move=> u /=; rewrite -morphV. Qed.",
    "Lemma rVabelemZ (m : 'F_p) : {morph rV_E : u / m *: u >-> (u ^+ m)%g}.\nProof. by move=> u; rewrite /= -morphX -?[(u ^+ m)%g]scaler_nat ?natr_Zp. Qed.",
    "Lemma abelem_rV_K : {in E, cancel ErV rV_E}. Proof. exact: invmE. Qed.",
    "Lemma rVabelemK : cancel rV_E ErV. Proof. by move=> u; rewrite invmK. Qed.",
    "Lemma rVabelem_inj : injective rV_E. Proof. exact: can_inj rVabelemK. Qed.",
    "Lemma rVabelem_injm : 'injm rV_E. Proof. exact: injm_invm abelem_rV_injm. Qed.",
    "Lemma im_rVabelem : rV_E @* setT = E.\nProof. by rewrite -im_abelem_rV im_invm. Qed.",
    "Lemma mem_rVabelem u : rV_E u \\in E.\nProof. by rewrite -im_rVabelem mem_morphim. Qed.",
    "Lemma sub_rVabelem L : rV_E @* L \\subset E.\nProof. by rewrite -[_ @* L]morphimIim im_invm subsetIl. Qed.",
    "Lemma card_rVabelem L : #|rV_E @* L| = #|L|.\nProof. by rewrite card_injm ?rVabelem_injm. Qed.",
    "Lemma abelem_rV_mK (H : {set gT}) : H \\subset E -> rV_E @* (ErV @* H) = H.\nProof. exact: morphim_invm abelem_rV_injm H. Qed.",
    "Lemma rVabelem_mK L : ErV @* (rV_E @* L) = L.\nProof. by rewrite morphim_invmE morphpreK. Qed.",
    "Lemma rVabelem_minj : injective (morphim (MorPhantom rV_E)).\nProof. exact: can_inj rVabelem_mK. Qed.",
    "Lemma rVabelemS L M : (rV_E @* L \\subset rV_E @* M) = (L \\subset M).\nProof. by rewrite injmSK ?rVabelem_injm. Qed.",
    "Lemma abelem_rV_S (H K : {set gT}) :\n  H \\subset E -> (ErV @* H \\subset ErV @* K) = (H \\subset K).\nProof. by move=> sHE; rewrite injmSK ?abelem_rV_injm. Qed.",
    "Lemma sub_rVabelem_im L (H : {set gT}) :\n  (rV_E @* L \\subset H) = (L \\subset ErV @* H).\nProof. by rewrite sub_morphim_pre ?morphpre_invm. Qed.",
    "Lemma sub_abelem_rV_im (H : {set gT}) (L : {set 'rV['F_p]_n}) :\n  H \\subset E -> (ErV @* H \\subset L) = (H \\subset rV_E @* L).\nProof. by move=> sHE; rewrite sub_morphim_pre ?morphim_invmE. Qed.",
    "Lemma rVabelemJ v x : x \\in G -> rV_E (v *m rG x) = (rV_E v) ^ x.\nProof. exact: rVabelemJmx. Qed.",
    "Lemma abelem_rV_J : {in E & G, forall x y, ErV (x ^ y) = ErV x *m rG y}.\nProof.\nby move=> x y Ex Gy; rewrite -{1}(abelem_rV_K Ex) -rVabelemJ ?rVabelemK.\nQed.",
    "Lemma abelem_rowgJ m (A : 'M_(m, n)) x :\n  x \\in G -> rV_E @* rowg (A *m rG x) = (rV_E @* rowg A) :^ x.\nProof.\nmove=> Gx; apply: (canRL (conjsgKV _)); apply/setP=> y.\nrewrite mem_conjgV !morphim_invmE !inE memJ_norm ?(subsetP nEG) //=.\napply: andb_id2l => Ey; rewrite abelem_rV_J //.\nby rewrite submxMfree // row_free_unit (repr_mx_unit rG).\nQed.",
    "Lemma rV_abelem_sJ (L : {group gT}) x :\n  x \\in G -> L \\subset E -> ErV @* (L :^ x) = rowg (rowg_mx (ErV @* L) *m rG x).\nProof.\nmove=> Gx sLE; apply: rVabelem_minj; rewrite abelem_rowgJ //.\nby rewrite rowg_mxK !morphim_invm // -(normsP nEG x Gx) conjSg.\nQed.",
    "Lemma rstab_abelem m (A : 'M_(m, n)) : rstab rG A = 'C_G(rV_E @* rowg A).\nProof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx; apply/eqP/centP => cAx.\nmove=> _ /morphimP[u _ + ->] => /[1!inE] /submxP[{}u ->].\n  by apply/esym/commgP/conjg_fixP; rewrite -rVabelemJ -?mulmxA ?cAx.\napply/row_matrixP=> i; apply: rVabelem_inj.\nby rewrite row_mul rVabelemJ // /conjg -cAx ?mulKg ?mem_morphim // inE row_sub.\nQed.",
    "Lemma rstabs_abelem m (A : 'M_(m, n)) : rstabs rG A = 'N_G(rV_E @* rowg A).\nProof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx.\nby rewrite -rowgS -rVabelemS abelem_rowgJ.\nQed.",
    "Lemma rstabs_abelemG (L : {group gT}) :\n  L \\subset E -> rstabs rG (rowg_mx (ErV @* L)) = 'N_G(L).\nProof. by move=> sLE; rewrite rstabs_abelem rowg_mxK morphim_invm. Qed.",
    "Lemma mxmodule_abelem m (U : 'M['F_p]_(m, n)) :\n  mxmodule rG U = (G \\subset 'N(rV_E @* rowg U)).\nProof. by rewrite -subsetIidl -rstabs_abelem. Qed.",
    "Lemma mxmodule_abelemG (L : {group gT}) :\n  L \\subset E -> mxmodule rG (rowg_mx (ErV @* L)) = (G \\subset 'N(L)).\nProof. by move=> sLE; rewrite -subsetIidl -rstabs_abelemG. Qed.",
    "Lemma mxsimple_abelemP (U : 'M['F_p]_n) :\n  reflect (mxsimple rG U) (minnormal (rV_E @* rowg U) G).\nProof.\napply: (iffP mingroupP) => [[/andP[ntU modU] minU] | [modU ntU minU]].\n  split=> [||V modV sVU ntV]; first by rewrite mxmodule_abelem.\n    by apply: contraNneq ntU => ->; rewrite /= rowg0 morphim1.\n  rewrite -rowgS -rVabelemS [_ @* rowg V]minU //.\n    rewrite -subG1 sub_rVabelem_im morphim1 subG1 trivg_rowg ntV /=.\n    by rewrite -mxmodule_abelem.\n  by rewrite rVabelemS rowgS.\nsplit=> [|D /andP[ntD nDG sDU]].\n  rewrite -subG1 sub_rVabelem_im morphim1 subG1 trivg_rowg ntU /=.\n  by rewrite -mxmodule_abelem.\napply/eqP; rewrite eqEsubset sDU sub_rVabelem_im /= -rowg_mxSK rowgK.\nhave sDE: D \\subset E := subset_trans sDU (sub_rVabelem _).\nrewrite minU ?mxmodule_abelemG //.\n  by rewrite -rowgS rowg_mxK sub_abelem_rV_im.\nby rewrite rowg_mx_eq0 (morphim_injm_eq1 abelem_rV_injm).\nQed.",
    "Lemma mxsimple_abelemGP (L : {group gT}) :\n  L \\subset E -> reflect (mxsimple rG (rowg_mx (ErV @* L))) (minnormal L G).\nProof.\nmove/abelem_rV_mK=> {2}<-; rewrite -{2}[_ @* L]rowg_mxK.\nexact: mxsimple_abelemP.\nQed.",
    "Lemma abelem_mx_irrP : reflect (mx_irreducible rG) (minnormal E G).\nProof.\nby rewrite -[E in minnormal E G]im_rVabelem -rowg1; apply: mxsimple_abelemP.\nQed.",
    "Lemma rfix_abelem (H : {set gT}) :\n  H \\subset G -> (rfix_mx rG H :=: rowg_mx (ErV @* 'C_E(H)%g))%MS.\nProof.\nmove/subsetP=> sHG; apply/eqmxP/andP; split.\n  rewrite -rowgS rowg_mxK -sub_rVabelem_im // subsetI sub_rVabelem /=.\n  apply/centsP=> y /morphimP[v _] /[1!inE] cGv ->{y} x Gx.\n  by apply/commgP/conjg_fixP; rewrite /= -rVabelemJ ?sHG ?(rfix_mxP H _).\nrewrite genmxE; apply/rfix_mxP=> x Hx; apply/row_matrixP=> i.\nrewrite row_mul rowK; case/morphimP: (enum_valP i) => z Ez /setIP[_ cHz] ->.\nby rewrite -abelem_rV_J ?sHG // conjgE (centP cHz) ?mulKg.\nQed.",
    "Lemma rker_abelem : rker rG = 'C_G(E).\nProof. by rewrite /rker rstab_abelem rowg1 im_rVabelem. Qed.",
    "Lemma abelem_mx_faithful : 'C_G(E) = 1%g -> mx_faithful rG.\nProof. by rewrite /mx_faithful rker_abelem => ->. Qed.",
    "Lemma eq_abelem_subg_repr : {in H, rHG =1 rH}.\nProof.\nmove=> x Hx; apply/row_matrixP=> i; rewrite !rowE !mul_rV_lin1 /=.\nby rewrite /abelem_mx_fun !subgK ?(subsetP sHG).\nQed.",
    "Lemma rsim_abelem_subg : mx_rsim rHG rH.\nProof.\nexists 1%:M => [//| |x Hx]; first by rewrite row_free_unit unitmx1.\nby rewrite mul1mx mulmx1 eq_abelem_subg_repr.\nQed.",
    "Lemma mxmodule_abelem_subg m (U : 'M_(m, n)) : mxmodule rHG U = mxmodule rH U.\nProof.\napply: eq_subset_r => x.\nrewrite [LHS]inE inE; apply: andb_id2l => Hx.\nby rewrite eq_abelem_subg_repr.\nQed.",
    "Lemma mxsimple_abelem_subg U : mxsimple rHG U <-> mxsimple rH U.\nProof.\nhave eq_modH := mxmodule_abelem_subg; rewrite /mxsimple eq_modH.\nby split=> [] [-> -> minU]; split=> [//|//|V]; have:= minU V; rewrite eq_modH.\nQed.",
    "Lemma rfix_pgroup_pchar G H n (rG : mx_representation F G n) :\n  n > 0 -> p.-group H -> H \\subset G -> rfix_mx rG H != 0.\nProof.\nmove=> n_gt0 pH sHG; rewrite -(rfix_subg rG sHG).\nmove: {2}_.+1 (ltnSn (n + #|H|)) {rG G sHG}(subg_repr _ _) => m.\nelim: m gT H pH => // m IHm gT' G pG in n n_gt0 *; rewrite ltnS => le_nG_m rG.\napply/eqP=> Gregular; have irrG: mx_irreducible rG.\n  apply/mx_irrP; split=> // U modU; rewrite -mxrank_eq0 -lt0n => Unz.\n  rewrite /row_full eqn_leq rank_leq_col leqNgt; apply/negP=> ltUn.\n  have: rfix_mx (submod_repr modU) G != 0.\n    by apply: IHm => //; apply: leq_trans le_nG_m; rewrite ltn_add2r.\n  by rewrite -mxrank_eq0 (rfix_submod modU) // Gregular capmx0 linear0 mxrank0.\nhave{m le_nG_m IHm} faithfulG: mx_faithful rG.\n  apply/trivgP/eqP/idPn; set C := _ rG => ntC.\n  suffices: rfix_mx (kquo_repr rG) (G / _)%g != 0.\n    by rewrite -mxrank_eq0 rfix_quo // Gregular mxrank0.\n  apply: (IHm _ _ (morphim_pgroup _ _)) => //.\n  by apply: leq_trans le_nG_m; rewrite ltn_add2l ltn_quotient // rstab_sub.\nhave{Gregular} ntG: G :!=: 1%g.\n  apply: contraL n_gt0; move/eqP=> G1; rewrite -leqNgt -(mxrank1 F n).\n  rewrite -(mxrank0 F n n) -Gregular mxrankS //; apply/rfix_mxP=> x.\n  by rewrite {1}G1 mul1mx => /set1P->; rewrite repr_mx1.\nhave p_pr: prime p by case/andP: pcharFp.\nhave{ntG pG} [z]: {z | z \\in 'Z(G) & #[z] = p}; last case/setIP=> Gz cGz ozp.\n  apply: Cauchy => //; apply: contraR ntG; rewrite -p'natE // => p'Z.\n  have pZ: p.-group 'Z(G) by rewrite (pgroupS (center_sub G)).\n  by rewrite (trivg_center_pgroup pG (card1_trivg (pnat_1 pZ p'Z))).\nhave{cGz} cGz1: centgmx rG (rG z - 1%:M).\n  apply/centgmxP=> x Gx; rewrite mulmxBl mulmxBr mulmx1 mul1mx.\n  by rewrite -!repr_mxM // (centP cGz).\nhave{irrG faithfulG cGz1} Urz1: rG z - 1%:M \\in unitmx.\n  apply: (mx_Schur irrG) cGz1 _; rewrite subr_eq0.\n  move/implyP: (subsetP faithfulG z).\n  by rewrite !inE Gz mul1mx -order_eq1 ozp -implybNN neq_ltn orbC prime_gt1.\ndo [case: n n_gt0 => // n' _; set n := n'.+1] in rG Urz1 *.\nhave pcharMp: p \\in [pchar 'M[F]_n].\n  exact: (rmorph_pchar (@scalar_mx F n)).\nhave{Urz1}: pFrobenius_aut pcharMp (rG z - 1) \\in GRing.unit by rewrite unitrX.\nrewrite (pFrobenius_autB_comm _ (commr1 _)) pFrobenius_aut1.\nby rewrite -[_ (rG z)](repr_mxX rG) // -ozp expg_order repr_mx1 subrr unitr0.\nQed.",
    "Lemma pcore_sub_rstab_mxsimple_pchar M :\n  mxsimple rG M -> 'O_p(G) \\subset rstab rG M.\nProof.\ncase=> modM nzM simM; have sGpG := pcore_sub p G.\nrewrite rfix_mx_rstabC //; set U := rfix_mx _ _.\nhave:= simM (M :&: U)%MS; rewrite sub_capmx submx_refl.\napply; rewrite ?capmxSl //.\n  by rewrite capmx_module // normal_rfix_mx_module ?pcore_normal.\nrewrite -(in_submodK (capmxSl _ _)) val_submod_eq0 -submx0.\nrewrite -(rfix_submod modM) // submx0 rfix_pgroup_pchar ?pcore_pgroup //.\nby rewrite lt0n mxrank_eq0.\nQed.",
    "Lemma pcore_sub_rker_mx_irr_pchar :\n  mx_irreducible rG -> 'O_p(G) \\subset rker rG.\nProof. exact: pcore_sub_rstab_mxsimple_pchar. Qed.",
    "Lemma pcore_faithful_mx_irr_pchar :\n  mx_irreducible rG -> mx_faithful rG -> 'O_p(G) = 1%g.\nProof.\nmove=> irrG ffulG; apply/trivgP; apply: subset_trans ffulG.\nexact: pcore_sub_rstab_mxsimple_pchar.\nQed.",
    "Lemma faithful_repr_extraspecial_pchar :\n \\rank U = (p ^ n)%N /\\\n   (forall V, mxsimple rS V -> mx_iso rZ U V -> mx_iso rS U V).\nProof.\nsuffices IH V: mxsimple rS V -> mx_iso rZ U V ->\n  [&& \\rank U == (p ^ n)%N & mxsimple_iso rS U V].\n- split=> [|/= V simV isoUV].\n    by case/andP: (IH U simU (mx_iso_refl _ _)) => /eqP.\n  by case/andP: (IH V simV isoUV) => _ /(mxsimple_isoP simU).\nmove=> simV isoUV; wlog sS: / irrType F S by apply: socle_exists.\nhave [[_ defS'] prZ] := esS.\nhave{prZ} ntZ: 'Z(S) :!=: 1%g by case: eqP prZ => // ->; rewrite cards1.\nhave [_ [iphi]] := extraspecial_repr_structure_pchar sS.\nset phi := fun i => _ => [] [inj_phi im_phi _ phiZ dim_phi] _.\nhave [modU nzU _]:= simU; pose rU := submod_repr modU.\nhave nlinU: \\rank U != 1.\n  apply/eqP=> /(rker_linear rU); apply/negP; rewrite /rker rstab_submod.\n  by rewrite (eqmx_rstab _ (val_submod1 _)) (eqP ffulU) defS' subG1.\nhave irrU: mx_irreducible rU by apply/submod_mx_irr.\nhave rsimU := rsim_irr_comp_pchar sS F'S irrU.\nset iU := irr_comp sS rU in rsimU; have [_ degU _ _]:= rsimU.\nhave phiUP: iU \\in codom iphi by rewrite im_phi !inE -degU.\nrewrite degU -(f_iinv phiUP) dim_phi eqxx /=; apply/(mxsimple_isoP simU).\nhave [modV _ _]:= simV; pose rV := submod_repr modV.\nhave irrV: mx_irreducible rV by apply/submod_mx_irr.\nhave rsimV := rsim_irr_comp_pchar sS F'S irrV.\nset iV := irr_comp sS rV in rsimV; have [_ degV _ _]:= rsimV.\nhave phiVP: iV \\in codom iphi by rewrite im_phi !inE -degV -(mxrank_iso isoUV).\npose jU := iinv phiUP; pose jV := iinv phiVP.\nhave [z Zz ntz]:= trivgPn _ ntZ.\nhave [|w prim_w phi_z] := phiZ z; first by rewrite 2!inE ntz.\nsuffices eqjUV: jU == jV.\n  apply/(mx_rsim_iso modU modV); apply: mx_rsim_trans rsimU _.\n  by rewrite -(f_iinv phiUP) -/jU (eqP eqjUV) f_iinv; apply: mx_rsim_sym.\nhave rsimUV: mx_rsim (subg_repr (phi jU) sZS) (subg_repr (phi jV) sZS).\n  have [bU _ bUfree bUhom] := mx_rsim_sym rsimU.\n  have [bV _ bVfree bVhom] := rsimV.\n  have modUZ := mxmodule_subg sZS modU; have modVZ := mxmodule_subg sZS modV.\n  case/(mx_rsim_iso modUZ modVZ): isoUV => [bZ degZ bZfree bZhom].\n  rewrite /phi !f_iinv; exists (bU *m bZ *m bV)=> [||x Zx].\n  - by rewrite -degU degZ degV.\n  - by rewrite /row_free !mxrankMfree.\n  have Sx := subsetP sZS x Zx.\n  by rewrite 2!mulmxA bUhom // -(mulmxA _ _ bZ) bZhom // -4!mulmxA bVhom.\nhave{rsimUV} [B [B' _ homB]] := mx_rsim_def rsimUV.\nhave:= eqxx (irr_mode (iphi jU) z); rewrite /irr_mode; set i0 := Ordinal _.\nrewrite {2}[_ z]homB // ![_ z]phi_z mxE mulr1n -scalemx1 -scalemxAr -scalemxAl.\nrewrite -(repr_mx1 (subg_repr (phi jV) sZS)) -{B B'}homB // repr_mx1 scalemx1.\nby rewrite mxE (eq_prim_root_expr prim_w) !modIp'.\nQed.",
    "Lemma separable_poly_neq0 p : separable p -> p != 0.\nProof.\nby apply: contraTneq => ->; rewrite unlock deriv0 coprime0p eqp01.\nQed.",
    "Lemma poly_square_freeP p :\n  (forall u v, u * v %| p -> coprimep u v)\n  <-> (forall u, size u != 1 -> ~~ (u ^+ 2 %| p)).\nProof.\nsplit=> [sq'p u | sq'p u v dvd_uv_p].\n  by apply: contra => /sq'p; rewrite coprimepp.\nrewrite coprimep_def (contraLR (sq'p _)) // (dvdp_trans _ dvd_uv_p) //.\nby rewrite dvdp_mul ?dvdp_gcdl ?dvdp_gcdr.\nQed.",
    "Lemma separable_polyP {p} :\n  reflect [/\\ forall u v, u * v %| p -> coprimep u v\n            & forall u, u %| p -> 1 < size u -> u^`() != 0]\n          (separable p).\nProof.\napply: (iffP idP) => [sep_p | [sq'p nz_der1p]].\n  split=> [u v | u u_dv_p]; last first.\n    apply: contraTneq => u'0; rewrite unlock in sep_p; rewrite -leqNgt -(eqnP sep_p).\n    rewrite dvdp_leq -?size_poly_eq0 ?(eqnP sep_p) // dvdp_gcd u_dv_p.\n    have /dvdpZr <-: lead_coef u ^+ scalp p u != 0 by rewrite lcn_neq0.\n    by rewrite -derivZ -Pdiv.Idomain.divpK //= derivM u'0 mulr0 addr0 dvdp_mull.\n  rewrite Pdiv.Idomain.dvdp_eq mulrCA mulrA; set c := _ ^+ _ => /eqP Dcp.\n  have nz_c: c != 0 by rewrite lcn_neq0.\n  move: sep_p; rewrite coprimep_sym unlock -(coprimepZl _ _ nz_c).\n  rewrite -(coprimepZr _ _ nz_c) -derivZ Dcp derivM coprimepMl.\n  by rewrite coprimep_addl_mul !coprimepMr -andbA => /and4P[].\nrewrite unlock coprimep_def eqn_leq size_poly_gt0; set g := gcdp _ _.\nhave nz_g: g != 0.\n  rewrite -dvd0p dvdp_gcd -(mulr0 0); apply/nandP; left.\n  by have /poly_square_freeP-> := sq'p; rewrite ?size_poly0.\nhave [g_p]: g %| p /\\ g %| p^`() by rewrite dvdp_gcdr ?dvdp_gcdl.\npose c := lead_coef g ^+ scalp p g; have nz_c: c != 0 by rewrite lcn_neq0.\nhave Dcp: c *: p = p %/ g * g by rewrite Pdiv.Idomain.divpK.\nrewrite nz_g andbT leqNgt -(dvdpZr _ _ nz_c) -derivZ Dcp derivM.\nrewrite dvdp_addr; last by rewrite dvdp_mull.\nrewrite Gauss_dvdpr; last by rewrite sq'p // mulrC -Dcp dvdpZl.\nby apply: contraL => /nz_der1p nz_g'; rewrite gtNdvdp ?nz_g' ?lt_size_deriv.\nQed.",
    "Lemma separable_coprime p u v : separable p -> u * v %| p -> coprimep u v.\nProof. by move=> /separable_polyP[sq'p _] /sq'p. Qed.",
    "Lemma separable_nosquare p u k :\n  separable p -> 1 < k -> size u != 1 -> (u ^+ k %| p) = false.\nProof.\nmove=> /separable_polyP[/poly_square_freeP sq'p _] /subnKC <- /sq'p.\nby apply: contraNF; apply: dvdp_trans; rewrite exprD dvdp_mulr.\nQed.",
    "Lemma separable_deriv_eq0 p u :\n  separable p -> u %| p -> 1 < size u -> (u^`() == 0) = false.\nProof. by move=> /separable_polyP[_ nz_der1p] u_p /nz_der1p/negPf->. Qed.",
    "Lemma dvdp_separable p q : q %| p -> separable p -> separable q.\nProof.\nmove=> /(dvdp_trans _)q_dv_p /separable_polyP[sq'p nz_der1p].\nby apply/separable_polyP; split=> [u v /q_dv_p/sq'p | u /q_dv_p/nz_der1p].\nQed.",
    "Lemma separable_mul p q :\n  separable (p * q) = [&& separable p, separable q & coprimep p q].\nProof.\napply/idP/and3P => [sep_pq | [sep_p sep_q co_pq]].\n  rewrite !(dvdp_separable _ sep_pq) ?dvdp_mulIr ?dvdp_mulIl //.\n  by rewrite (separable_coprime sep_pq).\nrewrite unlock in sep_p sep_q *.\nrewrite derivM coprimepMl {1}addrC mulrC !coprimep_addl_mul.\nby rewrite !coprimepMr (coprimep_sym q p) co_pq !andbT; apply/andP.\nQed.",
    "Lemma eqp_separable p q : p %= q -> separable p = separable q.\nProof. by case/andP=> p_q q_p; apply/idP/idP=> /dvdp_separable->. Qed.",
    "Lemma separable_root p x :\n  separable (p * ('X - x%:P)) = separable p && ~~ root p x.\nProof.\nrewrite separable_mul; apply: andb_id2l => seq_p.\nby rewrite unlock derivXsubC coprimep1 coprimep_XsubC.\nQed.",
    "Lemma separable_prod_XsubC (r : seq R) :\n  separable (\\prod_(x <- r) ('X - x%:P)) = uniq r.\nProof.\nelim: r => [|x r IH]; first by rewrite big_nil unlock /separable_poly coprime1p.\nby rewrite big_cons mulrC separable_root IH root_prod_XsubC andbC.\nQed.",
    "Lemma make_separable p : p != 0 -> separable (p %/ gcdp p p^`()).\nProof.\nset g := gcdp p p^`() => nz_p; apply/separable_polyP.\nhave max_dvd_u (u : {poly R}): 1 < size u -> exists k, ~~ (u ^+ k %| p).\n  move=> u_gt1; exists (size p); rewrite gtNdvdp // polySpred //.\n  by rewrite -(ltn_subRL 1) subn1 size_exp leq_pmull // -(subnKC u_gt1).\nsplit=> [|u u_pg u_gt1]; last first.\n  apply/eqP=> u'0 /=; have [k /negP[]] := max_dvd_u u u_gt1.\n  elim: k => [|k IHk]; first by rewrite dvd1p.\n  suffices: u ^+ k.+1 %| (p %/ g) * g.\n    by rewrite Pdiv.Idomain.divpK ?dvdp_gcdl // dvdpZr ?lcn_neq0.\n  rewrite exprS dvdp_mul // dvdp_gcd IHk //=.\n  suffices: u ^+ k %| (p %/ u ^+ k * u ^+ k)^`().\n    by rewrite Pdiv.Idomain.divpK // derivZ dvdpZr ?lcn_neq0.\n  by rewrite !derivCE u'0 mul0r mul0rn mulr0 addr0 dvdp_mull.\nhave pg_dv_p: p %/ g %| p by rewrite divp_dvd ?dvdp_gcdl.\napply/poly_square_freeP=> u; rewrite neq_ltn ltnS leqn0 size_poly_eq0.\ncase/predU1P=> [-> | /max_dvd_u[k]].\n  by apply: contra nz_p; rewrite expr0n -dvd0p => /dvdp_trans->.\napply: contra => u2_dv_pg; case: k; [by rewrite dvd1p | elim=> [|n IHn]].\n  exact: dvdp_trans (dvdp_mulr _ _) (dvdp_trans u2_dv_pg pg_dv_p).\nsuff: u ^+ n.+2 %| (p %/ g) * g.\n  by rewrite Pdiv.Idomain.divpK ?dvdp_gcdl // dvdpZr ?lcn_neq0.\nrewrite -add2n exprD dvdp_mul // dvdp_gcd.\nrewrite (dvdp_trans _ IHn) ?exprS ?dvdp_mull //=.\nsuff: u ^+ n %| ((p %/ u ^+ n.+1) * u ^+ n.+1)^`().\n  by rewrite Pdiv.Idomain.divpK // derivZ dvdpZr ?lcn_neq0.\nby rewrite !derivCE dvdp_add // -1?mulr_natl ?exprS !dvdp_mull.\nQed.",
    "Lemma separable_map (F : fieldType) (R : idomainType)\n                    (f : {rmorphism F -> R}) (p : {poly F}) :\n  separable_poly (map_poly f p) = separable_poly p.\nProof.\nby rewrite unlock deriv_map /coprimep -gcdp_map size_map_poly.\nQed.",
    "Lemma large_field_PET q :\n    root (q ^ iota) y -> separable_poly q ->\n  exists2 r, r != 0\n  & forall t (z := iota t * y - x), ~~ root r (iota t) -> inFz z x /\\ inFz z y.\nProof.\nmove=> qy_0 sep_q; have nz_q := separable_poly_neq0 sep_q.\nhave /factor_theorem[q0 Dq] := qy_0.\nset p1 := p ^ iota \\Po ('X + x%:P); set q1 := q0 \\Po ('X + y%:P).\nhave nz_p1: p1 != 0.\n  apply: contraNneq nz_p => /(canRL (fun r => comp_polyXaddC_K r _))/eqP.\n  by rewrite comp_poly0 map_poly_eq0.\nhave{sep_q} nz_q10: q1.[0] != 0.\n  move: sep_q; rewrite -(separable_map iota) Dq separable_root => /andP[_].\n  by rewrite horner_comp !hornerE.\nhave nz_q1: q1 != 0 by apply: contraNneq nz_q10 => ->; rewrite horner0.\npose p2 := p1 ^ polyC \\Po ('X * 'Y); pose q2 := q1 ^ polyC.\nhave /Bezout_coprimepP[[u v]]: coprimep p2 q2.\n  rewrite coprimep_def eqn_leq leqNgt andbC size_poly_gt0 gcdp_eq0 poly_XmY_eq0.\n  by rewrite map_polyC_eq0 (negPf nz_p1) -resultant_eq0 div_annihilant_neq0.\nrewrite -size_poly_eq1 => /size_poly1P[r nzr Dr]; exists r => {nzr}// t z nz_rt.\nhave [r1 nz_r1 r1z_0]: algebraicOver iota z.\n  apply/algebraic_sub; last by exists p.\n  by apply: algebraic_mul; [apply: algebraic_id | exists q].\npose Fz := subFExtend iota z r1; pose kappa : Fz -> L := subfx_inj.\npose kappa' := inj_subfx iota z r1.\nhave /eq_map_poly Diota: kappa \\o kappa' =1 iota.\n  by move=> w; rewrite /kappa /= subfx_inj_eval // map_polyC hornerC.\nsuffices [y3]: exists y3, y = kappa y3.\n  have [q3 ->] := subfxE y3; rewrite /kappa subfx_inj_eval // => Dy.\n  split; [exists (t *: q3 - 'X) | by exists q3].\n  by rewrite rmorphB /= linearZ map_polyX !hornerE -Dy opprB addrC addrNK.\npose p0 := p ^ iota \\Po (iota t *: 'X - z%:P).\nhave co_p0_q0: coprimep p0 q0.\n  pose at_t := horner_eval (iota t); have at_t0: at_t 0 = 0 by apply: rmorph0.\n  have /map_polyK polyCK: cancel polyC at_t by move=> w; apply: hornerC.\n  have ->: p0 = p2 ^ at_t \\Po ('X - y%:P).\n    rewrite map_comp_poly polyCK // rmorphM /= map_polyC map_polyX /=.\n    rewrite horner_evalE hornerX.\n    rewrite -!comp_polyA comp_polyM comp_polyD !comp_polyC !comp_polyX.\n    by rewrite mulrC mulrBr mul_polyC addrAC -addrA -opprB -rmorphM -rmorphB.\n  have ->: q0 = q2 ^ at_t \\Po ('X - y%:P) by rewrite polyCK ?comp_polyXaddC_K.\n  apply/coprimep_comp_poly/Bezout_coprimepP; exists (u ^ at_t, v ^ at_t).\n  by rewrite /= -!rmorphM -rmorphD Dr /= map_polyC polyC_eqp1.\nhave{co_p0_q0}: gcdp p0 (q ^ iota) %= 'X - y%:P.\n  rewrite /eqp Dq (eqp_dvdl _ (Gauss_gcdpr _ _)) // dvdp_gcdr dvdp_gcd.\n  rewrite dvdp_mull // -root_factor_theorem rootE horner_comp !hornerE.\n  by rewrite opprB addrC subrK.\nhave{p0} [p3 ->]: exists p3, p0 = p3 ^ kappa.\n  exists (p ^ kappa' \\Po (kappa' t *: 'X - (subfx_eval iota z r1 'X)%:P)).\n  rewrite map_comp_poly rmorphB /= linearZ /= map_polyC map_polyX /=.\n  rewrite !subfx_inj_eval // map_polyC hornerC map_polyX hornerX.\n  by rewrite -map_poly_comp Diota.\nrewrite -Diota map_poly_comp -gcdp_map /= -/kappa.\nmove: (gcdp _ _) => r3 /eqpf_eq[c nz_c Dr3].\nexists (- (r3`_0 / r3`_1)); rewrite [kappa _]rmorphN fmorph_div -!coef_map Dr3.\nby rewrite !coefZ polyseqXsubC mulr1 mulrC mulKf ?opprK.\nQed.",
    "Lemma pchar0_PET (q : {poly F}) :\n    q != 0 -> root (q ^ iota) y -> [pchar F] =i pred0 ->\n  exists n, let z := y *+ n - x in inFz z x /\\ inFz z y.\nProof.\nmove=> nz_q qy_0 /pcharf0P pcharF0.\nwithout loss{nz_q} sep_q: q qy_0 / separable_poly q.\n  move=> IHq; apply: IHq (make_separable nz_q).\n  have /dvdpP[q1 Dq] := dvdp_gcdl q q^`().\n  rewrite {1}Dq mulpK ?gcdp_eq0; last by apply/nandP; left.\n  have [n [r nz_ry Dr]] := multiplicity_XsubC (q ^ iota) y.\n  rewrite map_poly_eq0 nz_q /= in nz_ry.\n  case: n => [|n] in Dr; first by rewrite Dr mulr1 (negPf nz_ry) in qy_0.\n  have: ('X - y%:P) ^+ n.+1 %| q ^ iota by rewrite Dr dvdp_mulIr.\n  rewrite Dq rmorphM /= gcdp_map -(eqp_dvdr _ (gcdp_mul2l _ _ _)) -deriv_map Dr.\n  rewrite dvdp_gcd derivM deriv_exp derivXsubC mul1r !mulrA dvdp_mulIr /=.\n  rewrite mulrDr mulrA dvdp_addr ?dvdp_mulIr // exprS -scaler_nat -!scalerAr.\n  rewrite dvdpZr -?(rmorph_nat iota) ?fmorph_eq0 ?pcharF0 //.\n  rewrite mulrA dvdp_mul2r ?expf_neq0 ?polyXsubC_eq0 //.\n  by rewrite Gauss_dvdpl ?dvdp_XsubCl // coprimep_sym coprimep_XsubC.\nhave [r nz_r PETxy] := large_field_PET qy_0 sep_q.\npose ts := mkseq (fun n => iota n%:R) (size r).\nhave /(max_ring_poly_roots nz_r)/=/implyP: uniq_roots ts.\n  rewrite uniq_rootsE mkseq_uniq // => m n eq_mn; apply/eqP; rewrite eqn_leq.\n  wlog suffices: m n eq_mn / m <= n by move=> IHmn; rewrite !IHmn.\n  move/fmorph_inj/eqP: eq_mn; rewrite -subr_eq0 leqNgt; apply: contraL => lt_mn.\n  by rewrite -natrB ?(ltnW lt_mn) // pcharF0 -lt0n subn_gt0.\nrewrite size_mkseq ltnn implybF all_map => /allPn[n _ /= /PETxy].\nby rewrite rmorph_nat mulr_natl; exists n.\nQed.",
    "Lemma Derivation_mul : {in K &, forall u v, D (u * v) = D u * v + u * D v}.\nProof.\nmove=> u v /coord_vbasis-> /coord_vbasis->.\nrewrite !(mulr_sumr, linear_sum) -big_split; apply: eq_bigr => /= j _.\nrewrite !mulr_suml linear_sum -big_split; apply: eq_bigr => /= i _.\nrewrite !(=^~ scalerAl, linearZZ) -!scalerAr linearZZ -!scalerDr !scalerA /=.\nby congr (_ *: _); apply/eqP/(allrelP derD); exact: memt_nth.\nQed.",
    "Lemma Derivation_mul_poly (Dp := map_poly D) :\n  {in polyOver K &, forall p q, Dp (p * q) = Dp p * q + p * Dp q}.\nProof.\nmove=> p q Kp Kq; apply/polyP=> i; rewrite {}/Dp coefD coef_map /= !coefM.\nrewrite linear_sum -big_split; apply: eq_bigr => /= j _.\nby rewrite !{1}coef_map Derivation_mul ?(polyOverP _).\nQed.",
    "Lemma DerivationS E K D : (K <= E)%VS -> Derivation E D -> Derivation K D.\nProof.\nmove/subvP=> sKE derD; apply/allrelP=> x y Kx Ky; apply/eqP.\nby rewrite (Derivation_mul derD) ?sKE // vbasis_mem.\nQed.",
    "Lemma Derivation1 : D 1 = 0.\nProof.\napply: (addIr (D (1 * 1))); rewrite add0r {1}mul1r.\nby rewrite (Derivation_mul derD) ?mem1v // mulr1 mul1r.\nQed.",
    "Lemma Derivation_scalar x : x \\in 1%VS -> D x = 0.\nProof. by case/vlineP=> y ->; rewrite linearZ /= Derivation1 scaler0. Qed.",
    "Lemma Derivation_exp x m : x \\in E -> D (x ^+ m) = x ^+ m.-1 *+ m * D x.\nProof.\nmove=> Ex; case: m; first by rewrite expr0 mulr0n mul0r Derivation1.\nelim=> [|m IHm]; first by rewrite mul1r.\nrewrite exprS (Derivation_mul derD) //; last by apply: rpredX.\nby rewrite mulrC IHm mulrA mulrnAr -exprS -mulrDl.\nQed.",
    "Lemma Derivation_horner p x :\n    p \\is a polyOver E -> x \\in E ->\n  D p.[x] = (map_poly D p).[x] + p^`().[x] * D x.\nProof.\nmove=> Ep Ex; elim/poly_ind: p Ep => [|p c IHp] /polyOverP EpXc.\n  by rewrite !(raddf0, horner0) mul0r add0r.\nhave Ep: p \\is a polyOver E.\n  by apply/polyOverP=> i; have:= EpXc i.+1; rewrite coefD coefMX coefC addr0.\nhave->: map_poly D (p * 'X + c%:P) = map_poly D p * 'X + (D c)%:P.\n  apply/polyP=> i; rewrite !(coefD, coefMX, coef_map) /= linearD /= !coefC.\n  by rewrite !(fun_if D) linear0.\nrewrite derivMXaddC !hornerE mulrDl mulrAC addrAC linearD /=; congr (_ + _).\nby rewrite addrCA -mulrDl -IHp // addrC (Derivation_mul derD) ?rpred_horner.\nQed.",
    "Lemma separable_elementP :  \n  reflect (exists f, [/\\ f \\is a polyOver K, root f x & separable_poly f])\n          (separable_element K x).\nProof.\napply: (iffP idP) => [sep_x | [f [Kf /(minPoly_dvdp Kf)/dvdpP[g ->]]]].\n  by exists (minPoly K x); rewrite minPolyOver root_minPoly.\nby rewrite separable_mul => /and3P[].\nQed.",
    "Lemma base_separable : x \\in K -> separable_element K x.\nProof.\nmove=> Kx; apply/separable_elementP; exists ('X - x%:P).\nby rewrite polyOverXsubC root_XsubC unlock !derivCE coprimep1.\nQed.",
    "Lemma separable_nz_der : separable_element K x = ((minPoly K x)^`() != 0).\nProof.\nrewrite /separable_element unlock.\napply/idP/idP=> [|nzPx'].\n  by apply: contraTneq => ->; rewrite coprimep0 -size_poly_eq1 size_minPoly.\nhave gcdK : gcdp (minPoly K x) (minPoly K x)^`() \\in polyOver K.\n  by rewrite gcdp_polyOver ?polyOver_deriv // minPolyOver.\nrewrite -gcdp_eqp1 -size_poly_eq1 -dvdp1.\nhave /orP[/andP[_]|/andP[]//] := minPoly_irr gcdK (dvdp_gcdl _ _).\nrewrite dvdp_gcd dvdpp /= => /(dvdp_leq nzPx')/leq_trans/(_ (size_poly _ _)).\nby rewrite size_minPoly ltnn.\nQed.",
    "Lemma separablePn_pchar :\n  reflect (exists2 p, p \\in [pchar L] &\n            exists2 g, g \\is a polyOver K & minPoly K x = g \\Po 'X^p)\n          (~~ separable_element K x).\nProof.\nrewrite separable_nz_der negbK; set f := minPoly K x.\napply: (iffP eqP) => [f'0 | [p Hp [g _ ->]]]; last first.\n  by rewrite deriv_comp derivXn -scaler_nat (pcharf0 Hp) scale0r mulr0.\npose n := adjoin_degree K x; have sz_f: size f = n.+1 := size_minPoly K x.\nhave fn1: f`_n = 1 by rewrite -(monicP (monic_minPoly K x)) lead_coefE sz_f.\nhave dimKx: (adjoin_degree K x)%:R == 0 :> L.\n  by rewrite -(coef0 _ n.-1) -f'0 coef_deriv fn1.\nhave /natf0_pchar[// | p pcharLp] := dimKx.\nhave /dvdnP[r Dn]: (p %| n)%N by rewrite (dvdn_pcharf pcharLp).\nexists p => //; exists (\\poly_(i < r.+1) f`_(i * p)).\n  by apply: polyOver_poly => i _; rewrite (polyOverP _) ?minPolyOver.\nrewrite comp_polyE size_poly_eq -?Dn ?fn1 ?oner_eq0 //.\nhave pr_p := pcharf_prime pcharLp; have p_gt0 := prime_gt0 pr_p.\napply/polyP=> i; rewrite coef_sum.\nhave [[{}i ->] | p'i] := altP (@dvdnP p i); last first.\n  rewrite big1 => [|j _]; last first.\n    rewrite coefZ -exprM coefXn [_ == _](contraNF _ p'i) ?mulr0 // => /eqP->.\n    by rewrite dvdn_mulr.\n  rewrite (dvdn_pcharf pcharLp) in p'i; apply: mulfI p'i _ _ _.\n  by rewrite mulr0 mulr_natl; case: i => // i; rewrite -coef_deriv f'0 coef0.\nhave [ltri | leir] := leqP r.+1 i.\n  rewrite nth_default ?sz_f ?Dn ?ltn_pmul2r ?big1 // => j _.\n  rewrite coefZ -exprM coefXn mulnC gtn_eqF ?mulr0 //.\n  by rewrite ltn_pmul2l ?(leq_trans _ ltri).\nrewrite (bigD1 (Sub i _)) //= big1 ?addr0 => [|j i'j]; last first.\n  by rewrite coefZ -exprM coefXn mulnC eqn_pmul2l // mulr_natr mulrb ifN_eqC.\nby rewrite coef_poly leir coefZ -exprM coefXn mulnC eqxx mulr1.\nQed.",
    "Lemma separable_root_der : separable_element K x (+) root (minPoly K x)^`() x.\nProof.\nhave KpKx': _^`() \\is a polyOver K := polyOver_deriv (minPolyOver K x).\nrewrite separable_nz_der addNb (root_small_adjoin_poly KpKx') ?addbb //.\nby rewrite (leq_trans (size_poly _ _)) ?size_minPoly.\nQed.",
    "Lemma Derivation_separable D :\n    Derivation <<K; x>> D -> separable_element K x ->\n  D x = - (map_poly D (minPoly K x)).[x] / (minPoly K x)^`().[x].\nProof.\nmove=> derD sepKx; have:= separable_root_der; rewrite {}sepKx -sub0r => nzKx'x.\napply: canRL (mulfK nzKx'x) (canRL (addrK _) _); rewrite mulrC addrC.\nrewrite -(Derivation_horner derD) ?minPolyxx ?linear0 //.\nexact: polyOverSv sKxK _ (minPolyOver _ _).\nQed.",
    "Lemma extendDerivation_id y : y \\in K -> extendDerivation K y = D y.\nProof.\nmove=> yK; rewrite lfunE /= Fadjoin_polyC // derivC map_polyC hornerC.\nby rewrite horner0 mul0r addr0.\nQed.",
    "Lemma extendDerivation_horner p :\n    p \\is a polyOver K -> separable_element K x ->\n  extendDerivation K p.[x] = (map_poly D p).[x] + p^`().[x] * Dx K.\nProof.\nmove=> Kp sepKx; have:= separable_root_der; rewrite {}sepKx /= => nz_pKx'x.\nrewrite [in RHS](divp_eq p (minPoly K x)) lfunE /= Fadjoin_poly_mod ?raddfD //=.\nrewrite (Derivation_mul_poly derD) ?divp_polyOver ?minPolyOver //.\nrewrite derivM !{1}hornerD !{1}hornerM minPolyxx !{1}mulr0 !{1}add0r.\nrewrite mulrDl addrA [_ + (_ * _ * _)]addrC {2}/Dx -mulrA -/Dx.\nby rewrite [_ / _]mulrC (mulVKf nz_pKx'x) mulrN addKr.\nQed.",
    "Lemma extendDerivationP :\n  separable_element K x -> Derivation <<K; x>> (extendDerivation K).\nProof.\nmove=> sep; apply/allrelP=> u v /vbasis_mem Hu /vbasis_mem Hv; apply/eqP.\nrewrite -(Fadjoin_poly_eq Hu) -(Fadjoin_poly_eq Hv) -hornerM.\nrewrite !{1}extendDerivation_horner ?{1}rpredM ?Fadjoin_polyOver //.\nrewrite (Derivation_mul_poly derD) ?Fadjoin_polyOver //.\nrewrite derivM !{1}hornerD !{1}hornerM !{1}mulrDl !{1}mulrDr -!addrA.\ncongr (_ + _); rewrite [Dx K]lock -!{1}mulrA !{1}addrA; congr (_ + _).\nby rewrite addrC; congr (_ * _ + _); rewrite mulrC.\nQed.",
    "Lemma Derivation_separableP :\n  reflect\n    (forall D, Derivation <<K; x>> D -> K <= lker D -> <<K; x>> <= lker D)%VS\n    (separable_element K x).\nProof.\napply: (iffP idP) => [sepKx D derD /subvP DK_0 | derKx_0].\n  have{} DK_0 q: q \\is a polyOver K -> map_poly D q = 0.\n    move=> /polyOverP Kq; apply/polyP=> i; apply/eqP.\n    by rewrite coef0 coef_map -memv_ker DK_0.\n  apply/subvP=> _ /Fadjoin_polyP[p Kp ->]; rewrite memv_ker.\n  rewrite (Derivation_horner derD) ?(polyOverSv sKxK) //.\n  rewrite (Derivation_separable derD sepKx) !DK_0 ?minPolyOver //.\n  by rewrite horner0 oppr0 mul0r mulr0 addr0.\napply: wlog_neg; rewrite {1}separable_nz_der negbK => /eqP pKx'_0.\npose Df := fun y => (Fadjoin_poly K x y)^`().[x].\nhave Dlin: linear Df.\n  move=> a u v; rewrite /Df linearP /= -mul_polyC derivD derivM derivC.\n  by rewrite mul0r add0r hornerD hornerM hornerC -scalerAl mul1r.\npose DlinM := GRing.isLinear.Build _ _ _ _ Df Dlin.\npose DL : {linear _ -> _} := HB.pack Df DlinM.\npose D := linfun DL; apply: base_separable.\nhave DK_0: (K <= lker D)%VS.\n  apply/subvP=> v Kv; rewrite memv_ker lfunE /= /Df Fadjoin_polyC //.\n  by rewrite derivC horner0.\nhave Dder: Derivation <<K; x>> D.\n  apply/allrelP=> u v /vbasis_mem Kx_u /vbasis_mem Kx_v; apply/eqP.\n  rewrite !lfunE /= /Df; set Px := Fadjoin_poly K x.\n  set Px_u := Px u; rewrite -(Fadjoin_poly_eq Kx_u) -/Px -/Px_u.\n  set Px_v := Px v; rewrite -(Fadjoin_poly_eq Kx_v) -/Px -/Px_v.\n  rewrite -!hornerM -hornerD -derivM.\n  rewrite /Px Fadjoin_poly_mod ?rpredM ?Fadjoin_polyOver //.\n  rewrite [in RHS](divp_eq (Px_u * Px_v) (minPoly K x)) derivD derivM.\n  by rewrite pKx'_0 mulr0 addr0 hornerD hornerM minPolyxx mulr0 add0r.\nhave{Dder DK_0}: x \\in lker D by apply: subvP Kx_x; apply: derKx_0.\napply: contraLR => K'x; rewrite memv_ker lfunE /= /Df Fadjoin_polyX //.\nby rewrite derivX hornerC oner_eq0.\nQed.",
    "Lemma separable_elementS K E x :\n  (K <= E)%VS -> separable_element K x -> separable_element E x.\nProof.\nmove=> sKE /separable_elementP[f [fK rootf sepf]]; apply/separable_elementP.\nby exists f; rewrite (polyOverSv sKE).\nQed.",
    "Lemma adjoin_separableP {K x} :\n  reflect (forall y, y \\in <<K; x>>%VS -> separable_element K y)\n          (separable_element K x).\nProof.\napply: (iffP idP) => [sepKx | -> //]; last exact: memv_adjoin.\nmove=> _ /Fadjoin_polyP[q Kq ->]; apply/Derivation_separableP=> D derD DK_0.\napply/subvP=> _ /Fadjoin_polyP[p Kp ->].\nrewrite memv_ker -(extendDerivation_id x D (mempx_Fadjoin _ Kp)).\nhave sepFyx: (separable_element <<K; q.[x]>> x).\n  by apply: (separable_elementS (subv_adjoin _ _)).\nhave KyxEqKx: (<< <<K; q.[x]>>; x>> = <<K; x>>)%VS.\n  apply/eqP; rewrite eqEsubv andbC adjoinSl ?subv_adjoin //=.\n  apply/FadjoinP/andP; rewrite memv_adjoin andbT.\n  by apply/FadjoinP/andP; rewrite subv_adjoin mempx_Fadjoin.\nhave /[!KyxEqKx] derDx := extendDerivationP derD sepFyx.\nrewrite -horner_comp (Derivation_horner derDx) ?memv_adjoin //; last first.\n  by apply: (polyOverSv (subv_adjoin _ _)); apply: polyOver_comp.\nset Dx_p := map_poly _; have Dx_p_0 t: t \\is a polyOver K -> (Dx_p t).[x] = 0.\n  move/polyOverP=> Kt; congr (_.[x] = 0): (horner0 x); apply/esym/polyP => i.\n  have /eqP Dti_0: D t`_i == 0 by rewrite -memv_ker (subvP DK_0) ?Kt.\n  by rewrite coef0 coef_map /= {1}extendDerivation_id ?subvP_adjoin.\nrewrite (Derivation_separable derDx sepKx) -/Dx_p Dx_p_0 ?polyOver_comp //.\nby rewrite add0r mulrCA Dx_p_0 ?minPolyOver ?oppr0 ?mul0r.\nQed.",
    "Lemma separable_exponent_pchar K x :\n  exists n, [pchar L].-nat n && separable_element K (x ^+ n).\nProof.\npose d := adjoin_degree K x; move: {2}d.+1 (ltnSn d) => n.\nelim: n => // n IHn in x @d *; rewrite ltnS => le_d_n.\nhave [[p pcharLp]|] := altP (separablePn_pchar K x); last by rewrite negbK; exists 1.\ncase=> g Kg defKx; have p_pr := pcharf_prime pcharLp.\nsuffices /IHn[m /andP[pcharLm sepKxpm]]: adjoin_degree K (x ^+ p) < n.\n  by exists (p * m)%N; rewrite pnatM pnatE // pcharLp pcharLm exprM.\napply: leq_trans le_d_n; rewrite -ltnS -!size_minPoly.\nhave nzKx: minPoly K x != 0 by rewrite monic_neq0 ?monic_minPoly.\nhave nzg: g != 0 by apply: contra_eqN defKx => /eqP->; rewrite comp_poly0.\napply: leq_ltn_trans (dvdp_leq nzg _) _.\n  by rewrite minPoly_dvdp // rootE -hornerXn -horner_comp -defKx minPolyxx.\nrewrite (polySpred nzKx) ltnS defKx size_comp_poly size_polyXn /=.\nsuffices g_gt1: 1 < size g by rewrite -(subnKC g_gt1) ltn_Pmulr ?prime_gt1.\napply: contra_eqT (size_minPoly K x); rewrite defKx -leqNgt => /size1_polyC->.\nby rewrite comp_polyC size_polyC; case: (_ != 0).\nQed.",
    "Lemma pcharf0_separable K : [pchar L] =i pred0 -> forall x, separable_element K x.\nProof.\nmove=> pcharL0 x; have [n /andP[pcharLn]] := separable_exponent_pchar K x.\nby rewrite (pnat_1 pcharLn (sub_in_pnat _ pcharLn)) // => p _; rewrite pcharL0.\nQed.",
    "Lemma pcharf_p_separable K x e p :\n  p \\in [pchar L] -> separable_element K x = (x \\in <<K; x ^+ (p ^ e.+1)>>%VS).\nProof.\nmove=> pcharLp; apply/idP/idP=> [sepKx | /Fadjoin_poly_eq]; last first.\n  set m := p ^ _; set f := Fadjoin_poly K _ x => Dx; apply/separable_elementP.\n  have mL0: m%:R = 0 :> L by apply/eqP; rewrite -(dvdn_pcharf pcharLp) dvdn_exp.\n  exists ('X - (f \\Po 'X^m)); split.\n  - by rewrite rpredB ?polyOver_comp ?rpredX ?polyOverX ?Fadjoin_polyOver.\n  - by rewrite rootE !hornerE horner_comp hornerXn Dx subrr.\n  rewrite unlock !(derivE, deriv_comp) -mulr_natr -rmorphMn /= mL0.\n  by rewrite !mulr0 subr0 coprimep1.\nwithout loss{e} ->: e x sepKx / e = 0.\n  move=> IH; elim: {e}e.+1 => [|e]; [exact: memv_adjoin | apply: subvP].\n  apply/FadjoinP/andP; rewrite subv_adjoin expnSr exprM (IH 0) //.\n  by have /adjoin_separableP-> := sepKx; rewrite ?rpredX ?memv_adjoin.\nset K' := <<K; x ^+ p>>%VS; have sKK': (K <= K')%VS := subv_adjoin _ _.\npose q := minPoly K' x; pose g := 'X^p - (x ^+ p)%:P.\nhave [K'g]: g \\is a polyOver K' /\\ q \\is a polyOver K'.\n  by rewrite minPolyOver rpredB ?rpredX ?polyOverX // polyOverC memv_adjoin.\nhave /dvdpP[c Dq]: 'X - x%:P %| q by rewrite dvdp_XsubCl root_minPoly.\nhave co_c_g: coprimep c g.\n  have pcharPp: p \\in [pchar {poly L}] := rmorph_pchar polyC pcharLp.\n  rewrite /g polyC_exp -!(pFrobenius_autE pcharPp) -rmorphB coprimep_expr //.\n  have: separable_poly q := separable_elementS sKK' sepKx.\n  by rewrite Dq separable_mul => /and3P[].\nhave{g K'g co_c_g} /size_poly1P[a nz_a Dc]: size c == 1.\n  suffices c_dv_g: c %| g by rewrite -(eqp_size (dvdp_gcd_idl c_dv_g)).\n  have: q %| g by rewrite minPoly_dvdp // rootE !hornerE subrr.\n  by apply: dvdp_trans; rewrite Dq dvdp_mulIl.\nrewrite {q}Dq {c}Dc mulrBr -rmorphM -rmorphN -cons_poly_def qualifE /=.\nby rewrite polyseq_cons !polyseqC nz_a /= rpredN andbCA => /and3P[/fpredMl->].\nQed.",
    "Lemma pcharf_n_separable K x n :\n  [pchar L].-nat n -> 1 < n -> separable_element K x = (x \\in <<K; x ^+ n>>%VS).\nProof.\nrewrite -pi_pdiv; set p := pdiv n => pcharLn pi_n_p.\nhave pcharLp: p \\in [pchar L] := pnatPpi pcharLn pi_n_p.\nhave <-: (n`_p)%N = n by rewrite -(eq_partn n (pcharf_eq pcharLp)) part_pnat_id.\nby rewrite p_part lognE -mem_primes pi_n_p -pcharf_p_separable.\nQed.",
    "Lemma purely_inseparable_elementP_pchar {K x} :\n  reflect (exists2 n, [pchar L].-nat n & x ^+ n \\in K)\n          (purely_inseparable_element K x).\nProof.\nrewrite /purely_inseparable_element.\ncase: ex_minnP => n /andP[pcharLn /=]; rewrite subfield_closed => sepKxn min_xn.\napply: (iffP idP) => [Kxn | [m pcharLm Kxm]]; first by exists n.\nhave{min_xn}: n <= m by rewrite min_xn ?pcharLm ?base_separable.\nrewrite leq_eqVlt => /predU1P[-> // | ltnm]; pose p := pdiv m.\nhave m_gt1: 1 < m by have [/leq_ltn_trans->] := andP pcharLn.\nhave pcharLp: p \\in [pchar L] by rewrite (pnatPpi pcharLm) ?pi_pdiv.\nhave [/p_natP[em Dm] /p_natP[en Dn]]: p.-nat m /\\ p.-nat n.\n  by rewrite -!(eq_pnat _ (pcharf_eq pcharLp)).\nrewrite Dn Dm ltn_exp2l ?prime_gt1 ?pdiv_prime // in ltnm.\nrewrite -(Fadjoin_idP Kxm) Dm -(subnKC ltnm) addSnnS expnD exprM -Dn.\nby rewrite -pcharf_p_separable.\nQed.",
    "Lemma separable_inseparable_element K x :\n  separable_element K x && purely_inseparable_element K x = (x \\in K).\nProof.\nrewrite /purely_inseparable_element; case: ex_minnP => [[|m]] //=.\nrewrite subfield_closed; case: m => /= [-> //| m _ /(_ 1)/implyP/= insepKx].\nby rewrite (negPf insepKx) (contraNF (@base_separable K x) insepKx).\nQed.",
    "Lemma base_inseparable K x : x \\in K -> purely_inseparable_element K x.\nProof. by rewrite -separable_inseparable_element => /andP[]. Qed.",
    "Lemma sub_inseparable K E x :\n    (K <= E)%VS -> purely_inseparable_element K x ->\n purely_inseparable_element E x.\nProof.\nmove/subvP=> sKE /purely_inseparable_elementP_pchar[n pcharLn /sKE Exn].\nby apply/purely_inseparable_elementP_pchar; exists n.\nQed.",
    "Lemma finite_PET : K_is_large \\/ exists z, (<< <<K; y>>; x>> = <<K; z>>)%VS.\nProof.\nhave [-> | /cyclic_or_large[|[a Dxa]]] := eqVneq x 0; first 2 [by left].\n  by rewrite addv0 subfield_closed; right; exists y.\nhave [-> | /cyclic_or_large[|[b Dyb]]] := eqVneq y 0; first 2 [by left].\n  by rewrite addv0 subfield_closed; right; exists x.\npose h0 (ij : 'I_a.+1 * 'I_b.+1) := x ^+ ij.1 * y ^+ ij.2.\npose H := <<[set ij | h0 ij == 1%R]>>%G; pose h (u : coset_of H) := h0 (repr u).\nhave h0M: {morph h0: ij1 ij2 / (ij1 * ij2)%g >-> ij1 * ij2}.\n  by rewrite /h0 => [] [i1 j1] [i2 j2] /=; rewrite mulrACA -!exprD !expr_mod.\nhave memH ij: (ij \\in H) = (h0 ij == 1).\n  rewrite /= gen_set_id ?inE //; apply/group_setP; rewrite inE [h0 _]mulr1.\n  by split=> // ? ? /[!(inE, h0M)] /eqP-> /eqP->; rewrite mulr1.\nhave nH ij: ij \\in 'N(H)%g.\n  by apply/(subsetP (cent_sub _))/centP=> ij1 _; congr (_, _); rewrite Zp_mulgC.\nhave hE ij: h (coset H ij) = h0 ij.\n  rewrite /h val_coset //; case: repr_rcosetP => ij1.\n  by rewrite memH h0M => /eqP->; rewrite mul1r.\nhave h1: h 1%g = 1 by rewrite /h repr_coset1 [h0 _]mulr1.\nhave hM: {morph h: u v / (u * v)%g >-> u * v}.\n  by do 2![move=> u; have{u} [? _ ->] := cosetP u]; rewrite -morphM // !hE h0M.\nhave /cyclicP[w defW]: cyclic [set: coset_of H].\n  apply: field_mul_group_cyclic (in2W hM) _ => u _; have [ij _ ->] := cosetP u.\n  by split=> [/eqP | -> //]; rewrite hE -memH => /coset_id.\nhave Kw_h ij t: h0 ij = t -> t \\in <<K; h w>>%VS.\n  have /cycleP[k Dk]: coset H ij \\in <[w]>%g by rewrite -defW inE.\n  rewrite -hE {}Dk => <-; elim: k => [|k IHk]; first by rewrite h1 rpred1.\n  by rewrite expgS hM rpredM // memv_adjoin.\nright; exists (h w); apply/eqP; rewrite eqEsubv !(sameP FadjoinP andP).\nrewrite subv_adjoin (subv_trans (subv_adjoin K y)) ?subv_adjoin //=.\nrewrite (Kw_h (0, inZp 1)) 1?(Kw_h (inZp 1, 0)) /h0 ?mulr1 ?mul1r ?expr_mod //=.\nby rewrite rpredM ?rpredX ?memv_adjoin // subvP_adjoin ?memv_adjoin.\nQed.",
    "Lemma Primitive_Element_Theorem : exists z, (<< <<K; y>>; x>> = <<K; z>>)%VS.\nProof.\nhave /polyOver_subvs[p Dp]: minPoly K x \\is a polyOver K := minPolyOver K x.\nhave nz_pKx: minPoly K x != 0 by rewrite monic_neq0 ?monic_minPoly.\nhave{nz_pKx} nz_p: p != 0 by rewrite Dp map_poly_eq0 in nz_pKx.\nhave{Dp} px0: root (map_poly vsval p) x by rewrite -Dp root_minPoly.\nhave [q0 [Kq0 q0y0 sepKq0]] := separable_elementP sepKy.\nhave /polyOver_subvs[q Dq]: minPoly K y \\is a polyOver K := minPolyOver K y.\nhave qy0: root (map_poly vsval q) y by rewrite -Dq root_minPoly.\nhave sep_pKy: separable_poly (minPoly K y).\n  by rewrite (dvdp_separable _ sepKq0) ?minPoly_dvdp.\nhave{sep_pKy} sep_q: separable_poly q by rewrite Dq separable_map in sep_pKy.\nhave [r nz_r PETr] := large_field_PET nz_p px0 qy0 sep_q.\nhave [[s [Us Ks /ltnW leNs]] | //] := finite_PET (size r).\nhave{s Us leNs} /allPn[t {}/Ks Kt nz_rt]: ~~ all (root r) s.\n  by apply: contraTN leNs; rewrite -ltnNge => /max_poly_roots->.\nhave{PETr} [/= [p1 Dx] [q1 Dy]] := PETr (Subvs Kt) nz_rt.\nset z := t * y - x in Dx Dy; exists z; apply/eqP.\nrewrite eqEsubv !(sameP FadjoinP andP) subv_adjoin.\nhave Kz_p1z (r1 : {poly subvs_of K}): (map_poly vsval r1).[z] \\in <<K; z>>%VS.\n  rewrite rpred_horner ?memv_adjoin ?(polyOverSv (subv_adjoin K z)) //.\n  by apply/polyOver_subvs; exists r1.\nrewrite -{1}Dx -{1}Dy !{Dx Dy}Kz_p1z /=.\nrewrite (subv_trans (subv_adjoin K y)) ?subv_adjoin // rpredB ?memv_adjoin //.\nby rewrite subvP_adjoin // rpredM ?memv_adjoin ?subvP_adjoin.\nQed.",
    "Lemma adjoin_separable : separable_element <<K; y>> x -> separable_element K x.\nProof.\nhave /Derivation_separableP derKy := sepKy => /Derivation_separableP derKy_x.\nhave [z defKz] := Primitive_Element_Theorem.\nsuffices /adjoin_separableP: separable_element K z.\n  by apply; rewrite -defKz memv_adjoin.\napply/Derivation_separableP=> D; rewrite -defKz => derKxyD DK_0.\nsuffices derKyD: Derivation <<K; y>>%VS D by rewrite derKy_x // derKy.\nby apply: DerivationS derKxyD; apply: subv_adjoin.\nQed.",
    "Lemma strong_Primitive_Element_Theorem K x y :\n    separable_element <<K; x>> y ->\n  exists2 z : L, (<< <<K; y>>; x>> = <<K; z>>)%VS\n               & separable_element K x -> separable_element K y.\nProof.\nmove=> sepKx_y; have [n /andP[pcharLn sepKyn]] := separable_exponent_pchar K y.\nhave adjK_C z t: (<<<<K; z>>; t>> = <<<<K; t>>; z>>)%VS.\n  by rewrite !agenv_add_id -!addvA (addvC <[_]>%VS).\nhave [z defKz] := Primitive_Element_Theorem x sepKyn.\nexists z => [|/adjoin_separable->]; rewrite ?sepKx_y // -defKz.\nhave [|n_gt1|-> //] := ltngtP n 1; first by case: (n) pcharLn.\napply/eqP; rewrite !(adjK_C _ x) eqEsubv; apply/andP.\nsplit; apply/FadjoinP/andP; rewrite subv_adjoin ?rpredX ?memv_adjoin //=.\nby rewrite -pcharf_n_separable ?sepKx_y.\nQed.",
    "Lemma separable_add K x y :\n  separable_element K x -> separable_element K y -> separable_element K (x + y).\nProof.\nmove/(separable_elementS (subv_adjoin K y))=> sepKy_x sepKy.\nhave [z defKz] := Primitive_Element_Theorem x sepKy.\nhave /(adjoin_separableP _): x + y \\in <<K; z>>%VS.\n  by rewrite -defKz rpredD ?memv_adjoin // subvP_adjoin ?memv_adjoin.\napply; apply: adjoin_separable sepKy (adjoin_separable sepKy_x _).\nby rewrite defKz base_separable ?memv_adjoin.\nQed.",
    "Lemma separable_sum I r (P : pred I) (v_ : I -> L) K :\n    (forall i, P i -> separable_element K (v_ i)) ->\n  separable_element K (\\sum_(i <- r | P i) v_ i).\nProof.\nmove=> sepKi.\nby elim/big_ind: _; [apply/base_separable/mem0v | apply: separable_add |].\nQed.",
    "Lemma inseparable_add K x y :\n    purely_inseparable_element K x -> purely_inseparable_element K y ->\n  purely_inseparable_element K (x + y).\nProof.\nhave insepP := purely_inseparable_elementP_pchar.\nmove=> /insepP[n pcharLn Kxn] /insepP[m pcharLm Kym]; apply/insepP.\nhave pcharLnm: [pchar L].-nat (n * m)%N by rewrite pnatM pcharLn.\nby exists (n * m)%N; rewrite ?exprDn_pchar // {2}mulnC !exprM memvD // rpredX.\nQed.",
    "Lemma inseparable_sum I r (P : pred I) (v_ : I -> L) K :\n    (forall i, P i -> purely_inseparable_element K (v_ i)) ->\n  purely_inseparable_element K (\\sum_(i <- r | P i) v_ i).\nProof.\nmove=> insepKi.\nby elim/big_ind: _; [apply/base_inseparable/mem0v | apply: inseparable_add |].\nQed.",
    "Lemma separableP {K E} :\n  reflect (forall y, y \\in E -> separable_element K y) (separable K E).\nProof.\napply/(iffP idP)=> [/allP|] sepK_E; last by apply/allP=> x /vbasis_mem/sepK_E.\nmove=> y /coord_vbasis->; apply/separable_sum=> i _.\nhave: separable_element K (vbasis E)`_i by apply/sepK_E/memt_nth.\nby move/adjoin_separableP; apply; rewrite rpredZ ?memv_adjoin.\nQed.",
    "Lemma purely_inseparableP {K E} :\n  reflect (forall y, y \\in E -> purely_inseparable_element K y)\n          (purely_inseparable K E).\nProof.\napply/(iffP idP)=> [/allP|] sep'K_E; last by apply/allP=> x /vbasis_mem/sep'K_E.\nmove=> y /coord_vbasis->; apply/inseparable_sum=> i _.\nhave: purely_inseparable_element K (vbasis E)`_i by apply/sep'K_E/memt_nth.\ncase/purely_inseparable_elementP_pchar=> n pcharLn K_Ein.\nby apply/purely_inseparable_elementP_pchar; exists n; rewrite // exprZn rpredZ.\nQed.",
    "Lemma adjoin_separable_eq K x : separable_element K x = separable K <<K; x>>%VS.\nProof. exact: sameP adjoin_separableP separableP. Qed.",
    "Lemma separable_inseparable_decomposition E K :\n  {x | x \\in E /\\ separable_element K x & purely_inseparable <<K; x>> E}.\nProof.\nwithout loss sKE: K / (K <= E)%VS.\n  case/(_ _ (capvSr K E)) => x [Ex sepKEx] /purely_inseparableP sep'KExE.\n  exists x; first by split; last exact/(separable_elementS _ sepKEx)/capvSl.\n  apply/purely_inseparableP=> y /sep'KExE; apply: sub_inseparable.\n  exact/adjoinSl/capvSl.\npose E_ i := (vbasis E)`_i; pose fP i := separable_exponent_pchar K (E_ i).\npose f i := E_ i ^+ ex_minn (fP i); pose s := mkseq f (\\dim E).\npose K' := <<K & s>>%VS.\nhave sepKs: all (separable_element K) s.\n  by rewrite all_map /f; apply/allP=> i _ /=; case: ex_minnP => m /andP[].\nhave [x sepKx defKx]: {x | x \\in E /\\ separable_element K x & K' = <<K; x>>%VS}.\n  have: all [in E] s.\n    rewrite all_map; apply/allP=> i; rewrite mem_iota => ltis /=.\n    by rewrite rpredX // vbasis_mem // memt_nth.\n  rewrite {}/K'; elim/last_ind: s sepKs => [|s t IHs].\n    by exists 0; [rewrite base_separable mem0v | rewrite adjoin_nil addv0].\n  rewrite adjoin_rcons !all_rcons => /andP[sepKt sepKs] /andP[/= Et Es].\n  have{IHs sepKs Es} [y [Ey sepKy] ->{s}] := IHs sepKs Es.\n  have /sig_eqW[x defKx] := Primitive_Element_Theorem t sepKy.\n  exists x; [split | exact: defKx].\n    suffices: (<<K; x>> <= E)%VS by case/FadjoinP.\n    by rewrite -defKx !(sameP FadjoinP andP) sKE Ey Et.\n  apply/adjoin_separableP=> z; rewrite -defKx => Kyt_z.\n  apply: adjoin_separable sepKy _; apply: adjoin_separableP Kyt_z.\n  exact: separable_elementS (subv_adjoin K y) sepKt.\nexists x; rewrite // -defKx; apply/(all_nthP 0)=> i; rewrite size_tuple => ltiE.\napply/purely_inseparable_elementP_pchar.\nexists (ex_minn (fP i)); first by case: ex_minnP => n /andP[].\nby apply/seqv_sub_adjoin/map_f; rewrite mem_iota.\nQed.",
    "Lemma separable_generator_mem E K : separable_generator K E \\in E.\nProof. by rewrite /separable_generator; case: (locked _) => ? []. Qed.",
    "Lemma separable_generatorP E K : separable_element K (separable_generator K E).\nProof. by rewrite /separable_generator; case: (locked _) => ? []. Qed.",
    "Lemma separable_generator_maximal E K :\n  purely_inseparable <<K; separable_generator K E>> E.\nProof. by rewrite /separable_generator; case: (locked _). Qed.",
    "Lemma sub_adjoin_separable_generator E K :\n  separable K E -> (E <= <<K; separable_generator K E>>)%VS.\nProof.\nmove/separableP=> sepK_E; apply/subvP=> v Ev.\nrewrite -separable_inseparable_element.\nhave /purely_inseparableP-> // := separable_generator_maximal E K.\nby rewrite (separable_elementS _ (sepK_E _ Ev)) // subv_adjoin.\nQed.",
    "Lemma eq_adjoin_separable_generator E K :\n    separable K E -> (K <= E)%VS ->\n  E = <<K; separable_generator K E>>%VS :> {vspace _}.\nProof.\nmove=> sepK_E sKE; apply/eqP; rewrite eqEsubv sub_adjoin_separable_generator //.\nby apply/FadjoinP/andP; rewrite sKE separable_generator_mem.\nQed.",
    "Lemma separable_refl K : separable K K.\nProof. exact/separableP/base_separable. Qed.",
    "Lemma separable_trans M K E : separable K M -> separable M E -> separable K E.\nProof.\nmove/sub_adjoin_separable_generator.\nset x := separable_generator K M => sMKx /separableP sepM_E.\napply/separableP => w /sepM_E/(separable_elementS sMKx).\ncase/strong_Primitive_Element_Theorem => _ _ -> //.\nexact: separable_generatorP.\nQed.",
    "Lemma separableS K1 K2 E2 E1 : \n  (K1 <= K2)%VS -> (E2 <= E1)%VS -> separable K1 E1 -> separable K2 E2.\nProof.\nmove=> sK12 /subvP sE21 /separableP sepK1_E1.\nby apply/separableP=> y /sE21/sepK1_E1/(separable_elementS sK12).\nQed.",
    "Lemma separableSl K M E : (K <= M)%VS -> separable K E -> separable M E.\nProof. by move/separableS; apply. Qed.",
    "Lemma separableSr K M E : (M <= E)%VS -> separable K E -> separable K M.\nProof. exact: separableS. Qed.",
    "Lemma separable_Fadjoin_seq K rs :\n  all (separable_element K) rs -> separable K <<K & rs>>.\nProof.\nelim/last_ind: rs => [|s x IHs] in K *.\n  by rewrite adjoin_nil subfield_closed separable_refl.\nrewrite all_rcons adjoin_rcons => /andP[sepKx /IHs/separable_trans-> //].\nby rewrite -adjoin_separable_eq (separable_elementS _ sepKx) ?subv_adjoin_seq.\nQed.",
    "Lemma purely_inseparable_refl K : purely_inseparable K K.\nProof. by apply/purely_inseparableP; apply: base_inseparable. Qed.",
    "Lemma purely_inseparable_trans M K E :\n  purely_inseparable K M -> purely_inseparable M E -> purely_inseparable K E.\nProof.\nhave insepP := purely_inseparableP => /insepP insepK_M /insepP insepM_E.\nhave insepPe := purely_inseparable_elementP_pchar.\napply/insepP=> x /insepM_E/insepPe[n pcharLn /insepK_M/insepPe[m pcharLm Kxnm]].\nby apply/insepPe; exists (n * m)%N; rewrite ?exprM // pnatM pcharLn pcharLm.\nQed.",
    "Lemma mk_monicE : mk_monic h = h.\nProof. by rewrite /mk_monic !hI. Qed.",
    "Lemma coprimep_unit (p : {poly %/ h}) : p != 0%R -> coprimep hQ p.\nProof.\nmove=> pNZ.\nrewrite irreducible_poly_coprime //; last first.\n  by case: hI; rewrite mk_monicE.\napply: contra pNZ => H; case: eqP => // /eqP /dvdp_leq /(_ H).\nby rewrite leqNgt size_mk_monic.\nQed.",
    "Lemma qpoly_mulVp (p : {poly %/ h}) : p != 0%R -> (qpoly_inv p * p = 1)%R.\nProof. by move=> pNZ; apply/qpoly_mulVz/coprimep_unit. Qed.",
    "Lemma qpoly_inv0 : qpoly_inv 0%R = 0%R :> {poly %/ h}.\nProof.\nrewrite /qpoly_inv /= coprimep0 -size_poly_eq1.\nrewrite [in X in X == _]mk_monicE.\nby have [[]] := hI; case: size => [|[]].\nQed.",
    "Lemma card_qfpoly : #|{poly %/ h with hI}| = #|R| ^ (size h).-1.\nProof. by rewrite card_monic_qpoly ?hI. Qed.",
    "Lemma card_qfpoly_gt1 : 1 < #|{poly %/ h with hI}|.\nProof. by have := card_finNzRing_gt1 {poly %/ h with hI}. Qed.",
    "Lemma in_qpoly_comp_horner (p q : {poly R}) :\n in_qpoly h (p \\Po q) =\n     (map_poly (qpolyC h) p).[in_qpoly h q].\nProof.\nhave hQM := monic_mk_monic h.\nrewrite comp_polyE /map_poly poly_def horner_sum /=.\napply: val_inj.\nrewrite /= rmodp_sum // poly_of_qpoly_sum.\napply: eq_bigr => i  _.\nrewrite !hornerE /in_qpoly /=.\nrewrite mul_polyC // !rmodpZ //=.\nby rewrite poly_of_qpolyX /= rmodp_id // rmodpX // rmodp_id.\nQed.",
    "Lemma map_poly_div_inj : injective (map_poly (qpolyC h)).\nProof.\napply: map_inj_poly => [x y /val_eqP /eqP /polyC_inj //|].\nby rewrite qpolyC0.\nQed.",
    "Lemma map_fpoly_div_inj (R : idomainType) (h : {poly R})\n    (hMI : monic_irreducible_poly h) :\n  injective (map_poly (qfpoly_const hMI)).\nProof. by apply: (@map_poly_div_inj R h). Qed.",
    "Lemma primitive_polyP (p : {poly F}) :\n  reflect\n    (let v := #|{poly %/ p}|.-1 in\n      [/\\ monic_irreducible_poly p,\n          p %| 'X^v - 1 &\n          forall n, 0 < n < v -> ~~ (p %| 'X^n - 1)])\n    (primitive_poly p).\nProof.\napply: (iffP and4P) => [[H1 H2 H3 /forallP H4] v|[[H1 H2] H3 H4]]; split => //.\n- by split => //; apply/irreducibleP.\n- move=> n /andP[n_gt0 nLv]; apply/negP => /(implyP (H4 (Ordinal nLv))) /=.\n  by rewrite eqn0Ngt n_gt0.\n- by apply/irreducibleP.\napply/forallP=> [] [[|n] Hn] /=; apply/implyP => pDX //.\nby case/negP: (H4 n.+1 Hn).\nQed.",
    "Lemma primitive_mi : monic_irreducible_poly h.\nProof. by case/primitive_polyP: Hh. Qed.",
    "Lemma primitive_poly_in_qpoly_eq0 p : (in_qpoly h p == 0) = (h %| p).\nProof.\nhave hM : h \\is monic by case/and4P:Hh.\nhave hMi : monic_irreducible_poly h by apply: primitive_mi.\napply/eqP/idP => [/val_eqP /= | hDp].\n  by rewrite -Pdiv.IdomainMonic.modpE mk_monicE.\nby apply/val_eqP; rewrite /= -Pdiv.IdomainMonic.modpE mk_monicE.\nQed.",
    "Lemma card_primitive_qpoly : #|{poly %/ h}|= #|F| ^ (size h).-1.\nProof. by rewrite card_monic_qpoly ?primitive_mi. Qed.",
    "Lemma qX_neq0 : 'qX != 0 :> qT.\nProof.\napply/eqP => /val_eqP/=.\nby rewrite [rmodp _ _]qpolyXE ?polyX_eq0 //; case: primitive_mi.\nQed.",
    "Lemma qX_in_unit : ('qX : qT) \\in GRing.unit.\nProof. by rewrite unitfE /= qX_neq0. Qed.",
    "Lemma dvdp_order n : (h %| 'X^n - 1) = (gX ^+ n == 1)%g.\nProof.\nhave [hM hI] := primitive_mi.\nhave eqr_add2r (r : nzRingType) (a b c : r) : (a + c == b + c) = (a == b).\n  by apply/eqP/eqP => [H|->//]; rewrite -(addrK c a) H addrK.\nrewrite -val_eqE /= val_unitX /= -val_eqE /=.\nrewrite (poly_of_qpolyX) qpolyXE // mk_monicE //.\nrewrite -[in RHS](subrK 1 'X^n) rmodpD //.\nrewrite [rmodp 1 h]rmodp_small ?size_poly1 //.\nrewrite -[1%:P]add0r polyC1 /= eqr_add2r.\nby rewrite dvdpE /=; apply/rmodp_eq0P/eqP.\nQed.",
    "Lemma gX_order : #[gX]%g  = (#|qT|).-1.\nProof.\nhave /primitive_polyP[Hp1 Hp2 Hp3] := Hh.\nset n := _.-1 in Hp2 Hp3 *.\nhave n_gt0 : 0 < n by rewrite ltn_predRL card_qfpoly_gt1.\nhave [hM hI] := primitive_mi.\nhave gX_neq1 : gX != 1%g.\n  apply/eqP/val_eqP/eqP/val_eqP=> /=.\n  rewrite [X in X != _]qpolyXE /= //.\n  by apply/eqP=> Hx1; have := @size_polyX F; rewrite Hx1 size_poly1.\nhave Hx : (gX ^+ n)%g = 1%g by apply/eqP; rewrite -dvdp_order.\nhave Hf i : 0 < i < n -> (gX ^+ i != 1)%g by rewrite -dvdp_order => /Hp3.\nhave o_gt0 : 0 < #[gX]%g by rewrite order_gt0.\nhave : n <= #[gX]%g.\n  rewrite leqNgt; apply/negP=> oLx.\n  have /Hf/eqP[] : 0 < #[gX]%g < n by rewrite o_gt0.\n  by rewrite expg_order.\ncase: ltngtP => nLo _ //.\nhave: uniq (path.traject (mulg gX) 1%g #[gX]%g).\n  by apply/card_uniqP; rewrite path.size_traject -(eq_card (cycle_traject gX)).\ncase: #[gX]%g o_gt0 nLo => //= n1 _ nLn1 /andP[/negP[]].\napply/path.trajectP; exists n.-1; first by rewrite prednK.\nrewrite -iterSr prednK // -[LHS]Hx.\nby elim: (n) => //= n2 <-; rewrite expgS.\nQed.",
    "Lemma gX_all : <[gX]>%g = [set: {unit qT}]%G.\nProof.\napply/eqP; rewrite eqEcard; apply/andP; split.\n  by apply/subsetP=> i; rewrite inE.\nrewrite leq_eqVlt; apply/orP; left; apply/eqP.\nrewrite -orderE gX_order card_qfpoly -[in RHS](mk_monicE primitive_mi).\nrewrite -card_qpoly -(cardC1 (0 : {poly %/ h with primitive_mi})).\nrewrite cardsT card_sub.\nby apply: eq_card => x; rewrite [LHS]unitfE.\nQed.",
    "Lemma qlogp_lt p : qlogp p < #|qT|.-1.\nProof. by rewrite /qlogp; case: pickP. Qed.",
    "Lemma qlogp_qX (p : qT) : p != 0 -> 'qX ^+ (qlogp p) = p.\nProof.\nmove=> p_neq0.\nhave Up : p \\in GRing.unit by rewrite unitfE.\npose gp : {unit qT}:= FinRing.unit _ Up.\nhave /cyclePmin[i iLc iX] : gp \\in <[gX]>%g by rewrite gX_all inE.\nrewrite gX_order in iLc.\nrewrite /qlogp; case: pickP => [j /eqP//|/(_ (Ordinal iLc))] /eqP[].\nby have /val_eqP/eqP/= := iX; rewrite FinRing.val_unitX.\nQed.",
    "Lemma qX_order_card : 'qX ^+ (#|qT|).-1 = 1 :> qT.\nProof.\nhave /primitive_polyP [_ Hd _] := Hh.\nrewrite dvdp_order in Hd.\nhave -> : 1 = val (1%g : {unit qT}) by [].\nby rewrite -(eqP Hd) val_unitX.\nQed.",
    "Lemma qX_order_dvd (i : nat) : 'qX ^+ i = 1  :> qT -> (#|qT|.-1 %| i)%N.\nProof.\nrewrite -gX_order cyclic.order_dvdn => Hd.\nby apply/eqP/val_inj; rewrite /= -Hd val_unitX.\nQed.",
    "Lemma qlogp0 : qlogp 0 = 0%N.\nProof.\nrewrite /qlogp; case: pickP => //= x.\nby rewrite (expf_eq0 ('qX : qT))  (negPf qX_neq0) andbF.\nQed.",
    "Lemma qlogp1 : qlogp 1 = 0%N.\nProof.\ncase: (qlogp 1 =P 0%N) => // /eqP log1_neq0.\nhave := qlogp_lt 1; rewrite ltnNge => /negP[].\napply: dvdn_leq; first by rewrite lt0n.\nby rewrite qX_order_dvd // qlogp_qX ?oner_eq0.\nQed.",
    "Lemma qlogp_eq0 (q : qT) : (qlogp q == 0%N) = (q == 0) || (q == 1).\nProof.\ncase: (q =P 0) => [->|/eqP q_neq0]/=; first by rewrite qlogp0.\ncase: (q =P 1) => [->|/eqP q_neq1]/=; first by rewrite qlogp1.\nrewrite /qlogp; case: pickP => [x|/(_ (Ordinal (qlogp_lt q)))] /=.\n  by case: ((x : nat) =P 0%N) => // ->; rewrite expr0 eq_sym (negPf q_neq1).\nby rewrite qlogp_qX // eqxx.\nQed.",
    "Lemma qX_exp_neq0 i : 'qX ^+ i != 0 :> qT.\nProof.  by rewrite expf_eq0 negb_and qX_neq0 orbT. Qed.",
    "Lemma qX_exp_inj i j :\n  i < #|qT|.-1 -> j < #|qT|.-1 -> 'qX ^+ i = 'qX ^+ j :> qT -> i = j.\nProof.\nwlog iLj : i j / (i <= j)%N => [Hw|] iL jL Hqx.\n  case: (ltngtP i j)=> // /ltnW iLj; first by apply: Hw.\n  by apply/sym_equal/Hw.\nsuff ji_eq0 : (j - i = 0)%N by rewrite -(subnK iLj) ji_eq0.\ncase: ((j - i)%N =P 0%N) => // /eqP ji_neq0.\nhave : j - i < #|qT|.-1 by apply: leq_ltn_trans (leq_subr _ _) jL.\nrewrite ltnNge => /negP[].\napply: dvdn_leq; first by rewrite lt0n.\nhave HqXi : 'qX ^+ i != 0 :> qT by rewrite expf_eq0 (negPf qX_neq0) andbF.\nby apply/qX_order_dvd/(mulIf HqXi); rewrite mul1r -exprD subnK.\nQed.",
    "Lemma powX_eq_mod i j : i = j %[mod #|qT|.-1] -> 'qX ^+ i = 'qX ^+ j :> qT.\nProof.\nset n := _.-1 => iEj.\nrewrite [i](divn_eq i n) [j](divn_eq j n) !exprD ![(_ * n)%N]mulnC.\nby rewrite !exprM !qX_order_card !expr1n !mul1r iEj.\nQed.",
    "Lemma qX_expK i : i < #|qT|.-1 -> qlogp ('qX ^+ i) = i.\nProof.\nmove=> iLF; apply: qX_exp_inj => //; first by apply: qlogp_lt.\nby rewrite qlogp_qX // expf_eq0 (negPf qX_neq0) andbF.\nQed.",
    "Lemma qlogpD (q1 q2 : qT) :\n  q1 != 0 -> q2 != 0 ->qlogp (q1 * q2) = ((qlogp q1 + qlogp q2) %% #|qT|.-1)%N.\nProof.\nmove=> q1_neq0 q2_neq0.\napply: qX_exp_inj; [apply: qlogp_lt => // | rewrite ltn_mod // |].\nrewrite -[RHS]mul1r -(expr1n _ ((qlogp q1 + qlogp q2) %/ #|qT|.-1)).\nrewrite -qX_order_card -exprM mulnC -exprD -divn_eq exprD !qlogp_qX //.\nby rewrite mulf_eq0 negb_or q1_neq0.\nQed.",
    "Lemma plogp_lt (p q : {poly F}) : 2 < size p -> plogp p q < #|{poly %/ p}|.-1.\nProof.\nmove=> /ltnW size_gt1.\nrewrite /plogp.\ncase (boolP (primitive_poly p)) => // Hh; first by apply: qlogp_lt.\nby rewrite ltn_predRL (card_finNzRing_gt1 {poly %/ p}).\nQed.",
    "Lemma plogp_X (p q : {poly F}) :\n  2 < size p -> primitive_poly p -> ~~ (p %| q) -> p %| q - 'X ^+ plogp p q.\nProof.\nmove=> sp_gt2 Hh pNDq.\nrewrite /plogp.\ncase (boolP (primitive_poly p)) => // Hh'; last by case/negP: Hh'.\nhave pM : p \\is monic by case/and4P: Hh'.\nhave pMi : monic_irreducible_poly p by apply: primitive_mi.\nset q' : {poly %/ p with primitive_mi Hh'} := in_qpoly p q.\napply/modp_eq0P; rewrite modpD modpN; apply/eqP; rewrite subr_eq0; apply/eqP.\nrewrite !Pdiv.IdomainMonic.modpE //=.\nsuff /val_eqP/eqP/= : 'qX ^+ qlogp q' = q'.\n  rewrite /= [X in rmodp _ X]mk_monicE // => <-.\n  by rewrite poly_of_qpolyX /= mk_monicE // [rmodp 'X p]rmodp_small ?size_polyX.\napply: qlogp_qX => //.\napply/eqP=> /val_eqP/eqP.\nrewrite /= mk_monicE // => /rmodp_eq0P; rewrite -dvdpE => pDq.\nby case/negP: pNDq.\nQed.",
    "Lemma plogp0 (p : {poly F}) : 2 < size p -> plogp p 0 = 0%N.\nProof.\nmove=> sp_gt2; rewrite /plogp; case (boolP (primitive_poly p)) => // i.\nby rewrite in_qpoly0 qlogp0.\nQed.",
    "Lemma plogp1 (p : {poly F}) : 2 < size p -> plogp p 1 = 0%N.\nProof.\nmove=> sp_gt2; rewrite /plogp; case (boolP (primitive_poly p)) => // i.\nsuff->: in_qpoly p 1 = 1 by apply: qlogp1.\napply/val_eqP/eqP; apply: in_qpoly_small.\nrewrite mk_monicE ?size_poly1 ?(leq_trans _ sp_gt2) //.\nby apply: primitive_mi.\nQed.",
    "Lemma plogp_div_eq0 (p q : {poly F}) :\n  2 < size p -> (p %| q) -> plogp p q = 0%N.\nProof.\nmove=> sp_gt2; rewrite /plogp; case (boolP (primitive_poly p)) => // i pDq.\nsuff-> : in_qpoly p q = 0 by apply: qlogp0.\nby apply/eqP; rewrite primitive_poly_in_qpoly_eq0.\nQed.",
    "Lemma plogpD (p q1 q2 : {poly F}) :\n  2 < size p -> primitive_poly p -> ~~ (p %| q1) -> ~~ (p %| q2) ->\n  plogp p (q1 * q2) = ((plogp p q1 + plogp p q2) %% #|{poly %/ p}|.-1)%N.\nProof.\nmove=> sp_gt2 Pp pNDq1 pNDq2.\nrewrite /plogp; case (boolP (primitive_poly p)) => [|/negP//] i /=.\nhave pmi := primitive_mi i.\nby rewrite rmorphM qlogpD //= primitive_poly_in_qpoly_eq0.\nQed.",
    "Lemma nz2: 2 != 0 :> L.\nProof.\n  apply/eqP=> pchar2; apply: conj_nt => e; apply/eqP/idPn=> eJ.\n  have opp_id x: - x = x :> L.\n    by apply/esym/eqP; rewrite -addr_eq0 -mulr2n -mulr_natl pchar2 mul0r.\n  have{} pchar2: 2%N \\in [pchar L] by apply/eqP.\n  without loss{eJ} eJ: e / conj e = e + 1.\n    move/(_ (e / (e + conj e))); apply.\n    rewrite fmorph_div rmorphD /= conjK -{1}[conj e](addNKr e) mulrDl.\n    by rewrite opp_id (addrC e) divff // addr_eq0 opp_id.\n  pose a := e * conj e; have aJ: conj a = a by rewrite rmorphM /= conjK mulrC.\n  have [w Dw] := @solve_monicpoly _ 2%N (nth 0 [:: e * a; - 1]) isT.\n  have{} Dw: w ^+ 2 + w = e * a.\n    by rewrite Dw !big_ord_recl big_ord0 /= mulr1 mulN1r addr0 subrK.\n  pose b := w + conj w; have bJ: conj b = b by rewrite rmorphD /= conjK addrC.\n  have Db2: b ^+ 2 + b = a.\n    rewrite -pFrobenius_autE // rmorphD addrACA Dw /= pFrobenius_autE -rmorphXn.\n    by rewrite -rmorphD Dw rmorphM /= aJ eJ -mulrDl -{1}[e]opp_id addKr mul1r.\n  have /eqP[] := oner_eq0 L; apply: (addrI b); rewrite addr0 -{2}bJ.\n  have: (b + e) * (b + conj e) == 0.\n    \n    rewrite mulrDl 2![_ * (b + _)]mulrDr -/a.\n    rewrite addrA addr_eq0 opp_id (mulrC e) -addrA.\n    by rewrite -mulrDr eJ addrAC -{2}[e]opp_id subrr add0r mulr1 Db2.\n  rewrite mulf_eq0 !addr_eq0 !opp_id => /pred2P[] -> //.\n  by rewrite {2}eJ rmorphD rmorph1.\nQed.",
    "Lemma mul2I: injective (fun z : L => z *+ 2).\nProof.\n  have nz2 := nz2.\n  by move=> x y; rewrite /= -mulr_natl -(mulr_natl y) => /mulfI->.\nQed.",
    "Lemma sqrtK x: sqrt x ^+ 2 = x.\nProof.\n  rewrite /sqrt; case: sig_eqW => /= y ->.\n  by rewrite !big_ord_recl big_ord0 /= mulr1 mul0r !addr0.\nQed.",
    "Lemma sqrtE x y: y ^+ 2 = x -> {b : bool | y = (-1) ^+ b * sqrt x}.\nProof.\n  move=> Dx; exists (y != sqrt x); apply/eqP; rewrite mulr_sign if_neg.\n  by case: ifPn => //; apply/implyP; rewrite implyNb -eqf_sqr Dx sqrtK.\nQed.",
    "Lemma sqrMi x: (i * x) ^+ 2 = - x ^+ 2.\nProof. by rewrite exprMn sqrtK mulN1r. Qed.",
    "Lemma iJ : conj i = - i.\nProof.\n  have nz2 := nz2.\n  have /sqrtE[b]: conj i ^+ 2 = - 1 by rewrite -rmorphXn /= sqrtK rmorphN1.\n  rewrite mulr_sign -/i; case: b => // Ri.\n  case: conj_nt => z; wlog zJ: z / conj z = - z.\n    move/(_ (z - conj z)); rewrite !rmorphB conjK opprB => zJ.\n    by apply/mul2I/(canRL (subrK _)); rewrite -addrA zJ // addrC subrK.\n  have [-> | nz_z] := eqVneq z 0; first exact: rmorph0.\n  have [u Ru [v Rv Dz]]:\n    exists2 u, conj u = u & exists2 v, conj v = v & (u + z * v) ^+ 2 = z.\n  - pose y := sqrt z; exists ((y + conj y) / 2).\n      by rewrite fmorph_div rmorphD /= conjK addrC rmorph_nat.\n    exists ((y - conj y) / (z *+ 2)).\n      rewrite fmorph_div rmorphMn /= zJ mulNrn invrN mulrN -mulNr rmorphB opprB.\n      by rewrite conjK.\n    rewrite -(mulr_natl z) invfM (mulrC z) !mulrA divfK // -mulrDl addrACA.\n    \n    by rewrite subrr addr0 -mulr2n -[_ *+ 2]mulr_natr mulfK ?Neq0 ?sqrtK.\n  suff u0: u = 0 by rewrite -Dz u0 add0r rmorphXn rmorphM /= Rv zJ mulNr sqrrN.\n  suff [b Du]: exists b : bool, u = (-1) ^+ b * i * z * v.\n    apply: mul2I; rewrite mul0rn mulr2n -{2}Ru.\n    by rewrite Du !rmorphM /= rmorph_sign Rv Ri zJ !mulrN mulNr subrr.\n  have/eqP:= zJ; rewrite -addr_eq0 -{1 2}Dz rmorphXn rmorphD rmorphM /= Ru Rv zJ.\n  rewrite mulNr sqrrB sqrrD addrACA (addrACA (u ^+ 2)) addNr addr0 -!mulr2n.\n  rewrite -mulrnDl -(mul0rn _ 2) (inj_eq mul2I) /= -[rhs in _ + rhs]opprK.\n  rewrite -sqrMi subr_eq0 eqf_sqr -mulNr !mulrA.\n  by case/pred2P=> ->; [exists false | exists true]; rewrite mulr_sign.\nQed.",
    "Lemma normK x : norm x ^+ 2 = x * conj x.\nProof. by rewrite exprMn -rmorphXn sqrtK. Qed.",
    "Lemma normE x y : y ^+ 2 = x -> norm x = y * conj y.\nProof.\n  rewrite /norm => /sqrtE[b /(canLR (signrMK b)) <-].\n  by rewrite !rmorphM /= rmorph_sign mulrACA -mulrA signrMK.\nQed.",
    "Lemma norm_eq0 x : norm x = 0 -> x = 0.\nProof.\n  by move/eqP; rewrite mulf_eq0 fmorph_eq0 -mulf_eq0 -expr2 sqrtK => /eqP.\nQed.",
    "Lemma normM x y : norm (x * y) = norm x * norm y.\nProof.\n  by rewrite mulrACA -rmorphM; apply: normE; rewrite exprMn !sqrtK.\nQed.",
    "Lemma normN x : norm (- x) = norm x.\nProof.\n  by rewrite -mulN1r normM {1}/norm iJ mulrN -expr2 sqrtK opprK mul1r.\nQed.",
    "Lemma posE x: le 0 x = (norm x == x).\nProof. by rewrite /le subr0. Qed.",
    "Lemma leB x y: le x y = le 0 (y - x).\nProof. by rewrite posE. Qed.",
    "Lemma posP x : reflect (exists y, x = y * conj y) (le 0 x).\nProof.\n  rewrite posE; apply: (iffP eqP) => [Dx | [y {x}->]]; first by exists (sqrt x).\n  by rewrite (normE (normK y)) rmorphM /= conjK (mulrC (conj _)) -expr2 normK.\nQed.",
    "Lemma posJ x : le 0 x -> conj x = x.\nProof.\n  by case/posP=> {x}u ->; rewrite rmorphM /= conjK mulrC.\nQed.",
    "Lemma pos_linear x y : le 0 x -> le 0 y -> le x y || le y x.\nProof.\n  move=> pos_x pos_y; rewrite leB -opprB orbC leB !posE normN -eqf_sqr.\n  by rewrite normK rmorphB !posJ ?subrr.\nQed.",
    "Lemma sposDl x y : lt 0 x -> le 0 y -> lt 0 (x + y).\nProof.\n  have sqrtJ z : le 0 z -> conj (sqrt z) = sqrt z.\n    rewrite posE -{2}[z]sqrtK -subr_eq0 -mulrBr mulf_eq0 subr_eq0.\n    by case/pred2P=> ->; rewrite ?rmorph0.\n  case/andP=> nz_x /sqrtJ uJ /sqrtJ vJ.\n  set u := sqrt x in uJ; set v := sqrt y in vJ; pose w := u + i * v.\n  have ->: x + y = w * conj w.\n    rewrite rmorphD rmorphM /= iJ uJ vJ mulNr mulrC -subr_sqr sqrMi opprK.\n    by rewrite !sqrtK.\n  apply/andP; split; last by apply/posP; exists w.\n  rewrite -normK expf_eq0 //=; apply: contraNneq nz_x => /norm_eq0 w0.\n  rewrite -[x]sqrtK expf_eq0 /= -/u -(inj_eq mul2I) !mulr2n -{2}(rmorph0 conj).\n  by rewrite -w0 rmorphD rmorphM /= iJ uJ vJ mulNr addrACA subrr addr0.\nQed.",
    "Lemma sposD x y : lt 0 x -> lt 0 y -> lt 0 (x + y).\nProof.\n  by move=> x_gt0 /andP[_]; apply: sposDl.\nQed.",
    "Lemma normD x y : le (norm (x + y)) (norm x + norm y).\nProof.\n  have sposM u v: lt 0 u -> le 0 (u * v) -> le 0 v.\n    by rewrite /lt !posE normM andbC => /andP[/eqP-> /mulfI/inj_eq->].\n  have posD u v: le 0 u -> le 0 v -> le 0 (u + v).\n    have [-> | nz_u u_ge0 v_ge0] := eqVneq u 0; first by rewrite add0r.\n    by have /andP[]: lt 0 (u + v) by rewrite sposDl // /lt nz_u.\n  have le_sqr u v: conj u = u -> le 0 v -> le (u ^+ 2) (v ^+ 2) -> le u v.\n    case: (eqVneq u 0) => [-> //|nz_u Ru v_ge0].\n    have [u_gt0 | u_le0 _] := boolP (lt 0 u).\n      by rewrite leB (leB u) subr_sqr mulrC addrC; apply: sposM; apply: sposDl.\n    rewrite leB posD // posE normN -addr_eq0; apply/eqP.\n    rewrite /lt nz_u posE -subr_eq0 in u_le0; apply: (mulfI u_le0).\n    by rewrite mulr0 -subr_sqr normK Ru subrr.\n  have pos_norm z: le 0 (norm z) by apply/posP; exists (sqrt z).\n  rewrite le_sqr ?posJ ?posD // sqrrD !normK -normM rmorphD mulrDl !mulrDr.\n  rewrite addrA addrC !addrA -(addrC (y * conj y)) !addrA.\n  move: (y * _ + _) => u; rewrite -!addrA leB opprD addrACA {u}subrr add0r -leB.\n  rewrite {}le_sqr ?posD //.\n    by rewrite rmorphD !rmorphM /= !conjK addrC mulrC (mulrC y).\n  rewrite -mulr2n -mulr_natr exprMn normK -natrX mulr_natr sqrrD mulrACA.\n  rewrite -rmorphM (mulrC y x) addrAC leB mulrnA mulr2n opprD addrACA.\n  rewrite subrr addr0 {2}(mulrC x) rmorphM mulrACA -opprB addrAC -sqrrB -sqrMi.\n  apply/posP; exists (i * (x * conj y - y * conj x)); congr (_ * _).\n  rewrite !(rmorphM, rmorphB) iJ !conjK mulNr -mulrN opprB.\n  by rewrite (mulrC x) (mulrC y).\nQed.",
    "Lemma conjK : involutive conj.\nProof. by move=> u; apply: CtoL_inj; rewrite !LtoC_K conjL_K. Qed.",
    "Lemma algebraic : integralRange (@ratr type).\nProof.\nmove=> u; have [p mon_p pu0] := CtoL_P u; exists p => {mon_p}//.\nrewrite -(fmorph_root CtoL) -map_poly_comp; congr (root _ _):pu0.\nby apply/esym/eq_map_poly; apply: fmorph_eq_rat.\nQed.",
    "Lemma nCdivE (p : nat) : p = p%:R :> divisor. Proof. by []. Qed.",
    "Lemma zCdivE (p : int) : p = p%:~R :> divisor. Proof. by []. Qed.",
    "Lemma algCrect x : x = 'Re x + 'i * 'Im x.\nProof. by rewrite [LHS]Crect. Qed.",
    "Lemma algCreal_Re x : 'Re x \\is Creal.\nProof. by rewrite Creal_Re. Qed.",
    "Lemma algCreal_Im x : 'Im x \\is Creal.\nProof. by rewrite Creal_Im. Qed.",
    "Lemma dvdCP x y : reflect (exists2 z, z \\in Num.int & y = z * x) (x %| y)%C.\nProof.\nrewrite unfold_in; have [-> | nz_x] := eqVneq.\n  by apply: (iffP eqP) => [-> | [z _ ->]]; first exists 0; rewrite ?mulr0.\napply: (iffP idP) => [Zyx | [z Zz ->]]; last by rewrite mulfK.\nby exists (y / x); rewrite ?divfK.\nQed.",
    "Lemma dvdCP_nat x y : 0 <= x -> 0 <= y -> (x %| y)%C -> {n | y = n%:R * x}.\nProof.\nmove=> x_ge0 y_ge0 x_dv_y; apply: sig_eqW.\ncase/dvdCP: x_dv_y => z Zz -> in y_ge0 *; move: x_ge0 y_ge0 Zz.\nrewrite le_eqVlt => /predU1P[<- | ]; first by exists 22%N; rewrite !mulr0.\nby move=> /pmulr_lge0-> /intrEge0-> /natrP[n ->]; exists n.\nQed.",
    "Lemma dvdC0 x : (x %| 0)%C.\nProof. by apply/dvdCP; exists 0; rewrite ?mul0r. Qed.",
    "Lemma dvd0C x : (0 %| x)%C = (x == 0).\nProof. by rewrite unfold_in eqxx. Qed.",
    "Lemma dvdC_mull x y z : y \\in Num.int -> (x %| z)%C -> (x %| y * z)%C.\nProof.\nmove=> Zy /dvdCP[m Zm ->]; apply/dvdCP.\nby exists (y * m); rewrite ?mulrA ?rpredM.\nQed.",
    "Lemma dvdC_mulr x y z : y \\in Num.int -> (x %| z)%C -> (x %| z * y)%C.\nProof. by rewrite mulrC; apply: dvdC_mull. Qed.",
    "Lemma dvdC_mul2r x y z : y != 0 -> (x * y %| z * y)%C = (x %| z)%C.\nProof.\nmove=> nz_y; rewrite !unfold_in !(mulIr_eq0 _ (mulIf nz_y)).\nby rewrite mulrAC invfM mulrA divfK.\nQed.",
    "Lemma dvdC_mul2l x y z : y != 0 -> (y * x %| y * z)%C = (x %| z)%C.\nProof. by rewrite !(mulrC y); apply: dvdC_mul2r. Qed.",
    "Lemma dvdC_trans x y z : (x %| y)%C -> (y %| z)%C -> (x %| z)%C.\nProof. by move=> x_dv_y /dvdCP[m Zm ->]; apply: dvdC_mull. Qed.",
    "Lemma dvdC_refl x : (x %| x)%C.\nProof. by apply/dvdCP; exists 1; rewrite ?mul1r. Qed.",
    "Lemma dvdC_zmod x : zmod_closed (dvdC x).\nProof.\nsplit=> [| _ _ /dvdCP[y Zy ->] /dvdCP[z Zz ->]]; first exact: dvdC0.\nby rewrite -mulrBl dvdC_mull ?rpredB.\nQed.",
    "Lemma dvdC_nat (p n : nat) : (p %| n)%C = (p %| n)%N.\nProof.\nrewrite unfold_in intrEge0 ?divr_ge0 ?invr_ge0 ?ler0n // !pnatr_eq0.\nhave [-> | nz_p] := eqVneq; first by rewrite dvd0n.\napply/natrP/dvdnP=> [[q def_q] | [q ->]]; exists q.\n  by apply/eqP; rewrite -eqC_nat natrM -def_q divfK ?pnatr_eq0.\nby rewrite [num in num / _]natrM mulfK ?pnatr_eq0.\nQed.",
    "Lemma dvdC_int (p : nat) x :\n  x \\in Num.int -> (p %| x)%C = (p %| `|Num.floor x|)%N.\nProof.\nmove=> Zx; rewrite -{1}(floorK Zx) {1}[Num.floor x]intEsign.\nby rewrite rmorphMsign rpredMsign dvdC_nat.\nQed.",
    "Lemma eqCmod_refl e x : (x == x %[mod e])%C.\nProof. by rewrite /eqCmod subrr rpred0. Qed.",
    "Lemma eqCmodm0 e : (e == 0 %[mod e])%C. Proof. by rewrite /eqCmod subr0. Qed.",
    "Lemma eqCmod0 e x : (x == 0 %[mod e])%C = (e %| x)%C.\nProof. by rewrite /eqCmod subr0. Qed.",
    "Lemma eqCmod_sym e x y : ((x == y %[mod e]) = (y == x %[mod e]))%C.\nProof. by rewrite /eqCmod -opprB rpredN. Qed.",
    "Lemma eqCmod_trans e y x z :\n  (x == y %[mod e] -> y == z %[mod e] -> x == z %[mod e])%C.\nProof.\nby move=> Exy Eyz; rewrite /eqCmod -[x](subrK y) -[_ - z]addrA rpredD.\nQed.",
    "Lemma eqCmod_transl e x y z :\n  (x == y %[mod e])%C -> (x == z %[mod e])%C = (y == z %[mod e])%C.\nProof. by move/(sym_left_transitive (eqCmod_sym e) (@eqCmod_trans e)). Qed.",
    "Lemma eqCmod_transr e x y z :\n  (x == y %[mod e])%C -> (z == x %[mod e])%C = (z == y %[mod e])%C.\nProof. by move/(sym_right_transitive (eqCmod_sym e) (@eqCmod_trans e)). Qed.",
    "Lemma eqCmodN e x y : (- x == y %[mod e])%C = (x == - y %[mod e])%C.\nProof. by rewrite eqCmod_sym /eqCmod !opprK addrC. Qed.",
    "Lemma eqCmodDr e x y z : (y + x == z + x %[mod e])%C = (y == z %[mod e])%C.\nProof. by rewrite /eqCmod addrAC opprD !addrA subrK. Qed.",
    "Lemma eqCmodDl e x y z : (x + y == x + z %[mod e])%C = (y == z %[mod e])%C.\nProof. by rewrite !(addrC x) eqCmodDr. Qed.",
    "Lemma eqCmodD e x1 x2 y1 y2 :\n  (x1 == x2 %[mod e] -> y1 == y2 %[mod e] -> x1 + y1 == x2 + y2 %[mod e])%C.\nProof.\nby rewrite -(eqCmodDl e x2 y1) -(eqCmodDr e y1); apply: eqCmod_trans.\nQed.",
    "Lemma eqCmod_nat (e m n : nat) : (m == n %[mod e])%C = (m == n %[mod e]).\nProof.\nwithout loss lenm: m n / (n <= m)%N.\n  by move=> IH; case/orP: (leq_total m n) => /IH //; rewrite eqCmod_sym eq_sym.\nby rewrite /eqCmod -natrB // dvdC_nat eqn_mod_dvd.\nQed.",
    "Lemma eqCmod0_nat (e m : nat) : (m == 0 %[mod e])%C = (e %| m)%N.\nProof. by rewrite eqCmod0 dvdC_nat. Qed.",
    "Lemma eqCmodMr e :\n  {in Num.int, forall z x y, x == y %[mod e] -> x * z == y * z %[mod e]}%C.\nProof. by move=> z Zz x y; rewrite /eqCmod -mulrBl => /dvdC_mulr->. Qed.",
    "Lemma eqCmodMl e :\n  {in Num.int, forall z x y, x == y %[mod e] -> z * x == z * y %[mod e]}%C.\nProof. by move=> z Zz x y Exy; rewrite !(mulrC z) eqCmodMr. Qed.",
    "Lemma eqCmodMl0 e : {in Num.int, forall x, x * e == 0 %[mod e]}%C.\nProof. by move=> x Zx; rewrite -(mulr0 x) eqCmodMl. Qed.",
    "Lemma eqCmodMr0 e : {in Num.int, forall x, e * x == 0 %[mod e]}%C.\nProof. by move=> x Zx; rewrite /= mulrC eqCmodMl0. Qed.",
    "Lemma eqCmod_addl_mul e : {in Num.int, forall x y, x * e + y == y %[mod e]}%C.\nProof. by move=> x Zx y; rewrite -{2}[y]add0r eqCmodDr eqCmodMl0. Qed.",
    "Lemma eqCmodM e : {in Num.int & Num.int, forall x1 y2 x2 y1,\n  x1 == x2 %[mod e] -> y1 == y2 %[mod e] -> x1 * y1 == x2 * y2 %[mod e]}%C.\nProof.\nmove=> x1 y2 Zx1 Zy2 x2 y1 eq_x /(eqCmodMl Zx1)/eqCmod_trans-> //.\nexact: eqCmodMr.\nQed.",
    "Lemma ratCK : cancel QtoC CtoQ.\nProof. by rewrite /getCrat; case: getCrat_subproof. Qed.",
    "Lemma getCratK : {in Crat, cancel CtoQ QtoC}.\nProof. by move=> x /eqP. Qed.",
    "Lemma Crat_rat (a : rat) : QtoC a \\in Crat.\nProof. by rewrite unfold_in ratCK. Qed.",
    "Lemma CratP x : reflect (exists a, x = QtoC a) (x \\in Crat).\nProof.\nby apply: (iffP eqP) => [<- | [a ->]]; [exists (CtoQ x) | rewrite ratCK].\nQed.",
    "Lemma Crat0 : 0 \\in Crat. Proof. by apply/CratP; exists 0; rewrite rmorph0. Qed.",
    "Lemma Crat1 : 1 \\in Crat. Proof. by apply/CratP; exists 1; rewrite rmorph1. Qed.",
    "Lemma rpred_Crat (S : divringClosed algC) : {subset Crat <= S}.\nProof. by move=> _ /CratP[a ->]; apply: rpred_rat. Qed.",
    "Lemma conj_Crat z : z \\in Crat -> z^* = z.\nProof. by move/getCratK <-; rewrite fmorph_div !rmorph_int. Qed.",
    "Lemma Creal_Crat : {subset Crat <= Creal}.\nProof. by move=> x /conj_Crat/CrealP. Qed.",
    "Lemma Cint_rat a : (QtoC a \\in Num.int) = (a \\in Num.int).\nProof.\napply/idP/idP=> [Za | /numqK <-]; last by rewrite rmorph_int.\napply/intrP; exists (Num.floor (QtoC a)); apply: (can_inj ratCK).\nby rewrite rmorph_int floorK.\nQed.",
    "Lemma minCpolyP x :\n   {p : {poly rat} | minCpoly x = pQtoC p /\\ p \\is monic\n      & forall q, root (pQtoC q) x = (p %| q)%R}.\nProof. by rewrite /minCpoly; case: (minCpoly_subproof x) => p; exists p. Qed.",
    "Lemma minCpoly_monic x : minCpoly x \\is monic.\nProof. by have [p [-> mon_p] _] := minCpolyP x; rewrite map_monic. Qed.",
    "Lemma minCpoly_eq0 x : (minCpoly x == 0) = false.\nProof. exact/negbTE/monic_neq0/minCpoly_monic. Qed.",
    "Lemma root_minCpoly x : root (minCpoly x) x.\nProof. by have [p [-> _] ->] := minCpolyP x. Qed.",
    "Lemma size_minCpoly x : (1 < size (minCpoly x))%N.\nProof. by apply: root_size_gt1 (root_minCpoly x); rewrite ?minCpoly_eq0. Qed.",
    "Lemma aut_Crat nu : {in Crat, nu =1 id}.\nProof. by move=> _ /CratP[a ->]; apply: fmorph_rat. Qed.",
    "Lemma Crat_aut nu x : (nu x \\in Crat) = (x \\in Crat).\nProof.\napply/idP/idP=> /CratP[a] => [|->]; last by rewrite fmorph_rat Crat_rat.\nby rewrite -(fmorph_rat nu) => /fmorph_inj->; apply: Crat_rat.\nQed.",
    "Lemma algC_invaut_subproof nu x : {y | nu y = x}.\nProof.\nhave [r Dp] := closed_field_poly_normal (minCpoly x).\nsuffices /mapP/sig2_eqW[y _ ->]: x \\in map nu r by exists y.\nrewrite -root_prod_XsubC; congr (root _ x): (root_minCpoly x).\nhave [q [Dq _] _] := minCpolyP x; rewrite Dq -(eq_map_poly (fmorph_rat nu)).\nrewrite (map_poly_comp nu) -{q}Dq Dp (monicP (minCpoly_monic x)) scale1r.\nrewrite rmorph_prod big_map /=; apply: eq_bigr => z _.\nby rewrite rmorphB /= map_polyX map_polyC.\nQed.",
    "Lemma algC_invautK nu : cancel (algC_invaut nu) nu.\nProof. by move=> x; rewrite /algC_invaut; case: algC_invaut_subproof. Qed.",
    "Lemma algC_autK nu : cancel nu (algC_invaut nu).\nProof. exact: inj_can_sym (algC_invautK nu) (fmorph_inj nu). Qed.",
    "Lemma minCpoly_aut nu x : minCpoly (nu x) = minCpoly x.\nProof.\nwlog suffices dvd_nu: nu x / (minCpoly x %| minCpoly (nu x))%R.\n  apply/eqP; rewrite -eqp_monic ?minCpoly_monic //; apply/andP; split=> //.\n  by rewrite -{2}(algC_autK nu x) dvd_nu.\nhave [[q [Dq _] min_q] [q1 [Dq1 _] _]] := (minCpolyP x, minCpolyP (nu x)).\nrewrite Dq Dq1 dvdp_map -min_q -(fmorph_root nu) -map_poly_comp.\nby rewrite (eq_map_poly (fmorph_rat nu)) -Dq1 root_minCpoly.\nQed.",
    "Lemma total_algR : total (<=%O : rel (algR : porderType _)).\nProof. by move=> x y; apply/real_leVge/valP/valP. Qed.",
    "Lemma algRval_is_additive : additive algRval. Proof. by []. Qed.",
    "Lemma algRval_is_multiplicative : multiplicative algRval. Proof. by []. Qed.",
    "Lemma algR_ler_normD x y : algR_norm (x + y) <= (algR_norm x + algR_norm y).\nProof. exact: ler_normD. Qed.",
    "Lemma algR_normr0_eq0 x : algR_norm x = 0 -> x = 0.\nProof. by move=> /(congr1 val)/normr0_eq0 ?; apply/val_inj. Qed.",
    "Lemma algR_normrMn x n : algR_norm (x *+ n) = algR_norm x *+ n.\nProof. by apply/val_inj; rewrite /= !rmorphMn/= normrMn. Qed.",
    "Lemma algR_normrN x : algR_norm (- x) = algR_norm x.\nProof. by apply/val_inj; apply: normrN. Qed.",
    "Lemma algR_addr_gt0 (x y : algR) : z < x -> z < y -> z < x + y.\nProof. exact: addr_gt0. Qed.",
    "Lemma algR_ger_leVge (x y : algR) : z <= x -> z <= y -> (x <= y) || (y <= x).\nProof. exact: ger_leVge. Qed.",
    "Lemma algR_normrM : {morph algR_norm : x y / x * y}.\nProof. by move=> *; apply/val_inj; apply: normrM. Qed.",
    "Lemma algR_ler_def (x y : algR) : (x <= y) = (algR_norm (y - x) == y - x).\nProof. by apply: ler_def. Qed.",
    "Lemma algR_pfactorRE (x : algC) (xR : x \\is Creal) :\n  algR_pfactor x = 'X - (in_algR xR)%:P.\nProof.\nrewrite /algR_pfactor; case: eqP xR => //= p1 p2.\nby rewrite (bool_irrelevance p1 p2).\nQed.",
    "Lemma algC_pfactorRE (x : algC) : x \\is Creal ->\n  algC_pfactor x = 'X - x%:P.\nProof. by move=> xR; rewrite algR_pfactorRE map_polyXsubC. Qed.",
    "Lemma algR_pfactorCE (x : algC) : x \\isn't Creal ->\n  algR_pfactor x =\n  'X^2 - (in_algR (Creal_Re x) *+ 2) *: 'X + ((in_algR (normr_real x))^+2)%:P.\nProof. by rewrite /algR_pfactor; case: eqP => // p; rewrite p. Qed.",
    "Lemma algC_pfactorCE (x : algC) : x \\isn't Creal ->\n  algC_pfactor x = ('X - x%:P) * ('X - x^*%:P).\nProof.\nmove=> xNR; rewrite algR_pfactorCE//=.\nrewrite rmorphD /= rmorphB/= !map_polyZ !map_polyXn/= map_polyX.\nrewrite (map_polyC algRval)/=.\nrewrite mulrBl !mulrBr -!addrA; congr (_ + _).\nrewrite opprD addrA opprK -opprD -rmorphM/= -normCK; congr (- _ + _).\nrewrite mulrC !mul_polyC -scalerDl.\nrewrite [x in RHS]algCrect conjC_rect ?Creal_Re ?Creal_Im//.\nby rewrite addrACA addNr addr0.\nQed.",
    "Lemma algC_pfactorE x :\n  algC_pfactor x = ('X - x%:P) * ('X - x^*%:P) ^+ (x \\isn't Creal).\nProof.\nby have [/algC_pfactorRE|/algC_pfactorCE] := boolP (_ \\is _); rewrite ?mulr1.\nQed.",
    "Lemma size_algC_pfactor x : size (algC_pfactor x) = (x \\isn't Creal).+2.\nProof.\nhave [xR|xNR] := boolP (_ \\is _); first by rewrite algC_pfactorRE// size_XsubC.\nby rewrite algC_pfactorCE// size_mul ?size_XsubC ?polyXsubC_eq0.\nQed.",
    "Lemma size_algR_pfactor x : size (algR_pfactor x) = (x \\isn't Creal).+2.\nProof. by have := size_algC_pfactor x; rewrite size_map_poly. Qed.",
    "Lemma algC_pfactor_eq0 x : (algC_pfactor x == 0) = false.\nProof. by rewrite -size_poly_eq0 size_algC_pfactor. Qed.",
    "Lemma algR_pfactor_eq0 x : (algR_pfactor x == 0) = false.\nProof. by rewrite -size_poly_eq0 size_algR_pfactor. Qed.",
    "Lemma algC_pfactorCgt0 x y : x \\isn't Creal -> y \\is Creal ->\n  (algC_pfactor x).[y] > 0.\nProof.\nmove=> xNR yR; rewrite algC_pfactorCE// hornerM !hornerXsubC.\nrewrite [x]algCrect conjC_rect ?Creal_Re ?Creal_Im// !opprD !addrA opprK.\nrewrite -subr_sqr exprMn sqrCi mulN1r opprK ltr_wpDl//.\n- by rewrite real_exprn_even_ge0// ?rpredB// ?Creal_Re.\nby rewrite real_exprn_even_gt0 ?Creal_Im ?orTb//=; apply/eqP/Creal_ImP.\nQed.",
    "Lemma algR_pfactorR_mul_gt0 (x a b : algC) :\n    x \\is Creal -> a \\is Creal -> b \\is Creal ->\n    a <= b ->\n    ((algC_pfactor x).[a] * (algC_pfactor x).[b] <= 0) =\n  (a <= x <= b).\nProof.\nmove=> xR aR bR ab; rewrite !algC_pfactorRE// !hornerXsubC.\nhave [lt_xa|lt_ax|->]/= := real_ltgtP xR aR; last first.\n- by rewrite subrr mul0r lexx ab.\n- by rewrite nmulr_rle0 ?subr_lt0 ?subr_ge0.\nrewrite pmulr_rle0 ?subr_gt0// subr_le0.\nby apply: negbTE; rewrite -real_ltNge// (lt_le_trans lt_xa).\nQed.",
    "Lemma monic_algC_pfactor x : algC_pfactor x \\is monic.\nProof. by rewrite algC_pfactorE rpredM ?rpredX ?monicXsubC. Qed.",
    "Lemma monic_algR_pfactor x : algR_pfactor x \\is monic.\nProof. by have := monic_algC_pfactor x; rewrite map_monic. Qed.",
    "Lemma poly_algR_pfactor (p : {poly algR}) :\n  { r : seq algC |\n    p ^^ algRval = val (lead_coef p) *: \\prod_(z <- r) algC_pfactor z }.\nProof.\nwlog p_monic : p / p \\is monic => [hwlog|].\n  have [->|pN0] := eqVneq p 0.\n    by exists [::]; rewrite lead_coef0/= rmorph0 scale0r.\n  have [|r] := hwlog ((lead_coef p)^-1 *: p).\n    by rewrite monicE lead_coefZ mulVf ?lead_coef_eq0//.\n  rewrite !lead_coefZ mulVf ?lead_coef_eq0//= scale1r.\n  rewrite map_polyZ/= => /(canRL (scalerKV _))->; first by exists r.\n  by rewrite fmorph_eq0 lead_coef_eq0.\nsuff: {r : seq algC | p ^^ algRval = \\prod_(z <- r) algC_pfactor z}.\n  by move=> [r rP]; exists r; rewrite rP (monicP _)// scale1r.\nhave [/= r pr] := closed_field_poly_normal (p ^^ algRval).\nrewrite (monicP _) ?monic_map ?scale1r// {p_monic} in pr *.\nhave [n] := ubnP (size r).\nelim: n r => // n IHn [|x r]/= in p pr *.\n by exists [::]; rewrite pr !big_nil.\nrewrite ltnS => r_lt.\nhave xJxr : x^* \\in x :: r.\n  rewrite -root_prod_XsubC -pr.\n  have /eq_map_poly-> : algRval =1 Num.conj_op \\o algRval.\n    by move=> a /=; rewrite (CrealP (algRvalP _)).\n  by rewrite map_poly_comp mapf_root pr root_prod_XsubC mem_head.\nhave xJr : (x \\isn't Creal) ==> (x^* \\in r) by rewrite implyNb CrealE.\nhave pxdvdC : algC_pfactor x %| p ^^ algRval.\n  rewrite pr algC_pfactorE big_cons/= dvdp_mul2l ?polyXsubC_eq0//.\n  by case: (_ \\is _) xJr; rewrite ?dvd1p// dvdp_XsubCl root_prod_XsubC.\npose pr'x := p %/ algR_pfactor x.\nhave [||r'] := IHn (if x \\is Creal then r else rem x^* r) pr'x; last 2 first.\n- by case: (_ \\is _) in xJr *; rewrite ?size_rem// (leq_ltn_trans (leq_pred _)).\n- move=> /eqP; rewrite map_divp -dvdp_eq_mul ?algC_pfactor_eq0//= => /eqP->.\n  by exists (x :: r'); rewrite big_cons mulrC.\nrewrite map_divp/= pr big_cons algC_pfactorE/=.\nrewrite divp_pmul2l ?expf_neq0 ?polyXsubC_eq0//.\ncase: (_ \\is _) => /= in xJr *; first by rewrite divp1//.\nby rewrite (big_rem _ xJr)/= mulKp ?polyXsubC_eq0.\nQed.",
    "Lemma dim_cosetv U x : x != 0 -> \\dim (U * <[x]>) = \\dim U.\nProof.\nmove=> nz_x; rewrite -limg_amulr limg_dim_eq //.\napply/eqP; rewrite -subv0; apply/subvP=> y.\nby rewrite memv_cap memv0 memv_ker lfunE mulf_eq0 (negPf nz_x) orbF => /andP[].\nQed.",
    "Lemma prodvC : commutative (@prodv F0 L).\nProof.\nmove=> U V; without loss suffices subC: U V / (U * V <= V * U)%VS.\n  by apply/eqP; rewrite eqEsubv !{1}subC.\nby apply/prodvP=> x y Ux Vy; rewrite mulrC memv_mul.\nQed.",
    "Lemma prodvCA : left_commutative (@prodv F0 L).\nProof. exact: Monoid.mulmCA. Qed.",
    "Lemma prodvAC : right_commutative (@prodv F0 L).\nProof. exact: Monoid.mulmAC. Qed.",
    "Lemma algid1 K : algid K = 1. Proof. exact/skew_field_algid1/fieldP. Qed.",
    "Lemma mem1v K : 1 \\in K. Proof. by rewrite -algid_eq1 algid1. Qed.",
    "Lemma sub1v K : (1 <= K)%VS. Proof. exact: mem1v. Qed.",
    "Lemma subfield_closed K : agenv K = K.\nProof.\nby apply/eqP; rewrite eqEsubv sub_agenv agenv_sub_modr ?sub1v ?asubv.\nQed.",
    "Lemma AHom_lker0 (rT : falgType F0) (f : 'AHom(L, rT)) : lker f == 0%VS.\nProof. by apply/lker0P; apply: fmorph_inj. Qed.",
    "Lemma AEnd_lker0 (f : 'AEnd(L)) : lker f == 0%VS. Proof. exact: AHom_lker0. Qed.",
    "Lemma Fadjoin_idP {K x} : reflect (<<K; x>>%VS = K) (x \\in K).\nProof.\napply: (iffP idP) => [/addv_idPl-> | <-]; first exact: subfield_closed.\nexact: memv_adjoin.\nQed.",
    "Lemma Fadjoin0 K : <<K; 0>>%VS = K.\nProof. by rewrite addv0 subfield_closed. Qed.",
    "Lemma Fadjoin_nil K : <<K & [::]>>%VS = K.\nProof. by rewrite adjoin_nil subfield_closed. Qed.",
    "Lemma FadjoinP {K x E} :\n  reflect (K <= E /\\ x \\in E)%VS (<<K; x>>%AS <= E)%VS.\nProof.\napply: (iffP idP) => [sKxE | /andP].\n  by rewrite (subvP sKxE) ?memv_adjoin // (subv_trans _ sKxE) ?subv_adjoin.\nby rewrite -subv_add => /agenvS; rewrite subfield_closed.\nQed.",
    "Lemma Fadjoin_seqP {K} {rs : seq L} {E} :\n  reflect (K <= E /\\ {subset rs <= E})%VS (<<K & rs>> <= E)%VS.\nProof.\napply: (iffP idP) => [sKrsE | [sKE /span_subvP/(conj sKE)/andP]].\n  split=> [|x rs_x]; first exact: subv_trans (subv_adjoin_seq _ _) sKrsE.\n  by rewrite (subvP sKrsE) ?seqv_sub_adjoin.\nby rewrite -subv_add => /agenvS; rewrite subfield_closed.\nQed.",
    "Lemma alg_polyOver E p : map_poly (in_alg L) p \\is a polyOver E.\nProof. by apply/(polyOverS (subvP (sub1v _)))/polyOver1P; exists p. Qed.",
    "Lemma sub_adjoin1v x E : (<<1; x>> <= E)%VS = (x \\in E)%VS.\nProof. by rewrite (sameP FadjoinP andP) sub1v. Qed.",
    "Lemma vsval_invf K (w : subvs_of K) : val w^-1 = (vsval w)^-1.\nProof.\nhave [-> | Uv] := eqVneq w 0; first by rewrite !invr0.\nby apply: vsval_invr; rewrite unitfE.\nQed.",
    "Lemma subvs_fieldMixin K : GRing.field_axiom (subvs_of K).\nProof.\nby move=> w nz_w; rewrite unitrE -val_eqE /= vsval_invf algid1 divff.\nQed.",
    "Lemma polyOver_subvs {K} {p : {poly L}} :\n  reflect (exists q : {poly subvs_of K}, p = map_poly vsval q)\n          (p \\is a polyOver K).\nProof.\napply: (iffP polyOverP) => [Hp | [q ->] i]; last by rewrite coef_map // subvsP.\nexists (\\poly_(i < size p) (Subvs (Hp i))); rewrite -{1}[p]coefK.\nby apply/polyP=> i; rewrite coef_map !coef_poly; case: ifP.\nQed.",
    "Lemma divp_polyOver K : {in polyOver K &, forall p q, p %/ q \\is a polyOver K}.\nProof.\nmove=> _ _ /polyOver_subvs[p ->] /polyOver_subvs[q ->].\nby apply/polyOver_subvs; exists (p %/ q); rewrite map_divp.\nQed.",
    "Lemma modp_polyOver K : {in polyOver K &, forall p q, p %% q \\is a polyOver K}.\nProof.\nmove=> _ _ /polyOver_subvs[p ->] /polyOver_subvs[q ->].\nby apply/polyOver_subvs; exists (p %% q); rewrite map_modp.\nQed.",
    "Lemma gcdp_polyOver K :\n  {in polyOver K &, forall p q, gcdp p q \\is a polyOver K}.\nProof.\nmove=> _ _ /polyOver_subvs[p ->] /polyOver_subvs[q ->].\nby apply/polyOver_subvs; exists (gcdp p q); rewrite gcdp_map.\nQed.",
    "Lemma polyOverSv U V : (U <= V)%VS -> {subset polyOver U <= polyOver V}.\nProof. by move/subvP=> sUV; apply: polyOverS. Qed.",
    "Lemma field_subvMl F U : (U <= F * U)%VS.\nProof. by rewrite -{1}[U]prod1v prodvSl ?sub1v. Qed.",
    "Lemma field_subvMr U F : (U <= U * F)%VS.\nProof. by rewrite prodvC field_subvMl. Qed.",
    "Lemma field_module_eq F M : (F * M <= M)%VS -> (F * M)%VS = M.\nProof. by move=> modM; apply/eqP; rewrite eqEsubv modM field_subvMl. Qed.",
    "Lemma sup_field_module F E : (F * E <= E)%VS = (F <= E)%VS.\nProof.\napply/idP/idP; first exact: subv_trans (field_subvMr F E).\nby move/(prodvSl E)/subv_trans->; rewrite ?asubv.\nQed.",
    "Lemma field_module_dimS F M : (F * M <= M)%VS -> (\\dim F %| \\dim M)%N.\nProof. exact/skew_field_module_dimS/fieldP. Qed.",
    "Lemma field_dimS F E : (F <= E)%VS -> (\\dim F %| \\dim E)%N.\nProof. exact/skew_field_dimS/fieldP. Qed.",
    "Lemma dim_field_module F M : (F * M <= M)%VS -> \\dim M = (\\dim_F M * \\dim F)%N.\nProof. by move/field_module_dimS/divnK. Qed.",
    "Lemma dim_sup_field F E : (F <= E)%VS -> \\dim E = (\\dim_F E * \\dim F)%N.\nProof. by move/field_dimS/divnK. Qed.",
    "Lemma field_module_semisimple F M (m := \\dim_F M) :\n    (F * M <= M)%VS ->\n  {X : m.-tuple L | {subset X <= M} /\\ 0 \\notin X\n     & let FX := (\\sum_(i < m) F * <[X`_i]>)%VS in FX = M /\\ directv FX}.\nProof.\nmove=> modM; have dimM: (m * \\dim F)%N = \\dim M by rewrite -dim_field_module.\nhave [X [defM dxFX nzX]] := skew_field_module_semisimple (@fieldP L) modM.\nhave szX: size X == m.\n  rewrite -(eqn_pmul2r (adim_gt0 F)) dimM -defM (directvP dxFX) /=.\n  rewrite -sum1_size big_distrl; apply/eqP/eq_big_seq => x Xx /=.\n  by rewrite mul1n dim_cosetv ?(memPn nzX).\nrewrite directvE /= (big_nth 0) [eqbRHS](big_nth 0) in defM dxFX.\nrewrite (eqP szX) !big_mkord -directvE in defM dxFX.\nexists (Tuple szX) => //; split=> // _ /tnthP[i ->]; rewrite (tnth_nth 0) /=.\nby rewrite -defM memvE (sumv_sup i) ?field_subvMl.\nQed.",
    "Lemma size_Fadjoin_poly v : size (Fadjoin_poly v) <= n.\nProof. exact: size_poly. Qed.",
    "Lemma Fadjoin_polyOver v : Fadjoin_poly v \\is a polyOver U.\nProof.\napply/(all_nthP 0) => i _; rewrite coef_poly /=.\ncase: ifP => lti; last exact: mem0v.\nhave /memv_cosetP[y Uy ->] := memv_sum_pi (erefl Fadjoin_sum) (inord i) v.\nrewrite inordK //; have [-> | /mulfK-> //] := eqVneq (x ^+ i) 0.\nby rewrite mulr0 mul0r mem0v.\nQed.",
    "Lemma size_minPoly : size minPoly = n.+1.\nProof. by rewrite size_polyDl ?size_polyXn // size_polyN ltnS size_poly. Qed.",
    "Lemma monic_minPoly : minPoly \\is monic.\nProof.\nrewrite monicE /lead_coef size_minPoly coefB coefXn eqxx.\nby rewrite nth_default ?subr0 ?size_poly.\nQed.",
    "Lemma adjoin_degreeE : n = \\dim_K <<K; x>>.\nProof. by rewrite [n]prednK // divn_gt0 ?adim_gt0 // dimvS ?subv_adjoin. Qed.",
    "Lemma dim_Fadjoin : \\dim <<K; x>> = (n * \\dim K)%N.\nProof. by rewrite adjoin_degreeE -dim_sup_field ?subv_adjoin. Qed.",
    "Lemma adjoin0_deg : adjoin_degree K 0 = 1.\nProof. by rewrite /adjoin_degree addv0 subfield_closed divnn adim_gt0. Qed.",
    "Lemma adjoin_deg_eq1 : (n == 1) = (x \\in K).\nProof.\nrewrite (sameP Fadjoin_idP eqP) adjoin_degreeE; have sK_Kx := subv_adjoin K x.\napply/eqP/idP=> [dimKx1 | /eqP->]; last by rewrite divnn adim_gt0.\nby rewrite eq_sym eqEdim sK_Kx /= (dim_sup_field sK_Kx) dimKx1 mul1n.\nQed.",
    "Lemma Fadjoin_sum_direct : directv sumKx.\nProof.\nrewrite directvE /=; case: (ubnPgeq n) (isT : n > 0) => -[//|m] ltmn _.\nelim: m ltmn => [|m IHm] ltm1n; rewrite ?big_ord1 // !(big_ord_recr m.+1) /=.\ndo [move/(_ (ltnW ltm1n))/eqP; set S := (\\sum_i _)%VS] in IHm *.\nrewrite -IHm dimv_add_leqif; apply/subvP=> z; rewrite memv_cap => /andP[Sz].\ncase/memv_cosetP=> y Ky Dz; rewrite memv0 Dz mulf_eq0 expf_eq0 /=.\napply: contraLR ltm1n => /norP[nz_y nz_x].\nrewrite -leqNgt -(leq_pmul2r (adim_gt0 K)) -dim_Fadjoin.\nhave{IHm} ->: (m.+1 * \\dim K)%N = \\dim S.\n  rewrite -[m.+1]card_ord -sum_nat_const IHm.\n  by apply: eq_bigr => i; rewrite dim_cosetv ?expf_neq0.\napply/dimvS/agenv_sub_modl; first by rewrite (sumv_sup 0) //= prodv1 sub1v.\nrewrite prodvDl subv_add -[S]big_distrr prodvA prodv_id subvv !big_distrr /=.\napply/subv_sumP=> i _; rewrite -expv_line prodvCA -expvSl expv_line.\nhave [ltim | lemi] := ltnP i m; first by rewrite (sumv_sup (Sub i.+1 _)).\nhave{lemi} /eqP->: i == m :> nat by rewrite eqn_leq leq_ord.\nrewrite -big_distrr -2!{2}(prodv_id K) /= -!prodvA big_distrr -/S prodvSr //=.\nby rewrite -(canLR (mulKf nz_y) Dz) -memvE memv_mul ?rpredV.\nQed.",
    "Lemma Fadjoin_eq_sum : <<K; x>>%VS = sumKx.\nProof.\napply/esym/eqP; rewrite eqEdim eq_leq ?andbT.\n  apply/subv_sumP=> i _; rewrite -agenvM prodvS ?subv_adjoin //.\n  by rewrite -expv_line (subv_trans (subX_agenv _ _)) ?agenvS ?addvSr.\nrewrite dim_Fadjoin -[n]card_ord -sum_nat_const (directvP Fadjoin_sum_direct).\nby apply: eq_bigr => i _; rewrite /= dim_cosetv.\nQed.",
    "Lemma Fadjoin_poly_eq v : v \\in <<K; x>>%VS -> (Fadjoin_poly K x v).[x] = v.\nProof.\nmove/(sumv_pi_sum Fadjoin_eq_sum)=> {2}<-; rewrite horner_poly.\nby apply: eq_bigr => i _; rewrite inord_val mulfVK.\nQed.",
    "Lemma mempx_Fadjoin p : p \\is a polyOver K -> p.[x] \\in <<K; x>>%VS.\nProof.\nmove=> Kp; rewrite rpred_horner ?memv_adjoin ?(polyOverS _ Kp) //.\nexact: subvP_adjoin.\nQed.",
    "Lemma Fadjoin_polyP {v} :\n  reflect (exists2 p, p \\in polyOver K & v = p.[x]) (v \\in <<K; x>>%VS).\nProof.\napply: (iffP idP) => [Kx_v | [p Kp ->]]; last exact: mempx_Fadjoin.\nby exists (Fadjoin_poly K x v); rewrite ?Fadjoin_polyOver ?Fadjoin_poly_eq.\nQed.",
    "Lemma Fadjoin_poly_unique p v :\n  p \\is a polyOver K -> size p <= n -> p.[x] = v -> Fadjoin_poly K x v = p.\nProof.\nhave polyKx q i: q \\is a polyOver K -> q`_i * x ^+ i \\in (K * <[x ^+ i]>)%VS.\n  by move/polyOverP=> Kq; rewrite memv_mul ?Kq ?memv_line.\nmove=> Kp szp Dv; have /Fadjoin_poly_eq/eqP := mempx_Fadjoin Kp.\nrewrite {1}Dv {Dv} !(@horner_coef_wide _ n) ?size_poly //.\nmove/polyKx in Kp; have /polyKx K_pv := Fadjoin_polyOver K x v.\nrewrite (directv_sum_unique Fadjoin_sum_direct) // => /eqfunP eq_pq.\napply/polyP=> i; have [leni|?] := leqP n i; last exact: mulIf (eq_pq (Sub i _)).\nby rewrite !nth_default ?(leq_trans _ leni) ?size_poly.\nQed.",
    "Lemma Fadjoin_polyC v : v \\in K -> Fadjoin_poly K x v = v%:P.\nProof.\nmove=> Kv; apply: Fadjoin_poly_unique; rewrite ?polyOverC ?hornerC //.\nby rewrite size_polyC (leq_trans (leq_b1 _)).\nQed.",
    "Lemma Fadjoin_polyX : x \\notin K -> Fadjoin_poly K x x = 'X.\nProof.\nmove=> K'x; apply: Fadjoin_poly_unique; rewrite ?polyOverX ?hornerX //.\nby rewrite size_polyX ltn_neqAle andbT eq_sym adjoin_deg_eq1.\nQed.",
    "Lemma minPolyOver : minPoly K x \\is a polyOver K.\nProof. by rewrite /minPoly rpredB ?rpredX ?polyOverX ?Fadjoin_polyOver. Qed.",
    "Lemma minPolyxx : (minPoly K x).[x] = 0.\nProof.\nby rewrite !hornerE Fadjoin_poly_eq ?subrr ?rpredX ?memv_adjoin.\nQed.",
    "Lemma root_minPoly : root (minPoly K x) x. Proof. exact/rootP/minPolyxx. Qed.",
    "Lemma Fadjoin_poly_mod p :\n  p \\is a polyOver K -> Fadjoin_poly K x p.[x] = p %% minPoly K x.\nProof.\nmove=> Kp; rewrite {1}(divp_eq p (minPoly K x)) 2!hornerE minPolyxx mulr0 add0r.\napply: Fadjoin_poly_unique => //; first by rewrite modp_polyOver // minPolyOver.\nby rewrite -ltnS -size_minPoly ltn_modp // monic_neq0 ?monic_minPoly.\nQed.",
    "Lemma minPoly_XsubC : reflect (minPoly K x = 'X - x%:P) (x \\in K).\nProof.\nset p := minPoly K x; apply: (iffP idP) => [Kx | Dp]; last first.\n  suffices ->: x = - p`_0 by rewrite rpredN (polyOverP minPolyOver).\n  by rewrite Dp coefB coefX coefC add0r opprK.\nrewrite (@all_roots_prod_XsubC _ p [:: x]) /= ?root_minPoly //.\n  by rewrite big_seq1 (monicP (monic_minPoly K x)) scale1r.\nby apply/eqP; rewrite size_minPoly eqSS adjoin_deg_eq1.\nQed.",
    "Lemma root_small_adjoin_poly p :\n  p \\is a polyOver K -> size p <= n -> root p x = (p == 0).\nProof.\nmove=> Kp szp; apply/rootP/eqP=> [px0 | ->]; last by rewrite horner0.\nrewrite -(Fadjoin_poly_unique Kp szp px0).\nby apply: Fadjoin_poly_unique; rewrite ?polyOver0 ?size_poly0 ?horner0.\nQed.",
    "Lemma minPoly_irr p :\n  p \\is a polyOver K -> p %| minPoly K x -> (p %= minPoly K x) || (p %= 1).\nProof.\nrewrite dvdp_eq; set q := _ %/ _ => Kp def_pq.\nhave Kq: q \\is a polyOver K by rewrite divp_polyOver // minPolyOver.\nmove: q Kq def_pq root_minPoly (size_minPoly K x) => q Kq /eqP->.\nrewrite rootM => pqx0 szpq.\nhave [nzq nzp]: q != 0 /\\ p != 0.\n  by apply/norP; rewrite -mulf_eq0 -size_poly_eq0 szpq.\nwithout loss{pqx0} qx0: q p Kp Kq nzp nzq szpq / root q x.\n  move=> IH; case/orP: pqx0 => /IH{}IH; first exact: IH.\n  have{IH} /orP[]: (q %= p * q) || (q %= 1) by apply: IH => //; rewrite mulrC.\n    by rewrite orbC -{1}[q]mul1r eqp_mul2r // eqp_sym => ->.\n  by rewrite -{1}[p]mul1r eqp_sym eqp_mul2r // => ->.\napply/orP; right; rewrite -size_poly_eq1 eqn_leq lt0n size_poly_eq0 nzp andbT.\nrewrite -(leq_add2r (size q)) -leq_subLR subn1 -size_mul // mulrC szpq.\nby rewrite ltnNge; apply: contra nzq => /(root_small_adjoin_poly Kq) <-.\nQed.",
    "Lemma minPoly_dvdp p : p \\is a polyOver K -> root p x -> (minPoly K x) %| p.\nProof.\nmove=> Kp rootp.\nhave gcdK : gcdp (minPoly K x) p \\is a polyOver K.\n  by rewrite gcdp_polyOver ?minPolyOver.\nhave /orP[gcd_eqK|gcd_eq1] := minPoly_irr gcdK (dvdp_gcdl (minPoly K x) p).\n  by rewrite -(eqp_dvdl _ gcd_eqK) dvdp_gcdr.\ncase/negP: (root1 x).\nby rewrite -(eqp_root gcd_eq1) root_gcd rootp root_minPoly.\nQed.",
    "Lemma minPolyS K E a : (K <= E)%VS -> minPoly E a %| minPoly K a.\nProof.\nmove=> sKE; apply: minPoly_dvdp; last exact: root_minPoly.\nby apply: (polyOverSv sKE); rewrite minPolyOver.\nQed.",
    "Lemma Fadjoin1_polyP x v :\n  reflect (exists p, v = (map_poly (in_alg L) p).[x]) (v \\in <<1; x>>%VS).\nProof.\napply: (iffP Fadjoin_polyP) => [[_ /polyOver1P]|] [p ->]; first by exists p.\nby exists (map_poly (in_alg L) p) => //; apply: alg_polyOver.\nQed.",
    "Lemma fieldExt_hornerC b : fieldExt_horner b%:P = b%:A.\nProof. exact: horner_morphC. Qed.",
    "Lemma fieldExt_hornerX : fieldExt_horner 'X = z.\nProof. exact: horner_morphX. Qed.",
    "Lemma adjoin_degree_aimg : adjoin_degree (f @: K) (f x) = adjoin_degree K x.\nProof.\nrewrite !adjoin_degreeE -aimg_adjoin.\nby rewrite !limg_dim_eq ?(eqP (AHom_lker0 f)) ?capv0.\nQed.",
    "Lemma map_minPoly :  map_poly f (minPoly K x) = minPoly (f @: K) (f x).\nProof.\nset fp := minPoly (f @: K) (f x).\nhave [p Kp Dp]: exists2 p, p \\is a polyOver K & map_poly f p = fp.\n  have Kfp: fp \\is a polyOver (f @: K)%VS by apply: minPolyOver.\n  exists (map_poly f^-1%VF fp).\n    apply/polyOver_poly=> j _; have /memv_imgP[y Ky ->] := polyOverP Kfp j.\n    by rewrite lker0_lfunK ?AHom_lker0.\n  rewrite -map_poly_comp map_poly_id // => _ /(allP Kfp)/memv_imgP[y _ ->].\n  by rewrite /= limg_lfunVK ?memv_img ?memvf.\napply/eqP; rewrite -eqp_monic ?monic_map ?monic_minPoly // -Dp eqp_map.\nhave: ~~ (p %= 1) by rewrite -size_poly_eq1 -(size_map_poly f) Dp size_minPoly.\napply: implyP; rewrite implyNb orbC eqp_sym minPoly_irr //.\nrewrite -(dvdp_map f) Dp minPoly_dvdp ?fmorph_root ?root_minPoly //.\nby apply/polyOver_poly=> j _; apply/memv_img/polyOverP/minPolyOver.\nQed.",
    "Lemma fieldOver_scaleE a (u : L) : a *: (u : L_F) = vsval a * u.\nProof. by []. Qed.",
    "Lemma trivial_fieldOver : (1%VS : {vspace L_F}) =i F.\nProof.\nmove=> x; apply/vlineP/idP=> [[{}x ->] | Fx].\n  by rewrite fieldOver_scaleE mulr1 (valP x).\nby exists (vsproj F x); rewrite fieldOver_scaleE mulr1 vsprojK.\nQed.",
    "Lemma mem_vspaceOver V : vspaceOver V =i (F * V)%VS.\nProof.\nmove=> y; apply/idP/idP; last rewrite unlock; move/coord_span->.\n  rewrite (@memv_suml F0 L) // => i _.\n  by rewrite memv_mul ?subvsP // vbasis_mem ?memt_nth.\nrewrite memv_suml // => ij _; rewrite -tnth_nth; set x := tnth _ ij.\nhave/allpairsP[[u z] /= [Fu Vz {x}->]]: x \\in _ := mem_tnth ij _.\nby rewrite scalerAl (memvZ (Subvs _)) ?memvZ ?memv_span //= vbasis_mem.\nQed.",
    "Lemma mem_aspaceOver E : (F <= E)%VS -> vspaceOver E =i E.\nProof.\nby move=> sFE y; rewrite mem_vspaceOver field_module_eq ?sup_field_module.\nQed.",
    "Lemma dim_vspaceOver M : (F * M <= M)%VS -> \\dim (vspaceOver M) = \\dim_F M.\nProof.\nmove=> modM; have [] := field_module_semisimple modM.\nset n := \\dim_F M => b [Mb nz_b] [defM dx_b].\nsuff: basis_of (vspaceOver M) b by apply: size_basis.\napply/andP; split.\n  rewrite eqEsubv; apply/andP; split; apply/span_subvP=> u.\n    by rewrite mem_vspaceOver field_module_eq // => /Mb.\n  move/(@vbasis_mem _ _ _ M); rewrite -defM => /memv_sumP[{}u Fu ->].\n  apply: memv_suml => i _; have /memv_cosetP[a Fa ->] := Fu i isT.\n  by apply: (memvZ (Subvs Fa)); rewrite memv_span ?memt_nth.\napply/freeP=> a /(directv_sum_independent dx_b) a_0 i.\nhave{a_0}: a i *: (b`_i : L_F) == 0.\n  by rewrite a_0 {i}// => i _; rewrite memv_mul ?memv_line ?subvsP.\nby rewrite scaler_eq0=> /predU1P[] // /idPn[]; rewrite (memPn nz_b) ?memt_nth.\nQed.",
    "Lemma dim_aspaceOver E : (F <= E)%VS -> \\dim (vspaceOver E) = \\dim_F E.\nProof. by rewrite -sup_field_module; apply: dim_vspaceOver. Qed.",
    "Lemma vspaceOverP V_F :\n  {V | [/\\ V_F = vspaceOver V, (F * V <= V)%VS & V_F =i V]}.\nProof.\npose V := (F * <<vbasis V_F : seq L>>)%VS.\nhave idV: (F * V)%VS = V by rewrite prodvA prodv_id.\nsuffices defVF: V_F = vspaceOver V.\n  by exists V; split=> [||u]; rewrite ?defVF ?mem_vspaceOver ?idV.\napply/vspaceP=> v; rewrite mem_vspaceOver idV.\ndo [apply/idP/idP; last rewrite /V unlock] => [/coord_vbasis|/coord_span] ->.\n  by apply: memv_suml => i _; rewrite memv_mul ?subvsP ?memv_span ?memt_nth.\napply: memv_suml => i _; rewrite -tnth_nth; set xu := tnth _ i.\nhave /allpairsP[[x u] /=]: xu \\in _ := mem_tnth i _.\ncase=> /vbasis_mem Fx /vbasis_mem Vu ->.\nrewrite scalerAl (coord_span Vu) mulr_sumr memv_suml // => j_.\nby rewrite -scalerCA (memvZ (Subvs _)) ?memvZ // vbasis_mem ?memt_nth.\nQed.",
    "Lemma aspaceOverP (E_F : {subfield L_F}) :\n  {E | [/\\ E_F = aspaceOver E, (F <= E)%VS & E_F =i E]}.\nProof.\nhave [V [defEF modV memV]] := vspaceOverP E_F.\nhave algE: has_algid V && (V * V <= V)%VS.\n  rewrite has_algid1; last by rewrite -memV mem1v.\n  by apply/prodvP=> u v; rewrite -!memV; apply: memvM.\nby exists (ASpace algE); rewrite -sup_field_module; split; first apply: val_inj.\nQed.",
    "Lemma baseField_scaleE a (u : L) : a *: (u : L0) = a%:A *: u.\nProof. by []. Qed.",
    "Lemma mem_baseVspace V : baseVspace V =i V.\nProof.\nmove=> y; apply/idP/idP=> [/coord_span->|/coord_vbasis->]; last first.\n  apply: memv_suml => i _; rewrite (coordF (coord _ i (y : L))) scaler_suml -/n.\n  apply: memv_suml => j _; rewrite -/bF -F0ZEZ memvZ ?memv_span // -!tnth_nth.\n  by apply/imageP; exists (i, j).\n  \napply: memv_suml => k _; rewrite nth_image; case: (enum_val k) => i j /=.\nby rewrite F0ZEZ memvZ ?vbasis_mem ?mem_tnth.\nQed.",
    "Lemma dim_baseVspace V : \\dim (baseVspace V) = (\\dim V * n)%N.\nProof.\npose bV0 := baseVspace_basis V; set m := \\dim V in bV0 *.\nsuffices /size_basis->: basis_of (baseVspace V) bV0.\n  by rewrite card_prod !card_ord.\nrewrite /basis_of eqxx.\napply/freeP=> s sb0 k; rewrite -(enum_valK k); case/enum_val: k => i j.\nhave free_baseP := freeP (basis_free (vbasisP _)).\nmove: j; apply: (free_baseP _ _ fullv); move: i; apply: (free_baseP _ _ V).\ntransitivity (\\sum_i \\sum_j s (enum_rank (i, j)) *: bV0`_(enum_rank (i, j))).\n  apply: eq_bigr => i _; rewrite scaler_suml; apply: eq_bigr => j _.\n  by rewrite -F0ZEZ nth_image enum_rankK -!tnth_nth.\nrewrite pair_bigA (reindex _ (onW_bij _ (enum_val_bij _))); apply: etrans sb0.\nby apply: eq_bigr => k _; rewrite -{5 6}[k](enum_valK k); case/enum_val: k.\nQed.",
    "Lemma dim_refBaseField : \\dim F1 = n.\nProof. by rewrite F1unlock dim_baseVspace dimv1 mul1n. Qed.",
    "Lemma baseVspace_module V (V0 := baseVspace V) : (F1 * V0 <= V0)%VS.\nProof.\napply/prodvP=> u v; rewrite F1unlock !mem_baseVspace => /vlineP[x ->] Vv.\nby rewrite -(@scalerAl F L) mul1r; apply: memvZ.\nQed.",
    "Lemma sub_baseField (E : {subfield L}) : (F1 <= baseVspace E)%VS.\nProof. by rewrite -sup_field_module baseVspace_module. Qed.",
    "Lemma vspaceOver_refBase V : vspaceOver F1 (baseVspace V) =i V.\nProof.\nmove=> v; rewrite mem_vspaceOver field_module_eq ?baseVspace_module //.\nby rewrite mem_baseVspace.\nQed.",
    "Lemma module_baseVspace M0 :\n  (F1 * M0 <= M0)%VS -> {V | M0 = baseVspace V & M0 =i V}.\nProof.\nmove=> modM0; pose V := <<vbasis (vspaceOver F1 M0) : seq L>>%VS.\nsuffices memM0: M0 =i V.\n  by exists V => //; apply/vspaceP=> v; rewrite mem_baseVspace memM0.\nmove=> v; rewrite -{1}(field_module_eq modM0) -(mem_vspaceOver M0) {}/V.\nmove: (vspaceOver F1 M0) => M.\napply/idP/idP=> [/coord_vbasis|/coord_span]->; apply/memv_suml=> i _.\n  rewrite /(_ *: _) /= /fieldOver_scale; case: (coord _ i _) => /= x.\n  rewrite {1}F1unlock mem_baseVspace => /vlineP[{}x ->].\n  by rewrite -(@scalerAl F L) mul1r memvZ ?memv_span ?memt_nth.\nmove: (coord _ i _) => x; rewrite -[_`_i]mul1r scalerAl -tnth_nth.\nhave F1x: x%:A \\in F1.\n  by rewrite F1unlock mem_baseVspace (@memvZ F L) // mem1v.\nby congr (_ \\in M): (memvZ (Subvs F1x) (vbasis_mem (mem_tnth i _))).\nQed.",
    "Lemma module_baseAspace (E0 : {subfield L0}) :\n  (F1 <= E0)%VS -> {E | E0 = baseAspace E & E0 =i E}.\nProof.\nrewrite -sup_field_module => /module_baseVspace[E defE0 memE0].\nsuffices algE: is_aspace E by exists (ASpace algE); first apply: val_inj.\nrewrite /is_aspace has_algid1 -?memE0 ?mem1v //.\nby apply/prodvP=> u v; rewrite -!memE0; apply: memvM.\nQed.",
    "Lemma base_vspaceOver V : baseVspace (vspaceOver F V) =i (F * V)%VS.\nProof. by move=> v; rewrite mem_baseVspace mem_vspaceOver. Qed.",
    "Lemma base_moduleOver V : (F * V <= V)%VS -> baseVspace (vspaceOver F V) =i V.\nProof. by move=> /field_module_eq defV v; rewrite base_vspaceOver defV. Qed.",
    "Lemma base_aspaceOver (E : {subfield L}) :\n  (F <= E)%VS -> baseVspace (vspaceOver F E) =i E.\nProof. by rewrite -sup_field_module; apply: base_moduleOver. Qed.",
    "Lemma subfx_eval_is_additive : additive subfx_eval.\nProof. by move=> x y; apply/eqP; rewrite piE -linearB modpD modNp. Qed.",
    "Lemma subfx_eval_is_multiplicative : multiplicative subfx_eval.\nProof.\nsplit=> [x y|]; apply/eqP; rewrite piE.\n  by rewrite /subfx_mul_rep !poly_rV_modp_K !(modp_mul, mulrC _ y).\nby rewrite modp_small // size_poly1 -subn_gt0 subn1.\nQed.",
    "Lemma subfxE x: exists p, x = subfx_eval p.\nProof.\nelim/quotW: x => x; exists (rVpoly x); apply/eqP; rewrite piE /equiv_subfext.\nby rewrite /iotaFz poly_rV_modp_K iotaPz_modp.\nQed.",
    "Lemma subfx_inj_eval q : subfx_inj (subfx_eval q) = q^iota.[z].\nProof.\nby rewrite piE /iotaFz poly_rV_modp_K iotaPz_modp /iotaPz /z0 /wf_p nz_p pz0.\nQed.",
    "Lemma subfx_inj_root : subfx_inj subfx_root = z.\nProof. by rewrite subfx_inj_eval // map_polyX hornerX. Qed.",
    "Lemma subfx_injZ b x : subfx_inj (b *: x) = iota b * subfx_inj x.\nProof. by rewrite rmorphM /= subfx_inj_eval // map_polyC hornerC. Qed.",
    "Lemma subfx_inj_base b : subfx_inj b%:A = iota b.\nProof. by rewrite subfx_injZ rmorph1 mulr1. Qed.",
    "Lemma subfxEroot x : {q | x = (map_poly (in_alg subFExtend) q).[subfx_root]}.\nProof.\nhave /sig_eqW[q ->] := subfxE x; exists q.\napply: (fmorph_inj subfx_inj).\nrewrite -horner_map /= subfx_inj_root subfx_inj_eval //.\nby rewrite -map_poly_comp (eq_map_poly subfx_inj_base).\nQed.",
    "Lemma subfx_irreducibleP :\n (forall q, root q^iota z -> q != 0 -> size p <= size q) <-> irreducible_poly p.\nProof.\nsplit=> [min_p | irr_p q qz0 nz_q].\n  split=> [|q nonC_q q_dv_p].\n    by rewrite -(size_map_poly iota) (root_size_gt1 _ pz0) ?map_poly_eq0.\n  have /dvdpP[r Dp] := q_dv_p; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  have [nz_r nz_q]: r != 0 /\\ q != 0 by apply/norP; rewrite -mulf_eq0 -Dp.\n  have: root r^iota z || root q^iota z by rewrite -rootM -rmorphM -Dp.\n  case/orP=> /min_p; [case/(_ _)/idPn=> // | exact].\n  rewrite polySpred // -leqNgt Dp size_mul //= polySpred // -subn2 ltn_subRL.\n  by rewrite addSnnS addnC ltn_add2l ltn_neqAle eq_sym nonC_q size_poly_gt0.\npose r := gcdp p q; have nz_r: r != 0 by rewrite gcdp_eq0 (negPf nz_p).\nsuffices /eqp_size <-: r %= p by rewrite dvdp_leq ?dvdp_gcdr.\nrewrite (irr_p _) ?dvdp_gcdl // -(size_map_poly iota) gtn_eqF //.\nby rewrite (@root_size_gt1 _ z) ?map_poly_eq0 // gcdp_map root_gcd pz0.\nQed.",
    "Lemma min_subfx_vect : Vector.axiom (size p).-1 subFExtend.\nProof.\nmove/subfx_irreducibleP: irr_p => /=/(_ nz_p) min_p; set d := (size p).-1.\nhave Dd: d.+1 = size p by rewrite polySpred.\npose Fz2v x : 'rV_d := poly_rV (sval (sig_eqW (subfxE x)) %% p).\npose vFz : 'rV_d -> subFExtend := subfx_eval \\o rVpoly.\nhave FLinj: injective subfx_inj by apply: fmorph_inj.\nhave Fz2vK: cancel Fz2v vFz.\n  move=> x; rewrite /vFz /Fz2v; case: (sig_eqW _) => /= q ->.\n  apply: FLinj; rewrite !subfx_inj_eval // {2}(divp_eq q p) rmorphD rmorphM /=.\n  by rewrite !hornerE (eqP pz0) mulr0 add0r poly_rV_K // -ltnS Dd ltn_modpN0.\nsuffices vFzK: cancel vFz Fz2v.\n  by exists Fz2v; [apply: can2_linear Fz2vK | exists vFz].\napply: inj_can_sym Fz2vK _ => v1 v2 /(congr1 subfx_inj)/eqP.\nrewrite -subr_eq0 -!raddfB /= subfx_inj_eval // => /min_p/implyP.\nrewrite leqNgt implybNN -Dd ltnS size_poly linearB subr_eq0 /=.\nby move/eqP/(can_inj rVpolyK).\nQed.",
    "Lemma irredp_FAdjoin (F : fieldType) (p : {poly F}) :\n    irreducible_poly p ->\n  {L : fieldExtType F & \\dim {:L} = (size p).-1 &\n    {z | root (map_poly (in_alg L) p) z & <<1; z>>%VS = fullv}}.\nProof.\ncase=> p_gt1 irr_p; set n := (size p).-1; pose vL : vectType F := 'rV_n.\nhave Dn: n.+1 = size p := ltn_predK p_gt1.\nhave nz_p: p != 0 by rewrite -size_poly_eq0 -Dn.\nsuffices [L dimL [toPF [toL toPF_K toL_K]]]:\n   {L : fieldExtType F & \\dim {:L} = (size p).-1\n      & {toPF : {linear L -> {poly F}} & {toL : {lrmorphism {poly F} -> L} |\n         cancel toPF toL & forall q, toPF (toL q) = q %% p}}}.\n- exists L => //; pose z := toL 'X; set iota := in_alg _.\n  suffices q_z q: toPF (map_poly iota q).[z] = q %% p.\n    exists z; first by rewrite /root -(can_eq toPF_K) q_z modpp linear0.\n    apply/vspaceP=> x; rewrite memvf; apply/Fadjoin_polyP.\n    exists (map_poly iota (toPF x)).\n      by apply/polyOverP=> i; rewrite coef_map memvZ ?mem1v.\n    by apply: (can_inj toPF_K); rewrite q_z -toL_K toPF_K.\n  elim/poly_ind: q => [|a q IHq].\n    by rewrite map_poly0 horner0 linear0 mod0p.\n  rewrite rmorphD rmorphM /= map_polyX map_polyC hornerMXaddC linearD /=.\n  rewrite linearZ /= -(rmorph1 toL) toL_K -modpZl alg_polyC modpD.\n  congr (_ + _); rewrite -toL_K rmorphM -/z; congr (toPF (_ * z)).\n  by apply: (can_inj toPF_K); rewrite toL_K.\npose toL q : vL := poly_rV (q %% p); pose toPF (x : vL) := rVpoly x.\nhave toL_K q : toPF (toL q) = q %% p.\n  by rewrite /toPF poly_rV_K // -ltnS Dn ?ltn_modp -?Dn.\nhave toPF_K: cancel toPF toL.\n  by move=> x; rewrite /toL modp_small ?rVpolyK // -Dn ltnS size_poly.\nhave toPinj := can_inj toPF_K.\npose mul x y := toL (toPF x * toPF y); pose L1 := toL 1.\nhave L1K: toPF L1 = 1 by rewrite toL_K modp_small ?size_poly1.\nhave mulC: commutative mul by rewrite /mul => x y; rewrite mulrC.\nhave mulA: associative mul.\n  by move=> x y z; apply: toPinj; rewrite -!(mulC z) !toL_K !modp_mul mulrCA.\nhave mul1: left_id L1 mul.\n  by move=> x; apply: toPinj; rewrite mulC !toL_K modp_mul mulr1 -toL_K toPF_K.\nhave mulD: left_distributive mul +%R.\n  move=> x y z; apply: toPinj; rewrite /toPF raddfD /= -!/(toPF _).\n  by rewrite !toL_K /toPF raddfD mulrDl modpD.\nhave nzL1: L1 != 0 by rewrite -(inj_eq toPinj) L1K /toPF raddf0 oner_eq0.\npose mulM := GRing.Zmodule_isComNzRing.Build _ mulA mulC mul1 mulD nzL1.\npose rL : comNzRingType := HB.pack vL mulM.\nhave mulZlM : GRing.Lmodule_isLalgebra F rL.\n  constructor => a x y; apply: toPinj.\n  by rewrite toL_K /toPF !linearZ /= -!/(toPF _) toL_K -scalerAl modpZl.\npose laL : lalgType F := HB.pack rL mulZlM.\nhave mulZrM : GRing.Lalgebra_isAlgebra F laL.\n  by constructor => a x y; rewrite !(mulrC x) scalerAl.\npose aL : algType F := HB.pack laL mulZrM.\npose uLM := Algebra_isFalgebra.Build F aL.\npose cuL : comUnitRingType := HB.pack aL uLM.\nhave unitM : GRing.ComUnitRing_isField cuL.\n  constructor => x nz_x; apply/unitrP; set q := toPF x.\n  have nz_q: q != 0 by rewrite -(inj_eq toPinj) /toPF raddf0 in nz_x.\n  have /Bezout_eq1_coprimepP[u upq1]: coprimep p q.\n    apply: contraLR (leq_gcdpr p nz_q) => /irr_p/implyP.\n    rewrite dvdp_gcdl -ltnNge /= => /eqp_size->.\n    by rewrite (polySpred nz_p) ltnS size_poly.\n  suffices: x * toL u.2 = 1 by exists (toL u.2); rewrite mulrC.\n  apply: toPinj; rewrite !toL_K -upq1 modp_mul modpD mulrC.\n  by rewrite modp_mull add0r.\npose feL : fieldExtType F := HB.pack vL aL cuL unitM.\nexists feL; first by rewrite dimvf; apply: mul1n.\nexists toPF.\nhave tol_lin: linear toL by move=> a q1 q2; rewrite -linearP -modpZl -modpD.\nhave tol_mul : multiplicative (toL : {poly F} -> aL).\n  by split=> [q r|];\n    apply: toPinj; rewrite !toL_K // modp_mul -!(mulrC r) modp_mul.\npose toLlM := GRing.isLinear.Build _ _ _ _ toL tol_lin.\npose toLmM := GRing.isMultiplicative.Build _ _ _ tol_mul.\npose toLLRM : {lrmorphism _ -> feL} := HB.pack toL toLlM toLmM.\nby exists toLLRM.\nQed.",
    "Lemma finNzRing_nontrivial : [set: R] != 1%g.\nProof. by apply/trivgPn; exists 1; rewrite ?inE ?oner_neq0. Qed.",
    "Lemma finNzRing_gt1 : 1 < #|R|.\nProof. by rewrite -cardsT cardG_gt1 finNzRing_nontrivial. Qed.",
    "Lemma card_finField_unit : #|[set: {unit F}]| = #|F|.-1.\nProof.\nby rewrite -(cardC1 0) cardsT card_sub; apply: eq_card => x; rewrite unitfE.\nQed.",
    "Lemma expf_card x : x ^+ #|F| = x :> F.\nProof.\nrewrite -[RHS]mulr1 -(ltn_predK (finNzRing_gt1 F)) exprS.\napply/eqP; rewrite -subr_eq0 -mulrBr mulf_eq0 subr_eq0 -implyNb -unitfE.\napply/implyP=> Ux; rewrite -(val_unitX _ (Sub x _)) -val_unit1 val_eqE.\nby rewrite -order_dvdn -card_finField_unit order_dvdG ?inE.\nQed.",
    "Lemma finField_genPoly : 'X^#|F| - 'X = \\prod_x ('X - x%:P) :> {poly F}.\nProof.\nset n := #|F|; set oppX := - 'X; set pF := LHS.\nhave le_oppX_n: size oppX <= n by rewrite size_polyN size_polyX finNzRing_gt1.\nhave: size pF = (size (enum F)).+1 by rewrite -cardE size_polyDl size_polyXn.\nmove/all_roots_prod_XsubC->; last by rewrite uniq_rootsE enum_uniq.\n  by rewrite big_enum lead_coefDl ?size_polyXn // lead_coefXn scale1r.\nby apply/allP=> x _; rewrite rootE !hornerE expf_card subrr.\nQed.",
    "Lemma finPcharP : {p | prime p & p \\in [pchar F]}.\nProof.\npose e := exponent [set: F]; have e_gt0: e > 0 by apply: exponent_gt0.\nhave: e%:R == 0 :> F by rewrite -zmodXgE expg_exponent // inE.\nby case/natf0_pchar/sigW=> // p pcharFp; exists p; rewrite ?(pcharf_prime pcharFp).\nQed.",
    "Lemma finField_is_abelem : is_abelem [set: F].\nProof.\nhave [p pr_p pcharFp] := finPcharP.\nby apply/is_abelemP; exists p; last apply: fin_ring_pchar_abelem.\nQed.",
    "Lemma card_finPcharP p n : #|F| = (p ^ n)%N -> prime p -> p \\in [pchar F].\nProof.\nmove=> oF pr_p; rewrite inE pr_p -order_dvdn.\nrewrite (abelem_order_p finField_is_abelem) ?inE ?oner_neq0 //=.\nhave n_gt0: n > 0 by rewrite -(ltn_exp2l _ _ (prime_gt1 pr_p)) -oF finNzRing_gt1.\nby rewrite cardsT oF -(prednK n_gt0) pdiv_pfactor.\nQed.",
    "Lemma card_vspace (V : {vspace vT}) : #|V| = (#|F| ^ \\dim V)%N.\nProof.\nset n := \\dim V; pose V2rV v := \\row_i coord (vbasis V) i v.\npose rV2V (rv : 'rV_n) := \\sum_i rv 0 i *: (vbasis V)`_i.\nhave rV2V_K: cancel rV2V V2rV.\n  have freeV: free (vbasis V) := basis_free (vbasisP V).\n  by move=> rv; apply/rowP=> i; rewrite mxE coord_sum_free.\nrewrite -[n]mul1n -card_mx -(card_imset _ (can_inj rV2V_K)).\napply: eq_card => v; apply/idP/imsetP=> [/coord_vbasis-> | [rv _ ->]].\n  by exists (V2rV v) => //; apply: eq_bigr => i _; rewrite mxE.\nby apply: (@rpred_sum vT) => i _; rewrite rpredZ ?vbasis_mem ?memt_nth.\nQed.",
    "Lemma card_vspacef : #|{: vT}%VS| = #|T|.\nProof. by apply: eq_card => v; rewrite (@memvf _ vT). Qed.",
    "Lemma card_vspace1 : #|(1%VS : {vspace aT})| = #|F|.\nProof. by rewrite card_vspace (dimv1 aT). Qed.",
    "Lemma ffT_splitting_subproof : SplittingField.axiom ffT.\nProof.\nexists ('X^#|ffT| - 'X).\n  by rewrite (@rpredB {poly fT}) 1?rpredX ?polyOverX.\nexists (enum ffT); first by rewrite big_enum finField_genPoly eqpxx.\nby apply/vspaceP=> x; rewrite memvf seqv_sub_adjoin ?mem_enum.\nQed.",
    "Lemma pprimeChar_scaleA a b x : a *p': (b *p': x) = (a * b) *p': x.\nProof. by rewrite /pprimeChar_scale mulrA -natrM natrFp. Qed.",
    "Lemma pprimeChar_scale1 : left_id 1 pprimeChar_scale.\nProof. by move=> x; rewrite /pprimeChar_scale mul1r. Qed.",
    "Lemma pprimeChar_scaleDr : right_distributive pprimeChar_scale +%R.\nProof. by move=> a x y /=; rewrite /pprimeChar_scale mulrDr. Qed.",
    "Lemma pprimeChar_scaleDl x : {morph pprimeChar_scale^~ x: a b / a + b}.\nProof. by move=> a b; rewrite /pprimeChar_scale natrFp natrD mulrDl. Qed.",
    "Lemma pprimeChar_scaleAl (a : 'F_p) (u v : R) :  a *: (u * v) = (a *: u) * v.\nProof. by apply: mulrA. Qed.",
    "Lemma pprimeChar_scaleAr (a : 'F_p) (x y : R) : a *: (x * y) = x * (a *: y).\nProof. by rewrite ![a *: _]mulr_natl mulrnAr. Qed.",
    "Lemma pprimeChar_abelem : p.-abelem [set: R].\nProof. exact: fin_Fp_lmod_abelem. Qed.",
    "Lemma pprimeChar_pgroup : p.-group [set: R].\nProof. by case/and3P: pprimeChar_abelem. Qed.",
    "Lemma order_pprimeChar x : x != 0 :> R -> #[x]%g = p.\nProof. by apply: (abelem_order_p pprimeChar_abelem); rewrite inE. Qed.",
    "Lemma card_pprimeChar : #|R| = (p ^ n)%N.\nProof. by rewrite /n -cardsT {1}(card_pgroup pprimeChar_pgroup). Qed.",
    "Lemma pprimeChar_vectAxiom : Vector.axiom n R.\nProof.\nhave /isog_isom/=[f /isomP[injf im_f]]: [set: R] \\isog [set: 'rV['F_p]_n].\n  rewrite (@isog_abelem_card _ _ p) fin_Fp_lmod_abelem //=.\n  by rewrite !cardsT card_pprimeChar card_mx mul1n card_Fp.\nexists f; last by exists (invm injf) => x; rewrite ?invmE ?invmK ?im_f ?inE.\nmove=> a x y; rewrite [a *: _]mulr_natl morphM ?morphX ?inE // zmodXgE.\nby congr (_ + _); rewrite -scaler_nat natr_Zp.\nQed.",
    "Lemma pprimeChar_dimf : \\dim {: R : vectType 'F_p } = n.\nProof. by rewrite dimvf. Qed.",
    "Lemma finField_galois K E : (K <= E)%VS -> galois K E.\nProof.\nmove=> sKE; have /galois_fixedField <- := galL E.\nrewrite normal_fixedField_galois // -sub_abelian_normal ?galS //.\napply: abelianS (galS _ (sub1v _)) _.\nby have [alpha /('Gal(_ / _) =P _)-> _] := galLgen 1; apply: cycle_abelian.\nQed.",
    "Lemma finField_galois_generator K E :\n   (K <= E)%VS ->\n {alpha | generator 'Gal(E / K) alpha\n        & {in E, forall x, alpha x = x ^+ order K}}.\nProof.\nmove=> sKE; have [alpha defGalLK Dalpha] := galLgen K.\nhave inKL_E: (K <= E <= {:L})%VS by rewrite sKE subvf.\nhave nKE: normalField K E by have/and3P[] := finField_galois sKE.\nhave galLKalpha: alpha \\in 'Gal({:L} / K).\n  by rewrite (('Gal(_ / _) =P _) defGalLK) cycle_id.\nexists (normalField_cast _ alpha) => [|x Ex]; last first.\n  by rewrite (normalField_cast_eq inKL_E).\nrewrite /generator -(morphim_cycle (normalField_cast_morphism inKL_E nKE)) //.\nby rewrite -((_ =P <[alpha]>) defGalLK) normalField_img.\nQed.",
    "Lemma Fermat's_little_theorem (L : fieldExtType F) (K : {subfield L}) a :\n  (a \\in K) = (a ^+ order K == a).\nProof.\nmove: K a; wlog [{}L -> K a]: L / exists galL : splittingFieldType F, L = galL.\n  by pose galL := FinSplittingFieldType F L => /(_ galL); apply; exists galL.\nhave /galois_fixedField fixLK := finField_galois (subvf K).\nhave [alpha defGalLK Dalpha] := finField_galois_generator (subvf K).\nrewrite -Dalpha ?memvf // -{1}fixLK (('Gal(_ / _) =P _) defGalLK).\nrewrite /cycle -gal_generated (galois_fixedField _) ?fixedField_galois //.\nby apply/fixedFieldP/eqP=> [|-> | alpha_x _ /set1P->]; rewrite ?memvf ?set11.\nQed.",
    "Lemma FinSplittingFieldFor (F : finFieldType) (p : {poly F}) :\n  p != 0 -> {L : splittingFieldType F | splittingFieldFor 1 p^%:A {:L}}.\nProof.\nhave mapXsubC (f : {rmorphism _ -> _}) x:\n    map_poly f ('X - x%:P) = 'X - (f x)%:P.\n  by rewrite rmorphB /= map_polyX map_polyC.\nmove=> nz_p; pose splits q := {zs | q %= \\prod_(z <- zs) ('X - z%:P)}.\nsuffices [L splitLp]: {L : fieldExtType F | splittingFieldFor 1 p^%:A {:L}}.\n  by exists (FinSplittingFieldType F L).\nsuffices [L [ys Dp]]: {L : fieldExtType F & splits L p^%:A}.\n  pose Lp := subvs_of <<1 & ys>>; pose toL := linfun (vsval : Lp -> L).\n  have [zs Dys]: {zs | map toL zs = ys}.\n    exists (map (vsproj _) ys); rewrite -map_comp map_id_in // => y ys_y.\n    by rewrite /= lfunE /= vsprojK ?seqv_sub_adjoin.\n  exists Lp, zs.\n    set lhs := (lhs in lhs %= _); set rhs := (rhs in _ %= rhs).\n    suffices: map_poly toL lhs %= map_poly toL rhs by rewrite eqp_map.\n    rewrite -Dys big_map in Dp; apply: etrans Dp; apply: congr2.\n      by rewrite -map_poly_comp; apply/eq_map_poly=> x; apply: rmorph_alg.\n    by rewrite rmorph_prod; apply/eq_bigr=> z _; apply mapXsubC.\n  set Lzs := LHS; pose Lys := (toL @: Lzs)%VS; apply/vspaceP=> u.\n  have: val u \\in Lys by rewrite /Lys aimg_adjoin_seq aimg1 Dys (valP u).\n  by case/memv_imgP=> v Lzs_v; rewrite memvf lfunE => /val_inj->.\nmove: {2}_.+1 (ltnSn (size p)) => n; elim: n => // n IHn in F p nz_p * => lbn.\nhave [Cp|C'p] := leqP (size p) 1.\n  exists F^o, [::].\n  by rewrite big_nil -size_poly_eq1 size_map_poly eqn_leq Cp size_poly_gt0.\nhave [r r_dv_p irr_r]: {r | r %| p & irreducible_poly r}.\n  pose rVp (v : 'rV_n) (r := rVpoly v) := (1 < size r) && (r %| p).\n  have [v0 Dp]: {v0 | rVpoly v0 = p & rVp v0}.\n    by exists (poly_rV p); rewrite /rVp poly_rV_K ?C'p /=.\n  case/(arg_minnP (size \\o rVpoly))=> /= v; set r := rVpoly v.\n  case/andP=> C'r r_dv_p min_r; exists r => //; split=> // q C'q q_dv_r.\n  have nz_r: r != 0 by rewrite -size_poly_gt0 ltnW.\n  have le_q_r: size q <= size r by rewrite dvdp_leq.\n  have [u Dq]: {u : 'rV_n | rVpoly u = q}.\n    by exists (poly_rV q); rewrite poly_rV_K ?(leq_trans le_q_r) ?size_poly.\n  rewrite -dvdp_size_eqp // eqn_leq le_q_r -Dq min_r // /rVp Dq.\n  rewrite ltn_neqAle eq_sym C'q size_poly_gt0 (dvdpN0 q_dv_r) //=.\n  exact: dvdp_trans q_dv_r r_dv_p.\nhave{irr_r} [K _ [x rx0 defK]] := irredp_FAdjoin irr_r.\nhave{r rx0 r_dv_p} /factor_theorem/sig_eqW[q Dp]: root p^%:A x.\n  by rewrite -(divpK r_dv_p) [_^%:A]rmorphM rootM rx0 orbT.\nhave Dszp: size p = size (q * ('X - x%:P)) by rewrite -Dp size_map_poly.\nhave nz_q: q != 0.\n  by move: nz_p; rewrite -size_poly_eq0 Dszp size_poly_eq0 mulf_eq0 => /norP[].\nhave [L [zs Dq]]: {L : fieldExtType K & splits L q^%:A}.\n  apply: (IHn (FinFieldExtType K) q nz_q).\n  by rewrite ltnS Dszp size_mul ?polyXsubC_eq0 ?size_XsubC ?addn2 in lbn.\nsuffices: splits L p^%:A^%:A.\n  rewrite -[_^%:A]map_poly_comp.\n\n  rewrite -(eq_map_poly (fun a : F => baseField_scaleE a 1)).\n  by exists (baseFieldType L).\nexists (x%:A :: zs); rewrite big_cons; set rhs := _ * _.\nby rewrite Dp mulrC [_^%:A]rmorphM /= mapXsubC /= eqp_mull.\nQed.",
    "Lemma pPrimePowerField p k (m := (p ^ k)%N) :\n  prime p -> 0 < k -> {Fm : finFieldType | p \\in [pchar Fm] & #|Fm| = m}.\nProof.\nmove=> pr_p k_gt0; have m_gt1: m > 1 by rewrite (ltn_exp2l 0) ?prime_gt1.\nhave m_gt0 := ltnW m_gt1; have m1_gt0: m.-1 > 0 by rewrite -ltnS prednK.\npose q := 'X^m - 'X; have Dq R: q R = ('X^m.-1 - 1) * ('X - 0).\n  by rewrite subr0 mulrBl mul1r -exprSr prednK.\nhave /FinSplittingFieldFor[/= L splitLq]: q 'F_p != 0.\n  by rewrite Dq monic_neq0 ?rpredM ?monicXsubC ?monicXnsubC.\nrewrite [_^%:A]rmorphB rmorphXn /= map_polyX -/(q L) in splitLq.\nhave pcharL: p \\in [pchar L] by rewrite pchar_lalg pchar_Fp.\npose Fm := FinFieldExtType L; exists Fm => //.\nhave /finField_galois_generator[/= a _ Da]: (1 <= {:L})%VS by apply: sub1v.\npose Em := fixedSpace (a ^+ k)%g; rewrite card_Fp //= dimv1 expn1 in Da.\nhave{splitLq} [zs DqL defL] := splitLq.\nhave Uzs: uniq zs.\n  rewrite -separable_prod_XsubC -(eqp_separable DqL) Dq separable_root andbC.\n  rewrite /root !hornerE subr_eq0 eq_sym expr0n gtn_eqF ?oner_eq0 //=.\n  rewrite cyclotomic.separable_Xn_sub_1 // -subn1 natrB // subr_eq0.\n  by rewrite natrX pcharf0 // expr0n gtn_eqF // eq_sym oner_eq0.\nsuffices /eq_card->: Fm =i zs.\n  apply: succn_inj; rewrite (card_uniqP _) //= -(size_prod_XsubC _ id).\n  by rewrite -(eqp_size DqL) size_polyDl size_polyXn // size_polyN size_polyX.\nhave in_zs: zs =i Em.\n  move=> z; rewrite -root_prod_XsubC -(eqp_root DqL) (sameP fixedSpaceP eqP).\n  rewrite /root !hornerE subr_eq0 /= /m; congr (_ == z).\n  elim: (k) => [|i IHi]; first by rewrite gal_id.\n  by rewrite expgSr expnSr exprM IHi galM ?Da ?memvf.\nsuffices defEm: Em = {:L}%VS by move=> z; rewrite in_zs defEm memvf.\napply/eqP; rewrite eqEsubv subvf -defL -[Em]subfield_closed agenvS //.\nby rewrite subv_add sub1v; apply/span_subvP=> z; rewrite in_zs.\nQed.",
    "Lemma finDomain_field : GRing.field_axiom R.\nProof.\nmove=> x /lregR-regx; apply/unitrP; exists (invF regx 1).\nby split; first apply: (regx); rewrite ?mulrA f_invF // mulr1 mul1r.\nQed.",
    "Lemma splittingFieldForS (K M E : {subfield L}) p :\n    (K <= M)%VS -> (M <= E)%VS ->\n  splittingFieldFor K p E -> splittingFieldFor M p E.\nProof.\nmove=> sKM sKE [rs Dp genL]; exists rs => //; apply/eqP.\nrewrite eqEsubv -[in X in _ && (X <= _)%VS]genL adjoin_seqSl // andbT.\nby apply/Fadjoin_seqP; split; rewrite // -genL; apply: seqv_sub_adjoin.\nQed.",
    "Lemma kHomP {K V f} :\n  reflect [/\\ {in V &, forall x y, f (x * y) = f x * f y}\n            & {in K, forall x, f x = x}]\n          (kHom K V f).\nProof.\napply: (iffP andP) => [[/ahom_inP[fM _] /subvP idKf] | [fM idKf]].\n  by split=> // x /idKf/fixedSpaceP.\nsplit; last by apply/subvP=> x /idKf/fixedSpaceP.\nby apply/ahom_inP; split=> //; rewrite idKf ?mem1v.\nQed.",
    "Lemma kAHomP {U V} {f : 'AEnd(L)} :\n  reflect {in U, forall x, f x = x} (kHom U V f).\nProof. by rewrite /kHom ahomWin; apply: fixedSpacesP. Qed.",
    "Lemma kHom1 U V : kHom U V \\1.\nProof. by apply/kAHomP => u _; rewrite lfunE. Qed.",
    "Lemma k1HomE V f : kHom 1 V f = ahom_in V f.\nProof. by apply: andb_idr => /ahom_inP[_ f1]; apply/fixedSpaceP. Qed.",
    "Lemma kHom_lrmorphism (f : 'End(L)) : reflect (multiplicative f) (kHom 1 {:L} f).\nProof. by rewrite k1HomE; apply: ahomP. Qed.",
    "Lemma k1AHom V (f : 'AEnd(L)) : kHom 1 V f.\nProof. by rewrite k1HomE ahomWin. Qed.",
    "Lemma kHom_poly_id K E f p :\n  kHom K E f -> p \\is a polyOver K -> map_poly f p = p.\nProof.\nby case/kHomP=> _ idKf /polyOverP Kp; apply/polyP=> i; rewrite coef_map /= idKf.\nQed.",
    "Lemma kHomSl U1 U2 V f : (U1 <= U2)%VS -> kHom U2 V f -> kHom U1 V f.\nProof. by rewrite /kHom => sU12 /andP[-> /(subv_trans sU12)]. Qed.",
    "Lemma kHomSr K V1 V2 f : (V1 <= V2)%VS -> kHom K V2 f -> kHom K V1 f.\nProof. by move/subvP=> sV12 /kHomP[/(sub_in2 sV12)fM idKf]; apply/kHomP. Qed.",
    "Lemma kHomS K1 K2 V1 V2 f :\n  (K1 <= K2)%VS -> (V1 <= V2)%VS -> kHom K2 V2 f -> kHom K1 V1 f.\nProof. by move=> sK12 sV12 /(kHomSl sK12)/(kHomSr sV12). Qed.",
    "Lemma kHom_eq K E f g :\n  (K <= E)%VS -> {in E, f =1 g} -> kHom K E f = kHom K E g.\nProof.\nmove/subvP=> sKE eq_fg; wlog suffices: f g eq_fg / kHom K E f -> kHom K E g.\n  by move=> IH; apply/idP/idP; apply: IH => x /eq_fg.\ncase/kHomP=> fM idKf; apply/kHomP.\nby split=> [x y Ex Ey | x Kx]; rewrite -!eq_fg ?fM ?rpredM // ?idKf ?sKE.\nQed.",
    "Lemma kHom_inv K E f : kHom K E f -> {in E, {morph f : x / x^-1}}.\nProof.\ncase/kHomP=> fM idKf x Ex.\nhave [-> | nz_x] := eqVneq x 0; first by rewrite linear0 invr0 linear0.\nhave fxV: f x * f x^-1 = 1 by rewrite -fM ?rpredV ?divff // idKf ?mem1v.\nhave Ufx: f x \\is a GRing.unit by apply/unitrPr; exists (f x^-1).\nby apply: (mulrI Ufx); rewrite divrr.\nQed.",
    "Lemma kHom_dim K E f : kHom K E f -> \\dim (f @: E) = \\dim E.\nProof.\nmove=> homKf; have [fM idKf] := kHomP homKf.\napply/limg_dim_eq/eqP; rewrite -subv0; apply/subvP=> v.\nrewrite memv_cap memv0 memv_ker => /andP[Ev]; apply: contraLR => nz_v.\nby rewrite -unitfE unitrE -(kHom_inv homKf) // -fM ?rpredV ?divff ?idKf ?mem1v.\nQed.",
    "Lemma kHom_is_additive : kHom K E f -> additive kHomf.\nProof. by case/kHomP => fM idKf; apply: raddfB. Qed.",
    "Lemma kHom_is_multiplicative : kHom K E f -> multiplicative kHomf.\nProof.\ncase/kHomP=> fM idKf; rewrite /kHomf.\nby split=> [a b|] /=; [rewrite /= fM ?subvsP | rewrite algid1 idKf // mem1v].\nQed.",
    "Lemma kHom_horner K E f p x :\n  kHom K E f -> p \\is a polyOver E -> x \\in E -> f p.[x] = (map_poly f p).[f x].\nProof.\nmove=> homKf /polyOver_subvs[{}p -> Ex]; pose fRM := kHom_rmorphism homKf.\nby rewrite (horner_map _ _ (Subvs Ex)) -[f _](horner_map fRM) map_poly_comp.\nQed.",
    "Lemma kHom_root K E f p x :\n    kHom K E f -> p \\is a polyOver E -> x \\in E -> root p x ->\n  root (map_poly f p) (f x).\nProof.\nby move/kHom_horner=> homKf Ep Ex /rootP px0; rewrite /root -homKf ?px0 ?raddf0.\nQed.",
    "Lemma kHom_root_id K E f p x :\n   (K <= E)%VS -> kHom K E f -> p \\is a polyOver K -> x \\in E -> root p x ->\n  root p (f x).\nProof.\nmove=> sKE homKf Kp Ex /(kHom_root homKf (polyOverSv sKE Kp) Ex).\nby rewrite (kHom_poly_id homKf).\nQed.",
    "Lemma kHomExtendE z : kHomExtend z = (map_poly f (Fadjoin_poly E x z)).[y].\nProof. by rewrite lfunE. Qed.",
    "Lemma kHomExtend_id z : z \\in E -> kHomExtend z = f z.\nProof. by move=> Ez; rewrite kHomExtendE Fadjoin_polyC ?map_polyC ?hornerC. Qed.",
    "Lemma kHomExtend_val : kHomExtend x = y.\nProof.\nhave fX: map_poly f 'X = 'X by rewrite (kHom_poly_id homKf) ?polyOverX.\nhave [Ex | E'x] := boolP (x \\in E); last first.\n  by rewrite kHomExtendE Fadjoin_polyX // fX hornerX.\nhave:= fPx_y_0; rewrite (minPoly_XsubC Ex) raddfB /= map_polyC fX root_XsubC /=.\nby rewrite (kHomExtend_id Ex) => /eqP->.\nQed.",
    "Lemma kHomExtend_poly p :\n  p \\in polyOver E -> kHomExtend p.[x] = (map_poly f p).[y].\nProof.\nmove=> Ep; rewrite kHomExtendE (Fadjoin_poly_mod x) //.\nrewrite (divp_eq (map_poly f p) (map_poly f Px)).\nrewrite !hornerE (rootP fPx_y_0) mulr0 add0r.\nhave [p1 ->] := polyOver_subvs Ep.\nhave [Px1 ->] := polyOver_subvs (minPolyOver E x).\nby rewrite -map_modp -!map_poly_comp (map_modp (kHom_rmorphism homKf)).\nQed.",
    "Lemma kHomExtendP : kHom K <<E; x>> kHomExtend.\nProof.\nhave [fM idKf] := kHomP homKf.\napply/kHomP; split=> [|z Kz]; last by rewrite kHomExtend_id ?(subvP sKE) ?idKf.\nmove=> _ _ /Fadjoin_polyP[p Ep ->] /Fadjoin_polyP[q Eq ->].\nrewrite -hornerM !kHomExtend_poly ?rpredM // -hornerM; congr _.[_].\napply/polyP=> i; rewrite coef_map !coefM /= linear_sum /=.\nby apply: eq_bigr => j _; rewrite !coef_map /= fM ?(polyOverP _).\nQed.",
    "Lemma kAutE K E f : kAut K E f = kHom K E f && (f @: E <= E)%VS.\nProof.\napply/andP/andP=> [[-> /eqP->] // | [homKf EfE]].\nby rewrite eqEdim EfE /= (kHom_dim homKf).\nQed.",
    "Lemma kAutS U1 U2 V f : (U1 <= U2)%VS -> kAut U2 V f -> kAut U1 V f.\nProof. by move=> sU12 /andP[/(kHomSl sU12)homU1f EfE]; apply/andP. Qed.",
    "Lemma kHom_kAut_sub K E f : kAut K E f -> kHom K E f. Proof. by case/andP. Qed.",
    "Lemma kAut_eq K E (f g : 'End(L)) :\n  (K <= E)%VS -> {in E, f =1 g} -> kAut K E f = kAut K E g.\nProof.\nby move=> sKE eq_fg; rewrite !kAutE (kHom_eq sKE eq_fg) (eq_in_limg eq_fg).\nQed.",
    "Lemma kAutfE K f : kAut K {:L} f = kHom K {:L} f.\nProof. by rewrite kAutE subvf andbT. Qed.",
    "Lemma kAut1E E (f : 'AEnd(L)) : kAut 1 E f = (f @: E <= E)%VS.\nProof. by rewrite kAutE k1AHom. Qed.",
    "Lemma kAutf_lker0 K f : kHom K {:L} f -> lker f == 0%VS.\nProof.\nmove/(kHomSl (sub1v _))/kHom_lrmorphism=> fM.\npose fmM := GRing.isMultiplicative.Build _ _ _ fM.\npose fRM : {rmorphism _ -> _} := HB.pack (fun_of_lfun f) fmM.\nby apply/lker0P; apply: (fmorph_inj fRM).\nQed.",
    "Lemma inv_kHomf K f : kHom K {:L} f -> kHom K {:L} f^-1.\nProof.\nmove=> homKf; have [[fM idKf] kerf0] := (kHomP homKf, kAutf_lker0 homKf).\nhave f1K: cancel f^-1%VF f by apply: lker0_lfunVK.\napply/kHomP; split=> [x y _ _ | x Kx]; apply: (lker0P kerf0).\n  by rewrite fM ?memvf ?{1}f1K.\nby rewrite f1K idKf.\nQed.",
    "Lemma inv_is_ahom (f : 'AEnd(L)) : ahom_in {:L} f^-1.\nProof.\nhave /ahomP/kHom_lrmorphism hom1f := valP f.\nexact/ahomP/kHom_lrmorphism/inv_kHomf.\nQed.",
    "Lemma comp_kHom_img K E f g :\n  kHom K (g @: E) f -> kHom K E g -> kHom K E (f \\o g).\nProof.\nmove=> /kHomP[fM idKf] /kHomP[gM idKg]; apply/kHomP; split=> [x y Ex Ey | x Kx].\n  by rewrite !lfunE /= gM // fM ?memv_img.\nby rewrite lfunE /= idKg ?idKf.\nQed.",
    "Lemma comp_kHom K E f g : kHom K {:L} f -> kHom K E g -> kHom K E (f \\o g).\nProof. by move/(kHomSr (subvf (g @: E))); apply: comp_kHom_img. Qed.",
    "Lemma kHom_extends K E f p U :\n    (K <= E)%VS -> kHom K E f ->\n     p \\is a polyOver K -> splittingFieldFor E p U ->\n  {g | kHom K U g & {in E, f =1 g}}.\nProof.\nmove=> sKE homEf Kp /sig2_eqW[rs Dp <-{U}].\nset r := rs; have rs_r: all [in rs] r by apply/allP.\nelim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in E f sKE homEf *.\n  by exists f; rewrite ?Fadjoin_nil.\nset Ez := <<E; z>>%AS; pose fpEz := map_poly f (minPoly E z).\nsuffices{IHr} /sigW[y fpEz_y]: exists y, root fpEz y.\n  have homEz_fz: kHom K Ez (kHomExtend E f z y) by apply: kHomExtendP.\n  have sKEz: (K <= Ez)%VS := subv_trans sKE (subv_adjoin E z).\n  have [g homGg Dg] := IHr rs_r _ _ sKEz homEz_fz.\n  exists g => [|x Ex]; first by rewrite adjoin_cons.\n  by rewrite -Dg ?subvP_adjoin // kHomExtend_id.\nhave [m DfpEz]: {m | fpEz %= \\prod_(w <- mask m rs) ('X - w%:P)}.\n  apply: dvdp_prod_XsubC; rewrite -(eqp_dvdr _ Dp) -(kHom_poly_id homEf Kp).\n  have /polyOver_subvs[q Dq] := polyOverSv sKE Kp.\n  have /polyOver_subvs[qz Dqz] := minPolyOver E z.\n  rewrite /fpEz Dq Dqz -2?{1}map_poly_comp (dvdp_map (kHom_rmorphism homEf)).\n  rewrite -(dvdp_map (@vsval _ _ E)) -Dqz -Dq.\n  by rewrite minPoly_dvdp ?(polyOverSv sKE) // (eqp_root Dp) root_prod_XsubC.\nexists (mask m rs)`_0; rewrite (eqp_root DfpEz) root_prod_XsubC mem_nth //.\nrewrite -ltnS -(size_prod_XsubC _ id) -(eqp_size DfpEz).\nrewrite size_poly_eq -?lead_coefE ?size_minPoly // (monicP (monic_minPoly E z)).\nby have [_ idKf] := kHomP homEf; rewrite idKf ?mem1v ?oner_eq0.\nQed.",
    "Lemma normal_field_splitting (F : fieldType) (L : fieldExtType F) :\n  (forall (K : {subfield L}) x,\n    exists r, minPoly K x == \\prod_(y <- r) ('X - y%:P)) ->\n  SplittingField.axiom L.\nProof.\nmove=> normalL; pose r i := sval (sigW (normalL 1%AS (tnth (vbasis {:L}) i))).\nhave sz_r i: size (r i) <= \\dim {:L}.\n  rewrite -ltnS -(size_prod_XsubC _ id) /r; case: sigW => _ /= /eqP <-.\n  rewrite size_minPoly ltnS; move: (tnth _ _) => x.\n  by rewrite adjoin_degreeE dimv1 divn1 dimvS // subvf.\npose mkf (z : L) := 'X - z%:P.\nexists (\\prod_i \\prod_(j < \\dim {:L} | j < size (r i)) mkf (r i)`_j).\n  apply: rpred_prod => i _; rewrite big_ord_narrow /= /r; case: sigW => rs /=.\n  by rewrite (big_nth 0) big_mkord => /eqP <- {rs}; apply: minPolyOver.\nrewrite pair_big_dep /= -big_filter -(big_map _ xpredT mkf).\nset rF := map _ _; exists rF; first exact: eqpxx.\napply/eqP; rewrite eqEsubv subvf -(span_basis (vbasisP {:L})).\napply/span_subvP=> _ /tnthP[i ->]; set x := tnth _ i.\nhave /tnthP[j ->]: x \\in in_tuple (r i).\n  by rewrite -root_prod_XsubC /r; case: sigW => _ /=/eqP<-; apply: root_minPoly.\napply/seqv_sub_adjoin/mapP; rewrite (tnth_nth 0).\nexists (i, widen_ord (sz_r i) j) => //.\nby rewrite mem_filter /= ltn_ord mem_index_enum.\nQed.",
    "Lemma splittingFieldP : SplittingField.axiom L.\nProof. exact: splittingFieldP_subproof. Qed.",
    "Lemma splittingPoly :\n  {p : {poly L} | p \\is a polyOver 1%VS & splittingFieldFor 1 p {:L}}.\nProof.\npose factF p s := (p \\is a polyOver 1%VS) && (p %= \\prod_(z <- s) ('X - z%:P)).\nsuffices [[p rs] /andP[]]: {ps | factF F L ps.1 ps.2 & <<1 & ps.2>> = {:L}}%VS.\n  by exists p; last exists rs.\napply: sig2_eqW; have [p F0p [rs splitLp genLrs]] := splittingFieldP.\nby exists (p, rs); rewrite // /factF F0p splitLp.\nQed.",
    "Lemma enum_AEnd : {kAutL : seq 'AEnd(L) | forall f, f \\in kAutL}.\nProof.\npose isAutL (s : seq 'AEnd(L)) (f : 'AEnd(L)) := kHom 1 {:L} f = (f \\in s).\nsuffices [kAutL in_kAutL] : {kAutL : seq 'AEnd(L) | forall f, isAutL kAutL f}.\n  by exists kAutL => f; rewrite -in_kAutL k1AHom.\nhave [p Kp /sig2_eqW[rs Dp defL]] := splittingPoly.\ndo [rewrite {}/isAutL -(erefl (asval 1)); set r := rs; set E := 1%AS] in defL *.\nhave [sKE rs_r]: (1 <= E)%VS /\\ all [in rs] r by split; last apply/allP.\nelim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in (E) sKE defL *.\n  rewrite Fadjoin_nil in defL; exists [tuple \\1%AF] => f; rewrite defL inE.\n  apply/idP/eqP=> [/kAHomP f1 | ->]; last exact: kHom1.\n  by apply/val_inj/lfunP=> x; rewrite id_lfunE f1 ?memvf.\ndo [set Ez := <<E; z>>%VS; rewrite adjoin_cons] in defL.\nhave sEEz: (E <= Ez)%VS := subv_adjoin E z; have sKEz := subv_trans sKE sEEz.\nhave{IHr} [homEz DhomEz] := IHr rs_r _ sKEz defL.\nhave Ep: p \\in polyOver E := polyOverSv sKE Kp.\nhave{rs_z} pz0: root p z by rewrite (eqp_root Dp) root_prod_XsubC.\npose pEz := minPoly E z; pose n := \\dim_E Ez.\nhave{pz0} [rz DpEz]: {rz : n.-tuple L | pEz %= \\prod_(w <- rz) ('X - w%:P)}.\n  have /dvdp_prod_XsubC[m DpEz]: pEz %| \\prod_(w <- rs) ('X - w%:P).\n    by rewrite -(eqp_dvdr _ Dp) minPoly_dvdp ?(polyOverSv sKE).\n  suffices sz_rz: size (mask m rs) == n by exists (Tuple sz_rz).\n  rewrite -[n]adjoin_degreeE -eqSS -size_minPoly.\n  by rewrite (eqp_size DpEz) size_prod_XsubC.\nhave fEz i (y := tnth rz i): {f : 'AEnd(L) | kHom E {:L} f & f z = y}.\n  have homEfz: kHom E Ez (kHomExtend E \\1 z y).\n    rewrite kHomExtendP ?kHom1 // lfun1_poly.\n    by rewrite (eqp_root DpEz) -/rz root_prod_XsubC mem_tnth.\n  have splitFp: splittingFieldFor Ez p {:L}.\n    exists rs => //; apply/eqP; rewrite eqEsubv subvf -defL adjoin_seqSr //.\n    exact/allP.\n  have [f homLf Df] := kHom_extends sEEz homEfz Ep splitFp.\n  have [ahomf _] := andP homLf; exists (AHom ahomf) => //.\n  rewrite -Df ?memv_adjoin ?(kHomExtend_val (kHom1 E E)) // lfun1_poly.\n  by rewrite (eqp_root DpEz) root_prod_XsubC mem_tnth.\nexists [seq (s2val (fEz i) \\o f)%AF| i <- enum 'I_n, f <- homEz] => f.\napply/idP/allpairsP => [homLf | [[i g] [_ Hg ->]] /=]; last first.\n  by case: (fEz i) => fi /= /comp_kHom->; rewrite ?(kHomSl sEEz) ?DhomEz.\nhave /tnthP[i Dfz]: f z \\in rz.\n  rewrite memtE /= -root_prod_XsubC -(eqp_root DpEz).\n  by rewrite (kHom_root_id _ homLf) ?memvf ?subvf ?minPolyOver ?root_minPoly.\ncase Dfi: (fEz i) => [fi homLfi fi_z]; have kerfi0 := kAutf_lker0 homLfi.\nset fj := (fi ^-1 \\o f)%AF; suffices Hfj : fj \\in homEz.\n  exists (i, fj) => //=; rewrite mem_enum inE Hfj; split => //.\n  by apply/val_inj; rewrite {}Dfi /= (lker0_compVKf kerfi0).\nrewrite -DhomEz; apply/kAHomP => _ /Fadjoin_polyP[q Eq ->].\nhave homLfj: kHom E {:L} fj := comp_kHom (inv_kHomf homLfi) homLf.\nhave /kHom_lrmorphism fjM := kHomSl (sub1v _) homLfj.\npose fjmM := GRing.isMultiplicative.Build _ _ _ fjM.\npose fjRM : {rmorphism _ -> _} := HB.pack (fun_of_lfun fj) fjmM.\nrewrite -[fj _](horner_map fjRM) (kHom_poly_id homLfj) //=.\nby rewrite (@lfunE _ _ L) /= Dfz -fi_z lker0_lfunK.\nQed.",
    "Lemma splitting_field_normal K x :\n  exists r, minPoly K x == \\prod_(y <- r) ('X - y%:P).\nProof.\npose q1 := minPoly 1 x; pose fx_root q (f : 'AEnd(L)) := root q (f x).\nhave [[p F0p splitLp] [autL DautL]] := (splittingFieldP, enum_AEnd).\nsuffices{K} autL_px q: q != 0 -> q %| q1 -> size q > 1 -> has (fx_root q) autL.\n  set q := minPoly K x; have: q \\is monic := monic_minPoly K x.\n  have: q %| q1 by rewrite minPolyS // sub1v.\n  have [d] := ubnP (size q); elim: d q => // d IHd q leqd q_dv_q1 mon_q.\n  have nz_q: q != 0 := monic_neq0 mon_q.\n  have [|q_gt1|q_1] := ltngtP (size q) 1; last first; last by rewrite polySpred.\n    by exists nil; rewrite big_nil -eqp_monic ?monic1 // -size_poly_eq1 q_1.\n  have /hasP[f autLf /factor_theorem[q2 Dq]] := autL_px q nz_q q_dv_q1 q_gt1.\n  have mon_q2: q2 \\is monic by rewrite -(monicMr _ (monicXsubC (f x))) -Dq.\n  rewrite Dq size_monicM -?size_poly_eq0 ?size_XsubC ?addn2 //= ltnS in leqd.\n  have q2_dv_q1: q2 %| q1 by rewrite (dvdp_trans _ q_dv_q1) // Dq dvdp_mulr.\n  rewrite Dq; have [r /eqP->] := IHd q2 leqd q2_dv_q1 mon_q2.\n  by exists (f x :: r); rewrite big_cons mulrC.\nhave [d] := ubnP (size q); elim: d q => // d IHd q leqd nz_q q_dv_q1 q_gt1.\nwithout loss{d leqd IHd nz_q q_gt1} irr_q: q q_dv_q1 / irreducible_poly q.\n  move=> IHq; apply: wlog_neg => not_autLx_q; apply: IHq => //.\n  split=> // q2 q2_neq1 q2_dv_q; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  rewrite leqNgt; apply: contra not_autLx_q => ltq2q.\n  have nz_q2: q2 != 0 by apply: contraTneq q2_dv_q => ->; rewrite dvd0p.\n  have{q2_neq1} q2_gt1: size q2 > 1 by rewrite neq_ltn polySpred in q2_neq1 *.\n  have{leqd ltq2q} ltq2d: size q2 < d by apply: leq_trans ltq2q _.\n  apply: sub_has (IHd _ ltq2d nz_q2 (dvdp_trans q2_dv_q q_dv_q1) q2_gt1) => f.\n  by rewrite /fx_root !root_factor_theorem => /dvdp_trans->.\nhave{irr_q} [Lz [inLz [z qz0]]]: {Lz : fieldExtType F &\n  {inLz : 'AHom(L, Lz) & {z : Lz | root (map_poly inLz q) z}}}.\n- have [Lz0 _ [z qz0 defLz]] := irredp_FAdjoin irr_q.\n  pose Lz : fieldExtType _ := baseFieldType Lz0.\n  pose inLz : {rmorphism L -> Lz} := in_alg Lz0.\n  have inLzL_linear: linear (locked inLz).\n    by move=> a u v; rewrite -[in LHS]mulr_algl rmorphD rmorphM -lock mulr_algl.\n  pose inLzLlM := GRing.isLinear.Build _ _ _ _ _ inLzL_linear.\n  pose inLzLL : {linear _ -> _} := HB.pack (locked inLz : _ -> _) inLzLlM.\n  have ihLzZ: ahom_in {:L} (linfun inLzLL).\n    by apply/ahom_inP; split=> [u v|]; rewrite !lfunE (rmorphM, rmorph1).\n  exists Lz, (AHom ihLzZ), z; congr (root _ z): qz0.\n  by apply: eq_map_poly => y; rewrite lfunE /= -lock.\npose imL := [aspace of limg inLz]; pose pz := map_poly inLz p.\nhave in_imL u: inLz u \\in imL by rewrite memv_img ?memvf.\nhave F0pz: pz \\is a polyOver 1%VS.\n  apply/polyOverP=> i; rewrite -(aimg1 inLz) coef_map /= memv_img //.\n  exact: (polyOverP F0p).\nhave{splitLp} splitLpz: splittingFieldFor 1 pz imL.\n  have [r def_p defL] := splitLp; exists (map inLz r) => [|{def_p}].\n    move: def_p; rewrite -(eqp_map inLz) rmorph_prod.\n    rewrite big_map; congr (_ %= _); apply: eq_big => //= y _.\n    by rewrite rmorphB /= map_polyX map_polyC.\n  apply/eqP; rewrite eqEsubv /= -{2}defL {defL}; apply/andP; split.\n    by apply/Fadjoin_seqP; rewrite sub1v; split=> // _ /mapP[y r_y ->].\n  elim/last_ind: r => [|r y IHr] /=; first by rewrite !Fadjoin_nil aimg1.\n  rewrite map_rcons !adjoin_rcons /=.\n  apply/subvP=> _ /memv_imgP[_ /Fadjoin_polyP[p1 r_p1 ->] ->].\n  rewrite -horner_map /= mempx_Fadjoin //=; apply/polyOverP=> i.\n  by rewrite coef_map (subvP IHr) //= memv_img ?(polyOverP r_p1).\nhave [f homLf fxz]: exists2 f : 'End(Lz), kHom 1 imL f & f (inLz x) = z.\n  pose q1z := minPoly 1 (inLz x).\n  have Dq1z: map_poly inLz q1 %| q1z.\n    have F0q1z i: exists a, q1z`_i = a%:A by apply/vlineP/polyOverP/minPolyOver.\n    have [q2 Dq2]: exists q2, q1z = map_poly inLz q2.\n      exists (\\poly_(i < size q1z) (sval (sig_eqW (F0q1z i)))%:A).\n      rewrite -{1}[q1z]coefK; apply/polyP=> i; rewrite coef_map !{1}coef_poly.\n      by case: sig_eqW => a; case: ifP; rewrite /= ?rmorph0 ?rmorph_alg.\n    rewrite Dq2 dvdp_map minPoly_dvdp //.\n      apply/polyOverP=> i; have[a] := F0q1z i.\n      rewrite -(rmorph_alg inLz) Dq2 coef_map /= => /fmorph_inj->.\n      exact/rpredZ/mem1v.\n    by rewrite -(fmorph_root inLz) -Dq2 root_minPoly.\n  have q1z_z: root q1z z.\n    rewrite !root_factor_theorem in qz0 *.\n    by apply: dvdp_trans qz0 (dvdp_trans _ Dq1z); rewrite dvdp_map.\n  have map1q1z_z: root (map_poly \\1%VF q1z) z.\n    by rewrite map_poly_id => // ? _; rewrite lfunE.\n  pose f0 := kHomExtend 1 \\1 (inLz x) z.\n  have{map1q1z_z} hom_f0 : kHom 1 <<1; inLz x>> f0.\n    by apply: kHomExtendP map1q1z_z => //; apply: kHom1.\n  have{} splitLpz: splittingFieldFor <<1; inLz x>> pz imL.\n    have [r def_pz defLz] := splitLpz; exists r => //.\n    apply/eqP; rewrite eqEsubv -{2}defLz adjoin_seqSl ?sub1v // andbT.\n    apply/Fadjoin_seqP; split; last first.\n      by rewrite /= -[limg _]defLz; apply: seqv_sub_adjoin.\n    by apply/FadjoinP/andP; rewrite sub1v memv_img ?memvf.\n  have [f homLzf Df] := kHom_extends (sub1v _) hom_f0 F0pz splitLpz.\n  have [-> | x'z] := eqVneq (inLz x) z.\n    by exists \\1%VF; rewrite ?lfunE ?kHom1.\n  exists f => //; rewrite -Df ?memv_adjoin ?(kHomExtend_val (kHom1 1 1)) //.\n  by rewrite lfun1_poly.\npose f1 := (inLz^-1 \\o f \\o inLz)%VF; have /kHomP[fM fFid] := homLf.\nhave Df1 u: inLz (f1 u) = f (inLz u).\n  rewrite !comp_lfunE limg_lfunVK //= -[limg _]/(asval imL).\n  have [r def_pz defLz] := splitLpz; set r1 := r.\n  have: inLz u \\in <<1 & r1>>%VS by rewrite defLz.\n  have: all [in r] r1 by apply/allP.\n  elim/last_ind: r1 {u}(inLz u) => [|r1 y IHr1] u.\n    by rewrite Fadjoin_nil => _ Fu; rewrite fFid // (subvP (sub1v _)).\n  rewrite all_rcons adjoin_rcons => /andP[rr1 ry] /Fadjoin_polyP[pu r1pu ->].\n  rewrite (kHom_horner homLf) -defLz; last exact: seqv_sub_adjoin; last first.\n    by apply: polyOverS r1pu; apply/subvP/adjoin_seqSr/allP.\n  apply: rpred_horner.\n    by apply/polyOverP=> i; rewrite coef_map /= defLz IHr1 ?(polyOverP r1pu).\n  rewrite seqv_sub_adjoin // -root_prod_XsubC -(eqp_root def_pz).\n  rewrite (kHom_root_id _ homLf) ?sub1v //.\n    by rewrite -defLz seqv_sub_adjoin.\n  by rewrite (eqp_root def_pz) root_prod_XsubC.\nsuffices f1_is_ahom : ahom_in {:L} f1.\n  apply/hasP; exists (AHom f1_is_ahom); first exact: DautL.\n  by rewrite /fx_root -(fmorph_root inLz) /= Df1 fxz.\napply/ahom_inP; split=> [a b _ _|]; apply: (fmorph_inj inLz).\n  by rewrite rmorphM /= !Df1 rmorphM fM ?in_imL.\nby rewrite /= Df1 /= fFid ?rmorph1 ?mem1v.\nQed.",
    "Lemma kHom_to_AEnd K E f : kHom K E f -> {g : 'AEnd(L) | {in E, f =1 val g}}.\nProof.\nmove=> homKf; have{homKf} [homFf sFE] := (kHomSl (sub1v K) homKf, sub1v E).\nhave [p Fp /(splittingFieldForS sFE (subvf E))splitLp] := splittingPoly.\nhave [g0 homLg0 eq_fg] := kHom_extends sFE homFf Fp splitLp.\nby apply: exist (Sub g0 _) _ =>  //; apply/ahomP/kHom_lrmorphism.\nQed.",
    "Lemma kAEnd_group_set K E : group_set (kAEnd K E).\nProof.\napply/group_setP; split=> [|f g]; first by rewrite inE /kAut kHom1 lim1g eqxx.\nrewrite !inE !kAutE => /andP[homKf EfE] /andP[/(kHomSr EfE)homKg EgE].\nby rewrite (comp_kHom_img homKg homKf) limg_comp (subv_trans _ EgE) ?limgS.\nQed.",
    "Lemma kAEnd_norm K E : kAEnd K E \\subset 'N(kAEndf E)%g.\nProof.\napply/subsetP=> x; rewrite -groupV 2!in_set => /andP[_ /eqP ExE].\napply/subsetP=> _ /imsetP[y homEy ->]; rewrite !in_set !kAutfE in homEy *.\napply/kAHomP=> u Eu; have idEy := kAHomP homEy; rewrite -ExE in idEy.\nrewrite !(@lfunE _ _ L) /= (@lfunE _ _ L) /= idEy ?memv_img //.\nby rewrite lker0_lfunVK ?AEnd_lker0.\nQed.",
    "Lemma mem_kAut_coset K E (g : 'AEnd(L)) :\n  kAut K E g -> g \\in coset (kAEndf E) g.\nProof.\nmove=> autEg; rewrite val_coset ?rcoset_refl //.\nby rewrite (subsetP (kAEnd_norm K E)) // inE.\nQed.",
    "Lemma aut_mem_eqP E (x y : coset_of (kAEndf E)) f g : \n  f \\in x -> g \\in y -> reflect {in E, f =1 g} (x == y).\nProof.\nmove=> x_f y_g; rewrite -(coset_mem x_f) -(coset_mem y_g).\nhave [Nf Ng] := (subsetP (coset_norm x) f x_f, subsetP (coset_norm y) g y_g).\nrewrite (sameP eqP (rcoset_kercosetP Nf Ng)) mem_rcoset inE kAutfE.\napply: (iffP kAHomP) => idEfg u Eu.\n  by rewrite -(mulgKV g f) lfunE /= idEfg.\nby rewrite (@lfunE _ _ L) /= idEfg // lker0_lfunK ?AEnd_lker0.\nQed.",
    "Lemma gal_reprK : cancel gal_repr gal.\nProof. by case=> x; rewrite /gal coset_reprK sgvalK. Qed.",
    "Lemma gal_repr_inj : injective gal_repr.\nProof. exact: can_inj gal_reprK. Qed.",
    "Lemma gal_AEnd x : gal_repr x \\in kAEnd 1 (agenv V).\nProof.\nrewrite /gal_repr; case/gal_sgval: x => _ /=/morphimP[g Ng autEg ->].\nrewrite val_coset //=; case: repr_rcosetP => f; rewrite groupMr // !inE kAut1E.\nby rewrite kAutE -andbA => /and3P[_ /fixedSpace_limg-> _].\nQed.",
    "Lemma gal_eqP E {x y : gal_of E} : reflect {in E, x =1 y} (x == y).\nProof.\nby rewrite -{1}(subfield_closed E); apply: aut_mem_eqP; apply: mem_repr_coset.\nQed.",
    "Lemma galK E (f : 'AEnd(L)) : (f @: E <= E)%VS -> {in E, gal E f =1 f}.\nProof.\nrewrite -kAut1E -{1 2}(subfield_closed E) => autEf.\napply: (aut_mem_eqP (mem_repr_coset _) _ (eqxx _)).\nby rewrite subgK /= ?(mem_kAut_coset autEf) // ?mem_quotient ?inE.\nQed.",
    "Lemma eq_galP E (f g : 'AEnd(L)) :\n   (f @: E <= E)%VS -> (g @: E <= E)%VS ->\n  reflect {in E, f =1 g} (gal E f == gal E g).\nProof.\nmove=> EfE EgE.\nby apply: (iffP gal_eqP) => Dfg a Ea; have:= Dfg a Ea; rewrite !{1}galK.\nQed.",
    "Lemma limg_gal E (x : gal_of E) : (x @: E)%VS = E.\nProof. by have:= gal_AEnd x; rewrite inE subfield_closed => /andP[_ /eqP]. Qed.",
    "Lemma memv_gal E (x : gal_of E) a : a \\in E -> x a \\in E.\nProof. by move/(memv_img x); rewrite limg_gal. Qed.",
    "Lemma gal_id E a : (1 : gal_of E)%g a = a.\nProof. by rewrite /gal_repr repr_coset1 id_lfunE. Qed.",
    "Lemma galM E (x y : gal_of E) a : a \\in E -> (x * y)%g a = y (x a).\nProof.\nrewrite /= -comp_lfunE; apply/eq_galP; rewrite ?limg_comp ?limg_gal //.\nby rewrite morphM /= ?gal_reprK ?gal_AEnd.\nQed.",
    "Lemma galV E (x : gal_of E) : {in E, (x^-1)%g =1 x^-1%VF}.\nProof.\nmove=> a Ea; apply: canRL (lker0_lfunK (AEnd_lker0 _)) _.\nby rewrite -galM // mulVg gal_id.\nQed.",
    "Lemma gal_cap U V : 'Gal(V / U) = 'Gal(V / U :&: V).\nProof. by rewrite /galoisG -capvA capvv. Qed.",
    "Lemma gal_kAut K E x : (K <= E)%VS -> (x \\in 'Gal(E / K)) = kAut K E x.\nProof.\nmove=> sKE; apply/morphimP/idP=> /= [[g EgE KautEg ->{x}] | KautEx].\n  rewrite genGid !inE kAut1E /= subfield_closed (capv_idPl sKE) in KautEg EgE.\n  by apply: etrans KautEg; apply/(kAut_eq sKE); apply: galK.\nexists (x : 'AEnd(L)); rewrite ?gal_reprK ?gal_AEnd //.\nby rewrite (capv_idPl sKE) mem_gen ?inE.\nQed.",
    "Lemma gal_kHom K E x : (K <= E)%VS -> (x \\in 'Gal(E / K)) = kHom K E x.\nProof. by move/gal_kAut->; rewrite /kAut limg_gal eqxx andbT. Qed.",
    "Lemma kAut_to_gal K E f :\n  kAut K E f -> {x : gal_of E | x \\in 'Gal(E / K) & {in E, f =1 x}}.\nProof.\ncase/andP=> homKf EfE; have [g Df] := kHom_to_AEnd homKf.\nhave{homKf EfE} autEg: kAut (K :&: E) E g.\n  rewrite /kAut -(kHom_eq (capvSr _ _) Df) (kHomSl (capvSl _ _) homKf) /=.\n  by rewrite -(eq_in_limg Df).\nhave FautEg := kAutS (sub1v _) autEg.\nexists (gal E g) => [|a Ea]; last by rewrite {f}Df // galK // -kAut1E.\nby rewrite mem_morphim /= ?subfield_closed ?genGid ?inE.\nQed.",
    "Lemma fixed_gal K E x a :\n  (K <= E)%VS -> x \\in 'Gal(E / K) -> a \\in K -> x a = a.\nProof. by move/gal_kHom=> -> /kAHomP idKx /idKx. Qed.",
    "Lemma fixedPoly_gal K E x p :\n  (K <= E)%VS -> x \\in 'Gal(E / K) -> p \\is a polyOver K -> map_poly x p = p.\nProof.\nmove=> sKE galEKx /polyOverP Kp; apply/polyP => i.\nby rewrite coef_map /= (fixed_gal sKE).\nQed.",
    "Lemma root_minPoly_gal K E x a :\n  (K <= E)%VS -> x \\in 'Gal(E / K) -> a \\in E -> root (minPoly K a) (x a).\nProof.\nmove=> sKE galEKx Ea; have homKx: kHom K E x by rewrite -gal_kHom.\nhave K_Pa := minPolyOver K a; rewrite -[minPoly K a](fixedPoly_gal _ galEKx) //.\nby rewrite (kHom_root homKx) ?root_minPoly // (polyOverS (subvP sKE)).\nQed.",
    "Lemma gal_adjoin_eq K a x y :\n    x \\in 'Gal(<<K; a>> / K) -> y \\in 'Gal(<<K; a>> / K) ->\n  (x == y) = (x a == y a).\nProof.\nmove=> galKa_x galKa_y; apply/idP/eqP=> [/eqP-> // | eq_xy_a].\napply/gal_eqP => _ /Fadjoin_polyP[p Kp ->].\nby rewrite -!horner_map !(fixedPoly_gal (subv_adjoin K a)) //= eq_xy_a.\nQed.",
    "Lemma galS K M E : (K <= M)%VS -> 'Gal(E / M) \\subset 'Gal(E / K).\nProof.\nrewrite gal_cap (gal_cap K E) => sKM; apply/subsetP=> x.\nby rewrite !gal_kAut ?capvSr //; apply: kAutS; apply: capvS.\nQed.",
    "Lemma gal_conjg K E x : 'Gal(E / K) :^ x = 'Gal(E / x @: K).\nProof.\nwithout loss sKE: K / (K <= E)%VS.\n  move=> IH_K; rewrite gal_cap {}IH_K ?capvSr //.\n  transitivity 'Gal(E / x @: K :&: x @: E); last by rewrite limg_gal -gal_cap.\n  congr 'Gal(E / _); apply/eqP; rewrite eqEsubv limg_cap; apply/subvP=> a.\n  rewrite memv_cap => /andP[/memv_imgP[b Kb ->] /memv_imgP[c Ec] eq_bc].\n  by rewrite memv_img // memv_cap Kb (lker0P (AEnd_lker0 _) _ _ eq_bc).\nwlog suffices IHx: x K sKE / 'Gal(E / K) :^ x \\subset 'Gal(E / x @: K).\n  apply/eqP; rewrite eqEsubset IHx // -sub_conjgV (subset_trans (IHx _ _ _)) //.\n    by apply/subvP=> _ /memv_imgP[a Ka ->]; rewrite memv_gal ?(subvP sKE).\n  rewrite -limg_comp (etrans (eq_in_limg _) (lim1g _)) // => a /(subvP sKE)Ka.\n  by rewrite !(@lfunE _ _ L) /= -galM // mulgV gal_id.\napply/subsetP=> _ /imsetP[y galEy ->]; rewrite gal_cap gal_kHom ?capvSr //=.\napply/kAHomP=> _ /memv_capP[/memv_imgP[a Ka ->] _]; have Ea := subvP sKE a Ka.\nby rewrite -galM // -conjgC galM // (fixed_gal sKE galEy).\nQed.",
    "Lemma fixedFieldP E {A : {set gal_of E}} a :\n  a \\in E -> reflect (forall x, x \\in A -> x a = a) (a \\in fixedField A).\nProof.\nby rewrite memv_cap => ->; apply: (iffP subv_bigcapP) => cAa x /cAa/fixedSpaceP.\nQed.",
    "Lemma mem_fixedFieldP E (A : {set gal_of E}) a :\n  a \\in fixedField A -> a \\in E /\\ (forall x, x \\in A -> x a = a).\nProof.\nby move=> fixAa; have [Ea _] := memv_capP fixAa; have:= fixedFieldP Ea fixAa.\nQed.",
    "Lemma fixedField_bound E (A : {set gal_of E}) : (fixedField A <= E)%VS.\nProof. exact: capvSl. Qed.",
    "Lemma fixedFieldS E (A B : {set gal_of E}) :\n   A \\subset B -> (fixedField B <= fixedField A)%VS.\nProof.\nmove/subsetP=> sAB; apply/subvP => a /mem_fixedFieldP[Ea cBa].\nby apply/fixedFieldP; last apply: sub_in1 cBa.\nQed.",
    "Lemma galois_connection_subv K E :\n  (K <= E)%VS -> (K <= fixedField ('Gal(E / K)))%VS.\nProof.\nmove=> sKE; apply/subvP => a Ka; have Ea := subvP sKE a Ka.\nby apply/fixedFieldP=> // x galEx; apply: (fixed_gal sKE).\nQed.",
    "Lemma galois_connection_subset E (A : {set gal_of E}):\n  A \\subset 'Gal(E / fixedField A).\nProof.\napply/subsetP => x Ax; rewrite gal_kAut ?capvSl // kAutE limg_gal subvv andbT.\nby apply/kAHomP=> a /mem_fixedFieldP[_ ->].\nQed.",
    "Lemma galois_connection K E (A : {set gal_of E}):\n  (K <= E)%VS -> (A \\subset 'Gal(E / K)) = (K <= fixedField A)%VS.\nProof.\nmove=> sKE; apply/idP/idP => [/fixedFieldS | /(galS E)].\n  exact/subv_trans/galois_connection_subv.\nexact/subset_trans/galois_connection_subset.\nQed.",
    "Lemma galNorm1 : galNorm U V 1 = 1.\nProof. by apply: big1 => x _; rewrite rmorph1. Qed.",
    "Lemma galNormM : {morph galNorm U V : a b / a * b}.\nProof.\nby move=> a b /=; rewrite -big_split; apply: eq_bigr => x _; rewrite rmorphM.\nQed.",
    "Lemma galNormV : {morph galNorm U V : a / a^-1}.\nProof.\nby move=> a /=; rewrite -prodfV; apply: eq_bigr => x _; rewrite fmorphV.\nQed.",
    "Lemma galNormX n : {morph galNorm U V : a / a ^+ n}.\nProof.\nmove=> a; elim: n => [|n IHn]; first exact: galNorm1.\nby rewrite !exprS galNormM IHn.\nQed.",
    "Lemma galNorm_prod (I : Type) (r : seq I) (P : pred I) (B : I -> L) :\n  galNorm U V (\\prod_(i <- r | P i) B i)\n   = \\prod_(i <- r | P i) galNorm U V (B i).\nProof. exact: (big_morph _ galNormM galNorm1). Qed.",
    "Lemma galNorm0 : galNorm U V 0 = 0.\nProof. by rewrite /galNorm (bigD1 1%g) ?group1 // rmorph0 /= mul0r. Qed.",
    "Lemma galNorm_eq0 a : (galNorm U V a == 0) = (a == 0).\nProof.\napply/idP/eqP=> [/prodf_eq0[x _] | ->]; last by rewrite galNorm0.\nby rewrite fmorph_eq0 => /eqP.\nQed.",
    "Lemma galTrace_fixedField a :\n  a \\in E -> galTrace K E a \\in fixedField 'Gal(E / K).\nProof.\nmove=> Ea; apply/fixedFieldP=> [|x galEx].\n  by apply: rpred_sum => x _; apply: memv_gal.\nrewrite {2}/galTrace (reindex_acts 'R _ galEx) ?astabsR //=.\nby rewrite rmorph_sum; apply: eq_bigr => y _; rewrite galM ?lfunE.\nQed.",
    "Lemma galTrace_gal a x :\n  a \\in E -> x \\in 'Gal(E / K) -> galTrace K E (x a) = galTrace K E a.\nProof.\nmove=> Ea galEx; rewrite {2}/galTrace (reindex_inj (mulgI x)).\nby apply: eq_big => [b | b _]; rewrite ?groupMl // galM ?lfunE.\nQed.",
    "Lemma galNorm_fixedField a :\n  a \\in E -> galNorm K E a \\in fixedField 'Gal(E / K).\nProof.\nmove=> Ea; apply/fixedFieldP=> [|x galEx].\n  by apply: rpred_prod => x _; apply: memv_gal.\nrewrite {2}/galNorm (reindex_acts 'R _ galEx) ?astabsR //=.\nby rewrite rmorph_prod; apply: eq_bigr => y _; rewrite galM ?lfunE.\nQed.",
    "Lemma galNorm_gal a x :\n  a \\in E -> x \\in 'Gal(E / K) -> galNorm K E (x a) = galNorm K E a.\nProof.\nmove=> Ea galEx; rewrite {2}/galNorm (reindex_inj (mulgI x)).\nby apply: eq_big => [b | b _]; rewrite ?groupMl // galM ?lfunE.\nQed.",
    "Lemma normalField_kAut K M E f :\n  (K <= M <= E)%VS -> normalField K M -> kAut K E f -> kAut K M f.\nProof.\ncase/andP=> sKM sME nKM /kAut_to_gal[x galEx /(sub_in1 (subvP sME))Df].\nhave sKE := subv_trans sKM sME; rewrite gal_kHom // in galEx.\nrewrite (kAut_eq sKM Df) /kAut (kHomSr sME) //= (forall_inP nKM) // inE.\nby rewrite kAutfE; apply/kAHomP; apply: (kAHomP galEx).\nQed.",
    "Lemma normalFieldP K E :\n  reflect {in E, forall a, exists2 r,\n            all [in E] r & minPoly K a = \\prod_(b <- r) ('X - b%:P)}\n          (normalField K E).\nProof.\napply: (iffP eqfun_inP) => [nKE a Ea | nKE x]; last first.\n  rewrite inE kAutfE => homKx; suffices: kAut K E x by case/andP=> _ /eqP.\n  rewrite kAutE (kHomSr (subvf E)) //=; apply/subvP=> _ /memv_imgP[a Ea ->].\n  have [r /allP/=srE splitEa] := nKE a Ea.\n  rewrite srE // -root_prod_XsubC -splitEa.\n  by rewrite -(kHom_poly_id homKx (minPolyOver K a)) fmorph_root root_minPoly.\nhave [r /eqP splitKa] := splitting_field_normal K a.\nexists r => //; apply/allP => b; rewrite -root_prod_XsubC -splitKa => pKa_b_0.\npose y := kHomExtend K \\1 a b; have [hom1K lf1p] := (kHom1 K K, lfun1_poly).\nhave homKy: kHom K <<K; a>> y by apply/kHomExtendP; rewrite ?lf1p.\nhave [[g Dy] [_ idKy]] := (kHom_to_AEnd homKy, kHomP homKy).\nhave <-: g a = b by rewrite -Dy ?memv_adjoin // (kHomExtend_val hom1K) ?lf1p.\nsuffices /nKE <-: g \\in kAEndf K by apply: memv_img.\nby rewrite inE kAutfE; apply/kAHomP=> c Kc; rewrite -Dy ?subvP_adjoin ?idKy.\nQed.",
    "Lemma normalFieldf K : normalField K {:L}.\nProof.\napply/normalFieldP=> a _; have [r /eqP->] := splitting_field_normal K a.\nby exists r => //; apply/allP=> b; rewrite /= memvf.\nQed.",
    "Lemma normalFieldS K M E : (K <= M)%VS -> normalField K E -> normalField M E.\nProof.\nmove=> sKM /normalFieldP nKE; apply/normalFieldP=> a Ea.\nhave [r /allP Er splitKa] := nKE a Ea.\nhave /dvdp_prod_XsubC[m splitMa]: minPoly M a %| \\prod_(b <- r) ('X - b%:P).\n  by rewrite -splitKa minPolyS.\nexists (mask m r); first by apply/allP=> b /mem_mask/Er.\nby apply/eqP; rewrite -eqp_monic ?monic_prod_XsubC ?monic_minPoly.\nQed.",
    "Lemma splitting_normalField E K :\n   (K <= E)%VS ->\n  reflect (exists2 p, p \\is a polyOver K & splittingFieldFor K p E)\n          (normalField K E).\nProof.\nmove=> sKE; apply: (iffP idP) => [nKE| [p Kp [rs Dp defE]]]; last first.\n  apply/forall_inP=> g /[!(inE, kAutE)] /andP[homKg _].\n  rewrite -dimv_leqif_eq ?limg_dim_eq ?(eqP (AEnd_lker0 g)) ?capv0 //.\n  rewrite -defE aimg_adjoin_seq; have [_ /fixedSpace_limg->] := andP homKg.\n  apply/adjoin_seqSr=> _ /mapP[a rs_a ->].\n  rewrite -!root_prod_XsubC -!(eqp_root Dp) in rs_a *.\n  by apply: kHom_root_id homKg Kp _ rs_a; rewrite ?subvf ?memvf.\npose splitK a r := minPoly K a = \\prod_(b <- r) ('X - b%:P).\nhave{nKE} rK_ a: {r | a \\in E -> all [in E] r /\\ splitK a r}.\n  case Ea: (a \\in E); last by exists [::].\n  by have /sig2_eqW[r] := normalFieldP _ _ nKE a Ea; exists r.\nhave sXE := basis_mem (vbasisP E); set X : seq L := vbasis E in sXE.\nexists (\\prod_(a <- X) minPoly K a).\n  by apply: rpred_prod => a _; apply: minPolyOver.\nexists (flatten [seq (sval (rK_ a)) | a <- X]).\n  move/allP: sXE; elim: X => [|a X IHX]; first by rewrite !big_nil eqpxx.\n  rewrite big_cons /= big_cat /= => /andP[Ea sXE].\n  by case: (rK_ a) => /= r [] // _ <-; apply/eqp_mull/IHX.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  apply/Fadjoin_seqP; split=> // b /flatten_mapP[a /sXE Ea].\n  by apply/allP; case: rK_ => r /= [].\nrewrite -{1}(span_basis (vbasisP E)); apply/span_subvP=> a Xa.\napply/seqv_sub_adjoin/flatten_mapP; exists a => //; rewrite -root_prod_XsubC.\nby case: rK_ => /= r [| _ <-]; rewrite ?sXE ?root_minPoly.\nQed.",
    "Lemma kHom_to_gal K M E f :\n    (K <= M <= E)%VS -> normalField K E -> kHom K M f ->\n  {x | x \\in 'Gal(E / K) & {in M, f =1 x}}.\nProof.\ncase/andP=> /subvP sKM /subvP sME nKE KhomMf.\nhave [[g Df] [_ idKf]] := (kHom_to_AEnd KhomMf, kHomP KhomMf).\nsuffices /kAut_to_gal[x galEx Dg]: kAut K E g.\n  by exists x => //= a Ma; rewrite Df // Dg ?sME.\nhave homKg: kHom K {:L} g by apply/kAHomP=> a Ka; rewrite -Df ?sKM ?idKf.\nby rewrite /kAut (kHomSr (subvf _)) // (forall_inP nKE) // inE kAutfE.\nQed.",
    "Lemma normalField_root_minPoly K E a b :\n    (K <= E)%VS -> normalField K E -> a \\in E -> root (minPoly K a) b ->\n  exists2 x, x \\in 'Gal(E / K) & x a = b.\nProof.\nmove=> sKE nKE Ea pKa_b_0; pose f := kHomExtend K \\1 a b.\nhave homKa_f: kHom K <<K; a>> f.\n  by apply: kHomExtendP; rewrite ?kHom1 ?lfun1_poly.\nhave sK_Ka_E: (K <= <<K; a>> <= E)%VS.\n  by rewrite subv_adjoin; apply/FadjoinP; rewrite sKE Ea.\nhave [x galEx Df] := kHom_to_gal sK_Ka_E nKE homKa_f; exists x => //.\nby rewrite -Df ?memv_adjoin // (kHomExtend_val (kHom1 K K)) ?lfun1_poly.\nQed.",
    "Lemma normalField_factors K E :\n   (K <= E)%VS ->\n reflect {in E, forall a, exists2 r : seq (gal_of E),\n            r \\subset 'Gal(E / K)\n          & minPoly K a = \\prod_(x <- r) ('X - (x a)%:P)}\n   (normalField K E).\nProof.\nmove=> sKE; apply: (iffP idP) => [nKE a Ea | nKE]; last first.\n  apply/normalFieldP=> a Ea; have [r _ ->] := nKE a Ea.\n  exists [seq x a | x : gal_of E <- r]; last by rewrite big_map.\n  by rewrite all_map; apply/allP=> b _; apply: memv_gal.\nhave [r Er splitKa] := normalFieldP nKE a Ea.\npose f b := [pick x in 'Gal(E / K) | x a == b].\nexists (pmap f r).\n  apply/subsetP=> x; rewrite mem_pmap /f => /mapP[b _].\n  by case: (pickP _) => // c /andP[galEc _] [->].\nrewrite splitKa; have{splitKa}: all (root (minPoly K a)) r.\n  by apply/allP => b; rewrite splitKa root_prod_XsubC.\nelim: r Er => /= [|b r IHr]; first by rewrite !big_nil.\ncase/andP=> Eb Er /andP[pKa_b_0 /(IHr Er){Er}IHr].\nhave [x galE /eqP xa_b] := normalField_root_minPoly sKE nKE Ea pKa_b_0.\nrewrite /(f b); case: (pickP _) => [y /andP[_ /eqP<-]|/(_ x)/andP[]//].\nby rewrite !big_cons IHr.\nQed.",
    "Lemma galoisS K M E : (K <= M <= E)%VS -> galois K E -> galois M E.\nProof.\ncase/andP=> sKM sME /and3P[_ sepUV nUV].\nby rewrite /galois sME (separableSl sKM) ?(normalFieldS sKM).\nQed.",
    "Lemma galois_dim K E : galois K E -> \\dim_K E = #|'Gal(E / K)|.\nProof.\ncase/and3P=> sKE /eq_adjoin_separable_generator-> // nKE.\nset a := separable_generator K E in nKE *.\nhave [r /allP/=Er splitKa] := normalFieldP nKE a (memv_adjoin K a).\nrewrite (dim_sup_field (subv_adjoin K a)) mulnK ?adim_gt0 //.\napply/eqP; rewrite -eqSS -adjoin_degreeE -size_minPoly splitKa size_prod_XsubC.\nset n := size r; rewrite eqSS -[n]card_ord.\nhave x_ (i : 'I_n): {x | x \\in 'Gal(<<K; a>> / K) & x a = r`_i}.\n  apply/sig2_eqW/normalField_root_minPoly; rewrite ?subv_adjoin ?memv_adjoin //.\n  by rewrite splitKa root_prod_XsubC mem_nth.\nhave /card_image <-: injective (fun i => s2val (x_ i)).\n  move=> i j /eqP; case: (x_ i) (x_ j) => y /= galEy Dya [z /= galEx Dza].\n  rewrite gal_adjoin_eq // Dya Dza nth_uniq // => [/(i =P j)//|].\n  by rewrite -separable_prod_XsubC -splitKa; apply: separable_generatorP.\napply/eqP/eq_card=> x; apply/codomP/idP=> [[i ->] | galEx]; first by case: x_.\nhave /(nthP 0) [i ltin Dxa]: x a \\in r.\n  rewrite -root_prod_XsubC -splitKa.\n  by rewrite root_minPoly_gal ?memv_adjoin ?subv_adjoin.\nexists (Ordinal ltin); apply/esym/eqP.\nby case: x_ => y /= galEy /eqP; rewrite Dxa gal_adjoin_eq.\nQed.",
    "Lemma galois_factors K E :\n    (K <= E)%VS ->\n  reflect {in E, forall a, exists r, let r_a := [seq x a | x : gal_of E <- r] in\n            [/\\ r \\subset 'Gal(E / K), uniq r_a\n              & minPoly K a = \\prod_(b <- r_a) ('X - b%:P)]}\n          (galois K E).\nProof.\nmove=> sKE; apply: (iffP and3P) => [[_ sepKE nKE] a Ea | galKE].\n  have [r galEr splitEa] := normalField_factors sKE nKE a Ea.\n  exists r; rewrite /= -separable_prod_XsubC !big_map -splitEa.\n  by split=> //; apply: separableP Ea.\nsplit=> //.\n  apply/separableP => a /galKE[r [_ Ur_a splitKa]].\n  by rewrite /separable_element splitKa separable_prod_XsubC.\napply/(normalField_factors sKE)=> a /galKE[r [galEr _ ->]].\nby rewrite big_map; exists r.\nQed.",
    "Lemma splitting_galoisField K E :\n  reflect (exists p, [/\\ p \\is a polyOver K, separable_poly p\n                       & splittingFieldFor K p E])     \n          (galois K E).\nProof.\napply: (iffP and3P) => [[sKE sepKE nKE]|[p [Kp sep_p [r Dp defE]]]].\n  rewrite (eq_adjoin_separable_generator sepKE) // in nKE *.\n  set a := separable_generator K E in nKE *; exists (minPoly K a).\n  split; first 1 [exact: minPolyOver | exact/separable_generatorP].\n  have [r /= /allP Er splitKa] := normalFieldP nKE a (memv_adjoin _ _).\n  exists r; first by rewrite splitKa eqpxx.\n  apply/eqP; rewrite eqEsubv; apply/andP; split.\n    by apply/Fadjoin_seqP; split => //; apply: subv_adjoin.\n  apply/FadjoinP; split; first exact: subv_adjoin_seq.\n  by rewrite seqv_sub_adjoin // -root_prod_XsubC -splitKa root_minPoly.\nhave sKE: (K <= E)%VS by rewrite -defE subv_adjoin_seq.\nsplit=> //; last by apply/splitting_normalField=> //; exists p; last exists r.\nrewrite -defE; apply/separable_Fadjoin_seq/allP=> a r_a.\nby apply/separable_elementP; exists p; rewrite (eqp_root Dp) root_prod_XsubC.\nQed.",
    "Lemma galois_fixedField K E :\n  reflect (fixedField 'Gal(E / K) = K) (galois K E).\nProof.\napply: (iffP idP) => [/and3P[sKE /separableP sepKE nKE] | fixedKE].\n  apply/eqP; rewrite eqEsubv galois_connection_subv ?andbT //.\n  apply/subvP=> a /mem_fixedFieldP[Ea fixEa]; rewrite -adjoin_deg_eq1.\n  have [r /allP Er splitKa] := normalFieldP nKE a Ea.\n  rewrite -eqSS -size_minPoly splitKa size_prod_XsubC eqSS -[1]/(size [:: a]).\n  have Ur: uniq r by rewrite -separable_prod_XsubC -splitKa; apply: sepKE.\n  rewrite -uniq_size_uniq {Ur}// => b; rewrite inE -root_prod_XsubC -splitKa.\n  apply/eqP/idP=> [-> | pKa_b_0]; first exact: root_minPoly.\n  by have [x /fixEa-> ->] := normalField_root_minPoly sKE nKE Ea pKa_b_0.\nhave sKE: (K <= E)%VS by rewrite -fixedKE capvSl.\napply/galois_factors=> // a Ea.\npose r_pKa := [seq x a | x : gal_of E in 'Gal(E / K)].\nhave /fin_all_exists2[x_ galEx_ Dx_a] (b : seq_sub r_pKa) := imageP (valP b).\nexists (codom x_); rewrite -map_comp; set r := map _ _.\nhave r_xa x: x \\in 'Gal(E / K) -> x a \\in r.\n  move=> galEx; have r_pKa_xa: x a \\in r_pKa by apply/imageP; exists x.\n  by rewrite [x a](Dx_a (SeqSub r_pKa_xa)); apply: codom_f.\nhave Ur: uniq r by apply/injectiveP=> b c /=; rewrite -!Dx_a => /val_inj.\nsplit=> //; first by apply/subsetP=> _ /codomP[b ->].\napply/eqP; rewrite -eqp_monic ?monic_minPoly ?monic_prod_XsubC //.\napply/andP; split; last first.\n  rewrite uniq_roots_dvdp ?uniq_rootsE // all_map.\n  by apply/allP=> b _ /=; rewrite root_minPoly_gal.\napply: minPoly_dvdp; last by rewrite root_prod_XsubC -(gal_id E a) r_xa ?group1.\nrewrite -fixedKE; apply/polyOverP => i; apply/fixedFieldP=> [|x galEx].\n  rewrite (polyOverP _) // big_map rpred_prod // => b _.\n  by rewrite polyOverXsubC memv_gal.\nrewrite -coef_map rmorph_prod; congr (_ : {poly _})`_i.\nsymmetry; rewrite (perm_big (map x r)) /= ?(big_map x).\n  by apply: eq_bigr => b _; rewrite rmorphB /= map_polyX map_polyC.\nhave Uxr: uniq (map x r) by rewrite map_inj_uniq //; apply: fmorph_inj.\nhave /uniq_min_size: {subset map x r <= r}.\n  by rewrite -map_comp => _ /codomP[b ->] /=; rewrite -galM // r_xa ?groupM.\nby rewrite (size_map x) perm_sym; case=> // _ /uniq_perm->.\nQed.",
    "Lemma mem_galTrace K E a : galois K E -> a \\in E -> galTrace K E a \\in K.\nProof. by move/galois_fixedField => {2}<- /galTrace_fixedField. Qed.",
    "Lemma mem_galNorm K E a : galois K E -> a \\in E -> galNorm K E a \\in K.\nProof. by move/galois_fixedField=> {2}<- /galNorm_fixedField. Qed.",
    "Lemma gal_independent_contra E (P : pred (gal_of E)) (c_ : gal_of E -> L) x :\n    P x -> c_ x != 0 ->\n  exists2 a, a \\in E & \\sum_(y | P y) c_ y * y a != 0.\nProof.\nhave [n] := ubnP #|P|; elim: n c_ x P => // n IHn c_ x P lePn Px nz_cx.\nrewrite ltnS (cardD1x Px) in lePn; move/IHn: lePn => {n IHn}/=IH_P.\nhave [/eqfun_inP c_Px'_0 | ] := boolP [forall (y | P y && (y != x)), c_ y == 0].\n  exists 1; rewrite ?mem1v // (bigD1 x Px) /= rmorph1 mulr1.\n  by rewrite big1 ?addr0 // => y /c_Px'_0->; rewrite mul0r.\ncase/forall_inPn => y Px'y nz_cy.\nhave [Py /gal_eqP/eqlfun_inP/subvPn[a Ea]] := andP Px'y.\nrewrite memv_ker !lfun_simp => nz_yxa; pose d_ y := c_ y * (y a - x a).\nhave /IH_P[//|b Eb nz_sumb]: d_ y != 0 by rewrite mulf_neq0.\nhave [sumb_0|] := eqVneq (\\sum_(z | P z) c_ z * z b) 0; last by exists b.\nexists (a * b); first exact: rpredM.\nrewrite -subr_eq0 -[z in _ - z](mulr0 (x a)) -[in z in _ - z]sumb_0.\nrewrite mulr_sumr -sumrB (bigD1 x Px) rmorphM /= mulrCA subrr add0r.\ncongr (_ != 0): nz_sumb; apply: eq_bigr => z _.\nby rewrite mulrCA rmorphM -mulrBr -mulrBl mulrA.\nQed.",
    "Lemma gal_independent E (P : pred (gal_of E)) (c_ : gal_of E -> L) :\n    (forall a, a \\in E -> \\sum_(x | P x) c_ x * x a = 0) ->\n  (forall x, P x -> c_ x = 0).\nProof.\nmove=> sum_cP_0 x Px; apply/eqP/idPn=> /(gal_independent_contra Px)[a Ea].\nby rewrite sum_cP_0 ?eqxx.\nQed.",
    "Lemma Hilbert's_theorem_90 K E x a :\n   generator 'Gal(E / K) x -> a \\in E ->\n reflect (exists2 b, b \\in E /\\ b != 0 & a = b / x b) (galNorm K E a == 1).\nProof.\nmove/(_ =P <[x]>)=> DgalE Ea.\nhave galEx: x \\in 'Gal(E / K) by rewrite DgalE cycle_id.\napply: (iffP eqP) => [normEa1 | [b [Eb nzb] ->]]; last first.\n  by rewrite galNormM galNormV galNorm_gal // mulfV // galNorm_eq0.\nhave [x1 | ntx] := eqVneq x 1%g.\n  exists 1; first by rewrite mem1v oner_neq0.\n  by rewrite -{1}normEa1 /galNorm DgalE x1 cycle1 big_set1 !gal_id divr1.\npose c_ y := \\prod_(i < invm (injm_Zpm x) y) (x ^+ i)%g a.\nhave nz_c1: c_ 1%g != 0 by rewrite /c_ morph1 big_ord0 oner_neq0.\nhave [d] := @gal_independent_contra _ [in 'Gal(E / K)] _ _ (group1 _) nz_c1.\nset b := \\sum_(y in _) _ => Ed nz_b; exists b.\n  split=> //; apply: rpred_sum => y galEy.\n  by apply: rpredM; first apply: rpred_prod => i _; apply: memv_gal.\napply: canRL (mulfK _) _; first by rewrite fmorph_eq0.\nrewrite rmorph_sum mulr_sumr [b](reindex_acts 'R _ galEx) ?astabsR //=.\napply: eq_bigr => y galEy; rewrite galM // rmorphM mulrA; congr (_ * _).\nhave /morphimP[/= i _ _ ->] /=: y \\in Zpm @* Zp #[x] by rewrite im_Zpm -DgalE.\nhave <-: Zpm (i + 1) = (Zpm i * x)%g by rewrite morphM ?mem_Zp ?order_gt1.\nrewrite /c_ !invmE ?mem_Zp ?order_gt1 //= addn1; set n := _.+2.\ntransitivity (\\prod_(j < i.+1) (x ^+ j)%g a).\n  rewrite big_ord_recl gal_id rmorph_prod; congr (_ * _).\n  by apply: eq_bigr => j _; rewrite expgSr galM ?lfunE.\nhave [/modn_small->//||->] := ltngtP i.+1 n; first by rewrite ltnNge ltn_ord.\nrewrite modnn big_ord0; apply: etrans normEa1; rewrite /galNorm DgalE -im_Zpm.\nrewrite morphimEdom big_imset /=; last exact/injmP/injm_Zpm.\nby apply: eq_bigl => j /=; rewrite mem_Zp ?order_gt1.\nQed.",
    "Lemma gal_matrix :\n  {w : #|A|.-tuple L | {subset w <= E} /\\ 0 \\notin w &\n    [/\\ \\matrix_(i, j < #|A|) enum_val i (tnth w j) \\in unitmx,\n        directv (\\sum_i K * <[tnth w i]>) &\n        group_set A -> (\\sum_i K * <[tnth w i]>)%VS = E] }.\nProof.\npose nzE (w : #|A|.-tuple L) := {subset w <= E} /\\ 0 \\notin w.\npose M w := \\matrix_(i, j < #|A|) nth 1%g (enum A) i (tnth w j).\nhave [w [Ew nzw] uM]: {w : #|A|.-tuple L | nzE w & M w \\in unitmx}.\n  rewrite {}/nzE {}/M cardE; have: uniq (enum A) := enum_uniq _.\n  elim: (enum A) => [|x s IHs] Uxs.\n    by exists [tuple]; rewrite // flatmx0 -(flatmx0 1%:M) unitmx1.\n  have [s'x Us]: x \\notin s /\\ uniq s by apply/andP.\n  have{IHs} [w [Ew nzw] uM] := IHs Us; set M := \\matrix_(i, j) _ in uM.\n  pose a := \\row_i x (tnth w i) *m invmx M.\n  pose c_ y := oapp (a 0) (-1) (insub (index y s)).\n  have cx_n1 : c_ x = -1 by rewrite /c_ insubN ?index_mem.\n  have nz_cx : c_ x != 0 by rewrite cx_n1 oppr_eq0 oner_neq0.\n  have Px: [pred y in x :: s] x := mem_head x s.\n  have{Px nz_cx} /sig2W[w0 Ew0 nzS] := gal_independent_contra Px nz_cx.\n  exists [tuple of cons w0 w].\n    split; first by apply/allP; rewrite /= Ew0; apply/allP.\n    rewrite inE negb_or (contraNneq _ nzS) // => <-.\n    by rewrite big1 // => y _; rewrite rmorph0 mulr0.\n  rewrite unitmxE -[\\det _]mul1r; set M1 := \\matrix_(i, j < 1 + size s) _.\n  have <-: \\det (block_mx 1 (- a) 0 1%:M) = 1 by rewrite det_ublock !det1 mulr1.\n  rewrite -det_mulmx -[M1]submxK mulmx_block !mul0mx !mul1mx !add0r !mulNmx.\n  have ->: drsubmx M1 = M by apply/matrixP => i j; rewrite !mxE !(tnth_nth 0).\n  have ->: ursubmx M1 - a *m M = 0.\n    by apply/rowP=> i; rewrite mulmxKV // !mxE !(tnth_nth 0) subrr.\n  rewrite det_lblock unitrM andbC -unitmxE uM unitfE -oppr_eq0.\n  congr (_ != 0): nzS; rewrite [_ - _]mx11_scalar det_scalar !mxE opprB /=.\n  rewrite -big_uniq // big_cons /= cx_n1 mulN1r addrC; congr (_ + _).\n  rewrite (big_nth 1%g) big_mkord; apply: eq_bigr => j _.\n  by rewrite /c_ index_uniq // valK; congr (_ * _); rewrite !mxE.\nexists w => [//|]; split=> [||gA].\n- by congr (_ \\in unitmx): uM; apply/matrixP=> i j; rewrite !mxE -enum_val_nth.\n- apply/directv_sum_independent=> kw_ Kw_kw sum_kw_0 j _.\n  have /fin_all_exists2[k_ Kk_ Dk_] i := memv_cosetP (Kw_kw i isT).\n  pose kv := \\col_i k_ i.\n  transitivity (kv j 0 * tnth w j); first by rewrite !mxE.\n  suffices{j}/(canRL (mulKmx uM))->: M w *m kv = 0 by rewrite mulmx0 mxE mul0r.\n  apply/colP=> i /[!mxE]; pose Ai := nth 1%g (enum A) i.\n  transitivity (Ai (\\sum_j kw_ j)); last by rewrite sum_kw_0 rmorph0.\n  rewrite rmorph_sum; apply: eq_bigr => j _; rewrite !mxE /= -/Ai.\n  rewrite Dk_ mulrC rmorphM /=; congr (_ * _).\n  by have /mem_fixedFieldP[_ -> //] := Kk_ j; rewrite -mem_enum mem_nth -?cardE.\npose G := group gA; have G_1 := group1 G; pose iG := enum_rank_in G_1.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  apply/subv_sumP=> i _; apply: subv_trans (asubv _).\n  by rewrite prodvS ?capvSl // -memvE Ew ?mem_tnth.\napply/subvP=> w0 Ew0; apply/memv_sumP.\npose wv := \\col_(i < #|A|) enum_val i w0; pose v := invmx (M w) *m wv.\nexists (fun i => tnth w i * v i 0) => [i _|]; last first.\n  transitivity (wv (iG 1%g) 0); first by rewrite mxE enum_rankK_in ?gal_id.\n  rewrite -[wv](mulKVmx uM) -/v mxE; apply: eq_bigr => i _.\n  by congr (_ * _); rewrite !mxE -enum_val_nth enum_rankK_in ?gal_id.\nrewrite mulrC memv_mul ?memv_line //; apply/fixedFieldP=> [|x Gx].\n  rewrite mxE rpred_sum // => j _; rewrite !mxE rpredM //; last exact: memv_gal.\n  have E_M k l: M w k l \\in E by rewrite mxE memv_gal // Ew ?mem_tnth.\n  have Edet n (N : 'M_n) (E_N : forall i j, N i j \\in E): \\det N \\in E.\n    by apply: rpred_sum => sigma _; rewrite rpredMsign rpred_prod.\n  rewrite /invmx uM 2!mxE mulrC rpred_div ?Edet //.\n  by rewrite rpredMsign Edet // => k l; rewrite 2!mxE.\nsuffices{i} {2}<-: map_mx x v = v by rewrite [map_mx x v i 0]mxE.\nhave uMx: map_mx x (M w) \\in unitmx by rewrite map_unitmx.\nrewrite map_mxM map_invmx /=; apply: canLR {uMx}(mulKmx uMx) _.\napply/colP=> i /[!mxE]; pose ix := iG (enum_val i * x)%g.\nhave Dix b: b \\in E -> enum_val ix b = x (enum_val i b).\n  by move=> Eb; rewrite enum_rankK_in ?groupM ?enum_valP // galM ?lfunE.\ntransitivity ((M w *m v) ix 0); first by rewrite mulKVmx // mxE Dix.\nrewrite mxE; apply: eq_bigr => j _; congr (_ * _).\nby rewrite !mxE -!enum_val_nth Dix // ?Ew ?mem_tnth.\nQed.",
    "Lemma dim_fixedField E (G : {group gal_of E}) : #|G| = \\dim_(fixedField G) E.\nProof.\nhave [w [_ nzw] [_ Edirect /(_ (groupP G))defE]] := gal_matrix G.\nset n := #|G|; set m := \\dim (fixedField G); rewrite -defE (directvP Edirect).\nrewrite -[n]card_ord -(@mulnK #|'I_n| m) ?adim_gt0 //= -sum_nat_const.\ncongr (_ %/ _)%N; apply: eq_bigr => i _.\nby rewrite dim_cosetv ?(memPn nzw) ?mem_tnth.\nQed.",
    "Lemma dim_fixed_galois K E (G : {group gal_of E}) :\n    galois K E -> G \\subset 'Gal(E / K) ->\n  \\dim_K (fixedField G) = #|'Gal(E / K) : G|.\nProof.\nmove=> galE sGgal; have [sFE _ _] := and3P galE; apply/eqP.\nrewrite -divgS // eqn_div ?cardSg // dim_fixedField -galois_dim //.\nby rewrite mulnC muln_divA ?divnK ?field_dimS ?capvSl -?galois_connection.\nQed.",
    "Lemma gal_fixedField E (G : {group gal_of E}): 'Gal(E / fixedField G) = G.\nProof.\napply/esym/eqP; rewrite eqEcard galois_connection_subset /= (dim_fixedField G).\nrewrite galois_dim //; apply/galois_fixedField/eqP.\nrewrite eqEsubv galois_connection_subv ?capvSl //.\nby rewrite fixedFieldS ?galois_connection_subset.\nQed.",
    "Lemma gal_generated E (A : {set gal_of E}) : 'Gal(E / fixedField A) = <<A>>.\nProof.\napply/eqP; rewrite eqEsubset gen_subG galois_connection_subset.\nby rewrite -[<<A>>]gal_fixedField galS // fixedFieldS // subset_gen.\nQed.",
    "Lemma fixedField_galois E (A : {set gal_of E}): galois (fixedField A) E.\nProof.\nhave: galois (fixedField <<A>>) E.\n  by apply/galois_fixedField; rewrite gal_fixedField.\nby apply: galoisS; rewrite capvSl fixedFieldS // subset_gen.\nQed.",
    "Lemma normalField_galois : galois K M.\nProof.\nhave [[sKM sME] [_ sepKE nKE]] := (andP sKME, and3P galKE).\nby rewrite /galois sKM (separableSr sME).\nQed.",
    "Lemma normalField_cast_eq x :\n  x \\in 'Gal(E / K) -> {in M, normalField_cast x =1 x}.\nProof.\nhave [sKM sME] := andP sKME; have sKE := subv_trans sKM sME.\nrewrite gal_kAut // => /(normalField_kAut sKME nKM).\nby rewrite kAutE => /andP[_ /galK].\nQed.",
    "Lemma normalField_castM :\n  {in 'Gal(E / K) &, {morph normalField_cast : x y / (x * y)%g}}.\nProof.\nmove=> x y galEx galEy /=; apply/eqP/gal_eqP => a Ma.\nhave Ea: a \\in E by have [_ /subvP->] := andP sKME.\nrewrite normalField_cast_eq ?groupM ?galM //=.\nby rewrite normalField_cast_eq ?memv_gal // normalField_cast_eq.\nQed.",
    "Lemma normalField_ker : 'ker normalField_cast = 'Gal(E / M).\nProof.\nhave [sKM sME] := andP sKME.\napply/setP=> x; apply/idP/idP=> [kerMx | galEMx].\n  rewrite gal_kHom //; apply/kAHomP=> a Ma.\n  by rewrite -normalField_cast_eq ?(dom_ker kerMx) // (mker kerMx) gal_id.\nhave galEM: x \\in 'Gal(E / K) := subsetP (galS E sKM) x galEMx.\napply/kerP=> //; apply/eqP/gal_eqP=> a Ma.\nby rewrite normalField_cast_eq // gal_id (fixed_gal sME).\nQed.",
    "Lemma normalField_normal : 'Gal(E / M) <| 'Gal(E / K).\nProof. by rewrite -normalField_ker ker_normal. Qed.",
    "Lemma normalField_img : normalField_cast @* 'Gal(E / K) = 'Gal(M / K).\nProof.\nhave [[sKM sME] [sKE _ nKE]] := (andP sKME, and3P galKE).\napply/setP=> x; apply/idP/idP=> [/morphimP[{}x galEx _ ->] | galMx].\n  rewrite gal_kHom //; apply/kAHomP=> a Ka; have Ma := subvP sKM a Ka.\n  by rewrite normalField_cast_eq // (fixed_gal sKE).\nhave /(kHom_to_gal sKME nKE)[y galEy eq_xy]: kHom K M x by rewrite -gal_kHom.\napply/morphimP; exists y => //; apply/eqP/gal_eqP => a Ha.\nby rewrite normalField_cast_eq // eq_xy.\nQed.",
    "Lemma normalField_isom :\n  {f : {morphism ('Gal(E / K) / 'Gal(E / M)) >-> gal_of M} |\n     isom ('Gal(E / K) / 'Gal (E / M)) 'Gal(M / K) f\n   & (forall A, f @* (A / 'Gal(E / M)) = normalField_cast @* A)\n  /\\ {in 'Gal(E / K) & M, forall x, f (coset 'Gal (E / M) x) =1 x} }%g.\nProof.\nhave:= first_isom normalField_cast_morphism; rewrite normalField_ker.\ncase=> f injf Df; exists f; first by apply/isomP; rewrite Df normalField_img.\nsplit=> [//|x a galEx /normalField_cast_eq<- //]; congr ((_ : gal_of M) a).\napply: set1_inj; rewrite -!morphim_set1 ?mem_quotient ?Df //.\nby rewrite (subsetP (normal_norm normalField_normal)).\nQed.",
    "Lemma normalField_isog : 'Gal(E / K) / 'Gal(E / M) \\isog 'Gal(M / K).\nProof. by rewrite -normalField_ker -normalField_img first_isog. Qed.",
    "Lemma normal_fixedField_galois : galois K (fixedField G).\nProof.\nhave [[sKE sepKE nKE] [sGgal nGgal]] := (and3P galKE, andP nsGgalE).\nrewrite /galois -(galois_connection _ sKE) sGgal.\nrewrite (separableSr _ sepKE) ?capvSl //; apply/forall_inP=> f autKf.\nrewrite eqEdim limg_dim_eq ?(eqP (AEnd_lker0 _)) ?capv0 // leqnn andbT.\napply/subvP => _ /memv_imgP[a /mem_fixedFieldP[Ea cGa] ->].\nhave /kAut_to_gal[x galEx -> //]: kAut K E f.\n  rewrite /kAut (forall_inP nKE) // andbT; apply/kAHomP.\n  by move: autKf; rewrite inE kAutfE => /kHomP[].\napply/fixedFieldP=> [|y Gy]; first exact: memv_gal.\nby rewrite -galM // conjgCV galM //= cGa // memJ_norm ?groupV ?(subsetP nGgal).\nQed.",
    "Lemma cyclotomic_monic z n : cyclotomic z n \\is monic.\nProof. exact: monic_prod_XsubC. Qed.",
    "Lemma size_cyclotomic z n : size (cyclotomic z n) = (totient n).+1.\nProof.\nrewrite /cyclotomic -big_filter size_prod_XsubC; congr _.+1.\ncase: big_enumP => _ _ _ [_ ->].\nrewrite totient_count_coprime -big_mkcond big_mkord -sum1_card.\nby apply: eq_bigl => k; rewrite coprime_sym.\nQed.",
    "Lemma separable_Xn_sub_1 (R : idomainType) n :\n  n%:R != 0 :> R -> @separable_poly R ('X^n - 1).\nProof.\ncase: n => [/eqP// | n nz_n]; rewrite unlock linearB /= derivC subr0.\nrewrite derivXn -scaler_nat coprimepZr //= exprS -scaleN1r coprimep_sym.\nby rewrite coprimep_addl_mul coprimepZr ?coprimep1 // (signr_eq0 _ 1).\nQed.",
    "Lemma root_cyclotomic x : root (cyclotomic z n) x = n.-primitive_root x.\nProof.\ntransitivity (x \\in [seq z ^+ i | i : 'I_n in [pred i : 'I_n | coprime i n]]).\n  by rewrite -root_prod_XsubC big_image.\napply/imageP/idP=> [[k co_k_n ->] | prim_x].\n  by rewrite prim_root_exp_coprime.\nhave [k Dx] := prim_rootP prim_z (prim_expr_order prim_x).\nexists (Ordinal (ltn_pmod k n_gt0)) => /=; last by rewrite prim_expr_mod.\nby rewrite inE coprime_modl -(prim_root_exp_coprime k prim_z) -Dx.\nQed.",
    "Lemma prod_cyclotomic :\n  'X^n - 1 = \\prod_(d <- divisors n) cyclotomic (z ^+ (n %/ d)) d.\nProof.\nhave in_d d: (d %| n)%N -> val (@inord n d) = d by move/dvdn_leq/inordK=> /= ->.\nhave dv_n k: (n %/ gcdn k n %| n)%N.\n  by rewrite -{3}(divnK (dvdn_gcdr k n)) dvdn_mulr.\nhave [uDn _ inDn] := divisors_correct n_gt0.\nhave defDn: divisors n = map val (map (@inord n) (divisors n)).\n  by rewrite -map_comp map_id_in // => d; rewrite inDn => /in_d.\nrewrite defDn big_map big_uniq /=; last first.\n  by rewrite -(map_inj_uniq val_inj) -defDn.\npose h (k : 'I_n) : 'I_n.+1 := inord (n %/ gcdn k n).\nrewrite -(factor_Xn_sub_1 prim_z) big_mkord.\nrewrite (partition_big h (dvdn^~ n)) /= => [|k _]; last by rewrite in_d ?dv_n.\napply: eq_big => d; first by rewrite -(mem_map val_inj) -defDn inDn.\nset q := (n %/ d)%N => d_dv_n.\nhave [q_gt0 d_gt0]: (0 < q /\\ 0 < d)%N by apply/andP; rewrite -muln_gt0 divnK.\nhave fP (k : 'I_d): (q * k < n)%N by rewrite divn_mulAC ?ltn_divLR ?ltn_pmul2l.\nrewrite (reindex (fun k => Ordinal (fP k))); last first.\n  have f'P (k : 'I_n): (k %/ q < d)%N by rewrite ltn_divLR // mulnC divnK.\n  exists (fun k => Ordinal (f'P k)) => [k _ | k /eqnP/=].\n    by apply: val_inj; rewrite /= mulKn.\n  rewrite in_d // => Dd; apply: val_inj; rewrite /= mulnC divnK // /q -Dd.\n  by rewrite divnA ?mulKn ?dvdn_gcdl ?dvdn_gcdr.\napply: eq_big => k; rewrite ?exprM // -val_eqE in_d //=.\nrewrite -eqn_mul ?dvdn_gcdr ?gcdn_gt0 ?n_gt0 ?orbT //.\nrewrite -[n in gcdn _ n](divnK d_dv_n) -muln_gcdr mulnCA mulnA divnK //.\nby rewrite mulnC eqn_mul // divnn n_gt0 eq_sym.\nQed.",
    "Lemma C_prim_root_exists n : (n > 0)%N -> {z : algC | n.-primitive_root z}.\nProof.\npose p : {poly algC} := 'X^n - 1; have [r Dp] := closed_field_poly_normal p.\nmove=> n_gt0; apply/sigW; rewrite (monicP _) ?monicXnsubC // scale1r in Dp.\nhave rn1: all n.-unity_root r by apply/allP=> z; rewrite -root_prod_XsubC -Dp.\nhave sz_r: (n < (size r).+1)%N.\n  by rewrite -(size_prod_XsubC r id) -Dp size_XnsubC.\nhave [|z] := hasP (has_prim_root n_gt0 rn1 _ sz_r); last by exists z.\nby rewrite -separable_prod_XsubC -Dp separable_Xn_sub_1 // pnatr_eq0 -lt0n.\nQed.",
    "Lemma Cyclotomic_monic n : 'Phi_n \\is monic.\nProof.\nrewrite /'Phi_n; case: (C_prim_root_exists _) => z /= _.\nrewrite monicE lead_coefE coef_map_id0 ?(int_algC_K 0) ?floor0 //.\nby rewrite size_poly_eq -lead_coefE (monicP (cyclotomic_monic _ _)) (intCK 1).\nQed.",
    "Lemma Cintr_Cyclotomic n z :\n  n.-primitive_root z -> pZtoC 'Phi_n = cyclotomic z n.\nProof.\nelim/ltn_ind: n z => n IHn z0 prim_z0.\nrewrite /'Phi_n; case: (C_prim_root_exists _) => z /=.\nhave n_gt0 := prim_order_gt0 prim_z0; rewrite prednK // => prim_z.\nhave [uDn _ inDn] := divisors_correct n_gt0.\npose q := \\prod_(d <- rem n (divisors n)) 'Phi_d.\nhave mon_q: q \\is monic by apply: monic_prod => d _; apply: Cyclotomic_monic.\nhave defXn1: cyclotomic z n * pZtoC q = 'X^n - 1.\n  rewrite (prod_cyclotomic prim_z) (big_rem n) ?inDn //=.\n  rewrite divnn n_gt0 rmorph_prod /=; congr (_ * _).\n  apply: eq_big_seq => d; rewrite mem_rem_uniq ?inE //= inDn => /andP[n'd ddvn].\n  by rewrite -IHn ?dvdn_prim_root // ltn_neqAle n'd dvdn_leq.\nhave mapXn1 (R1 R2 : nzRingType) (f : {rmorphism R1 -> R2}):\n  map_poly f ('X^n - 1) = 'X^n - 1.\n- by rewrite rmorphB /= rmorph1 map_polyXn.\nhave nz_q: pZtoC q != 0.\n  by rewrite -size_poly_eq0 size_map_inj_poly // size_poly_eq0 monic_neq0.\nhave [r def_zn]: exists r, cyclotomic z n = pZtoC r.\n  have defZtoC: ZtoC =1 QtoC \\o ZtoQ by move=> a; rewrite /= rmorph_int.\n  have /dvdpP[r0 Dr0]: map_poly ZtoQ q %| 'X^n - 1.\n    rewrite -(dvdp_map (@ratr algC)) mapXn1 -map_poly_comp.\n    by rewrite -(eq_map_poly defZtoC) -defXn1 dvdp_mull.\n  have [r [a nz_a Dr]] := rat_poly_scale r0.\n  exists (zprimitive r); apply: (mulIf nz_q); rewrite defXn1.\n  rewrite -rmorphM -(zprimitive_monic mon_q) -zprimitiveM /=.\n  have ->: r * q = a *: ('X^n - 1).\n    apply: (map_inj_poly (intr_inj : injective ZtoQ)) => //.\n    rewrite map_polyZ mapXn1 Dr0 Dr -scalerAl scalerKV ?intr_eq0 //.\n    by rewrite rmorphM.\n  by rewrite zprimitiveZ // zprimitive_monic ?monicXnsubC ?mapXn1.\nrewrite floorpK; last by apply/polyOverP=> i; rewrite def_zn coef_map /=.\npose f e (k : 'I_n) := Ordinal (ltn_pmod (k * e) n_gt0).\nhave [e Dz0] := prim_rootP prim_z (prim_expr_order prim_z0).\nhave co_e_n: coprime e n by rewrite -(prim_root_exp_coprime e prim_z) -Dz0.\nhave injf: injective (f e).\n  apply: can_inj (f (egcdn e n).1) _ => k; apply: val_inj => /=.\n  rewrite modnMml -mulnA -modnMmr -{1}(mul1n e).\n  by rewrite (chinese_modr co_e_n 0) modnMmr muln1 modn_small.\nrewrite [_ n](reindex_inj injf); apply: eq_big => k /=.\n  by rewrite coprime_modl coprimeMl co_e_n andbT.\nby rewrite prim_expr_mod // mulnC exprM -Dz0.\nQed.",
    "Lemma prod_Cyclotomic n :\n  (n > 0)%N -> \\prod_(d <- divisors n) 'Phi_d = 'X^n - 1.\nProof.\nmove=> n_gt0; have [z prim_z] := C_prim_root_exists n_gt0.\napply: (map_inj_poly (intr_inj : injective ZtoC)) => //.\nrewrite rmorphB rmorph1 rmorph_prod /= map_polyXn (prod_cyclotomic prim_z).\napply: eq_big_seq => d; rewrite -dvdn_divisors // => d_dv_n.\nby rewrite -Cintr_Cyclotomic ?dvdn_prim_root.\nQed.",
    "Lemma Cyclotomic0 : 'Phi_0 = 1.\nProof.\nrewrite /'Phi_0; case: (C_prim_root_exists _) => z /= _.\nby rewrite -[1]polyseqK /cyclotomic big_ord0 map_polyE !polyseq1 /= (intCK 1).\nQed.",
    "Lemma size_Cyclotomic n : size 'Phi_n = (totient n).+1.\nProof.\nhave [-> | n_gt0] := posnP n; first by rewrite Cyclotomic0 polyseq1.\nhave [z prim_z] := C_prim_root_exists n_gt0.\nrewrite -(size_map_inj_poly (can_inj intCK)) //.\nby rewrite (Cintr_Cyclotomic prim_z) size_cyclotomic.\nQed.",
    "Lemma minCpoly_cyclotomic n z :\n  n.-primitive_root z -> minCpoly z = cyclotomic z n.\nProof.\nmove=> prim_z; have n_gt0 := prim_order_gt0 prim_z.\nhave Dpz := Cintr_Cyclotomic prim_z; set pz := cyclotomic z n in Dpz *.\nhave mon_pz: pz \\is monic by apply: cyclotomic_monic.\nhave pz0: root pz z by rewrite root_cyclotomic.\nhave [pf [Dpf mon_pf] dv_pf] := minCpolyP z.\nhave /dvdpP_rat_int[f [af nz_af Df] [g /esym Dfg]]: pf %| pZtoQ 'Phi_n.\n  rewrite -dv_pf; congr (root _ z): pz0; rewrite -Dpz -map_poly_comp.\n  by apply: eq_map_poly => b; rewrite /= rmorph_int.\nwithout loss{nz_af} [mon_f mon_g]: af f g Df Dfg / f \\is monic /\\ g \\is monic.\n  move=> IH; pose cf := lead_coef f; pose cg := lead_coef g.\n  have cfg1: cf * cg = 1.\n    by rewrite -lead_coefM Dfg (monicP (Cyclotomic_monic n)).\n  apply: (IH (af *~ cf) (f *~ cg) (g *~ cf)).\n  - by rewrite rmorphMz -scalerMzr scalerMzl -mulrzA cfg1.\n  - by rewrite mulrzAl mulrzAr -mulrzA cfg1.\n  by rewrite !(intz, =^~ scaler_int) !monicE !lead_coefZ mulrC cfg1.\nhave{af} Df: pQtoC pf = pZtoC f.\n  have:= congr1 lead_coef Df.\n  rewrite lead_coefZ lead_coef_map_inj //; last exact: intr_inj.\n  rewrite !(monicP _) // mulr1 Df => <-; rewrite scale1r -map_poly_comp.\n  by apply: eq_map_poly => b; rewrite /= rmorph_int.\nhave [/size1_polyC Dg | g_gt1] := leqP (size g) 1.\n  rewrite monicE Dg lead_coefC in mon_g.\n  by rewrite -Dpz -Dfg Dg (eqP mon_g) mulr1 Dpf.\nhave [zk gzk0]: exists zk, root (pZtoC g) zk.\n  have [rg] := closed_field_poly_normal (pZtoC g).\n  rewrite lead_coef_map_inj // (monicP mon_g) scale1r => Dg.\n  rewrite -(size_map_inj_poly (can_inj intCK)) // Dg in g_gt1.\n  rewrite size_prod_XsubC in g_gt1.\n  by exists rg`_0; rewrite Dg root_prod_XsubC mem_nth.\nhave [k cokn Dzk]: exists2 k, coprime k n & zk = z ^+ k.\n  have: root pz zk by rewrite -Dpz -Dfg rmorphM rootM gzk0 orbT.\n  rewrite -[pz](big_image _ _ _ _ (fun r => 'X - r%:P)) root_prod_XsubC.\n  by case/imageP=> k; exists k.\nhave co_fg (R : idomainType): n%:R != 0 :> R -> @coprimep R (intrp f) (intrp g).\n  move=> nz_n; have: separable_poly (intrp ('X^n - 1) : {poly R}).\n    by rewrite rmorphB rmorph1 /= map_polyXn separable_Xn_sub_1.\n  rewrite -prod_Cyclotomic // (big_rem n) -?dvdn_divisors //= -Dfg.\n  by rewrite !rmorphM /= !separable_mul => /and3P[] /and3P[].\nsuffices fzk0: root (pZtoC f) zk.\n  have [] // := negP (coprimep_root (co_fg _ _) fzk0).\n  by rewrite pnatr_eq0 -lt0n.\nmove: gzk0 cokn; rewrite {zk}Dzk; elim/ltn_ind: k => k IHk gzk0 cokn.\nhave [|k_gt1] := leqP k 1; last have [p p_pr /dvdnP[k1 Dk]] := pdivP k_gt1.\n  rewrite -[leq k 1](mem_iota 0 2) !inE => /pred2P[k0 | ->]; last first.\n    by rewrite -Df dv_pf.\n  have /eqP := size_Cyclotomic n; rewrite -Dfg size_Mmonic ?monic_neq0 //.\n  rewrite k0 /coprime gcd0n in cokn; rewrite (eqP cokn).\n  rewrite -(size_map_inj_poly (can_inj intCK)) // -Df -Dpf.\n  by rewrite -(subnKC g_gt1) -(subnKC (size_minCpoly z)) !addnS.\nmove: cokn; rewrite Dk coprimeMl => /andP[cok1n].\nrewrite prime_coprime // (dvdn_pcharf (pchar_Fp p_pr)) => /co_fg {co_fg}.\nhave pcharFpX: p \\in [pchar {poly 'F_p}] by rewrite (rmorph_pchar polyC) ?pchar_Fp.\nrewrite -(coprimep_pexpr _ _ (prime_gt0 p_pr)) -(pFrobenius_autE pcharFpX).\nrewrite -[g]comp_polyXr map_comp_poly -horner_map /= pFrobenius_autE -rmorphXn.\nrewrite -!map_poly_comp (@eq_map_poly _ _ _ (polyC \\o *~%R 1)); last first.\n  by move=> a; rewrite /= !rmorph_int.\nrewrite map_poly_comp -[_.[_]]map_comp_poly /= => co_fg.\nsuffices: coprimep (pZtoC f) (pZtoC (g \\Po 'X^p)).\n  move/coprimep_root=> /=/(_ (z ^+ k1))/implyP.\n  rewrite map_comp_poly map_polyXn horner_comp hornerXn.\n  rewrite -exprM -Dk [_ == 0]gzk0 implybF => /negP[].\n  have: root pz (z ^+ k1).\n    by rewrite root_cyclotomic // prim_root_exp_coprime.\n  rewrite -Dpz -Dfg rmorphM rootM => /orP[] //= /IHk-> //.\n  rewrite -[k1]muln1 Dk ltn_pmul2l ?prime_gt1 //.\n  by have:= ltnW k_gt1; rewrite Dk muln_gt0 => /andP[].\nsuffices: coprimep f (g \\Po 'X^p).\n  case/Bezout_coprimepP=> [[u v]]; rewrite -size_poly_eq1.\n  rewrite -(size_map_inj_poly (can_inj intCK)) // rmorphD !rmorphM /=.\n  rewrite size_poly_eq1 => {}co_fg; apply/Bezout_coprimepP.\n  by exists (pZtoC u, pZtoC v).\napply: contraLR co_fg => /coprimepPn[|d]; first exact: monic_neq0.\nrewrite andbC -size_poly_eq1 dvdp_gcd => /and3P[sz_d].\npose d1 := zprimitive d.\nhave d_dv_mon h: d %| h -> h \\is monic -> exists h1, h = d1 * h1.\n  case/Pdiv.Idomain.dvdpP=> [[c h1] /= nz_c Dh] mon_h; exists (zprimitive h1).\n  by rewrite -zprimitiveM mulrC -Dh zprimitiveZ ?zprimitive_monic.\ncase/d_dv_mon=> // f1 Df1 /d_dv_mon[|f2 ->].\n  rewrite monicE lead_coefE size_comp_poly size_polyXn /=.\n  rewrite comp_polyE coef_sum polySpred ?monic_neq0 //= mulnC.\n  rewrite big_ord_recr /= -lead_coefE (monicP mon_g) scale1r.\n  rewrite -exprM coefXn eqxx big1 ?add0r // => i _.\n  rewrite coefZ -exprM coefXn eqn_pmul2l ?prime_gt0 //.\n  by rewrite eqn_leq leqNgt ltn_ord mulr0.\nhave monFp h: h \\is monic -> size (map_poly intr h) = size h.\n  by move=> mon_h; rewrite size_poly_eq // -lead_coefE (monicP mon_h) oner_eq0.\napply/coprimepPn; last exists (map_poly intr d1).\n  by rewrite -size_poly_eq0 monFp // size_poly_eq0 monic_neq0.\nrewrite Df1 !rmorphM dvdp_gcd !dvdp_mulr //= -size_poly_eq1.\nrewrite monFp ?size_zprimitive //.\nrewrite monicE [_ d1]intEsg sgz_lead_primitive -zprimitive_eq0 -/d1.\nrewrite -lead_coef_eq0 -absz_eq0.\nhave/esym/eqP := congr1 (absz \\o lead_coef) Df1.\nby rewrite /= (monicP mon_f) lead_coefM abszM muln_eq1 => /andP[/eqP-> _].\nQed.",
    "Lemma qf_simpl (f : fF) :\n  (qf f -> GRing.qf_form f) * (qf f -> GRing.rformula f).\nProof. by split=> /andP[]. Qed.",
    "Lemma qf_cps_ret T D (x : T) : D x -> qf_cps D (ret x).\nProof. move=> ??; exact. Qed.",
    "Lemma qf_cps_bind T1 D1 T2 D2 (x : cps T1) (f : T1 -> cps T2) :\n  qf_cps D1 x -> (forall x, D1 x -> qf_cps D2 (f x)) -> qf_cps D2 (bind x f).\nProof. by move=> xP fP k kP /=; apply: xP => y ?; apply: fP. Qed.",
    "Lemma qf_cps_if T D (c : fF) (t : T) (e : T) : qf c -> D t -> D e ->\n  qf_cps D ('if c then t else e).\nProof.\nmove=> qfc Dt De k kP /=; have [qft qfe] := (kP _ Dt, kP _ De).\nby do !rewrite qf_simpl //.\nQed.",
    "Lemma sizeTP (pf : polyF) : sizeT pf ->_e size (eval_poly e pf).\nProof.\nelim: pf=> [|c qf qfP /=]; first by rewrite /= size_poly0.\nmove=> e k; rewrite size_MXaddC qfP -(size_poly_eq0 (eval_poly _ _)).\nby case: (size (eval_poly e qf))=> //=; case: eqP; rewrite // orbF.\nQed.",
    "Lemma sizeT_qf (p : polyF) : rpoly p -> qf_cps xpredT (sizeT p).\nProof.\nelim: p => /= [_|c p ihp /andP[rc rq]]; first exact: qf_cps_ret.\napply: qf_cps_bind; first exact: ihp.\nmove=> [|n] //= _; last exact: qf_cps_ret.\nby apply: qf_cps_if; rewrite //= rc.\nQed.",
    "Lemma isnullP (p : polyF) : isnull p ->_e (eval_poly e p == 0).\nProof. by move=> e k; rewrite sizeTP size_poly_eq0. Qed.",
    "Lemma isnull_qf (p : polyF) : rpoly p -> qf_cps xpredT (isnull p).\nProof.\nmove=> rp; apply: qf_cps_bind; first exact: sizeT_qf.\nby move=> ? _; apply: qf_cps_ret.\nQed.",
    "Lemma eval_lift (e : seq F) (p : {poly F}) : eval_poly e (lift p) = p.\nProof.\nelim/poly_ind: p => [|p c]; first by rewrite /lift polyseq0.\nrewrite -cons_poly_def /lift polyseq_cons /nilp.\ncase pn0: (_ == _) => /=; last by move->; rewrite -cons_poly_def.\nmove=> _; rewrite polyseqC.\ncase c0: (_==_)=> /=.\n  move: pn0; rewrite (eqP c0) size_poly_eq0; move/eqP->.\n  by apply: val_inj=> /=; rewrite polyseq_cons // polyseq0.\nby rewrite mul0r add0r; apply: val_inj=> /=; rewrite polyseq_cons // /nilp pn0.\nQed.",
    "Lemma lead_coefTP (k : tF -> fF) :\n (forall x e, qf_eval e (k x) = qf_eval e (k (eval e x)%:T%T)) ->\n  forall (p : polyF) (e : seq F),\n  qf_eval e (lead_coefT p k) = qf_eval e (k (lead_coef (eval_poly e p))%:T%T).\nProof.\nmove=> kP p e; elim: p => [|a p IHp]/= in k kP e *.\n  by rewrite lead_coef0 kP.\nrewrite IHp; last by move=> *; rewrite //= -kP.\nrewrite GRing.eval_If /= lead_coef_eq0.\ncase p'0: (_ == _); first by rewrite (eqP p'0) mul0r add0r lead_coefC -kP.\nrewrite lead_coefDl ?lead_coefMX // polyseqC size_mul ?p'0 //; last first.\n  by rewrite -size_poly_eq0 size_polyX.\nrewrite size_polyX addnC /=; case: (_ == _)=> //=.\nby rewrite ltnS lt0n size_poly_eq0 p'0.\nQed.",
    "Lemma lead_coefT_qf (p : polyF) : rpoly p -> qf_cps (@rterm _) (lead_coefT p).\nProof.\nelim: p => [_|c q ihp //= /andP[rc rq]]; first by apply: qf_cps_ret.\napply: qf_cps_bind => [|y ty]; first exact: ihp.\nby apply: qf_cps_if; rewrite //= ty.\nQed.",
    "Lemma eval_amulXnT  (a : tF) (n : nat) (e : seq F) :\n  eval_poly e (amulXnT a n) = (eval e a)%:P * 'X^n.\nProof.\nelim: n=> [|n] /=; first by rewrite expr0 mulr1 mul0r add0r.\nby move->; rewrite addr0 -mulrA -exprSr.\nQed.",
    "Lemma ramulXnT: forall a n, rterm a -> rpoly (amulXnT a n).\nProof. by move=> a n; elim: n a=> [a /= -> //|n ihn a ra]; apply: ihn. Qed.",
    "Lemma eval_sumpT (p q : polyF) (e : seq F) :\n  eval_poly e (sumpT p q) = (eval_poly e p) + (eval_poly e q).\nProof.\nelim: p q => [|a p Hp] q /=; first by rewrite add0r.\ncase: q => [|b q] /=; first by rewrite addr0.\nrewrite Hp mulrDl -!addrA; congr (_ + _); rewrite polyCD addrC -addrA.\nby congr (_ + _); rewrite addrC.\nQed.",
    "Lemma rsumpT (p q : polyF) : rpoly p -> rpoly q -> rpoly (sumpT p q).\nProof.\nelim: p q=> [|a p ihp] q rp rq //; move: rp; case/andP=> ra rp.\ncase: q rq => [|b q]; rewrite /= ?ra ?rp //=.\nby case/andP=> -> rq //=; apply: ihp.\nQed.",
    "Lemma eval_mulpT (p q : polyF) (e : seq F) :\n  eval_poly e (mulpT p q) = (eval_poly e p) * (eval_poly e q).\nProof.\nelim: p q=> [|a p Hp] q /=; first by rewrite mul0r.\nrewrite eval_sumpT /= Hp addr0 mulrDl addrC mulrAC; congr (_ + _).\nby elim: q=> [|b q Hq] /=; rewrite ?mulr0 // Hq polyCM mulrDr mulrA.\nQed.",
    "Lemma rpoly_map_mul (t : tF) (p : polyF) (rt : rterm t) :\n  rpoly [seq (t * x)%T | x <- p] = rpoly p.\nProof. by rewrite /rpoly all_map; apply/eq_all => x; rewrite /= rt. Qed.",
    "Lemma rmulpT (p q : polyF) : rpoly p -> rpoly q -> rpoly (mulpT p q).\nProof.\nelim: p q=> [|a p ihp] q rp rq //=; move: rp; case/andP=> ra rp /=.\napply: rsumpT; last exact: ihp.\nby rewrite rpoly_map_mul.\nQed.",
    "Lemma eval_opppT (p : polyF) (e : seq F) :\n  eval_poly e (opppT p) = - eval_poly e p.\nProof.\nby elim: p; rewrite /= ?oppr0 // => ? ? ->; rewrite !mulNr opprD polyCN mul1r.\nQed.",
    "Lemma eval_natmulpT  (p : polyF) (n : nat) (e : seq F) :\n  eval_poly e (natmulpT n p) = (eval_poly e p) *+ n.\nProof.\nelim: p; rewrite //= ?mul0rn // => c p ->.\nrewrite mulrnDl mulr_natl polyCMn; congr (_ + _).\nby rewrite -mulr_natl mulrAC -mulrA mulr_natl mulrC.\nQed.",
    "Lemma redivp_rec_loopTP (k : nat * polyF * polyF -> fF) :\n  (forall c qq r e,  qf_eval e (k (c,qq,r))\n    = qf_eval e (k (c, lift (eval_poly e qq), lift (eval_poly e r))))\n  -> forall q sq cq c qq r n e\n    (d := redivp_rec_loop (eval_poly e q) sq (eval e cq)\n      c (eval_poly e qq) (eval_poly e r) n),\n    qf_eval e (redivp_rec_loopT q sq cq c qq r n k)\n    = qf_eval e (k (d.1.1, lift d.1.2, lift d.2)).\nProof.\nmove=> Pk q sq cq c qq r n e /=.\nelim: n c qq r k Pk e => [|n Pn] c qq r k Pk e; rewrite sizeTP.\n  case ltrq : (_ < _); first by rewrite /= ltrq /= -Pk.\n  rewrite lead_coefTP => [|a p]; rewrite Pk.\n    rewrite ?(eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT) //=.\n    by rewrite ltrq //= !mul_polyC ?(mul0r,add0r,scale0r).\n  by symmetry; rewrite Pk ?(eval_mulpT,eval_amulXnT,eval_sumpT, eval_opppT).\ncase ltrq : (_<_); first by rewrite /= ltrq Pk.\nrewrite lead_coefTP.\n  rewrite Pn ?(eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT) //=.\n  by rewrite ltrq //= !mul_polyC ?(mul0r,add0r,scale0r).\nrewrite -/redivp_rec_loopT => x e'.\nrewrite Pn; last by move=> *; rewrite Pk.\nsymmetry; rewrite Pn; last by move=> *; rewrite Pk.\nrewrite Pk ?(eval_lift,eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT).\nby rewrite mul_polyC ?(mul0r,add0r).\nQed.",
    "Lemma redivp_rec_loopT_qf (q : polyF) (sq : nat) (cq : tF)\n  (c : nat) (qq r : polyF) (n : nat) :\n  rpoly q -> rterm cq -> rpoly qq -> rpoly r ->\n  qf_cps (fun x => [&& rpoly x.1.2 & rpoly x.2])\n         (redivp_rec_loopT q sq cq c qq r n).\nProof.\ndo ![move=>x/(pair x){x}] => rw; elim: n => [|n IHn]//= in q sq cq c qq r rw *;\napply: qf_cps_bind; do ?[by apply: sizeT_qf; rewrite !rw] => sr _;\ncase: ifPn => // _; do ?[by apply: qf_cps_ret; rewrite //= ?rw];\napply: qf_cps_bind; do ?[by apply: lead_coefT_qf; rewrite !rw] => lr /= rlr;\n[apply: qf_cps_ret|apply: IHn];\nby do !rewrite ?(rsumpT,rmulpT,ramulXnT,rpoly_map_mul,rlr,rw) //=.\nQed.",
    "Lemma redivp_rec_loopP  (q : {poly F}) (c : nat) (qq r : {poly F}) (n : nat) :\n  redivp_rec q c qq r n = redivp_rec_loop q (size q) (lead_coef q) c qq r n.\nProof. by elim: n c qq r => [| n Pn] c qq r //=; rewrite Pn. Qed.",
    "Lemma redivpTP (k : nat * polyF * polyF -> fF) :\n  (forall c qq r e,\n     qf_eval e (k (c,qq,r)) =\n     qf_eval e (k (c, lift (eval_poly e qq), lift (eval_poly e r)))) ->\n  forall p q e (d := redivp (eval_poly e p) (eval_poly e q)),\n    qf_eval e (redivpT p q k) = qf_eval e (k (d.1.1, lift d.1.2, lift d.2)).\nProof.\nmove=> Pk p q e /=; rewrite isnullP unlock /=.\ncase q0 : (eval_poly e q == 0) => /=; first by rewrite Pk /= mul0r add0r polyC0.\nrewrite !sizeTP lead_coefTP /=; last by move=> *; rewrite !redivp_rec_loopTP.\nrewrite redivp_rec_loopTP /=; last by move=> *; rewrite Pk.\nby rewrite mul0r add0r polyC0 redivp_rec_loopP.\nQed.",
    "Lemma redivpT_qf (p : polyF) (q : polyF) : rpoly p -> rpoly q ->\n  qf_cps (fun x => [&& rpoly x.1.2 & rpoly x.2]) (redivpT p q).\nProof.\nmove=> rp rq; apply: qf_cps_bind => [|[] _]; first exact: isnull_qf.\n  by apply: qf_cps_ret.\napply: qf_cps_bind => [|sp _]; first exact: sizeT_qf.\napply: qf_cps_bind => [|sq _]; first exact: sizeT_qf.\napply: qf_cps_bind => [|lq rlq]; first exact: lead_coefT_qf.\nby apply: redivp_rec_loopT_qf => //=.\nQed.",
    "Lemma rgcdp_loopP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p)))) ->\n  forall n p q e,\n    qf_eval e (rgcdp_loopT n p q k) =\n    qf_eval e (k (lift (rgcdp_loop n (eval_poly e p) (eval_poly e q)))).\nProof.\nmove=> Pk n p q e; elim: n => /= [| m IHm] in p q e *;\nrewrite redivpTP /==> *; rewrite ?isnullP ?eval_lift -/(rmodp _ _);\nby case: (_ == _); do ?by rewrite -?Pk ?IHm ?eval_lift.\nQed.",
    "Lemma rgcdp_loopT_qf (n : nat) (p : polyF) (q : polyF) :\n  rpoly p -> rpoly q -> qf_cps rpoly (rgcdp_loopT n p q).\nProof.\nelim: n => [|n IHn] in p q * => rp rq /=;\n(apply: qf_cps_bind=> [|rr rrr]; [\n  apply: qf_cps_bind => [|[[a u] v]]; do ?exact: redivpT_qf;\n  by move=> /andP[/= ??]; apply: (@qf_cps_ret _ rpoly)|\napply: qf_cps_bind => [|[] _];\nby [apply: isnull_qf|apply: qf_cps_ret|apply: IHn]]).\nQed.",
    "Lemma rgcdpTP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p)))) ->\n   forall p q e, qf_eval e (rgcdpT p q k) =\n                 qf_eval e (k (lift (rgcdp (eval_poly e p) (eval_poly e q)))).\nProof.\nmove=> Pk p q e; rewrite /rgcdpT /rgcdp !sizeTP /=.\ncase: (_ < _); rewrite !isnullP /=; case: (_ == _); rewrite -?Pk ?sizeTP;\nby rewrite ?rgcdp_loopP.\nQed.",
    "Lemma rgcdpT_qf (p : polyF) (q : polyF) :\n   rpoly p -> rpoly q -> qf_cps rpoly (rgcdpT p q).\nProof.\nmove=> rp rq k kP; rewrite /rgcdpT /=; do ![rewrite sizeT_qf => // ? _].\ncase: (_ < _); rewrite ?isnull_qf // => -[]; rewrite ?kP // => _;\nby rewrite sizeT_qf => // ? _; rewrite rgcdp_loopT_qf.\nQed.",
    "Lemma rgcdpTsP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p)))) ->\n  forall ps e,\n    qf_eval e (rgcdpTs ps k) =\n    qf_eval e (k (lift (\\big[@rgcdp _/0%:P]_(i <- ps)(eval_poly e i)))).\nProof.\nmove=> Pk ps e; elim: ps k Pk => [|p ps Pps] /= k Pk.\n  by rewrite /= big_nil Pk /= mul0r add0r.\nby rewrite big_cons Pps => *; rewrite !rgcdpTP // !eval_lift -?Pk.\nQed.",
    "Lemma rgcdpTs_qf (ps : seq polyF) :\n   all rpoly ps -> qf_cps rpoly (rgcdpTs ps).\nProof.\nelim: ps => [_|c p ihp /andP[rc rp]] //=; first exact: qf_cps_ret.\nby apply: qf_cps_bind => [|r rr]; [apply: ihp|apply: rgcdpT_qf].\nQed.",
    "Lemma rgdcop_recTP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p))))\n  -> forall p q n e, qf_eval e (rgdcop_recT n p q k)\n    = qf_eval e (k (lift (rgdcop_rec (eval_poly e p) (eval_poly e q) n))).\nProof.\nmove=> Pk p q n e; elim: n => [|n Pn] /= in k Pk p q e *.\n  rewrite isnullP /=.\n  by case: (_ == _); rewrite Pk /= mul0r add0r ?(polyC0, polyC1).\nrewrite /rcoprimep rgcdpTP ?sizeTP ?eval_lift => * /=.\n  case: (_ == _);\n  by do ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\ndo ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\ncase: (_ == _);\nby do ?[rewrite /= ?(=^~Pk, redivpTP, rgcdpTP, sizeTP, Pn, eval_lift) //==> *].\nQed.",
    "Lemma rgdcop_recT_qf (n : nat) (p : polyF) (q : polyF) :\n  rpoly p -> rpoly q -> qf_cps rpoly (rgdcop_recT n p q).\nProof.\nelim: n => [|n ihn] in p q * => k kP rp rq /=.\n  by rewrite isnull_qf => //*; rewrite rq.\nrewrite rgcdpT_qf=> //*; rewrite sizeT_qf=> //*.\ncase: (_ == _); rewrite ?kP ?rq //= redivpT_qf=> //= ? /andP[??].\nby rewrite ihn.\nQed.",
    "Lemma rgdcopTP (k : polyF -> fF) :\n  (forall p e, qf_eval e (k p) = qf_eval e (k (lift (eval_poly e p)))) ->\n  forall p q e, qf_eval e (rgdcopT p q k) =\n                qf_eval e (k (lift (rgdcop (eval_poly e p) (eval_poly e q)))).\nProof. by move=> *; rewrite sizeTP rgdcop_recTP 1?Pk. Qed.",
    "Lemma rgdcopT_qf (p : polyF) (q : polyF) :\n  rpoly p -> rpoly q -> qf_cps rpoly (rgdcopT p q).\nProof.\nby move=> rp rq k kP; rewrite sizeT_qf => //*; rewrite rgdcop_recT_qf.\nQed.",
    "Lemma ex_elim_seqP (ps : seq polyF) (q : polyF) (e : seq F) :\n  let gp := (\\big[@rgcdp _/0%:P]_(p <- ps)(eval_poly e p)) in\n  qf_eval e (ex_elim_seq ps q) = (size (rgdcop (eval_poly e q) gp) != 1).\nProof.\nby do ![rewrite (rgcdpTsP,rgdcopTP,sizeTP,eval_lift) //= | move=> * //=].\nQed.",
    "Lemma ex_elim_seq_qf  (ps : seq polyF) (q : polyF) :\n  all rpoly ps -> rpoly q -> qf (ex_elim_seq ps q).\nProof.\nmove=> rps rq; apply: rgcdpTs_qf=> // g rg; apply: rgdcopT_qf=> // d rd.\nexact : sizeT_qf.\nQed.",
    "Lemma abstrXP  (i : nat) (t : tF) (e : seq F) (x : F) :\n  rterm t -> (eval_poly e (abstrX i t)).[x] = eval (set_nth 0 e i x) t.\nProof.\nelim: t => [n | r | n | t tP s sP | t tP | t tP n | t tP s sP | t tP | t tP n] h.\n- move=> /=; case ni: (_ == _);\n    rewrite //= ?(mul0r,add0r,addr0,polyC1,mul1r,hornerX,hornerC);\n    by rewrite // nth_set_nth /= ni.\n- by rewrite /= mul0r add0r hornerC.\n- by rewrite /= mul0r add0r hornerC.\n- by case/andP: h => *; rewrite /= eval_sumpT hornerD tP ?sP.\n- by rewrite /= eval_opppT hornerN tP.\n- by rewrite /= eval_natmulpT hornerMn tP.\n- by case/andP: h => *; rewrite /= eval_mulpT hornerM tP ?sP.\n- by [].\n- elim: n h => [|n ihn] rt; first by rewrite /= expr0 mul0r add0r hornerC.\n  by rewrite /= eval_mulpT exprSr hornerM ihn // mulrC tP.\nQed.",
    "Lemma rabstrX (i : nat) (t : tF) : rterm t -> rpoly (abstrX i t).\nProof.\nelim: t; do ?[ by move=> * //=; do ?case: (_ == _)].\n- move=> t irt s irs /=; case/andP=> rt rs.\n  by apply: rsumpT; rewrite ?irt ?irs //.\n- by move=> t irt /= rt; rewrite rpoly_map_mul ?irt //.\n- by move=> t irt /= n rt; rewrite rpoly_map_mul ?irt //.\n- move=> t irt s irs /=; case/andP=> rt rs.\n  by apply: rmulpT; rewrite ?irt ?irs //.\n- move=> t irt /= n rt; move: (irt rt) => {}rt; elim: n => [|n ihn] //=.\n  exact: rmulpT.\nQed.",
    "Lemma abstrX_mulM (i : nat) : {morph abstrX i : x y / x * y >-> mulpT x y}%T.\nProof. by []. Qed.",
    "Lemma abstrX1 (i : nat) : abstrX i 1%T = [::1%T].\nProof. done. Qed.",
    "Lemma eval_poly_mulM e : {morph eval_poly e : x y / mulpT x y >-> x * y}.\nProof. by move=> x y; rewrite eval_mulpT. Qed.",
    "Lemma eval_poly1 e : eval_poly e [::1%T] = 1.\nProof. by rewrite /= mul0r add0r. Qed.",
    "Lemma rseq_poly_map (x : nat) (ts : seq tF) :\n  all (@rterm _) ts ->  all rpoly (map (abstrX x) ts).\nProof.\nby elim: ts => //= t ts iht; case/andP=> rt rts; rewrite rabstrX // iht.\nQed.",
    "Lemma ex_elim_qf (x : nat) (pqs : seq tF * seq tF) :\n  GRing.dnf_rterm pqs -> qf (ex_elim x pqs).\nProof.\ncase: pqs => ps qs; case/andP=> /= rps rqs.\napply: ex_elim_seq_qf; first exact: rseq_poly_map.\napply: rabstrX=> /=.\nelim: qs rqs=> [|t ts iht] //=; first by rewrite big_nil.\nby case/andP=> rt rts; rewrite big_cons /= rt /= iht.\nQed.",
    "Lemma holds_conj : forall e i x ps, all (@rterm _) ps ->\n  (GRing.holds (set_nth 0 e i x)\n               (foldr (fun t : tF => GRing.And (t == 0)) GRing.True%T ps)\n  <-> all ((@root _)^~ x) (map (eval_poly e \\o abstrX i) ps)).\nProof.\nmove=> e i x; elim=> [|p ps ihps] //=.\ncase/andP=> rp rps; rewrite rootE abstrXP //.\nconstructor; first by case=> -> hps; rewrite eqxx /=; apply/ihps.\nby case/andP; move/eqP=> -> psr; split=> //; apply/ihps.\nQed.",
    "Lemma holds_conjn (e : seq F) (i : nat) (x : F) (ps : seq tF) :\n  all (@rterm _) ps ->\n  (GRing.holds (set_nth 0 e i x)\n               (foldr (fun t : tF => GRing.And (t != 0)) GRing.True ps) <->\n  all (fun p => ~~root p x) (map (eval_poly e \\o abstrX i) ps)).\nProof.\nelim: ps => [|p ps ihps] //=.\ncase/andP=> rp rps; rewrite rootE abstrXP //.\nconstructor; first by case=> /eqP-> hps /=; apply/ihps.\nby case/andP=> pr psr; split; first apply/eqP=> //; apply/ihps.\nQed.",
    "Lemma holds_ex_elim: GRing.valid_QE_proj ex_elim.\nProof.\nmove=> i [ps qs] /= e; case/andP=> /= rps rqs.\nrewrite ex_elim_seqP big_map.\nhave -> : \\big[@rgcdp _/0%:P]_(j <- ps) eval_poly e (abstrX i j) =\n          \\big[@rgcdp _/0%:P]_(j <- (map (eval_poly e) (map (abstrX i) (ps)))) j.\n  by rewrite !big_map.\nrewrite -!map_comp.\n  have aux I (l : seq I) (P : I -> {poly F}) :\n    \\big[(@gcdp F)/0]_(j <- l) P j %= \\big[(@rgcdp F)/0]_(j <- l) P j.\n    elim: l => [| u l ihl] /=; first by rewrite !big_nil eqpxx.\n    rewrite !big_cons; move: ihl; move/(eqp_gcdr (P u)) => h.\n    by apply: eqp_trans h _; rewrite eqp_sym; apply: eqp_rgcd_gcd.\ncase g0: (\\big[(@rgcdp F)/0%:P]_(j <- map (eval_poly e \\o abstrX i) ps) j == 0).\n  rewrite (eqP g0) rgdcop0.\n  case m0 : (_ == 0)=> //=; rewrite ?(size_poly1,size_poly0) //=.\n    rewrite abstrX_bigmul eval_bigmul -bigmap_id in m0.\n    constructor=> [[x] // []] //.\n    case=> _; move/holds_conjn=> hc; move/hc:rqs.\n    by rewrite -root_bigmul //= (eqP m0) root0.\n  constructor; move/negP:m0; move/negP=>m0.\n  case: (closed_nonrootP F_closed _ m0) => x {m0}.\n  rewrite abstrX_bigmul eval_bigmul -bigmap_id root_bigmul=> m0.\n  exists x; do 2?constructor=> //; last by apply/holds_conjn.\n  apply/holds_conj; rewrite //= -root_biggcd.\n  by rewrite (eqp_root (aux _ _ _ )) (eqP g0) root0.\napply: (iffP (closed_rootP F_closed _)) => -[x Px]; exists x; move: Px => //=.\n  rewrite (eqp_root (@eqp_rgdco_gdco F _ _)) root_gdco ?g0 //.\n  rewrite -(eqp_root (aux _ _ _ )) root_biggcd  abstrX_bigmul eval_bigmul.\n  rewrite -bigmap_id root_bigmul; case/andP=> psr qsr.\n  do 2?constructor; first by apply/holds_conj.\n  by apply/holds_conjn.\nrewrite (eqp_root(@eqp_rgdco_gdco F _ _)) root_gdco?g0// -(eqp_root(aux _ _ _)).\nrewrite root_biggcd abstrX_bigmul eval_bigmul -bigmap_id.\nrewrite root_bigmul=> [[] // [hps hqs]]; apply/andP.\nconstructor; first by apply/holds_conj.\nby apply/holds_conjn.\nQed.",
    "Lemma wf_ex_elim : GRing.wf_QE_proj ex_elim.\nProof. by move=> i bc /= rbc; apply: ex_elim_qf. Qed.",
    "Lemma countable_field_extension (F : countFieldType) (p : {poly F}) :\n    size p > 1 ->\n  {E : countFieldType & {FtoE : {rmorphism F -> E} &\n  {w : E | root (map_poly FtoE p) w\n         & forall u : E, exists q, u = (map_poly FtoE q).[w]}}}.\nProof.\npose fix d i :=\n  if i is i1.+1 then\n    let d1 := oapp (gcdp (d i1)) 0 (unpickle i1) in\n    if size d1 > 1 then d1 else d i1\n  else p.\nmove=> p_gt1; have sz_d i: size (d i) > 1 by elim: i => //= i IHi; case: ifP.\nhave dv_d i j: i <= j -> d j %| d i.\n  move/subnK <-; elim: {j}(j - i)%N => //= j IHj; case: ifP => //=.\n  case: (unpickle _) => /= [q _|]; last by rewrite size_poly0.\n  exact: dvdp_trans (dvdp_gcdl _ _) IHj.\npose I : pred {poly F} := [pred q | d (pickle q).+1 %| q].\nhave I'co q i: q \\notin I -> i > pickle q -> coprimep q (d i).\n  rewrite inE => I'q /dv_d/coprimep_dvdl-> //; apply: contraR I'q.\n  rewrite coprimep_sym /coprimep /= pickleK /= neq_ltn.\n  case: ifP => [_ _| ->]; first exact: dvdp_gcdr.\n  rewrite orbF ltnS leqn0 size_poly_eq0 gcdp_eq0 -size_poly_eq0.\n  by rewrite -leqn0 leqNgt ltnW //.\nhave memI q: reflect (exists i, d i %| q) (q \\in I).\n  apply: (iffP idP) => [|[i dv_di_q]]; first by exists (pickle q).+1.\n  have [le_i_q | /I'co i_co_q] := leqP i (pickle q).\n    rewrite inE /= pickleK /=; case: ifP => _; first exact: dvdp_gcdr.\n    exact: dvdp_trans (dv_d _ _ le_i_q) dv_di_q.\n  apply: contraR i_co_q _.\n  by rewrite /coprimep (eqp_size (dvdp_gcd_idr dv_di_q)) neq_ltn sz_d orbT.\nhave I_ideal : idealr_closed I.\n  split=> [||a q1 q2 Iq1 Iq2]; first exact: dvdp0.\n    by apply/memI=> [[i /idPn[]]]; rewrite dvdp1 neq_ltn sz_d orbT.\n  apply/memI; exists (maxn (pickle q1).+1 (pickle q2).+1); apply: dvdp_add.\n    by apply: dvdp_mull; apply: dvdp_trans Iq1; apply/dv_d/leq_maxl.\n  by apply: dvdp_trans Iq2; apply/dv_d/leq_maxr.\npose IaM := GRing.isAddClosed.Build _ I (idealr_closedB I_ideal).\npose IoM := GRing.isOppClosed.Build _ I (idealr_closedB I_ideal).\npose IpM := isProperIdeal.Build _ I (idealr_closed_nontrivial I_ideal).\npose Iid : idealr _ := HB.pack I IaM IoM IpM.\npose EMixin := GRing.PzRing_hasCommutativeMul.Build _ (@Quotient.mulqC _ Iid).\npose E : comNzRingType := (HB.pack _ EMixin : comPzRingType).\npose PtoE : {rmorphism {poly F} -> E} := \\pi_E%qT.\nhave PtoEd i: PtoE (d i) = 0.\n  by apply/eqP; rewrite piE Quotient.equivE subr0; apply/memI; exists i.\npose Einv (z : E) (q := repr z) (dq := d (pickle q).+1) :=\n  let q_unitP := Bezout_eq1_coprimepP q dq in\n  if q_unitP is ReflectT ex_uv then PtoE (sval (sig_eqW ex_uv)).1 else 0.\nhave Einv0 : Einv 0 = 0.\n  rewrite /Einv; case: Bezout_eq1_coprimepP => // ex_uv.\n  case/negP: (oner_neq0 E); rewrite [X in X == _]piE.\n  rewrite -[_ 1]/(PtoE 1); have [uv <-] := ex_uv.\n  by rewrite rmorphD !rmorphM [X in _ + _ * X]PtoEd /= reprK !mulr0 addr0.\nhave EmulV : forall x, x != 0 -> Einv x * x = 1.\n  rewrite /Einv=> z nz_z; case: Bezout_eq1_coprimepP => [ex_uv |]; last first.\n    move/Bezout_eq1_coprimepP; rewrite I'co //.\n    by rewrite piE -{1}[z]reprK -Quotient.idealrBE subr0 in nz_z.\n  apply/eqP; case: sig_eqW => {ex_uv} [uv uv1]; set i := _.+1 in uv1 *.\n  rewrite piE /= -[z]reprK -(rmorphM PtoE) -Quotient.idealrBE.\n  rewrite -[X in _ - X]uv1 opprD addNKr -mulNr.\n  by apply/memI; exists i; apply: dvdp_mull.\npose EfieldMixin := GRing.ComNzRing_isField.Build _ EmulV Einv0.\npose Efield : fieldType := HB.pack E EfieldMixin.\npose EIsCountable := isCountable.Build E (pcan_pickleK (can_pcan (reprK))).\npose Ecount : countFieldType := HB.pack E Efield EIsCountable.\npose FtoE : {rmorphism _ -> _} := PtoE \\o polyC; pose w : E := PtoE 'X.\nhave defPtoE q: (map_poly FtoE q).[w] = PtoE q.\n  by rewrite (map_poly_comp PtoE polyC) horner_map [_.['X]]comp_polyXr.\nexists Ecount, FtoE, w => [|u].\n  by rewrite /root defPtoE (PtoEd 0).\nby exists (repr u); rewrite defPtoE /= reprK.\nQed.",
    "Lemma countable_algebraic_closure (F : countFieldType) :\n  {K : countClosedFieldType & {FtoK : {rmorphism F -> K} | integralRange FtoK}}.\nProof.\npose minXp (R : nzRingType) (p : {poly R}) := if size p > 1 then p else 'X.\nhave minXp_gt1 R p: size (minXp R p) > 1.\n  by rewrite /minXp; case: ifP => // _; rewrite size_polyX.\nhave minXpE (R : nzRingType) (p : {poly R}) : size p > 1 -> minXp R p = p.\n  by rewrite /minXp => ->.\nhave ext1 p := countable_field_extension (minXp_gt1 _ p).\npose ext1fT E p := tag (ext1 E p).\npose ext1to E p : {rmorphism _ -> ext1fT E p} := tag (tagged (ext1 E p)).\npose ext1w E p : ext1fT E p := s2val (tagged (tagged (ext1 E p))).\nhave ext1root E p: root (map_poly (ext1to E p) (minXp E p)) (ext1w E p).\n  by rewrite /ext1w; case: (tagged (tagged (ext1 E p))).\nhave ext1gen E p u: {q | u = (map_poly (ext1to E p) q).[ext1w E p]}.\n  by apply: sig_eqW; rewrite /ext1w; case: (tagged (tagged (ext1 E p))) u.\npose pExtEnum (E : countFieldType) := nat -> {poly E}.\npose Ext := {E : countFieldType & pExtEnum E}; pose MkExt : Ext := Tagged _ _.\npose EtoInc (E : Ext) i := ext1to (tag E) (tagged E i).\npose incEp E i j :=\n  let v := map_poly (EtoInc E i) (tagged E j) in\n  if decode j is [:: i1; k] then\n    if i1 == i then odflt v (unpickle k) else v\n  else v.\npose fix E_ i := if i is i1.+1 then MkExt _ (incEp (E_ i1) i1) else MkExt F \\0.\npose E i := tag (E_ i); pose Krep := {i : nat & E i}.\npose fix toEadd i k : {rmorphism E i -> E (k + i)%N} :=\n  if k isn't k1.+1 then idfun else EtoInc _ (k1 + i)%N \\o toEadd _ _.\npose toE i j (le_ij : i <= j) :=\n  ecast j {rmorphism E i -> E j} (subnK le_ij) (toEadd i (j - i)%N).\nhave toEeq i le_ii: toE i i le_ii =1 id.\n  by rewrite /toE; move: (subnK _); rewrite subnn => ?; rewrite eq_axiomK.\nhave toEleS i j leij leiSj z: toE i j.+1 leiSj z = EtoInc _ _ (toE i j leij z).\n  rewrite /toE; move: (j - i)%N {leij leiSj}(subnK _) (subnK _) => k.\n  by case: j /; rewrite (addnK i k.+1) => eq_kk; rewrite [eq_kk]eq_axiomK.\nhave toEirr := congr1 ((toE _ _)^~ _) (bool_irrelevance _ _).\nhave toEtrans j i k leij lejk leik z:\n  toE i k leik z = toE j k lejk (toE i j leij z).\n- elim: k leik lejk => [|k IHk] leiSk lejSk.\n    by case: j => // in leij lejSk *; rewrite toEeq.\n  have:= lejSk; rewrite {1}leq_eqVlt ltnS => /predU1P[Dk | lejk].\n    by rewrite -Dk in leiSk lejSk *; rewrite toEeq.\n  by have leik := leq_trans leij lejk; rewrite !toEleS -IHk.\nhave [leMl leMr] := (leq_maxl, leq_maxr); pose le_max := (leq_max, leqnn, orbT).\npose pairK (x y : Krep) (m := maxn _ _) :=\n  (toE _ m (leMl _ _) (tagged x), toE _ m (leMr _ _) (tagged y)).\npose eqKrep x y := uncurry (@eq_op _) (pairK x y).\nhave eqKrefl : reflexive eqKrep by move=> z; apply/eqP; apply: toEirr.\nhave eqKsym : symmetric eqKrep.\n  move=> z1 z2; rewrite {1}/eqKrep /= eq_sym; move: (leMl _ _) (leMr _ _).\n  by rewrite maxnC => lez1m lez2m; congr (_ == _); apply: toEirr.\nhave eqKtrans : transitive eqKrep.\n  rewrite /eqKrep /= => z2 z1 z3 /eqP eq_z12 /eqP eq_z23.\n  rewrite -(inj_eq (fmorph_inj (toE _ _ (leMr (tag z2) _)))).\n  rewrite -!toEtrans ?le_max // maxnCA maxnA => lez3m lez1m.\n  rewrite {lez1m}(toEtrans (maxn (tag z1) (tag z2))) // {}eq_z12.\n  do [rewrite -toEtrans ?le_max // -maxnA => lez2m] in lez3m *.\n  by rewrite (toEtrans (maxn (tag z2) (tag z3))) // eq_z23 -toEtrans.\npose K := {eq_quot EquivRel _ eqKrefl eqKsym eqKtrans}%qT.\npose cntK := isCountable.Build K (pcan_pickleK (can_pcan (reprK))).\npose EtoKrep i (x : E i) : K := \\pi%qT (Tagged E x).\nhave [EtoK piEtoK]: {EtoK | forall i, EtoKrep i =1 EtoK i} by exists EtoKrep.\npose FtoK := EtoK 0; rewrite {}/EtoKrep in piEtoK.\nhave eqEtoK i j x y:\n  toE i _ (leMl i j) x = toE j _ (leMr i j) y -> EtoK i x = EtoK j y.\n- by move/eqP=> eq_xy; rewrite -!piEtoK; apply/eqmodP.\nhave toEtoK j i leij x : EtoK j (toE i j leij x) = EtoK i x.\n  by apply: eqEtoK; rewrite -toEtrans.\nhave EtoK_0 i: EtoK i 0 = FtoK 0 by apply: eqEtoK; rewrite !rmorph0.\nhave EtoK_1 i: EtoK i 1 = FtoK 1 by apply: eqEtoK; rewrite !rmorph1.\nhave EtoKeq0 i x: (EtoK i x == FtoK 0) = (x == 0).\n  by rewrite /FtoK -!piEtoK eqmodE /= /eqKrep /= rmorph0 fmorph_eq0.\nhave toErepr m i leim x lerm:\n  toE _ m lerm (tagged (repr (EtoK i x))) = toE i m leim x.\n- have: (Tagged E x == repr (EtoK i x) %[mod K])%qT by rewrite reprK piEtoK.\n  rewrite eqmodE /= /eqKrep; case: (repr _) => j y /= in lerm * => /eqP /=.\n  have leijm: maxn i j <= m by rewrite geq_max leim.\n  by move/(congr1 (toE _ _ leijm)); rewrite -!toEtrans.\npose Kadd (x y : K) := EtoK _ (uncurry +%R (pairK (repr x) (repr y))).\npose Kopp (x : K) := EtoK _ (- tagged (repr x)).\npose Kmul (x y : K) := EtoK _ (uncurry *%R (pairK (repr x) (repr y))).\npose Kinv (x : K) := EtoK _ (tagged (repr x))^-1.\nhave EtoK_D i: {morph EtoK i : x y / x + y >-> Kadd x y}.\n  move=> x y; apply: eqEtoK; set j := maxn (tag _) _; rewrite !rmorphD.\n  rewrite -![X in _ = X + _]toEtrans ?le_max// => lexm.\n  rewrite -![X in _ = _ + X]toEtrans ?le_max// => leym.\n  by rewrite !toErepr.\nhave EtoK_N i: {morph EtoK i : x / - x >-> Kopp x}.\n  by move=> x; apply: eqEtoK; set j := tag _; rewrite !rmorphN toErepr.\nhave EtoK_M i: {morph EtoK i : x y / x * y >-> Kmul x y}.\n  move=> x y; apply: eqEtoK; set j := maxn (tag _) _; rewrite !rmorphM.\n  rewrite -![X in _ = X * _]toEtrans ?le_max// => lexm.\n  rewrite -![X in _ = _ * X]toEtrans ?le_max// => leym.\n  by rewrite !toErepr.\nhave EtoK_V i: {morph EtoK i : x / x^-1 >-> Kinv x}.\n  by move=> x; apply: eqEtoK; set j := tag _; rewrite !fmorphV toErepr.\ncase: {toErepr}I in (Kadd) (Kopp) (Kmul) (Kinv) EtoK_D EtoK_N EtoK_M EtoK_V.\npose inEi i z := {x : E i | z = EtoK i x}; have KtoE z: {i : nat & inEi i z}.\n  by elim/quotW: z => [[i x] /=]; exists i, x; rewrite piEtoK.\nhave inEle i j z: i <= j -> inEi i z -> inEi j z.\n  by move=> leij [x ->]; exists (toE i j leij x); rewrite toEtoK.\nhave KtoE2 z1 z2: {i : nat & inEi i z1 & inEi i z2}.\n  have [[i1 Ez1] [i2 Ez2]] := (KtoE z1, KtoE z2).\n  by exists (maxn i1 i2); [apply: inEle Ez1 | apply: inEle Ez2].\nhave KtoE3 z1 z2 z3: {i : nat & inEi i z1 & inEi i z2 * inEi i z3}%type.\n  have [[i1 Ez1] [i2 Ez2 Ez3]] := (KtoE z1, KtoE2 z2 z3).\n  by exists (maxn i1 i2); [apply: inEle Ez1 | split; apply: inEle (leMr _ _) _].\nhave KaddC: commutative Kadd.\n  by move=> u v; have [i [x ->] [y ->]] := KtoE2 u v; rewrite -!EtoK_D addrC.\nhave KaddA: associative Kadd.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!EtoK_D addrA.\nhave Kadd0: left_id (FtoK 0) Kadd.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -(EtoK_0 i) -EtoK_D add0r.\nhave KaddN: left_inverse (FtoK 0) Kopp Kadd.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -EtoK_N -EtoK_D addNr EtoK_0.\npose KzmodMixin := GRing.isZmodule.Build K KaddA KaddC Kadd0 KaddN.\npose Kzmod : countZmodType := HB.pack K KzmodMixin.\nhave KmulC: commutative Kmul.\n  by move=> u v; have [i [x ->] [y ->]] := KtoE2 u v; rewrite -!EtoK_M mulrC.\nhave KmulA: @associative Kzmod Kmul.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!EtoK_M mulrA.\nhave Kmul1: left_id (FtoK 1) Kmul.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -(EtoK_1 i) -EtoK_M mul1r.\nhave KmulD: left_distributive Kmul Kadd.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!(EtoK_M, EtoK_D) mulrDl.\nhave Kone_nz: FtoK 1 != FtoK 0 by rewrite EtoKeq0 oner_neq0.\npose KringMixin := GRing.Zmodule_isComNzRing.Build _\n  KmulA KmulC Kmul1 KmulD Kone_nz.\npose Kring : comNzRingType := HB.pack K Kzmod KringMixin cntK.\nhave KmulV: forall x : Kring, x != 0 -> (Kinv x : Kring) * x = 1.\n  move=> u; have [i [x ->]] := KtoE u; rewrite EtoKeq0 => nz_x.\n  by rewrite -EtoK_V -[_ * _]EtoK_M mulVf ?EtoK_1.\nhave Kinv0: Kinv (FtoK 0) = FtoK 0 by rewrite -EtoK_V invr0.\npose KfieldMixin := GRing.ComNzRing_isField.Build _ KmulV Kinv0.\npose Kfield : fieldType := HB.pack K Kring KfieldMixin.\nhave EtoKAdd i : additive (EtoK i : E i -> Kfield).\n  by move=> x y; rewrite EtoK_D EtoK_N.\nhave EtoKMul i : multiplicative (EtoK i : E i -> Kfield).\n  by split=> [x y|]; rewrite ?EtoK_M ?EtoK_1.\npose EtoKMa i := GRing.isAdditive.Build _ _ _ (EtoKAdd i).\npose EtoKMm i := GRing.isMultiplicative.Build _ _ _ (EtoKMul i).\npose EtoKM i : {rmorphism _ -> _} :=\n  HB.pack (EtoK i : E i -> Kfield) (EtoKMa i) (EtoKMm i).\nhave EtoK_E: EtoK _ = EtoKM _ by [].\nhave toEtoKp := @eq_map_poly _ Kring _ _(toEtoK _ _ _).\nhave Kclosed: GRing.closed_field_axiom Kfield.\n  move=> n pK n_gt0; pose m0 := \\max_(i < n) tag (KtoE (pK i)); pose m := m0.+1.\n  have /fin_all_exists[pE DpE] (i : 'I_n): exists y, EtoK m y = pK i.\n    pose u := KtoE (pK i); have leum0: tag u <= m0 by rewrite (bigmax_sup i).\n    by have [y ->] := tagged u; exists (toE _ _ (leqW leum0) y); rewrite toEtoK.\n  pose p := 'X^n - rVpoly (\\row_i pE i); pose j := code [:: m0; pickle p].\n  pose pj := tagged (E_ j) j; pose w : E j.+1 := ext1w (E j) pj.\n  have lemj: m <= j by rewrite (allP (ltn_code _)) ?mem_head.\n  exists (EtoKM j.+1 w); apply/eqP; rewrite -subr_eq0; apply/eqP.\n  transitivity (EtoKM j.+1 (map_poly (toE m j.+1 (leqW lemj)) p).[w]).\n    rewrite -horner_map -map_poly_comp toEtoKp EtoK_E.\n    move: (EtoKM j.+1 w) => {}w.\n    rewrite rmorphB [_ 'X^n]map_polyXn !hornerE; congr (_ - _ : Kring).\n    rewrite (@horner_coef_wide _ n) ?size_map_poly ?size_poly //.\n    by apply: eq_bigr => i _; rewrite coef_map coef_rVpoly valK mxE /= DpE.\n  suffices Dpj: map_poly (toE m j lemj) p = pj.\n    apply/eqP; rewrite EtoKeq0 (eq_map_poly (toEleS _ _ _ _)) map_poly_comp Dpj.\n    rewrite -rootE -[pj]minXpE ?ext1root // -Dpj size_map_poly.\n    by rewrite size_polyDl ?size_polyXn ltnS ?size_polyN ?size_poly.\n  rewrite {w}/pj; set j0 := (j in tagged (E_ _) j).\n  elim: {+}j lemj => // k IHk lemSk; rewrite {}/j0 in IHk *.\n  have:= lemSk; rewrite leq_eqVlt ltnS => /predU1P[Dm | lemk].\n    rewrite -{}Dm in lemSk *; rewrite {k IHk lemSk}(eq_map_poly (toEeq m _)).\n    by rewrite map_poly_id //= /incEp codeK eqxx pickleK.\n  rewrite (eq_map_poly (toEleS _ _ _ _)) map_poly_comp {}IHk //= /incEp codeK.\n  by rewrite -if_neg neq_ltn lemk.\nsuffices{Kclosed} algF_K: {FtoK : {rmorphism F -> Kfield} | integralRange FtoK}.\n  pose Kcc := Field_isAlgClosed.Build Kfield Kclosed.\n  by exists (HB.pack_for countClosedFieldType K Kfield Kcc).\nexists (EtoKM 0) => /= z; have [i [{}z ->]] := KtoE z.\nsuffices{z} /(_ z)[p mon_p]: integralRange (toE 0 i isT).\n  by rewrite -(fmorph_root (EtoKM i)) -map_poly_comp toEtoKp; exists p.\nrewrite /toE /E; clear - minXp_gt1 ext1root ext1gen.\nmove: (i - 0)%N (subnK _) => n; case: i /.\nelim: n => [|n IHn] /= z; first exact: integral_id.\nhave{z} [q ->] := ext1gen _ _ z; set pn := tagged (E_ _) _.\napply: integral_horner.\n  by apply/integral_poly=> i; rewrite coef_map; apply: integral_rmorph.\napply: integral_root (ext1root _ _) _.\n  by rewrite map_poly_eq0 -size_poly_gt0 ltnW.\nby apply/integral_poly=> i; rewrite coef_map; apply: integral_rmorph.\nQed.",
    "Lemma rat_algebraic_archimedean (C : numFieldType) (QtoC : Qmorphism C) :\n  integralRange QtoC -> Num.archimedean_axiom C.\nProof.\nmove=> algC x.\nwithout loss x_ge0: x / 0 <= x by rewrite -normr_id; apply.\nhave [-> | nz_x] := eqVneq x 0; first by exists 1; rewrite normr0.\nhave [p mon_p px0] := algC x; exists (\\sum_(j < size p) `|numq p`_j|)%N.\nrewrite ger0_norm // real_ltNge ?rpred_nat ?ger0_real //.\napply: contraL px0 => lb_x; rewrite rootE gt_eqF // horner_coef size_map_poly.\nhave x_gt0 k: 0 < x ^+ k by rewrite exprn_gt0 // lt_def nz_x.\nmove: lb_x; rewrite polySpred ?monic_neq0 // !big_ord_recr coef_map /=.\nrewrite -lead_coefE (monicP mon_p) natrD [QtoC _]rmorph1 mul1r => lb_x.\ncase: _.-1 (lb_x) => [|n]; first by rewrite !big_ord0 !add0r ltr01.\nrewrite -ltrBlDl add0r -(ler_pM2r (x_gt0 n)) -exprS.\napply: lt_le_trans; rewrite mulrDl mul1r ltr_pwDr // -sumrN.\nrewrite natr_sum mulr_suml ler_sum // => j _.\nrewrite coef_map /= fmorph_eq_rat (le_trans (real_ler_norm _)) //.\n  by rewrite rpredN rpredM ?rpred_rat ?rpredX // ger0_real.\nrewrite normrN normrM ler_pM //.\n  rewrite normf_div -!intr_norm -!abszE ler_piMr ?ler0n //.\n  by rewrite invf_le1 ?ler1n ?ltr0n absz_gt0.\nrewrite normrX ger0_norm ?(ltrW x_gt0) // ler_weXn2l ?leq_ord //.\nby rewrite (le_trans _ lb_x) // natr1 ler1n.\nQed.",
    "Lemma rat_algebraic_decidable (C : fieldType) (QtoC : Qmorphism C) :\n  integralRange QtoC -> decidable_embedding QtoC.\nProof.\nhave QtoCinj: injective QtoC by apply: fmorph_inj.\npose ZtoQ : int -> rat := intr; pose ZtoC : int -> C := intr.\nhave ZtoQinj: injective ZtoQ by apply: intr_inj.\nhave defZtoC: ZtoC =1 QtoC \\o ZtoQ by move=> m; rewrite /= rmorph_int.\nmove=> algC x; have /sig2_eqW[q mon_q qx0] := algC x; pose d := (size q).-1.\nhave [n ub_n]: {n | forall y, root q y -> `|y| < n}.\n  have [n1 ub_n1] := monic_Cauchy_bound mon_q.\n  have /monic_Cauchy_bound[n2 ub_n2]: (-1) ^+ d *: (q \\Po - 'X) \\is monic.\n    rewrite monicE lead_coefZ lead_coef_comp ?size_polyN ?size_polyX // -/d.\n    by rewrite lead_coefN lead_coefX (monicP mon_q) (mulrC 1) signrMK.\n  exists (Num.max n1 n2) => y; rewrite ltNge ler_normr !leUx rootE.\n  apply: contraL => /orP[]/andP[] => [/ub_n1/gt_eqF->// | _ /ub_n2/gt_eqF].\n  by rewrite hornerZ horner_comp !hornerE opprK mulf_eq0 signr_eq0 => /= ->.\nhave [p [a nz_a Dq]] := rat_poly_scale q; pose N := Num.bound `|n * a%:~R|.\npose xa : seq rat := [seq (m%:R - N%:R) / a%:~R | m <- iota 0 N.*2].\nhave [/sig2_eqW[y _ ->] | xa'x] := @mapP _ _ QtoC xa x; first by left; exists y.\nright=> [[y Dx]]; case: xa'x; exists y => //.\nhave{x Dx qx0} qy0: root q y by rewrite Dx fmorph_root in qx0.\nhave /dvdzP[b Da]: (denq y %| a)%Z.\n  have /Gauss_dvdzl <-: coprimez (denq y) (numq y ^+ d).\n    by rewrite coprimez_sym coprimezXl //; apply: coprime_num_den.\n  pose p1 : {poly int} := a *: 'X^d - p.\n  have Dp1: p1 ^ intr = a%:~R *: ('X^d - q).\n    by rewrite rmorphB /= linearZ /= map_polyXn scalerBr Dq scalerKV ?intr_eq0.\n  apply/dvdzP; exists (\\sum_(i < d) p1`_i * numq y ^+ i * denq y ^+ (d - i.+1)).\n  apply: ZtoQinj; rewrite /ZtoQ rmorphM mulr_suml rmorph_sum /=.\n  transitivity ((p1 ^ intr).[y] * (denq y ^+ d)%:~R).\n    rewrite Dp1 !hornerE (rootP qy0) subr0.\n    by rewrite !rmorphXn /= numqE exprMn mulrA.\n  have sz_p1: (size (p1 ^ ZtoQ)%R <= d)%N.\n    rewrite Dp1 size_scale ?intr_eq0 //; apply/leq_sizeP=> i.\n    rewrite leq_eqVlt eq_sym -polySpred ?monic_neq0 // coefB coefXn.\n    case: eqP => [-> _ | _ /(nth_default 0)->//].\n    by rewrite -lead_coefE (monicP mon_q).\n  rewrite (horner_coef_wide _ sz_p1) mulr_suml; apply: eq_bigr => i _.\n  rewrite -!mulrA -exprSr coef_map !rmorphM !rmorphXn /= numqE exprMn -mulrA.\n  by rewrite -exprD -addSnnS subnKC.\npose m := `|(numq y * b + N)%R|%N.\nhave Dm: m%:R = `|y * a%:~R + N%:R|.\n  by rewrite pmulrn abszE intr_norm Da rmorphD !rmorphM /= numqE mulrAC mulrA.\nhave ltr_Qnat n1 n2 : (n1%:R < n2%:R :> rat = _) := ltr_nat _ n1 n2.\nhave ub_y: `|y * a%:~R| < N%:R.\n  apply: le_lt_trans (archi_boundP (normr_ge0 _)); rewrite !normrM.\n  by rewrite ler_pM // (le_trans _ (ler_norm n)) ?ltW ?ub_n.\napply/mapP; exists m.\n  rewrite mem_iota /= add0n -addnn -ltr_Qnat Dm natrD.\n  by rewrite (le_lt_trans (ler_normD _ _)) // normr_nat ltrD2.\nrewrite Dm ger0_norm ?addrK ?mulfK ?intr_eq0 // -lerBlDl sub0r.\nby rewrite (le_trans (ler_norm _)) ?normrN ?ltW.\nQed.",
    "Lemma minPoly_decidable_closure\n  (F : fieldType) (L : closedFieldType) (FtoL : {rmorphism F -> L}) x :\n    decidable_embedding FtoL -> integralOver FtoL x ->\n  {p | [/\\ p \\is monic, root (p ^ FtoL) x & irreducible_poly p]}.\nProof.\nmove=> isF /sig2W[p /monicP mon_p px0].\nhave [r Dp] := closed_field_poly_normal (p ^ FtoL); pose n := size r.\nrewrite lead_coef_map {}mon_p rmorph1 scale1r in Dp.\npose Fpx q := (q \\is a polyOver isF) && root q x.\nhave FpxF q: Fpx (q ^ FtoL) = root (q ^ FtoL) x.\n  by rewrite /Fpx polyOver_poly // => j _; apply/sumboolP; exists q`_j.\npose p_ (I : {set 'I_n}) := \\prod_(i <- enum I) ('X - (r`_i)%:P).\nhave{px0 Dp} /ex_minset[I /minsetP[/andP[FpI pIx0] minI]]: exists I, Fpx (p_ I).\n  exists setT; suffices ->: p_ setT = p ^ FtoL by rewrite FpxF.\n  by rewrite Dp (big_nth 0) big_mkord /p_ big_enum; apply/eq_bigl => i /[1!inE].\nhave{p} [p DpI]: {p | p_ I = p ^ FtoL}.\n  exists (p_ I ^ (fun y => if isF y is left Fy then sval (sig_eqW Fy) else 0)).\n  rewrite -map_poly_comp map_poly_id // => y /(allP FpI) /=.\n  by rewrite unfold_in; case: (isF y) => // Fy _; case: (sig_eqW _).\nhave mon_pI: p_ I \\is monic by apply: monic_prod_XsubC.\nhave mon_p: p \\is monic by rewrite -(map_monic FtoL) -DpI.\nexists p; rewrite -DpI; split=> //; split=> [|q nCq q_dv_p].\n  by rewrite -(size_map_poly FtoL) -DpI (root_size_gt1 _ pIx0) ?monic_neq0.\nrewrite -dvdp_size_eqp //; apply/eqP.\nwithout loss mon_q: q nCq q_dv_p / q \\is monic.\n  move=> IHq; pose a := lead_coef q; pose q1 := a^-1 *: q.\n  have nz_a: a != 0 by rewrite lead_coef_eq0 (dvdpN0 q_dv_p) ?monic_neq0.\n  have /IHq IHq1: q1 \\is monic by rewrite monicE lead_coefZ mulVf.\n  by rewrite -IHq1 ?size_scale ?dvdpZl ?invr_eq0.\nwithout loss{nCq} qx0: q mon_q q_dv_p / root (q ^ FtoL) x.\n  have /dvdpP[q1 Dp] := q_dv_p; rewrite DpI Dp rmorphM rootM -implyNb in pIx0.\n  have mon_q1: q1 \\is monic by rewrite Dp monicMr in mon_p.\n  move=> IH; apply: (IH) (implyP pIx0 _) => //; apply: contra nCq => /IH IHq1.\n  rewrite natr1E -(subnn (size q1)) {1}IHq1 ?Dp ?dvdp_mulr //.\n  rewrite polySpred ?monic_neq0 //.\n  by rewrite eqSS size_monicM ?monic_neq0 // -!subn1 subnAC addKn.\nhave /dvdp_prod_XsubC[m Dq]: q ^ FtoL %| p_ I by rewrite DpI dvdp_map.\npose B := [set j in mask m (enum I)]; have{} Dq: q ^ FtoL = p_ B.\n  apply/eqP; rewrite -eqp_monic ?monic_map ?monic_prod_XsubC //.\n  congr (_ %= _): Dq; apply: perm_big => //.\n  by rewrite uniq_perm ?mask_uniq ?enum_uniq // => j; rewrite mem_enum inE.\nrewrite -!(size_map_poly FtoL) Dq -DpI (minI B) // -?Dq ?FpxF //.\nby apply/subsetP=> j /[1!inE] /mem_mask; rewrite mem_enum.\nQed.",
    "Lemma alg_integral (F : fieldType) (L : fieldExtType F) :\n  integralRange (in_alg L).\nProof.\nmove=> x; have [/polyOver1P[p Dp]] := (minPolyOver 1 x, monic_minPoly 1 x).\nby rewrite Dp map_monic; exists p; rewrite // -Dp root_minPoly.\nQed.",
    "Lemma alg_num_field (Qz : fieldExtType rat) a : a%:A = ratr a :> Qz.\nProof. by rewrite -in_algE fmorph_eq_rat. Qed.",
    "Lemma rmorphZ_num (Qz : fieldExtType rat) rR (f : {rmorphism Qz -> rR}) a x :\n  f (a *: x) = ratr a * f x.\nProof. by rewrite -mulr_algl rmorphM alg_num_field fmorph_rat. Qed.",
    "Lemma fmorph_numZ (Qz1 Qz2 : fieldExtType rat) (f : {rmorphism Qz1 -> Qz2}) :\n  scalable f.\nProof. by move=> a x; rewrite rmorphZ_num -alg_num_field mulr_algl. Qed.",
    "Lemma algC_PET (s : seq algC) :\n  {z | exists a : nat ^ size s, z = \\sum_(i < size s) s`_i *+ a i\n     & exists ps, s = [seq (pQtoC p).[z] | p <- ps]}.\nProof.\nelim: s => [|x s [z /sig_eqW[a Dz] /sig_eqW[ps Ds]]].\n  by exists 0; [exists [ffun _ => 2%N]; rewrite big_ord0 | exists nil].\nhave r_exists (y : algC): {r | r != 0 & root (pQtoC r) y}.\n  have [r [_ mon_r] dv_r] := minCpolyP y.\n  by exists r; rewrite ?monic_neq0 ?dv_r.\nsuffices /sig_eqW[[n [|px [|pz []]]]// [Dpx Dpz]]:\n  exists np, let zn := x *+ np.1 + z in\n    [:: x; z] = [seq (pQtoC p).[zn] | p <- np.2].\n- exists (x *+ n + z).\n    exists [ffun i => oapp a n (unlift ord0 i)].\n    rewrite /= big_ord_recl ffunE unlift_none Dz; congr (_ + _).\n    by apply: eq_bigr => i _; rewrite ffunE liftK.\n  exists (px :: [seq p \\Po pz | p <- ps]); rewrite /= -Dpx; congr (_ :: _).\n  rewrite -map_comp Ds; apply: eq_map => p /=.\n  by rewrite map_comp_poly horner_comp -Dpz.\nhave [rx nz_rx rx0] := r_exists x.\nhave [rz nz_rz rz0] := r_exists (- z).\nhave pchar0_Q: [pchar rat] =i pred0 by apply: pchar_num.\nhave [n [[pz Dpz] [px Dpx]]] := pchar0_PET nz_rz rz0 nz_rx rx0 pchar0_Q.\nby exists (n, [:: px; - pz]); rewrite /= !raddfN hornerN -[z]opprK Dpz Dpx.\nQed.",
    "Lemma num_field_exists (s : seq algC) :\n  {Qs : fieldExtType rat & {QsC : {rmorphism Qs -> algC}\n   & {s1 : seq Qs | map QsC s1 = s & <<1 & s1>>%VS = fullv}}}.\nProof.\nhave [z /sig_eqW[a Dz] /sig_eqW[ps Ds]] := algC_PET s.\nsuffices [Qs [QsC [z1 z1C z1gen]]]:\n  {Qs : fieldExtType rat & {QsC : {rmorphism Qs -> algC} &\n     {z1 : Qs | QsC z1 = z & forall xx, exists p, fieldExt_horner z1 p = xx}}}.\n- set inQs := fieldExt_horner z1 in z1gen *; pose s1 := map inQs ps.\n  have inQsK p: QsC (inQs p) = (pQtoC p).[z].\n    rewrite /= -horner_map z1C -map_poly_comp; congr _.[z].\n    by apply: eq_map_poly => b /=; rewrite alg_num_field fmorph_rat.\n  exists Qs, QsC, s1; first by rewrite -map_comp Ds (eq_map inQsK).\n  have sz_ps: size ps = size s by rewrite Ds size_map.\n  apply/vspaceP=> x; rewrite memvf; have [p {x}<-] := z1gen x.\n  elim/poly_ind: p => [|p b ApQs]; first by rewrite /inQs rmorph0 mem0v.\n  rewrite /inQs rmorphD rmorphM /= fieldExt_hornerX fieldExt_hornerC -/inQs /=.\n  suffices ->: z1 = \\sum_(i < size s) s1`_i *+ a i.\n    rewrite memvD ?memvZ ?mem1v ?memvM ?memv_suml // => i _.\n    by rewrite rpredMn ?seqv_sub_adjoin ?mem_nth // size_map sz_ps.\n  apply: (fmorph_inj QsC); rewrite z1C Dz rmorph_sum; apply: eq_bigr => i _.\n  by rewrite rmorphMn {1}Ds !(nth_map 0) ?sz_ps //= inQsK.\nhave [r [Dr /monic_neq0 nz_r] dv_r] := minCpolyP z.\nhave rz0: root (pQtoC r) z by rewrite dv_r.\nhave irr_r: irreducible_poly r.\n  by apply/(subfx_irreducibleP rz0 nz_r)=> q qz0 nzq; rewrite dvdp_leq // -dv_r.\nexists (SubFieldExtType rz0 irr_r), (@subfx_inj _ _ QtoC z r).\nexists (subfx_root _ z r) => [|x]; first exact: subfx_inj_root.\nby have{x} [p ->] := subfxEroot rz0 nz_r x; exists p.\nQed.",
    "Lemma Crat_spanP s x : reflect (in_Crat_span s x) (x \\in Crat_span s).\nProof. exact: sumboolP. Qed.",
    "Lemma mem_Crat_span s : {subset s <= Crat_span s}.\nProof.\nmove=> _ /(nthP 0)[ix ltxs <-]; pose i0 := Ordinal ltxs.\napply/Crat_spanP; exists [ffun i => (i == i0)%:R].\nrewrite (bigD1_ord i0) //= ffunE eqxx // rmorph1 mul1r.\nby rewrite big1 ?addr0 // => i; rewrite ffunE rmorph_nat mulr_natl lift_eqF.\nQed.",
    "Lemma Crat_spanZ b a : {in Crat_span b, forall x, ratr a * x \\in Crat_span b}.\nProof.\nmove=> _ /Crat_spanP[a1 ->]; apply/Crat_spanP; exists [ffun i => a * a1 i].\nby rewrite mulr_sumr; apply: eq_bigr => i _; rewrite ffunE mulrA -rmorphM.\nQed.",
    "Lemma Crat_spanM b : {in Crat & Crat_span b, forall a x, a * x \\in Crat_span b}.\nProof. by move=> _ x /CratP[a ->]; apply: Crat_spanZ. Qed.",
    "Lemma num_field_proj : {CtoQn | CtoQn 0 = 0 & cancel QnC CtoQn}.\nProof.\npose b := vbasis {:Qn}.\nhave Qn_bC (u : {x | x \\in Crat_span (map QnC b)}): {y | QnC y = sval u}.\n  case: u => _ /= /Crat_spanP/sig_eqW[a ->].\n  exists (\\sum_i a i *: b`_i); rewrite rmorph_sum /=; apply: eq_bigr => i _.\n  by rewrite rmorphZ_num (nth_map 0) // -(size_map QnC).\npose CtoQn x := oapp (fun u => sval (Qn_bC u)) 0 (insub x).\nsuffices QnCK: cancel QnC CtoQn by exists CtoQn; rewrite // -(rmorph0 QnC) /=.\nmove=> x; rewrite /CtoQn insubT => /= [|Qn_x]; last first.\n  by case: (Qn_bC _) => x1 /= /fmorph_inj.\nrewrite (coord_vbasis (memvf x)) rmorph_sum rpred_sum //= => i _.\nrewrite rmorphZ_num Crat_spanZ ?mem_Crat_span // -/b.\nby rewrite -tnth_nth -tnth_map mem_tnth.\nQed.",
    "Lemma restrict_aut_to_num_field (nu : {rmorphism algC -> algC}) :\n    (forall x, exists y, nu (QnC x) = QnC y) ->\n  {nu0 : {lrmorphism Qn -> Qn} | {morph QnC : x / nu0 x >-> nu x}}.\nProof.\nmove=> Qn_nu; pose nu0 x := sval (sig_eqW (Qn_nu x)).\nhave QnC_nu0: {morph QnC : x / nu0 x >-> nu x}.\n  by rewrite /nu0 => x; case: (sig_eqW _).\nhave nu0a : additive nu0.\n  by move=> x y; apply: (fmorph_inj QnC); rewrite !(QnC_nu0, rmorphB).\nhave nu0m : multiplicative nu0.\n  split=> [x y|]; apply: (fmorph_inj QnC); rewrite ?QnC_nu0 ?rmorph1 //.\n  by rewrite !rmorphM /= !QnC_nu0.\npose nu0aM := GRing.isAdditive.Build Qn Qn nu0 nu0a.\npose nu0mM := GRing.isMultiplicative.Build Qn Qn nu0 nu0m.\npose nu0RM : {rmorphism _ -> _} := HB.pack nu0 nu0aM nu0mM.\npose nu0lM := GRing.isScalable.Build rat Qn Qn *:%R nu0 (fmorph_numZ nu0RM).\npose nu0LRM : {lrmorphism _ -> _} := HB.pack nu0 nu0aM nu0mM nu0lM.\nby exists nu0LRM.\nQed.",
    "Lemma map_Qnum_poly (nu : {rmorphism algC -> algC}) p :\n  p \\in polyOver 1%VS -> map_poly (nu \\o QnC) p = (map_poly QnC p).\nProof.\nmove=> Qp; apply/polyP=> i; rewrite /= !coef_map /=.\nhave /vlineP[a ->]: p`_i \\in 1%VS by apply: polyOverP.\nby rewrite alg_num_field !fmorph_rat.\nQed.",
    "Lemma restrict_aut_to_normal_num_field (Qn : splittingFieldType rat)\n  (QnC : {rmorphism Qn -> algC})(nu : {rmorphism algC -> algC}) :\n    {nu0 : {lrmorphism Qn -> Qn} | {morph QnC : x / nu0 x >-> nu x}}.\nProof.\napply: restrict_aut_to_num_field => x.\ncase: (splitting_field_normal 1%AS x) => rs /eqP Hrs.\nhave: root (map_poly (nu \\o QnC) (minPoly 1%AS x)) (nu (QnC x)).\n  by rewrite fmorph_root root_minPoly.\nrewrite map_Qnum_poly ?minPolyOver // Hrs.\nrewrite [map_poly _ _](_:_ = \\prod_(y <- map QnC rs) ('X - y%:P)).\n  by rewrite root_prod_XsubC; case/mapP => y _ ?; exists y.\nby rewrite big_map rmorph_prod /=; apply: eq_bigr => i _; rewrite map_polyXsubC.\nQed.",
    "Lemma dec_Cint_span (V : vectType algC) m (s : m.-tuple V) v :\n  decidable (inIntSpan s v).\nProof.\nhave s_s (i : 'I_m): s`_i \\in <<s>>%VS by rewrite memv_span ?memt_nth.\nhave s_Zs a: \\sum_(i < m) s`_i *~ a i \\in <<s>>%VS.\n  by rewrite memv_suml // => i _; rewrite -scaler_int memvZ.\ncase s_v: (v \\in <<s>>%VS); last by right=> [[a Dv]]; rewrite Dv s_Zs in s_v.\npose IzT := {: 'I_m * 'I_(\\dim <<s>>)}; pose Iz := 'I_#|IzT|.\npose b := vbasis <<s>>.\npose z_s := [seq coord b ij.2 (tnth s ij.1) | ij : IzT].\npose rank2 j i: Iz := enum_rank (i, j); pose val21 (p : Iz) := (enum_val p).1.\npose inQzs w := [forall j, Crat_span z_s (coord b j w)].\nhave enum_pairK j: {in predT, cancel (rank2 j) val21}.\n  by move=> i; rewrite /val21 enum_rankK.\nhave Qz_Zs a: inQzs (\\sum_(i < m) s`_i *~ a i).\n  apply/forallP=> j; apply/Crat_spanP; rewrite /in_Crat_span size_map -cardE.\n  exists [ffun ij => (a (val21 ij))%:Q *+ ((enum_val ij).2 == j)].\n  rewrite linear_sum {1}(reindex_onto _ _ (enum_pairK j)) big_mkcond /=.\n  apply: eq_bigr => ij _ /=; rewrite nth_image (tnth_nth 0) ffunE /val21.\n  rewrite raddfMz rmorphMn rmorph_int mulrnAl mulrzl /=.\n  rewrite (can2_eq (@enum_rankK _) (@enum_valK _)).\n  by case: (enum_val ij) => i j1; rewrite xpair_eqE eqxx; have [->|] := eqVneq.\ncase Qz_v: (inQzs v); last by right=> [[a Dv]]; rewrite Dv Qz_Zs in Qz_v.\nhave [Qz [QzC [z1s Dz_s _]]] := num_field_exists z_s.\nhave sz_z1s: size z1s = #|IzT| by rewrite -(size_map QzC) Dz_s size_map cardE.\nhave xv j: {x | coord b j v = QzC x}.\n  apply: sig_eqW; have /Crat_spanP[x ->] := forallP Qz_v j.\n  exists (\\sum_ij x ij *: z1s`_ij); rewrite rmorph_sum; apply: eq_bigr => ij _.\n  by rewrite rmorphZ_num -[in RHS](nth_map _ 0) ?Dz_s // -(size_map QzC) Dz_s.\npose sz := [tuple [ffun j => z1s`_(rank2 j i)] | i < m].\nhave [Zsv | Zs'v] := dec_Qint_span sz [ffun j => sval (xv j)].\n  left; have{Zsv} [a Dv] := Zsv; exists a.\n  transitivity (\\sum_j \\sum_(i < m) QzC ((sz`_i *~ a i) j) *: b`_j).\n    rewrite {1}(coord_vbasis s_v) -/b; apply: eq_bigr => j _.\n    rewrite -scaler_suml; congr (_ *: _).\n    have{Dv} /ffunP/(_ j) := Dv; rewrite sum_ffunE !ffunE -rmorph_sum => <-.\n    by case: (xv j).\n  rewrite exchange_big; apply: eq_bigr => i _.\n  rewrite (coord_vbasis (s_s i)) -/b mulrz_suml; apply: eq_bigr => j _.\n  rewrite scalerMzl ffunMzE rmorphMz; congr ((_ *~ _) *: _).\n  rewrite nth_mktuple ffunE -(nth_map _ 0) ?sz_z1s // Dz_s.\n  by rewrite nth_image enum_rankK /= (tnth_nth 0).\nright=> [[a Dv]]; case: Zs'v; exists a.\napply/ffunP=> j; rewrite sum_ffunE !ffunE; apply: (fmorph_inj QzC).\ncase: (xv j) => /= _ <-; rewrite Dv linear_sum rmorph_sum /=.\napply: eq_bigr => i _; rewrite nth_mktuple raddfMz !ffunMzE rmorphMz ffunE.\nby rewrite -(nth_map _ 0 QzC) ?sz_z1s // Dz_s nth_image enum_rankK -tnth_nth.\nQed.",
    "Lemma Cint_spanP n (s : n.-tuple algC) x :\n  reflect (inIntSpan s x) (x \\in Cint_span s).\nProof.\nrewrite unfold_in; case: (dec_Cint_span _ _) => [Zs_x | Zs'x] /=.\n  left; have{Zs_x} [] := Zs_x; rewrite /= size_map size_tuple => a /rowP/(_ 0).\n  rewrite !mxE => ->; exists a; rewrite summxE; apply: eq_bigr => i _.\n  by rewrite -scaler_int (nth_map 0) ?size_tuple // !mxE mulrzl.\nright=> [[a Dx]]; have{Zs'x} [] := Zs'x.\nrewrite /inIntSpan /= size_map size_tuple; exists a.\napply/rowP=> i0; rewrite !mxE summxE Dx; apply: eq_bigr => i _.\nby rewrite -scaler_int mxE mulrzl (nth_map 0) ?size_tuple // !mxE.\nQed.",
    "Lemma mem_Cint_span s : {subset s <= Cint_span s}.\nProof.\nmove=> _ /(nthP 0)[ix ltxs <-]; apply/(Cint_spanP (in_tuple s)).\nexists [ffun i => i == Ordinal ltxs : int].\nrewrite (bigD1 (Ordinal ltxs)) //= ffunE eqxx.\nby rewrite big1 ?addr0 // => i; rewrite ffunE => /negbTE->.\nQed.",
    "Lemma Cint_span_zmod_closed s : zmod_closed (Cint_span s).\nProof.\nhave sP := Cint_spanP (in_tuple s); split=> [|_ _ /sP[x ->] /sP[y ->]].\n  by apply/sP; exists 0; rewrite big1 // => i; rewrite ffunE.\napply/sP; exists (x - y); rewrite -sumrB; apply: eq_bigr => i _.\nby rewrite !ffunE raddfB.\nQed.",
    "Lemma extend_algC_subfield_aut (Qs : fieldExtType rat)\n  (QsC : {rmorphism Qs -> algC}) (phi : {rmorphism Qs -> Qs}) :\n  {nu : {rmorphism algC -> algC} | {morph QsC : x / phi x >-> nu x}}.\nProof.\npose numF_inj (Qr : fieldExtType rat) := {rmorphism Qr -> algC}.\npose subAut := {Qr : _ & numF_inj Qr * {lrmorphism Qr -> Qr}}%type.\npose SubAut := existT _ _ (_, _) : subAut.\npose Sdom (mu : subAut) := projT1 mu.\npose Sinj (mu : subAut) : {rmorphism Sdom mu -> algC} := (projT2 mu).1.\npose Saut (mu : subAut) : {rmorphism Sdom mu -> Sdom mu} := (projT2 mu).2.\nhave Sinj_poly Qr (QrC : numF_inj Qr) p:\n  map_poly QrC (map_poly (in_alg Qr) p) = pQtoC p.\n- rewrite -map_poly_comp; apply: eq_map_poly => a.\n  by rewrite /= rmorphZ_num rmorph1 mulr1.\nhave ext1 mu0 x : {mu1 | exists y, x = Sinj mu1 y\n  & exists2 in01 : {lrmorphism _ -> _}, Sinj mu0 =1 Sinj mu1 \\o in01\n  & {morph in01: y / Saut mu0 y >-> Saut mu1 y}}.\n- pose b0 := vbasis {:Sdom mu0}.\n  have [z _ /sig_eqW[[|px ps] // [Dx Ds]]] := algC_PET (x :: map (Sinj mu0) b0).\n  have [p [_ mon_p] /(_ p) pz0] := minCpolyP z; rewrite dvdpp in pz0.\n  have [r Dr] := closed_field_poly_normal (pQtoC p : {poly algC}).\n  rewrite lead_coef_map {mon_p}(monicP mon_p) rmorph1 scale1r in Dr.\n  have{pz0} rz: z \\in r by rewrite -root_prod_XsubC -Dr.\n  have [Qr [QrC [rr Drr genQr]]] := num_field_exists r.\n  have{rz} [zz Dz]: {zz | QrC zz = z}.\n    by move: rz; rewrite -Drr => /mapP/sig2_eqW[zz]; exists zz.\n  have{ps Ds} [in01 Din01]:\n      {in01 : {lrmorphism _ -> _} | Sinj mu0 =1 QrC \\o in01}.\n    have in01P y: {yy | Sinj mu0 y = QrC yy}.\n      exists (\\sum_i coord b0 i y *: (map_poly (in_alg Qr) ps`_i).[zz]).\n      rewrite {1}(coord_vbasis (memvf y)) !rmorph_sum /=; apply: eq_bigr => i _.\n      rewrite 2!rmorphZ_num -(nth_map _ 0) ?size_tuple // Ds.\n      rewrite -horner_map Dz Sinj_poly (nth_map 0) //.\n      by have:= congr1 size Ds; rewrite !size_map size_tuple => <-.\n    pose in01 y := sval (in01P y).\n    have Din01 y: Sinj mu0 y = QrC (in01 y) by rewrite /in01; case: (in01P y).\n    pose rwM := (=^~ Din01, rmorphZ_num, rmorph1, rmorphB, rmorphM).\n    have in01a : additive in01.\n      by move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM.\n    have in01m : multiplicative in01.\n      by split; try move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM /= ?rwM.\n    have in01l : scalable in01.\n      by try move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM.\n    pose in01aM := GRing.isAdditive.Build _ _ in01 in01a.\n    pose in01mM := GRing.isMultiplicative.Build _ _ in01 in01m.\n    pose in01lM := GRing.isScalable.Build _ _  _ _ in01 in01l.\n    pose in01LRM : {lrmorphism _ -> _} := HB.pack in01\n      in01aM in01mM in01lM.\n    by exists in01LRM.\n  have {z zz Dz px} Dx: exists xx, x = QrC xx.\n    exists (map_poly (in_alg Qr) px).[zz].\n    by rewrite -horner_map Dz Sinj_poly Dx.\n  pose lin01 := linfun in01; pose K := (lin01 @: fullv)%VS.\n  have memK y: reflect (exists yy, y = in01 yy) (y \\in K).\n    apply: (iffP memv_imgP) => [[yy _ ->] | [yy ->]];\n      by exists yy; rewrite ?lfunE ?memvf.\n  have algK: is_aspace K.\n    rewrite /is_aspace has_algid1; last first.\n      by apply/memK; exists 1; rewrite rmorph1.\n    apply/prodvP=> _ _ /memK[y1 ->] /memK[y2 ->].\n    by apply/memK; exists (y1 * y2); rewrite rmorphM.\n  have ker_in01: lker lin01 == 0%VS.\n    by apply/lker0P=> y1 y2; rewrite !lfunE; apply: fmorph_inj.\n  pose f := (lin01 \\o linfun (Saut mu0) \\o lin01^-1)%VF.\n  have Df y: f (in01 y) = in01 (Saut mu0 y).\n    transitivity (f (lin01 y)); first by rewrite !lfunE.\n    by do 4!rewrite lfunE /=; rewrite lker0_lfunK.\n  have hom_f: kHom 1 (ASpace algK) f.\n    apply/kHomP; split=> [_ _ /memK[y1 ->] /memK[y2 ->] |_ /vlineP[a ->]].\n      by rewrite -rmorphM !Df !rmorphM.\n    by rewrite -(rmorph_alg in01) Df /= !rmorph_alg.\n  pose pr := map_poly (in_alg Qr) p.\n  have Qpr: pr \\is a polyOver 1%VS.\n    by apply/polyOverP=> i; rewrite coef_map memvZ ?memv_line.\n  have splitQr: splittingFieldFor K pr fullv.\n    apply: splittingFieldForS (sub1v (Sub K algK)) (subvf _) _; exists rr => //.\n    congr (_ %= _): (eqpxx pr); apply/(map_poly_inj QrC).\n    rewrite Sinj_poly Dr -Drr big_map rmorph_prod /=; apply: eq_bigr => zz _.\n    by rewrite map_polyXsubC.\n  have [f1 aut_f1 Df1]:= kHom_extends (sub1v (ASpace algK)) hom_f Qpr splitQr.\n  pose f1mM := GRing.isMultiplicative.Build _ _ f1 (kHom_lrmorphism aut_f1).\n  pose nu : {lrmorphism _ -> _} := HB.pack (fun_of_lfun f1) f1mM.\n  exists (SubAut Qr QrC nu) => //; exists in01 => //= y.\n  by rewrite -Df -Df1 //; apply/memK; exists y.\nhave phiZ: scalable phi.\n  by move=> a y; rewrite rmorphZ_num -alg_num_field mulr_algl.\npose philM := GRing.isScalable.Build _ _ _ _ phi phiZ.\npose phiLRM : {lrmorphism _ -> _} := HB.pack (GRing.RMorphism.sort phi) philM.\npose fix ext n :=\n  if n is i.+1 then oapp (fun x => s2val (ext1 (ext i) x)) (ext i) (unpickle i)\n  else SubAut Qs QsC phiLRM.\nhave mem_ext x n: (pickle x < n)%N -> {xx | Sinj (ext n) xx = x}.\n  move=> ltxn; apply: sig_eqW; elim: n ltxn => // n IHn.\n  rewrite ltnS leq_eqVlt => /predU1P[<- | /IHn[xx <-]] /=.\n    by rewrite pickleK /=; case: (ext1 _ x) => mu [xx]; exists xx.\n  case: (unpickle n) => /= [y|]; last by exists xx.\n  case: (ext1 _ y) => mu /= _ [in_mu inj_in_mu _].\n  by exists (in_mu xx); rewrite inj_in_mu.\npose nu x := Sinj _ (Saut _ (sval (mem_ext x _ (ltnSn _)))).\nhave nu_inj n y: nu (Sinj (ext n) y) = Sinj (ext n) (Saut (ext n) y).\n  rewrite /nu; case: (mem_ext _ _ _); move: _.+1 => n1 y1 Dy /=.\n  without loss /subnK Dn1: n n1 y y1 Dy / (n <= n1)%N.\n    by move=> IH; case/orP: (leq_total n n1) => /IH => [/(_ y) | /(_ y1)]->.\n  move: (n1 - n)%N => k in Dn1; elim: k => [|k IHk] in n Dn1 y Dy *.\n    by move: y1 Dy; rewrite -Dn1 => y1  /fmorph_inj ->.\n  rewrite addSnnS in Dn1; move/IHk: Dn1 => /=.\n  case: (unpickle _) => [z|] /=; last exact.\n  case: (ext1 _ _) => mu /= _ [in_mu Dinj Daut].\n  by rewrite Dy => /(_ _ (Dinj _))->; rewrite -Daut Dinj.\npose le_nu (x : algC) n := (pickle x < n)%N.\nhave max3 x1 x2 x3: exists n, [/\\ le_nu x1 n, le_nu x2 n & le_nu x3 n].\n  exists (maxn (pickle x1) (maxn (pickle x2) (pickle x3))).+1.\n  by apply/and3P; rewrite /le_nu !ltnS -!geq_max.\nhave nua : additive nu.\n  move=> x1 x2; have [n] := max3 (x1 - x2) x1 x2.\n  case=> /mem_ext[y Dx] /mem_ext[y1 Dx1] /mem_ext[y2 Dx2].\n  rewrite -Dx nu_inj; rewrite -Dx1 -Dx2 -rmorphB in Dx.\n  by rewrite (fmorph_inj _ Dx) !rmorphB -!nu_inj Dx1 Dx2.\nhave num : multiplicative nu.\n  split=> [x1 x2|]; last by rewrite -(rmorph1 QsC) (nu_inj 0) !rmorph1.\n  have [n] := max3 (x1 * x2) x1 x2.\n  case=> /mem_ext[y Dx] /mem_ext[y1 Dx1] /mem_ext[y2 Dx2].\n  rewrite -Dx nu_inj; rewrite -Dx1 -Dx2 -rmorphM in Dx.\n  by rewrite (fmorph_inj _ Dx) !rmorphM /= -!nu_inj Dx1 Dx2.\npose nuaM := GRing.isAdditive.Build _ _ nu nua.\npose numM := GRing.isMultiplicative.Build _ _ nu num.\npose nuRM : {rmorphism _ -> _} := HB.pack nu nuaM numM.\nby exists nuRM => x; rewrite /= (nu_inj 0).\nQed.",
    "Lemma Qn_aut_exists k n :\n    coprime k n ->\n  {u : {rmorphism algC -> algC} | forall z, z ^+ n = 1 -> u z = z ^+ k}.\nProof.\nhave [-> /eqnP | n_gt0 co_k_n] := posnP n.\n  by rewrite gcdn0 => ->; exists idfun.\nhave [z prim_z] := C_prim_root_exists n_gt0.\nhave [Qn [QnC [[|zn []] // [Dz]]] genQn] := num_field_exists [:: z].\npose phi := kHomExtend 1 \\1 zn (zn ^+ k).\nhave homQn1: kHom 1 1 (\\1%VF : 'End(Qn)) by rewrite kHom1.\nhave pzn_zk0: root (map_poly \\1%VF (minPoly 1 zn)) (zn ^+ k).\n  rewrite -(fmorph_root QnC) rmorphXn /= Dz -map_poly_comp.\n  rewrite (@eq_map_poly _ _ _ QnC) => [|a]; last by rewrite /= id_lfunE.\n  set p1 := map_poly _ _.\n  have [q1 Dp1]: exists q1, p1 = pQtoC q1.\n    have aP i: (minPoly 1 zn)`_i \\in 1%VS.\n      by apply/polyOverP; apply: minPolyOver.\n    have{aP} a_ i := sig_eqW (vlineP _ _ (aP i)).\n    exists (\\poly_(i < size (minPoly 1 zn)) sval (a_ i)).\n    apply/polyP=> i; rewrite coef_poly coef_map coef_poly /=.\n    case: ifP => _; rewrite ?rmorph0 //; case: (a_ i) => a /= ->.\n    by rewrite alg_num_field fmorph_rat.\n  have: root p1 z by rewrite -Dz fmorph_root root_minPoly.\n  rewrite Dp1; have [q2 [Dq2 _] ->] := minCpolyP z.\n  case/dvdpP=> r1 ->; rewrite rmorphM rootM /= -Dq2; apply/orP; right.\n  rewrite (minCpoly_cyclotomic prim_z) /cyclotomic.\n  rewrite (bigD1 (Ordinal (ltn_pmod k n_gt0))) ?coprime_modl //=.\n  by rewrite rootM root_XsubC prim_expr_mod ?eqxx.\nhave phim : multiplicative phi.\n  by apply/kHom_lrmorphism; rewrite -genQn span_seq1 /= kHomExtendP.\npose phimM := GRing.isMultiplicative.Build _ _ phi phim.\npose phiRM : {rmorphism _ -> _} := HB.pack (fun_of_lfun phi) phimM.\nhave [nu Dnu] := extend_algC_subfield_aut QnC phiRM.\nexists nu => _ /(prim_rootP prim_z)[i ->].\nrewrite rmorphXn /= exprAC -Dz -Dnu /= -{1}[zn]hornerX /phi.\nrewrite (kHomExtend_poly homQn1) ?polyOverX //.\nrewrite map_polyE map_id_in => [|?]; last by rewrite id_lfunE.\nby rewrite polyseqK hornerX rmorphXn.\nQed.",
    "Lemma root_monic_Aint p x :\n  root p x -> p \\is monic -> p \\is a polyOver Num.int -> x \\in Aint.\nProof.\nhave pZtoQtoC pz: pQtoC (pZtoQ pz) = pZtoC pz.\n  by rewrite -map_poly_comp; apply: eq_map_poly => b; rewrite /= rmorph_int.\nmove=> px0 mon_p /floorpP[pz Dp]; rewrite unfold_in.\nmove: px0; rewrite Dp -pZtoQtoC; have [q [-> mon_q] ->] := minCpolyP x.\ncase/dvdpP_rat_int=> qz [a nz_a Dq] [r].\nmove/(congr1 (fun q1 => lead_coef (a *: pZtoQ q1))).\nrewrite rmorphM scalerAl -Dq lead_coefZ lead_coefM /=.\nhave /monicP->: pZtoQ pz \\is monic by rewrite -(map_monic QtoC) pZtoQtoC -Dp.\nrewrite (monicP mon_q) mul1r mulr1 lead_coef_map_inj //; last exact: intr_inj.\nrewrite Dq => ->; apply/polyOverP=> i; rewrite !(coefZ, coef_map).\nby rewrite -rmorphM /= rmorph_int.\nQed.",
    "Lemma Cint_rat_Aint z : z \\in Crat -> z \\in Aint -> z \\in Num.int.\nProof.\ncase/CratP=> a ->{z} /polyOverP/(_ 0).\nhave [p [Dp mon_p] dv_p] := minCpolyP (ratr a); rewrite Dp coef_map.\nsuffices /eqP->: p == 'X - a%:P by rewrite polyseqXsubC /= rmorphN rpredN.\nrewrite -eqp_monic ?monicXsubC // irredp_XsubC //.\n  by rewrite -(size_map_poly QtoC) -Dp neq_ltn size_minCpoly orbT.\nby rewrite -dv_p fmorph_root root_XsubC.\nQed.",
    "Lemma Aint_Cint : {subset Num.int <= Aint}.\nProof.\nmove=> x; rewrite -polyOverXsubC.\nby apply: root_monic_Aint; rewrite ?monicXsubC ?root_XsubC.\nQed.",
    "Lemma Aint_int x : x%:~R \\in Aint. Proof. by rewrite Aint_Cint. Qed.",
    "Lemma Aint0 : 0 \\in Aint. Proof. exact: Aint_int 0. Qed.",
    "Lemma Aint1 : 1 \\in Aint. Proof. exact: Aint_int 1. Qed.",
    "Lemma Aint_unity_root n x : (n > 0)%N -> n.-unity_root x -> x \\in Aint.\nProof.\nmove=> n_gt0 xn1; apply: root_monic_Aint xn1 (monicXnsubC _ n_gt0) _.\nby apply/polyOverP=> i; rewrite coefB coefC -mulrb coefXn /= rpredB ?rpred_nat.\nQed.",
    "Lemma Aint_prim_root n z : n.-primitive_root z -> z \\in Aint.\nProof.\nmove=> pr_z; apply/(Aint_unity_root (prim_order_gt0 pr_z))/unity_rootP.\nexact: prim_expr_order.\nQed.",
    "Lemma Aint_Cnat : {subset Num.nat <= Aint}.\nProof. by move=> z /intr_nat/Aint_Cint. Qed.",
    "Lemma Aint_subring_exists (X : seq algC) :\n    {subset X <= Aint} ->\n  {S : pred algC &\n      subring_closed S\n  /\\  {subset X <= S}\n   &  {Y : {n : nat & n.-tuple algC} &\n                {subset tagged Y <= S}\n              & forall x, reflect (inIntSpan (tagged Y) x) (x \\in S)}}.\nProof.\nmove=> AZ_X; pose m := (size X).+1.\npose n (i : 'I_m) := (size (minCpoly X`_i)).-2; pose N := (\\max_i n i).+1.\npose IY := family (fun i => [pred e : 'I_N | e <= n i]%N).\nhave IY_0: 0 \\in IY by apply/familyP=> // i; rewrite ffunE.\npose inIY := enum_rank_in IY_0.\npose Y := [seq \\prod_(i < m) X`_i ^+ (f : 'I_N ^ m) i | f in IY].\nhave S_P := Cint_spanP [tuple of Y]; set S := Cint_span _ in S_P.\nhave sYS: {subset Y <= S} by apply: mem_Cint_span.\nhave S_1: 1 \\in S.\n  by apply/sYS/imageP; exists 0 => //; rewrite big1 // => i; rewrite ffunE.\nhave SmulX (i : 'I_m): {in S, forall x, x * X`_i \\in S}.\n  move=> _ /S_P[x ->]; rewrite mulr_suml rpred_sum // => j _.\n  rewrite mulrzAl rpredMz {x}// nth_image mulrC (bigD1 i) //= mulrA -exprS.\n  move: {j}(enum_val j) (familyP (enum_valP j)) => f fP.\n  have:= fP i; rewrite inE /= leq_eqVlt => /predU1P[-> | fi_ltn]; last first.\n    apply/sYS/imageP; have fiK: (inord (f i).+1 : 'I_N) = (f i).+1 :> nat.\n      by rewrite inordK // ltnS (bigmax_sup i).\n    exists (finfun [eta f with i |-> inord (f i).+1]).\n      apply/familyP=> i1; rewrite inE ffunE /= fun_if fiK.\n      by case: eqP => [-> // | _]; apply: fP.\n    rewrite (bigD1 i isT) ffunE /= eqxx fiK; congr (_ * _).\n    by apply: eq_bigr => i1 /[!ffunE]/= /negPf->.\n  have [/monicP ] := (minCpoly_monic X`_i, root_minCpoly X`_i).\n  rewrite /root horner_coef lead_coefE -(subnKC (size_minCpoly _)) subn2.\n  rewrite big_ord_recr /= addrC addr_eq0 => ->; rewrite mul1r => /eqP->.\n  have /floorpP[p Dp]: X`_i \\in Aint.\n    by have [/(nth_default 0)-> | /(mem_nth 0)/AZ_X] := leqP (size X) i.\n  rewrite -/(n i) Dp mulNr rpredN // mulr_suml rpred_sum // => [[e le_e]] /= _.\n  rewrite coef_map -mulrA mulrzl rpredMz ?sYS //; apply/imageP.\n  have eK: (inord e : 'I_N) = e :> nat by rewrite inordK // ltnS (bigmax_sup i).\n  exists (finfun [eta f with i |-> inord e]).\n    apply/familyP=> i1; rewrite inE ffunE /= fun_if eK.\n    by case: eqP => [-> // | _]; apply: fP.\n  rewrite (bigD1 i isT) ffunE /= eqxx eK; congr (_ * _).\n  by apply: eq_bigr => i1 /[!ffunE] /= /negPf->.\nexists S; last by exists (Tagged (fun n => n.-tuple _) [tuple of Y]).\nsplit=> [|x Xx]; last first.\n  by rewrite -[x]mul1r -(nth_index 0 Xx) (SmulX (Ordinal _)) // ltnS index_size.\nsplit=> // x y Sx Sy; first by rewrite rpredB.\ncase/S_P: Sy => {y}[y ->]; rewrite mulr_sumr rpred_sum //= => j.\nrewrite mulrzAr rpredMz {y}// nth_image; move: {j}(enum_val j) => f.\nelim/big_rec: _ => [|i y _ IHy] in x Sx *; first by rewrite mulr1.\nrewrite mulrA {y}IHy //.\nelim: {f}(f i : nat) => [|e IHe] in x Sx *; first by rewrite mulr1.\nby rewrite exprS mulrA IHe // SmulX.\nQed.",
    "Lemma Aint_aut (nu : {rmorphism algC -> algC}) x :\n  (nu x \\in Aint) = (x \\in Aint).\nProof. by rewrite !unfold_in minCpoly_aut. Qed.",
    "Lemma eqAmod_refl e x : (x == x %[mod e])%A.\nProof. by rewrite /eqAmod subrr rpred0. Qed.",
    "Lemma eqAmod_sym e x y : ((x == y %[mod e]) = (y == x %[mod e]))%A.\nProof. by rewrite /eqAmod -opprB rpredN. Qed.",
    "Lemma eqAmod_trans e y x z :\n  (x == y %[mod e] -> y == z %[mod e] -> x == z %[mod e])%A.\nProof.\nby move=> Exy Eyz; rewrite /eqAmod -[x](subrK y) -[_ - z]addrA rpredD.\nQed.",
    "Lemma eqAmod_transl e x y z :\n  (x == y %[mod e])%A -> (x == z %[mod e])%A = (y == z %[mod e])%A.\nProof. by move/(sym_left_transitive (eqAmod_sym e) (@eqAmod_trans e)). Qed.",
    "Lemma eqAmod_transr e x y z :\n  (x == y %[mod e])%A -> (z == x %[mod e])%A = (z == y %[mod e])%A.\nProof. by move/(sym_right_transitive (eqAmod_sym e) (@eqAmod_trans e)). Qed.",
    "Lemma eqAmod0 e x : (x == 0 %[mod e])%A = (e %| x)%A.\nProof. by rewrite /eqAmod subr0. Qed.",
    "Lemma eqAmodN e x y : (- x == y %[mod e])%A = (x == - y %[mod e])%A.\nProof. by rewrite eqAmod_sym /eqAmod !opprK addrC. Qed.",
    "Lemma eqAmodDr e x y z : (y + x == z + x %[mod e])%A = (y == z %[mod e])%A.\nProof. by rewrite /eqAmod addrAC opprD !addrA subrK. Qed.",
    "Lemma eqAmodDl e x y z : (x + y == x + z %[mod e])%A = (y == z %[mod e])%A.\nProof. by rewrite !(addrC x) eqAmodDr. Qed.",
    "Lemma eqAmodD e x1 x2 y1 y2 :\n  (x1 == x2 %[mod e] -> y1 == y2 %[mod e] -> x1 + y1 == x2 + y2 %[mod e])%A.\nProof.\nby rewrite -(eqAmodDl e x2 y1) -(eqAmodDr e y1); apply: eqAmod_trans.\nQed.",
    "Lemma eqAmodm0 e : (e == 0 %[mod e])%A.\nProof. by rewrite /eqAmod subr0 unfold_in; case: ifPn => // /divff->. Qed.",
    "Lemma eqAmodMr e :\n  {in Aint, forall z x y, x == y %[mod e] -> x * z == y * z %[mod e]}%A.\nProof.\nmove=> z Zz x y.\nrewrite /eqAmod -mulrBl ![(e %| _)%A]unfold_in mulf_eq0 mulrAC.\nby case: ifP => [_ -> // | _ Exy]; apply: rpredM.\nQed.",
    "Lemma eqAmodMl e :\n  {in Aint, forall z x y, x == y %[mod e] -> z * x == z * y %[mod e]}%A.\nProof. by move=> z Zz x y Exy; rewrite !(mulrC z) eqAmodMr. Qed.",
    "Lemma eqAmodMl0 e : {in Aint, forall x, x * e == 0 %[mod e]}%A.\nProof. by move=> x Zx; rewrite -(mulr0 x) eqAmodMl. Qed.",
    "Lemma eqAmodMr0 e : {in Aint, forall x, e * x == 0 %[mod e]}%A.\nProof. by move=> x Zx; rewrite /= mulrC eqAmodMl0. Qed.",
    "Lemma eqAmod_addl_mul e : {in Aint, forall x y, x * e + y == y %[mod e]}%A.\nProof. by move=> x Zx y; rewrite -{2}[y]add0r eqAmodDr eqAmodMl0. Qed.",
    "Lemma eqAmodM e : {in Aint &, forall x1 y2 x2 y1,\n  x1 == x2 %[mod e] -> y1 == y2 %[mod e] -> x1 * y1 == x2 * y2 %[mod e]}%A.\nProof.\nmove=> x1 y2 Zx1 Zy2 x2 y1 eq_x /(eqAmodMl Zx1)/eqAmod_trans-> //.\nexact: eqAmodMr.\nQed.",
    "Lemma eqAmod_rat :\n  {in Crat & &, forall e m n, (m == n %[mod e])%A = (m == n %[mod e])%C}.\nProof.\nmove=> e m n Qe Qm Qn; rewrite /eqCmod unfold_in /eqAmod unfold_in.\ncase: ifPn => // nz_e; apply/idP/idP=> [/Cint_rat_Aint | /Aint_Cint] -> //.\nby rewrite rpred_div ?rpredB.\nQed.",
    "Lemma eqAmod0_rat : {in Crat &, forall e n, (n == 0 %[mod e])%A = (e %| n)%C}.\nProof. by move=> e n Qe Qn; rewrite /= eqAmod_rat /eqCmod ?subr0 ?Crat0. Qed.",
    "Lemma eqAmod_nat (e m n : nat) : (m == n %[mod e])%A = (m == n %[mod e])%N.\nProof. by rewrite eqAmod_rat ?rpred_nat // eqCmod_nat. Qed.",
    "Lemma eqAmod0_nat (e m : nat) : (m == 0 %[mod e])%A = (e %| m)%N.\nProof. by rewrite eqAmod0_rat ?rpred_nat // dvdC_nat. Qed.",
    "Lemma exp_orderC x : x ^+ #[x]%C = 1.\nProof.\nrewrite /orderC; case: pickP => //= [] [n _] /= /eqP Dp.\nhave n_gt0: (0 < n)%N.\n  rewrite lt0n; apply: contraTneq (size_minCpoly x) => n0.\n  by rewrite Dp n0 Cyclotomic0 rmorph1 size_poly1.\nhave [z prim_z] := C_prim_root_exists n_gt0.\nrewrite prim_expr_order // -(root_cyclotomic prim_z).\nby rewrite -Cintr_Cyclotomic // -Dp root_minCpoly.\nQed.",
    "Lemma dvdn_orderC x n : (#[x]%C %| n)%N = (x ^+ n == 1).\nProof.\napply/idP/eqP=> [|x_n_1]; first by apply: expr_dvd; apply: exp_orderC.\nhave [-> | n_gt0] := posnP n; first by rewrite dvdn0.\nhave [m prim_x m_dv_n] := prim_order_exists n_gt0 x_n_1.\nhave{n_gt0} m_gt0 := dvdn_gt0 n_gt0 m_dv_n; congr (_ %| n)%N: m_dv_n.\npose p := minCpoly x; have Dp: p = cyclotomic x m := minCpoly_cyclotomic prim_x.\nrewrite /orderC; case: pickP => /= [k /eqP Dp_k | no_k]; last first.\n  suffices lt_m_2p: (m < 2 * size p ^ 2)%N.\n    have /eqP[] := no_k (Ordinal lt_m_2p).\n    by rewrite /= -/p Dp -Cintr_Cyclotomic.\n  rewrite Dp size_cyclotomic (sqrnD 1) addnAC mulnDr -add1n leq_add //.\n  suffices: (m <= \\prod_(q <- primes m | q == 2) q * totient m ^ 2)%N.\n    have [m_even | m_odd] := boolP (2%N \\in primes m).\n      by rewrite -big_filter filter_pred1_uniq ?primes_uniq // big_seq1.\n    by rewrite big_hasC ?has_pred1 // => /leq_trans-> //; apply: leq_addl.\n  rewrite big_mkcond totientE // -mulnn -!big_split /=.\n  rewrite {1}[m]prod_prime_decomp // prime_decompE big_map /= !big_seq.\n  elim/big_ind2: _ => // [n1 m1 n2 m2 | q]; first exact: leq_mul.\n  rewrite mem_primes => /and3P[q_pr _ q_dv_m].\n  rewrite lognE q_pr m_gt0 q_dv_m /=; move: (logn q _) => k.\n  rewrite !mulnA expnS leq_mul //.\n  case: (ltngtP q 2) (prime_gt1 q_pr) => // [q_gt2|->] _.\n    rewrite mul1n mulnAC mulnn -{1}[q]muln1 leq_mul ?expn_gt0 ?prime_gt0 //.\n    by rewrite -(subnKC q_gt2) (ltn_exp2l 1).\n  by rewrite !muln1 -expnS (ltn_exp2l 0).\nhave k_prim_x: k.-primitive_root x.\n  have k_gt0: (0 < k)%N.\n    rewrite lt0n; apply: contraTneq (size_minCpoly x) => k0.\n    by rewrite Dp_k k0 Cyclotomic0 rmorph1 size_poly1.\n  have [z prim_z] := C_prim_root_exists k_gt0.\n  rewrite -(root_cyclotomic prim_z) -Cintr_Cyclotomic //.\n  by rewrite -Dp_k root_minCpoly.\napply/eqP; rewrite eqn_dvd !(@prim_order_dvd _ _ x) //.\nby rewrite !prim_expr_order ?eqxx.\nQed.",
    "Lemma amE u v : am u v = v * u. Proof. by rewrite lfunE. Qed.",
    "Lemma mulVr : {in uam, left_inverse 1 vam *%R}.\n  Proof. by move=> u Uu; rewrite /= Uu -amE lker0_lfunVK. Qed.",
    "Lemma divrr : {in uam, right_inverse 1 vam *%R}.\n  Proof.\n  by move=> u Uu; apply/(lker0P Uu); rewrite !amE -mulrA mulVr // mul1r mulr1.\n  Qed.",
    "Lemma unitrP : forall x y, y * x = 1 /\\ x * y = 1 -> uam x.\n  Proof.\n  move=> u v [_ uv1].\n  by apply/lker0P=> w1 w2 /(congr1 (am v)); rewrite !amE -!mulrA uv1 !mulr1.\n  Qed.",
    "Lemma invr_out : {in [predC uam], vam =1 id}.\n  Proof. by move=> u /negbTE/= ->. Qed.",
    "Lemma regular_fullv (K : fieldType) : (fullv = 1 :> {vspace K^o})%VS.\nProof. by apply/esym/eqP; rewrite eqEdim subvf dim_vline oner_eq0 dimvf. Qed.",
    "Lemma FalgType_proper : dim aT > 0.\nProof.\nrewrite lt0n; apply: contraNneq (oner_neq0 aT) => aT0.\nby apply/eqP/v2r_inj; do 2!move: (v2r _); rewrite aT0 => u v; rewrite !thinmx0.\nQed.",
    "Lemma lfun_mulE f g u : (f * g) u = g (f u). Proof. exact: lfunE. Qed.",
    "Lemma lfun_compE f g : (g \\o f)%VF = f * g. Proof. by []. Qed.",
    "Lemma lfun_mulVr f : lker f == 0%VS -> f^-1%VF * f = 1.\nProof. exact: lker0_compfV. Qed.",
    "Lemma lfun_mulrV f : lker f == 0%VS -> f * f^-1%VF = 1.\nProof. exact: lker0_compVf. Qed.",
    "Lemma lfun_invr_out f : lker f != 0%VS -> lfun_invr f = f.\nProof. by rewrite /lfun_invr => /negPf->. Qed.",
    "Lemma lfun_invE f : lker f == 0%VS -> f^-1%VF = f^-1.\nProof. by rewrite /f^-1 /= /lfun_invr => ->. Qed.",
    "Lemma amull_inj : injective amull.\nProof. by move=> u v /lfunP/(_ 1); rewrite !lfunE /= !mulr1. Qed.",
    "Lemma amulr_inj : injective amulr.\nProof. by move=> u v /lfunP/(_ 1); rewrite !lfunE /= !mul1r. Qed.",
    "Lemma amull1 : amull 1 = \\1%VF.\nProof. by apply/lfunP => z; rewrite id_lfunE lfunE /= mul1r. Qed.",
    "Lemma amullM u v : (amull (u * v) = amull v * amull u)%VF.\nProof. by apply/lfunP => w; rewrite comp_lfunE !lfunE /= mulrA. Qed.",
    "Lemma amulr_is_linear : linear amulr.\nProof.\nmove=> a u v; apply/lfunP => w.\nby rewrite !lfunE /= !lfunE /= lfunE mulrDr /= scalerAr.\nQed.",
    "Lemma amulr_is_multiplicative : multiplicative amulr.\nProof.\nsplit=> [x y|]; last by apply/lfunP => w; rewrite id_lfunE !lfunE /= mulr1.\nby apply/lfunP=> w; rewrite comp_lfunE !lfunE /= mulrA.\nQed.",
    "Lemma lker0_amull u : u \\is a GRing.unit -> lker (amull u) == 0%VS.\nProof. by move=> Uu; apply/lker0P=> v w; rewrite !lfunE; apply: mulrI. Qed.",
    "Lemma lker0_amulr u : u \\is a GRing.unit -> lker (amulr u) == 0%VS.\nProof. by move=> Uu; apply/lker0P=> v w; rewrite !lfunE; apply: mulIr. Qed.",
    "Lemma lfun1_poly (p : {poly aT}) : map_poly \\1%VF p = p.\nProof. by apply: map_poly_id => u _; apply: id_lfunE. Qed.",
    "Lemma memv_mul U V : {in U & V, forall u v, u * v \\in (U * V)%VS}.\nProof.\nmove=> u v /coord_vbasis-> /coord_vbasis->.\nrewrite mulr_suml; apply: memv_suml => i _.\nrewrite mulr_sumr; apply: memv_suml => j _.\nrewrite -scalerAl -scalerAr !memvZ // [prodv]unlock memv_span //.\nby apply/allpairsP; exists ((vbasis U)`_i, (vbasis V)`_j); rewrite !memt_nth.\nQed.",
    "Lemma prodvP {U V W} :\n  reflect {in U & V, forall u v, u * v \\in W} (U * V <= W)%VS.\nProof.\napply: (iffP idP) => [sUVW u v Uu Vv | sUVW].\n  by rewrite (subvP sUVW) ?memv_mul.\nrewrite [prodv]unlock; apply/span_subvP=> _ /allpairsP[[u v] /= [Uu Vv ->]].\nby rewrite sUVW ?vbasis_mem.\nQed.",
    "Lemma prodv_line u v : (<[u]> * <[v]> = <[u * v]>)%VS.\nProof.\napply: subv_anti; rewrite -memvE memv_mul ?memv_line // andbT.\napply/prodvP=> _ _ /vlineP[a ->] /vlineP[b ->].\nby rewrite -scalerAr -scalerAl !memvZ ?memv_line.\nQed.",
    "Lemma dimv1: \\dim (1%VS : {vspace aT}) = 1.\nProof. by rewrite dim_vline oner_neq0. Qed.",
    "Lemma dim_prodv U V : \\dim (U * V) <= \\dim U * \\dim V.\nProof. by rewrite unlock (leq_trans (dim_span _)) ?size_tuple. Qed.",
    "Lemma vspace1_neq0 : (1 != 0 :> {vspace aT})%VS.\nProof. by rewrite -dimv_eq0 dimv1. Qed.",
    "Lemma vbasis1 : exists2 k, k != 0 & vbasis 1 = [:: k%:A] :> seq aT.\nProof.\nmove: (vbasis 1) (@vbasisP K aT 1); rewrite dim_vline oner_neq0.\ncase/tupleP=> x X0; rewrite {X0}tuple0 => defX; have Xx := mem_head x nil.\nhave /vlineP[k def_x] := basis_mem defX Xx; exists k; last by rewrite def_x.\nby have:= basis_not0 defX Xx; rewrite def_x scaler_eq0 oner_eq0 orbF.\nQed.",
    "Lemma prod0v : left_zero 0%VS prodv.\nProof.\nmove=> U; apply/eqP; rewrite -dimv_eq0 -leqn0 (leq_trans (dim_prodv 0 U)) //.\nby rewrite dimv0.\nQed.",
    "Lemma prodv0 : right_zero 0%VS prodv.\nProof.\nmove=> U; apply/eqP; rewrite -dimv_eq0 -leqn0 (leq_trans (dim_prodv U 0)) //.\nby rewrite dimv0 muln0.\nQed.",
    "Lemma prod1v : left_id 1%VS prodv.\nProof.\nmove=> U; apply/subv_anti/andP; split.\n  by apply/prodvP=> _ u /vlineP[a ->] Uu; rewrite mulr_algl memvZ.\nby apply/subvP=> u Uu; rewrite -[u]mul1r memv_mul ?memv_line.\nQed.",
    "Lemma prodv1 : right_id 1%VS prodv.\nProof.\nmove=> U; apply/subv_anti/andP; split.\n  by apply/prodvP=> u _ Uu /vlineP[a ->]; rewrite mulr_algr memvZ.\nby apply/subvP=> u Uu; rewrite -[u]mulr1 memv_mul ?memv_line.\nQed.",
    "Lemma prodvS U1 U2 V1 V2 : (U1 <= U2 -> V1 <= V2 -> U1 * V1 <= U2 * V2)%VS.\nProof.\nmove/subvP=> sU12 /subvP sV12; apply/prodvP=> u v Uu Vv.\nby rewrite memv_mul ?sU12 ?sV12.\nQed.",
    "Lemma prodvSl U1 U2 V : (U1 <= U2 -> U1 * V <= U2 * V)%VS.\nProof. by move/prodvS->. Qed.",
    "Lemma prodvSr U V1 V2 : (V1 <= V2 -> U * V1 <= U * V2)%VS.\nProof. exact: prodvS. Qed.",
    "Lemma prodvDl : left_distributive prodv addv.\nProof.\nmove=> U1 U2 V; apply/esym/subv_anti/andP; split.\n  by rewrite subv_add 2?prodvS ?addvSl ?addvSr.\napply/prodvP=> _ v /memv_addP[u1 Uu1 [u2 Uu2 ->]] Vv.\nby rewrite mulrDl memv_add ?memv_mul.\nQed.",
    "Lemma prodvDr : right_distributive prodv addv.\nProof.\nmove=> U V1 V2; apply/esym/subv_anti/andP; split.\n  by rewrite subv_add 2?prodvS ?addvSl ?addvSr.\napply/prodvP=> u _ Uu /memv_addP[v1 Vv1 [v2 Vv2 ->]].\nby rewrite mulrDr memv_add ?memv_mul.\nQed.",
    "Lemma prodvA : associative prodv.\nProof.\nmove=> U V W; rewrite -(span_basis (vbasisP U)) span_def !big_distrl /=.\napply: eq_bigr => u _; rewrite -(span_basis (vbasisP W)) span_def !big_distrr.\napply: eq_bigr => w _; rewrite -(span_basis (vbasisP V)) span_def /=.\nrewrite !(big_distrl, big_distrr) /=; apply: eq_bigr => v _.\nby rewrite !prodv_line mulrA.\nQed.",
    "Lemma expv0 U : (U ^+ 0 = 1)%VS. Proof. by []. Qed.",
    "Lemma expv1 U : (U ^+ 1 = U)%VS. Proof. by []. Qed.",
    "Lemma expv2 U : (U ^+ 2 = U * U)%VS. Proof. by []. Qed.",
    "Lemma expvSl U n : (U ^+ n.+1 = U * U ^+ n)%VS.\nProof. by case: n => //; rewrite prodv1. Qed.",
    "Lemma expv0n n : (0 ^+ n = if n is _.+1 then 0 else 1)%VS.\nProof. by case: n => // n; rewrite expvSl prod0v. Qed.",
    "Lemma expv1n n : (1 ^+ n = 1)%VS.\nProof. by elim: n => // n IHn; rewrite expvSl IHn prodv1. Qed.",
    "Lemma expvD U m n : (U ^+ (m + n) = U ^+ m * U ^+ n)%VS.\nProof. by elim: m => [|m IHm]; rewrite ?prod1v // !expvSl IHm prodvA. Qed.",
    "Lemma expvSr U n : (U ^+ n.+1 = U ^+ n * U)%VS.\nProof. by rewrite -addn1 expvD. Qed.",
    "Lemma expvM U m n : (U ^+ (m * n) = U ^+ m ^+ n)%VS.\nProof. by elim: n => [|n IHn]; rewrite ?muln0 // mulnS expvD IHn expvSl. Qed.",
    "Lemma expvS U V n : (U <= V -> U ^+ n <= V ^+ n)%VS.\nProof.\nmove=> sUV; elim: n => [|n IHn]; first by rewrite !expv0 subvv.\nby rewrite !expvSl prodvS.\nQed.",
    "Lemma expv_line u n : (<[u]> ^+ n = <[u ^+ n]>)%VS.\nProof.\nelim: n => [|n IH]; first by rewrite expr0 expv0.\nby rewrite exprS expvSl IH prodv_line.\nQed.",
    "Lemma cent1vP u v : reflect (u * v = v * u) (u \\in 'C[v]%VS).\nProof. by rewrite (sameP eqlfunP eqP) !lfunE /=; apply: eqP. Qed.",
    "Lemma cent1v1 u : 1 \\in 'C[u]%VS. Proof. by apply/cent1vP; rewrite commr1. Qed.",
    "Lemma cent1v_id u : u \\in 'C[u]%VS. Proof. exact/cent1vP. Qed.",
    "Lemma cent1vX u n : u ^+ n \\in 'C[u]%VS. Proof. exact/cent1vP/esym/commrX. Qed.",
    "Lemma cent1vC u v : (u \\in 'C[v])%VS = (v \\in 'C[u])%VS.\nProof. exact/cent1vP/cent1vP. Qed.",
    "Lemma centvP u V : reflect {in V, forall v, u * v = v * u} (u \\in 'C(V))%VS.\nProof.\napply: (iffP subv_bigcapP) => [cVu y /coord_vbasis-> | cVu i _].\n  apply/esym/cent1vP/rpred_sum=> i _; apply: rpredZ.\n  by rewrite -tnth_nth cent1vC memvE cVu.\nexact/cent1vP/cVu/vbasis_mem/mem_tnth.\nQed.",
    "Lemma centvsP U V : reflect {in U & V, commutative *%R} (U <= 'C(V))%VS.\nProof. by apply: (iffP subvP) => [cUV u v | cUV u] /cUV-/centvP; apply. Qed.",
    "Lemma subv_cent1 U v : (U <= 'C[v])%VS = (v \\in 'C(U)%VS).\nProof.\nby apply/subvP/centvP=> cUv u Uu; apply/cent1vP; rewrite 1?cent1vC cUv.\nQed.",
    "Lemma centv1 V : 1 \\in 'C(V)%VS.\nProof. by apply/centvP=> v _; rewrite commr1. Qed.",
    "Lemma centvX V u n : u \\in 'C(V)%VS -> u ^+ n \\in 'C(V)%VS.\nProof. by move/centvP=> cVu; apply/centvP=> v /cVu/esym/commrX->. Qed.",
    "Lemma centvC U V : (U <= 'C(V))%VS = (V <= 'C(U))%VS.\nProof. by apply/centvsP/centvsP=> cUV u v UVu /cUV->. Qed.",
    "Lemma centerv_sub V : ('Z(V) <= V)%VS. Proof. exact: capvSl. Qed.",
    "Lemma cent_centerv V : (V <= 'C('Z(V)))%VS.\nProof. by rewrite centvC capvSr. Qed.",
    "Lemma has_algidP {U} : reflect (exists e, is_algid e U) (has_algid U).\nProof. exact: sumboolP. Qed.",
    "Lemma has_algid1 U : 1 \\in U -> has_algid U.\nProof.\nmove=> U1; apply/has_algidP; exists 1; split; rewrite ?oner_eq0 // => u _.\nby rewrite mulr1 mul1r.\nQed.",
    "Lemma aspacef_subproof : is_aspace fullv.\nProof. by rewrite /is_aspace subvf has_algid1 ?memvf. Qed.",
    "Lemma polyOver1P p :\n  reflect (exists q, p = map_poly (in_alg aT) q) (p \\is a polyOver 1%VS).\nProof.\napply: (iffP idP) => [/allP/=Qp | [q ->]]; last first.\n  by apply/polyOverP=> j; rewrite coef_map rpredZ ?memv_line.\nexists (map_poly (coord [tuple 1] 0) p).\nrewrite -map_poly_comp map_poly_id // => _ /Qp/vlineP[a ->] /=.\nby rewrite linearZ /= (coord_free 0) ?mulr1 // seq1_free ?oner_eq0.\nQed.",
    "Lemma algid_subproof U :\n  {e | e \\in U\n     & has_algid U ==> (U <= lker (amull e - 1) :&: lker (amulr e - 1))%VS}.\nProof.\napply: sig2W; case: has_algidP => [[e]|]; last by exists 0; rewrite ?mem0v.\ncase=> Ae _ idAe; exists e => //; apply/subvP=> u /idAe[eu_u ue_u].\nby rewrite memv_cap !memv_ker !lfun_simp /= eu_u ue_u subrr eqxx.\nQed.",
    "Lemma memv_algid U : algid U \\in U.\nProof. by rewrite /algid; case: algid_subproof. Qed.",
    "Lemma algidl A : {in A, left_id (algid A) *%R}.\nProof.\nrewrite /algid; case: algid_subproof => e _ /=; have /andP[-> _] := valP A.\nmove/subvP=> idAe u /idAe/memv_capP[].\nby rewrite memv_ker !lfun_simp /= subr_eq0 => /eqP.\nQed.",
    "Lemma algidr A : {in A, right_id (algid A) *%R}.\nProof.\nrewrite /algid; case: algid_subproof => e _ /=; have /andP[-> _] := valP A.\nmove/subvP=> idAe u /idAe/memv_capP[_].\nby rewrite memv_ker !lfun_simp /= subr_eq0 => /eqP.\nQed.",
    "Lemma unitr_algid1 A u : u \\in A -> u \\is a GRing.unit -> algid A = 1.\nProof. by move=> Eu /mulrI; apply; rewrite mulr1 algidr. Qed.",
    "Lemma algid_eq1 A : (algid A == 1) = (1 \\in A).\nProof. by apply/eqP/idP=> [<- | /algidr <-]; rewrite ?memv_algid ?mul1r. Qed.",
    "Lemma algid_neq0 A : algid A != 0.\nProof.\nhave /andP[/has_algidP[u [Au nz_u _]] _] := valP A.\nby apply: contraNneq nz_u => e0; rewrite -(algidr Au) e0 mulr0.\nQed.",
    "Lemma dim_algid A : \\dim <[algid A]> = 1%N.\nProof. by rewrite dim_vline algid_neq0. Qed.",
    "Lemma adim_gt0 A : (0 < \\dim A)%N.\nProof. by rewrite -(dim_algid A) dimvS // -memvE ?memv_algid. Qed.",
    "Lemma not_asubv0 A : ~~ (A <= 0)%VS.\nProof. by rewrite subv0 -dimv_eq0 -lt0n adim_gt0. Qed.",
    "Lemma adim1P {A} : reflect (A = <[algid A]>%VS :> {vspace aT}) (\\dim A == 1%N).\nProof.\nrewrite eqn_leq adim_gt0 -(memv_algid A) andbC -(dim_algid A) -eqEdim eq_sym.\nexact: eqP.\nQed.",
    "Lemma asubv A : (A * A <= A)%VS.\nProof. by have /andP[] := valP A. Qed.",
    "Lemma memvM A : {in A &, forall u v, u * v \\in A}.\nProof. exact/prodvP/asubv. Qed.",
    "Lemma prodv_id A : (A * A)%VS = A.\nProof.\napply/eqP; rewrite eqEsubv asubv; apply/subvP=> u Au.\nby rewrite -(algidl Au) memv_mul // memv_algid.\nQed.",
    "Lemma prodv_sub U V A : (U <= A -> V <= A -> U * V <= A)%VS.\nProof. by move=> sUA sVA; rewrite -prodv_id prodvS. Qed.",
    "Lemma expv_id A n : (A ^+ n.+1)%VS = A.\nProof. by elim: n => // n IHn; rewrite !expvSl prodvA prodv_id -expvSl. Qed.",
    "Lemma limg_amulr U v : (amulr v @: U = U * <[v]>)%VS.\nProof.\nrewrite -(span_basis (vbasisP U)) limg_span !span_def big_distrl /= big_map.\nby apply: eq_bigr => u; rewrite prodv_line lfunE.\nQed.",
    "Lemma memv_cosetP {U v w} :\n  reflect (exists2 u, u\\in U & w = u * v) (w \\in U * <[v]>)%VS.\nProof.\nrewrite -limg_amulr.\nby apply: (iffP memv_imgP) => [] [u] Uu ->; exists u; rewrite ?lfunE.\nQed.",
    "Lemma dim_cosetv_unit V u : u \\is a GRing.unit -> \\dim (V * <[u]>) = \\dim V.\nProof.\nby move/lker0_amulr/eqP=> Uu; rewrite -limg_amulr limg_dim_eq // Uu capv0.\nQed.",
    "Lemma memvV A u : (u^-1 \\in A) = (u \\in A).\nProof.\nsuffices{u} invA: invr_closed A by apply/idP/idP=> /invA; rewrite ?invrK.\nmove=> u Au; have [Uu | /invr_out-> //] := boolP (u \\is a GRing.unit).\nrewrite memvE -(limg_ker0 _ _ (lker0_amulr Uu)) limg_line lfunE /= mulVr //.\nsuff ->: (amulr u @: A)%VS = A by rewrite -memvE -algid_eq1 (unitr_algid1 Au).\nby apply/eqP; rewrite limg_amulr -dimv_leqif_eq ?prodv_sub ?dim_cosetv_unit.\nQed.",
    "Lemma centv_algid A : algid A \\in 'C(A)%VS.\nProof. by apply/centvP=> u Au; rewrite algidl ?algidr. Qed.",
    "Lemma algid_center A : algid 'Z(A) = algid A.\nProof.\nrewrite -(algidl (subvP (centerv_sub A) _ (memv_algid _))) algidr //=.\nby rewrite memv_cap memv_algid centv_algid.\nQed.",
    "Lemma Falgebra_FieldMixin :\n  GRing.integral_domain_axiom aT -> GRing.field_axiom aT.\nProof.\nmove=> domT u nz_u; apply/unitrP.\nhave kerMu: lker (amulr u) == 0%VS.\n  rewrite eqEsubv sub0v andbT; apply/subvP=> v; rewrite memv_ker lfunE /=.\n  by move/eqP/domT; rewrite (negPf nz_u) orbF memv0.\nhave /memv_imgP[v _ vu1]: 1 \\in limg (amulr u); last rewrite lfunE /= in vu1.\n  suffices /eqP->: limg (amulr u) == fullv by rewrite memvf.\n  by rewrite -dimv_leqif_eq ?subvf ?limg_dim_eq // (eqP kerMu) capv0.\nexists v; split=> //; apply: (lker0P kerMu).\nby rewrite !lfunE /= -mulrA -vu1 mulr1 mul1r.\nQed.",
    "Lemma skew_field_algid1 A : algid A = 1.\nProof. by rewrite (unitr_algid1 (memv_algid A)) ?fieldT ?algid_neq0. Qed.",
    "Lemma skew_field_module_semisimple A M :\n  let sumA X := (\\sum_(x <- X) A * <[x]>)%VS in\n  (A * M <= M)%VS -> {X | [/\\ sumA X = M, directv (sumA X) & 0 \\notin X]}.\nProof.\nmove=> sumA sAM_M; pose X := Nil aT; pose k := (\\dim (A * M) - \\dim (sumA X))%N.\nhave: (\\dim (A * M) - \\dim (sumA X) < k.+1)%N by [].\nhave: [/\\ (sumA X <= A * M)%VS, directv (sumA X) & 0 \\notin X].\n  by rewrite /sumA directvE /= !big_nil sub0v dimv0.\nelim: {X k}k.+1 (X) => // k IHk X [sAX_AM dxAX nzX]; rewrite ltnS => leAXk.\nhave [sM_AX | /subvPn/sig2W[y My notAXy]] := boolP (M <= sumA X)%VS.\n  by exists X; split=> //; apply/eqP; rewrite eqEsubv (subv_trans sAX_AM).\nhave nz_y: y != 0 by rewrite (memPnC notAXy) ?mem0v.\npose AY := sumA (y :: X).\nhave sAY_AM: (AY <= A * M)%VS by rewrite [AY]big_cons subv_add ?prodvSr.\nhave dxAY: directv AY.\n  rewrite directvE /= !big_cons [_ == _]directv_addE dxAX directvE eqxx /=.\n  rewrite -/(sumA X) eqEsubv sub0v andbT -limg_amulr.\n  apply/subvP=> _ /memv_capP[/memv_imgP[a Aa ->]]/[!lfunE]/= AXay.\n  rewrite memv0 (mulIr_eq0 a (mulIr _)) ?fieldT //.\n  apply: contraR notAXy => /fieldT-Ua; rewrite -[y](mulKr Ua) /sumA.\n  by rewrite -big_distrr -(prodv_id A) /= -prodvA big_distrr memv_mul ?memvV.\napply: (IHk (y :: X)); first by rewrite !inE eq_sym negb_or nz_y.\nrewrite -subSn ?dimvS // (directvP dxAY) /= big_cons -(directvP dxAX) /=.\nrewrite subnDA (leq_trans _ leAXk) ?leq_sub2r // leq_subLR -add1n leq_add2r.\nby rewrite dim_cosetv_unit ?fieldT ?adim_gt0.\nQed.",
    "Lemma skew_field_module_dimS A M : (A * M <= M)%VS -> \\dim A %| \\dim M.\nProof.\ncase/skew_field_module_semisimple=> X [<- /directvP-> nzX] /=.\nrewrite big_seq prime.dvdn_sum // => x /(memPn nzX)nz_x.\nby rewrite dim_cosetv_unit ?fieldT.\nQed.",
    "Lemma skew_field_dimS A B : (A <= B)%VS -> \\dim A %| \\dim B.\nProof. by move=> sAB; rewrite skew_field_module_dimS ?prodv_sub. Qed.",
    "Lemma agenvEl U : agenv U = (1 + U * agenv U)%VS.\nProof.\npose f V := (1 + U * V)%VS; rewrite -/(f _); pose n := \\dim {:aT}.\nhave ->: agenv U = iter n f 0%VS.\n  rewrite /agenv -/n; elim: n => [|n IHn]; first by rewrite big_ord0.\n  rewrite big_ord_recl /= -{}IHn; congr (1 + _)%VS; rewrite big_distrr /=.\n  by apply: eq_bigr => i; rewrite expvSl.\nhave fS i j: i <= j -> (iter i f 0 <= iter j f 0)%VS.\n  by elim: i j => [|i IHi] [|j] leij; rewrite ?sub0v //= addvS ?prodvSr ?IHi.\nsuffices /(@trajectP _ f _ n.+1)[i le_i_n Dfi]: looping f 0%VS n.+1.\n  by apply/eqP; rewrite eqEsubv -iterS fS // Dfi fS.\napply: contraLR (dimvS (subvf (iter n.+1 f 0%VS))); rewrite -/n -ltnNge.\nrewrite -looping_uniq; elim: n.+1 => // i IHi; rewrite trajectSr rcons_uniq.\nrewrite {1}trajectSr mem_rcons inE negb_or eq_sym eqEdim fS ?leqW // -ltnNge.\nby rewrite -andbA => /and3P[lt_fi _ /IHi/leq_ltn_trans->].\nQed.",
    "Lemma agenvEr U : agenv U = (1 + agenv U * U)%VS.\nProof.\nrewrite [lhs in lhs = _]agenvEl big_distrr big_distrl /=; congr (_ + _)%VS.\nby apply: eq_bigr => i _ /=; rewrite -expvSr -expvSl.\nQed.",
    "Lemma agenv_modl U V : (U * V <= V -> agenv U * V <= V)%VS.\nProof.\nrewrite big_distrl /= => idlU_V; apply/subv_sumP=> [[i _] /= _].\nelim: i => [|i]; first by rewrite expv0 prod1v.\nby apply: subv_trans; rewrite expvSr -prodvA prodvSr.\nQed.",
    "Lemma agenv_modr U V : (V * U <= V -> V * agenv U <= V)%VS.\nProof.\nrewrite big_distrr /= => idrU_V; apply/subv_sumP=> [[i _] /= _].\nelim: i => [|i]; first by rewrite expv0 prodv1.\nby apply: subv_trans; rewrite expvSl prodvA prodvSl.\nQed.",
    "Lemma agenvE U : agenv U = agenv_aspace U. Proof. by []. Qed.",
    "Lemma agenvM U : (agenv U * agenv U)%VS = agenv U. Proof. exact: prodv_id. Qed.",
    "Lemma agenvX n U : (agenv U ^+ n.+1)%VS = agenv U. Proof. exact: expv_id. Qed.",
    "Lemma sub1_agenv U : (1 <= agenv U)%VS. Proof. by rewrite agenvEl addvSl. Qed.",
    "Lemma sub_agenv U : (U <= agenv U)%VS.\nProof. by rewrite 2!agenvEl addvC prodvDr prodv1 -addvA addvSl. Qed.",
    "Lemma subX_agenv U n : (U ^+ n <= agenv U)%VS.\nProof.\nby case: n => [|n]; rewrite ?sub1_agenv // -(agenvX n) expvS // sub_agenv.\nQed.",
    "Lemma agenv_sub_modl U V : (1 <= V -> U * V <= V -> agenv U <= V)%VS.\nProof.\nmove=> s1V /agenv_modl; apply: subv_trans.\nby rewrite -[Us in (Us <= _)%VS]prodv1 prodvSr.\nQed.",
    "Lemma agenv_sub_modr U V : (1 <= V -> V * U <= V -> agenv U <= V)%VS.\nProof.\nmove=> s1V /agenv_modr; apply: subv_trans.\nby rewrite -[Us in (Us <= _)%VS]prod1v prodvSl.\nQed.",
    "Lemma agenv_id U : agenv (agenv U) = agenv U.\nProof.\napply/eqP; rewrite eqEsubv sub_agenv andbT.\nby rewrite agenv_sub_modl ?sub1_agenv ?agenvM.\nQed.",
    "Lemma agenvS U V : (U <= V -> agenv U <= agenv V)%VS.\nProof.\nmove=> sUV; rewrite agenv_sub_modl ?sub1_agenv //.\nby rewrite -[Vs in (_ <= Vs)%VS]agenvM prodvSl ?(subv_trans sUV) ?sub_agenv.\nQed.",
    "Lemma agenv_add_id U V : agenv (agenv U + V) = agenv (U + V).\nProof.\napply/eqP; rewrite eqEsubv andbC agenvS ?addvS ?sub_agenv //=.\nrewrite agenv_sub_modl ?sub1_agenv //.\nrewrite -[rhs in (_ <= rhs)%VS]agenvM prodvSl // subv_add agenvS ?addvSl //=.\nexact: subv_trans (addvSr U V) (sub_agenv _).\nQed.",
    "Lemma subv_adjoin U x : (U <= <<U; x>>)%VS.\nProof. by rewrite (subv_trans (sub_agenv _)) ?agenvS ?addvSl. Qed.",
    "Lemma subv_adjoin_seq U xs : (U <= <<U & xs>>)%VS.\nProof. by rewrite (subv_trans (sub_agenv _)) // ?agenvS ?addvSl. Qed.",
    "Lemma memv_adjoin U x : x \\in <<U; x>>%VS.\nProof. by rewrite memvE (subv_trans (sub_agenv _)) ?agenvS ?addvSr. Qed.",
    "Lemma seqv_sub_adjoin U xs : {subset xs <= <<U & xs>>%VS}.\nProof.\nby apply/span_subvP; rewrite (subv_trans (sub_agenv _)) ?agenvS ?addvSr.\nQed.",
    "Lemma subvP_adjoin U x y : y \\in U -> y \\in <<U; x>>%VS.\nProof. exact/subvP/subv_adjoin. Qed.",
    "Lemma adjoin_nil V : <<V & [::]>>%VS = agenv V.\nProof. by rewrite span_nil addv0. Qed.",
    "Lemma adjoin_cons V x rs : <<V & x :: rs>>%VS = << <<V; x>> & rs>>%VS.\nProof. by rewrite span_cons addvA agenv_add_id. Qed.",
    "Lemma adjoin_rcons V rs x : <<V & rcons rs x>>%VS = << <<V & rs>>%VS; x>>%VS.\nProof. by rewrite -cats1 span_cat addvA span_seq1 agenv_add_id. Qed.",
    "Lemma adjoin_seq1 V x : <<V & [:: x]>>%VS = <<V; x>>%VS.\nProof. by rewrite adjoin_cons adjoin_nil agenv_id. Qed.",
    "Lemma adjoinC V x y : << <<V; x>>; y>>%VS = << <<V; y>>; x>>%VS.\nProof. by rewrite !agenv_add_id -!addvA (addvC <[x]>%VS). Qed.",
    "Lemma adjoinSl U V x : (U <= V -> <<U; x>> <= <<V; x>>)%VS.\nProof. by move=> sUV; rewrite agenvS ?addvS. Qed.",
    "Lemma adjoin_seqSl U V rs : (U <= V -> <<U & rs>> <= <<V & rs>>)%VS.\nProof. by move=> sUV; rewrite agenvS ?addvS. Qed.",
    "Lemma adjoin_seqSr U rs1 rs2 :\n  {subset rs1 <= rs2} -> (<<U & rs1>> <= <<U & rs2>>)%VS.\nProof. by move/sub_span=> s_rs12; rewrite agenvS ?addvS. Qed.",
    "Lemma subvs_scaleAl k (x y : subvs_of A) : k *: (x * y) = (k *: x) * y.\nProof. exact/val_inj/scalerAl. Qed.",
    "Lemma subvs_scaleAr k (x y : subvs_of A) : k *: (x * y) = x * (k *: y).\nProof. exact/val_inj/scalerAr. Qed.",
    "Lemma vsval_unitr w : vsval w \\is a GRing.unit -> w \\is a GRing.unit.\nProof.\ncase: w => /= u Au Uu; have Au1: u^-1 \\in A by rewrite memvV.\napply/unitrP; exists (Subvs Au1).\nby split; apply: val_inj; rewrite /= ?mulrV ?mulVr ?(unitr_algid1 Au).\nQed.",
    "Lemma vsval_invr w : vsval w \\is a GRing.unit -> val w^-1 = (val w)^-1.\nProof.\nmove=> Uu; have def_w: w / w * w = w by rewrite divrK ?vsval_unitr.\nby apply: (mulrI Uu); rewrite -[in u in u / _]def_w ?mulrK.\nQed.",
    "Lemma ahom_inP {f : 'Hom(aT, rT)} {U : {vspace aT}} :\n  reflect ({in U &, {morph f : x y / x * y >-> x * y}} * (f 1 = 1))\n          (ahom_in U f).\nProof.\napply: (iffP andP) => [[/allrelP fM /eqP f1] | [fM f1]]; last first.\n  rewrite f1; split=> //; apply/allrelP => x y Ax Ay.\n  by rewrite fM // vbasis_mem.\nsplit=> // x y /coord_vbasis -> /coord_vbasis ->.\nrewrite !mulr_suml ![f _]linear_sum mulr_suml; apply: eq_bigr => i _ /=.\nrewrite !mulr_sumr linear_sum; apply: eq_bigr => j _ /=.\nrewrite !linearZ -!scalerAr -!scalerAl 2!linearZ /=; congr (_ *: (_ *: _)).\nby apply/eqP/fM; apply: memt_nth.\nQed.",
    "Lemma ahomP {f : 'Hom(aT, rT)} : reflect (multiplicative f) (ahom_in {:aT} f).\nProof.\napply: (iffP ahom_inP) => [[fM f1] | fRM_P]; last first.\n  by split=> [x y|]; [rewrite fRM_P.1|rewrite fRM_P.2].\nby split=> // x y; rewrite fM ?memvf.\nQed.",
    "Lemma ahomWin (f : ahom aT rT) U : ahom_in U f.\nProof.\nby apply/ahom_inP; split; [apply: in2W (rmorphM _) | apply: rmorph1].\nQed.",
    "Lemma id_is_ahom (V : {vspace aT}) : ahom_in V \\1.\nProof. by apply/ahom_inP; split=> [x y|] /=; rewrite !id_lfunE. Qed.",
    "Lemma comp_is_ahom (V : {vspace aT}) (f : 'Hom(rT, sT)) (g : 'Hom(aT, rT)) :\n  ahom_in {:rT} f -> ahom_in V g -> ahom_in V (f \\o g).\nProof.\nmove=> /ahom_inP fM /ahom_inP gM; apply/ahom_inP.\nby split=> [x y Vx Vy|] /=; rewrite !comp_lfunE gM // fM ?memvf.\nQed.",
    "Lemma aimgM (f : ahom aT rT) U V : (f @: (U * V) = f @: U * f @: V)%VS.\nProof.\napply/eqP; rewrite eqEsubv; apply/andP; split; last first.\n  apply/prodvP=> _ _ /memv_imgP[u Hu ->] /memv_imgP[v Hv ->].\n  by rewrite -rmorphM memv_img // memv_mul.\napply/subvP=> _ /memv_imgP[w UVw ->]; rewrite memv_preim (subvP _ w UVw) //.\nby apply/prodvP=> u v Uu Vv; rewrite -memv_preim rmorphM memv_mul // memv_img.\nQed.",
    "Lemma aimg1 (f : ahom aT rT) : (f @: 1 = 1)%VS.\nProof. by rewrite limg_line rmorph1. Qed.",
    "Lemma aimgX (f : ahom aT rT) U n : (f @: (U ^+ n) = f @: U ^+ n)%VS.\nProof.\nelim: n => [|n IH]; first by rewrite !expv0 aimg1.\nby rewrite !expvSl aimgM IH.\nQed.",
    "Lemma aimg_agen (f : ahom aT rT) U : (f @: agenv U)%VS = agenv (f @: U).\nProof.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  by rewrite limg_sum; apply/subv_sumP => i _; rewrite aimgX subX_agenv.\napply: agenv_sub_modl; first by rewrite -(aimg1 f) limgS // sub1_agenv.\nby rewrite -aimgM limgS // [rhs in (_ <= rhs)%VS]agenvEl addvSr.\nQed.",
    "Lemma aimg_adjoin (f : ahom aT rT) U x : (f @: <<U; x>> = <<f @: U; f x>>)%VS.\nProof. by rewrite aimg_agen limgD limg_line. Qed.",
    "Lemma aimg_adjoin_seq (f : ahom aT rT) U xs :\n  (f @: <<U & xs>> = <<f @: U & map f xs>>)%VS.\nProof. by rewrite aimg_agen limgD limg_span. Qed.",
    "Lemma derg0 A : A^`(0) = A. Proof. by []. Qed.",
    "Lemma derg1 A : A^`(1) = [~: A, A]. Proof. by []. Qed.",
    "Lemma dergSn n A : A^`(n.+1) = [~: A^`(n), A^`(n)]. Proof. by []. Qed.",
    "Lemma der_group_set G n : group_set G^`(n).\nProof. by case: n => [|n]; apply: groupP. Qed.",
    "Lemma conjg_mulR x y : x ^ y = x * [~ x, y].\nProof. by rewrite mulKVg. Qed.",
    "Lemma conjg_Rmul x y : x ^ y = [~ y, x^-1] * x.\nProof. by rewrite commgEr invgK mulgKV. Qed.",
    "Lemma commMgJ x y z : [~ x * y, z] = [~ x, z] ^ y * [~ y, z].\nProof. by rewrite !commgEr conjgM mulgA -conjMg mulgK. Qed.",
    "Lemma commgMJ x y z : [~ x, y * z] = [~ x, z] * [~ x, y] ^ z.\nProof. by rewrite !commgEl conjgM -mulgA -conjMg mulKVg. Qed.",
    "Lemma commMgR x y z : [~ x * y, z] = [~ x, z] * [~ x, z, y] * [~ y, z].\nProof. by rewrite commMgJ conjg_mulR. Qed.",
    "Lemma commgMR x y z : [~ x, y * z] = [~ x, z] * [~ x, y] * [~ x, y, z].\nProof. by rewrite commgMJ conjg_mulR mulgA. Qed.",
    "Lemma Hall_Witt_identity x y z :\n  [~ x, y^-1, z] ^ y * [~ y, z^-1, x] ^ z * [~ z, x^-1, y] ^ x = 1.\nProof. \npose a x y z : gT := x * z * y ^ x.\nsuffices{x y z} hw_aux x y z: [~ x, y^-1, z] ^ y = (a x y z)^-1 * (a y z x).\n  by rewrite !hw_aux 2!mulgA !mulgK mulVg.\nby rewrite commgEr conjMg -conjgM -conjg_Rmul 2!invMg conjgE !mulgA.\nQed.",
    "Lemma commVg : [~ x^-1, y] = [~ x, y]^-1.\nProof.\napply/eqP; rewrite commgEl eq_sym eq_invg_mul invgK mulgA -cxz.\nby rewrite -conjg_mulR -conjMg mulgV conj1g.\nQed.",
    "Lemma commXg : [~ x ^+ i, y] = [~ x, y] ^+ i.\nProof.\nelim: i => [|i' IHi]; first exact: comm1g.\nby rewrite !expgS commMgJ /conjg commuteX // mulKg IHi.\nQed.",
    "Lemma commgV : [~ x, y^-1] = [~ x, y]^-1.\nProof. by rewrite -invg_comm commVg -(invg_comm x y) ?invgK. Qed.",
    "Lemma commgX : [~ x, y ^+ i] = [~ x, y] ^+ i.\nProof. by rewrite -invg_comm commXg -(invg_comm x y) ?expgVn ?invgK. Qed.",
    "Lemma commXXg : [~ x ^+ i, y ^+ j] = [~ x, y] ^+ (i * j).\nProof. by rewrite expgM commgX commXg //; apply: commuteX. Qed.",
    "Lemma expMg_Rmul : (y * x) ^+ i = y ^+ i * x ^+ i * [~ x, y] ^+ 'C(i, 2).\nProof.\nrewrite -bin2_sum; symmetry.\nelim: i => [|k IHk] /=; first by rewrite big_geq ?mulg1.\nrewrite big_nat_recr //= addnC expgD !expgS -{}IHk !mulgA; congr (_ * _).\nby rewrite -!mulgA commuteX2 // -commgX // [mulg y]lock 3!mulgA -commgC.\nQed.",
    "Lemma commG1 A : [~: A, 1] = 1.\nProof. by apply/commG1P; rewrite centsC sub1G. Qed.",
    "Lemma comm1G A : [~: 1, A] = 1.\nProof. by rewrite commGC commG1. Qed.",
    "Lemma commg_sub A B : [~: A, B] \\subset A <*> B.\nProof. by rewrite comm_subG // (joing_subl, joing_subr). Qed.",
    "Lemma commg_norml G A : G \\subset 'N([~: G, A]).\nProof.\napply/subsetP=> x Gx; rewrite inE -genJ gen_subG.\napply/subsetP=> _ /imsetP[_ /imset2P[y z Gy Az ->] ->].\nby rewrite -(mulgK [~ x, z] (_ ^ x)) -commMgJ !(mem_commg, groupMl, groupV).\nQed.",
    "Lemma commg_normr G A : G \\subset 'N([~: A, G]).\nProof. by rewrite commGC commg_norml. Qed.",
    "Lemma commg_norm G H : G <*> H \\subset 'N([~: G, H]).\nProof. by rewrite join_subG ?commg_norml ?commg_normr. Qed.",
    "Lemma commg_normal G H : [~: G, H] <| G <*> H.\nProof. by rewrite /(_ <| _) commg_sub commg_norm. Qed.",
    "Lemma normsRl A G B : A \\subset G -> A \\subset 'N([~: G, B]).\nProof. by move=> sAG; apply: subset_trans (commg_norml G B). Qed.",
    "Lemma normsRr A G B : A \\subset G -> A \\subset 'N([~: B, G]).\nProof. by move=> sAG; apply: subset_trans (commg_normr G B). Qed.",
    "Lemma commg_subr G H : ([~: G, H] \\subset H) = (G \\subset 'N(H)).\nProof.\nrewrite gen_subG; apply/subsetP/subsetP=> [sRH x Gx | nGH xy].\n  rewrite inE; apply/subsetP=> _ /imsetP[y Ky ->].\n  by rewrite conjg_Rmul groupMr // sRH // imset2_f ?groupV.\ncase/imset2P=> x y Gx Hy ->{xy}.\nby rewrite commgEr groupMr // memJ_norm (groupV, nGH).\nQed.",
    "Lemma commg_subl G H : ([~: G, H] \\subset G) = (H \\subset 'N(G)).\nProof. by rewrite commGC commg_subr. Qed.",
    "Lemma commg_subI A B G H :\n  A \\subset 'N_G(H) -> B \\subset 'N_H(G) -> [~: A, B] \\subset G :&: H.\nProof.\nrewrite !subsetI -(gen_subG _ 'N(G)) -(gen_subG _ 'N(H)).\nrewrite -commg_subr -commg_subl; case/andP=> sAG sRH; case/andP=> sBH sRG.\nby rewrite (subset_trans _ sRG) ?(subset_trans _ sRH) ?commgSS ?subset_gen.\nQed.",
    "Lemma quotient_cents2 A B K :\n    A \\subset 'N(K) -> B \\subset 'N(K) ->\n  (A / K \\subset 'C(B / K)) = ([~: A, B] \\subset K).\nProof.\nmove=> nKA nKB.\nby rewrite (sameP commG1P trivgP) /= -quotientR // quotient_sub1 // comm_subG.\nQed.",
    "Lemma quotient_cents2r A B K :\n  [~: A, B] \\subset K -> (A / K) \\subset 'C(B / K).\nProof.\nmove=> sABK; rewrite -2![_ / _]morphimIdom -!quotientE.\nby rewrite quotient_cents2 ?subsetIl ?(subset_trans _ sABK) ?commgSS ?subsetIr.\nQed.",
    "Lemma sub_der1_norm G H : G^`(1) \\subset H -> H \\subset G -> G \\subset 'N(H).\nProof.\nby move=> sG'H sHG; rewrite -commg_subr (subset_trans _ sG'H) ?commgS.\nQed.",
    "Lemma sub_der1_normal G H : G^`(1) \\subset H -> H \\subset G -> H <| G.\nProof. by move=> sG'H sHG; rewrite /(H <| G) sHG sub_der1_norm. Qed.",
    "Lemma sub_der1_abelian G H : G^`(1) \\subset H -> abelian (G / H).\nProof. by move=> sG'H; apply: quotient_cents2r. Qed.",
    "Lemma der1_min G H : G \\subset 'N(H) -> abelian (G / H) -> G^`(1) \\subset H.\nProof. by move=> nHG abGH; rewrite -quotient_cents2. Qed.",
    "Lemma der_abelian n G : abelian (G^`(n) / G^`(n.+1)).\nProof. by rewrite sub_der1_abelian // der_subS. Qed.",
    "Lemma commg_normSl G H K : G \\subset 'N(H) -> [~: G, H] \\subset 'N([~: K, H]).\nProof. by move=> nHG; rewrite normsRr // commg_subr. Qed.",
    "Lemma commg_normSr G H K : G \\subset 'N(H) -> [~: H, G] \\subset 'N([~: H, K]).\nProof. by move=> nHG; rewrite !(commGC H) commg_normSl. Qed.",
    "Lemma commMGr G H K : [~: G, K] * [~: H, K] \\subset [~: G * H , K].\nProof. by rewrite mul_subG ?commSg ?(mulG_subl, mulG_subr). Qed.",
    "Lemma commMG G H K :\n  H \\subset 'N([~: G, K]) -> [~: G * H , K] = [~: G, K] * [~: H, K].\nProof.\nmove=> nRH; apply/eqP; rewrite eqEsubset commMGr andbT.\nhave nRHK: [~: H, K] \\subset 'N([~: G, K]) by rewrite comm_subG ?commg_normr.\nhave defM := norm_joinEr nRHK; rewrite -defM gen_subG /=.\napply/subsetP=> _ /imset2P[_ z /imset2P[x y Gx Hy ->] Kz ->].\nby rewrite commMgJ {}defM mem_mulg ?memJ_norm ?mem_commg // (subsetP nRH).\nQed.",
    "Lemma comm3G1P A B C :\n  reflect {in A & B & C, forall h k l, [~ h, k, l] = 1} ([~: A, B, C] :==: 1).\nProof.\nhave R_C := sameP trivgP commG1P.\nrewrite -subG1 R_C gen_subG -{}R_C gen_subG.\napply: (iffP subsetP) => [cABC x y z Ax By Cz | cABC xyz].\n  by apply/set1P; rewrite cABC // !imset2_f.\nby case/imset2P=> _ z /imset2P[x y Ax By ->] Cz ->; rewrite cABC.\nQed.",
    "Lemma three_subgroup G H K :\n  [~: G, H, K] :=: 1 -> [~: H, K, G] :=: 1-> [~: K, G, H] :=: 1.\nProof.\nmove/eqP/comm3G1P=> cGHK /eqP/comm3G1P cHKG.\napply/eqP/comm3G1P=> x y z Kx Gy Hz; symmetry.\nrewrite -(conj1g y) -(Hall_Witt_identity y^-1 z x) invgK.\nby rewrite cGHK ?groupV // cHKG ?groupV // !conj1g !mul1g conjgKV.\nQed.",
    "Lemma der1_joing_cycles (x y : gT) : \n  let XY := <[x]> <*> <[y]> in let xy := [~ x, y] in\n  xy \\in 'C(XY) -> XY^`(1) = <[xy]>.\nProof.\nrewrite joing_idl joing_idr /= -sub_cent1 => /norms_gen nRxy.\napply/eqP; rewrite eqEsubset cycle_subG mem_commg ?mem_gen ?set21 ?set22 //.\nrewrite der1_min // quotient_gen -1?gen_subG // quotientU abelian_gen.\nrewrite /abelian subUset centU !subsetI andbC centsC -andbA -!abelianE.\nrewrite !quotient_abelian ?(abelianS (subset_gen _) (cycle_abelian _)) //=.\nby rewrite andbb quotient_cents2r ?genS // /commg_set imset2_set1l imset_set1.\nQed.",
    "Lemma commgAC G x y z : x \\in G -> y \\in G -> z \\in G ->\n  commute y z -> abelian [~: [set x], G] -> [~ x, y, z] = [~ x, z, y].\nProof.\nmove=> Gx Gy Gz cyz /centsP cRxG; pose cx' u := [~ x^-1, u].\nhave xR3 u v: [~ x, u, v] = x^-1 * (cx' u * cx' v) * x ^ (u * v).\n  rewrite mulgA -conjg_mulR conjVg [cx' v]commgEl mulgA -invMg.\n  by rewrite -mulgA conjgM -conjMg -!commgEl.\nsuffices RxGcx' u: u \\in G -> cx' u \\in [~: [set x], G].\n  by rewrite !xR3 {}cyz; congr (_ * _ * _); rewrite cRxG ?RxGcx'.\nmove=> Gu; suffices/groupMl <-: [~ x, u] ^ x^-1 \\in [~: [set x], G].\n  by rewrite -commMgJ mulgV comm1g group1.\nby rewrite memJ_norm ?mem_commg ?set11 // groupV (subsetP (commg_normr _ _)).\nQed.",
    "Lemma comm_norm_cent_cent H G K :\n    H \\subset 'N(G) -> H \\subset 'C(K) -> G \\subset 'N(K) ->\n  [~: G, H] \\subset 'C(K).\nProof.\nmove=> nGH /centsP cKH nKG; rewrite commGC gen_subG centsC.\napply/centsP=> x Kx _ /imset2P[y z Hy Gz ->]; red.\nrewrite mulgA -[x * _]cKH ?groupV // -!mulgA; congr (_ * _).\nrewrite (mulgA x) (conjgC x) (conjgCV z) 3!mulgA; congr (_ * _).\nby rewrite -2!mulgA (cKH y) // -mem_conjg (normsP nKG).\nQed.",
    "Lemma charR H K G : H \\char G -> K \\char G -> [~: H, K] \\char G.\nProof.\ncase/charP=> sHG chH /charP[sKG chK]; apply/charP.\nby split=> [|f infj Gf]; [rewrite comm_subG | rewrite morphimR // chH // chK].\nQed.",
    "Lemma der_char n G : G^`(n) \\char G.\nProof. by elim: n => [|n IHn]; rewrite ?char_refl // dergSn charR. Qed.",
    "Lemma der_sub n G : G^`(n) \\subset G.\nProof. by rewrite char_sub ?der_char. Qed.",
    "Lemma der_norm n G : G \\subset 'N(G^`(n)).\nProof. by rewrite char_norm ?der_char. Qed.",
    "Lemma der_normal n G : G^`(n) <| G.\nProof. by rewrite char_normal ?der_char. Qed.",
    "Lemma der_subS n G : G^`(n.+1) \\subset G^`(n).\nProof. by rewrite comm_subG. Qed.",
    "Lemma der_normalS n G : G^`(n.+1) <| G^`(n).\nProof. by rewrite sub_der1_normal // der_subS. Qed.",
    "Lemma morphim_der rT D (f : {morphism D >-> rT}) n G :\n   G \\subset D -> f @* G^`(n) = (f @* G)^`(n).\nProof.\nmove=> sGD; elim: n => // n IHn.\nby rewrite !dergSn -IHn morphimR ?(subset_trans (der_sub n G)).\nQed.",
    "Lemma dergS n G H : G \\subset H -> G^`(n) \\subset H^`(n).\nProof. by move=> sGH; elim: n => // n IHn; apply: commgSS. Qed.",
    "Lemma quotient_der n G H : G \\subset 'N(H) -> G^`(n) / H = (G / H)^`(n).\nProof. exact: morphim_der. Qed.",
    "Lemma derJ G n x : (G :^ x)^`(n) = G^`(n) :^ x.\nProof. by elim: n => //= n IHn; rewrite !dergSn IHn -conjsRg. Qed.",
    "Lemma derG1P G : reflect (G^`(1) = 1) (abelian G).\nProof. exact: commG1P. Qed.",
    "Lemma der_cont n : GFunctor.continuous (@derived_at n).\nProof. by move=> aT rT G f; rewrite morphim_der. Qed.",
    "Lemma isog_der (aT rT : finGroupType) n (G : {group aT}) (H : {group rT}) :\n  G \\isog H -> G^`(n) \\isog H^`(n).\nProof. exact: gFisog. Qed.",
    "Lemma subnormalP H G :\n  reflect (exists2 s, normal.-series H s & last H s = G) (H <|<| G).\nProof.\napply: (iffP andP) => [[sHG snHG] | [s Hsn <-{G}]].\n  move: #|G| snHG => m; elim: m => [|m IHm] in G sHG *.\n    by exists [::]; last by apply/eqP; rewrite eq_sym.\n  rewrite iterSr => /IHm[|s Hsn defG].\n    by rewrite sub_gen // class_supportEr (bigD1 1) //= conjsg1 subsetUl.\n  exists (rcons s G); rewrite ?last_rcons // -cats1 cat_path Hsn defG /=.\n  rewrite /normal gen_subG class_support_subG //=.\n  by rewrite norms_gen ?class_support_norm.\nset f := fun _ => <<_>>; have idf: iter _ f H == H.\n  by elim=> //= m IHm; rewrite (eqP IHm) /f class_support_id genGid.\nhave [m] := ubnP (size s); elim: m s Hsn => // m IHm /lastP[//|s G].\nrewrite size_rcons last_rcons rcons_path /= ltnS.\nset K := last H s => /andP[Hsn /andP[sKG nKG]] lt_s_m.\nhave /[1!subEproper]/predU1P[<-|prKG] := sKG; first exact: IHm.\npose L := [group of f G].\nhave sHK: H \\subset K by case/IHm: Hsn.\nhave sLK: L \\subset K by rewrite gen_subG class_support_sub_norm.\nrewrite -(subnK (proper_card (sub_proper_trans sLK prKG))) iterD iterSr.\nhave defH: H = setIgr L H by rewrite -sub_setIgr ?sub_gen ?sub_class_support.\nhave: normal.-series H (map (setIgr L) s) by rewrite defH path_setIgr.\ncase/IHm=> [|_]; first by rewrite size_map.\nrewrite [in last _]defH last_map (subset_trans sHK) //=.\nby rewrite (setIidPr sLK) => /eqP->.\nQed.",
    "Lemma subnormal_refl G : G <|<| G.\nProof. by apply/subnormalP; exists [::]. Qed.",
    "Lemma subnormal_trans K H G : H <|<| K -> K <|<| G -> H <|<| G.\nProof.\ncase/subnormalP=> [s1 Hs1 <-] /subnormalP[s2 Hs12 <-].\nby apply/subnormalP; exists (s1 ++ s2); rewrite ?last_cat // cat_path Hs1.\nQed.",
    "Lemma normal_subnormal H G : H <| G -> H <|<| G.\nProof. by move=> nsHG; apply/subnormalP; exists [:: G]; rewrite //= nsHG. Qed.",
    "Lemma setI_subnormal G H K : K \\subset G -> H <|<| G -> H :&: K <|<| K.\nProof.\nmove=> sKG /subnormalP[s Hs defG]; apply/subnormalP.\nexists (map (setIgr K) s); first exact: path_setIgr.\nrewrite (last_map (setIgr K)) defG.\nby apply: val_inj; rewrite /= (setIidPr sKG).\nQed.",
    "Lemma subnormal_sub G H : H <|<| G -> H \\subset G.\nProof. by case/andP. Qed.",
    "Lemma invariant_subnormal A G H :\n    A \\subset 'N(G) -> A \\subset 'N(H) -> H <|<| G ->\n  exists2 s, (A.-invariant).-series H s & last H s = G.\nProof.\nmove=> nGA nHA /andP[]; move: #|G| => m.\nelim: m => [|m IHm] in G nGA * => sHG.\n  by rewrite eq_sym; exists [::]; last apply/eqP.\nrewrite iterSr; set K := <<_>>.\nhave nKA: A \\subset 'N(K) by rewrite norms_gen ?norms_class_support.\nhave sHK: H \\subset K by rewrite sub_gen ?sub_class_support.\ncase/IHm=> // s Hsn defK; exists (rcons s G); last by rewrite last_rcons.\nrewrite rcons_path Hsn !andbA defK nGA nKA /= -/K.\nby rewrite gen_subG class_support_subG ?norms_gen ?class_support_norm.\nQed.",
    "Lemma subnormalEsupport G H :\n  H <|<| G -> H :=: G \\/ <<class_support H G>> \\proper G.\nProof.\ncase/andP=> sHG; set K := <<_>> => /eqP <-.\nhave: K \\subset G by rewrite gen_subG class_support_subG.\nrewrite subEproper; case/predU1P=> [defK|]; [left | by right].\nby elim: #|G| => //= _ ->.\nQed.",
    "Lemma subnormalEr G H : H <|<| G -> \n  H :=: G \\/ (exists K : {group gT}, [/\\ H <|<| K, K <| G & K \\proper G]).\nProof.\ncase/subnormalP=> s Hs <-{G}.\nelim/last_ind: s Hs => [|s G IHs]; first by left.\nrewrite last_rcons -cats1 cat_path /= andbT; set K := last H s.\ncase/andP=> Hs nsKG; have /[1!subEproper] := normal_sub nsKG.\ncase/predU1P=> [<- | prKG]; [exact: IHs | right; exists K; split=> //].\nby apply/subnormalP; exists s.\nQed.",
    "Lemma subnormalEl G H : H <|<| G ->\n  H :=: G \\/ (exists K : {group gT}, [/\\ H <| K, K <|<| G & H \\proper K]).\nProof.\ncase/subnormalP=> s Hs <-{G}; elim: s H Hs => /= [|K s IHs] H; first by left.\ncase/andP=> nsHK Ks; have /[1!subEproper] := normal_sub nsHK.\ncase/predU1P=> [-> | prHK]; [exact: IHs | right; exists K; split=> //].\nby apply/subnormalP; exists s.\nQed.",
    "Lemma morphim_subnormal (rT : finGroupType) G (f : {morphism G >-> rT}) H K :\n  H <|<| K -> f @* H <|<| f @* K.\nProof.\ncase/subnormalP => s Hs <-{K}; apply/subnormalP.\nelim: s H Hs => [|K s IHs] H /=; first by exists [::].\ncase/andP=> nsHK /IHs[fs Hfs <-].\nby exists ([group of f @* K] :: fs); rewrite /= ?morphim_normal.\nQed.",
    "Lemma quotient_subnormal H G K : G <|<| K -> G / H <|<| K / H.\nProof. exact: morphim_subnormal. Qed.",
    "Lemma maximal_eqP M G :\n  reflect (M \\subset G  /\\\n             forall H, M \\subset H -> H \\subset G -> H :=: M \\/ H :=: G)\n       (maximal_eq M G).\nProof.\nrewrite subEproper /maximal_eq; case: eqP => [->|_]; first left.\n  by split=> // H sGH sHG; right; apply/eqP; rewrite eqEsubset sHG.\napply: (iffP maxgroupP) => [] [sMG maxM]; split=> // H.\n  by move/maxM=> maxMH; rewrite subEproper; case/predU1P; auto.\nby rewrite properEneq => /andP[/eqP neHG sHG] /maxM[].\nQed.",
    "Lemma maximal_exists H G :\n    H \\subset G ->\n  H :=: G \\/ (exists2 M : {group gT}, maximal M G & H \\subset M).\nProof.\nrewrite subEproper; case/predU1P=> sHG; first by left.\nsuff [M *]: {M : {group gT} | maximal M G & H \\subset M} by right; exists M.\nexact: maxgroup_exists.\nQed.",
    "Lemma mulg_normal_maximal G M H :\n  M <| G -> maximal M G -> H \\subset G -> ~~ (H \\subset M) -> (M * H = G)%g.\nProof.\ncase/andP=> sMG nMG /maxgroupP[_ maxM] sHG not_sHM.\napply/eqP; rewrite eqEproper mul_subG // -norm_joinEr ?(subset_trans sHG) //.\nby apply: contra not_sHM => /maxM <-; rewrite ?joing_subl ?joing_subr.\nQed.",
    "Lemma minnormal_exists G H : H :!=: 1 -> G \\subset 'N(H) ->\n  {M : {group gT} | minnormal M G & M \\subset H}.\nProof. by move=> ntH nHG; apply: mingroup_exists (H) _; rewrite ntH. Qed.",
    "Lemma morphpre_maximal : maximal (f @*^-1 M) (f @*^-1 G) = maximal M G.\nProof.\napply/maxgroupP/maxgroupP; rewrite morphpre_proper //= => [] [ltMG maxM].\n  split=> // H ltHG sMH; have dH := subset_trans (proper_sub ltHG) dG.\n  rewrite -(morphpreK dH) [f @*^-1 H]maxM ?morphpreK ?morphpreSK //.\n  by rewrite morphpre_proper.\nsplit=> // H ltHG sMH.\nhave dH: H \\subset D := subset_trans (proper_sub ltHG) (subsetIl D _).\nhave defH: f @*^-1 (f @* H) = H.\n  by apply: morphimGK dH; apply: subset_trans sMH; apply: ker_sub_pre.\nrewrite -defH morphpre_proper ?morphimS // in ltHG.\nby rewrite -defH [f @* H]maxM // -(morphpreK dM) morphimS.\nQed.",
    "Lemma morphpre_maximal_eq : maximal_eq (f @*^-1 M) (f @*^-1 G) = maximal_eq M G.\nProof. by rewrite /maximal_eq morphpre_maximal !eqEsubset !morphpreSK. Qed.",
    "Lemma injm_maximal : maximal (f @* M) (f @* G) = maximal M G.\nProof.\nrewrite -(morphpre_invm injf) -(morphpre_invm injf G).\nby rewrite morphpre_maximal ?morphim_invm.\nQed.",
    "Lemma injm_maximal_eq : maximal_eq (f @* M) (f @* G) = maximal_eq M G.\nProof. by rewrite /maximal_eq injm_maximal // injm_eq. Qed.",
    "Lemma injm_maxnormal : maxnormal (f @* M) (f @* G) (f @* L) = maxnormal M G L.\nProof.\npose injfm := (injm_proper injf, injm_norms, injmSK injf, subsetIl).\napply/maxgroupP/maxgroupP; rewrite !injfm // => [[nML maxM]].\n  split=> // H nHL sMH; have [/proper_sub sHG _] := andP nHL.\n  have dH := subset_trans sHG dG; apply: (injm_morphim_inj injf) => //.\n  by apply: maxM; rewrite !injfm.\nsplit=> // fH nHL sMH; have [/proper_sub sfHG _] := andP nHL.\nhave{sfHG} dfH: fH \\subset f @* D := subset_trans sfHG (morphim_sub f G).\nby rewrite -(morphpreK dfH) !injfm // in nHL sMH *; rewrite (maxM _ nHL).\nQed.",
    "Lemma injm_minnormal : minnormal (f @* M) (f @* G) = minnormal M G.\nProof.\npose injfm := (morphim_injm_eq1 injf, injm_norms, injmSK injf, subsetIl).\napply/mingroupP/mingroupP; rewrite !injfm // => [[nML minM]].\n  split=> // H nHG sHM; have dH := subset_trans sHM dM.\n  by apply: (injm_morphim_inj injf) => //; apply: minM; rewrite !injfm.\nsplit=> // fH nHG sHM; have dfH := subset_trans sHM (morphim_sub f M).\nby rewrite -(morphpreK dfH) !injfm // in nHG sHM *; rewrite (minM _ nHG).\nQed.",
    "Lemma cosetpre_maximal (Q R : {group coset_of K}) :\n  maximal (coset K @*^-1 Q) (coset K @*^-1 R) = maximal Q R.\nProof. by rewrite morphpre_maximal ?sub_im_coset. Qed.",
    "Lemma cosetpre_maximal_eq (Q R : {group coset_of K}) :\n  maximal_eq (coset K @*^-1 Q) (coset K @*^-1 R) = maximal_eq Q R.\nProof. by rewrite /maximal_eq !eqEsubset !cosetpreSK cosetpre_maximal. Qed.",
    "Lemma quotient_maximal :\n  K <| G -> K <| H -> maximal (G / K) (H / K) = maximal G H.\nProof. by move=> nKG nKH; rewrite -cosetpre_maximal ?quotientGK. Qed.",
    "Lemma quotient_maximal_eq :\n  K <| G -> K <| H -> maximal_eq (G / K) (H / K) = maximal_eq G H.\nProof. by move=> nKG nKH; rewrite -cosetpre_maximal_eq ?quotientGK. Qed.",
    "Lemma maximalJ x : maximal (G :^ x) (H :^ x) = maximal G H.\nProof.\nrewrite -{1}(setTI G) -{1}(setTI H) -!morphim_conj.\nby rewrite injm_maximal ?subsetT ?injm_conj.\nQed.",
    "Lemma maximal_eqJ x : maximal_eq (G :^ x) (H :^ x) = maximal_eq G H.\nProof. by rewrite /maximal_eq !eqEsubset !conjSg maximalJ. Qed.",
    "Lemma maxnormal_normal A B : maxnormal A B B -> A <| B.\nProof.\nby case/maxsetP=> /and3P[/gen_set_id /= -> pAB nAB]; rewrite /normal proper_sub.\nQed.",
    "Lemma maxnormal_proper A B C : maxnormal A B C -> A \\proper B.\nProof.\nby case/maxsetP=> /and3P[gA pAB _] _; apply: (sub_proper_trans (subset_gen A)).\nQed.",
    "Lemma maxnormal_sub A B C : maxnormal A B C -> A \\subset B.\nProof.\nby move=> maxA; rewrite proper_sub //; apply: (maxnormal_proper maxA).\nQed.",
    "Lemma ex_maxnormal_ntrivg G : G :!=: 1-> {N : {group gT} | maxnormal N G G}.\nProof.\nmove=> ntG; apply: ex_maxgroup; exists [1 gT]%G; rewrite norm1 proper1G.\nby rewrite subsetT ntG.\nQed.",
    "Lemma maxnormalM G H K :\n  maxnormal H G G -> maxnormal K G G -> H :<>: K -> H * K = G.\nProof.\nmove=> maxH maxK /eqP; apply: contraNeq => ltHK_G.\nhave [nsHG nsKG] := (maxnormal_normal maxH, maxnormal_normal maxK).\nhave cHK: commute H K.\n  exact: normC (subset_trans (normal_sub nsHG) (normal_norm nsKG)).\nwlog suffices: H K {maxH} maxK nsHG nsKG cHK ltHK_G / H \\subset K.\n  by move=> IH; rewrite eqEsubset !IH // -cHK.\nhave{maxK} /maxgroupP[_ maxK] := maxK.\napply/joing_idPr/maxK; rewrite ?joing_subr //= comm_joingE //.\nby rewrite properEneq ltHK_G; apply: normalM.\nQed.",
    "Lemma maxnormal_minnormal G L M :\n    G \\subset 'N(M) -> L \\subset 'N(G) ->  maxnormal M G L ->\n  minnormal (G / M) (L / M).\nProof.\nmove=> nMG nGL /maxgroupP[/andP[/andP[sMG ltMG] nML] maxM]; apply/mingroupP.\nrewrite -subG1 quotient_sub1 ?ltMG ?quotient_norms //.\nsplit=> // Hb /andP[ntHb nHbL]; have nsMG: M <| G by apply/andP.\ncase/inv_quotientS=> // H defHb sMH sHG; rewrite defHb; congr (_ / M).\napply/eqP; rewrite eqEproper sHG /=; apply: contra ntHb => ltHG.\nhave nsMH: M <| H := normalS sMH sHG nsMG.\nrewrite defHb quotientS1 // (maxM H) // ltHG /=  -(quotientGK nsMH) -defHb.\nexact: norm_quotient_pre.\nQed.",
    "Lemma minnormal_maxnormal G L M :\n  M <| G -> L \\subset 'N(M) -> minnormal (G / M) (L / M) -> maxnormal M G L.\nProof.\ncase/andP=> sMG nMG nML /mingroupP[/andP[/= ntGM _] minGM]; apply/maxgroupP.\nsplit=> [|H /andP[/andP[sHG ltHG] nHL] sMH].\n  by rewrite /proper sMG nML andbT; apply: contra ntGM => /quotientS1 ->.\napply/eqP; rewrite eqEsubset sMH andbT -quotient_sub1 ?(subset_trans sHG) //.\nrewrite subG1; apply: contraR ltHG => ntHM; rewrite -(quotientSGK nMG) //.\nby rewrite (minGM (H / M)%G) ?quotientS // ntHM quotient_norms.\nQed.",
    "Lemma simpleP gT (G : {group gT}) :\n  reflect (G :!=: 1 /\\ forall H : {group gT}, H <| G -> H :=: 1 \\/ H :=: G)\n          (simple G).\nProof.\napply: (iffP mingroupP); rewrite normG andbT => [[ntG simG]].\n  split=> // N /andP[sNG nNG].\n  by case: (eqsVneq N 1) => [|ntN]; [left | right; apply: simG; rewrite ?ntN].\nsplit=> // N /andP[ntN nNG] sNG.\nby case: (simG N) ntN => // [|->]; [apply/andP | case/eqP].\nQed.",
    "Lemma quotient_simple gT (G H : {group gT}) :\n  H <| G -> simple (G / H) = maxnormal H G G.\nProof.\nmove=> nsHG; have nGH := normal_norm nsHG.\nby apply/idP/idP; [apply: minnormal_maxnormal | apply: maxnormal_minnormal].\nQed.",
    "Lemma isog_simple gT rT (G : {group gT}) (M : {group rT}) :\n  G \\isog M -> simple G = simple M.\nProof.\nmove=> eqGM; wlog suffices: gT rT G M eqGM / simple M -> simple G.\n  by move=> IH; apply/idP/idP; apply: IH; rewrite // isog_sym.\ncase/isogP: eqGM => f injf <- /simpleP[ntGf simGf].\napply/simpleP; split=> [|N nsNG]; first by rewrite -(morphim_injm_eq1 injf).\nrewrite -(morphim_invm injf (normal_sub nsNG)).\nhave: f @* N <| f @* G by rewrite morphim_normal.\nby case/simGf=> /= ->; [left | right]; rewrite (morphim1, morphim_invm).\nQed.",
    "Lemma simple_maxnormal gT (G : {group gT}) : simple G = maxnormal 1 G G.\nProof.\nby rewrite -quotient_simple ?normal1 // -(isog_simple (quotient1_isog G)).\nQed.",
    "Lemma chief_factor_minnormal G V U :\n  chief_factor G V U -> minnormal (U / V) (G / V).\nProof.\ncase/andP=> maxV /andP[sUG nUG]; apply: maxnormal_minnormal => //.\nby have /andP[_ nVG] := maxgroupp maxV; apply: subset_trans sUG nVG.\nQed.",
    "Lemma acts_irrQ G U V :\n    G \\subset 'N(V) -> V <| U ->\n  acts_irreducibly G (U / V) 'Q = minnormal (U / V) (G / V).\nProof.\nmove=> nVG nsVU; apply/mingroupP/mingroupP; case=> /andP[->] /=.\n  rewrite astabsQ // subsetI nVG /= => nUG minUV.\n  rewrite quotient_norms //; split=> // H /andP[ntH nHG] sHU.\n  by apply: minUV (sHU); rewrite ntH -(cosetpreK H) actsQ // norm_quotient_pre.\nrewrite sub_quotient_pre // => nUG minU; rewrite astabsQ //.\nrewrite (subset_trans nUG); last first.\n  by rewrite subsetI subsetIl /= -{2}(quotientGK nsVU) morphpre_norm.\nsplit=> // H /andP[ntH nHG] sHU.\nrewrite -{1}(cosetpreK H) astabsQ ?normal_cosetpre ?subsetI ?nVG //= in nHG.\napply: minU sHU; rewrite ntH; apply: subset_trans (quotientS _ nHG) _.\nby rewrite -{2}(cosetpreK H) quotient_norm.\nQed.",
    "Lemma chief_series_exists H G :\n  H <| G -> {s | (G.-chief).-series 1%G s & last 1%G s = H}.\nProof.\nhave [m] := ubnP #|H|; elim: m H => // m IHm U leUm nsUG.\nhave [-> | ntU] := eqVneq U 1%G; first by exists [::].\nhave [V maxV]: {V : {group gT} | maxnormal V U G}.\n  by apply: ex_maxgroup; exists 1%G; rewrite proper1G ntU norms1.\nhave /andP[ltVU nVG] := maxgroupp maxV.\nhave [||s ch_s defV] := IHm V; first exact: leq_trans (proper_card ltVU) _.\n  by rewrite /normal (subset_trans (proper_sub ltVU) (normal_sub nsUG)).\nexists (rcons s U); last by rewrite last_rcons.\nby rewrite rcons_path defV /= ch_s /chief_factor; apply/and3P.\nQed.",
    "Lemma central_factor_central H K :\n  central_factor G H K -> (K / H) \\subset 'Z(G / H).\nProof. by case/and3P=> /quotient_cents2r *; rewrite subsetI quotientS. Qed.",
    "Lemma central_central_factor H K :\n  (K / H) \\subset 'Z(G / H) -> H <| K -> H <| G -> central_factor G H K.\nProof.\ncase/subsetIP=> sKGb cGKb /andP[sHK nHK] /andP[sHG nHG].\nby rewrite /central_factor -quotient_cents2 // cGKb sHK -(quotientSGK nHK).\nQed.",
    "Lemma trivgVpdiv G : G :=: 1 \\/ (exists2 p, prime p & p %| #|G|).\nProof.\nhave [leG1|lt1G] := leqP #|G| 1; first by left; apply: card_le1_trivg.\nby right; exists (pdiv #|G|); rewrite ?pdiv_dvd ?pdiv_prime.\nQed.",
    "Lemma prime_subgroupVti G H : prime #|G| -> G \\subset H \\/ H :&: G = 1.\nProof.\nmove=> prG; have [|[p p_pr pG]] := trivgVpdiv (H :&: G); first by right.\nleft; rewrite (sameP setIidPr eqP) eqEcard subsetIr.\nsuffices <-: p = #|G| by rewrite dvdn_leq ?cardG_gt0.\nby apply/eqP; rewrite -dvdn_prime2 // -(LagrangeI G H) setIC dvdn_mulr.\nQed.",
    "Lemma pgroupE pi A : pi.-group A = pi.-nat #|A|. Proof. by []. Qed.",
    "Lemma sub_pgroup pi rho A : {subset pi <= rho} -> pi.-group A -> rho.-group A.\nProof. by move=> pi_sub_rho; apply: sub_in_pnat (in1W pi_sub_rho). Qed.",
    "Lemma eq_pgroup pi rho A : pi =i rho -> pi.-group A = rho.-group A.\nProof. exact: eq_pnat. Qed.",
    "Lemma eq_p'group pi rho A : pi =i rho -> pi^'.-group A = rho^'.-group A.\nProof. by move/eq_negn; apply: eq_pnat. Qed.",
    "Lemma pgroupNK pi A : pi^'^'.-group A = pi.-group A.\nProof. exact: pnatNK. Qed.",
    "Lemma pi_pgroup p pi A : p.-group A -> p \\in pi -> pi.-group A.\nProof. exact: pi_pnat. Qed.",
    "Lemma pi_p'group p pi A : pi.-group A -> p \\in pi^' -> p^'.-group A.\nProof. exact: pi_p'nat. Qed.",
    "Lemma pi'_p'group p pi A : pi^'.-group A -> p \\in pi -> p^'.-group A.\nProof. exact: pi'_p'nat. Qed.",
    "Lemma p'groupEpi p G : p^'.-group G = (p \\notin \\pi(G)).\nProof. exact: p'natEpi (cardG_gt0 G). Qed.",
    "Lemma pgroup_pi G : \\pi(G).-group G.\nProof. by rewrite /=; apply: pnat_pi. Qed.",
    "Lemma partG_eq1 pi G : (#|G|`_pi == 1%N) = pi^'.-group G.\nProof. exact: partn_eq1 (cardG_gt0 G). Qed.",
    "Lemma pgroupP pi G :\n  reflect (forall p, prime p -> p %| #|G| -> p \\in pi) (pi.-group G).\nProof. exact: pnatP. Qed.",
    "Lemma pgroup1 pi : pi.-group [1 gT].\nProof. by rewrite /pgroup cards1. Qed.",
    "Lemma pgroupS pi G H : H \\subset G -> pi.-group G -> pi.-group H.\nProof. by move=> sHG; apply: pnat_dvd (cardSg sHG). Qed.",
    "Lemma oddSg G H : H \\subset G -> odd #|G| -> odd #|H|.\nProof. by rewrite !odd_2'nat; apply: pgroupS. Qed.",
    "Lemma odd_pgroup_odd p G : odd p -> p.-group G -> odd #|G|.\nProof.\nmove=> p_odd pG; rewrite odd_2'nat (pi_pnat pG) // !inE.\nby case: eqP p_odd => // ->.\nQed.",
    "Lemma card_pgroup p G : p.-group G -> #|G| = (p ^ logn p #|G|)%N.\nProof. by move=> pG; rewrite -p_part part_pnat_id. Qed.",
    "Lemma properG_ltn_log p G H :\n  p.-group G -> H \\proper G -> logn p #|H| < logn p #|G|.\nProof.\nmove=> pG; rewrite properEneq eqEcard andbC ltnNge => /andP[sHG].\nrewrite sHG /= {1}(card_pgroup pG) {1}(card_pgroup (pgroupS sHG pG)).\nby apply: contra; case: p {pG} => [|p] leHG; rewrite ?logn0 // leq_pexp2l.\nQed.",
    "Lemma pgroupM pi G H : pi.-group (G * H) = pi.-group G && pi.-group H.\nProof.\nhave GH_gt0: 0 < #|G :&: H| := cardG_gt0 _.\nrewrite /pgroup -(mulnK #|_| GH_gt0) -mul_cardG -(LagrangeI G H) -mulnA.\nby rewrite mulKn // -(LagrangeI H G) setIC !pnatM andbCA; case: (pnat _).\nQed.",
    "Lemma pgroupJ pi G x : pi.-group (G :^ x) = pi.-group G.\nProof. by rewrite /pgroup cardJg. Qed.",
    "Lemma pgroup_p p P : p.-group P -> p_group P.\nProof.\ncase: (leqP #|P| 1); first by move=> /card_le1_trivg-> _; apply: pgroup1.\nmove/pdiv_prime=> pr_q pgP; have:= pgroupP pgP _ pr_q (pdiv_dvd _).\nby rewrite /p_group => /eqnP->.\nQed.",
    "Lemma p_groupP P : p_group P -> exists2 p, prime p & p.-group P.\nProof.\ncase: (ltnP 1 #|P|); first by move/pdiv_prime; exists (pdiv #|P|).\nby move/card_le1_trivg=> -> _; exists 2 => //; apply: pgroup1.\nQed.",
    "Lemma pgroup_pdiv p G :\n    p.-group G -> G :!=: 1 ->\n  [/\\ prime p, p %| #|G| & exists m, #|G| = p ^ m.+1]%N.\nProof.\nmove=> pG; rewrite trivg_card1; case/p_groupP: (pgroup_p pG) => q q_pr qG.\nmove/implyP: (pgroupP pG q q_pr); case/p_natP: qG => // [[|m] ->] //.\nby rewrite dvdn_exp // => /eqnP <- _; split; rewrite ?dvdn_exp //; exists m.\nQed.",
    "Lemma coprime_p'group p K R :\n  coprime #|K| #|R| -> p.-group R -> R :!=: 1 -> p^'.-group K.\nProof.\nmove=> coKR pR ntR; have [p_pr _ [e oK]] := pgroup_pdiv pR ntR.\nby rewrite oK coprime_sym coprime_pexpl // prime_coprime // -p'natE in coKR.\nQed.",
    "Lemma card_Hall pi G H : pi.-Hall(G) H -> #|H| = #|G|`_pi.\nProof.\ncase/and3P=> sHG piH pi'H; rewrite -(Lagrange sHG).\nby rewrite partnM ?Lagrange // part_pnat_id ?part_p'nat ?muln1.\nQed.",
    "Lemma pHall_sub pi A B : pi.-Hall(A) B -> B \\subset A.\nProof. by case/andP. Qed.",
    "Lemma pHall_pgroup pi A B : pi.-Hall(A) B -> pi.-group B.\nProof. by case/and3P. Qed.",
    "Lemma pHallP pi G H : reflect (H \\subset G /\\ #|H| = #|G|`_pi) (pi.-Hall(G) H).\nProof.\napply: (iffP idP) => [piH | [sHG oH]].\n  by split; [apply: pHall_sub piH | apply: card_Hall].\nrewrite /pHall sHG -divgS // /pgroup oH.\nby rewrite -{2}(@partnC pi #|G|) ?mulKn ?part_pnat.\nQed.",
    "Lemma pHallE pi G H : pi.-Hall(G) H = (H \\subset G) && (#|H| == #|G|`_pi).\nProof. by apply/pHallP/andP=> [] [->] /eqP. Qed.",
    "Lemma coprime_mulpG_Hall pi G K R :\n    K * R = G -> pi.-group K -> pi^'.-group R ->\n  pi.-Hall(G) K /\\ pi^'.-Hall(G) R.\nProof.\nmove=> defG piK pi'R; apply/andP.\nrewrite /pHall piK -!divgS /= -defG ?mulG_subl ?mulg_subr //= pnatNK.\nby rewrite coprime_cardMg ?(pnat_coprime piK) // mulKn ?mulnK //; apply/and3P.\nQed.",
    "Lemma coprime_mulGp_Hall pi G K R :\n    K * R = G -> pi^'.-group K -> pi.-group R ->\n  pi^'.-Hall(G) K /\\ pi.-Hall(G) R.\nProof.\nmove=> defG pi'K piR; apply/andP; rewrite andbC; apply/andP.\nby apply: coprime_mulpG_Hall => //; rewrite -(comm_group_setP _) defG ?groupP.\nQed.",
    "Lemma eq_in_pHall pi rho G H :\n  {in \\pi(G), pi =i rho} -> pi.-Hall(G) H = rho.-Hall(G) H.\nProof.\nmove=> eq_pi_rho; apply: andb_id2l => sHG.\ncongr (_ && _); apply: eq_in_pnat => p piHp.\n  by apply: eq_pi_rho; apply: (piSg sHG).\nby congr (~~ _); apply: eq_pi_rho; apply: (pi_of_dvd (dvdn_indexg G H)).\nQed.",
    "Lemma eq_pHall pi rho G H : pi =i rho -> pi.-Hall(G) H = rho.-Hall(G) H.\nProof. by move=> eq_pi_rho; apply: eq_in_pHall (in1W eq_pi_rho). Qed.",
    "Lemma eq_p'Hall pi rho G H : pi =i rho -> pi^'.-Hall(G) H = rho^'.-Hall(G) H.\nProof. by move=> eq_pi_rho; apply: eq_pHall (eq_negn _). Qed.",
    "Lemma pHallNK pi G H : pi^'^'.-Hall(G) H = pi.-Hall(G) H.\nProof. exact: eq_pHall (negnK _). Qed.",
    "Lemma subHall_Hall pi rho G H K :\n  rho.-Hall(G) H -> {subset pi <= rho} -> pi.-Hall(H) K -> pi.-Hall(G) K.\nProof.\nmove=> hallH pi_sub_rho hallK.\nrewrite pHallE (subset_trans (pHall_sub hallK) (pHall_sub hallH)) /=.\nby rewrite (card_Hall hallK) (card_Hall hallH) partn_part.\nQed.",
    "Lemma subHall_Sylow pi p G H P :\n  pi.-Hall(G) H -> p \\in pi -> p.-Sylow(H) P -> p.-Sylow(G) P.\nProof.\nmove=> hallH pi_p sylP; have [sHG piH _] := and3P hallH.\nrewrite pHallE (subset_trans (pHall_sub sylP) sHG) /=.\nby rewrite (card_Hall sylP) (card_Hall hallH) partn_part // => q; move/eqnP->.\nQed.",
    "Lemma pHall_Hall pi A B : pi.-Hall(A) B -> Hall A B.\nProof. by case/and3P=> sBA piB pi'B; rewrite /Hall sBA (pnat_coprime piB). Qed.",
    "Lemma Hall_pi G H : Hall G H -> \\pi(H).-Hall(G) H.\nProof.\nby case/andP=> sHG coHG /=; rewrite /pHall sHG /pgroup pnat_pi -?coprime_pi'.\nQed.",
    "Lemma HallP G H : Hall G H -> exists pi, pi.-Hall(G) H.\nProof. by exists \\pi(H); apply: Hall_pi. Qed.",
    "Lemma sdprod_Hall G K H : K ><| H = G -> Hall G K = Hall G H.\nProof.\ncase/sdprod_context=> /andP[sKG _] sHG defG _ tiKH.\nby rewrite /Hall sKG sHG -!divgS // -defG TI_cardMg // coprime_sym mulKn ?mulnK.\nQed.",
    "Lemma coprime_sdprod_Hall_l G K H : K ><| H = G -> coprime #|K| #|H| = Hall G K.\nProof.\ncase/sdprod_context=> /andP[sKG _] _ defG _ tiKH.\nby rewrite /Hall sKG -divgS // -defG TI_cardMg ?mulKn.\nQed.",
    "Lemma coprime_sdprod_Hall_r G K H : K ><| H = G -> coprime #|K| #|H| = Hall G H.\nProof.\nby move=> defG; rewrite (coprime_sdprod_Hall_l defG) (sdprod_Hall defG).\nQed.",
    "Lemma compl_pHall pi K H G :\n  pi.-Hall(G) K -> (H \\in [complements to K in G]) = pi^'.-Hall(G) H.\nProof.\nmove=> hallK; apply/complP/idP=> [[tiKH mulKH] | hallH].\n  have [_] := andP hallK; rewrite /pHall pnatNK -{3}(invGid G) -mulKH mulG_subr.\n  by rewrite invMG !indexMg -indexgI andbC -indexgI setIC tiKH !indexg1.\nhave [[sKG piK _] [sHG pi'H _]] := (and3P hallK, and3P hallH).\nhave tiKH: K :&: H = 1 := coprime_TIg (pnat_coprime piK pi'H).\nsplit=> //; apply/eqP; rewrite eqEcard mul_subG //= TI_cardMg //.\nby rewrite (card_Hall hallK) (card_Hall hallH) partnC.\nQed.",
    "Lemma compl_p'Hall pi K H G :\n  pi^'.-Hall(G) K -> (H \\in [complements to K in G]) = pi.-Hall(G) H.\nProof. by move/compl_pHall->; apply: eq_pHall (negnK pi). Qed.",
    "Lemma sdprod_normal_p'HallP pi K H G :\n  K <| G -> pi^'.-Hall(G) H -> reflect (K ><| H = G) (pi.-Hall(G) K).\nProof.\nmove=> nsKG hallH; rewrite -(compl_p'Hall K hallH).\nexact: sdprod_normal_complP.\nQed.",
    "Lemma sdprod_normal_pHallP pi K H G :\n  K <| G -> pi.-Hall(G) H -> reflect (K ><| H = G) (pi^'.-Hall(G) K).\nProof.\nby move=> nsKG hallH; apply: sdprod_normal_p'HallP; rewrite ?pHallNK.\nQed.",
    "Lemma pHallJ2 pi G H x : pi.-Hall(G :^ x) (H :^ x) = pi.-Hall(G) H.\nProof. by rewrite !pHallE conjSg !cardJg. Qed.",
    "Lemma pHallJnorm pi G H x : x \\in 'N(G) -> pi.-Hall(G) (H :^ x) = pi.-Hall(G) H.\nProof. by move=> Nx; rewrite -{1}(normP Nx) pHallJ2. Qed.",
    "Lemma pHallJ pi G H x : x \\in G -> pi.-Hall(G) (H :^ x) = pi.-Hall(G) H.\nProof. by move=> Gx; rewrite -{1}(conjGid Gx) pHallJ2. Qed.",
    "Lemma HallJ G H x : x \\in G -> Hall G (H :^ x) = Hall G H.\nProof.\nby move=> Gx; rewrite /Hall -!divgI -{1 3}(conjGid Gx) conjSg -conjIg !cardJg.\nQed.",
    "Lemma psubgroupJ pi G H x :\n  x \\in G -> pi.-subgroup(G) (H :^ x) = pi.-subgroup(G) H.\nProof. by move=> Gx; rewrite /psubgroup pgroupJ -{1}(conjGid Gx) conjSg. Qed.",
    "Lemma p_groupJ P x : p_group (P :^ x) = p_group P.\nProof. by rewrite /p_group cardJg pgroupJ. Qed.",
    "Lemma SylowJ G P x : x \\in G -> Sylow G (P :^ x) = Sylow G P.\nProof. by move=> Gx; rewrite /Sylow p_groupJ HallJ. Qed.",
    "Lemma p_Sylow p G P : p.-Sylow(G) P -> Sylow G P.\nProof.\nby move=> pP; rewrite /Sylow (pgroup_p (pHall_pgroup pP)) (pHall_Hall pP).\nQed.",
    "Lemma pHall_subl pi G K H :\n  H \\subset K -> K \\subset G -> pi.-Hall(G) H -> pi.-Hall(K) H.\nProof.\nby move=> sHK sKG; rewrite /pHall sHK => /and3P[_ ->]; apply/pnat_dvd/indexSg.\nQed.",
    "Lemma Hall1 G : Hall G 1.\nProof. by rewrite /Hall sub1G cards1 coprime1n. Qed.",
    "Lemma p_group1 : @p_group gT 1.\nProof. by rewrite (@pgroup_p 2) ?pgroup1. Qed.",
    "Lemma Sylow1 G : Sylow G 1.\nProof. by rewrite /Sylow p_group1 Hall1. Qed.",
    "Lemma SylowP G P : reflect (exists2 p, prime p & p.-Sylow(G) P) (Sylow G P).\nProof.\napply: (iffP idP) => [| [p _]]; last exact: p_Sylow.\ncase/andP=> /p_groupP[p p_pr] /p_natP[[P1 _ | n oP /Hall_pi]]; last first.\n  by rewrite /= oP pi_of_exp // (eq_pHall _ _ (pi_of_prime _)) //; exists p.\nhave{p p_pr P1} ->: P :=: 1 by apply: card1_trivg; rewrite P1.\npose p := pdiv #|G|.+1; have p_pr: prime p by rewrite pdiv_prime ?ltnS.\nexists p; rewrite // pHallE sub1G cards1 part_p'nat //.\napply/pgroupP=> q pr_q qG; apply/eqnP=> def_q.\nhave: p %| #|G| + 1 by rewrite addn1 pdiv_dvd.\nby rewrite dvdn_addr -def_q // Euclid_dvd1.\nQed.",
    "Lemma p_elt_exp pi x m : pi.-elt (x ^+ m) = (#[x]`_pi^' %| m).\nProof.\napply/idP/idP=> [pi_xm | /dvdnP[q ->{m}]]; last first.\n  rewrite mulnC; apply: pnat_dvd (part_pnat pi #[x]).\n  by rewrite order_dvdn -expgM mulnC mulnA partnC // -order_dvdn dvdn_mulr.\nrewrite -(@Gauss_dvdr _ #[x ^+ m]); last first.\n  by rewrite coprime_sym (pnat_coprime pi_xm) ?part_pnat.\napply: (@dvdn_trans #[x]); first by rewrite -{2}[#[x]](partnC pi) ?dvdn_mull.\nby rewrite order_dvdn mulnC expgM expg_order.\nQed.",
    "Lemma mem_p_elt pi x G : pi.-group G -> x \\in G -> pi.-elt x.\nProof. by move=> piG Gx; apply: pgroupS piG; rewrite cycle_subG. Qed.",
    "Lemma p_eltM_norm pi x y :\n  x \\in 'N(<[y]>) -> pi.-elt x -> pi.-elt y -> pi.-elt (x * y).\nProof.\nmove=> nyx pi_x pi_y; apply: (@mem_p_elt pi _ (<[x]> <*> <[y]>)%G).\n  by rewrite /= norm_joinEl ?cycle_subG // pgroupM; apply/andP.\nby rewrite groupM // mem_gen // inE cycle_id ?orbT.\nQed.",
    "Lemma p_eltM pi x y : commute x y -> pi.-elt x -> pi.-elt y -> pi.-elt (x * y).\nProof.\nmove=> cxy; apply: p_eltM_norm; apply: (subsetP (cent_sub _)).\nby rewrite cent_gen cent_set1; apply/cent1P.\nQed.",
    "Lemma p_elt1 pi : pi.-elt (1 : gT).\nProof. by rewrite /p_elt order1. Qed.",
    "Lemma p_eltV pi x : pi.-elt x^-1 = pi.-elt x.\nProof. by rewrite /p_elt orderV. Qed.",
    "Lemma p_eltX pi x n : pi.-elt x -> pi.-elt (x ^+ n).\nProof. by rewrite -{1}[x]expg1 !p_elt_exp dvdn1 => /eqnP->. Qed.",
    "Lemma p_eltJ pi x y : pi.-elt (x ^ y) = pi.-elt x.\nProof. by congr pnat; rewrite orderJ. Qed.",
    "Lemma sub_p_elt pi1 pi2 x : {subset pi1 <= pi2} -> pi1.-elt x -> pi2.-elt x.\nProof. by move=> pi12; apply: sub_in_pnat => q _; apply: pi12. Qed.",
    "Lemma eq_p_elt pi1 pi2 x : pi1 =i pi2 -> pi1.-elt x = pi2.-elt x.\nProof. by move=> pi12; apply: eq_pnat. Qed.",
    "Lemma p_eltNK pi x : pi^'^'.-elt x = pi.-elt x.\nProof. exact: pnatNK. Qed.",
    "Lemma eq_constt pi1 pi2 x : pi1 =i pi2 -> x.`_pi1 = x.`_pi2.\nProof.\nmove=> pi12; congr (x ^+ (chinese _ _ 1 0)); apply: eq_partn => // a.\nby congr (~~ _); apply: pi12.\nQed.",
    "Lemma consttNK pi x : x.`_pi^'^' = x.`_pi.\nProof. by rewrite /constt !partnNK. Qed.",
    "Lemma cycle_constt pi x : x.`_pi \\in <[x]>.\nProof. exact: mem_cycle. Qed.",
    "Lemma consttV pi x : (x^-1).`_pi = (x.`_pi)^-1.\nProof. by rewrite /constt expgVn orderV. Qed.",
    "Lemma constt1 pi : 1.`_pi = 1 :> gT.\nProof. exact: expg1n. Qed.",
    "Lemma consttJ pi x y : (x ^ y).`_pi = x.`_pi ^ y.\nProof. by rewrite /constt orderJ conjXg. Qed.",
    "Lemma p_elt_constt pi x : pi.-elt x.`_pi.\nProof. by rewrite p_elt_exp /chinese addn0 mul1n dvdn_mulr. Qed.",
    "Lemma consttC pi x : x.`_pi * x.`_pi^' = x.\nProof.\napply/eqP; rewrite -{3}[x]expg1 -expgD eq_expg_mod_order.\nrewrite partnNK -{5 6}(@partnC pi #[x]) // /chinese !addn0.\nby rewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC ?eqxx.\nQed.",
    "Lemma p'_elt_constt pi x : pi^'.-elt (x * (x.`_pi)^-1).\nProof. by rewrite -{1}(consttC pi^' x) consttNK mulgK p_elt_constt. Qed.",
    "Lemma order_constt pi (x : gT) : #[x.`_pi] = #[x]`_pi.\nProof.\nrewrite -{2}(consttC pi x) orderM; [|exact: commuteX2|]; last first.\n  by apply: (@pnat_coprime pi); apply: p_elt_constt.\nby rewrite partnM // part_pnat_id ?part_p'nat ?muln1 //; apply: p_elt_constt.\nQed.",
    "Lemma consttM pi x y : commute x y -> (x * y).`_pi = x.`_pi * y.`_pi.\nProof.\nmove=> cxy; pose m := #|<<[set x; y]>>|; have m_gt0: 0 < m := cardG_gt0 _.\npose k := chinese m`_pi m`_pi^' 1 0.\nsuffices kXpi z: z \\in <<[set x; y]>> -> z.`_pi = z ^+ k.\n  by rewrite !kXpi ?expgMn // ?groupM ?mem_gen // !inE eqxx ?orbT.\nmove=> xyz; have{xyz} zm: #[z] %| m by rewrite cardSg ?cycle_subG.\napply/eqP; rewrite eq_expg_mod_order -{3 4}[#[z]](partnC pi) //.\nrewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC //.\nrewrite -!(modn_dvdm k (partn_dvd _ m_gt0 zm)).\nrewrite chinese_modl ?chinese_modr ?coprime_partC //.\nby rewrite !modn_dvdm ?partn_dvd ?eqxx.\nQed.",
    "Lemma consttX pi x n : (x ^+ n).`_pi = x.`_pi ^+ n.\nProof.\nelim: n => [|n IHn]; first exact: constt1.\nby rewrite !expgS consttM ?IHn //; apply: commuteX.\nQed.",
    "Lemma constt1P pi x : reflect (x.`_pi = 1) (pi^'.-elt x).\nProof.\nrewrite -{2}[x]expg1 p_elt_exp -order_constt consttNK order_dvdn expg1.\nexact: eqP.\nQed.",
    "Lemma constt_p_elt pi x : pi.-elt x -> x.`_pi = x.\nProof.\nby rewrite -p_eltNK -{3}(consttC pi x) => /constt1P->; rewrite mulg1.\nQed.",
    "Lemma sub_in_constt pi1 pi2 x :\n  {in \\pi(#[x]), {subset pi1 <= pi2}} -> x.`_pi2.`_pi1 = x.`_pi1.\nProof.\nmove=> pi12; rewrite -{2}(consttC pi2 x) consttM; last exact: commuteX2.\nrewrite (constt1P _ x.`_pi2^' _) ?mulg1 //.\napply: sub_in_pnat (p_elt_constt _ x) => p; rewrite order_constt => pi_p.\nby apply/contra/pi12; rewrite -[#[x]](partnC pi2^') // primesM // pi_p.\nQed.",
    "Lemma prod_constt x : \\prod_(0 <= p < #[x].+1) x.`_p = x.\nProof.\npose lp n := [pred p | p < n].\nhave: (lp #[x].+1).-elt x by apply/pnatP=> // p _; apply: dvdn_leq.\nmove/constt_p_elt=> def_x; symmetry; rewrite -{1}def_x {def_x}.\nelim: _.+1 => [|p IHp].\n  by rewrite big_nil; apply/constt1P; apply/pgroupP.\nrewrite big_nat_recr //= -{}IHp -(consttC (lp p) x.`__); congr (_ * _).\n  by rewrite sub_in_constt // => q _; apply: leqW.\nset y := _.`__; rewrite -(consttC p y) (constt1P p^' _ _) ?mulg1.\n  by rewrite 2?sub_in_constt // => q _; move/eqnP->; rewrite !inE ?ltnn.\nrewrite /p_elt pnatNK !order_constt -partnI.\napply: sub_in_pnat (part_pnat _ _) => q _.\nby rewrite !inE ltnS -leqNgt -eqn_leq.\nQed.",
    "Lemma max_pgroupJ pi M G x :\n    x \\in G -> [max M | pi.-subgroup(G) M] ->\n  [max M :^ x of M | pi.-subgroup(G) M].\nProof.\nmove=> Gx /maxgroupP[piM maxM]; apply/maxgroupP.\nsplit=> [|H piH]; first by rewrite psubgroupJ.\nby rewrite -(conjsgKV x H) conjSg => /maxM/=-> //; rewrite psubgroupJ ?groupV.\nQed.",
    "Lemma comm_sub_max_pgroup pi H M G :\n    [max M | pi.-subgroup(G) M] -> pi.-group H -> H \\subset G ->\n  commute H M -> H \\subset M.\nProof.\ncase/maxgroupP=> /andP[sMG piM] maxM piH sHG cHM.\nrewrite -(maxM (H <*> M)%G) /= comm_joingE ?(mulG_subl, mulG_subr) //.\nby rewrite /psubgroup pgroupM piM piH mul_subG.\nQed.",
    "Lemma normal_sub_max_pgroup pi H M G :\n  [max M | pi.-subgroup(G) M] -> pi.-group H -> H <| G -> H \\subset M.\nProof.\nmove=> maxM piH /andP[sHG nHG].\napply: comm_sub_max_pgroup piH sHG _ => //; apply: commute_sym; apply: normC.\nby apply: subset_trans nHG; case/andP: (maxgroupp maxM).\nQed.",
    "Lemma norm_sub_max_pgroup pi H M G :\n    [max M | pi.-subgroup(G) M] -> pi.-group H -> H \\subset G ->\n  H \\subset 'N(M) -> H \\subset M.\nProof. by move=> maxM piH sHG /normC; apply: comm_sub_max_pgroup piH sHG. Qed.",
    "Lemma sub_pHall pi H G K :\n  pi.-Hall(G) H -> pi.-group K -> H \\subset K -> K \\subset G -> K :=: H.\nProof.\nmove=> hallH piK sHK sKG; apply/eqP; rewrite eq_sym eqEcard sHK.\nby rewrite (card_Hall hallH) -(part_pnat_id piK) dvdn_leq ?partn_dvd ?cardSg.\nQed.",
    "Lemma Hall_max pi H G : pi.-Hall(G) H -> [max H | pi.-subgroup(G) H].\nProof.\nmove=> hallH; apply/maxgroupP; split=> [|K /andP[sKG piK] sHK].\n  by rewrite /psubgroup; case/and3P: hallH => ->.\nexact: (sub_pHall hallH).\nQed.",
    "Lemma pHall_id pi H G : pi.-Hall(G) H -> pi.-group G -> H :=: G.\nProof.\nby move=> hallH piG; rewrite (sub_pHall hallH piG) ?(pHall_sub hallH).\nQed.",
    "Lemma psubgroup1 pi G : pi.-subgroup(G) 1.\nProof. by rewrite /psubgroup sub1G pgroup1. Qed.",
    "Lemma Cauchy p G : prime p -> p %| #|G| -> {x | x \\in G & #[x] = p}.\nProof.\nmove=> p_pr; have [n] := ubnP #|G|; elim: n G => // n IHn G /ltnSE-leGn pG.\npose xpG := [pred x in G | #[x] == p].\nhave [x /andP[Gx /eqP] | no_x] := pickP xpG; first by exists x.\nhave{pG n leGn IHn} pZ: p %| #|'C_G(G)|.\n  suffices /dvdn_addl <-:  p %| #|G :\\: 'C(G)| by rewrite cardsID.\n  have /acts_sum_card_orbit <-: [acts G, on G :\\: 'C(G) | 'J].\n    by apply/actsP=> x Gx y; rewrite !inE -!mem_conjgV -centJ conjGid ?groupV.\n  elim/big_rec: _ => // _ _ /imsetP[x /setDP[Gx nCx] ->] /dvdn_addl->.\n  have ltCx: 'C_G[x] \\proper G by rewrite properE subsetIl subsetIidl sub_cent1.\n  have /negP: ~ p %| #|'C_G[x]|.\n    case/(IHn _ (leq_trans (proper_card ltCx) leGn))=> y /setIP[Gy _] /eqP-oy.\n    by have /andP[] := no_x y.\n  by apply/implyP; rewrite -index_cent1 indexgI implyNb -Euclid_dvdM ?LagrangeI.\nhave [Q maxQ _]: {Q | [max Q | p^'.-subgroup('C_G(G)) Q] & 1%G \\subset Q}.\n  by apply: maxgroup_exists; apply: psubgroup1.\ncase/andP: (maxgroupp maxQ) => sQC; rewrite /pgroup p'natE // => /negP[].\napply: dvdn_trans pZ (cardSg _); apply/subsetP=> x /setIP[Gx Cx].\nrewrite -sub1set -gen_subG (normal_sub_max_pgroup maxQ) //; last first.\n  rewrite /normal subsetI !cycle_subG ?Gx ?cents_norm ?subIset ?andbT //=.\n  by rewrite centsC cycle_subG Cx.\nrewrite /pgroup p'natE //= -[#|_|]/#[x]; apply/dvdnP=> [[m oxm]].\nhave m_gt0: 0 < m by apply: dvdn_gt0 (order_gt0 x) _; rewrite oxm dvdn_mulr.\ncase/idP: (no_x (x ^+ m)); rewrite /= groupX //= orderXgcd //= oxm.\nby rewrite gcdnC gcdnMr mulKn.\nQed.",
    "Lemma sub_normal_Hall pi G H K :\n  pi.-Hall(G) H -> H <| G -> K \\subset G -> (K \\subset H) = pi.-group K.\nProof.\nmove=> hallH nsHG sKG; apply/idP/idP=> [sKH | piK].\n  by rewrite (pgroupS sKH) ?(pHall_pgroup hallH).\napply: norm_sub_max_pgroup (Hall_max hallH) piK _ _ => //.\nexact: subset_trans sKG (normal_norm nsHG).\nQed.",
    "Lemma mem_normal_Hall pi H G x :\n  pi.-Hall(G) H -> H <| G -> x \\in G -> (x \\in H) = pi.-elt x.\nProof. by rewrite -!cycle_subG; apply: sub_normal_Hall. Qed.",
    "Lemma uniq_normal_Hall pi H G K :\n  pi.-Hall(G) H -> H <| G -> [max K | pi.-subgroup(G) K] -> K :=: H.\nProof.\nmove=> hallH nHG /maxgroupP[/andP[sKG piK] /(_ H) -> //].\n  exact: (maxgroupp (Hall_max hallH)).\nby rewrite (sub_normal_Hall hallH).\nQed.",
    "Lemma normal_max_pgroup_Hall G H :\n  [max H | pi.-subgroup(G) H] -> H <| G -> pi.-Hall(G) H.\nProof.\ncase/maxgroupP=> /andP[sHG piH] maxH nsHG; have [_ nHG] := andP nsHG.\nrewrite /pHall sHG piH; apply/pnatP=> // p p_pr.\nrewrite inE /= -pnatE // -card_quotient //.\ncase/Cauchy=> //= Hx; rewrite -sub1set -gen_subG -/<[Hx]> /order.\ncase/inv_quotientS=> //= K -> sHK sKG {Hx}.\nrewrite card_quotient ?(subset_trans sKG) // => iKH; apply/negP=> pi_p.\nrewrite -iKH -divgS // (maxH K) ?divnn ?cardG_gt0 // in p_pr.\nby rewrite /psubgroup sKG /pgroup -(Lagrange sHK) mulnC pnatM iKH pi_p.\nQed.",
    "Lemma setI_normal_Hall G H K :\n  H <| G -> pi.-Hall(G) H -> K \\subset G -> pi.-Hall(K) (H :&: K).\nProof.\nmove=> nsHG hallH sKG; apply: normal_max_pgroup_Hall; last first.\n  by rewrite /= setIC (normalGI sKG nsHG).\napply/maxgroupP; split=> [|M /andP[sMK piM] sHK_M].\n  by rewrite /psubgroup subsetIr (pgroupS (subsetIl _ _) (pHall_pgroup hallH)).\napply/eqP; rewrite eqEsubset sHK_M subsetI sMK !andbT.\nby rewrite (sub_normal_Hall hallH) // (subset_trans sMK).\nQed.",
    "Lemma morphim_pgroup pi G : pi.-group G -> pi.-group (f @* G).\nProof. by apply: pnat_dvd; apply: dvdn_morphim. Qed.",
    "Lemma morphim_odd G : odd #|G| -> odd #|f @* G|.\nProof. by rewrite !odd_2'nat; apply: morphim_pgroup. Qed.",
    "Lemma pmorphim_pgroup pi G :\n   pi.-group ('ker f) -> G \\subset D -> pi.-group (f @* G) = pi.-group G.\nProof.\nmove=> piker sGD; apply/idP/idP=> [pifG|]; last exact: morphim_pgroup.\napply: (@pgroupS _ _ (f @*^-1 (f @* G))); first by rewrite -sub_morphim_pre.\nby rewrite /pgroup card_morphpre ?morphimS // pnatM; apply/andP.\nQed.",
    "Lemma morphim_p_index pi G H :\n  H \\subset D -> pi.-nat #|G : H| -> pi.-nat #|f @* G : f @* H|.\nProof.\nby move=> sHD; apply: pnat_dvd; rewrite index_morphim ?subIset // sHD orbT.\nQed.",
    "Lemma morphim_pHall pi G H :\n  H \\subset D -> pi.-Hall(G) H -> pi.-Hall(f @* G) (f @* H).\nProof.\nmove=> sHD /and3P[sHG piH pi'GH].\nby rewrite /pHall morphimS // morphim_pgroup // morphim_p_index.\nQed.",
    "Lemma pmorphim_pHall pi G H :\n    G \\subset D -> H \\subset D -> pi.-subgroup(H :&: G) ('ker f) ->\n  pi.-Hall(f @* G) (f @* H) = pi.-Hall(G) H.\nProof.\nmove=> sGD sHD /andP[/subsetIP[sKH sKG] piK]; rewrite !pHallE morphimSGK //.\napply: andb_id2l => sHG; rewrite -(Lagrange sKH) -(Lagrange sKG) partnM //.\nby rewrite (part_pnat_id piK) !card_morphim !(setIidPr _) // eqn_pmul2l.\nQed.",
    "Lemma morphim_Hall G H : H \\subset D -> Hall G H -> Hall (f @* G) (f @* H).\nProof.\nby move=> sHD /HallP[pi piH]; apply: (@pHall_Hall _ pi); apply: morphim_pHall.\nQed.",
    "Lemma morphim_pSylow p G P :\n  P \\subset D -> p.-Sylow(G) P -> p.-Sylow(f @* G) (f @* P).\nProof. exact: morphim_pHall. Qed.",
    "Lemma morphim_p_group P : p_group P -> p_group (f @* P).\nProof. by move/morphim_pgroup; apply: pgroup_p. Qed.",
    "Lemma morphim_Sylow G P : P \\subset D -> Sylow G P -> Sylow (f @* G) (f @* P).\nProof.\nby move=> sPD /andP[pP hallP]; rewrite /Sylow morphim_p_group // morphim_Hall.\nQed.",
    "Lemma morph_p_elt pi x : x \\in D -> pi.-elt x -> pi.-elt (f x).\nProof. by move=> Dx; apply: pnat_dvd; apply: morph_order. Qed.",
    "Lemma morph_constt pi x : x \\in D -> f x.`_pi = (f x).`_pi.\nProof.\nmove=> Dx; rewrite -{2}(consttC pi x) morphM ?groupX //.\nrewrite consttM; last by rewrite !morphX //; apply: commuteX2.\nhave: pi.-elt (f x.`_pi) by rewrite morph_p_elt ?groupX ?p_elt_constt //.\nhave: pi^'.-elt (f x.`_pi^') by rewrite morph_p_elt ?groupX ?p_elt_constt //.\nby move/constt1P->; move/constt_p_elt->; rewrite mulg1.\nQed.",
    "Lemma quotient_pgroup : pi.-group (K / H). Proof. exact: morphim_pgroup. Qed.",
    "Lemma quotient_pHall :\n  K \\subset 'N(H) -> pi.-Hall(G) K -> pi.-Hall(G / H) (K / H).\nProof. exact: morphim_pHall. Qed.",
    "Lemma quotient_odd : odd #|K| -> odd #|K / H|. Proof. exact: morphim_odd. Qed.",
    "Lemma pquotient_pgroup : G \\subset 'N(K) -> pi.-group (G / K) = pi.-group G.\nProof. by move=> nKG; rewrite pmorphim_pgroup ?ker_coset. Qed.",
    "Lemma pquotient_pHall :\n  K <| G -> K <| H -> pi.-Hall(G / K) (H / K) = pi.-Hall(G) H.\nProof.\ncase/andP=> sKG nKG; case/andP=> sKH nKH.\nby rewrite pmorphim_pHall // ker_coset /psubgroup subsetI sKH sKG.\nQed.",
    "Lemma ltn_log_quotient :\n  p.-group G -> H :!=: 1 -> H \\subset G -> logn p #|G / H| < logn p #|G|.\nProof.\nmove=> pG ntH sHG; apply: contraLR (ltn_quotient ntH sHG); rewrite -!leqNgt.\nrewrite {2}(card_pgroup pG) {2}(card_pgroup (morphim_pgroup _ pG)).\nby case: (posnP p) => [-> //|]; apply: leq_pexp2l.\nQed.",
    "Lemma logn_quotient_cent_cyclic_pgroup : \n  p.-group C -> cyclic C -> logn p #|G / 'C_G(C)| <= (logn p #|C|).-1.\nProof.\nmove=> pC cycC; have [-> | ntC] := eqsVneq C 1.\n  by rewrite cent1T setIT trivg_quotient cards1 logn1.\nhave [p_pr _ [e oC]] := pgroup_pdiv pC ntC.\nrewrite -ker_conj_aut (card_isog (first_isog_loc _ _)) //.\napply: leq_trans (dvdn_leq_log _ _ (cardSg (Aut_conj_aut _ _))) _ => //.\nrewrite card_Aut_cyclic // oC totient_pfactor //= logn_Gauss ?pfactorK //.\nby rewrite prime_coprime // gtnNdvd // -(subnKC (prime_gt1 p_pr)).\nQed.",
    "Lemma p'group_quotient_cent_prime :\n  prime p -> #|C| %| p -> p^'.-group (G / 'C_G(C)).\nProof.\nmove=> p_pr pC; have pgC: p.-group C := pnat_dvd pC (pnat_id p_pr).\nhave [_ dv_p] := primeP p_pr; case/pred2P: {dv_p pC}(dv_p _ pC) => [|pC].\n  by move/card1_trivg->; rewrite cent1T setIT trivg_quotient pgroup1.\nhave le_oGC := logn_quotient_cent_cyclic_pgroup pgC.\nrewrite /pgroup -partn_eq1 ?cardG_gt0 // -dvdn1 p_part pfactor_dvdn // logn1.\nby rewrite (leq_trans (le_oGC _)) ?prime_cyclic // pC ?(pfactorK 1).\nQed.",
    "Lemma pseries_group_set : group_set pseries.\nProof. by rewrite /pseries; case: rev => [|pi1 pi1']; apply: groupP. Qed.",
    "Lemma pcore_psubgroup G : pi.-subgroup(G) 'O_pi(G).\nProof.\nhave [M maxM _]: {M | [max M | pi.-subgroup(G) M] & 1%G \\subset M}.\n  by apply: maxgroup_exists; rewrite /psubgroup sub1G pgroup1.\nhave sOM: 'O_pi(G) \\subset M by apply: bigcap_inf.\nhave /andP[piM sMG] := maxgroupp maxM.\nby rewrite /psubgroup (pgroupS sOM) // (subset_trans sOM).\nQed.",
    "Lemma pcore_pgroup G : pi.-group 'O_pi(G).\nProof. by case/andP: (pcore_psubgroup G). Qed.",
    "Lemma pcore_sub G : 'O_pi(G) \\subset G.\nProof. by case/andP: (pcore_psubgroup G). Qed.",
    "Lemma pcore_sub_Hall G H : pi.-Hall(G) H -> 'O_pi(G) \\subset H.\nProof. by move/Hall_max=> maxH; apply: bigcap_inf. Qed.",
    "Lemma pcore_max G H : pi.-group H -> H <| G -> H \\subset 'O_pi(G).\nProof.\nmove=> piH nHG; apply/bigcapsP=> M maxM.\nexact: normal_sub_max_pgroup piH nHG.\nQed.",
    "Lemma pcore_pgroup_id G : pi.-group G -> 'O_pi(G) = G.\nProof. by move=> piG; apply/eqP; rewrite eqEsubset pcore_sub pcore_max. Qed.",
    "Lemma pcore_normal G : 'O_pi(G) <| G.\nProof.\nrewrite /(_ <| G) pcore_sub; apply/subsetP=> x Gx.\nrewrite inE; apply/bigcapsP=> M maxM; rewrite sub_conjg.\nby apply: bigcap_inf; apply: max_pgroupJ; rewrite ?groupV.\nQed.",
    "Lemma normal_Hall_pcore H G : pi.-Hall(G) H -> H <| G -> 'O_pi(G) = H.\nProof.\nmove=> hallH nHG; apply/eqP.\nrewrite eqEsubset (sub_normal_Hall hallH) ?pcore_sub ?pcore_pgroup //=.\nby rewrite pcore_max //= (pHall_pgroup hallH).\nQed.",
    "Lemma eq_Hall_pcore G H :\n   pi.-Hall(G) 'O_pi(G) -> pi.-Hall(G) H -> H :=: 'O_pi(G).\nProof.\nmove=> hallGpi hallH.\nexact: uniq_normal_Hall (pcore_normal G) (Hall_max hallH).\nQed.",
    "Lemma sub_Hall_pcore G K :\n  pi.-Hall(G) 'O_pi(G) -> K \\subset G -> (K \\subset 'O_pi(G)) = pi.-group K.\nProof. by move=> hallGpi; apply: sub_normal_Hall (pcore_normal G). Qed.",
    "Lemma mem_Hall_pcore G x :\n  pi.-Hall(G) 'O_pi(G) -> x \\in G -> (x \\in 'O_pi(G)) = pi.-elt x.\nProof. by move=> hallGpi; apply: mem_normal_Hall (pcore_normal G). Qed.",
    "Lemma sdprod_Hall_pcoreP H G :\n  pi.-Hall(G) 'O_pi(G) -> reflect ('O_pi(G) ><| H = G) (pi^'.-Hall(G) H).\nProof.\nmove=> hallGpi; rewrite -(compl_pHall H hallGpi) complgC.\nexact: sdprod_normal_complP (pcore_normal G).\nQed.",
    "Lemma sdprod_pcore_HallP H G :\n  pi^'.-Hall(G) H -> reflect ('O_pi(G) ><| H = G) (pi.-Hall(G) 'O_pi(G)).\nProof. exact: sdprod_normal_p'HallP (pcore_normal G). Qed.",
    "Lemma pcoreJ G x : 'O_pi(G :^ x) = 'O_pi(G) :^ x.\nProof.\napply/eqP; rewrite eqEsubset -sub_conjgV.\nrewrite !pcore_max ?pgroupJ ?pcore_pgroup ?normalJ ?pcore_normal //.\nby rewrite -(normalJ _ _ x) conjsgKV pcore_normal.\nQed.",
    "Lemma morphim_pcore pi : GFunctor.pcontinuous (@pcore pi).\nProof.\nmove=> gT rT D G f; apply/bigcapsP=> M /normal_sub_max_pgroup; apply.\n  by rewrite morphim_pgroup ?pcore_pgroup.\nby apply: morphim_normal; apply: pcore_normal.\nQed.",
    "Lemma pcoreS pi gT (G H : {group gT}) :\n  H \\subset G -> H :&: 'O_pi(G) \\subset 'O_pi(H).\nProof.\nmove=> sHG; rewrite -{2}(setIidPl sHG).\nby do 2!rewrite -(morphim_idm (subsetIl H _)) morphimIdom; apply: morphim_pcore.\nQed.",
    "Lemma pcore_char pi gT (G : {group gT}) : 'O_pi(G) \\char G.\nProof. exact: gFchar. Qed.",
    "Lemma pcore_mod_sub pi gT (G : {group gT}) : pcore_mod G pi (F _ G) \\subset G.\nProof.\nby rewrite sub_morphpre_im ?gFsub_trans ?morphimS ?gFnorm //= ker_coset gFsub.\nQed.",
    "Lemma quotient_pcore_mod pi gT (G : {group gT}) (B : {set gT}) :\n  pcore_mod G pi B / B = 'O_pi(G / B).\nProof. exact/morphpreK/gFsub_trans/morphim_sub. Qed.",
    "Lemma morphim_pcore_mod pi gT rT (D G : {group gT}) (f : {morphism D >-> rT}) :\n  f @* pcore_mod G pi (F _ G) \\subset pcore_mod (f @* G) pi (F _ (f @* G)).\nProof.\nhave sDF: D :&: G \\subset 'dom (coset (F _ G)).\n  by rewrite setIC subIset ?gFnorm.\nhave sDFf: D :&: G \\subset 'dom (coset (F _ (f @* G)) \\o f).\n  by rewrite -sub_morphim_pre ?subsetIl // morphimIdom gFnorm.\npose K := 'ker (restrm sDFf (coset (F _ (f @* G)) \\o f)).\nhave sFK: 'ker (restrm sDF (coset (F _ G))) \\subset K.\n  rewrite /K !ker_restrm ker_comp /= subsetI subsetIl /= -setIA.\n  rewrite -sub_morphim_pre ?subsetIl //.\n  by rewrite morphimIdom !ker_coset (setIidPr _) ?pmorphimF ?gFsub.\nhave sOF := pcore_sub pi (G / F _ G); have sDD: D :&: G \\subset D :&: G by [].\nrewrite -sub_morphim_pre -?quotientE; last first.\n  by apply: subset_trans (gFnorm F _); rewrite morphimS ?pcore_mod_sub.\nsuffices im_fact (H : {group gT}) : F _ G \\subset H -> H \\subset G ->\n  factm sFK sDD @* (H / F _ G) = f @* H / F _ (f @* G).\n- rewrite -2?im_fact ?pcore_mod_sub ?gFsub //;\n    try by rewrite -{1}[F _ G]ker_coset morphpreS ?sub1G.\n  by rewrite quotient_pcore_mod morphim_pcore.\nmove=> sFH sHG; rewrite -(morphimIdom _ (H / _)) /= {2}morphim_restrm setIid.\nrewrite -morphimIG ?ker_coset //.\nrewrite -(morphim_restrm sDF) morphim_factm morphim_restrm.\nby rewrite morphim_comp -quotientE -setIA morphimIdom (setIidPr _).\nQed.",
    "Lemma pcore_mod_res pi gT rT (D : {group gT}) (f : {morphism D >-> rT}) :\n  f @* pcore_mod D pi (F _ D) \\subset pcore_mod (f @* D) pi (F _ (f @* D)).\nProof. exact: morphim_pcore_mod. Qed.",
    "Lemma pcore_mod1 pi gT (G : {group gT}) : pcore_mod G pi 1 = 'O_pi(G).\nProof.\nrewrite /pcore_mod; have inj1 := coset1_injm gT; rewrite -injmF ?norms1 //.\nby rewrite -(morphim_invmE inj1) morphim_invm ?norms1.\nQed.",
    "Lemma pseries_rcons pi pis gT (A : {set gT}) :\n  pseries (rcons pis pi) A = pcore_mod A pi (pseries pis A).\nProof. by rewrite /pseries rev_rcons. Qed.",
    "Lemma pseries_subfun pis :\n   GFunctor.closed (@pseries pis) /\\  GFunctor.pcontinuous (@pseries pis).\nProof.\nelim/last_ind: pis => [|pis pi [sFpi fFpi]].\n  by split=> [gT G | gT rT D G f]; rewrite (sub1G, morphim1).\npose fF := [gFun by fFpi : GFunctor.continuous [igFun by sFpi & fFpi]].\npose F := [pgFun by fFpi : GFunctor.hereditary fF].\nsplit=> [gT G | gT rT D G f]; rewrite !pseries_rcons ?(pcore_mod_sub F) //.\nexact: (morphim_pcore_mod F).\nQed.",
    "Lemma pseries_sub pis : GFunctor.closed (@pseries pis).\nProof. by case: (pseries_subfun pis). Qed.",
    "Lemma morphim_pseries pis : GFunctor.pcontinuous (@pseries pis).\nProof. by case: (pseries_subfun pis). Qed.",
    "Lemma pseriesS pis : GFunctor.hereditary (@pseries pis).\nProof. exact: (morphim_pseries pis). Qed.",
    "Lemma pseries_char pis gT (G : {group gT}) : pseries pis G \\char G.\nProof. exact: gFchar. Qed.",
    "Lemma pseries_normal pis gT (G : {group gT}) : pseries pis G <| G.\nProof. exact: gFnormal. Qed.",
    "Lemma pseriesJ pis gT (G : {group gT}) x :\n  pseries pis (G :^ x) = pseries pis G :^ x.\nProof.\nrewrite -{1}(setIid G) -morphim_conj -(injmF _ (injm_conj G x)) //=.\nby rewrite morphim_conj (setIidPr (pseries_sub _ _)).\nQed.",
    "Lemma pseries1 pi gT (G : {group gT}) : 'O_{pi}(G) = 'O_pi(G).\nProof. exact: pcore_mod1. Qed.",
    "Lemma pseries_pop pi pis gT (G : {group gT}) :\n  'O_pi(G) = 1 -> pseries (pi :: pis) G = pseries pis G.\nProof.\nby move=> OG1; rewrite /pseries rev_cons -cats1 foldr_cat /= pcore_mod1 OG1.\nQed.",
    "Lemma pseries_pop2 pi1 pi2 gT (G : {group gT}) :\n  'O_pi1(G) = 1 -> 'O_{pi1, pi2}(G) = 'O_pi2(G).\nProof. by move/pseries_pop->; apply: pseries1. Qed.",
    "Lemma pseries_sub_catl pi1s pi2s gT (G : {group gT}) :\n  pseries pi1s G \\subset pseries (pi1s ++ pi2s) G.\nProof.\nelim/last_ind: pi2s => [|pi pis IHpi]; rewrite ?cats0 //  -rcons_cat.\nby rewrite pseries_rcons; apply: subset_trans IHpi _; rewrite sub_cosetpre.\nQed.",
    "Lemma quotient_pseries pis pi gT (G : {group gT}) :\n  pseries (rcons pis pi) G / pseries pis G = 'O_pi(G / pseries pis G).\nProof. by rewrite pseries_rcons quotient_pcore_mod. Qed.",
    "Lemma pseries_norm2 pi1s pi2s gT (G : {group gT}) :\n  pseries pi2s G \\subset 'N(pseries pi1s G).\nProof. by rewrite gFsub_trans ?gFnorm. Qed.",
    "Lemma pseries_sub_catr pi1s pi2s gT (G : {group gT}) :\n  pseries pi2s G \\subset pseries (pi1s ++ pi2s) G.\nProof.\nelim: pi1s => //= pi1 pi1s /subset_trans; apply.\nelim/last_ind: {pi1s pi2s}(_ ++ _) => [|pis pi IHpi]; first exact: sub1G.\nrewrite -rcons_cons (pseries_rcons _ (pi1 :: pis)).\nrewrite -sub_morphim_pre ?pseries_norm2 //.\napply: pcore_max; last by rewrite morphim_normal ?pseries_normal.\nhave: pi.-group (pseries (rcons pis pi) G / pseries pis G).\n  by rewrite quotient_pseries pcore_pgroup.\nby apply: pnat_dvd; rewrite !card_quotient ?pseries_norm2 // indexgS.\nQed.",
    "Lemma quotient_pseries2 pi1 pi2 gT (G : {group gT}) :\n  'O_{pi1, pi2}(G) / 'O_pi1(G) = 'O_pi2(G / 'O_pi1(G)).\nProof. by rewrite -pseries1 -quotient_pseries. Qed.",
    "Lemma quotient_pseries_cat pi1s pi2s gT (G : {group gT}) :\n  pseries (pi1s ++ pi2s) G / pseries pi1s G\n    = pseries pi2s (G / pseries pi1s G).\nProof.\nelim/last_ind: pi2s => [|pi2s pi IHpi]; first by rewrite cats0 trivg_quotient.\nhave psN := pseries_normal _ G; set K := pseries _ G.\ncase: (third_isom (pseries_sub_catl pi1s pi2s G) (psN _)) => //= f inj_f im_f.\nhave nH2H: pseries pi2s (G / K) <| pseries (pi1s ++ rcons pi2s pi) G / K.\n  rewrite -IHpi morphim_normal // -cats1 catA.\n  by apply/andP; rewrite pseries_sub_catl pseries_norm2.\napply: (quotient_inj nH2H).\n  by apply/andP; rewrite /= -cats1 pseries_sub_catl pseries_norm2.\nrewrite /= quotient_pseries /= -IHpi -rcons_cat.\nrewrite -[G / _ / _](morphim_invm inj_f) //= {2}im_f //.\nrewrite -(@injmF [igFun of @pcore pi]) /= ?injm_invm ?im_f // -quotient_pseries.\nby rewrite -im_f ?morphim_invm ?morphimS ?normal_sub.\nQed.",
    "Lemma pseries_catl_id pi1s pi2s gT (G : {group gT}) :\n  pseries pi1s (pseries (pi1s ++ pi2s) G) = pseries pi1s G.\nProof.\nelim/last_ind: pi1s => [//|pi1s pi IHpi] in pi2s *.\napply: (@quotient_inj _ (pseries_group pi1s G)).\n- rewrite /= -(IHpi (pi :: pi2s)) cat_rcons /(_ <| _) pseries_norm2.\n  by rewrite -cats1 pseries_sub_catl.\n- by rewrite /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.\nrewrite /= cat_rcons -(IHpi (pi :: pi2s)) {1}quotient_pseries IHpi.\napply/eqP; rewrite quotient_pseries eqEsubset !pcore_max ?pcore_pgroup //=.\n  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.\n  by rewrite -cat_rcons pseries_sub_catl.\nby rewrite gFnormal_trans ?quotient_normal ?gFnormal.\nQed.",
    "Lemma pseries_char_catl pi1s pi2s gT (G : {group gT}) :\n  pseries pi1s G \\char pseries (pi1s ++ pi2s) G.\nProof. by rewrite -(pseries_catl_id pi1s pi2s G) pseries_char. Qed.",
    "Lemma pseries_catr_id pi1s pi2s gT (G : {group gT}) :\n  pseries pi2s (pseries (pi1s ++ pi2s) G) = pseries pi2s G.\nProof.\nelim/last_ind: pi2s => [//|pi2s pi IHpi] in G *.\nhave Epis: pseries pi2s (pseries (pi1s ++ rcons pi2s pi) G) = pseries pi2s G.\n  by rewrite -cats1 catA -2!IHpi pseries_catl_id.\napply: (@quotient_inj _ (pseries_group pi2s G)).\n- by rewrite /= -Epis /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.\n- by rewrite /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.\nrewrite /= -Epis {1}quotient_pseries Epis quotient_pseries.\napply/eqP; rewrite eqEsubset !pcore_max ?pcore_pgroup //=.\n  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.\n  by rewrite pseries_sub_catr.\nby rewrite gFnormal_trans ?morphim_normal ?gFnormal.\nQed.",
    "Lemma pseries_char_catr pi1s pi2s gT (G : {group gT}) :\n  pseries pi2s G \\char pseries (pi1s ++ pi2s) G.\nProof. by rewrite -(pseries_catr_id pi1s pi2s G) pseries_char. Qed.",
    "Lemma pcore_modp pi gT (G H : {group gT}) :\n  H <| G -> pi.-group H -> pcore_mod G pi H = 'O_pi(G).\nProof.\nmove=> nsHG piH; have nHG := normal_norm nsHG; apply/eqP.\nrewrite eqEsubset andbC -sub_morphim_pre ?(gFsub_trans, morphim_pcore) //=.\nrewrite -[G in 'O_pi(G)](quotientGK nsHG) pcore_max //.\n  by rewrite -(pquotient_pgroup piH) ?subsetIl // cosetpreK pcore_pgroup.\nby rewrite morphpre_normal ?gFnormal ?gFsub_trans ?morphim_sub.\nQed.",
    "Lemma pquotient_pcore pi gT (G H : {group gT}) :\n  H <| G -> pi.-group H -> 'O_pi(G / H) = 'O_pi(G) / H.\nProof. by move=> nsHG piH; rewrite -quotient_pcore_mod pcore_modp. Qed.",
    "Lemma trivg_pcore_quotient pi gT (G : {group gT}) : 'O_pi(G / 'O_pi(G)) = 1.\nProof. by rewrite pquotient_pcore ?gFnormal ?pcore_pgroup ?trivg_quotient. Qed.",
    "Lemma pseries_rcons_id pis pi gT (G : {group gT}) :\n  pseries (rcons (rcons pis pi) pi) G = pseries (rcons pis pi) G.\nProof.\napply/eqP; rewrite -!cats1 eqEsubset pseries_sub_catl andbT -catA.\nrewrite -(quotientSGK _ (pseries_sub_catl _ _ _)) ?pseries_norm2 //.\nrewrite !quotient_pseries_cat -quotient_sub1 ?pseries_norm2 //.\nby rewrite quotient_pseries_cat /= !pseries1 trivg_pcore_quotient.\nQed.",
    "Lemma sub_in_pcore pi rho G :\n  {in \\pi(G), {subset pi <= rho}} -> 'O_pi(G) \\subset 'O_rho(G).\nProof.\nmove=> pi_sub_rho; rewrite pcore_max ?pcore_normal //.\napply: sub_in_pnat (pcore_pgroup _ _) => p.\nby move/(piSg (pcore_sub _ _)); apply: pi_sub_rho.\nQed.",
    "Lemma sub_pcore pi rho G : {subset pi <= rho} -> 'O_pi(G) \\subset 'O_rho(G).\nProof. by move=> pi_sub_rho; apply: sub_in_pcore (in1W pi_sub_rho). Qed.",
    "Lemma eq_in_pcore pi rho G : {in \\pi(G), pi =i rho} -> 'O_pi(G) = 'O_rho(G).\nProof.\nmove=> eq_pi_rho; apply/eqP; rewrite eqEsubset.\nby rewrite !sub_in_pcore // => p /eq_pi_rho->.\nQed.",
    "Lemma eq_pcore pi rho G : pi =i rho -> 'O_pi(G) = 'O_rho(G).\nProof. by move=> eq_pi_rho; apply: eq_in_pcore (in1W eq_pi_rho). Qed.",
    "Lemma pcoreNK pi G : 'O_pi^'^'(G) = 'O_pi(G).\nProof. by apply: eq_pcore; apply: negnK. Qed.",
    "Lemma eq_p'core pi rho G : pi =i rho -> 'O_pi^'(G) = 'O_rho^'(G).\nProof. by move/eq_negn; apply: eq_pcore. Qed.",
    "Lemma sdprod_Hall_p'coreP pi H G :\n  pi^'.-Hall(G) 'O_pi^'(G) -> reflect ('O_pi^'(G) ><| H = G) (pi.-Hall(G) H).\nProof. by rewrite -(pHallNK pi G H); apply: sdprod_Hall_pcoreP. Qed.",
    "Lemma sdprod_p'core_HallP pi H G :\n  pi.-Hall(G) H -> reflect ('O_pi^'(G) ><| H = G) (pi^'.-Hall(G) 'O_pi^'(G)).\nProof. by rewrite -(pHallNK pi G H); apply: sdprod_pcore_HallP. Qed.",
    "Lemma pcoreI pi rho G : 'O_[predI pi & rho](G) = 'O_pi('O_rho(G)).\nProof.\napply/eqP; rewrite eqEsubset !pcore_max //.\n- rewrite /pgroup pnatI -!pgroupE.\n  by rewrite pcore_pgroup (pgroupS (pcore_sub pi _))// pcore_pgroup.\n- by rewrite !gFnormal_trans.\n- by apply: sub_pgroup (pcore_pgroup _ _) => p /andP[].\napply/andP; split; first by apply: sub_pcore => p /andP[].\nby rewrite gFnorm_trans ?normsG ?gFsub.\nQed.",
    "Lemma bigcap_p'core pi G :\n  G :&: \\bigcap_(p < #|G|.+1 | (p : nat) \\in pi) 'O_p^'(G) = 'O_pi^'(G).\nProof.\napply/eqP; rewrite eqEsubset subsetI pcore_sub pcore_max /=.\n- by apply/bigcapsP=> p pi_p; apply: sub_pcore => r; apply: contraNneq => ->.\n- apply/pgroupP=> q q_pr qGpi'; apply: contraL (eqxx q) => /= pi_q.\n  apply: (pgroupP (pcore_pgroup q^' G)) => //.\n  have qG: q %| #|G| by rewrite (dvdn_trans qGpi') // cardSg ?subsetIl.\n  have ltqG: q < #|G|.+1 by rewrite ltnS dvdn_leq.\n  rewrite (dvdn_trans qGpi') ?cardSg ?subIset //= orbC.\n  by rewrite (bigcap_inf (Ordinal ltqG)).\nrewrite /normal subsetIl normsI ?normG // norms_bigcap //.\nby apply/bigcapsP => p _; apply: gFnorm.\nQed.",
    "Lemma coprime_pcoreC (rT : finGroupType) pi G (R : {group rT}) :\n  coprime #|'O_pi(G)| #|'O_pi^'(R)|.\nProof. exact: pnat_coprime (pcore_pgroup _ _) (pcore_pgroup _ _). Qed.",
    "Lemma TI_pcoreC pi G H : 'O_pi(G) :&: 'O_pi^'(H) = 1.\nProof. by rewrite coprime_TIg ?coprime_pcoreC. Qed.",
    "Lemma pcore_setI_normal pi G H : H <| G -> 'O_pi(G) :&: H = 'O_pi(H).\nProof.\nmove=> nsHG; apply/eqP; rewrite eqEsubset subsetI pcore_sub setIC.\nrewrite !pcore_max ?(pgroupS (subsetIr H _)) ?pcore_pgroup ?gFnormal_trans //=.\nby rewrite norm_normalI ?gFnorm_trans ?normsG ?normal_sub.\nQed.",
    "Lemma injm_pgroup pi A : A \\subset D -> pi.-group (f @* A) = pi.-group A.\nProof. by move=> sAD; rewrite /pgroup card_injm. Qed.",
    "Lemma injm_pelt pi x : x \\in D -> pi.-elt (f x) = pi.-elt x.\nProof. by move=> Dx; rewrite /p_elt order_injm. Qed.",
    "Lemma injm_pHall pi G H :\n  G \\subset D -> H \\subset D -> pi.-Hall(f @* G) (f @* H) = pi.-Hall(G) H.\nProof. by move=> sGD sGH; rewrite !pHallE injmSK ?card_injm. Qed.",
    "Lemma injm_pcore pi G : G \\subset D -> f @* 'O_pi(G) = 'O_pi(f @* G).\nProof. exact: injmF. Qed.",
    "Lemma injm_pseries pis G :\n  G \\subset D -> f @* pseries pis G = pseries pis (f @* G).\nProof. exact: injmF. Qed.",
    "Lemma isog_pgroup pi : G \\isog H -> pi.-group G = pi.-group H.\nProof. by move=> isoGH; rewrite /pgroup (card_isog isoGH). Qed.",
    "Lemma isog_pcore pi : G \\isog H -> 'O_pi(G) \\isog 'O_pi(H).\nProof. exact: gFisog. Qed.",
    "Lemma isog_pseries pis : G \\isog H -> pseries pis G \\isog pseries pis H.\nProof. exact: gFisog. Qed.",
    "Lemma pgroup_fix_mod (p : nat) (G : {group aT}) (S : {set sT}) :\n  p.-group G -> [acts G, on S | to] -> #|S| = #|'Fix_(S | to)(G)| %[mod p].\nProof.\nmove=> pG nSG; have sGD: G \\subset D := acts_dom nSG.\napply/eqP; rewrite -(cardsID 'Fix_to(G)) eqn_mod_dvd (leq_addr, addKn) //.\nhave: [acts G, on S :\\: 'Fix_to(G) | to]; last move/acts_sum_card_orbit <-.\n  rewrite actsD // -(setIidPr sGD); apply: subset_trans (acts_subnorm_fix _ _).\n  by rewrite setIS ?normG.\napply: dvdn_sum => _ /imsetP[x /setDP[_ nfx] ->].\nhave [k oGx]: {k | #|orbit to G x| = (p ^ k)%N}.\n  by apply: p_natP; apply: pnat_dvd pG; rewrite card_orbit_in ?dvdn_indexg.\ncase: k oGx => [/card_orbit1 fix_x | k ->]; last by rewrite expnS dvdn_mulr.\nby case/afixP: nfx => a Ga; apply/set1P; rewrite -fix_x mem_orbit.\nQed.",
    "Lemma nontrivial_gacent_pgroup G M :\n    p.-group G -> p.-group M -> {acts G, on group M | to} ->\n  M :!=: 1 -> 'C_(M | to)(G) :!=: 1.\nProof.\nmove=> pG pM [nMG sMR] ntM; have [p_pr p_dv_M _] := pgroup_pdiv pM ntM.\nrewrite -cardG_gt1 (leq_trans (prime_gt1 p_pr)) 1?dvdn_leq ?cardG_gt0 //= /dvdn.\nby rewrite gacentE ?(acts_dom nMG) // setIA (setIidPl sMR) -pgroup_fix_mod.\nQed.",
    "Lemma pcore_sub_astab_irr G M :\n    p.-group M -> M \\subset R -> acts_irreducibly G M to ->\n  'O_p(G) \\subset 'C_G(M | to).\nProof.\nmove=> pM sMR /mingroupP[/andP[ntM nMG] minM].\nhave /andP[sGpG nGpG]: 'O_p(G) <| G := gFnormal _ G.\nhave sGD := acts_dom nMG; have sGpD: 'O_p(G) \\subset D := gFsub_trans _ sGD.\nrewrite subsetI sGpG -gacentC //=; apply/setIidPl; apply: minM (subsetIl _ _).\nrewrite nontrivial_gacent_pgroup ?pcore_pgroup //=; last first.\n  by split; rewrite ?gFsub_trans.\nby apply: subset_trans (acts_subnorm_subgacent sGpD nMG); rewrite subsetI subxx.\nQed.",
    "Lemma pcore_faithful_irr_act G M :\n    p.-group M -> M \\subset R -> acts_irreducibly G M to ->\n    [faithful G, on M | to] ->\n  'O_p(G) = 1.\nProof.\nmove=> pM sMR irrG ffulG; apply/trivgP; apply: subset_trans ffulG.\nexact: pcore_sub_astab_irr.\nQed.",
    "Lemma max_pgroup_Sylow P : [max P | p.-subgroup(G) P] = p.-Sylow(G) P.\nProof. by case Sylow's_theorem. Qed.",
    "Lemma Sylow_superset Q :\n  Q \\subset G -> p.-group Q -> {P : {group gT} | p.-Sylow(G) P & Q \\subset P}.\nProof.\nmove=> sQG pQ.\nhave [|P] := @maxgroup_exists _ (p.-subgroup(G)) Q; first exact/andP.\nby rewrite max_pgroup_Sylow; exists P.\nQed.",
    "Lemma Sylow_exists : {P : {group gT} | p.-Sylow(G) P}.\nProof. by case: (Sylow_superset (sub1G G) (pgroup1 _ p)) => P; exists P. Qed.",
    "Lemma Syl_trans : [transitive G, on 'Syl_p(G) | 'JG].\nProof. by case Sylow's_theorem. Qed.",
    "Lemma Sylow_trans P Q :\n  p.-Sylow(G) P -> p.-Sylow(G) Q -> exists2 x, x \\in G & Q :=: P :^ x.\nProof.\nmove=> sylP sylQ; have /[!inE] := (atransP2 Syl_trans) P Q.\nby case=> // x Gx ->; exists x.\nQed.",
    "Lemma Sylow_subJ P Q :\n    p.-Sylow(G) P -> Q \\subset G -> p.-group Q ->\n  exists2 x, x \\in G & Q \\subset P :^ x.\nProof.\nmove=> sylP sQG pQ; have [Px sylPx] := Sylow_superset sQG pQ.\nby have [x Gx ->] := Sylow_trans sylP sylPx; exists x.\nQed.",
    "Lemma Sylow_Jsub P Q :\n    p.-Sylow(G) P -> Q \\subset G -> p.-group Q ->\n  exists2 x, x \\in G & Q :^ x \\subset P.\nProof.\nmove=> sylP sQG pQ; have [x Gx] := Sylow_subJ sylP sQG pQ.\nby exists x^-1; rewrite (groupV, sub_conjgV).\nQed.",
    "Lemma card_Syl P : p.-Sylow(G) P -> #|'Syl_p(G)| = #|G : 'N_G(P)|.\nProof. by case: Sylow's_theorem P. Qed.",
    "Lemma card_Syl_dvd : #|'Syl_p(G)| %| #|G|.\nProof. by case Sylow_exists => P /card_Syl->; apply: dvdn_indexg. Qed.",
    "Lemma card_Syl_mod : prime p -> #|'Syl_p(G)| %% p = 1%N.\nProof. by case Sylow's_theorem. Qed.",
    "Lemma Frattini_arg H P : G <| H -> p.-Sylow(G) P -> G * 'N_H(P) = H.\nProof.\ncase/andP=> sGH nGH sylP; rewrite -normC ?subIset ?nGH ?orbT // -astab1JG.\nmove/subgroup_transitiveP: Syl_trans => ->; rewrite ?inE //.\napply/imsetP; exists P; rewrite ?inE //.\napply/eqP; rewrite eqEsubset -{1}((atransP Syl_trans) P) ?inE // imsetS //=.\nby apply/subsetP=> _ /imsetP[x Hx ->]; rewrite inE -(normsP nGH x Hx) pHallJ2.\nQed.",
    "Lemma Sylow_setI_normal G H P :\n  G <| H -> p.-Sylow(H) P -> p.-Sylow(G) (G :&: P).\nProof.\ncase/normalP=> sGH nGH sylP; have [Q sylQ] := Sylow_exists p G.\nhave /maxgroupP[/andP[sQG pQ] maxQ] := Hall_max sylQ.\nhave [R sylR sQR] := Sylow_superset (subset_trans sQG sGH) pQ.\nhave [[x Hx ->] pR] := (Sylow_trans sylR sylP, pHall_pgroup sylR).\nrewrite -(nGH x Hx) -conjIg pHallJ2.\nhave /maxQ-> //: Q \\subset G :&: R by rewrite subsetI sQG.\nby rewrite /psubgroup subsetIl (pgroupS _ pR) ?subsetIr.\nQed.",
    "Lemma normal_sylowP G :\n  reflect (exists2 P : {group gT}, p.-Sylow(G) P & P <| G)\n          (#|'Syl_p(G)| == 1%N).\nProof.\napply: (iffP idP) => [syl1 | [P sylP nPG]]; last first.\n  by rewrite (card_Syl sylP) (setIidPl _) (indexgg, normal_norm).\nhave [P sylP] := Sylow_exists p G; exists P => //.\nrewrite /normal (pHall_sub sylP); apply/setIidPl; apply/eqP.\nrewrite eqEcard subsetIl -(LagrangeI G 'N(P)) -indexgI /=.\nby rewrite -(card_Syl sylP) (eqP syl1) muln1.\nQed.",
    "Lemma trivg_center_pgroup P : p.-group P -> 'Z(P) = 1 -> P :=: 1.\nProof.\nmove=> pP Z1; apply/eqP/idPn=> ntP.\nhave{ntP} [p_pr p_dv_P _] := pgroup_pdiv pP ntP.\nsuff: p %| #|'Z(P)| by rewrite Z1 cards1 gtnNdvd ?prime_gt1.\nby rewrite /center /dvdn -afixJ -pgroup_fix_mod // astabsJ normG.\nQed.",
    "Lemma p2group_abelian P : p.-group P -> logn p #|P| <= 2 -> abelian P.\nProof.\nmove=> pP lePp2; pose Z := 'Z(P); have sZP: Z \\subset P := center_sub P.\nhave [/(trivg_center_pgroup pP) ->|] := eqVneq Z 1; first exact: abelian1.\ncase/(pgroup_pdiv (pgroupS sZP pP)) => p_pr _ [k oZ].\napply: cyclic_center_factor_abelian.\nhave [->|] := eqVneq (P / Z) 1; first exact: cyclic1.\nhave pPq := quotient_pgroup 'Z(P) pP; case/(pgroup_pdiv pPq) => _ _ [j oPq].\nrewrite prime_cyclic // oPq; case: j oPq lePp2 => //= j.\nrewrite card_quotient ?gFnorm //.\nby rewrite -(Lagrange sZP) lognM // => ->; rewrite oZ !pfactorK ?addnS.\nQed.",
    "Lemma card_p2group_abelian P : prime p -> #|P| = (p ^ 2)%N -> abelian P.\nProof.\nmove=> primep oP; have pP: p.-group P by rewrite /pgroup oP pnatX pnat_id.\nby rewrite (p2group_abelian pP) // oP pfactorK.\nQed.",
    "Lemma Sylow_transversal_gen (T : {set {group gT}}) G :\n    (forall P, P \\in T -> P \\subset G) ->\n    (forall p, p \\in \\pi(G) -> exists2 P, P \\in T & p.-Sylow(G) P) ->\n  << \\bigcup_(P in T) P >> = G.\nProof.\nmove=> G_T T_G; apply/eqP; rewrite eqEcard gen_subG.\napply/andP; split; first exact/bigcupsP.\napply: dvdn_leq (cardG_gt0 _) _; apply/dvdn_partP=> // q /T_G[P T_P sylP].\nby rewrite -(card_Hall sylP); apply: cardSg; rewrite sub_gen // bigcup_sup.\nQed.",
    "Lemma Sylow_gen G : <<\\bigcup_(P : {group gT} | Sylow G P) P>> = G.\nProof.\nset T := [set P : {group gT} | Sylow G P].\nrewrite -{2}(@Sylow_transversal_gen T G) => [|P | q _].\n- by congr <<_>>; apply: eq_bigl => P; rewrite inE.\n- by rewrite inE => /and3P[].\nby case: (Sylow_exists q G) => P sylP; exists P; rewrite // inE (p_Sylow sylP).\nQed.",
    "Lemma Hall_pJsub p pi G H P :\n    pi.-Hall(G) H -> p \\in pi -> P \\subset G -> p.-group P -> \n  exists2 x, x \\in G & P :^ x \\subset H.\nProof.\nmove=> hallH pi_p sPG pP.\nhave [S sylS] := Sylow_exists p H; have sylS_G := subHall_Sylow hallH pi_p sylS.\nhave [x Gx sPxS] := Sylow_Jsub sylS_G sPG pP; exists x => //.\nexact: subset_trans sPxS (pHall_sub sylS).\nQed.",
    "Lemma Hall_psubJ p pi G H P :\n    pi.-Hall(G) H -> p \\in pi -> P \\subset G -> p.-group P -> \n  exists2 x, x \\in G & P \\subset H :^ x.\nProof.\nmove=> hallH pi_p sPG pP; have [x Gx sPxH] := Hall_pJsub hallH pi_p sPG pP.\nby exists x^-1; rewrite ?groupV -?sub_conjg.\nQed.",
    "Lemma Hall_setI_normal pi G K H :\n  K <| G -> pi.-Hall(G) H -> pi.-Hall(K) (H :&: K).\nProof.\nmove=> nsKG hallH; have [sHG piH _] := and3P hallH.\nhave [sHK_H sHK_K] := (subsetIl H K, subsetIr H K).\nrewrite pHallE sHK_K /= -(part_pnat_id (pgroupS sHK_H piH)); apply/eqP.\nrewrite (widen_partn _ (subset_leq_card sHK_K)); apply: eq_bigr => p pi_p.\nhave [P sylP] := Sylow_exists p H.\nhave sylPK := Sylow_setI_normal nsKG (subHall_Sylow hallH pi_p sylP).\nrewrite -!p_part -(card_Hall sylPK); symmetry; apply: card_Hall.\nby rewrite (pHall_subl _ sHK_K) //= setIC setSI ?(pHall_sub sylP).\nQed.",
    "Lemma coprime_mulG_setI_norm H G K R :\n    K * R = G -> G \\subset 'N(H) -> coprime #|K| #|R| ->\n  (K :&: H) * (R :&: H) = G :&: H.\nProof.\nmove=> defG nHG coKR; apply/eqP; rewrite eqEcard mulG_subG /= -defG.\nrewrite !setSI ?mulG_subl ?mulG_subr //=.\nrewrite coprime_cardMg ?(coKR, coprimeSg (subsetIl _ _), coprime_sym) //=.\npose pi := \\pi(K); have piK: pi.-group K by apply: pgroup_pi.\nhave pi'R: pi^'.-group R by rewrite /pgroup -coprime_pi' /=.\nhave [hallK hallR] := coprime_mulpG_Hall defG piK pi'R.\nhave nsHG: H :&: G <| G by rewrite /normal subsetIr normsI ?normG.\nrewrite -!(setIC H) defG -(partnC pi (cardG_gt0 _)).\nrewrite -(card_Hall (Hall_setI_normal nsHG hallR)) /= setICA.\nrewrite -(card_Hall (Hall_setI_normal nsHG hallK)) /= setICA.\nby rewrite -defG (setIidPl (mulG_subl _ _)) (setIidPl (mulG_subr _ _)).\nQed.",
    "Lemma pgroup_nil p P : p.-group P -> nilpotent P.\nProof.\nmove: {2}_.+1 (ltnSn #|P|) => n.\nelim: n gT P => // n IHn pT P; rewrite ltnS=> lePn pP.\nhave [Z1 | ntZ] := eqVneq 'Z(P) 1.\n  by rewrite (trivg_center_pgroup pP Z1) nilpotent1.\nrewrite -quotient_center_nil IHn ?morphim_pgroup // (leq_trans _ lePn) //.\nrewrite card_quotient ?normal_norm ?center_normal // -divgS ?subsetIl //.\nby rewrite ltn_Pdiv // ltnNge -trivg_card_le1.\nQed.",
    "Lemma pgroup_sol p P : p.-group P -> solvable P.\nProof. by move/pgroup_nil; apply: nilpotent_sol. Qed.",
    "Lemma small_nil_class G : nil_class G <= 5 -> nilpotent G.\nProof.\nmove=> leK5; case: (ltnP 5 #|G|) => [lt5G | leG5 {leK5}].\n  by rewrite nilpotent_class (leq_ltn_trans leK5).\napply: pgroup_nil (pdiv #|G|) _ _; apply/andP; split=> //.\nby case: #|G| leG5 => //; do 5!case=> //.\nQed.",
    "Lemma nil_class2 G : (nil_class G <= 2) = (G^`(1) \\subset 'Z(G)).\nProof.\nrewrite subsetI der_sub; apply/idP/commG1P=> [clG2 | L3G1].\n  by apply/(lcn_nil_classP 2); rewrite ?small_nil_class ?(leq_trans clG2).\nby apply/(lcn_nil_classP 2) => //; apply/lcnP; exists 2.\nQed.",
    "Lemma nil_class3 G : (nil_class G <= 3) = ('L_3(G) \\subset 'Z(G)).\nProof.\nrewrite subsetI lcn_sub; apply/idP/commG1P=> [clG3 | L4G1].\n  by apply/(lcn_nil_classP 3); rewrite ?small_nil_class ?(leq_trans clG3).\nby apply/(lcn_nil_classP 3) => //; apply/lcnP; exists 3.\nQed.",
    "Lemma nilpotent_maxp_normal pi G H :\n  nilpotent G -> [max H | pi.-subgroup(G) H] -> H <| G.\nProof.\nmove=> nilG /maxgroupP[/andP[sHG piH] maxH].\nhave nHN: H <| 'N_G(H) by rewrite normal_subnorm.\nhave{maxH} hallH: pi.-Hall('N_G(H)) H.\n  apply: normal_max_pgroup_Hall => //; apply/maxgroupP.\n  rewrite /psubgroup normal_sub // piH; split=> // K.\n  by rewrite subsetI -andbA andbCA => /andP[_ /maxH].\nrewrite /normal sHG; apply/setIidPl/esym.\napply: nilpotent_sub_norm; rewrite ?subsetIl ?setIS //= char_norms //.\nby congr (_ \\char _): (pcore_char pi 'N_G(H)); apply: normal_Hall_pcore.\nQed.",
    "Lemma nilpotent_Hall_pcore pi G H :\n  nilpotent G -> pi.-Hall(G) H -> H :=: 'O_pi(G).\nProof.\nmove=> nilG hallH; have maxH := Hall_max hallH; apply/eqP.\nrewrite eqEsubset pcore_max ?(pHall_pgroup hallH) //.\n  by rewrite (normal_sub_max_pgroup maxH) ?pcore_pgroup ?pcore_normal.\nexact: nilpotent_maxp_normal maxH.\nQed.",
    "Lemma nilpotent_pcore_Hall pi G : nilpotent G -> pi.-Hall(G) 'O_pi(G).\nProof.\nmove=> nilG; case: (@maxgroup_exists _ (psubgroup pi G) 1) => [|H maxH _].\n  by rewrite /psubgroup sub1G pgroup1.\nhave hallH := normal_max_pgroup_Hall maxH (nilpotent_maxp_normal nilG maxH).\nby rewrite -(nilpotent_Hall_pcore nilG hallH).\nQed.",
    "Lemma nilpotent_pcoreC pi G : nilpotent G -> 'O_pi(G) \\x 'O_pi^'(G) = G.\nProof.\nmove=> nilG; have trO: 'O_pi(G) :&: 'O_pi^'(G) = 1.\n  by apply: coprime_TIg; apply: (@pnat_coprime pi); apply: pcore_pgroup.\nrewrite dprodE //.\n  apply/eqP; rewrite eqEcard mul_subG ?pcore_sub // (TI_cardMg trO).\n  by rewrite !(card_Hall (nilpotent_pcore_Hall _ _)) // partnC ?leqnn.\nrewrite (sameP commG1P trivgP) -trO subsetI commg_subl commg_subr.\nby rewrite !gFsub_trans ?gFnorm.\nQed.",
    "Lemma sub_nilpotent_cent2 H K G :\n    nilpotent G -> K \\subset G -> H \\subset G -> coprime #|K| #|H| ->\n  H \\subset 'C(K).\nProof.\nmove=> nilG sKG sHG; rewrite coprime_pi' // => p'H.\nhave sub_Gp := sub_Hall_pcore (nilpotent_pcore_Hall _ nilG).\nhave [_ _ cGpp' _] := dprodP (nilpotent_pcoreC \\pi(K) nilG).\nby apply: centSS cGpp'; rewrite sub_Gp ?pgroup_pi.\nQed.",
    "Lemma pi_center_nilpotent G : nilpotent G -> \\pi('Z(G)) = \\pi(G).\nProof.\nmove=> nilG; apply/eq_piP => /= p.\napply/idP/idP=> [|pG]; first exact: (piSg (center_sub _)).\nmove: (pG); rewrite !mem_primes !cardG_gt0; case/andP=> p_pr _.\npose Z := 'O_p(G) :&: 'Z(G); have ntZ: Z != 1.\n  rewrite meet_center_nil ?pcore_normal // trivg_card_le1 -ltnNge.\n  rewrite (card_Hall (nilpotent_pcore_Hall p nilG)) p_part.\n  by rewrite (ltn_exp2l 0 _ (prime_gt1 p_pr)) logn_gt0.\nhave pZ: p.-group Z := pgroupS (subsetIl _ _) (pcore_pgroup _ _).\nhave{ntZ pZ} [_ pZ _] := pgroup_pdiv pZ ntZ.\nby rewrite p_pr (dvdn_trans pZ) // cardSg ?subsetIr.\nQed.",
    "Lemma Sylow_subnorm p G P : p.-Sylow('N_G(P)) P = p.-Sylow(G) P.\nProof.\napply/idP/idP=> sylP; last first.\n  apply: pHall_subl (subsetIl _ _) (sylP).\n  by rewrite subsetI normG (pHall_sub sylP).\nhave [/subsetIP[sPG sPN] pP _] := and3P sylP.\nhave [Q sylQ sPQ] := Sylow_superset sPG pP; have [sQG pQ _] := and3P sylQ.\nrewrite -(nilpotent_sub_norm (pgroup_nil pQ) sPQ) {sylQ}//.\nrewrite subEproper eq_sym eqEcard subsetI sPQ sPN dvdn_leq //.\nrewrite -(part_pnat_id (pgroupS (subsetIl _ _) pQ)) (card_Hall sylP).\nby rewrite partn_dvd // cardSg ?setSI.\nQed.",
    "Lemma nil_class_pgroup (gT : finGroupType) (p : nat) (P : {group gT}) :\n  p.-group P -> nil_class P <= maxn 1 (logn p #|P|).-1.\nProof.\nmove=> pP; move def_c: (nil_class P) => c.\nelim: c => // c IHc in gT P def_c pP *; set e := logn p _.\nhave nilP := pgroup_nil pP; have sZP := center_sub P.\nhave [e_le2 | e_gt2] := leqP e 2.\n  by rewrite -def_c leq_max nil_class1 (p2group_abelian pP).\nhave pPq: p.-group (P / 'Z(P)) by apply: quotient_pgroup.\nrewrite -(subnKC e_gt2) ltnS (leq_trans (IHc _ _ _ pPq)) //.\n  by rewrite nil_class_quotient_center ?def_c.\nrewrite geq_max /= -add1n -leq_subLR -subn1 -subnDA -subSS leq_sub2r //.\nrewrite ltn_log_quotient //= -(setIidPr sZP) meet_center_nil //.\nby rewrite -nil_class0 def_c.\nQed.",
    "Lemma ZgroupS G H : H \\subset G -> Zgroup G -> Zgroup H.\nProof.\nmove=> sHG /forallP zgG; apply/forall_inP=> V /SylowP[p p_pr /and3P[sVH]].\ncase/(Sylow_superset (subset_trans sVH sHG))=> P sylP sVP _.\nby have:= zgG P; rewrite (p_Sylow sylP); apply: cyclicS.\nQed.",
    "Lemma morphim_Zgroup G : Zgroup G -> Zgroup (f @* G).\nProof.\nmove=> zgG; wlog sGD: G zgG / G \\subset D.\n  by rewrite -morphimIdom; apply; rewrite (ZgroupS _ zgG, subsetIl) ?subsetIr.\napply/forall_inP=> fV /SylowP[p pr_p sylfV].\nhave [P sylP] := Sylow_exists p G.\nhave [|z _ ->] := @Sylow_trans p _ _ (f @* P)%G _ _ sylfV.\n  by apply: morphim_pHall (sylP); apply: subset_trans (pHall_sub sylP) sGD.\nby rewrite cyclicJ morphim_cyclic ?(forall_inP zgG) //; apply/SylowP; exists p.\nQed.",
    "Lemma nil_Zgroup_cyclic G : Zgroup G -> nilpotent G -> cyclic G.\nProof.\nhave [n] := ubnP #|G|; elim: n G => // n IHn G /ltnSE-leGn ZgG nilG.\nhave [->|[p pr_p pG]] := trivgVpdiv G; first by rewrite -cycle1 cycle_cyclic.\nhave /dprodP[_ defG Cpp' _] := nilpotent_pcoreC p nilG.\nhave /cyclicP[x def_p]: cyclic 'O_p(G).\n  have:= forallP ZgG 'O_p(G)%G.\n  by rewrite (p_Sylow (nilpotent_pcore_Hall p nilG)).\nhave /cyclicP[x' def_p']: cyclic 'O_p^'(G).\n  have sp'G := pcore_sub p^' G.\n  apply: IHn (leq_trans _ leGn) (ZgroupS sp'G _) (nilpotentS sp'G _) => //.\n  rewrite proper_card // properEneq sp'G andbT; case: eqP => //= def_p'.\n  by have:= pcore_pgroup p^' G; rewrite def_p' /pgroup p'natE ?pG.\napply/cyclicP; exists (x * x'); rewrite -{}defG def_p def_p' cycleM //.\n  by red; rewrite -(centsP Cpp') // (def_p, def_p') cycle_id.\nby rewrite /order -def_p -def_p' (@pnat_coprime p) //; apply: pcore_pgroup.\nQed.",
    "Lemma normal_pgroup r P N :\n    p.-group P -> N <| P -> r <= logn p #|N| ->\n  exists Q : {group gT}, [/\\ Q \\subset N, Q <| P & #|Q| = (p ^ r)%N].\nProof.\nelim: r gT P N => [|r IHr] gTr P N pP nNP le_r.\n  by exists (1%G : {group gTr}); rewrite sub1G normal1 cards1.\nhave [NZ_1 | ntNZ] := eqVneq (N :&: 'Z(P)) 1.\n  by rewrite (TI_center_nil (pgroup_nil pP)) // cards1 logn1 in le_r.\nhave: p.-group (N :&: 'Z(P)) by apply: pgroupS pP; rewrite /= setICA subsetIl.\ncase/pgroup_pdiv=> // p_pr /Cauchy[// | z].\nrewrite -cycle_subG !subsetI => /and3P[szN szP cPz] ozp _.\nhave{cPz} nzP: P \\subset 'N(<[z]>) by rewrite cents_norm // centsC.\nhave: N / <[z]> <| P / <[z]> by rewrite morphim_normal.\ncase/IHr=> [||Qb [sQNb nQPb]]; first exact: morphim_pgroup.\n  rewrite card_quotient ?(subset_trans (normal_sub nNP)) // -ltnS.\n  apply: (leq_trans le_r); rewrite -(Lagrange szN) [#|_|]ozp.\n  by rewrite lognM // ?prime_gt0 // logn_prime ?eqxx.\ncase/(inv_quotientN _): nQPb sQNb => [|Q -> szQ nQP]; first exact/andP.\nhave nzQ := subset_trans (normal_sub nQP) nzP.\nrewrite quotientSGK // card_quotient // => sQN izQ.\nby exists Q; split=> //; rewrite expnS -izQ -ozp Lagrange.\nQed.",
    "Lemma aut_dvdn : #[aut_of] %| #[a].\nProof.\nrewrite order_Zp1 /aut_of; case: pickP => [s | _]; last by rewrite order1.\nby case/and4P=> _ p_gt1 p_s _; rewrite Zp_cast.\nQed.",
    "Lemma act_dom : <[a]> \\subset act_dom base_act.\nProof.\nrewrite cycle_subG 2!inE cycle_id /= eltm_id /aut_of.\nby case: pickP => [op /andP[] | _] //=; rewrite group1.\nQed.",
    "Lemma card : #|[set: gtype]| = (p * q)%N.\nProof.\nrewrite [gtype.body]unlock -(sdprod_card (sdprod_sdpair _)).\nrewrite !card_injm ?injm_sdpair1 ?injm_sdpair2 //.\nby rewrite mulnC -!orderE !order_Zp1 !Zp_cast.\nQed.",
    "Lemma Grp : (exists s, [/\\ s \\in Aut B, #[s] %| p & s b = b ^+ e]) ->\n  [set: gtype] \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ e).\nProof.\nrewrite [gtype.body]unlock => [[s [AutBs dvd_s_p sb]]].\nhave memB: _ \\in B by move=> c; rewrite -Zp_cycle inE.\nhave Aa: a \\in <[a]> by rewrite !cycle_id.\nhave [oa ob]: #[a] = p /\\ #[b] = q by rewrite !order_Zp1 !Zp_cast.\nhave def_s: aut_of = s.\n  rewrite /aut_of; case: pickP => /= [t | ]; last first.\n    by move/(_ s); case/and4P; rewrite sb.\n  case/and4P=> AutBt _ _ tb; apply: (eq_Aut AutBt) => // b_i.\n  case/cycleP=> i ->; rewrite -(autmE AutBt) -(autmE AutBs) !morphX //=.\n  by rewrite !autmE // sb (eqP tb).\napply: intro_isoGrp => [|gT G].\n  apply/existsP; exists (sdpair1 _ b, sdpair2 _ a); rewrite /= !xpair_eqE.\n  apply/andP; split.\n    by rewrite -!morphim_cycle ?norm_joinEr ?im_sdpair ?im_sdpair_norm ?eqxx //=.\n  rewrite -!order_dvdn !order_injm ?injm_sdpair1 ?injm_sdpair2 // oa ob !dvdnn.\n  by rewrite -sdpair_act // [act _ _ _]apermE /= eltm_id -morphX // -sb -def_s.\ncase/existsP=> -[x y] /= /eqP[defG xq1 yp1 xy].\nhave fxP: #[x] %| #[b] by rewrite order_dvdn ob xq1.\nhave fyP: #[y] %| #[a] by rewrite order_dvdn oa yp1.\nhave fP: {in <[b]> & <[a]>, morph_act gact 'J (eltm fxP) (eltm fyP)}.\n  move=> bj ai; case/cycleP=> j ->{bj}; case/cycleP=> i ->{ai}.\n  rewrite /= !eltmE def_s gactX ?groupX // conjXg morphX //=; congr (_ ^+ j).\n  rewrite /autact /= apermE; elim: i {j} => /= [|i IHi].\n    by rewrite perm1 eltm_id conjg1.\n  rewrite !expgS permM sb -(autmE (groupX i AutBs)) !morphX //= {}IHi.\n  by rewrite -conjXg -xy -conjgM.\napply/homgP; exists (xsdprod_morphism fP).\nrewrite im_xsdprodm !morphim_cycle //= !eltm_id -norm_joinEr //.\nby rewrite norms_cycle xy mem_cycle.\nQed.",
    "Lemma cyclic_pgroup_Aut_structure gT p (G : {group gT}) :\n    p.-group G -> cyclic G -> G :!=: 1 ->\n  let q := #|G| in let n := (logn p q).-1 in\n  let A := Aut G in let P := 'O_p(A) in let F := 'O_p^'(A) in\n  exists m : {perm gT} -> 'Z_q,\n  [/\\ [/\\ {in A & G, forall a x, x ^+ m a = a x},\n          m 1 = 1%R /\\ {in A &, {morph m : a b / a * b >-> (a * b)%R}},\n          {in A &, injective m} /\\ image m A =i GRing.unit,\n          forall k, {in A, {morph m : a / a ^+ k >-> (a ^+ k)%R}}\n        & {in A, {morph m : a / a^-1 >-> (a^-1)%R}}],\n      [/\\ abelian A, cyclic F, #|F| = p.-1\n        & [faithful F, on 'Ohm_1(G) | [Aut G]]]\n    & if n == 0 then A = F else\n      exists t, [/\\ t \\in A, #[t] = 2, m t = (- 1)%R\n      & if odd p then\n        [/\\ cyclic A /\\ cyclic P,\n           exists s, [/\\ s \\in A, #[s] = (p ^ n)%N, m s = p.+1%:R & P = <[s]>]\n         & exists s0, [/\\ s0 \\in A, #[s0] = p, m s0 = (p ^ n).+1%:R\n                        & 'Ohm_1(P) = <[s0]>]]\n   else if n == 1%N then A = <[t]>\n   else exists s,\n        [/\\ s \\in A, #[s] = (2 ^ n.-1)%N, m s = 5%:R, <[s]> \\x <[t]> = A\n      & exists s0, [/\\ s0 \\in A, #[s0] = 2, m s0 = (2 ^ n).+1%:R,\n                       m (s0 * t) = (2 ^ n).-1%:R & 'Ohm_1(<[s]>) = <[s0]>]]]].\nProof.\nmove=> pG cycG ntG q n0 A P F; have [p_pr p_dvd_G [n oG]] := pgroup_pdiv pG ntG.\nhave [x0 defG] := cyclicP cycG; have Gx0: x0 \\in G by rewrite defG cycle_id.\nrewrite {1}/q oG pfactorK //= in n0 *; rewrite {}/n0.\nhave [p_gt1 min_p] := primeP p_pr; have p_gt0 := ltnW p_gt1.\nhave q_gt1: q > 1 by rewrite cardG_gt1.\nhave cAA: abelian A := Aut_cyclic_abelian cycG; have nilA := abelian_nil cAA.\nhave oA: #|A| = (p.-1 * p ^ n)%N.\n  by rewrite card_Aut_cyclic // oG totient_pfactor.\nhave [sylP hallF]: p.-Sylow(A) P /\\ p^'.-Hall(A) F.\n  by rewrite !nilpotent_pcore_Hall.\nhave [defPF tiPF]: P * F = A /\\ P :&: F = 1.\n  by case/dprodP: (nilpotent_pcoreC p nilA).\nhave oP: #|P| = (p ^ n)%N.\n  by rewrite (card_Hall sylP) oA p_part logn_Gauss ?coprimenP ?pfactorK.\nhave oF: #|F| = p.-1.\n  apply/eqP; rewrite -(@eqn_pmul2l #|P|) ?cardG_gt0 // -TI_cardMg // defPF.\n  by rewrite oA oP mulnC.\nhave [m' [inj_m' defA def_m']]: exists m' : {morphism units_Zp q >-> {perm gT}},\n  [/\\ 'injm m', m' @* setT = A & {in G, forall x u, m' u x = x ^+ val u}].\n- rewrite /A /q defG; exists (Zp_unit_morphism x0).\n  by have [->]:= isomP (Zp_unit_isom x0); split=> // y Gy u; rewrite permE Gy.\npose m (a : {perm gT}) : 'Z_q := val (invm inj_m' a).\nhave{def_m'} def_m: {in A & G, forall a x, x ^+ m a = a x}.\n  by move=> a x Aa Gx /=; rewrite -{2}[a](invmK inj_m') ?defA ?def_m'.\nhave m1: m 1 = 1%R by rewrite /m morph1.\nhave mM: {in A &, {morph m : a b / a * b >-> (a * b)%R}}.\n  by move=> a b Aa Ab; rewrite /m morphM ?defA.\nhave mX k: {in A, {morph m : a / a ^+ k >-> (a ^+ k)%R}}.\n  by elim: k => // k IHk a Aa; rewrite expgS exprS mM ?groupX ?IHk.\nhave inj_m: {in A &, injective m}.\n  apply: can_in_inj (fun u => m' (insubd (1 : {unit 'Z_q}) u)) _ => a Aa.\n  by rewrite valKd invmK ?defA.\nhave{defA} im_m: image m A =i GRing.unit.\n  move=> u; apply/imageP/idP=> [[a Aa ->]| Uu]; first exact: valP.\n  exists (m' (Sub u Uu)) => /=; first by rewrite -defA mem_morphim ?inE.\n  by rewrite /m invmE ?inE.\nhave mV: {in A, {morph m : a / a^-1 >-> (a^-1)%R}}.\n  move=> a Aa /=; rewrite -div1r; apply: canRL (mulrK (valP _)) _.\n  by rewrite -mM ?groupV ?mulVg.\nhave inv_m (u : 'Z_q) : coprime q u -> {a | a \\in A & m a = u}.\n  rewrite -?unitZpE // natr_Zp -im_m => m_u.\n  by exists (iinv m_u); [apply: mem_iinv | rewrite f_iinv].\nhave [cycF ffulF]: cyclic F /\\ [faithful F, on 'Ohm_1(G) | [Aut G]].\n  have Um0 a: ((m a)%:R : 'F_p) \\in GRing.unit.\n    have: m a \\in GRing.unit by apply: valP.\n    by rewrite -{1}[m a]natr_Zp unitFpE ?unitZpE // {1}/q oG coprime_pexpl.\n  pose fm0 a := FinRing.unit 'F_p (Um0 a).\n  have natZqp u: (u%:R : 'Z_q)%:R = u %:R :> 'F_p.\n    by rewrite val_Zp_nat // -Fp_nat_mod // modn_dvdm ?Fp_nat_mod.\n  have m0M: {in A &, {morph fm0 : a b / a * b}}.\n    by move=> a b Aa Ab; apply: val_inj; rewrite /= -natrM mM //= -val_Zp_nat.\n  pose m0 : {morphism A >-> {unit 'F_p}} := Morphism m0M.\n  have im_m0: m0 @* A = [set: {unit 'F_p}].\n    apply/setP=> [[/= u Uu]]; rewrite in_setT morphimEdom; apply/imsetP.\n    have [|a Aa m_a] := inv_m u%:R.\n      by rewrite {1}[q]oG coprime_pexpl // -unitFpE // natZqp natr_Zp.\n    by exists a => //; apply: val_inj; rewrite /= m_a natZqp natr_Zp.\n  have [x1 defG1]: exists x1, 'Ohm_1(G) = <[x1]>.\n    by apply/cyclicP; apply: cyclicS (Ohm_sub _ _) cycG.\n  have ox1: #[x1] = p by rewrite orderE -defG1 (Ohm1_cyclic_pgroup_prime _ pG).\n  have Gx1: x1 \\in G by rewrite -cycle_subG -defG1 Ohm_sub.\n  have ker_m0: 'ker m0 = 'C('Ohm_1(G) | [Aut G]).\n    apply/setP=> a; rewrite inE in_setI; apply: andb_id2l => Aa.\n    rewrite 3!inE /= -2!val_eqE /= val_Fp_nat // [1 %% _]modn_small // defG1.\n    apply/idP/subsetP=> [ma1 x1i | ma1].\n      case/cycleP=> i ->{x1i}; rewrite inE gactX // -[_ a]def_m //.\n      by rewrite -(expg_mod_order x1) ox1 (eqP ma1).\n    have:= ma1 x1 (cycle_id x1); rewrite inE -[_ a]def_m //.\n    by rewrite (eq_expg_mod_order x1 _ 1) ox1 (modn_small p_gt1).\n  have card_units_Fp: #|[set: {unit 'F_p}]| = p.-1.\n    by rewrite card_units_Zp // pdiv_id // (@totient_pfactor p 1) ?muln1.\n  have ker_m0_P: 'ker m0 = P.\n    apply: nilpotent_Hall_pcore nilA _.\n    rewrite pHallE -(card_Hall sylP) oP subsetIl /=.\n    rewrite -(@eqn_pmul2r #|m0 @* A|) ?cardG_gt0 //; apply/eqP.\n    rewrite -{1}(card_isog (first_isog _)) card_quotient ?ker_norm //.\n    by rewrite Lagrange ?subsetIl // oA im_m0 mulnC card_units_Fp.\n  have inj_m0: 'ker_F m0 \\subset [1] by rewrite setIC ker_m0_P tiPF.\n  split; last by rewrite /faithful -ker_m0.\n  have isogF: F \\isog [set: {unit 'F_p}].\n    have sFA: F \\subset A by apply: pcore_sub.\n    apply/isogP; exists (restrm_morphism sFA m0); first by rewrite ker_restrm.\n    apply/eqP; rewrite eqEcard subsetT card_injm ?ker_restrm //= oF.\n    by rewrite card_units_Fp.\n  rewrite (isog_cyclic isogF) pdiv_id // -ox1 (isog_cyclic (Zp_unit_isog x1)).\n  by rewrite Aut_prime_cyclic // -orderE ox1.\nexists m; split=> {im_m mV}//; have [n0 | n_gt0] := posnP n.\n  by apply/eqP; rewrite eq_sym eqEcard pcore_sub oF oA n0 muln1 /=.\nhave [t At mt]: {t | t \\in A & m t = -1}%R.\n  apply: inv_m; rewrite /= Zp_cast // coprime_modr modn_small // subn1.\n  by rewrite coprimenP // ltnW.\nhave ot: #[t] = 2.\n  apply/eqP; rewrite eqn_leq order_gt1 dvdn_leq ?order_dvdn //=.\n    apply/eqP; move/(congr1 m); apply/eqP; rewrite mt m1 eq_sym -subr_eq0.\n    rewrite opprK -val_eqE /= Zp_cast ?modn_small // /q oG ltnW //.\n    by rewrite (leq_trans (_ : 2 ^ 2 <= p ^ 2)) ?leq_sqr ?leq_exp2l.\n  by apply/eqP; apply: inj_m; rewrite ?groupX ?group1 ?mX // mt -signr_odd.\nexists t; split=> //.\ncase G4: (~~ odd p && (n == 1%N)).\n  case: (even_prime p_pr) G4 => [p2 | -> //]; rewrite p2 /=; move/eqP=> n1.\n  rewrite n1 /=; apply/eqP; rewrite eq_sym eqEcard cycle_subG At /=.\n  by rewrite -orderE oA ot p2 n1.\npose e0 : nat := ~~ odd p.\nhave{inv_m} [s As ms]: {s | s \\in A & m s = (p ^ e0.+1).+1%:R}.\n  apply: inv_m; rewrite val_Zp_nat // coprime_modr /q oG coprime_pexpl //.\n  by rewrite -(@coprime_pexpl e0.+1) // coprimenS.\nhave lt_e0_n: e0 < n.\n  by rewrite /e0; case: (~~ _) G4 => //=; rewrite ltn_neqAle eq_sym => ->.\npose s0 := s ^+ (p ^ (n - e0.+1)).\nhave [ms0 os0]: m s0 = (p ^ n).+1%:R /\\ #[s0] = p.\n  have m_se e:\n    exists2 k, k = 1 %[mod p] & m (s ^+ (p ^ e)) = (k * p ^ (e + e0.+1)).+1%:R.\n  - elim: e => [|e [k k1 IHe]]; first by exists 1%N; rewrite ?mul1n.\n    rewrite expnSr expgM mX ?groupX // {}IHe -natrX -(add1n (k * _)).\n    rewrite expnDn -(prednK p_gt0) 2!big_ord_recl /= prednK // !exp1n bin1.\n    rewrite bin0 muln1 mul1n mulnCA -expnS (addSn e).\n    set f := (e + _)%N; set sum := (\\sum_i _)%N.\n    exists (sum %/ p ^ f.+2 * p + k)%N; first by rewrite modnMDl.\n    rewrite -(addnC k) mulnDl -mulnA -expnS divnK // {}/sum.\n    apply big_ind => [||[i _] /= _]; [exact: dvdn0 | exact: dvdn_add |].\n    rewrite exp1n mul1n /bump !add1n expnMn mulnCA dvdn_mull // -expnM.\n    case: (ltnP f.+1 (f * i.+2)) => [le_f_fi|].\n      by rewrite dvdn_mull ?dvdn_exp2l.\n    rewrite {1}mulnS -(addn1 f) leq_add2l {}/f addnS /e0.\n    case: i e => [] // [] //; case odd_p: (odd p) => //= _.\n    by rewrite bin2odd // mulnAC dvdn_mulr.\n  have [[|d]] := m_se (n - e0.+1)%N; first by rewrite mod0n modn_small.\n  move/eqP; rewrite -/s0 eqn_mod_dvd ?subn1 //=; case/dvdnP=> f -> {d}.\n  rewrite subnK // mulSn -mulnA -expnS -addSn natrD natrM -oG pchar_Zp //.\n  rewrite mulr0 addr0 => m_s0; split => //.\n  have [d _] := m_se (n - e0)%N; rewrite -subnSK // expnSr expgM -/s0.\n  rewrite addSn subnK // -oG  mulrS natrM pchar_Zp // {d}mulr0 addr0.\n  move/eqP; rewrite -m1 (inj_in_eq inj_m) ?group1 ?groupX // -order_dvdn.\n  move/min_p; rewrite order_eq1; case/predU1P=> [s0_1 | ]; last by move/eqP.\n  move/eqP: m_s0; rewrite eq_sym s0_1 m1 -subr_eq0 mulrSr addrK -val_eqE /=.\n  have pf_gt0: p ^ _ > 0 by move=> e; rewrite expn_gt0 p_gt0.\n  by rewrite val_Zp_nat // /q oG [_ == _]pfactor_dvdn // pfactorK ?ltnn.\nhave os: #[s] = (p ^ (n - e0))%N.\n  have: #[s] %| p ^ (n - e0).\n    by rewrite order_dvdn -subnSK // expnSr expgM -order_dvdn os0.\n  case/dvdn_pfactor=> // d; rewrite leq_eqVlt.\n  case/predU1P=> [-> // | lt_d os]; case/idPn: (p_gt1); rewrite -os0.\n  by rewrite order_gt1 negbK -order_dvdn os dvdn_exp2l // -ltnS -subSn.\nhave p_s: p.-elt s by rewrite /p_elt os pnatX ?pnat_id.\nhave defS1: 'Ohm_1(<[s]>) = <[s0]>.\n  apply/eqP; rewrite eq_sym eqEcard cycle_subG -orderE os0.\n  rewrite (Ohm1_cyclic_pgroup_prime _ p_s) ?cycle_cyclic ?leqnn ?cycle_eq1 //=.\n    rewrite (OhmE _ p_s) mem_gen ?groupX //= !inE mem_cycle //.\n    by rewrite -order_dvdn os0 ?dvdnn.\n  by apply/eqP=> s1; rewrite -os0 /s0 s1 expg1n order1 in p_gt1.\ncase: (even_prime p_pr) => [p2 | oddp]; last first.\n  rewrite {+}/e0 oddp subn0 in s0 os0 ms0 os ms defS1 *.\n  have [f defF] := cyclicP cycF; have defP: P = <[s]>.\n    apply/eqP; rewrite eq_sym eqEcard -orderE oP os leqnn andbT.\n    by rewrite cycle_subG (mem_normal_Hall sylP) ?pcore_normal.\n  rewrite defP; split; last 1 [by exists s | by exists s0; rewrite ?groupX].\n  rewrite -defPF defP defF -cycleM ?cycle_cyclic // /order.\n    by red; rewrite (centsP cAA) // -cycle_subG -defF pcore_sub.\n  by rewrite -defF -defP (pnat_coprime (pcore_pgroup _ _) (pcore_pgroup _ _)).\nrewrite {+}/e0 p2 subn1 /= in s0 os0 ms0 os ms G4 defS1 lt_e0_n *.\nrewrite G4; exists s; split=> //; last first.\n  exists s0; split; rewrite ?groupX //; apply/eqP; rewrite mM ?groupX //.\n  rewrite ms0 mt eq_sym mulrN1 -subr_eq0 opprK -natrD -addSnnS.\n  by rewrite prednK ?expn_gt0 // addnn -mul2n -expnS -p2 -oG pchar_Zp.\nsuffices TIst: <[s]> :&: <[t]> = 1.\n  rewrite dprodE //; last by rewrite (sub_abelian_cent2 cAA) ?cycle_subG.\n  apply/eqP; rewrite eqEcard mulG_subG !cycle_subG As At oA.\n  by rewrite TI_cardMg // -!orderE os ot p2 mul1n /= -expnSr prednK.\nrewrite setIC; apply: prime_TIg; first by rewrite -orderE ot.\nrewrite cycle_subG; apply/negP=> St.\nhave: t \\in <[s0]>.\n  by rewrite -defS1 (OhmE _ p_s) mem_gen // !inE St -order_dvdn ot p2.\nhave ->: <[s0]> = [set 1; s0].\n  apply/eqP; rewrite eq_sym eqEcard subUset !sub1set group1 cycle_id /=.\n  by rewrite -orderE cards2 eq_sym -order_gt1 os0.\nrewrite !inE -order_eq1 ot /=; move/eqP; move/(congr1 m); move/eqP.\nrewrite mt ms0 eq_sym -subr_eq0 opprK -mulrSr.\nrewrite -val_eqE [val _]val_Zp_nat //= /q oG p2 modn_small //.\nby rewrite -addn3 expnS mul2n -addnn leq_add2l (ltn_exp2l 1).\nQed.",
    "Lemma extremal_generators_facts gT (G : {group gT}) p n x y :\n    prime p -> extremal_generators G p n (x, y) ->\n  [/\\ p.-group G, maximal <[x]> G, <[x]> <| G,\n      <[x]> * <[y]> = G & <[y]> \\subset 'N(<[x]>)].\nProof.\nmove=> p_pr [oG Gx ox] /setDP[Gy notXy].\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave maxX: maximal <[x]> G.\n  rewrite p_index_maximal -?divgS ?cycle_subG // -orderE oG ox.\n  case: (n) oG => [|n' _]; last by rewrite -expnB ?subSnn ?leqnSn ?prime_gt0.\n  move/eqP; rewrite -trivg_card1; case/trivgPn.\n  by exists y; rewrite // (group1_contra notXy).\nhave nsXG := p_maximal_normal pG maxX; split=> //.\n  by apply: mulg_normal_maximal; rewrite ?cycle_subG.\nby rewrite cycle_subG (subsetP (normal_norm nsXG)).\nQed.",
    "Lemma card_modular_group : #|'Mod_(p ^ n)| = (p ^ n)%N.\nProof. by rewrite Extremal.card def_p ?def_q // -expnS def_n. Qed.",
    "Lemma Grp_modular_group :\n  'Mod_(p ^ n) \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ r.+1).\nProof.\nrewrite /modular_gtype def_p def_q def_r; apply: Extremal.Grp => //.\nset B := <[_]>; have Bb: Zp1 \\in B by apply: cycle_id.\nhave oB: #|B| = q by rewrite -orderE order_Zp1 Zp_cast.\nhave cycB: cyclic B by rewrite cycle_cyclic.\nhave pB: p.-group B by rewrite /pgroup oB pnatX ?pnat_id.\nhave ntB: B != 1 by rewrite -cardG_gt1 oB.\nhave [] := cyclic_pgroup_Aut_structure pB cycB ntB.\nrewrite oB pfactorK //= -/B -(expg_znat r.+1 Bb) oB => mB [[def_mB _ _ _ _] _].\nrewrite {1}def_n /= => [[t [At ot mBt]]].\nhave [p2 | ->] := even_prime p_pr; last first.\n  by case=> _ _ [s [As os mBs _]]; exists s; rewrite os -mBs def_mB.\nrewrite {1}p2 /= -2!eqSS -addn2 -2!{1}subn1 -subnDA subnK 1?ltnW //.\ncase: eqP => [n3 _ | _ [_ [_ _ _ _ [s [As os mBs _ _]{t At ot mBt}]]]].\n  by exists t; rewrite At ot -def_mB // mBt /q /r p2 n3.\nby exists s; rewrite As os -def_mB // mBs /r p2.\nQed.",
    "Lemma generators_modular_group gT (G : {group gT}) :\n    G \\isog 'Mod_m ->\n  exists2 xy, extremal_generators G p n xy & modular_group_generators xy.\nProof.\ncase/(isoGrpP _ Grp_modular_group); rewrite card_modular_group // -/m => oG.\ncase/existsP=> -[x y] /= /eqP[defG xq yp xy].\nrewrite norm_joinEr ?norms_cycle ?xy ?mem_cycle // in defG.\nhave [Gx Gy]: x \\in G /\\ y \\in G.\n  by apply/andP; rewrite -!cycle_subG -mulG_subG defG.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm; rewrite -cycle_subG -oG -defG; move/mulGidPl->.\n  by rewrite -leqNgt dvdn_leq ?(ltnW q_gt1) // order_dvdn xq.\nhave oy: #[y] = p by apply: nt_prime_order (group1_contra notXy).\nexists (x, y) => //=; split; rewrite ?inE ?notXy //.\napply/eqP; rewrite -(eqn_pmul2r p_gt0) -expnSr -{1}oy (ltn_predK n_gt2) -/m.\nby rewrite -TI_cardMg ?defG ?oG // setIC prime_TIg ?cycle_subG // -orderE oy.\nQed.",
    "Lemma modular_group_structure gT (G : {group gT}) x y :\n    extremal_generators G p n (x, y) ->\n    G \\isog 'Mod_m -> modular_group_generators (x, y) ->\n  let X := <[x]> in\n  [/\\ [/\\ X ><| <[y]> = G, ~~ abelian G\n        & {in X, forall z j, z ^ (y ^+ j) = z ^+ (j * r).+1}],\n      [/\\ 'Z(G) = <[x ^+ p]>, 'Phi(G) = 'Z(G) & #|'Z(G)| = r],\n      [/\\ G^`(1) = <[x ^+ r]>, #|G^`(1)| = p & nil_class G = 2],\n      forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (p ^ k)]>\n    & if (p, n) == (2, 3) then 'Ohm_1(G) = G else\n      forall k, 0 < k < n.-1 ->\n         <[x ^+ (p ^ (n - k.+1))]> \\x <[y]> = 'Ohm_k(G)\n      /\\ #|'Ohm_k(G)| = (p ^ k.+1)%N].\nProof.\nmove=> genG isoG [oy xy] X.\nhave [oG Gx ox /setDP[Gy notXy]] := genG; rewrite -/m -/q in ox oG.\nhave [pG _ nsXG defXY nXY] := extremal_generators_facts p_pr genG.\nhave [sXG nXG] := andP nsXG; have sYG: <[y]> \\subset G by rewrite cycle_subG.\nhave n1_gt1: n.-1 > 1 by [rewrite def_n]; have n1_gt0 := ltnW n1_gt1.\nhave def_n1 := prednK n1_gt0.\nhave def_m: (q * p)%N = m by rewrite -expnSr /m def_n.\nhave notcxy: y \\notin 'C[x].\n  apply: contraL (introT eqP xy); move/cent1P=> cxy.\n  rewrite /conjg -cxy // eq_mulVg1 expgS !mulKg -order_dvdn ox.\n  by rewrite pfactor_dvdn ?expn_gt0 ?p_gt0 // pfactorK // -ltnNge prednK.\nhave tiXY: <[x]> :&: <[y]> = 1.\n  rewrite setIC prime_TIg -?orderE ?oy //; apply: contra notcxy.\n  by rewrite cycle_subG; apply: subsetP; rewrite cycle_subG cent1id.\nhave notcGG: ~~ abelian G.\n  by rewrite -defXY abelianM !cycle_abelian cent_cycle cycle_subG.\nhave cXpY: <[y]> \\subset 'C(<[x ^+ p]>).\n  rewrite cent_cycle cycle_subG cent1C (sameP cent1P commgP) /commg conjXg xy.\n  by rewrite -expgM mulSn expgD mulKg -expnSr def_n1 -/q -ox expg_order.\nhave oxp: #[x ^+ p] = r by rewrite orderXdiv ox ?dvdn_exp //.\nhave [sZG nZG] := andP (center_normal G).\nhave defZ: 'Z(G) = <[x ^+ p]>.\n  apply/eqP; rewrite eq_sym eqEcard subsetI -{2}defXY centM subsetI cent_cycle.\n  rewrite 2!cycle_subG !groupX ?cent1id //= centsC cXpY /= -orderE oxp leqNgt.\n  apply: contra notcGG => gtZr; apply: cyclic_center_factor_abelian.\n  rewrite (dvdn_prime_cyclic p_pr) // card_quotient //.\n  rewrite -(dvdn_pmul2l (cardG_gt0 'Z(G))) Lagrange // oG -def_m dvdn_pmul2r //.\n  case/p_natP: (pgroupS sZG pG) gtZr => k ->.\n  by rewrite ltn_exp2l // def_n1; apply: dvdn_exp2l.\nhave Zxr: x ^+ r \\in 'Z(G) by rewrite /r def_n expnS expgM defZ mem_cycle.\nhave rxy: [~ x, y] = x ^+ r by rewrite /commg xy expgS mulKg.\nhave defG': G^`(1) = <[x ^+ r]>.\n  case/setIP: Zxr => _; rewrite -rxy -defXY -(norm_joinEr nXY).\n  exact: der1_joing_cycles.\nhave oG': #|G^`(1)| = p.\n  by rewrite defG' -orderE orderXdiv ox /q -def_n1 ?dvdn_exp2l // expnS mulnK.\nhave sG'Z: G^`(1) \\subset 'Z(G) by rewrite defG' cycle_subG.\nhave nil2_G: nil_class G = 2.\n  by apply/eqP; rewrite eqn_leq andbC ltnNge nil_class1 notcGG nil_class2.\nhave XYp: {in X & <[y]>, forall z t,\n   (z * t) ^+ p \\in z ^+ p *: <[x ^+ r ^+ 'C(p, 2)]>}.\n- move=> z t Xz Yt; have Gz := subsetP sXG z Xz; have Gt := subsetP sYG t Yt.\n  have Rtz: [~ t, z] \\in G^`(1) by apply: mem_commg.\n  have cGtz: [~ t, z] \\in 'C(G) by case/setIP: (subsetP sG'Z _ Rtz).\n  rewrite expMg_Rmul /commute ?(centP cGtz) //.\n  have ->: t ^+ p = 1 by apply/eqP; rewrite -order_dvdn -oy order_dvdG.\n  rewrite defG' in Rtz; case/cycleP: Rtz => i ->.\n  by rewrite mem_lcoset mulg1 mulKg expgAC mem_cycle.\nhave defMho: 'Mho^1(G) = <[x ^+ p]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (Mho_p_elt 1) ?(mem_p_elt pG) //.\n  rewrite andbT (MhoE 1 pG) gen_subG -defXY; apply/subsetP=> ztp.\n  case/imsetP=> zt; case/imset2P=> z t Xz Yt -> -> {zt ztp}.\n  apply: subsetP (XYp z t Xz Yt); case/cycleP: Xz => i ->.\n  by rewrite expgAC mul_subG ?sub1set ?mem_cycle //= -defZ cycle_subG groupX.\nsplit=> //; try exact: extend_cyclic_Mho.\n- rewrite sdprodE //; split=> // z; case/cycleP=> i ->{z} j.\n  rewrite conjXg -expgM mulnC expgM actX; congr (_ ^+ i).\n  elim: j {i} => //= j ->; rewrite conjXg xy -!expgM mulnS mulSn addSn.\n  rewrite addnA -mulSn -addSn expgD mulnCA (mulnC j).\n  rewrite {3}/r def_n expnS mulnA -expnSr def_n1 -/q -ox -mulnA expgM.\n  by rewrite expg_order expg1n mulg1.\n- by rewrite (Phi_joing pG) defMho -defZ (joing_idPr _) ?defZ.\nhave G1y: y \\in 'Ohm_1(G).\n  by rewrite (OhmE _ pG) mem_gen // !inE Gy -order_dvdn oy /=.\ncase: eqP => [[p2 n3] | notG8 k]; last case/andP=> k_gt0 lt_k_n1.\n  apply/eqP; rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n  rewrite G1y -(groupMr _ G1y) /= (OhmE _ pG) mem_gen // !inE groupM //.\n  rewrite /q /r p2 n3 in oy ox xy *.\n  by rewrite expgS -mulgA -{1}(invg2id oy) -conjgE xy -expgS -order_dvdn ox.\nhave le_k_n2: k <= n.-2 by rewrite -def_n1 in lt_k_n1.\nsuffices{lt_k_n1} defGk: <[x ^+ (p ^ (n - k.+1))]> \\x <[y]> = 'Ohm_k(G).\n  split=> //; case/dprodP: defGk => _ <- _ tiXkY; rewrite expnSr TI_cardMg //.\n  rewrite -!orderE oy (subnDA 1) subn1 orderXdiv ox ?dvdn_exp2l ?leq_subr //.\n  by rewrite /q -{1}(subnK (ltnW lt_k_n1)) expnD mulKn // expn_gt0 p_gt0.\nsuffices{k k_gt0 le_k_n2} defGn2: <[x ^+ p]> \\x <[y]> = 'Ohm_(n.-2)(G).\n  have:= Ohm_dprod k defGn2; have p_xp := mem_p_elt pG (groupX p Gx).\n  rewrite (Ohm_p_cycle _ p_xp) (Ohm_p_cycle _ (mem_p_elt pG Gy)) oxp oy.\n  rewrite pfactorK ?(pfactorK 1) // (eqnP k_gt0) expg1 -expgM -expnS.\n  rewrite -subSn // -subSS def_n1 def_n => -> /=; rewrite ?add1n subnSK // subn2.\n  by apply/eqP; rewrite eqEsubset OhmS ?Ohm_sub //= -{1}Ohm_id OhmS ?Ohm_leq.\nrewrite dprodEY //=; last by apply/trivgP; rewrite -tiXY setSI ?cycleX.\napply/eqP; rewrite eqEsubset join_subG !cycle_subG /= [in y \\in _]def_n.\nrewrite (subsetP (Ohm_leq G (ltn0Sn _)) y) //= (OhmE _ pG) -/r.\nrewrite mem_gen /=; last by rewrite !inE -order_dvdn oxp groupX /=.\nrewrite gen_subG /= cent_joinEr // -defXY; apply/subsetP=> uv; case/setIP.\ncase/imset2P=> u v Xu Yv ->{uv}; rewrite /r inE def_n expnS expgM.\ncase/lcosetP: (XYp u v Xu Yv) => _ /cycleP[j ->] ->.\ncase/cycleP: Xu => i ->{u}; rewrite -!(expgM, expgD) -order_dvdn ox.\nrewrite (mulnC r) /r {1}def_n expnSr mulnA -mulnDl -mulnA -expnS.\nrewrite subnSK  // subn2 /q -def_n1 expnS dvdn_pmul2r // dvdn_addl.\n  by case/dvdnP=> k ->; rewrite mulnC expgM mem_mulg ?mem_cycle.\ncase: (ltngtP n 3) => [|n_gt3|n3]; first by rewrite ltnNge n_gt2.\n  by rewrite -subnSK // expnSr mulnA dvdn_mull.\ncase: (even_prime p_pr) notG8 => [-> | oddp _]; first by rewrite n3.\nby rewrite bin2odd // -!mulnA dvdn_mulr.\nQed.",
    "Lemma card_ext_dihedral : #|ED| = (p./2 * m)%N.\nProof. by rewrite Extremal.card // /m -mul2n -divn2 mulnA divnK. Qed.",
    "Lemma Grp_ext_dihedral : ED \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x^-1).\nProof.\nsuffices isoED: ED \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ q.-1).\n  move=> gT G; rewrite isoED.\n  apply: eq_existsb => [[x y]] /=; rewrite !xpair_eqE.\n  congr (_ && _); apply: andb_id2l; move/eqP=> xq1; congr (_ && (_ == _)).\n  by apply/eqP; rewrite eq_sym eq_invg_mul -expgS (ltn_predK q_gt1) xq1.\nhave unitrN1 : (- 1)%R \\in GRing.unit by move=> R; rewrite unitrN unitr1.\npose uN1 := FinRing.unit ('Z_#[Zp1 : 'Z_q]) (unitrN1 _).\napply: Extremal.Grp => //; exists (Zp_unitm uN1).\nrewrite Aut_aut order_injm ?injm_Zp_unitm ?in_setT //; split=> //.\n  by rewrite (dvdn_trans _ even_p) // order_dvdn -val_eqE /= mulrNN.\napply/eqP; rewrite autE ?cycle_id // eq_expg_mod_order /=.\nby rewrite order_Zp1 !Zp_cast // !modn_mod (modn_small q_gt1) subn1.\nQed.",
    "Lemma card_dihedral : #|'D_m| = m.\nProof. by rewrite /('D_m)%type def_q card_ext_dihedral ?mul1n. Qed.",
    "Lemma Grp_dihedral : 'D_m \\isog Grp (x : y : x ^+ q, y ^+ 2, x ^ y = x^-1).\nProof. by rewrite /('D_m)%type def_q; apply: Grp_ext_dihedral. Qed.",
    "Lemma Grp'_dihedral : 'D_m \\isog Grp (x : y : x ^+ 2, y ^+ 2, (x * y) ^+ q).\nProof.\nmove=> gT G; rewrite Grp_dihedral; apply/existsP/existsP=> [] [[x y]] /=.\n  case/eqP=> <- xq1 y2 xy; exists (x * y, y); rewrite !xpair_eqE /= eqEsubset.\n  rewrite !join_subG !joing_subr !cycle_subG -{3}(mulgK y x) /=.\n  rewrite 2?groupM ?groupV ?mem_gen ?inE ?cycle_id ?orbT //= -mulgA expgS.\n  by rewrite {1}(conjgC x) xy -mulgA mulKg -(expgS y 1) y2 mulg1 xq1 !eqxx.\ncase/eqP=> <- x2 y2 xyq; exists (x * y, y); rewrite !xpair_eqE /= eqEsubset.\nrewrite !join_subG !joing_subr !cycle_subG -{3}(mulgK y x) /=.\nrewrite 2?groupM ?groupV ?mem_gen ?inE ?cycle_id ?orbT //= xyq y2 !eqxx /=.\nby rewrite eq_sym eq_invg_mul !mulgA mulgK -mulgA -!(expgS _ 1) x2 y2 mulg1.\nQed.",
    "Lemma involutions_gen_dihedral gT (x y : gT) :\n    let G := <<[set x; y]>> in\n  #[x] = 2 -> #[y] = 2 -> x != y -> G \\isog 'D_#|G|.\nProof.\nmove=> G ox oy ne_x_y; pose q := #[x * y].\nhave q_gt1: q > 1 by rewrite order_gt1 -eq_invg_mul invg_expg ox.\nhave homG: G \\homg 'D_q.*2.\n  rewrite Grp'_dihedral //; apply/existsP; exists (x, y); rewrite /= !xpair_eqE.\n  by rewrite joing_idl joing_idr -{1}ox -oy !expg_order !eqxx.\nsuff oG: #|G| = q.*2 by rewrite oG isogEcard oG card_dihedral ?leqnn ?andbT.\nhave: #|G| %| q.*2  by rewrite -card_dihedral ?card_homg.\nhave Gxy: <[x * y]> \\subset G.\n  by rewrite cycle_subG groupM ?mem_gen ?set21 ?set22.\nhave[k oG]: exists k, #|G| = (k * q)%N by apply/dvdnP; rewrite cardSg.\nrewrite oG -mul2n dvdn_pmul2r ?order_gt0 ?dvdn_divisors // !inE /=.\ncase/pred2P=> [k1 | -> //]; case/negP: ne_x_y.\nhave cycG: cyclic G.\n  apply/cyclicP; exists (x * y); apply/eqP.\n  by rewrite eq_sym eqEcard Gxy oG k1 mul1n leqnn.\nhave: <[x]> == <[y]>.\n  by rewrite (eq_subG_cyclic cycG) ?genS ?subsetUl ?subsetUr -?orderE ?ox ?oy.\nby rewrite eqEcard cycle_subG /= cycle2g // !inE -order_eq1 ox; case/andP.\nQed.",
    "Lemma Grp_2dihedral n : n > 1 ->\n  'D_(2 ^ n) \\isog Grp (x : y : x ^+ (2 ^ n.-1), y ^+ 2, x ^ y = x^-1).\nProof.\nmove=> n_gt1; rewrite -(ltn_predK n_gt1) expnS mul2n /=.\nby apply: Grp_dihedral; rewrite (ltn_exp2l 0) // -(subnKC n_gt1).\nQed.",
    "Lemma card_2dihedral n : n > 1 -> #|'D_(2 ^ n)| = (2 ^ n)%N.\nProof.\nmove=> n_gt1; rewrite -(ltn_predK n_gt1) expnS mul2n /= card_dihedral //.\nby rewrite (ltn_exp2l 0) // -(subnKC n_gt1).\nQed.",
    "Lemma card_semidihedral n : n > 3 -> #|'SD_(2 ^ n)| = (2 ^ n)%N.\nProof.\nmove=> n_gt3.\nrewrite /('SD__)%type -(subnKC (ltnW (ltnW n_gt3))) pdiv_pfactor //.\nby rewrite // !expnS !mulKn -?expnS ?Extremal.card //= (ltn_exp2l 0).\nQed.",
    "Lemma Grp_semidihedral n : n > 3 ->\n  'SD_(2 ^ n) \\isog\n     Grp (x : y : x ^+ (2 ^ n.-1), y ^+ 2, x ^ y = x ^+ (2 ^ n.-2).-1).\nProof.\nmove=> n_gt3.\nrewrite /('SD__)%type -(subnKC (ltnW (ltnW n_gt3))) pdiv_pfactor //.\nrewrite !expnS !mulKn // -!expnS /=; set q := (2 ^ _)%N.\nhave q_gt1: q > 1 by rewrite (ltn_exp2l 0).\napply: Extremal.Grp => //; set B := <[_]>.\nhave oB: #|B| = q by rewrite -orderE order_Zp1 Zp_cast.\nhave pB: 2.-group B by rewrite /pgroup oB pnatX.\nhave ntB: B != 1 by rewrite -cardG_gt1 oB.\nhave [] := cyclic_pgroup_Aut_structure pB (cycle_cyclic _) ntB.\nrewrite oB /= pfactorK //= -/B => m [[def_m _ _ _ _] _].\nrewrite -{1 2}(subnKC n_gt3) => [[t [At ot _ [s [_ _ _ defA]]]]].\ncase/dprodP: defA => _ defA cst _.\nhave{cst defA} cAt: t \\in 'C(Aut B).\n  rewrite -defA centM inE -sub_cent1 -cent_cycle centsC cst /=.\n  by rewrite cent_cycle cent1id.\ncase=> s0 [As0 os0 _ def_s0t _]; exists (s0 * t).\nrewrite -def_m ?groupM ?cycle_id // def_s0t !Zp_expg !mul1n valZpK Zp_nat.\nrewrite order_dvdn expgMn /commute 1?(centP cAt) // -{1}os0 -{1}ot.\nby rewrite !expg_order mul1g.\nQed.",
    "Lemma card_quaternion : #|'Q_m| = m. Proof. by case defQ. Qed.",
    "Lemma Grp_quaternion : GrpQ. Proof. by case defQ. Qed.",
    "Lemma eq_Mod8_D8 : 'Mod_8 = 'D_8. Proof. by []. Qed.",
    "Lemma generators_2dihedral :\n    n > 1 -> G \\isog 'D_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in #[y] = 2 /\\ x ^ y = x^-1.\nProof.\nmove=> n_gt1; have [def2q _ ltqm _] := def2qr n_gt1.\ncase/(isoGrpP _ (Grp_2dihedral n_gt1)); rewrite card_2dihedral // -/ m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy groupV cycle_id.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave oy: #[y] = 2 by apply: nt_prime_order (group1_contra notXy).\nhave ox: #[x] = q.\n  apply: double_inj; rewrite -muln2 -oy -mul2n def2q -oG -defG TI_cardMg //.\n  by rewrite setIC prime_TIg ?cycle_subG // -orderE oy.\nexists (x, y) => //=.\nby rewrite oG ox !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed.",
    "Lemma generators_semidihedral :\n    n > 3 -> G \\isog 'SD_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in #[y] = 2 /\\ x ^ y = x ^+ r.-1.\nProof.\nmove=> n_gt3; have [def2q _ ltqm _] := def2qr (ltnW (ltnW n_gt3)).\ncase/(isoGrpP _ (Grp_semidihedral n_gt3)).\nrewrite card_semidihedral // -/m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q -/r => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy mem_cycle.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave oy: #[y] = 2 by apply: nt_prime_order (group1_contra notXy).\nhave ox: #[x] = q.\n  apply: double_inj; rewrite -muln2 -oy -mul2n def2q -oG -defG TI_cardMg //.\n  by rewrite setIC prime_TIg ?cycle_subG // -orderE oy.\nexists (x, y) => //=.\nby rewrite oG ox !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed.",
    "Lemma generators_quaternion :\n    n > 2 -> G \\isog 'Q_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in [/\\ #[y] = 4, y ^+ 2 = x ^+ r & x ^ y = x^-1].\nProof.\nmove=> n_gt2; have [def2q def2r ltqm _] := def2qr (ltnW n_gt2).\ncase/(isoGrpP _ (Grp_quaternion n_gt2)); rewrite card_quaternion // -/m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q -/r => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy groupV cycle_id.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave ox: #[x] = q.\n  apply/eqP; rewrite eqn_leq dvdn_leq ?order_dvdn ?xq //=.\n  rewrite -(leq_pmul2r (order_gt0 y)) mul_cardG defG oG -def2q mulnAC mulnC.\n  rewrite leq_pmul2r // dvdn_leq ?muln_gt0 ?cardG_gt0 // order_dvdn expgM.\n  by rewrite -order_dvdn order_dvdG //= inE {1}y2 !mem_cycle.\nhave oy2: #[y ^+ 2] = 2 by rewrite y2 orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nexists (x, y) => /=; last by rewrite (orderXprime oy2).\nby rewrite oG !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed.",
    "Lemma cancel_index_extremal_groups :\n  cancel index_extremal_group_type (nth NotExtremal enum_extremal_groups).\nProof. by case. Qed.",
    "Lemma bound_extremal_groups (c : extremal_group_type) : pickle c < 6.\nProof. by case: c. Qed.",
    "Lemma dihedral_classP :\n  extremal_class G = Dihedral <-> (exists2 n, n > 1 & G \\isog 'D_(2 ^ n)).\nProof.\nrewrite /extremal_class; split=> [ | [n n_gt1 isoG]].\n  by move: (logn _ _) => n; do 4?case: ifP => //; case/andP; exists n.\nrewrite (card_isog isoG) card_2dihedral // -(ltn_predK n_gt1) pdiv_pfactor //.\nby rewrite pfactorK // (ltn_predK n_gt1) n_gt1 isoG.\nQed.",
    "Lemma quaternion_classP :\n  extremal_class G = Quaternion <-> (exists2 n, n > 2 & G \\isog 'Q_(2 ^ n)).\nProof.\nrewrite /extremal_class; split=> [ | [n n_gt2 isoG]].\n  by move: (logn _ _) => n; do 4?case: ifP => //; case/andP; exists n.\nrewrite (card_isog isoG) card_quaternion // -(ltn_predK n_gt2) pdiv_pfactor //.\nrewrite pfactorK // (ltn_predK n_gt2) n_gt2 isoG.\ncase: andP => // [[n_gt1 isoGD]].\nhave [[x y] genG [oy _ _]]:= generators_quaternion n_gt2 isoG.\nhave [_ _ _ X'y] := genG.\nby case/dihedral2_structure: genG oy => // [[_ ->]].\nQed.",
    "Lemma semidihedral_classP :\n  extremal_class G = SemiDihedral <-> (exists2 n, n > 3 & G \\isog 'SD_(2 ^ n)).\nProof.\nrewrite /extremal_class; split=> [ | [n n_gt3 isoG]].\n  by move: (logn _ _) => n; do 4?case: ifP => //; case/andP; exists n.\nrewrite (card_isog isoG) card_semidihedral //.\nrewrite -(ltn_predK n_gt3) pdiv_pfactor // pfactorK // (ltn_predK n_gt3) n_gt3.\nhave [[x y] genG [oy _]]:= generators_semidihedral n_gt3 isoG.\nhave [_ Gx _ X'y]:= genG.\ncase: andP => [[n_gt1 isoGD]|_].\n  have [[_ oxy _ _] _ _ _]:= semidihedral_structure n_gt3 genG isoG oy.\n  case: (dihedral2_structure n_gt1 genG isoGD) oxy => [[_ ->]] //.\n  by rewrite !inE !groupMl ?cycle_id in X'y *.\ncase: andP => // [[n_gt2 isoGQ]|]; last by rewrite isoG.\nby case: (quaternion_structure n_gt2 genG isoGQ) oy => [[_ ->]].\nQed.",
    "Lemma odd_not_extremal2 : odd #|G| -> ~~ extremal2 G.\nProof.\nrewrite /extremal2 /extremal_class; case: logn => // n'.\ncase: andP => [[n_gt1 isoG] | _].\n  by rewrite (card_isog isoG) card_2dihedral ?oddX.\ncase: andP => [[n_gt2 isoG] | _].\n  by rewrite (card_isog isoG) card_quaternion ?oddX.\ncase: andP => [[n_gt3 isoG] | _].\n  by rewrite (card_isog isoG) card_semidihedral ?oddX.\nby case: ifP.\nQed.",
    "Lemma modular_group_classP :\n  extremal_class G = ModularGroup\n     <-> (exists2 p, prime p &\n          exists2 n, n >= (p == 2) + 3 & G \\isog 'Mod_(p ^ n)).\nProof.\nrewrite /extremal_class; split=> [ | [p p_pr [n n_gt23 isoG]]].\n  move: (pdiv _) => p; set n := logn p _; do 4?case: ifP => //.\n  case/andP=> n_gt2 isoG _ _; rewrite ltnW //= => not_isoG _.\n  exists p; first by move: n_gt2; rewrite /n lognE; case (prime p).\n  exists n => //; case: eqP => // p2; rewrite ltn_neqAle; case: eqP => // n3.\n  by case/idP: not_isoG; rewrite p2 -n3 in isoG *.\nhave n_gt2 := leq_trans (leq_addl _ _) n_gt23; have n_gt1 := ltnW n_gt2.\nhave n_gt0 := ltnW n_gt1; have def_n := prednK n_gt0.\nhave [[x y] genG mod_xy] := generators_modular_group p_pr n_gt2 isoG.\ncase/modular_group_structure: (genG) => // _ _ [_ _ nil2G] _ _.\nhave [oG _ _ _] := genG; have [oy _] := mod_xy.\nrewrite oG -def_n pdiv_pfactor // def_n pfactorK // n_gt1 n_gt2 {}isoG /=.\ncase: (ltngtP p 2) => [|p_gt2|p2]; first by rewrite ltnNge prime_gt1.\n  rewrite !(isog_sym G) !isogEcard card_2dihedral ?card_quaternion //= oG.\n  rewrite leq_exp2r // leqNgt p_gt2 !andbF; case: and3P=> // [[n_gt3 _]].\n  by rewrite card_semidihedral // leq_exp2r // leqNgt p_gt2.\nrewrite p2 in genG oy n_gt23; rewrite n_gt23.\nhave: nil_class G <> n.-1.\n  by apply/eqP; rewrite neq_ltn -ltnS nil2G def_n n_gt23.\ncase: ifP => [isoG | _]; first by case/dihedral2_structure: genG => // _ [].\ncase: ifP => [isoG | _]; first by case/quaternion_structure: genG => // _ [].\nby case: ifP => // isoG; case/semidihedral_structure: genG => // _ [].\nQed.",
    "Lemma maximal_cycle_extremal gT p (G X : {group gT}) :\n    p.-group G -> ~~ abelian G -> cyclic X -> X \\subset G -> #|G : X| = p ->\n  (extremal_class G == ModularGroup) || (p == 2) && extremal2 G.\nProof.\nmove=> pG not_cGG cycX sXG iXG; rewrite /extremal2; set cG := extremal_class G.\nhave [|p_pr _ _] := pgroup_pdiv pG.\n  by case: eqP not_cGG => // ->; rewrite abelian1.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave [n oG] := p_natP pG; have n_gt2: n > 2.\n  apply: contraR not_cGG; rewrite -leqNgt => n_le2.\n  by rewrite (p2group_abelian pG) // oG pfactorK.\nhave def_n := subnKC n_gt2; have n_gt1 := ltnW n_gt2; have n_gt0 := ltnW n_gt1.\npose q := (p ^ n.-1)%N; pose r := (p ^ n.-2)%N.\nhave q_gt1: q > 1 by rewrite (ltn_exp2l 0) // -(subnKC n_gt2).\nhave r_gt0: r > 0 by rewrite expn_gt0 p_gt0.\nhave def_pr: (p * r)%N = q by rewrite /q /r -def_n.\nhave oX: #|X| = q by rewrite -(divg_indexS sXG) oG iXG /q -def_n mulKn.\nhave ntX: X :!=: 1 by rewrite -cardG_gt1 oX.\nhave maxX: maximal X G by rewrite p_index_maximal ?iXG.\nhave nsXG: X <| G := p_maximal_normal pG maxX; have [_ nXG] := andP nsXG.\nhave cXX: abelian X := cyclic_abelian cycX.\nhave scXG: 'C_G(X) = X.\n  apply/eqP; rewrite eqEsubset subsetI sXG -abelianE cXX !andbT.\n  apply: contraR not_cGG; case/subsetPn=> y; case/setIP=> Gy cXy notXy.\n  rewrite -!cycle_subG in Gy notXy; rewrite -(mulg_normal_maximal nsXG _ Gy) //.\n  by rewrite abelianM cycle_abelian cyclic_abelian ?cycle_subG.\nhave [x defX] := cyclicP cycX; have pX := pgroupS sXG pG.\nhave Xx: x \\in X by [rewrite defX cycle_id]; have Gx := subsetP sXG x Xx.\nhave [ox p_x]: #[x] = q /\\ p.-elt x by rewrite defX in pX oX.\npose Z := <[x ^+ r]>.\nhave defZ: Z = 'Ohm_1(X) by rewrite defX (Ohm_p_cycle _ p_x) ox subn1 pfactorK.\nhave oZ: #|Z| = p by rewrite -orderE orderXdiv ox -def_pr ?dvdn_mull ?mulnK.\nhave cGZ: Z \\subset 'C(G).\n  have nsZG: Z <| G by rewrite defZ gFnormal_trans.\n  move/implyP: (meet_center_nil (pgroup_nil pG) nsZG).\n  rewrite -cardG_gt1 oZ p_gt1 setIA (setIidPl (normal_sub nsZG)).\n  by apply: contraR; move/prime_TIg=> -> //; rewrite oZ.\nhave X_Gp y: y \\in G -> y ^+ p \\in X.\n  move=> Gy; have nXy: y \\in 'N(X) := subsetP nXG y Gy.\n  rewrite coset_idr ?groupX // morphX //; apply/eqP.\n  by rewrite -order_dvdn -iXG -card_quotient // order_dvdG ?mem_quotient.\nhave [y X'y]: exists2 y, y \\in G :\\: X &\n  (p == 2) + 3 <= n /\\ x ^ y = x ^+ r.+1 \\/ p = 2 /\\ x * x ^ y \\in Z.\n- have [y Gy notXy]: exists2 y, y \\in G & y \\notin X.\n    by apply/subsetPn; rewrite proper_subn ?(maxgroupp maxX).\n  have nXy: y \\in 'N(X) := subsetP nXG y Gy; pose ay := conj_aut X y.\n  have oay: #[ay] = p.\n    apply: nt_prime_order => //.\n      by rewrite -morphX // mker // ker_conj_aut (subsetP cXX) ?X_Gp.\n    rewrite (sameP eqP (kerP _ nXy)) ker_conj_aut.\n    by apply: contra notXy => cXy; rewrite -scXG inE Gy.\n  have [m []]:= cyclic_pgroup_Aut_structure pX cycX ntX.\n  set Ap := 'O_p(_); case=> def_m [m1 _] [m_inj _] _ _ _.\n  have sylAp: p.-Sylow(Aut X) Ap.\n    by rewrite nilpotent_pcore_Hall // abelian_nil // Aut_cyclic_abelian.\n  have Ap1ay: ay \\in 'Ohm_1(Ap).\n    rewrite (OhmE _ (pcore_pgroup _ _)) mem_gen // !inE -order_dvdn oay dvdnn.\n    rewrite (mem_normal_Hall sylAp) ?pcore_normal ?Aut_aut //.\n    by rewrite /p_elt oay pnat_id.\n  rewrite {1}oX pfactorK // -{1}def_n /=.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    rewrite (sameP eqP (prime_oddPn p_pr)) odd_p n_gt2.\n    case=> _ [_ _ _] [_ _ [s [As os m_s defAp1]]].\n    have [j def_s]: exists j, s = ay ^+ j.\n      apply/cycleP; rewrite -cycle_subG subEproper eq_sym eqEcard -!orderE.\n      by rewrite -defAp1 cycle_subG Ap1ay oay os leqnn .\n    exists (y ^+ j); last first.\n      left; rewrite -(norm_conj_autE _ Xx) ?groupX // morphX // -def_s.\n      by rewrite -def_m // m_s expg_znat // oX pfactorK ?eqxx.\n    rewrite -scXG !inE groupX //= andbT -ker_conj_aut !inE morphX // -def_s.\n    rewrite andbC -(inj_in_eq m_inj) ?group1 // m_s m1 oX pfactorK // -/r.\n    rewrite mulrSr -subr_eq0 addrK -val_eqE /= val_Zp_nat //.\n    by rewrite [_ == 0]dvdn_Pexp2l // -def_n ltnn.\n  rewrite {1}p2 /= => [[t [At ot m_t]]]; rewrite {1}oX pfactorK // -{1}def_n.\n  rewrite eqSS subn_eq0 => defA; exists y; rewrite ?inE ?notXy //.\n  rewrite p2 -(norm_conj_autE _ Xx) //= -/ay -def_m ?Aut_aut //.\n  case Tay: (ay \\in <[t]>).\n    rewrite cycle2g // !inE -order_eq1 oay p2 /= in Tay.\n    by right; rewrite (eqP Tay) m_t expg_zneg // mulgV group1.\n  case: leqP defA => [_ defA|le3n [a [Aa _ _ defA [s [As os m_s m_st defA1]]]]].\n    by rewrite -defA Aut_aut in Tay.\n  have: ay \\in [set s; s * t].\n    have: ay \\in 'Ohm_1(Aut X) := subsetP (OhmS 1 (pcore_sub _ _)) ay Ap1ay.\n    case/dprodP: (Ohm_dprod 1 defA) => _ <- _ _.\n    rewrite defA1 (@Ohm_p_cycle _ _ 2) /p_elt ot //= expg1 cycle2g //.\n    by rewrite mulUg mul1g inE Tay cycle2g // mulgU mulg1 mulg_set1.\n  case/set2P=> ->; [left | right].\n    by rewrite ?le3n m_s expg_znat // oX pfactorK // -p2.\n  by rewrite m_st expg_znat // oX pfactorK // -p2 -/r -expgS prednK ?cycle_id.\nhave [Gy notXy] := setDP X'y; have nXy := subsetP nXG y Gy.\nhave defG j: <[x]> <*> <[x ^+ j * y]> = G.\n  rewrite -defX -genM_join.\n  by rewrite (mulg_normal_maximal nsXG) ?cycle_subG ?groupMl ?groupX ?genGid.\nhave[i def_yp]: exists i, y ^- p = x ^+ i.\n  by apply/cycleP; rewrite -defX groupV X_Gp.\nhave p_i: p %| i.\n  apply: contraR notXy; rewrite -prime_coprime // => co_p_j.\n  have genX: generator X (y ^- p).\n    by rewrite def_yp defX generator_coprime ox coprimeXl.\n  rewrite -scXG (setIidPl _) // centsC ((X :=P: _) genX) cycle_subG groupV.\n  rewrite /= -(defG 0) mul1g centY inE -defX (subsetP cXX) ?X_Gp //.\n  by rewrite (subsetP (cycle_abelian y)) ?mem_cycle.\ncase=> [[n_gt23 xy] | [p2 Z_xxy]].\n  suffices ->: cG = ModularGroup by []; apply/modular_group_classP.\n  exists p => //; exists n => //; rewrite isogEcard card_modular_group //.\n  rewrite oG leqnn andbT Grp_modular_group // -/q -/r.\n  have{i def_yp p_i} [i def_yp]: exists i, y ^- p = x ^+ i ^+ p.\n    by case/dvdnP: p_i => j def_i; exists j; rewrite -expgM -def_i.\n  have Zyx: [~ y, x] \\in Z.\n    by rewrite -groupV invg_comm commgEl xy expgS mulKg cycle_id.\n  have def_yxj j: [~ y, x ^+ j] = [~ y, x] ^+ j.\n    by rewrite commgX /commute ?(centsP cGZ _ Zyx).\n  have Zyxj j: [~ y, x ^+ j] \\in Z by rewrite def_yxj groupX.\n  have x_xjy j: x ^ (x ^+ j * y) = x ^+ r.+1.\n    by rewrite conjgM {2}/conjg commuteX //= mulKg.\n  have [cyxi | not_cyxi] := eqVneq ([~ y, x ^+ i] ^+ 'C(p, 2)) 1.\n    apply/existsP; exists (x, x ^+ i * y); rewrite /= !xpair_eqE.\n    rewrite defG x_xjy -order_dvdn ox dvdnn !eqxx andbT /=.\n    rewrite expMg_Rmul /commute ?(centsP cGZ _ (Zyxj _)) ?groupX // cyxi.\n    by rewrite -def_yp -mulgA mulKg.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    by rewrite -order_dvdn bin2odd ?dvdn_mulr // -oZ order_dvdG in not_cyxi.\n  have def_yxi: [~ y, x ^+ i] = x ^+ r.\n    have:= Zyxj i; rewrite /Z cycle_traject orderE oZ p2 !inE mulg1.\n    by case/pred2P=> // cyxi; rewrite cyxi p2 eqxx in not_cyxi.\n  apply/existsP; exists (x, x ^+ (i + r %/ 2) * y); rewrite /= !xpair_eqE.\n  rewrite defG x_xjy -order_dvdn ox dvdnn !eqxx andbT /=.\n  rewrite expMg_Rmul /commute ?(centsP cGZ _ (Zyxj _)) ?groupX // def_yxj.\n  rewrite -expgM mulnDl addnC !expgD (expgM x i) -def_yp mulgKV.\n  rewrite -def_yxj def_yxi p2 mulgA -expgD in n_gt23 *.\n  rewrite -expg_mod_order ox /q /r p2 -(subnKC n_gt23) mulnC !expnS mulKn //.\n  rewrite addnn -mul2n modnn mul1g -order_dvdn dvdn_mulr //.\n  by rewrite -p2 -oZ order_dvdG.\nhave{i def_yp p_i} Zy2: y ^+ 2 \\in Z.\n  rewrite defZ (OhmE _ pX) -groupV -p2 def_yp mem_gen // !inE groupX //= p2.\n  rewrite expgS -{2}def_yp -(mulKg y y) -conjgE -conjXg -conjVg def_yp conjXg.\n  rewrite -expgMn //; last by apply: (centsP cXX); rewrite ?memJ_norm.\n  by rewrite -order_dvdn (dvdn_trans (order_dvdG Z_xxy)) ?oZ.\nrewrite !cycle_traject !orderE oZ p2 !inE !mulg1 /= in Z_xxy Zy2 *.\nrewrite -eq_invg_mul eq_sym -[r]prednK // expgS (inj_eq (mulgI _)) in Z_xxy.\ncase/pred2P: Z_xxy => xy; last first.\n  suffices ->: cG = SemiDihedral by []; apply/semidihedral_classP.\n  have n_gt3: n > 3.\n    case: ltngtP notXy => // [|n3]; first by rewrite ltnNge n_gt2.\n    rewrite -scXG inE Gy defX cent_cycle; case/cent1P; red.\n    by rewrite (conjgC x) xy /r p2 -n3.\n  exists n => //; rewrite isogEcard card_semidihedral // oG p2 leqnn andbT.\n  rewrite Grp_semidihedral //; apply/existsP=> /=.\n  case/pred2P: Zy2 => y2; [exists (x, y) | exists (x, x * y)].\n    by rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\n  rewrite /= (defG 1%N) conjgM {2}/conjg mulKg -p2 -/q -ox expg_order -xy.\n  rewrite !xpair_eqE !eqxx /= andbT p2 expgS {2}(conjgC x) xy mulgA -(mulgA x).\n  rewrite [y * y]y2 -expgS -expgD addSnnS prednK // addnn -mul2n -p2 def_pr.\n  by rewrite -ox expg_order.\ncase/pred2P: Zy2 => y2.\n  suffices ->: cG = Dihedral by []; apply/dihedral_classP.\n  exists n => //; rewrite isogEcard card_2dihedral // oG p2 leqnn andbT.\n  rewrite Grp_2dihedral //; apply/existsP; exists (x, y) => /=.\n  by rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\nsuffices ->: cG = Quaternion by []; apply/quaternion_classP.\nexists n => //; rewrite isogEcard card_quaternion // oG p2 leqnn andbT.\nrewrite Grp_quaternion //; apply/existsP; exists (x, y) => /=.\nby rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\nQed.",
    "Lemma cyclic_SCN gT p (G U : {group gT}) :\n    p.-group G -> U \\in 'SCN(G) -> ~~ abelian G -> cyclic U ->\n    [/\\ p = 2, #|G : U| = 2 & extremal2 G]\n\\/ exists M : {group gT},\n   [/\\ M :=: 'C_G('Mho^1(U)), #|M : U| = p, extremal_class M = ModularGroup,\n       'Ohm_1(M)%G \\in 'E_p^2(G) & 'Ohm_1(M) \\char G].\nProof.\nmove=> pG /SCN_P[nsUG scUG] not_cGG cycU; have [sUG nUG] := andP nsUG.\nhave [cUU pU] := (cyclic_abelian cycU, pgroupS sUG pG).\nhave ltUG: ~~ (G \\subset U).\n  by apply: contra not_cGG => sGU; apply: abelianS cUU.\nhave ntU: U :!=: 1.\n  by apply: contraNneq ltUG => U1; rewrite -scUG subsetIidl U1 cents1.\nhave [p_pr _ [n oU]] := pgroup_pdiv pU ntU.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave [u defU] := cyclicP cycU; have Uu: u \\in U by rewrite defU cycle_id.\nhave Gu := subsetP sUG u Uu; have p_u := mem_p_elt pG Gu.\nhave defU1: 'Mho^1(U) = <[u ^+ p]> by rewrite defU (Mho_p_cycle _ p_u).\nhave modM1 (M : {group gT}):\n    [/\\ U \\subset M, #|M : U| = p & extremal_class M = ModularGroup] ->\n  M :=: 'C_M('Mho^1(U)) /\\ 'Ohm_1(M)%G \\in 'E_p^2(M).\n- case=> sUM iUM /modular_group_classP[q q_pr {n oU}[n n_gt23 isoM]].\n  have n_gt2: n > 2 by apply: leq_trans (leq_addl _ _) n_gt23.\n  have def_n: n = (n - 3).+3 by rewrite -{1}(subnKC n_gt2).\n  have oM: #|M| = (q ^ n)%N by rewrite (card_isog isoM) card_modular_group.\n  have pM: q.-group M by rewrite /pgroup oM pnatX pnat_id.\n  have def_q: q = p; last rewrite {q q_pr}def_q in oM pM isoM n_gt23.\n    by apply/eqP; rewrite eq_sym [p == q](pgroupP pM) // -iUM dvdn_indexg.\n  have [[x y] genM modM] := generators_modular_group p_pr n_gt2 isoM.\n  case/modular_group_structure: genM => // _ [defZ _ oZ] _ defMho.\n  have ->: 'Mho^1(U) = 'Z(M).\n    apply/eqP; rewrite eqEcard oZ defZ -(defMho 1%N) ?MhoS //= defU1 -orderE.\n    suff ou: #[u] = (p * p ^ n.-2)%N by rewrite orderXdiv ou ?dvdn_mulr ?mulKn.\n    by rewrite orderE -defU -(divg_indexS sUM) iUM oM def_n mulKn.\n  case: eqP => [[p2 n3] | _ defOhm]; first by rewrite p2 n3 in n_gt23.\n  have{defOhm} [|defM1 oM1] := defOhm 1%N; first by rewrite def_n.\n  split; rewrite ?(setIidPl _) //; first by rewrite centsC subsetIr.\n  rewrite inE oM1 pfactorK // andbT inE Ohm_sub abelem_Ohm1 //.\n  exact: (card_p2group_abelian p_pr oM1).\nhave ou: #[u] = (p ^ n.+1)%N by rewrite defU in oU.\npose Gs := G / U; have pGs: p.-group Gs by rewrite quotient_pgroup.\nhave ntGs: Gs != 1 by rewrite -subG1 quotient_sub1.\nhave [_ _ [[|k] oGs]] := pgroup_pdiv pGs ntGs.\n  have iUG: #|G : U| = p by rewrite -card_quotient ?oGs.\n  case: (predU1P (maximal_cycle_extremal _ _ _ _ iUG)) => // [modG | ext2G].\n    by right; exists G; case: (modM1 G) => // <- ->; rewrite Ohm_char.\n  by left; case: eqP ext2G => // <-.\npose M := 'C_G('Mho^1(U)); right; exists [group of M].\nhave sMG: M \\subset G by apply: subsetIl.\nhave [pM nUM] := (pgroupS sMG pG, subset_trans sMG nUG).\nhave sUM: U \\subset M by rewrite subsetI sUG sub_abelian_cent ?Mho_sub.\npose A := Aut U; have cAA: abelian A by rewrite Aut_cyclic_abelian.\nhave sylAp: p.-Sylow(A) 'O_p(A) by rewrite nilpotent_pcore_Hall ?abelian_nil.\nhave [f [injf sfGsA fG]]: exists f : {morphism Gs >-> {perm gT}},\n   [/\\ 'injm f, f @* Gs \\subset A & {in G, forall y, f (coset U y) u = u ^ y}].\n- have [] := first_isom_loc [morphism of conj_aut U] nUG.\n  rewrite ker_conj_aut scUG /= -/Gs => f injf im_f.\n  exists f; rewrite im_f ?Aut_conj_aut //.\n  split=> // y Gy; have nUy := subsetP nUG y Gy.\n  suffices ->: f (coset U y) = conj_aut U y by rewrite norm_conj_autE.\n  by apply: set1_inj; rewrite -!morphim_set1 ?mem_quotient // im_f ?sub1set.\nhave cGsGs: abelian Gs by rewrite -(injm_abelian injf) // (abelianS sfGsA).\nhave p_fGs: p.-group (f @* Gs) by rewrite morphim_pgroup.\nhave sfGsAp: f @* Gs \\subset 'O_p(A) by rewrite (sub_Hall_pcore sylAp).\nhave [a [fGa oa au n_gt01 cycGs]]: exists a,\n  [/\\ a \\in f @* Gs, #[a] = p, a u = u ^+ (p ^ n).+1, (p == 2) + 1 <= n\n    & cyclic Gs \\/ p = 2 /\\ (exists2 c, c \\in f @* Gs & c u = u^-1)].\n- have [m [[def_m _ _ _ _] _]] := cyclic_pgroup_Aut_structure pU cycU ntU.\n  have ->: logn p #|U| = n.+1 by rewrite oU pfactorK.\n  rewrite /= -/A; case: posnP => [_ defA | n_gt0 [c [Ac oc m_c defA]]].\n    have:= cardSg sfGsAp; rewrite (card_Hall sylAp) /= -/A defA card_injm //.\n    by rewrite oGs (part_p'nat (pcore_pgroup _ _)) pfactor_dvdn // logn1.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    case: eqP => [-> // | _] in odd_p *; rewrite odd_p in defA.\n    have [[cycA _] _ [a [Aa oa m_a defA1]]] := defA.\n    exists a; rewrite -def_m // oa m_a expg_znat //.\n    split=> //; last by left; rewrite -(injm_cyclic injf) ?(cyclicS sfGsA).\n    have: f @* Gs != 1 by rewrite morphim_injm_eq1.\n    rewrite -cycle_subG; apply: contraR => not_sfGs_a.\n    by rewrite -(setIidPl sfGsAp) TI_Ohm1 // defA1 setIC prime_TIg -?orderE ?oa.\n  do [rewrite {1}p2 /= eqn_leq n_gt0; case: leqP => /= [_ | n_gt1]] in defA.\n    have:= cardSg sfGsAp; rewrite (card_Hall sylAp) /= -/A defA -orderE oc p2.\n    by rewrite card_injm // oGs p2 pfactor_dvdn // p_part.\n  have{defA} [s [As os _ defA [a [Aa oa m_a _ defA1]]]] := defA; exists a.\n  have fGs_a: a \\in f @* Gs.\n    suffices: f @* Gs :&: <[s]> != 1.\n      apply: contraR => not_fGs_a; rewrite TI_Ohm1 // defA1 setIC.\n      by rewrite prime_TIg -?orderE ?oa // cycle_subG.\n    have: (f @* Gs) * <[s]> \\subset A by rewrite mulG_subG cycle_subG sfGsA.\n    move/subset_leq_card; apply: contraL; move/eqP; move/TI_cardMg->.\n    rewrite -(dprod_card defA) -ltnNge mulnC -!orderE ltn_pmul2r // oc.\n    by rewrite card_injm // oGs p2 (ltn_exp2l 1).\n  rewrite -def_m // oa m_a expg_znat // p2; split=> //.\n  rewrite abelian_rank1_cyclic // (rank_pgroup pGs) //.\n  rewrite -(injm_p_rank injf) // p_rank_abelian 1?morphim_abelian //= p2 -/Gs.\n  case: leqP => [|fGs1_gt1]; [by left | right].\n  split=> //; exists c; last by rewrite -def_m // m_c expg_zneg.\n  have{} defA1: <[a]> \\x <[c]> = 'Ohm_1(Aut U).\n    by rewrite -(Ohm_dprod 1 defA) defA1 (@Ohm_p_cycle 1 _ 2) /p_elt oc.\n  have def_fGs1: 'Ohm_1(f @* Gs) = 'Ohm_1(A).\n    apply/eqP; rewrite eqEcard OhmS // -(dprod_card defA1) -!orderE oa oc.\n    by rewrite dvdn_leq ?(@pfactor_dvdn 2 2) ?cardG_gt0.\n  rewrite (subsetP (Ohm_sub 1 _)) // def_fGs1 -cycle_subG.\n  by case/dprodP: defA1 => _ <- _ _; rewrite mulG_subr.\nhave n_gt0: n > 0 := leq_trans (leq_addl _ _) n_gt01.\nhave [ys Gys _ def_a] := morphimP fGa.\nhave oys: #[ys] = p by rewrite -(order_injm injf) // -def_a oa.\nhave defMs: M / U = <[ys]>.\n  apply/eqP; rewrite eq_sym eqEcard -orderE oys cycle_subG; apply/andP; split.\n    have [y nUy Gy /= def_ys] := morphimP Gys.\n    rewrite def_ys mem_quotient //= inE Gy defU1 cent_cycle cent1C.\n    rewrite (sameP cent1P commgP) commgEl conjXg -fG //= -def_ys -def_a au.\n    by rewrite -expgM mulSn expgD mulKg -expnSr -ou expg_order.\n  rewrite card_quotient // -(setIidPr sUM) -scUG setIA (setIidPl sMG).\n  rewrite defU cent_cycle index_cent1 -(card_imset _ (mulgI u^-1)) -imset_comp.\n  have <-: #|'Ohm_1(U)| = p.\n    rewrite defU (Ohm_p_cycle 1 p_u) -orderE (orderXexp _ ou) ou pfactorK //.\n    by rewrite subKn.\n  rewrite (OhmE 1 pU) subset_leq_card ?sub_gen //.\n  apply/subsetP=> _ /imsetP[z /setIP[/(subsetP nUG) nUz cU1z] ->].\n  have Uv' := groupVr Uu; have Uuz: u ^ z \\in U by rewrite memJ_norm.\n  rewrite !inE groupM // expgMn /commute 1?(centsP cUU u^-1) //= expgVn -conjXg.\n  by rewrite (sameP commgP cent1P) cent1C -cent_cycle -defU1.\nhave iUM: #|M : U| = p by rewrite -card_quotient ?defMs.\nhave not_cMM: ~~ abelian M.\n  apply: contraL p_pr => cMM; rewrite -iUM -indexgI /= -/M.\n  by rewrite (setIidPl _) ?indexgg // -scUG subsetI sMG sub_abelian_cent.\nhave modM: extremal_class M = ModularGroup.\n  have sU1Z: 'Mho^1(U) \\subset 'Z(M).\n    by rewrite subsetI gFsub_trans // centsC subsetIr.\n  have /maximal_cycle_extremal/predU1P[] //= := iUM; rewrite -/M.\n  case/andP=> /eqP-p2 ext2M; rewrite p2 add1n in n_gt01.\n  suffices{sU1Z}: #|'Z(M)| = 2.\n    move/eqP; rewrite eqn_leq leqNgt (leq_trans _ (subset_leq_card sU1Z)) //.\n    by rewrite defU1 -orderE (orderXexp 1 ou) subn1 p2 (ltn_exp2l 1).\n  move: ext2M; rewrite /extremal2 !inE orbC -orbA; case/or3P; move/eqP.\n  - case/semidihedral_classP=> m m_gt3 isoM.\n    have [[x z] genM [oz _]] := generators_semidihedral m_gt3 isoM.\n    by case/semidihedral_structure: genM => // _ _ [].\n  - case/quaternion_classP=> m m_gt2 isoM.\n    have [[x z] genM _] := generators_quaternion m_gt2 isoM.\n    by case/quaternion_structure: genM => // _ _ [].\n  case/dihedral_classP=> m m_gt1 isoM.\n  have [[x z] genM _] := generators_2dihedral m_gt1 isoM.\n  case/dihedral2_structure: genM not_cMM => // _ _ _ _.\n  by case: (m == 2) => [|[]//]; move/abelem_abelian->.\nsplit=> //.\n  have [//|_] := modM1 [group of M]; rewrite !inE -andbA /=.\n  by case/andP=> /subset_trans->.\nhave{cycGs} [cycGs | [p2 [c fGs_c u_c]]] := cycGs.\n  suffices ->: 'Ohm_1(M) = 'Ohm_1(G) by apply: Ohm_char.\n  suffices sG1M: 'Ohm_1(G) \\subset M.\n    by apply/eqP; rewrite eqEsubset -{2}(Ohm_id 1 G) !OhmS.\n  rewrite -(quotientSGK _ sUM) ?(subset_trans (Ohm_sub _ G)) //= defMs.\n  suffices ->: <[ys]> = 'Ohm_1(Gs) by rewrite morphim_Ohm.\n  apply/eqP; rewrite eqEcard -orderE cycle_subG /= {1}(OhmE 1 pGs) /=.\n  rewrite mem_gen ?inE ?Gys -?order_dvdn oys //=.\n  rewrite -(part_pnat_id (pgroupS (Ohm_sub _ _) pGs)) p_part (leq_exp2l _ 1) //.\n  by rewrite -p_rank_abelian -?rank_pgroup -?abelian_rank1_cyclic.\nsuffices charU1: 'Mho^1(U) \\char G^`(1).\n  by rewrite gFchar_trans // subcent_char ?(char_trans charU1) ?gFchar.\nsuffices sUiG': 'Mho^1(U) \\subset G^`(1).\n  have /cyclicP[zs cycG']: cyclic G^`(1) by rewrite (cyclicS _ cycU) ?der1_min.\n  by rewrite cycG' in sUiG' *; apply: cycle_subgroup_char.\nrewrite defU1 cycle_subG p2 -groupV invMg -{2}u_c.\nby have [_ _ /morphimP[z _ Gz ->] ->] := morphimP fGs_c; rewrite fG ?mem_commg.\nQed.",
    "Lemma normal_rank1_structure gT p (G : {group gT}) :\n    p.-group G -> (forall X : {group gT}, X <| G -> abelian X -> cyclic X) ->\n  cyclic G \\/ [&& p == 2, extremal2 G & (#|G| >= 16) || (G \\isog 'Q_8)].\nProof.\nmove=> pG dn_G_1.\nhave [cGG | not_cGG] := boolP (abelian G); first by left; rewrite dn_G_1.\nhave [X maxX]: {X | [max X | X <| G & abelian X]}.\n  by apply: ex_maxgroup; exists 1%G; rewrite normal1 abelian1.\nhave cycX: cyclic X by rewrite dn_G_1; case/andP: (maxgroupp maxX).\nhave scX: X \\in 'SCN(G) := max_SCN pG maxX.\nhave [[p2 _ cG] | [M [_ _ _]]] := cyclic_SCN pG scX not_cGG cycX; last first.\n  rewrite 2!inE -andbA => /and3P[sEG abelE dimE_2] charE.\n  have:= dn_G_1 _ (char_normal charE) (abelem_abelian abelE).\n  by rewrite (abelem_cyclic abelE) (eqP dimE_2).\nhave [n oG] := p_natP pG; right; rewrite p2 cG /= in oG *.\nrewrite oG (@leq_exp2l 2 4) //.\nrewrite /extremal2 /extremal_class oG pfactorKpdiv // in cG.\ncase: andP cG => [[n_gt1 isoG] _ | _]; last first.\n  by case: (ltngtP 3 n) => //= <-; do 2?case: ifP.\nhave [[x y] genG _] := generators_2dihedral n_gt1 isoG.\nhave [_ _ _ [_ _ maxG]] := dihedral2_structure n_gt1 genG isoG.\nrewrite 2!ltn_neqAle n_gt1 !(eq_sym _ n).\ncase: eqP => [_ abelG| _]; first by rewrite (abelem_abelian abelG) in not_cGG.\ncase: eqP => // -> [_ _ isoY _ _]; set Y := <<_>> in isoY.\nhave nxYG: Y <| G by rewrite (p_maximal_normal pG) // maxG !inE eqxx orbT.\nhave [// | [u v] genY _] := generators_2dihedral _ isoY.\ncase/dihedral2_structure: (genY) => //= _ _ _ _ abelY.\nhave:= dn_G_1 _ nxYG (abelem_abelian abelY).\nby rewrite (abelem_cyclic abelY); case: genY => ->.\nQed.",
    "Lemma odd_pgroup_rank1_cyclic gT p (G : {group gT}) :\n  p.-group G -> odd #|G| -> cyclic G = ('r_p(G) <= 1).\nProof.\nmove=> pG oddG; rewrite -rank_pgroup //; apply/idP/idP=> [cycG | dimG1].\n  by rewrite -abelian_rank1_cyclic ?cyclic_abelian.\nhave [X nsXG cXX|//|] := normal_rank1_structure pG; last first.\n  by rewrite (negPf (odd_not_extremal2 oddG)) andbF.\nby rewrite abelian_rank1_cyclic // (leq_trans (rankS (normal_sub nsXG))).\nQed.",
    "Lemma prime_Ohm1P gT p (G : {group gT}) :\n    p.-group G -> G :!=: 1 ->\n  reflect (#|'Ohm_1(G)| = p)\n          (cyclic G || (p == 2) && (extremal_class G == Quaternion)).\nProof.\nmove=> pG ntG; have [p_pr p_dvd_G _] := pgroup_pdiv pG ntG.\napply: (iffP idP) => [|oG1p].\n  case/orP=> [cycG|]; first exact: Ohm1_cyclic_pgroup_prime.\n  case/andP=> /eqP p2 /eqP/quaternion_classP[n n_gt2 isoG].\n  rewrite p2; have [[x y]] := generators_quaternion n_gt2 isoG.\n  by case/quaternion_structure=> // _ _ [<- oZ _ [->]].\nhave [X nsXG cXX|-> //|]:= normal_rank1_structure pG.\n  have [sXG _] := andP nsXG; have pX := pgroupS sXG pG.\n  rewrite abelian_rank1_cyclic // (rank_pgroup pX) p_rank_abelian //.\n  rewrite -{2}(pfactorK 1 p_pr) -{3}oG1p dvdn_leq_log ?cardG_gt0 //.\n  by rewrite cardSg ?OhmS.\ncase/and3P=> /eqP p2; rewrite p2 (orbC (cyclic G)) /extremal2.\ncase cG: (extremal_class G) => //; case: notF.\n  case/dihedral_classP: cG => n n_gt1 isoG.\n  have [[x y] genG _] := generators_2dihedral n_gt1 isoG.\n  have [oG _ _ _] := genG; case/dihedral2_structure: genG => // _ _ [defG1 _] _.\n  by case/idPn: n_gt1; rewrite -(@ltn_exp2l 2) // -oG -defG1 oG1p p2.\ncase/semidihedral_classP: cG => n n_gt3 isoG.\nhave [[x y] genG [oy _]] := generators_semidihedral n_gt3 isoG.\ncase/semidihedral_structure: genG => // _ _ [_ _ [defG1 _] _] _ [isoG1 _ _].\ncase/idPn: (n_gt3); rewrite -(ltn_predK n_gt3) ltnS -leqNgt -(@leq_exp2l 2) //.\nrewrite -card_2dihedral //; last by rewrite -(subnKC n_gt3).\nby rewrite -(card_isog isoG1) /= -defG1 oG1p p2.\nQed.",
    "Lemma Fitting_group_set G : group_set (Fitting G).\nProof.\nsuffices [F ->]: exists F : {group gT}, Fitting G = F by apply: groupP.\nrewrite /Fitting; elim: primes (primes_uniq #|G|) => [_|p r IHr] /=.\n  by exists [1 gT]%G; rewrite big_nil.\ncase/andP=> rp /IHr[F defF]; rewrite big_cons defF.\nsuffices{IHr} /and3P[p'F sFG nFG]: p^'.-group F && (F <| G).\n  have nFGp: 'O_p(G) \\subset 'N(F) := gFsub_trans _ nFG.\n  have pGp: p.-group('O_p(G)) := pcore_pgroup p G.\n  have{pGp} tiGpF: 'O_p(G) :&: F = 1 by rewrite coprime_TIg ?(pnat_coprime pGp).\n  exists ('O_p(G) <*> F)%G; rewrite dprodEY // (sameP commG1P trivgP) -tiGpF.\n  by rewrite subsetI commg_subl commg_subr (subset_trans sFG) // gFnorm.\nmove/bigdprodWY: defF => <- {F}; elim: r rp => [_|q r IHr] /=.\n  by rewrite big_nil gen0 pgroup1 normal1.\nrewrite inE eq_sym big_cons -joingE -joing_idr => /norP[qp /IHr {IHr}].\nset F := <<_>> => /andP[p'F nsFG].\nrewrite norm_joinEl /= -/F; last exact/gFsub_trans/normal_norm.\nby rewrite pgroupM p'F normalM ?pcore_normal //= (pi_pgroup (pcore_pgroup q G)).\nQed.",
    "Lemma p_maximal_normal : maximal M P -> M <| P.\nProof.\ncase/maxgroupP=> /andP[sMP sPM] maxM; rewrite /normal sMP.\nhave:= subsetIl P 'N(M); rewrite subEproper.\ncase/predU1P=> [/setIidPl-> // | /maxM/= SNM]; case/negP: sPM.\nrewrite (nilpotent_sub_norm (pgroup_nil pP) sMP) //.\nby rewrite SNM // subsetI sMP normG.\nQed.",
    "Lemma p_maximal_index : maximal M P -> #|P : M| = p.\nProof.\nmove=> maxM; have nM := p_maximal_normal maxM.\nrewrite -card_quotient ?normal_norm //.\nrewrite -(quotient_maximal _ nM) ?normal_refl // trivg_quotient in maxM.\ncase/maxgroupP: maxM; rewrite properEneq eq_sym sub1G andbT /=.\ncase/(pgroup_pdiv (quotient_pgroup M pP)) => p_pr /Cauchy[] // xq.\nrewrite /order -cycle_subG subEproper => /predU1P[-> // | sxPq oxq_p _].\nby move/(_ _ sxPq (sub1G _)) => xq1; rewrite -oxq_p xq1 cards1 in p_pr.\nQed.",
    "Lemma p_index_maximal : M \\subset P -> prime #|P : M| -> maximal M P.\nProof.\nmove=> sMP /primeP[lt1PM pr_PM].\napply/maxgroupP; rewrite properEcard sMP -(Lagrange sMP).\nrewrite -{1}(muln1 #|M|) ltn_pmul2l //; split=> // H sHP sMH.\napply/eqP; rewrite eq_sym eqEcard sMH.\ncase/orP: (pr_PM _ (indexSg sMH (proper_sub sHP))) => /eqP iM.\n  by rewrite -(Lagrange sMH) iM muln1 /=.\nby have:= proper_card sHP; rewrite -(Lagrange sMH) iM Lagrange ?ltnn.\nQed.",
    "Lemma Phi_sub G : 'Phi(G) \\subset G.\nProof. by rewrite bigcap_inf // /maximal_eq eqxx. Qed.",
    "Lemma Phi_sub_max G M : maximal M G -> 'Phi(G) \\subset M.\nProof. by move=> maxM; rewrite bigcap_inf // /maximal_eq predU1r. Qed.",
    "Lemma Phi_proper G : G :!=: 1 -> 'Phi(G) \\proper G.\nProof.\nmove/eqP; case/maximal_exists: (sub1G G) => [<- //| [M maxM _] _].\nexact: sub_proper_trans (Phi_sub_max maxM) (maxgroupp maxM).\nQed.",
    "Lemma Phi_nongen G X : 'Phi(G) <*> X = G -> <<X>> = G.\nProof.\nmove=> defG; have: <<X>> \\subset G by rewrite -{1}defG genS ?subsetUr.\ncase/maximal_exists=> //= [[M maxM]]; rewrite gen_subG => sXM.\ncase/andP: (maxgroupp maxM) => _ /negP[].\nby rewrite -defG gen_subG subUset Phi_sub_max.\nQed.",
    "Lemma Frattini_continuous (rT : finGroupType) G (f : {morphism G >-> rT}) :\n  f @* 'Phi(G) \\subset 'Phi(f @* G).\nProof.\napply/bigcapsP=> M maxM; rewrite sub_morphim_pre ?Phi_sub // bigcap_inf //.\nhave {2}<-: f @*^-1 (f @* G) = G by rewrite morphimGK ?subsetIl.\nby rewrite morphpre_maximal_eq ?maxM //; case/maximal_eqP: maxM.\nQed.",
    "Lemma Phi_char G : 'Phi(G) \\char G.\nProof. exact: gFchar. Qed.",
    "Lemma Phi_normal G : 'Phi(G) <| G.\nProof. exact: gFnormal. Qed.",
    "Lemma injm_Phi rT D G (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* 'Phi(G) = 'Phi(f @* G).\nProof. exact: injmF. Qed.",
    "Lemma isog_Phi rT G (H : {group rT}) : G \\isog H -> 'Phi(G) \\isog 'Phi(H).\nProof. exact: gFisog. Qed.",
    "Lemma PhiJ G x : 'Phi(G :^ x) = 'Phi(G) :^ x.\nProof.\nrewrite -{1}(setIid G) -(setIidPr (Phi_sub G)) -!morphim_conj.\nby rewrite injm_Phi ?injm_conj.\nQed.",
    "Lemma Phi_quotient_id G : 'Phi (G / 'Phi(G)) = 1.\nProof.\napply/trivgP; rewrite -cosetpreSK cosetpre1 /=; apply/bigcapsP=> M maxM.\nhave nPhi := Phi_normal G; have nPhiM: 'Phi(G) <| M.\n  by apply: normalS nPhi; [apply: bigcap_inf | case/maximal_eqP: maxM].\nby rewrite sub_cosetpre_quo ?bigcap_inf // quotient_maximal_eq.\nQed.",
    "Lemma Phi_quotient_cyclic G : cyclic (G / 'Phi(G)) -> cyclic G.\nProof.\ncase/cyclicP=> /= Px; case: (cosetP Px) => x nPx ->{Px} defG.\napply/cyclicP; exists x; symmetry; apply: Phi_nongen.\nrewrite -joing_idr norm_joinEr -?quotientK ?cycle_subG //.\nby rewrite /quotient morphim_cycle //= -defG quotientGK ?Phi_normal.\nQed.",
    "Lemma trivg_Phi : p.-group P -> ('Phi(P) == 1) = p.-abelem P.\nProof.\nmove=> pP; case: (eqsVneq P 1) => [P1 | ntP].\n  by rewrite P1 abelem1 -subG1 -P1 Phi_sub.\nhave [p_pr _ _] := pgroup_pdiv pP ntP.\napply/eqP/idP=> [trPhi | abP].\n  apply/abelemP=> //; split=> [|x Px].\n    apply/commG1P/trivgP; rewrite -trPhi.\n    apply/bigcapsP=> M /predU1P[-> | maxM]; first exact: der1_subG.\n    have /andP[_ nMP]: M <| P := p_maximal_normal pP maxM.\n    rewrite der1_min // cyclic_abelian // prime_cyclic // card_quotient //.\n    by rewrite (p_maximal_index pP).\n  apply/set1gP; rewrite -trPhi; apply/bigcapP=> M.\n  case/predU1P=> [-> | maxM]; first exact: groupX.\n  have /andP[_ nMP] := p_maximal_normal pP maxM.\n  have nMx : x \\in 'N(M) by apply: subsetP Px.\n  apply: coset_idr; rewrite ?groupX ?morphX //=; apply/eqP.\n  rewrite -(p_maximal_index pP maxM) -card_quotient // -order_dvdn cardSg //=.\n  by rewrite cycle_subG mem_quotient.\napply/trivgP/subsetP=> x Phi_x; rewrite -cycle_subG.\nhave Px: x \\in P by apply: (subsetP (Phi_sub P)).\nhave sxP: <[x]> \\subset P by rewrite cycle_subG.\ncase/splitsP: (abelem_splits abP sxP) => K /complP[tiKx defP].\nhave [-> | nt_x] := eqVneq x 1; first by rewrite cycle1.\nhave oxp := abelem_order_p abP Px nt_x.\nrewrite /= -tiKx subsetI subxx cycle_subG.\napply: (bigcapP Phi_x); apply/orP; right.\napply: p_index_maximal; rewrite -?divgS -defP ?mulG_subr //.\nby rewrite (TI_cardMg tiKx) mulnK // [#|_|]oxp.\nQed.",
    "Lemma Phi_quotient_abelem : p.-abelem (P / 'Phi(P)).\nProof. by rewrite -trivg_Phi ?morphim_pgroup //= Phi_quotient_id. Qed.",
    "Lemma Phi_joing : 'Phi(P) = P^`(1) <*> 'Mho^1(P).\nProof.\nhave [sPhiP nPhiP] := andP (Phi_normal P).\napply/eqP; rewrite eqEsubset join_subG.\ncase: (eqsVneq P 1) => [-> | ntP] in sPhiP *.\n  by rewrite /= (trivgP sPhiP) sub1G der_subS Mho_sub.\nhave [p_pr _ _] := pgroup_pdiv pP ntP.\nhave [abP x1P] := abelemP p_pr Phi_quotient_abelem.\napply/andP; split.\n  have nMP: P \\subset 'N(P^`(1) <*> 'Mho^1(P)) by rewrite normsY // !gFnorm.\n  rewrite -quotient_sub1 ?gFsub_trans //=.\n  suffices <-: 'Phi(P / (P^`(1) <*> 'Mho^1(P))) = 1 by apply: morphimF.\n  apply/eqP; rewrite (trivg_Phi (morphim_pgroup _ pP)) /= -quotientE.\n  apply/abelemP=> //; rewrite [abelian _]quotient_cents2 ?joing_subl //.\n  split=> // _ /morphimP[x Nx Px ->] /=.\n  rewrite -morphX //= coset_id // (MhoE 1 pP) joing_idr expn1.\n  by rewrite mem_gen //; apply/setUP; right; apply: imset_f.\nrewrite -quotient_cents2 // [_ \\subset 'C(_)]abP (MhoE 1 pP) gen_subG /=.\napply/subsetP=> _ /imsetP[x Px ->]; rewrite expn1.\nhave nPhi_x: x \\in 'N('Phi(P)) by apply: (subsetP nPhiP).\nby rewrite coset_idr ?groupX ?morphX ?x1P ?mem_morphim.\nQed.",
    "Lemma Phi_Mho : abelian P -> 'Phi(P) = 'Mho^1(P).\nProof. by move=> cPP; rewrite Phi_joing (derG1P cPP) joing1G. Qed.",
    "Lemma PhiS G H : p.-group H -> G \\subset H -> 'Phi(G) \\subset 'Phi(H).\nProof.\nmove=> pH sGH; rewrite (Phi_joing pH) (Phi_joing (pgroupS sGH pH)).\nby rewrite genS // setUSS ?dergS ?MhoS.\nQed.",
    "Lemma morphim_Phi rT P D (f : {morphism D >-> rT}) :\n  p.-group P -> P \\subset D -> f @* 'Phi(P) = 'Phi(f @* P).\nProof.\nmove=> pP sPD; rewrite !(@Phi_joing _ p) ?morphim_pgroup //.\nrewrite morphim_gen ?subUset ?gFsub_trans // morphimU -joingE.\nby rewrite morphimR ?morphim_Mho.\nQed.",
    "Lemma quotient_Phi P H :\n  p.-group P -> P \\subset 'N(H) -> 'Phi(P) / H = 'Phi(P / H).\nProof. exact: morphim_Phi. Qed.",
    "Lemma Phi_min G H :\n  p.-group G -> G \\subset 'N(H) -> p.-abelem (G / H) -> 'Phi(G) \\subset H.\nProof.\nmove=> pG nHG; rewrite -trivg_Phi ?quotient_pgroup // -subG1 /=.\nby rewrite -(quotient_Phi pG) ?quotient_sub1 // gFsub_trans.\nQed.",
    "Lemma Phi_cprod G H K :\n  p.-group G -> H \\* K = G -> 'Phi(H) \\* 'Phi(K) = 'Phi(G).\nProof.\nmove=> pG defG; have [_ /mulG_sub[sHG sKG] cHK] := cprodP defG.\nrewrite cprodEY /=; last by rewrite (centSS (Phi_sub _) (Phi_sub _)).\nrewrite !(Phi_joing (pgroupS _ pG)) //=.\nhave /cprodP[_ <- /cent_joinEr <-] := der_cprod 1 defG.\nhave /cprodP[_ <- /cent_joinEr <-] := Mho_cprod 1 defG.\nby rewrite !joingA /= -!(joingA H^`(1)) (joingC K^`(1)).\nQed.",
    "Lemma Phi_mulg H K :\n    p.-group H -> p.-group K -> K \\subset 'C(H) ->\n  'Phi(H * K) = 'Phi(H) * 'Phi(K).\nProof.\nmove=> pH pK cHK; have defHK := cprodEY cHK.\nhave [|_ ->] /= := cprodP (Phi_cprod _ defHK); rewrite cent_joinEr //.\nby rewrite pgroupM pH.\nQed.",
    "Lemma charsimpleP G :\n  reflect (G :!=: 1 /\\ forall K, K :!=: 1 -> K \\char G -> K :=: G)\n          (charsimple G).\nProof.\napply: (iffP mingroupP); rewrite char_refl andbT => -[ntG simG].\n  by split=> // K ntK chK; apply: simG; rewrite ?ntK // char_sub.\nby split=> // K /andP[ntK chK] _; apply: simG.\nQed.",
    "Lemma Fitting_normal G : 'F(G) <| G.\nProof.\nrewrite -['F(G)](bigdprodWY (erefl 'F(G))).\nelim/big_rec: _ => [|p H _ nsHG]; first by rewrite gen0 normal1.\nby rewrite -[<<_>>]joing_idr normalY ?pcore_normal.\nQed.",
    "Lemma Fitting_sub G : 'F(G) \\subset G.\nProof. by rewrite normal_sub ?Fitting_normal. Qed.",
    "Lemma Fitting_nil G : nilpotent 'F(G).\nProof.\napply: (bigdprod_nil (erefl 'F(G))) => p _.\nexact: pgroup_nil (pcore_pgroup p G).\nQed.",
    "Lemma Fitting_max G H : H <| G -> nilpotent H -> H \\subset 'F(G).\nProof.\nmove=> nsHG nilH; rewrite -(Sylow_gen H) gen_subG.\napply/bigcupsP=> P /SylowP[p _ sylP].\ncase Gp: (p \\in \\pi(G)); last first.\n  rewrite card1_trivg ?sub1G // (card_Hall sylP).\n  rewrite part_p'nat // (pnat_dvd (cardSg (normal_sub nsHG))) //.\n  by rewrite /pnat cardG_gt0 all_predC has_pred1 Gp.\nrewrite {P sylP}(nilpotent_Hall_pcore nilH sylP).\nrewrite -(bigdprodWY (erefl 'F(G))) sub_gen //.\nrewrite -(filter_pi_of (ltnSn _)) big_filter big_mkord.\napply: (bigcup_max (Sub p _)) => //= [|_].\n  by have:= Gp; rewrite ltnS mem_primes => /and3P[_ ntG /dvdn_leq->].\nby rewrite pcore_max ?pcore_pgroup ?gFnormal_trans.\nQed.",
    "Lemma pcore_Fitting pi G : 'O_pi('F(G)) \\subset 'O_pi(G).\nProof. by rewrite pcore_max ?pcore_pgroup ?gFnormal_trans ?Fitting_normal. Qed.",
    "Lemma p_core_Fitting p G : 'O_p('F(G)) = 'O_p(G).\nProof.\napply/eqP; rewrite eqEsubset pcore_Fitting pcore_max ?pcore_pgroup //.\napply: normalS (normal_sub (Fitting_normal _)) (pcore_normal _ _).\nexact: Fitting_max (pcore_normal _ _) (pgroup_nil (pcore_pgroup _ _)).\nQed.",
    "Lemma nilpotent_Fitting G : nilpotent G -> 'F(G) = G.\nProof.\nby move=> nilG; apply/eqP; rewrite eqEsubset Fitting_sub Fitting_max.\nQed.",
    "Lemma Fitting_eq_pcore p G : 'O_p^'(G) = 1 -> 'F(G) = 'O_p(G).\nProof.\nmove=> p'G1; have /dprodP[_  /= <- _ _] := nilpotent_pcoreC p (Fitting_nil G).\nby rewrite p_core_Fitting ['O_p^'(_)](trivgP _) ?mulg1 // -p'G1 pcore_Fitting.\nQed.",
    "Lemma FittingEgen G :\n  'F(G) = <<\\bigcup_(p < #|G|.+1 | (p : nat) \\in \\pi(G)) 'O_p(G)>>.\nProof.\napply/eqP; rewrite eqEsubset gen_subG /=.\nrewrite -{1}(bigdprodWY (erefl 'F(G))) (big_nth 0) big_mkord genS.\n  by apply/bigcupsP=> p _; rewrite -p_core_Fitting pcore_sub.\napply/bigcupsP=> [[i /= lti]] _; set p := nth _ _ i.\nhave pi_p: p \\in \\pi(G) by rewrite mem_nth.\nhave p_dv_G: p %| #|G| by rewrite mem_primes in pi_p; case/and3P: pi_p.\nhave lepG: p < #|G|.+1 by rewrite ltnS dvdn_leq.\nby rewrite (bigcup_max (Ordinal lepG)).\nQed.",
    "Lemma morphim_Fitting : GFunctor.pcontinuous (@Fitting).\nProof.\nmove=> gT rT G D f; apply: Fitting_max.\n  by rewrite morphim_normal ?Fitting_normal.\nby rewrite morphim_nil ?Fitting_nil.\nQed.",
    "Lemma FittingS gT (G H : {group gT}) : H \\subset G -> H :&: 'F(G) \\subset 'F(H).\nProof.\nmove=> sHG; rewrite -{2}(setIidPl sHG).\ndo 2!rewrite -(morphim_idm (subsetIl H _)) morphimIdom; apply: morphim_Fitting.\nQed.",
    "Lemma FittingJ gT (G : {group gT}) x : 'F(G :^ x) = 'F(G) :^ x.\nProof.\nrewrite !FittingEgen -genJ /= cardJg; symmetry; congr <<_>>.\nrewrite (big_morph (conjugate^~ x) (fun A B => conjUg A B x) (imset0 _)).\nby apply: eq_bigr => p _; rewrite pcoreJ.\nQed.",
    "Lemma Fitting_char : 'F(G) \\char G. Proof. exact: gFchar. Qed.",
    "Lemma injm_Fitting : 'injm f -> G \\subset D -> f @* 'F(G) = 'F(f @* G).\nProof. exact: injmF. Qed.",
    "Lemma isog_Fitting (H : {group rT}) : G \\isog H -> 'F(G) \\isog 'F(H).\nProof. exact: gFisog. Qed.",
    "Lemma minnormal_charsimple G H : minnormal H G -> charsimple H.\nProof.\ncase/mingroupP=> /andP[ntH nHG] minH.\napply/charsimpleP; split=> // K ntK chK.\nby apply: minH; rewrite ?ntK (char_sub chK, char_norm_trans chK).\nQed.",
    "Lemma maxnormal_charsimple G H L :\n  G <| L -> maxnormal H G L -> charsimple (G / H).\nProof.\ncase/andP=> sGL nGL /maxgroupP[/andP[/andP[sHG not_sGH] nHL] maxH].\nhave nHG: G \\subset 'N(H) := subset_trans sGL nHL.\napply/charsimpleP; rewrite -subG1 quotient_sub1 //; split=> // HK ntHK chHK.\ncase/(inv_quotientN _): (char_normal chHK) => [|K defHK sHK]; first exact/andP.\ncase/andP; rewrite subEproper defHK => /predU1P[-> // | ltKG] nKG.\nhave nHK: H <| K by rewrite /normal sHK (subset_trans (proper_sub ltKG)).\ncase/negP: ntHK; rewrite defHK -subG1 quotient_sub1 ?normal_norm //.\nrewrite (maxH K) // ltKG -(quotientGK nHK) -defHK norm_quotient_pre //.\nby rewrite (char_norm_trans chHK) ?quotient_norms.\nQed.",
    "Lemma abelem_split_dprod rT p (A B : {group rT}) :\n  p.-abelem A -> B \\subset A -> exists C : {group rT}, B \\x C = A.\nProof.\nmove=> abelA sBA; have [_ cAA _]:= and3P abelA.\ncase/splitsP: (abelem_splits abelA sBA) => C /complP[tiBC defA].\nby exists C; rewrite dprodE // (centSS _ sBA cAA) // -defA mulG_subr.\nQed.",
    "Lemma p_abelem_split1 rT p (A : {group rT}) x :\n     p.-abelem A -> x \\in A ->\n  exists B : {group rT}, [/\\ B \\subset A, #|B| = #|A| %/ #[x] & <[x]> \\x B = A].\nProof.\nmove=> abelA Ax; have sxA: <[x]> \\subset A by rewrite cycle_subG.\nhave [B defA] := abelem_split_dprod abelA sxA.\nhave [_ defxB _ ti_xB] := dprodP defA.\nhave sBA: B \\subset A by rewrite -defxB mulG_subr.\nby exists B; split; rewrite // -defxB (TI_cardMg ti_xB) mulKn ?order_gt0.\nQed.",
    "Lemma abelem_charsimple p G : p.-abelem G -> G :!=: 1 -> charsimple G.\nProof.\nmove=> abelG ntG; apply/charsimpleP; split=> // K ntK /charP[sKG chK].\ncase/eqVproper: sKG => // /properP[sKG [x Gx notKx]].\nhave ox := abelem_order_p abelG Gx (group1_contra notKx).\nhave [A [sAG oA defA]] := p_abelem_split1 abelG Gx.\ncase/trivgPn: ntK => y Ky nty; have Gy := subsetP sKG y Ky.\nhave{nty} oy := abelem_order_p abelG Gy nty.\nhave [B [sBG oB defB]] := p_abelem_split1 abelG Gy.\nhave: isog A B; last case/isogP=> fAB injAB defAB.\n  rewrite (isog_abelem_card _ (abelemS sAG abelG)) (abelemS sBG) //=.\n  by rewrite oA oB ox oy.\nhave: isog <[x]> <[y]>; last case/isogP=> fxy injxy /= defxy.\n  by rewrite isog_cyclic_card ?cycle_cyclic // [#|_|]oy -ox eqxx.\nhave cfxA: fAB @* A \\subset 'C(fxy @* <[x]>).\n  by rewrite defAB defxy; case/dprodP: defB.\nhave injf: 'injm (dprodm defA cfxA).\n  by rewrite injm_dprodm injAB injxy defAB defxy; apply/eqP; case/dprodP: defB.\ncase/negP: notKx; rewrite -cycle_subG -(injmSK injf) ?cycle_subG //=.\nrewrite morphim_dprodml // defxy cycle_subG /= chK //.\nhave [_ {4}<- _ _] := dprodP defB; have [_ {3}<- _ _] := dprodP defA.\nby rewrite morphim_dprodm // defAB defxy.\nQed.",
    "Lemma charsimple_dprod G : charsimple G ->\n  exists H : {group gT}, [/\\ H \\subset G, simple H\n                         & exists2 I : {set {perm gT}}, I \\subset Aut G\n                         & \\big[dprod/1]_(f in I) f @: H = G].\nProof.\ncase/charsimpleP=> ntG simG.\nhave [H minH sHG]: {H : {group gT} | minnormal H G & H \\subset G}.\n  by apply: mingroup_exists; rewrite ntG normG.\ncase/mingroupP: minH => /andP[ntH nHG] minH.\npose Iok (I : {set {perm gT}}) :=\n  (I \\subset Aut G) &&\n  [exists (M : {group gT} | M <| G), \\big[dprod/1]_(f in I) f @: H == M].\nhave defH: (1 : {perm gT}) @: H = H.\n  apply/eqP; rewrite eqEcard card_imset ?leqnn; last exact: perm_inj.\n  by rewrite andbT; apply/subsetP=> _ /imsetP[x Hx ->]; rewrite perm1.\nhave [|I] := @maxset_exists _ Iok 1.\n  rewrite /Iok sub1G; apply/existsP; exists H.\n  by rewrite /normal sHG nHG (big_pred1 1) => [|f]; rewrite ?defH /= ?inE.\ncase/maxsetP=> /andP[Aut_I /exists_eq_inP[M /andP[sMG nMG] defM]] maxI.\nrewrite sub1set=> ntI; case/eqVproper: sMG => [defG | /andP[sMG not_sGM]].\n  exists H; split=> //; last by exists I; rewrite ?defM.\n  apply/mingroupP; rewrite ntH normG; split=> // N /andP[ntN nNH] sNH.\n  apply: minH => //; rewrite ntN /= -defG.\n  move: defM; rewrite (bigD1 1) //= defH; case/dprodP=> [[_ K _ ->] <- cHK _].\n  by rewrite mul_subG // cents_norm // (subset_trans cHK) ?centS.\nhave defG: <<\\bigcup_(f in Aut G) f @: H>> = G.\n  have sXG: \\bigcup_(f in Aut G) f @: H \\subset G.\n    by apply/bigcupsP=> f Af; rewrite -(im_autm Af) morphimEdom imsetS.\n  apply: simG.\n    apply: contra ntH; rewrite -!subG1; apply: subset_trans.\n    by rewrite sub_gen // (bigcup_max 1) ?group1 ?defH.\n  rewrite /characteristic gen_subG sXG; apply/forall_inP=> f Af.\n  rewrite -(autmE Af) -morphimEsub ?gen_subG ?morphim_gen // genS //.\n  rewrite morphimEsub //= autmE.\n  apply/subsetP=> _ /imsetP[_ /bigcupP[g Ag /imsetP[x Hx ->]] ->].\n  apply/bigcupP; exists (g * f); first exact: groupM.\n  by apply/imsetP; exists x; rewrite // permM.\nhave [f Af sfHM]: exists2 f, f \\in Aut G & ~~ (f @: H \\subset M).\n  move: not_sGM; rewrite -{1}defG gen_subG; case/subsetPn=> x.\n  by case/bigcupP=> f Af fHx Mx; exists f => //; apply/subsetPn; exists x.\ncase If: (f \\in I).\n  by case/negP: sfHM; rewrite -(bigdprodWY defM) sub_gen // (bigcup_max f).\ncase/idP: (If); rewrite -(maxI ([set f] :|: I)) ?subsetUr ?inE ?eqxx //.\nrewrite {maxI}/Iok subUset sub1set Af {}Aut_I; apply/existsP.\nhave sfHG: autm Af @* H \\subset G by rewrite -{4}(im_autm Af) morphimS.\nhave{minH nHG} /mingroupP[/andP[ntfH nfHG] minfH]: minnormal (autm Af @* H) G.\n  apply/mingroupP; rewrite andbC -{1}(im_autm Af) morphim_norms //=.\n  rewrite -subG1 sub_morphim_pre // -kerE ker_autm subG1.\n  split=> // N /andP[ntN nNG] sNfH.\n  have sNG: N \\subset G := subset_trans sNfH sfHG.\n  apply/eqP; rewrite eqEsubset sNfH sub_morphim_pre //=.\n  rewrite -(morphim_invmE (injm_autm Af)) [_ @* N]minH //=.\n    rewrite -subG1 sub_morphim_pre /= ?im_autm // morphpre_invm morphim1 subG1.\n    by rewrite ntN -{1}(im_invm (injm_autm Af)) /= {2}im_autm morphim_norms.\n  by rewrite sub_morphim_pre /= ?im_autm // morphpre_invm.\nhave{minfH sfHM} tifHM: autm Af @* H :&: M = 1.\n  apply/eqP/idPn=> ntMfH; case/setIidPl: sfHM.\n  rewrite -(autmE Af) -morphimEsub //.\n  by apply: minfH; rewrite ?subsetIl // ntMfH normsI.\nhave cfHM: M \\subset 'C(autm Af @* H).\n  rewrite centsC (sameP commG1P trivgP) -tifHM subsetI commg_subl commg_subr.\n  by rewrite (subset_trans sMG) // (subset_trans sfHG).\nexists (autm Af @* H <*> M)%G; rewrite /normal /= join_subG sMG sfHG normsY //=.\nrewrite (bigD1 f) ?inE ?eqxx // (eq_bigl [in I]) /= => [|g]; last first.\n  by rewrite /= !inE andbC; case: eqP => // ->.\nby rewrite defM -(autmE Af) -morphimEsub // dprodE // cent_joinEr ?eqxx.\nQed.",
    "Lemma simple_sol_prime G : solvable G -> simple G -> prime #|G|.\nProof.\nmove=> solG /simpleP[ntG simG].\nhave{solG} cGG: abelian G.\n  apply/commG1P; case/simG: (der_normal 1 G) => // /eqP/idPn[].\n  by rewrite proper_neq // (sol_der1_proper solG).\ncase: (trivgVpdiv G) ntG => [-> | [p p_pr]]; first by rewrite eqxx.\ncase/Cauchy=> // x Gx oxp _; move: p_pr; rewrite -oxp orderE.\nhave: <[x]> <| G by rewrite -sub_abelian_normal ?cycle_subG.\nby case/simG=> -> //; rewrite cards1.\nQed.",
    "Lemma charsimple_solvable G : charsimple G -> solvable G -> is_abelem G.\nProof.\ncase/charsimple_dprod=> H [sHG simH [I Aut_I defG]] solG.\nhave p_pr: prime #|H| by apply: simple_sol_prime (solvableS sHG solG) simH.\nset p := #|H| in p_pr; apply/is_abelemP; exists p => //.\nelim/big_rec: _ (G) defG => [_ <-|f B If IH_B M defM]; first exact: abelem1.\nhave [Af [[_ K _ defB] _ _ _]] := (subsetP Aut_I f If, dprodP defM).\nrewrite (dprod_abelem p defM) defB IH_B // andbT -(autmE Af) -morphimEsub //=.\nrewrite morphim_abelem ?abelemE // exponent_dvdn.\nby rewrite cyclic_abelian ?prime_cyclic.\nQed.",
    "Lemma minnormal_solvable L G H :\n    minnormal H L -> H \\subset G -> solvable G ->\n  [/\\ L \\subset 'N(H), H :!=: 1 & is_abelem H].\nProof.\nmove=> minH sHG solG; have /andP[ntH nHL] := mingroupp minH.\nsplit=> //; apply: (charsimple_solvable (minnormal_charsimple minH)).\nexact: solvableS solG.\nQed.",
    "Lemma solvable_norm_abelem L G :\n    solvable G -> G <| L -> G :!=: 1 ->\n  exists H : {group gT}, [/\\ H \\subset G, H <| L, H :!=: 1 & is_abelem H].\nProof.\nmove=> solG /andP[sGL nGL] ntG.\nhave [H minH sHG]: {H : {group gT} | minnormal H L & H \\subset G}.\n  by apply: mingroup_exists; rewrite ntG.\nhave [nHL ntH abH] := minnormal_solvable minH sHG solG.\nby exists H; split; rewrite // /normal (subset_trans sHG).\nQed.",
    "Lemma trivg_Fitting G : solvable G -> ('F(G) == 1) = (G :==: 1).\nProof.\nmove=> solG; apply/idP/idP=> [F1 | /eqP->]; last by rewrite gF1.\napply/idPn=> /(solvable_norm_abelem solG (normal_refl _))[M [_ nsMG ntM]].\ncase/is_abelemP=> p _ /and3P[pM _ _]; case/negP: ntM.\nby rewrite -subG1 -(eqP F1) Fitting_max ?(pgroup_nil pM).\nQed.",
    "Lemma Fitting_pcore pi G : 'F('O_pi(G)) = 'O_pi('F(G)).\nProof.\napply/eqP; rewrite eqEsubset.\nrewrite (subset_trans _ (pcoreS _ (Fitting_sub _))); last first.\n  by rewrite subsetI Fitting_sub Fitting_max ?Fitting_nil ?gFnormal_trans.\nrewrite (subset_trans _ (FittingS (pcore_sub _ _))) // subsetI pcore_sub.\nby rewrite pcore_max ?pcore_pgroup ?gFnormal_trans.\nQed.",
    "Lemma index_maxnormal_sol_prime (H : {group gT}) :\n  solvable G -> maxnormal H G G -> prime #|G : H|.\nProof.\nmove=> solG maxH; have nsHG := maxnormal_normal maxH.\nrewrite -card_quotient ?normal_norm // simple_sol_prime ?quotient_sol //.\nby rewrite quotient_simple.\nQed.",
    "Lemma sol_prime_factor_exists :\n  solvable G -> G :!=: 1 -> {H : {group gT} | H <| G & prime #|G : H| }.\nProof.\nmove=> solG /ex_maxnormal_ntrivg[H maxH].\nby exists H; [apply: maxnormal_normal | apply: index_maxnormal_sol_prime].\nQed.",
    "Lemma center_special_abelem : p.-group G -> special G -> p.-abelem 'Z(G).\nProof.\nmove=> pG [defPhi defG'].\nhave [-> | ntG] := eqsVneq G 1; first by rewrite center1 abelem1.\nhave [p_pr _ _] := pgroup_pdiv pG ntG.\nhave fM: {in 'Z(G) &, {morph expgn^~ p : x y / x * y}}.\n  by move=> x y /setIP[_ /centP cxG] /setIP[/cxG cxy _]; apply: expgMn.\nrewrite abelemE //= center_abelian; apply/exponentP=> /= z Zz.\napply: (@kerP _ _ _ (Morphism fM)) => //; apply: subsetP z Zz.\nrewrite -{1}defG' gen_subG; apply/subsetP=> _ /imset2P[x y Gx Gy ->].\nhave Zxy: [~ x, y] \\in 'Z(G) by rewrite -defG' mem_commg.\nhave Zxp: x ^+ p \\in 'Z(G).\n  rewrite -defPhi (Phi_joing pG) (MhoE 1 pG) joing_idr mem_gen // !inE.\n  by rewrite expn1 orbC (imset_f (expgn^~ p)).\nrewrite mem_morphpre /= ?defG' ?Zxy // inE -commXg; last first.\n  by red; case/setIP: Zxy => _ /centP->.\nby apply/commgP; red; case/setIP: Zxp => _ /centP->.\nQed.",
    "Lemma exponent_special : p.-group G -> special G -> exponent G %| p ^ 2.\nProof.\nmove=> pG spG; have [defPhi _] := spG.\nhave /and3P[_ _ expZ] := center_special_abelem pG spG.\napply/exponentP=> x Gx; rewrite expgM (exponentP expZ) // -defPhi.\nby rewrite (Phi_joing pG) mem_gen // inE orbC (Mho_p_elt 1) ?(mem_p_elt pG).\nQed.",
    "Lemma extraspecial_prime : prime p.\nProof.\nby case: esS => _ /prime_gt1; rewrite cardG_gt1; case/(pgroup_pdiv pZ).\nQed.",
    "Lemma card_center_extraspecial : #|'Z(S)| = p.\nProof. by apply/eqP; apply: (pgroupP pZ); case: esS. Qed.",
    "Lemma min_card_extraspecial : #|S| >= p ^ 3.\nProof.\nhave p_gt1 := prime_gt1 extraspecial_prime.\nrewrite leqNgt (card_pgroup pS) ltn_exp2l // ltnS.\ncase: esS => [[_ defS']]; apply: contraL => /(p2group_abelian pS)/derG1P S'1.\nby rewrite -defS' S'1 cards1.\nQed.",
    "Lemma card_p3group_extraspecial E :\n  prime p -> #|E| = (p ^ 3)%N -> #|'Z(E)| = p -> extraspecial E.\nProof.\nmove=> p_pr oEp3 oZp; have p_gt0 := prime_gt0 p_pr.\nhave pE: p.-group E by rewrite /pgroup oEp3 pnatX pnat_id.\nhave pEq: p.-group (E / 'Z(E))%g by rewrite quotient_pgroup.\nhave /andP[sZE nZE] := center_normal E.\nhave oEq: #|E / 'Z(E)|%g = (p ^ 2)%N.\n  by rewrite card_quotient -?divgS // oEp3 oZp expnS mulKn.\nhave cEEq: abelian (E / 'Z(E))%g by apply: card_p2group_abelian oEq.\nhave not_cEE: ~~ abelian E.\n  have: #|'Z(E)| < #|E| by rewrite oEp3 oZp (ltn_exp2l 1) ?prime_gt1.\n  by apply: contraL => cEE; rewrite -leqNgt subset_leq_card // subsetI subxx.\nhave defE': E^`(1) = 'Z(E).\n  apply/eqP; rewrite eqEsubset der1_min //=; apply: contraR not_cEE => not_sE'Z.\n  apply/commG1P/(TI_center_nil (pgroup_nil pE) (der_normal 1 _)).\n  by rewrite setIC prime_TIg ?oZp.\nsplit; [split=> // | by rewrite oZp]; apply/eqP.\nrewrite eqEsubset andbC -{1}defE' {1}(Phi_joing pE) joing_subl.\nrewrite -quotient_sub1 ?gFsub_trans ?subG1 //=.\nrewrite (quotient_Phi pE) //= (trivg_Phi pEq).\napply/abelemP=> //; split=> // Zx EqZx; apply/eqP; rewrite -order_dvdn /order.\nrewrite (card_pgroup (mem_p_elt pEq EqZx)) (@dvdn_exp2l _ _ 1) //.\nrewrite leqNgt -pfactor_dvdn // -oEq; apply: contra not_cEE => sEqZx.\nrewrite cyclic_center_factor_abelian //; apply/cyclicP.\nexists Zx; apply/eqP; rewrite eq_sym eqEcard cycle_subG EqZx -orderE.\nexact: dvdn_leq sEqZx.\nQed.",
    "Lemma p3group_extraspecial G :\n  p.-group G -> ~~ abelian G -> logn p #|G| <= 3 -> extraspecial G.\nProof.\nmove=> pG not_cGG; have /andP[sZG nZG] := center_normal G.\nhave ntG: G :!=: 1 by apply: contraNneq not_cGG => ->; apply: abelian1.\nhave ntZ: 'Z(G) != 1 by rewrite (center_nil_eq1 (pgroup_nil pG)).\nhave [p_pr _ [n oG]] := pgroup_pdiv pG ntG; rewrite oG pfactorK //.\nhave [_ _ [m oZ]] := pgroup_pdiv (pgroupS sZG pG) ntZ.\nhave lt_m1_n: m.+1 < n.\n  suffices: 1 < logn p #|(G / 'Z(G))|.\n    rewrite card_quotient // -divgS // logn_div ?cardSg //.\n    by rewrite oG oZ !pfactorK // ltn_subRL addn1.\n  rewrite ltnNge; apply: contra not_cGG => cycGs.\n  apply: cyclic_center_factor_abelian; rewrite (dvdn_prime_cyclic p_pr) //.\n  by rewrite (card_pgroup (quotient_pgroup _ pG)) (dvdn_exp2l _ cycGs).\nrewrite -{lt_m1_n}(subnKC lt_m1_n) !addSn !ltnS leqn0 in oG *.\ncase: m => // in oZ oG * => /eqP n2; rewrite {n}n2 in oG.\nexact: card_p3group_extraspecial oZ.\nQed.",
    "Lemma extraspecial_nonabelian G : extraspecial G -> ~~ abelian G.\nProof.\ncase=> [[_ defG'] oZ]; rewrite /abelian (sameP commG1P eqP).\nby rewrite -derg1 defG' -cardG_gt1 prime_gt1.\nQed.",
    "Lemma exponent_2extraspecial G : 2.-group G -> extraspecial G -> exponent G = 4.\nProof.\nmove=> p2G esG; have [spG _] := esG.\ncase/dvdn_pfactor: (exponent_special p2G spG) => // k.\nrewrite leq_eqVlt ltnS => /predU1P[-> // | lek1] expG.\ncase/negP: (extraspecial_nonabelian esG).\nby rewrite (@abelem_abelian _ 2) ?exponent2_abelem // expG pfactor_dvdn.\nQed.",
    "Lemma injm_special D G (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> special G -> special (f @* G).\nProof.\nmove=> injf sGD [defPhiG defG'].\nby rewrite /special -morphim_der // -injm_Phi // defPhiG defG' injm_center.\nQed.",
    "Lemma injm_extraspecial D G (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> extraspecial G -> extraspecial (f @* G).\nProof.\nmove=> injf sGD [spG ZG_pr]; split; first exact: injm_special spG.\nby rewrite -injm_center // card_injm // subIset ?sGD.\nQed.",
    "Lemma isog_special G (R : {group rT}) :\n  G \\isog R -> special G -> special R.\nProof. by case/isogP=> f injf <-; apply: injm_special. Qed.",
    "Lemma isog_extraspecial G (R : {group rT}) :\n  G \\isog R -> extraspecial G -> extraspecial R.\nProof. by case/isogP=> f injf <-; apply: injm_extraspecial. Qed.",
    "Lemma cprod_extraspecial G H K :\n    p.-group G -> H \\* K = G -> H :&: K = 'Z(H) ->\n  extraspecial H -> extraspecial K -> extraspecial G.\nProof.\nmove=> pG defG ziHK [[PhiH defH'] ZH_pr] [[PhiK defK'] ZK_pr].\nhave [_ defHK cHK]:= cprodP defG.\nhave sZHK: 'Z(H) \\subset 'Z(K).\n  by rewrite subsetI -{1}ziHK subsetIr subIset // centsC cHK.\nhave{sZHK} defZH: 'Z(H) = 'Z(K).\n  by apply/eqP; rewrite eqEcard sZHK leq_eqVlt eq_sym -dvdn_prime2 ?cardSg.\nhave defZ: 'Z(G) = 'Z(K).\n  by case/cprodP: (center_cprod defG) => /= _ <- _; rewrite defZH mulGid.\nsplit; first split; rewrite defZ //.\n  by have /cprodP[_ <- _] := Phi_cprod pG defG; rewrite PhiH PhiK defZH mulGid.\nby have /cprodP[_ <- _] := der_cprod 1 defG; rewrite defH' defK' defZH mulGid.\nQed.",
    "Lemma cent1_extraspecial_maximal x :\n  x \\in G -> x \\notin 'Z(G) -> maximal 'C_G[x] G.\nProof.\nmove=> Gx notZx; pose f y := [~ x, y]; have [[_ defG'] prZ] := esG.\nhave{defG'} fZ y: y \\in G -> f y \\in 'Z(G).\n  by move=> Gy; rewrite -defG' mem_commg.\nhave fM: {in G &, {morph f : y z / y * z}}%g.\n  move=> y z Gy Gz; rewrite {1}/f commgMJ conjgCV -conjgM (conjg_fixP _) //.\n  rewrite (sameP commgP cent1P); apply: subsetP (fZ y Gy).\n  by rewrite subIset // orbC -cent_set1 centS // sub1set !(groupM, groupV).\npose fm := Morphism fM.\nhave fmG: fm @* G = 'Z(G).\n  have sfmG: fm @* G \\subset 'Z(G).\n    by apply/subsetP=> _ /morphimP[z _ Gz ->]; apply: fZ.\n  apply/eqP; rewrite eqEsubset sfmG; apply: contraR notZx => /(prime_TIg prZ).\n  rewrite (setIidPr _) // => fmG1; rewrite inE Gx; apply/centP=> y Gy.\n  by apply/commgP; rewrite -in_set1 -[[set _]]fmG1; apply: mem_morphim.\nhave ->: 'C_G[x] = 'ker fm.\n  apply/setP=> z; rewrite inE (sameP cent1P commgP) !inE.\n  by rewrite -invg_comm eq_invg_mul mulg1.\nrewrite p_index_maximal ?subsetIl // -card_quotient ?ker_norm //.\nby rewrite (card_isog (first_isog fm)) /= fmG.\nQed.",
    "Lemma subcent1_extraspecial_maximal U x :\n  U \\subset G -> x \\in G :\\: 'C(U) -> maximal 'C_U[x] U.\nProof.\nmove=> sUG /setDP[Gx not_cUx]; apply/maxgroupP; split=> [|H ltHU sCxH].\n  by rewrite /proper subsetIl subsetI subxx sub_cent1.\ncase/andP: ltHU => sHU not_sHU; have sHG := subset_trans sHU sUG.\napply/eqP; rewrite eqEsubset sCxH subsetI sHU /= andbT.\napply: contraR not_sHU => not_sHCx.\nhave maxCx: maximal 'C_G[x] G.\n  rewrite cent1_extraspecial_maximal //; apply: contra not_cUx.\n  by rewrite inE Gx; apply: subsetP (centS sUG) _.\nhave nsCx := p_maximal_normal pG maxCx.\nrewrite -(setIidPl sUG) -(mulg_normal_maximal nsCx maxCx sHG) ?subsetI ?sHG //.\nby rewrite -group_modr //= setIA (setIidPl sUG) mul_subG.\nQed.",
    "Lemma card_subcent_extraspecial U :\n  U \\subset G -> #|'C_G(U)| = (#|'Z(G) :&: U| * #|G : U|)%N.\nProof.\nmove=> sUG; rewrite setIAC (setIidPr sUG).\nhave [m leUm] := ubnP #|U|; elim: m => // m IHm in U leUm sUG *.\nhave [cUG | not_cUG]:= orP (orbN (G \\subset 'C(U))).\n  by rewrite !(setIidPl _) ?Lagrange // centsC.\nhave{not_cUG} [x Gx not_cUx] := subsetPn not_cUG.\npose W := 'C_U[x]; have sCW_G: 'C_G(W) \\subset G := subsetIl G _.\nhave maxW: maximal W U by rewrite subcent1_extraspecial_maximal // inE not_cUx.\nhave nsWU: W <| U := p_maximal_normal (pgroupS sUG pG) maxW.\nhave ltWU: W \\proper U by apply: maxgroupp maxW.\nhave [sWU [u Uu notWu]] := properP ltWU; have sWG := subset_trans sWU sUG.\nhave defU: W * <[u]> = U by rewrite (mulg_normal_maximal nsWU) ?cycle_subG.\nhave iCW_CU: #|'C_G(W) : 'C_G(U)| = p.\n  rewrite -defU centM cent_cycle setIA /=; rewrite inE Uu cent1C in notWu.\n  apply: p_maximal_index (pgroupS sCW_G pG) _.\n  apply: subcent1_extraspecial_maximal sCW_G _.\n  rewrite inE andbC (subsetP sUG) //= -sub_cent1.\n  by apply/subsetPn; exists x; rewrite // inE Gx -sub_cent1 subsetIr.\napply/eqP; rewrite -(eqn_pmul2r p_gt0) -{1}iCW_CU Lagrange ?setIS ?centS //.\nrewrite IHm ?(leq_trans (proper_card ltWU)) // -setIA -mulnA.\nrewrite -(Lagrange_index sUG sWU) (p_maximal_index (pgroupS sUG pG)) //=.\nby rewrite -cent_set1 (setIidPr (centS _)) ?sub1set.\nQed.",
    "Lemma split1_extraspecial x :\n    x \\in G :\\: 'Z(G) ->\n  {E : {group gT} & {R : {group gT} |\n    [/\\ #|E| = (p ^ 3)%N /\\ #|R| = #|G| %/ p ^ 2,\n        E \\* R = G /\\ E :&: R = 'Z(E),\n        'Z(E) = 'Z(G) /\\ 'Z(R) = 'Z(G),\n        extraspecial E /\\ x \\in E\n      & if abelian R then R :=: 'Z(G) else extraspecial R]}}.\nProof.\ncase/setDP=> Gx notZx; rewrite inE Gx /= in notZx.\nhave [[defPhiG defG'] prZ] := esG.\nhave maxCx: maximal 'C_G[x] G.\n  by rewrite subcent1_extraspecial_maximal // inE notZx.\npose y := repr (G :\\: 'C[x]).\nhave [Gy not_cxy]: y \\in G /\\ y \\notin 'C[x].\n  move/maxgroupp: maxCx => /properP[_ [t Gt not_cyt]].\n  by apply/setDP; apply: (mem_repr t); rewrite !inE Gt andbT in not_cyt *.\npose E := <[x]> <*> <[y]>; pose R := 'C_G(E).\nexists [group of E]; exists [group of R] => /=.\nhave sEG: E \\subset G by rewrite join_subG !cycle_subG Gx.\nhave [Ex Ey]: x \\in E /\\ y \\in E by rewrite !mem_gen // inE cycle_id ?orbT.\nhave sZE: 'Z(G) \\subset E.\n  rewrite (('Z(G) =P E^`(1)) _) ?der_sub // eqEsubset -{2}defG' dergS // andbT.\n  apply: contraR not_cxy => /= not_sZE'.\n  rewrite (sameP cent1P commgP) -in_set1 -[[set 1]](prime_TIg prZ not_sZE').\n  by rewrite /= -defG' inE !mem_commg.\nhave ziER: E :&: R = 'Z(E) by rewrite setIA (setIidPl sEG).\nhave cER: R \\subset 'C(E) by rewrite subsetIr.\nhave iCxG: #|G : 'C_G[x]| = p by apply: p_maximal_index.\nhave maxR: maximal R 'C_G[x].\n  rewrite /R centY !cent_cycle setIA.\n  rewrite subcent1_extraspecial_maximal ?subsetIl // inE Gy andbT -sub_cent1.\n  by apply/subsetPn; exists x; rewrite 1?cent1C // inE Gx cent1id.\nhave sRCx: R \\subset 'C_G[x] by rewrite -cent_cycle setIS ?centS ?joing_subl.\nhave sCxG: 'C_G[x] \\subset G by rewrite subsetIl.\nhave sRG: R \\subset G by rewrite subsetIl.\nhave iRCx: #|'C_G[x] : R| = p by rewrite (p_maximal_index (pgroupS sCxG pG)).\nhave defG: E * R = G.\n  rewrite -cent_joinEr //= -/R joingC joingA.\n  have cGx_x: <[x]> \\subset 'C_G[x] by rewrite cycle_subG inE Gx cent1id.\n  have nsRcx := p_maximal_normal (pgroupS sCxG pG) maxR.\n  rewrite (norm_joinEr (subset_trans cGx_x (normal_norm nsRcx))).\n  rewrite (mulg_normal_maximal nsRcx) //=; last first.\n    by rewrite centY !cent_cycle cycle_subG !in_setI Gx cent1id cent1C.\n  have nsCxG := p_maximal_normal pG maxCx.\n  have syG: <[y]> \\subset G by rewrite cycle_subG.\n  rewrite (norm_joinEr (subset_trans syG (normal_norm nsCxG))).\n  by rewrite (mulg_normal_maximal nsCxG) //= cycle_subG inE Gy.\nhave defZR: 'Z(R) = 'Z(G) by rewrite -['Z(R)]setIA -centM defG.\nhave defZE: 'Z(E) = 'Z(G).\n  by rewrite -defG -center_prod ?mulGSid //= -ziER subsetI center_sub defZR sZE.\nhave [n oG] := p_natP pG.\nhave n_gt1: n > 1.\n   by rewrite ltnW // -(@leq_exp2l p) // -oG min_card_extraspecial.\nhave oR: #|R| = (p ^ n.-2)%N.\n  apply/eqP; rewrite -(divg_indexS sRCx) iRCx /= -(divg_indexS sCxG) iCxG /= oG.\n  by rewrite -{1}(subnKC n_gt1) subn2 !expnS !mulKn.\nhave oE: #|E| = (p ^ 3)%N.\n  apply/eqP; rewrite -(@eqn_pmul2r #|R|) ?cardG_gt0 // mul_cardG defG ziER.\n  by rewrite defZE oZ oG -{1}(subnKC n_gt1) oR -expnSr -expnD subn2.\nrewrite cprodE // oR oG -expnB ?subn2 //; split=> //.\n  by split=> //; apply: card_p3group_extraspecial _ oE _; rewrite // defZE.\ncase: ifP => [cRR | not_cRR]; first by rewrite -defZR (center_idP _).\nsplit; rewrite /special defZR //.\nhave ntR': R^`(1) != 1 by rewrite (sameP eqP commG1P) -abelianE not_cRR.\nhave pR: p.-group R := pgroupS sRG pG.\nhave pR': p.-group R^`(1) := pgroupS (der_sub 1 _) pR.\nhave defR': R^`(1) = 'Z(G).\n  apply/eqP; rewrite eqEcard -{1}defG' dergS //= oZ.\n  by have [_ _ [k ->]]:= pgroup_pdiv pR' ntR'; rewrite (leq_exp2l 1).\nsplit=> //; apply/eqP; rewrite eqEsubset -{1}defPhiG -defR' (PhiS pG) //=.\nby rewrite (Phi_joing pR) joing_subl.\nQed.",
    "Lemma pmaxElem_extraspecial : 'E*_p(G) = 'E_p^('r_p(G))(G).\nProof.\nhave sZmax: {in 'E*_p(G), forall E, 'Z(G) \\subset E}.\n  move=> E maxE; have defE := pmaxElem_LdivP p_pr maxE.\n  have abelZ: p.-abelem 'Z(G) by rewrite prime_abelem ?oZ.\n  rewrite -(Ohm1_id abelZ) (OhmE 1 (abelem_pgroup abelZ)) gen_subG -defE.\n  by rewrite setSI // setIS ?centS // -defE !subIset ?subxx.\nsuffices card_max: {in 'E*_p(G) &, forall E F, #|E| <= #|F| }.\n  have EprGmax: 'E_p^('r_p(G))(G) \\subset 'E*_p(G) := p_rankElem_max p G.\n  have [E EprE]:= p_rank_witness p G; have maxE := subsetP EprGmax E EprE.\n  apply/eqP; rewrite eqEsubset EprGmax andbT; apply/subsetP=> F maxF.\n  rewrite inE; have [-> _]:= pmaxElemP maxF; have [_ _ <-]:= pnElemP EprE.\n  by apply/eqP; congr (logn p _); apply/eqP; rewrite eqn_leq !card_max.\nmove=> E F maxE maxF; set U := E :&: F.\nhave [sUE sUF]: U \\subset E /\\ U \\subset F by apply/andP; rewrite -subsetI.\nhave sZU: 'Z(G) \\subset U by rewrite subsetI !sZmax.\nhave [EpE _]:= pmaxElemP maxE; have{EpE} [sEG abelE] := pElemP EpE.\nhave [EpF _]:= pmaxElemP maxF; have{EpF} [sFG abelF] := pElemP EpF.\nhave [V] := abelem_split_dprod abelE sUE; case/dprodP=> _ defE cUV tiUV.\nhave [W] := abelem_split_dprod abelF sUF; case/dprodP=> _ defF _ tiUW.\nhave [sVE sWF]: V \\subset E /\\ W \\subset F by rewrite -defE -defF !mulG_subr.\nhave [sVG sWG] := (subset_trans sVE sEG, subset_trans sWF sFG).\nrewrite -defE -defF !TI_cardMg // leq_pmul2l ?cardG_gt0 //.\nrewrite -(leq_pmul2r (cardG_gt0 'C_G(W))) mul_cardG.\nrewrite card_subcent_extraspecial // mulnCA Lagrange // mulnC.\nrewrite leq_mul ?subset_leq_card //; last by rewrite mul_subG ?subsetIl.\napply: subset_trans (sub1G _); rewrite -tiUV !subsetI subsetIl subIset ?sVE //=.\nrewrite -(pmaxElem_LdivP p_pr maxF) -defF centM -!setIA -(setICA 'C(W)).\nrewrite setIC (setIA G) setIS // subsetI cUV sub_LdivT.\nby case/and3P: (abelemS sVE abelE).\nQed.",
    "Lemma critical_extraspecial R S :\n    p.-group R -> S \\subset R -> extraspecial S -> [~: S, R] \\subset S^`(1) ->\n  S \\* 'C_R(S) = R.\nProof.\nmove=> pR sSR esS sSR_S'; have [[defPhi defS'] _] := esS.\nhave [pS [sPS nPS]] := (pgroupS sSR pR, andP (Phi_normal S : 'Phi(S) <| S)).\nhave{esS} oZS: #|'Z(S)| = p := card_center_extraspecial pS esS.\nhave nSR: R \\subset 'N(S) by rewrite -commg_subl (subset_trans sSR_S') ?der_sub.\nhave nsCR: 'C_R(S) <| R by rewrite (normalGI nSR) ?cent_normal.\nhave nCS: S \\subset 'N('C_R(S)) by rewrite cents_norm // centsC subsetIr.\nrewrite cprodE ?subsetIr //= -{2}(quotientGK nsCR) normC -?quotientK //.\ncongr (_ @*^-1 _); apply/eqP; rewrite eqEcard quotientS //=.\nrewrite -(card_isog (second_isog nCS)) setIAC (setIidPr sSR) /= -/'Z(S) -defPhi.\nrewrite -ker_conj_aut (card_isog (first_isog_loc _ nSR)) //=; set A := _ @* R.\nhave{pS} abelSb := Phi_quotient_abelem pS; have [pSb cSSb _] := and3P abelSb.\nhave [/= Xb defSb oXb] := grank_witness (S / 'Phi(S)).\npose X := (repr \\o val : coset_of _ -> gT) @: Xb.\nhave sXS: X \\subset S; last have nPX := subset_trans sXS nPS.\n  apply/subsetP=> x; case/imsetP=> xb Xxb ->; have nPx := repr_coset_norm xb.\n  rewrite -sub1set -(quotientSGK _ sPS) ?sub1set ?quotient_set1 //= sub1set.\n  by rewrite coset_reprK -defSb mem_gen.\nhave defS: <<X>> = S.\n  apply: Phi_nongen; apply/eqP; rewrite eqEsubset join_subG sPS sXS -joing_idr.\n  rewrite -genM_join sub_gen // -quotientSK ?quotient_gen // -defSb genS //.\n  apply/subsetP=> xb Xxb; apply/imsetP; rewrite (setIidPr nPX).\n  by exists (repr xb); rewrite /= ?coset_reprK //; apply: imset_f.\npose f (a : {perm gT}) := [ffun x => if x \\in X then x^-1 * a x else 1].\nhave injf: {in A &, injective f}.\n  move=> _ _ /morphimP[y nSy Ry ->] /morphimP[z nSz Rz ->].\n  move/ffunP=> eq_fyz; apply: (@eq_Aut _ S); rewrite ?Aut_aut //= => x Sx.\n  rewrite !norm_conj_autE //; apply: canRL (conjgKV z) _; rewrite -conjgM.\n  rewrite /conjg -(centP _ x Sx) ?mulKg {x Sx}// -defS cent_gen -sub_cent1.\n  apply/subsetP=> x Xx; have Sx := subsetP sXS x Xx.\n  move/(_ x): eq_fyz; rewrite !ffunE Xx !norm_conj_autE // => /mulgI xy_xz.\n  by rewrite cent1C inE conjg_set1 conjgM xy_xz conjgK.\nhave sfA_XS': f @: A \\subset pffun_on 1 X S^`(1).\n  apply/subsetP=> _ /imsetP[_ /morphimP[y nSy Ry ->] ->].\n  apply/pffun_onP; split=> [|_ /imageP[x /= Xx ->]].\n    by apply/subsetP=> x; apply: contraNT => /[!ffunE]/negPf->.\n  have Sx := subsetP sXS x Xx.\n  by rewrite ffunE Xx norm_conj_autE // (subsetP sSR_S') ?mem_commg.\nrewrite -(card_in_imset injf) (leq_trans (subset_leq_card sfA_XS')) // defS'.\nrewrite card_pffun_on (card_pgroup pSb) -rank_abelem -?grank_abelian // -oXb.\nby rewrite -oZS ?leq_pexp2l ?cardG_gt0 ?leq_imset_card.\nQed.",
    "Lemma card_extraspecial : {n | n > 0 & #|S| = (p ^ n.*2.+1)%N}.\nProof.\nset T := S; exists (logn p #|T|)./2.\n  rewrite half_gt0 ltnW // -(leq_exp2l _ _ (prime_gt1 p_pr)) -card_pgroup //.\n  exact: min_card_extraspecial.\nhave [Es] := extraspecial_structure pS esS; rewrite -[in RHS]/T.\nelim: Es T => [_ _ <-| E s IHs T] /=.\n  by rewrite big_nil cprod1g oZ (pfactorK 1).\nrewrite -andbA big_cons -cprodA => /and3P[/eqP oEp3 /eqP defZE].\nmove=> /IHs{}IHs /cprodP[[_ U _ defU]]; rewrite defU => defT cEU.\nrewrite -(mulnK #|T| (cardG_gt0 (E :&: U))) -defT -mul_cardG /=.\nhave ->: E :&: U = 'Z(S).\n  apply/eqP; rewrite eqEsubset subsetI -{1 2}defZE subsetIl setIS //=.\n  by case/cprodP: defU => [[V _ -> _]]  <- _; apply: mulG_subr.\nrewrite (IHs U) // oEp3 oZ -expnD addSn expnS mulKn ?prime_gt0 //.\nby rewrite pfactorK //= uphalf_double.\nQed.",
    "Lemma Aut_extraspecial_full : Aut_in (Aut S) 'Z(S) \\isog Aut 'Z(S).\nProof.\nhave [p_gt1 p_gt0] := (prime_gt1 p_pr, prime_gt0 p_pr).\nhave [Es] := extraspecial_structure pS esS.\nelim: Es S oZ => [T _ _ <-| E s IHs T oZT] /=.\n  rewrite big_nil cprod1g (center_idP (center_abelian T)).\n  by apply/Aut_sub_fullP=> // g injg gZ; exists g.\nrewrite -andbA big_cons -cprodA => /and3P[/eqP-oE /eqP-defZE es_s].\ncase/cprodP=> -[_ U _ defU]; rewrite defU => defT cEU.\nhave sUT: U \\subset T by rewrite -defT mulG_subr.\nhave sZU: 'Z(T) \\subset U.\n  by case/cprodP: defU => [[V _ -> _] <- _]; apply: mulG_subr.\nhave defZU: 'Z(E) = 'Z(U).\n  apply/eqP; rewrite eqEsubset defZE subsetI sZU subIset ?centS ?orbT //=.\n  by rewrite subsetI subIset ?sUT //= -defT centM setSI.\napply: (Aut_cprod_full _ defZU); rewrite ?cprodE //; last first.\n  by apply: IHs; rewrite -?defZU ?defZE.\nhave oZE: #|'Z(E)| = p by rewrite defZE.\nhave [p2 | odd_p] := even_prime p_pr.\n  suffices <-: restr_perm 'Z(E) @* Aut E = Aut 'Z(E) by apply: Aut_in_isog.\n  apply/eqP; rewrite eqEcard restr_perm_Aut ?center_sub //=.\n  by rewrite card_Aut_cyclic ?prime_cyclic ?oZE // {1}p2 cardG_gt0.\nhave pE: p.-group E by rewrite /pgroup oE pnatX pnat_id.\nhave nZE: E \\subset 'N('Z(E)) by rewrite normal_norm ?center_normal.\nhave esE: extraspecial E := card_p3group_extraspecial p_pr oE oZE.\nhave [[defPhiE defE'] prZ] := esE.\nhave{defPhiE} sEpZ x: x \\in E -> (x ^+ p)%g \\in 'Z(E).\n  move=> Ex; rewrite -defPhiE (Phi_joing pE) mem_gen // inE orbC.\n  by rewrite (Mho_p_elt 1) // (mem_p_elt pE).\nhave ltZE: 'Z(E) \\proper E by rewrite properEcard subsetIl oZE oE (ltn_exp2l 1).\nhave [x [Ex notZx oxp]]: exists x, [/\\ x \\in E, x \\notin 'Z(E) & #[x] %| p]%N.\n  have [_ [x Ex notZx]] := properP ltZE.\n  case: (prime_subgroupVti <[x ^+ p]> prZ) => [sZxp | ]; last first.\n    move/eqP; rewrite (setIidPl _) ?cycle_subG ?sEpZ //.\n    by rewrite cycle_eq1 -order_dvdn; exists x.\n  have [y Ey notxy]: exists2 y, y \\in E & y \\notin <[x]>.\n    apply/subsetPn; apply: contra (extraspecial_nonabelian esE) => sEx.\n    by rewrite (abelianS sEx) ?cycle_abelian.\n  have: (y ^+ p)%g \\in <[x ^+ p]> by rewrite (subsetP sZxp) ?sEpZ.\n  case/cycleP=> i def_yp; set xi := (x ^- i)%g.\n  have Exi: xi \\in E by rewrite groupV groupX.\n  exists (y * xi)%g; split; first by rewrite groupM.\n    have sxpx: <[x ^+ p]> \\subset <[x]> by rewrite cycle_subG mem_cycle.\n    apply: contra notxy; move/(subsetP (subset_trans sZxp sxpx)).\n    by rewrite groupMr // groupV mem_cycle.\n  pose z := [~ xi, y]; have Zz: z \\in 'Z(E) by rewrite -defE' mem_commg.\n  case: (setIP Zz) => _; move/centP=> cEz.\n  rewrite order_dvdn expMg_Rmul; try by apply: commute_sym; apply: cEz.\n  rewrite def_yp expgVn -!expgM mulnC mulgV mul1g -order_dvdn.\n  by rewrite (dvdn_trans (order_dvdG Zz)) //= oZE bin2odd // dvdn_mulr.\nhave{oxp} ox: #[x] = p.\n  apply/eqP; case/primeP: p_pr => _ dvd_p; case/orP: (dvd_p _ oxp) => //.\n  by rewrite order_eq1; case: eqP notZx => // ->; rewrite group1.\nhave [y Ey not_cxy]: exists2 y, y \\in E & y \\notin 'C[x].\n  by apply/subsetPn; rewrite sub_cent1; rewrite inE Ex in notZx.\nhave notZy: y \\notin 'Z(E).\n  apply: contra not_cxy; rewrite inE Ey; apply: subsetP.\n  by rewrite -cent_set1 centS ?sub1set.\npose K := 'C_E[y]; have maxK: maximal K E by apply: cent1_extraspecial_maximal.\nhave nsKE: K <| E := p_maximal_normal pE maxK; have [sKE nKE] := andP nsKE.\nhave oK: #|K| = (p ^ 2)%N.\n  by rewrite -(divg_indexS sKE) oE (p_maximal_index pE) ?mulKn.\nhave cKK: abelian K := card_p2group_abelian p_pr oK.\nhave sZK: 'Z(E) \\subset K by rewrite setIS // -cent_set1 centS ?sub1set.\nhave defE: K ><| <[x]> = E.\n  have notKx: x \\notin K by rewrite inE Ex cent1C.\n  rewrite sdprodE ?(mulg_normal_maximal nsKE) ?cycle_subG ?(subsetP nKE) //.\n  by rewrite setIC prime_TIg -?orderE ?ox ?cycle_subG.\nhave /cyclicP[z defZ]: cyclic 'Z(E) by rewrite prime_cyclic ?oZE.\napply/(Aut_sub_fullP (center_sub E)); rewrite /= defZ => g injg gZ.\npose k := invm (injm_Zp_unitm z) (aut injg gZ).\nhave fM: {in K &, {morph expgn^~ (val k): u v / u * v}}.\n  by move=> u v Ku Kv; rewrite /= expgMn // /commute (centsP cKK).\npose f := Morphism fM; have fK: f @* K = K.\n  apply/setP=> u; rewrite morphimEdom.\n  apply/imsetP/idP=> [[v Kv ->] | Ku]; first exact: groupX.\n  exists (u ^+ expg_invn K (val k)); first exact: groupX.\n  rewrite /f /= expgAC expgK // oK coprimeXl // -unitZpE //.\n  by case: (k) => /=; rewrite orderE -defZ oZE => j; rewrite natr_Zp.\nhave fMact: {in K & <[x]>, morph_act 'J 'J f (idm <[x]>)}.\n  by move=> u v _ _; rewrite /= conjXg.\nexists (sdprodm_morphism defE fMact).\nrewrite im_sdprodm injm_sdprodm injm_idm -card_im_injm im_idm fK.\nhave [_ -> _ ->] := sdprodP defE; rewrite !eqxx; split=> //= u Zu.\nrewrite sdprodmEl ?(subsetP sZK) ?defZ // -(autE injg gZ Zu).\nrewrite -[aut _ _](invmK (injm_Zp_unitm z)); first by rewrite permE Zu.\nby rewrite im_Zp_unitm Aut_aut.\nQed.",
    "Lemma center_aut_extraspecial k : coprime k p ->\n  exists2 f, f \\in Aut S & forall z, z \\in 'Z(S) -> f z = (z ^+ k)%g.\nProof.\nhave /cyclicP[z defZ]: cyclic 'Z(S) by rewrite prime_cyclic ?oZ.\nhave oz: #[z] = p by rewrite orderE -defZ.\nrewrite coprime_sym -unitZpE ?prime_gt1 // -oz => u_k.\npose g := Zp_unitm (FinRing.unit 'Z_#[z] u_k).\nhave AutZg: g \\in Aut 'Z(S) by rewrite defZ -im_Zp_unitm mem_morphim ?inE.\nhave ZSfull := Aut_sub_fullP (center_sub S) Aut_extraspecial_full.\nhave [f [injf fS fZ]] := ZSfull _ (injm_autm AutZg) (im_autm AutZg).\nexists (aut injf fS) => [|u Zu]; first exact: Aut_aut.\nhave [Su _] := setIP Zu; have z_u: u \\in <[z]> by rewrite -defZ.\nby rewrite autE // fZ //= autmE permE /= z_u /cyclem expg_znat.\nQed.",
    "Lemma SCN_P A : reflect (A <| G /\\ 'C_G(A) = A) (A \\in 'SCN(G)).\nProof. by apply: (iffP setIdP) => [] [->]; move/eqP. Qed.",
    "Lemma SCN_abelian A : A \\in 'SCN(G) -> abelian A.\nProof. by case/SCN_P=> _ defA; rewrite /abelian -{1}defA subsetIr. Qed.",
    "Lemma exponent_Ohm1_class2 H :\n  odd p -> p.-group H -> nil_class H <= 2 -> exponent 'Ohm_1(H) %| p.\nProof.\nmove=> odd_p pH; rewrite nil_class2 => sH'Z; apply/exponentP=> x /=.\nrewrite (OhmE 1 pH) expn1 gen_set_id => {x} [/LdivP[] //|].\napply/group_setP; split=> [|x y]; first by rewrite !inE group1 expg1n //=.\ncase/LdivP=> Hx xp1 /LdivP[Hy yp1]; rewrite !inE groupM //=.\nhave [_ czH]: [~ y, x] \\in H /\\ centralises [~ y, x] H.\n  by apply/centerP; rewrite (subsetP sH'Z) ?mem_commg.\nrewrite expMg_Rmul ?xp1 ?yp1 /commute ?czH //= !mul1g.\nby rewrite bin2odd // -commXXg ?yp1 /commute ?czH // comm1g.\nQed.",
    "Lemma SCN_max A : A \\in 'SCN(G) -> [max A | A <| G & abelian A].\nProof.\ncase/SCN_P => nAG scA; apply/maxgroupP; split=> [|H].\n  by rewrite nAG /abelian -{1}scA subsetIr.\ndo 2![case/andP]=> sHG _ abelH sAH; apply/eqP.\nby rewrite eqEsubset sAH -scA subsetI sHG centsC (subset_trans sAH).\nQed.",
    "Lemma max_SCN A :\n  p.-group G -> [max A | A <| G & abelian A] -> A \\in 'SCN(G).\nProof.\nmove/pgroup_nil=> nilG; rewrite /abelian.\ncase/maxgroupP=> /andP[nsAG abelA] maxA; have [sAG nAG] := andP nsAG.\nrewrite inE nsAG eqEsubset /= andbC subsetI abelA normal_sub //=.\nrewrite -quotient_sub1; last by rewrite subIset 1?normal_norm.\napply/trivgP; apply: (TI_center_nil (quotient_nil A nilG)).\n  by rewrite quotient_normal // /normal subsetIl normsI ?normG ?norms_cent.\napply/trivgP/subsetP=> _ /setIP[/morphimP[x Nx /setIP[_ Cx]] ->].\nrewrite -cycle_subG in Cx => /setIP[GAx CAx].\nhave{CAx GAx}: <[coset A x]> <| G / A.\n  by rewrite /normal cycle_subG GAx cents_norm // centsC cycle_subG.\ncase/(inv_quotientN nsAG)=> B /= defB sAB nBG.\nrewrite -cycle_subG defB (maxA B) ?trivg_quotient // nBG.\nhave{} defB : B :=: A * <[x]>.\n  rewrite -quotientK ?cycle_subG ?quotient_cycle // defB quotientGK //.\n  exact: normalS (normal_sub nBG) nsAG.\napply/setIidPl; rewrite ?defB -[_ :&: _]center_prod //=.\nrewrite /center !(setIidPl _) //; apply: cycle_abelian.\nQed.",
    "Lemma der1_stab_Ohm1_SCN_series : ('C(Z) :&: 'C_G(A / Z | 'Q))^`(1) \\subset A.\nProof.\ncase/SCN_P: SCN_A => /andP[sAG nAG] {4} <-.\nrewrite subsetI {1}setICA comm_subG ?subsetIl //= gen_subG.\napply/subsetP=> w /imset2P[u v].\nrewrite -groupV -(groupV _ v) /= astabQR //= -/Z !inE groupV.\ncase/and4P=> cZu _ _ sRuZ /and4P[cZv' _ _ sRvZ] ->{w}.\napply/centP=> a Aa; rewrite /commute -!mulgA (commgCV v) (mulgA u).\nrewrite (centP cZu); last by rewrite (subsetP sRvZ) ?mem_commg ?set11 ?groupV.\nrewrite 2!(mulgA v^-1) mulKVg 4!mulgA invgK (commgC u^-1) mulgA.\nrewrite -(mulgA _ _ v^-1) -(centP cZv') ?(subsetP sRuZ) ?mem_commg ?set11//.\nby rewrite -!mulgA invgK mulKVg !mulKg.\nQed.",
    "Lemma Ohm1_stab_Ohm1_SCN_series :\n  odd p -> p.-group G -> 'Ohm_1('C_G(Z)) \\subset 'C_G(A / Z | 'Q).\nProof.\nhave [-> | ntG] := eqsVneq G 1; first by rewrite !(setIidPl (sub1G _)) Ohm1.\nmove=> p_odd pG; have{ntG} [p_pr _ _] := pgroup_pdiv pG ntG.\ncase/SCN_P: SCN_A => /andP[sAG nAG] _; have pA := pgroupS sAG pG.\nhave pCGZ : p.-group 'C_G(Z) by rewrite (pgroupS _ pG) // subsetIl.\nrewrite {pCGZ}(OhmE 1 pCGZ) gen_subG; apply/subsetP=> x; rewrite 3!inE -andbA.\nrewrite -!cycle_subG => /and3P[sXG cZX xp1] /=; have cXX := cycle_abelian x.\nhave nZX := cents_norm cZX; have{nAG} nAX := subset_trans sXG nAG.\npose XA := <[x]> <*> A; pose C := 'C(<[x]> / Z | 'Q); pose CA := A :&: C.\npose Y := <[x]> <*> CA; pose W := 'Ohm_1(Y).\nhave sXC: <[x]> \\subset C by rewrite sub_astabQ nZX (quotient_cents _ cXX).\nhave defY : Y = <[x]> * CA by rewrite -norm_joinEl // normsI ?nAX ?normsG.\nhave{nAX} defXA: XA = <[x]> * A := norm_joinEl nAX.\nsuffices{sXC}: XA \\subset Y.\n  rewrite subsetI sXG /= sub_astabQ nZX centsC defY group_modl //= -/Z -/C.\n  by rewrite subsetI sub_astabQ defXA quotientMl //= !mulG_subG; case/and4P.\nhave sZCA: Z \\subset CA by rewrite subsetI sZA [C]astabQ sub_cosetpre.\nhave cZCA: CA \\subset 'C(Z) by rewrite subIset 1?(sub_abelian_cent2 cAA).\nhave sZY: Z \\subset Y by rewrite (subset_trans sZCA) ?joing_subr.\nhave{cZCA cZX} cZY: Y \\subset 'C(Z) by rewrite join_subG cZX.\nhave{cXX nZX} sY'Z : Y^`(1) \\subset Z.\n  rewrite der1_min ?cents_norm //= -/Y defY quotientMl // abelianM /= -/Z -/CA.\n  rewrite !quotient_abelian // ?(abelianS _ cAA) ?subsetIl //=.\n  by rewrite /= quotientGI ?Ohm_sub // quotient_astabQ subsetIr.\nhave{sY'Z cZY} nil_classY: nil_class Y <= 2.\n  by rewrite nil_class2 (subset_trans sY'Z ) // subsetI sZY centsC.\nhave pY: p.-group Y by rewrite (pgroupS _ pG) // join_subG sXG subIset ?sAG.\nhave sXW: <[x]> \\subset W.\n  by rewrite [W](OhmE 1 pY) ?genS // sub1set !inE -cycle_subG joing_subl.\nhave{nil_classY pY sXW sZY sZCA} defW: W = <[x]> * Z.\n  rewrite -[W](setIidPr (Ohm_sub _ _)) /= -/Y {1}defY -group_modl //= -/Y -/W.\n  congr (_ * _); apply/eqP; rewrite eqEsubset {1}[Z](OhmE 1 pA).\n  rewrite subsetI setIAC subIset //; first by rewrite sZCA -[Z]Ohm_id OhmS.\n  rewrite sub_gen ?setIS //; apply/subsetP=> w Ww; rewrite inE.\n  by apply/eqP; apply: exponentP w Ww; apply: exponent_Ohm1_class2.\nhave{sXG sAG} sXAG: XA \\subset G by rewrite join_subG sXG.\nhave{sXAG} nilXA: nilpotent XA := nilpotentS sXAG (pgroup_nil pG).\nhave sYXA: Y \\subset XA by rewrite defY defXA mulgS ?subsetIl.\nrewrite -[Y](nilpotent_sub_norm nilXA) {nilXA sYXA}//= -/Y -/XA.\nsuffices: 'N_XA('Ohm_1(Y)) \\subset Y by apply/subset_trans/setIS/gFnorms.\nrewrite {XA}defXA -group_modl ?normsG /= -/W ?{W}defW ?mulG_subl //.\nrewrite {Y}defY mulgS // subsetI subsetIl {CA C}sub_astabQ subIset ?nZA //= -/Z.\nrewrite (subset_trans (quotient_subnorm _ _ _)) //= quotientMidr /= -/Z.\nrewrite -quotient_sub1 ?subIset ?cent_norm ?orbT //.\nrewrite (subset_trans (quotientI _ _ _)) ?coprime_TIg //.\nrewrite (@pnat_coprime p) // -/(p.-group _) ?quotient_pgroup {pA}//= -pgroupE.\nrewrite -(setIidPr (cent_sub _)) p'group_quotient_cent_prime //.\nby rewrite (dvdn_trans (dvdn_quotient _ _)) ?order_dvdn.\nQed.",
    "Lemma Ohm1_cent_max_normal_abelem Z :\n  odd p -> p.-group G -> [max Z | Z <| G & p.-abelem Z] -> 'Ohm_1('C_G(Z)) = Z.\nProof.\nmove=> p_odd pG; set X := 'Ohm_1('C_G(Z)).\ncase/maxgroupP=> /andP[nsZG abelZ] maxZ.\nhave [sZG nZG] := andP nsZG; have [_ cZZ expZp] := and3P abelZ.\nhave{nZG} nsXG: X <| G by rewrite gFnormal_trans ?norm_normalI ?norms_cent.\nhave cZX : X \\subset 'C(Z) by apply/gFsub_trans/subsetIr.\nhave{sZG expZp} sZX: Z \\subset X.\n  rewrite [X](OhmE 1 (pgroupS _ pG)) ?subsetIl ?sub_gen //.\n  apply/subsetP=> x Zx; rewrite !inE  ?(subsetP sZG) ?(subsetP cZZ) //=.\n  by rewrite (exponentP expZp).\nsuffices{sZX} expXp: (exponent X %| p).\n  apply/eqP; rewrite eqEsubset sZX andbT -quotient_sub1 ?cents_norm //= -/X.\n  have pGq: p.-group (G / Z) by rewrite quotient_pgroup.\n  rewrite (TI_center_nil (pgroup_nil pGq)) ?quotient_normal //= -/X setIC.\n  apply/eqP/trivgPn=> [[Zd]]; rewrite inE -!cycle_subG -cycle_eq1 -subG1 /= -/X.\n  case/andP=> /sub_center_normal nsZdG.\n  have{nsZdG} [D defD sZD nsDG] := inv_quotientN nsZG nsZdG; rewrite defD.\n  have sDG := normal_sub nsDG; have nsZD := normalS sZD sDG nsZG.\n  rewrite quotientSGK ?quotient_sub1 ?normal_norm //= -/X => sDX /negP[].\n  rewrite (maxZ D) // nsDG andbA (pgroupS sDG) ?(dvdn_trans (exponentS sDX)) //.\n  have sZZD: Z \\subset 'Z(D) by rewrite subsetI sZD centsC (subset_trans sDX).\n  by rewrite (cyclic_factor_abelian sZZD) //= -defD cycle_cyclic.\npose normal_abelian := [pred A : {group gT} | A <| G & abelian A].\nhave{nsZG cZZ} normal_abelian_Z : normal_abelian Z by apply/andP.\nhave{normal_abelian_Z} [A maxA sZA] := maxgroup_exists normal_abelian_Z.\nhave SCN_A : A \\in 'SCN(G) by apply: max_SCN pG maxA.\nmove/maxgroupp: maxA => /andP[nsAG cAA] {normal_abelian}.\nhave pA := pgroupS (normal_sub nsAG) pG.\nhave{abelZ maxZ nsAG cAA sZA} defA1: 'Ohm_1(A) = Z.\n  have: Z \\subset 'Ohm_1(A) by rewrite -(Ohm1_id abelZ) OhmS.\n  by apply: maxZ; rewrite Ohm1_abelem ?gFnormal_trans.\nhave{SCN_A} sX'A: X^`(1) \\subset A.\n  have sX_CWA1 : X \\subset 'C('Ohm_1(A)) :&: 'C_G(A / 'Ohm_1(A) | 'Q).\n    rewrite subsetI /X -defA1 (Ohm1_stab_Ohm1_SCN_series _ p_odd) //=.\n    by rewrite gFsub_trans ?subsetIr.\n  by apply: subset_trans (der1_stab_Ohm1_SCN_series SCN_A); rewrite commgSS.\npose genXp := [pred U : {group gT} | 'Ohm_1(U) == U & ~~ (exponent U %| p)].\napply/idPn=> expXp'; have genXp_X: genXp [group of X] by rewrite /= Ohm_id eqxx.\nhave{genXp_X expXp'} [U] := mingroup_exists genXp_X; case/mingroupP; case/andP.\nmove/eqP=> defU1 expUp' minU sUX; case/negP: expUp'.\nhave{nsXG} pU := pgroupS (subset_trans sUX (normal_sub nsXG)) pG.\ncase gsetU1: (group_set 'Ldiv_p(U)).\n  by rewrite -defU1 (OhmE 1 pU) gen_set_id // -sub_LdivT subsetIr.\nmove: gsetU1; rewrite /group_set 2!inE group1 expg1n eqxx; case/subsetPn=> xy.\ncase/imset2P=> x y /[!inE] /andP[Ux xp1] /andP[Uy yp1] ->{xy}.\nrewrite groupM //= => nt_xyp; pose XY := <[x]> <*> <[y]>.\nhave{yp1 nt_xyp} defXY: XY = U.\n  have sXY_U: XY \\subset U by rewrite join_subG !cycle_subG Ux Uy.\n  rewrite [XY]minU //= eqEsubset Ohm_sub (OhmE 1 (pgroupS _ pU)) //.\n  rewrite /= joing_idl joing_idr genS; last first.\n    by rewrite subsetI subset_gen subUset !sub1set !inE xp1 yp1.\n  apply: contra nt_xyp => /exponentP-> //.\n  by rewrite groupMl mem_gen // (set21, set22).\nhave: <[x]> <|<| U by rewrite nilpotent_subnormal ?(pgroup_nil pU) ?cycle_subG.\ncase/subnormalEsupport=> [defU | /=].\n  by apply: dvdn_trans (exponent_dvdn U) _; rewrite -defU order_dvdn.\nset V := <<class_support <[x]> U>>; case/andP=> sVU ltVU.\nhave{genXp minU xp1 sVU ltVU} expVp: exponent V %| p.\n  apply: contraR ltVU => expVp'; rewrite [V]minU //= expVp' eqEsubset Ohm_sub.\n  rewrite (OhmE 1 (pgroupS sVU pU)) genS //= subsetI subset_gen class_supportEr.\n  apply/bigcupsP=> z _; apply/subsetP=> v Vv.\n  by rewrite inE -order_dvdn (dvdn_trans (order_dvdG Vv)) // cardJg order_dvdn.\nhave{A pA defA1 sX'A V expVp} Zxy: [~ x, y] \\in Z.\n  rewrite -defA1 (OhmE 1 pA) mem_gen // !inE (exponentP expVp).\n    by rewrite (subsetP sX'A) //= mem_commg ?(subsetP sUX).\n  by rewrite groupMl -1?[x^-1]conjg1 mem_gen // imset2_f // ?groupV cycle_id.\nhave{Zxy sUX cZX} cXYxy: [~ x, y] \\in 'C(XY).\n  by rewrite centsC in cZX; rewrite defXY (subsetP (centS sUX)) ?(subsetP cZX).\nrewrite -defU1 exponent_Ohm1_class2 // nil_class2 -defXY der1_joing_cycles //.\nby rewrite subsetI {1}defXY !cycle_subG groupR.\nQed.",
    "Lemma critical_class2 H : critical H G -> nil_class H <= 2.\nProof.\ncase=> [chH _ sRZ _].\nby rewrite nil_class2 (subset_trans _ sRZ) ?commSg // char_sub.\nQed.",
    "Lemma Thompson_critical : p.-group G -> {K : {group gT} | critical K G}.\nProof.\nmove=> pG; pose qcr A := (A \\char G) && ('Phi(A) :|: [~: G, A] \\subset 'Z(A)).\nhave [|K]:= @maxgroup_exists _ qcr 1 _.\n  by rewrite /qcr char1 center1 commG1 subUset Phi_sub subxx.\ncase/maxgroupP; rewrite {}/qcr subUset => /and3P[chK sPhiZ sRZ] maxK _.\nhave sKG := char_sub chK; have nKG := char_normal chK.\nexists K; split=> //; apply/eqP; rewrite eqEsubset andbC setSI //=.\nhave chZ: 'Z(K) \\char G by [apply: subcent_char]; have nZG := char_norm chZ.\nhave chC: 'C_G(K) \\char G by apply: subcent_char chK.\nrewrite -quotient_sub1; last by rewrite subIset // char_norm.\napply/trivgP; apply: (TI_center_nil (quotient_nil _ (pgroup_nil pG))).\n  by rewrite quotient_normal ?norm_normalI ?norms_cent ?normal_norm.\napply: TI_Ohm1; apply/trivgP; rewrite -trivg_quotient -sub_cosetpre_quo //.\nrewrite morphpreI quotientGK /=; last first.\n  by apply: normalS (char_normal chZ); rewrite ?subsetIl ?setSI.\nset X := _ :&: _; pose gX := [group of X].\nhave sXG: X \\subset G by rewrite subIset ?subsetIl.\nhave cXK: K \\subset 'C(gX) by rewrite centsC 2?subIset // subxx orbT.\nrewrite subsetI centsC cXK andbT -(mul1g K) -mulSG mul1g -(cent_joinEr cXK).\nrewrite [_ <*> K]maxK ?joing_subr //= andbC (cent_joinEr cXK).\nrewrite -center_prod // (subset_trans _ (mulG_subr _ _)).\n  rewrite charM 1?charI ?(char_from_quotient (normal_cosetpre _)) //.\n  by rewrite cosetpreK !gFchar_trans.\nrewrite (@Phi_mulg p) ?(pgroupS _ pG) // subUset commGC commMG; last first.\n  by rewrite normsR ?(normsG sKG) // cents_norm // centsC.\nrewrite !mul_subG 1?commGC //.\n  apply: subset_trans (commgS _ (subsetIr _ _)) _.\n  rewrite -quotient_cents2 ?subsetIl // centsC // cosetpreK //.\n  exact/gFsub_trans/subsetIr.\nhave nZX := subset_trans sXG nZG; have pX : p.-group gX by apply: pgroupS pG.\nrewrite -quotient_sub1 ?gFsub_trans //=.\nhave pXZ: p.-group (gX / 'Z(K)) by apply: morphim_pgroup.\nrewrite (quotient_Phi pX nZX) subG1 (trivg_Phi pXZ).\napply: (abelemS (quotientS _ (subsetIr _ _))); rewrite /= cosetpreK /=.\nhave pZ: p.-group 'Z(G / 'Z(K)).\n  by rewrite (pgroupS (center_sub _)) ?morphim_pgroup.\nby rewrite Ohm1_abelem ?center_abelian.\nQed.",
    "Lemma critical_p_stab_Aut H :\n  critical H G -> p.-group G -> p.-group 'C(H | [Aut G]).\nProof.\nmove=> [chH sPhiZ sRZ eqCZ] pG; have sHG := char_sub chH.\npose G' := (sdpair1 [Aut G] @* G)%G; pose H' := (sdpair1 [Aut G] @* H)%G.\napply/pgroupP=> q pr_q; case/Cauchy=> //= f cHF; move: (cHF); rewrite astab_ract.\ncase/setIP=> Af cHFP ofq; rewrite -cycle_subG in cHF; apply: (pgroupP pG) => //.\npose F' := (sdpair2 [Aut G] @* <[f]>)%G.\nhave trHF: [~: H', F'] = 1.\n  apply/trivgP; rewrite gen_subG; apply/subsetP=> u; case/imset2P=> x' a'.\n  case/morphimP=> x Gx Hx ->; case/morphimP=> a Aa Fa -> -> {u x' a'}.\n  by rewrite inE commgEl -sdpair_act ?(astab_act (subsetP cHF _ Fa) Hx) ?mulVg.\nhave sGH_H: [~: G', H'] \\subset H'.\n  by rewrite -morphimR ?(char_sub chH) // morphimS // commg_subr char_norm.\nhave{trHF sGH_H} trFGH: [~: F', G', H'] = 1.\n  apply: three_subgroup; last by rewrite trHF comm1G.\n  by apply/trivgP; rewrite -trHF commSg.\napply/negP=> qG; case: (qG); rewrite -ofq.\nsuffices ->: f = 1 by rewrite order1 dvd1n.\napply/permP=> x; rewrite perm1; case Gx: (x \\in G); last first.\n  by apply: out_perm (negbT Gx); case/setIdP: Af.\nhave Gfx: f x \\in G by rewrite -(im_autm Af) -{1}(autmE Af) mem_morphim.\npose y := x^-1 * f x; have Gy: y \\in G by rewrite groupMl ?groupV.\nhave [inj1 inj2] := (injm_sdpair1 [Aut G], injm_sdpair2 [Aut G]).\nhave Hy: y \\in H.\n  rewrite (subsetP (center_sub H)) // -eqCZ -cycle_subG.\n  rewrite -(injmSK inj1) ?cycle_subG // injm_subcent // subsetI.\n  rewrite morphimS ?morphim_cycle ?cycle_subG //=.\n  suffices: sdpair1 [Aut G] y \\in [~: G', F'].\n    by rewrite commGC; apply: subsetP; apply/commG1P.\n  rewrite morphM ?groupV ?morphV //= sdpair_act // -commgEl.\n  by rewrite mem_commg ?mem_morphim ?cycle_id.\nhave fy: f y = y := astabP cHFP _ Hy.\nhave: (f ^+ q) x = x * y ^+ q.\n  elim: (q) => [|i IHi]; first by rewrite perm1 mulg1.\n  rewrite expgSr permM {}IHi -(autmE Af) morphM ?morphX ?groupX //= autmE.\n  by rewrite fy expgS mulgA mulKVg.\nmove/eqP; rewrite -{1}ofq expg_order perm1 eq_mulVg1 mulKg -order_dvdn.\ncase/primeP: pr_q => _ pr_q /pr_q; rewrite order_eq1 -eq_mulVg1.\nby case: eqP => //= _ /eqP oyq; case: qG; rewrite -oyq order_dvdG.\nQed.",
    "Lemma trans_prim_astab x :\n    x \\in S -> [transitive G, on S | to] ->\n  [primitive G, on S | to] = maximal_eq 'C_G[x | to] G.\nProof.\nmove=> Sx trG; rewrite /primitive trG negb_exists.\napply/forallP/maximal_eqP=> /= [primG | [_ maxCx] Q].\n  split=> [|H sCH sHG]; first exact: subsetIl.\n  pose X := orbit to H x; pose Q := orbit (to^*)%act G X.\n  have Xx: x \\in X by apply: orbit_refl.\n  have defH: 'N_(G)(X | to) = H.\n    have trH: [transitive H, on X | to] by apply/imsetP; exists x.\n    have sHN: H \\subset 'N_G(X | to) by rewrite subsetI sHG atrans_acts.\n    move/(subgroup_transitiveP Xx sHN): (trH) => /= <-.\n      by rewrite mulSGid //= setIAC subIset ?sCH.\n    apply/imsetP; exists x => //; apply/eqP.\n    by rewrite eqEsubset imsetS // acts_sub_orbit ?subsetIr.\n  have [|/proper_card oCH] := eqVproper sCH; [by left | right].\n  apply/eqP; rewrite eqEcard sHG leqNgt.\n  apply: contra {primG}(primG Q) => oHG; apply/and3P; split; last first.\n  - rewrite card_orbit astab1_set defH -(@ltn_pmul2l #|H|) ?Lagrange // muln1.\n    rewrite oHG -(@ltn_pmul2l #|H|) ?Lagrange // -(card_orbit_stab to G x).\n    by rewrite -(atransP trG x Sx) mulnC card_orbit ltn_pmul2r.\n  - by apply/actsP=> a Ga Y; apply/orbit_transl/mem_orbit.\n  apply/and3P; split; last 1 first.\n  - rewrite orbit_sym; apply/imsetP=> [[a _]] /= defX.\n    by rewrite defX /setact imset0 inE in Xx.\n  - apply/eqP/setP=> y; apply/bigcupP/idP=> [[_ /imsetP[a Ga ->]] | Sy].\n      case/imsetP=> _ /imsetP[b Hb ->] ->.\n      by rewrite !(actsP (atrans_acts trG)) //; apply: subsetP Hb.\n    case: (atransP2 trG Sx Sy) => a Ga ->.\n    by exists ((to^*)%act X a); apply: imset_f; rewrite // orbit_refl.\n  apply/trivIsetP=> _ _ /imsetP[a Ga ->] /imsetP[b Gb ->].\n  apply: contraR => /exists_inP[_ /imsetP[_ /imsetP[a1 Ha1 ->] ->]].\n  case/imsetP=> _ /imsetP[b1 Hb1 ->] /(canLR (actK _ _)) /(canLR (actK _ _)).\n  rewrite -(canF_eq (actKV _ _)) -!actM (sameP eqP astab1P) => /astab1P Cab.\n  rewrite astab1_set (subsetP (subsetIr G _)) //= defH.\n  rewrite -(groupMr _ (groupVr Hb1)) -mulgA -(groupMl _ Ha1).\n  by rewrite (subsetP sCH) // inE Cab !groupM ?groupV // (subsetP sHG).\napply/and3P=> [[/and3P[/eqP defS tIQ ntQ]]]; set sto := (to^*)%act => actQ.\nrewrite !ltnNge -negb_or => /orP[].\npose X := pblock Q x; have Xx: x \\in X by rewrite mem_pblock defS.\nhave QX: X \\in Q by rewrite pblock_mem ?defS.\nhave toX Y a: Y \\in Q -> a \\in G -> to x a \\in Y -> sto X a = Y.\n  move=> QY Ga Yxa; rewrite -(contraNeq (trivIsetP tIQ Y (sto X a) _ _)) //.\n    by rewrite (actsP actQ).\n  by apply/existsP; exists (to x a); rewrite /= Yxa; apply: imset_f.\nhave defQ: Q = orbit (to^*)%act G X.\n  apply/eqP; rewrite eqEsubset andbC acts_sub_orbit // QX.\n  apply/subsetP=> Y QY.\n  have /set0Pn[y Yy]: Y != set0 by apply: contraNneq ntQ => <-.\n  have Sy: y \\in S by rewrite -defS; apply/bigcupP; exists Y.\n  have [a Ga def_y] := atransP2 trG Sx Sy.\n  by apply/imsetP; exists a; rewrite // (toX Y) // -def_y.\nrewrite defQ card_orbit; case: (maxCx 'C_G[X | sto]%G) => /= [||->|->].\n- apply/subsetP=> a /setIP[Ga cxa]; rewrite inE Ga /=.\n  by apply/astab1P; rewrite (toX X) // (astab1P cxa).\n- exact: subsetIl.\n- by right; rewrite -card_orbit (atransP trG).\nby left; rewrite indexgg.\nQed.",
    "Lemma prim_trans_norm (H : {group aT}) :\n    [primitive G, on S | to] -> H <| G ->\n  H \\subset 'C_G(S | to) \\/ [transitive H, on S | to].\nProof.\nmove=> primG /andP[sHG nHG]; rewrite subsetI sHG.\nhave [trG _] := andP primG; have [x Sx defS] := imsetP trG.\nmove: primG; rewrite (trans_prim_astab Sx) // => /maximal_eqP[_].\ncase/(_ ('C_G[x | to] <*> H)%G) => /= [||cxH|]; first exact: joing_subl.\n- by rewrite join_subG subsetIl.\n- have{} cxH: H \\subset 'C_G[x | to] by rewrite -cxH joing_subr.\n  rewrite subsetI sHG /= in cxH; left; apply/subsetP=> a Ha.\n  apply/astabP=> y Sy; have [b Gb ->] := atransP2 trG Sx Sy.\n  rewrite actCJV [to x (a ^ _)](astab1P _) ?(subsetP cxH) //.\n  by rewrite -mem_conjg (normsP nHG).\nrewrite norm_joinEl 1?subIset ?nHG //.\nby move/(subgroup_transitiveP Sx sHG trG); right.\nQed.",
    "Lemma dtuple_onP t :\n  reflect (injective (tnth t) /\\ forall i, tnth t i \\in S) (t \\in dtuple_on).\nProof.\nrewrite inE subset_all -forallb_tnth -[in uniq t]map_tnth_enum /=.\nby apply: (iffP andP) => -[/injectiveP-f_inj /forallP].\nQed.",
    "Lemma n_act_dtuple t a :\n  a \\in 'N(S | to) -> t \\in dtuple_on -> n_act to t a \\in dtuple_on.\nProof.\nmove/astabsP=> toSa /dtuple_onP[t_inj St]; apply/dtuple_onP.\nsplit=> [i j | i]; rewrite !tnth_map ?[_ \\in S]toSa //.\nby move/act_inj; apply: t_inj.\nQed.",
    "Lemma card_uniq_tuple n (t : n.-tuple sT) : uniq t -> #|t| = n.\nProof. by move/card_uniqP->; apply: size_tuple. Qed.",
    "Lemma n_act0 (t : 0.-tuple sT) a : n_act to t a = [tuple].\nProof. exact: tuple0. Qed.",
    "Lemma dtuple_on_add n x (t : n.-tuple sT) :\n  ([tuple of x :: t] \\in n.+1.-dtuple(S)) =\n     [&& x \\in S, x \\notin t & t \\in n.-dtuple(S)].\nProof. by rewrite !inE memtE !subset_all -!andbA; do !bool_congr. Qed.",
    "Lemma dtuple_on_add_D1 n x (t : n.-tuple sT) :\n  ([tuple of x :: t] \\in n.+1.-dtuple(S))\n     = (x \\in S) && (t \\in n.-dtuple(S :\\ x)).\nProof.\nrewrite dtuple_on_add !inE (andbCA (~~ _)); do 2!congr (_ && _).\nrewrite -!(eq_subset (in_set [in t])) setDE setIC subsetI; congr (_ && _).\nby rewrite -setCS setCK sub1set !inE.\nQed.",
    "Lemma dtuple_on_subset n (S1 S2 : {set sT}) t :\n  S1 \\subset S2 -> t \\in n.-dtuple(S1) -> t \\in n.-dtuple(S2).\nProof. by move=> sS12 /[!inE] /andP[-> /subset_trans]; apply. Qed.",
    "Lemma n_act_add n x (t : n.-tuple sT) a :\n  n_act to [tuple of x :: t] a = [tuple of to x a :: n_act to t a].\nProof. exact: val_inj. Qed.",
    "Lemma ntransitive0 : [transitive^0 G, on S | to].\nProof.\nhave dt0: [tuple] \\in 0.-dtuple(S) by rewrite inE memtE subset_all.\napply/imsetP; exists [tuple of Nil sT] => //.\nby apply/setP=> x; rewrite [x]tuple0 orbit_refl.\nQed.",
    "Lemma ntransitive_weak k m :\n  k <= m -> [transitive^m G, on S | to] -> [transitive^k G, on S | to].\nProof.\nmove/subnKC <-; rewrite addnC; elim: {m}(m - k) => // m IHm.\nrewrite addSn => tr_m1; apply: IHm; move: {m k}(m + k) tr_m1 => m tr_m1.\nhave ext_t t: t \\in dtuple_on m S ->\n  exists x, [tuple of x :: t] \\in m.+1.-dtuple(S).\n- move=> dt.\n  have [sSt | /subsetPn[x Sx ntx]] := boolP (S \\subset t); last first.\n    by exists x; rewrite dtuple_on_add andbA /= Sx ntx.\n  case/imsetP: tr_m1 dt => t1 /[!inE] /andP[Ut1 St1] _ /andP[Ut _].\n  have /subset_leq_card := subset_trans St1 sSt.\n  by rewrite !card_uniq_tuple // ltnn.\ncase/imsetP: (tr_m1); case/tupleP=> [x t]; rewrite dtuple_on_add.\ncase/and3P=> Sx ntx dt; set xt := [tuple of _] => tr_xt.\napply/imsetP; exists t => //.\napply/setP=> u; apply/idP/imsetP=> [du | [a Ga ->{u}]].\n  case: (ext_t u du) => y; rewrite tr_xt.\n  by case/imsetP=> a Ga [_ def_u]; exists a => //; apply: val_inj.\nhave: n_act to xt a \\in dtuple_on _ S by rewrite tr_xt imset_f.\nby rewrite n_act_add dtuple_on_add; case/and3P.\nQed.",
    "Lemma ntransitive1 m :\n  0 < m -> [transitive^m G, on S | to] -> [transitive G, on S | to].\nProof.\nhave trdom1 x: ([tuple x] \\in 1.-dtuple(S)) = (x \\in S).\n  by rewrite dtuple_on_add !inE memtE subset_all andbT.\nmove=> m_gt0 /(ntransitive_weak m_gt0) {m m_gt0}.\ncase/imsetP; case/tupleP=> x t0; rewrite {t0}(tuple0 t0) trdom1 => Sx trx.\napply/imsetP; exists x => //; apply/setP=> y; rewrite -trdom1 trx.\nby apply/imsetP/imsetP=> [[a ? [->]]|[a ? ->]]; exists a => //; apply: val_inj.\nQed.",
    "Lemma ntransitive_primitive m :\n  1 < m -> [transitive^m G, on S | to] -> [primitive G, on S | to].\nProof.\nmove=> lt1m /(ntransitive_weak lt1m) {m lt1m}tr2G.\nhave trG: [transitive G, on S | to] by apply: ntransitive1 tr2G.\nhave [x Sx _]:= imsetP trG; rewrite (trans_prim_astab Sx trG).\napply/maximal_eqP; split=> [|H]; first exact: subsetIl; rewrite subEproper.\ncase/predU1P; first by [left]; case/andP=> sCH /subsetPn[a Ha nCa] sHG.\nright; rewrite -(subgroup_transitiveP Sx sHG trG _) ?mulSGid //.\nhave actH := subset_trans sHG (atrans_acts trG).\npose y := to x a; have Sy: y \\in S by rewrite (actsP actH).\nhave{nCa} yx: y != x by rewrite inE (sameP astab1P eqP) (subsetP sHG) in nCa.\napply/imsetP; exists y => //; apply/eqP.\nrewrite eqEsubset acts_sub_orbit // Sy andbT; apply/subsetP=> z Sz.\nhave [-> | zx] := eqVneq z x; first by rewrite orbit_sym mem_orbit.\npose ty := [tuple y; x]; pose tz := [tuple z; x].\nhave [Sty Stz]: ty \\in 2.-dtuple(S) /\\ tz \\in 2.-dtuple(S).\n  by rewrite !inE !memtE !subset_all /= !mem_seq1 !andbT; split; apply/and3P.\ncase: (atransP2 tr2G Sty Stz) => b Gb [->] /esym/astab1P cxb.\nby rewrite mem_orbit // (subsetP sCH) // inE Gb.\nQed.",
    "Lemma SchurZassenhaus_trans_actsol gT (G A B : {group gT}) :\n    solvable A -> A \\subset 'N(G) -> B \\subset A <*> G ->\n    coprime #|G| #|A| -> #|A| = #|B| ->\n  exists2 x, x \\in G & B :=: A :^ x.\nProof.\nset AG := A <*> G; have [n] := ubnP #|AG|.\nelim: n => // n IHn in gT A B G AG * => /ltnSE-leAn solA nGA sB_AG coGA oAB.\nhave [A1 | ntA] := eqsVneq A 1.\n  by exists 1; rewrite // conjsg1 A1 (@card1_trivg _ B) // -oAB A1 cards1.\nhave [M [sMA nsMA ntM]] := solvable_norm_abelem solA (normal_refl A) ntA.\ncase/is_abelemP=> q q_pr /abelem_pgroup qM; have nMA := normal_norm nsMA.\nhave defAG: AG = A * G := norm_joinEl nGA.\nhave sA_AG: A \\subset AG := joing_subl _ _.\nhave sG_AG: G \\subset AG := joing_subr _ _.\nhave sM_AG := subset_trans sMA sA_AG.\nhave oAG: #|AG| = (#|A| * #|G|)%N by rewrite defAG coprime_cardMg 1?coprime_sym.\nhave q'G: #|G|`_q = 1%N.\n  rewrite part_p'nat ?p'natE -?prime_coprime // coprime_sym.\n  have [_ _ [k oM]] := pgroup_pdiv qM ntM.\n  by rewrite -(@coprime_pexpr k.+1) // -oM (coprimegS sMA).\nhave coBG: coprime #|B| #|G| by rewrite -oAB coprime_sym.\nhave defBG: B * G = AG.\n  by apply/eqP; rewrite eqEcard mul_subG ?sG_AG //= oAG oAB coprime_cardMg.\ncase nMG: (G \\subset 'N(M)).\n  have nsM_AG: M <| AG by rewrite /normal sM_AG join_subG nMA.\n  have nMB: B \\subset 'N(M) := subset_trans sB_AG (normal_norm nsM_AG).\n  have sMB: M \\subset B.\n    have [Q sylQ]:= Sylow_exists q B; have sQB := pHall_sub sylQ.\n    apply: subset_trans (normal_sub_max_pgroup (Hall_max _) qM nsM_AG) (sQB).\n    rewrite pHallE (subset_trans sQB) //= oAG partnM // q'G muln1 oAB.\n    by rewrite (card_Hall sylQ).\n  have defAGq: AG / M = (A / M) <*> (G / M).\n    by rewrite quotient_gen ?quotientU ?subUset ?nMA.\n  have: B / M \\subset (A / M) <*> (G / M) by rewrite -defAGq quotientS.\n  case/IHn; rewrite ?morphim_sol ?quotient_norms ?coprime_morph //.\n  - by rewrite -defAGq (leq_trans _ leAn) ?ltn_quotient.\n  - by rewrite !card_quotient // -!divgS // oAB.\n  move=> Mx; case/morphimP=> x Nx Gx ->{Mx} //; rewrite -quotientJ //= => defBq.\n  exists x => //; apply: quotient_inj defBq; first by rewrite /normal sMB.\n  by rewrite -(normsP nMG x Gx) /normal normJ !conjSg.\npose K := M <*> G; pose R := K :&: B; pose N := 'N_G(M).\nhave defK: K = M * G by rewrite -norm_joinEl ?(subset_trans sMA).\nhave oK: #|K| = (#|M| * #|G|)%N.\n  by rewrite defK coprime_cardMg // coprime_sym (coprimegS sMA).\nhave sylM: q.-Sylow(K) M.\n  by rewrite pHallE joing_subl /= oK partnM // q'G muln1 part_pnat_id.\nhave sylR: q.-Sylow(K) R.\n  rewrite pHallE subsetIl /= -(card_Hall sylM) -(@eqn_pmul2r #|G|) // -oK.\n  rewrite -coprime_cardMg ?(coprimeSg _ coBG) ?subsetIr //=.\n  by rewrite group_modr ?joing_subr ?(setIidPl _) // defBG join_subG sM_AG.\nhave [mx] := Sylow_trans sylM sylR.\nrewrite /= -/K defK; case/imset2P=> m x Mm Gx ->{mx}.\nrewrite conjsgM conjGid {m Mm}// => defR.\nhave sNG: N \\subset G := subsetIl _ _.\nhave pNG: N \\proper G by rewrite /proper sNG subsetI subxx nMG.\nhave nNA: A \\subset 'N(N) by rewrite normsI ?norms_norm.\nhave: B :^ x^-1 \\subset A <*> N.\n  rewrite norm_joinEl ?group_modl // -defAG subsetI !sub_conjgV -normJ -defR.\n  rewrite conjGid ?(subsetP sG_AG) // normsI ?normsG // (subset_trans sB_AG) //.\n  by rewrite join_subG normsM // -defK normsG ?joing_subr.\ndo [case/IHn; rewrite ?cardJg ?(coprimeSg _ coGA) //= -/N] => [|y Ny defB].\n  rewrite joingC norm_joinEr // coprime_cardMg ?(coprimeSg sNG) //.\n  by rewrite (leq_trans _ leAn) // oAG mulnC ltn_pmul2l // proper_card.\nexists (y * x); first by rewrite groupM // (subsetP sNG).\nby rewrite conjsgM -defB conjsgKV.\nQed.",
    "Lemma Hall_exists_subJ pi gT (G : {group gT}) :\n  solvable G -> exists2 H : {group gT}, pi.-Hall(G) H\n                & forall K : {group gT}, K \\subset G -> pi.-group K ->\n                  exists2 x, x \\in G & K \\subset H :^ x.\nProof.\nhave [n] := ubnP #|G|; elim: n gT G => // n IHn gT G /ltnSE-leGn solG.\nhave [-> | ntG] := eqsVneq G 1.\n  exists 1%G => [|_ /trivGP-> _]; last by exists 1; rewrite ?set11 ?sub1G.\n  by rewrite pHallE sub1G cards1 part_p'nat.\ncase: (solvable_norm_abelem solG (normal_refl _)) => // M [sMG nsMG ntM].\ncase/is_abelemP=> p pr_p /and3P[pM cMM _].\npose Gb := (G / M)%G; case: (IHn _ Gb) => [||Hb]; try exact: quotient_sol.\n  by rewrite (leq_trans (ltn_quotient _ _)).\ncase/and3P=> [sHbGb piHb pi'Hb'] transHb.\ncase: (inv_quotientS nsMG sHbGb) => H def_H sMH sHG.\nhave nMG := normal_norm nsMG; have nMH := subset_trans sHG nMG.\nhave{transHb} transH (K : {group gT}):\n  K \\subset G -> pi.-group K -> exists2 x, x \\in G & K \\subset H :^ x.\n- move=> sKG piK; have nMK := subset_trans sKG nMG.\n  case: (transHb (K / M)%G) => [||xb Gxb sKHxb]; first exact: morphimS.\n    exact: morphim_pgroup.\n  case/morphimP: Gxb => x Nx Gx /= def_x; exists x => //.\n  apply/subsetP=> y Ky.\n  have: y \\in coset M y by rewrite val_coset (subsetP nMK, rcoset_refl).\n  have: coset M y \\in (H :^ x) / M.\n    rewrite /quotient morphimJ //=.\n    by rewrite def_x def_H in sKHxb; apply/(subsetP sKHxb)/mem_quotient.\n  case/morphimP=> z Nz Hxz ->.\n  rewrite val_coset //; case/rcosetP=> t Mt ->; rewrite groupMl //.\n  by rewrite mem_conjg (subsetP sMH) // -mem_conjg (normP Nx).\nhave{pi'Hb'} pi'H': pi^'.-nat #|G : H|.\n  move: pi'Hb'; rewrite -!divgS // def_H !card_quotient //.\n  by rewrite -(divnMl (cardG_gt0 M)) !Lagrange.\nhave [pi_p | pi'p] := boolP (p \\in pi).\n  exists H => //; apply/and3P; split=> //; rewrite /pgroup.\n  by rewrite -(Lagrange sMH) -card_quotient // pnatM -def_H (pi_pnat pM).\nhave [ltHG | leGH {n IHn leGn transH}] := ltnP #|H| #|G|.\n  case: (IHn _ H (leq_trans ltHG leGn)) => [|H1]; first exact: solvableS solG.\n  case/and3P=> sH1H piH1 pi'H1' transH1.\n  have sH1G: H1 \\subset G by apply: subset_trans sHG.\n  exists H1 => [|K sKG piK].\n    apply/and3P; split => //.\n    rewrite -divgS // -(Lagrange sHG) -(Lagrange sH1H) -mulnA.\n    by rewrite mulKn // pnatM pi'H1'.\n  case: (transH K sKG piK) => x Gx def_K.\n  case: (transH1 (K :^ x^-1)%G) => [||y Hy def_K1].\n  - by rewrite sub_conjgV.\n  - by rewrite /pgroup cardJg.\n  exists (y * x); first by rewrite groupMr // (subsetP sHG).\n  by rewrite -(conjsgKV x K) conjsgM conjSg.\nhave{leGH Gb sHbGb sHG sMH pi'H'} eqHG: H = G.\n  by apply/eqP; rewrite -val_eqE eqEcard sHG.\nhave{H Hb def_H eqHG piHb nMH} hallM: pi^'.-Hall(G) M.\n  rewrite /pHall /pgroup sMG pnatNK -card_quotient //=.\n  by rewrite -eqHG -def_H (pi_pnat pM).\ncase/splitsP: (SchurZassenhaus_split (pHall_Hall hallM) nsMG) => H.\ncase/complP=> trMH defG.\nhave sHG: H \\subset G by rewrite -defG mulG_subr.\nexists H => [|K sKG piK].\n  apply: etrans hallM; rewrite /pHall sMG sHG /= -!divgS // -defG andbC.\n  by rewrite (TI_cardMg trMH) mulKn ?mulnK // pnatNK.\npose G1 := (K <*> M)%G; pose K1 := (H :&: G1)%G.\nhave nMK: K \\subset 'N(M) by apply: subset_trans sKG nMG.\nhave defG1: M * K = G1 by rewrite -normC -?norm_joinEl.\nhave sK1G1: K1 \\subset M * K by rewrite defG1 subsetIr.\nhave coMK: coprime #|M| #|K|.\n  by rewrite coprime_sym (pnat_coprime piK) //; apply: (pHall_pgroup hallM).\ncase: (SchurZassenhaus_trans_sol _ nMK sK1G1 coMK) => [||x Mx defK1].\n- exact: solvableS solG.\n- apply/eqP; rewrite -(eqn_pmul2l (cardG_gt0 M)) -TI_cardMg //; last first.\n    by apply/trivgP; rewrite -trMH /= setIA subsetIl.\n  rewrite -coprime_cardMg // defG1; apply/eqP; congr #|(_ : {set _})|.\n  rewrite group_modl; last by rewrite -defG1 mulG_subl.\n  by apply/setIidPr; rewrite defG gen_subG subUset sKG.\nexists x^-1; first by rewrite groupV (subsetP sMG).\nby rewrite -(_ : K1 :^ x^-1 = K) ?(conjSg, subsetIl) // defK1 conjsgK.\nQed.",
    "Lemma Hall_Frattini_arg pi (G K H : {group gT}) :\n  solvable K -> K <| G -> pi.-Hall(K) H -> K * 'N_G(H) = G.\nProof.\nmove=> solK /andP[sKG nKG] hallH.\nhave sHG: H \\subset G by apply: subset_trans sKG; case/andP: hallH.\nrewrite setIC group_modl //; apply/setIidPr/subsetP=> x Gx.\npose H1 := (H :^ x^-1)%G.\nhave hallH1: pi.-Hall(K) H1 by rewrite pHallJnorm // groupV (subsetP nKG).\ncase: (Hall_trans solK hallH hallH1) => y Ky defH.\nrewrite -(mulKVg y x) mem_mulg //; apply/normP.\nby rewrite conjsgM {1}defH conjsgK conjsgKV.\nQed.",
    "Lemma coprime_norm_cent A G :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> 'N_G(A) = 'C_G(A).\nProof.\nmove=> nGA coGA; apply/eqP; rewrite eqEsubset andbC setIS ?cent_sub //=.\nrewrite subsetI subsetIl /= (sameP commG1P trivgP) -(coprime_TIg coGA).\nrewrite subsetI commg_subr subsetIr andbT.\nmove: nGA; rewrite -commg_subl; apply: subset_trans.\nby rewrite commSg ?subsetIl.\nQed.",
    "Lemma norm_conj_cent A G x : x \\in 'C(A) ->\n  (A \\subset 'N(G :^ x)) = (A \\subset 'N(G)).\nProof. by move=> cAx; rewrite norm_conj_norm ?(subsetP (cent_sub A)). Qed.",
    "Lemma strongest_coprime_quotient_cent A G H :\n      let R := H :&: [~: G, A] in\n      A \\subset 'N(H) -> R \\subset G -> coprime #|R| #|A| ->\n      solvable R || solvable A ->\n  'C_G(A) / H = 'C_(G / H)(A / H).\nProof.\nmove=> R nHA sRG coRA solRA.\nhave nRA: A \\subset 'N(R) by rewrite normsI ?commg_normr.\napply/eqP; rewrite eqEsubset subsetI morphimS ?subsetIl //=.\nrewrite (subset_trans _ (morphim_cent _ _)) ?morphimS ?subsetIr //=.\napply/subsetP=> _ /setIP[/morphimP[x Nx Gx ->] cAHx].\nhave{cAHx} cAxR y: y \\in A -> [~ x, y] \\in R.\n  move=> Ay; have Ny: y \\in 'N(H) by apply: subsetP Ay.\n  rewrite inE mem_commg // andbT coset_idr ?groupR // morphR //=.\n  by apply/eqP; apply/commgP; apply: (centP cAHx); rewrite mem_quotient.\nhave AxRA: A :^ x \\subset R * A.\n  apply/subsetP=> _ /imsetP[y Ay ->].\n  rewrite -normC // -(mulKVg y (y ^ x)) -commgEl mem_mulg //.\n  by rewrite -groupV invg_comm cAxR.\nhave [y Ry def_Ax]: exists2 y, y \\in R & A :^ x = A :^ y.\n  have oAx: #|A :^ x| = #|A| by rewrite cardJg.\n  have [solR | solA] := orP solRA; first exact: SchurZassenhaus_trans_sol.\n  by apply: SchurZassenhaus_trans_actsol; rewrite // joingC norm_joinEr.\nrewrite -imset_coset; apply/imsetP; exists (x * y^-1); last first.\n  by rewrite conjgCV mkerl // ker_coset memJ_norm groupV; case/setIP: Ry.\nrewrite /= inE groupMl // ?(groupV, subsetP sRG) //=.\napply/centP=> z Az; apply/commgP/eqP/set1P.\nrewrite -[[set 1]](coprime_TIg coRA) inE {1}commgEl commgEr /= -/R.\nrewrite invMg -mulgA invgK groupMl // conjMg mulgA -commgEl.\nrewrite groupMl ?cAxR // memJ_norm ?(groupV, subsetP nRA) // Ry /=.\nby rewrite groupMr // conjVg groupV conjgM -mem_conjg -def_Ax memJ_conjg.\nQed.",
    "Lemma coprime_norm_quotient_cent A G H :\n    A \\subset 'N(G) -> A \\subset 'N(H) -> coprime #|H| #|A| -> solvable H ->\n  'C_G(A) / H = 'C_(G / H)(A / H).\nProof.\nmove=> nGA nHA coHA solH; have sRH := subsetIl H [~: G, A].\nrewrite strongest_coprime_quotient_cent ?(coprimeSg sRH) 1?(solvableS sRH) //.\nby rewrite subIset // commg_subl nGA orbT.\nQed.",
    "Lemma coprime_cent_mulG A G H :\n     A \\subset 'N(G) -> A \\subset 'N(H) -> G \\subset 'N(H) ->\n     coprime #|H| #|A| -> solvable H ->\n  'C_(H * G)(A) = 'C_H(A) * 'C_G(A).\nProof.\nmove=> nHA nGA nHG coHA solH; rewrite -norm_joinEr //.\nhave nsHG: H <| H <*> G by rewrite /normal joing_subl join_subG normG.\nrewrite -{2}(setIidPr (normal_sub nsHG)) setIAC.\nrewrite group_modr ?setSI ?joing_subr //=; symmetry; apply/setIidPl.\nrewrite -quotientSK ?subIset 1?normal_norm //.\nby rewrite !coprime_norm_quotient_cent ?normsY //= norm_joinEr ?quotientMidl.\nQed.",
    "Lemma quotient_TI_subcent K G H :\n    G \\subset 'N(K) -> G \\subset 'N(H) -> K :&: H = 1 ->\n  'C_K(G) / H = 'C_(K / H)(G / H).\nProof.\nmove=> nGK nGH tiKH.\nhave tiHR: H :&: [~: K, G] = 1.\n  by apply/trivgP; rewrite /= setIC -tiKH setSI ?commg_subl.\napply: strongest_coprime_quotient_cent; rewrite ?tiHR ?sub1G ?solvable1 //.\nby rewrite cards1 coprime1n.\nQed.",
    "Lemma external_action_im_coprime : coprime #|G'| #|A'|.\nProof. by rewrite !card_injm. Qed.",
    "Lemma ext_coprime_Hall_exists :\n  exists2 H : {group gT}, pi.-Hall(G) H & [acts A, on H | to].\nProof.\nhave [H' hallH' nHA'] := coprime_Hall_exists pi nGA' coGA' solG'.\nhave sHG' := pHall_sub hallH'.\nexists (inG @*^-1 H')%G => /=.\n  by rewrite -(morphim_invmE injG) -{1}(im_invm injG) morphim_pHall.\nby rewrite actsEsd ?morphpreK // subsetIl.\nQed.",
    "Lemma ext_coprime_Hall_trans (H1 H2 : {group gT}) :\n    pi.-Hall(G) H1 -> [acts A, on H1 | to] ->\n    pi.-Hall(G) H2 -> [acts A, on H2 | to] ->\n  exists2 x, x \\in 'C_(G | to)(A) & H1 :=: H2 :^ x.\nProof.\nmove=> hallH1 nH1A hallH2 nH2A.\nhave sH1G := pHall_sub hallH1; have sH2G := pHall_sub hallH2.\nrewrite !actsEsd // in nH1A nH2A.\nhave hallH1': pi.-Hall(G') (inG @* H1) by rewrite morphim_pHall.\nhave hallH2': pi.-Hall(G') (inG @* H2) by rewrite morphim_pHall.\nhave [x'] := coprime_Hall_trans nGA' coGA' solG' hallH1' nH1A hallH2' nH2A.\ncase/setIP=> /= Gx' cAx' /eqP defH1; pose x := invm injG x'.\nhave Gx: x \\in G by rewrite -(im_invm injG) mem_morphim.\nhave def_x': x' = inG x by rewrite invmK.\nexists x; first by rewrite inE Gx gacentEsd mem_morphpre /= -?def_x'.\napply/eqP; move: defH1; rewrite def_x' /= -morphimJ //=.\nby rewrite !eqEsubset !injmSK // conj_subG.\nQed.",
    "Lemma ext_norm_conj_cent (H : {group gT}) x :\n    H \\subset G -> x \\in 'C_(G | to)(A) ->\n  [acts A, on H :^ x | to] = [acts A, on H | to].\nProof.\nmove=> sHG /setIP[Gx].\nrewrite gacentEsd !actsEsd ?conj_subG ?morphimJ // 2!inE Gx /=.\nexact: norm_conj_cent.\nQed.",
    "Lemma ext_coprime_Hall_subset (X : {group gT}) :\n    X \\subset G -> pi.-group X -> [acts A, on X | to] ->\n  exists H : {group gT},\n    [/\\ pi.-Hall(G) H, [acts A, on H | to] & X \\subset H].\nProof.\nmove=> sXG piX; rewrite actsEsd // => nXA'.\ncase: (coprime_Hall_subset nGA' coGA' solG' _ (morphim_pgroup _ piX) nXA').\n  exact: morphimS.\nmove=> H' /= [piH' nHA' sXH']; have sHG' := pHall_sub piH'.\nexists (inG @*^-1 H')%G; rewrite actsEsd ?subsetIl ?morphpreK // nHA'.\nrewrite -sub_morphim_pre //= sXH'; split=> //.\nby rewrite -(morphim_invmE injG) -{1}(im_invm injG) morphim_pHall.\nQed.",
    "Lemma ext_coprime_quotient_cent (H : {group gT}) :\n    H \\subset G -> [acts A, on H | to] -> coprime #|H| #|A| -> solvable H ->\n 'C_(|to)(A) / H = 'C_(|to / H)(A).\nProof.\nmove=> sHG nHA coHA solH; pose N := 'N_G(H).\nhave nsHN: H <| N by rewrite normal_subnorm.\nhave [sHN nHn] := andP nsHN.\nhave sNG: N \\subset G by apply: subsetIl.\nhave nNA: {acts A, on group N | to}.\n  split; rewrite // actsEsd // injm_subnorm ?injm_sdpair1 //=.\n  by rewrite normsI ?norms_norm ?im_sdpair_norm -?actsEsd.\nrewrite -!(gacentIdom _ A) -quotientInorm -gacentIim setIAC.\nrewrite -(gacent_actby nNA) gacentEsd -morphpreIim /= -/N.\nhave:= (injm_sdpair1 <[nNA]>, injm_sdpair2 <[nNA]>).\nset inG := sdpair1 _; set inA := sdpair2 _ => [[injG injA]].\nset G' := inG @* N; set A' := inA @* A; pose H' := inG @* H.\nhave defN: 'N(H | to) = A by apply/eqP; rewrite eqEsubset subsetIl.\nhave def_Dq: qact_dom to H = A by rewrite qact_domE.\nhave sAq: A \\subset qact_dom to H by rewrite def_Dq.\nrewrite {2}def_Dq -(gacent_ract _ sAq); set to_q := (_ \\ _)%gact.\nhave:= And3 (sdprod_sdpair to_q) (injm_sdpair1 to_q) (injm_sdpair2 to_q).\nrewrite gacentEsd; set inAq := sdpair2 _; set inGq := sdpair1 _ => /=.\nset Gq := inGq @* _; set Aq := inAq @* _ => [[q_d iGq iAq]].\nhave nH': 'N(H') = setT.\n  apply/eqP; rewrite -subTset -im_sdpair mulG_subG morphim_norms //=.\n  by rewrite -actsEsd // acts_actby subxx /= (setIidPr sHN).\nhave: 'dom (coset H' \\o inA \\o invm iAq) = Aq.\n  by rewrite ['dom _]morphpre_invm /= nH' morphpreT.\ncase/domP=> /= qA [def_qA ker_qA _ im_qA].\nhave{coHA} coHA': coprime #|H'| #|A'| by rewrite !card_injm.\nhave{ker_qA} injAq: 'injm qA.\n  rewrite {}ker_qA !ker_comp ker_coset morphpre_invm -morphpreIim /= setIC.\n  by rewrite coprime_TIg // -kerE (trivgP injA) morphim1.\nhave{im_qA} im_Aq : qA @* Aq = A' / H'.\n  by rewrite {}im_qA !morphim_comp im_invm.\nhave: 'dom (quotm (sdpair1_morphism <[nNA]>) nsHN \\o invm iGq) = Gq.\n  by rewrite ['dom _]morphpre_invm /= quotientInorm.\ncase/domP=> /= qG [def_qG ker_qG _ im_qG].\nhave{ker_qG} injGq: 'injm qG.\n  rewrite {}ker_qG ker_comp ker_quotm morphpre_invm (trivgP injG).\n  by rewrite quotient1 morphim1.\nhave im_Gq: qG @* Gq = G' / H'.\n  rewrite {}im_qG morphim_comp im_invm morphim_quotm //= -/inG -/H'.\n  by rewrite -morphimIdom setIAC setIid.\nhave{def_qA def_qG} q_J : {in Gq & Aq, morph_act 'J 'J qG qA}.\n  move=> x' a'; case/morphimP=> Hx; case/morphimP=> x nHx Gx -> GHx ->{Hx x'}.\n  case/morphimP=> a _ Aa ->{a'} /=; rewrite -/inAq -/inGq.\n  rewrite !{}def_qG {}def_qA /= !invmE // -sdpair_act //= -/inG -/inA.\n  have Nx: x \\in N by rewrite inE Gx.\n  have Nxa: to x a \\in N by case: (nNA); move/acts_act->.\n  have [Gxa nHxa] := setIP Nxa.\n  rewrite invmE qactE ?quotmE ?mem_morphim ?def_Dq //=.\n  by rewrite -morphJ /= ?nH' ?inE // -sdpair_act //= actbyE.\npose q := sdprodm q_d q_J.\nhave{injAq injGq} injq: 'injm q.\n  rewrite injm_sdprodm injAq injGq /= {}im_Aq {}im_Gq -/Aq .\n  by rewrite -quotientGI ?im_sdpair_TI ?morphimS //= quotient1.\nrewrite -[inGq @*^-1 _]morphpreIim -/Gq.\nhave sC'G: inG @*^-1 'C_G'(A') \\subset G by rewrite !subIset ?subxx.\nrewrite -[_ / _](injmK iGq) ?quotientS //= -/inGq; congr (_ @*^-1 _).\napply: (injm_morphim_inj injq); rewrite 1?injm_subcent ?subsetT //= -/q.\nrewrite 2?morphim_sdprodml ?morphimS //= im_Gq.\nrewrite morphim_sdprodmr ?morphimS //= im_Aq.\nrewrite {}im_qG morphim_comp morphim_invm ?morphimS //.\nrewrite morphim_quotm morphpreK ?subsetIl //= -/H'.\nrewrite coprime_norm_quotient_cent ?im_sdpair_norm ?nH' ?subsetT //=.\nexact: morphim_sol.\nQed.",
    "Lemma sol_coprime_Sylow_exists A G :\n    solvable A -> A \\subset 'N(G) -> coprime #|G| #|A| ->\n  exists2 P : {group gT}, p.-Sylow(G) P & A \\subset 'N(P).\nProof.\nmove=> solA nGA coGA; pose AG := A <*> G.\nhave nsG_AG: G <| AG by rewrite /normal joing_subr join_subG nGA normG.\nhave [sG_AG nG_AG]:= andP nsG_AG.\nhave [P sylP] := Sylow_exists p G; pose N := 'N_AG(P); pose NG := G :&: N.\nhave nGN: N \\subset 'N(G) by rewrite subIset ?nG_AG.\nhave sNG_G: NG \\subset G := subsetIl G N.\nhave nsNG_N: NG <| N by rewrite /normal subsetIr normsI ?normG.\nhave defAG: G * N = AG := Frattini_arg nsG_AG sylP.\nhave oA : #|A| = #|N| %/ #|NG|.\n  rewrite /NG setIC divgI -card_quotient // -quotientMidl defAG.\n  rewrite card_quotient -?divgS //= norm_joinEl //.\n  by rewrite coprime_cardMg 1?coprime_sym // mulnK.\nhave: [splits N, over NG].\n  rewrite SchurZassenhaus_split // /Hall -divgS subsetIr //.\n  by rewrite -oA (coprimeSg sNG_G).\ncase/splitsP=> B; case/complP=> tNG_B defN.\nhave [nPB]: B \\subset 'N(P) /\\ B \\subset AG.\n  by apply/andP; rewrite andbC -subsetI -/N -defN mulG_subr.\ncase/SchurZassenhaus_trans_actsol => // [|x Gx defB].\n  by rewrite oA -defN TI_cardMg // mulKn.\nexists (P :^ x^-1)%G; first by rewrite pHallJ ?groupV.\nby rewrite normJ -sub_conjg -defB.\nQed.",
    "Lemma sol_coprime_Sylow_trans A G :\n    solvable A -> A \\subset 'N(G) -> coprime #|G| #|A| ->\n  [transitive 'C_G(A), on [set P in 'Syl_p(G) | A \\subset 'N(P)] | 'JG].\nProof.\nmove=> solA nGA coGA; pose AG := A <*> G; set FpA := finset _.\nhave nG_AG: AG \\subset 'N(G) by rewrite join_subG nGA normG.\nhave [P sylP nPA] := sol_coprime_Sylow_exists solA nGA coGA.\npose N := 'N_AG(P); have sAN: A \\subset N by rewrite subsetI joing_subl.\nhave trNPA: A :^: AG ::&: N = A :^: N.\n  pose NG := 'N_G(P); have sNG_G : NG \\subset G := subsetIl _ _.\n  have nNGA: A \\subset 'N(NG) by rewrite normsI ?norms_norm.\n  apply/setP=> Ax; apply/setIdP/imsetP=> [[]|[x Nx ->{Ax}]]; last first.\n    by rewrite conj_subG //; case/setIP: Nx => AGx; rewrite imset_f.\n  have ->: N = A <*> NG by rewrite /N /AG !norm_joinEl // -group_modl.\n  have coNG_A := coprimeSg sNG_G coGA; case/imsetP=> x AGx ->{Ax}.\n  case/SchurZassenhaus_trans_actsol; rewrite ?cardJg // => y Ny /= ->.\n  by exists y; rewrite // mem_gen 1?inE ?Ny ?orbT.\nhave{trNPA}: [transitive 'N_AG(A), on FpA | 'JG].\n  have ->: FpA = 'Fix_('Syl_p(G) | 'JG)(A).\n    by apply/setP=> Q; rewrite 4!inE afixJG.\n  have SylP : P \\in 'Syl_p(G) by rewrite inE.\n  apply/(trans_subnorm_fixP _ SylP); rewrite ?astab1JG //.\n  rewrite (atrans_supgroup _ (Syl_trans _ _)) ?joing_subr //= -/AG.\n  by apply/actsP=> x /= AGx Q /=; rewrite !inE -{1}(normsP nG_AG x) ?pHallJ2.\nrewrite {1}/AG norm_joinEl // -group_modl ?normG ?coprime_norm_cent //=.\nrewrite -cent_joinEr ?subsetIr // => trC_FpA.\nhave FpA_P: P \\in FpA by rewrite !inE sylP.\napply/(subgroup_transitiveP FpA_P _ trC_FpA); rewrite ?joing_subr //=.\nrewrite astab1JG cent_joinEr ?subsetIr // -group_modl // -mulgA.\nby congr (_ * _); rewrite mulSGid ?subsetIl.\nQed.",
    "Lemma sol_coprime_Sylow_subset A G X :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> solvable A ->\n  X \\subset G -> p.-group X -> A \\subset 'N(X) ->\n  exists P : {group gT}, [/\\ p.-Sylow(G) P, A \\subset 'N(P) & X \\subset P].\nProof.\nmove=> nGA coGA solA sXG pX nXA.\npose nAp (Q : {group gT}) := [&& p.-group Q, Q \\subset G & A \\subset 'N(Q)].\nhave: nAp X by apply/and3P.\ncase/maxgroup_exists=> R; case/maxgroupP; case/and3P=> pR sRG nRA maxR sXR.\nhave [P sylP sRP]:= Sylow_superset sRG pR.\nsuffices defP: P :=: R by exists P; rewrite sylP defP.\ncase/and3P: sylP => sPG pP _; apply: (nilpotent_sub_norm (pgroup_nil pP)) => //.\npose N := 'N_G(R); have{sPG} sPN_N: 'N_P(R) \\subset N by apply: setSI.\napply: norm_sub_max_pgroup (pgroupS (subsetIl _ _) pP) sPN_N (subsetIr _ _).\nhave nNA: A \\subset 'N(N) by rewrite normsI ?norms_norm.\nhave coNA: coprime #|N| #|A| by apply: coprimeSg coGA; rewrite subsetIl.\nhave{solA coNA} [Q sylQ nQA] := sol_coprime_Sylow_exists solA nNA coNA.\nsuffices defQ: Q :=: R by rewrite max_pgroup_Sylow -{2}defQ.\napply: maxR; first by apply/and3P; case/and3P: sylQ; rewrite subsetI; case/andP.\nby apply: normal_sub_max_pgroup (Hall_max sylQ) pR _; rewrite normal_subnorm.\nQed.",
    "Lemma semiregular1l H : semiregular 1 H.\nProof. by move=> x _ /=; rewrite setI1g. Qed.",
    "Lemma semiregular1r K : semiregular K 1.\nProof. by move=> x; rewrite setDv inE. Qed.",
    "Lemma semiregular_sym H K : semiregular K H -> semiregular H K.\nProof.\nmove=> regH x /setD1P[ntx Kx]; apply: contraNeq ntx.\nrewrite -subG1 -setD_eq0 -setIDAC => /set0Pn[y /setIP[Hy cxy]].\nby rewrite (sameP eqP set1gP) -(regH y Hy) inE Kx cent1C.\nQed.",
    "Lemma semiregularS K1 K2 A1 A2 :\n  K1 \\subset K2 -> A1 \\subset A2 -> semiregular K2 A2 -> semiregular K1 A1.\nProof.\nmove=> sK12 sA12 regKA2 x /setD1P[ntx /(subsetP sA12)A2x].\nby apply/trivgP; rewrite -(regKA2 x) ?inE ?ntx ?setSI.\nQed.",
    "Lemma semiregular_prime H K : semiregular K H -> semiprime K H.\nProof.\nmove=> regH x Hx; apply/eqP; rewrite eqEsubset {1}regH // sub1G.\nby rewrite -cent_set1 setIS ?centS // sub1set; case/setD1P: Hx.\nQed.",
    "Lemma semiprime_regular H K : semiprime K H -> 'C_K(H) = 1 -> semiregular K H.\nProof. by move=> prKH tiKcH x Hx; rewrite prKH. Qed.",
    "Lemma semiprimeS K1 K2 A1 A2 :\n  K1 \\subset K2 -> A1 \\subset A2 -> semiprime K2 A2 -> semiprime K1 A1.\nProof.\nmove=> sK12 sA12 prKA2 x /setD1P[ntx A1x].\napply/eqP; rewrite eqEsubset andbC -{1}cent_set1 setIS ?centS ?sub1set //=.\nrewrite -(setIidPl sK12) -!setIA prKA2 ?setIS ?centS //.\nby rewrite !inE ntx (subsetP sA12).\nQed.",
    "Lemma cent_semiprime H K X :\n   semiprime K H -> X \\subset H -> X :!=: 1 -> 'C_K(X) = 'C_K(H).\nProof.\nmove=> prKH sXH /trivgPn[x Xx ntx]; apply/eqP.\nrewrite eqEsubset -{1}(prKH x) ?inE ?(subsetP sXH) ?ntx //=.\nby rewrite -cent_cycle !setIS ?centS ?cycle_subG.\nQed.",
    "Lemma stab_semiprime H K X :\n   semiprime K H -> X \\subset K -> 'C_H(X) != 1 -> 'C_H(X) = H.\nProof.\nmove=> prKH sXK ntCHX; apply/setIidPl; rewrite centsC -subsetIidl.\nrewrite -{2}(setIidPl sXK) -setIA -(cent_semiprime prKH _ ntCHX) ?subsetIl //.\nby rewrite !subsetI subxx sXK centsC subsetIr.\nQed.",
    "Lemma cent_semiregular H K X :\n   semiregular K H -> X \\subset H -> X :!=: 1 -> 'C_K(X) = 1.\nProof.\nmove=> regKH sXH /trivgPn[x Xx ntx]; apply/trivgP.\nrewrite -(regKH x) ?inE ?(subsetP sXH) ?ntx ?setIS //=.\nby rewrite -cent_cycle centS ?cycle_subG.\nQed.",
    "Lemma regular_norm_dvd_pred K H :\n  H \\subset 'N(K) -> semiregular K H -> #|H| %| #|K|.-1.\nProof.\nmove=> nKH regH; have actsH: [acts H, on K^# | 'J] by rewrite astabsJ normD1.\nrewrite (cardsD1 1 K) group1 -(acts_sum_card_orbit actsH) /=.\nrewrite (eq_bigr (fun _ => #|H|)) ?sum_nat_const ?dvdn_mull //.\nmove=> _ /imsetP[x /setIdP[ntx Kx] ->]; rewrite card_orbit astab1J.\nrewrite ['C_H[x]](trivgP _) ?indexg1 //=.\napply/subsetP=> y /setIP[Hy cxy]; apply: contraR ntx => nty.\nby rewrite -[[set 1]](regH y) inE ?nty // Kx cent1C.\n\nQed.",
    "Lemma regular_norm_coprime K H :\n  H \\subset 'N(K) -> semiregular K H -> coprime #|K| #|H|.\nProof.\nmove=> nKH regH.\nby rewrite (coprime_dvdr (regular_norm_dvd_pred nKH regH)) ?coprimenP.\nQed.",
    "Lemma semiregularJ K H x : semiregular K H -> semiregular (K :^ x) (H :^ x).\nProof.\nmove=> regH yx; rewrite -conjD1g => /imsetP[y Hy ->].\nby rewrite cent1J -conjIg regH ?conjs1g.\nQed.",
    "Lemma semiprimeJ K H x : semiprime K H -> semiprime (K :^ x) (H :^ x).\nProof.\nmove=> prH yx; rewrite -conjD1g => /imsetP[y Hy ->].\nby rewrite cent1J centJ -!conjIg prH.\nQed.",
    "Lemma normedTI_P A G L : \n  reflect [/\\ A != set0, L \\subset 'N_G(A)\n           & {in G, forall g, ~~ [disjoint A & A :^ g] -> g \\in L}]\n          (normedTI A G L).\nProof.\napply: (iffP and3P) => [[nzA /trivIsetP tiAG /eqP <-] | [nzA sLN tiAG]].\n  split=> // g Gg; rewrite inE Gg (sameP normP eqP) /= eq_sym; apply: contraR.\n  by apply: tiAG; rewrite ?mem_orbit ?orbit_refl.\nhave [/set0Pn[a Aa] /subsetIP[_ nAL]] := (nzA, sLN); split=> //; last first.\n  rewrite eqEsubset sLN andbT; apply/subsetP=> x /setIP[Gx nAx].\n  by apply/tiAG/pred0Pn=> //; exists a; rewrite /= (normP nAx) Aa.\napply/trivIsetP=> _ _ /imsetP[x Gx ->] /imsetP[y Gy ->]; apply: contraR.\nrewrite -setI_eq0 -(mulgKV x y) conjsgM; set g := (y * x^-1)%g.\nhave Gg: g \\in G by rewrite groupMl ?groupV.\nrewrite -conjIg (inj_eq (act_inj 'Js x)) (eq_sym A) (sameP eqP normP).\nby rewrite -cards_eq0 cardJg cards_eq0 setI_eq0 => /tiAG/(subsetP nAL)->.\nQed.",
    "Lemma normedTI_memJ_P A G L :\n  reflect [/\\ A != set0, L \\subset G\n            & {in A & G, forall a g, (a ^ g \\in A) = (g \\in L)}]\n          (normedTI A G L).\nProof.\napply: (iffP normedTI_P) => [[-> /subsetIP[sLG nAL] tiAG] | [-> sLG tiAG]].\n  split=> // a g Aa Gg; apply/idP/idP=> [Aag | Lg]; last first.\n    by rewrite memJ_norm ?(subsetP nAL).\n  by apply/tiAG/pred0Pn=> //; exists (a ^ g)%g; rewrite /= Aag memJ_conjg.\nsplit=> // [ | g Gg /pred0Pn[ag /=]]; last first.\n  by rewrite andbC => /andP[/imsetP[a Aa ->]]; rewrite tiAG.\napply/subsetP=> g Lg; have Gg := subsetP sLG g Lg.\nby rewrite !inE Gg; apply/subsetP=> _ /imsetP[a Aa ->]; rewrite tiAG.\nQed.",
    "Lemma partition_class_support A G :\n  A != set0 -> trivIset (A :^: G) -> partition (A :^: G) (class_support A G).\nProof.\nrewrite /partition cover_imset -class_supportEr eqxx => nzA ->.\nby apply: contra nzA => /imsetP[x _ /eqP]; rewrite eq_sym -!cards_eq0 cardJg.\nQed.",
    "Lemma partition_normedTI A G L :\n  normedTI A G L -> partition (A :^: G) (class_support A G).\nProof. by case/and3P=> ntA tiAG _; apply: partition_class_support. Qed.",
    "Lemma card_support_normedTI A G L :\n  normedTI A G L -> #|class_support A G| = (#|A| * #|G : L|)%N.\nProof.\ncase/and3P=> ntA tiAG /eqP <-; rewrite -card_conjugates mulnC.\napply: card_uniform_partition (partition_class_support ntA tiAG).\nby move=> _ /imsetP[y _ ->]; rewrite cardJg.\nQed.",
    "Lemma normedTI_S A B G L : \n    A != set0 -> L \\subset 'N(A) -> A \\subset B -> normedTI B G L ->\n  normedTI A G L.\nProof.\nmove=> nzA /subsetP nAL /subsetP sAB /normedTI_memJ_P[nzB sLG tiB].\napply/normedTI_memJ_P; split=> // a x Aa Gx.\nby apply/idP/idP => [Aax | /nAL/memJ_norm-> //]; rewrite -(tiB a) ?sAB.\nQed.",
    "Lemma cent1_normedTI A G L :\n  normedTI A G L -> {in A, forall x, 'C_G[x] \\subset L}.\nProof.\ncase/normedTI_memJ_P=> [_ _ tiAG] x Ax; apply/subsetP=> y /setIP[Gy cxy].\nby rewrite -(tiAG x) // /(x ^ y) -(cent1P cxy) mulKg.\nQed.",
    "Lemma Frobenius_actionP G H :\n  reflect (has_Frobenius_action G H) [Frobenius G with complement H].\nProof.\napply: (iffP andP) => [[neqHG] | [sT S to [ffulG transG regG ntH [u Su defH]]]].\n  case/normedTI_P=> nzH /subsetIP[sHG _] tiHG.\n  suffices: Frobenius_action G H (rcosets H G) 'Rs by apply: hasFrobeniusAction.\n  pose Hfix x := 'Fix_(rcosets H G | 'Rs)[x].\n  have regG: {in G^#, forall x, #|Hfix x| <= 1}.\n    move=> x /setD1P[ntx Gx].\n    apply: wlog_neg; rewrite -ltnNge => /ltnW/card_gt0P/=[Hy].\n    rewrite -(cards1 Hy) => /setIP[/imsetP[y Gy ->{Hy}] cHyx].\n    apply/subset_leq_card/subsetP=> _ /setIP[/imsetP[z Gz ->] cHzx].\n    rewrite -!sub_astab1 !astab1_act !sub1set astab1Rs in cHyx cHzx *.\n    rewrite !rcosetE; apply/set1P/rcoset_eqP; rewrite mem_rcoset.\n    apply: tiHG; [by rewrite !in_group | apply/pred0Pn; exists (x ^ y^-1)].\n    by rewrite conjD1g !inE conjg_eq1 ntx -mem_conjg cHyx conjsgM memJ_conjg.\n  have ntH: H :!=: 1 by rewrite -subG1 -setD_eq0.\n  split=> //; first 1 last; first exact: transRs_rcosets.\n    by exists (val H); rewrite ?orbit_refl // astab1Rs (setIidPr sHG).\n  apply/subsetP=> y /setIP[Gy cHy]; apply: contraR neqHG => nt_y.\n  rewrite (index1g sHG) //; apply/eqP; rewrite eqn_leq indexg_gt0 andbT.\n  apply: leq_trans (regG y _); last by rewrite setDE 2!inE Gy nt_y /=.\n  by rewrite /Hfix (setIidPl _) -1?astabC ?sub1set.\nhave sHG: H \\subset G by rewrite defH subsetIl.\nsplit.\n  apply: contraNneq ntH => /= defG.\n  suffices defS: S = [set u] by rewrite -(trivgP ffulG) /= defS defH.\n  apply/eqP; rewrite eq_sym eqEcard sub1set Su.\n  by rewrite -(atransP transG u Su) card_orbit -defH defG indexgg cards1.\napply/normedTI_P; rewrite setD_eq0 subG1 normD1 subsetI sHG normG.\nsplit=> // x Gx; rewrite -setI_eq0 conjD1g defH inE Gx conjIg conjGid //.\nrewrite -setDIl -setIIr -astab1_act setDIl => /set0Pn[y /setIP[Gy /setD1P[_]]].\ncase/setIP; rewrite 2!(sameP astab1P afix1P) => cuy cuxy; apply/astab1P.\napply: contraTeq (regG y Gy) => cu'x.\nrewrite (cardD1 u) (cardD1 (to u x)) inE Su cuy inE /= inE cu'x cuxy.\nby rewrite (actsP (atrans_acts transG)) ?Su.\nQed.",
    "Lemma FrobeniusWker : [Frobenius G with kernel K].\nProof. by apply/existsP; exists H. Qed.",
    "Lemma FrobeniusWcompl : [Frobenius G with complement H].\nProof. by case/andP: frobG. Qed.",
    "Lemma FrobeniusW : [Frobenius G].\nProof. by apply/existsP; exists H; apply: FrobeniusWcompl. Qed.",
    "Lemma Frobenius_context :\n  [/\\ K ><| H = G, K :!=: 1, H :!=: 1, K \\proper G & H \\proper G].\nProof.\nhave [/eqP defG neqHG ntH _] := and4P frobG; rewrite setD_eq0 subG1 in ntH.\nhave ntK: K :!=: 1 by apply: contraNneq neqHG => K1; rewrite -defG K1 sdprod1g.\nrewrite properEcard properEneq neqHG; have /mulG_sub[-> ->] := sdprodW defG.\nby rewrite -(sdprod_card defG) ltn_Pmulr ?cardG_gt1.\nQed.",
    "Lemma Frobenius_partition : partition (gval K |: (H^# :^: K)) G.\nProof.\nhave [/eqP defG _ tiHG] := and3P frobG; have [_ tiH1G /eqP defN] := and3P tiHG.\nhave [[_ /mulG_sub[sKG sHG] nKH tiKH] mulHK] := (sdprodP defG, sdprodWC defG).\nset HG := H^# :^: K; set KHG := _ |: _.\nhave defHG: HG = H^# :^: G.\n  have: 'C_G[H^# | 'Js] * K = G by rewrite astab1Js defN mulHK.\n  move/subgroup_transitiveP/atransP.\n  by apply; rewrite ?atrans_orbit ?orbit_refl.\nhave /and3P[defHK _ nzHG] := partition_normedTI tiHG.\nrewrite -defHG in defHK nzHG tiH1G.\nhave [tiKHG HG'K]: trivIset KHG /\\ gval K \\notin HG.\n  apply: trivIsetU1 => // _ /imsetP[x Kx ->]; rewrite -setI_eq0.\n  by rewrite -(conjGid Kx) -conjIg setIDA tiKH setDv conj0g.\nrewrite /partition andbC tiKHG !inE negb_or nzHG eq_sym -card_gt0 cardG_gt0 /=.\nrewrite eqEcard; apply/andP; split.\n  rewrite /cover big_setU1 //= subUset sKG -/(cover HG) (eqP defHK).\n  by rewrite class_support_subG // (subset_trans _ sHG) ?subD1set.\nrewrite -(eqnP tiKHG) big_setU1 //= (eqnP tiH1G) (eqP defHK).\nrewrite (card_support_normedTI tiHG) -(Lagrange sHG) (cardsD1 1) group1 mulSn.\nby rewrite leq_add2r -mulHK indexMg -indexgI tiKH indexg1.\nQed.",
    "Lemma Frobenius_cent1_ker : {in K^#, forall x, 'C_G[x] \\subset K}.\nProof.\nhave [/eqP defG _ /normedTI_memJ_P[_ _ tiHG]] := and3P frobG.\nmove=> x /setD1P[ntx Kx]; have [_ /mulG_sub[sKG _] _ tiKH] := sdprodP defG.\nhave [/eqP <- _ _] := and3P Frobenius_partition; rewrite big_distrl /=.\napply/bigcupsP=> _ /setU1P[|/imsetP[y Ky]] ->; first exact: subsetIl.\napply: contraR ntx => /subsetPn[z]; rewrite inE mem_conjg => /andP[Hzy cxz] _.\nrewrite -(conjg_eq1 x y^-1) -in_set1 -set1gE -tiKH inE andbC.\nrewrite -(tiHG _ _ Hzy) ?(subsetP sKG) ?in_group // Ky andbT -conjJg.\nby rewrite /(z ^ x) (cent1P cxz) mulKg.\nQed.",
    "Lemma Frobenius_reg_ker : semiregular K H.\nProof.\nmove=> x /setD1P[ntx Hx].\napply/trivgP/subsetP=> y /setIP[Ky cxy]; apply: contraR ntx => nty.\nhave K1y: y \\in K^# by rewrite inE nty.\nhave [/eqP/sdprod_context[_ sHG _ _ tiKH] _] := andP frobG.\nsuffices: x \\in K :&: H by rewrite tiKH inE.\nby rewrite inE (subsetP (Frobenius_cent1_ker K1y)) // inE cent1C (subsetP sHG).\nQed.",
    "Lemma Frobenius_reg_compl : semiregular H K.\nProof. by apply: semiregular_sym; apply: Frobenius_reg_ker. Qed.",
    "Lemma Frobenius_dvd_ker1 : #|H| %| #|K|.-1.\nProof.\napply: regular_norm_dvd_pred Frobenius_reg_ker.\nby have[/sdprodP[]] := Frobenius_context.\nQed.",
    "Lemma ltn_odd_Frobenius_ker : odd #|G| -> #|H|.*2 < #|K|.\nProof.\nmove/oddSg=> oddG.\nhave [/sdprodW/mulG_sub[sKG sHG] ntK _ _ _] := Frobenius_context.\nby rewrite dvdn_double_ltn ?oddG ?cardG_gt1 ?Frobenius_dvd_ker1.\nQed.",
    "Lemma Frobenius_index_dvd_ker1 : #|G : K| %| #|K|.-1.\nProof.\nhave[defG _ _ /andP[sKG _] _] := Frobenius_context.\nby rewrite -divgS // -(sdprod_card defG) mulKn ?Frobenius_dvd_ker1.\nQed.",
    "Lemma Frobenius_coprime : coprime #|K| #|H|.\nProof. by rewrite (coprime_dvdr Frobenius_dvd_ker1) ?coprimenP. Qed.",
    "Lemma Frobenius_trivg_cent : 'C_K(H) = 1.\nProof.\nby apply: (cent_semiregular Frobenius_reg_ker); case: Frobenius_context.\nQed.",
    "Lemma Frobenius_index_coprime : coprime #|K| #|G : K|.\nProof. by rewrite (coprime_dvdr Frobenius_index_dvd_ker1) ?coprimenP. Qed.",
    "Lemma Frobenius_ker_Hall : Hall G K.\nProof.\nhave [_ _ _ /andP[sKG _] _] := Frobenius_context.\nby rewrite /Hall sKG Frobenius_index_coprime.\nQed.",
    "Lemma Frobenius_compl_Hall : Hall G H.\nProof.\nhave [defG _ _ _ _] := Frobenius_context.\nby rewrite -(sdprod_Hall defG) Frobenius_ker_Hall.\nQed.",
    "Lemma normedTI_J x A G L : normedTI (A :^ x) (G :^ x) (L :^ x) = normedTI A G L.\nProof.\nrewrite {1}/normedTI normJ -conjIg -(conj0g x) !(can_eq (conjsgK x)).\ncongr [&&  _, _ == _ & _]; rewrite /cover (reindex_inj (@conjsg_inj _ x)).\n  by apply: eq_big => Hy; rewrite ?orbit_conjsg ?cardJg.\nby rewrite bigcupJ cardJg (eq_bigl _ _ (orbit_conjsg _ _ _ _)).\nQed.",
    "Lemma FrobeniusJcompl x G H :\n  [Frobenius G :^ x with complement H :^ x] = [Frobenius G with complement H].\nProof.\nby congr (_ && _); rewrite ?(can_eq (conjsgK x)) // -conjD1g normedTI_J.\nQed.",
    "Lemma FrobeniusJ x G K H :\n  [Frobenius G :^ x = K :^ x ><| H :^ x] = [Frobenius G = K ><| H].\nProof.\nby congr (_ && _); rewrite ?FrobeniusJcompl // -sdprodJ (can_eq (conjsgK x)).\nQed.",
    "Lemma FrobeniusJker x G K :\n  [Frobenius G :^ x with kernel K :^ x] = [Frobenius G with kernel K].\nProof.\napply/existsP/existsP=> [] [H]; last by exists (H :^ x)%G; rewrite FrobeniusJ.\nby rewrite -(conjsgKV x H) FrobeniusJ; exists (H :^ x^-1)%G.\nQed.",
    "Lemma FrobeniusJgroup x G : [Frobenius G :^ x] = [Frobenius G].\nProof.\napply/existsP/existsP=> [] [H].\n  by rewrite -(conjsgKV x H) FrobeniusJcompl; exists (H :^ x^-1)%G.\nby exists (H :^ x)%G; rewrite FrobeniusJcompl.\nQed.",
    "Lemma Frobenius_ker_dvd_ker1 G K :\n  [Frobenius G with kernel K] -> #|G : K| %| #|K|.-1.\nProof. by case/existsP=> H; apply: Frobenius_index_dvd_ker1. Qed.",
    "Lemma Frobenius_ker_coprime G K :\n  [Frobenius G with kernel K] -> coprime #|K| #|G : K|.\nProof. by case/existsP=> H; apply: Frobenius_index_coprime. Qed.",
    "Lemma Frobenius_semiregularP G K H :\n    K ><| H = G -> K :!=: 1 -> H :!=: 1 ->\n  reflect (semiregular K H) [Frobenius G = K ><| H].\nProof.\nmove=> defG ntK ntH.\napply: (iffP idP) => [|regG]; first exact: Frobenius_reg_ker.\nhave [nsKG sHG defKH nKH tiKH]:= sdprod_context defG; have [sKG _]:= andP nsKG.\napply/and3P; split; first by rewrite defG.\n  by rewrite eqEcard sHG -(sdprod_card defG) -ltnNge ltn_Pmull ?cardG_gt1.\napply/normedTI_memJ_P; rewrite setD_eq0 subG1 sHG -defKH -(normC nKH).\nsplit=> // z _ /setD1P[ntz Hz] /mulsgP[y x Hy Kx ->]; rewrite groupMl // !inE.\nrewrite conjg_eq1 ntz; apply/idP/idP=> [Hzxy | Hx]; last by rewrite !in_group.\napply: (subsetP (sub1G H)); have Hzy: z ^ y \\in H by apply: groupJ.\nrewrite -(regG (z ^ y)); last by apply/setD1P; rewrite conjg_eq1.\nrewrite inE Kx cent1C (sameP cent1P commgP) -in_set1 -[[set 1]]tiKH inE /=.\nrewrite andbC groupM ?groupV -?conjgM //= commgEr groupMr //.\nby rewrite memJ_norm ?(subsetP nKH) ?groupV.\nQed.",
    "Lemma prime_FrobeniusP G K H :\n    K :!=: 1 -> prime #|H| ->\n  reflect (K ><| H = G /\\ 'C_K(H) = 1) [Frobenius G = K ><| H].\nProof.\nmove=> ntK H_pr; have ntH: H :!=: 1 by rewrite -cardG_gt1 prime_gt1.\nhave [defG | not_sdG] := eqVneq (K ><| H) G; last first.\n  by apply: (iffP andP) => [] [defG]; rewrite defG ?eqxx in not_sdG.\napply: (iffP (Frobenius_semiregularP defG ntK ntH)) => [regH | [_ regH x]].\n  split=> //; have [x defH] := cyclicP (prime_cyclic H_pr).\n  by rewrite defH cent_cycle regH // !inE defH cycle_id andbT -cycle_eq1 -defH.\ncase/setD1P=> nt_x Hx; apply/trivgP; rewrite -regH setIS //= -cent_cycle.\nby rewrite centS // prime_meetG // (setIidPr _) ?cycle_eq1 ?cycle_subG.\nQed.",
    "Lemma Frobenius_subl G K K1 H :\n    K1 :!=: 1 -> K1 \\subset K -> H \\subset 'N(K1) -> [Frobenius G = K ><| H] ->\n  [Frobenius K1 <*> H = K1 ><| H].\nProof.\nmove=> ntK1 sK1K nK1H frobG; have [_ _ ntH _ _] := Frobenius_context frobG.\napply/Frobenius_semiregularP=> //.\n  by rewrite sdprodEY ?coprime_TIg ?(coprimeSg sK1K) ?(Frobenius_coprime frobG).\nby move=> x /(Frobenius_reg_ker frobG) cKx1; apply/trivgP; rewrite -cKx1 setSI.\nQed.",
    "Lemma Frobenius_subr G K H H1 :\n    H1 :!=: 1 -> H1 \\subset H -> [Frobenius G = K ><| H] ->\n  [Frobenius K <*> H1 = K ><| H1].\nProof.\nmove=> ntH1 sH1H frobG; have [defG ntK _ _ _] := Frobenius_context frobG.\napply/Frobenius_semiregularP=> //.\n  have [_ _ /(subset_trans sH1H) nH1K tiHK] := sdprodP defG.\n  by rewrite sdprodEY //; apply/trivgP; rewrite -tiHK setIS.\nby apply: sub_in1 (Frobenius_reg_ker frobG); apply/subsetP/setSD.\nQed.",
    "Lemma Frobenius_kerP G K :\n  reflect [/\\ K :!=: 1, K \\proper G, K <| G\n            & {in K^#, forall x, 'C_G[x] \\subset K}]\n          [Frobenius G with kernel K].\nProof.\napply: (iffP existsP) => [[H frobG] | [ntK ltKG nsKG regK]].\n  have [/sdprod_context[nsKG _ _ _ _] ntK _ ltKG _] := Frobenius_context frobG.\n  by split=> //; apply: Frobenius_cent1_ker frobG.\nhave /andP[sKG nKG] := nsKG.\nhave hallK: Hall G K.\n  rewrite /Hall sKG //= coprime_sym coprime_pi' //.\n  apply: sub_pgroup (pgroup_pi K) => p; have [P sylP] := Sylow_exists p G.\n  have [[sPG pP p'GiP] sylPK] := (and3P sylP, Hall_setI_normal nsKG sylP).\n  rewrite -p_rank_gt0 -(rank_Sylow sylPK) rank_gt0 => ntPK.\n  rewrite inE /= -p'natEpi // (pnat_dvd _ p'GiP) ?indexgS //.\n  have /trivgPn[z]: P :&: K :&: 'Z(P) != 1.\n    by rewrite meet_center_nil ?(pgroup_nil pP) ?(normalGI sPG nsKG).\n  rewrite !inE -andbA -sub_cent1=> /and4P[_ Kz _ cPz] ntz.\n  by apply: subset_trans (regK z _); [apply/subsetIP | apply/setD1P].\nhave /splitsP[H /complP[tiKH defG]] := SchurZassenhaus_split hallK nsKG.\nhave [_ sHG] := mulG_sub defG; have nKH := subset_trans sHG nKG.\nexists H; apply/Frobenius_semiregularP; rewrite ?sdprodE //.\n  by apply: contraNneq (proper_subn ltKG) => H1; rewrite -defG H1 mulg1.\napply: semiregular_sym => x Kx; apply/trivgP; rewrite -tiKH.\nby rewrite subsetI subsetIl (subset_trans _ (regK x _)) ?setSI.\nQed.",
    "Lemma set_Frobenius_compl G K H :\n  K ><| H = G -> [Frobenius G with kernel K] -> [Frobenius G = K ><| H].\nProof.\nmove=> defG /Frobenius_kerP[ntK ltKG _ regKG].\napply/Frobenius_semiregularP=> //.\n  by apply: contraTneq ltKG => H_1; rewrite -defG H_1 sdprodg1 properxx.\napply: semiregular_sym => y /regKG sCyK.\nhave [_ sHG _ _ tiKH] := sdprod_context defG.\nby apply/trivgP; rewrite /= -(setIidPr sHG) setIAC -tiKH setSI.\nQed.",
    "Lemma Frobenius_kerS G K G1 :\n    G1 \\subset G -> K \\proper G1 ->\n  [Frobenius G with kernel K] -> [Frobenius G1 with kernel K].\nProof.\nmove=> sG1G ltKG1 /Frobenius_kerP[ntK _ /andP[_ nKG] regKG].\napply/Frobenius_kerP; rewrite /normal proper_sub // (subset_trans sG1G) //.\nby split=> // x /regKG; apply: subset_trans; rewrite setSI.\nQed.",
    "Lemma Frobenius_action_kernel_def G H K sT S to :\n    K ><| H = G -> @Frobenius_action _ G H sT S to ->\n  K :=: 1 :|: [set x in G | 'Fix_(S | to)[x] == set0].\nProof.\nmove=> defG FrobG.\nhave partG: partition (gval K |: (H^# :^: K)) G.\n  apply: Frobenius_partition; apply/andP; rewrite defG; split=> //.\n  by apply/Frobenius_actionP; apply: hasFrobeniusAction FrobG.\nhave{FrobG} [ffulG transG regG ntH [u Su defH]]:= FrobG.\napply/setP=> x /[!inE]; have [-> | ntx] := eqVneq; first exact: group1.\nrewrite /= -(cover_partition partG) /cover.\nhave neKHy y: gval K <> H^# :^ y.\n  by move/setP/(_ 1); rewrite group1 conjD1g setD11.\nrewrite big_setU1 /= ?inE; last by apply/imsetP=> [[y _ /neKHy]].\nhave [nsKG sHG _ _ tiKH] := sdprod_context defG; have [sKG nKG]:= andP nsKG.\nsymmetry; case Kx: (x \\in K) => /=.\n  apply/set0Pn=> [[v /setIP[Sv]]]; have [y Gy ->] := atransP2 transG Su Sv.\n  rewrite -sub1set -astabC sub1set astab1_act mem_conjg => Hxy.\n  case/negP: ntx; rewrite -in_set1 -(conjgKV y x) -mem_conjgV conjs1g -tiKH.\n  by rewrite defH setIA inE -mem_conjg (setIidPl sKG) (normsP nKG) ?Kx.\napply/andP=> [[/bigcupP[_ /imsetP[y Ky ->] Hyx] /set0Pn[]]]; exists (to u y).\nrewrite inE (actsP (atrans_acts transG)) ?(subsetP sKG) // Su.\nrewrite -sub1set -astabC sub1set astab1_act.\nby rewrite conjD1g defH conjIg !inE in Hyx; case/and3P: Hyx.\nQed.",
    "Lemma Frobenius_coprime_quotient (gT : finGroupType) (G K H N : {group gT}) :\n    K ><| H = G -> N <| G -> coprime #|K| #|H| /\\ H :!=: 1%g ->\n    N \\proper K /\\ {in H^#, forall x, 'C_K[x] \\subset N} ->\n  [Frobenius G / N = (K / N) ><| (H / N)]%g.\nProof.\nmove=> defG nsNG [coKH ntH] [ltNK regH].\nhave [[sNK _] [_ /mulG_sub[sKG sHG] _ _]] := (andP ltNK, sdprodP defG).\nhave [_ nNG] := andP nsNG; have nNH := subset_trans sHG nNG.\napply/Frobenius_semiregularP; first exact: quotient_coprime_sdprod.\n- by rewrite quotient_neq1 ?(normalS _ sKG).\n- by rewrite -(isog_eq1 (quotient_isog _ _)) ?coprime_TIg ?(coprimeSg sNK).\nmove=> _ /(subsetP (quotientD1 _ _))/morphimP[x nNx H1x ->].\nrewrite -cent_cycle -quotient_cycle //=.\nrewrite -strongest_coprime_quotient_cent ?cycle_subG //.\n- by rewrite cent_cycle quotientS1 ?regH.\n- by rewrite subIset ?sNK.\n- rewrite (coprimeSg (subsetIl N _)) ?(coprimeSg sNK) ?(coprimegS _ coKH) //.\n  by rewrite cycle_subG; case/setD1P: H1x.\nby rewrite orbC abelian_sol ?cycle_abelian.\nQed.",
    "Lemma injm_Frobenius_compl H sGD injf : \n  [Frobenius G with complement H] -> [Frobenius f @* G with complement f @* H].\nProof.\ncase/andP=> neqGH /normedTI_P[nzH /subsetIP[sHG _] tiHG].\nhave sHD := subset_trans sHG sGD; have sH1D := subset_trans (subD1set H 1) sHD.\napply/andP; rewrite (can_in_eq (injmK injf)) //; split=> //.\napply/normedTI_P; rewrite normD1 -injmD1 // -!cards_eq0 card_injm // in nzH *.\nrewrite subsetI normG morphimS //; split=> // _ /morphimP[x Dx Gx ->] ti'fHx.\nrewrite mem_morphim ?tiHG //; apply: contra ti'fHx; rewrite -!setI_eq0 => tiHx.\nby rewrite -morphimJ // -injmI ?conj_subG // (eqP tiHx) morphim0.\nQed.",
    "Lemma injm_Frobenius H K sGD injf : \n  [Frobenius G = K ><| H] -> [Frobenius f @* G = f @* K ><| f @* H].\nProof.\ncase/andP=> /eqP defG frobG.\nby apply/andP; rewrite (injm_sdprod _ injf defG) // eqxx injm_Frobenius_compl.\nQed.",
    "Lemma injm_Frobenius_ker K sGD injf : \n  [Frobenius G with kernel K] -> [Frobenius f @* G with kernel f @* K].\nProof.\ncase/existsP=> H frobG; apply/existsP.\nby exists (f @* H)%G; apply: injm_Frobenius.\nQed.",
    "Lemma injm_Frobenius_group sGD injf : [Frobenius G] -> [Frobenius f @* G].\nProof.\ncase/existsP=> H frobG; apply/existsP; exists (f @* H)%G.\nexact: injm_Frobenius_compl.\nQed.",
    "Lemma actP : is_action [set: 'Z_p] act.\nProof.\napply: is_total_action=> [] [i j] => [|k1 k2] /=; first by rewrite mul0r addr0.\nby rewrite mulrDl addrA.\nQed.",
    "Lemma gactP : is_groupAction [set: 'Z_p * 'Z_p] action.\nProof.\nmove=> k _ /[1!inE]; apply/andP; split; first by apply/subsetP=> ij _ /[1!inE].\napply/morphicP=> /= [[i1 j1] [i2 j2] _ _].\nby rewrite !permE /= mulrDr -addrA (addrCA i2) (addrA i1).\nQed.",
    "Lemma card_pX1p2 : #|p^{1+2}| = (p ^ 3)%N.\nProof.\nrewrite [@gtype _]unlock -(sdprod_card (sdprod_sdpair _)).\nrewrite !card_injm ?injm_sdpair1 ?injm_sdpair2 // !cardsT card_prod card_ord.\nby rewrite -mulnA Zp_cast.\nQed.",
    "Lemma Grp_pX1p2 :\n  p^{1+2} \\isog Grp (x : y : x ^+ p, y ^+ p, [~ x, y, x], [~ x, y, y]).\nProof.\nrewrite [@gtype _]unlock; apply: intro_isoGrp => [|rT H].\n  apply/existsP; pose x := sdpair1 actp (0, 1)%R; pose y := sdpair2 actp 1%R.\n  exists (x, y); rewrite /= !xpair_eqE; set z := [~ x, y]; set G := _ <*> _.\n  have def_z: z = sdpair1 actp (1, 0)%R.\n    rewrite [z]commgEl -sdpair_act ?inE //=.\n    rewrite -morphV -?morphM ?inE //=; congr (sdpair1 _ (_, _)) => /=.\n      by rewrite mulr1 mulKg.\n    by rewrite mulVg.\n  have def_xi i: x ^+ i = sdpair1 actp (0, i%:R)%R.  \n    rewrite -morphX ?inE //; congr (sdpair1 _ _).\n    by apply/eqP; rewrite /eq_op /= !morphX ?inE ?expg1n //=.\n  have def_yi i: y ^+ i = sdpair2 actp i%:R.  \n    by rewrite -morphX ?inE //.\n  have def_zi i: z ^+ i = sdpair1 actp (i%:R, 0)%R.  \n    rewrite def_z -morphX ?inE //; congr (sdpair1 _ _).\n    by apply/eqP; rewrite /eq_op /= !morphX ?inE ?expg1n ?andbT //=.\n  rewrite def_xi def_yi pchar_Zp ?morph1 //.\n  rewrite def_z -morphR ?inE // !commgEl -sdpair_act ?inE //= mulr0 addr0.\n  rewrite mulVg -[_ * _]/(_ , _) /= !invg1 mulg1 !mul1g mulVg morph1 !andbT.\n  have Gx: x \\in G by rewrite -cycle_subG joing_subl.\n  have Gy: y \\in G by rewrite -cycle_subG joing_subr.\n  rewrite eqEsubset subsetT -im_sdpair mulG_subG /= -/G; apply/andP; split.\n    apply/subsetP=> u /morphimP[[i j] _ _ def_u].\n    suffices ->: u = z ^+ i * x ^+ j. \n      rewrite groupMl; apply/groupX; first exact: Gx.\n      by apply/groupR; first exact: Gx.\n    rewrite def_zi def_xi !natr_Zp -morphM ?inE // def_u.\n    by congr (sdpair1 _ (_, _)); rewrite ?mulg1 ?mul1g.\n  apply/subsetP=> v /morphimP[k _ _ def_v].\n  suffices ->: v = y ^+ k by rewrite groupX.\n  by rewrite def_yi natr_Zp.\ncase/existsP=> [[x y] /=]; set z := [~ x, y].\ncase/eqP=> defH xp yp /eqP/commgP czx /eqP/commgP czy.\nhave zp: z ^+ p = 1 by rewrite -commXg // xp comm1g.\npose f1 (ij : 'Z_p * 'Z_p) := let: (i, j) := ij in z ^+ i * x ^+ j.\nhave f1M: {in setT &, {morph f1 : u v / u * v}}.\n  case=> /= [i1 j1] [i2 j2] _ _ /=; rewrite {3 6}Zp_cast // !expg_mod //.\n  rewrite !expgD !mulgA; congr (_ * _); rewrite -!mulgA; congr (_ * _).\n  by apply: commuteX2.\npose f2 (k : 'Z_p) := y ^+ k.\nhave f2M: {in setT &, {morph f2 : u v / u * v}}.\n  by move=> k1 k2 _ _; rewrite /f2 /= {3}Zp_cast // expg_mod // expgD.\nhave actf: {in setT & setT, morph_act actp 'J (Morphism f1M) (Morphism f2M)}.\n  case=> /= i j k _ _; rewrite modnDmr {4}Zp_cast // expg_mod // expgD.\n  rewrite /f2 conjMg {1}/conjg (commuteX2 i k czy) mulKg -mulgA.\n  congr (_ * _); rewrite (commuteX2 _ _ czx) mulnC expgM.\n  by rewrite -commXg // -commgX ?mulKVg // commXg // /commute commuteX.\napply/homgP; exists (xsdprod_morphism actf).\napply/eqP; rewrite eqEsubset -{2}defH -genM_join gen_subG /= im_xsdprodm.\nhave Hx: x \\in H by rewrite -cycle_subG -defH joing_subl.\nhave Hy: y \\in H by rewrite -cycle_subG -defH joing_subr.\nrewrite mulG_subG -andbA; apply/and3P; split.\n- apply/subsetP=> _ /morphimP[[i j] _ _ -> /=].\n  by rewrite groupMl groupX ?groupR.\n- by apply/subsetP=> _ /morphimP[k _ _ ->]; rewrite groupX.\nrewrite mulgSS ?cycle_subG //= morphimEdom; apply/imsetP.\n  by exists (0, 1)%R; rewrite ?inE //= mul1g.\nby exists 1%R; rewrite ?inE.\nQed.",
    "Lemma pX1p2_pgroup : p.-group p^{1+2}.\nProof. by rewrite /pgroup card_pX1p2 pnatX pnat_id. Qed.",
    "Lemma pX1p2_extraspecial : extraspecial p^{1+2}.\nProof.\napply: (p3group_extraspecial pX1p2_pgroup); last first.\n  by rewrite card_pX1p2 pfactorK.\ncase/existsP: (isoGrp_hom Grp_pX1p2) card_pX1p2 => [[x y]] /=.\ncase/eqP=> <- xp yp _ _ oXY.\napply: contraL (dvdn_cardMg <[x]> <[y]>) => cXY_XY.\nrewrite -cent_joinEl ?(sub_abelian_cent2 cXY_XY) ?joing_subl ?joing_subr //.\nrewrite oXY -!orderE pfactor_dvdn ?muln_gt0 ?order_gt0 // -leqNgt.\nrewrite -(pfactorK 2 p_pr) dvdn_leq_log ?expn_gt0 ?p_gt0 //.\nby rewrite dvdn_mul ?order_dvdn ?xp ?yp.\nQed.",
    "Lemma exponent_pX1p2 : odd p -> exponent p^{1+2} %| p.\nProof.\nmove=> p_odd; have pG := pX1p2_pgroup.\nhave ->: p^{1+2} = 'Ohm_1(p^{1+2}).\n  apply/eqP; rewrite eqEsubset Ohm_sub andbT (OhmE 1 pG).\n  case/existsP: (isoGrp_hom Grp_pX1p2) => [[x y]] /=.\n  case/eqP=> <- xp yp _ _; rewrite joing_idl joing_idr genS //.\n  by rewrite subsetI subset_gen subUset !sub1set !inE xp yp!eqxx.\nrewrite exponent_Ohm1_class2 ?card_pX1p2 ?oddX // nil_class2.\nby have [[_ ->] _ ] := pX1p2_extraspecial.\nQed.",
    "Lemma isog_pX1p2 (gT : finGroupType) (G : {group gT}) :\n  extraspecial G -> exponent G %| p -> #|G| = (p ^ 3)%N -> G \\isog p^{1+2}.\nProof.\nmove=> esG expGp oG; apply/(isoGrpP _ Grp_pX1p2).\nrewrite card_pX1p2; split=> //.\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave oZ := card_center_extraspecial pG esG.\nhave [x Gx notZx]: exists2 x, x \\in G & x \\notin 'Z(G).\n  apply/subsetPn; rewrite proper_subn // properEcard center_sub oZ oG.\n  by rewrite (ltn_exp2l 1 3).\nhave ox: #[x] = p.\n  by apply: nt_prime_order; rewrite ?(exponentP expGp) ?(group1_contra notZx).\nhave [y Gy not_cxy]: exists2 y, y \\in G & y \\notin 'C[x].\n  by apply/subsetPn; rewrite sub_cent1; rewrite inE Gx in notZx.\napply/existsP; exists (x, y) => /=; set z := [~ x, y].\nhave [[defPhiG defG'] _] := esG.\nhave Zz: z \\in 'Z(G) by rewrite -defG' mem_commg.\nhave [Gz cGz] := setIP Zz; rewrite !xpair_eqE !(exponentP expGp) //.\nhave [_ nZG] := andP (center_normal G).\nrewrite /commg /conjg !(centP cGz) // !mulKg mulVg !eqxx !andbT.\nhave sXY_G: <[x]> <*> <[y]> \\subset G by rewrite join_subG !cycle_subG Gx.\nhave defZ: <[z]> = 'Z(G).\n  apply/eqP; rewrite eqEcard cycle_subG Zz oZ /= -orderE.\n  rewrite (nt_prime_order p_pr) ?(exponentP expGp) //.\n  by rewrite (sameP commgP cent1P) cent1C.\nhave sZ_XY: 'Z(G) \\subset <[x]> <*> <[y]>.\n  by rewrite -defZ cycle_subG groupR // mem_gen // inE cycle_id ?orbT.\nrewrite eqEcard sXY_G /= oG -(Lagrange sZ_XY) oZ leq_pmul2l //.\nrewrite -card_quotient ?(subset_trans sXY_G) //.\nrewrite quotientY ?quotient_cycle ?cycle_subG ?(subsetP nZG) //.\nhave abelGz: p.-abelem (G / 'Z(G)) by rewrite -defPhiG Phi_quotient_abelem.\nhave [cGzGz expGz] := abelemP p_pr abelGz.\nrewrite cent_joinEr ?(sub_abelian_cent2 cGzGz) ?cycle_subG ?mem_quotient //.\nhave oZx: #|<[coset 'Z(G) x]>| = p.\n  rewrite -orderE (nt_prime_order p_pr) ?expGz ?mem_quotient //.\n  by apply: contra notZx; move/eqP=> Zx; rewrite coset_idr ?(subsetP nZG).\nrewrite TI_cardMg ?oZx -?orderE ?(nt_prime_order p_pr) ?expGz ?mem_quotient //.\n  apply: contra not_cxy; move/eqP=> Zy.\n  rewrite -cent_cycle (subsetP _ y (coset_idr _ Zy)) ?(subsetP nZG) //.\n  by rewrite subIset ?centS ?orbT ?cycle_subG.\nrewrite prime_TIg ?oZx // cycle_subG; apply: contra not_cxy.\ncase/cycleP=> i; rewrite -morphX ?(subsetP nZG) // => /rcoset_kercosetP.\nrewrite groupX ?(subsetP nZG) // cent1C => /(_ isT isT); apply: subsetP.\nrewrite mul_subG ?sub1set ?groupX ?cent1id //= -cent_cycle subIset // orbC.\nby rewrite centS ?cycle_subG.\nQed.",
    "Lemma pX1p2id : p^{1+2*1} \\isog p^{1+2}.\nProof. exact: ncprod1. Qed.",
    "Lemma pX1p2S n : xcprod_spec p^{1+2} p^{1+2*n} p^{1+2*n.+1}%type.\nProof. exact: ncprodS. Qed.",
    "Lemma card_pX1p2n n : prime p -> #|p^{1+2*n}| = (p ^ n.*2.+1)%N.\nProof.\nmove=> p_pr; have pG := pX1p2_pgroup p_pr.\nhave oG := card_pX1p2 p_pr; have esG := pX1p2_extraspecial p_pr.\nhave oZ := card_center_extraspecial pG esG.\nelim: n => [|n IHn]; first by rewrite (card_isog (ncprod0 _)) oZ.\ncase: pX1p2S => gz isoZ; rewrite -im_cpair cardMg_divn setI_im_cpair.\nrewrite -injm_center ?{1}card_injm ?injm_cpairg1 ?injm_cpair1g ?center_sub //.\nby rewrite oG oZ IHn -expnD mulKn ?prime_gt0.\nQed.",
    "Lemma pX1p2n_pgroup n : prime p -> p.-group p^{1+2*n}.\nProof. by move=> p_pr; rewrite /pgroup card_pX1p2n // pnatX pnat_id. Qed.",
    "Lemma exponent_pX1p2n n : prime p -> odd p -> exponent p^{1+2*n} = p.\nProof.\nmove=> p_pr odd_p; apply: prime_nt_dvdP => //.\n  rewrite -dvdn1 -trivg_exponent -cardG_gt1 card_pX1p2n //.\n  by rewrite (ltn_exp2l 0) // prime_gt1.\nelim: n => [|n IHn].\n  by rewrite (dvdn_trans (exponent_dvdn _)) ?card_pX1p2n.\ncase: pX1p2S => gz isoZ; rewrite -im_cpair /=.\napply/exponentP=> xy; case/imset2P=> x y C1x C2y ->{xy}.\nrewrite expgMn; last by red; rewrite -(centsP (im_cpair_cent isoZ)).\nrewrite (exponentP _ y C2y) ?exponent_injm ?injm_cpair1g // mulg1.\nby rewrite (exponentP _ x C1x) ?exponent_injm ?injm_cpairg1 // exponent_pX1p2.\nQed.",
    "Lemma pX1p2n_extraspecial n : prime p -> n > 0 -> extraspecial p^{1+2*n}.\nProof.\nmove=> p_pr; elim: n => [//|n IHn _].\nhave esG := pX1p2_extraspecial p_pr.\nhave [n0 | n_gt0] := posnP n.\n  by apply: isog_extraspecial esG; rewrite isog_sym n0 pX1p2id.\ncase: pX1p2S (pX1p2n_pgroup n.+1 p_pr) => gz isoZ pGn.\napply: (cprod_extraspecial pGn (im_cpair_cprod isoZ) (setI_im_cpair isoZ)).\n  by apply: injm_extraspecial esG; rewrite ?injm_cpairg1.\nby apply: injm_extraspecial (IHn n_gt0); rewrite ?injm_cpair1g.\nQed.",
    "Lemma Ohm1_extraspecial_odd (gT : finGroupType) (G : {group gT}) :\n    p.-group G -> extraspecial G -> odd #|G| ->\n let Y := 'Ohm_1(G) in\n  [/\\ exponent Y = p, #|G : Y| %| p\n    & Y != G ->\n      exists E : {group gT},\n        [/\\ #|G : Y| = p, #|E| = p \\/ extraspecial E,\n            exists2 X : {group gT}, #|X| = p & X \\x E = Y\n          & exists M : {group gT},\n             [/\\ M \\isog 'Mod_(p ^ 3), M \\* E = G & M :&: E = 'Z(M)]]].\nProof.\nmove=> pG esG oddG Y; have [spG _] := esG.\nhave [defPhiG defG'] := spG; set Z := 'Z(G) in defPhiG defG'.\nhave{spG} expG: exponent G %| p ^ 2 by apply: exponent_special.\nhave p_pr := extraspecial_prime pG esG.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave oZ: #|Z| = p := card_center_extraspecial pG esG.\nhave nsZG: Z <| G := center_normal G; have [sZG nZG] := andP nsZG.\nhave nsYG: Y <| G := Ohm_normal 1 G; have [sYG nYG] := andP nsYG.\nhave ntZ: Z != 1 by rewrite -cardG_gt1 oZ.\nhave sZY: Z \\subset Y.\n  by apply: contraR ntZ => ?; rewrite -(setIidPl sZG) TI_Ohm1 ?prime_TIg ?oZ.\nhave ntY: Y != 1 by apply: subG1_contra ntZ.\nhave p_odd: odd p by rewrite -oZ (oddSg sZG).\nhave expY: exponent Y %| p by rewrite exponent_Ohm1_class2 // nil_class2 defG'.\nrewrite (prime_nt_dvdP p_pr _ expY) -?dvdn1 -?trivg_exponent //.\nhave [-> | neYG] := eqVneq Y G; first by rewrite indexgg dvd1n; split.\nhave sG1Z: 'Mho^1(G) \\subset Z by rewrite -defPhiG (Phi_joing pG) joing_subr.\nhave Z_Gp: {in G, forall x, x ^+ p \\in Z}.\n  by move=> x Gx; rewrite /= (subsetP sG1Z) ?(Mho_p_elt 1) ?(mem_p_elt pG).\nhave{expG} oY': {in G :\\: Y, forall u, #[u] = (p ^ 2)%N}.\n  move=> u /setDP[Gu notYu]; apply/eqP.\n  have [k ou] := p_natP (mem_p_elt pG Gu).\n  rewrite eqn_dvd order_dvdn (exponentP expG) // eqxx ou dvdn_Pexp2l // ltnNge.\n  apply: contra notYu => k_le_1; rewrite [Y](OhmE _ pG) mem_gen // !inE Gu /=.\n  by rewrite -order_dvdn ou dvdn_exp2l.\nhave isoMod3 (M : {group gT}):\n    M \\subset G -> ~~ abelian M -> ~~ (M \\subset Y) -> #|M| = (p ^ 3)%N ->\n  M \\isog 'Mod_(p ^ 3).\n- move=> sMG not_cMM /subsetPn[u Mu notYu oM].\n  have pM := pgroupS sMG pG; have sUM: <[u]> \\subset M by rewrite cycle_subG.\n  have Y'u: u \\in G :\\: Y by rewrite inE notYu (subsetP sMG).\n  have iUM: #|M : <[u]>| = p by rewrite -divgS // oM expnS -(oY' u) ?mulnK.\n  have cM := maximal_cycle_extremal pM not_cMM (cycle_cyclic u) sUM iUM.\n  rewrite (sameP eqP (prime_oddPn p_pr)) p_odd orbF in cM.\n  rewrite /extremal_class oM pdiv_pfactor // pfactorK //= in cM.\n  by do 3!case: ifP => // _ in cM.\nhave iYG: #|G : Y| = p.\n  have [V maxV sYV]: {V : {group gT} | maximal V G & Y \\subset V}.\n    by apply: maxgroup_exists; rewrite properEneq neYG.\n  have [sVG [u Gu notVu]] := properP (maxgroupp maxV).\n  without loss [v Vv notYv]: / exists2 v, v \\in V & v \\notin Y.\n    have [->| ] := eqVneq Y V; first by rewrite (p_maximal_index pG).\n    by rewrite eqEsubset sYV => not_sVY; apply; apply/subsetPn.\n  pose U := <[u]> <*> <[v]>; have Gv := subsetP sVG v Vv.\n  have sUG: U \\subset G by rewrite join_subG !cycle_subG Gu.\n  have Uu: u \\in U by rewrite -cycle_subG joing_subl.\n  have Uv: v \\in U by rewrite -cycle_subG joing_subr.\n  have not_sUY: ~~ (U \\subset Y) by apply/subsetPn; exists v.\n  have sU1U: 'Ohm_1(U) \\subset U := Ohm_sub 1 _.\n  have sU1Y: 'Ohm_1(U) \\subset Y := OhmS 1 sUG.\n  suffices defUV: U :&: V = 'Ohm_1(U).\n    by rewrite (subsetP sU1Y) // -defUV inE Uv in notYv.\n  suffices iU1U: #|U : 'Ohm_1(U)| = p.\n    have: maximal 'Ohm_1(U) U by rewrite p_index_maximal ?Ohm_sub ?iU1U.\n    case/maxgroupP=> _; apply; rewrite /= -/U.\n      by apply/properP; split; last exists u; rewrite ?subsetIl ?inE ?Uu.\n    by rewrite subsetI Ohm_sub (subset_trans sU1Y).\n  apply/prime_nt_dvdP=> //.\n    by apply: contra not_sUY; rewrite /U; move/eqP; move/(index1g sU1U)=> <-.\n  have ov: #[v] = (p ^ 2)%N by rewrite oY' // inE notYv.\n  have sZv: Z \\subset <[v]>.\n    suffices defZ: <[v ^+ p]> == Z by rewrite -(eqP defZ) cycleX.\n    by rewrite eqEcard cycle_subG Z_Gp //= oZ -orderE (orderXexp 1 ov).\n  have nvG: G \\subset 'N(<[v]>) by rewrite sub_der1_norm ?cycle_subG // defG'.\n  have [cUU | not_cUU] := orP (orbN (abelian U)).\n    rewrite -divgS ?Ohm_sub // -(mul_card_Ohm_Mho_abelian 1 cUU) /= -/U.\n    by rewrite mulKn ?cardG_gt0 //= -oZ cardSg ?(subset_trans (MhoS 1 sUG)).\n  have oU: #|U| = (p ^ 3)%N.\n    have nvu := subsetP nvG u Gu; have nvU := subset_trans sUG nvG.\n    rewrite -(Lagrange (joing_subr _ _)) -orderE ov mulnC; congr (_ * _)%N.\n    rewrite -card_quotient //= quotientYidr ?cycle_subG //=.\n    rewrite quotient_cycle // -orderE; apply: nt_prime_order => //.\n      by rewrite -morphX //= coset_id // (subsetP sZv) // Z_Gp.\n    have svV: <[v]> \\subset V by rewrite cycle_subG.\n    by apply: contra notVu; move/eqP=> v_u; rewrite (subsetP svV) // coset_idr.\n  have isoU := isoMod3 _ sUG not_cUU not_sUY oU; rewrite /= -/U in isoU.\n  have [//|[x y] genU modU] := generators_modular_group p_pr _ isoU.\n  case/modular_group_structure: genU => // _ _ _ _.\n  case: eqP (p_odd) => [[-> //] | _ _]; case/(_ 1%N)=> // _ oU1.\n  by rewrite -divgS // oU oU1 mulnK // muln_gt0 p_gt0.\nhave iC1U (U : {group gT}) x:\n  U \\subset G -> x \\in G :\\: 'C(U) -> #|U : 'C_U[x]| = p.\n- move=> sUG /setDP[Gx not_cUx]; apply/prime_nt_dvdP=> //.\n    apply: contra not_cUx; rewrite -sub_cent1 => /eqP sUCx.\n    by rewrite -(index1g _ sUCx) ?subsetIl ?subsetIr.\n  rewrite -(@dvdn_pmul2l (#|U| * #|'C_G[x]|)) ?muln_gt0 ?cardG_gt0 //.\n  have maxCx: maximal 'C_G[x] G.\n    rewrite cent1_extraspecial_maximal //; apply: contra not_cUx.\n    by rewrite inE Gx; apply: subsetP (centS sUG) _.\n  rewrite {1}mul_cardG setIA (setIidPl sUG) -(p_maximal_index pG maxCx) -!mulnA.\n  rewrite !Lagrange ?subsetIl // mulnC dvdn_pmul2l //.\n  have [sCxG nCxG] := andP (p_maximal_normal pG maxCx).\n  by rewrite -norm_joinEl ?cardSg ?join_subG ?(subset_trans sUG).\nhave oCG (U : {group gT}):\n  Z \\subset U -> U \\subset G -> #|'C_G(U)| = (p * #|G : U|)%N.\n- have [m] := ubnP #|U|; elim: m U => // m IHm U leUm sZU sUG.\n  have [<- | neZU] := eqVneq Z U.\n    by rewrite -oZ Lagrange // (setIidPl _) // centsC subsetIr.\n  have{neZU} [x Gx not_cUx]: exists2 x, x \\in G & x \\notin 'C(U).\n    by apply/subsetPn; rewrite eqEsubset sZU subsetI sUG centsC in neZU.\n  pose W := 'C_U[x]; have iWU: #|U : W| = p by rewrite iC1U // inE not_cUx.\n  have maxW: maximal W U by rewrite p_index_maximal ?subsetIl ?iWU.\n  have ltWU: W \\proper U by apply: maxgroupp maxW.\n  have [sWU [u Uu notWu]] := properP ltWU.\n  have defU: W * <[u]> = U.\n    have nsWU: W <| U := p_maximal_normal (pgroupS sUG pG) maxW.\n    by rewrite (mulg_normal_maximal nsWU) ?cycle_subG.\n  have sWG := subset_trans sWU sUG.\n  have sZW: Z \\subset W.\n    by rewrite subsetI sZU -cent_set1 subIset ?centS ?orbT ?sub1set.\n  have iCW_CU: #|'C_G(W) : 'C_G(U)| = p.\n    rewrite -defU centM cent_cycle setIA /= -/W.\n    rewrite iC1U ?subsetIl ?setIS ?centS // inE andbC (subsetP sUG) //=.\n    rewrite -sub_cent1; apply/subsetPn; exists x.\n      by rewrite inE Gx -sub_cent1 subsetIr.\n    by rewrite -defU centM cent_cycle inE -sub_cent1 subsetIr in not_cUx.\n  apply/eqP; rewrite -(eqn_pmul2r p_gt0) -{1}iCW_CU Lagrange ?setIS ?centS //.\n  rewrite IHm ?(leq_trans (proper_card ltWU)) //= -/W.\n  by rewrite -(Lagrange_index sUG sWU) iWU mulnA.\nhave oCY: #|'C_G(Y)| = (p ^ 2)%N by rewrite oCG // iYG.\nhave [x cYx notZx]: exists2 x, x \\in 'C_G(Y) & x \\notin Z.\n  apply/subsetPn; rewrite proper_subn // properEcard setIS ?centS //=.\n  by rewrite oZ oCY (ltn_exp2l 1 2).\nhave{cYx} [Gx cYx] := setIP cYx; have nZx := subsetP nZG x Gx.\nhave defCx: 'C_G[x] = Y.\n  apply/eqP; rewrite eq_sym eqEcard subsetI sYG sub_cent1 cYx /=.\n  rewrite -(leq_pmul2r p_gt0) -{2}iYG -(iC1U G x) ?Lagrange ?subsetIl //.\n  by rewrite !inE Gx ?andbT in notZx *.\nhave Yx: x \\in Y by rewrite -defCx inE Gx cent1id.\nhave ox: #[x] = p.\n  by apply: nt_prime_order; rewrite ?(exponentP expY) // (group1_contra notZx).\nhave defCy: 'C_G(Y) = Z * <[x]>.\n  apply/eqP; rewrite eq_sym eqEcard mulG_subG setIS ?centS //=.\n  rewrite cycle_subG inE Gx cYx oCY TI_cardMg ?oZ -?orderE ?ox //=.\n  by rewrite setIC prime_TIg -?orderE ?ox ?cycle_subG.\nhave abelYt: p.-abelem (Y / Z).\n  by rewrite (abelemS (quotientS _ sYG)) //= -/Z -defPhiG Phi_quotient_abelem.\nhave Yxt: coset Z x \\in Y / Z by rewrite mem_quotient.\nhave{Yxt} [Et [sEtYt oEt defYt]] := p_abelem_split1 abelYt Yxt.\nhave nsZY: Z <| Y := normalS sZY sYG nsZG.\nhave [E defEt sZE sEY] := inv_quotientS nsZY sEtYt.\nhave{defYt} [_ defYt _ tiXEt] := dprodP defYt.\nhave defY: <[x]> \\x E = Y.\n  have nZX: <[x]> \\subset 'N(Z) by rewrite cycle_subG.\n  have TIxE: <[x]> :&: E = 1.\n    rewrite prime_TIg -?orderE ?ox // -(quotientSGK _ sZE) ?quotient_cycle //.\n    rewrite (sameP setIidPl eqP) eq_sym -defEt tiXEt -quotient_cycle //.\n    by rewrite -subG1 quotient_sub1 // cycle_subG.\n  rewrite dprodE //; last 1 first.\n    by rewrite cent_cycle (subset_trans sEY) //= -/Y -defCx subsetIr.\n  rewrite -[Y](quotientGK nsZY) -defYt cosetpreM -quotient_cycle //.\n  rewrite quotientK // -(normC nZX) defEt quotientGK ?(normalS _ sEY) //.\n  by rewrite -mulgA (mulSGid sZE).\nhave sEG := subset_trans sEY sYG; have nZE := subset_trans sEG nZG.\nhave defZE: 'Z(E) = Z.\n  apply/eqP; rewrite eqEsubset andbC subsetI sZE subIset ?centS ?orbT //.\n  rewrite -quotient_sub1 ?subIset ?nZE //= -tiXEt defEt subsetI andbC.\n  rewrite quotientS ?center_sub //= -quotient_cycle //.\n  rewrite -(quotientMidl _ <[x]>) /= -defCy quotientS // /Y.\n  by case/dprodP: defY => _ <- _ _; rewrite centM setIA cent_cycle defCx setSI.\nhave pE := pgroupS sEG pG.\nrewrite iYG; split=> // _; exists E.\nsplit=> //; first 2 [by exists [group of <[x]>]].\n  have:= sZE; rewrite subEproper; case/predU1P=> [<- | ltZE]; [by left | right].\n  split; rewrite /special defZE ?oZ // (Phi_joing pE).\n  have defE': E^`(1) = Z.\n    have sE'Z: E^`(1) \\subset Z by rewrite -defG' dergS.\n    apply/eqP; rewrite eqEcard sE'Z -(prime_nt_dvdP _ _ (cardSg sE'Z)) ?oZ //=.\n    rewrite -trivg_card1 (sameP eqP commG1P).\n    by rewrite /proper sZE /= -/Z -defZE subsetI subxx in ltZE.\n  split=> //; rewrite -defE'; apply/joing_idPl.\n  by rewrite /= defE' -defPhiG (Phi_joing pG) joingC sub_gen ?subsetU ?MhoS.\nhave iEG: #|G : E| = (p ^ 2)%N.\n  apply/eqP; rewrite -(@eqn_pmul2l #|E|) // Lagrange // -(Lagrange sYG) iYG.\n  by rewrite -(dprod_card defY) -mulnA mulnCA -orderE ox.\npose M := 'C_G(E); exists [group of M] => /=.\nhave sMG: M \\subset G := subsetIl _ _; have pM: p.-group M := pgroupS sMG pG.\nhave sZM: Z \\subset M by rewrite setIS ?centS.\nhave oM: #|M| = (p ^ 3)%N by rewrite oCG ?iEG.\nhave defME: M * E = G.\n  apply/eqP; rewrite eqEcard mulG_subG sMG sEG /= -(leq_pmul2r p_gt0).\n  rewrite -{2}oZ -defZE /('Z(E)) -{2}(setIidPr sEG) setIAC -mul_cardG /= -/M.\n  by rewrite -(Lagrange sEG) mulnAC -mulnA mulnC iEG oM.\nhave defZM: 'Z(M) = Z.\n  apply/eqP; rewrite eqEsubset andbC subsetI sZM subIset ?centS ?orbT //=.\n  by rewrite /Z /('Z(G)) -{2}defME centM setIA setIAC.\nrewrite cprodE 1?centsC ?subsetIr //.\nrewrite defME setIAC (setIidPr sEG) defZM isoMod3 //.\n  rewrite abelianE (sameP setIidPl eqP) eqEcard subsetIl /= -/('Z(M)) -/M.\n  by rewrite defZM oZ oM (leq_exp2l 3 1).\nby apply: contra neYG => sMY; rewrite eqEsubset sYG -defME mulG_subG sMY.\nQed.",
    "Lemma isog_pX1p2n n (gT : finGroupType) (G : {group gT}) :\n    prime p -> extraspecial G -> #|G| = (p ^ n.*2.+1)%N -> exponent G %| p ->\n  G \\isog p^{1+2*n}.\nProof.\nmove=> p_pr esG oG expG; have p_gt1 := prime_gt1 p_pr.\nhave not_le_p3_p: ~~ (p ^ 3 <= p) by rewrite (leq_exp2l 3 1).\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave oZ := card_center_extraspecial pG esG.\nhave{pG esG} [Es p3Es defG] := extraspecial_structure pG esG.\nset Z := 'Z(G) in oZ defG p3Es.\nelim: Es {+}G => [|E Es IHs] S in n oG expG p3Es defG *.\n  rewrite big_nil cprod1g in defG; rewrite -defG.\n  have ->: n = 0.\n    apply: double_inj; apply/eqP.\n    by rewrite -eqSS -(eqn_exp2l _ _ p_gt1) -oG -defG oZ.\n  by rewrite isog_cyclic_card prime_cyclic ?oZ ?card_pX1p2n //=.\nrewrite big_cons -cprodA in defG; rewrite /= -andbA in p3Es.\nhave [[_ T _ defT] defET cTE] := cprodP defG; rewrite defT in defET cTE defG.\nmove: p3Es => /and3P[/eqP oE /eqP defZE /IHs{}IHs].\nhave not_cEE: ~~ abelian E.\n  by apply: contra not_le_p3_p => cEE; rewrite -oE -oZ -defZE (center_idP _).\nhave sES: E \\subset S by rewrite -defET mulG_subl.\nhave sTS: T \\subset S by rewrite -defET mulG_subr.\nhave expE: exponent E %| p by apply: dvdn_trans (exponentS sES) expG.\nhave expT: exponent T %| p by apply: dvdn_trans (exponentS sTS) expG.\nhave{expE not_cEE} isoE: E \\isog p^{1+2}.\n  apply: isog_pX1p2 => //.\n  by apply: card_p3group_extraspecial p_pr oE _; rewrite defZE.\nhave sZT: 'Z(E) \\subset T.\n  by case/cprodP: defT => [[U _ -> _] <- _]; rewrite defZE mulG_subr.\ncase def_n: n => [|n'].\n  case/negP: not_le_p3_p; rewrite def_n in oG; rewrite -oE -[p]oG.\n  exact: subset_leq_card.\nhave zI_ET: E :&: T = 'Z(E).\n  by apply/eqP; rewrite eqEsubset subsetI sZT subsetIl setIS // centsC.\nhave{n def_n oG} oT: #|T| = (p ^ n'.*2.+1)%N.\n  apply/eqP; rewrite -(eqn_pmul2l (cardG_gt0 E)) mul_cardG zI_ET defET.\n  by rewrite defZE oE oG oZ -expnSr -expnD def_n.\nhave{IHs oT expT defT Es} isoT: T \\isog p^{1+2*n'} by rewrite IHs.\ncase: pX1p2S => gz isoZ; rewrite (isog_cprod_by _ defG) //.\nexact: Aut_extraspecial_full (pX1p2_pgroup p_pr) (pX1p2_extraspecial p_pr).\nQed.",
    "Lemma isog_2X1p2 : 2^{1+2} \\isog 'D_8.\nProof.\nhave pr2: prime 2 by []; have oG := card_pX1p2 pr2; rewrite -[8]oG.\ncase/existsP: (isoGrp_hom (Grp_pX1p2 pr2)) => [[x y]] /=.\nrewrite -/2^{1+2}; case/eqP=> defG x2 y2 _ _.\nhave not_oG_2: ~~ (#|2^{1+2}| %| 2) by rewrite oG.\nhave ox: #[x] = 2.\n  apply: nt_prime_order => //; apply: contra not_oG_2 => x1.\n  by rewrite -defG (eqP x1) cycle1 joing1G order_dvdn y2.\nhave oy: #[y] = 2.\n  apply: nt_prime_order => //; apply: contra not_oG_2 => y1.\n  by rewrite -defG (eqP y1) cycle1 joingG1 order_dvdn x2.\nrewrite -defG joing_idl joing_idr involutions_gen_dihedral //.\napply: contra not_oG_2 => eq_xy; rewrite -defG (eqP eq_xy) (joing_idPl _) //.\nby rewrite -orderE oy.\nQed.",
    "Lemma Q8_extraspecial : extraspecial 'Q_8.\nProof.\nhave gt32: 3 > 2 by []; have isoQ: 'Q_8 \\isog 'Q_(2 ^ 3) by apply: isog_refl.\nhave [[x y] genQ _] := generators_quaternion gt32 isoQ.\nhave [_ [defQ' defPhiQ _ _]] := quaternion_structure gt32 genQ isoQ.\ncase=> defZ oZ _ _ _ _ _; split; last by rewrite oZ.\nby split; rewrite ?defPhiQ defZ.\nQed.",
    "Lemma DnQ_P n : xcprod_spec 'D^n 'Q_8 ('D^n*Q)%type.\nProof.\nhave pQ: 2.-group 'Q_(2 ^ 3) by rewrite /pgroup card_quaternion.\nhave{pQ} oZQ := card_center_extraspecial pQ Q8_extraspecial.\nsuffices oZDn: #|'Z('D^n)| = 2.\n  by apply: xcprodP; rewrite isog_cyclic_card ?prime_cyclic ?oZQ ?oZDn.\nhave [-> | n_gt0] := posnP n; first by rewrite center_ncprod0 card_pX1p2n.\nhave pr2: prime 2 by []; have pDn := pX1p2n_pgroup n pr2.\nexact: card_center_extraspecial (pX1p2n_extraspecial pr2 n_gt0).\nQed.",
    "Lemma card_DnQ n : #|'D^n*Q| = (2 ^ n.+1.*2.+1)%N.\nProof.\nhave oQ: #|'Q_(2 ^ 3)| = 8 by rewrite card_quaternion.\nhave pQ: 2.-group 'Q_8 by rewrite /pgroup oQ.\ncase: DnQ_P => gz isoZ.\nrewrite -im_cpair cardMg_divn setI_im_cpair cpair_center_id.\nrewrite -injm_center//; last exact: injm_cpair1g.\nrewrite (card_injm (injm_cpairg1 _))// (card_injm (injm_cpair1g _))//.\nrewrite (card_injm (injm_cpair1g _))//; last exact: center_sub.\nrewrite oQ card_pX1p2n // (card_center_extraspecial pQ Q8_extraspecial).\nby rewrite -muln_divA // mulnC -(expnD 2 2).\nQed.",
    "Lemma DnQ_pgroup n : 2.-group 'D^n*Q.\nProof. by rewrite /pgroup card_DnQ pnatX. Qed.",
    "Lemma DnQ_extraspecial n : extraspecial 'D^n*Q.\nProof.\ncase: DnQ_P (DnQ_pgroup n) => gz isoZ pDnQ.\nhave [injDn injQ] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\nhave [n0 | n_gt0] := posnP n.\n  rewrite -im_cpair mulSGid; first exact: injm_extraspecial Q8_extraspecial.\n  apply/setIidPl; rewrite setI_im_cpair -injm_center //=.\n  by congr (_ @* _); rewrite n0 center_ncprod0.\napply: (cprod_extraspecial pDnQ (im_cpair_cprod isoZ) (setI_im_cpair _)).\n  exact: injm_extraspecial (pX1p2n_extraspecial _ _).\nexact: injm_extraspecial Q8_extraspecial.\nQed.",
    "Lemma card_isog8_extraspecial (gT : finGroupType) (G : {group gT}) :\n  #|G| = 8 -> extraspecial G -> (G \\isog 'D_8) || (G \\isog 'Q_8).\nProof.\nmove=> oG esG; have pG: 2.-group G by rewrite /pgroup oG.\napply/norP=> [[notG_D8 notG_Q8]].\nhave not_extG: extremal_class G = NotExtremal.\n  by rewrite /extremal_class oG andFb (negPf notG_D8) (negPf notG_Q8).\nhave [x Gx ox] := exponent_witness (pgroup_nil pG).\npose X := <[x]>; have cycX: cyclic X := cycle_cyclic x.\nhave sXG: X \\subset G by rewrite cycle_subG.\nhave iXG: #|G : X| = 2.\n  by rewrite -divgS // oG -orderE -ox exponent_2extraspecial.\nhave not_cGG := extraspecial_nonabelian esG.\nhave:= maximal_cycle_extremal pG not_cGG cycX sXG iXG.\nby rewrite /extremal2 not_extG.\nQed.",
    "Lemma isog_2extraspecial (gT : finGroupType) (G : {group gT}) n :\n  #|G| = (2 ^ n.*2.+1)%N -> extraspecial G -> G \\isog 'D^n \\/ G \\isog 'D^n.-1*Q.\nProof.\nelim: n G => [|n IHn] G oG esG.\n  case/negP: (extraspecial_nonabelian esG).\n  by rewrite cyclic_abelian ?prime_cyclic ?oG.\nhave pG: 2.-group G by rewrite /pgroup oG pnatX.\nhave oZ:= card_center_extraspecial pG esG.\nhave: 'Z(G) \\subset 'Ohm_1(G).\n  apply/subsetP=> z Zz; rewrite (OhmE _ pG) mem_gen //.\n  by rewrite !inE -order_dvdn -oZ order_dvdG ?(subsetP (center_sub G)).\nrewrite subEproper; case/predU1P=> [defG1 | ltZG1].\n  have [n' n'_gt2 isoG]: exists2 n', n' > 2 & G \\isog 'Q_(2 ^ n').\n    apply/quaternion_classP; apply/eqP.\n    have not_cycG: ~~ cyclic G.\n      by apply: contra (extraspecial_nonabelian esG); apply: cyclic_abelian.\n    move: oZ; rewrite defG1; move/prime_Ohm1P; rewrite (negPf not_cycG) /=.\n    by apply=> //; apply: contra not_cycG; move/eqP->; apply: cyclic1.\n  have [n0 n'3]: n = 0 /\\ n' = 3.\n    have [[x y] genG _] := generators_quaternion n'_gt2 isoG.\n    have n'3: n' = 3.\n      have [_ [_ _ oG' _] _ _ _] := quaternion_structure n'_gt2 genG isoG.\n      apply/eqP; rewrite -(subnKC (ltnW n'_gt2)) subn2 !eqSS -(@eqn_exp2l 2) //.\n      by rewrite -oG' -oZ; case: esG => [[_ ->]].\n    by move/eqP: oG; have [-> _ _ _] := genG; rewrite n'3 eqn_exp2l //; case n.\n  right; rewrite (isog_trans isoG) // n'3 n0 /=.\n  case: DnQ_P => z isoZ; rewrite -im_cpair mulSGid ?sub_isog ?injm_cpair1g //.\n  apply/setIidPl; rewrite setI_im_cpair -injm_center ?injm_cpairg1 //.\n  by rewrite center_ncprod0.\ncase/andP: ltZG1 => _; rewrite (OhmE _ pG) gen_subG.\ncase/subsetPn=> x; case/LdivP=> Gx x2 notZx.\nhave ox: #[x] = 2 by apply: nt_prime_order (group1_contra notZx).\nhave Z'x: x \\in G :\\: 'Z(G) by rewrite inE notZx.\nhave [E [R [[oE oR] [defG ziER]]]] := split1_extraspecial pG esG Z'x.\ncase=> defZE defZR [esE Ex] esR.\nhave isoE: E \\isog 2^{1+2}.\n  apply: isog_trans (isog_symr isog_2X1p2).\n  case/orP: (card_isog8_extraspecial oE esE) => // isoE; case/negP: notZx.\n  have gt32: 3 > 2 by [].\n  have [[y z] genE _] := generators_quaternion gt32 isoE.\n  have [_ _ [defZx _ eq_y2 _ _] _ _] := quaternion_structure gt32 genE isoE.\n  by rewrite (eq_y2 x) // -cycle_subG -defZx defZE.\nrewrite oG doubleS 2!expnS divnMl ?mulKn // in oR.\ncase: ifP esR => [_ defR | _ esR].\n  have ->: n = 0 by move/eqP: oR; rewrite defR oZ (eqn_exp2l 1) //; case n.\n  left; apply: isog_trans (isog_symr (ncprod1 _)).\n  by rewrite -defG defR -defZE cprod_center_id.\nhave AutZin2_1p2: Aut_in (Aut 2^{1+2}) 'Z(2^{1+2}) \\isog Aut 'Z(2^{1+2}).\n  exact: Aut_extraspecial_full (pX1p2_pgroup _) (pX1p2_extraspecial _).\nhave [isoR | isoR] := IHn R oR esR.\n  by left; case: pX1p2S => gz isoZ; rewrite (isog_cprod_by _ defG).\nhave n_gt0: n > 0.\n  have pR: 2.-group R by rewrite /pgroup oR pnatX.\n  have:= min_card_extraspecial pR esR.\n  by rewrite oR leq_exp2l // ltnS (leq_double 1).\ncase: DnQ_P isoR => gR isoZR /=; rewrite isog_sym; case/isogP=> fR injfR im_fR.\nhave [injDn injQ] := (injm_cpairg1 isoZR, injm_cpair1g isoZR).\npose Dn1 := cpairg1 isoZR @* 'D^n.-1; pose Q := cpair1g isoZR @* 'Q_8.\nhave defR: fR @* Dn1 \\* fR @* Q = R.\n  rewrite cprodE ?morphim_cents ?im_cpair_cent //.\n  by rewrite -morphimMl ?subsetT ?im_cpair.\nrewrite -defR cprodA in defG.\nhave [[Dn _ defDn _] _ _] := cprodP defG; rewrite defDn in defG.\nhave isoDn: Dn \\isog 'D^n.\n  rewrite -(prednK n_gt0); case: pX1p2S => gz isoZ.\n  rewrite (isog_cprod_by _ defDn) //; last 1 first.\n    by rewrite isog_sym (isog_trans _ (sub_isog _ _)) ?subsetT // sub_isog.\n  rewrite /= -morphimIim im_fR setIA ziER; apply/setIidPl.\n  rewrite defZE -defZR -{1}im_fR -injm_center // morphimS //.\n  by rewrite -cpairg1_center morphimS // center_sub.\nright; case: DnQ_P => gz isoZ; rewrite (isog_cprod_by _ defG) //; first 1 last.\n- exact: Aut_extraspecial_full (pX1p2n_pgroup _ _) (pX1p2n_extraspecial _ _).\n- by rewrite isog_sym (isog_trans _ (sub_isog _ _)) ?subsetT // sub_isog.\nrewrite /= -morphimIim; case/cprodP: defDn => _ defDn cDn1E.\nrewrite setICA setIA -defDn -group_modr ?morphimS ?subsetT //.\nrewrite /= im_fR (setIC R) ziER -center_prod // defZE -defZR.\nrewrite mulSGid /=; last first.\n  by rewrite -{1}im_fR -injm_center // -cpairg1_center !morphimS ?center_sub.\nrewrite -injm_center ?subsetT // -injmI // setI_im_cpair.\nby rewrite -injm_center // cpairg1_center injm_center // im_fR mulGid.\nQed.",
    "Lemma rank_Dn n : 'r_2('D^n) = n.+1.\nProof.\nelim: n => [|n IHn]; first by rewrite p_rank_abelem ?prime_abelem ?card_pX1p2n.\nhave oDDn: #|'D^n.+1| = (2 ^ n.+1.*2.+1)%N by apply: card_pX1p2n.\nhave esDDn: extraspecial 'D^n.+1 by apply: pX1p2n_extraspecial.\ndo [case: pX1p2S => gz isoZ; set DDn := [set: _]] in oDDn esDDn *.\nhave pDDn: 2.-group DDn by rewrite /pgroup oDDn pnatX.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  have [E EprE]:= p_rank_witness 2 [group of DDn].\n  have [sEDDn abelE <-] := pnElemP EprE; have [pE cEE _]:= and3P abelE.\n  rewrite -(@leq_exp2l 2) // -p_part part_pnat_id // -leq_sqr -expnM -mulnn.\n  rewrite muln2 doubleS expnS -oDDn -(@leq_pmul2r #|'C_DDn(E)|) ?cardG_gt0 //.\n  rewrite {1}(card_subcent_extraspecial pDDn) // mulnCA -mulnA Lagrange //=.\n  rewrite mulnAC mulnA leq_pmul2r ?cardG_gt0 // setTI.\n  have ->: (2 * #|'C(E)| = #|'Z(DDn)| * #|'C(E)|)%N.\n    by rewrite (card_center_extraspecial pDDn).\n  by rewrite leq_mul ?subset_leq_card ?subsetIl.\nhave [inj1 injn] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\npose D := cpairg1 isoZ @* 2^{1+2}; pose Dn := cpair1g isoZ @* 'D^n.\nhave [E EprE] := p_rank_witness 2 [group of Dn].\nrewrite injm_p_rank //= IHn in EprE; have [sEDn abelE dimE]:= pnElemP EprE.\nhave [x [Dx ox] notDnx]: exists x, [/\\ x \\in D, #[x] = 2 & x \\notin Dn].\n  have isoD: D \\isog 'D_(2 ^ 3).\n    by rewrite isog_sym -(isog_transl _ isog_2X1p2) sub_isog.\n  have [//| [x y] genD [oy _]] := generators_2dihedral _ isoD.\n  have [_ _ _ X'y] := genD; case/setDP: X'y; rewrite /= -/D => Dy notXy.\n  exists y; split=> //; apply: contra notXy => Dny.\n  case/dihedral2_structure: genD => // _ _ _ _ [defZD _ _ _ _].\n  by rewrite (subsetP (cycleX x 2)) // -defZD -setI_im_cpair inE Dy.\nhave def_xE: <[x]> \\x E = <[x]> <*> E.\n  rewrite dprodEY ?prime_TIg -?orderE ?ox //.\n    by rewrite (centSS sEDn _ (im_cpair_cent _)) ?cycle_subG.\n  by rewrite cycle_subG (contra (subsetP sEDn x)).\napply/p_rank_geP; exists (<[x]> <*> E)%G.\nrewrite 2!inE subsetT (dprod_abelem _ def_xE) abelE -(dprod_card def_xE).\nby rewrite prime_abelem -?orderE ?ox //= lognM ?cardG_gt0 ?dimE.\nQed.",
    "Lemma rank_DnQ n : 'r_2('D^n*Q) = n.+1.\nProof.\nhave pDnQ: 2.-group 'D^n*Q := DnQ_pgroup n.\nhave esDnQ: extraspecial 'D^n*Q := DnQ_extraspecial n.\ndo [case: DnQ_P => gz isoZ; set DnQ := setT] in pDnQ esDnQ *.\nsuffices [E]: exists2 E, E \\in 'E*_2(DnQ) & logn 2 #|E| = n.+1.\n  by rewrite (pmaxElem_extraspecial pDnQ esDnQ); case/pnElemP=> _ _ <-.\nhave oZ: #|'Z(DnQ)| = 2 by apply: card_center_extraspecial.\npose Dn := cpairg1 isoZ @* 'D^n; pose Q := cpair1g isoZ @* 'Q_8.\nhave [injDn injQ] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\nhave [E EprE]:= p_rank_witness 2 [group of Dn].\nhave [sEDn abelE dimE] := pnElemP EprE; have [pE cEE eE]:= and3P abelE.\nrewrite injm_p_rank // rank_Dn in dimE; exists E => //.\nhave sZE: 'Z(DnQ) \\subset E.\n  have maxE := subsetP (p_rankElem_max _ _) E EprE.\n  have abelZ: 2.-abelem 'Z(DnQ) by rewrite prime_abelem ?oZ.\n  rewrite -(Ohm1_id abelZ) (OhmE _ (abelem_pgroup abelZ)) gen_subG.\n  rewrite -(pmaxElem_LdivP _ maxE) // setSI //=.\n  by rewrite -cpairg1_center injm_center // setIS ?centS.\nhave scE: 'C_Dn(E) = E.\n  apply/eqP; rewrite eq_sym eqEcard subsetI sEDn -abelianE cEE /=.\n  have [n0 | n_gt0] := posnP n.\n    rewrite subset_leq_card // subIset // (subset_trans _ sZE) //.\n    by rewrite -cpairg1_center morphimS // n0 center_ncprod0.\n  have pDn: 2.-group Dn by rewrite morphim_pgroup ?pX1p2n_pgroup.\n  have esDn: extraspecial Dn.\n    exact: injm_extraspecial (pX1p2n_extraspecial _ _).\n  rewrite dvdn_leq ?cardG_gt0 // (card_subcent_extraspecial pDn) //=.\n  rewrite -injm_center // cpairg1_center (setIidPl sZE) oZ.\n  rewrite -(dvdn_pmul2l (cardG_gt0 E)) mulnn mulnCA Lagrange //.\n  rewrite card_injm ?card_pX1p2n // -expnS pfactor_dvdn ?expn_gt0 ?cardG_gt0 //.\n  by rewrite lognX dimE mul2n.\napply/pmaxElemP; split=> [|F E2F sEF]; first by rewrite inE subsetT abelE.\nhave{E2F} [_ abelF] := pElemP E2F; have [pF cFF eF] := and3P abelF.\napply/eqP; rewrite eqEsubset sEF andbT; apply/subsetP=> x Fx.\nhave DnQx: x \\in Dn * Q by rewrite im_cpair inE.\nhave{DnQx} [y z Dn_y Qz def_x]:= imset2P DnQx.\nhave{Dn_y} Ey: y \\in E.\n  have cEz: z \\in 'C(E).\n    by rewrite (subsetP (centS sEDn)) // (subsetP (im_cpair_cent _)).\n  rewrite -scE inE Dn_y -(groupMr _ cEz) -def_x (subsetP (centS sEF)) //.\n  by rewrite (subsetP cFF).\nrewrite def_x groupMl // (subsetP sZE) // -cpair1g_center injm_center //= -/Q.\nhave: z \\in 'Ohm_1(Q).\n  rewrite (OhmE 1 (pgroupS (subsetT Q) pDnQ)) mem_gen // !inE Qz /=.\n  rewrite -[z](mulKg y) -def_x (exponentP eF) ?groupM //.\n  by rewrite groupV (subsetP sEF).\nhave isoQ: Q \\isog 'Q_(2 ^ 3) by rewrite isog_sym sub_isog.\nhave [//|[u v] genQ _] := generators_quaternion _ isoQ.\nby case/quaternion_structure: genQ => // _ _ [-> _ _ [-> _] _] _ _.\nQed.",
    "Lemma not_isog_Dn_DnQ n : ~~ ('D^n \\isog 'D^n.-1*Q).\nProof.\ncase: n => [|n] /=; first by rewrite isogEcard card_pX1p2n // card_DnQ andbF.\napply: contraL (leqnn n.+1) => isoDn1DnQ.\nby rewrite -ltnNge -rank_Dn (isog_p_rank isoDn1DnQ) rank_DnQ.\nQed.",
    "Lemma burnside_formula : forall (gT : finGroupType) s (G : {group gT}),\n   uniq s -> s =i G ->\n   forall (sT : finType) (to : {action gT &-> sT}),\n   (#|orbit to G @: setT| * size s)%N = \\sum_(p <- s) #|'Fix_to[p]|.\nProof.\nmove=> gT s G Us sG sT to.\nrewrite big_uniq // -(card_uniqP Us) (eq_card sG) -Frobenius_Cauchy.\n  by apply: eq_big => // p _; rewrite setTI.\nby apply/actsP=> ? _ ?; rewrite !inE.\nQed.",
    "Lemma R1_inj :  injective R1.\nProof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed.",
    "Lemma R2_inj :  injective R2.\nProof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed.",
    "Lemma R3_inj : injective R3.\nProof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed.",
    "Lemma group_set_rot : group_set rot.\nProof.\napply/group_setP; split; first  by rewrite /rot  inE /is_rot mulg1 mul1g.\nmove=> x1 y; rewrite /rot !inE /= /is_rot; move/eqP => hx1; move/eqP => hy.\nby rewrite -mulgA hy !mulgA hx1.\nQed.",
    "Lemma rot_eq_c0 : forall r s : {perm square},\n  is_rot r -> is_rot s -> r c0 = s c0 -> r = s.\nProof.\nrewrite /is_rot => r s; move/eqP => hr; move/eqP=> hs hrs; apply/permP => a.\nhave ->: a = (r1 ^+ a) c0\n   by apply/eqP; case: a; do 4?case=> //=; rewrite ?permM !permE.\nby rewrite -!permM -!commuteX   //  !permM hrs.\nQed.",
    "Lemma rot_r1 : forall r, is_rot r -> r = r1 ^+ (r c0).\nProof.\nmove=> r hr; apply: rot_eq_c0 => //; apply/eqP.\n   by symmetry; apply: commuteX.\nby case: (r c0); do 4?case=> //=; rewrite ?permM !permE  /=.\nQed.",
    "Lemma rotations_is_rot : forall r, r \\in rotations -> is_rot r.\nProof.\nmove=> r Dr; apply/eqP; apply/permP => a; rewrite !inE -!orbA !permM in Dr *.\nby case/or4P: Dr; move/eqP->; rewrite !permE //; case: a; do 4?case.\nQed.",
    "Lemma rot_is_rot : rot = rotations.\nProof.\napply/setP=> r; apply/idP/idP => [|/rotations_is_rot] /[!inE]// h.\nhave -> : r = r1 ^+ (r c0) by apply: rot_eq_c0; rewrite // -rot_r1.\nhave e2: 2 = r2 c0 by rewrite permE /=.\nhave e3: 3 = r3 c0 by rewrite permE /=.\ncase (r c0); do 4?[case] => // ?; rewrite ?(expg1, eqxx, orbT) //.\n  by rewrite [nat_of_ord _]/= e2 -rot_r1 ?(eqxx, orbT, rotations_is_rot, inE).\nby rewrite [nat_of_ord _]/= e3 -rot_r1 ?(eqxx, orbT, rotations_is_rot, inE).\nQed.",
    "Lemma Sh_inj : injective Sh.\nProof.\nby apply: (can_inj (g:= Sh)); case; do 4?case=> //=; move=> H; apply/eqP.\nQed.",
    "Lemma sh_inv : sh^-1 = sh.\nProof.\napply: (mulIg sh); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed.",
    "Lemma Sv_inj : injective Sv.\nProof.\nby apply: (can_inj (g:= Sv)); case; do 4?case=> //=; move=> H; apply/eqP.\nQed.",
    "Lemma sv_inv : sv^-1 = sv.\nProof.\napply: (mulIg sv); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed.",
    "Lemma Sd1_inj : injective Sd1.\nProof.\nby apply: can_inj Sd1 _; case; do 4?case=> //=; move=> H; apply/eqP.\nQed.",
    "Lemma sd1_inv : sd1^-1 = sd1.\nProof.\napply: (mulIg sd1); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed.",
    "Lemma Sd2_inj : injective Sd2.\nProof.\nby apply: can_inj Sd2 _; case; do 4?case=> //=; move=> H; apply/eqP.\nQed.",
    "Lemma sd2_inv : sd2^-1 = sd2.\nProof.\napply: (mulIg sd2); rewrite mulVg; apply/permP.\nby case; do 4?case=> //=; move=> H; rewrite !permE /= !permE; apply/eqP.\nQed.",
    "Lemma ord_enum4 : enum 'I_4 = [:: c0; c1; c2; c3].\nProof. by apply: (inj_map val_inj); rewrite val_enum_ord. Qed.",
    "Lemma diff_id_sh : 1 != sh.\nProof.\nby apply/eqP; move/(congr1 (fun p : {perm square} => p c0)); rewrite !permE.\nQed.",
    "Lemma card_iso2 : #|isometries2| = 2.\nProof. by rewrite cards2 diff_id_sh. Qed.",
    "Lemma group_set_iso2 : group_set isometries2.\nProof.\napply/group_setP; split => [|x y]; rewrite !inE ?eqxx //.\ndo 2![case/orP; move/eqP->]; rewrite ?(mul1g, mulg1) ?eqxx ?orbT//.\nby rewrite -/sh -{1}sh_inv mulVg eqxx.\nQed.",
    "Lemma isometries_iso : forall p, p \\in isometries -> is_iso p.\nProof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> -> a; rewrite !permE; case: a; do 4?case.\nQed.",
    "Lemma is_isoP : forall p, reflect (is_iso p) (p \\in isometries).\nProof.\nmove=> p; apply: (iffP idP) => [|iso_p]; first exact: isometries_iso.\nmove e1: (p c1) (iso_p c1) => k1; move e0: (p c0) (iso_p c0) k1 e1 => k0.\ncase: k0 e0; do 4?[case] => //= ? e0 e2; do 5?[case] => //= ? e1 e3;\n try by [non_inj p c0 c1 e0 e1 | non_inj p c0 c3 e0 e3].\nby is_isoPtac p id1 e0 e1 e2 e3.\nby is_isoPtac p sd1 e0 e1 e2 e3.\nby is_isoPtac p sh e0 e1 e2 e3.\nby is_isoPtac p r1 e0 e1 e2 e3.\nby is_isoPtac p sd2 e0 e1 e2 e3.\nby is_isoPtac p r2 e0 e1 e2 e3.\nby is_isoPtac p r3 e0 e1 e2 e3.\nby is_isoPtac p sv e0 e1 e2 e3.\nQed.",
    "Lemma group_set_iso : group_set isometries.\nProof.\napply/group_setP; split; first by rewrite inE eqxx /=.\nby move=> x y hx hy; apply/is_isoP => ci; rewrite !permM !isometries_iso.\nQed.",
    "Lemma card_rot : #|rot| = 4.\nProof.\nrewrite -[4]/(size [:: id1; r1; r2; r3]) -(card_uniqP _).\n  by apply: eq_card => x; rewrite rot_is_rot !inE -!orbA.\nby apply: map_uniq (fun p : {perm square} => p c0) _ _; rewrite /= !permE.\nQed.",
    "Lemma group_set_rotations : group_set rotations.\nProof. by rewrite -rot_is_rot group_set_rot. Qed.",
    "Lemma act_f_1 :  forall k, act_f k 1 = k.\nProof. by move=> k; apply/ffunP=> a; rewrite ffunE invg1 permE. Qed.",
    "Lemma act_f_morph :  forall k x y, act_f k (x * y) = act_f (act_f k x) y.\nProof. by move=> k x y; apply/ffunP=> a; rewrite !ffunE invMg permE. Qed.",
    "Lemma Fid : 'Fix_to(1) = setT.\nProof. by apply/setP=> x /=; rewrite in_setT; apply/afix1P; apply: act1. Qed.",
    "Lemma card_Fid : #|'Fix_to(1)| = (n ^ 4)%N.\nProof.\nrewrite -[4]card_ord -[n]card_ord -card_ffun_on Fid cardsE.\nby symmetry; apply: eq_card => f; apply/ffun_onP.\nQed.",
    "Lemma eqperm_map : forall p1 p2 : col_squares,\n  (p1 == p2) = all (fun s => p1 s == p2 s) [:: c0; c1; c2; c3].\nProof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/ffunP=> x.\nby apply/eqP; apply Ep12; case: x; do 4!case=> //.\nQed.",
    "Lemma F_Sh :\n  'Fix_to[sh] = [set x | (coin0 x == coin1 x) && (coin2 x == coin3 x)].\nProof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f sh_inv !ffunE !permE /=.\nby rewrite eq_sym (eq_sym (x c3)) andbT andbA !andbb.\nQed.",
    "Lemma F_Sv :\n  'Fix_to[sv] = [set x | (coin0 x == coin3 x) && (coin2 x == coin1 x)].\nProof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f sv_inv !ffunE !permE /=.\nby rewrite eq_sym andbT andbC (eq_sym (x c1)) andbA -andbA !andbb andbC.\nQed.",
    "Lemma r1_inv : r1^-1 = r3.\nProof. by inv_tac. Qed.",
    "Lemma r2_inv : r2^-1 = r2.\nProof. by inv_tac. Qed.",
    "Lemma r3_inv : r3^-1 = r1.\nProof. by inv_tac. Qed.",
    "Lemma F_r2 :\n  'Fix_to[r2] = [set x | (coin0 x == coin2 x) && (coin1 x == coin3 x)].\nProof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f r2_inv !ffunE !permE /=.\nby rewrite eq_sym andbT andbCA andbC (eq_sym (x c3)) andbA -andbA !andbb andbC.\nQed.",
    "Lemma F_r1 : 'Fix_to[r1] =\n  [set x | (coin0 x == coin1 x)&&(coin1 x == coin2 x)&&(coin2 x == coin3 x)].\nProof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f r1_inv !ffunE !permE andbC.\nby do 3![case E: {+}(_ == _); rewrite // {E}(eqP E)]; rewrite eqxx.\nQed.",
    "Lemma F_r3 : 'Fix_to[r3] =\n  [set x | (coin0 x == coin1 x)&&(coin1 x == coin2 x)&&(coin2 x == coin3 x)].\nProof.\napply/setP=> x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f r3_inv !ffunE !permE /=.\nby do 3![case: eqVneq=> // <-].\nQed.",
    "Lemma card_n2 : forall x y z t : square, uniq [:: x; y; z; t] ->\n  #|[set p : col_squares | (p x == p y) && (p z == p t)]| = (n ^ 2)%N.\nProof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\npose f (p : col_squares) := (p x, p z); rewrite -(@card_in_image _ _ f).\n  rewrite -mulnn -card_prod; apply: eq_card => [] [c d] /=; apply/imageP.\n  rewrite (cat_uniq [::x; y]) in Uxt; case/and3P: Uxt => _.\n  rewrite /= !orbF !andbT => /norP[] /[!inE] nxzt nyzt _.\n  exists [ffun i => if pred2 x y i then c else d].\n    by rewrite inE !ffunE /= !eqxx orbT (negbTE nxzt) (negbTE nyzt) !eqxx.\n  by rewrite {}/f !ffunE /= eqxx (negbTE nxzt).\nmove=> p1 p2 /[!inE] /andP[p1y p1t] /andP[p2y p2t] [px pz].\nhave eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t].\n  by rewrite /= -(eqP p1y) -(eqP p1t) -(eqP p2y) -(eqP p2t) px pz !eqxx.\napply/ffunP=> i; apply/eqP; apply: (allP eqp12).\nby rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxt) card_ord.\nQed.",
    "Lemma card_n :\n #|[set x | (coin0 x == coin1 x)&&(coin1 x == coin2 x)&& (coin2 x == coin3 x)]|\n   = n.\nProof.\nrewrite -[n]card_ord /coin0 /coin1 /coin2 /coin3.\npose f (p : col_squares) := p c3; rewrite -(@card_in_image _ _ f).\n  apply: eq_card => c /=; apply/imageP.\n  exists ([ffun => c] : col_squares); last by rewrite /f ffunE.\n  by rewrite /= inE !ffunE !eqxx.\nmove=> p1 p2; rewrite /= !inE /f -!andbA => eqp1 eqp2 eqp12.\napply/eqP; rewrite eqperm_map /= andbT.\ncase/and3P: eqp1; do 3!move/eqP->; case/and3P: eqp2; do 3!move/eqP->.\nby rewrite !andbb eqp12.\nQed.",
    "Lemma burnside_app2 : (square_coloring_number2 * 2 = n ^ 4 + n ^ 2)%N.\nProof.\nrewrite (burnside_formula [:: id1; sh]) => [||p]; last first.\n- by rewrite !inE.\n- by rewrite /= inE diff_id_sh.\nby rewrite 2!big_cons big_nil addn0 {1}card_Fid F_Sh card_n2.\nQed.",
    "Lemma burnside_app_rot :\n  (square_coloring_number4 * 4 = n ^ 4 + n ^ 2 + 2 * n)%N.\nProof.\nrewrite (burnside_formula [:: id1; r1; r2; r3]) => [||p]; last first.\n- by rewrite !inE !orbA.\n- by apply: map_uniq (fun p : {perm square} => p c0) _ _; rewrite /= !permE.\nrewrite !big_cons big_nil /= addn0 {1}card_Fid F_r1 F_r2 F_r3.\nby rewrite card_n card_n2 //= [n + _]addnC !addnA addn0.\nQed.",
    "Lemma F_Sd1 : 'Fix_to[sd1] = [set x | coin1 x == coin3 x].\nProof.\napply/setP => x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nrewrite /act_f sd1_inv !ffunE !permE /=.\nby rewrite !eqxx !andbT eq_sym /= andbb.\nQed.",
    "Lemma card_n3 : forall x y : square, x != y ->\n  #|[set k : col_squares | k x == k y]| = (n ^ 3)%N.\nProof.\nmove=> x y nxy; apply/eqP; case: (posnP n) => [n0|].\n  by rewrite n0; apply/existsP=> [] [p _]; case: (p c0) => i; rewrite n0.\nmove/eqn_pmul2l <-; rewrite -expnS -card_Fid Fid cardsT.\nrewrite -{1}[n]card_ord -cardX.\npose pk k := [ffun i => k (if i == y then x else i) : colors].\nrewrite -(@card_image _ _ (fun k : col_squares => (k y, pk k))).\n  apply/eqP; apply: eq_card => ck /=; rewrite inE /= [_ \\in _]inE.\n  apply/eqP/imageP; last first.\n    by case=> k _ -> /=; rewrite !ffunE if_same eqxx.\n  case: ck => c k /= kxy.\n  exists [ffun i => if i == y then c else k i]; first by rewrite inE.\n  rewrite !ffunE eqxx; congr (_, _); apply/ffunP=> i; rewrite !ffunE.\n  case Eiy: (i == y); last by rewrite Eiy.\n  by rewrite (negbTE nxy) (eqP Eiy).\nmove=> k1 k2 [Eky Epk]; apply/ffunP=> i.\nhave{Epk}: pk k1 i = pk k2 i by rewrite Epk.\nby rewrite !ffunE; case: eqP => // ->.\nQed.",
    "Lemma F_Sd2 : 'Fix_to[sd2] = [set x | coin0 x == coin2 x].\nProof.\napply/setP => x; rewrite (sameP afix1P eqP) !inE eqperm_map /=.\nby rewrite /act_f sd2_inv !ffunE !permE /= !eqxx !andbT eq_sym /= andbb.\nQed.",
    "Lemma burnside_app_iso :\n  (square_coloring_number8 * 8 = n ^ 4 + 2 * n ^ 3 + 3 * n ^ 2 + 2 * n)%N.\nProof.\npose iso_list := [:: id1; r1; r2; r3; sh; sv; sd1; sd2].\nrewrite (burnside_formula iso_list) => [||p]; last first.\n- by rewrite /= !inE.\n- apply: map_uniq (fun p : {perm square} => (p c0, p c1)) _ _.\n  by rewrite /= !permE.\nrewrite !big_cons big_nil {1}card_Fid F_r1 F_r2 F_r3 F_Sh F_Sv F_Sd1 F_Sd2.\nrewrite card_n !card_n3 // !card_n2 //= !addnA !addn0.\nby rewrite [LHS]addn.[ACl 1 * 7 * 8 * 3 * 5 * 6 * 2 * 4].\nQed.",
    "Lemma S1_inv : involutive S1f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S2_inv : involutive S2f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S3_inv : involutive S3f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S4_inv : involutive S4f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S5_inv : involutive S5f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S6_inv : involutive S6f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S05_inj : injective S05f.\nProof. by apply: can_inj S05f _ => z; apply/eqP; case: z; do 6?case.  Qed.",
    "Lemma S14_inj : injective S14f.\nProof. by apply: can_inj S14f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S23_inv : involutive S23f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R05_inj : injective R05f.\nProof. by apply: can_inj R50f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R14_inj : injective R14f.\nProof. by apply: can_inj R41f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R23_inj : injective R23f.\nProof. by apply: can_inj R32f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R50_inj : injective R50f.\nProof. by apply: can_inj R05f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R41_inj : injective R41f.\nProof. by apply: can_inj R14f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R32_inj : injective R32f.\nProof. by apply: can_inj R23f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R024_inj : injective R024f.\nProof. by apply: can_inj R042f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R042_inj : injective R042f.\nProof. by apply: can_inj R024f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R012_inj : injective R012f.\nProof. by apply: can_inj R021f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R021_inj : injective R021f.\nProof. by apply: can_inj R012f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R031_inj : injective R031f.\nProof. by apply: can_inj R013f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R013_inj : injective R013f.\nProof. by apply: can_inj R031f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R043_inj : injective R043f.\nProof. by apply: can_inj R034f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma R034_inj : injective R034f.\nProof. by apply: can_inj R043f _ => z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma S0_inv : involutive S0f.\nProof. by move=> z; apply/eqP; case: z; do 6?case. Qed.",
    "Lemma dir_iso_iso3 : forall p, p \\in dir_iso3  -> is_iso3 p.\nProof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> <- a; rewrite !permE; case: a; do 6?case.\nQed.",
    "Lemma iso3_ndir : forall p, p \\in dir_iso3  -> is_iso3 (s0 * p).\nProof.\nmove=> p; rewrite inE.\nby do ?case/orP; move/eqP=> <- a; rewrite !(permM, permE); case: a; do 6?case.\nQed.",
    "Lemma sop_inj : injective sop.\nProof. by move=> p1 p2 /val_inj/(can_inj fgraphK)/val_inj. Qed.",
    "Lemma sop_spec x (n0 : 'I_6): nth F0 (sop x) n0 = x n0.\nProof. by rewrite nth_fgraph_ord pvalE. Qed.",
    "Lemma prod_t_correct : forall (x y : {perm cube}) (i : cube),\n  (x * y) i = nth F0 (prod_tuple (sop x) (sop y)) i.\nProof.\nmove=> x y i; rewrite permM -!sop_spec [RHS](nth_map F0) // size_tuple /=.\nby rewrite card_ord ltn_ord.\nQed.",
    "Lemma sop_morph : {morph sop : x y / x * y >-> prod_tuple x y}.\nProof.\nmove=> x y; apply: (@eq_from_nth _ F0) => [|/= i].\n  by rewrite size_map !size_tuple.\nrewrite size_tuple card_ord => lti6.\nby rewrite -[i]/(val (Ordinal lti6)) sop_spec -prod_t_correct.\nQed.",
    "Lemma ecubes_def : ecubes = enum (@predT cube).\nProof. by apply: (inj_map val_inj); rewrite val_enum_ord. Qed.",
    "Lemma seqs1 : forall f injf, sop (@perm _ f injf) = map f ecubes.\nProof.\nmove=> f ?; rewrite ecubes_def /sop /= -codom_ffun pvalE.\nby apply: eq_codom; apply: permE.\nQed.",
    "Lemma Lcorrect : seq_iso_L == map sop [:: id3; s05; s14; s23; r05; r14; r23;\n  r50; r41; r32; r024; r042; r012; r021; r031; r013; r043; r034;\n  s1; s2; s3; s4; s5; s6].\nProof. by rewrite /= !seqs1. Qed.",
    "Lemma iso0_1 : dir_iso3 =i dir_iso3l.\nProof. by move=> p; rewrite /= !inE /= -!(eq_sym p). Qed.",
    "Lemma L_iso : forall p, (p \\in dir_iso3) = (sop p \\in seq_iso_L).\nProof.\nby move=> p; rewrite (eqP Lcorrect) mem_map ?iso0_1 //; apply: sop_inj.\nQed.",
    "Lemma stable : forall x y,\n  x \\in dir_iso3 -> y \\in dir_iso3 -> x * y \\in dir_iso3.\nProof.\nmove=> x y; rewrite !L_iso sop_morph => Hx Hy.\nby move/sop: y Hy; apply/allP; move/sop: x Hx; apply/allP; vm_compute.\nQed.",
    "Lemma iso_eq_F0_F1 : forall r s : {perm cube}, r \\in dir_iso3 ->\n  s \\in dir_iso3 -> r F0 = s F0 -> r F1 = s F1 -> r = s.\nProof.\nmove=> r s; rewrite !L_iso => hr hs hrs0 hrs1; apply: sop_inj; apply/eqP.\nmove/eqP: hrs0; apply/implyP; move/eqP: hrs1; apply/implyP; rewrite -!sop_spec.\nby move/sop: r hr; apply/allP; move/sop: s hs; apply/allP; vm_compute.\nQed.",
    "Lemma ndir_s0p : forall p, p \\in dir_iso3 -> s0 * p \\notin dir_iso3.\nProof.\nmove=> p; rewrite !L_iso sop_morph seqs1.\nby move/sop: p; apply/allP; vm_compute.\nQed.",
    "Lemma eqperm : forall p1 p2 : {perm cube},\n  (p1 == p2) = all (fun s => p1 s == p2 s) ecubes.\nProof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/permP=> x.\nby apply/eqP; rewrite Ep12 // ecubes_def mem_enum.\nQed.",
    "Lemma iso_eq_F0_F1_F2 : forall r s : {perm cube}, is_iso3 r ->\n   is_iso3 s -> r F0 = s F0 -> r F1 = s F1 ->  r F2 = s F2 -> r = s.\nProof.\nmove=> r s hr hs hrs0 hrs1 hrs2.\nhave:= hrs0; have:= hrs1; have:= hrs2.\nhave e23: F2 = s0 F3 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nhave e14: F1 = s0 F4 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nhave e05: F0 = s0 F5 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nrewrite e23 e14 e05; rewrite !hr !hs.\nmove/perm_inj=> hrs3; move/perm_inj=> hrs4; move/perm_inj=> hrs5.\nby apply/eqP; rewrite eqperm /= hrs0 hrs1 hrs2 hrs3 hrs4 hrs5 !eqxx.\nQed.",
    "Lemma dir_s0p : forall p,  (s0 * p) \\in dir_iso3 -> p \\notin dir_iso3.\nProof.\nmove=> p Hs0p; move: (ndir_s0p Hs0p); rewrite mulgA.\nhave e:  (s0^-1=s0) by inv_tac.\nby rewrite -{1}e mulVg mul1g.\nQed.",
    "Lemma is_iso3P : forall p, reflect (is_iso3 p) (p \\in iso3).\nProof.\nmove=> p; apply: (iffP idP); rewrite inE /iso3  /is_iso3b /is_iso3 => e.\n  by move=> fi; rewrite -!permM (eqP e).\nby apply/eqP; apply/permP=> z; rewrite !permM (e z).\nQed.",
    "Lemma group_set_iso3 : group_set iso3.\nProof.\napply/group_setP; split.\n  by apply/is_iso3P => fi; rewrite -!permM mulg1 mul1g.\nmove=> x1 y; rewrite /iso3 !inE /= /is_iso3.\nrewrite /is_iso3b.\nrewrite -mulgA.\nmove/eqP => hx1; move/eqP => hy.\nrewrite hy !mulgA. by  rewrite -hx1.\nQed.",
    "Lemma group_set_diso3 : group_set  dir_iso3.\nProof.\napply/group_setP; split; first by   rewrite inE eqxx /=.\nby apply: stable.\nQed.",
    "Lemma gen_diso3 :  dir_iso3 = <<[set r05; r14]>>.\nProof.\napply/setP/subset_eqP/andP; split; first last.\n  rewrite gen_subG; apply/subsetP.\n  by move=> x /[!inE] /orP[] /eqP->; rewrite !eqxx !orbT.\napply/subsetP => x /[!inE].\nhave -> : s05 = r05 * r05  by iso_tac.\nhave -> : s14 = r14 * r14  by iso_tac.\nhave -> : s23 = r14 * r14 * r05 * r05 by iso_tac.\nhave -> : r23 = r05 * r14 * r05 * r14 * r14 by iso_tac.\nhave -> : r50 = r05  * r05 * r05 by iso_tac.\nhave -> : r41 = r14 * r14 * r14 by iso_tac.\nhave -> : r32 = r14 * r14 * r14 * r05* r14 by iso_tac.\nhave -> : r024 = r05 * r14 * r14 * r14 by iso_tac.\nhave -> : r042 = r14 * r05 * r05 * r05 by iso_tac.\nhave -> : r012 = r14 * r05 by iso_tac.\nhave -> : r021 = r05 * r14 * r05 * r05 by iso_tac.\nhave -> : r031 = r05 * r14 by iso_tac.\nhave -> : r013 = r05 * r05 * r14 * r05 by iso_tac.\nhave -> : r043 = r14 * r14 * r14 * r05 by iso_tac.\nhave -> : r034 = r05 * r05 * r05 * r14 by iso_tac.\nhave -> : s1 = r14 * r14 * r05 by iso_tac.\nhave -> : s2 = r05 * r14 * r14 by iso_tac.\nhave -> : s3 = r05 * r14 * r05 by iso_tac.\nhave -> : s4 = r05 * r14  * r14 * r14 * r05 by iso_tac.\nhave -> : s5 = r14  * r05 * r05 by iso_tac.\nhave -> : s6 = r05 * r05 * r14 by iso_tac.\nby do ?case/predU1P=> [<-|]; first exact: group1; last (move/eqP<-);\n   rewrite ?groupMl ?mem_gen // !inE eqxx ?orbT.\nQed.",
    "Lemma act_g_1 :  forall k, act_g k 1 = k.\nProof. by move=> k; apply/ffunP=> a; rewrite ffunE invg1 permE. Qed.",
    "Lemma act_g_morph :  forall k x y, act_g k (x * y) = act_g (act_g k x) y.\nProof. by move=> k x y; apply/ffunP=> a; rewrite !ffunE invMg permE. Qed.",
    "Lemma Fid3 : 'Fix_to_g[1] = setT.\nProof. by apply/setP=> x /=; rewrite (sameP afix1P eqP) !inE act1 eqxx. Qed.",
    "Lemma card_Fid3 : #|'Fix_to_g[1]| = (n ^ 6)%N.\nProof.\nrewrite -[6]card_ord -[n]card_ord -card_ffun_on Fid3 cardsT.\nby symmetry; apply: eq_card => ff; apply/ffun_onP.\nQed.",
    "Lemma eqperm_map2 : forall p1 p2 : col_cubes,\n  (p1 == p2) = all (fun s => p1 s == p2 s) [:: F0; F1; F2; F3; F4; F5].\nProof.\nmove=> p1 p2; apply/eqP/allP=> [-> // | Ep12]; apply/ffunP=> x.\nby apply/eqP; apply Ep12; case: x; do 6?case.\nQed.",
    "Lemma F_s05 :\n  'Fix_to_g[s05] = [set x | (col1 x == col4 x) && (col2 x == col3 x)].\nProof.\nhave s05_inv: s05^-1=s05 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s05_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //= ].\nQed.",
    "Lemma F_s14 :\n   'Fix_to_g[s14]= [set x | (col0 x == col5 x) && (col2 x == col3 x)].\nProof.\nhave s14_inv: s14^-1=s14  by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s14_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //= ].\nQed.",
    "Lemma r05_inv : r05^-1 = r50.\nProof. by inv_tac. Qed.",
    "Lemma r50_inv : r50^-1 = r05.\nProof. by inv_tac. Qed.",
    "Lemma r14_inv : r14^-1 = r41.\nProof. by inv_tac. Qed.",
    "Lemma r41_inv : r41^-1 = r14.\nProof. by inv_tac. Qed.",
    "Lemma s23_inv : s23^-1 = s23.\nProof. by inv_tac. Qed.",
    "Lemma F_s23 :\n  'Fix_to_g[s23] = [set x | (col0 x == col5 x) && (col1 x == col4 x)].\nProof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s23_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= andbT/col1/col2/col3/col4/col5/col0.\nby do 2![rewrite eq_sym; case: {+}(_ == _)=>  //=].\nQed.",
    "Lemma F_r05 : 'Fix_to_g[r05]=\n  [set x | (col1 x == col2 x) && (col2 x == col3 x)\n                                && (col3 x == col4 x)].\nProof.\napply sym_equal.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r05_inv !ffunE !permE /=.\nrewrite !eqxx /= !andbT /col1/col2/col3/col4/col5/col0.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r50 : 'Fix_to_g[r50]=\n  [set x | (col1 x == col2 x) && (col2 x == col3 x)\n                                && (col3 x == col4 x)].\nProof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r50_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col2/col3/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r23 : 'Fix_to_g[r23] =\n  [set x | (col0 x == col1 x) && (col1 x == col4 x)\n                                && (col4 x == col5 x)].\nProof.\nhave r23_inv: r23^-1 = r32 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r23_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col0/col5/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r32 : 'Fix_to_g[r32] =\n  [set x | (col0 x == col1 x) && (col1 x == col4 x)\n                                && (col4 x == col5 x)].\nProof.\nhave r32_inv: r32^-1 = r23 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r32_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col1/col0/col5/col4.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r14 : 'Fix_to_g[r14] =\n  [set x | (col0 x == col2 x) && (col2 x == col3 x) && (col3 x == col5 x)].\nProof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r14_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col2/col0/col5/col3.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r41 : 'Fix_to_g[r41] =\n  [set x | (col0 x == col2 x) && (col2 x == col3 x) && (col3 x == col5 x)].\nProof.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r41_inv !ffunE !permE /=.\napply sym_equal; rewrite !eqxx /= !andbT /col2/col0/col5/col3.\nby do 3![case: eqVneq; rewrite ?andbF // => <-].\nQed.",
    "Lemma F_r024 : 'Fix_to_g[r024] =\n  [set x | (col0 x == col4 x) && (col4 x == col2  x) && (col1 x == col3 x)\n       && (col3 x == col5 x) ].\nProof.\nhave r024_inv: r024^-1 = r042 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r024_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r042 : 'Fix_to_g[r042] =\n  [set x | (col0 x == col4 x) && (col4 x == col2  x) && (col1 x == col3 x)\n       && (col3 x == col5 x)].\nProof.\nhave r042_inv: r042^-1 = r024 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r042_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r012 : 'Fix_to_g[r012] =\n  [set x | (col0 x == col2 x) && (col2 x == col1  x) && (col3 x == col4 x)\n       && (col4 x == col5 x)].\nProof.\nhave r012_inv: r012^-1 = r021 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r012_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r021 : 'Fix_to_g[r021] =\n  [set x | (col0 x == col2 x) && (col2 x == col1  x) && (col3 x == col4 x)\n       && (col4 x == col5 x)].\nProof.\nhave r021_inv: r021^-1 = r012 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r021_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\ndo 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r031 : 'Fix_to_g[r031] =\n  [set x | (col0 x == col3 x) && (col3 x == col1  x) && (col2 x == col4 x)\n       && (col4 x == col5 x)].\nProof.\nhave r031_inv: r031^-1 = r013 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r031_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r013 : 'Fix_to_g[r013] =\n  [set x | (col0 x == col3 x) && (col3 x == col1  x) && (col2 x == col4 x)\n       && (col4 x == col5 x)].\nProof.\nhave r013_inv: r013^-1 = r031 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r013_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r043 : 'Fix_to_g[r043] =\n  [set x | (col0 x == col4 x) && (col4 x == col3  x) && (col1 x == col2 x)\n       && (col2 x == col5 x)].\nProof.\nhave r043_inv: r043^-1 = r034 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r043_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_r034 : 'Fix_to_g[r034] =\n  [set x | (col0 x == col4 x) && (col4 x == col3  x) && (col1 x == col2 x)\n       && (col2 x == col5 x)].\nProof.\nhave r034_inv: r034^-1 = r043 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g r034_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 4![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s1 : 'Fix_to_g[s1] =\n  [set x | (col0 x == col5 x) && (col1 x == col2  x) && (col3 x == col4 x)].\nProof.\nhave s1_inv: s1^-1 = s1 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s1_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s2 : 'Fix_to_g[s2] =\n  [set x | (col0 x == col5 x) && (col1 x == col3  x) && (col2 x == col4 x)].\nProof.\nhave s2_inv: s2^-1 = s2 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s2_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s3 : 'Fix_to_g[s3] =\n  [set x | (col0 x == col1 x) && (col2 x == col3  x) && (col4 x == col5 x)].\nProof.\nhave s3_inv: s3^-1 = s3 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s3_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s4 : 'Fix_to_g[s4] =\n  [set x | (col0 x == col4 x) && (col1 x == col5  x) && (col2 x == col3 x)].\nProof.\nhave s4_inv: s4^-1 = s4 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s4_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s5 : 'Fix_to_g[s5] =\n  [set x | (col0 x == col2 x) && (col1 x == col4  x) && (col3 x == col5 x)].\nProof.\nhave s5_inv: s5^-1 = s5 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s5_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma F_s6 : 'Fix_to_g[s6] =\n  [set x | (col0 x == col3 x) && (col1 x == col4  x) && (col2 x == col5 x)].\nProof.\nhave s6_inv: s6^-1 = s6 by inv_tac.\napply/setP => x; rewrite infE !inE eqperm_map2 /= /act_g s6_inv !ffunE !permE /=.\napply sym_equal; rewrite ?eqxx /= !andbT /col0/col1/col2/col3/col4/col5.\nby do 3![case: eqVneq=> E; rewrite ?andbF // ?{}E].\nQed.",
    "Lemma uniq4_uniq6 : forall x y z t : cube,\n  uniq [:: x; y; z; t] -> exists u, exists v, uniq [:: x; y; z; t; u; v].\nProof.\nmove=> x y z t Uxt; move: (cardC [in [:: x; y; z; t]]).\nrewrite card_ord  (card_uniq_tuple Uxt) => hcard.\nhave hcard2: #|[predC [:: x; y; z; t]]| = 2.\n  by apply: (@addnI 4); rewrite /injective  hcard.\nhave:  #|[predC [:: x; y; z; t]]| != 0 by rewrite hcard2.\ncase/existsP=> u Hu; exists u.\nmove: (cardC [in [:: x; y; z; t; u]]); rewrite card_ord => hcard5.\nhave: #|[predC [:: x; y; z; t; u]]| !=0.\n  rewrite -lt0n  -(ltn_add2l #|[:: x; y; z; t; u]|) hcard5 addn0.\n  by apply: (leq_ltn_trans (card_size [:: x; y; z; t; u])).\ncase/existsP => v; rewrite (mem_cat _ [:: _; _; _; _]) => /norP[Hv Huv].\nexists v; rewrite (cat_uniq [:: x; y; z; t]) Uxt andTb -rev_uniq /= orbF.\nby rewrite negb_or Hu Hv Huv.\nQed.",
    "Lemma card_n4 : forall x y z t : cube, uniq [:: x; y; z; t] ->\n   #|[set p : col_cubes | (p x == p y) && (p z == p t)]| = (n ^ 4)%N.\nProof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\ncase: (uniq4_uniq6 Uxt) => u [v Uxv].\npose ff (p : col_cubes) := (p x, p z, p u, p v).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE] /andP[p1y p1t] /andP[p2y p2t] [px pz] pu pv.\n  have eqp12 : all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n   by rewrite /= -(eqP p1y) -(eqP p1t) -(eqP p2y) -(eqP p2t) px pz pu pv !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 4 = n * n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[[c d] e] g] /=; apply/imageP => /=.\nmove: Uxv; rewrite (cat_uniq [:: x; y; z; t]) => /and3P[_]/=; rewrite orbF.\nmove=> /norP[] /[!inE] + + /andP[/negPf nuv _].\nrewrite orbA => /norP[/negPf nxyu /negPf nztu].\nrewrite orbA => /norP[/negPf nxyv /negPf nztv].\nmove: Uxt; rewrite (cat_uniq [::x; y]) => /and3P[_]/= /[!(andbT, orbF)].\nmove=> /norP[] /[!inE] /negPf nxyz /negPf nxyt _.\nexists [ffun i => if pred2 x y i then c else if pred2 z t i then d\n                  else if u == i then e else g].\n  by rewrite !(inE, ffunE, eqxx,orbT)//= nxyz nxyt.\nby rewrite {}/ff !ffunE /= !eqxx /= nxyz nxyu nztu nxyv nztv nuv.\nQed.",
    "Lemma card_n3_3 : forall x y z t: cube, uniq [:: x; y; z; t] ->\n  #|[set p : col_cubes | (p x == p y) && (p y == p z)&& (p z == p t)]|\n      = (n ^ 3)%N.\nProof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\ncase: (uniq4_uniq6 Uxt) => u [v Uxv].\npose ff (p : col_cubes) := (p x, p u, p v);\n    rewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and3P[/eqP p1xy /eqP p1yz /eqP p1zt].\n  move=> /and3P[/eqP p2xy /eqP p2yz /eqP p2zt] [px pu] pv.\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1zt -p2zt -p1yz -p2yz -p1xy -p2xy px pu pv !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 3 = n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[c d] e] /=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z; t]) => /and3P[_ hasxt].\nrewrite /uniq !inE !andbT => /negPf nuv.\nexists [ffun i => if i \\in [:: x; y; z; t] then c else if u == i then d else e].\n  by rewrite /= !(inE, ffunE, eqxx, orbT).\nrewrite {}/ff !(ffunE, inE, eqxx) /=; move: hasxt; rewrite nuv.\nby do 8![case E: ( _ ==  _ ); rewrite ?(eqP E)/= ?inE ?eqxx //= ?E {E}].\nQed.",
    "Lemma card_n2_3 : forall x y z t u v: cube, uniq [:: x; y; z; t; u; v] ->\n  #|[set p : col_cubes | (p x == p y) && (p y == p z)&& (p t == p u )\n                            && (p u== p v)]|  = (n ^ 2)%N.\nProof.\nmove=> x y z t u v  Uxv; rewrite -[n]card_ord .\npose ff (p : col_cubes) := (p x, p t).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and4P[/eqP p1xy /eqP p1yz /eqP p1tu /eqP p1uv].\n  move=> /and4P[/eqP p2xy/eqP  p2yz /eqP p2tu /eqP p2uv] [px pu].\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1yz -p2yz -p1xy -p2xy -p1uv -p2uv -p1tu -p2tu px pu !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nrewrite -mulnn -!card_prod; apply: eq_card => [] [c d]/=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z]) => /= /and3P[Uxt + nuv].\nmove=> /[!orbF] /norP[] /[!inE] /negPf nxyzt /norP[/negPf nxyzu /negPf nxyzv].\nexists [ffun i =>  if (i \\in [:: x; y; z] ) then c else d].\n  by rewrite /= !(inE, ffunE, eqxx, orbT, nxyzt, nxyzu, nxyzv).\nby rewrite {}/ff !ffunE  !inE /= !eqxx /= nxyzt.\nQed.",
    "Lemma card_n3s : forall x y z t u v: cube, uniq [:: x; y; z; t; u; v] ->\n  #|[set p : col_cubes | (p x == p y) && (p z == p t)&& (p u == p v )]|\n    = (n ^ 3)%N.\nProof.\nmove=> x y z t u v Uxv; rewrite -[n]card_ord .\npose ff (p : col_cubes) := (p x, p z, p u).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and3P[/eqP p1xy /eqP p1zt /eqP p1uv].\n  move=> /and3P[/eqP p2xy /eqP p2zt /eqP p2uv] [px pz] pu.\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1xy -p2xy -p1zt -p2zt -p1uv -p2uv px pz pu !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 3 = n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[c d] e] /=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z; t]) => /and3P[Uxt + nuv].\nmove=> /= /[!orbF] /norP[] /[!inE].\nrewrite orbA => /norP[/negPf nxyu /negPf nztu].\nrewrite orbA => /norP[/negPf nxyv /negPf nztv].\nmove: Uxt; rewrite (cat_uniq [::x; y]) => /and3P[_].\nrewrite /= !orbF !andbT => /norP[] /[!inE] /negPf nxyz /negPf nxyt _.\nexists [ffun i => if i \\in [:: x; y] then c\n                  else if i \\in [:: z; t] then d else e].\n  by rewrite !(inE, ffunE, eqxx,orbT)//= nxyz nxyt nxyu nztu nxyv nztv !eqxx.\nby rewrite {}/ff !ffunE !inE /= !eqxx nxyz nxyu nztu.\nQed.",
    "Lemma burnside_app_iso3 :\n  (cube_coloring_number24 * 24 =\n   n ^ 6 + 6 * n ^ 3 + 3 * n ^ 4 + 8 * (n ^ 2)  + 6 * n ^ 3)%N.\nProof.\npose iso_list := [:: id3; s05; s14; s23; r05; r14; r23; r50; r41; r32;\n                     r024; r042; r012; r021; r031; r013; r043; r034;\n                     s1; s2; s3; s4; s5; s6].\nrewrite (burnside_formula iso_list); last first.\n- by move=> p; rewrite !inE /= !(eq_sym _ p).\n- apply: map_uniq (fun p : {perm cube} => (p F0, p F1)) _ _.\n  have bsr : (fun p : {perm cube} => (p F0, p F1)) =1\n             (fun p => (nth F0 p F0, nth F0 p F1)) \\o sop.\n    by move=> x; rewrite /= -2!sop_spec.\n  by rewrite (eq_map bsr) map_comp  -(eqP Lcorrect); vm_compute.\nrewrite !big_cons big_nil {1}card_Fid3 /= F_s05 F_s14 F_s23 F_r05 F_r14 F_r23\n  F_r50 F_r41 F_r32 F_r024 F_r042 F_r012 F_r021 F_r031 F_r013 F_r043  F_r034\n  F_s1  F_s2 F_s3 F_s4 F_s5 F_s6.\nrewrite !card_n4 // !card_n3_3 // !card_n2_3 // !card_n3s //.\nby rewrite [RHS]addn.[ACl 1 * 3 * 2 * 4 * 5] !addnA !addn0.\nQed.",
    "Lemma fmodP u : val u \\in A. Proof. exact: valP. Qed.",
    "Lemma fmod_inj : injective fmval. Proof. exact: val_inj. Qed.",
    "Lemma congr_fmod u v : u = v -> fmval u = fmval v.\nProof. exact: congr1. Qed.",
    "Lemma fmvalA : {morph valA : x y / x + y >-> (x * y)%g}. Proof. by []. Qed.",
    "Lemma fmvalN : {morph valA : x / - x >-> x^-1%g}. Proof. by []. Qed.",
    "Lemma fmval0 : valA 0 = 1%g. Proof. by []. Qed.",
    "Lemma fmvalZ n : {morph valA : x / x *+ n >-> (x ^+ n)%g}.\nProof. by move=> u; rewrite /= morphX ?inE. Qed.",
    "Lemma fmodKcond x : val (fmod x) = if x \\in A then x else 1%g.\nProof. by rewrite /= /fmval /= val_insubd. Qed.",
    "Lemma fmodK : {in A, cancel fmod val}. Proof. exact: subgK. Qed.",
    "Lemma fmvalK : cancel val fmod.\nProof. by case=> x Ax; apply: val_inj; rewrite /fmod /= sgvalK. Qed.",
    "Lemma fmod1 : fmod 1 = 0. Proof. by rewrite -fmval0 fmvalK. Qed.",
    "Lemma fmodM : {in A &, {morph fmod : x y / (x * y)%g >-> x + y}}.\nProof. by move=> x y Ax Ay /=; apply: val_inj; rewrite /fmod morphM. Qed.",
    "Lemma fmodX n : {in A, {morph fmod : x / (x ^+ n)%g >-> x *+ n}}.\nProof. exact: morphX. Qed.",
    "Lemma fmodV : {morph fmod : x / x^-1%g >-> - x}.\nProof.\nmove=> x; apply: val_inj; rewrite fmvalN !fmodKcond groupV.\nby case: (x \\in A); rewrite ?invg1.\nQed.",
    "Lemma injm_fmod : 'injm fmod.\nProof.\nby apply/injmP=> x y Ax Ay []; move/val_inj; apply: (injmP (injm_subg A)).\nQed.",
    "Lemma fmvalJcond u x :\n  val (u ^@ x) = if x \\in 'N(A) then val u ^ x else val u.\nProof. by case: ifP => Nx; rewrite /actr Nx ?fmodK // memJ_norm ?fmodP. Qed.",
    "Lemma fmvalJ u x : x \\in 'N(A) -> val (u ^@ x) = val u ^ x.\nProof. by move=> Nx; rewrite fmvalJcond Nx. Qed.",
    "Lemma fmodJ x y : y \\in 'N(A) -> fmod (x ^ y) = fmod x ^@ y.\nProof.\nmove=> Ny; apply: val_inj; rewrite fmvalJ ?fmodKcond ?memJ_norm //.\nby case: ifP => // _; rewrite conj1g.\nQed.",
    "Lemma act0r x : 0 ^@ x = 0.\nProof. by rewrite /actr conj1g morph1 if_same. Qed.",
    "Lemma actAr x : {morph actr^~ x : u v / u + v}.\nProof.\nby move=> u v; apply: val_inj; rewrite !(fmvalA, fmvalJcond) conjMg; case: ifP.\nQed.",
    "Lemma actNr x : {morph actr^~ x : u / - u}.\nProof. by move=> u; apply: (addrI (u ^@ x)); rewrite -actAr !subrr act0r. Qed.",
    "Lemma actZr x n : {morph actr^~ x : u / u *+ n}.\nProof.\nby move=> u; elim: n => [|n IHn]; rewrite ?act0r // !mulrS actAr IHn.\nQed.",
    "Lemma actr1 u : u ^@ 1 = u.\nProof. exact: act1. Qed.",
    "Lemma actrM : {in 'N(A) &, forall x y u, u ^@ (x * y) = u ^@ x ^@ y}.\nProof.\nby move=> x y Nx Ny /= u; apply: val_inj; rewrite !fmvalJ ?conjgM ?groupM.\nQed.",
    "Lemma actrK x : cancel (actr^~ x) (actr^~ x^-1%g).\nProof.\nmove=> u; apply: val_inj; rewrite !fmvalJcond groupV.\nby case: ifP => -> //; rewrite conjgK.\nQed.",
    "Lemma actrKV x : cancel (actr^~ x^-1%g) (actr^~ x).\nProof. by move=> u; rewrite /= -{2}(invgK x) actrK. Qed.",
    "Lemma coprime_abel_cent_TI (gT : finGroupType) (A G : {group gT}) :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> abelian G -> 'C_[~: G, A](A) = 1.\nProof.\nmove=> nGA coGA abG; pose f x := val (\\sum_(a in A) fmod abG x ^@ a)%R.\nhave fM: {in G &, {morph f : x y / x * y}}.\n  move=> x y Gx Gy /=; rewrite -fmvalA -big_split /=; congr (fmval _).\n  by apply: eq_bigr => a Aa; rewrite fmodM // actAr.\nhave nfA x a: a \\in A -> f (x ^ a) = f x.\n  move=> Aa; rewrite {2}/f (reindex_inj (mulgI a)) /=; congr (fmval _).\n  apply: eq_big => [b | b Ab]; first by rewrite groupMl.\n  by rewrite -!fmodJ ?groupM ?(subsetP nGA) // conjgM.\nhave kerR: [~: G, A] \\subset 'ker (Morphism fM).\n  rewrite gen_subG; apply/subsetP=> xa; case/imset2P=> x a Gx Aa -> {xa}.\n  have Gxa: x ^ a \\in G by rewrite memJ_norm ?(subsetP nGA).\n  rewrite commgEl; apply/kerP; rewrite (groupM, morphM) ?(groupV, morphV) //=.\n  by rewrite nfA ?mulVg.\napply/trivgP; apply/subsetP=> x /setIP[Rx cAx]; apply/set1P.\nhave Gx: x \\in G by apply: subsetP Rx; rewrite commg_subl.\nrewrite -(expgK coGA Gx) (_ : x ^+ _ = 1) ?expg1n //.\nrewrite -(fmodK abG Gx) -fmvalZ -(mker (subsetP kerR x Rx)); congr fmval.\nrewrite -GRing.sumr_const; apply: eq_bigr => a Aa.\nby rewrite -fmodJ ?(subsetP nGA) // /conjg (centP cAx) // mulKg.\nQed.",
    "Lemma transferM : {in G &, {morph transfer : x y / (x * y)%g >-> x + y}}.\nProof.\nmove=> s t Gs Gt /=.\nrewrite [transfer t](reindex_acts 'Rs _ Gs) ?actsRs_rcosets //= -big_split /=.\napply: eq_bigr => _ /rcosetsP[x Gx ->]; rewrite !rcosetE -!rcosetM.\nrewrite -zmodMgE -morphM -?mem_rcoset; first by rewrite !mulgA mulgKV rcosetM.\n  by rewrite rcoset_repr rcosetM mem_rcoset mulgK mem_repr_rcoset.\nby rewrite rcoset_repr (rcosetM _ _ t) mem_rcoset mulgK mem_repr_rcoset.\nQed.",
    "Lemma transfer_indep X (rX := transversal_repr 1 X) :\n  is_transversal X HG G -> {in G, transfer =1 V rX}.\nProof.\nmove=> trX g Gg; have mem_rX := repr_mem_pblock trX 1; rewrite -/rX in mem_rX.\napply: (addrI (\\sum_(Hx in HG) fmalpha (repr Hx * (rX Hx)^-1))).\nrewrite {1}(reindex_acts 'Rs _ Gg) ?actsRs_rcosets // -!big_split /=.\napply: eq_bigr => _ /rcosetsP[x Gx ->]; rewrite !rcosetE -!rcosetM.\ncase: repr_rcosetP => h1 Hh1; case: repr_rcosetP => h2 Hh2.\nhave: H :* (x * g) \\in rcosets H G by rewrite -rcosetE imset_f ?groupM.\nhave: H :* x \\in rcosets H G by rewrite -rcosetE imset_f.\ncase/mem_rX/rcosetP=> h3 Hh3 -> /mem_rX/rcosetP[h4 Hh4 ->].\nrewrite -!(mulgA h1) -!(mulgA h2) -!(mulgA h3) !(mulKVg, invMg).\nby rewrite addrC -!zmodMgE -!morphM ?groupM ?groupV // -!mulgA !mulKg.\nQed.",
    "Lemma mulg_exp_card_rcosets x : x * (g ^+ n_ x) \\in H :* x.\nProof.\nrewrite /n_ /indexg -orbitRs -porbit_actperm ?inE //.\nrewrite -{2}(iter_porbit (actperm 'Rs g) (H :* x)) -permX -morphX ?inE //.\nby rewrite actpermE //= rcosetE -rcosetM rcoset_refl.\nQed.",
    "Lemma rcosets_cycle_partition : partition (HG :* <[g]>) G.\nProof. by rewrite defHGg; have [] := partition_partition partHG partHGg. Qed.",
    "Lemma rcosets_cycle_transversal : H_g_rcosets @: X = HGg.\nProof.\nhave sHXgHGg x: x \\in X -> H_g_rcosets x \\in HGg.\n  by move/sXG=> Gx; apply: imset_f; rewrite -rcosetE imset_f.\napply/setP=> Hxg; apply/imsetP/idP=> [[x /sHXgHGg HGgHxg -> //] | HGgHxg].\nhave [_ /rcosetsP[z Gz ->] ->] := imsetP HGgHxg.\npose Hzg := H :* z * <[g]>; pose x := transversal_repr 1 X Hzg.\nhave HGgHzg: Hzg \\in HG :* <[g]>.\n  by rewrite mem_mulg ?set11 // -rcosetE imset_f.\nhave Hzg_x: x \\in Hzg by rewrite (repr_mem_pblock trX).\nexists x; first by rewrite (repr_mem_transversal trX).\ncase/mulsgP: Hzg_x => y u /rcoset_eqP <- /(orbit_act 'Rs) <- -> /=.\nby rewrite rcosetE -rcosetM.\nQed.",
    "Lemma sum_index_rcosets_cycle : (\\sum_(x in X) n_ x)%N = #|G : H|.\nProof. by rewrite [#|G : H|](card_partition partHGg) -defHgX big_imset. Qed.",
    "Lemma transfer_cycle_expansion :\n   transfer g = \\sum_(x in X) fmalpha ((g ^+ n_ x) ^ (x^-1)).\nProof.\npose Y := \\bigcup_(x in X) [set x * g ^+ i | i : 'I_(n_ x)].\npose rY := transversal_repr 1 Y.\npose pcyc x := porbit (actperm 'Rs g) (H :* x).\npose traj x := traject (actperm 'Rs g) (H :* x) #|pcyc x|.\nhave Hgr_eq x: H_g_rcosets x = pcyc x.\n  by rewrite /H_g_rcosets -orbitRs -porbit_actperm ?inE.\nhave pcyc_eq x: pcyc x =i traj x by apply: porbit_traject.\nhave uniq_traj x: uniq (traj x) by apply: uniq_traject_porbit.\nhave n_eq x: n_ x = #|pcyc x| by rewrite -Hgr_eq.\nhave size_traj x: size (traj x) = n_ x by rewrite n_eq size_traject.\nhave nth_traj x j: j < n_ x -> nth (H :* x) (traj x) j = H :* (x * g ^+ j).\n  move=> lt_j_x; rewrite nth_traject -?n_eq //.\n  by rewrite -permX -morphX ?inE // actpermE //= rcosetE rcosetM.\nhave sYG: Y \\subset G.\n  apply/bigcupsP=> x Xx; apply/subsetP=> _ /imsetP[i _ ->].\n  by rewrite groupM ?groupX // sXG.\nhave trY: is_transversal Y HG G.\n  apply/and3P; split=> //; apply/forall_inP=> Hy.\n  have /and3P[/eqP <- _ _] := partHGg; rewrite -defHgX cover_imset.\n  case/bigcupP=> x Xx; rewrite Hgr_eq pcyc_eq => /trajectP[i].\n  rewrite -n_eq -permX -morphX ?in_setT // actpermE /= rcosetE -rcosetM => lti.\n  set y := x * _ => ->{Hy}; pose oi := Ordinal lti.\n  have Yy: y \\in Y by apply/bigcupP; exists x => //; apply/imsetP; exists oi.\n  apply/cards1P; exists y; apply/esym/eqP.\n  rewrite eqEsubset sub1set inE Yy rcoset_refl.\n  apply/subsetP=> _ /setIP[/bigcupP[x' Xx' /imsetP[j _ ->]] Hy_x'gj].\n  have eq_xx': x = x'.\n    apply: (pblock_inj trX) => //; have /andP[/and3P[_ tiX _] _] := trX.\n    have HGgHyg: H :* y * <[g]> \\in HG :* <[g]>.\n      by rewrite mem_mulg ?set11 // -rcosetE imset_f ?(subsetP sYG).\n    rewrite !(def_pblock tiX HGgHyg) //.\n      by rewrite -[x'](mulgK (g ^+ j)) mem_mulg // groupV mem_cycle.\n    by rewrite -[x](mulgK (g ^+ i)) mem_mulg ?rcoset_refl // groupV mem_cycle.\n  apply/set1P; rewrite /y eq_xx'; congr (_ * _ ^+ _) => //; apply/eqP.\n  rewrite -(@nth_uniq _ (H :* x) (traj x)) ?size_traj // ?eq_xx' //.\n  by rewrite !nth_traj ?(rcoset_eqP Hy_x'gj) // -eq_xx'.\nhave rYE x i : x \\in X -> i < n_ x -> rY (H :* x :* g ^+ i) = x * g ^+ i.\n  move=> Xx lt_i_x; rewrite -rcosetM; apply: (canLR_in (pblockK trY 1)).\n    by apply/bigcupP; exists x => //; apply/imsetP; exists (Ordinal lt_i_x).\n  apply/esym/def_pblock; last exact: rcoset_refl; first by case/and3P: partHG.\n  by rewrite -rcosetE imset_f ?groupM ?groupX // sXG.\nrewrite (transfer_indep trY Gg) /V -/rY (set_partition_big _ partHGg) /=.\nrewrite -defHgX big_imset /=; last first.\n  apply/imset_injP; rewrite defHgX (card_transversal trX) defHGg.\n  by rewrite (card_in_imset injHGg).\napply eq_bigr=> x Xx; rewrite Hgr_eq (eq_bigl _ _ (pcyc_eq x)) -big_uniq //=.\nhave n_gt0: 0 < n_ x by rewrite indexg_gt0.\nrewrite /traj -n_eq; case def_n: (n_ x) (n_gt0) => // [n] _.\nrewrite conjgE invgK -{1}[H :* x]rcoset1 -{1}(expg0 g).\nelim: {1 3}n 0%N (addn0 n) => [|m IHm] i def_i /=.\n  rewrite big_seq1 {i}[i]def_i rYE // ?def_n //.\n  rewrite -(mulgA _ _ g) -rcosetM -expgSr -[(H :* x) :* _]rcosetE.\n  rewrite -actpermE morphX ?inE // permX // -{2}def_n n_eq iter_porbit mulgA.\n  by rewrite -[H :* x]rcoset1 (rYE _ 0) ?mulg1.\nrewrite big_cons rYE //; last by rewrite def_n -def_i ltnS leq_addl.\nrewrite permE /= rcosetE -rcosetM -(mulgA _ _ g) -expgSr.\nrewrite addSnnS in def_i; rewrite IHm //.\nrewrite rYE //; last by rewrite def_n -def_i ltnS leq_addl.\nby rewrite mulgV [fmalpha 1]morph1 add0r.\nQed.",
    "Lemma morphim_center : GFunctor.pcontinuous (@center).\nProof. by move=> gT rT G D f; apply: morphim_subcent. Qed.",
    "Lemma subcentP A B x : reflect (x \\in A /\\ centralises x B) (x \\in 'C_A(B)).\nProof.\nrewrite inE. case: (x \\in A); last by right; case.\nby apply: (iffP centP) => [|[]].\nQed.",
    "Lemma subcent_sub A B : 'C_A(B) \\subset 'N_A(B).\nProof. by rewrite setIS ?cent_sub. Qed.",
    "Lemma subcent_norm G B : 'N_G(B) \\subset 'N('C_G(B)).\nProof. by rewrite normsI ?subIset ?normG // orbC cent_norm.  Qed.",
    "Lemma subcent_normal G B : 'C_G(B) <| 'N_G(B).\nProof. by rewrite /normal subcent_sub subcent_norm. Qed.",
    "Lemma subcent_char G H K : H \\char G -> K \\char G -> 'C_H(K) \\char G.\nProof.\ncase/charP=> sHG chHG /charP[sKG chKG]; apply/charP.\nsplit=> [|f injf Gf]; first by rewrite subIset ?sHG.\nby rewrite injm_subcent ?chHG ?chKG.\nQed.",
    "Lemma centerP A x : reflect (x \\in A /\\ centralises x A) (x \\in 'Z(A)).\nProof. exact: subcentP. Qed.",
    "Lemma center_sub A : 'Z(A) \\subset A.\nProof. exact: subsetIl. Qed.",
    "Lemma center1 : 'Z(1) = 1 :> {set gT}.\nProof. exact: gF1. Qed.",
    "Lemma centerC A : {in A, centralised 'Z(A)}.\nProof. by apply/centsP; rewrite centsC subsetIr. Qed.",
    "Lemma center_normal G : 'Z(G) <| G.\nProof. exact: gFnormal. Qed.",
    "Lemma sub_center_normal H G : H \\subset 'Z(G) -> H <| G.\nProof. by rewrite subsetI centsC /normal => /andP[-> /cents_norm]. Qed.",
    "Lemma center_abelian G : abelian 'Z(G).\nProof. by rewrite /abelian subIset // centsC subIset // subxx orbT. Qed.",
    "Lemma center_char G : 'Z(G) \\char G.\nProof. exact: gFchar. Qed.",
    "Lemma center_idP A : reflect ('Z(A) = A) (abelian A).\nProof. exact: setIidPl. Qed.",
    "Lemma center_class_formula G :\n  #|G| = #|'Z(G)| + \\sum_(xG in [set x ^: G | x in G :\\: 'C(G)]) #|xG|.\nProof.\nby rewrite acts_sum_card_orbit ?cardsID // astabsJ normsD ?norms_cent ?normG.\nQed.",
    "Lemma subcent1P A x y : reflect (y \\in A /\\ commute x y) (y \\in 'C_A[x]).\nProof.\nrewrite inE; case: (y \\in A); last by right; case.\nby apply: (iffP cent1P) => [|[]].\nQed.",
    "Lemma subcent1_id x G : x \\in G -> x \\in 'C_G[x].\nProof. by move=> Gx; rewrite inE Gx; apply/cent1P. Qed.",
    "Lemma subcent1_sub x G : 'C_G[x] \\subset G.\nProof. exact: subsetIl. Qed.",
    "Lemma subcent1C x y G : x \\in G -> y \\in 'C_G[x] -> x \\in 'C_G[y].\nProof. by move=> Gx /subcent1P[_ cxy]; apply/subcent1P. Qed.",
    "Lemma subcent1_cycle_sub x G : x \\in G -> <[x]> \\subset 'C_G[x].\nProof. by move=> Gx; rewrite cycle_subG ?subcent1_id. Qed.",
    "Lemma subcent1_cycle_norm x G : 'C_G[x] \\subset 'N(<[x]>).\nProof. by rewrite cents_norm // cent_gen cent_set1 subsetIr. Qed.",
    "Lemma subcent1_cycle_normal x G : x \\in G -> <[x]> <| 'C_G[x].\nProof.\nby move=> Gx; rewrite /normal subcent1_cycle_norm subcent1_cycle_sub.\nQed.",
    "Lemma cyclic_center_factor_abelian G : cyclic (G / 'Z(G)) -> abelian G.\nProof.\ncase/cyclicP=> a Ga; case: (cosetP a) => /= z Nz def_a.\nhave G_Zz: G :=: 'Z(G) * <[z]>.\n  rewrite -quotientK ?cycle_subG ?quotient_cycle //=.\n  by rewrite -def_a -Ga quotientGK // center_normal.\nrewrite G_Zz abelianM cycle_abelian center_abelian centsC /= G_Zz.\nby rewrite subIset ?centS ?orbT ?mulG_subr.\nQed.",
    "Lemma cyclic_factor_abelian H G :\n  H \\subset 'Z(G) -> cyclic (G / H) -> abelian G.\nProof.\nmove=> sHZ cycGH; apply: cyclic_center_factor_abelian.\nhave /andP[_ nHG]: H <| G := sub_center_normal sHZ.\nhave [f <-]:= homgP (homg_quotientS nHG (gFnorm _ G) sHZ).\nexact: morphim_cyclic cycGH.\nQed.",
    "Lemma injm_center G : G \\subset D -> f @* 'Z(G) = 'Z(f @* G).\nProof. exact: injm_subcent. Qed.",
    "Lemma isog_center (aT rT : finGroupType) (G : {group aT}) (H : {group rT}) :\n  G \\isog H -> 'Z(G) \\isog 'Z(H).\nProof. exact: gFisog. Qed.",
    "Lemma center_prod H K : K \\subset 'C(H) -> 'Z(H) * 'Z(K) = 'Z(H * K).\nProof.\nmove=> cHK; apply/setP=> z; rewrite {3}/center centM !inE.\nhave cKH: H \\subset 'C(K) by rewrite centsC.\napply/imset2P/and3P=> [[x y /setIP[Hx cHx] /setIP[Ky cKy] ->{z}]| []].\n  by rewrite imset2_f ?groupM // ?(subsetP cHK) ?(subsetP cKH).\ncase/imset2P=> x y Hx Ky ->{z}.\nrewrite groupMr => [cHx|]; last exact: subsetP Ky.\nrewrite groupMl => [cKy|]; last exact: subsetP Hx.\nby exists x y; rewrite ?inE ?Hx ?Ky.\nQed.",
    "Lemma center_cprod A B G : A \\* B = G -> 'Z(A) \\* 'Z(B) = 'Z(G).\nProof.\ncase/cprodP => [[H K -> ->] <- cHK].\nrewrite cprodE ?center_prod //= subIset ?(subset_trans cHK) //.\nby rewrite centS ?center_sub.\nQed.",
    "Lemma center_bigcprod I r P (F : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) F i = G ->\n  \\big[cprod/1]_(i <- r | P i) 'Z(F i) = 'Z(G).\nProof.\nelim/big_ind2: _ G => [_ <-|A B C D IHA IHB G dG|_ _ G ->]; rewrite ?center1 //.\ncase/cprodP: dG IHA IHB (dG) => [[H K -> ->] _ _] IHH IHK dG.\nby rewrite (IHH H) // (IHK K) // (center_cprod dG).\nQed.",
    "Lemma cprod_center_id G : G \\* 'Z(G) = G.\nProof. by rewrite cprodE ?subsetIr // mulGSid ?center_sub. Qed.",
    "Lemma center_dprod A B G : A \\x B = G -> 'Z(A) \\x 'Z(B) = 'Z(G).\nProof.\ncase/dprodP=> [[H1 H2 -> ->] defG cH12 trH12].\nmove: defG; rewrite -cprodE // => /center_cprod/cprodP[_ /= <- cZ12].\nby apply: dprodE; rewrite //= setIAC setIA -setIA trH12 (setIidPl _) ?sub1G.\nQed.",
    "Lemma center_bigdprod I r P (F: I -> {set gT}) G :\n    \\big[dprod/1]_(i <- r | P i) F i = G ->\n  \\big[dprod/1]_(i <- r | P i) 'Z(F i) = 'Z(G).\nProof.\nelim/big_ind2: _ G => [_ <-|A B C D IHA IHB G dG|_ _ G ->]; rewrite ?center1 //.\ncase/dprodP: dG IHA IHB (dG) => [[H K -> ->] _ _ _] IHH IHK dG.\nby rewrite (IHH H) // (IHK K) // (center_dprod dG).\nQed.",
    "Lemma Aut_cprod_full G H K :\n    H \\* K = G -> 'Z(H) = 'Z(K) ->\n    Aut_in (Aut H) 'Z(H) \\isog Aut 'Z(H) ->\n    Aut_in (Aut K) 'Z(K) \\isog Aut 'Z(K) ->\n  Aut_in (Aut G) 'Z(G) \\isog Aut 'Z(G).\nProof.\nmove=> defG eqZHK; have [_ defHK cHK] := cprodP defG.\nhave defZ: 'Z(G) = 'Z(H) by rewrite -defHK -center_prod // eqZHK mulGid.\nhave ziHK: H :&: K = 'Z(K).\n  by apply/eqP; rewrite eqEsubset subsetI -{1 2}eqZHK !center_sub setIS.\nhave AutZP := Aut_sub_fullP (@center_sub gT _).\nmove/AutZP=> AutZHfull /AutZP AutZKfull; apply/AutZP=> g injg gZ.\nhave [gH [def_gH ker_gH _ im_gH]] := domP g defZ.\nhave [gK [def_gK ker_gK _ im_gK]] := domP g (etrans defZ eqZHK).\nhave [injgH injgK]: 'injm gH /\\ 'injm gK by rewrite ker_gH ker_gK.\nhave [gHH gKK]: gH @* 'Z(H) = 'Z(H) /\\ gK @* 'Z(K) = 'Z(K).\n  by rewrite im_gH im_gK -eqZHK -defZ.\nhave [|fH [injfH im_fH fHZ]] := AutZHfull gH injgH.\n  by rewrite im_gH /= -defZ.\nhave [|fK [injfK im_fK fKZ]] := AutZKfull gK injgK.\n  by rewrite im_gK /= -eqZHK -defZ.\nhave cfHK: fK @* K \\subset 'C(fH @* H) by rewrite im_fH im_fK.\nhave eq_fHK: {in H :&: K, fH =1 fK}.\n  by move=> z; rewrite ziHK => Zz; rewrite fHZ ?fKZ /= ?eqZHK // def_gH def_gK.\nexists (cprodm_morphism defG cfHK eq_fHK).\nrewrite injm_cprodm injfH injfK im_cprodm im_fH im_fK defHK.\nrewrite -morphimIdom ziHK -eqZHK injm_center // im_fH eqxx.\nsplit=> //= z; rewrite {1}defZ => Zz; have [Hz _] := setIP Zz.\nby rewrite cprodmEl // fHZ // def_gH.\nQed.",
    "Lemma ker_cprod_by_is_group : group_set kerHK.\nProof.\napply/group_setP; rewrite inE /= group1 morph1 invg1 /=.\nsplit=> // [[x1 y1] [x2 y2]].\nrewrite inE /= => /andP[Zx1 /eqP->]; have [_ cGx1] := setIP Zx1.\nrewrite inE /= => /andP[Zx2 /eqP->]; have [Gx2 _] := setIP Zx2.\nby rewrite inE /= groupM //= -invMg (centP cGx1) // morphM.\nQed.",
    "Lemma ker_cprod_by_central : kerHK \\subset 'Z(setX H K).\nProof.\nrewrite -(center_dprod (setX_dprod H K)) -morphim_pairg1 -morphim_pair1g.\nrewrite -!injm_center ?subsetT ?injm_pair1g ?injm_pairg1 //=.\nrewrite morphim_pairg1 morphim_pair1g setX_dprod.\napply/subsetP=> [[x y]] /[1!inE] /andP[Zx /eqP->].\nby rewrite inE /= Zx groupV (subsetP sgzZZ) ?mem_morphim.\nQed.",
    "Lemma in_cprodM : {in setX H K &, {morph in_cprod : u v / u * v}}.\nProof.\nrewrite /in_cprod /cprod_by; case: cprod_by_key => /= u v Gu Gv.\nhave nkerHKG := normal_norm (sub_center_normal ker_cprod_by_central).\nby rewrite -!morphM ?mem_quotient // (subsetP nkerHKG).\nQed.",
    "Lemma ker_in_cprod : 'ker in_cprod = kerHK.\nProof.\ntransitivity ('ker (subg [group of setX H K / kerHK] \\o coset kerHK)).\n  rewrite /ker /morphpre /= /in_cprod /cprod_by; case: cprod_by_key => /=.\n  by rewrite ['N(_) :&: _]quotientGK ?sub_center_normal ?ker_cprod_by_central.\nby rewrite ker_comp ker_subg -kerE ker_coset.\nQed.",
    "Lemma cpairg1_dom : H \\subset 'dom (in_cprod \\o @pairg1 gTH gTK).\nProof. by rewrite -sub_morphim_pre ?subsetT // morphim_pairg1 setXS ?sub1G. Qed.",
    "Lemma cpair1g_dom : K \\subset 'dom (in_cprod \\o @pair1g gTH gTK).\nProof. by rewrite -sub_morphim_pre ?subsetT // morphim_pair1g setXS ?sub1G. Qed.",
    "Lemma injm_cpairg1 : 'injm cpairg1.\nProof.\nrewrite /cpairg1; case: restrmP => _ [_ -> _ _].\nrewrite ker_comp ker_in_cprod; apply/subsetP=> x; rewrite 5!inE /=.\nby case/and3P=> _ Zx; rewrite inE eq_sym (inv_eq invgK) invg1 morph_injm_eq1.\nQed.",
    "Lemma injm_cpair1g : 'injm cpair1g.\nProof.\nrewrite /cpair1g; case: restrmP => _ [_ -> _ _].\nrewrite ker_comp ker_in_cprod; apply/subsetP=> y; rewrite !inE /= morph1 invg1.\nby case/and3P.\nQed.",
    "Lemma im_cpair_cent : CK \\subset 'C(CH).\nProof.\nrewrite /cpairg1 /cpair1g; do 2!case: restrmP => _ [_ _ _ -> //].\nrewrite !morphim_comp morphim_cents // morphim_pair1g morphim_pairg1.\nby case/dprodP: (setX_dprod H K).\nQed.",
    "Lemma im_cpair : CH * CK = C.\nProof.\nrewrite /cpairg1 /cpair1g; do 2!case: restrmP => _ [_ _ _ -> //].\nrewrite !morphim_comp -morphimMl morphim_pairg1 ?setXS ?sub1G //.\nrewrite morphim_pair1g setX_prod morphimEdom /= /in_cprod /cprod_by.\nby case: cprod_by_key; rewrite /= imset_comp imset_coset -morphimEdom im_subg.\nQed.",
    "Lemma im_cpair_cprod : CH \\* CK = C. Proof. by rewrite cprodE ?im_cpair. Qed.",
    "Lemma eq_cpairZ : {in 'Z(H), cpairg1 =1 cpair1g \\o gz}.\nProof.\nrewrite /cpairg1 /cpair1g => z1 Zz1; set z2 := gz z1.\nhave Zz2: z2 \\in 'Z(K) by rewrite (subsetP sgzZZ) ?mem_morphim.\nhave [[Gz1 _] [/= Gz2 _]]:= (setIP Zz1, setIP Zz2).\ndo 2![case: restrmP => f /= [df _ _ _]; rewrite {f}df].\napply/rcoset_kerP; rewrite ?inE ?group1 ?andbT //.\nby rewrite ker_in_cprod mem_rcoset inE /= invg1 mulg1 mul1g Zz1 /=.\nQed.",
    "Lemma setI_im_cpair : CH :&: CK = 'Z(CH).\nProof.\napply/eqP; rewrite eqEsubset setIS //=.\nrewrite subsetI center_sub -injm_center //.\nrewrite (eq_in_morphim _ eq_cpairZ); first by rewrite morphim_comp morphimS.\nby rewrite !(setIidPr _) // -sub_morphim_pre.\nQed.",
    "Lemma cpair1g_center : cpair1g @* 'Z(K) = 'Z(C).\nProof.\ncase/cprodP: (center_cprod im_cpair_cprod) => _ <- _.\nby rewrite injm_center // -setI_im_cpair mulSGid //= setIC setIS 1?centsC.\nQed.",
    "Lemma cpair_center_id : 'Z(CH) = 'Z(CK).\nProof.\nrewrite -!injm_center // -gzZ -morphim_comp; apply: eq_in_morphim eq_cpairZ.\nby rewrite !(setIidPr _) // -sub_morphim_pre.\nQed.",
    "Lemma cpairg1_center : cpairg1 @* 'Z(H) = 'Z(C).\nProof. by rewrite -cpair1g_center !injm_center // cpair_center_id. Qed.",
    "Lemma xcprodm_cent : gK @* CK \\subset 'C(gH @* CH).\nProof. by rewrite !im_ifactm. Qed.",
    "Lemma xcprodmI : {in CH :&: CK, gH =1 gK}.\nProof.\nrewrite setI_im_cpair -injm_center // => fHx; case/morphimP=> x Gx Zx ->{fHx}.\nby rewrite {2}eq_cpairZ //= ?ifactmE ?eq_fHK //= (subsetP sgzZG) ?mem_morphim.\nQed.",
    "Lemma xcprodmEl : {in H, forall x, xcprodm (cpairg1 x) = fH x}.\nProof. by move=> x Hx; rewrite /xcprodm cprodmEl ?mem_morphim ?ifactmE. Qed.",
    "Lemma xcprodmEr : {in K, forall y, xcprodm (cpair1g y) = fK y}.\nProof. by move=> y Ky; rewrite /xcprodm cprodmEr ?mem_morphim ?ifactmE. Qed.",
    "Lemma xcprodmE :\n  {in H & K, forall x y, xcprodm (cpairg1 x * cpair1g y) = fH x * fK y}.\nProof.\nby move=> x y Hx Ky; rewrite /xcprodm cprodmE ?mem_morphim ?ifactmE.\nQed.",
    "Lemma im_xcprodm : xcprodm @* C = fH @* H * fK @* K.\nProof. by rewrite -im_cpair morphim_cprodm // !im_ifactm. Qed.",
    "Lemma im_xcprodml A : xcprodm @* (cpairg1 @* A) = fH @* A.\nProof.\nrewrite -!(morphimIdom _ A) morphim_cprodml ?morphimS ?subsetIl //.\nby rewrite morphim_ifactm ?subsetIl.\nQed.",
    "Lemma im_xcprodmr A : xcprodm @* (cpair1g @* A) = fK @* A.\nProof.\nrewrite -!(morphimIdom _ A) morphim_cprodmr ?morphimS ?subsetIl //.\nby rewrite morphim_ifactm ?subsetIl.\nQed.",
    "Lemma injm_xcprodm : 'injm xcprodm = 'injm fH && 'injm fK.\nProof.\nrewrite injm_cprodm !ker_ifactm !subG1 !morphim_injm_eq1 ?subsetIl // -!subG1.\napply: andb_id2l => /= injfH; apply: andb_idr => _.\nrewrite !im_ifactm // -(morphimIdom gH) setI_im_cpair -injm_center //.\nrewrite morphim_ifactm // eqEsubset subsetI morphimS //=.\nrewrite {1}injm_center // setIS //=.\nrewrite (eq_in_morphim _ eq_fHK); first by rewrite morphim_comp morphimS.\nby rewrite !(setIidPr _) // -sub_morphim_pre.\nQed.",
    "Lemma Aut_cprod_by_full :\n    Aut_in (Aut H) 'Z(H) \\isog Aut 'Z(H) ->\n    Aut_in (Aut K) 'Z(K) \\isog Aut 'Z(K) ->\n  Aut_in (Aut C) 'Z(C) \\isog Aut 'Z(C).\nProof.\nmove=> AutZinH AutZinK.\nhave Cfull:= Aut_cprod_full im_cpair_cprod cpair_center_id.\nby rewrite Cfull // -injm_center // injm_Aut_full ?center_sub.\nQed.",
    "Lemma cprod_by_uniq :\n  exists f : {morphism G >-> cprod_by},\n    [/\\ isom G C f, f @* GH = CH & f @* GK = CK].\nProof.\nhave [_ defGHK cGKH] := cprodP defG.\nhave AutZinH := Aut_sub_fullP sZH AutZHfull.\nhave [fH injfH defGH]:= isogP (isog_symr isoGH).\nhave [fK injfK defGK]:= isogP (isog_symr isoGK).\nhave sfHZfK: fH @* 'Z(H) \\subset fK @* K.\n  by rewrite injm_center //= defGH defGK -ziGHK subsetIr.\nhave gzZ_id: gz @* 'Z(H) = invm injfK @* (fH @* 'Z(H)).\n  apply: gzZ_lone => /=.\n    rewrite injm_center // defGH -ziGHK sub_morphim_pre /= ?defGK ?subsetIr //.\n    by rewrite setIC morphpre_invm injm_center // defGK setIS 1?centsC.\n  rewrite -morphim_comp.\n  apply: isog_trans (sub_isog _ _); first by rewrite isog_sym sub_isog.\n    by rewrite -sub_morphim_pre.\n  by rewrite !injm_comp ?injm_invm.\nhave: 'dom (invm injfH \\o fK \\o gz) = 'Z(H).\n  rewrite /dom /= -(morphpreIdom gz); apply/setIidPl.\n  by rewrite -2?sub_morphim_pre // gzZ_id morphim_invmE morphpreK ?morphimS.\ncase/domP=> gzH [def_gzH ker_gzH _ im_gzH].\nhave{ker_gzH} injgzH: 'injm gzH by rewrite ker_gzH !injm_comp ?injm_invm.\nhave{AutZinH} [|gH [injgH gH_H def_gH]] := AutZinH _ injgzH.\n  by rewrite im_gzH !morphim_comp /= gzZ_id !morphim_invmE morphpreK ?injmK.\nhave: 'dom (fH \\o gH) = H by rewrite /dom /= -{3}gH_H injmK.\ncase/domP=> gfH [def_gfH ker_gfH _ im_gfH].\nhave{im_gfH} gfH_H: gfH @* H = GH by rewrite im_gfH morphim_comp gH_H.\nhave cgfHfK: fK @* K \\subset 'C(gfH @* H) by rewrite gfH_H defGK.\nhave eq_gfHK: {in 'Z(H), gfH =1 fK \\o gz}.\n  move=> z Zz; rewrite def_gfH /= def_gH //= def_gzH /= invmK //.\n  have {Zz}: gz z \\in gz @* 'Z(H) by rewrite mem_morphim.\n  rewrite gzZ_id morphim_invmE; case/morphpreP=> _.\n  exact: (subsetP (morphimS _ _)).\npose f := xcprodm cgfHfK eq_gfHK.\nhave injf: 'injm f by rewrite injm_xcprodm ker_gfH injm_comp.\nhave fCH: f @* CH = GH by rewrite im_xcprodml gfH_H.\nhave fCK: f @* CK = GK by rewrite im_xcprodmr defGK.\nhave fC: f @* C = G by rewrite im_xcprodm gfH_H defGK defGHK.\nhave [f' [_ ker_f' _ im_f']] := domP (invm_morphism injf) fC.\nexists f'; rewrite -fCH -fCK !{1}im_f' !{1}morphim_invm ?subsetT //.\nby split=> //; apply/isomP; rewrite ker_f' injm_invm im_f' -fC im_invm.\nQed.",
    "Lemma isog_cprod_by : G \\isog C.\nProof. by have [f [isoG _ _]] := cprod_by_uniq; apply: isom_isog isoG. Qed.",
    "Lemma xcprod_subproof :\n  {gz : {morphism 'Z(H) >-> gt_ isob} | isom 'Z(H) 'Z(G_ isob) gz}.\nProof.\ncase: (pickP [pred f : {ffun _} | misom 'Z(H) 'Z(K) f]) => [f isoZ | no_f].\n  rewrite (misom_isog isoZ); case/andP: isoZ => fM isoZ.\n  by exists [morphism of morphm fM].\nmove/pred0P: no_f => not_isoZ; rewrite [isob](congr1 negb not_isoZ).\nby exists (idm_morphism  _); apply/isomP; rewrite injm_idm im_idm.\nQed.",
    "Lemma xcprodP : 'Z(H) \\isog 'Z(K) -> xcprod_spec xcprod.\nProof. by rewrite /xcprod => isoZ; move: xcprod_subproof; rewrite isoZ. Qed.",
    "Lemma isog_xcprod (rT : finGroupType) (GH GK G : {group rT}) :\n    Aut_in (Aut H) 'Z(H) \\isog Aut 'Z(H) ->\n    GH \\isog H -> GK \\isog K -> GH \\* GK = G -> 'Z(GH) = 'Z(GK) ->\n  G \\isog [set: xcprod].\nProof.\nmove=> AutZinH isoGH isoGK defG eqZGHK; have [_ _ cGHK] := cprodP defG.\nhave [|gz isoZ] := xcprodP.\n  have [[fH injfH <-] [fK injfK <-]] := (isogP isoGH, isogP isoGK).\n  rewrite -!injm_center -?(isog_transl _ (sub_isog _ _)) ?center_sub //=.\n  by rewrite eqZGHK sub_isog ?center_sub.\nrewrite (isog_cprod_by _ defG) //.\nby apply/eqP; rewrite eqEsubset setIS // subsetI {2}eqZGHK !center_sub.\nQed.",
    "Lemma ncprod0 : G_ 0 \\isog 'Z(G).\nProof. by rewrite [ncprod]unlock isog_sym isog_subg. Qed.",
    "Lemma center_ncprod0 : 'Z(G_ 0) = G_ 0.\nProof. by apply: center_idP; rewrite (isog_abelian ncprod0) center_abelian. Qed.",
    "Lemma center_ncprod n : 'Z(G_ n) \\isog 'Z(G).\nProof.\nelim: n => [|n]; first by rewrite center_ncprod0 ncprod0.\nrewrite [ncprod]unlock=> /isog_symr/xcprodP[gz isoZ] /=.\nby rewrite -cpairg1_center isog_sym sub_isog ?center_sub ?injm_cpairg1.\nQed.",
    "Lemma ncprodS n : xcprod_spec G [set: ncprod n] (ncprod n.+1).\nProof.\nby have:= xcprodP (isog_symr (center_ncprod n)); rewrite [ncprod]unlock.\nQed.",
    "Lemma ncprod1 : G_ 1 \\isog G.\nProof.\ncase: ncprodS => gz isoZ; rewrite isog_sym /= -im_cpair.\nrewrite mulGSid /=; first by rewrite sub_isog ?injm_cpairg1.\nrewrite -{3}center_ncprod0 injm_center ?injm_cpair1g //.\nby rewrite -cpair_center_id center_sub.\nQed.",
    "Lemma Aut_ncprod_full n :\n    Aut_in (Aut G) 'Z(G) \\isog Aut 'Z(G) ->\n  Aut_in (Aut (G_ n)) 'Z(G_ n) \\isog Aut 'Z(G_ n).\nProof.\nmove=> AutZinG; elim: n => [|n IHn].\n  by rewrite center_ncprod0; apply/Aut_sub_fullP=> // g injg gG0; exists g.\nby case: ncprodS => gz isoZ; apply: Aut_cprod_by_full.\nQed.",
    "Lemma cyclicP A : reflect (exists x, A = <[x]>) (cyclic A).\nProof. exact: exists_eqP. Qed.",
    "Lemma cycle_cyclic x : cyclic <[x]>.\nProof. by apply/cyclicP; exists x. Qed.",
    "Lemma cyclic1 : cyclic [1 gT].\nProof. by rewrite -cycle1 cycle_cyclic. Qed.",
    "Lemma ZpmM : {in Zp #[a] &, {morph Zpm : x y / x * y}}.\nProof.\nrewrite /Zpm; case: (eqVneq a 1) => [-> | nta] i j _ _.\n  by rewrite !expg1n ?mulg1.\nby rewrite /= {3}Zp_cast ?order_gt1 // expg_mod_order expgD.\nQed.",
    "Lemma im_Zpm : Zpm @* Zp #[a] = <[a]>.\nProof.\napply/eqP; rewrite eq_sym eqEcard cycle_subG /= andbC morphimEdom.\nrewrite (leq_trans (leq_imset_card _ _)) ?card_Zp //= /Zp order_gt1.\ncase: eqP => /= [a1 | _]; first by rewrite imset_set1 morph1 a1 set11.\nby apply/imsetP; exists 1%R; rewrite ?expg1 ?inE.\nQed.",
    "Lemma injm_Zpm : 'injm Zpm.\nProof.\napply/injmP/dinjectiveP/card_uniqP.\nrewrite size_map -cardE card_Zp //= {7}/order -im_Zpm morphimEdom /=.\nby apply: eq_card => x; apply/imageP/imsetP=> [] [i Zp_i ->]; exists i.\nQed.",
    "Lemma eq_expg_mod_order m n : (a ^+ m == a ^+ n) = (m == n %[mod #[a]]).\nProof.\nhave [->|] := eqVneq a 1; first by rewrite order1 !modn1 !expg1n eqxx.\nrewrite -order_gt1 => lt1a; have ZpT: Zp #[a] = setT by rewrite /Zp lt1a.\nhave: injective Zpm by move=> i j; apply (injmP injm_Zpm); rewrite /= ZpT inE.\nmove/inj_eq=> eqZ; symmetry; rewrite -(Zp_cast lt1a).\nby rewrite -[_ == _](eqZ (inZp m) (inZp n)) /Zpm /= Zp_cast ?expg_mod_order.\nQed.",
    "Lemma eq_expg_ord d (m n : 'I_d) :\n  d <= #[a]%g -> (a ^+ m == a ^+ n) = (m == n).\nProof.\nby move=> d_leq; rewrite eq_expg_mod_order !modn_small// (leq_trans _ d_leq).\nQed.",
    "Lemma expgD_Zp d (n m : 'Z_d) : (d > 0)%N ->\n  #[a]%g %| d -> a ^+ (n + m)%R = a ^+ n * a ^+ m.\nProof.\nmove=> d_gt0 xdvd; apply/eqP; rewrite -expgD eq_expg_mod_order/= modn_dvdm//.\nby case: d d_gt0 {m n} xdvd => [|[|[]]]//= _; rewrite dvdn1 => /eqP->.\nQed.",
    "Lemma Zp_isom : isom (Zp #[a]) <[a]> Zpm.\nProof. by apply/isomP; rewrite injm_Zpm im_Zpm. Qed.",
    "Lemma Zp_isog : isog (Zp #[a]) <[a]>.\nProof. exact: isom_isog Zp_isom. Qed.",
    "Lemma cyclic_abelian A : cyclic A -> abelian A.\nProof. by case/cyclicP=> a ->; apply: cycle_abelian. Qed.",
    "Lemma cycleMsub a b :\n  commute a b -> coprime #[a] #[b] -> <[a]> \\subset <[a * b]>.\nProof.\nmove=> cab co_ab; apply/subsetP=> _ /cycleP[k ->].\napply/cycleP; exists (chinese #[a] #[b] k 0); symmetry.\nrewrite expgMn // -expg_mod_order chinese_modl // expg_mod_order.\nby rewrite /chinese addn0 -mulnA mulnCA expgM expg_order expg1n mulg1.\nQed.",
    "Lemma cycleM a b :\n  commute a b -> coprime #[a] #[b] -> <[a * b]> = <[a]> * <[b]>.\nProof.\nmove=> cab co_ab; apply/eqP; rewrite eqEsubset -(cent_joinEl (cents_cycle cab)).\nrewrite join_subG {3}cab !cycleMsub // 1?coprime_sym //.\nby rewrite -genM_join cycle_subG mem_gen // imset2_f ?cycle_id.\nQed.",
    "Lemma cyclicM A B :\n    cyclic A -> cyclic B -> B \\subset 'C(A) -> coprime #|A| #|B| ->\n  cyclic (A * B).\nProof.\nmove=> /cyclicP[a ->] /cyclicP[b ->]; rewrite cent_cycle cycle_subG => cab coab.\nby rewrite -cycleM ?cycle_cyclic //; apply/esym/cent1P.\nQed.",
    "Lemma cyclicY K H :\n    cyclic K -> cyclic H -> H \\subset 'C(K) -> coprime #|K| #|H| ->\n  cyclic (K <*> H).\nProof. by move=> cycK cycH cKH coKH; rewrite cent_joinEr // cyclicM. Qed.",
    "Lemma order_dvdn a n : #[a] %| n = (a ^+ n == 1).\nProof. by rewrite (eq_expg_mod_order a n 0) mod0n. Qed.",
    "Lemma order_inf a n : a ^+ n.+1 == 1 -> #[a] <= n.+1.\nProof. by rewrite -order_dvdn; apply: dvdn_leq. Qed.",
    "Lemma order_dvdG G a : a \\in G -> #[a] %| #|G|.\nProof. by move=> Ga; apply: cardSg; rewrite cycle_subG. Qed.",
    "Lemma expg_cardG G a : a \\in G -> a ^+ #|G| = 1.\nProof. by move=> Ga; apply/eqP; rewrite -order_dvdn order_dvdG. Qed.",
    "Lemma expg_znat G x k : x \\in G -> x ^+ (k%:R : 'Z_(#|G|))%R = x ^+ k.\nProof.\ncase: (eqsVneq G 1) => [-> /set1P-> | ntG Gx]; first by rewrite !expg1n.\napply/eqP; rewrite val_Zp_nat ?cardG_gt1 // eq_expg_mod_order.\nby rewrite modn_dvdm ?order_dvdG.\nQed.",
    "Lemma expg_zneg G x (k : 'Z_(#|G|)) : x \\in G -> x ^+ (- k)%R = x ^- k.\nProof.\nmove=> Gx; apply/eqP; rewrite eq_sym eq_invg_mul -expgD.\nby rewrite -(expg_znat _ Gx) natrD natr_Zp natr_negZp subrr.\nQed.",
    "Lemma nt_gen_prime G x : prime #|G| -> x \\in G^# -> G :=: <[x]>.\nProof.\nmove=> Gpr /setD1P[]; rewrite -cycle_subG -cycle_eq1 => ntX sXG.\napply/eqP; rewrite eqEsubset sXG andbT.\nby apply: contraR ntX => /(prime_TIg Gpr); rewrite (setIidPr sXG) => ->.\nQed.",
    "Lemma nt_prime_order p x : prime p -> x ^+ p = 1 -> x != 1 -> #[x] = p.\nProof.\nmove=> p_pr xp ntx; apply/prime_nt_dvdP; rewrite ?order_eq1 //.\nby rewrite order_dvdn xp.\nQed.",
    "Lemma orderXdvd a n : #[a ^+ n] %| #[a].\nProof. by apply: order_dvdG; apply: mem_cycle. Qed.",
    "Lemma orderXgcd a n : #[a ^+ n] = #[a] %/ gcdn #[a] n.\nProof.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  rewrite order_dvdn -expgM -muln_divCA_gcd //.\n  by rewrite expgM expg_order expg1n.\nhave [-> | n_gt0] := posnP n; first by rewrite gcdn0 divnn order_gt0 dvd1n.\nrewrite -(dvdn_pmul2r n_gt0) divn_mulAC ?dvdn_gcdl // dvdn_lcm.\nby rewrite order_dvdn mulnC expgM expg_order eqxx dvdn_mulr.\nQed.",
    "Lemma orderXdiv a n : n %| #[a] -> #[a ^+ n] = #[a] %/ n.\nProof. by case/dvdnP=> q defq; rewrite orderXgcd {2}defq gcdnC gcdnMl. Qed.",
    "Lemma orderXexp p m n x : #[x] = (p ^ n)%N -> #[x ^+ (p ^ m)] = (p ^ (n - m))%N.\nProof.\nmove=> ox; have [n_le_m | m_lt_n] := leqP n m.\n  rewrite -(subnKC n_le_m) subnDA subnn expnD expgM -ox.\n  by rewrite expg_order expg1n order1.\nrewrite orderXdiv ox ?dvdn_exp2l ?expnB ?(ltnW m_lt_n) //.\nby have:= order_gt0 x; rewrite ox expn_gt0 orbC -(ltn_predK m_lt_n).\nQed.",
    "Lemma orderXpfactor p k n x :\n  #[x ^+ (p ^ k)] = n -> prime p -> p %| n -> #[x] = (p ^ k * n)%N.\nProof.\nmove=> oxp p_pr dv_p_n.\nsuffices pk_x: p ^ k %| #[x] by rewrite -oxp orderXdiv // mulnC divnK.\nrewrite pfactor_dvdn // leqNgt; apply: contraL dv_p_n => lt_x_k.\nrewrite -oxp -p'natE // -(subnKC (ltnW lt_x_k)) expnD expgM.\nrewrite (pnat_dvd (orderXdvd _ _)) // -p_part // orderXdiv ?dvdn_part //.\nby rewrite -{1}[#[x]](partnC p) // mulKn // part_pnat.\nQed.",
    "Lemma orderXprime p n x :\n  #[x ^+ p] = n -> prime p -> p %| n -> #[x] = (p * n)%N.\nProof. exact: (@orderXpfactor p 1). Qed.",
    "Lemma orderXpnat m n x : #[x ^+ m] = n -> \\pi(n).-nat m -> #[x] = (m * n)%N.\nProof.\nmove=> oxm n_m; have [m_gt0 _] := andP n_m.\nsuffices m_x: m %| #[x] by rewrite -oxm orderXdiv // mulnC divnK.\napply/dvdn_partP=> // p; rewrite mem_primes => /and3P[p_pr _ p_m].\nhave n_p: p \\in \\pi(n) by apply: (pnatP _ _ n_m).\nhave p_oxm: p %| #[x ^+ (p ^ logn p m)].\n  apply: dvdn_trans (orderXdvd _ m`_p^'); rewrite -expgM -p_part ?partnC //.\n  by rewrite oxm; rewrite mem_primes in n_p; case/and3P: n_p.\nby rewrite (orderXpfactor (erefl _) p_pr p_oxm) p_part // dvdn_mulr.\nQed.",
    "Lemma orderM a b :\n  commute a b -> coprime #[a] #[b] -> #[a * b] = (#[a] * #[b])%N.\nProof. by move=> cab co_ab; rewrite -coprime_cardMg -?cycleM. Qed.",
    "Lemma expgK G k :\n  coprime #|G| k -> {in G, cancel (expgn^~ k) (expgn^~ (expg_invn G k))}.\nProof.\nmove=> coGk x /order_dvdG Gx; apply/eqP.\nrewrite -expgM (eq_expg_mod_order _ _ 1) -(modn_dvdm 1 Gx).\nby rewrite -(chinese_modl coGk 1 0) /chinese mul1n addn0 modn_dvdm.\nQed.",
    "Lemma cyclic_dprod K H G :\n  K \\x H = G -> cyclic K -> cyclic H -> cyclic G = coprime #|K| #|H| .\nProof.\ncase/dprodP=> _ defKH cKH tiKH cycK cycH; pose m := lcmn #|K| #|H|.\napply/idP/idP=> [/cyclicP[x defG] | coKH]; last by rewrite -defKH cyclicM.\nrewrite /coprime -dvdn1 -(@dvdn_pmul2l m) ?lcmn_gt0 ?cardG_gt0 //.\nrewrite muln_lcm_gcd muln1 -TI_cardMg // defKH defG order_dvdn.\nhave /mulsgP[y z Ky Hz ->]: x \\in K * H by rewrite defKH defG cycle_id.\nrewrite -[1]mulg1 expgMn; last exact/commute_sym/(centsP cKH).\napply/eqP; congr (_ * _); apply/eqP; rewrite -order_dvdn.\n  exact: dvdn_trans (order_dvdG Ky) (dvdn_lcml _ _).\nexact: dvdn_trans (order_dvdG Hz) (dvdn_lcmr _ _).\nQed.",
    "Lemma generator_cycle a : generator <[a]> a.\nProof. exact: eqxx. Qed.",
    "Lemma cycle_generator a x : generator <[a]> x -> x \\in <[a]>.\nProof. by move/(<[a]> =P _)->; apply: cycle_id. Qed.",
    "Lemma generator_order a b : generator <[a]> b -> #[a] = #[b].\nProof. by rewrite /order => /(<[a]> =P _)->. Qed.",
    "Lemma eltmE i : eltm dvd_y_x (x ^+ i) = y ^+ i.\nProof.\napply/eqP; rewrite eq_expg_mod_order.\nhave [x_le1 | x_gt1] := leqP #[x] 1.\n  suffices: #[y] %| 1 by rewrite dvdn1 => /eqP->; rewrite !modn1.\n  by rewrite (dvdn_trans dvd_y_x) // dvdn1 order_eq1 -cycle_eq1 trivg_card_le1.\nrewrite -(expg_znat i (cycle_id x)) invmE /=; last by rewrite /Zp x_gt1 inE.\nby rewrite val_Zp_nat // modn_dvdm.\nQed.",
    "Lemma eltm_id : eltm dvd_y_x x = y. Proof. exact: (eltmE 1). Qed.",
    "Lemma eltmM : {in <[x]> &, {morph eltm dvd_y_x : x_i x_j / x_i * x_j}}.\nProof.\nmove=> _ _ /cycleP[i ->] /cycleP[j ->].\nby apply/eqP; rewrite -expgD !eltmE expgD.\nQed.",
    "Lemma im_eltm : eltm dvd_y_x @* <[x]> = <[y]>.\nProof. by rewrite morphim_cycle ?cycle_id //= eltm_id. Qed.",
    "Lemma ker_eltm : 'ker (eltm dvd_y_x) = <[x ^+ #[y]]>.\nProof.\napply/eqP; rewrite eq_sym eqEcard cycle_subG 3!inE mem_cycle /= eltmE.\nrewrite expg_order eqxx (orderE y) -im_eltm card_morphim setIid -orderE.\nby rewrite orderXdiv ?dvdn_indexg //= leq_divRL ?indexg_gt0 ?Lagrange ?subsetIl.\nQed.",
    "Lemma injm_eltm : 'injm (eltm dvd_y_x) = (#[x] %| #[y]).\nProof. by rewrite ker_eltm subG1 cycle_eq1 -order_dvdn. Qed.",
    "Lemma cycle_sub_group (a : gT) m :\n     m %| #[a] ->\n  [set H : {group gT} | H \\subset <[a]> & #|H| == m]\n     = [set <[a ^+ (#[a] %/ m)]>%G].\nProof.\nmove=> m_dv_a; have m_gt0: 0 < m by apply: dvdn_gt0 m_dv_a.\nhave oam: #|<[a ^+ (#[a] %/ m)]>| = m.\n  apply/eqP; rewrite [#|_|]orderXgcd -(divnMr m_gt0) muln_gcdl divnK //.\n  by rewrite gcdnC gcdnMr mulKn.\napply/eqP; rewrite eqEsubset sub1set inE /= cycleX oam eqxx !andbT.\napply/subsetP=> X; rewrite in_set1 inE -val_eqE /= eqEcard oam.\ncase/andP=> sXa /eqP oX; rewrite oX leqnn andbT.\napply/subsetP=> x Xx; case/cycleP: (subsetP sXa _ Xx) => k def_x.\nhave: (x ^+ m == 1)%g by rewrite -oX -order_dvdn cardSg // gen_subG sub1set.\nrewrite {x Xx}def_x -expgM -order_dvdn -[#[a]](Lagrange sXa) -oX mulnC.\nrewrite dvdn_pmul2r // mulnK // => /dvdnP[i ->].\nby rewrite mulnC expgM groupX // cycle_id.\nQed.",
    "Lemma cycle_subgroup_char a (H : {group gT}) : H \\subset <[a]> -> H \\char <[a]>.\nProof.\nmove=> sHa; apply: lone_subgroup_char => // J sJa isoJH.\nhave dvHa: #|H| %| #[a] by apply: cardSg.\nhave{dvHa} /setP Huniq := esym (cycle_sub_group dvHa).\nmove: (Huniq H) (Huniq J); rewrite !inE /=.\nby rewrite sHa sJa (card_isog isoJH) eqxx => /eqP<- /eqP<-.\nQed.",
    "Lemma morph_order : #[f x] %| #[x].\nProof. by rewrite order_dvdn -morphX // expg_order morph1. Qed.",
    "Lemma morph_generator A : generator A x -> generator (f @* A) (f x).\nProof. by move/(A =P _)->; rewrite /generator morphim_cycle. Qed.",
    "Lemma cyclicS G H : H \\subset G -> cyclic G -> cyclic H.\nProof.\nmove=> sHG /cyclicP[x defG]; apply/cyclicP.\nexists (x ^+ (#[x] %/ #|H|)); apply/congr_group/set1P.\nby rewrite -cycle_sub_group /order -defG ?cardSg // inE sHG eqxx.\nQed.",
    "Lemma cyclicJ G x : cyclic (G :^ x) = cyclic G.\nProof.\napply/cyclicP/cyclicP=> [[y /(canRL (conjsgK x))] | [y ->]].\n  by rewrite -cycleJ; exists (y ^ x^-1).\nby exists (y ^ x); rewrite cycleJ.\nQed.",
    "Lemma eq_subG_cyclic G H K :\n  cyclic G -> H \\subset G -> K \\subset G -> (H :==: K) = (#|H| == #|K|).\nProof.\ncase/cyclicP=> x -> sHx sKx; apply/eqP/eqP=> [-> //| eqHK].\nhave def_GHx := cycle_sub_group (cardSg sHx); set GHx := [set _] in def_GHx.\nhave []: H \\in GHx /\\ K \\in GHx by rewrite -def_GHx !inE sHx sKx eqHK /=.\nby do 2!move/set1P->.\nQed.",
    "Lemma cardSg_cyclic G H K :\n  cyclic G -> H \\subset G -> K \\subset G -> (#|H| %| #|K|) = (H \\subset K).\nProof.\nmove=> cycG sHG sKG; apply/idP/idP; last exact: cardSg.\ncase/cyclicP: (cyclicS sKG cycG) => x defK; rewrite {K}defK in sKG *.\ncase/dvdnP=> k ox; suffices ->: H :=: <[x ^+ k]> by apply: cycleX.\napply/eqP; rewrite (eq_subG_cyclic cycG) ?(subset_trans (cycleX _ _)) //.\nrewrite -orderE orderXdiv orderE ox ?dvdn_mulr ?mulKn //.\nby have:= order_gt0 x; rewrite orderE ox; case k.\nQed.",
    "Lemma sub_cyclic_char G H : cyclic G -> (H \\char G) = (H \\subset G).\nProof.\ncase/cyclicP=> x ->; apply/idP/idP => [/andP[] //|].\nexact: cycle_subgroup_char.\nQed.",
    "Lemma morphim_cyclic rT G H (f : {morphism G >-> rT}) :\n  cyclic H -> cyclic (f @* H).\nProof.\nmove=> cycH; wlog sHG: H cycH / H \\subset G.\n  by rewrite -morphimIdom; apply; rewrite (cyclicS _ cycH, subsetIl) ?subsetIr.\ncase/cyclicP: cycH sHG => x ->; rewrite gen_subG sub1set => Gx.\nby apply/cyclicP; exists (f x); rewrite morphim_cycle.\nQed.",
    "Lemma quotient_cycle x H : x \\in 'N(H) -> <[x]> / H = <[coset H x]>.\nProof. exact: morphim_cycle. Qed.",
    "Lemma quotient_cyclic G H : cyclic G -> cyclic (G / H).\nProof. exact: morphim_cyclic. Qed.",
    "Lemma quotient_generator x G H :\n  x \\in 'N(H) -> generator G x -> generator (G / H) (coset H x).\nProof. by move=> Nx; apply: morph_generator. Qed.",
    "Lemma prime_cyclic G : prime #|G| -> cyclic G.\nProof.\ncase/primeP; rewrite ltnNge -trivg_card_le1.\ncase/trivgPn=> x Gx ntx /(_ _ (order_dvdG Gx)).\nrewrite order_eq1 (negbTE ntx) => /eqnP oxG; apply/cyclicP.\nby exists x; apply/eqP; rewrite eq_sym eqEcard -oxG cycle_subG Gx leqnn.\nQed.",
    "Lemma dvdn_prime_cyclic G p : prime p -> #|G| %| p -> cyclic G.\nProof.\nmove=> p_pr pG; case: (eqsVneq G 1) => [-> | ntG]; first exact: cyclic1.\nby rewrite prime_cyclic // (prime_nt_dvdP p_pr _ pG) -?trivg_card1.\nQed.",
    "Lemma cyclic_small G : #|G| <= 3 -> cyclic G.\nProof.\nrewrite 4!(ltnS, leq_eqVlt) -trivg_card_le1 orbA orbC.\ncase/predU1P=> [-> | oG]; first exact: cyclic1.\nby apply: prime_cyclic; case/pred2P: oG => ->.\nQed.",
    "Lemma injm_cyclic G H (f : {morphism G >-> rT}) :\n  'injm f -> H \\subset G -> cyclic (f @* H) = cyclic H.\nProof.\nmove=> injf sHG; apply/idP/idP; last exact: morphim_cyclic.\nby rewrite -{2}(morphim_invm injf sHG); apply: morphim_cyclic.\nQed.",
    "Lemma isog_cyclic G M : G \\isog M -> cyclic G = cyclic M.\nProof. by case/isogP=> f injf <-; rewrite injm_cyclic. Qed.",
    "Lemma isog_cyclic_card G M : cyclic G -> isog G M = cyclic M && (#|M| == #|G|).\nProof.\nmove=> cycG; apply/idP/idP=> [isoGM | ].\n  by rewrite (card_isog isoGM) -(isog_cyclic isoGM) cycG /=.\ncase/cyclicP: cycG => x ->{G} /andP[/cyclicP[y ->] /eqP oy].\nby apply: isog_trans (isog_symr _) (Zp_isog y); rewrite /order oy Zp_isog.\nQed.",
    "Lemma injm_generator G H (f : {morphism G >-> rT}) x :\n    'injm f -> x \\in G -> H \\subset G ->\n  generator (f @* H) (f x) = generator H x.\nProof.\nmove=> injf Gx sHG; apply/idP/idP; last exact: morph_generator.\nrewrite -{2}(morphim_invm injf sHG) -{2}(invmE injf Gx).\nby apply: morph_generator; apply: mem_morphim.\nQed.",
    "Lemma metacyclicP A : \n  reflect (exists H : {group gT}, [/\\ cyclic H, H <| A & cyclic (A / H)]) \n          (metacyclic A).\nProof. exact: 'exists_and3P. Qed.",
    "Lemma metacyclic1 : metacyclic 1.\nProof.\nby apply/existsP; exists 1%G; rewrite normal1 trivg_quotient !cyclic1.\nQed.",
    "Lemma cyclic_metacyclic A : cyclic A -> metacyclic A.\nProof.\ncase/cyclicP=> x ->; apply/existsP; exists (<[x]>)%G.\nby rewrite normal_refl cycle_cyclic trivg_quotient cyclic1.\nQed.",
    "Lemma metacyclicS G H : H \\subset G -> metacyclic G -> metacyclic H.\nProof.\nmove=> sHG /metacyclicP[K [cycK nsKG cycGq]]; apply/metacyclicP.\nexists (H :&: K)%G; rewrite (cyclicS (subsetIr H K)) ?(normalGI sHG) //=.\nrewrite setIC (isog_cyclic (second_isog _)) ?(cyclicS _ cycGq) ?quotientS //.\nby rewrite (subset_trans sHG) ?normal_norm.\nQed.",
    "Lemma cyclemM : {in <[a]> & , {morph cyclem a : x y / x * y}}.\nProof.\nby move=> x y ax ay; apply: expgMn; apply: (centsP (cycle_abelian a)).\nQed.",
    "Lemma injm_cyclem : 'injm (cyclem (val u) a).\nProof.\napply/subsetP=> x /setIdP[ax]; rewrite !inE -order_dvdn.\nhave [a1 | nta] := eqVneq a 1; first by rewrite a1 cycle1 inE in ax.\nrewrite -order_eq1 -dvdn1; move/eqnP: (valP u) => /= <-.\nby rewrite dvdn_gcd [in X in X && _]Zp_cast ?order_gt1 // order_dvdG.\nQed.",
    "Lemma im_cyclem : cyclem (val u) a @* <[a]> = <[a]>.\nProof.\napply/morphim_fixP=> //; first exact: injm_cyclem.\nby rewrite morphim_cycle ?cycle_id ?cycleX.\nQed.",
    "Lemma Zp_unitmM : {in units_Zp #[a] &, {morph Zp_unitm : u v / u * v}}.\nProof.\nmove=> u v _ _; apply: (eq_Aut (Aut_aut _ _)) => [|x a_x].\n  by rewrite groupM ?Aut_aut.\nrewrite permM !autE ?groupX //= /cyclem -expgM.\nrewrite -expg_mod_order modn_dvdm ?expg_mod_order //.\ncase: (leqP #[a] 1) => [lea1 | lt1a]; last by rewrite Zp_cast ?order_dvdG.\nby rewrite card_le1_trivg // in a_x; rewrite (set1P a_x) order1 dvd1n.\nQed.",
    "Lemma injm_Zp_unitm : 'injm Zp_unitm.\nProof.\nhave [a1 | nta] := eqVneq a 1.\n  by rewrite subIset //= card_le1_trivg ?subxx // card_units_Zp a1 order1.\napply/subsetP=> /= u /morphpreP[_ /set1P/= um1].\nhave{um1}: Zp_unitm u a == Zp_unitm 1 a by rewrite um1 morph1.\nrewrite !autE ?cycle_id // eq_expg_mod_order.\nby rewrite -[n in _ == _ %[mod n]]Zp_cast ?order_gt1 // !modZp inE.\nQed.",
    "Lemma generator_coprime m : generator <[a]> (a ^+ m) = coprime #[a] m.\nProof.\nrewrite /generator eq_sym eqEcard cycleX -/#[a] [#|_|]orderXgcd /=.\napply/idP/idP=> [le_a_am|co_am]; last by rewrite (eqnP co_am) divn1.\nhave am_gt0: 0 < gcdn #[a] m by rewrite gcdn_gt0 order_gt0.\nby rewrite /coprime eqn_leq am_gt0 andbT -(@leq_pmul2l #[a]) ?muln1 -?leq_divRL.\nQed.",
    "Lemma im_Zp_unitm : Zp_unitm @* units_Zp #[a] = Aut <[a]>.\nProof.\nrewrite morphimEdom; apply/setP=> f; pose n := invm (injm_Zpm a) (f a).\napply/imsetP/idP=> [[u _ ->] | Af]; first exact: Aut_aut.\nhave [a1 | nta] := eqVneq a 1.\n  by rewrite a1 cycle1 Aut1 in Af; exists 1; rewrite // morph1 (set1P Af).\nhave a_fa: <[a]> = <[f a]>.\n  by rewrite -(autmE Af) -morphim_cycle ?im_autm ?cycle_id.\nhave def_n: a ^+ n = f a.\n  by rewrite -/(Zpm n) invmK // im_Zpm a_fa cycle_id.\nhave co_a_n: coprime #[a].-2.+2 n.\n  by rewrite {1}Zp_cast ?order_gt1 // -generator_coprime def_n; apply/eqP.\nexists (FinRing.unit 'Z_#[a] co_a_n); rewrite ?inE //.\napply: eq_Aut (Af) (Aut_aut _ _) _ => x ax.\nrewrite autE //= /cyclem; case/cycleP: ax => k ->{x}.\nby rewrite -(autmE Af) morphX ?cycle_id //= autmE -def_n -!expgM mulnC.\nQed.",
    "Lemma Zp_unit_isom : isom (units_Zp #[a]) (Aut <[a]>) Zp_unitm.\nProof. by apply/isomP; rewrite ?injm_Zp_unitm ?im_Zp_unitm. Qed.",
    "Lemma Zp_unit_isog : isog (units_Zp #[a]) (Aut <[a]>).\nProof. exact: isom_isog Zp_unit_isom. Qed.",
    "Lemma card_Aut_cycle : #|Aut <[a]>| = totient #[a].\nProof. by rewrite -(card_isog Zp_unit_isog) card_units_Zp. Qed.",
    "Lemma totient_gen : totient #[a] = #|[set x | generator <[a]> x]|.\nProof.\nhave [lea1 | lt1a] := leqP #[a] 1.\n  rewrite /order card_le1_trivg // cards1 (@eq_card1 _ 1) // => x.\n  by rewrite !inE -cycle_eq1 eq_sym.\nrewrite -(card_injm (injm_invm (injm_Zpm a))) /= ?im_Zpm; last first.\n  by apply/subsetP=> x /[1!inE]; apply: cycle_generator.\nrewrite -card_units_Zp // cardsE card_sub morphim_invmE; apply: eq_card => /= d.\nby rewrite !inE /= qualifE /= /Zp lt1a inE /= generator_coprime {1}Zp_cast.\nQed.",
    "Lemma Aut_cycle_abelian : abelian (Aut <[a]>).\nProof. by rewrite -im_Zp_unitm morphim_abelian ?units_Zp_abelian. Qed.",
    "Lemma Aut_cyclic_abelian : cyclic G -> abelian (Aut G).\nProof. by case/cyclicP=> x ->; apply: Aut_cycle_abelian. Qed.",
    "Lemma card_Aut_cyclic : cyclic G -> #|Aut G| = totient #|G|.\nProof. by case/cyclicP=> x ->; apply: card_Aut_cycle. Qed.",
    "Lemma sum_ncycle_totient :\n  \\sum_(d < #|G|.+1) #|[set <[x]> | x in G & #[x] == d]| * totient d = #|G|.\nProof.\npose h (x : gT) : 'I_#|G|.+1 := inord #[x].\nsymmetry; rewrite -{1}sum1_card (partition_big h xpredT) //=.\napply: eq_bigr => d _; set Gd := finset _.\nrewrite -sum_nat_const sum1dep_card -sum1_card (_ : finset _ = Gd); last first.\n  apply/setP=> x /[!inE]; apply: andb_id2l => Gx.\n  by rewrite /eq_op /= inordK // ltnS subset_leq_card ?cycle_subG.\nrewrite (partition_big_imset cycle) {}/Gd; apply: eq_bigr => C /=.\ncase/imsetP=> x /setIdP[Gx /eqP <-] -> {C d}.\nrewrite sum1dep_card totient_gen; apply: eq_card => y; rewrite !inE /generator.\nmove: Gx; rewrite andbC eq_sym -!cycle_subG /order.\nby case: eqP => // -> ->; rewrite eqxx.\nQed.",
    "Lemma sum_totient_dvd n : \\sum_(d < n.+1 | d %| n) totient d = n.\nProof.\ncase: n => [|[|n']]; try by rewrite big_mkcond !big_ord_recl big_ord0.\nset n := n'.+2; pose x1 : 'Z_n := 1%R.\nhave ox1: #[x1] = n by rewrite /order -Zp_cycle card_Zp.\nrewrite -[rhs in _ = rhs]ox1 -[#[_]]sum_ncycle_totient [#|_|]ox1 big_mkcond /=.\napply: eq_bigr => d _; rewrite -{2}ox1; case: ifP => [|ndv_dG]; last first.\n  rewrite eq_card0 // => C; apply/imsetP=> [[x /setIdP[Gx oxd] _{C}]].\n  by rewrite -(eqP oxd) order_dvdG in ndv_dG.\nmove/cycle_sub_group; set Gd := [set _] => def_Gd.\nrewrite (_ : _ @: _ = @gval _ @: Gd); first by rewrite imset_set1 cards1 mul1n.\napply/setP=> C; apply/idP/imsetP=> [| [gC GdC ->{C}]].\n  case/imsetP=> x /setIdP[_ oxd] ->; exists <[x]>%G => //.\n  by rewrite -def_Gd inE -Zp_cycle subsetT.\nhave:= GdC; rewrite -def_Gd => /setIdP[_ /eqP <-].\nby rewrite (set1P GdC) /= imset_f // inE eqxx (mem_cycle x1).\nQed.",
    "Lemma order_inj_cyclic :\n  {in G &, forall x y, #[x] = #[y] -> <[x]> = <[y]>} -> cyclic G.\nProof.\nmove=> ucG; apply: negbNE (contra _ (negbT (ltnn #|G|))) => ncG.\nrewrite -{2}[#|G|]sum_totient_dvd big_mkcond (bigD1 ord_max) ?dvdnn //=.\nrewrite -{1}[#|G|]sum_ncycle_totient (bigD1 ord_max) //= -addSn leq_add //.\n  rewrite eq_card0 ?totient_gt0 ?cardG_gt0 // => C.\n  apply/imsetP=> [[x /setIdP[Gx /eqP oxG]]]; case/cyclicP: ncG.\n  by exists x; apply/eqP; rewrite eq_sym eqEcard cycle_subG Gx -oxG /=.\nelim/big_ind2: _ => // [m1 n1 m2 n2 | d _]; first exact: leq_add.\nset Gd := _ @: _; case: (set_0Vmem Gd) => [-> | [C]]; first by rewrite cards0.\nrewrite {}/Gd => /imsetP[x /setIdP[Gx /eqP <-] _ {C d}].\nrewrite order_dvdG // (@eq_card1 _ <[x]>) ?mul1n // => C.\napply/idP/eqP=> [|-> {C}]; last by rewrite imset_f // inE Gx eqxx.\nby case/imsetP=> y /setIdP[Gy /eqP/ucG->].\nQed.",
    "Lemma div_ring_mul_group_cyclic (R : unitRingType) (f : gT -> R) :\n    f 1 = 1%R -> {in G &, {morph f : u v / u * v >-> (u * v)%R}} ->\n    {in G^#, forall x, f x - 1 \\in GRing.unit}%R ->\n  abelian G -> cyclic G.\nProof.\nmove=> f1 fM f1P abelG.\nhave fX n: {in G, {morph f : u / u ^+ n >-> (u ^+ n)%R}}.\n  by case: n => // n x Gx; elim: n => //= n IHn; rewrite expgS fM ?groupX ?IHn.\nhave fU x: x \\in G -> f x \\in GRing.unit.\n  by move=> Gx; apply/unitrP; exists (f x^-1); rewrite -!fM ?groupV ?gsimp.\napply: order_inj_cyclic => x y Gx Gy; set n := #[x] => yn.\napply/eqP; rewrite eq_sym eqEcard -[#|_|]/n yn leqnn andbT cycle_subG /=.\nsuff{y Gy yn} ->: <[x]> = G :&: [set z | #[z] %| n] by rewrite !inE Gy yn /=.\napply/eqP; rewrite eqEcard subsetI cycle_subG {}Gx /= cardE; set rs := enum _.\napply/andP; split; first by apply/subsetP=> y xy; rewrite inE order_dvdG.\npose P : {poly R} := ('X^n - 1)%R; have n_gt0: n > 0 by apply: order_gt0.\nhave szP : size P = n.+1.\n  by rewrite size_polyDl size_polyXn ?size_polyN ?size_poly1.\nrewrite -ltnS -szP -(size_map f) max_ring_poly_roots -?size_poly_eq0 ?{}szP //.\n  apply/allP=> fy /mapP[y]; rewrite mem_enum !inE order_dvdn => /andP[Gy].\n  move/eqP=> yn1 ->{fy}; apply/eqP.\n  by rewrite !(hornerE, hornerXn) -fX // yn1 f1 subrr.\nhave: uniq rs by apply: enum_uniq.\nhave: all [in G] rs by apply/allP=> y; rewrite mem_enum; case/setIP.\nelim: rs => //= y rs IHrs /andP[Gy Grs] /andP[y_rs]; rewrite andbC.\nmove/IHrs=> -> {IHrs}//; apply/allP=> _ /mapP[z rs_z ->].\nhave{Grs} Gz := allP Grs z rs_z; rewrite /diff_roots -!fM // (centsP abelG) //.\nrewrite eqxx -[f y]mul1r -(mulgKV y z) fM ?groupM ?groupV //=.\nrewrite -mulNr -mulrDl unitrMl ?fU ?f1P // !inE.\nby rewrite groupM ?groupV // andbT -eq_mulgV1; apply: contra y_rs; move/eqP <-.\nQed.",
    "Lemma field_mul_group_cyclic (F : fieldType) (f : gT -> F) :\n    {in G &, {morph f : u v / u * v >-> (u * v)%R}} ->\n    {in G, forall x, f x = 1%R <-> x = 1} ->\n  cyclic G.\nProof.\nmove=> fM f1P; have f1 : f 1 = 1%R by apply/f1P.\napply: (div_ring_mul_group_cyclic f1 fM) => [x|].\n  case/setD1P=> x1 Gx; rewrite unitfE; apply: contra x1.\n  by rewrite subr_eq0 => /eqP/f1P->.\napply/centsP=> x Gx y Gy; apply/commgP/eqP.\napply/f1P; rewrite ?fM ?groupM ?groupV //.\nby rewrite mulrCA -!fM ?groupM ?groupV // mulKg mulVg.\nQed.",
    "Lemma field_unit_group_cyclic (F : finFieldType) (G : {group {unit F}}) :\n  cyclic G.\nProof.\napply: field_mul_group_cyclic FinRing.uval _ _ => // u _.\nby split=> /eqP ?; apply/eqP.\nQed.",
    "Lemma units_Zp_cyclic p : prime p -> cyclic (units_Zp p).\nProof. by move/pdiv_id <-; exact: field_unit_group_cyclic. Qed.",
    "Lemma has_prim_root_subproof (F : fieldType) (n : nat) (rs : seq F)\n    (n_gt0 : n > 0)\n    (rsn1 : all n.-unity_root rs)\n    (Urs : uniq rs)\n    (sz_rs : size rs = n)\n    (r := fun s => val (s : seq_sub rs))\n    (rn1 : forall x : seq_sub rs, r x ^+ n = 1)\n    (prim_r : forall z : F, z ^+ n = 1 -> z \\in rs)\n    (r' := (fun s (e : s ^+ n = 1) => {| ssval := s; ssvalP := prim_r s e |})\n       : forall s : F, s ^+ n = 1 -> seq_sub rs)\n    (sG_1 := r' 1 (expr1n F n) : seq_sub rs)\n    (sG_VP : forall s : seq_sub rs, r s ^+ n.-1 ^+ n = 1)\n    (sG_MP : forall s s0 : seq_sub rs, (r s * r s0) ^+ n = 1)\n    (sG_V := (fun s : seq_sub rs => r' (r s ^+ n.-1) (sG_VP s))\n       : seq_sub rs -> seq_sub rs)\n    (sG_M := (fun s s0 : seq_sub rs => r' (r s * r s0) (sG_MP s s0))\n       : seq_sub rs -> seq_sub rs -> seq_sub rs)\n    (sG_Ag : associative sG_M)\n    (sG_1g : left_id sG_1 sG_M)\n    (sG_Vg : left_inverse sG_1 sG_V sG_M) :\n  has n.-primitive_root rs.\nProof.\npose ssMG : isMulGroup (seq_sub rs) := isMulGroup.Build (seq_sub rs) sG_Ag sG_1g sG_Vg.\npose gT : finGroupType := HB.pack (seq_sub rs) ssMG.\nhave /cyclicP[x gen_x]: @cyclic gT setT.\n  apply: (@field_mul_group_cyclic gT [set: _] F r) => // x _.\n  by split=> [ri1 | ->]; first apply: val_inj.\napply/hasP; exists (r x); first exact: (valP x).\nhave [m prim_x dvdmn] := prim_order_exists n_gt0 (rn1 x).\nrewrite -((m =P n) _) // eqn_dvd {}dvdmn -sz_rs -(card_seq_sub Urs) -cardsT.\nrewrite gen_x (@order_dvdn gT) /(_ == _) /= -{prim_x}(prim_expr_order prim_x).\nby apply/eqP; elim: m => //= m IHm; rewrite exprS expgS /= -IHm.\nQed.",
    "Lemma has_prim_root (F : fieldType) (n : nat) (rs : seq F) :\n    n > 0 -> all n.-unity_root rs -> uniq rs -> size rs >= n ->\n  has n.-primitive_root rs.\nProof.\nmove=> n_gt0 rsn1 Urs; rewrite leq_eqVlt ltnNge max_unity_roots // orbF eq_sym.\nmove/eqP=> sz_rs; pose r := val (_ : seq_sub rs).\nhave rn1 x: r x ^+ n = 1.\n  by apply/eqP; rewrite -unity_rootE (allP rsn1) ?(valP x).\nhave prim_r z: z ^+ n = 1 -> z \\in rs.\n  by move/eqP; rewrite -unity_rootE -(mem_unity_roots n_gt0).\npose r' := SeqSub (prim_r _ _); pose sG_1 := r' _ (expr1n _ _).\nhave sG_VP: r _ ^+ n.-1 ^+ n = 1.\n  by move=> x; rewrite -exprM mulnC exprM rn1 expr1n.\nhave sG_MP: (r _ * r _) ^+ n = 1 by move=> x y; rewrite exprMn !rn1 mul1r.\npose sG_V := r' _ (sG_VP _); pose sG_M := r' _ (sG_MP _ _).\nhave sG_Ag: associative sG_M by move=> x y z; apply: val_inj; rewrite /= mulrA.\nhave sG_1g: left_id sG_1 sG_M by move=> x; apply: val_inj; rewrite /= mul1r.\nhave sG_Vg: left_inverse sG_1 sG_V sG_M.\n  by move=> x; apply: val_inj; rewrite /= -exprSr prednK ?rn1.\nexact: has_prim_root_subproof.\nQed.",
    "Lemma Aut_prime_cycle_cyclic (a : gT) : prime #[a] -> cyclic (Aut <[a]>).\nProof.\nmove=> pr_a; have inj_um := injm_Zp_unitm a.\nhave /eq_S/eq_S eq_a := Fp_Zcast pr_a.\npose fm := cast_ord (esym eq_a) \\o val \\o invm inj_um.\napply: (@field_mul_group_cyclic _ _ _ fm) => [f g Af Ag | f Af] /=.\n  by apply: val_inj; rewrite /= morphM ?im_Zp_unitm //= eq_a.\nsplit=> [/= fm1 |->]; last by apply: val_inj; rewrite /= morph1.\napply: (injm1 (injm_invm inj_um)); first by rewrite /= im_Zp_unitm.\nby do 2!apply: val_inj; move/(congr1 val): fm1.\nQed.",
    "Lemma Aut_prime_cyclic (G : {group gT}) : prime #|G| -> cyclic (Aut G).\nProof.\nmove=> pr_G; case/cyclicP: (prime_cyclic pr_G) (pr_G) => x ->.\nexact: Aut_prime_cycle_cyclic.\nQed.",
    "Lemma pdiv_p_elt (p : nat) (x : gT) : p.-elt x -> x != 1 -> pdiv #[x] = p.\nProof.\nmove=> p_x; rewrite /order -cycle_eq1.\nby case/(pgroup_pdiv p_x)=> p_pr _ [k ->]; rewrite pdiv_pfactor.\nQed.",
    "Lemma OhmPredP (x : gT) :\n  reflect (exists2 p, prime p & x ^+ (p ^ n) = 1) (x ^+ (pdiv #[x] ^ n) == 1).\nProof.\nhave [-> | nt_x] := eqVneq x 1.\n  by rewrite expg1n eqxx; left; exists 2; rewrite ?expg1n.\napply: (iffP idP) => [/eqP | [p p_pr /eqP x_pn]].\n  by exists (pdiv #[x]); rewrite ?pdiv_prime ?order_gt1.\nrewrite (@pdiv_p_elt p) //; rewrite -order_dvdn in x_pn.\nby rewrite [p_elt _ _](pnat_dvd x_pn) // pnatX pnat_id.\nQed.",
    "Lemma Mho_p_elt (p : nat) x : x \\in A -> p.-elt x -> x ^+ (p ^ n) \\in Mho.\nProof.\nmove=> Ax p_x; have [-> | ntx] := eqVneq x 1; first by rewrite groupX.\nby apply/mem_gen/imsetP; exists x; rewrite ?inE ?Ax (pdiv_p_elt p_x).\nQed.",
    "Lemma LdivP A n x : reflect (x \\in A /\\ x ^+ n = 1) (x \\in 'Ldiv_n(A)).\nProof. by rewrite !inE; apply: (iffP andP) => [] [-> /eqP]. Qed.",
    "Lemma dvdn_exponent x A : x \\in A -> #[x] %| exponent A.\nProof. by move=> Ax; rewrite (biglcmn_sup x). Qed.",
    "Lemma expg_exponent x A : x \\in A -> x ^+ exponent A = 1.\nProof. by move=> Ax; apply/eqP; rewrite -order_dvdn dvdn_exponent. Qed.",
    "Lemma exponentS A B : A \\subset B -> exponent A %| exponent B.\nProof.\nby move=> sAB; apply/dvdn_biglcmP=> x Ax; rewrite dvdn_exponent ?(subsetP sAB).\nQed.",
    "Lemma exponentP A n :\n  reflect (forall x, x \\in A -> x ^+ n = 1) (exponent A %| n).\nProof.\napply: (iffP (dvdn_biglcmP _ _ _)) => eAn x Ax.\n  by apply/eqP; rewrite -order_dvdn eAn.\nby rewrite order_dvdn eAn.\nQed.",
    "Lemma trivg_exponent G : (G :==: 1) = (exponent G %| 1).\nProof.\nrewrite -subG1.\nby apply/subsetP/exponentP=> trG x /trG; rewrite expg1 => /set1P.\nQed.",
    "Lemma exponent1 : exponent [1 gT] = 1%N.\nProof. by apply/eqP; rewrite -dvdn1 -trivg_exponent eqxx. Qed.",
    "Lemma exponent_dvdn G : exponent G %| #|G|.\nProof. by apply/dvdn_biglcmP=> x Gx; apply: order_dvdG. Qed.",
    "Lemma exponent_gt0 G : 0 < exponent G.\nProof. exact: dvdn_gt0 (exponent_dvdn G). Qed.",
    "Lemma pnat_exponent pi G : pi.-nat (exponent G) = pi.-group G.\nProof.\ncongr (_ && _); first by rewrite cardG_gt0 exponent_gt0.\napply: eq_all_r => p; rewrite !mem_primes cardG_gt0 exponent_gt0 /=.\napply: andb_id2l => p_pr; apply/idP/idP=> pG.\n  exact: dvdn_trans pG (exponent_dvdn G).\nby case/Cauchy: pG => // x Gx <-; apply: dvdn_exponent.\nQed.",
    "Lemma exponentJ A x : exponent (A :^ x) = exponent A.\nProof.\nrewrite /exponent (reindex_inj (conjg_inj x)).\nby apply: eq_big => [y | y _]; rewrite ?orderJ ?memJ_conjg.\nQed.",
    "Lemma exponent_witness G : nilpotent G -> {x | x \\in G & exponent G = #[x]}.\nProof.\nmove=> nilG; have [//=| /= x Gx max_x] := @arg_maxnP _ 1 [in G] order.\nexists x => //; apply/eqP; rewrite eqn_dvd dvdn_exponent // andbT.\napply/dvdn_biglcmP=> y Gy; apply/dvdn_partP=> //= p.\nrewrite mem_primes => /andP[p_pr _]; have p_gt1: p > 1 := prime_gt1 p_pr.\nrewrite p_part pfactor_dvdn // -(leq_exp2l _ _ p_gt1) -!p_part.\nrewrite -(leq_pmul2r (part_gt0 p^' #[x])) partnC // -!order_constt.\nrewrite -orderM ?order_constt ?coprime_partC // ?max_x ?groupM ?groupX //.\ncase/dprodP: (nilpotent_pcoreC p nilG) => _ _ cGpGp' _.\nhave inGp := mem_normal_Hall (nilpotent_pcore_Hall _ nilG) (pcore_normal _ _).\nby red; rewrite -(centsP cGpGp') // inGp ?p_elt_constt ?groupX.\nQed.",
    "Lemma exponent_cycle x : exponent <[x]> = #[x].\nProof. by apply/eqP; rewrite eqn_dvd exponent_dvdn dvdn_exponent ?cycle_id. Qed.",
    "Lemma exponent_cyclic X : cyclic X -> exponent X = #|X|.\nProof. by case/cyclicP=> x ->; apply: exponent_cycle. Qed.",
    "Lemma primes_exponent G : primes (exponent G) = primes (#|G|).\nProof.\napply/eq_primes => p; rewrite !mem_primes exponent_gt0 cardG_gt0 /=.\nby apply: andb_id2l => p_pr; apply: negb_inj; rewrite -!p'natE // pnat_exponent.\nQed.",
    "Lemma pi_of_exponent G : \\pi(exponent G) = \\pi(G).\nProof. by rewrite /pi_of primes_exponent. Qed.",
    "Lemma partn_exponentS pi H G :\n  H \\subset G -> #|G|`_pi %| #|H| -> (exponent H)`_pi = (exponent G)`_pi.\nProof.\nmove=> sHG Gpi_dvd_H; apply/eqP; rewrite eqn_dvd.\nrewrite partn_dvd ?exponentS ?exponent_gt0 //=; apply/dvdn_partP=> // p.\nrewrite pi_of_part ?exponent_gt0 // => /andP[_ /= pi_p].\nhave sppi: {subset (p : nat_pred) <= pi} by move=> q /eqnP->.\nhave [P sylP] := Sylow_exists p H; have sPH := pHall_sub sylP.\nhave{} sylP: p.-Sylow(G) P.\n  rewrite pHallE (subset_trans sPH) //= (card_Hall sylP) eqn_dvd andbC.\n  by rewrite -{1}(partn_part _ sppi) !partn_dvd ?cardSg ?cardG_gt0.\nrewrite partn_part ?partn_biglcm //.\napply: (@big_ind _ (dvdn^~ _)) => [|m n|x Gx]; first exact: dvd1n.\n  by rewrite dvdn_lcm => ->.\nrewrite -order_constt; have p_y := p_elt_constt p x; set y := x.`_p in p_y *.\nhave sYG: <[y]> \\subset G by rewrite cycle_subG groupX.\nhave [z _ Pyz] := Sylow_Jsub sylP sYG p_y.\nrewrite (bigD1 (y ^ z))  ?(subsetP sPH) -?cycle_subG ?cycleJ //=.\nby rewrite orderJ part_pnat_id ?dvdn_lcml // (pi_pnat p_y).\nQed.",
    "Lemma exponent_Hall pi G H : pi.-Hall(G) H -> exponent H = (exponent G)`_pi.\nProof.\nmove=> hallH; have [sHG piH _] := and3P hallH.\nrewrite -(partn_exponentS sHG) -?(card_Hall hallH) ?part_pnat_id //.\nby apply: pnat_dvd piH; apply: exponent_dvdn.\nQed.",
    "Lemma exponent_Zgroup G : Zgroup G -> exponent G = #|G|.\nProof.\nmove/forall_inP=> ZgG; apply/eqP; rewrite eqn_dvd exponent_dvdn.\napply/(dvdn_partP _ (cardG_gt0 _)) => p _.\nhave [S sylS] := Sylow_exists p G; rewrite -(card_Hall sylS).\nhave /cyclicP[x defS]: cyclic S by rewrite ZgG ?(p_Sylow sylS).\nby rewrite defS dvdn_exponent // -cycle_subG -defS (pHall_sub sylS).\nQed.",
    "Lemma cprod_exponent A B G :\n  A \\* B = G -> lcmn (exponent A) (exponent B) = (exponent G).\nProof.\ncase/cprodP=> [[K H -> ->{A B}] <- cKH].\napply/eqP; rewrite eqn_dvd dvdn_lcm !exponentS ?mulG_subl ?mulG_subr //=.\napply/exponentP=> _ /imset2P[x y Kx Hy ->].\nrewrite -[1]mulg1 expgMn; last by red; rewrite -(centsP cKH).\ncongr (_ * _); apply/eqP; rewrite -order_dvdn.\n  by rewrite (dvdn_trans (dvdn_exponent Kx)) ?dvdn_lcml.\nby rewrite (dvdn_trans (dvdn_exponent Hy)) ?dvdn_lcmr.\nQed.",
    "Lemma dprod_exponent A B G :\n  A \\x B = G -> lcmn (exponent A) (exponent B) = (exponent G).\nProof.\ncase/dprodP=> [[K H -> ->{A B}] defG cKH _].\nby apply: cprod_exponent; rewrite cprodE.\nQed.",
    "Lemma sub_LdivT A n : (A \\subset 'Ldiv_n()) = (exponent A %| n).\nProof. by apply/subsetP/exponentP=> eAn x /eAn /[1!inE] /eqP. Qed.",
    "Lemma LdivT_J n x : 'Ldiv_n() :^ x = 'Ldiv_n().\nProof.\napply/setP=> y; rewrite !inE mem_conjg inE -conjXg.\nby rewrite (canF_eq (conjgKV x)) conj1g.\nQed.",
    "Lemma LdivJ n A x : 'Ldiv_n(A :^ x) = 'Ldiv_n(A) :^ x.\nProof. by rewrite conjIg LdivT_J. Qed.",
    "Lemma sub_Ldiv A n : (A \\subset 'Ldiv_n(A)) = (exponent A %| n).\nProof. by rewrite subsetI subxx sub_LdivT. Qed.",
    "Lemma group_Ldiv G n : abelian G -> group_set 'Ldiv_n(G).\nProof.\nmove=> cGG; apply/group_setP.\nsplit=> [|x y]; rewrite !inE ?group1 ?expg1n //=.\ncase/andP=> Gx /eqP xn /andP[Gy /eqP yn].\nby rewrite groupM //= expgMn ?xn ?yn ?mulg1 //; apply: (centsP cGG).\nQed.",
    "Lemma abelian_exponent_gen A : abelian A -> exponent <<A>> = exponent A.\nProof.\nrewrite -abelian_gen; set n := exponent A; set G := <<A>> => cGG.\napply/eqP; rewrite eqn_dvd andbC exponentS ?subset_gen //= -sub_Ldiv.\nrewrite -(gen_set_id (group_Ldiv n cGG)) genS // subsetI subset_gen /=.\nby rewrite sub_LdivT.\nQed.",
    "Lemma abelem_pgroup p A : p.-abelem A -> p.-group A.\nProof. by case/andP. Qed.",
    "Lemma abelem_abelian p A : p.-abelem A -> abelian A.\nProof. by case/and3P. Qed.",
    "Lemma abelem1 p : p.-abelem [1 gT].\nProof. by rewrite /abelem pgroup1 abelian1 exponent1 dvd1n. Qed.",
    "Lemma abelemE p G : prime p -> p.-abelem G = abelian G && (exponent G %| p).\nProof.\nmove=> p_pr; rewrite /abelem -pnat_exponent andbA -!(andbC (_ %| _)).\nby case: (dvdn_pfactor _ 1 p_pr) => // [[k _ ->]]; rewrite pnatX pnat_id.\nQed.",
    "Lemma abelemP p G :\n    prime p ->\n  reflect (abelian G /\\ forall x, x \\in G -> x ^+ p = 1) (p.-abelem G).\nProof.\nby move=> p_pr; rewrite abelemE //; apply: (iffP andP) => [] [-> /exponentP].\nQed.",
    "Lemma abelem_order_p p G x : p.-abelem G -> x \\in G -> x != 1 -> #[x] = p.\nProof.\ncase/and3P=> pG _ eG Gx; rewrite -cycle_eq1 => ntX.\nhave{ntX} [p_pr p_x _] := pgroup_pdiv (mem_p_elt pG Gx) ntX.\nby apply/eqP; rewrite eqn_dvd p_x andbT order_dvdn (exponentP eG).\nQed.",
    "Lemma cyclic_abelem_prime p X : p.-abelem X -> cyclic X -> X :!=: 1 -> #|X| = p.\nProof.\nmove=> abelX cycX; case/cyclicP: cycX => x -> in abelX *.\nby rewrite cycle_eq1; apply: abelem_order_p abelX (cycle_id x).\nQed.",
    "Lemma cycle_abelem p x : p.-elt x || prime p -> p.-abelem <[x]> = (#[x] %| p).\nProof.\nmove=> p_xVpr; rewrite /abelem cycle_abelian /=.\napply/andP/idP=> [[_ xp1] | x_dvd_p].\n  by rewrite order_dvdn (exponentP xp1) ?cycle_id.\nsplit; last exact: dvdn_trans (exponent_dvdn _) x_dvd_p.\nby case/orP: p_xVpr => // /pnat_id; apply: pnat_dvd.\nQed.",
    "Lemma exponent2_abelem G : exponent G %| 2 -> 2.-abelem G.\nProof.\nmove/exponentP=> expG; apply/abelemP=> //; split=> //.\napply/centsP=> x Gx y Gy; apply: (mulIg x); apply: (mulgI y).\nby rewrite -!mulgA !(mulgA y) -!(expgS _ 1) !expG ?mulg1 ?groupM.\nQed.",
    "Lemma prime_abelem p G : prime p -> #|G| = p -> p.-abelem G.\nProof.\nmove=> p_pr oG; rewrite /abelem -oG exponent_dvdn.\nby rewrite /pgroup cyclic_abelian ?prime_cyclic ?oG ?pnat_id.\nQed.",
    "Lemma abelem_cyclic p G : p.-abelem G -> cyclic G = (logn p #|G| <= 1).\nProof.\nmove=> abelG; have [pG _ expGp] := and3P abelG.\ncase: (eqsVneq G 1) => [-> | ntG]; first by rewrite cyclic1 cards1 logn1.\nhave [p_pr _ [e oG]] := pgroup_pdiv pG ntG; apply/idP/idP.\n  case/cyclicP=> x defG; rewrite -(pfactorK 1 p_pr) dvdn_leq_log ?prime_gt0 //.\n  by rewrite defG order_dvdn (exponentP expGp) // defG cycle_id.\nby rewrite oG pfactorK // ltnS leqn0 => e0; rewrite prime_cyclic // oG (eqP e0).\nQed.",
    "Lemma abelemS p H G : H \\subset G -> p.-abelem G -> p.-abelem H.\nProof.\nmove=> sHG /and3P[cGG pG Gp1]; rewrite /abelem.\nby rewrite (pgroupS sHG) // (abelianS sHG) // (dvdn_trans (exponentS sHG)).\nQed.",
    "Lemma abelemJ p G x : p.-abelem (G :^ x) = p.-abelem G.\nProof. by rewrite /abelem pgroupJ abelianJ exponentJ. Qed.",
    "Lemma cprod_abelem p A B G :\n  A \\* B = G -> p.-abelem G = p.-abelem A && p.-abelem B.\nProof.\ncase/cprodP=> [[H K -> ->{A B}] defG cHK].\napply/idP/andP=> [abelG | []].\n  by rewrite !(abelemS _ abelG) // -defG (mulG_subl, mulG_subr).\ncase/and3P=> pH cHH expHp; case/and3P=> pK cKK expKp.\nrewrite -defG /abelem pgroupM pH pK abelianM cHH cKK cHK /=.\napply/exponentP=> _ /imset2P[x y Hx Ky ->].\nrewrite expgMn; last by red; rewrite -(centsP cHK).\nby rewrite (exponentP expHp) // (exponentP expKp) // mul1g.\nQed.",
    "Lemma dprod_abelem p A B G :\n  A \\x B = G -> p.-abelem G = p.-abelem A && p.-abelem B.\nProof.\nmove=> defG; case/dprodP: (defG) => _ _ _ tiHK.\nby apply: cprod_abelem; rewrite -dprodEcp.\nQed.",
    "Lemma is_abelem_pgroup p G : p.-group G -> is_abelem G = p.-abelem G.\nProof.\nrewrite /is_abelem => pG.\ncase: (eqsVneq G 1) => [-> | ntG]; first by rewrite !abelem1.\nby have [p_pr _ [k ->]] := pgroup_pdiv pG ntG; rewrite pdiv_pfactor.\nQed.",
    "Lemma is_abelemP G : reflect (exists2 p, prime p & p.-abelem G) (is_abelem G).\nProof.\napply: (iffP idP) => [abelG | [p p_pr abelG]].\n  case: (eqsVneq G 1) => [-> | ntG]; first by exists 2; rewrite ?abelem1.\n  by exists (pdiv #|G|); rewrite ?pdiv_prime // ltnNge -trivg_card_le1.\nby rewrite (is_abelem_pgroup (abelem_pgroup abelG)).\nQed.",
    "Lemma pElemP p A E : reflect (E \\subset A /\\ p.-abelem E) (E \\in 'E_p(A)).\nProof. by rewrite inE; apply: andP. Qed.",
    "Lemma pElemS p A B : A \\subset B -> 'E_p(A) \\subset 'E_p(B).\nProof.\nby move=> sAB; apply/subsetP=> E /[!inE] /andP[/subset_trans->].\nQed.",
    "Lemma pElemI p A B : 'E_p(A :&: B) = 'E_p(A) :&: subgroups B.\nProof. by apply/setP=> E; rewrite !inE subsetI andbAC. Qed.",
    "Lemma pElemJ x p A E : ((E :^ x)%G \\in 'E_p(A :^ x)) = (E \\in 'E_p(A)).\nProof. by rewrite !inE conjSg abelemJ. Qed.",
    "Lemma pnElemP p n A E :\n  reflect [/\\ E \\subset A, p.-abelem E & logn p #|E| = n] (E \\in 'E_p^n(A)).\nProof. by rewrite !inE -andbA; apply: (iffP and3P) => [] [-> -> /eqP]. Qed.",
    "Lemma pnElemPcard p n A E :\n  E \\in 'E_p^n(A) -> [/\\ E \\subset A, p.-abelem E & #|E| = p ^ n]%N.\nProof.\nby case/pnElemP=> -> abelE <-; rewrite -card_pgroup // abelem_pgroup.\nQed.",
    "Lemma card_pnElem p n A E : E \\in 'E_p^n(A) -> #|E| = (p ^ n)%N.\nProof. by case/pnElemPcard. Qed.",
    "Lemma pnElem0 p G : 'E_p^0(G) = [set 1%G].\nProof.\napply/setP=> E; rewrite !inE -andbA; apply/and3P/idP=> [[_ pE] | /eqP->].\n  apply: contraLR; case/(pgroup_pdiv (abelem_pgroup pE)) => p_pr _ [k ->].\n  by rewrite pfactorK.\nby rewrite sub1G abelem1 cards1 logn1.\nQed.",
    "Lemma pnElem_prime p n A E : E \\in 'E_p^n.+1(A) -> prime p.\nProof. by case/pnElemP=> _ _; rewrite lognE; case: prime. Qed.",
    "Lemma pnElemE p n A :\n  prime p -> 'E_p^n(A) = [set E in 'E_p(A) | #|E| == (p ^ n)%N].\nProof.\nmove/pfactorK=> pnK; apply/setP=> E; rewrite 3!inE.\ncase: (@andP (E \\subset A)) => //= [[_]] /andP[/p_natP[k ->] _].\nby rewrite pnK (can_eq pnK).\nQed.",
    "Lemma pnElemS p n A B : A \\subset B -> 'E_p^n(A) \\subset 'E_p^n(B).\nProof.\nmove=> sAB; apply/subsetP=> E.\nby rewrite !inE -!andbA => /andP[/subset_trans->].\nQed.",
    "Lemma pnElemI p n A B : 'E_p^n(A :&: B) = 'E_p^n(A) :&: subgroups B.\nProof. by apply/setP=> E; rewrite !inE subsetI -!andbA; do !bool_congr. Qed.",
    "Lemma pnElemJ x p n A E : ((E :^ x)%G \\in 'E_p^n(A :^ x)) = (E \\in 'E_p^n(A)).\nProof. by rewrite inE pElemJ cardJg !inE. Qed.",
    "Lemma abelem_pnElem p n G :\n  p.-abelem G -> n <= logn p #|G| -> exists E, E \\in 'E_p^n(G).\nProof.\ncase: n => [|n] abelG lt_nG; first by exists 1%G; rewrite pnElem0 set11.\nhave p_pr: prime p by move: lt_nG; rewrite lognE; case: prime.\ncase/(normal_pgroup (abelem_pgroup abelG)): lt_nG => // E [sEG _ oE].\nby exists E; rewrite pnElemE // !inE oE sEG (abelemS sEG) /=.\nQed.",
    "Lemma card_p1Elem p A X : X \\in 'E_p^1(A) -> #|X| = p.\nProof. exact: card_pnElem. Qed.",
    "Lemma p1ElemE p A : prime p -> 'E_p^1(A) = [set X in subgroups A | #|X| == p].\nProof.\nmove=> p_pr; apply/setP=> X; rewrite pnElemE // !inE -andbA; congr (_ && _).\nby apply: andb_idl => /eqP oX; rewrite prime_abelem ?oX.\nQed.",
    "Lemma TIp1ElemP p A X Y :\n  X \\in 'E_p^1(A) -> Y \\in 'E_p^1(A) -> reflect (X :&: Y = 1) (X :!=: Y).\nProof.\nmove=> EpX EpY; have p_pr := pnElem_prime EpX.\nhave [oX oY] := (card_p1Elem EpX, card_p1Elem EpY).\nhave [<-|] := eqVneq.\n  by right=> X1; rewrite -oX -(setIid X) X1 cards1 in p_pr.\nby rewrite eqEcard oX oY leqnn andbT; left; rewrite prime_TIg ?oX.\nQed.",
    "Lemma card_p1Elem_pnElem p n A E :\n  E \\in 'E_p^n(A) -> #|'E_p^1(E)| = (\\sum_(i < n) p ^ i)%N.\nProof.\ncase/pnElemP=> _ {A} abelE dimE; have [pE cEE _] := and3P abelE.\nhave [E1 | ntE] := eqsVneq E 1.\n  rewrite -dimE E1 cards1 logn1 big_ord0 eq_card0 // => X.\n  by rewrite !inE subG1 trivg_card1; case: eqP => // ->; rewrite logn1 andbF.\nhave [p_pr _ _] := pgroup_pdiv pE ntE; have p_gt1 := prime_gt1 p_pr.\napply/eqP; rewrite -(@eqn_pmul2l (p - 1)) ?subn_gt0 // subn1 -predn_exp.\nhave groupD1_inj: injective (fun X => (gval X)^#).\n  apply: can_inj (@generated_group _) _ => X.\n  by apply: val_inj; rewrite /= genD1 ?group1 ?genGid.\nrewrite -dimE -card_pgroup // (cardsD1 1 E) group1 /= mulnC.\nrewrite -(card_imset _ groupD1_inj) eq_sym.\napply/eqP; apply: card_uniform_partition => [X'|].\n  case/imsetP=> X; rewrite pnElemE // expn1 => /setIdP[_ /eqP <-] ->.\n  by rewrite (cardsD1 1 X) group1.\napply/and3P; split; last 1 first.\n- apply/imsetP=> [[X /card_p1Elem oX X'0]].\n  by rewrite -oX (cardsD1 1) -X'0 group1 cards0 in p_pr.\n- rewrite eqEsubset; apply/andP; split.\n    by apply/bigcupsP=> _ /imsetP[X /pnElemP[sXE _ _] ->]; apply: setSD.\n  apply/subsetP=> x /setD1P[ntx Ex].\n  apply/bigcupP; exists <[x]>^#; last by rewrite !inE ntx cycle_id.\n  apply/imsetP; exists <[x]>%G; rewrite ?p1ElemE // !inE cycle_subG Ex /=.\n  by rewrite -orderE (abelem_order_p abelE).\napply/trivIsetP=> _ _ /imsetP[X EpX ->] /imsetP[Y EpY ->]; apply/implyP.\nrewrite (inj_eq groupD1_inj) -setI_eq0 -setDIl setD_eq0 subG1.\nby rewrite (sameP eqP (TIp1ElemP EpX EpY)) implybb.\nQed.",
    "Lemma card_p1Elem_p2Elem p A E : E \\in 'E_p^2(A) -> #|'E_p^1(E)| = p.+1.\nProof. by move/card_p1Elem_pnElem->; rewrite big_ord_recl big_ord1. Qed.",
    "Lemma p2Elem_dprodP p A E X Y :\n    E \\in 'E_p^2(A) -> X \\in 'E_p^1(E) -> Y \\in 'E_p^1(E) ->\n  reflect (X \\x Y = E) (X :!=: Y).\nProof.\nmove=> Ep2E EpX EpY; have [_ abelE oE] := pnElemPcard Ep2E.\napply: (iffP (TIp1ElemP EpX EpY)) => [tiXY|]; last by case/dprodP.\nhave [[sXE _ oX] [sYE _ oY]] := (pnElemPcard EpX, pnElemPcard EpY).\nrewrite dprodE ?(sub_abelian_cent2 (abelem_abelian abelE)) //.\nby apply/eqP; rewrite eqEcard mul_subG //= TI_cardMg // oX oY oE.\nQed.",
    "Lemma nElemP n G E : reflect (exists p, E \\in 'E_p^n(G)) (E \\in 'E^n(G)).\nProof.\nrewrite ['E^n(G)]big_mkord.\napply: (iffP bigcupP) => [[[p /= _] _] | [p]]; first by exists p.\ncase: n => [|n EpnE]; first by rewrite pnElem0; exists ord0; rewrite ?pnElem0.\nsuffices lepG: p < #|G|.+1  by exists (Ordinal lepG).\nhave:= EpnE; rewrite pnElemE ?(pnElem_prime EpnE) // !inE -andbA ltnS.\ncase/and3P=> sEG _ oE; rewrite dvdn_leq // (dvdn_trans _ (cardSg sEG)) //.\nby rewrite (eqP oE) dvdn_exp.\nQed.",
    "Lemma nElem0 G : 'E^0(G) = [set 1%G].\nProof.\napply/setP=> E; apply/nElemP/idP=> [[p] |]; first by rewrite pnElem0.\nby exists 2; rewrite pnElem0.\nQed.",
    "Lemma nElem1P G E :\n  reflect (E \\subset G /\\ exists2 p, prime p & #|E| = p) (E \\in 'E^1(G)).\nProof.\napply: (iffP nElemP) => [[p pE] | [sEG [p p_pr oE]]].\n  have p_pr := pnElem_prime pE; rewrite pnElemE // !inE -andbA in pE.\n  by case/and3P: pE => -> _ /eqP; split; last exists p.\nexists p; rewrite pnElemE // !inE sEG oE eqxx abelemE // -oE exponent_dvdn.\nby rewrite cyclic_abelian // prime_cyclic // oE.\nQed.",
    "Lemma nElemS n G H : G \\subset H -> 'E^n(G) \\subset 'E^n(H).\nProof.\nmove=> sGH; apply/subsetP=> E /nElemP[p EpnG_E].\nby apply/nElemP; exists p; rewrite // (subsetP (pnElemS _ _ sGH)).\nQed.",
    "Lemma nElemI n G H : 'E^n(G :&: H) = 'E^n(G) :&: subgroups H.\nProof.\napply/setP=> E; apply/nElemP/setIP=> [[p] | []].\n  by rewrite pnElemI; case/setIP; split=> //; apply/nElemP; exists p.\nby case/nElemP=> p EpnG_E sHE; exists p; rewrite pnElemI inE EpnG_E.\nQed.",
    "Lemma def_pnElem p n G : 'E_p^n(G) = 'E_p(G) :&: 'E^n(G).\nProof.\napply/setP=> E; rewrite inE in_setI; apply: andb_id2l => /pElemP[sEG abelE].\napply/idP/nElemP=> [|[q]]; first by exists p; rewrite !inE sEG abelE.\nrewrite !inE -2!andbA => /and4P[_ /pgroupP qE _].\nhave [->|] := eqVneq E 1%G; first by rewrite cards1 !logn1.\ncase/(pgroup_pdiv (abelem_pgroup abelE)) => p_pr pE _.\nby rewrite (eqnP (qE p p_pr pE)).\nQed.",
    "Lemma pmaxElemP p A E :\n  reflect (E \\in 'E_p(A) /\\ forall H, H \\in 'E_p(A) -> E \\subset H -> H :=: E)\n          (E \\in 'E*_p(A)).\nProof. by rewrite [E \\in 'E*_p(A)]inE; apply: (iffP maxgroupP). Qed.",
    "Lemma pmaxElem_exists p A D :\n  D \\in 'E_p(A) -> {E | E \\in 'E*_p(A) & D \\subset E}.\nProof.\nmove=> EpD; have [E maxE sDE] := maxgroup_exists (EpD : mem 'E_p(A) D).\nby exists E; rewrite // inE.\nQed.",
    "Lemma pmaxElem_LdivP p G E :\n  prime p -> reflect ('Ldiv_p('C_G(E)) = E) (E \\in 'E*_p(G)).\nProof.\nmove=> p_pr; apply: (iffP (pmaxElemP p G E)) => [[] | defE].\n  case/pElemP=> sEG abelE maxE; have [_ cEE eE] := and3P abelE.\n  apply/setP=> x; rewrite !inE -andbA; apply/and3P/idP=> [[Gx cEx xp] | Ex].\n    rewrite -(maxE (<[x]> <*> E)%G) ?joing_subr //.\n      by rewrite -cycle_subG joing_subl.\n    rewrite inE join_subG cycle_subG Gx sEG /=.\n    rewrite (cprod_abelem _ (cprodEY _)); last by rewrite centsC cycle_subG.\n    by rewrite cycle_abelem ?p_pr ?orbT // order_dvdn xp.\n  by rewrite (subsetP sEG) // (subsetP cEE) // (exponentP eE).\nsplit=> [|H]; last first.\n  case/pElemP=> sHG /abelemP[// | cHH Hp1] sEH.\n  apply/eqP; rewrite eqEsubset sEH andbC /= -defE; apply/subsetP=> x Hx.\n  by rewrite 3!inE (subsetP sHG) // Hp1 ?(subsetP (centsS _ cHH)) /=.\napply/pElemP; split; first by rewrite -defE -setIA subsetIl.\napply/abelemP=> //; rewrite /abelian -{1 3}defE setIAC subsetIr.\nby split=> //; apply/exponentP; rewrite -sub_LdivT setIAC subsetIr.\nQed.",
    "Lemma pmaxElemS p A B :\n  A \\subset B -> 'E*_p(B) :&: subgroups A \\subset 'E*_p(A).\nProof.\nmove=> sAB; apply/subsetP=> E /[!inE].\ncase/andP=> /maxgroupP[/pElemP[_ abelE] maxE] sEA.\napply/maxgroupP; rewrite inE sEA; split=> // D EpD.\nby apply: maxE; apply: subsetP EpD; apply: pElemS.\nQed.",
    "Lemma pmaxElemJ p A E x : ((E :^ x)%G \\in 'E*_p(A :^ x)) = (E \\in 'E*_p(A)).\nProof.\napply/pmaxElemP/pmaxElemP=> [] [EpE maxE].\n  rewrite pElemJ in EpE; split=> //= H EpH sEH; apply: (act_inj 'Js x).\n  by apply: maxE; rewrite ?conjSg ?pElemJ.\nrewrite pElemJ; split=> // H; rewrite -(actKV 'JG x H) pElemJ conjSg => EpHx'.\nby move/maxE=> /= ->.\nQed.",
    "Lemma grank_min B : 'm(<<B>>) <= #|B|.\nProof.\nby rewrite /gen_rank; case: arg_minnP => [|_ _ -> //]; rewrite genGid.\nQed.",
    "Lemma grank_witness G : {B | <<B>> = G & #|B| = 'm(G)}.\nProof.\nrewrite /gen_rank; case: arg_minnP => [|B defG _]; first by rewrite genGid.\nby exists B; first apply/eqP.\nQed.",
    "Lemma p_rank_witness p G : {E | E \\in 'E_p^('r_p(G))(G)}.\nProof.\nhave [E EG_E mE]: {E | E \\in 'E_p(G) & 'r_p(G) = logn p #|E| }.\n  by apply: eq_bigmax_cond; rewrite (cardD1 1%G) inE sub1G abelem1.\nby exists E; rewrite inE EG_E -mE /=.\nQed.",
    "Lemma p_rank_geP p n G : reflect (exists E, E \\in 'E_p^n(G)) (n <= 'r_p(G)).\nProof.\napply: (iffP idP) => [|[E]]; last first.\n  by rewrite inE => /andP[Ep_E /eqP <-]; rewrite (bigmax_sup E).\nhave [D /pnElemP[sDG abelD <-]] := p_rank_witness p G.\nby case/abelem_pnElem=> // E; exists E; apply: (subsetP (pnElemS _ _ sDG)).\nQed.",
    "Lemma p_rank_gt0 p H : ('r_p(H) > 0) = (p \\in \\pi(H)).\nProof.\nrewrite mem_primes cardG_gt0 /=; apply/p_rank_geP/andP=> [[E] | [p_pr]].\n  case/pnElemP=> sEG _; rewrite lognE; case: and3P => // [[-> _ pE] _].\n  by rewrite (dvdn_trans _ (cardSg sEG)).\ncase/Cauchy=> // x Hx ox; exists <[x]>%G; rewrite 2!inE [#|_|]ox cycle_subG.\nby rewrite Hx (pfactorK 1) ?abelemE // cycle_abelian -ox exponent_dvdn.\nQed.",
    "Lemma p_rank1 p : 'r_p([1 gT]) = 0.\nProof. by apply/eqP; rewrite eqn0Ngt p_rank_gt0 /= cards1. Qed.",
    "Lemma logn_le_p_rank p A E : E \\in 'E_p(A) -> logn p #|E| <= 'r_p(A).\nProof. by move=> EpA_E; rewrite (bigmax_sup E). Qed.",
    "Lemma p_rank_le_logn p G : 'r_p(G) <= logn p #|G|.\nProof.\nhave [E EpE] := p_rank_witness p G.\nby have [sEG _ <-] := pnElemP EpE; apply: lognSg.\nQed.",
    "Lemma p_rank_abelem p G : p.-abelem G -> 'r_p(G) = logn p #|G|.\nProof.\nmove=> abelG; apply/eqP; rewrite eqn_leq andbC (bigmax_sup G)//.\n  by apply/bigmax_leqP=> E /[1!inE] /andP[/lognSg->].\nby rewrite inE subxx.\nQed.",
    "Lemma p_rankS p A B : A \\subset B -> 'r_p(A) <= 'r_p(B).\nProof.\nmove=> sAB; apply/bigmax_leqP=> E /(subsetP (pElemS p sAB)) EpB_E.\nby rewrite (bigmax_sup E).\nQed.",
    "Lemma p_rankElem_max p A : 'E_p^('r_p(A))(A) \\subset 'E*_p(A).\nProof.\napply/subsetP=> E /setIdP[EpE dimE].\napply/pmaxElemP; split=> // F EpF sEF; apply/eqP.\nhave pF: p.-group F by case/pElemP: EpF => _ /and3P[].\nhave pE: p.-group E by case/pElemP: EpE => _ /and3P[].\nrewrite eq_sym eqEcard sEF dvdn_leq // (card_pgroup pE) (card_pgroup pF).\nby rewrite (eqP dimE) dvdn_exp2l // logn_le_p_rank.\nQed.",
    "Lemma p_rankJ p A x : 'r_p(A :^ x) = 'r_p(A).\nProof.\nrewrite /p_rank (reindex_inj (act_inj 'JG x)).\nby apply: eq_big => [E | E _]; rewrite ?cardJg ?pElemJ.\nQed.",
    "Lemma p_rank_Sylow p G H : p.-Sylow(G) H -> 'r_p(H) = 'r_p(G).\nProof.\nmove=> sylH; apply/eqP; rewrite eqn_leq (p_rankS _ (pHall_sub sylH)) /=.\napply/bigmax_leqP=> E /[1!inE] /andP[sEG abelE].\nhave [P sylP sEP] := Sylow_superset sEG (abelem_pgroup abelE).\nhave [x _ ->] := Sylow_trans sylP sylH.\nby rewrite p_rankJ -(p_rank_abelem abelE) (p_rankS _ sEP).\nQed.",
    "Lemma p_rank_Hall pi p G H : pi.-Hall(G) H -> p \\in pi -> 'r_p(H) = 'r_p(G).\nProof.\nmove=> hallH pi_p; have [P sylP] := Sylow_exists p H.\nby rewrite -(p_rank_Sylow sylP) (p_rank_Sylow (subHall_Sylow hallH pi_p sylP)).\nQed.",
    "Lemma p_rank_pmaxElem_exists p r G :\n  'r_p(G) >= r -> exists2 E, E \\in 'E*_p(G) & 'r_p(E) >= r.\nProof.\ncase/p_rank_geP=> D /setIdP[EpD /eqP <- {r}].\nhave [E EpE sDE] := pmaxElem_exists EpD; exists E => //.\ncase/pmaxElemP: EpE => /setIdP[_ abelE] _.\nby rewrite (p_rank_abelem abelE) lognSg.\nQed.",
    "Lemma rank1 : 'r([1 gT]) = 0.\nProof. by rewrite ['r(1)]big1_seq // => p _; rewrite p_rank1. Qed.",
    "Lemma p_rank_le_rank p G : 'r_p(G) <= 'r(G).\nProof.\ncase: (posnP 'r_p(G)) => [-> //|]; rewrite p_rank_gt0 mem_primes.\ncase/and3P=> p_pr _ pG; have lepg: p < #|G|.+1 by rewrite ltnS dvdn_leq.\nby rewrite ['r(G)]big_mkord (bigmax_sup (Ordinal lepg)).\nQed.",
    "Lemma rank_gt0 G : ('r(G) > 0) = (G :!=: 1).\nProof.\ncase: (eqsVneq G 1) => [-> |]; first by rewrite rank1.\ncase: (trivgVpdiv G) => [/eqP->// | [p p_pr]].\ncase/Cauchy=> // x Gx oxp _; apply: leq_trans (p_rank_le_rank p G).\nhave EpGx: <[x]>%G \\in 'E_p(G).\n  by rewrite inE cycle_subG Gx abelemE // cycle_abelian -oxp exponent_dvdn.\nby apply: leq_trans (logn_le_p_rank EpGx); rewrite -orderE oxp logn_prime ?eqxx.\nQed.",
    "Lemma rank_witness G : {p | prime p & 'r(G) = 'r_p(G)}.\nProof.\nhave [p _ defmG]: {p : 'I_(#|G|.+1) | true & 'r(G) = 'r_p(G)}.\n  by rewrite ['r(G)]big_mkord; apply: eq_bigmax_cond; rewrite card_ord.\ncase: (eqsVneq G 1) => [-> | ]; first by exists 2; rewrite // rank1 p_rank1.\nby rewrite -rank_gt0 defmG p_rank_gt0 mem_primes; case/andP; exists p.\nQed.",
    "Lemma rank_pgroup p G : p.-group G -> 'r(G) = 'r_p(G).\nProof.\nmove=> pG; apply/eqP; rewrite eqn_leq p_rank_le_rank andbT.\nrewrite ['r(G)]big_mkord; apply/bigmax_leqP=> [[q /= _] _].\ncase: (posnP 'r_q(G)) => [-> // |]; rewrite p_rank_gt0 mem_primes.\nby case/and3P=> q_pr _ qG; rewrite (eqnP (pgroupP pG q q_pr qG)).\nQed.",
    "Lemma rank_Sylow p G P : p.-Sylow(G) P -> 'r(P) = 'r_p(G).\nProof.\nmove=> sylP; have pP := pHall_pgroup sylP.\nby rewrite -(p_rank_Sylow sylP) -(rank_pgroup pP).\nQed.",
    "Lemma rank_abelem p G : p.-abelem G -> 'r(G) = logn p #|G|.\nProof.\nby move=> abelG; rewrite (rank_pgroup (abelem_pgroup abelG)) p_rank_abelem.\nQed.",
    "Lemma nt_pnElem p n E A : E \\in 'E_p^n(A) -> n > 0 -> E :!=: 1.\nProof. by case/pnElemP=> _ /rank_abelem <- <-; rewrite rank_gt0. Qed.",
    "Lemma rankJ A x : 'r(A :^ x) = 'r(A).\nProof. by rewrite /rank cardJg; apply: eq_bigr => p _; rewrite p_rankJ. Qed.",
    "Lemma rankS A B : A \\subset B -> 'r(A) <= 'r(B).\nProof.\nmove=> sAB; rewrite /rank !big_mkord; apply/bigmax_leqP=> p _.\nhave leAB: #|A| < #|B|.+1 by rewrite ltnS subset_leq_card.\nby rewrite (bigmax_sup (widen_ord leAB p)) ?p_rankS.\nQed.",
    "Lemma rank_geP n G : reflect (exists E, E \\in 'E^n(G)) (n <= 'r(G)).\nProof.\napply: (iffP idP) => [|[E]].\n  have [p _ ->] := rank_witness G; case/p_rank_geP=> E.\n  by rewrite def_pnElem; case/setIP; exists E.\ncase/nElemP=> p /[1!inE] /andP[EpG_E /eqP <-].\nby rewrite (leq_trans (logn_le_p_rank EpG_E)) ?p_rank_le_rank.\nQed.",
    "Lemma exponent_morphim G : exponent (f @* G) %| exponent G.\nProof.\napply/exponentP=> _ /morphimP[x Dx Gx ->].\nby rewrite -morphX // expg_exponent // morph1.\nQed.",
    "Lemma morphim_LdivT n : f @* 'Ldiv_n() \\subset 'Ldiv_n().\nProof.\napply/subsetP=> _ /morphimP[x Dx xn ->]; rewrite inE in xn.\nby rewrite inE -morphX // (eqP xn) morph1.\nQed.",
    "Lemma morphim_Ldiv n A : f @* 'Ldiv_n(A) \\subset 'Ldiv_n(f @* A).\nProof.\nby apply: subset_trans (morphimI f A _) (setIS _ _); apply: morphim_LdivT.\nQed.",
    "Lemma morphim_abelem p G : p.-abelem G -> p.-abelem (f @* G).\nProof.\ncase: (eqsVneq G 1) => [-> | ntG] abelG; first by rewrite morphim1 abelem1.\nhave [p_pr _ _] := pgroup_pdiv (abelem_pgroup abelG) ntG.\ncase/abelemP: abelG => // abG elemG; apply/abelemP; rewrite ?morphim_abelian //.\nby split=> // _ /morphimP[x Dx Gx ->]; rewrite -morphX // elemG ?morph1.\nQed.",
    "Lemma morphim_pElem p G E : E \\in 'E_p(G) -> (f @* E)%G \\in 'E_p(f @* G).\nProof.\nby rewrite !inE => /andP[sEG abelE]; rewrite morphimS // morphim_abelem.\nQed.",
    "Lemma morphim_pnElem p n G E :\n  E \\in 'E_p^n(G) -> {m | m <= n & (f @* E)%G \\in 'E_p^m(f @* G)}.\nProof.\nrewrite inE => /andP[EpE /eqP <-].\nby exists (logn p #|f @* E|); rewrite ?logn_morphim // inE morphim_pElem /=.\nQed.",
    "Lemma morphim_grank G : G \\subset D -> 'm(f @* G) <= 'm(G).\nProof.\nhave [B defG <-] := grank_witness G; rewrite -defG gen_subG => sBD.\nby rewrite morphim_gen ?morphimEsub ?(leq_trans (grank_min _)) ?leq_imset_card.\nQed.",
    "Lemma exponent_injm : exponent (f @* G) = exponent G.\nProof. by apply/eqP; rewrite eqn_dvd -{3}defG !exponent_morphim. Qed.",
    "Lemma injm_Ldiv n A : f @* 'Ldiv_n(A) = 'Ldiv_n(f @* A).\nProof.\napply/eqP; rewrite eqEsubset morphim_Ldiv.\nrewrite -[f @* 'Ldiv_n(A)](morphpre_invm injf).\nrewrite -sub_morphim_pre; last by rewrite subIset ?morphim_sub.\nrewrite injmI ?injm_invm // setISS ?morphim_LdivT //.\nby rewrite sub_morphim_pre ?morphim_sub // morphpre_invm.\nQed.",
    "Lemma injm_abelem p : p.-abelem (f @* G) = p.-abelem G.\nProof. by apply/idP/idP; first rewrite -{2}defG; apply: morphim_abelem. Qed.",
    "Lemma injm_pElem p (E : {group aT}) :\n  E \\subset D -> ((f @* E)%G \\in 'E_p(f @* G)) = (E \\in 'E_p(G)).\nProof.\nmove=> sED; apply/idP/idP=> EpE; last exact: morphim_pElem.\nby rewrite -defG -(group_inj (morphim_invm injf sED)) morphim_pElem.\nQed.",
    "Lemma injm_pnElem p n (E : {group aT}) :\n  E \\subset D -> ((f @* E)%G \\in 'E_p^n(f @* G)) = (E \\in 'E_p^n(G)).\nProof. by move=> sED; rewrite inE injm_pElem // card_injm ?inE. Qed.",
    "Lemma injm_nElem n (E : {group aT}) :\n  E \\subset D -> ((f @* E)%G \\in 'E^n(f @* G)) = (E \\in 'E^n(G)).\nProof.\nmove=> sED; apply/nElemP/nElemP=> [] [p EpE];\n by exists p; rewrite injm_pnElem in EpE *.\nQed.",
    "Lemma injm_pmaxElem p (E : {group aT}) :\n  E \\subset D -> ((f @* E)%G \\in 'E*_p(f @* G)) = (E \\in 'E*_p(G)).\nProof.\nmove=> sED; have defE := morphim_invm injf sED.\napply/pmaxElemP/pmaxElemP=> [] [EpE maxE].\n  split=> [|H EpH sEH]; first by rewrite injm_pElem in EpE.\n  have sHD: H \\subset D by apply: subset_trans (sGD); case/pElemP: EpH.\n  by rewrite -(morphim_invm injf sHD) [f @* H]maxE ?morphimS ?injm_pElem.\nrewrite injm_pElem //; split=> // fH Ep_fH sfEH; have [sfHG _] := pElemP Ep_fH.\nhave sfHD : fH \\subset f @* D by rewrite (subset_trans sfHG) ?morphimS.\nrewrite -(morphpreK sfHD); congr (f @* _).\nrewrite [_ @*^-1 fH]maxE -?sub_morphim_pre //.\nby rewrite -injm_pElem ?subsetIl // (group_inj (morphpreK sfHD)).\nQed.",
    "Lemma injm_grank : 'm(f @* G) = 'm(G).\nProof. by apply/eqP; rewrite eqn_leq -{3}defG !morphim_grank ?morphimS. Qed.",
    "Lemma injm_p_rank p : 'r_p(f @* G) = 'r_p(G).\nProof.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  have [fE] := p_rank_witness p (f @* G); move: 'r_p(_) => n Ep_fE.\n  apply/p_rank_geP; exists (f @*^-1 fE)%G.\n  rewrite -injm_pnElem ?subsetIl ?(group_inj (morphpreK _)) //.\n  by case/pnElemP: Ep_fE => sfEG _ _; rewrite (subset_trans sfEG) ?morphimS.\nhave [E] := p_rank_witness p G; move: 'r_p(_) => n EpE.\napply/p_rank_geP; exists (f @* E)%G; rewrite injm_pnElem //.\nby case/pnElemP: EpE => sEG _ _; rewrite (subset_trans sEG).\nQed.",
    "Lemma injm_rank : 'r(f @* G) = 'r(G).\nProof.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  by have [p _ ->] := rank_witness (f @* G); rewrite injm_p_rank p_rank_le_rank.\nby have [p _ ->] := rank_witness G; rewrite -injm_p_rank p_rank_le_rank.\nQed.",
    "Lemma exponent_isog : exponent G = exponent H.\nProof. by case/isogP: isoGH => f injf <-; rewrite exponent_injm. Qed.",
    "Lemma isog_abelem p : p.-abelem G = p.-abelem H.\nProof. by case/isogP: isoGH => f injf <-; rewrite injm_abelem. Qed.",
    "Lemma isog_grank : 'm(G) = 'm(H).\nProof. by case/isogP: isoGH => f injf <-; rewrite injm_grank. Qed.",
    "Lemma isog_p_rank p : 'r_p(G) = 'r_p(H).\nProof. by case/isogP: isoGH => f injf <-; rewrite injm_p_rank. Qed.",
    "Lemma isog_rank : 'r(G) = 'r(H).\nProof. by case/isogP: isoGH => f injf <-; rewrite injm_rank. Qed.",
    "Lemma exponent_quotient G H : exponent (G / H) %| exponent G.\nProof. exact: exponent_morphim. Qed.",
    "Lemma quotient_LdivT n H : 'Ldiv_n() / H \\subset 'Ldiv_n().\nProof. exact: morphim_LdivT. Qed.",
    "Lemma quotient_Ldiv n A H : 'Ldiv_n(A) / H \\subset 'Ldiv_n(A / H).\nProof. exact: morphim_Ldiv. Qed.",
    "Lemma quotient_abelem G H : p.-abelem G -> p.-abelem (G / H).\nProof. exact: morphim_abelem. Qed.",
    "Lemma quotient_pElem G H E : E \\in 'E_p(G) -> (E / H)%G \\in 'E_p(G / H).\nProof. exact: morphim_pElem. Qed.",
    "Lemma logn_quotient G H : logn p #|G / H| <= logn p #|G|.\nProof. exact: logn_morphim. Qed.",
    "Lemma quotient_pnElem G H n E :\n  E \\in 'E_p^n(G) -> {m | m <= n & (E / H)%G \\in 'E_p^m(G / H)}.\nProof. exact: morphim_pnElem. Qed.",
    "Lemma quotient_grank G H : G \\subset 'N(H) -> 'm(G / H) <= 'm(G).\nProof. exact: morphim_grank. Qed.",
    "Lemma p_rank_quotient G H : G \\subset 'N(H) -> 'r_p(G) - 'r_p(H) <= 'r_p(G / H).\nProof.\nmove=> nHG; rewrite leq_subLR.\nhave [E EpE] := p_rank_witness p G; have{EpE} [sEG abelE <-] := pnElemP EpE.\nrewrite -(LagrangeI E H) lognM ?cardG_gt0 //.\nrewrite -card_quotient ?(subset_trans sEG) // leq_add ?logn_le_p_rank // !inE.\n  by rewrite subsetIr (abelemS (subsetIl E H)).\nby rewrite quotientS ?quotient_abelem.\nQed.",
    "Lemma p_rank_dprod K H G : K \\x H = G -> 'r_p(K) + 'r_p(H) = 'r_p(G).\nProof.\nmove=> defG; apply/eqP; rewrite eqn_leq -leq_subLR andbC.\nhave [_ defKH cKH tiKH] := dprodP defG; have nKH := cents_norm cKH.\nrewrite {1}(isog_p_rank (quotient_isog nKH tiKH)) /= -quotientMidl defKH.\nrewrite p_rank_quotient; last by rewrite -defKH mul_subG ?normG.\nhave [[E EpE] [F EpF]] := (p_rank_witness p K, p_rank_witness p H).\nhave [[sEK abelE <-] [sFH abelF <-]] := (pnElemP EpE, pnElemP EpF).\nhave defEF: E \\x F = E <*> F.\n  by rewrite dprodEY ?(centSS sFH sEK) //; apply/trivgP; rewrite -tiKH setISS.\napply/p_rank_geP; exists (E <*> F)%G; rewrite !inE (dprod_abelem p defEF).\nrewrite -lognM ?cargG_gt0 // (dprod_card defEF) abelE abelF eqxx.\nby rewrite -(genGid G) -defKH genM_join genS ?setUSS.\nQed.",
    "Lemma p_rank_p'quotient G H :\n  (p : nat)^'.-group H -> G \\subset 'N(H) -> 'r_p(G / H) = 'r_p(G).\nProof.\nmove=> p'H nHG; have [P sylP] := Sylow_exists p G.\nhave [sPG pP _] := and3P sylP; have nHP := subset_trans sPG nHG.\nhave tiHP: H :&: P = 1 := coprime_TIg (p'nat_coprime p'H pP).\nrewrite -(p_rank_Sylow sylP) -(p_rank_Sylow (quotient_pHall nHP sylP)).\nby rewrite (isog_p_rank (quotient_isog nHP tiHP)).\nQed.",
    "Lemma Ohm_sub G : 'Ohm_n(G) \\subset G.\nProof. by rewrite gen_subG; apply/subsetP=> x /setIdP[]. Qed.",
    "Lemma Ohm1 : 'Ohm_n([1 gT]) = 1. Proof. exact: (trivgP (Ohm_sub _)). Qed.",
    "Lemma Ohm_id G : 'Ohm_n('Ohm_n(G)) = 'Ohm_n(G).\nProof.\napply/eqP; rewrite eqEsubset Ohm_sub genS //.\nby apply/subsetP=> x /setIdP[Gx oxn]; rewrite inE mem_gen // inE Gx.\nQed.",
    "Lemma Ohm_cont rT G (f : {morphism G >-> rT}) :\n  f @* 'Ohm_n(G) \\subset 'Ohm_n(f @* G).\nProof.\nrewrite morphim_gen ?genS //; last by rewrite -gen_subG Ohm_sub.\napply/subsetP=> fx /morphimP[x Gx]; rewrite inE Gx /=.\ncase/OhmPredP=> p p_pr xpn_1 -> {fx}.\nrewrite inE morphimEdom imset_f //=; apply/OhmPredP; exists p => //.\nby rewrite -morphX // xpn_1 morph1.\nQed.",
    "Lemma OhmS H G : H \\subset G -> 'Ohm_n(H) \\subset 'Ohm_n(G).\nProof.\nmove=> sHG; apply: genS; apply/subsetP=> x /[!inE] /andP[Hx ->].\nby rewrite (subsetP sHG).\nQed.",
    "Lemma OhmE p G : p.-group G -> 'Ohm_n(G) = <<'Ldiv_(p ^ n)(G)>>.\nProof.\nmove=> pG; congr <<_>>; apply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nhave [-> | ntx] := eqVneq x 1; first by rewrite !expg1n.\nby rewrite (pdiv_p_elt (mem_p_elt pG Gx)).\nQed.",
    "Lemma OhmEabelian p G :\n  p.-group G -> abelian 'Ohm_n(G) -> 'Ohm_n(G) = 'Ldiv_(p ^ n)(G).\nProof.\nmove=> pG; rewrite (OhmE pG) abelian_gen => cGGn; rewrite gen_set_id //.\nrewrite -(setIidPr (subset_gen 'Ldiv_(p ^ n)(G))) setIA.\nby rewrite [_ :&: G](setIidPl _) ?gen_subG ?subsetIl // group_Ldiv ?abelian_gen.\nQed.",
    "Lemma Ohm_p_cycle p x :\n  p.-elt x -> 'Ohm_n(<[x]>) = <[x ^+ (p ^ (logn p #[x] - n))]>.\nProof.\nmove=> p_x; apply/eqP; rewrite (OhmE p_x) eqEsubset cycle_subG mem_gen.\n  rewrite gen_subG andbT; apply/subsetP=> y /LdivP[x_y ypn].\n  case: (leqP (logn p #[x]) n) => [|lt_n_x].\n    by rewrite -subn_eq0 => /eqP->.\n  have p_pr: prime p by move: lt_n_x; rewrite lognE; case: (prime p).\n  have def_y: <[y]> = <[x ^+ (#[x] %/ #[y])]>.\n    apply: congr_group; apply/set1P.\n    by rewrite -cycle_sub_group ?cardSg ?inE ?cycle_subG ?x_y /=.\n  rewrite -cycle_subG def_y cycle_subG -{1}(part_pnat_id p_x) p_part.\n  rewrite -{1}(subnK (ltnW lt_n_x)) expnD -muln_divA ?order_dvdn ?ypn //.\n  by rewrite expgM mem_cycle.\nrewrite !inE mem_cycle -expgM -expnD addnC -maxnE -order_dvdn.\nby rewrite -{1}(part_pnat_id p_x) p_part dvdn_exp2l ?leq_maxr.\nQed.",
    "Lemma Ohm_dprod A B G : A \\x B = G -> 'Ohm_n(A) \\x 'Ohm_n(B) = 'Ohm_n(G).\nProof.\ncase/dprodP => [[H K -> ->{A B}]] <- cHK tiHK.\nrewrite dprodEY //; last first.\n- by apply/trivgP; rewrite -tiHK setISS ?Ohm_sub.\n- by rewrite (subset_trans (subset_trans _ cHK)) ?centS ?Ohm_sub.\napply/eqP; rewrite -(cent_joinEr cHK) eqEsubset join_subG /=.\nrewrite !OhmS ?joing_subl ?joing_subr //= cent_joinEr //= -genM_join genS //.\napply/subsetP=> _ /setIdP[/imset2P[x y Hx Ky ->] /OhmPredP[p p_pr /eqP]].\nhave cxy: commute x y by red; rewrite -(centsP cHK).\nrewrite ?expgMn // -eq_invg_mul => /eqP def_x.\nhave ypn1: y ^+ (p ^ n) = 1.\n  by apply/set1P; rewrite -[[set 1]]tiHK inE -{1}def_x groupV !groupX.\nhave xpn1: x ^+ (p ^ n) = 1 by rewrite -[x ^+ _]invgK def_x ypn1 invg1.\nby rewrite mem_mulg ?mem_gen // inE (Hx, Ky); apply/OhmPredP; exists p.\nQed.",
    "Lemma Mho_sub G : 'Mho^n(G) \\subset G.\nProof.\nrewrite gen_subG; apply/subsetP=> _ /imsetP[x /setIdP[Gx _] ->].\nexact: groupX.\nQed.",
    "Lemma Mho1 : 'Mho^n([1 gT]) = 1. Proof. exact: (trivgP (Mho_sub _)). Qed.",
    "Lemma morphim_Mho rT D G (f : {morphism D >-> rT}) :\n  G \\subset D -> f @* 'Mho^n(G) = 'Mho^n(f @* G).\nProof.\nmove=> sGD; have sGnD := subset_trans (Mho_sub G) sGD.\napply/eqP; rewrite eqEsubset {1}morphim_gen -1?gen_subG // !gen_subG.\napply/andP; split; apply/subsetP=> y.\n  case/morphimP=> xpn _ /imsetP[x /setIdP[Gx]].\n  set p := pdiv _ => p_x -> -> {xpn y}; have Dx := subsetP sGD x Gx.\n  by rewrite morphX // Mho_p_elt ?morph_p_elt ?mem_morphim.\ncase/imsetP=> _ /setIdP[/morphimP[x Dx Gx ->]].\nset p := pdiv _ => p_fx ->{y}; rewrite -(constt_p_elt p_fx) -morph_constt //.\nby rewrite -morphX ?mem_morphim ?Mho_p_elt ?groupX ?p_elt_constt.\nQed.",
    "Lemma Mho_cont rT G (f : {morphism G >-> rT}) :\n  f @* 'Mho^n(G) \\subset 'Mho^n(f @* G).\nProof. by rewrite morphim_Mho. Qed.",
    "Lemma MhoS H G : H \\subset G -> 'Mho^n(H) \\subset 'Mho^n(G).\nProof.\nmove=> sHG; apply: genS; apply: imsetS; apply/subsetP=> x.\nby rewrite !inE => /andP[Hx]; rewrite (subsetP sHG).\nQed.",
    "Lemma MhoE p G : p.-group G -> 'Mho^n(G) = <<[set x ^+ (p ^ n) | x in G]>>.\nProof.\nmove=> pG; apply/eqP; rewrite eqEsubset !gen_subG; apply/andP.\ndo [split; apply/subsetP=> xpn; case/imsetP=> x] => [|Gx ->]; last first.\n  by rewrite Mho_p_elt ?(mem_p_elt pG).\ncase/setIdP=> Gx _ ->; have [-> | ntx] := eqVneq x 1; first by rewrite expg1n.\nby rewrite (pdiv_p_elt (mem_p_elt pG Gx) ntx) mem_gen //; apply: imset_f.\nQed.",
    "Lemma MhoEabelian p G :\n  p.-group G -> abelian G -> 'Mho^n(G) = [set x ^+ (p ^ n) | x in G].\nProof.\nmove=> pG cGG; rewrite (MhoE pG); rewrite gen_set_id //; apply/group_setP.\nsplit=> [|xn yn]; first by apply/imsetP; exists 1; rewrite ?expg1n.\ncase/imsetP=> x Gx ->; case/imsetP=> y Gy ->.\nby rewrite -expgMn; [apply: imset_f; rewrite groupM | apply: (centsP cGG)].\nQed.",
    "Lemma trivg_Mho G : 'Mho^n(G) == 1 -> 'Ohm_n(G) == G.\nProof.\nrewrite -subG1 gen_subG eqEsubset Ohm_sub /= => Gp1.\nrewrite -{1}(Sylow_gen G) genS //; apply/bigcupsP=> P.\ncase/SylowP=> p p_pr /and3P[sPG pP _]; apply/subsetP=> x Px.\nhave Gx := subsetP sPG x Px; rewrite inE Gx //=.\nrewrite (sameP eqP set1P) (subsetP Gp1) ?mem_gen //; apply: imset_f.\nby rewrite inE Gx; apply: pgroup_p (mem_p_elt pP Px).\nQed.",
    "Lemma Mho_p_cycle p x : p.-elt x -> 'Mho^n(<[x]>) = <[x ^+ (p ^ n)]>.\nProof.\nmove=> p_x.\napply/eqP; rewrite (MhoE p_x) eqEsubset cycle_subG mem_gen; last first.\n  by apply: imset_f; apply: cycle_id.\nrewrite gen_subG andbT; apply/subsetP=> _ /imsetP[_ /cycleP[k ->] ->].\nby rewrite -expgM mulnC expgM mem_cycle.\nQed.",
    "Lemma Mho_cprod A B G : A \\* B = G -> 'Mho^n(A) \\* 'Mho^n(B) = 'Mho^n(G).\nProof.\ncase/cprodP => [[H K -> ->{A B}]] <- cHK; rewrite cprodEY //; last first.\n  by rewrite (subset_trans (subset_trans _ cHK)) ?centS ?Mho_sub.\napply/eqP; rewrite -(cent_joinEr cHK) eqEsubset join_subG /=.\nrewrite !MhoS ?joing_subl ?joing_subr //= cent_joinEr // -genM_join.\napply: genS; apply/subsetP=> xypn /imsetP[_ /setIdP[/imset2P[x y Hx Ky ->]]].\nmove/constt_p_elt; move: (pdiv _) => p <- ->.\nhave cxy: commute x y by red; rewrite -(centsP cHK).\nrewrite consttM // expgMn; last exact: commuteX2.\nby rewrite mem_mulg ?Mho_p_elt ?groupX ?p_elt_constt.\nQed.",
    "Lemma Mho_dprod A B G : A \\x B = G -> 'Mho^n(A) \\x 'Mho^n(B) = 'Mho^n(G).\nProof.\ncase/dprodP => [[H K -> ->{A B}]] defG cHK tiHK.\nrewrite dprodEcp; first by apply: Mho_cprod; rewrite cprodE.\nby apply/trivgP; rewrite -tiHK setISS ?Mho_sub.\nQed.",
    "Lemma Ohm_char : 'Ohm_n(G) \\char G. Proof. exact: gFchar. Qed.",
    "Lemma Ohm_normal : 'Ohm_n(G) <| G. Proof. exact: gFnormal. Qed.",
    "Lemma Mho_char : 'Mho^n(G) \\char G. Proof. exact: gFchar. Qed.",
    "Lemma Mho_normal : 'Mho^n(G) <| G. Proof. exact: gFnormal. Qed.",
    "Lemma morphim_Ohm (f : {morphism D >-> rT}) :\n  G \\subset D -> f @* 'Ohm_n(G) \\subset 'Ohm_n(f @* G).\nProof. exact: morphimF. Qed.",
    "Lemma injm_Ohm (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* 'Ohm_n(G) = 'Ohm_n(f @* G).\nProof. by move=> injf; apply: injmF. Qed.",
    "Lemma isog_Ohm (H : {group rT}) : G \\isog H -> 'Ohm_n(G) \\isog 'Ohm_n(H).\nProof. exact: gFisog. Qed.",
    "Lemma isog_Mho (H : {group rT}) : G \\isog H -> 'Mho^n(G) \\isog 'Mho^n(H).\nProof. exact: gFisog. Qed.",
    "Lemma Ohm0 G : 'Ohm_0(G) = 1.\nProof.\nby apply/trivgP; rewrite /= gen_subG; apply/subsetP=> x /setIdP[_] /[1!inE].\nQed.",
    "Lemma Ohm_leq m n G : m <= n -> 'Ohm_m(G) \\subset 'Ohm_n(G).\nProof.\nmove/subnKC <-; rewrite genS //; apply/subsetP=> y.\nby rewrite !inE expnD expgM => /andP[-> /eqP->]; rewrite expg1n /=.\nQed.",
    "Lemma OhmJ n G x : 'Ohm_n(G :^ x) = 'Ohm_n(G) :^ x.\nProof.\nrewrite -{1}(setIid G) -(setIidPr (Ohm_sub n G)).\nby rewrite -!morphim_conj injm_Ohm ?injm_conj.\nQed.",
    "Lemma Mho0 G : 'Mho^0(G) = G.\nProof.\napply/eqP; rewrite eqEsubset Mho_sub /=.\napply/subsetP=> x Gx; rewrite -[x]prod_constt group_prod // => p _.\nexact: Mho_p_elt (groupX _ Gx) (p_elt_constt _ _).\nQed.",
    "Lemma Mho_leq m n G : m <= n -> 'Mho^n(G) \\subset 'Mho^m(G).\nProof.\nmove/subnKC <-; rewrite gen_subG //.\napply/subsetP=> _ /imsetP[x /setIdP[Gx p_x] ->].\nby rewrite expnD expgM groupX ?(Mho_p_elt _ _ p_x).\nQed.",
    "Lemma MhoJ n G x : 'Mho^n(G :^ x) = 'Mho^n(G) :^ x.\nProof.\nby rewrite -{1}(setIid G) -(setIidPr (Mho_sub n G)) -!morphim_conj morphim_Mho.\nQed.",
    "Lemma extend_cyclic_Mho G p x :\n    p.-group G -> x \\in G -> 'Mho^1(G) = <[x ^+ p]> -> \n  forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (p ^ k)]>.\nProof.\nmove=> pG Gx defG1 [//|k _]; have pX := mem_p_elt pG Gx.\napply/eqP; rewrite eqEsubset cycle_subG (Mho_p_elt _ Gx pX) andbT.\nrewrite (MhoE _ pG) gen_subG; apply/subsetP=> ypk; case/imsetP=> y Gy ->{ypk}.\nhave: y ^+ p \\in <[x ^+ p]> by rewrite -defG1 (Mho_p_elt 1 _ (mem_p_elt pG Gy)).\nrewrite !expnS /= !expgM => /cycleP[j ->].\nby rewrite -!expgM mulnCA mulnC expgM mem_cycle.\nQed.",
    "Lemma Ohm1Eprime G : 'Ohm_1(G) = <<[set x in G | prime #[x]]>>.\nProof.\nrewrite -['Ohm_1(G)](genD1 (group1 _)); congr <<_>>.\napply/setP=> x; rewrite !inE andbCA -order_dvdn -order_gt1; congr (_ && _).\napply/andP/idP=> [[p_gt1] | p_pr]; last by rewrite prime_gt1 ?pdiv_id.\nset p := pdiv _ => ox_p; have p_pr: prime p by rewrite pdiv_prime.\nby have [_ dv_p] := primeP p_pr; case/pred2P: (dv_p _ ox_p) p_gt1 => ->.\nQed.",
    "Lemma abelem_Ohm1 p G : p.-group G -> p.-abelem 'Ohm_1(G) = abelian 'Ohm_1(G).\nProof.\nmove=> pG; rewrite /abelem (pgroupS (Ohm_sub 1 G)) //.\ncase abG1: (abelian _) => //=; apply/exponentP=> x.\nby rewrite (OhmEabelian pG abG1); case/LdivP.\nQed.",
    "Lemma Ohm1_abelem p G : p.-group G -> abelian G -> p.-abelem ('Ohm_1(G)).\nProof. by move=> pG cGG; rewrite abelem_Ohm1 ?(abelianS (Ohm_sub 1 G)). Qed.",
    "Lemma Ohm1_id p G : p.-abelem G -> 'Ohm_1(G) = G.\nProof.\ncase/and3P=> pG cGG /exponentP Gp.\napply/eqP; rewrite eqEsubset Ohm_sub (OhmE 1 pG) sub_gen //.\nby apply/subsetP=> x Gx; rewrite !inE Gx Gp /=.\nQed.",
    "Lemma abelem_Ohm1P p G :\n  abelian G -> p.-group G -> reflect ('Ohm_1(G) = G) (p.-abelem G).\nProof.\nmove=> cGG pG.\nby apply: (iffP idP) => [| <-]; [apply: Ohm1_id | apply: Ohm1_abelem].\nQed.",
    "Lemma TI_Ohm1 G H : H :&: 'Ohm_1(G) = 1 -> H :&: G = 1.\nProof.\nmove=> tiHG1; case: (trivgVpdiv (H :&: G)) => // [[p pr_p]].\ncase/Cauchy=> // x /setIP[Hx Gx] ox.\nsuffices x1: x \\in [1] by rewrite -ox (set1P x1) order1 in pr_p.\nby rewrite -{}tiHG1 inE Hx Ohm1Eprime mem_gen // inE Gx ox.\nQed.",
    "Lemma Ohm1_eq1 G : ('Ohm_1(G) == 1) = (G :==: 1).\nProof.\napply/idP/idP => [/eqP G1_1 | /eqP->]; last by rewrite -subG1 Ohm_sub.\nby rewrite -(setIid G) TI_Ohm1 // G1_1 setIg1.\nQed.",
    "Lemma meet_Ohm1 G H : G :&: H != 1 -> G :&: 'Ohm_1(H) != 1.\nProof. by apply: contraNneq => /TI_Ohm1->. Qed.",
    "Lemma Ohm1_cent_max G E p : E \\in 'E*_p(G) -> p.-group G -> 'Ohm_1('C_G(E)) = E.\nProof.\nmove=> EpmE pG; have [G1 | ntG]:= eqsVneq G 1.\n  case/pmaxElemP: EpmE; case/pElemP; rewrite G1 => /trivgP-> _ _.\n  by apply/trivgP; rewrite cent1T setIT Ohm_sub.\nhave [p_pr _ _] := pgroup_pdiv pG ntG.\nby rewrite (OhmE 1 (pgroupS (subsetIl G _) pG)) (pmaxElem_LdivP _ _) ?genGid.\nQed.",
    "Lemma Ohm1_cyclic_pgroup_prime p G :\n  cyclic G -> p.-group G -> G :!=: 1 -> #|'Ohm_1(G)| = p.\nProof.\nmove=> cycG pG ntG; set K := 'Ohm_1(G).\nhave abelK: p.-abelem K by rewrite Ohm1_abelem ?cyclic_abelian.\nhave sKG: K \\subset G := Ohm_sub 1 G.\ncase/cyclicP: (cyclicS sKG cycG) => x /=; rewrite -/K => defK.\nrewrite defK -orderE (abelem_order_p abelK) //= -/K ?defK ?cycle_id //.\nrewrite -cycle_eq1 -defK -(setIidPr sKG).\nby apply: contraNneq ntG => /TI_Ohm1; rewrite setIid => ->.\nQed.",
    "Lemma cyclic_pgroup_dprod_trivg p A B C :\n    p.-group C -> cyclic C -> A \\x B = C ->\n  A = 1 /\\ B = C \\/ B = 1 /\\ A = C.\nProof.\nmove=> pC cycC; case/cyclicP: cycC pC => x ->{C} pC defC.\ncase/dprodP: defC => [] [G H -> ->{A B}] defC _ tiGH; rewrite -defC.\nhave [/trivgP | ntC] := eqVneq <[x]> 1.\n  by rewrite -defC mulG_subG => /andP[/trivgP-> _]; rewrite mul1g; left.\nhave [pr_p _ _] := pgroup_pdiv pC ntC; pose K := 'Ohm_1(<[x]>).\nhave prK : prime #|K| by rewrite (Ohm1_cyclic_pgroup_prime _ pC) ?cycle_cyclic.\ncase: (prime_subgroupVti G prK) => [sKG |]; last first.\n  move/TI_Ohm1; rewrite -defC (setIidPl (mulG_subl _ _)) => ->.\n  by left; rewrite mul1g.\ncase: (prime_subgroupVti H prK) => [sKH |]; last first.\n  move/TI_Ohm1; rewrite -defC (setIidPl (mulG_subr _ _)) => ->.\n  by right; rewrite mulg1.\nhave K1: K :=: 1 by apply/trivgP; rewrite -tiGH subsetI sKG.\nby rewrite K1 cards1 in prK.\nQed.",
    "Lemma piOhm1 G : \\pi('Ohm_1(G)) = \\pi(G).\nProof.\napply/eq_piP => p; apply/idP/idP; first exact: (piSg (Ohm_sub 1 G)).\nrewrite !mem_primes !cardG_gt0 => /andP[p_pr /Cauchy[] // x Gx oxp].\nby rewrite p_pr -oxp order_dvdG //= Ohm1Eprime mem_gen // inE Gx oxp.\nQed.",
    "Lemma Ohm1Eexponent p G :\n  prime p -> exponent 'Ohm_1(G) %| p -> 'Ohm_1(G) = 'Ldiv_p(G).\nProof.\nmove=> p_pr expG1p; have pG: p.-group G.\n  apply: sub_in_pnat (pnat_pi (cardG_gt0 G)) => q _.\n  rewrite -piOhm1 mem_primes; case/and3P=> q_pr _; apply: pgroupP q_pr.\n  by rewrite -pnat_exponent (pnat_dvd expG1p) ?pnat_id.\napply/eqP; rewrite eqEsubset {2}(OhmE 1 pG) subset_gen subsetI Ohm_sub.\nby rewrite sub_LdivT expG1p.\nQed.",
    "Lemma p_rank_Ohm1 p G : 'r_p('Ohm_1(G)) = 'r_p(G).\nProof.\napply/eqP; rewrite eqn_leq p_rankS ?Ohm_sub //.\napply/bigmax_leqP=> E /setIdP[sEG abelE].\nby rewrite (bigmax_sup E) // inE -{1}(Ohm1_id abelE) OhmS.\nQed.",
    "Lemma rank_Ohm1 G : 'r('Ohm_1(G)) = 'r(G).\nProof.\napply/eqP; rewrite eqn_leq rankS ?Ohm_sub //.\nby have [p _ ->] := rank_witness G; rewrite -p_rank_Ohm1 p_rank_le_rank.\nQed.",
    "Lemma p_rank_abelian p G : abelian G -> 'r_p(G) = logn p #|'Ohm_1(G)|.\nProof.\nmove=> cGG; have nilG := abelian_nil cGG; case p_pr: (prime p); last first.\n  by apply/eqP; rewrite lognE p_pr eqn0Ngt p_rank_gt0 mem_primes p_pr.\ncase/dprodP: (Ohm_dprod 1 (nilpotent_pcoreC p nilG)) => _ <- _ /TI_cardMg->.\nrewrite mulnC logn_Gauss; last first.\n  rewrite prime_coprime // -p'natE // -/(pgroup _ _).\n  exact: pgroupS (Ohm_sub _ _) (pcore_pgroup _ _).\nrewrite -(p_rank_Sylow (nilpotent_pcore_Hall p nilG)) -p_rank_Ohm1.\nrewrite p_rank_abelem // Ohm1_abelem ?pcore_pgroup //.\nexact: abelianS (pcore_sub _ _) cGG.\nQed.",
    "Lemma rank_abelian_pgroup p G :\n  p.-group G -> abelian G -> 'r(G) = logn p #|'Ohm_1(G)|.\nProof. by move=> pG cGG; rewrite (rank_pgroup pG) p_rank_abelian. Qed.",
    "Lemma abelian_splits x G :\n  x \\in G -> #[x] = exponent G -> abelian G -> [splits G, over <[x]>].\nProof.\nmove=> Gx ox cGG; apply/splitsP; have [n] := ubnP #|G|.\nelim: n gT => // n IHn aT in x G Gx ox cGG * => /ltnSE-leGn.\nhave: <[x]> \\subset G by [rewrite cycle_subG]; rewrite subEproper.\ncase/predU1P=> [<- | /properP[sxG [y]]].\n  by exists 1%G; rewrite inE -subG1 subsetIr mulg1 /=.\nhave [m] := ubnP #[y]; elim: m y => // m IHm y /ltnSE-leym Gy x'y.\ncase: (trivgVpdiv <[y]>) => [y1 | [p p_pr p_dv_y]].\n  by rewrite -cycle_subG y1 sub1G in x'y.\ncase x_yp: (y ^+ p \\in <[x]>); last first.\n  apply: IHm (negbT x_yp); rewrite ?groupX ?(leq_trans _ leym) //.\n  by rewrite orderXdiv // ltn_Pdiv ?prime_gt1.\nhave{x_yp} xp_yp: (y ^+ p \\in <[x ^+ p]>).\n  have: <[y ^+ p]>%G \\in [set <[x ^+ (#[x] %/ #[y ^+ p])]>%G].\n    by rewrite -cycle_sub_group ?order_dvdG // inE cycle_subG x_yp eqxx.\n  rewrite inE -cycle_subG -val_eqE /=; move/eqP->.\n  rewrite cycle_subG orderXdiv // divnA // mulnC ox.\n  by rewrite -muln_divA ?dvdn_exponent ?expgM 1?groupX ?cycle_id.\nhave: p <= #[y] by rewrite dvdn_leq.\nrewrite leq_eqVlt => /predU1P[{xp_yp m IHm leym}oy | ltpy]; last first.\n  case/cycleP: xp_yp => k; rewrite -expgM mulnC expgM => def_yp.\n  suffices: #[y * x ^- k] < m.\n    by move/IHm; apply; rewrite groupMr // groupV groupX ?cycle_id.\n  apply: leq_ltn_trans (leq_trans ltpy leym).\n  rewrite dvdn_leq ?prime_gt0 // order_dvdn expgMn.\n    by rewrite expgVn def_yp mulgV.\n  by apply: (centsP cGG); rewrite ?groupV ?groupX.\npose Y := <[y]>; have nsYG: Y <| G by rewrite -sub_abelian_normal ?cycle_subG.\nhave [sYG nYG] := andP nsYG; have nYx := subsetP nYG x Gx.\nhave GxY: coset Y x \\in G / Y by rewrite mem_morphim.\nhave tiYx: Y :&: <[x]> = 1 by rewrite prime_TIg ?indexg1 -?[#|_|]oy ?cycle_subG.\nhave: #[coset Y x] = exponent (G / Y).\n  apply/eqP; rewrite eqn_dvd dvdn_exponent //.\n  apply/exponentP=> _ /morphimP[z Nz Gz ->].\n  rewrite -morphX // ((z ^+ _ =P 1) _) ?morph1 //.\n  rewrite orderE -quotient_cycle ?card_quotient ?cycle_subG // -indexgI /=.\n  by rewrite setIC tiYx indexg1 -orderE ox -order_dvdn dvdn_exponent.\ncase/IHn => // [||Hq]; first exact: quotient_abelian.\n  apply: leq_trans leGn; rewrite ltn_quotient // cycle_eq1.\n  by apply: contra x'y; move/eqP->; rewrite group1.\ncase/complP=> /= ti_x_Hq defGq.\nhave: Hq \\subset G / Y by rewrite -defGq mulG_subr.\ncase/inv_quotientS=> // H defHq sYH sHG; exists H.\nhave nYX: <[x]> \\subset 'N(Y) by rewrite cycle_subG.\nrewrite inE -subG1 eqEsubset mul_subG //= -tiYx subsetI subsetIl andbT.\nrewrite -{2}(mulSGid sYH) mulgA (normC nYX) -mulgA -quotientSK ?quotientMl //.\nrewrite -quotient_sub1 ?(subset_trans (subsetIl _ _)) // quotientIG //= -/Y.\nby rewrite -defHq quotient_cycle // ti_x_Hq defGq !subxx.\nQed.",
    "Lemma abelem_splits p G H : p.-abelem G -> H \\subset G -> [splits G, over H].\nProof.\nhave [m] := ubnP #|G|; elim: m G H => // m IHm G H /ltnSE-leGm abelG sHG.\nhave [-> | ] := eqsVneq H 1. \n  by apply/splitsP; exists G; rewrite inE mul1g -subG1 subsetIl /=.\ncase/trivgPn=> x Hx ntx; have Gx := subsetP sHG x Hx.\nhave [_ cGG eGp] := and3P abelG.\nhave ox: #[x] = exponent G.\n  by apply/eqP; rewrite eqn_dvd dvdn_exponent // (abelem_order_p abelG).\ncase/splitsP: (abelian_splits Gx ox cGG) => K; case/complP=> tixK defG.\nhave sKG: K \\subset G by rewrite -defG mulG_subr.\nhave ltKm: #|K| < m.\n  rewrite (leq_trans _ leGm) ?proper_card //; apply/properP; split=> //.\n  exists x => //; apply: contra ntx => Kx; rewrite -cycle_eq1 -subG1 -tixK.\n  by rewrite subsetI subxx cycle_subG.\ncase/splitsP: (IHm _ _ ltKm (abelemS sKG abelG) (subsetIr H K)) => L.\ncase/complP=> tiHKL defK; apply/splitsP; exists L; rewrite inE.\nrewrite -subG1 -tiHKL -setIA setIS; last by rewrite subsetI -defK mulG_subr /=.\nby rewrite -(setIidPr sHG) -defG -group_modl ?cycle_subG //= setIC -mulgA defK.\nQed.",
    "Lemma abelian_type_dvdn_sorted A : sorted [rel m n | n %| m] (abelian_type A).\nProof.\nset R := SimplRel _; pose G := <<A>>%G; pose M := G.\nsuffices: path R (exponent M) (abelian_type A) by case: (_ A) => // m t /andP[].\nrewrite /abelian_type -/G; have: G \\subset M by [].\nelim: {A}#|A| G M => //= n IHn G M sGM.\ncase: andP => //= -[cGG ntG]; rewrite exponentS ?IHn //=.\ncase: (abelian_type_subproof G) => H /= [//| x _] /dprodP[_ /= <- _ _].\nexact: mulG_subr.\nQed.",
    "Lemma abelian_type_gt1 A : all [pred m | m > 1] (abelian_type A).\nProof.\nrewrite /abelian_type; elim: {A}#|A| <<A>>%G => //= n IHn G.\ncase: ifP => //= /andP[_ ntG]; rewrite {n}IHn.\nby rewrite ltn_neqAle exponent_gt0 eq_sym -dvdn1 -trivg_exponent ntG.\nQed.",
    "Lemma abelian_type_sorted A : sorted geq (abelian_type A).\nProof.\nhave:= abelian_type_dvdn_sorted A; have:= abelian_type_gt1 A.\ncase: (abelian_type A) => //= m t; elim: t m => //= n t IHt m /andP[].\nby move/ltnW=> m_gt0 t_gt1 /andP[n_dv_m /IHt->]; rewrite // dvdn_leq.\nQed.",
    "Lemma count_logn_dprod_cycle p n b G :\n    \\big[dprod/1]_(x <- b) <[x]> = G ->\n  count [pred x | logn p #[x] > n] b = logn p #|'Ohm_n.+1(G) : 'Ohm_n(G)|.\nProof.\nhave sOn1 H: 'Ohm_n(H) \\subset 'Ohm_n.+1(H) by apply: Ohm_leq.\npose lnO i (A : {set gT}) := logn p #|'Ohm_i(A)|.\nhave lnO_le H: lnO n H <= lnO n.+1 H.\n  by rewrite dvdn_leq_log ?cardG_gt0 // cardSg ?sOn1.\nhave lnOx i A B H: A \\x B = H -> lnO i A + lnO i B = lnO i H.\n  move=> defH; case/dprodP: defH (defH) => {A B}[[A B -> ->]] _ _ _ defH.\n  rewrite /lnO; case/dprodP: (Ohm_dprod i defH) => _ <- _ tiOAB.\n  by rewrite TI_cardMg ?lognM.\nrewrite -divgS //= logn_div ?cardSg //= -/(lnO _ _) -/(lnO _ _).\nelim: b G => [_ <-|x b IHb G] /=.\n  by rewrite big_nil /lnO !(trivgP (Ohm_sub _ _)) subnn.\nrewrite /= big_cons => defG; rewrite -!(lnOx _ _ _ _ defG) subnDA.\ncase/dprodP: defG => [[_ H _ defH] _ _ _] {G}; rewrite defH (IHb _ defH).\nsymmetry; do 2!rewrite addnC -addnBA ?lnO_le //; congr (_ + _).\npose y := x.`_p; have p_y: p.-elt y by rewrite p_elt_constt.\nhave{lnOx} lnOy i: lnO i <[x]> = lnO i <[y]>.\n  have cXX := cycle_abelian x.\n  have co_yx': coprime #[y] #[x.`_p^'] by rewrite !order_constt coprime_partC.\n  have defX: <[y]> \\x <[x.`_p^']> = <[x]>.\n    rewrite dprodE ?coprime_TIg //.\n      by rewrite -cycleM ?consttC //; apply: (centsP cXX); apply: mem_cycle.\n    by apply: (sub_abelian_cent2 cXX); rewrite cycle_subG mem_cycle.\n  rewrite -(lnOx i _ _ _ defX) addnC {1}/lnO lognE.\n  case: and3P => // [[p_pr _ /idPn[]]]; rewrite -p'natE //.\n  exact: pgroupS (Ohm_sub _ _) (p_elt_constt _ _).\nrewrite -logn_part -order_constt -/y !{}lnOy /lnO !(Ohm_p_cycle _ p_y).\ncase: leqP => [| lt_n_y].\n  by rewrite -subn_eq0 -addn1 subnDA => /eqP->; rewrite subnn.\nrewrite -!orderE -(subSS n) subSn // expnSr expgM.\nhave p_pr: prime p by move: lt_n_y; rewrite lognE; case: prime.\nset m := (p ^ _)%N; have m_gt0: m > 0 by rewrite expn_gt0 prime_gt0.\nsuffices p_ym: p %| #[y ^+ m].\n  rewrite -logn_div ?orderXdvd // (orderXdiv p_ym) divnA // mulKn //.\n  by rewrite logn_prime ?eqxx.\nrewrite orderXdiv ?pfactor_dvdn ?leq_subr // -(dvdn_pmul2r m_gt0).\nby rewrite -expnS -subSn // subSS divnK pfactor_dvdn ?leq_subr.\nQed.",
    "Lemma abelian_type_pgroup p b G :\n    p.-group G -> \\big[dprod/1]_(x <- b) <[x]> = G -> 1 \\notin b ->\n  perm_eq (abelian_type G) (map order b).\nProof.\nrewrite perm_sym; move: b => b1 pG defG1 ntb1.\nhave cGG: abelian G.\n  elim: (b1) {pG}G defG1 => [_ <-|x b IHb G]; first by rewrite big_nil abelian1.\n  rewrite big_cons; case/dprodP=> [[_ H _ defH]] <-; rewrite defH => cxH _.\n  by rewrite abelianM cycle_abelian IHb.\nhave p_bG b: \\big[dprod/1]_(x <- b) <[x]> = G -> all (p_elt p) b.\n  elim: b {defG1 cGG}G pG => //= x b IHb G pG; rewrite big_cons.\n  case/dprodP=> [[_ H _ defH]]; rewrite defH andbC => defG _ _.\n  by rewrite -defG pgroupM in pG; case/andP: pG => p_x /IHb->.\nhave [b2 defG2 def_t] := abelian_structure cGG.\nhave ntb2: 1 \\notin b2.\n  apply: contraL (abelian_type_gt1 G) => b2_1.\n  rewrite -def_t -has_predC has_map.\n  by apply/hasP; exists 1; rewrite //= order1.\nrewrite -{}def_t; apply/allP=> m; rewrite -map_cat => /mapP[x b_x def_m].\nhave{ntb1 ntb2} ntx: x != 1.\n  by apply: contraL b_x; move/eqP->; rewrite mem_cat negb_or ntb1 ntb2.\nhave p_x: p.-elt x by apply: allP (x) b_x; rewrite all_cat !p_bG.\nrewrite -cycle_eq1 in ntx; have [p_pr _ [k ox]] := pgroup_pdiv p_x ntx.\napply/eqnP; rewrite {m}def_m orderE ox !count_map.\npose cnt_p k := count [pred x : gT | logn p #[x] > k].\nhave cnt_b b: \\big[dprod/1]_(x <- b) <[x]> = G ->\n  count [pred x | #[x] == p ^ k.+1]%N b = cnt_p k b - cnt_p k.+1 b.\n- move/p_bG; elim: b => //= _ b IHb /andP[/p_natP[j ->] /IHb-> {IHb}].\n  rewrite eqn_leq !leq_exp2l ?prime_gt1 // -eqn_leq pfactorK //.\n  case: (ltngtP k.+1) => // _ {j}; rewrite subSn // add0n.\n  by elim: b => //= y b IHb; rewrite leq_add // ltn_neqAle; case: (~~ _).\nby rewrite !cnt_b // /cnt_p !(@count_logn_dprod_cycle _ _ _ G).\nQed.",
    "Lemma size_abelian_type G : abelian G -> size (abelian_type G) = 'r(G).\nProof.\nmove=> cGG; have [b defG def_t] := abelian_structure cGG.\napply/eqP; rewrite -def_t size_map eqn_leq andbC; apply/andP; split.\n  have [p p_pr ->] := rank_witness G; rewrite p_rank_abelian //.\n  by rewrite -indexg1 -(Ohm0 G) -(count_logn_dprod_cycle _ _ defG) count_size.\ncase/lastP def_b: b => // [b' x]; pose p := pdiv #[x].\nhave p_pr: prime p.\n  have:= abelian_type_gt1 G; rewrite -def_t def_b map_rcons -cats1 all_cat.\n  by rewrite /= andbT => /andP[_]; apply: pdiv_prime.\nsuffices: all [pred y | logn p #[y] > 0] b.\n  rewrite all_count (count_logn_dprod_cycle _ _ defG) -def_b; move/eqP <-.\n  by rewrite Ohm0 indexg1 -p_rank_abelian ?p_rank_le_rank.\napply/allP=> y; rewrite def_b mem_rcons inE /= => b_y.\nrewrite lognE p_pr order_gt0 (dvdn_trans (pdiv_dvd _)) //.\ncase/predU1P: b_y => [-> // | b'_y].\nhave:= abelian_type_dvdn_sorted G; rewrite -def_t def_b.\ncase/splitPr: b'_y => b1 b2; rewrite -cat_rcons rcons_cat map_cat !map_rcons.\nrewrite headI /= cat_path -(last_cons 2) -headI last_rcons.\ncase/andP=> _ /order_path_min min_y.\napply: (allP (min_y _)) => [? ? ? ? dv|]; first exact: (dvdn_trans dv).\nby rewrite mem_rcons mem_head.\nQed.",
    "Lemma mul_card_Ohm_Mho_abelian n G :\n  abelian G -> (#|'Ohm_n(G)| * #|'Mho^n(G)|)%N = #|G|.\nProof.\ncase/abelian_structure => b defG _.\nelim: b G defG => [_ <-|x b IHb G].\n  by rewrite !big_nil (trivgP (Ohm_sub _ _)) (trivgP (Mho_sub _ _)) !cards1.\nrewrite big_cons => defG; rewrite -(dprod_card defG).\nrewrite -(dprod_card (Ohm_dprod n defG)) -(dprod_card (Mho_dprod n defG)) /=.\nrewrite mulnCA -!mulnA mulnCA mulnA; case/dprodP: defG => [[_ H _ defH] _ _ _].\nrewrite defH {b G defH IHb}(IHb H defH); congr (_ * _)%N => {H}.\nhave [m] := ubnP #[x]; elim: m x => // m IHm x /ltnSE-lexm.\ncase p_x: (p_group <[x]>); last first.\n  case: (eqVneq x 1) p_x => [-> |]; first by rewrite cycle1 p_group1.\n  rewrite -order_gt1 /p_group -orderE; set p := pdiv _ => ntx p'x.\n  have def_x: <[x.`_p]> \\x <[x.`_p^']> = <[x]>.\n    have ?: coprime #[x.`_p] #[x.`_p^'] by rewrite !order_constt coprime_partC.\n    have ?: commute x.`_p x.`_p^' by apply: commuteX2.\n    rewrite dprodE ?coprime_TIg -?cycleM ?consttC //.\n    by rewrite cent_cycle cycle_subG; apply/cent1P.\n  rewrite -(dprod_card (Ohm_dprod n def_x)) -(dprod_card (Mho_dprod n def_x)).\n  rewrite mulnCA -mulnA mulnCA mulnA.\n  rewrite !{}IHm ?(dprod_card def_x) ?(leq_trans _ lexm) {m lexm}//.\n    rewrite /order -(dprod_card def_x) -!orderE !order_constt ltn_Pmull //.\n    rewrite p_part -(expn0 p) ltn_exp2l 1?lognE ?prime_gt1 ?pdiv_prime //.\n    by rewrite order_gt0 pdiv_dvd.\n  rewrite proper_card // properEneq cycle_subG mem_cycle andbT.\n  by apply: contra (negbT p'x); move/eqP <-; apply: p_elt_constt.\ncase/p_groupP: p_x => p p_pr p_x.\nrewrite (Ohm_p_cycle n p_x) (Mho_p_cycle n p_x) -!orderE.\nset k := logn p #[x]; have ox: #[x] = (p ^ k)%N by rewrite -card_pgroup.\ncase: (leqP k n) => [le_k_n | lt_n_k].\n  rewrite -(subnKC le_k_n) subnDA subnn expg1 expnD expgM -ox.\n  by rewrite expg_order expg1n order1 muln1.\nrewrite !orderXgcd ox -[in (p ^ k)%N](subnKC (ltnW lt_n_k)) expnD.\nrewrite gcdnC gcdnMl gcdnC gcdnMr.\nby rewrite mulnK ?mulKn ?expn_gt0 ?prime_gt0.\nQed.",
    "Lemma grank_abelian G : abelian G -> 'm(G) = 'r(G).\nProof.\nmove=> cGG; apply/eqP; rewrite eqn_leq; apply/andP; split.\n  rewrite -size_abelian_type //; case/abelian_structure: cGG => b defG <-.\n  suffices <-: <<[set x in b]>> = G.\n    by rewrite (leq_trans (grank_min _)) // size_map cardsE card_size.\n  rewrite -{G defG}(bigdprodWY defG).\n  elim: b => [|x b IHb]; first by rewrite big_nil gen0.\n  by rewrite big_cons -joingE -joing_idr -IHb joing_idl joing_idr set_cons.\nhave [p p_pr ->] := rank_witness G; pose K := 'Mho^1(G).\nhave ->: 'r_p(G) = logn p #|G / K|.\n  rewrite p_rank_abelian // card_quotient /= ?gFnorm // -divgS ?Mho_sub //.\n  by rewrite -(mul_card_Ohm_Mho_abelian 1 cGG) mulnK ?cardG_gt0.\ncase: (grank_witness G) => B genB <-; rewrite -genB.\nhave{genB}: <<B>> \\subset G by rewrite genB.\nhave [m] := ubnP #|B|; elim: m B => // m IHm B.\nhave [-> | [x Bx]] := set_0Vmem B; first by rewrite gen0 quotient1 cards1 logn1.\nrewrite ltnS (cardsD1 x) Bx -[in <<B>>](setD1K Bx); set B' := B :\\ x => ltB'm.\nrewrite -joingE -joing_idl -joing_idr -/<[x]> join_subG => /andP[Gx sB'G].\nrewrite cent_joinEl ?(sub_abelian_cent2 cGG) //.\nhave nKx: x \\in 'N(K) by rewrite -cycle_subG (subset_trans Gx) ?gFnorm.\nrewrite quotientMl ?cycle_subG // quotient_cycle //= -/K.\nhave le_Kxp_1: logn p #[coset K x] <= 1.\n  rewrite -(dvdn_Pexp2l _ _ (prime_gt1 p_pr)) -p_part -order_constt.\n  rewrite order_dvdn -morph_constt // -morphX ?groupX //= coset_id //.\n  by rewrite Mho_p_elt ?p_elt_constt ?groupX -?cycle_subG.\napply: leq_trans (leq_add le_Kxp_1 (IHm _ ltB'm sB'G)).\nby rewrite -lognM ?dvdn_leq_log ?muln_gt0 ?cardG_gt0 // mul_cardG dvdn_mulr.\nQed.",
    "Lemma rank_cycle (x : gT) : 'r(<[x]>) = (x != 1).\nProof.\nhave [->|ntx] := eqVneq x 1; first by rewrite cycle1 rank1.\napply/eqP; rewrite eqn_leq rank_gt0 cycle_eq1 ntx andbT.\nby rewrite -grank_abelian ?cycle_abelian //= -(cards1 x) grank_min.\nQed.",
    "Lemma abelian_rank1_cyclic G : abelian G -> cyclic G = ('r(G) <= 1).\nProof.\nmove=> cGG; have [b defG atypG] := abelian_structure cGG.\napply/idP/idP; first by case/cyclicP=> x ->; rewrite rank_cycle leq_b1.\nrewrite -size_abelian_type // -{}atypG -{}defG unlock.\nby case: b => [|x []] //= _; rewrite ?cyclic1 // dprodg1 cycle_cyclic.\nQed.",
    "Lemma homocyclic_Ohm_Mho n p G :\n  p.-group G -> homocyclic G -> 'Ohm_n(G) = 'Mho^(logn p (exponent G) - n)(G).\nProof.\nmove=> pG /andP[cGG homoG]; set e := exponent G.\nhave{pG} p_e: p.-nat e by apply: pnat_dvd pG; apply: exponent_dvdn.\nhave{homoG}: all (pred1 e) (abelian_type G).\n  move: homoG; rewrite /abelian_type -(prednK (cardG_gt0 G)) /=.\n  by case: (_ && _) (tag _); rewrite //= genGid eqxx.\nhave{cGG} [b defG <-] := abelian_structure cGG.\nmove: e => e in p_e *; elim: b => /= [|x b IHb] in G defG *.\n  by rewrite -defG big_nil (trivgP (Ohm_sub _ _)) (trivgP (Mho_sub _ _)).\ncase/andP=> /eqP ox e_b; rewrite big_cons in defG.\nrewrite -(Ohm_dprod _ defG) -(Mho_dprod _ defG).\ncase/dprodP: defG => [[_ H _ defH] _ _ _]; rewrite defH IHb //; congr (_ \\x _).\nby rewrite -ox in p_e *; rewrite (Ohm_p_cycle _ p_e) (Mho_p_cycle _ p_e).\nQed.",
    "Lemma Ohm_Mho_homocyclic (n p : nat) G :\n    abelian G -> p.-group G -> 0 < n < logn p (exponent G) ->\n  'Ohm_n(G) = 'Mho^(logn p (exponent G) - n)(G) -> homocyclic G.\nProof.\nset e := exponent G => cGG pG /andP[n_gt0 n_lte] eq_Ohm_Mho.\nsuffices: all (pred1 e) (abelian_type G).\n  by rewrite /homocyclic cGG; apply: all_pred1_constant.\ncase/abelian_structure: cGG (abelian_type_gt1 G) => b defG <-.\nset H := G in defG eq_Ohm_Mho *; have sHG: H \\subset G by [].\nelim: b H defG sHG eq_Ohm_Mho => //= x b IHb H.\nrewrite big_cons => defG; case/dprodP: defG (defG) => [[_ K _ defK]].\nrewrite defK => defHm cxK; rewrite setIC => /trivgP-tiKx defHd.\nrewrite -{}[in H \\subset G]defHm mulG_subG cycle_subG ltnNge -trivg_card_le1.\ncase/andP=> Gx sKG; rewrite -(Mho_dprod _ defHd) => /esym defMho /andP[ntx ntb].\nhave{defHd} defOhm := Ohm_dprod n defHd.\napply/andP; split; last first.\n  apply: (IHb K) => //; have:= dprod_modr defMho (Mho_sub _ _).\n  rewrite -(dprod_modr defOhm (Ohm_sub _ _)).\n  rewrite !(trivgP (subset_trans (setIS _ _) tiKx)) ?Ohm_sub ?Mho_sub //.\n  by rewrite !dprod1g.\nhave:= dprod_modl defMho (Mho_sub _ _).\nrewrite -(dprod_modl defOhm (Ohm_sub _ _)) .\nrewrite !(trivgP (subset_trans (setSI _ _) tiKx)) ?Ohm_sub ?Mho_sub //.\nmove/eqP; rewrite eqEcard => /andP[_].\nhave p_x: p.-elt x := mem_p_elt pG Gx.\nhave [p_pr p_dv_x _] := pgroup_pdiv p_x ntx.\nrewrite !dprodg1 (Ohm_p_cycle _ p_x) (Mho_p_cycle _ p_x) -!orderE.\nrewrite orderXdiv ?leq_divLR ?pfactor_dvdn ?leq_subr //.\nrewrite orderXgcd divn_mulAC ?dvdn_gcdl // leq_divRL ?gcdn_gt0 ?order_gt0 //.\nrewrite leq_pmul2l //; apply: contraLR.\nrewrite eqn_dvd dvdn_exponent //= -ltnNge => lt_x_e.\nrewrite (leq_trans (ltn_Pmull (prime_gt1 p_pr) _)) ?expn_gt0 ?prime_gt0 //.\nrewrite -expnS dvdn_leq // ?gcdn_gt0 ?order_gt0 // dvdn_gcd.\nrewrite pfactor_dvdn // dvdn_exp2l.\n  by rewrite -[ltnRHS]subn0 ltn_sub2l // lognE p_pr order_gt0 p_dv_x.\nrewrite ltn_sub2r // ltnNge -(dvdn_Pexp2l _ _ (prime_gt1 p_pr)) -!p_part.\nby rewrite !part_pnat_id // (pnat_dvd (exponent_dvdn G)).\nQed.",
    "Lemma abelem_homocyclic p G : p.-abelem G -> homocyclic G.\nProof.\nmove=> abelG; have [_ cGG _] := and3P abelG.\nrewrite /homocyclic cGG (@all_pred1_constant _ p) //.\ncase/abelian_structure: cGG (abelian_type_gt1 G) => b defG <- => b_gt1.\napply/allP=> _ /mapP[x b_x ->] /=; rewrite (abelem_order_p abelG) //.\n  rewrite -cycle_subG -(bigdprodWY defG) ?sub_gen //.\n  by rewrite bigcup_seq (bigcup_sup x).\nby rewrite -order_gt1 [_ > 1](allP b_gt1) ?map_f.\nQed.",
    "Lemma homocyclic1 : homocyclic [1 gT].\nProof. exact: abelem_homocyclic (abelem1 _ 2). Qed.",
    "Lemma Ohm1_homocyclicP p G : p.-group G -> abelian G ->\n  reflect ('Ohm_1(G) = 'Mho^(logn p (exponent G)).-1(G)) (homocyclic G).\nProof.\nmove=> pG cGG; set e := logn p (exponent G); rewrite -subn1.\napply: (iffP idP) => [homoG | ]; first exact: homocyclic_Ohm_Mho.\ncase: (ltnP 1 e) => [lt1e | ]; first exact: Ohm_Mho_homocyclic.\nrewrite -subn_eq0 => /eqP->; rewrite Mho0 => <-.\nexact: abelem_homocyclic (Ohm1_abelem pG cGG).\nQed.",
    "Lemma abelian_type_homocyclic G :\n  homocyclic G -> abelian_type G = nseq 'r(G) (exponent G).\nProof.\ncase/andP=> cGG; rewrite -size_abelian_type // /abelian_type.\nrewrite -(prednK (cardG_gt0 G)) /=; case: andP => //= _; move: (tag _) => H.\nby move/all_pred1P->; rewrite genGid size_nseq.\nQed.",
    "Lemma abelian_type_abelem p G : p.-abelem G -> abelian_type G = nseq 'r(G) p.\nProof.\nmove=> abelG; rewrite (abelian_type_homocyclic (abelem_homocyclic abelG)).\nhave [-> | ntG] := eqVneq G 1%G; first by rewrite rank1.\ncongr nseq; apply/eqP; rewrite eqn_dvd; have [pG _ ->] := and3P abelG.\nhave [p_pr] := pgroup_pdiv pG ntG; case/Cauchy=> // x Gx <- _.\nexact: dvdn_exponent.\nQed.",
    "Lemma max_card_abelian G :\n  abelian G -> #|G| <= exponent G ^ 'r(G) ?= iff homocyclic G.\nProof.\nmove=> cGG; have [b defG def_tG] := abelian_structure cGG.\nhave Gb: all [in G] b.\n  apply/allP=> x b_x; rewrite -(bigdprodWY defG); have [b1 b2] := splitPr b_x.\n  by rewrite big_cat big_cons /= mem_gen // setUCA inE cycle_id.\nhave ->: homocyclic G = all (pred1 (exponent G)) (abelian_type G).\n  rewrite /homocyclic cGG /abelian_type; case: #|G| => //= n.\n  by move: (_ (tag _)) => t; case: ifP => //= _; rewrite genGid eqxx.\nrewrite -size_abelian_type // -{}def_tG -{defG}(bigdprod_card defG) size_map.\nrewrite unlock; elim: b Gb => //= x b IHb; case/andP=> Gx Gb.\nhave eGgt0: exponent G > 0 := exponent_gt0 G.\nhave le_x_G: #[x] <= exponent G by rewrite dvdn_leq ?dvdn_exponent.\nhave:= leqif_mul (leqif_eq le_x_G) (IHb Gb).\nby rewrite -expnS expn_eq0 eqn0Ngt eGgt0.\nQed.",
    "Lemma card_homocyclic G : homocyclic G -> #|G| = (exponent G ^ 'r(G))%N.\nProof.\nby move=> homG; have [cGG _] := andP homG; apply/eqP; rewrite max_card_abelian.\nQed.",
    "Lemma abelian_type_dprod_homocyclic p K H G :\n    K \\x H = G -> p.-group G -> homocyclic G ->\n     abelian_type K = nseq 'r(K) (exponent G)\n  /\\ abelian_type H = nseq 'r(H) (exponent G).\nProof.\nmove=> defG pG homG; have [cGG _] := andP homG.\nhave /mulG_sub[sKG sHG]: K * H = G by case/dprodP: defG.\nhave [cKK cHH] := (abelianS sKG cGG, abelianS sHG cGG).\nsuffices: all (pred1 (exponent G)) (abelian_type K ++ abelian_type H).\n  rewrite all_cat => /andP[/all_pred1P-> /all_pred1P->].\n  by rewrite !size_abelian_type.\nsuffices def_atG: abelian_type K ++ abelian_type H =i abelian_type G.\n  rewrite (eq_all_r def_atG); apply/all_pred1P.\n  by rewrite size_abelian_type // -abelian_type_homocyclic.\nhave [bK defK atK] := abelian_structure cKK.\nhave [bH defH atH] := abelian_structure cHH.\napply/perm_mem; rewrite perm_sym -atK -atH -map_cat.\napply: (abelian_type_pgroup pG); first by rewrite big_cat defK defH.\nhave: all [pred m | m > 1] (map order (bK ++ bH)).\n  by rewrite map_cat all_cat atK atH !abelian_type_gt1.\nby rewrite all_map (eq_all (@order_gt1 _)) all_predC has_pred1.\nQed.",
    "Lemma dprod_homocyclic p K H G :\n  K \\x H = G -> p.-group G -> homocyclic G -> homocyclic K /\\ homocyclic H.\nProof.\nmove=> defG pG homG; have [cGG _] := andP homG.\nhave /mulG_sub[sKG sHG]: K * H = G by case/dprodP: defG.\nhave [abtK abtH] := abelian_type_dprod_homocyclic defG pG homG.\nby rewrite /homocyclic !(abelianS _ cGG) // abtK abtH !constant_nseq.\nQed.",
    "Lemma exponent_dprod_homocyclic p K H G :\n    K \\x H = G -> p.-group G -> homocyclic G -> K :!=: 1 ->\n  exponent K = exponent G.\nProof.\nmove=> defG pG homG ntK; have [homK _] := dprod_homocyclic defG pG homG.\nhave [] := abelian_type_dprod_homocyclic defG pG homG.\nby rewrite abelian_type_homocyclic // -['r(K)]prednK ?rank_gt0 => [[]|].\nQed.",
    "Lemma isog_abelian_type G H : isog G H -> abelian_type G = abelian_type H.\nProof.\npose lnO p n gT (A : {set gT}) := logn p #|'Ohm_n.+1(A) : 'Ohm_n(A)|.\npose lni i p gT (A : {set gT}) := \\max_(e < logn p #|A| | i < lnO p e _ A) e.+1.\nsuffices{G} nth_abty gT (G : {group gT}) i:\n    abelian G -> i < size (abelian_type G) ->\n  nth 1%N (abelian_type G) i = (\\prod_(p < #|G|.+1) p ^ lni i p _ G)%N.\n- move=> isoGH; case cGG: (abelian G); last first.\n    rewrite /abelian_type -(prednK (cardG_gt0 G)) -(prednK (cardG_gt0 H)) /=.\n    by rewrite {1}(genGid G) {1}(genGid H) -(isog_abelian isoGH) cGG.\n  have cHH: abelian H by rewrite -(isog_abelian isoGH).\n  have eq_sz: size (abelian_type G) = size (abelian_type H).\n    by rewrite !size_abelian_type ?(isog_rank isoGH).\n  apply: (@eq_from_nth _ 1%N) => // i lt_i_G; rewrite !nth_abty // -?eq_sz //.\n  rewrite /lni (card_isog isoGH); apply: eq_bigr => p _; congr (p ^ _)%N.\n  apply: eq_bigl => e; rewrite /lnO -!divgS ?(Ohm_leq _ (leqnSn _)) //=.\n  by have:= card_isog (gFisog _ isoGH) => /= eqF; rewrite !eqF.\nmove=> cGG.\nhave (p): path leq 0 (map (logn p) (rev (abelian_type G))).\n  move: (abelian_type_gt1 G) (abelian_type_dvdn_sorted G).\n  case: abelian_type => //= m t; rewrite rev_cons map_rcons.\n  elim: t m => //= n t IHt m /andP[/ltnW m_gt0 nt_gt1].\n  rewrite -cats1 cat_path rev_cons map_rcons last_rcons /=.\n  by case/andP=> /dvdn_leq_log-> // /IHt->.\nhave{cGG} [b defG <- b_sorted] := abelian_structure cGG.\nrewrite size_map => ltib; rewrite (nth_map 1 _ _ ltib); set x := nth 1 b i.\nhave Gx: x \\in G.\n  have: x \\in b by rewrite mem_nth.\n  rewrite -(bigdprodWY defG); case/splitPr=> bl br.\n  by rewrite mem_gen // big_cat big_cons !inE cycle_id orbT.\nhave lexG: #[x] <= #|G| by rewrite dvdn_leq ?order_dvdG.\nrewrite -[#[x]]partn_pi // (widen_partn _ lexG) big_mkord big_mkcond.\napply: eq_bigr => p _; transitivity (p ^ logn p #[x])%N.\n  by rewrite -logn_gt0; case: posnP => // ->.\nsuffices lti_lnO e: (i < lnO p e _ G) = (e < logn p #[x]).\n  congr (p ^ _)%N; apply/eqP; rewrite eqn_leq andbC; apply/andP; split.\n    by apply/bigmax_leqP=> e; rewrite lti_lnO.\n  have [-> //|logx_gt0] := posnP (logn p #[x]).\n  have lexpG: (logn p #[x]).-1 < logn p #|G|.\n    by rewrite prednK // dvdn_leq_log ?order_dvdG.\n  by rewrite (bigmax_sup (Ordinal lexpG)) ?(prednK, lti_lnO).\nrewrite /lnO -(count_logn_dprod_cycle _ _ defG).\ncase: (ltnP e) (b_sorted p) => [lt_e_x | le_x_e].\n  rewrite -(cat_take_drop i.+1 b) -map_rev rev_cat !map_cat cat_path.\n  case/andP=> _ ordb; rewrite count_cat ((count _ _ =P i.+1) _) ?leq_addr //.\n  rewrite -{2}(size_takel ltib) -all_count.\n  move: ordb; rewrite (take_nth 1 ltib) -/x rev_rcons all_rcons /= lt_e_x.\n  case/andP=> _ /=; move/(order_path_min leq_trans); apply: contraLR.\n  rewrite -!has_predC !has_map; case/hasP=> y b_y /= le_y_e; apply/hasP.\n  by exists y; rewrite ?mem_rev //=; apply: contra le_y_e; apply: leq_trans.\nrewrite -(cat_take_drop i b) -map_rev rev_cat !map_cat cat_path.\ncase/andP=> ordb _; rewrite count_cat -{1}(size_takel (ltnW ltib)) ltnNge.\nrewrite addnC ((count _ _ =P 0) _) ?count_size //.\nrewrite eqn0Ngt -has_count; apply/hasPn=> y b_y /=; rewrite -leqNgt.\napply: leq_trans le_x_e; have ->: x = last x (rev (drop i b)).\n  by rewrite (drop_nth 1 ltib) rev_cons last_rcons.\nrewrite -mem_rev in b_y; case/splitPr: (rev _) / b_y ordb => b1 b2.\nrewrite !map_cat cat_path last_cat /=; case/and3P=> _ _.\nmove/(order_path_min leq_trans); case/lastP: b2 => // b3 x'.\nby move/allP; apply; rewrite ?map_f ?last_rcons ?mem_rcons ?mem_head.\nQed.",
    "Lemma eq_abelian_type_isog G H :\n  abelian G -> abelian H -> isog G H = (abelian_type G == abelian_type H).\nProof.\nmove=> cGG cHH; apply/idP/eqP; first exact: isog_abelian_type.\nhave{cGG} [bG defG <-] := abelian_structure cGG.\nhave{cHH} [bH defH <-] := abelian_structure cHH.\nelim: bG bH G H defG defH => [|x bG IHb] [|y bH] // G H.\n  rewrite !big_nil => <- <- _.\n  by rewrite isog_cyclic_card ?cyclic1 ?cards1.\nrewrite !big_cons => defG defH /= [eqxy eqb].\napply: (isog_dprod defG defH).\n  by rewrite isog_cyclic_card ?cycle_cyclic -?orderE ?eqxy /=.\ncase/dprodP: defG => [[_ G' _ defG]] _ _ _; rewrite defG.\ncase/dprodP: defH => [[_ H' _ defH]] _ _ _; rewrite defH.\nexact: IHb eqb.\nQed.",
    "Lemma isog_abelem_card p G H :\n  p.-abelem G -> isog G H = p.-abelem H && (#|H| == #|G|).\nProof.\nmove=> abelG; apply/idP/andP=> [isoGH | [abelH eqGH]].\n  by rewrite -(isog_abelem isoGH) (card_isog isoGH).\nrewrite eq_abelian_type_isog ?(@abelem_abelian _ p) //.\nby rewrite !(@abelian_type_abelem _ p) ?(@rank_abelem _ p) // (eqP eqGH).\nQed.",
    "Lemma morphim_rank_abelian G : abelian G -> 'r(f @* G) <= 'r(G).\nProof.\nmove=> cGG; have sHG := subsetIr D G; apply: leq_trans (rankS sHG).\nrewrite -!grank_abelian ?morphim_abelian ?(abelianS sHG) //=.\nby rewrite -morphimIdom morphim_grank ?subsetIl.\nQed.",
    "Lemma morphim_p_rank_abelian p G : abelian G -> 'r_p(f @* G) <= 'r_p(G).\nProof.\nmove=> cGG; have sHG := subsetIr D G; apply: leq_trans (p_rankS p sHG).\nhave cHH := abelianS sHG cGG; rewrite -morphimIdom /=; set H := D :&: G.\nhave sylP := nilpotent_pcore_Hall p (abelian_nil cHH).\nhave sPH := pHall_sub sylP.\nhave sPD: 'O_p(H) \\subset D by rewrite (subset_trans sPH) ?subsetIl.\nrewrite -(p_rank_Sylow (morphim_pHall f sPD sylP)) -(p_rank_Sylow sylP) //.\nrewrite -!rank_pgroup ?morphim_pgroup ?pcore_pgroup //.\nby rewrite morphim_rank_abelian ?(abelianS sPH).\nQed.",
    "Lemma isog_homocyclic G H : G \\isog H -> homocyclic G = homocyclic H.\nProof.\nmove=> isoGH.\nby rewrite /homocyclic (isog_abelian isoGH) (isog_abelian_type isoGH).\nQed.",
    "Lemma quotient_rank_abelian : 'r(G / H) <= 'r(G).\nProof. exact: morphim_rank_abelian. Qed.",
    "Lemma quotient_p_rank_abelian : 'r_p(G / H) <= 'r_p(G).\nProof. exact: morphim_p_rank_abelian. Qed.",
    "Lemma fin_lmod_pchar_abelem p (R : nzRingType) (V : finLmodType R):\n  p \\in [pchar R]%R -> p.-abelem [set: V].\nProof.\ncase/andP=> p_pr /eqP-pR0; apply/abelemP=> //.\nby split=> [|v _]; rewrite ?zmod_abelian // zmodXgE -scaler_nat pR0 scale0r.\nQed.",
    "Lemma fin_Fp_lmod_abelem p (V : finLmodType 'F_p) :\n  prime p -> p.-abelem [set: V].\nProof. by move/pchar_Fp/fin_lmod_pchar_abelem->. Qed.",
    "Lemma fin_ring_pchar_abelem p (R : finNzRingType) :\n  p \\in [pchar R]%R -> p.-abelem [set: R].\nProof. exact: fin_lmod_pchar_abelem R^o. Qed.",
    "Lemma continuous_is_iso_continuous : continuous -> iso_continuous.\nProof. by move=> Fcont gT hT G phi inj_phi; apply: Fcont. Qed.",
    "Lemma pcontinuous_is_continuous : pcontinuous -> continuous.\nProof. by move=> Fcont gT hT G; apply: Fcont. Qed.",
    "Lemma pcontinuous_is_hereditary : pcontinuous -> hereditary.\nProof.\nmove=> Fcont gT H G sHG; rewrite -{2}(setIidPl sHG) setIC.\nby do 2!rewrite -(morphim_idm (subsetIl H _)) morphimIdom ?Fcont.\nQed.",
    "Lemma gFgroupset : group_set (F gT G). Proof. by case: F. Qed.",
    "Lemma gFsub gT (G : {group gT}) : F gT G \\subset G.\nProof. by case: F gT G. Qed.",
    "Lemma gFsub_trans gT (G : {group gT}) (A : {pred gT}) :\n  G \\subset A -> F gT G \\subset A.\nProof. exact/subset_trans/gFsub. Qed.",
    "Lemma gF1 gT : F gT 1 = 1. Proof. exact/trivgP/gFsub. Qed.",
    "Lemma gFiso_cont : GFunctor.iso_continuous F.\nProof. by case F. Qed.",
    "Lemma gFchar gT (G : {group gT}) : F gT G \\char G.\nProof.\napply/andP; split => //; first by apply: gFsub.\napply/forall_inP=> f Af; rewrite -{2}(im_autm Af) -(autmE Af).\nby rewrite -morphimEsub ?gFsub ?gFiso_cont ?injm_autm.\nQed.",
    "Lemma gFnorm gT (G : {group gT}) : G \\subset 'N(F gT G).\nProof. exact/char_norm/gFchar. Qed.",
    "Lemma gFnorms gT (G : {group gT}) : 'N(G) \\subset 'N(F gT G).\nProof. exact/char_norms/gFchar. Qed.",
    "Lemma gFnormal gT (G : {group gT}) : F gT G <| G.\nProof. exact/char_normal/gFchar. Qed.",
    "Lemma gFchar_trans gT (G H : {group gT}) : H \\char G -> F gT H \\char G.\nProof. exact/char_trans/gFchar. Qed.",
    "Lemma gFnormal_trans gT (G H : {group gT}) : H <| G -> F gT H <| G.\nProof. exact/char_normal_trans/gFchar. Qed.",
    "Lemma gFnorm_trans gT (A : {pred gT}) (G : {group gT}) :\n  A \\subset 'N(G) -> A \\subset 'N(F gT G).\nProof. by move/subset_trans/(_ (gFnorms G)). Qed.",
    "Lemma injmF_sub gT rT (G D : {group gT}) (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* (F gT G) \\subset F rT (f @* G).\nProof.\nmove=> injf sGD; have:= gFiso_cont (injm_restrm sGD injf).\nby rewrite im_restrm morphim_restrm (setIidPr _) ?gFsub.\nQed.",
    "Lemma injmF gT rT (G D : {group gT}) (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* (F gT G) = F rT (f @* G).\nProof.\nmove=> injf sGD; have [sfGD injf'] := (morphimS f sGD, injm_invm injf).\napply/esym/eqP; rewrite eqEsubset -(injmSK injf') ?gFsub_trans //.\nby rewrite !(subset_trans (injmF_sub _ _)) ?morphim_invm // gFsub_trans.\nQed.",
    "Lemma gFisom gT rT (G D : {group gT}) R (f : {morphism D >-> rT}) :\n  G \\subset D -> isom G (gval R) f -> isom (F gT G) (F rT R) f.\nProof.\ncase/(restrmP f)=> g [gf _ _ _]; rewrite -{f}gf => /isomP[injg <-].\nby rewrite sub_isom ?gFsub ?injmF.\nQed.",
    "Lemma gFisog gT rT (G : {group gT}) (R : {group rT}) :\n  G \\isog R -> F gT G \\isog F rT R.\nProof. by case/isogP=> f injf <-; rewrite -injmF // sub_isog ?gFsub. Qed.",
    "Lemma gFcont : GFunctor.continuous F.\nProof. by case F. Qed.",
    "Lemma morphimF gT rT (G D : {group gT}) (f : {morphism D >-> rT}) :\n  G \\subset D -> f @* (F gT G) \\subset F rT (f @* G).\nProof.\nmove=> sGD; rewrite -(setIidPr (gFsub F G)).\nby rewrite -{3}(setIid G) -!(morphim_restrm sGD) gFcont.\nQed.",
    "Lemma gFhereditary : GFunctor.hereditary F.\nProof. by case F. Qed.",
    "Lemma gFunctorI gT (G H : {group gT}) :\n  F gT G :&: H = F gT G :&: F gT (G :&: H).\nProof.\nrewrite -{1}(setIidPr (gFsub F G)) setIAC setIC.\nrewrite -(setIidPr (gFhereditary (subsetIl G H))).\nby rewrite setIC -setIA (setIidPr (gFsub F (G :&: H))).\nQed.",
    "Lemma pmorphimF : GFunctor.pcontinuous F.\nProof.\nmove=> gT rT G D f; rewrite -morphimIdom -(setIidPl (gFsub F G)) setICA.\napply: (subset_trans (morphimS f (gFhereditary (subsetIr D G)))).\nby rewrite (subset_trans (morphimF F _ _ )) ?morphimIdom ?subsetIl.\nQed.",
    "Lemma gFid gT (G : {group gT}) : F gT (F gT G)  = F gT G.\nProof.\napply/eqP; rewrite eqEsubset gFsub.\nby move/gFhereditary: (gFsub F G); rewrite setIid /=.\nQed.",
    "Lemma gFmod_closed : GFunctor.closed (F1 %% F2).\nProof. by move=> gT G; rewrite sub_cosetpre_quo ?gFsub ?gFnormal. Qed.",
    "Lemma gFmod_cont : GFunctor.continuous (F1 %% F2).\nProof.\nmove=> gT rT G f; have nF2 := gFnorm F2.\nhave sDF: G \\subset 'dom (coset (F2 _ G)) by rewrite nF2.\nhave sDFf: G \\subset 'dom (coset (F2 _ (f @* G)) \\o f).\n  by rewrite -sub_morphim_pre ?subsetIl // nF2.\npose K := 'ker (restrm sDFf (coset (F2 _ (f @* G)) \\o f)).\nhave sFK: 'ker (restrm sDF (coset (F2 _ G))) \\subset K.\n  rewrite {}/K !ker_restrm ker_comp /= subsetI subsetIl !ker_coset /=.\n  by rewrite -sub_morphim_pre ?subsetIl // morphimIdom ?morphimF.\nhave sOF := gFsub F1 (G / F2 _ G); have sGG: G \\subset G by [].\nrewrite -sub_quotient_pre; last first.\n  by apply: subset_trans (nF2 _ _); rewrite morphimS ?gFmod_closed.\nsuffices im_fact H : F2 _ G \\subset gval H -> H \\subset G ->\n  factm sFK sGG @* (H / F2 _ G) = f @* H / F2 _ (f @* G).\n- rewrite -2?im_fact ?gFmod_closed ?gFsub //.\n    by rewrite cosetpreK morphimF /= ?morphim_restrm ?setIid.\n  by rewrite -sub_quotient_pre ?normG //= trivg_quotient sub1G.\nmove=> sFH sHG; rewrite -(morphimIdom _ (H / _)) /= {2}morphim_restrm setIid.\nrewrite -morphimIG ?ker_coset // -(morphim_restrm sDF) morphim_factm.\nby rewrite morphim_restrm morphim_comp -quotientE morphimIdom.\nQed.",
    "Lemma gFmod_hereditary : GFunctor.hereditary (F1 %% F2).\nProof.\nmove=> gT H G sHG; set FGH := _ :&: H; have nF2H := gFnorm F2 H.\nrewrite -sub_quotient_pre; last exact: subset_trans (subsetIr _ _) _.\npose rH := restrm nF2H (coset (F2 _ H)); pose rHM := [morphism of rH].\nhave rnorm_simpl: rHM @* H = H / F2 _ H by rewrite morphim_restrm setIid.\nhave nF2G := subset_trans sHG (gFnorm F2 G).\npose rG := restrm nF2G (coset (F2 _ G)); pose rGM := [morphism of rG].\nhave sqKfK: 'ker rGM \\subset 'ker rHM.\n  rewrite !ker_restrm !ker_coset (setIidPr (gFsub F2 _)) setIC /=.\n  exact: gFhereditary.\nhave sHH := subxx H; rewrite -rnorm_simpl /= -(morphim_factm sqKfK sHH) /=.\napply: subset_trans (gFcont F1 _); rewrite /= {2}morphim_restrm setIid /=.\napply: subset_trans (morphimS _ (gFhereditary _ (quotientS _ sHG))) => /=.\nhave ->: FGH / _ = restrm nF2H (coset _) @* FGH.\n  by rewrite morphim_restrm setICA setIid.\nrewrite -(morphim_factm sqKfK sHH) morphimS //= morphim_restrm -quotientE.\nby rewrite setICA setIid (subset_trans (quotientI _ _ _)) // cosetpreK.\nQed.",
    "Lemma gFunctorS (F : GFunctor.mono_map) : GFunctor.monotonic F.\nProof. by case: F. Qed.",
    "Lemma gFcomp_closed : GFunctor.closed (F1 \\o F2).\nProof. by move=> gT G; rewrite !gFsub_trans. Qed.",
    "Lemma gFcomp_cont : GFunctor.continuous (F1 \\o F2).\nProof.\nmove=> gT rT G phi; rewrite (subset_trans (morphimF _ _ (gFsub _ _))) //.\nby rewrite (subset_trans (gFunctorS F1 (gFcont F2 phi))).\nQed.",
    "Lemma gFcompS : GFunctor.monotonic (F1 \\o F2).\nProof. by move=> gT H G sHG; rewrite !gFunctorS. Qed.",
    "Lemma idGfun_closed : GFunctor.closed idGfun. Proof. by []. Qed.",
    "Lemma idGfun_cont : GFunctor.continuous idGfun. Proof. by []. Qed.",
    "Lemma idGfun_monotonic : GFunctor.monotonic idGfun. Proof. by []. Qed.",
    "Lemma trivGfun_cont : GFunctor.pcontinuous trivGfun.\nProof. by move=> gT rT D G f; rewrite morphim1. Qed.",
    "Lemma Alt_even p : (p \\in 'Alt_T) = ~~ p.\nProof. by rewrite !inE /=; case: odd_perm. Qed.",
    "Lemma Alt_subset : 'Alt_T \\subset 'Sym_T.\nProof. exact: subsetT. Qed.",
    "Lemma Alt_normal : 'Alt_T <| 'Sym_T.\nProof. exact: ker_normal. Qed.",
    "Lemma Alt_norm : 'Sym_T \\subset 'N('Alt_T).\nProof. by case/andP: Alt_normal. Qed.",
    "Lemma Alt_index : 1 < n -> #|'Sym_T : 'Alt_T| = 2.\nProof.\nmove=> lt1n; rewrite -card_quotient ?Alt_norm //=.\nhave : ('Sym_T / 'Alt_T) \\isog (@odd_perm T @* 'Sym_T) by apply: first_isog.\ncase/isogP=> g /injmP/card_in_imset <-.\nrewrite /morphim setIid=> ->; rewrite -card_bool; apply: eq_card => b.\napply/imsetP; case: b => /=; last first.\n  by exists (1 : {perm T}); [rewrite setIid inE | rewrite odd_perm1].\ncase: (pickP T) lt1n => [x1 _ | d0]; last by rewrite /n eq_card0.\nrewrite /n (cardD1 x1) ltnS lt0n => /existsP[x2 /=].\nby rewrite eq_sym andbT -odd_tperm; exists (tperm x1 x2); rewrite ?inE.\nQed.",
    "Lemma card_Sym : #|'Sym_T| = n`!.\nProof.\nrewrite -[n]cardsE -card_perm; apply: eq_card => p.\nby apply/idP/subsetP=> [? ?|]; rewrite !inE.\nQed.",
    "Lemma card_Alt : 1 < n -> (2 * #|'Alt_T|)%N = n`!.\nProof.\nby move/Alt_index <-; rewrite mulnC (Lagrange Alt_subset) card_Sym.\nQed.",
    "Lemma Sym_trans : [transitive^n 'Sym_T, on setT | 'P].\nProof.\napply/imsetP; pose t1 := [tuple of enum T].\nhave dt1: t1 \\in n.-dtuple(setT) by rewrite inE enum_uniq; apply/subsetP.\nexists t1 => //; apply/setP=> t; apply/idP/imsetP=> [|[a _ ->{t}]]; last first.\n  by apply: n_act_dtuple => //; apply/astabsP=> x; rewrite !inE.\ncase/dtuple_onP=> injt _; have injf := inj_comp injt enum_rank_inj.\nexists (perm injf); first by rewrite inE.\napply: eq_from_tnth => i; rewrite tnth_map /= [aperm _ _]permE; congr tnth.\nby rewrite (tnth_nth (enum_default i)) enum_valK.\nQed.",
    "Lemma Alt_trans : [transitive^n.-2 'Alt_T, on setT | 'P].\nProof.\ncase n_m2: n Sym_trans => [|[|m]] /= tr_m2; try exact: ntransitive0.\nhave tr_m := ntransitive_weak (leqW (leqnSn m)) tr_m2.\ncase/imsetP: tr_m2; case/tupleP=> x; case/tupleP=> y t.\nrewrite !dtuple_on_add 2![x \\in _]inE inE negb_or /= -!andbA.\ncase/and4P=> nxy ntx nty dt _; apply/imsetP; exists t => //; apply/setP=> u.\napply/idP/imsetP=> [|[a _ ->{u}]]; last first.\n  by apply: n_act_dtuple => //; apply/astabsP=> z; rewrite !inE.\ncase/(atransP2 tr_m dt)=> /= a _ ->{u}.\ncase odd_a: (odd_perm a); last by exists a => //; rewrite !inE /= odd_a.\nexists (tperm x y * a); first by rewrite !inE /= odd_permM odd_tperm nxy odd_a.\napply/val_inj/eq_in_map => z tz; rewrite actM /= /aperm; congr (a _).\nby case: tpermP ntx nty => // <-; rewrite tz.\nQed.",
    "Lemma aperm_faithful (A : {group {perm T}}) : [faithful A, on setT | 'P].\nProof.\nby apply/faithfulP=> /= p _ np1; apply/eqP/perm_act1P=> y; rewrite np1 ?inE.\nQed.",
    "Lemma trivial_Alt_2 (T : finType) : #|T| <= 2 -> 'Alt_T = 1.\nProof.\nrewrite leq_eqVlt => /predU1P[] oT.\n  by apply: card_le1_trivg; rewrite -leq_double -mul2n card_Alt oT.\nsuffices Sym1: 'Sym_T = 1 by apply/trivgP; rewrite -Sym1 subsetT.\nby apply: card1_trivg; rewrite card_Sym; case: #|T| oT; do 2?case.\nQed.",
    "Lemma simple_Alt_3 (T : finType) : #|T| = 3 -> simple 'Alt_T.\nProof.\nmove=> T3; have{T3} oA: #|'Alt_T| = 3.\n  by apply: double_inj; rewrite -mul2n card_Alt T3.\napply/simpleP; split=> [|K]; [by rewrite trivg_card1 oA | case/andP=> sKH _].\nhave:= cardSg sKH; rewrite oA dvdn_divisors // !inE orbC /= -oA.\ncase/pred2P=> eqK; [right | left]; apply/eqP.\n  by rewrite eqEcard sKH eqK leqnn.\nby rewrite eq_sym eqEcard sub1G eqK cards1.\nQed.",
    "Lemma not_simple_Alt_4 (T : finType) : #|T| = 4 -> ~~ simple 'Alt_T.\nProof.\nmove=> oT; set A := 'Alt_T.\nhave oA: #|A| = 12 by apply: double_inj; rewrite -mul2n card_Alt oT.\nsuffices [p]: exists p, [/\\ prime p, 1 < #|A|`_p < #|A| & #|'Syl_p(A)| == 1%N].\n  case=> p_pr pA_int; rewrite /A; case/normal_sylowP=> P; case/pHallP.\n  rewrite /= -/A => sPA pP nPA; apply/simpleP=> [] [_]; rewrite -pP in pA_int.\n  by case/(_ P)=> // defP; rewrite defP oA ?cards1 in pA_int.\nhave: #|'Syl_3(A)| \\in filter [pred d | d %% 3 == 1%N] (divisors 12).\n  by rewrite mem_filter -dvdn_divisors //= -oA card_Syl_dvd ?card_Syl_mod.\nrewrite /= oA mem_seq2 orbC.\ncase/predU1P=> [oQ3|]; [exists 2 | exists 3]; split; rewrite ?p_part //.\npose A3 := [set x : {perm T} | #[x] == 3]; suffices oA3: #|A :&: A3| = 8.\n  have sQ2 P: P \\in 'Syl_2(A) -> P :=: A :\\: A3.\n    rewrite inE pHallE oA p_part -natTrecE /= => /andP[sPA /eqP oP].\n    apply/eqP; rewrite eqEcard -(leq_add2l 8) -{1}oA3 cardsID oA oP.\n    rewrite andbT subsetD sPA; apply/exists_inP=> -[x] /= Px.\n    by rewrite inE => /eqP ox; have:= order_dvdG Px; rewrite oP ox.\n  have [/= P sylP] := Sylow_exists 2 [group of A].\n  rewrite -(([set P] =P 'Syl_2(A)) _) ?cards1 // eqEsubset sub1set inE sylP.\n  by apply/subsetP=> Q sylQ; rewrite inE -val_eqE /= !sQ2 // inE.\nrewrite -[8]/(4 * 2)%N -{}oQ3 -sum1_card -sum_nat_const.\nrewrite (partition_big (fun x => <[x]>%G) [in 'Syl_3(A)]) => [|x]; last first.\n  by case/setIP=> Ax; rewrite /= !inE pHallE p_part cycle_subG Ax oA.\napply: eq_bigr => Q; rewrite inE pHallE oA p_part -?natTrecE //=.\ncase/andP=> sQA /eqP oQ; have:= oQ.\nrewrite (cardsD1 1) group1 -sum1_card => [[/= <-]]; apply: eq_bigl => x.\nrewrite setIC -val_eqE /= 2!inE in_setD1 -andbA -{4}[x]expg1 -order_dvdn dvdn1.\napply/and3P/andP=> [[/eqP-> _ /eqP <-] | [ntx Qx]]; first by rewrite cycle_id.\nhave:= order_dvdG Qx; rewrite oQ dvdn_divisors // mem_seq2 (negPf ntx) /=.\nby rewrite eqEcard cycle_subG Qx (subsetP sQA) // oQ /order => /eqP->.\nQed.",
    "Lemma simple_Alt5_base (T : finType) : #|T| = 5 -> simple 'Alt_T.\nProof.\nmove=> oT.\nhave F1: #|'Alt_T| = 60 by apply: double_inj; rewrite -mul2n card_Alt oT.\nhave FF (H : {group {perm T}}): H <| 'Alt_T -> H :<>: 1 -> 20 %| #|H|.\n- move=> Hh1 Hh3.\n  have [x _]: exists x, x \\in T by apply/existsP/eqP; rewrite oT.\n  have F2 := Alt_trans T; rewrite oT /= in F2.\n  have F3: [transitive 'Alt_T, on setT | 'P] by apply: ntransitive1 F2.\n  have F4: [primitive 'Alt_T, on setT | 'P] by apply: ntransitive_primitive F2.\n  case: (prim_trans_norm F4 Hh1) => F5.\n    by case: Hh3; apply/trivgP; apply: subset_trans F5 (aperm_faithful _).\n  have F6: 5 %| #|H| by rewrite -oT -cardsT (atrans_dvd F5).\n  have F7: 4 %| #|H|.\n    have F7: #|[set~ x]| = 4 by rewrite cardsC1 oT.\n    case: (pickP [in [set~ x]]) => [y Hy | ?]; last by rewrite eq_card0 in F7.\n    pose K := 'C_H[x | 'P]%G.\n    have F8 : K \\subset H by apply: subsetIl.\n    pose Gx := 'C_('Alt_T)[x | 'P]%G.\n    have F9: [transitive^2 Gx, on [set~ x] | 'P].\n      by rewrite -[[set~ x]]setTI -setDE stab_ntransitive ?inE.\n    have F10: [transitive Gx, on [set~ x] | 'P].\n      exact: ntransitive1 F9.\n    have F11: [primitive Gx, on [set~ x] | 'P].\n      exact: ntransitive_primitive F9.\n    have F12: K \\subset Gx by apply: setSI; apply: normal_sub.\n    have F13: K <| Gx by rewrite /(K <| _) F12 normsIG // normal_norm.\n    case: (prim_trans_norm F11 F13) => Ksub; last first.\n      by apply: dvdn_trans (cardSg F8); rewrite -F7; apply: atrans_dvd Ksub.\n    have F14: [faithful Gx, on [set~ x] | 'P].\n      apply/subsetP=> g; do 2![case/setIP] => Altg cgx cgx'.\n      apply: (subsetP (aperm_faithful 'Alt_T)).\n      rewrite inE Altg /=; apply/astabP=> z _.\n      case: (z =P x) => [->|]; first exact: (astab1P cgx).\n      by move/eqP=> nxz; rewrite (astabP cgx') ?inE //.\n    have Hreg g (z : T): g \\in H -> g z = z -> g = 1.\n      have F15 h: h \\in H -> h x = x -> h = 1.\n        move=> Hh Hhx; have: h \\in K by rewrite inE Hh; apply/astab1P.\n        by rewrite (trivGP (subset_trans Ksub F14)) => /set1P.\n      move=> Hg Hgz; have:= in_setT x; rewrite -(atransP F3 z) ?inE //.\n      case/imsetP=> g1 Hg1 Hg2; apply: (conjg_inj g1); rewrite conj1g.\n      apply: F15; last by rewrite Hg2 -permM mulKVg permM Hgz.\n      by case/normalP: Hh1 => _ nH1; rewrite -(nH1 _ Hg1) memJ_conjg.\n    clear K F8 F12 F13 Ksub F14.\n    case: (Cauchy _ F6) => // h Hh /eqP Horder.\n    have diff_hnx_x n: 0 < n -> n < 5 -> x != (h ^+ n) x.\n      move=> Hn1 Hn2; rewrite eq_sym; apply/negP => HH.\n      have: #[h ^+ n] = 5.\n        rewrite orderXgcd // (eqP Horder).\n        by move: Hn1 Hn2 {HH}; do 5 (case: n => [|n] //).\n      have Hhd2: h ^+ n \\in H by rewrite groupX.\n      by rewrite (Hreg _ _ Hhd2 (eqP HH)) order1.\n    pose S1 := [tuple x; h x; (h ^+ 3) x].\n    have DnS1: S1 \\in 3.-dtuple(setT).\n      rewrite inE memtE subset_all /= !inE /= !negb_or -!andbA /= andbT.\n      rewrite -{1}[h]expg1 !diff_hnx_x // expgSr permM.\n      by rewrite (inj_eq perm_inj) diff_hnx_x.\n    pose S2 := [tuple x; h x; (h ^+ 2) x].\n    have DnS2:  S2 \\in 3.-dtuple(setT).\n      rewrite inE memtE subset_all /= !inE /= !negb_or -!andbA /= andbT.\n      rewrite -{1}[h]expg1 !diff_hnx_x // expgSr permM.\n      by rewrite (inj_eq perm_inj) diff_hnx_x.\n    case: (atransP2 F2 DnS1 DnS2) => g Hg [/=].\n    rewrite /aperm => Hgx Hghx Hgh3x.\n    have h_g_com: h * g = g * h.\n      suff HH: (g * h * g^-1) * h^-1 = 1 by rewrite -[h * g]mul1g -HH !gnorm.\n      apply: (Hreg _ x); last first.\n        by rewrite !permM -Hgx Hghx -!permM mulKVg mulgV perm1.\n      rewrite groupM // ?groupV // (conjgCV g) mulgK -mem_conjg.\n      by case/normalP: Hh1 => _ ->.\n    have: (g * (h ^+ 2) * g ^-1) x = (h ^+ 3) x.\n      rewrite !permM -Hgx.\n      have ->: h (h x) = (h ^+ 2) x by rewrite /= permM.\n      by rewrite {1}Hgh3x -!permM /= mulgV mulg1 -expgSr.\n    rewrite commuteX // mulgK {1}[expgn]lock expgS permM -lock.\n    by move/perm_inj=> eqxhx; case/eqP: (diff_hnx_x 1%N isT isT); rewrite expg1.\n  by rewrite (@Gauss_dvd 4 5) // F7.\napply/simpleP; split => [|H Hnorm]; first by rewrite trivg_card1 F1.\ncase Hcard1: (#|H| == 1%N); move/eqP: Hcard1 => Hcard1.\n  by left; apply: card1_trivg; rewrite Hcard1.\nright; case Hcard60: (#|H| == 60); move/eqP: Hcard60 => Hcard60.\n  by apply/eqP; rewrite eqEcard Hcard60 F1 andbT; case/andP: Hnorm.\nhave {Hcard1 Hcard60} Hcard20: #|H| = 20.\n  have Hdiv: 20 %| #|H| by apply: FF => // HH; case Hcard1; rewrite HH cards1.\n  case H20: (#|H| == 20); first exact/eqP.\n  case: Hcard60; case/andP: Hnorm; move/cardSg; rewrite F1 => Hdiv1 _.\n  by case/dvdnP: Hdiv H20 Hdiv1 => n ->; move: n; do 4!case=> //.\nhave prime_5: prime 5 by [].\nhave nSyl5: #|'Syl_5(H)| = 1%N.\n  move: (card_Syl_dvd 5 H) (card_Syl_mod H prime_5).\n  rewrite Hcard20; case: (card _) => // n Hdiv.\n  move: (dvdn_leq  (isT: (0 < 20)%N) Hdiv).\n  by move: (n) Hdiv; do 20 (case=> //).\ncase: (Sylow_exists 5 H) => S; case/pHallP=> sSH oS.\nhave{} oS: #|S| = 5 by rewrite oS p_part Hcard20.\nsuff: 20 %| #|S| by rewrite oS.\napply: FF => [|S1]; last by rewrite S1 cards1 in oS.\napply: char_normal_trans Hnorm; apply: lone_subgroup_char => // Q sQH isoQS.\nrewrite subEproper; apply/norP=> [[nQS _]]; move: nSyl5.\nrewrite (cardsD1 S) (cardsD1 Q) 4!{1}inE nQS !pHallE sQH sSH Hcard20 p_part.\nby rewrite (card_isog isoQS) oS.\nQed.",
    "Lemma rfd_funP (p : {perm T}) (u : T') :\n  let p1 := if p x == x then p else 1 in p1 (val u) != x.\nProof.\ncase: (p x =P x) => /= [pxx | _]; last by rewrite perm1 (valP u).\nby rewrite -[x in _ != x]pxx (inj_eq perm_inj); apply: (valP u).\nQed.",
    "Lemma rfdP p : injective (rfd_fun p).\nProof.\napply: can_inj (rfd_fun p^-1) _ => u; apply: val_inj => /=.\nrewrite -(can_eq (permK p)) permKV eq_sym.\nby case: eqP => _; rewrite !(perm1, permK).\nQed.",
    "Lemma rfd_morph : {in 'C_('Sym_T)[x | 'P] &, {morph rfd : y z / y * z}}.\nProof.\nmove=> p q; rewrite !setIA !setIid; move/astab1P=> p_x; move/astab1P=> q_x.\napply/permP=> u; apply: val_inj.\nby rewrite permE /= !permM !permE /= [p x]p_x [q x]q_x eqxx permM /=.\nQed.",
    "Lemma rgdP p : injective (rgd_fun p).\nProof.\napply: can_inj (rgd_fun p^-1) _ => y /=.\ncase: (insubP _ y) => [u _ val_u|]; first by rewrite valK permK.\nby rewrite negbK; move/eqP->; rewrite insubF //= eqxx.\nQed.",
    "Lemma rfd_odd (p : {perm T}) : p x = x -> rfd p = p :> bool.\nProof.\nhave rfd1: rfd 1 = 1.\n  by apply/permP => u; apply: val_inj; rewrite permE /= if_same !perm1.\nhave [n] := ubnP #|[set x | p x != x]|; elim: n p => // n IHn p le_p_n px_x.\nhave [p_id | [x1 Hx1]] := set_0Vmem [set x | p x != x].\n  suffices ->: p = 1 by rewrite rfd1 !odd_perm1.\n  by apply/permP => z; apply: contraFeq (in_set0 z); rewrite perm1 -p_id inE.\nhave nx1x: x1 != x by apply: contraTneq Hx1 => ->; rewrite inE px_x eqxx.\nhave npxx1: p x != x1 by apply: contraNneq nx1x => <-; rewrite px_x.\nhave npx1x: p x1 != x by rewrite -px_x (inj_eq perm_inj).\npose p1 := p * tperm x1 (p x1).\nhave fix_p1 y: p y = y -> p1 y = y.\n  by move=> pyy; rewrite permM; have [<-|/perm_inj<-|] := tpermP; rewrite ?pyy.\nhave p1x_x: p1 x = x by apply: fix_p1.\nhave{le_p_n} lt_p1_n: #|[set x | p1 x != x]| < n.\n  move: le_p_n; rewrite ltnS (cardsD1 x1) Hx1; apply/leq_trans/subset_leq_card.\n  rewrite subsetD1 inE permM tpermR eqxx andbT.\n  by apply/subsetP=> y /[!inE]; apply: contraNneq=> /fix_p1->.\ntransitivity (p1 (+) true); last first.\n  by rewrite odd_permM odd_tperm -Hx1 inE eq_sym addbK.\nhave ->: p = p1 * tperm x1 (p x1) by rewrite -tpermV mulgK.\nrewrite morphM; last 2 first; first by rewrite 2!inE; apply/astab1P.\n  by rewrite 2!inE; apply/astab1P; rewrite -[RHS]p1x_x permM px_x.\nrewrite odd_permM IHn //=; congr (_ (+) _).\npose x2 : T' := Sub x1 nx1x; pose px2 : T' := Sub (p x1) npx1x.\nsuffices ->: rfd (tperm x1 (p x1)) = tperm x2 px2.\n  by rewrite odd_tperm eq_sym; rewrite inE in Hx1.\napply/permP => z; apply/val_eqP; rewrite permE /= tpermD // eqxx.\nby rewrite !permE /= -!val_eqE /= !(fun_if sval) /=.\nQed.",
    "Lemma rfd_iso : 'C_('Alt_T)[x | 'P] \\isog 'Alt_T'.\nProof.\nhave rgd_x p: rgd p x = x by rewrite permE /= insubF //= eqxx.\nhave rfd_rgd p: rfd (rgd p) = p.\n  apply/permP => [[z Hz]]; apply/val_eqP; rewrite !permE.\n  by rewrite /= [rgd _ _]permE /= insubF eqxx // permE /= insubT.\nhave sSd: 'C_('Alt_T)[x | 'P] \\subset 'dom rfd.\n  by apply/subsetP=> p /[!inE]/= /andP[].\napply/isogP; exists [morphism of restrm sSd rfd] => /=; last first.\n  rewrite morphim_restrm setIid; apply/setP=> z; apply/morphimP/idP=> [[p _]|].\n    case/setIP; rewrite Alt_even => Hp; move/astab1P=> Hp1 ->.\n    by rewrite Alt_even rfd_odd.\n  have dz': rgd z x == x by rewrite rgd_x.\n  move=> kz; exists (rgd z); last by rewrite /= rfd_rgd.\n    by rewrite 2!inE (sameP astab1P eqP).\n  rewrite 4!inE /= (sameP astab1P eqP) dz' -rfd_odd; last exact/eqP.\n  by rewrite rfd_rgd mker // ?set11.\napply/injmP=> x1 y1 /=.\ncase/setIP=> Hax1; move/astab1P; rewrite /= /aperm => Hx1.\ncase/setIP=> Hay1; move/astab1P; rewrite /= /aperm => Hy1 Hr.\napply/permP => z.\ncase (z =P x) => [->|]; [by rewrite Hx1 | move/eqP => nzx].\nmove: (congr1 (fun q : {perm T'} => q (Sub z nzx)) Hr).\nby rewrite !permE => [[]]; rewrite Hx1 Hy1 !eqxx.\nQed.",
    "Lemma simple_Alt5 (T : finType) : #|T| >= 5 -> simple 'Alt_T.\nProof.\nsuff F1 n: #|T| = n + 5 -> simple 'Alt_T by move/subnK/esym/F1.\nelim: n T => [| n Hrec T Hde]; first exact: simple_Alt5_base.\nhave oT: 5 < #|T| by rewrite Hde addnC.\napply/simpleP; split=> [|H Hnorm]; last have [Hh1 nH] := andP Hnorm.\n  rewrite trivg_card1 -[#|_|]half_double -mul2n card_Alt Hde addnC //.\n  by rewrite addSn factS mulnC -(prednK (fact_gt0 _)).\ncase E1: (pred0b T); first by rewrite /pred0b in E1; rewrite (eqP E1) in oT.\ncase/pred0Pn: E1 => x _; have Hx := in_setT x.\nhave F2: [transitive^4 'Alt_T, on setT | 'P].\n  by apply: ntransitive_weak (Alt_trans T); rewrite -(subnKC oT).\nhave F3 := ntransitive1 (isT: 0 < 4) F2.\nhave F4 := ntransitive_primitive (isT: 1 < 4) F2.\ncase Hcard1: (#|H| == 1%N); move/eqP: Hcard1 => Hcard1.\n  by left; apply: card1_trivg; rewrite Hcard1.\nright; case: (prim_trans_norm F4 Hnorm) => F5.\n  by rewrite (trivGP (subset_trans F5 (aperm_faithful _))) cards1 in Hcard1.\ncase E1: (pred0b (predD1 T x)).\n  rewrite /pred0b in E1; move: oT.\n  by rewrite (cardD1 x) (eqP E1); case: (T x).\ncase/pred0Pn: E1 => y Hdy; case/andP: (Hdy) => diff_x_y Hy.\npose K := 'C_H[x | 'P]%G.\nhave F8: K \\subset H by apply: subsetIl.\npose Gx := 'C_('Alt_T)[x | 'P].\nhave F9: [transitive^3 Gx, on [set~ x] | 'P].\n  by rewrite -[[set~ x]]setTI -setDE stab_ntransitive ?inE.\nhave F10: [transitive Gx, on [set~ x] | 'P].\n  by apply: ntransitive1 F9.\nhave F11: [primitive Gx, on [set~ x] | 'P].\n  by apply: ntransitive_primitive F9.\nhave F12: K \\subset Gx by rewrite setSI // normal_sub.\nhave F13: K <| Gx by apply/andP; rewrite normsIG.\nhave:= prim_trans_norm F11; case/(_ K) => //= => Ksub; last first.\n  have F14: Gx * H = 'Alt_T by apply/(subgroup_transitiveP _ _ F3).\n  have: simple Gx.\n    by rewrite (isog_simple (rfd_iso x)) Hrec //= card_sig cardC1 Hde.\n  case/simpleP=> _ simGx; case/simGx: F13 => /= HH2.\n    case Ez: (pred0b (predD1 (predD1 T x) y)).\n      move: oT; rewrite /pred0b in Ez.\n      by rewrite (cardD1 x) (cardD1 y) (eqP Ez) inE /= inE /= diff_x_y.\n    case/pred0Pn: Ez => z; case/andP => diff_y_z Hdz.\n    have [diff_x_z Hz] := andP Hdz.\n    have: z \\in [set~ x] by rewrite !inE.\n    rewrite -(atransP Ksub y) ?inE //; case/imsetP => g.\n    rewrite /= HH2 inE; move/eqP=> -> HH4.\n    by case/negP: diff_y_z; rewrite HH4 act1.\n  by rewrite /= -F14 -[Gx]HH2 (mulSGid F8).\nhave F14: [faithful Gx, on [set~ x] | 'P].\n  apply: subset_trans (aperm_faithful 'Sym_T); rewrite subsetI subsetT.\n  apply/subsetP=> g; do 2![case/setIP]=> _ cgx cgx'; apply/astabP=> z _ /=.\n  case: (z =P x) => [->|]; first exact: (astab1P cgx).\n  by move/eqP=> zx; rewrite [_ g](astabP cgx') ?inE.\nhave Hreg g z: g \\in H -> g z = z -> g = 1.\n  have F15 h: h \\in H -> h x = x -> h = 1.\n    move=> Hh Hhx; have: h \\in K by rewrite inE Hh; apply/astab1P.\n    by rewrite [K](trivGP (subset_trans Ksub F14)) => /set1P.\n  move=> Hg Hgz; have:= in_setT x; rewrite -(atransP F3 z) ?inE //.\n  case/imsetP=> g1 Hg1 Hg2; apply: (conjg_inj g1); rewrite conj1g.\n  apply: F15; last by rewrite Hg2 -permM mulKVg permM Hgz.\n  by rewrite memJ_norm ?(subsetP nH).\nclear K F8 F12 F13 Ksub F14.\nhave Hcard: 5 < #|H|.\n  apply: (leq_trans oT); apply: dvdn_leq; first exact: cardG_gt0.\n  by rewrite -cardsT (atrans_dvd F5).\ncase Eh: (pred0b [predD1 H & 1]).\n  by move: Hcard; rewrite /pred0b in Eh; rewrite (cardD1 1) group1 (eqP Eh).\ncase/pred0Pn: Eh => h; case/andP => diff_1_h /= Hh.\ncase Eg: (pred0b (predD1 (predD1 [predD1 H & 1] h) h^-1)).\n  move: Hcard; rewrite ltnNge; case/negP.\n  rewrite (cardD1 1) group1 (cardD1 h) (cardD1 h^-1) (eqnP Eg).\n  by do 2!case: (_ \\in _).\ncase/pred0Pn: Eg => g; case/andP => diff_h1_g; case/andP => diff_h_g.\ncase/andP => diff_1_g /= Hg.\ncase diff_hx_x: (h x == x).\nby case/negP: diff_1_h; apply/eqP; apply: (Hreg _ _ Hh (eqP diff_hx_x)).\ncase diff_gx_x: (g x == x).\n  case/negP: diff_1_g; apply/eqP; apply: (Hreg _ _ Hg (eqP diff_gx_x)).\ncase diff_gx_hx: (g x == h x).\n  case/negP: diff_h_g; apply/eqP; symmetry; apply: (mulIg g^-1); rewrite gsimp.\n  apply: (Hreg _ x); first by rewrite groupM // groupV.\n  by rewrite permM -(eqP diff_gx_hx) -permM mulgV perm1.\ncase diff_hgx_x: ((h * g) x == x).\n  case/negP: diff_h1_g; apply/eqP; apply: (mulgI h); rewrite !gsimp.\n  by apply: (Hreg _ x); [apply: groupM | apply/eqP].\ncase diff_hgx_hx: ((h * g) x == h x).\n  case/negP: diff_1_g; apply/eqP.\n  by apply: (Hreg _ (h x)) => //; apply/eqP; rewrite -permM.\ncase diff_hgx_gx: ((h * g) x == g x).\n  by case/idP: diff_hx_x; rewrite -(can_eq (permK g)) -permM.\ncase Ez: (pred0b\n            (predD1 (predD1 (predD1 (predD1 T x) (h x)) (g x)) ((h * g) x))).\n- move: oT; rewrite /pred0b in Ez.\n  rewrite (cardD1 x) (cardD1 (h x)) (cardD1 (g x)) (cardD1 ((h * g) x)).\n  by rewrite (eqP Ez) addnC; do 3!case: (_ x \\in _).\ncase/pred0Pn: Ez => z.\ncase/and5P=> diff_hgx_z diff_gx_z diff_hx_z diff_x_z /= Hz.\npose S1 := [tuple x; h x; g x; z].\nhave DnS1: S1 \\in 4.-dtuple(setT).\n  rewrite inE memtE subset_all -!andbA !negb_or /= !inE !andbT.\n  rewrite -!(eq_sym z) diff_gx_z diff_x_z diff_hx_z.\n  by rewrite !(eq_sym x) diff_hx_x diff_gx_x eq_sym diff_gx_hx.\npose S2 := [tuple x; h x; g x; (h * g) x].\nhave DnS2: S2 \\in 4.-dtuple(setT).\n  rewrite inE memtE subset_all -!andbA !negb_or /= !inE !andbT !(eq_sym x).\n  rewrite diff_hx_x diff_gx_x diff_hgx_x.\n  by rewrite !(eq_sym (h x)) diff_gx_hx diff_hgx_hx eq_sym diff_hgx_gx.\ncase: (atransP2 F2 DnS1 DnS2) => k Hk [/=].\nrewrite /aperm => Hkx Hkhx Hkgx Hkhgx.\nhave h_k_com: h * k = k * h.\n  suff HH: (k * h * k^-1) * h^-1 = 1 by rewrite -[h * k]mul1g -HH !gnorm.\n  apply: (Hreg _ x); last first.\n    by rewrite !permM -Hkx Hkhx -!permM mulKVg mulgV perm1.\n  by rewrite groupM // ?groupV // (conjgCV k) mulgK -mem_conjg (normsP nH).\nhave g_k_com: g * k = k * g.\n  suff HH: (k * g * k^-1) * g^-1 = 1 by rewrite -[g * k]mul1g -HH !gnorm.\n  apply: (Hreg _ x); last first.\n    by rewrite !permM -Hkx Hkgx -!permM mulKVg mulgV perm1.\n  by rewrite groupM // ?groupV // (conjgCV k) mulgK -mem_conjg (normsP nH).\nhave HH: (k * (h * g) * k ^-1) x = z.\n   by rewrite 2!permM -Hkx Hkhgx -permM mulgV perm1.\ncase/negP: diff_hgx_z.\nrewrite -HH !mulgA -h_k_com -!mulgA [k * _]mulgA.\nby rewrite -g_k_com -!mulgA mulgV mulg1.\nQed.",
    "Lemma gen_tperm_circular_shift (X : finType) x y c : prime #|X| ->\n  x != y -> #[c]%g = #|X| ->\n  <<[set tperm x y; c]>>%g = ('Sym_X)%g.\nProof.\nmove=> Xprime neq_xy ord_c; apply/eqP; rewrite eqEsubset subsetT/=.\nhave c_gt1 : (1 < #[c]%g)%N by rewrite ord_c prime_gt1.\nhave cppSS : #[c]%g.-2.+2 = #|X| by rewrite ?prednK ?ltn_predRL.\npose f (i : 'Z_#[c]%g) : X := Zpm i x.\nhave [g fK gK] : bijective f.\n  apply: inj_card_bij; rewrite ?cppSS ?card_ord// /f /Zpm => i j cijx.\n  pose stabx := ('C_<[c]>[x | 'P])%g.\n  have cjix : (c ^+ (j - i)%R)%g x = x.\n    by apply: (@perm_inj _ (c ^+ i)%g); rewrite -permM -expgD_Zp// addrNK.\n  have : (c ^+ (j - i)%R)%g \\in stabx.\n    by rewrite !inE ?groupX ?mem_gen ?sub1set ?inE// ['P%act _ _]cjix eqxx.\n  rewrite [stabx]perm_prime_astab// => /set1gP.\n  move=> /(congr1 (mulg (c ^+ i))); rewrite -expgD_Zp// addrC addrNK mulg1.\n  by move=> /eqP; rewrite eq_expg_ord// ?cppSS ?ord_c// => /eqP->.\npose gsf s := g \\o s \\o f.\nhave gsf_inj (s : {perm X}) : injective (gsf s).\n  apply: inj_comp; last exact: can_inj fK.\n  by apply: inj_comp; [exact: can_inj gK|exact: perm_inj].\npose fsg s := f \\o s \\o g.\nhave fsg_inj (s : {perm _}) : injective (fsg s).\n  apply: inj_comp; last exact: can_inj gK.\n  by apply: inj_comp; [exact: can_inj fK|exact: perm_inj].\nhave gsf_morphic : morphic 'Sym_X (fun s => perm (gsf_inj s)).\n  apply/morphicP => u v _ _; apply/permP => /= i.\n  by rewrite !permE/= !permE /gsf /= gK permM.\npose phi := morphm gsf_morphic; rewrite /= in phi.\nhave phi_inj : ('injm phi)%g.\n  apply/subsetP => /= u /mker/=; rewrite morphmE => gsfu1.\n  apply/set1gP/permP=> z; have /permP/(_ (g z)) := gsfu1.\n  by rewrite !perm1 permE /gsf/= gK => /(can_inj gK).\nhave phiT : (phi @* 'Sym_X)%g = [set: {perm 'Z_#[c]%g}].\n  apply/eqP; rewrite eqEsubset subsetT/=; apply/subsetP => /= u _.\n  apply/morphimP; exists (perm (fsg_inj u)); rewrite ?in_setT//.\n  by apply/permP => /= i; rewrite morphmE permE /gsf/fsg/= permE/= !fK.\nhave f0 : f 0%R = x by rewrite /f /Zpm permX.\npose k := g y; have k_gt0 : (k > 0)%N.\n  by rewrite lt0n (val_eqE k 0%R) -(can_eq fK) eq_sym gK f0.\nhave phixy : phi (tperm x y) = tperm (0%R : 'Z_#[c]) k.\n  apply/permP => i; rewrite permE/= /gsf/=; apply: (canLR fK).\n  by rewrite !permE/= -f0 -[y]gK !(can_eq fK) -!fun_if.\nhave phic : phi c = perm (addrI (1%R : 'Z_#[c])).\n  apply/permP => i; rewrite /phi morphmE !permE /gsf/=; apply: (canLR fK).\n  by rewrite /f /Zpm -permM addrC expgD_Zp.\nrewrite -(injmSK phi_inj)//= morphim_gen/= ?subsetT//= -/phi.\nrewrite phiT /morphim !setTI/= -/phi imsetU1 imset_set1/= phixy phic.\nsuff /gen_tpermn_circular_shift<- : coprime #[c]%g.-2.+2 (k - 0)%R by [].\nby rewrite subr0 prime_coprime ?gtnNdvd// ?cppSS.\nQed.",
    "Lemma solvable_AltF : 4 < #|T| -> solvable 'Alt_T = false.\nProof.\nmove=> card_T; apply/negP => Alt_solvable.\nhave/simple_Alt5 Alt_simple := card_T.\nhave := simple_sol_prime Alt_solvable Alt_simple.\nhave lt_T n : n <= 4 -> n < #|T| by move/leq_ltn_trans; apply.\nhave -> : #|('Alt_T)%G| = #|T|`! %/ 2 by rewrite -card_Alt ?mulKn ?lt_T.\nmove/even_prime => [/eqP|]; apply/negP.\n  rewrite neq_ltn leq_divRL // mulnC -[2 * 3]/(3`!).\n  by apply/orP; right; apply/ltnW/ltn_fact/lt_T.\nby rewrite -dvdn2 dvdn_divRL dvdn_fact //=; apply/ltnW/lt_T.\nQed.",
    "Lemma solvable_SymF : 4 < #|T| -> solvable 'Sym_T = false.\nProof. by rewrite (series_sol (Alt_normal T)) => /solvable_AltF->. Qed.",
    "Lemma section_reprP s : section_repr s \\isog s.\nProof.\nby rewrite /section_repr; case: pickP => //= /(_ s); rewrite isog_refl.\nQed.",
    "Lemma section_repr_isog s1 s2 :\n  s1 \\isog s2 -> section_repr s1 = section_repr s2.\nProof.\nby move=> iso12; congr (odflt _ _); apply: eq_pick => s; apply: isog_transr.\nQed.",
    "Lemma compsP G s :\n  reflect (last G s = 1%G /\\  path [rel x y : gTg | maxnormal y x x] G s)\n          (comps G s).\nProof. by apply: (iffP andP) => [] [/eqP]. Qed.",
    "Lemma trivg_comps G s : comps G s -> (G :==: 1) = (s == [::]).\nProof.\ncase/andP=> ls cs; apply/eqP/eqP=> [G1 | s1]; last first.\n  by rewrite s1 /= in ls; apply/eqP.\nby case: s {ls} cs => //= H s /andP[/maxgroupp]; rewrite G1 /proper sub1G andbF.\nQed.",
    "Lemma comps_cons G H s : comps G (H :: s) -> comps H s.\nProof. by case/andP => /= ls /andP[_]; rewrite /comps ls. Qed.",
    "Lemma simple_compsP G s : comps G s -> reflect (s = [:: 1%G]) (simple G).\nProof.\nmove=> cs; apply: (iffP idP) => [|s1]; last first.\n  by rewrite s1 /comps eqxx /= andbT -simple_maxnormal in cs.\ncase: s cs => [/trivg_comps/eqP-> | H s]; first by case/simpleP; rewrite eqxx.\nrewrite [comps _ _]andbCA /= => /andP[/maxgroupp maxH /trivg_comps/esym nil_s].\nrewrite simple_maxnormal => /maxgroupP[_ simG].\nhave H1: H = 1%G by apply/val_inj/simG; rewrite // sub1G.\nby move: nil_s; rewrite H1 eqxx => /eqP->.\nQed.",
    "Lemma exists_comps (G : gTg) : exists s, comps G s.\nProof.\nelim: {G} #|G| {1 3}G (leqnn #|G|) => [G | n IHn G cG].\n  by rewrite leqNgt cardG_gt0.\nhave [sG | nsG] := boolP (simple G).\n  by exists [:: 1%G]; rewrite /comps eqxx /=  -simple_maxnormal andbT.\nhave [-> | ntG] := eqVneq G 1%G; first by exists [::]; rewrite /comps eqxx.\nhave [N maxN] := ex_maxnormal_ntrivg ntG.\nhave [|s /andP[ls cs]] := IHn N.\n  by rewrite -ltnS (leq_trans _ cG) // proper_card // (maxnormal_proper maxN).\nby exists (N :: s); apply/and3P.\nQed.",
    "Lemma JordanHolderUniqueness (G : gTg) (s1 s2 : seq gTg) :\n  comps G s1 -> comps G s2 -> perm_eq (mkfactors G s1) (mkfactors G s2).\nProof.\nhave [n] := ubnP #|G|; elim: n G => // n Hi G in s1 s2 * => /ltnSE-cG cs1 cs2.\nhave [G1 | ntG] := boolP (G :==: 1).\n  have -> : s1 = [::] by apply/eqP; rewrite -(trivg_comps cs1).\n  have -> : s2 = [::] by apply/eqP; rewrite -(trivg_comps cs2).\n  by rewrite /= perm_refl.\nhave [sG | nsG] := boolP (simple G).\n  by rewrite (simple_compsP cs1 sG) (simple_compsP cs2 sG) perm_refl.\ncase es1: s1 cs1 => [|N1 st1] cs1.\n  by move: (trivg_comps cs1); rewrite eqxx; move/negP:ntG.\ncase es2: s2 cs2 => [|N2 st2] cs2 {s1 es1}.\n  by move: (trivg_comps cs2); rewrite eqxx; move/negP:ntG.\ncase/andP: cs1 => /= lst1; case/andP=> maxN_1 pst1.\ncase/andP: cs2 => /= lst2; case/andP=> maxN_2 pst2.\nhave cN1 : #|N1| < n.\n  by rewrite (leq_trans _ cG) ?proper_card ?(maxnormal_proper maxN_1).\nhave cN2 : #|N2| < n.\n  by rewrite (leq_trans _ cG) ?proper_card ?(maxnormal_proper maxN_2).\ncase: (N1 =P N2) {s2 es2} => [eN12 |].\n  by rewrite eN12 /= perm_cons Hi // /comps ?lst2 //= -eN12 lst1.\nmove/eqP; rewrite -val_eqE /=; move/eqP=> neN12.\nhave nN1G : N1 <| G by apply: maxnormal_normal.\nhave nN2G : N2 <| G by apply: maxnormal_normal.\npose N := (N1 :&: N2)%G.\nhave nNG : N <| G.\n  by rewrite /normal subIset ?(normal_sub nN1G) //= normsI ?normal_norm.\nhave iso1 : (G / N1)%G \\isog (N2 / N)%G.\n  rewrite isog_sym /= -(maxnormalM maxN_1 maxN_2) //.\n  rewrite (@normC _ N1 N2) ?(subset_trans (normal_sub nN1G)) ?normal_norm //.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN2G)) ?normal_norm.\nhave iso2 : (G / N2)%G \\isog (N1 / N)%G.\n  rewrite isog_sym /= -(maxnormalM maxN_1 maxN_2) // setIC.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN1G)) ?normal_norm.\nhave [sN /andP[lsN csN]] := exists_comps N.\nhave i1 : perm_eq (mksrepr G N1 :: mkfactors N1 st1)\n                  [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N1 [:: N & sN]).\n  apply: Hi=> //; rewrite /comps ?lst1 //= lsN csN andbT /=.\n  rewrite -quotient_simple.\n    by rewrite -(isog_simple iso2) quotient_simple.\n  by rewrite (normalS (subsetIl N1 N2) (normal_sub nN1G)).\nhave i2 : perm_eq (mksrepr G N2 :: mkfactors N2 st2)\n                  [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N2 [:: N & sN]).\n  apply: Hi=> //; rewrite /comps ?lst2 //= lsN csN andbT /=.\n  rewrite -quotient_simple.\n    by rewrite -(isog_simple iso1) quotient_simple.\n  by rewrite (normalS (subsetIr N1 N2) (normal_sub nN2G)).\npose fG1 := [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\npose fG2 := [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\nhave i3 : perm_eq fG1 fG2.\n  rewrite (@perm_catCA _ [::_] [::_]) /mksrepr.\n  rewrite (@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso1).\n  rewrite -(@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso2).\n  exact: perm_refl.\napply: (perm_trans i1); apply: (perm_trans i3); rewrite perm_sym.\nby apply: perm_trans i2; apply: perm_refl.\nQed.",
    "Lemma gactsP (G : {set rT}) : reflect {acts A, on G | to} [acts A, on G | to].\nProof.\napply: (iffP idP) => [nGA x|nGA]; first exact: acts_act.\napply/subsetP=> a Aa /[!inE]; rewrite Aa.\nby  apply/subsetP=> x; rewrite inE nGA.\nQed.",
    "Lemma gactsM (N1 N2 : {set rT}) :\n    N1 \\subset D -> N2 \\subset D ->\n  [acts A, on N1 | to] -> [acts A, on N2 | to] -> [acts A, on N1 * N2 | to].\nProof.\nmove=> sN1D sN2D aAN1 aAN2; apply/gactsP=> x Ax y.\napply/idP/idP; case/mulsgP=> y1 y2 N1y1 N2y2 e.\n  move: (actKin to Ax y); rewrite e; move<-.\n  rewrite gactM ?groupV ?(subsetP sN1D y1) ?(subsetP sN2D) //.\n  by apply: mem_mulg; rewrite ?(gactsP _ aAN1) ?(gactsP _ aAN2) // groupV.\nrewrite e gactM // ?(subsetP sN1D y1) ?(subsetP sN2D) //.\nby apply: mem_mulg; rewrite ?(gactsP _ aAN1) // ?(gactsP _ aAN2).\nQed.",
    "Lemma gactsI (N1 N2 : {set rT}) :\n  [acts A, on N1 | to] -> [acts A, on N2 | to] -> [acts A, on N1 :&: N2 | to].\nProof.\nmove=> aAN1 aAN2.\napply/subsetP=> x Ax; rewrite !inE Ax /=; apply/subsetP=> y Ny /[1!inE].\ncase/setIP: Ny=> N1y N2y; rewrite inE ?astabs_act  ?N1y ?N2y //.\n- by move/subsetP: aAN2; move/(_ x Ax).\n- by move/subsetP: aAN1; move/(_ x Ax).\nQed.",
    "Lemma gastabsP (S : {set rT}) (a : aT) :\n  a \\in A -> reflect (forall x, (to x a \\in S) = (x \\in S)) (a \\in 'N(S | to)).\nProof.\nmove=> Aa; apply: (iffP idP) => [nSa x|nSa]; first exact: astabs_act.\nby rewrite !inE Aa; apply/subsetP=> x; rewrite inE nSa.\nQed.",
    "Lemma qact_dom_doms (H : {group rT}) : H \\subset D -> qact_dom to H \\subset A.\nProof.\nby move=> sHD; apply/subsetP=> x; rewrite qact_domE // inE; case/andP.\nQed.",
    "Lemma acts_qact_doms (H : {group rT}) :\n  H \\subset D -> [acts A, on H | to] -> qact_dom to H :=: A.\nProof.\nmove=> sHD aH; apply/eqP; rewrite eqEsubset; apply/andP.\nsplit; first exact: qact_dom_doms.\napply/subsetP=> x Ax; rewrite qact_domE //; apply/gastabsP=> //.\nby move/gactsP: aH; move/(_ x Ax).\nQed.",
    "Lemma qacts_cosetpre (H : {group rT}) (K' : {group coset_of H}) :\n    H \\subset D -> [acts A, on H | to] ->\n    [acts qact_dom to H, on K' | to / H] ->\n  [acts A, on coset H @*^-1 K' | to].\nProof.\nmove=> sHD aH aK'; apply/subsetP=> x Ax; move: (Ax) (subsetP aK').\nrewrite -{1}(acts_qact_doms sHD aH) => qdx; move/(_ x qdx) => nx.\nrewrite !inE Ax; apply/subsetP=> y; case/morphpreP=> Ny /= K'Hy /[1!inE].\napply/morphpreP; split; first by rewrite acts_qact_dom_norm.\nby move/gastabsP: nx; move/(_  qdx (coset H y)); rewrite K'Hy qactE.\nQed.",
    "Lemma qacts_coset (H K : {group rT}) :\n    H \\subset D -> [acts A, on K | to] ->\n  [acts qact_dom to H, on (coset H) @* K | to / H].\nProof.\nmove=> sHD aK.\napply/subsetP=> x qdx; rewrite inE qdx inE; apply/subsetP=> y.\ncase/morphimP=> z Nz Kz /= e; rewrite e inE qactE // imset_f // inE.\nmove/gactsP: aK; move/(_ x (subsetP (qact_dom_doms sHD) _ qdx) z); rewrite Kz.\nmove->; move/acts_act: (acts_qact_dom to H); move/(_ x qdx z).\nby rewrite Nz andbT.\nQed.",
    "Lemma maxainv_norm : maxainv K N -> N <| K.\nProof. by move/maxgroupp; case/andP. Qed.",
    "Lemma maxainv_proper : maxainv K N -> N \\proper K.\nProof.\nby move/maxgroupp; case/andP; rewrite properE; move/normal_sub->; case/andP.\nQed.",
    "Lemma maxainv_sub : maxainv K N -> N \\subset K.\nProof. by move=> h; apply: proper_sub; apply: maxainv_proper. Qed.",
    "Lemma maxainv_ainvar : maxainv K N -> A \\subset 'N(N | to).\nProof. by move/maxgroupp; case/and3P. Qed.",
    "Lemma maxainvS : maxainv K N -> N \\subset K.\nProof. by move=> pNN; rewrite proper_sub // maxainv_proper. Qed.",
    "Lemma maxainv_exists : K :!=: 1 -> {N : {group rT} | maxainv K N}.\nProof.\nmove=> nt; apply: ex_maxgroup. exists [1 rT]%G.\nrewrite /= normal1 subG1 nt /=.\napply/subsetP=> a Da; rewrite !inE Da /= sub1set !inE.\nby rewrite /= -actmE // morph1 eqxx.\nQed.",
    "Lemma maxainvM (G H K : {group rT}) :\n    H \\subset D -> K \\subset D -> maxainv G H -> maxainv G K ->\n  H :<>: K -> H * K = G.\nProof.\nmove: H K => N1 N2 sN1D sN2D pmN1 pmN2 neN12.\nhave cN12 : commute N1 N2.\n  apply: normC; apply: (subset_trans (maxainv_sub pmN1)).\n  by rewrite normal_norm ?maxainv_norm.\nwlog nsN21 : G N1 N2 sN1D sN2D pmN1 pmN2 neN12 cN12/ ~~(N1 \\subset N2).\n  move/eqP: (neN12); rewrite eqEsubset negb_and; case/orP=> ns; first by apply.\n  by rewrite cN12; apply=> //; apply: sym_not_eq.\nhave nP : N1 * N2 <| G by rewrite normalM ?maxainv_norm.\nhave sN2P : N2 \\subset N1 * N2 by rewrite mulg_subr ?group1.\ncase/maxgroupP: (pmN1); case/andP=> nN1G pN1G mN1.\ncase/maxgroupP: (pmN2); case/andP=> nN2G pN2G mN2.\ncase/andP: pN1G=> nsGN1 ha1; case/andP: pN2G=> nsGN2 ha2.\ncase e : (G \\subset N1 * N2).\n  by apply/eqP; rewrite eqEsubset e mulG_subG !normal_sub.\nhave: N1 <*> N2 = N2 by apply: mN2; rewrite /= ?comm_joingE // nP e /= gactsM.\nby rewrite comm_joingE // => h; move: nsN21; rewrite -h mulg_subl.\nQed.",
    "Lemma asimpleP K :\n  reflect [/\\ K :!=: 1\n            & forall H, H <| K -> [acts A, on H | to] -> H :=: 1 \\/ H :=: K]\n          (asimple K).\nProof.\napply: (iffP idP).\n  case/maxgroupP; rewrite normal1 /=; case/andP=> nsK1 aK H1.\n  rewrite eqEsubset negb_and nsK1 /=; split => // H nHK ha.\n  case eHK : (H :==: K); first by right; apply/eqP.\n  left; apply: H1; rewrite ?sub1G // nHK; move/negbT: eHK.\n  by rewrite eqEsubset negb_and normal_sub //=; move->.\ncase=> ntK h; apply/maxgroupP; split.\n  move: ntK; rewrite eqEsubset sub1G andbT normal1; move->.\n  apply/subsetP=> a Da; rewrite !inE Da /= sub1set !inE.\n  by rewrite /= -actmE // morph1 eqxx.\nmove=> H /andP[nHK /andP[nsKH ha]] _.\ncase: (h _ nHK ha)=> // /eqP; rewrite eqEsubset.\nby rewrite (negbTE nsKH) andbF.\nQed.",
    "Lemma acompsP K s :\n  reflect (last K s = 1%G /\\  path [rel x y : {group rT} | maxainv x y] K s)\n          (acomps K s).\nProof. by apply: (iffP andP); case; move/eqP. Qed.",
    "Lemma trivg_acomps K s : acomps K s -> (K :==: 1) = (s == [::]).\nProof.\ncase/andP=> ls cs; apply/eqP/eqP; last first.\n  by move=> se; rewrite se /= in ls; apply/eqP.\nmove=> G1; case: s ls cs => // H s _ /=; case/andP; case/maxgroupP.\nby rewrite G1 sub1G andbF.\nQed.",
    "Lemma acomps_cons K H s : acomps K (H :: s) -> acomps H s.\nProof. by case/andP => /= ls; case/andP=> _ p; rewrite /acomps ls. Qed.",
    "Lemma asimple_acompsP K s : acomps K s -> reflect (s = [:: 1%G]) (asimple K).\nProof.\nmove=> cs; apply: (iffP idP); last first.\n  by move=> se; move: cs; rewrite se /=; case/andP=> /=; rewrite andbT.\ncase: s cs.\n  by rewrite /acomps /= andbT; move/eqP->; case/asimpleP; rewrite eqxx.\nmove=> H s cs sG; apply/eqP.\nrewrite eqseq_cons -(trivg_acomps (acomps_cons cs)) andbC andbb.\ncase/acompsP: cs => /= ls; case/andP=> mH ps.\ncase/maxgroupP: sG; case/and3P => _ ntG _ ->; rewrite ?sub1G //.\nrewrite (maxainv_norm mH); case/andP: (maxainv_proper mH)=> _ ->.\nexact: (maxainv_ainvar mH).\nQed.",
    "Lemma exists_acomps K : exists s, acomps K s.\nProof.\nelim: {K} #|K| {1 3}K (leqnn #|K|) => [K | n Hi K cK].\n  by rewrite leqNgt cardG_gt0.\ncase/orP: (orbN (asimple K)) => [sK | nsK].\n  by exists [:: (1%G : {group rT})]; rewrite /acomps eqxx /= andbT.\ncase/orP: (orbN (K :==: 1))=> [tK | ntK].\n  by exists (Nil _); rewrite /acomps /= andbT.\ncase: (maxainv_exists ntK)=> N pmN.\nhave cN: #|N| <= n.\n  by rewrite -ltnS (leq_trans _ cK) // proper_card // (maxainv_proper pmN).\ncase: (Hi _ cN)=> s; case/andP=> lasts ps; exists [:: N & s]; rewrite /acomps.\nby rewrite last_cons lasts /= pmN.\nQed.",
    "Lemma maxainv_asimple_quo (G H : {group rT}) :\n   H \\subset D -> maxainv to G H -> asimple (to / H) (G / H).\nProof.\nmove=> sHD /maxgroupP[/and3P[nHG pHG aH] Hmax].\napply/asimpleP; split; first by rewrite -subG1 quotient_sub1 ?normal_norm.\nmove=> K' nK'Q aK'.\nhave: (K' \\proper (G / H)) || (G / H == K').\n  by rewrite properE eqEsubset andbC (normal_sub nK'Q) !andbT orbC orbN.\ncase/orP=> [ pHQ | eQH]; last by right; apply sym_eq; apply/eqP.\nleft; pose K := ((coset H) @*^-1 K')%G.\nhave eK'I : K' \\subset (coset H) @* 'N(H).\n  by rewrite (subset_trans (normal_sub nK'Q)) ?morphimS ?normal_norm.\nhave eKK' : K' :=: K / H by rewrite /(K / H) morphpreK //=.\nsuff eKH : K :=: H by rewrite -trivg_quotient eKK' eKH.\nhave sHK : H \\subset K by rewrite -ker_coset kerE morphpreS // sub1set group1.\napply: Hmax => //; apply/and3P; split; last exact: qacts_cosetpre.\n  by rewrite -(quotientGK nHG) cosetpre_normal.\nby move: (proper_subn pHQ); rewrite sub_morphim_pre ?normal_norm.\nQed.",
    "Lemma asimple_quo_maxainv (G H : {group rT}) :\n    H \\subset D -> G \\subset D -> [acts A, on G | to] -> [acts A, on H | to] ->\n    H <| G -> asimple (to / H) (G / H) ->\n  maxainv to G H.\nProof.\nmove=> sHD sGD aG aH nHG /asimpleP[ntQ maxQ]; apply/maxgroupP; split.\n  by rewrite nHG -quotient_sub1 ?normal_norm // subG1 ntQ.\nmove=> K /and3P[nKG nsGK aK] sHK.\npose K' := (K / H)%G.\nhave K'dQ : K' <| (G / H)%G by apply: morphim_normal.\nhave nKH : H <| K by rewrite (normalS _ _ nHG) // normal_sub.\nhave: K' :=: 1%G \\/ K' :=: (G / H).\n  apply: (maxQ K' K'dQ) => /=.\n  apply/subsetP=> x Adx. rewrite inE Adx /= inE. apply/subsetP=> y.\n  rewrite quotientE; case/morphimP=> z Nz Kz ->; rewrite /= !inE qactE //.\n  have ntoyx :  to z x \\in 'N(H) by  rewrite (acts_qact_dom_norm Adx).\n  apply/morphimP; exists (to z x) => //.\n  suff h: qact_dom to H \\subset A.\n    by rewrite astabs_act // (subsetP aK) //; apply: (subsetP h).\n  by apply/subsetP=> t; rewrite qact_domE // inE; case/andP.\ncase=> [|/quotient_injG /[!inE]/(_ nKH nHG) c]; last by rewrite c subxx in nsGK.\nrewrite /= -trivg_quotient => tK'; apply: (congr1 (@gval _)); move: tK'.\nby apply: (@quotient_injG _ H); rewrite ?inE /= ?normal_refl.\nQed.",
    "Lemma asimpleI (N1 N2 : {group rT}) :\n    N2 \\subset 'N(N1) -> N1 \\subset D ->\n    [acts A, on N1 | to] -> [acts A, on N2 | to] ->\n    asimple (to / N1) (N2 / N1) ->\n  asimple (to / (N2 :&: N1)) (N2 / (N2 :&: N1)).\nProof.\nmove=> nN21 sN1D aN1 aN2 /asimpleP[ntQ1 max1].\nhave [f1 [f1e f1ker f1pre f1im]] := restrmP (coset_morphism N1) nN21.\nhave hf2' : N2 \\subset 'N(N2 :&: N1) by apply: normsI => //; rewrite normG.\nhave hf2'' : 'ker (coset (N2 :&: N1)) \\subset 'ker f1.\n  by rewrite f1ker !ker_coset.\npose f2 := factm_morphism  hf2'' hf2'.\napply/asimpleP; split.\n   rewrite /= setIC; apply/negP; move: (second_isog nN21); move/isog_eq1->.\n   by apply/negP.\nmove=> H nHQ2 aH; pose K := f2 @* H.\nhave nKQ1 : K <| N2 / N1.\n  rewrite (_ : N2 / N1 = f2 @* (N2 / (N2 :&: N1))) ?morphim_normal //.\n  by rewrite morphim_factm f1im.\nhave sqA : qact_dom to N1 \\subset A.\n  by apply/subsetP=> t; rewrite qact_domE // inE; case/andP.\nhave nNN2 : (N2 :&: N1) <| N2.\n  by rewrite /normal subsetIl; apply: normsI => //; apply: normG.\nhave aKQ1 : [acts qact_dom to N1, on K | to / N1].\n  pose H':= coset (N2 :&: N1)@*^-1 H.\n  have eHH' : H :=: H' / (N2 :&: N1) by rewrite cosetpreK.\n  have -> : K :=: f1 @* H' by rewrite /K eHH' morphim_factm.\n  have sH'N2 : H' \\subset N2.\n    rewrite /H' eHH' quotientGK ?normal_cosetpre //=.\n    by rewrite sub_cosetpre_quo ?normal_sub.\n  have -> : f1 @* H' = coset N1 @* H' by rewrite f1im //=.\n  apply: qacts_coset => //; apply: qacts_cosetpre => //; last exact: gactsI.\n  by apply: (subset_trans (subsetIr _ _)).\nhave injf2 : 'injm f2.\n  by rewrite ker_factm f1ker /= ker_coset /= subG1 /= -quotientE trivg_quotient.\nhave iHK : H \\isog K.\n  apply/isogP; pose f3 := restrm_morphism (normal_sub nHQ2) f2.\n  by exists f3; rewrite 1?injm_restrm // morphim_restrm setIid.\ncase: (max1 _ nKQ1 aKQ1).\n  by move/eqP; rewrite -(isog_eq1 iHK); move/eqP->; left.\nmove=> he /=; right; apply/eqP; rewrite eqEcard normal_sub //=.\nmove: (second_isog nN21); rewrite setIC; move/card_isog->; rewrite -he.\nby move/card_isog: iHK=> <-; rewrite leqnn.\nQed.",
    "Lemma StrongJordanHolderUniqueness (G : {group rT}) (s1 s2 : seq {group rT}) :\n    G \\subset D -> acomps to G s1 -> acomps to G s2 ->\n  perm_eq (mkfactors G s1) (mkfactors G s2).\nProof.\nhave [n] := ubnP #|G|; elim: n G => // n Hi G in s1 s2 * => cG hsD cs1 cs2.\ncase/orP: (orbN (G :==: 1)) => [tG | ntG].\n  have -> : s1 = [::] by apply/eqP; rewrite -(trivg_acomps cs1).\n  have -> : s2 = [::] by apply/eqP; rewrite -(trivg_acomps cs2).\n  by rewrite /= perm_refl.\ncase/orP: (orbN (asimple to G))=> [sG | nsG].\n  have -> : s1 = [:: 1%G ] by apply/(asimple_acompsP cs1).\n  have -> : s2 = [:: 1%G ] by apply/(asimple_acompsP cs2).\n  by rewrite /= perm_refl.\ncase es1: s1 cs1 => [|N1 st1] cs1.\n  by move: (trivg_comps cs1); rewrite eqxx; move/negP:ntG.\ncase es2: s2 cs2 => [|N2 st2] cs2 {s1 es1}.\n  by move: (trivg_comps cs2); rewrite eqxx; move/negP:ntG.\ncase/andP: cs1 => /= lst1; case/andP=> maxN_1 pst1.\ncase/andP: cs2 => /= lst2; case/andP=> maxN_2 pst2.\nhave sN1D : N1 \\subset D.\n  by apply: subset_trans hsD; apply: maxainv_sub maxN_1.\nhave sN2D : N2 \\subset D.\n  by apply: subset_trans hsD; apply: maxainv_sub maxN_2.\nhave cN1 : #|N1| < n.\n  by rewrite -ltnS (leq_trans _ cG) ?ltnS ?proper_card ?(maxainv_proper maxN_1).\nhave cN2 : #|N2| < n.\n  by rewrite -ltnS (leq_trans _ cG) ?ltnS ?proper_card ?(maxainv_proper maxN_2).\ncase: (N1 =P N2) {s2 es2} => [eN12 |].\n  by rewrite eN12 /= perm_cons Hi // /acomps ?lst2 //= -eN12 lst1.\nmove/eqP; rewrite -val_eqE /=; move/eqP=> neN12.\nhave nN1G : N1 <| G by apply: (maxainv_norm maxN_1).\nhave nN2G : N2 <| G by apply: (maxainv_norm maxN_2).\npose N := (N1 :&: N2)%G.\nhave nNG : N <| G.\n  by rewrite /normal subIset ?(normal_sub nN1G) //= normsI ?normal_norm.\nhave iso1 : (G / N1)%G \\isog (N2 / N)%G.\n  rewrite isog_sym /= -(maxainvM _ _ maxN_1 maxN_2) //.\n  rewrite (@normC _ N1 N2) ?(subset_trans (normal_sub nN1G)) ?normal_norm //.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN2G)) ?normal_norm.\nhave iso2 : (G / N2)%G \\isog (N1 / N)%G.\n  rewrite isog_sym /= -(maxainvM _ _ maxN_1 maxN_2) // setIC.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN1G)) ?normal_norm.\ncase: (exists_acomps to N)=> sN; case/andP=> lsN csN.\nhave aN1 : [acts A, on N1 | to].\n  by case/maxgroupP: maxN_1; case/and3P.\nhave aN2 : [acts A, on N2 | to].\n  by case/maxgroupP: maxN_2; case/and3P.\nhave nNN1 : N <| N1.\n  by apply: (normalS _ _ nNG); rewrite ?subsetIl ?normal_sub.\nhave nNN2 : N <| N2.\n  by apply: (normalS _ _ nNG); rewrite ?subsetIr ?normal_sub.\nhave aN : [ acts A, on N1 :&: N2 | to].\n  apply/subsetP=> x Ax; rewrite !inE Ax /=; apply/subsetP=> y Ny; rewrite inE.\n  case/setIP: Ny=> N1y N2y. rewrite inE ?astabs_act  ?N1y ?N2y //.\n    by move/subsetP: aN2; move/(_ x Ax).\n  by move/subsetP: aN1; move/(_ x Ax).\nhave i1 : perm_eq (mksrepr G N1 :: mkfactors N1 st1)\n                  [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N1 [:: N & sN]).\n  apply: Hi=> //; rewrite /acomps ?lst1 //= lsN csN andbT /=.\n  apply: asimple_quo_maxainv=> //; first by apply: subIset; rewrite sN1D.\n  apply: asimpleI => //.\n    by apply: subset_trans (normal_norm nN2G); apply: normal_sub.\n  rewrite -quotientMidl (maxainvM _ _ maxN_2) //.\n    by apply: maxainv_asimple_quo.\n  by move=> e; apply: neN12.\nhave i2 : perm_eq (mksrepr G N2 :: mkfactors N2 st2)\n                  [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N2 [:: N & sN]).\n  apply: Hi=> //; rewrite /acomps ?lst2 //= lsN csN andbT /=.\n  apply: asimple_quo_maxainv=> //; first by apply: subIset; rewrite sN1D.\n  have e : N1 :&: N2 :=: N2 :&: N1 by rewrite setIC.\n  rewrite (group_inj (setIC N1 N2)); apply: asimpleI => //.\n    by apply: subset_trans (normal_norm nN1G); apply: normal_sub.\n  rewrite -quotientMidl (maxainvM _ _ maxN_1) //.\n  exact: maxainv_asimple_quo.\npose fG1 := [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\npose fG2 := [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\nhave i3 : perm_eq fG1 fG2.\n  rewrite (@perm_catCA _ [::_] [::_]) /mksrepr.\n  rewrite (@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso1).\n  rewrite -(@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso2).\n  exact: perm_refl.\napply: (perm_trans i1); apply: (perm_trans i3); rewrite perm_sym.\nby apply: perm_trans i2; apply: perm_refl.\nQed.",
    "Lemma nilpotent1 : nilpotent [1 gT].\nProof. by apply/forall_inP=> H; rewrite commG1 setIid -subG1. Qed.",
    "Lemma nilpotentS A B : B \\subset A -> nilpotent A -> nilpotent B.\nProof.\nmove=> sBA nilA; apply/forall_inP=> H sHR.\nhave:= forallP nilA H; rewrite (subset_trans sHR) //.\nby apply: subset_trans (setIS _ _) (setSI _ _); rewrite ?commgS.\nQed.",
    "Lemma nil_comm_properl G H A :\n    nilpotent G -> H \\subset G -> H :!=: 1 -> A \\subset 'N_G(H) ->\n  [~: H, A] \\proper H.\nProof.\nmove=> nilG sHG ntH; rewrite subsetI properE; case/andP=> sAG nHA.\nrewrite (subset_trans (commgS H (subset_gen A))) ?commg_subl ?gen_subG //.\napply: contra ntH => sHR; have:= forallP nilG H; rewrite subsetI sHG.\nby rewrite (subset_trans sHR) ?commgS.\nQed.",
    "Lemma nil_comm_properr G A H :\n    nilpotent G -> H \\subset G -> H :!=: 1 -> A \\subset 'N_G(H) ->\n  [~: A, H] \\proper H.\nProof. by rewrite commGC; apply: nil_comm_properl. Qed.",
    "Lemma centrals_nil (s : seq {group gT}) G :\n  G.-central.-series 1%G s -> last 1%G s = G -> nilpotent G.\nProof.\nmove=> cGs defG; apply/forall_inP=> H /subsetIP[sHG sHR].\nmove: sHG; rewrite -{}defG -subG1 -[1]/(gval 1%G).\nelim: s 1%G cGs => //= L s IHs K /andP[/and3P[sRK sKL sLG] /IHs sHL] sHs.\nexact: subset_trans sHR (subset_trans (commSg _ (sHL sHs)) sRK).\nQed.",
    "Lemma lcn0 A : 'L_0(A) = A. Proof. by []. Qed.",
    "Lemma lcn1 A : 'L_1(A) = A. Proof. by []. Qed.",
    "Lemma lcnSn n A : 'L_n.+2(A) = [~: 'L_n.+1(A), A]. Proof. by []. Qed.",
    "Lemma lcnSnS n G : [~: 'L_n(G), G] \\subset 'L_n.+1(G).\nProof. by case: n => //; apply: der1_subG. Qed.",
    "Lemma lcnE n A : 'L_n.+1(A) = iter n (fun B => [~: B, A]) A.\nProof. by []. Qed.",
    "Lemma lcn2 A : 'L_2(A) = A^`(1). Proof. by []. Qed.",
    "Lemma lcn_group_set n G : group_set 'L_n(G).\nProof. by case: n => [|[|n]]; apply: groupP. Qed.",
    "Lemma lcn_char n G : 'L_n(G) \\char G.\nProof. by case: n; last elim=> [|n IHn]; rewrite ?char_refl ?lcnSn ?charR. Qed.",
    "Lemma lcn_normal n G : 'L_n(G) <|  G.\nProof. exact/char_normal/lcn_char. Qed.",
    "Lemma lcn_sub n G : 'L_n(G) \\subset G.\nProof. exact/char_sub/lcn_char. Qed.",
    "Lemma lcn_norm n G : G \\subset 'N('L_n(G)).\nProof. exact/char_norm/lcn_char. Qed.",
    "Lemma lcn_subS n G : 'L_n.+1(G) \\subset 'L_n(G).\nProof.\ncase: n => // n; rewrite lcnSn commGC commg_subr.\nby case/andP: (lcn_normal n.+1 G).\nQed.",
    "Lemma lcn_normalS n G : 'L_n.+1(G) <| 'L_n(G).\nProof. by apply: normalS (lcn_normal _ _); rewrite (lcn_subS, lcn_sub). Qed.",
    "Lemma lcn_central n G : 'L_n(G) / 'L_n.+1(G) \\subset 'Z(G / 'L_n.+1(G)).\nProof.\ncase: n => [|n]; first by rewrite trivg_quotient sub1G.\nby rewrite subsetI quotientS ?lcn_sub ?quotient_cents2r.\nQed.",
    "Lemma lcn_sub_leq m n G : n <= m -> 'L_m(G) \\subset 'L_n(G).\nProof.\nby move/subnK <-; elim: {m}(m - n) => // m; apply: subset_trans (lcn_subS _ _).\nQed.",
    "Lemma lcnS n A B : A \\subset B -> 'L_n(A) \\subset 'L_n(B).\nProof.\nby case: n => // n sAB; elim: n => // n IHn; rewrite !lcnSn genS ?imset2S.\nQed.",
    "Lemma lcn_cprod n A B G : A \\* B = G -> 'L_n(A) \\* 'L_n(B) = 'L_n(G).\nProof.\ncase: n => // n /cprodP[[H K -> ->{A B}] defG cHK].\nhave sL := subset_trans (lcn_sub _ _); rewrite cprodE ?(centSS _ _ cHK) ?sL //.\nsymmetry; elim: n => // n; rewrite lcnSn => ->; rewrite commMG /=; last first.\n  by apply: subset_trans (commg_normr _ _); rewrite sL // -defG mulG_subr.\nrewrite -!(commGC G) -defG -{1}(centC cHK).\nrewrite !commMG ?normsR ?lcn_norm ?cents_norm // 1?centsC //.\nby rewrite -!(commGC 'L__(_)) -!lcnSn !(commG1P _) ?mul1g ?sL // centsC.\nQed.",
    "Lemma lcn_dprod n A B G : A \\x B = G -> 'L_n(A) \\x 'L_n(B) = 'L_n(G).\nProof.\nmove=> defG; have [[K H defA defB] _ _ tiAB] := dprodP defG.\nrewrite !dprodEcp // in defG *; first exact: lcn_cprod.\nby rewrite defA defB; apply/trivgP; rewrite -tiAB defA defB setISS ?lcn_sub.\nQed.",
    "Lemma der_cprod n A B G : A \\* B = G -> A^`(n) \\* B^`(n) = G^`(n).\nProof. by move=> defG; elim: n => {defG}// n; apply: (lcn_cprod 2). Qed.",
    "Lemma der_dprod n A B G : A \\x B = G -> A^`(n) \\x B^`(n) = G^`(n).\nProof. by move=> defG; elim: n => {defG}// n; apply: (lcn_dprod 2). Qed.",
    "Lemma lcn_bigcprod n I r P (F : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) F i = G ->\n  \\big[cprod/1]_(i <- r | P i) 'L_n(F i) = 'L_n(G).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first exact/esym/trivgP/lcn_sub.\nby rewrite -(lcn_cprod n dG); have [[_ H _ dH]] := cprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma lcn_bigdprod n I r P (F : I -> {set gT}) G :\n    \\big[dprod/1]_(i <- r | P i) F i = G ->\n  \\big[dprod/1]_(i <- r | P i) 'L_n(F i) = 'L_n(G).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first exact/esym/trivgP/lcn_sub.\nby rewrite -(lcn_dprod n dG); have [[_ H _ dH]] := dprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma der_bigcprod n I r P (F : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) F i = G ->\n  \\big[cprod/1]_(i <- r | P i) (F i)^`(n) = G^`(n).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first by rewrite gF1.\nby rewrite -(der_cprod n dG); have [[_ H _ dH]] := cprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma der_bigdprod n I r P (F : I -> {set gT}) G :\n    \\big[dprod/1]_(i <- r | P i) F i = G ->\n  \\big[dprod/1]_(i <- r | P i) (F i)^`(n) = G^`(n).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first by rewrite gF1.\nby rewrite -(der_dprod n dG); have [[_ H _ dH]] := dprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma nilpotent_class G : nilpotent G = (nil_class G < #|G|).\nProof.\nrewrite /nil_class; set s := mkseq _ _.\ntransitivity (1 \\in s); last by rewrite -index_mem size_mkseq.\napply/idP/mapP=> {s}/= [nilG | [n _ Ln1]]; last first.\n  apply/forall_inP=> H /subsetIP[sHG sHR].\n  rewrite -subG1 {}Ln1; elim: n => // n IHn.\n  by rewrite (subset_trans sHR) ?commSg.\npose m := #|G|.-1; exists m; first by rewrite mem_iota /= prednK.\nset n := m; rewrite ['L__(G)]card_le1_trivg //= -(subnn m) -[m in _ - m]/n.\nelim: n => [|n]; [by rewrite subn0 prednK | rewrite lcnSn subnS].\ncase: (eqsVneq 'L_n.+1(G) 1) => [-> | ntLn]; first by rewrite comm1G cards1.\ncase: (m - n) => [|m' /= IHn]; first by rewrite leqNgt cardG_gt1 ntLn.\nrewrite -ltnS (leq_trans (proper_card _) IHn) //.\nby rewrite (nil_comm_properl nilG) ?lcn_sub // subsetI subxx lcn_norm.\nQed.",
    "Lemma lcn_nil_classP n G :\n  nilpotent G -> reflect ('L_n.+1(G) = 1) (nil_class G <= n).\nProof.\nrewrite nilpotent_class /nil_class; set s := mkseq _ _.\nset c := index 1 s => lt_c_G; case: leqP => [le_c_n | lt_n_c].\n  have Lc1: nth 1 s c = 1 by rewrite nth_index // -index_mem size_mkseq.\n  by left; apply/trivgP; rewrite -Lc1 nth_mkseq ?lcn_sub_leq.\nright; apply/eqP/negPf; rewrite -(before_find 1 lt_n_c) nth_mkseq //.\nexact: ltn_trans lt_n_c lt_c_G.\nQed.",
    "Lemma lcnP G : reflect (exists n, 'L_n.+1(G) = 1) (nilpotent G).\nProof.\napply: (iffP idP) => [nilG | [n Ln1]].\n  by exists (nil_class G); apply/lcn_nil_classP.\napply/forall_inP=> H /subsetIP[sHG sHR]; rewrite -subG1 -{}Ln1.\nby elim: n => // n IHn; rewrite (subset_trans sHR) ?commSg.\nQed.",
    "Lemma abelian_nil G : abelian G -> nilpotent G.\nProof. by move=> abG; apply/lcnP; exists 1%N; apply/commG1P. Qed.",
    "Lemma nil_class0 G : (nil_class G == 0) = (G :==: 1).\nProof.\napply/idP/eqP=> [nilG | ->].\n  by apply/(lcn_nil_classP 0); rewrite ?nilpotent_class (eqP nilG) ?cardG_gt0.\nby rewrite -leqn0; apply/(lcn_nil_classP 0); rewrite ?nilpotent1.\nQed.",
    "Lemma nil_class1 G : (nil_class G <= 1) = abelian G.\nProof.\nhave [-> | ntG] := eqsVneq G 1.\n  by rewrite abelian1 leq_eqVlt ltnS leqn0 nil_class0 eqxx orbT.\napply/idP/idP=> cGG.\n  apply/commG1P; apply/(lcn_nil_classP 1); rewrite // nilpotent_class.\n  by rewrite (leq_ltn_trans cGG) // cardG_gt1.\nby apply/(lcn_nil_classP 1); rewrite ?abelian_nil //; apply/commG1P.\nQed.",
    "Lemma cprod_nil A B G : A \\* B = G -> nilpotent G = nilpotent A && nilpotent B.\nProof.\nmove=> defG; case/cprodP: defG (defG) => [[H K -> ->{A B}] defG _] defGc.\napply/idP/andP=> [nilG | [/lcnP[m LmH1] /lcnP[n LnK1]]].\n  by rewrite !(nilpotentS _ nilG) // -defG (mulG_subr, mulG_subl).\napply/lcnP; exists (m + n.+1); apply/trivgP.\ncase/cprodP: (lcn_cprod (m.+1 + n.+1) defGc) => _ <- _.\nby rewrite mulG_subG /= -{1}LmH1 -LnK1 !lcn_sub_leq ?leq_addl ?leq_addr.\nQed.",
    "Lemma mulg_nil G H :\n  H \\subset 'C(G) -> nilpotent (G * H) = nilpotent G && nilpotent H.\nProof. by move=> cGH; rewrite -(cprod_nil (cprodEY cGH)) /= cent_joinEr. Qed.",
    "Lemma dprod_nil A B G : A \\x B = G -> nilpotent G = nilpotent A && nilpotent B.\nProof. by case/dprodP=> [[H K -> ->] <- cHK _]; rewrite mulg_nil.\nQed.",
    "Lemma bigdprod_nil I r (P : pred I) (A_ : I -> {set gT}) G :\n  \\big[dprod/1]_(i <- r | P i) A_ i = G\n  -> (forall i, P i -> nilpotent (A_ i)) -> nilpotent G.\nProof.\nmove=> defG nilA; elim/big_rec: _ => [|i B Pi nilB] in G defG *.\n  by rewrite -defG nilpotent1.\nhave [[_ H _ defB] _ _ _] := dprodP defG.\nby rewrite (dprod_nil defG) nilA //= defB nilB.\nQed.",
    "Lemma lcn_cont n : GFunctor.continuous (@lower_central_at n).\nProof.\ncase: n => //; elim=> // n IHn g0T h0T H phi.\nby rewrite !lcnSn morphimR ?lcn_sub // commSg ?IHn.\nQed.",
    "Lemma ucn_pmap : exists hZ : GFunctor.pmap, @upper_central_at n = hZ.\nProof.\nelim: n => [|n' [hZ defZ]]; first by exists trivGfun_pgFun.\nby exists [pgFun of @center %% hZ]; rewrite /= -defZ.\nQed.",
    "Lemma ucn_group_set gT (G : {group gT}) : group_set 'Z_n(G).\nProof. by have [hZ ->] := ucn_pmap; apply: groupP. Qed.",
    "Lemma ucn_sub gT (G : {group gT}) : 'Z_n(G) \\subset G.\nProof. by have [hZ ->] := ucn_pmap; apply: gFsub. Qed.",
    "Lemma morphim_ucn : GFunctor.pcontinuous (@upper_central_at n).\nProof. by have [hZ ->] := ucn_pmap; apply: pmorphimF. Qed.",
    "Lemma ucn_char : 'Z_n(G) \\char G. Proof. exact: gFchar. Qed.",
    "Lemma ucn_norm : G \\subset 'N('Z_n(G)). Proof. exact: gFnorm. Qed.",
    "Lemma ucn_normal : 'Z_n(G) <| G. Proof. exact: gFnormal. Qed.",
    "Lemma ucn0 A : 'Z_0(A) = 1.\nProof. by []. Qed.",
    "Lemma ucnSn n A : 'Z_n.+1(A) = coset 'Z_n(A) @*^-1 'Z(A / 'Z_n(A)).\nProof. by []. Qed.",
    "Lemma ucnE n A : 'Z_n(A) = iter n (fun B => coset B @*^-1 'Z(A / B)) 1.\nProof. by []. Qed.",
    "Lemma ucn_subS n G : 'Z_n(G) \\subset 'Z_n.+1(G).\nProof. by rewrite -{1}['Z_n(G)]ker_coset morphpreS ?sub1G. Qed.",
    "Lemma ucn_sub_geq m n G : n >= m -> 'Z_m(G) \\subset 'Z_n(G).\nProof.\nmove/subnK <-; elim: {n}(n - m) => // n IHn.\nexact: subset_trans (ucn_subS _ _).\nQed.",
    "Lemma ucn_central n G : 'Z_n.+1(G) / 'Z_n(G) = 'Z(G / 'Z_n(G)).\nProof. by rewrite ucnSn cosetpreK. Qed.",
    "Lemma ucn_normalS n G : 'Z_n(G) <| 'Z_n.+1(G).\nProof. by rewrite (normalS _ _ (ucn_normal n G)) ?ucn_subS ?ucn_sub. Qed.",
    "Lemma ucn_comm n G : [~: 'Z_n.+1(G), G] \\subset 'Z_n(G).\nProof.\nrewrite -quotient_cents2 ?normal_norm ?ucn_normal ?ucn_normalS //.\nby rewrite ucn_central subsetIr.\nQed.",
    "Lemma ucn1 G : 'Z_1(G) = 'Z(G).\nProof.\napply: (quotient_inj (normal1 _) (normal1 _)).\nby rewrite /= (ucn_central 0) -injmF ?norms1 ?coset1_injm.\nQed.",
    "Lemma ucnSnR n G : 'Z_n.+1(G) = [set x in G | [~: [set x], G] \\subset 'Z_n(G)].\nProof.\n\n\napply/setP=> x; rewrite -(setIidPr (ucn_sub n.+1 G)) [LHS]inE [RHS]inE ucnSn.\ncase Gx: (x \\in G) => //=; have nZG := ucn_norm n G.\nrewrite -sub1set -sub_quotient_pre -?quotient_cents2 ?sub1set ?(subsetP nZG) //.\nby rewrite subsetI quotientS ?sub1set.\nQed.",
    "Lemma ucn_cprod n A B G : A \\* B = G -> 'Z_n(A) \\* 'Z_n(B) = 'Z_n(G).\nProof.\ncase/cprodP=> [[H K -> ->{A B}] mulHK cHK].\nelim: n => [|n /cprodP[_ /= defZ cZn]]; first exact: cprod1g.\nset Z := 'Z_n(G) in defZ cZn; rewrite (ucnSn n G) /= -/Z.\nhave /mulGsubP[nZH nZK]: H * K \\subset 'N(Z) by rewrite mulHK gFnorm.\nhave <-: 'Z(H / Z) * 'Z(K / Z) = 'Z(G / Z).\n  by rewrite -mulHK quotientMl // center_prod ?quotient_cents.\nhave ZquoZ (B A : {group gT}):\n  B \\subset 'C(A) -> 'Z_n(A) * 'Z_n(B) = Z -> 'Z(A / Z) = 'Z_n.+1(A) / Z.\n- move=> cAB {}defZ; have cAZnB: 'Z_n(B) \\subset 'C(A) := gFsub_trans _ cAB.\n  have /second_isom[/=]: A \\subset 'N(Z).\n    by rewrite -defZ normsM ?gFnorm ?cents_norm // centsC.\n  suffices ->: Z :&: A = 'Z_n(A).\n    by move=> f inj_f im_f; rewrite -!im_f ?gFsub // ucn_central injm_center.\n  rewrite -defZ -group_modl ?gFsub //; apply/mulGidPl.\n  have [-> | n_gt0] := posnP n; first exact: subsetIl.\n  by apply: subset_trans (ucn_sub_geq A n_gt0); rewrite /= setIC ucn1 setIS.\nrewrite (ZquoZ H K) 1?centsC 1?(centC cZn) // {ZquoZ}(ZquoZ K H) //.\nhave cZn1: 'Z_n.+1(K) \\subset 'C('Z_n.+1(H)) by apply: centSS cHK; apply: gFsub.\nrewrite -quotientMl ?quotientK ?mul_subG ?gFsub_trans //=.\nrewrite cprodE // -cent_joinEr ?mulSGid //= cent_joinEr //= -/Z.\nby rewrite -defZ mulgSS ?ucn_subS.\nQed.",
    "Lemma ucn_dprod n A B G : A \\x B = G -> 'Z_n(A) \\x 'Z_n(B) = 'Z_n(G).\nProof.\nmove=> defG; have [[K H defA defB] _ _ tiAB] := dprodP defG.\nrewrite !dprodEcp // in defG *; first exact: ucn_cprod.\nby rewrite defA defB; apply/trivgP; rewrite -tiAB defA defB setISS ?ucn_sub.\nQed.",
    "Lemma ucn_bigcprod n I r P (F : I -> {set gT}) G :\n    \\big[cprod/1]_(i <- r | P i) F i = G ->\n  \\big[cprod/1]_(i <- r | P i) 'Z_n(F i) = 'Z_n(G).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first by rewrite gF1.\nby rewrite -(ucn_cprod n dG); have [[_ H _ dH]] := cprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma ucn_bigdprod n I r P (F : I -> {set gT}) G :\n    \\big[dprod/1]_(i <- r | P i) F i = G ->\n  \\big[dprod/1]_(i <- r | P i) 'Z_n(F i) = 'Z_n(G).\nProof.\nelim/big_rec2: _ G => [_ <- | i A Z _ IH G dG]; first by rewrite gF1.\nby rewrite -(ucn_dprod n dG); have [[_ H _ dH]] := dprodP dG; rewrite dH (IH H).\nQed.",
    "Lemma ucn_lcnP n G : ('L_n.+1(G) == 1) = ('Z_n(G) == G).\nProof.\nrewrite !eqEsubset sub1G ucn_sub /= andbT -(ucn0 G); set i := (n in LHS).\nhave: i + 0 = n by [rewrite addn0]; elim: i 0 => [j <- //|i IHi j].\nrewrite addSnnS => /IHi <- {IHi}; rewrite ucnSn lcnSn.\nrewrite -sub_morphim_pre ?gFsub_trans ?gFnorm_trans // subsetI.\nby rewrite morphimS ?gFsub // quotient_cents2 ?gFsub_trans ?gFnorm_trans.\nQed.",
    "Lemma ucnP G : reflect (exists n, 'Z_n(G) = G) (nilpotent G).\nProof.\napply: (iffP (lcnP G)) => -[n /eqP-clGn];\n  by exists n; apply/eqP; rewrite ucn_lcnP in clGn *.\nQed.",
    "Lemma ucn_nil_classP n G :\n  nilpotent G -> reflect ('Z_n(G) = G) (nil_class G <= n).\nProof.\nmove=> nilG; rewrite (sameP (lcn_nil_classP n nilG) eqP) ucn_lcnP; apply: eqP.\nQed.",
    "Lemma ucn_id n G : 'Z_n('Z_n(G)) = 'Z_n(G).\nProof. exact: gFid. Qed.",
    "Lemma ucn_nilpotent n G : nilpotent 'Z_n(G).\nProof. by apply/ucnP; exists n; rewrite ucn_id. Qed.",
    "Lemma nil_class_ucn n G : nil_class 'Z_n(G) <= n.\nProof. by apply/ucn_nil_classP; rewrite ?ucn_nilpotent ?ucn_id. Qed.",
    "Lemma morphim_lcn n G : G \\subset D -> f @* 'L_n(G) = 'L_n(f @* G).\nProof.\nmove=> sHG; case: n => //; elim=> // n IHn.\nby rewrite !lcnSn -IHn morphimR // (subset_trans _ sHG) // lcn_sub.\nQed.",
    "Lemma injm_ucn n G : 'injm f -> G \\subset D -> f @* 'Z_n(G) = 'Z_n(f @* G).\nProof. exact: injmF. Qed.",
    "Lemma morphim_nil G : nilpotent G -> nilpotent (f @* G).\nProof.\ncase/ucnP=> n ZnG; apply/ucnP; exists n; apply/eqP.\nby rewrite eqEsubset ucn_sub /= -{1}ZnG morphim_ucn.\nQed.",
    "Lemma injm_nil G : 'injm f -> G \\subset D -> nilpotent (f @* G) = nilpotent G.\nProof.\nmove=> injf sGD; apply/idP/idP; last exact: morphim_nil.\ncase/ucnP=> n; rewrite -injm_ucn // => /injm_morphim_inj defZ.\nby apply/ucnP; exists n; rewrite defZ ?gFsub_trans.\nQed.",
    "Lemma nil_class_morphim G : nilpotent G -> nil_class (f @* G) <= nil_class G.\nProof.\nmove=> nilG; rewrite (sameP (ucn_nil_classP _ (morphim_nil nilG)) eqP) /=.\nby rewrite eqEsubset ucn_sub -{1}(ucn_nil_classP _ nilG (leqnn _)) morphim_ucn.\nQed.",
    "Lemma nil_class_injm G :\n  'injm f -> G \\subset D -> nil_class (f @* G) = nil_class G.\nProof.\nmove=> injf sGD; case nilG: (nilpotent G).\n  apply/eqP; rewrite eqn_leq nil_class_morphim //.\n  rewrite (sameP (lcn_nil_classP _ nilG) eqP) -subG1.\n  rewrite -(injmSK injf) ?gFsub_trans // morphim1.\n  by rewrite morphim_lcn // (lcn_nil_classP _ _ (leqnn _)) //= injm_nil.\ntransitivity #|G|; apply/eqP; rewrite eqn_leq.\n  rewrite -(card_injm injf sGD) (leq_trans (index_size _ _)) ?size_mkseq //.\n  by rewrite leqNgt -nilpotent_class injm_nil ?nilG.\nrewrite (leq_trans (index_size _ _)) ?size_mkseq // leqNgt -nilpotent_class.\nby rewrite nilG.\nQed.",
    "Lemma quotient_ucn_add m n G : 'Z_(m + n)(G) / 'Z_n(G) = 'Z_m(G / 'Z_n(G)).\nProof.\nelim: m => [|m IHm]; first exact: trivg_quotient.\napply/setP=> Zx; have [x Nx ->{Zx}] := cosetP Zx.\nhave [sZG nZG] := andP (ucn_normal n G).\nrewrite (ucnSnR m) inE -!sub1set -morphim_set1 //= -quotientR ?sub1set // -IHm.\nrewrite !quotientSGK ?(ucn_sub_geq, leq_addl, comm_subG _ nZG, sub1set) //=.\nby rewrite addSn /= ucnSnR inE.\nQed.",
    "Lemma isog_nil rT G (L : {group rT}) : G \\isog L -> nilpotent G = nilpotent L.\nProof. by case/isogP=> f injf <-; rewrite injm_nil. Qed.",
    "Lemma isog_nil_class rT G (L : {group rT}) :\n  G \\isog L -> nil_class G = nil_class L.\nProof. by case/isogP=> f injf <-; rewrite nil_class_injm. Qed.",
    "Lemma quotient_nil G H : nilpotent G -> nilpotent (G / H).\nProof. exact: morphim_nil. Qed.",
    "Lemma quotient_center_nil G : nilpotent (G / 'Z(G)) = nilpotent G.\nProof.\nrewrite -ucn1; apply/idP/idP; last exact: quotient_nil.\ncase/ucnP=> c nilGq; apply/ucnP; exists c.+1; have nsZ1G := ucn_normal 1 G.\napply: (quotient_inj _ nsZ1G); last by rewrite /= -(addn1 c) quotient_ucn_add.\nby rewrite (normalS _ _ nsZ1G) ?ucn_sub ?ucn_sub_geq.\nQed.",
    "Lemma nil_class_quotient_center G :\n  nilpotent (G) -> nil_class (G / 'Z(G)) = (nil_class G).-1.\nProof.\nmove=> nilG; have nsZ1G := ucn_normal 1 G.\napply/eqP; rewrite -ucn1 eqn_leq; apply/andP; split.\n  apply/ucn_nil_classP; rewrite ?quotient_nil //= -quotient_ucn_add ucn1.\n  by rewrite (ucn_nil_classP _ _ _) ?addn1 ?leqSpred.\nrewrite -subn1 leq_subLR addnC; apply/ucn_nil_classP => //=.\napply: (quotient_inj _ nsZ1G) => /=.\n  by apply: normalS (ucn_sub _ _) nsZ1G; rewrite /= addnS ucn_sub_geq.\nby rewrite quotient_ucn_add; apply/ucn_nil_classP; rewrite //= quotient_nil.\nQed.",
    "Lemma nilpotent_sub_norm G H :\n  nilpotent G -> H \\subset G -> 'N_G(H) \\subset H -> G :=: H.\nProof.\nmove=> nilG sHG sNH; apply/eqP; rewrite eqEsubset sHG andbT; apply/negP=> nsGH.\nhave{nsGH} [i sZH []]: exists2 i, 'Z_i(G) \\subset H & ~ 'Z_i.+1(G) \\subset H.\n  case/ucnP: nilG => n ZnG; rewrite -{}ZnG in nsGH.\n  elim: n => [|i IHi] in nsGH *; first by rewrite sub1G in nsGH.\n  by case sZH: ('Z_i(G) \\subset H); [exists i | apply: IHi; rewrite sZH].\napply: subset_trans sNH; rewrite subsetI ucn_sub -commg_subr.\nby apply: subset_trans sZH; apply: subset_trans (ucn_comm i G); apply: commgS.\nQed.",
    "Lemma nilpotent_proper_norm G H :\n  nilpotent G -> H \\proper G -> H \\proper 'N_G(H).\nProof.\nmove=> nilG; rewrite properEneq properE subsetI normG => /andP[neHG sHG].\nby rewrite sHG; apply: contra neHG => /(nilpotent_sub_norm nilG)->.\nQed.",
    "Lemma nilpotent_subnormal G H : nilpotent G -> H \\subset G -> H <|<| G.\nProof.\nmove=> nilG; have [m] := ubnP (#|G| - #|H|).\nelim: m H => // m IHm H /ltnSE-leGHm sHG.\nhave [->|] := eqVproper sHG; first exact: subnormal_refl.\nmove/(nilpotent_proper_norm nilG); set K := 'N_G(H) => prHK.\nhave snHK: H <|<| K by rewrite normal_subnormal ?normalSG.\nhave sKG: K \\subset G by rewrite subsetIl.\napply: subnormal_trans snHK (IHm _ (leq_trans _ leGHm) sKG).\nby rewrite ltn_sub2l ?proper_card ?(proper_sub_trans prHK).\nQed.",
    "Lemma TI_center_nil G H : nilpotent G -> H <| G -> H :&: 'Z(G) = 1 -> H :=: 1.\nProof.\nmove=> nilG /andP[sHG nHG] tiHZ.\nrewrite -{1}(setIidPl sHG); have{nilG} /ucnP[n <-] := nilG.\nelim: n => [|n IHn]; apply/trivgP; rewrite ?subsetIr // -tiHZ.\nrewrite [H :&: 'Z(G)]setIA subsetI setIS ?ucn_sub //= (sameP commG1P trivgP).\nrewrite -commg_subr commGC in nHG.\nrewrite -IHn subsetI (subset_trans _ nHG) ?commSg ?subsetIl //=.\nby rewrite (subset_trans _ (ucn_comm n G)) ?commSg ?subsetIr.\nQed.",
    "Lemma meet_center_nil G H :\n  nilpotent G -> H <| G -> H :!=: 1 -> H :&: 'Z(G) != 1.\nProof. by move=> nilG nsHG; apply: contraNneq => /TI_center_nil->. Qed.",
    "Lemma center_nil_eq1 G : nilpotent G -> ('Z(G) == 1) = (G :==: 1).\nProof.\nmove=> nilG; apply/eqP/eqP=> [Z1 | ->]; last exact: center1.\nby rewrite (TI_center_nil nilG) // (setIidPr (center_sub G)).\nQed.",
    "Lemma cyclic_nilpotent_quo_der1_cyclic G :\n  nilpotent G -> cyclic (G / G^`(1)) -> cyclic G.\nProof.\nmove=> nG; rewrite (isog_cyclic (quotient1_isog G)).\nhave [-> // | ntG' cGG'] := (eqVneq G^`(1) 1)%g.\nsuffices: 'L_2(G) \\subset G :&: 'L_3(G) by move/(eqfun_inP nG)=> <-.\nrewrite subsetI lcn_sub /= -quotient_cents2 ?lcn_norm //.\napply: cyclic_factor_abelian (lcn_central 2 G) _.\nby rewrite (isog_cyclic (third_isog _ _ _)) ?lcn_normal // lcn_subS.\nQed.",
    "Lemma nilpotent_sol G : nilpotent G -> solvable G.\nProof.\nmove=> nilG; apply/forall_inP=> H /subsetIP[sHG sHH'].\nby rewrite (forall_inP nilG) // subsetI sHG (subset_trans sHH') ?commgS.\nQed.",
    "Lemma abelian_sol G : abelian G -> solvable G.\nProof. by move/abelian_nil/nilpotent_sol. Qed.",
    "Lemma solvable1 : solvable [1 gT]. Proof. exact: abelian_sol (abelian1 gT). Qed.",
    "Lemma solvableS G H : H \\subset G -> solvable G -> solvable H.\nProof.\nmove=> sHG solG; apply/forall_inP=> K /subsetIP[sKH sKK'].\nby rewrite (forall_inP solG) // subsetI (subset_trans sKH).\nQed.",
    "Lemma sol_der1_proper G H :\n  solvable G -> H \\subset G -> H :!=: 1 -> H^`(1) \\proper H.\nProof.\nmove=> solG sHG ntH; rewrite properE comm_subG //; apply: implyP ntH.\nby have:= forallP solG H; rewrite subsetI sHG implybNN.\nQed.",
    "Lemma derivedP G : reflect (exists n, G^`(n) = 1) (solvable G).\nProof.\napply: (iffP idP) => [solG | [n solGn]]; last first.\n  apply/forall_inP=> H /subsetIP[sHG sHH'].\n  rewrite -subG1 -{}solGn; elim: n => // n IHn.\n  exact: subset_trans sHH' (commgSS _ _).\nsuffices IHn n: #|G^`(n)| <= (#|G|.-1 - n).+1.\n  by exists #|G|.-1; rewrite [G^`(_)]card_le1_trivg ?(leq_trans (IHn _)) ?subnn.\nelim: n => [|n IHn]; first by rewrite subn0 prednK.\nrewrite dergSn subnS -ltnS.\nhave [-> | ntGn] := eqVneq G^`(n) 1; first by rewrite commG1 cards1.\ncase: (_ - _) IHn => [|n']; first by rewrite leqNgt cardG_gt1 ntGn.\nby apply: leq_trans (proper_card _); apply: sol_der1_proper (der_sub _ _) _.\nQed.",
    "Lemma morphim_sol : solvable G -> solvable (f @* G).\nProof.\nmove/(solvableS (subsetIr D G)); case/derivedP=> n Gn1; apply/derivedP.\nby exists n; rewrite /= -morphimIdom -morphim_der ?subsetIl // Gn1 morphim1.\nQed.",
    "Lemma injm_sol : 'injm f -> G \\subset D -> solvable (f @* G) = solvable G.\nProof.\nmove=> injf sGD; apply/idP/idP; last exact: morphim_sol.\ncase/derivedP=> n Gn1; apply/derivedP; exists n; apply/trivgP.\nby rewrite -(injmSK injf) ?gFsub_trans ?morphim_der // Gn1 morphim1.\nQed.",
    "Lemma isog_sol G (L : {group rT}) : G \\isog L -> solvable G = solvable L.\nProof. by case/isogP=> f injf <-; rewrite injm_sol. Qed.",
    "Lemma quotient_sol G H : solvable G -> solvable (G / H).\nProof. exact: morphim_sol. Qed.",
    "Lemma series_sol G H : H <| G -> solvable G = solvable H && solvable (G / H).\nProof.\ncase/andP=> sHG nHG; apply/idP/andP=> [solG | [solH solGH]].\n  by rewrite quotient_sol // (solvableS sHG).\napply/forall_inP=> K /subsetIP[sKG sK'K].\nsuffices sKH: K \\subset H by rewrite (forall_inP solH) // subsetI sKH.\nhave nHK := subset_trans sKG nHG.\nrewrite -quotient_sub1 // subG1 (forall_inP solGH) //.\nby rewrite subsetI -morphimR ?morphimS.\nQed.",
    "Lemma metacyclic_sol G : metacyclic G -> solvable G.\nProof.\ncase/metacyclicP=> K [cycK nsKG cycGq].\nby rewrite (series_sol nsKG) !abelian_sol ?cyclic_abelian.\nQed.",
    "Lemma setXn_sol n (gT : 'I_n -> finGroupType) (G : forall i, {group gT i}) :\n  (forall i, solvable (G i)) -> solvable (setXn G).\nProof.\nelim: n => [|n IHn] in gT G * => solG; first by rewrite groupX0 solvable1.\npose gT' (i : 'I_n) := gT (lift ord0 i).\npose prod_group_gT := [the finGroupType of {dffun forall i, gT i}].\npose prod_group_gT' := [the finGroupType of {dffun forall i, gT' i}].\npose f (x : prod_group_gT) : prod_group_gT' := [ffun i => x (lift ord0 i)].\nhave fm : morphic (setXn G) f.\n  apply/'forall_implyP => -[a b]; rewrite !inE/=.\n  by move=> /andP[/forallP aG /forallP bG]; apply/eqP/ffunP => i; rewrite !ffunE.\nrewrite (@series_sol _ [group of setXn G] ('ker (morphm fm))) ?ker_normal//=.\nrewrite (isog_sol (first_isog _))/=.\nhave -> : (morphm fm @* setXn G)%g = setXn (fun i => G (lift ord0 i)).\n  apply/setP => v; rewrite !inE morphimEdom; apply/idP/forallP => /=.\n    move=> /imsetP[/=x]; rewrite inE => /forallP/= xG ->.\n    by move=> i; rewrite morphmE ffunE xG.\n  move=> vG; apply/imsetP.\n  pose w := [ffun i : 'I_n.+1 =>\n             match unliftP ord0 i return (gT i) : Type with\n             | UnliftSome j i_eq => ecast i (gT i) (esym i_eq) (v j)\n             | UnliftNone i0 => 1%g\n             end].\n  have wl i : w (lift ord0 i) = v i.\n    rewrite ffunE; case: unliftP => //= j elij.\n    have eij : i = j by case: elij; apply/val_inj.\n    by rewrite [elij](eq_irrelevance _ (congr1 _ eij)); case: _ / eij.\n  have w0 : w ord0 = 1%g by rewrite ffunE; case: unliftP.\n  exists w; last by apply/ffunP => i; rewrite morphmE ffunE/= wl.\n  apply/setXnP => i.\n  case: (unliftP ord0 i) => [j|]->; rewrite ?wl ?w0 ?vG//.\nrewrite IHn ?andbT//; last by move=> i; apply: solG.\npose k (x : gT ord0) : prod_group_gT :=\n  [ffun i : 'I_n.+1 =>\n     match (ord0 =P i) return (gT i) : Type with\n     | ReflectT P => ecast i (gT i) P x\n     | _ => 1%g\n     end].\nhave km : morphic (G ord0) k.\n  apply/'forall_implyP => -[a b]; rewrite !inE/= => /andP[aG bG].\n  apply/eqP/ffunP => i; rewrite !ffunE; case: eqP => //; rewrite ?mulg1//.\n  by case: _ /.\nsuff -> : ('ker (morphm fm) = morphm km @* G ord0)%g by rewrite morphim_sol.\napply/setP => x; rewrite morphimEdom; apply/idP/imsetP => [xker|].\n  exists (x ord0).\n     by have := dom_ker xker; rewrite inE => /forallP/(_ ord0).\n  rewrite /= morphmE; apply/ffunP => i; rewrite ffunE; case: eqP => //=.\n    by case: _ /.\n  move/eqP; rewrite eq_sym; have /mker/= := xker; rewrite morphmE => /ffunP.\n  by case: (@unliftP _ ord0 i) => [j|] ->//= /(_ j); rewrite !ffunE.\nmove=> [x0 xG0 -> /=]; rewrite morphmE; apply/kerP; rewrite ?inE.\n  by apply/forallP => i; rewrite ffunE; case: eqP => //=; case: _ /.\nby rewrite /= morphmE; apply/ffunP => i; rewrite !ffunE; case: eqP.\nQed.",
    "Lemma leEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <=^d y :> T^d) = (y <= x).\nProof. by []. Qed.",
    "Lemma ltEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <^d y :> T^d) = (y < x).\nProof. by []. Qed.",
    "Lemma botEdual d (T : tPOrderType d) : (dual_bottom : T^d) = \\top :> T.\nProof. by []. Qed.",
    "Lemma topEdual d (T : bPOrderType d) : (dual_top : T^d) = \\bot :> T.\nProof. by []. Qed.",
    "Lemma meetEdual d (T : joinSemilatticeType d) (x y : T) :\n  ((x : T^d) `&^d` y) = (x `|` y).\nProof. by []. Qed.",
    "Lemma joinEdual d (T : meetSemilatticeType d) (x y : T) :\n  ((x : T^d) `|^d` y) = (x `&` y).\nProof. by []. Qed.",
    "Lemma geE x y : ge x y = (y <= x). Proof. by []. Qed.",
    "Lemma gtE x y : gt x y = (y < x). Proof. by []. Qed.",
    "Lemma lexx (x : T) : x <= x.\nProof. exact: le_refl. Qed.",
    "Lemma le_anti: antisymmetric (<=%O : rel T).\nProof. exact: le_anti. Qed.",
    "Lemma ge_anti: antisymmetric (>=%O : rel T).\nProof. exact: ge_anti. Qed.",
    "Lemma le_trans: transitive (<=%O : rel T).\nProof. exact: le_trans. Qed.",
    "Lemma ge_trans: transitive (>=%O : rel T).\nProof. by move=> ? ? ? ? /le_trans; apply. Qed.",
    "Lemma le_le_trans x y z t : z <= x -> y <= t -> x <= y -> z <= t.\nProof. by move=> + /(le_trans _)/[apply]; apply: le_trans. Qed.",
    "Lemma lt_def x y: (x < y) = (y != x) && (x <= y).\nProof. exact: lt_def. Qed.",
    "Lemma lt_neqAle x y: (x < y) = (x != y) && (x <= y).\nProof. by rewrite lt_def eq_sym. Qed.",
    "Lemma ltxx x: x < x = false.\nProof. by rewrite lt_def eqxx. Qed.",
    "Lemma le_eqVlt x y: (x <= y) = (x == y) || (x < y).\nProof. by rewrite lt_neqAle; case: eqP => //= ->; rewrite lexx. Qed.",
    "Lemma lt_eqF x y: x < y -> x == y = false.\nProof. by rewrite lt_neqAle => /andP [/negbTE->]. Qed.",
    "Lemma gt_eqF x y : y < x -> x == y = false.\nProof. by rewrite lt_def; case: eqP. Qed.",
    "Lemma eq_le x y: (x == y) = (x <= y <= x).\nProof. by apply/eqP/idP => [->|/le_anti]; rewrite ?lexx. Qed.",
    "Lemma ltW x y: x < y -> x <= y.\nProof. by rewrite le_eqVlt orbC => ->. Qed.",
    "Lemma lt_le_trans y x z: x < y -> y <= z -> x < z.\nProof.\nrewrite !lt_neqAle => /andP [nexy lexy leyz]; rewrite (le_trans lexy) // andbT.\nby apply: contraNneq nexy => eqxz; rewrite eqxz eq_le leyz andbT in lexy *.\nQed.",
    "Lemma lt_trans: transitive (<%O : rel T).\nProof. by move=> y x z le1 /ltW le2; apply/(@lt_le_trans y). Qed.",
    "Lemma le_lt_trans y x z: x <= y -> y < z -> x < z.\nProof. by rewrite le_eqVlt => /orP [/eqP ->|/lt_trans t /t]. Qed.",
    "Lemma lt_nsym x y : x < y -> y < x -> False.\nProof. by move=> xy /(lt_trans xy); rewrite ltxx. Qed.",
    "Lemma lt_asym x y : x < y < x = false.\nProof. by apply/negP => /andP []; apply: lt_nsym. Qed.",
    "Lemma le_gtF x y: x <= y -> y < x = false.\nProof.\nby move=> le_xy; apply/negP => /lt_le_trans /(_ le_xy); rewrite ltxx.\nQed.",
    "Lemma lt_geF x y : x < y -> y <= x = false.\nProof. by apply: contraTF => /le_gtF ->. Qed.",
    "Lemma lt_leAnge x y : (x < y) = (x <= y) && ~~ (y <= x).\nProof.\napply/idP/idP => [ltxy|/andP[lexy Nleyx]]; first by rewrite ltW // lt_geF.\nby rewrite lt_neqAle lexy andbT; apply: contraNneq Nleyx => ->.\nQed.",
    "Lemma lt_le_asym x y : x < y <= x = false.\nProof. by rewrite lt_neqAle -andbA -eq_le eq_sym andNb. Qed.",
    "Lemma le_lt_asym x y : x <= y < x = false.\nProof. by rewrite andbC lt_le_asym. Qed.",
    "Lemma le_path_min x s : path <=%O x s -> all (>= x) s.\nProof. exact/order_path_min/le_trans. Qed.",
    "Lemma lt_path_min x s : path <%O x s -> all (> x) s.\nProof. exact/order_path_min/lt_trans. Qed.",
    "Lemma le_path_sortedE x s : path <=%O x s = all (>= x) s && sorted <=%O s.\nProof. exact/path_sortedE/le_trans. Qed.",
    "Lemma lt_path_sortedE x s : path <%O x s = all (> x) s && sorted <%O s.\nProof. exact/path_sortedE/lt_trans. Qed.",
    "Lemma le_sorted_pairwise s : sorted <=%O s = pairwise <=%O s.\nProof. exact/sorted_pairwise/le_trans. Qed.",
    "Lemma lt_sorted_pairwise s : sorted <%O s = pairwise <%O s.\nProof. exact/sorted_pairwise/lt_trans. Qed.",
    "Lemma le_path_pairwise x s : path <=%O x s = pairwise <=%O (x :: s).\nProof. exact/path_pairwise/le_trans. Qed.",
    "Lemma lt_path_pairwise x s : path <%O x s = pairwise <%O (x :: s).\nProof. exact/path_pairwise/lt_trans. Qed.",
    "Lemma lt_sorted_uniq_le s : sorted <%O s = uniq s && sorted <=%O s.\nProof.\nrewrite le_sorted_pairwise lt_sorted_pairwise uniq_pairwise -pairwise_relI.\nby apply/eq_pairwise => ? ?; rewrite lt_neqAle.\nQed.",
    "Lemma le_sorted_mask m s : sorted <=%O s -> sorted <=%O (mask m s).\nProof. exact/sorted_mask/le_trans. Qed.",
    "Lemma lt_sorted_mask m s : sorted <%O s -> sorted <%O (mask m s).\nProof. exact/sorted_mask/lt_trans. Qed.",
    "Lemma le_sorted_filter a s : sorted <=%O s -> sorted <=%O (filter a s).\nProof. exact/sorted_filter/le_trans. Qed.",
    "Lemma lt_sorted_filter a s : sorted <%O s -> sorted <%O (filter a s).\nProof. exact/sorted_filter/lt_trans. Qed.",
    "Lemma le_path_mask x m s : path <=%O x s -> path <=%O x (mask m s).\nProof. exact/path_mask/le_trans. Qed.",
    "Lemma lt_path_mask x m s : path <%O x s -> path <%O x (mask m s).\nProof. exact/path_mask/lt_trans. Qed.",
    "Lemma le_path_filter x a s : path <=%O x s -> path <=%O x (filter a s).\nProof. exact/path_filter/le_trans. Qed.",
    "Lemma lt_path_filter x a s : path <%O x s -> path <%O x (filter a s).\nProof. exact/path_filter/lt_trans. Qed.",
    "Lemma le_sorted_ltn_nth (x0 : T) (s : seq T) : sorted <=%O s ->\n {in [pred n | (n < size s)%N] &,\n    {homo nth x0 s : i j / (i < j)%N >-> i <= j}}.\nProof. exact/sorted_ltn_nth/le_trans. Qed.",
    "Lemma le_sorted_leq_nth (x0 : T) (s : seq T) : sorted <=%O s ->\n  {in [pred n | (n < size s)%N] &,\n    {homo nth x0 s : i j / (i <= j)%N >-> i <= j}}.\nProof. exact/sorted_leq_nth/le_refl/le_trans. Qed.",
    "Lemma lt_sorted_leq_nth (x0 : T) (s : seq T) : sorted <%O s ->\n  {in [pred n | (n < size s)%N] &,\n    {mono nth x0 s : i j / (i <= j)%N >-> i <= j}}.\nProof.\nrewrite lt_sorted_uniq_le => /andP[s_uniq le_s].\napply: (total_homo_mono_in _ _ ltn_neqAle lt_neqAle le_anti leq_total) => //.\nmove=> i j ilt jlt ltij; rewrite lt_neqAle le_sorted_leq_nth// 1?ltnW//.\nby rewrite nth_uniq// ltn_eqF.\nQed.",
    "Lemma lt_sorted_ltn_nth (x0 : T) (s : seq T) : sorted <%O s ->\n  {in [pred n | (n < size s)%N] &,\n    {mono nth x0 s : i j / (i < j)%N >-> i < j}}.\nProof.\nmove=> ss; have := lt_sorted_leq_nth x0 ss.\nexact: (anti_mono_in _ ltn_neqAle lt_neqAle anti_leq).\nQed.",
    "Lemma subseq_le_path x s1 s2 : subseq s1 s2 -> path <=%O x s2 -> path <=%O x s1.\nProof. exact/subseq_path/le_trans. Qed.",
    "Lemma subseq_lt_path x s1 s2 : subseq s1 s2 -> path <%O x s2 -> path <%O x s1.\nProof. exact/subseq_path/lt_trans. Qed.",
    "Lemma subseq_le_sorted s1 s2 : subseq s1 s2 -> sorted <=%O s2 -> sorted <=%O s1.\nProof. exact/subseq_sorted/le_trans. Qed.",
    "Lemma subseq_lt_sorted s1 s2 : subseq s1 s2 -> sorted <%O s2 -> sorted <%O s1.\nProof. exact/subseq_sorted/lt_trans. Qed.",
    "Lemma lt_sorted_uniq s : sorted <%O s -> uniq s.\nProof. exact/sorted_uniq/ltxx/lt_trans. Qed.",
    "Lemma lt_sorted_eq s1 s2 :\n  sorted <%O s1 -> sorted <%O s2 -> s1 =i s2 -> s1 = s2.\nProof. exact/irr_sorted_eq/ltxx/lt_trans. Qed.",
    "Lemma le_sorted_eq s1 s2 :\n  sorted <=%O s1 -> sorted <=%O s2 -> perm_eq s1 s2 -> s1 = s2.\nProof. exact/sorted_eq/le_anti/le_trans. Qed.",
    "Lemma filter_lt_nth x0 s i : sorted <%O s -> (i < size s)%N ->\n  [seq x <- s | x < nth x0 s i] = take i s.\nProof.\nmove=> ss i_lt/=; rewrite -[X in filter _ X](mkseq_nth x0) filter_map.\nunder eq_in_filter => j do\n  [rewrite ?mem_iota => j_s /=; rewrite lt_sorted_ltn_nth//].\nby rewrite (filter_iota_ltn 0) ?map_nth_iota0 // ltnW.\nQed.",
    "Lemma count_lt_nth x0 s i : sorted <%O s -> (i < size s)%N ->\n  count (< nth x0 s i) s = i.\nProof.\nby move=> ss i_lt; rewrite -size_filter/= filter_lt_nth// size_take i_lt.\nQed.",
    "Lemma filter_le_nth x0 s i : sorted <%O s -> (i < size s)%N ->\n  [seq x <- s | x <= nth x0 s i] = take i.+1 s.\nProof.\nmove=> ss i_lt/=; rewrite -[X in filter _ X](mkseq_nth x0) filter_map.\nunder eq_in_filter => j do\n  [rewrite ?mem_iota => j_s /=; rewrite lt_sorted_leq_nth//].\nby rewrite (filter_iota_leq 0)// map_nth_iota0.\nQed.",
    "Lemma count_le_nth x0 s i : sorted <%O s -> (i < size s)%N ->\n  count (<= nth x0 s i) s = i.+1.\nProof.\nby move=> ss i_lt; rewrite -size_filter/= filter_le_nth// size_takel.\nQed.",
    "Lemma count_lt_le_mem x s : (count (< x) s < count (<= x) s)%N = (x \\in s).\nProof.\nhave := count_predUI (pred1 x) (< x) s.\nhave -> : count (predI (pred1 x) (< x)) s = 0%N.\n  rewrite (@eq_count _ _ pred0) ?count_pred0 // => y /=.\n  by rewrite lt_def; case: eqP => //= ->; rewrite eqxx.\nhave /eq_count-> : [predU1 x & < x] =1 (<= x) by move=> y /=; rewrite le_eqVlt.\nby rewrite addn0 => ->; rewrite -add1n leq_add2r -has_count has_pred1.\nQed.",
    "Lemma sorted_filter_lt x s :\n  sorted <=%O s -> [seq y <- s | y < x] = take (count (< x) s) s.\nProof.\nelim: s => [//|y s IHs]/=; rewrite (path_sortedE le_trans) => /andP[le_y_s ss].\ncase: ifP => [|ltyxF]; rewrite IHs//.\nrewrite (@eq_in_count _ _ pred0) ?count_pred0/= ?take0// => z.\nby move=> /(allP le_y_s) yz; apply: contraFF ltyxF; apply: le_lt_trans.\nQed.",
    "Lemma sorted_filter_le x s :\n  sorted <=%O s -> [seq y <- s | y <= x] = take (count (<= x) s) s.\nProof.\nelim: s => [//|y s IHs]/=; rewrite (path_sortedE le_trans) => /andP[le_y_s ss].\ncase: ifP => [|leyxF]; rewrite IHs//.\nrewrite (@eq_in_count _ _ pred0) ?count_pred0/= ?take0// => z.\nby move=> /(allP le_y_s) yz; apply: contraFF leyxF; apply: le_trans.\nQed.",
    "Lemma nth_count_le x x0 s i : sorted <=%O s ->\n  (i < count (<= x) s)%N -> nth x0 s i <= x.\nProof.\nmove=> ss iltc; rewrite -(nth_take _ iltc) -sorted_filter_le //.\nby apply/(all_nthP _ (filter_all (<= x) _)); rewrite size_filter.\nQed.",
    "Lemma nth_count_lt x x0 s i : sorted <=%O s ->\n  (i < count (< x) s)%N -> nth x0 s i < x.\nProof.\nmove=> ss iltc; rewrite -(nth_take _ iltc) -sorted_filter_lt //.\nby apply/(all_nthP _ (filter_all (< x) _)); rewrite size_filter.\nQed.",
    "Lemma sort_le_id s : sorted <=%O s -> sort <=%O s = s.\nProof. exact/sorted_sort/le_trans. Qed.",
    "Lemma sort_lt_id s : sorted <%O s -> sort <%O s = s.\nProof. exact/sorted_sort/lt_trans. Qed.",
    "Lemma comparable_leNgt x y : x >=< y -> (x <= y) = ~~ (y < x).\nProof.\nmove=> c_xy; apply/idP/idP => [/le_gtF/negP/negP//|]; rewrite lt_neqAle.\nby move: c_xy => /orP [] -> //; rewrite andbT negbK => /eqP ->.\nQed.",
    "Lemma comparable_ltNge x y : x >=< y -> (x < y) = ~~ (y <= x).\nProof.\nmove=> c_xy; apply/idP/idP => [/lt_geF/negP/negP//|].\nby rewrite lt_neqAle eq_le; move: c_xy => /orP [] -> //; rewrite andbT.\nQed.",
    "Lemma comparable_ltgtP x y : x >=< y ->\n  compare x y (min y x) (min x y) (max y x) (max x y)\n  (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y).\nProof.\nrewrite /min /max />=<%O !le_eqVlt [y == x]eq_sym.\nhave := (eqVneq x y, (boolP (x < y), boolP (y < x))).\nmove=> [[->//|neq_xy /=] [[] xy [] //=]] ; do ?by rewrite ?ltxx; constructor.\n  by rewrite ltxx in xy.\nby rewrite le_gtF // ltW.\nQed.",
    "Lemma comparable_leP x y : x >=< y ->\n  le_xor_gt x y (min y x) (min x y) (max y x) (max x y) (x <= y) (y < x).\nProof. by move=> /comparable_ltgtP [?|?|->]; constructor; rewrite // ltW. Qed.",
    "Lemma comparable_ltP x y : x >=< y ->\n  lt_xor_ge x y (min y x) (min x y) (max y x) (max x y) (y <= x) (x < y).\nProof. by move=> /comparable_ltgtP [?|?|->]; constructor; rewrite // ltW. Qed.",
    "Lemma comparable_sym x y : (y >=< x) = (x >=< y).\nProof. by rewrite /comparable orbC. Qed.",
    "Lemma comparablexx x : x >=< x.\nProof. by rewrite /comparable lexx. Qed.",
    "Lemma incomparable_eqF x y : (x >< y) -> (x == y) = false.\nProof. by apply: contraNF => /eqP ->; rewrite comparablexx. Qed.",
    "Lemma incomparable_leF x y : (x >< y) -> (x <= y) = false.\nProof. by apply: contraNF; rewrite /comparable => ->. Qed.",
    "Lemma incomparable_ltF x y : (x >< y) -> (x < y) = false.\nProof. by rewrite lt_neqAle => /incomparable_leF ->; rewrite andbF. Qed.",
    "Lemma comparableP x y : incompare x y\n  (min y x) (min x y) (max y x) (max x y)\n  (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y)\n  (y >=< x) (x >=< y).\nProof.\nrewrite ![y >=< _]comparable_sym; have [c_xy|i_xy] := boolP (x >=< y).\n  by case: (comparable_ltgtP c_xy) => ?; constructor.\nby rewrite /min /max ?incomparable_eqF ?incomparable_leF;\n   rewrite ?incomparable_ltF// 1?comparable_sym //; constructor.\nQed.",
    "Lemma le_comparable (x y : T) : x <= y -> x >=< y.\nProof. by case: comparableP. Qed.",
    "Lemma lt_comparable (x y : T) : x < y -> x >=< y.\nProof. by case: comparableP. Qed.",
    "Lemma ge_comparable (x y : T) : y <= x -> x >=< y.\nProof. by case: comparableP. Qed.",
    "Lemma gt_comparable (x y : T) : y < x -> x >=< y.\nProof. by case: comparableP. Qed.",
    "Lemma leifP x y C : reflect (x <= y ?= iff C) (if C then x == y else x < y).\nProof.\nrewrite /leif le_eqVlt; apply: (iffP idP)=> [|[]].\n  by case: C => [/eqP->|lxy]; rewrite ?eqxx // lxy lt_eqF.\nby move=> /orP[/eqP->|lxy] <-; rewrite ?eqxx // lt_eqF.\nQed.",
    "Lemma leif_refl x C : reflect (x <= x ?= iff C) C.\nProof. by apply: (iffP idP) => [-> | <-] //; split; rewrite ?eqxx. Qed.",
    "Lemma leif_trans x1 x2 x3 C12 C23 :\n  x1 <= x2 ?= iff C12 -> x2 <= x3 ?= iff C23 -> x1 <= x3 ?= iff C12 && C23.\nProof.\nmove=> ltx12 ltx23; apply/leifP; rewrite -ltx12.\ncase eqx12: (x1 == x2).\n  by rewrite (eqP eqx12) lt_neqAle !ltx23 andbT; case C23.\nby rewrite (@lt_le_trans x2) ?ltx23 // lt_neqAle eqx12 ltx12.\nQed.",
    "Lemma leif_le x y : x <= y -> x <= y ?= iff (x >= y).\nProof. by move=> lexy; split=> //; rewrite eq_le lexy. Qed.",
    "Lemma leif_eq x y : x <= y -> x <= y ?= iff (x == y).\nProof. by []. Qed.",
    "Lemma ge_leif x y C : x <= y ?= iff C -> (y <= x) = C.\nProof. by case=> le_xy; rewrite eq_le le_xy. Qed.",
    "Lemma lt_leif x y C : x <= y ?= iff C -> (x < y) = ~~ C.\nProof. by move=> le_xy; rewrite lt_neqAle !le_xy andbT. Qed.",
    "Lemma ltNleif x y C : x <= y ?= iff ~~ C -> (x < y) = C.\nProof. by move=> /lt_leif; rewrite negbK. Qed.",
    "Lemma eq_leif x y C : x <= y ?= iff C -> (x == y) = C.\nProof. by move=> /leifP; case: C comparableP => [] []. Qed.",
    "Lemma eqTleif x y C : x <= y ?= iff C -> C -> x = y.\nProof. by move=> /eq_leif<-/eqP. Qed.",
    "Lemma lteif_trans x y z C1 C2 :\n  x < y ?<= if C1 -> y < z ?<= if C2 -> x < z ?<= if C1 && C2.\nProof.\ncase: C1 C2 => [][];\n  [exact: le_trans | exact: le_lt_trans | exact: lt_le_trans | exact: lt_trans].\nQed.",
    "Lemma lteif_anti C1 C2 x y :\n  (x < y ?<= if C1) && (y < x ?<= if C2) = C1 && C2 && (x == y).\nProof. by case: C1 C2 => [][]; rewrite lte_anti. Qed.",
    "Lemma lteifxx x C : (x < x ?<= if C) = C.\nProof. by case: C; rewrite /= ltexx. Qed.",
    "Lemma lteifNF x y C : y < x ?<= if ~~ C -> x < y ?<= if C = false.\nProof. by case: C => [/lt_geF|/le_gtF]. Qed.",
    "Lemma lteifS x y C : x < y -> x < y ?<= if C.\nProof. by case: C => //= /ltW. Qed.",
    "Lemma lteifT x y : x < y ?<= if true = (x <= y). Proof. by []. Qed.",
    "Lemma lteifF x y : x < y ?<= if false = (x < y). Proof. by []. Qed.",
    "Lemma lteif_orb x y : {morph lteif x y : p q / p || q}.\nProof. by case=> [][] /=; case: comparableP. Qed.",
    "Lemma lteif_andb x y : {morph lteif x y : p q / p && q}.\nProof. by case=> [][] /=; case: comparableP. Qed.",
    "Lemma lteif_imply C1 C2 x y : C1 ==> C2 -> x < y ?<= if C1 -> x < y ?<= if C2.\nProof. by case: C1 C2 => [][] //= _ /ltW. Qed.",
    "Lemma lteifW C x y : x < y ?<= if C -> x <= y.\nProof. by case: C => // /ltW. Qed.",
    "Lemma ltrW_lteif C x y : x < y -> x < y ?<= if C.\nProof. by case: C => // /ltW. Qed.",
    "Lemma lteifN C x y : x < y ?<= if ~~ C -> ~~ (y < x ?<= if C).\nProof. by case: C => /=; case: comparableP. Qed.",
    "Lemma minElt x y : min x y = if x < y then x else y. Proof. by []. Qed.",
    "Lemma maxElt x y : max x y = if x < y then y else x. Proof. by []. Qed.",
    "Lemma minEle x y : min x y = if x <= y then x else y.\nProof. by case: comparableP. Qed.",
    "Lemma maxEle x y : max x y = if x <= y then y else x.\nProof. by case: comparableP. Qed.",
    "Lemma comparable_minEgt x y : x >=< y -> min x y = if x > y then y else x.\nProof. by case: comparableP. Qed.",
    "Lemma comparable_maxEgt x y : x >=< y -> max x y = if x > y then x else y.\nProof. by case: comparableP. Qed.",
    "Lemma comparable_minEge x y : x >=< y -> min x y = if x >= y then y else x.\nProof. by case: comparableP. Qed.",
    "Lemma comparable_maxEge x y : x >=< y -> max x y = if x >= y then x else y.\nProof. by case: comparableP. Qed.",
    "Lemma min_l x y : x <= y -> min x y = x. Proof. by case: comparableP. Qed.",
    "Lemma min_r x y : y <= x -> min x y = y. Proof. by case: comparableP. Qed.",
    "Lemma max_l x y : y <= x -> max x y = x. Proof. by case: comparableP. Qed.",
    "Lemma max_r x y : x <= y -> max x y = y. Proof. by case: comparableP. Qed.",
    "Lemma minxx : idempotent_op (min : T -> T -> T).\nProof. by rewrite /min => x; rewrite ltxx. Qed.",
    "Lemma maxxx : idempotent_op (max : T -> T -> T).\nProof. by rewrite /max => x; rewrite ltxx. Qed.",
    "Lemma eq_minl x y : (min x y == x) = (x <= y).\nProof. by rewrite !(fun_if, if_arg) eqxx; case: comparableP. Qed.",
    "Lemma eq_maxr x y : (max x y == y) = (x <= y).\nProof. by rewrite !(fun_if, if_arg) eqxx; case: comparableP. Qed.",
    "Lemma min_idPl x y : reflect (min x y = x) (x <= y).\nProof. by rewrite -eq_minl; apply/eqP. Qed.",
    "Lemma max_idPr x y : reflect (max x y = y) (x <= y).\nProof. by rewrite -eq_maxr; apply/eqP. Qed.",
    "Lemma min_minKx x y : min (min x y) y = min x y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed.",
    "Lemma min_minxK x y : min x (min x y) = min x y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed.",
    "Lemma max_maxKx x y : max (max x y) y = max x y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed.",
    "Lemma max_maxxK x y : max x (max x y) = max x y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed.",
    "Lemma comparable_minl z : {in >=< z &, forall x y, min x y >=< z}.\nProof. by move=> x y cmp_xz cmp_yz; rewrite /min; case: ifP. Qed.",
    "Lemma comparable_minr z : {in >=<%O z &, forall x y, z >=< min x y}.\nProof. by move=> x y cmp_xz cmp_yz; rewrite /min; case: ifP. Qed.",
    "Lemma comparable_maxl z : {in >=< z &, forall x y, max x y >=< z}.\nProof. by move=> x y cmp_xz cmp_yz; rewrite /max; case: ifP. Qed.",
    "Lemma comparable_maxr z : {in >=<%O z &, forall x y, z >=< max x y}.\nProof. by move=> x y cmp_xz cmp_yz; rewrite /max; case: ifP. Qed.",
    "Lemma comparable_minC : min x y = min y x.\nProof. by case: comparableP cmp_xy. Qed.",
    "Lemma comparable_maxC : max x y = max y x.\nProof. by case: comparableP cmp_xy. Qed.",
    "Lemma comparable_eq_minr : (min x y == y) = (y <= x).\nProof. by rewrite !(fun_if, if_arg) eqxx; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_eq_maxl : (max x y == x) = (y <= x).\nProof. by rewrite !(fun_if, if_arg) eqxx; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_min_idPr : reflect (min x y = y) (y <= x).\nProof. by rewrite -comparable_eq_minr; apply/eqP. Qed.",
    "Lemma comparable_max_idPl : reflect (max x y = x) (y <= x).\nProof. by rewrite -comparable_eq_maxl; apply/eqP. Qed.",
    "Lemma comparable_le_min : (z <= min x y) = (z <= x) && (z <= y).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?andbb//; last rewrite andbC;\n  by case: (comparableP z) => // [/lt_trans xlt/xlt|->] /ltW.\nQed.",
    "Lemma comparable_ge_min : (min x y <= z) = (x <= z) || (y <= z).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?orbb//; last rewrite orbC;\n  by move=> xy _; apply/idP/idP => [->|/orP[]]//; apply/le_trans/ltW.\nQed.",
    "Lemma comparable_lt_min : (z < min x y) = (z < x) && (z < y).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?andbb//; last rewrite andbC;\n  by case: (comparableP z) => // /lt_trans xlt/xlt.\nQed.",
    "Lemma comparable_gt_min : (min x y < z) = (x < z) || (y < z).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?orbb//; last rewrite orbC;\n  by move=> xy _; apply/idP/idP => [->|/orP[]]//; apply/lt_trans.\nQed.",
    "Lemma comparable_le_max : (z <= max x y) = (z <= x) || (z <= y).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?orbb//; first rewrite orbC;\n  by move=> xy _; apply/idP/idP => [->|/orP[]]// /le_trans->//; apply/ltW.\nQed.",
    "Lemma comparable_ge_max : (max x y <= z) = (x <= z) && (y <= z).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?andbb//; first rewrite andbC;\n  by case: (comparableP z) => // [ylt /lt_trans /(_ _)/ltW|->/ltW]->.\nQed.",
    "Lemma comparable_lt_max : (z < max x y) = (z < x) || (z < y).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?orbb//; first rewrite orbC;\n  by move=> xy _; apply/idP/idP => [->|/orP[]]// /lt_trans->.\nQed.",
    "Lemma comparable_gt_max : (max x y < z) = (x < z) && (y < z).\nProof.\ncase: comparableP cmp_xy => // [||<-//]; rewrite ?andbb//; first rewrite andbC;\nby case: (comparableP z) => // ylt /lt_trans->.\nQed.",
    "Lemma comparable_minxK : max (min x y) y = y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_minKx : max x (min x y) = x.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_maxxK : min (max x y) y = y.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_maxKx : min x (max x y) = x.\nProof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP cmp_xy. Qed.",
    "Lemma comparable_lteifNE C : x >=< y -> x < y ?<= if ~~ C = ~~ (y < x ?<= if C).\nProof. by case: C => /=; case: comparableP. Qed.",
    "Lemma comparable_lteif_minr C :\n  (z < min x y ?<= if C) = (z < x ?<= if C) && (z < y ?<= if C).\nProof. by case: C; rewrite /= (comparable_le_min, comparable_lt_min). Qed.",
    "Lemma comparable_lteif_minl C :\n  (min x y < z ?<= if C) = (x < z ?<= if C) || (y < z ?<= if C).\nProof. by case: C; rewrite /= (comparable_ge_min, comparable_gt_min). Qed.",
    "Lemma comparable_lteif_maxr C :\n  (z < max x y ?<= if C) = (z < x ?<= if C) || (z < y ?<= if C).\nProof. by case: C; rewrite /= (comparable_le_max, comparable_lt_max). Qed.",
    "Lemma comparable_lteif_maxl C :\n  (max x y < z ?<= if C) = (x < z ?<= if C) && (y < z ?<= if C).\nProof. by case: C; rewrite /= (comparable_ge_max, comparable_gt_max). Qed.",
    "Lemma comparable_minA : min x (min y z) = min (min x y) z.\nProof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z) => [xy|xy|xy|<-] [xz|xz|xz|<-]// []//= yz.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\n- by have := lt_trans xy xz; rewrite yz ltxx.\nQed.",
    "Lemma comparable_maxA : max x (max y z) = max (max x y) z.\nProof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z) => [xy|xy|xy|<-] [xz|xz|xz|<-]// []//= yz.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\n- by have := lt_trans xy xz; rewrite yz ltxx.\nQed.",
    "Lemma comparable_max_minl : max (min x y) z = min (max x z) (max y z).\nProof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z).\nmove=> [xy|xy|xy|<-] [xz|xz|xz|<-] [yz|yz|yz|//->]//= _; rewrite ?ltxx//.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\nQed.",
    "Lemma comparable_min_maxl : min (max x y) z = max (min x z) (min y z).\nProof.\nmove: cmp_xy cmp_xz cmp_yz; rewrite !(fun_if, if_arg)/=.\nmove: (P x y) (P x z) (P y z).\nmove=> [xy|xy|xy|<-] [xz|xz|xz|<-] []yz//= _; rewrite ?ltxx//.\n- by have := lt_trans xy (lt_trans yz xz); rewrite ltxx.\n- by have := lt_trans xy yz; rewrite ltxx.\n- by have := lt_trans xy (lt_trans xz yz); rewrite ltxx.\n- by have := lt_trans xy xz; rewrite yz ltxx.\nQed.",
    "Lemma comparable_le_min2 : x <= z -> y <= w ->\n  Order.min x y <= Order.min z w.\nProof.\nmove: cmp_xy cmp_zw => /comparable_leP[] xy /comparable_leP[] zw // xz yw.\n- exact: le_trans xy yw.\n- exact: le_trans (ltW xy) xz.\nQed.",
    "Lemma comparable_le_max2 : x <= z -> y <= w ->\n  Order.max x y <= Order.max z w.\nProof.\nmove: cmp_xy cmp_zw => /comparable_leP[] xy /comparable_leP[] zw // xz yw.\n- exact: le_trans yw (ltW zw).\n- exact: le_trans xz zw.\nQed.",
    "Lemma comparable_minAC x y z : x >=< y -> x >=< z -> y >=< z ->\n  min (min x y) z = min (min x z) y.\nProof.\nmove=> xy xz yz; rewrite -comparable_minA// [min y z]comparable_minC//.\nby rewrite comparable_minA// 1?comparable_sym.\nQed.",
    "Lemma comparable_maxAC x y z : x >=< y -> x >=< z -> y >=< z ->\n  max (max x y) z = max (max x z) y.\nProof.\nmove=> xy xz yz; rewrite -comparable_maxA// [max y z]comparable_maxC//.\nby rewrite comparable_maxA// 1?comparable_sym.\nQed.",
    "Lemma comparable_minCA x y z : x >=< y -> x >=< z -> y >=< z ->\n  min x (min y z) = min y (min x z).\nProof.\nmove=> xy xz yz; rewrite comparable_minA// [min x y]comparable_minC//.\nby rewrite -comparable_minA// 1?comparable_sym.\nQed.",
    "Lemma comparable_maxCA x y z : x >=< y -> x >=< z -> y >=< z ->\n  max x (max y z) = max y (max x z).\nProof.\nmove=> xy xz yz; rewrite comparable_maxA// [max x y]comparable_maxC//.\nby rewrite -comparable_maxA// 1?comparable_sym.\nQed.",
    "Lemma comparable_minACA x y z t :\n    x >=< y -> x >=< z -> x >=< t -> y >=< z -> y >=< t -> z >=< t ->\n  min (min x y) (min z t) = min (min x z) (min y t).\nProof.\nmove=> xy xz xt yz yt zt; rewrite comparable_minA// ?comparable_minl//.\nrewrite [min _ z]comparable_minAC// -comparable_minA// ?comparable_minl//.\nby rewrite inE comparable_sym.\nQed.",
    "Lemma comparable_maxACA x y z t :\n    x >=< y -> x >=< z -> x >=< t -> y >=< z -> y >=< t -> z >=< t ->\n  max (max x y) (max z t) = max (max x z) (max y t).\nProof.\nmove=> xy xz xt yz yt zt; rewrite comparable_maxA// ?comparable_maxl//.\nrewrite [max _ z]comparable_maxAC// -comparable_maxA// ?comparable_maxl//.\nby rewrite inE comparable_sym.\nQed.",
    "Lemma comparable_max_minr x y z : x >=< y -> x >=< z -> y >=< z ->\n  max x (min y z) = min (max x y) (max x z).\nProof.\nmove=> xy xz yz; rewrite ![max x _]comparable_maxC// ?comparable_minr//.\nby rewrite comparable_max_minl// 1?comparable_sym.\nQed.",
    "Lemma comparable_min_maxr x y z : x >=< y -> x >=< z -> y >=< z ->\n  min x (max y z) = max (min x y) (min x z).\nProof.\nmove=> xy xz yz; rewrite ![min x _]comparable_minC// ?comparable_maxr//.\nby rewrite comparable_min_maxl// 1?comparable_sym.\nQed.",
    "Lemma comparable_arg_minP: extremum_spec <=%O P F (arg_min i0 P F).\nProof.\nby apply: extremum_inP => // [x _|y x z _ _ _]; [apply: lexx|apply: le_trans].\nQed.",
    "Lemma comparable_arg_maxP: extremum_spec >=%O P F (arg_max i0 P F).\nProof.\napply: extremum_inP => // [x _|y x z _ _ _|]; [exact: lexx|exact: ge_trans|].\nby move=> x y xP yP; rewrite orbC [_ || _]F_comparable.\nQed.",
    "Lemma mono_in_leif (A : {pred T}) (f : T -> T) C :\n   {in A &, {mono f : x y / x <= y}} ->\n  {in A &, forall x y, (f x <= f y ?= iff C) = (x <= y ?= iff C)}.\nProof. by move=> mf x y Ax Ay; rewrite /leif !eq_le !mf. Qed.",
    "Lemma mono_leif (f : T -> T) C :\n    {mono f : x y / x <= y} ->\n  forall x y, (f x <= f y ?= iff C) = (x <= y ?= iff C).\nProof. by move=> mf x y; rewrite /leif !eq_le !mf. Qed.",
    "Lemma nmono_in_leif (A : {pred T}) (f : T -> T) C :\n    {in A &, {mono f : x y /~ x <= y}} ->\n  {in A &, forall x y, (f x <= f y ?= iff C) = (y <= x ?= iff C)}.\nProof. by move=> mf x y Ax Ay; rewrite /leif !eq_le !mf. Qed.",
    "Lemma nmono_leif (f : T -> T) C : {mono f : x y /~ x <= y} ->\n  forall x y, (f x <= f y ?= iff C) = (y <= x ?= iff C).\nProof. by move=> mf x y; rewrite /leif !eq_le !mf. Qed.",
    "Lemma comparable_bigl x x0 op I (P : pred I) F (s : seq I) :\n  {in >=< x &, forall y z, op y z >=< x} -> x0 >=< x ->\n  {in P, forall i, F i >=< x} -> \\big[op/x0]_(i <- s | P i) F i >=< x.\nProof. by move=> *; elim/big_ind : _. Qed.",
    "Lemma comparable_bigr x x0 op I (P : pred I) F (s : seq I) :\n  {in >=<%O x &, forall y z, x >=< op y z} -> x >=< x0 ->\n  {in P, forall i, x >=< F i} -> x >=< \\big[op/x0]_(i <- s | P i) F i.\nProof. by move=> *; elim/big_ind : _. Qed.",
    "Lemma bigmax_le : x0 <= x -> (forall i, P i -> f i <= x) ->\n  \\big[max/x0]_(i <- r | P i) f i <= x.\nProof. by move=> ? ?; elim/big_ind: _ => // *; rewrite maxEle; case: ifPn. Qed.",
    "Lemma bigmax_lt : x0 < x -> (forall i, P i -> f i < x) ->\n  \\big[max/x0]_(i <- r | P i) f i < x.\nProof. by move=> ? ?; elim/big_ind: _ => // *; rewrite maxElt; case: ifPn. Qed.",
    "Lemma lt_bigmin : x < x0 -> (forall i, P i -> x < f i) ->\n  x < \\big[min/x0]_(i <- r | P i) f i.\nProof. by move=> ? ?; elim/big_ind: _ => // *; rewrite minElt; case: ifPn. Qed.",
    "Lemma le_bigmin : x <= x0 -> (forall i, P i -> x <= f i) ->\n  x <= \\big[min/x0]_(i <- r | P i) f i.\nProof. by move=> ? ?; elim/big_ind: _ => // *; rewrite minEle; case: ifPn. Qed.",
    "Lemma comparable_contraTle b x y : x >=< y -> (y < x -> ~~ b) -> (b -> x <= y).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma comparable_contraTlt b x y : x >=< y -> (y <= x -> ~~ b) -> (b -> x < y).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma comparable_contraPle P x y : x >=< y -> (y < x -> ~ P) -> (P -> x <= y).\nProof. by case: comparableP => // _ _ /(_ isT). Qed.",
    "Lemma comparable_contraPlt P x y : x >=< y -> (y <= x -> ~ P) -> (P -> x < y).\nProof. by case: comparableP => // _ _ /(_ isT). Qed.",
    "Lemma comparable_contraNle b x y : x >=< y -> (y < x -> b) -> (~~ b -> x <= y).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma comparable_contraNlt b x y : x >=< y -> (y <= x -> b) -> (~~ b -> x < y).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma comparable_contra_not_le P x y : x >=< y -> (y < x -> P) -> (~ P -> x <= y).\nProof. by case: comparableP => // _ _ /(_ isT). Qed.",
    "Lemma comparable_contra_not_lt P x y : x >=< y -> (y <= x -> P) -> (~ P -> x < y).\nProof. by case: comparableP => // _ _ /(_ isT). Qed.",
    "Lemma comparable_contraFle b x y : x >=< y -> (y < x -> b) -> (b = false -> x <= y).\nProof. by case: comparableP; case: b => // _ _ /implyP. Qed.",
    "Lemma comparable_contraFlt b x y : x >=< y -> (y <= x -> b) -> (b = false -> x < y).\nProof. by case: comparableP; case: b => // _ _ /implyP. Qed.",
    "Lemma contra_leT b x y : (~~ b -> x < y) -> (y <= x -> b).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma contra_ltT b x y : (~~ b -> x <= y) -> (y < x -> b).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma contra_leN b x y : (b -> x < y) -> (y <= x -> ~~ b).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma contra_ltN b x y : (b -> x <= y) -> (y < x -> ~~ b).\nProof. by case: comparableP; case: b. Qed.",
    "Lemma contra_le_not P x y : (P -> x < y) -> (y <= x -> ~ P).\nProof. by case: comparableP => // _ PF _ /PF. Qed.",
    "Lemma contra_lt_not P x y : (P -> x <= y) -> (y < x -> ~ P).\nProof. by case: comparableP => // _ PF _ /PF. Qed.",
    "Lemma contra_leF b x y : (b -> x < y) -> (y <= x -> b = false).\nProof. by case: comparableP; case: b => // _ /implyP. Qed.",
    "Lemma contra_ltF b x y : (b -> x <= y) -> (y < x -> b = false).\nProof. by case: comparableP; case: b => // _ /implyP. Qed.",
    "Lemma comparable_contra_leq_le m n x y : x >=< y ->\n  (y < x -> (n < m)%N) -> ((m <= n)%N -> x <= y).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma comparable_contra_leq_lt m n x y : x >=< y ->\n  (y <= x -> (n < m)%N) -> ((m <= n)%N -> x < y).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma comparable_contra_ltn_le m n x y : x >=< y ->\n  (y < x -> (n <= m)%N) -> ((m < n)%N -> x <= y).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma comparable_contra_ltn_lt m n x y : x >=< y ->\n  (y <= x -> (n <= m)%N) -> ((m < n)%N -> x < y).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma contra_le_leq x y m n : ((n < m)%N -> y < x) -> (x <= y -> (m <= n)%N).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma contra_le_ltn x y m n : ((n <= m)%N -> y < x) -> (x <= y -> (m < n)%N).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma contra_lt_leq x y m n : ((n < m)%N -> y <= x) -> (x < y -> (m <= n)%N).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma contra_lt_ltn x y m n : ((n <= m)%N -> y <= x) -> (x < y -> (m < n)%N).\nProof. by case: comparableP; case: ltngtP. Qed.",
    "Lemma comparable_contra_le x y z t : z >=< t ->\n  (t < z -> y < x) -> (x <= y -> z <= t).\nProof. by do 2![case: comparableP => //= ?]. Qed.",
    "Lemma comparable_contra_le_lt x y z t : z >=< t ->\n  (t <= z -> y < x) -> (x <= y -> z < t).\nProof. by do 2![case: comparableP => //= ?]. Qed.",
    "Lemma comparable_contra_lt_le x y z t : z >=< t ->\n  (t < z -> y <= x) -> (x < y -> z <= t).\nProof. by do 2![case: comparableP => //= ?]. Qed.",
    "Lemma comparable_contra_lt x y z t : z >=< t ->\n (t <= z -> y <= x) -> (x < y -> z < t).\nProof. by do 2![case: comparableP => //= ?]. Qed.",
    "Lemma ltW_homo : {homo f : x y / x < y} -> {homo f : x y / x <= y}.\nProof. exact: homoW. Qed.",
    "Lemma ltW_nhomo : {homo f : x y /~ x < y} -> {homo f : x y /~ x <= y}.\nProof. by apply: homoW=> // x y; rewrite eq_sym. Qed.",
    "Lemma inj_homo_lt :\n  injective f -> {homo f : x y / x <= y} -> {homo f : x y / x < y}.\nProof. exact: inj_homo. Qed.",
    "Lemma inj_nhomo_lt :\n  injective f -> {homo f : x y /~ x <= y} -> {homo f : x y /~ x < y}.\nProof. by apply: inj_homo=> // x y; rewrite eq_sym. Qed.",
    "Lemma inc_inj : {mono f : x y / x <= y} -> injective f.\nProof. exact: mono_inj. Qed.",
    "Lemma dec_inj : {mono f : x y /~ x <= y} -> injective f.\nProof. exact: mono_inj. Qed.",
    "Lemma leW_mono : {mono f : x y / x <= y} -> {mono f : x y / x < y}.\nProof. exact: anti_mono. Qed.",
    "Lemma leW_nmono : {mono f : x y /~ x <= y} -> {mono f : x y /~ x < y}.\nProof. by apply: anti_mono=> // x y; rewrite eq_sym. Qed.",
    "Lemma ltW_homo_in :\n  {in D & D', {homo f : x y / x < y}} -> {in D & D', {homo f : x y / x <= y}}.\nProof. exact: homoW_in. Qed.",
    "Lemma ltW_nhomo_in :\n  {in D & D', {homo f : x y /~ x < y}} -> {in D & D', {homo f : x y /~ x <= y}}.\nProof. by apply: homoW_in=> // x y; rewrite eq_sym. Qed.",
    "Lemma inj_homo_lt_in :\n    {in D & D', injective f} ->  {in D & D', {homo f : x y / x <= y}} ->\n  {in D & D', {homo f : x y / x < y}}.\nProof. exact: inj_homo_in. Qed.",
    "Lemma inj_nhomo_lt_in :\n    {in D & D', injective f} -> {in D & D', {homo f : x y /~ x <= y}} ->\n  {in D & D', {homo f : x y /~ x < y}}.\nProof. by apply: inj_homo_in=> // x y; rewrite eq_sym. Qed.",
    "Lemma inc_inj_in : {in D &, {mono f : x y / x <= y}} ->\n   {in D &, injective f}.\nProof. exact: mono_inj_in. Qed.",
    "Lemma dec_inj_in :\n  {in D &, {mono f : x y /~ x <= y}} -> {in D &, injective f}.\nProof. exact: mono_inj_in. Qed.",
    "Lemma leW_mono_in :\n  {in D &, {mono f : x y / x <= y}} -> {in D &, {mono f : x y / x < y}}.\nProof. exact: anti_mono_in. Qed.",
    "Lemma leW_nmono_in :\n  {in D &, {mono f : x y /~ x <= y}} -> {in D &, {mono f : x y /~ x < y}}.\nProof. by apply: anti_mono_in=> // x y; rewrite eq_sym. Qed.",
    "Lemma le0x x : \\bot <= x. Proof. exact: le0x. Qed.",
    "Lemma ltx0 x : (x < \\bot) = false.\nProof. exact/le_gtF/le0x. Qed.",
    "Lemma lex0 x : (x <= \\bot) = (x == \\bot).\nProof. by rewrite le_eqVlt ltx0 orbF. Qed.",
    "Lemma lt0x x : (\\bot < x) = (x != \\bot).\nProof. by rewrite lt_def le0x andbT. Qed.",
    "Lemma posxP x : eq0_xor_gt0 x (x == \\bot) (\\bot < x).\nProof. by rewrite lt0x; have [] := eqVneq; constructor; rewrite ?lt0x. Qed.",
    "Lemma lex1 x : x <= \\top. Proof. exact: lex1. Qed.",
    "Lemma lt1x x : (\\top < x) = false. Proof. exact: (@ltx0 _ T^d). Qed.",
    "Lemma le1x x : (\\top <= x) = (x == \\top). Proof. exact: (@lex0 _ T^d). Qed.",
    "Lemma ltx1 x : (x < \\top) = (x != \\top). Proof. exact: (@lt0x _ T^d). Qed.",
    "Lemma lexI x y z : (x <= y `&` z) = (x <= y) && (x <= z).\nProof. exact: lexI. Qed.",
    "Lemma leIr x y : y `&` x <= x.\nProof. by have:= le_refl (meet y x); rewrite lexI => /andP []. Qed.",
    "Lemma leIl x y : x `&` y <= x.\nProof. by have:= le_refl (meet x y); rewrite lexI => /andP []. Qed.",
    "Lemma leIxl x y z : y <= x -> y `&` z <= x.\nProof. exact/le_trans/leIl. Qed.",
    "Lemma leIxr x y z : z <= x -> y `&` z <= x.\nProof. exact/le_trans/leIr. Qed.",
    "Lemma leIx2 x y z : (y <= x) || (z <= x) -> y `&` z <= x.\nProof. by case/orP => [/leIxl|/leIxr]. Qed.",
    "Lemma leEmeet x y : (x <= y) = (x `&` y == x).\nProof. by rewrite eq_le lexI leIl lexx. Qed.",
    "Lemma eq_meetl x y : (x `&` y == x) = (x <= y).\nProof. by apply/esym/leEmeet. Qed.",
    "Lemma eq_meetr x y : (x `&` y == y) = (y <= x).\nProof. by rewrite eq_le lexI leIr lexx andbT. Qed.",
    "Lemma meet_idPl {x y} : reflect (x `&` y = x) (x <= y).\nProof. by rewrite -eq_meetl; apply/eqP. Qed.",
    "Lemma meet_idPr {x y} : reflect (y `&` x = x) (x <= y).\nProof. by rewrite -eq_meetr; apply/eqP. Qed.",
    "Lemma meet_l x y : x <= y -> x `&` y = x. Proof. exact/meet_idPl. Qed.",
    "Lemma meet_r x y : y <= x -> x `&` y = y. Proof. exact/meet_idPr. Qed.",
    "Lemma leIidl x y : (x <= x `&` y) = (x <= y).\nProof. by rewrite lexI lexx. Qed.",
    "Lemma leIidr x y : (x <= y `&` x) = (x <= y).\nProof. by rewrite lexI lexx andbT. Qed.",
    "Lemma leI2 x y z t : x <= z -> y <= t -> x `&` y <= z `&` t.\nProof. by move=> xz yt; rewrite lexI !leIx2 ?xz ?yt ?orbT //. Qed.",
    "Lemma meetC : commutative (@meet _ L).\nProof. by move=> x y; apply: le_anti; rewrite !lexI !leIr !leIl. Qed.",
    "Lemma meetA : associative (@meet _ L).\nProof.\nmove=> x y z; apply: le_anti.\nrewrite !lexI leIr leIl /= andbT -andbA.\nrewrite ![_ `&` (_ `&` _) <= _]leIxr ?(leIr, leIl) //=.\nby rewrite leIxl ?leIl // leIxl // leIr.\nQed.",
    "Lemma meetxx : idempotent_op (@meet _ L).\nProof. by move=> x; apply/eqP; rewrite -leEmeet. Qed.",
    "Lemma meetAC : right_commutative (@meet _ L).\nProof. by move=> x y z; rewrite -!meetA [X in _ `&` X]meetC. Qed.",
    "Lemma meetCA : left_commutative (@meet _ L).\nProof. by move=> x y z; rewrite !meetA [X in X `&` _]meetC. Qed.",
    "Lemma meetACA : interchange (@meet _ L) (@meet _ L).\nProof. by move=> x y z t; rewrite !meetA [X in X `&` _]meetAC. Qed.",
    "Lemma meetKI y x : x `&` (x `&` y) = x `&` y.\nProof. by rewrite meetA meetxx. Qed.",
    "Lemma meetIK y x : (x `&` y) `&` y = x `&` y.\nProof. by rewrite -meetA meetxx. Qed.",
    "Lemma meetKIC y x : x `&` (y `&` x) = x `&` y.\nProof. by rewrite meetC meetIK meetC. Qed.",
    "Lemma meetIKC y x : y `&` x `&` y = x `&` y.\nProof. by rewrite meetAC meetC meetxx. Qed.",
    "Lemma meet0x : left_zero \\bot (@meet _ L).\nProof. by move=> x; apply/eqP; rewrite -leEmeet. Qed.",
    "Lemma meetx0 : right_zero \\bot (@meet _ L).\nProof. by move=> x; rewrite meetC meet0x. Qed.",
    "Lemma meetx1 : right_id \\top (@meet _ L).\nProof. by move=> x; apply/eqP; rewrite -leEmeet. Qed.",
    "Lemma meet1x : left_id \\top (@meet _ L).\nProof. by move=> x; apply/eqP; rewrite meetC meetx1. Qed.",
    "Lemma meet_eq1 x y : (x `&` y == \\top) = (x == \\top) && (y == \\top).\nProof.\napply/idP/idP; last by move=> /andP[/eqP-> /eqP->]; rewrite meetx1.\nby move=> /eqP xIy1; rewrite -!le1x -xIy1 leIl leIr.\nQed.",
    "Lemma meets_inf_seq T (r : seq T) (P : {pred T}) (F : T -> L) (x : T) :\n  x \\in r -> P x -> \\meet_(i <- r | P i) F i <= F x.\nProof. by move=> xr Px; rewrite (big_rem x) ?Px //= leIl. Qed.",
    "Lemma meets_max_seq T (r : seq T) (P : {pred T}) (F : T -> L) (x : T) (u : L) :\n  x \\in r -> P x -> F x <= u -> \\meet_(x <- r | P x) F x <= u.\nProof. by move=> ? ?; apply/le_trans/meets_inf_seq. Qed.",
    "Lemma meets_inf I (j : I) (P : {pred I}) (F : I -> L) :\n   P j -> \\meet_(i | P i) F i <= F j.\nProof. exact: meets_inf_seq. Qed.",
    "Lemma meets_max I (j : I) (u : L) (P : {pred I}) (F : I -> L) :\n   P j -> F j <= u -> \\meet_(i | P i) F i <= u.\nProof. exact: meets_max_seq. Qed.",
    "Lemma meets_ge J (r : seq J) (P : {pred J}) (F : J -> L) (u : L) :\n  (forall x : J, P x -> u <= F x) -> u <= \\meet_(x <- r | P x) F x.\nProof. by move=> leFm; elim/big_rec: _ => // i x Px xu; rewrite lexI leFm. Qed.",
    "Lemma meetsP_seq T (r : seq T) (P : {pred T}) (F : T -> L) (l : L) :\n  reflect (forall x : T, x \\in r -> P x -> l <= F x)\n          (l <= \\meet_(x <- r | P x) F x).\nProof.\napply: (iffP idP) => leFm => [x xr Px|].\n  exact/(le_trans leFm)/meets_inf_seq.\nby rewrite big_seq_cond meets_ge// => x /andP[/leFm].\nQed.",
    "Lemma meetsP I (l : L) (P : {pred I}) (F : I -> L) :\n   reflect (forall i : I, P i -> l <= F i) (l <= \\meet_(i | P i) F i).\nProof. by apply: (iffP (meetsP_seq _ _ _ _)) => H ? ?; apply: H. Qed.",
    "Lemma le_meets I (A B : {set I}) (F : I -> L) :\n   A \\subset B -> \\meet_(i in B) F i <= \\meet_(i in A) F i.\nProof. by move=> /subsetP AB; apply/meetsP => i iA; apply/meets_inf/AB. Qed.",
    "Lemma meets_setU I (A B : {set I}) (F : I -> L) :\n   \\meet_(i in (A :|: B)) F i = \\meet_(i in A) F i `&` \\meet_(i in B) F i.\nProof.\nrewrite -!big_enum; have /= <- := @big_cat _ _ meet.\napply/eq_big_idem; first exact: meetxx.\nby move=> ?; rewrite mem_cat !mem_enum inE.\nQed.",
    "Lemma meets_seq I (r : seq I) (F : I -> L) :\n   \\meet_(i <- r) F i = \\meet_(i in r) F i.\nProof.\nby rewrite -big_enum; apply/eq_big_idem => ?; rewrite /= ?meetxx ?mem_enum.\nQed.",
    "Lemma leUx x y z : (x `|` y <= z) = (x <= z) && (y <= z).\nProof. exact: leUx. Qed.",
    "Lemma leUr x y : x <= y `|` x. Proof. exact: (@leIr _ L^d). Qed.",
    "Lemma leUl x y : x <= x `|` y. Proof. exact: (@leIl _ L^d). Qed.",
    "Lemma lexUl x y z : x <= y -> x <= y `|` z.\nProof. exact: (@leIxl _ L^d). Qed.",
    "Lemma lexUr x y z : x <= z -> x <= y `|` z.\nProof. exact: (@leIxr _ L^d). Qed.",
    "Lemma lexU2 x y z : (x <= y) || (x <= z) -> x <= y `|` z.\nProof. exact: (@leIx2 _ L^d). Qed.",
    "Lemma leEjoin x y : (x <= y) = (x `|` y == y).\nProof. by rewrite [LHS](@leEmeet _ L^d) meetC. Qed.",
    "Lemma eq_joinl x y : (x `|` y == x) = (y <= x).\nProof. exact: (@eq_meetl _ L^d). Qed.",
    "Lemma eq_joinr x y : (x `|` y == y) = (x <= y).\nProof. exact: (@eq_meetr _ L^d). Qed.",
    "Lemma join_idPl {x y} : reflect (y `|` x = y) (x <= y).\nProof. exact: (@meet_idPl _ L^d). Qed.",
    "Lemma join_idPr {x y} : reflect (x `|` y = y) (x <= y).\nProof. exact: (@meet_idPr _ L^d). Qed.",
    "Lemma join_l x y : y <= x -> x `|` y = x. Proof. exact/join_idPl. Qed.",
    "Lemma join_r x y : x <= y -> x `|` y = y. Proof. exact/join_idPr. Qed.",
    "Lemma leUidl x y : (x `|` y <= y) = (x <= y).\nProof. exact: (@leIidr _ L^d). Qed.",
    "Lemma leUidr x y : (y `|` x <= y) = (x <= y).\nProof. exact: (@leIidl _ L^d). Qed.",
    "Lemma leU2 x y z t : x <= z -> y <= t -> x `|` y <= z `|` t.\nProof. exact: (@leI2 _ L^d). Qed.",
    "Lemma joinC : commutative (@join _ L). Proof. exact: (@meetC _ L^d). Qed.",
    "Lemma joinA : associative (@join _ L). Proof. exact: (@meetA _ L^d). Qed.",
    "Lemma joinxx : idempotent_op (@join _ L).\nProof. exact: (@meetxx _ L^d). Qed.",
    "Lemma joinAC : right_commutative (@join _ L).\nProof. exact: (@meetAC _ L^d). Qed.",
    "Lemma joinCA : left_commutative (@join _ L).\nProof. exact: (@meetCA _ L^d). Qed.",
    "Lemma joinACA : interchange (@join _ L) (@join _ L).\nProof. exact: (@meetACA _ L^d). Qed.",
    "Lemma joinKU y x : x `|` (x `|` y) = x `|` y.\nProof. exact: (@meetKI _ L^d). Qed.",
    "Lemma joinUK y x : (x `|` y) `|` y = x `|` y.\nProof. exact: (@meetIK _ L^d). Qed.",
    "Lemma joinKUC y x : x `|` (y `|` x) = x `|` y.\nProof. exact: (@meetKIC _ L^d). Qed.",
    "Lemma joinUKC y x : y `|` x `|` y = x `|` y.\nProof. exact: (@meetIKC _ L^d). Qed.",
    "Lemma joinx0 : right_id \\bot (@join _ L).\nProof. exact: (@meetx1 _ L^d). Qed.",
    "Lemma join0x : left_id \\bot (@join _ L).\nProof. exact: (@meet1x _ L^d). Qed.",
    "Lemma join_eq0 x y : (x `|` y == \\bot) = (x == \\bot) && (y == \\bot).\nProof. exact: (@meet_eq1 _ L^d). Qed.",
    "Lemma joins_sup_seq T (r : seq T) (P : {pred T}) (F : T -> L) (x : T) :\n  x \\in r -> P x -> F x <= \\join_(i <- r | P i) F i.\nProof. exact: (@meets_inf_seq _ L^d). Qed.",
    "Lemma joins_min_seq T (r : seq T) (P : {pred T}) (F : T -> L) (x : T) (l : L) :\n  x \\in r -> P x -> l <= F x -> l <= \\join_(x <- r | P x) F x.\nProof. exact: (@meets_max_seq _ L^d). Qed.",
    "Lemma joins_sup I (j : I) (P : {pred I}) (F : I -> L) :\n  P j -> F j <= \\join_(i | P i) F i.\nProof. exact: (@meets_inf _ L^d). Qed.",
    "Lemma joins_min I (j : I) (l : L) (P : {pred I}) (F : I -> L) :\n  P j -> l <= F j -> l <= \\join_(i | P i) F i.\nProof. exact: (@meets_max _ L^d). Qed.",
    "Lemma joins_le J (r : seq J) (P : {pred J}) (F : J -> L) (u : L) :\n  (forall x : J, P x -> F x <= u) -> \\join_(x <- r | P x) F x <= u.\nProof. exact: (@meets_ge _ L^d). Qed.",
    "Lemma joinsP_seq T (r : seq T) (P : {pred T}) (F : T -> L) (u : L) :\n  reflect (forall x : T, x \\in r -> P x -> F x <= u)\n          (\\join_(x <- r | P x) F x <= u).\nProof. exact: (@meetsP_seq _ L^d). Qed.",
    "Lemma joinsP I (u : L) (P : {pred I}) (F : I -> L) :\n  reflect (forall i : I, P i -> F i <= u) (\\join_(i | P i) F i <= u).\nProof. exact: (@meetsP _ L^d). Qed.",
    "Lemma le_joins I (A B : {set I}) (F : I -> L) :\n  A \\subset B -> \\join_(i in A) F i <= \\join_(i in B) F i.\nProof. exact: (@le_meets _ L^d). Qed.",
    "Lemma joins_setU I (A B : {set I}) (F : I -> L) :\n  \\join_(i in (A :|: B)) F i = \\join_(i in A) F i `|` \\join_(i in B) F i.\nProof. exact: (@meets_setU _ L^d). Qed.",
    "Lemma joins_seq I (r : seq I) (F : I -> L) :\n  \\join_(i <- r) F i = \\join_(i in r) F i.\nProof. exact: (@meets_seq _ L^d). Qed.",
    "Lemma joinx1 : right_zero \\top (@join _ L). Proof. exact: (@meetx0 _ L^d). Qed.",
    "Lemma join1x : left_zero \\top (@join _ L). Proof. exact: (@meet0x _ L^d). Qed.",
    "Lemma meetUK x y : (x `&` y) `|` y = y. Proof. exact/join_idPr/leIr. Qed.",
    "Lemma meetUKC x y : (y `&` x) `|` y = y. Proof. by rewrite meetC meetUK. Qed.",
    "Lemma meetKUC y x : x `|` (y `&` x) = x. Proof. by rewrite joinC meetUK. Qed.",
    "Lemma meetKU y x : x `|` (x `&` y) = x. Proof. by rewrite meetC meetKUC. Qed.",
    "Lemma joinIK x y : (x `|` y) `&` y = y. Proof. exact/meet_idPr/leUr. Qed.",
    "Lemma joinIKC x y : (y `|` x) `&` y = y. Proof. by rewrite joinC joinIK. Qed.",
    "Lemma joinKIC y x : x `&` (y `|` x) = x. Proof. by rewrite meetC joinIK. Qed.",
    "Lemma joinKI y x : x `&` (x `|` y) = x. Proof. by rewrite joinC joinKIC. Qed.",
    "Lemma lcomparableP x y : incomparel x y\n  (min y x) (min x y) (max y x) (max x y)\n  (y `&` x) (x `&` y) (y `|` x) (x `|` y)\n  (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y) (y >=< x) (x >=< y).\nProof.\nby case: (comparableP x) => [hxy|hxy|hxy|->]; do 1?have hxy' := ltW hxy;\n   rewrite ?(meetxx, joinxx);\n   rewrite ?(meet_l hxy', meet_r hxy', join_l hxy', join_r hxy');\n   constructor.\nQed.",
    "Lemma lcomparable_ltgtP x y : x >=< y ->\n  comparel x y (min y x) (min x y) (max y x) (max x y)\n               (y `&` x) (x `&` y) (y `|` x) (x `|` y)\n               (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y).\nProof. by case: (lcomparableP x) => // *; constructor. Qed.",
    "Lemma lcomparable_leP x y : x >=< y ->\n  lel_xor_gt x y (min y x) (min x y) (max y x) (max x y)\n                 (y `&` x) (x `&` y) (y `|` x) (x `|` y) (x <= y) (y < x).\nProof. by move/lcomparable_ltgtP => [/ltW xy|xy|->]; constructor. Qed.",
    "Lemma lcomparable_ltP x y : x >=< y ->\n  ltl_xor_ge x y (min y x) (min x y) (max y x) (max x y)\n                 (y `&` x) (x `&` y) (y `|` x) (x `|` y) (y <= x) (x < y).\nProof. by move=> /lcomparable_ltgtP [xy|/ltW xy|->]; constructor. Qed.",
    "Lemma meetUl : left_distributive (@meet _ L) (@join _ L).\nProof. exact: meetUl. Qed.",
    "Lemma meetUr : right_distributive (@meet _ L) (@join _ L).\nProof. by move=> x y z; rewrite ![x `&` _]meetC meetUl. Qed.",
    "Lemma joinIl : left_distributive (@join _ L) (@meet _ L).\nProof. exact: joinIl. Qed.",
    "Lemma joinIr : right_distributive (@join _ L) (@meet _ L).\nProof. by move=> x y z; rewrite ![x `|` _]joinC joinIl. Qed.",
    "Lemma leU2l_le y t x z : x `&` t = \\bot -> x `|` y <= z `|` t -> x <= z.\nProof.\nby move=> xIt0 /(leI2 (lexx x)); rewrite joinKI meetUr xIt0 joinx0 leIidl.\nQed.",
    "Lemma leU2r_le y t x z : x `&` t = \\bot -> y `|` x <= t `|` z -> x <= z.\nProof. by rewrite joinC [_ `|` z]joinC => /leU2l_le H /H. Qed.",
    "Lemma disjoint_lexUl z x y : x `&` z = \\bot -> (x <= y `|` z) = (x <= y).\nProof.\nmove=> xz0; apply/idP/idP=> xy; last by rewrite lexU2 ?xy.\nby apply: (@leU2l_le x z); rewrite ?joinxx.\nQed.",
    "Lemma disjoint_lexUr z x y : x `&` z = \\bot -> (x <= z `|` y) = (x <= y).\nProof. by move=> xz0; rewrite joinC; rewrite disjoint_lexUl. Qed.",
    "Lemma leU2E x y z t : x `&` t = \\bot -> y `&` z = \\bot ->\n  (x `|` y <= z `|` t) = (x <= z) && (y <= t).\nProof.\nmove=> dxt dyz; apply/idP/andP; last by case=> ? ?; exact: leU2.\nby move=> lexyzt; rewrite (leU2l_le _ lexyzt) // (leU2r_le _ lexyzt).\nQed.",
    "Lemma joins_disjoint (I : finType) (d : L) (P : {pred I}) (F : I -> L) :\n   (forall i : I, P i -> d `&` F i = \\bot) -> d `&` \\join_(i | P i) F i = \\bot.\nProof.\nmove=> d_Fi_disj; have : \\big[andb/true]_(i | P i) (d `&` F i == \\bot).\n  rewrite big_all_cond; apply/allP => i _ /=.\n  by apply/implyP => /d_Fi_disj ->.\nelim/big_rec2: _ => [|i y]; first by rewrite meetx0.\ncase; rewrite (andbF, andbT) // => Pi /(_ isT) dy /eqP dFi.\nby rewrite meetUr dy dFi joinxx.\nQed.",
    "Lemma leI2l_le y t x z : y `|` z = \\top -> x `&` y <= z `&` t -> x <= z.\nProof. by rewrite joinC; exact: (@leU2l_le _ L^d). Qed.",
    "Lemma leI2r_le y t x z : y `|` z = \\top -> y `&` x <= t `&` z -> x <= z.\nProof. by rewrite joinC; exact: (@leU2r_le _ L^d). Qed.",
    "Lemma cover_leIxl z x y : z `|` y = \\top -> (x `&` z <= y) = (x <= y).\nProof. by rewrite joinC; exact: (@disjoint_lexUl _ L^d). Qed.",
    "Lemma cover_leIxr z x y : z `|` y = \\top -> (z `&` x <= y) = (x <= y).\nProof. by rewrite joinC; exact: (@disjoint_lexUr _ L^d). Qed.",
    "Lemma leI2E x y z t : x `|` t = \\top -> y `|` z = \\top ->\n  (x `&` y <= z `&` t) = (x <= z) && (y <= t).\nProof. by move=> ? ?; apply: (@leU2E _ L^d); rewrite meetC. Qed.",
    "Lemma meets_total (I : finType) (d : L) (P : {pred I}) (F : I -> L) :\n   (forall i : I, P i -> d `|` F i = \\top) -> d `|` \\meet_(i | P i) F i = \\top.\nProof. exact: (@joins_disjoint _ L^d). Qed.",
    "Lemma ge_total : total (>=%O : rel T).\nProof. by move=> ? ?; apply: le_total. Qed.",
    "Lemma comparableT x y : x >=< y. Proof. exact: le_total. Qed.",
    "Lemma sort_le_sorted s : sorted <=%O (sort <=%O s).\nProof. exact: sort_sorted. Qed.",
    "Lemma sort_lt_sorted s : sorted <%O (sort <=%O s) = uniq s.\nProof. by rewrite lt_sorted_uniq_le sort_uniq sort_le_sorted andbT. Qed.",
    "Lemma perm_sort_leP s1 s2 : reflect (sort <=%O s1 = sort <=%O s2) (perm_eq s1 s2).\nProof. exact/perm_sortP/le_anti/le_trans/le_total. Qed.",
    "Lemma filter_sort_le p s : filter p (sort <=%O s) = sort <=%O (filter p s).\nProof. exact/filter_sort/le_trans/le_total. Qed.",
    "Lemma mask_sort_le s (m : bitseq) :\n  {m_s : bitseq | mask m_s (sort <=%O s) = sort <=%O (mask m s)}.\nProof. exact/mask_sort/le_trans/le_total. Qed.",
    "Lemma sorted_mask_sort_le s (m : bitseq) :\n  sorted <=%O (mask m s) -> {m_s : bitseq | mask m_s (sort <=%O s) = mask m s}.\nProof. exact/sorted_mask_sort/le_trans/le_total. Qed.",
    "Lemma subseq_sort_le : {homo sort <=%O : s1 s2 / @subseq T s1 s2}.\nProof. exact/subseq_sort/le_trans/le_total. Qed.",
    "Lemma sorted_subseq_sort_le s1 s2 :\n  subseq s1 s2 -> sorted <=%O s1 -> subseq s1 (sort <=%O s2).\nProof. exact/sorted_subseq_sort/le_trans/le_total. Qed.",
    "Lemma mem2_sort_le s x y : x <= y -> mem2 s x y -> mem2 (sort <=%O s) x y.\nProof. exact/mem2_sort/le_trans/le_total. Qed.",
    "Lemma leNgt x y : (x <= y) = ~~ (y < x). Proof. exact: comparable_leNgt. Qed.",
    "Lemma ltNge x y : (x < y) = ~~ (y <= x). Proof. exact: comparable_ltNge. Qed.",
    "Lemma wlog_le P :\n     (forall x y, P y x -> P x y) -> (forall x y, x <= y -> P x y) ->\n   forall x y, P x y.\nProof. by move=> sP hP x y; case: (leP x y) => [| /ltW] /hP // /sP. Qed.",
    "Lemma wlog_lt P :\n    (forall x, P x x) ->\n    (forall x y, (P y x -> P x y)) -> (forall x y, x < y -> P x y) ->\n  forall x y, P x y.\nProof. by move=> rP sP hP x y; case: (ltgtP x y) => [||->] // /hP // /sP. Qed.",
    "Lemma neq_lt x y : (x != y) = (x < y) || (y < x). Proof. by case: ltgtP. Qed.",
    "Lemma lt_total x y : x != y -> (x < y) || (y < x). Proof. by case: ltgtP. Qed.",
    "Lemma eq_leLR x y z t :\n  (x <= y -> z <= t) -> (y < x -> t < z) -> (x <= y) = (z <= t).\nProof. by rewrite !ltNge => ? /contraTT ?; apply/idP/idP. Qed.",
    "Lemma eq_leRL x y z t :\n  (x <= y -> z <= t) -> (y < x -> t < z) -> (z <= t) = (x <= y).\nProof. by move=> *; apply/esym/eq_leLR. Qed.",
    "Lemma eq_ltLR x y z t :\n  (x < y -> z < t) -> (y <= x -> t <= z) -> (x < y) = (z < t).\nProof. by rewrite !leNgt => ? /contraTT ?; apply/idP/idP. Qed.",
    "Lemma eq_ltRL x y z t :\n  (x < y -> z < t) -> (y <= x -> t <= z) -> (z < t) = (x < y).\nProof. by move=> *; apply/esym/eq_ltLR. Qed.",
    "Lemma meetEtotal x y : x `&` y = min x y. Proof. by case: leP. Qed.",
    "Lemma joinEtotal x y : x `|` y = max x y. Proof. by case: leP. Qed.",
    "Lemma minEgt x y : min x y = if x > y then y else x. Proof. by case: ltP. Qed.",
    "Lemma maxEgt x y : max x y = if x > y then x else y. Proof. by case: ltP. Qed.",
    "Lemma minEge x y : min x y = if x >= y then y else x. Proof. by case: leP. Qed.",
    "Lemma maxEge x y : max x y = if x >= y then x else y. Proof. by case: leP. Qed.",
    "Lemma minC : commutative (min : T -> T -> T).\nProof. by move=> x y; apply: comparable_minC. Qed.",
    "Lemma maxC : commutative (max : T -> T -> T).\nProof. by move=> x y; apply: comparable_maxC. Qed.",
    "Lemma minA : associative (min : T -> T -> T).\nProof. by move=> x y z; apply: comparable_minA. Qed.",
    "Lemma maxA : associative (max : T -> T -> T).\nProof. by move=> x y z; apply: comparable_maxA. Qed.",
    "Lemma minAC : right_commutative (min : T -> T -> T).\nProof. by move=> x y z; apply: comparable_minAC. Qed.",
    "Lemma maxAC : right_commutative (max : T -> T -> T).\nProof. by move=> x y z; apply: comparable_maxAC. Qed.",
    "Lemma minCA : left_commutative (min : T -> T -> T).\nProof. by move=> x y z; apply: comparable_minCA. Qed.",
    "Lemma maxCA : left_commutative (max : T -> T -> T).\nProof. by move=> x y z; apply: comparable_maxCA. Qed.",
    "Lemma minACA : interchange (min : T -> T -> T) min.\nProof. by move=> x y z t; apply: comparable_minACA. Qed.",
    "Lemma maxACA : interchange (max : T -> T -> T) max.\nProof. by move=> x y z t; apply: comparable_maxACA. Qed.",
    "Lemma eq_minr x y : (min x y == y) = (y <= x).\nProof. exact: comparable_eq_minr. Qed.",
    "Lemma eq_maxl x y : (max x y == x) = (y <= x).\nProof. exact: comparable_eq_maxl. Qed.",
    "Lemma min_idPr x y : reflect (min x y = y) (y <= x).\nProof. exact: comparable_min_idPr. Qed.",
    "Lemma max_idPl x y : reflect (max x y = x) (y <= x).\nProof. exact: comparable_max_idPl. Qed.",
    "Lemma le_min z x y : (z <= min x y) = (z <= x) && (z <= y).\nProof. exact: comparable_le_min. Qed.",
    "Lemma ge_min z x y : (min x y <= z) = (x <= z) || (y <= z).\nProof. exact: comparable_ge_min. Qed.",
    "Lemma lt_min z x y : (z < min x y) = (z < x) && (z < y).\nProof. exact: comparable_lt_min. Qed.",
    "Lemma gt_min z x y : (min x y < z) = (x < z) || (y < z).\nProof. exact: comparable_gt_min. Qed.",
    "Lemma le_max z x y : (z <= max x y) = (z <= x) || (z <= y).\nProof. exact: comparable_le_max. Qed.",
    "Lemma ge_max z x y : (max x y <= z) = (x <= z) && (y <= z).\nProof. exact: comparable_ge_max. Qed.",
    "Lemma lt_max z x y : (z < max x y) = (z < x) || (z < y).\nProof. exact: comparable_lt_max. Qed.",
    "Lemma gt_max z x y : (max x y < z) = (x < z) && (y < z).\nProof. exact: comparable_gt_max. Qed.",
    "Lemma minxK x y : max (min x y) y = y. Proof. exact: comparable_minxK. Qed.",
    "Lemma minKx x y : max x (min x y) = x. Proof. exact: comparable_minKx. Qed.",
    "Lemma maxxK x y : min (max x y) y = y. Proof. exact: comparable_maxxK. Qed.",
    "Lemma maxKx x y : min x (max x y) = x. Proof. exact: comparable_maxKx. Qed.",
    "Lemma max_minl : left_distributive (max : T -> T -> T) min.\nProof. by move=> x y z; apply: comparable_max_minl. Qed.",
    "Lemma min_maxl : left_distributive (min : T -> T -> T) max.\nProof. by move=> x y z; apply: comparable_min_maxl. Qed.",
    "Lemma max_minr : right_distributive (max : T -> T -> T) min.\nProof. by move=> x y z; apply: comparable_max_minr. Qed.",
    "Lemma min_maxr : right_distributive (min : T -> T -> T) max.\nProof. by move=> x y z; apply: comparable_min_maxr. Qed.",
    "Lemma leIx x y z : (meet y z <= x) = (y <= x) || (z <= x).\nProof. by rewrite meetEtotal ge_min. Qed.",
    "Lemma lexU x y z : (x <= join y z) = (x <= y) || (x <= z).\nProof. by rewrite joinEtotal le_max. Qed.",
    "Lemma ltxI x y z : (x < meet y z) = (x < y) && (x < z).\nProof. by rewrite !ltNge leIx negb_or. Qed.",
    "Lemma ltIx x y z : (meet y z < x) = (y < x) || (z < x).\nProof. by rewrite !ltNge lexI negb_and. Qed.",
    "Lemma ltxU x y z : (x < join y z) = (x < y) || (x < z).\nProof. by rewrite !ltNge leUx negb_and. Qed.",
    "Lemma ltUx x y z : (join y z < x) = (y < x) && (z < x).\nProof. by rewrite !ltNge lexU negb_or. Qed.",
    "Lemma le_min2 x y z t : x <= z -> y <= t -> Order.min x y <= Order.min z t.\nProof. exact: comparable_le_min2. Qed.",
    "Lemma le_max2 x y z t : x <= z -> y <= t -> Order.max x y <= Order.max z t.\nProof. exact: comparable_le_max2. Qed.",
    "Lemma lteifNE x y C : x < y ?<= if ~~ C = ~~ (y < x ?<= if C).\nProof. by case: C => /=; case: leP. Qed.",
    "Lemma lteif_minr z x y C :\n  (z < min x y ?<= if C) = (z < x ?<= if C) && (z < y ?<= if C).\nProof. by case: C; rewrite /= (le_min, lt_min). Qed.",
    "Lemma lteif_minl z x y C :\n  (min x y < z ?<= if C) = (x < z ?<= if C) || (y < z ?<= if C).\nProof. by case: C; rewrite /= (ge_min, gt_min). Qed.",
    "Lemma lteif_maxr z x y C :\n  (z < max x y ?<= if C) = (z < x ?<= if C) || (z < y ?<= if C).\nProof. by case: C; rewrite /= (le_max, lt_max). Qed.",
    "Lemma lteif_maxl z x y C :\n  (max x y < z ?<= if C) = (x < z ?<= if C) && (y < z ?<= if C).\nProof. by case: C; rewrite /= (ge_max, gt_max). Qed.",
    "Lemma arg_minP: extremum_spec <=%O P F (arg_min i0 P F).\nProof. by apply: extremumP => //; apply: le_trans. Qed.",
    "Lemma arg_maxP: extremum_spec >=%O P F (arg_max i0 P F).\nProof. by apply: extremumP => //; [apply: ge_refl | apply: ge_trans]. Qed.",
    "Lemma count_le_gt x s : count (<= x) s = size s - count (> x) s.\nProof.\nby rewrite -(count_predC (> x)) addKn; apply: eq_count => y; rewrite /= leNgt.\nQed.",
    "Lemma count_lt_ge x s : count (< x) s = size s - count (>= x) s.\nProof.\nby rewrite -(count_predC (>= x)) addKn; apply: eq_count => y; rewrite /= ltNge.\nQed.",
    "Lemma bigmin_mkcond P F : \\big[min/x]_(i <- r | P i) F i =\n  \\big[min/x]_(i <- r) (if P i then F i else x).\nProof. by rewrite big_mkcond_idem //= minxx. Qed.",
    "Lemma bigmax_mkcond P F :\n  \\big[max/x]_(i <- r | P i) F i = \\big[max/x]_(i <- r) if P i then F i else x.\nProof. by rewrite big_mkcond_idem //= maxxx. Qed.",
    "Lemma bigmin_mkcondl P Q F :\n  \\big[min/x]_(i <- r | P i && Q i) F i\n  = \\big[min/x]_(i <- r | Q i) if P i then F i else x.\nProof.\nrewrite bigmin_mkcond [RHS]bigmin_mkcond.\nby apply: eq_bigr => i _; case: P; case: Q.\nQed.",
    "Lemma bigmin_mkcondr P Q F :\n  \\big[min/x]_(i <- r | P i && Q i) F i\n  = \\big[min/x]_(i <- r | P i) if Q i then F i else x.\nProof. by under eq_bigl do rewrite andbC; apply: bigmin_mkcondl. Qed.",
    "Lemma bigmax_mkcondl P Q F :\n  \\big[max/x]_(i <- r | P i && Q i) F i\n  = \\big[max/x]_(i <- r | Q i) if P i then F i else x.\nProof.\nrewrite bigmax_mkcond [RHS]bigmax_mkcond.\nby apply: eq_bigr => i _; case: P; case: Q.\nQed.",
    "Lemma bigmax_mkcondr P Q F :\n  \\big[max/x]_(i <- r | P i && Q i) F i\n  = \\big[max/x]_(i <- r | P i) if Q i then F i else x.\nProof. by under eq_bigl do rewrite andbC; apply: bigmax_mkcondl. Qed.",
    "Lemma bigmin_split P F1 F2 :\n  \\big[min/x]_(i <- r | P i) (min (F1 i) (F2 i)) =\n    min (\\big[min/x]_(i <- r | P i) F1 i) (\\big[min/x]_(i <- r | P i) F2 i).\nProof. by rewrite big_split_idem //= minxx. Qed.",
    "Lemma bigmax_split P F1 F2 :\n  \\big[max/x]_(i <- r | P i) (max (F1 i) (F2 i)) =\n    max (\\big[max/x]_(i <- r | P i) F1 i) (\\big[max/x]_(i <- r | P i) F2 i).\nProof. by rewrite big_split_idem //= maxxx. Qed.",
    "Lemma bigmin_idl P F :\n  \\big[min/x]_(i <- r | P i) F i = min x (\\big[min/x]_(i <- r | P i) F i).\nProof. by rewrite minC big_id_idem //= minxx. Qed.",
    "Lemma bigmax_idl P F :\n  \\big[max/x]_(i <- r | P i) F i = max x (\\big[max/x]_(i <- r | P i) F i).\nProof. by rewrite maxC big_id_idem //= maxxx. Qed.",
    "Lemma bigmin_idr P F :\n  \\big[min/x]_(i <- r | P i) F i = min (\\big[min/x]_(i <- r | P i) F i) x.\nProof. by rewrite [LHS]bigmin_idl minC. Qed.",
    "Lemma bigmax_idr P F :\n  \\big[max/x]_(i <- r | P i) F i = max (\\big[max/x]_(i <- r | P i) F i) x.\nProof. by rewrite [LHS]bigmax_idl maxC. Qed.",
    "Lemma bigminID a P F : \\big[min/x]_(i <- r | P i) F i =\n  min (\\big[min/x]_(i <- r | P i && a i) F i)\n      (\\big[min/x]_(i <- r | P i && ~~ a i) F i).\nProof. by rewrite (bigID_idem _ _ a) //= minxx. Qed.",
    "Lemma bigmaxID a P F : \\big[max/x]_(i <- r | P i) F i =\n  max (\\big[max/x]_(i <- r | P i && a i) F i)\n      (\\big[max/x]_(i <- r | P i && ~~ a i) F i).\nProof. by rewrite (bigID_idem _ _ a) //= maxxx. Qed.",
    "Lemma sub_bigmin [x0] I r (P P' : {pred I}) (F : I -> T) :\n    (forall i, P' i -> P i) ->\n  \\big[min/x0]_(i <- r | P i) F i <= \\big[min/x0]_(i <- r | P' i) F i.\nProof. exact: (sub_le_big ge_refl). Qed.",
    "Lemma sub_bigmax [x0] I r (P P' : {pred I}) (F : I -> T) :\n    (forall i, P i -> P' i) ->\n  \\big[max/x0]_(i <- r | P i) F i <= \\big[max/x0]_(i <- r | P' i) F i.\nProof. exact: sub_le_big. Qed.",
    "Lemma sub_bigmin_seq [x0] (I : eqType) r r' P (F : I -> T) : {subset r' <= r} ->\n  \\big[min/x0]_(i <- r | P i) F i <= \\big[min/x0]_(i <- r' | P i) F i.\nProof. exact: (idem_sub_le_big ge_refl _ minxx). Qed.",
    "Lemma sub_bigmax_seq [x0] (I : eqType) r r' P (F : I -> T) : {subset r <= r'} ->\n  \\big[max/x0]_(i <- r | P i) F i <= \\big[max/x0]_(i <- r' | P i) F i.\nProof. exact: (idem_sub_le_big _ _ maxxx). Qed.",
    "Lemma sub_bigmin_cond [x0] (I : eqType) r r' P P' (F : I -> T) :\n    {subset [seq i <- r | P i] <= [seq i <- r' | P' i]} ->\n  \\big[min/x0]_(i <- r' | P' i) F i <= \\big[min/x0]_(i <- r | P i) F i.\nProof. exact: (idem_sub_le_big_cond ge_refl _ minxx). Qed.",
    "Lemma sub_bigmax_cond [x0] (I : eqType) r r' P P' (F : I -> T) :\n    {subset [seq i <- r | P i] <= [seq i <- r' | P' i]} ->\n  \\big[max/x0]_(i <- r | P i) F i <= \\big[max/x0]_(i <- r' | P' i) F i.\nProof. exact: (idem_sub_le_big_cond _ _ maxxx). Qed.",
    "Lemma sub_in_bigmin [x0] [I : eqType] (r : seq I) (P P' : {pred I}) F :\n    {in r, forall i, P' i -> P i} ->\n  \\big[min/x0]_(i <- r | P i) F i <= \\big[min/x0]_(i <- r | P' i) F i.\nProof. exact: (sub_in_le_big ge_refl). Qed.",
    "Lemma sub_in_bigmax [x0] [I : eqType] (r : seq I) (P P' : {pred I}) F :\n    {in r, forall i, P i -> P' i} ->\n  \\big[max/x0]_(i <- r | P i) F i <= \\big[max/x0]_(i <- r | P' i) F i.\nProof. exact: sub_in_le_big. Qed.",
    "Lemma le_bigmin_nat [x0] n m n' m' P (F : nat -> T) :\n    (n <= n')%N -> (m' <= m)%N ->\n  \\big[min/x0]_(n <= i < m | P i) F i <= \\big[min/x0]_(n' <= i < m' | P i) F i.\nProof. exact: (le_big_nat ge_refl). Qed.",
    "Lemma le_bigmax_nat [x0] n m n' m' P (F : nat -> T) :\n    (n' <= n)%N -> (m <= m')%N ->\n  \\big[max/x0]_(n <= i < m | P i) F i <= \\big[max/x0]_(n' <= i < m' | P i) F i.\nProof. exact: le_big_nat. Qed.",
    "Lemma le_bigmin_nat_cond [x0] n m n' m' (P P' : pred nat) (F : nat -> T) :\n    (n <= n')%N -> (m' <= m)%N -> (forall i, (n' <= i < m')%N -> P' i -> P i) ->\n  \\big[min/x0]_(n <= i < m | P i) F i <= \\big[min/x0]_(n' <= i < m' | P' i) F i.\nProof. exact: (le_big_nat_cond ge_refl). Qed.",
    "Lemma le_bigmax_nat_cond [x0] n m n' m' (P P' : {pred nat}) (F : nat -> T) :\n    (n' <= n)%N -> (m <= m')%N -> (forall i, (n <= i < m)%N -> P i -> P' i) ->\n  \\big[max/x0]_(n <= i < m | P i) F i <= \\big[max/x0]_(n' <= i < m' | P' i) F i.\nProof. exact: le_big_nat_cond. Qed.",
    "Lemma le_bigmin_ord [x0] n m (P : pred nat) (F : nat -> T) : (m <= n)%N ->\n  \\big[min/x0]_(i < n | P i) F i <= \\big[min/x0]_(i < m | P i) F i.\nProof. exact: (le_big_ord ge_refl). Qed.",
    "Lemma le_bigmax_ord [x0] n m (P : {pred nat}) (F : nat -> T) : (n <= m)%N ->\n  \\big[max/x0]_(i < n | P i) F i <= \\big[max/x0]_(i < m | P i) F i.\nProof. exact: le_big_ord. Qed.",
    "Lemma le_bigmin_ord_cond [x0] n m (P P' : pred nat) (F : nat -> T) :\n    (m <= n)%N -> (forall i : 'I_m, P' i -> P i) ->\n  \\big[min/x0]_(i < n | P i) F i <= \\big[min/x0]_(i < m | P' i) F i.\nProof. exact: (le_big_ord_cond ge_refl). Qed.",
    "Lemma le_bigmax_ord_cond [x0] n m (P P' : {pred nat}) (F : nat -> T) :\n    (n <= m)%N -> (forall i : 'I_n, P i -> P' i) ->\n  \\big[max/x0]_(i < n | P i) F i <= \\big[max/x0]_(i < m | P' i) F i.\nProof. exact: le_big_ord_cond. Qed.",
    "Lemma subset_bigmin [x0] [I : finType] [A A' P : {pred I}] (F : I -> T) :\n    A' \\subset A ->\n  \\big[min/x0]_(i in A | P i) F i <= \\big[min/x0]_(i in A' | P i) F i.\nProof. exact: (subset_le_big ge_refl). Qed.",
    "Lemma subset_bigmax [x0] [I : finType] (A A' P : {pred I}) (F : I -> T) :\n    A \\subset A' ->\n  \\big[max/x0]_(i in A | P i) F i <= \\big[max/x0]_(i in A' | P i) F i.\nProof. exact: subset_le_big. Qed.",
    "Lemma subset_bigmin_cond [x0] (I : finType) (A A' P P' : {pred I}) (F : I -> T) :\n    [set i in A' | P' i]  \\subset [set i in A | P i] ->\n  \\big[min/x0]_(i in A | P i) F i <= \\big[min/x0]_(i in A' | P' i) F i.\nProof. exact: (subset_le_big_cond ge_refl). Qed.",
    "Lemma subset_bigmax_cond [x0] (I : finType) (A A' P P' : {pred I}) (F : I -> T) :\n    [set i in A | P i]  \\subset [set i in A' | P' i] ->\n  \\big[max/x0]_(i in A | P i) F i <= \\big[max/x0]_(i in A' | P' i) F i.\nProof. exact: subset_le_big_cond. Qed.",
    "Lemma bigmin_le_id P F : \\big[min/x]_(i <- r | P i) F i <= x.\nProof. by rewrite bigmin_idl. Qed.",
    "Lemma bigmax_ge_id P F : \\big[max/x]_(i <- r | P i) F i >= x.\nProof. by rewrite bigmax_idl. Qed.",
    "Lemma bigmin_eq_id P F :\n  (forall i, P i -> x <= F i) -> \\big[min/x]_(i <- r | P i) F i = x.\nProof. by move=> x_le; apply: le_anti; rewrite bigmin_le_id le_bigmin. Qed.",
    "Lemma bigmax_eq_id P F :\n  (forall i, P i -> x >= F i) -> \\big[max/x]_(i <- r | P i) F i = x.\nProof. by move=> x_ge; apply: le_anti; rewrite bigmax_ge_id bigmax_le. Qed.",
    "Lemma bigminD1 j P F : P j ->\n  \\big[min/x]_(i | P i) F i = min (F j) (\\big[min/x]_(i | P i && (i != j)) F i).\nProof. by move/(bigD1 _) ->. Qed.",
    "Lemma bigmaxD1 j P F : P j ->\n  \\big[max/x]_(i | P i) F i = max (F j) (\\big[max/x]_(i | P i && (i != j)) F i).\nProof. by move/(bigD1 _) ->. Qed.",
    "Lemma bigmin_le_cond j P F : P j -> \\big[min/x]_(i | P i) F i <= F j.\nProof.\nhave := mem_index_enum j; rewrite unlock; elim: (index_enum I) => //= i l ih.\nrewrite inE => /orP [/eqP-> ->|/ih leminlfi Pi]; first by rewrite ge_min lexx.\nby case: ifPn => Pj; [rewrite ge_min leminlfi// orbC|exact: leminlfi].\nQed.",
    "Lemma le_bigmax_cond j P F : P j -> F j <= \\big[max/x]_(i | P i) F i.\nProof. by move=> Pj; rewrite (bigmaxD1 _ Pj) le_max lexx. Qed.",
    "Lemma bigmin_le j F : \\big[min/x]_i F i <= F j.\nProof. exact: bigmin_le_cond. Qed.",
    "Lemma le_bigmax F j : F j <= \\big[max/x]_i F i.\nProof. exact: le_bigmax_cond. Qed.",
    "Lemma bigmin_inf j P m F : P j -> F j <= m -> \\big[min/x]_(i | P i) F i <= m.\nProof. by move=> Pj ?; apply: le_trans (bigmin_le_cond _ Pj) _. Qed.",
    "Lemma bigmax_sup j P m F : P j -> m <= F j -> m <= \\big[max/x]_(i | P i) F i.\nProof. by move=> Pj ?; apply: le_trans (le_bigmax_cond _ Pj). Qed.",
    "Lemma bigmin_geP m P F :\n  reflect (m <= x /\\ forall i, P i -> m <= F i)\n          (m <= \\big[min/x]_(i | P i) F i).\nProof.\napply: (iffP idP) => [lemFi|[lemx lemPi]]; [split|exact: le_bigmin].\n- by rewrite (le_trans lemFi)// bigmin_idl ge_min lexx.\n- by move=> i Pi; rewrite (le_trans lemFi)// (bigminD1 _ Pi)// le_minl lexx.\nQed.",
    "Lemma bigmax_leP m P F :\n  reflect (x <= m /\\ forall i, P i -> F i <= m)\n          (\\big[max/x]_(i | P i) F i <= m).\nProof.\napply: (iffP idP) => [|[? ?]]; last exact: bigmax_le.\nrewrite bigmax_idl ge_max => /andP[-> leFm]; split=> // i Pi.\nby apply: le_trans leFm; exact: le_bigmax_cond.\nQed.",
    "Lemma bigmin_gtP m P F :\n  reflect (m < x /\\ forall i, P i -> m < F i) (m < \\big[min/x]_(i | P i) F i).\nProof.\napply: (iffP idP) => [lemFi|[lemx lemPi]]; [split|exact: lt_bigmin].\n- by rewrite (lt_le_trans lemFi)// bigmin_idl ge_min lexx.\n- by move=> i Pi; rewrite (lt_le_trans lemFi)// (bigminD1 _ Pi)// le_minl lexx.\nQed.",
    "Lemma bigmax_ltP m P F :\n  reflect (x < m /\\ forall i, P i -> F i < m) (\\big[max/x]_(i | P i) F i < m).\nProof.\napply: (iffP idP) => [|[? ?]]; last exact: bigmax_lt.\nrewrite bigmax_idl gt_max => /andP[-> ltFm]; split=> // i Pi.\nby apply: le_lt_trans ltFm; exact: le_bigmax_cond.\nQed.",
    "Lemma bigmin_eq_arg j P F : P j -> (forall i, P i -> F i <= x) ->\n  \\big[min/x]_(i | P i) F i = F [arg min_(i < j | P i) F i].\nProof.\nmove=> Pi0; case: arg_minP => //= i Pi PF PFx.\napply/eqP; rewrite eq_le bigmin_le_cond //=.\nby apply/bigmin_geP; split => //; exact: PFx.\nQed.",
    "Lemma bigmax_eq_arg j P F : P j -> (forall i, P i -> x <= F i) ->\n  \\big[max/x]_(i | P i) F i = F [arg max_(i > j | P i) F i].\nProof.\nmove=> Pi0; case: arg_maxP => //= i Pi PF PxF.\napply/eqP; rewrite eq_le le_bigmax_cond // andbT.\nby apply/bigmax_leP; split => //; exact: PxF.\nQed.",
    "Lemma eq_bigmin j P F : P j -> (forall i, P i -> F i <= x) ->\n  {i0 | i0 \\in P & \\big[min/x]_(i | P i) F i = F i0}.\nProof.\nby move=> Pi0 Hx; rewrite (bigmin_eq_arg Pi0) //; eexists=> //; case: arg_minP.\nQed.",
    "Lemma eq_bigmax j P F : P j -> (forall i, P i -> x <= F i) ->\n  {i0 | i0 \\in P & \\big[max/x]_(i | P i) F i = F i0}.\nProof.\nby move=> Pi0 Hx; rewrite (bigmax_eq_arg Pi0) //; eexists=> //; case: arg_maxP.\nQed.",
    "Lemma le_bigmin2 P F1 F2 : (forall i, P i -> F1 i <= F2 i) ->\n  \\big[min/x]_(i | P i) F1 i <= \\big[min/x]_(i | P i) F2 i.\nProof.\nmove=> FG; elim/big_ind2 : _ => // a b e f ba fe.\nrewrite ge_min 2!le_min ba fe /= andbT.\nmove: (le_total a e) => /orP[/(le_trans ba)-> // | /(le_trans fe)->].\nby rewrite orbT.\nQed.",
    "Lemma le_bigmax2 P F1 F2 : (forall i, P i -> F1 i <= F2 i) ->\n  \\big[max/x]_(i | P i) F1 i <= \\big[max/x]_(i | P i) F2 i.\nProof.\nmove=> FG; elim/big_ind2 : _ => // a b e f ba fe.\nrewrite le_max 2!ge_max ba fe /= andbT; have [//|/= af] := leP f a.\nby rewrite (le_trans ba) // (le_trans _ fe) // ltW.\nQed.",
    "Lemma bigmaxUl (A B : {set I}) F :\n  \\big[max/x]_(i in A) F i <= \\big[max/x]_(i in A :|: B) F i.\nProof. by apply: sub_bigmax => t; rewrite in_setU => ->. Qed.",
    "Lemma bigmaxUr (A B : {set I}) F :\n  \\big[max/x]_(i in B) F i <= \\big[max/x]_(i in A :|: B) F i.\nProof. by under [leRHS]eq_bigl do rewrite setUC; apply: bigmaxUl. Qed.",
    "Lemma bigminUl (A B : {set I}) F :\n  \\big[min/x]_(i in A) F i >= \\big[min/x]_(i in A :|: B) F i.\nProof. by apply: sub_bigmin => t; rewrite in_setU => ->. Qed.",
    "Lemma bigminUr (A B : {set I}) F :\n  \\big[min/x]_(i in B) F i >= \\big[min/x]_(i in A :|: B) F i.\nProof. by under [leLHS]eq_bigl do rewrite setUC; apply: bigminUl. Qed.",
    "Lemma bigmaxIl (A B : {set I}) F :\n  \\big[max/x]_(i in A) F i >= \\big[max/x]_(i in A :&: B) F i.\nProof. by apply: sub_bigmax => t; rewrite in_setI => /andP[-> _]. Qed.",
    "Lemma bigmaxIr (A B : {set I}) F :\n  \\big[max/x]_(i in B) F i >= \\big[max/x]_(i in A :&: B) F i.\nProof. by under eq_bigl do rewrite setIC; apply: bigmaxIl. Qed.",
    "Lemma bigminIl (A B : {set I}) F :\n  \\big[min/x]_(i in A) F i <= \\big[min/x]_(i in A :&: B) F i.\nProof. by apply: sub_bigmin => t; rewrite in_setI => /andP[->_]. Qed.",
    "Lemma bigminIr (A B : {set I}) F :\n  \\big[min/x]_(i in B) F i <= \\big[min/x]_(i in A :&: B) F i.\nProof. by under [leRHS]eq_bigl do rewrite setIC; apply: bigminIl. Qed.",
    "Lemma bigmaxD (A B : {set I}) F :\n  \\big[max/x]_(i in B) F i >= \\big[max/x]_(i in B :\\: A) F i.\nProof. by apply: sub_bigmax => t; rewrite in_setD => /andP[_->]. Qed.",
    "Lemma bigminD (A B : {set I}) F :\n  \\big[min/x]_(i in B) F i <= \\big[min/x]_(i in B :\\: A) F i.\nProof. by apply: sub_bigmin => t; rewrite in_setD => /andP[_->]. Qed.",
    "Lemma bigmaxU (A B : {set I}) F :\n  \\big[max/x]_(i in A :|: B) F i\n  = max (\\big[max/x]_(i in A) F i) (\\big[max/x]_(i in B) F i).\nProof.\napply: le_anti; rewrite ge_max bigmaxUl bigmaxUr !andbT; apply/bigmax_leP.\nsplit=> [|i /[!in_setU]/orP[iA|iB]]; first by rewrite le_max bigmax_ge_id.\n- by rewrite le_max le_bigmax_cond.\n- by rewrite le_max orbC le_bigmax_cond.\nQed.",
    "Lemma bigminU (A B : {set I}) F :\n  \\big[min/x]_(i in A :|: B) F i\n  = min (\\big[min/x]_(i in A) F i) (\\big[min/x]_(i in B) F i).\nProof.\napply: le_anti; rewrite le_min bigminUl bigminUr !andbT; apply/bigmin_geP.\nsplit=> [|i /[!in_setU]/orP[iA|iB]]; first by rewrite ge_min bigmin_le_id.\n- by rewrite ge_min bigmin_le_cond.\n- by rewrite ge_min orbC bigmin_le_cond.\nQed.",
    "Lemma bigmin_set1 j F : \\big[min/x]_(i in [set j]) F i = min (F j) x.\nProof. exact: big_set1E. Qed.",
    "Lemma bigmax_set1 j F : \\big[max/x]_(i in [set j]) F i = max (F j) x.\nProof. exact: big_set1E. Qed.",
    "Lemma bigmin_imset [I J : finType] x [h : I -> J] [A : {set I}] (F : J -> T) :\n  \\big[min/x]_(j in [set h x | x in A]) F j = \\big[min/x]_(i in A) F (h i).\nProof. by apply: big_imset_idem; apply: minxx. Qed.",
    "Lemma bigmax_imset [I J : finType] x [h : I -> J] [A : {set I}] (F : J -> T) :\n  \\big[max/x]_(j in [set h x | x in A]) F j = \\big[max/x]_(i in A) F (h i).\nProof. by apply: big_imset_idem; apply: maxxx. Qed.",
    "Lemma sorted_filter_gt x s :\n  sorted <=%O s -> [seq y <- s | x < y] = drop (count (<= x) s) s.\nProof.\nmove=> s_sorted; rewrite count_le_gt -[LHS]revK -filter_rev.\nrewrite (@sorted_filter_lt _ T^d); first by rewrite take_rev revK count_rev.\nby rewrite rev_sorted.\nQed.",
    "Lemma sorted_filter_ge x s :\n  sorted <=%O s -> [seq y <- s | x <= y] = drop (count (< x) s) s.\nProof.\nmove=> s_sorted; rewrite count_lt_ge -[LHS]revK -filter_rev.\nrewrite (@sorted_filter_le _ T^d); first by rewrite take_rev revK count_rev.\nby rewrite rev_sorted.\nQed.",
    "Lemma nth_count_ge x x0 s i : sorted <=%O s ->\n  (count (< x) s <= i < size s)%N -> x <= nth x0 s i.\nProof.\nmove=> ss /andP[ige ilt]; rewrite -(subnKC ige) -nth_drop -sorted_filter_ge //.\napply/(all_nthP _ (filter_all _ _)).\nby rewrite size_filter ltn_subLR // count_lt_ge subnK // count_size.\nQed.",
    "Lemma nth_count_gt x x0 s i : sorted <=%O s ->\n  (count (<= x) s <= i < size s)%N -> x < nth x0 s i.\nProof.\nmove=> ss /andP[ige ilt]; rewrite -(subnKC ige) -nth_drop -sorted_filter_gt //.\napply/(all_nthP _ (filter_all _ _)).\nby rewrite size_filter ltn_subLR // count_le_gt subnK // count_size.\nQed.",
    "Lemma nth_count_eq x x0 s i : sorted <=%O s ->\n  (count (< x) s <= i < count (<= x) s)%N -> nth x0 s i = x.\nProof.\nmove=> ss /andP[ige ilt]; apply/le_anti.\nby rewrite nth_count_le// nth_count_ge// ige (leq_trans ilt (count_size _ _)).\nQed.",
    "Lemma contraTle b z t : (t < z -> ~~ b) -> (b -> z <= t).\nProof. exact: comparable_contraTle. Qed.",
    "Lemma contraTlt b z t : (t <= z -> ~~ b) -> (b -> z < t).\nProof. exact: comparable_contraTlt. Qed.",
    "Lemma contraPle P z t : (t < z -> ~ P) -> (P -> z <= t).\nProof. exact: comparable_contraPle. Qed.",
    "Lemma contraPlt P z t : (t <= z -> ~ P) -> (P -> z < t).\nProof. exact: comparable_contraPlt. Qed.",
    "Lemma contraNle b z t : (t < z -> b) -> (~~ b -> z <= t).\nProof. exact: comparable_contraNle. Qed.",
    "Lemma contraNlt b z t : (t <= z -> b) -> (~~ b -> z < t).\nProof. exact: comparable_contraNlt. Qed.",
    "Lemma contra_not_le P z t : (t < z -> P) -> (~ P -> z <= t).\nProof. exact: comparable_contra_not_le. Qed.",
    "Lemma contra_not_lt P z t : (t <= z -> P) -> (~ P -> z < t).\nProof. exact: comparable_contra_not_lt. Qed.",
    "Lemma contraFle b z t : (t < z -> b) -> (b = false -> z <= t).\nProof. exact: comparable_contraFle. Qed.",
    "Lemma contraFlt b z t : (t <= z -> b) -> (b = false -> z < t).\nProof. exact: comparable_contraFlt. Qed.",
    "Lemma contra_leq_le m n z t : (t < z -> (n < m)%N) -> ((m <= n)%N -> z <= t).\nProof. exact: comparable_contra_leq_le. Qed.",
    "Lemma contra_leq_lt m n z t : (t <= z -> (n < m)%N) -> ((m <= n)%N -> z < t).\nProof. exact: comparable_contra_leq_lt. Qed.",
    "Lemma contra_ltn_le m n z t : (t < z -> (n <= m)%N) -> ((m < n)%N -> z <= t).\nProof. exact: comparable_contra_ltn_le. Qed.",
    "Lemma contra_ltn_lt m n z t : (t <= z -> (n <= m)%N) -> ((m < n)%N -> z < t).\nProof. exact: comparable_contra_ltn_lt. Qed.",
    "Lemma contra_le x y z t : (t < z -> y < x) -> (x <= y -> z <= t).\nProof. exact: comparable_contra_le. Qed.",
    "Lemma contra_le_lt x y z t : (t <= z -> y < x) -> (x <= y -> z < t).\nProof. exact: comparable_contra_le_lt. Qed.",
    "Lemma contra_lt_le x y z t : (t < z -> y <= x) -> (x < y -> z <= t).\nProof. exact: comparable_contra_lt_le. Qed.",
    "Lemma contra_lt x y z t : (t <= z -> y <= x) -> (x < y -> z < t).\nProof. exact: comparable_contra_lt. Qed.",
    "Lemma le_mono : {homo f : x y / x < y} -> {mono f : x y / x <= y}.\nProof. exact: total_homo_mono. Qed.",
    "Lemma le_nmono : {homo f : x y /~ x < y} -> {mono f : x y /~ x <= y}.\nProof. exact: total_homo_mono. Qed.",
    "Lemma le_mono_in :\n  {in D &, {homo f : x y / x < y}} -> {in D &, {mono f : x y / x <= y}}.\nProof. exact: total_homo_mono_in. Qed.",
    "Lemma le_nmono_in :\n  {in D &, {homo f : x y /~ x < y}} -> {in D &, {mono f : x y /~ x <= y}}.\nProof. exact: total_homo_mono_in. Qed.",
    "Lemma rcomplPmeet x y z : ((x `&` y) `|` z) `&` rcompl x y z = x `&` y.\nProof. exact: rcomplPmeet. Qed.",
    "Lemma rcomplPjoin x y z : ((y `|` x) `&` z) `|` rcompl x y z = y `|` x.\nProof. exact: rcomplPjoin. Qed.",
    "Lemma rcomplKI x y z : x <= y -> (x `|` z) `&` rcompl x y z = x.\nProof. by move=> lexy; have := rcomplPmeet x y z; rewrite (meet_l lexy). Qed.",
    "Lemma rcomplKU x y z : x <= y -> (y `&` z) `|` rcompl x y z = y.\nProof. by move=> lexy; have := rcomplPjoin x y z; rewrite (join_l lexy). Qed.",
    "Lemma diffErcompl x y : x `\\` y = rcompl \\bot x y.\nProof. exact: diffErcompl. Qed.",
    "Lemma diffKI x y : y `&` (x `\\` y) = \\bot.\nProof. by have := rcomplKI y (le0x x); rewrite join0x diffErcompl. Qed.",
    "Lemma diffIK x y : (x `\\` y) `&` y = \\bot.\nProof. by rewrite meetC diffKI. Qed.",
    "Lemma meetIB z x y : (z `&` y) `&` (x `\\` y) = \\bot.\nProof. by rewrite -meetA diffKI meetx0. Qed.",
    "Lemma meetBI z x y : (x `\\` y) `&` (z `&` y) = \\bot.\nProof. by rewrite meetC meetIB. Qed.",
    "Lemma joinIB y x : (x `&` y) `|` (x `\\` y) = x.\nProof. by rewrite diffErcompl rcomplKU. Qed.",
    "Lemma joinBI y x : (x `\\` y) `|` (x `&` y) = x.\nProof. by rewrite joinC joinIB. Qed.",
    "Lemma joinIBC y x : (y `&` x) `|` (x `\\` y) = x.\nProof. by rewrite meetC joinIB. Qed.",
    "Lemma joinBIC y x : (x `\\` y) `|` (y `&` x) = x.\nProof. by rewrite meetC joinBI. Qed.",
    "Lemma leBx x y : x `\\` y <= x.\nProof. by rewrite -[leRHS](joinIB y) leUr. Qed.",
    "Lemma diffxx x : x `\\` x = \\bot.\nProof. by have := diffKI x x; rewrite meet_r. Qed.",
    "Lemma leBl z x y : x <= y -> x `\\` z <= y `\\` z.\nProof.\nrewrite -[leLHS](joinIB z) -[leRHS](joinIB z).\nby rewrite leU2E ?meetIB ?meetBI // => /andP [].\nQed.",
    "Lemma diffKU y x : y `|` (x `\\` y) = y `|` x.\nProof.\napply/eqP; rewrite eq_le leU2 //= leUx leUl.\nby apply/meet_idPl; have := joinIB y x; rewrite joinIl join_l.\nQed.",
    "Lemma diffUK y x : (x `\\` y) `|` y = x `|` y.\nProof. by rewrite joinC diffKU joinC. Qed.",
    "Lemma leBKU y x : y <= x -> y `|` (x `\\` y) = x.\nProof. by move=> /join_r {2}<-; rewrite diffKU. Qed.",
    "Lemma leBUK y x : y <= x -> (x `\\` y) `|` y = x.\nProof. by move=> leyx; rewrite joinC leBKU. Qed.",
    "Lemma leBLR x y z : (x `\\` y <= z) = (x <= y `|` z).\nProof.\napply/idP/idP; first by move=> /join_r <-; rewrite joinA diffKU joinAC leUr.\nby rewrite -{1}[x](joinIB y) => /(leU2r_le (diffIK _ _)).\nQed.",
    "Lemma diffUx x y z : (x `|` y) `\\` z = (x `\\` z) `|` (y `\\` z).\nProof.\napply/eqP; rewrite eq_le leUx !leBl ?leUr ?leUl ?andbT //.\nby rewrite leBLR joinA diffKU joinAC diffKU joinAC -joinA leUr.\nQed.",
    "Lemma diff_eq0 x y : (x `\\` y == \\bot) = (x <= y).\nProof. by rewrite -lex0 leBLR joinx0. Qed.",
    "Lemma joinxB x y z : x `|` (y `\\` z) = ((x `|` y) `\\` z) `|` (x `&` z).\nProof. by rewrite diffUx joinAC joinBI. Qed.",
    "Lemma joinBx x y z : (y `\\` z) `|` x = ((y `|` x) `\\` z) `|` (z `&` x).\nProof. by rewrite ![_ `|` x]joinC ![_ `&` x]meetC joinxB. Qed.",
    "Lemma leBr z x y : x <= y -> z `\\` y <= z `\\` x.\nProof. by move=> lexy; rewrite leBLR joinxB meet_r ?leBUK ?leUr ?lexUl. Qed.",
    "Lemma leB2 x y z t : x <= z -> t <= y -> x `\\` y <= z `\\` t.\nProof. by move=> /(@leBl t) ? /(@leBr x) /le_trans ->. Qed.",
    "Lemma meet_eq0E_diff z x y : x <= z -> (x `&` y == \\bot) = (x <= z `\\` y).\nProof.\nmove=> xz; apply/idP/idP; last by move=> /meet_r <-; rewrite -meetA meetBI.\nby move=> /eqP xIy_eq0; rewrite -[x](joinIB y) xIy_eq0 join0x leBl.\nQed.",
    "Lemma leBRL x y z : (x <= z `\\` y) = (x <= z) && (x `&` y == \\bot).\nProof.\napply/idP/idP => [xyz|]; first by rewrite (@meet_eq0E_diff z) // (le_trans xyz).\nby move=> /andP [?]; rewrite -meet_eq0E_diff.\nQed.",
    "Lemma eq_diff x y z : (x `\\` y == z) = (z <= x <= y `|` z) && (z `&` y == \\bot).\nProof. by rewrite eq_le leBLR leBRL andbCA andbA. Qed.",
    "Lemma diffxU x y z : z `\\` (x `|` y) = (z `\\` x) `&` (z `\\` y).\nProof.\napply/eqP; rewrite eq_le lexI !leBr ?leUl ?leUr //=.\nrewrite leBRL leIx2 ?leBx //= meetUr meetAC diffIK -meetA diffIK.\nby rewrite meet0x meetx0 joinx0.\nQed.",
    "Lemma diffx0 x : x `\\` \\bot = x.\nProof. by apply/eqP; rewrite eq_diff join0x meetx0 lexx eqxx. Qed.",
    "Lemma diff0x x : \\bot `\\` x = \\bot.\nProof. by apply/eqP; rewrite eq_diff joinx0 meet0x lexx eqxx le0x. Qed.",
    "Lemma diffIx x y z : (x `&` y) `\\` z = (x `\\` z) `&` (y `\\` z).\nProof.\napply/eqP; rewrite eq_diff joinIr ?leI2 ?diffKU ?leUr ?leBx //=.\nby rewrite -meetA diffIK meetx0.\nQed.",
    "Lemma meetxB x y z : x `&` (y `\\` z) = (x `&` y) `\\` z.\nProof. by rewrite diffIx -{1}[x](joinBI z) meetUl meetIB joinx0. Qed.",
    "Lemma meetBx x y z : (x `\\` y) `&` z = (x `&` z) `\\` y.\nProof. by rewrite ![_ `&` z]meetC meetxB. Qed.",
    "Lemma diffxI x y z : x `\\` (y `&` z) = (x `\\` y) `|` (x `\\` z).\nProof.\napply/eqP; rewrite eq_diff leUx !leBx //= joinIl joinA joinCA !diffKU.\nrewrite joinCA -joinA [_ `|` x]joinC ![x `|` _]join_l //.\nby rewrite -joinIl leUr /= meetUl {1}[_ `&` z]meetC ?meetBI joinx0.\nQed.",
    "Lemma diffBx x y z : (x `\\` y) `\\` z = x `\\` (y `|` z).\nProof.\napply/eqP; rewrite eq_diff leBr ?leUl //=.\nby rewrite diffxU joinIr diffKU -joinIr meet_l ?leUr //= -meetA diffIK meetx0.\nQed.",
    "Lemma diffxB x y z : x `\\` (y `\\` z) = (x `\\` y) `|` (x `&` z).\nProof.\nrewrite -[y in RHS](joinIB z) diffxU joinIl diffxI -joinA joinBI join_r //.\nby rewrite joinBx meetKU meetA meetAC diffIK meet0x joinx0 meet_r.\nQed.",
    "Lemma joinBK x y : (y `|` x) `\\` x = (y `\\` x).\nProof. by rewrite diffUx diffxx joinx0. Qed.",
    "Lemma joinBKC x y : (x `|` y) `\\` x = (y `\\` x).\nProof. by rewrite diffUx diffxx join0x. Qed.",
    "Lemma disj_le x y : x `&` y == \\bot -> x <= y = (x == \\bot).\nProof. by rewrite [x == \\bot]eq_sym -eq_meetl => /eqP ->. Qed.",
    "Lemma disj_leC x y : y `&` x == \\bot -> x <= y = (x == \\bot).\nProof. by rewrite meetC => /disj_le. Qed.",
    "Lemma disj_diffl x y : x `&` y == \\bot -> x `\\` y = x.\nProof. by move=> dxy; apply/eqP; rewrite eq_diff dxy lexx leUr. Qed.",
    "Lemma disj_diffr x y : x `&` y == \\bot -> y `\\` x = y.\nProof. by rewrite meetC => /disj_diffl. Qed.",
    "Lemma lt0B x y : x < y -> \\bot < y `\\` x.\nProof. by move=> ?; rewrite lt_leAnge le0x leBLR joinx0 /= lt_geF. Qed.",
    "Lemma codiffErcompl x y : codiff x y = rcompl x \\top y.\nProof. exact: codiffErcompl. Qed.",
    "Lemma complEdiff x : ~` x = \\top `\\` x. Proof. exact: complEdiff. Qed.",
    "Lemma complEcodiff x : ~` x = codiff \\bot x. Proof. exact: complEcodiff. Qed.",
    "Lemma complErcompl x : ~` x = rcompl \\bot \\top x.\nProof. by rewrite complEdiff diffErcompl. Qed.",
    "Lemma diff1x x : \\top `\\` x = ~` x.\nProof. exact/esym/complEdiff. Qed.",
    "Lemma diffE x y : x `\\` y = x `&` ~` y.\nProof. by rewrite complEdiff meetxB meetx1. Qed.",
    "Lemma complK : involutive (@compl _ L).\nProof. by move=> x; rewrite !complEdiff diffxB diffxx meet1x join0x. Qed.",
    "Lemma compl_inj : injective (@compl _ L).\nProof. exact/inv_inj/complK. Qed.",
    "Lemma disj_leC x y : (x `&` y == \\bot) = (x <= ~` y).\nProof. by rewrite -diff_eq0 diffE complK. Qed.",
    "Lemma leCx x y : (~` x <= y) = (~` y <= x).\nProof. by rewrite !complEdiff !leBLR joinC. Qed.",
    "Lemma lexC x y : (x <= ~` y) = (y <= ~` x).\nProof. by rewrite -[x in LHS]complK leCx complK. Qed.",
    "Lemma leC x y : (~` x <= ~` y) = (y <= x).\nProof. by rewrite leCx complK. Qed.",
    "Lemma complU x y : ~` (x `|` y) = ~` x `&` ~` y.\nProof. by rewrite !complEdiff diffxU. Qed.",
    "Lemma complI  x y : ~` (x `&` y) = ~` x `|` ~` y.\nProof. by rewrite !complEdiff diffxI. Qed.",
    "Lemma joinxC  x :  x `|` ~` x = \\top.\nProof. by rewrite complEdiff diffKU joinx1. Qed.",
    "Lemma joinCx  x : ~` x `|` x = \\top.\nProof. by rewrite joinC joinxC. Qed.",
    "Lemma meetxC  x :  x `&` ~` x = \\bot.\nProof. by rewrite complEdiff diffKI. Qed.",
    "Lemma meetCx  x : ~` x `&` x = \\bot.\nProof. by rewrite meetC meetxC. Qed.",
    "Lemma compl1 : ~` \\top = \\bot :> L.\nProof. by rewrite complEdiff diffxx. Qed.",
    "Lemma compl0 : ~` \\bot = \\top :> L.\nProof. by rewrite -compl1 complK. Qed.",
    "Lemma complB x y : ~` (x `\\` y) = ~` x `|` y.\nProof. by rewrite diffE complI complK. Qed.",
    "Lemma leBC x y : x `\\` y <= ~` y.\nProof. by rewrite leBLR joinxC lex1. Qed.",
    "Lemma compl_joins (J : Type) (r : seq J) (P : {pred J}) (F : J -> L) :\n   ~` (\\join_(j <- r | P j) F j) = \\meet_(j <- r | P j) ~` F j.\nProof. by elim/big_rec2: _=> [|i x y ? <-]; rewrite ?compl0 ?complU. Qed.",
    "Lemma compl_meets (J : Type) (r : seq J) (P : {pred J}) (F : J -> L) :\n   ~` (\\meet_(j <- r | P j) F j) = \\join_(j <- r | P j) ~` F j.\nProof. by elim/big_rec2: _=> [|i x y ? <-]; rewrite ?compl1 ?complI. Qed.",
    "Lemma omorph_le : {homo f : x y / x <= y}.\nProof. exact: omorph_le_subproof. Qed.",
    "Lemma omorph_lt : injective f -> {homo f : x y / x < y}.\nProof. by move/inj_homo_lt; apply; apply: omorph_le. Qed.",
    "Lemma omorphI (f : {mlmorphism T -> T'}) : {morph f : x y / x `&` y}.\nProof. exact: omorphI_subproof. Qed.",
    "Lemma omorphU (f : {jlmorphism T -> T'}) : {morph f : x y / x `|` y}.\nProof. exact: omorphU_subproof. Qed.",
    "Lemma omorph0 : f \\bot = \\bot.\nProof. exact: omorph0_subproof. Qed.",
    "Lemma omorph1 : f \\top = \\top.\nProof. exact: omorph1_subproof. Qed.",
    "Lemma opredI (S : meetLatticeClosed T) : {in S &, forall u v, u `&` v \\in S}.\nProof. exact: opredI. Qed.",
    "Lemma opredU (S : joinLatticeClosed T) : {in S &, forall u v, u `|` v \\in S}.\nProof. exact: opredU. Qed.",
    "Lemma opred0 (S : bLatticeClosed T) : \\bot \\in S.\nProof. exact: opred0. Qed.",
    "Lemma opred_joins (S : bJoinLatticeClosed T) I r (P : pred I) F :\n  (forall i, P i -> F i \\in S) -> \\join_(i <- r | P i) F i \\in S.\nProof. by move=> FS; elim/big_ind: _; [exact: opred0 | exact: opredU |]. Qed.",
    "Lemma opred1 (S : tLatticeClosed T) : \\top \\in S.\nProof. exact: opred1. Qed.",
    "Lemma opred_meets (S : tMeetLatticeClosed T) I r (P : pred I) F :\n  (forall i, P i -> F i \\in S) -> \\meet_(i <- r | P i) F i \\in S.\nProof. by move=> FS; elim/big_ind: _; [exact: opred1 | exact: opredI |]. Qed.",
    "Lemma le_val : {mono val : x y / x <= y}. Proof. exact: le_val_subproof. Qed.",
    "Lemma leEsub x y : (x <= y) = (val x <= val y). Proof. by rewrite le_val. Qed.",
    "Lemma lt_val : {mono val : x y / x < y}.\nProof. by move=> x y; rewrite !lt_def (inj_eq val_inj) le_val. Qed.",
    "Lemma ltEsub x y : (x < y) = (val x < val y). Proof. by rewrite lt_val. Qed.",
    "Lemma le_wval : {homo val : x y / x <= y}. Proof. exact/mono2W/le_val. Qed.",
    "Lemma lt_wval : {homo val : x y / x < y}. Proof. exact/mono2W/lt_val. Qed.",
    "Lemma joinUKI y x : meetU x (joinU x y) = x.\nProof. by apply: val_inj; rewrite !SubK joinKI. Qed.",
    "Lemma totalU : total (<=%O : rel U).\nProof. by move=> x y; rewrite -!le_val le_total. Qed.",
    "Lemma ltn_def x y : (x < y)%N = (y != x) && (x <= y)%N.\nProof. by rewrite ltn_neqAle eq_sym. Qed.",
    "Lemma leEnat : le = leq. Proof. by []. Qed.",
    "Lemma ltEnat : lt = ltn. Proof. by []. Qed.",
    "Lemma minEnat : min = minn. Proof. by []. Qed.",
    "Lemma maxEnat : max = maxn. Proof. by []. Qed.",
    "Lemma botEnat : \\bot = 0%N :> nat. Proof. by []. Qed.",
    "Lemma homo_ltn_lt_in : {in D, forall i, i.+1 \\in D -> f i < f i.+1} ->\n  {in D &, {homo f : i j / i < j}}.\nProof. by apply: homo_ltn_in Dconvex; apply: lt_trans. Qed.",
    "Lemma incn_inP : {in D, forall i, i.+1 \\in D -> f i < f i.+1} ->\n  {in D &, {mono f : i j / i <= j}}.\nProof. by move=> f_inc; apply/le_mono_in/homo_ltn_lt_in. Qed.",
    "Lemma nondecn_inP : {in D, forall i, i.+1 \\in D -> f i <= f i.+1} ->\n  {in D &, {homo f : i j / i <= j}}.\nProof. by apply: homo_leq_in Dconvex => //; apply: le_trans. Qed.",
    "Lemma nhomo_ltn_lt_in : {in D, forall i, i.+1 \\in D -> f i > f i.+1} ->\n  {in D &, {homo f : i j /~ i < j}}.\nProof.\nmove=> f_dec; apply: homo_sym_in.\nby apply: homo_ltn_in Dconvex f_dec => ? ? ? ? /lt_trans->.\nQed.",
    "Lemma decn_inP : {in D, forall i, i.+1 \\in D -> f i > f i.+1} ->\n  {in D &, {mono f : i j /~ i <= j}}.\nProof. by move=> f_dec; apply/le_nmono_in/nhomo_ltn_lt_in. Qed.",
    "Lemma nonincn_inP : {in D, forall i, i.+1 \\in D -> f i >= f i.+1} ->\n  {in D &, {homo f : i j /~ i <= j}}.\nProof.\nmove=> /= f_dec; apply: homo_sym_in.\nby apply: homo_leq_in Dconvex f_dec => //= ? ? ? ? /le_trans->.\nQed.",
    "Lemma homo_ltn_lt : (forall i, f i < f i.+1) -> {homo f : i j / i < j}.\nProof. by apply: homo_ltn; apply: lt_trans. Qed.",
    "Lemma incnP : (forall i, f i < f i.+1) -> {mono f : i j / i <= j}.\nProof. by move=> f_inc; apply/le_mono/homo_ltn_lt. Qed.",
    "Lemma nondecnP : (forall i, f i <= f i.+1) -> {homo f : i j / i <= j}.\nProof. by apply: homo_leq => //; apply: le_trans. Qed.",
    "Lemma nhomo_ltn_lt : (forall i, f i > f i.+1) -> {homo f : i j /~ i < j}.\nProof.\nmove=> f_dec; apply: homo_sym.\nby apply: homo_ltn f_dec => ? ? ? ? /lt_trans->.\nQed.",
    "Lemma decnP : (forall i, f i > f i.+1) -> {mono f : i j /~ i <= j}.\nProof. by move=> f_dec; apply/le_nmono/nhomo_ltn_lt. Qed.",
    "Lemma nonincnP : (forall i, f i >= f i.+1) -> {homo f : i j /~ i <= j}.\nProof.\nmove=> /= f_dec; apply: homo_sym.\nby apply: homo_leq f_dec => //= ? ? ? ? /le_trans->.\nQed.",
    "Lemma lcmnn n : lcmn n n = n.\nProof. by case: n => // n; rewrite /lcmn gcdnn mulnK. Qed.",
    "Lemma le_def m n : m %| n = (gcdn m n == m)%N.\nProof. by apply/gcdn_idPl/eqP. Qed.",
    "Lemma joinKI n m : gcdn m (lcmn m n) = m.\nProof. by rewrite (gcdn_idPl _)// dvdn_lcml. Qed.",
    "Lemma meetKU n m : lcmn m (gcdn m n) = m.\nProof. by rewrite (lcmn_idPl _)// dvdn_gcdl. Qed.",
    "Lemma meetUl : left_distributive gcdn lcmn.\nProof.\nmove=> [|m'] [|n'] [|p'] //=; rewrite ?lcmnn ?lcm0n ?lcmn0 ?gcd0n ?gcdn0//.\n- by rewrite gcdnC meetKU.\n- by rewrite lcmnC gcdnC meetKU.\napply: eqn_from_log; rewrite ?(gcdn_gt0, lcmn_gt0)//= => p.\nby rewrite !(logn_gcd, logn_lcm) ?(gcdn_gt0, lcmn_gt0)// minn_maxl.\nQed.",
    "Lemma dvdE : dvd = dvdn :> rel t. Proof. by []. Qed.",
    "Lemma sdvdE (m n : t) : m %<| n = (n != m) && (m %| n). Proof. by []. Qed.",
    "Lemma gcdE : gcd = gcdn :> (t -> t -> t). Proof. by []. Qed.",
    "Lemma lcmE : lcm = lcmn :> (t -> t -> t). Proof. by []. Qed.",
    "Lemma nat1E : nat1 = 1%N :> t. Proof. by []. Qed.",
    "Lemma nat0E : nat0 = 0%N :> t. Proof. by []. Qed.",
    "Lemma leEord : (le : rel 'I_n) = leq. Proof. by []. Qed.",
    "Lemma ltEord : (lt : rel 'I_n) = (fun m n => m < n)%N. Proof. by []. Qed.",
    "Lemma botEord : \\bot = ord0. Proof. by []. Qed.",
    "Lemma topEord : \\top = ord_max. Proof. by []. Qed.",
    "Lemma leEbool : le = (leq : rel bool). Proof. by []. Qed.",
    "Lemma ltEbool x y : (x < y) = (x < y)%N. Proof. by []. Qed.",
    "Lemma andEbool : meet = andb. Proof. by []. Qed.",
    "Lemma orEbool : meet = andb. Proof. by []. Qed.",
    "Lemma subEbool x y : x `\\` y = x && ~~ y. Proof. by []. Qed.",
    "Lemma complEbool : compl = negb. Proof. by []. Qed.",
    "Lemma leEprod x y : (x <= y) = (x.1 <= y.1) && (x.2 <= y.2). Proof. by []. Qed.",
    "Lemma ltEprod x y : (x < y) = [&& x != y, x.1 <= y.1 & x.2 <= y.2].\nProof. by rewrite lt_neqAle. Qed.",
    "Lemma le_pair (x1 y1 : T1) (x2 y2 : T2) :\n  (x1, x2) <= (y1, y2) :> T1 * T2 = (x1 <= y1) && (x2 <= y2).\nProof. by []. Qed.",
    "Lemma lt_pair (x1 y1 : T1) (x2 y2 : T2) : (x1, x2) < (y1, y2) :> T1 * T2 =\n  [&& (x1 != y1) || (x2 != y2), x1 <= y1 & x2 <= y2].\nProof. by rewrite ltEprod negb_and. Qed.",
    "Lemma botEprod : \\bot = (\\bot, \\bot) :> T1 * T2. Proof. by []. Qed.",
    "Lemma topEprod : \\top = (\\top, \\top) :> T1 * T2. Proof. by []. Qed.",
    "Lemma meetEprod x y : x `&` y = (x.1 `&` y.1, x.2 `&` y.2). Proof. by []. Qed.",
    "Lemma joinEprod x y : x `|` y = (x.1 `|` y.1, x.2 `|` y.2). Proof. by []. Qed.",
    "Lemma rcomplEprod x y z :\n  rcompl x y z = (Order.rcompl x.1 y.1 z.1, Order.rcompl x.2 y.2 z.2).\nProof. by []. Qed.",
    "Lemma diffEprod x y : x `\\` y = (x.1 `\\` y.1, x.2 `\\` y.2). Proof. by []. Qed.",
    "Lemma codiffEprod x y :\n  codiff x y = (Order.codiff x.1 y.1, Order.codiff x.2 y.2).\nProof. by []. Qed.",
    "Lemma complEprod x : ~` x = (~` x.1, ~` x.2). Proof. by []. Qed.",
    "Lemma leEsig x y : x <= y =\n  (tag x <= tag y) && ((tag x >= tag y) ==> (tagged x <= tagged_as x y)).\nProof. by []. Qed.",
    "Lemma ltEsig x y : x < y =\n  (tag x <= tag y) && ((tag x >= tag y) ==> (tagged x < tagged_as x y)).\nProof. by []. Qed.",
    "Lemma le_Taggedl x (u : T' (tag x)) : (Tagged T' u <= x) = (u <= tagged x).\nProof. by case: x => [t v]/= in u *; rewrite leEsig/= lexx/= tagged_asE. Qed.",
    "Lemma le_Taggedr x (u : T' (tag x)) : (x <= Tagged T' u) = (tagged x <= u).\nProof. by case: x => [t v]/= in u *; rewrite leEsig/= lexx/= tagged_asE. Qed.",
    "Lemma lt_Taggedl x (u : T' (tag x)) : (Tagged T' u < x) = (u < tagged x).\nProof. by case: x => [t v]/= in u *; rewrite ltEsig/= lexx/= tagged_asE. Qed.",
    "Lemma lt_Taggedr x (u : T' (tag x)) : (x < Tagged T' u) = (tagged x < u).\nProof. by case: x => [t v]/= in u *; rewrite ltEsig/= lexx/= tagged_asE. Qed.",
    "Lemma botEsig : \\bot = Tagged T' (\\bot : T' \\bot). Proof. by []. Qed.",
    "Lemma topEsig : \\top = Tagged T' (\\top : T' \\top). Proof. by []. Qed.",
    "Lemma leEprodlexi x y :\n  (x <= y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 <= y.2)).\nProof. by []. Qed.",
    "Lemma ltEprodlexi x y :\n  (x < y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 < y.2)).\nProof. by []. Qed.",
    "Lemma lexi_pair (x1 y1 : T1) (x2 y2 : T2) :\n   (x1, x2) <= (y1, y2) :> T1 * T2 = (x1 <= y1) && ((x1 >= y1) ==> (x2 <= y2)).\nProof. by []. Qed.",
    "Lemma ltxi_pair (x1 y1 : T1) (x2 y2 : T2) :\n   (x1, x2) < (y1, y2) :> T1 * T2 = (x1 <= y1) && ((x1 >= y1) ==> (x2 < y2)).\nProof. by []. Qed.",
    "Lemma botEprodlexi : \\bot = (\\bot, \\bot) :> T1 * T2. Proof. by []. Qed.",
    "Lemma topEprodlexi : \\top = (\\top, \\top) :> T1 * T2. Proof. by []. Qed.",
    "Lemma sub_prod_lexi (disp1 disp2 disp3 disp4 : disp_t)\n  (T1 : porderType disp1) (T2 : porderType disp2) :\n  subrel (<=%O : rel (T1 *prod[disp3] T2)) (<=%O : rel (type disp4 T1 T2)).\nProof.\nby case=> [x1 x2] [y1 y2]; rewrite leEprod leEprodlexi /=; case: comparableP.\nQed.",
    "Lemma leEseq s1 s2 : s1 <= s2 = if s1 isn't x1 :: s1' then true else\n                                if s2 isn't x2 :: s2' then false else\n                                (x1 <= x2) && (s1' <= s2' :> seq _).\nProof. by case: s1. Qed.",
    "Lemma le0s s : [::] <= s :> seq _. Proof. by []. Qed.",
    "Lemma les0 s : s <= [::] = (s == [::]). Proof. by rewrite leEseq. Qed.",
    "Lemma le_cons x1 s1 x2 s2 :\n   x1 :: s1 <= x2 :: s2 :> seq _ = (x1 <= x2) && (s1 <= s2).\nProof. by []. Qed.",
    "Lemma botEseq : \\bot = [::] :> seq T.\nProof. by []. Qed.",
    "Lemma meetEseq s1 s2 : s1 `&` s2 =  [seq x.1 `&` x.2 | x <- zip s1 s2].\nProof. by elim: s1 s2 => [|x s1 ihs1] [|y s2]//=; rewrite -ihs1. Qed.",
    "Lemma meet_cons x1 s1 x2 s2 :\n  (x1 :: s1 : seq T) `&` (x2 :: s2) = (x1 `&` x2) :: s1 `&` s2.\nProof. by []. Qed.",
    "Lemma joinEseq s1 s2 : s1 `|` s2 =\n  match s1, s2 with\n    | [::], _ => s2 | _, [::] => s1\n    | x1 :: s1', x2 :: s2' => (x1 `|` x2) :: ((s1' : seq _) `|` s2')\n  end.\nProof. by case: s1. Qed.",
    "Lemma join_cons x1 s1 x2 s2 :\n  (x1 :: s1 : seq T) `|` (x2 :: s2) = (x1 `|` x2) :: s1 `|` s2.\nProof. by []. Qed.",
    "Lemma lt_def s1 s2 : lt  s1 s2 = (s2 != s1) && le s1 s2.\nProof.\nelim: s1 s2 => [|x s1 ihs1] [|y s2]//=.\nby rewrite eqseq_cons ihs1; case: comparableP.\nQed.",
    "Lemma leEseqlexi s1 s2 :\n   s1 <= s2 = if s1 isn't x1 :: s1' then true else\n              if s2 isn't x2 :: s2' then false else\n              (x1 <= x2) && ((x1 >= x2) ==> (s1' <= s2' :> seq T)).\nProof. by case: s1. Qed.",
    "Lemma ltEseqlexi s1 s2 :\n   s1 < s2 = if s2 isn't x2 :: s2' then false else\n              if s1 isn't x1 :: s1' then true else\n              (x1 <= x2) && ((x1 >= x2) ==> (s1' < s2' :> seq T)).\nProof. by case: s1. Qed.",
    "Lemma lexi0s s : [::] <= s :> seq T. Proof. by []. Qed.",
    "Lemma lexis0 s : s <= [::] = (s == [::]). Proof. by rewrite leEseqlexi. Qed.",
    "Lemma ltxi0s s : ([::] < s :> seq T) = (s != [::]). Proof. by case: s. Qed.",
    "Lemma ltxis0 s : s < [::] = false. Proof. by rewrite ltEseqlexi. Qed.",
    "Lemma lexi_cons x1 s1 x2 s2 :\n  x1 :: s1 <= x2 :: s2 :> seq T = (x1 <= x2) && ((x1 >= x2) ==> (s1 <= s2)).\nProof. by []. Qed.",
    "Lemma ltxi_cons x1 s1 x2 s2 :\n  x1 :: s1 < x2 :: s2 :> seq T = (x1 <= x2) && ((x1 >= x2) ==> (s1 < s2)).\nProof. by []. Qed.",
    "Lemma lexi_lehead x s1 y s2 : x :: s1 <= y :: s2 :> seq T -> x <= y.\nProof. by rewrite lexi_cons => /andP[]. Qed.",
    "Lemma ltxi_lehead x s1 y s2 : x :: s1 < y :: s2 :> seq T -> x <= y.\nProof. by rewrite ltxi_cons => /andP[]. Qed.",
    "Lemma eqhead_lexiE (x : T) s1 s2 : (x :: s1 <= x :: s2 :> seq _) = (s1 <= s2).\nProof. by rewrite lexi_cons lexx. Qed.",
    "Lemma eqhead_ltxiE (x : T) s1 s2 : (x :: s1 < x :: s2 :> seq _) = (s1 < s2).\nProof. by rewrite ltxi_cons lexx. Qed.",
    "Lemma neqhead_lexiE (x y : T) s1 s2 : x != y ->\n  (x :: s1 <= y :: s2 :> seq _) = (x < y).\nProof. by rewrite lexi_cons; case: comparableP. Qed.",
    "Lemma neqhead_ltxiE (x y : T) s1 s2 : x != y ->\n  (x :: s1 < y :: s2 :> seq _) = (x < y).\nProof. by rewrite ltxi_cons; case: (comparableP x y). Qed.",
    "Lemma sub_seqprod_lexi d (T : porderType disp) :\n   subrel (<=%O : rel (seqprod_with d T)) (<=%O : rel (seq T)).\nProof.\nelim=> [|x1 s1 ihs1] [|x2 s2]//=; rewrite le_cons lexi_cons /=.\nby move=> /andP[-> /ihs1->]; rewrite implybT.\nQed.",
    "Lemma leEtprod n T (t1 t2 : n.-tuple T) :\n   t1 <= t2 = [forall i, tnth t1 i <= tnth t2 i].\nProof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= lexx; symmetry; apply/forallP => [].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ <= _]le_cons [t1 <= t2 :> seq _]IHn.\napply/idP/forallP => [/andP[lex12 /forallP/= let12 i]|lext12].\n  by case: (unliftP ord0 i) => [j ->|->]//; rewrite !tnthS.\nrewrite (lext12 ord0)/=; apply/forallP=> i.\nby have := lext12 (lift ord0 i); rewrite !tnthS.\nQed.",
    "Lemma ltEtprod n T (t1 t2 : n.-tuple T) :\n  t1 < t2 = [exists i, tnth t1 i != tnth t2 i] &&\n            [forall i, tnth t1 i <= tnth t2 i].\nProof. by rewrite lt_neqAle leEtprod eqEtuple negb_forall. Qed.",
    "Lemma botEtprod : \\bot = [tuple \\bot | _ < n] :> n.-tuple T.\nProof. by []. Qed.",
    "Lemma topEtprod : \\top = [tuple \\top | _ < n] :> n.-tuple T.\nProof. by []. Qed.",
    "Lemma tnth_meet t1 t2 i : tnth (t1 `&` t2) i = tnth t1 i `&` tnth t2 i.\nProof. exact: tnth_mktuple. Qed.",
    "Lemma meetEtprod t1 t2 : t1 `&` t2 = [tuple tnth t1 i `&` tnth t2 i | i < n].\nProof. by []. Qed.",
    "Lemma tnth_join t1 t2 i : tnth (t1 `|` t2) i = tnth t1 i `|` tnth t2 i.\nProof. exact: tnth_mktuple. Qed.",
    "Lemma joinEtprod t1 t2 : t1 `|` t2 = [tuple tnth t1 i `|` tnth t2 i | i < n].\nProof. by []. Qed.",
    "Lemma tnth_rcompl t1 t2 t3 i :\n  tnth (Order.rcompl t1 t2 t3) i =\n    Order.rcompl (tnth t1 i) (tnth t2 i) (tnth t3 i).\nProof. exact: tnth_mktuple. Qed.",
    "Lemma rcomplEtprod t1 t2 t3 :\n  Order.rcompl t1 t2 t3 =\n    [tuple Order.rcompl (tnth t1 i) (tnth t2 i) (tnth t3 i) | i < n].\nProof. by []. Qed.",
    "Lemma tnth_diff t1 t2 i : tnth (diff t1 t2) i = tnth t1 i `\\` tnth t2 i.\nProof. exact: tnth_mktuple. Qed.",
    "Lemma diffEtprod t1 t2 : t1 `\\` t2 = [tuple tnth t1 i `\\` tnth t2 i | i < n].\nProof. by []. Qed.",
    "Lemma tnth_codiff t1 t2 i :\n  tnth (Order.codiff t1 t2) i = Order.codiff (tnth t1 i) (tnth t2 i).\nProof. exact: tnth_mktuple. Qed.",
    "Lemma codiffEtprod t1 t2 :\n  Order.codiff t1 t2 = [tuple Order.codiff (tnth t1 i) (tnth t2 i) | i < n].\nProof. by []. Qed.",
    "Lemma tnth_compl t i : tnth (~` t) i = ~` tnth t i.\nProof. by rewrite tnth_map. Qed.",
    "Lemma complEtprod t : ~` t = map_tuple Order.compl t.\nProof. by []. Qed.",
    "Lemma lexi_tupleP n T (t1 t2 : n.-tuple T) :\n   reflect (exists k : 'I_n.+1, forall i : 'I_n, (i <= k)%N ->\n               tnth t1 i <= tnth t2 i ?= iff (i != k :> nat)) (t1 <= t2).\nProof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= lexx; constructor; exists ord0 => -[].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ <= _]lexi_cons; apply: (iffP idP) => [|[k leif_xt12]].\n  case: comparableP => //= [ltx12 _|-> /IHn[k kP]].\n    exists ord0 => i; rewrite leqn0 => /eqP/(@ord_inj n.+1 i ord0)->.\n    by apply/leifP; rewrite !tnth0.\n  exists (lift ord0 k) => i; case: (unliftP ord0 i) => [j ->|-> _].\n    by rewrite !ltnS => /kP; rewrite !tnthS.\n  by apply/leifP; rewrite !tnth0 eqxx.\nhave /= := leif_xt12 ord0 isT; rewrite !tnth0 => leif_x12.\nrewrite leif_x12/=; move: leif_x12 leif_xt12 => /leifP.\ncase: (unliftP ord0 k) => {k} [k-> /eqP<-{x2}|-> /lt_geF->//] leif_xt12.\nrewrite lexx implyTb; apply/IHn; exists k => i le_ik.\nby have := leif_xt12 (lift ord0 i) le_ik; rewrite !tnthS.\nQed.",
    "Lemma ltxi_tupleP n T (t1 t2 : n.-tuple T) :\n   reflect (exists k : 'I_n, forall i : 'I_n, (i <= k)%N ->\n               tnth t1 i <= tnth t2 i ?= iff (i != k :> nat)) (t1 < t2).\nProof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= ltxx; constructor => - [] [].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ < _]ltxi_cons; apply: (iffP idP) => [|[k leif_xt12]].\n  case: (comparableP x1 x2) => //= [ltx12 _|-> /IHn[k kP]].\n    exists ord0 => i; rewrite leqn0 => /eqP/(@ord_inj n.+1 i ord0)->.\n    by apply/leifP; rewrite !tnth0.\n  exists (lift ord0 k) => i; case: (unliftP ord0 i) => {i} [i ->|-> _].\n    by rewrite !ltnS => /kP; rewrite !tnthS.\n  by apply/leifP; rewrite !tnth0 eqxx.\nhave /= := leif_xt12 ord0 isT; rewrite !tnth0 => leif_x12.\nrewrite leif_x12/=; move: leif_x12 leif_xt12 => /leifP.\ncase: (unliftP ord0 k) => {k} [k-> /eqP<-{x2}|-> /lt_geF->//] leif_xt12.\nrewrite lexx implyTb; apply/IHn; exists k => i le_ik.\nby have := leif_xt12 (lift ord0 i) le_ik; rewrite !tnthS.\nQed.",
    "Lemma ltxi_tuplePlt n T (t1 t2 : n.-tuple T) : reflect\n  (exists2 k : 'I_n, forall i : 'I_n, (i < k)%N -> tnth t1 i = tnth t2 i\n                                                 & tnth t1 k < tnth t2 k)\n  (t1 < t2).\nProof.\napply: (iffP (ltxi_tupleP _ _)) => [[k kP]|[k kP ltk12]].\n  exists k => [i i_lt|]; last by rewrite (lt_leif (kP _ _)) ?eqxx ?leqnn.\n  by have /eqTleif->// := kP i (ltnW i_lt); rewrite ltn_eqF.\nby exists k => i; case: ltngtP => //= [/kP-> _|/ord_inj-> _]; apply/leifP.\nQed.",
    "Lemma botEtlexi : \\bot = [tuple \\bot | _ < n] :> n.-tuple T. Proof. by []. Qed.",
    "Lemma topEtlexi : \\top = [tuple \\top | _ < n] :> n.-tuple T. Proof. by []. Qed.",
    "Lemma sub_tprod_lexi d n (T : porderType disp) :\n   subrel (<=%O : rel (n.-tupleprod[d] T)) (<=%O : rel (n.-tuple T)).\nProof. exact: sub_seqprod_lexi. Qed.",
    "Lemma le_def A B : A \\subset B = (A :&: B == A).\nProof. exact/setIidPl/eqP. Qed.",
    "Lemma setKUC B A : A :&: (A :|: B) = A.\nProof. by rewrite setUC setKU. Qed.",
    "Lemma setKIC B A : A :|: (A :&: B) = A.\nProof. by rewrite setIC setKI. Qed.",
    "Lemma setIDv A B : B :&: (A :\\: B) = set0.\nProof.\napply/eqP; rewrite -subset0; apply/subsetP => x.\nby rewrite !inE => /and3P[->].\nQed.",
    "Lemma setTDsym A : ~: A = setT :\\: A.\nProof. by rewrite setTD. Qed.",
    "Lemma leEsubset A B : (A <= B) = (A \\subset B).\nProof. by []. Qed.",
    "Lemma meetEsubset A B : A `&` B = A :&: B.\nProof. by []. Qed.",
    "Lemma joinEsubset A B : A `|` B = A :|: B.\nProof. by []. Qed.",
    "Lemma botEsubset : \\bot = set0 :> {subset T}.\nProof. by []. Qed.",
    "Lemma topEsubset : \\top = setT :> {subset T}.\nProof. by []. Qed.",
    "Lemma subEsubset A B : A `\\` B = A :\\: B.\nProof. by []. Qed.",
    "Lemma complEsubset A : ~` A = ~: A.\nProof. by []. Qed.",
    "Lemma cardE (A : {pred T}) : #|A| = size (enum A).\nProof. by rewrite size_sort cardE. Qed.",
    "Lemma mem_enum (A : {pred T}) : enum A =i A.\nProof. by move=> x; rewrite mem_sort mem_enum. Qed.",
    "Lemma enum_uniq (A : {pred T}) : uniq (enum A).\nProof. by rewrite sort_uniq enum_uniq. Qed.",
    "Lemma cardT : #|T| = size (enum T).\nProof. by rewrite cardT size_sort. Qed.",
    "Lemma enumT : enum T = sort <=%O (Finite.enum T).\nProof. by rewrite enumT. Qed.",
    "Lemma enum0 : enum (pred0 : {pred T}) = [::].\nProof. by rewrite enum0. Qed.",
    "Lemma enum1 (x : T) : enum (pred1 x) = [:: x].\nProof. by rewrite enum1. Qed.",
    "Lemma eq_enum (A B : {pred T}) : A =i B -> enum A = enum B.\nProof. by move=> /eq_enum->. Qed.",
    "Lemma eq_cardT (A : {pred T}) : A =i predT -> #|A| = size (enum T).\nProof. by move=> /eq_enum<-; rewrite cardE. Qed.",
    "Lemma set_enum (A : {set T}) : [set x in enum A] = A.\nProof. by apply/setP => x; rewrite inE mem_enum. Qed.",
    "Lemma enum_set0 : enum (set0 : {set T}) = [::].\nProof. by rewrite enum_set0. Qed.",
    "Lemma enum_setT : enum [set: T] = sort <=%O (Finite.enum T).\nProof. by rewrite enum_setT. Qed.",
    "Lemma enum_set1 (a : T) : enum [set a] = [:: a].\nProof. by rewrite enum_set1. Qed.",
    "Lemma enum_ord n : enum 'I_n = fintype.enum 'I_n.\nProof.\nrewrite (sorted_sort le_trans)// -(@sorted_map _ _ (val : 'I_n -> nat))/=.\nby rewrite val_enum_ord iota_sorted.\nQed.",
    "Lemma val_enum_ord n : [seq val i | i <- enum 'I_n] = iota 0 n.\nProof. by rewrite enum_ord val_enum_ord. Qed.",
    "Lemma size_enum_ord n : size (enum 'I_n) = n.\nProof. by rewrite -cardE card_ord. Qed.",
    "Lemma nth_enum_ord (n : nat) (i0 : 'I_n) (m : nat) :\n  (m < n)%N -> nth i0 (enum 'I_n) m = m :> nat.\nProof. by move=> lemn; rewrite enum_ord nth_enum_ord. Qed.",
    "Lemma nth_ord_enum (n : nat) (i0 i : 'I_n) : nth i0 (enum 'I_n) i = i.\nProof. by rewrite enum_ord nth_ord_enum. Qed.",
    "Lemma index_enum_ord (n : nat) (i : 'I_n) : index i (enum 'I_n) = i.\nProof. by rewrite enum_ord index_enum_ord. Qed.",
    "Lemma mono_sorted_enum d d' (T : finPOrderType d)\n    (T' : porderType d') (f : T -> T') :\n    total (<=%O : rel T) -> {mono f : x y / (x <= y)%O} ->\n  sorted <=%O [seq f x | x <- Order.enum T].\nProof.\nmove=> /sort_sorted ss_sorted lef; wlog [x0 x'0] : / (T * T')%type.\n  by case: (Order.enum T) => // x ? => /(_ (x, f x)).\nrewrite (sorted_pairwise le_trans).\napply/(pairwiseP x'0) => i j; rewrite !inE !size_map -!Order.cardT.\nmove=> ilt jlt ij; rewrite !(nth_map x0) -?Order.cardT// lef.\nby rewrite (sorted_leq_nth le_trans le_refl) ?inE -?Order.cardT// 1?ltnW.\nQed.",
    "Lemma mono_unique d (T T' : finPOrderType d) (f g : T -> T') :\n    total (<=%O : rel T) -> (#|T'| <= #|T|)%N ->\n    {mono f : x y / x <= y} -> {mono g : x y / x <= y} ->\n  f =1 g.\nProof.\nmove=> le_total leT'T lef leg x0; move: {+}x0.\nsuff: finfun f = finfun g by move=> /ffunP + x => /(_ x); rewrite !ffunE.\napply: (can_inj fgraphK); apply/val_inj => /=; rewrite !codomE.\nunder eq_map do rewrite ffunE; under [RHS]eq_map do rewrite ffunE.\nhave [finj ginj] := (inc_inj lef, inc_inj leg).\nhave [f' fK f'K] := inj_card_bij finj leT'T.\nhave [g' gK g'K] := inj_card_bij ginj leT'T.\napply/eqP; have : [seq f i | i <- Order.enum T] = [seq g i | i <- Order.enum T].\n  apply: (@sorted_eq _ <=%O le_trans le_anti); rewrite ?mono_sorted_enum//.\n  apply: uniq_perm; rewrite ?map_inj_uniq ?sort_uniq ?fintype.enum_uniq//.\n  move=> x; apply/mapP/mapP => -[y _ ->].\n    by exists (g' (f y)); rewrite ?Order.mem_enum.\n  by exists (f' (g y)); rewrite ?Order.mem_enum.\nmove=> /eqP; rewrite !eq_map_all all_map [in X in _ -> X]all_map.\nby have /permPl/perm_all-> := perm_sort <=%O (fintype.enum T).\nQed.",
    "Lemma enum_valP A i : @enum_val A i \\in A.\nProof.\nsuff: enum_val i \\in enum A by rewrite mem_enum.\nby apply: mem_nth; rewrite -cardE.\nQed.",
    "Lemma enum_val_nth A x i : @enum_val A i = nth x (enum A) i.\nProof. by apply: set_nth_default; rewrite cardE in i *. Qed.",
    "Lemma nth_enum_rank_in x00 x0 A Ax0 :\n  {in A, cancel (@enum_rank_in x0 A Ax0) (nth x00 (enum A))}.\nProof.\nmove=> x Ax; rewrite /= insubdK ?nth_index ?mem_enum //.\nby rewrite cardE [_ \\in _]index_mem mem_enum.\nQed.",
    "Lemma nth_enum_rank x0 : cancel enum_rank (nth x0 (enum T)).\nProof. by move=> x; apply: nth_enum_rank_in. Qed.",
    "Lemma enum_rankK_in x0 A Ax0 :\n   {in A, cancel (@enum_rank_in x0 A Ax0) enum_val}.\nProof. by move=> x; apply: nth_enum_rank_in. Qed.",
    "Lemma enum_rankK : cancel enum_rank enum_val.\nProof. by move=> x; apply: enum_rankK_in. Qed.",
    "Lemma enum_valK_in x0 A Ax0 : cancel enum_val (@enum_rank_in x0 A Ax0).\nProof.\nmove=> x; apply: ord_inj; rewrite insubdK; last first.\n  by rewrite cardE [_ \\in _]index_mem mem_nth // -cardE.\nby rewrite index_uniq ?enum_uniq // -cardE.\nQed.",
    "Lemma enum_valK : cancel enum_val enum_rank.\nProof. by move=> x; apply: enum_valK_in. Qed.",
    "Lemma enum_rank_inj : injective enum_rank.\nProof. exact: can_inj enum_rankK. Qed.",
    "Lemma enum_val_inj A : injective (@enum_val A).\nProof. by move=> i; apply: can_inj (enum_valK_in (enum_valP i)) (i). Qed.",
    "Lemma enum_val_bij_in x0 A : x0 \\in A -> {on A, bijective (@enum_val A)}.\nProof.\nmove=> Ax0; exists (enum_rank_in Ax0) => [i _|]; last exact: enum_rankK_in.\nexact: enum_valK_in.\nQed.",
    "Lemma eq_enum_rank_in (x0 y0 : T) A (Ax0 : x0 \\in A) (Ay0 : y0 \\in A) :\n  {in A, enum_rank_in Ax0 =1 enum_rank_in Ay0}.\nProof. by move=> x xA; apply: enum_val_inj; rewrite !enum_rankK_in. Qed.",
    "Lemma enum_rank_in_inj (x0 y0 : T) A (Ax0 : x0 \\in A) (Ay0 : y0 \\in A) :\n  {in A &, forall x y, enum_rank_in Ax0 x = enum_rank_in Ay0 y -> x = y}.\nProof. by move=> x y xA yA /(congr1 enum_val); rewrite !enum_rankK_in. Qed.",
    "Lemma enum_rank_bij : bijective enum_rank.\nProof. by move: enum_rankK enum_valK; exists (@enum_val T). Qed.",
    "Lemma enum_val_bij : bijective (@enum_val T).\nProof. by move: enum_rankK enum_valK; exists enum_rank. Qed.",
    "Lemma le_enum_val A : {mono @enum_val A : i j / i <= j}.\nProof.\napply: le_mono => i j le_ij.\nrewrite /enum_val (set_nth_default (enum_default j)) -?cardE//.\napply: (sorted_ltn_nth lt_trans); rewrite -?topredE/= -?cardE//.\nby rewrite lt_sorted_uniq_le enum_uniq/= sort_sorted.\nQed.",
    "Lemma le_enum_rank_in x0 A (Ax0 : x0 \\in A) :\n  {in A &, {mono enum_rank_in Ax0 : x y / x <= y}}.\nProof.\napply: can_mono_in (@in2W _ _ predT predT _ (@le_enum_val A)) => //.\nexact/onW_can_in/enum_rankK_in.\nQed.",
    "Lemma le_enum_rank : {mono enum_rank : i j / i <= j}.\nProof. exact: can_mono enum_rankK (@le_enum_val predT). Qed.",
    "Lemma card : #|{: T}| = \\sum_i p_ i.\nProof.\nrewrite card_tagged sumnE/= big_map big_enum.\nby apply: eq_bigr => i _; rewrite card_ord.\nQed.",
    "Lemma sigK : cancel sig rank.\nProof.\nby move=> s; rewrite /sig/rank/= enum_valK cast_ord_comp cast_ord_id.\nQed.",
    "Lemma sig_inj : injective sig. Proof. exact: can_inj sigK. Qed.",
    "Lemma rankK : cancel rank sig.\nProof.\nby move=> p; rewrite /sig/rank/= cast_ord_comp cast_ord_id enum_rankK.\nQed.",
    "Lemma rank_inj : injective rank. Proof. exact: can_inj rankK. Qed.",
    "Lemma sigE12 s : sig s = @Tagged _ (sig1 s) _ (sig2 s).\nProof. by rewrite /sig1 /sig2; case: sig. Qed.",
    "Lemma rankE p : rank p = @Rank (tag p) (tagged p). Proof. by case: p. Qed.",
    "Lemma sig2K s : Rank (sig2 s) = s. Proof. by rewrite -rankE sigK. Qed.",
    "Lemma Rank1K i0 (k : 'I_(p_ i0)) : sig1 (Rank k) = i0.\nProof. by rewrite /sig1 /Rank/= rankK/=. Qed.",
    "Lemma Rank2K i0 (k : 'I_(p_ i0)) :\n  sig2 (Rank k) = cast_ord (congr1 p_ (esym (Rank1K k))) k.\nProof. by apply: val_inj; rewrite /sig2/sig1/Rank/= rankK. Qed.",
    "Lemma rank_bij : bijective rank. Proof. by exists sig. Qed.",
    "Lemma sig_bij  : bijective sig.  Proof. by exists rank. Qed.",
    "Lemma rank_bij_on : {on [pred _ | true], bijective rank}.\nProof. exact/onW_bij/rank_bij. Qed.",
    "Lemma sig_bij_on : {on [pred _ | true], bijective sig}.\nProof. exact/onW_bij/sig_bij. Qed.",
    "Lemma le_sig : {mono sig : i j / i <= j}.\nProof. by move=> i j; rewrite /sig/= le_enum_val//; apply: le_total. Qed.",
    "Lemma le_sig1 : {homo sig1 : i j / i <= j}.\nProof. by move=> i j; rewrite /sig1/= -le_sig leEsig/=; case: leP. Qed.",
    "Lemma le_rank : {mono rank : p q / p <= q}.\nProof. exact: can_mono le_sig. Qed.",
    "Lemma le_Rank i : {mono @Rank i : j k / j <= k}.\nProof. by move=> j k; rewrite /Rank le_rank/= leEsig/= tagged_asE lexx. Qed.",
    "Lemma lt_sig : {mono sig : i j / i < j}.\nProof. by move=> i j; rewrite !ltNge le_sig. Qed.",
    "Lemma lt_rank : {mono rank : p q / p < q}.\nProof. by move=> p q; rewrite !ltNge le_rank. Qed.",
    "Lemma lt_Rank i : {mono @Rank i : j k / j < k}.\nProof. by move=> j k; rewrite !ltNge le_Rank. Qed.",
    "Lemma eq_Rank i i' (j : 'I_(p_ i)) (j': 'I_(p_ i')) :\n  (Rank j == Rank j' :> nat) = (i == i') && (j == j' :> nat).\nProof.\nrewrite val_eqE /Rank -(can_eq sigK) !rankK.\ncase: (i =P i') => ii' /=; last by case: eqVneq => // -[].\nby case: _ / ii' in j' *; rewrite eq_Tagged.\nQed.",
    "Lemma rankEsum p : rank p = \\sum_(i < n | (i < tag p)%N) p_ i + tagged p :> nat.\nProof.\npose sum p := \\sum_(i < n | (i < tag p)%N) p_ i + tagged p.\nrewrite -/(sum _); have sumlt : forall p, (sum p < \\sum_i p_ i)%N.\n  rewrite /sum => -[/= i j].\n  rewrite [ltnRHS](bigID [pred i' : 'I__ | (i' < i)%N])/= ltn_add2l.\n  by rewrite (bigD1 i) ?ltnn//= ltn_addr.\nsuff: rank =1 (fun p => Ordinal (sumlt p)) by move=> /(_ p)/(congr1 val).\napply: (Order.mono_unique _ _ le_rank) => //=.\n- exact: le_total.\n- by rewrite card card_ord.\napply: le_mono => /= -[i j] -[i' j']; rewrite ltEsig/= !ltEord/= /sum leEord/=.\ncase: (ltngtP i i') => //= [ltii' _|/val_inj ii']; last first.\n  by rewrite -ii' in j' *; rewrite tagged_asE => ltjj'; rewrite ltn_add2l.\nrewrite ltn_addr// (@leq_trans (\\sum_(i0 < n | (i0 < i)%N) p_ i0 + p_ i))%N//.\n  by rewrite ltn_add2l.\nrewrite [leqRHS](bigID [pred i' : 'I__ | (i' < i)%N])/=.\nrewrite leq_add//; last first.\n  by rewrite (bigD1 i) ?ltnn ?ltii'//= leq_addr.\nrewrite [leqRHS](eq_bigl [pred k : 'I_n | (k < i)%N])// => k/=.\nby case: (ltnP k i); rewrite ?andbF// => /ltn_trans->.\nQed.",
    "Lemma RankEsum i j : @Rank i j = \\sum_(k < n | (k < i)%N) p_ k + j :> nat.\nProof. by rewrite /Rank rankEsum/=. Qed.",
    "Lemma rect s : s = \\sum_(i < n | (i < sig1 s)%N) p_ i + sig2 s :> nat.\nProof. by rewrite -[s]sigK rankEsum /= sigK. Qed.",
    "Lemma eqRank (i0 j : nat) (li0 : (i0 < n)%N) (lj : (j < p_ (Ordinal li0))%N) :\n  (\\sum_(i < n | (i < i0)%N) p_ i) + j = Rank (Ordinal lj) :> nat.\nProof. by rewrite RankEsum. Qed.",
    "Lemma eqE (T : eqType) x : eq_op x = hasDecEq.eq_op (Equality.class T) x.\nProof. by []. Qed.",
    "Lemma eq_refl (T : eqType) (x : T) : x == x. Proof. exact/eqP. Qed.",
    "Lemma eq_sym (T : eqType) (x y : T) : (x == y) = (y == x).\nProof. exact/eqP/eqP. Qed.",
    "Lemma eqVneq (T : eqType) (x y : T) : eq_xor_neq x y (y == x) (x == y).\nProof. by rewrite eq_sym; case: (altP eqP); constructor. Qed.",
    "Lemma contraTeq b x y : (x != y -> ~~ b) -> b -> x = y.\nProof. by move=> imp hyp; apply/eqP; apply: contraTT hyp. Qed.",
    "Lemma contraNeq b x y : (x != y -> b) -> ~~ b -> x = y.\nProof. by move=> imp hyp; apply/eqP; apply: contraNT hyp. Qed.",
    "Lemma contraFeq b x y : (x != y -> b) -> b = false -> x = y.\nProof. by move=> imp /negbT; apply: contraNeq. Qed.",
    "Lemma contraPeq P x y : (x != y -> ~ P) -> P -> x = y.\nProof. by move=> imp HP; apply: contraTeq isT => /imp /(_ HP). Qed.",
    "Lemma contra_not_eq P x y : (x != y -> P) -> ~ P -> x = y.\nProof. by move=> imp; apply: contraPeq => /imp HP /(_ HP). Qed.",
    "Lemma contra_not_neq P x y : (x = y -> P) -> ~ P -> x != y.\nProof. by move=> imp; apply: contra_notN => /eqP. Qed.",
    "Lemma contraTneq b x y : (x = y -> ~~ b) -> b -> x != y.\nProof. by move=> imp; apply: contraTN => /eqP. Qed.",
    "Lemma contraNneq b x y : (x = y -> b) -> ~~ b -> x != y.\nProof. by move=> imp; apply: contraNN => /eqP. Qed.",
    "Lemma contraFneq b x y : (x = y -> b) -> b = false -> x != y.\nProof. by move=> imp /negbT; apply: contraNneq. Qed.",
    "Lemma contraPneq P x y : (x = y -> ~ P) -> P -> x != y.\nProof. by move=> imp; apply: contraPN => /eqP. Qed.",
    "Lemma contra_eqN b x y : (b -> x != y) -> x = y -> ~~ b.\nProof. by move=> imp /eqP; apply: contraL. Qed.",
    "Lemma contra_eqF b x y : (b -> x != y) -> x = y -> b = false.\nProof. by move=> imp /eqP; apply: contraTF. Qed.",
    "Lemma contra_eqT b x y : (~~ b -> x != y) -> x = y -> b.\nProof. by move=> imp /eqP; apply: contraLR. Qed.",
    "Lemma contra_neqN b x y : (b -> x = y) -> x != y -> ~~ b.\nProof. by move=> imp; apply: contraNN => /imp->. Qed.",
    "Lemma contra_neqF b x y : (b -> x = y) -> x != y -> b = false.\nProof. by move=> imp; apply: contraNF => /imp->. Qed.",
    "Lemma contra_neqT b x y : (~~ b -> x = y) -> x != y -> b.\nProof. by move=> imp; apply: contraNT => /imp->. Qed.",
    "Lemma contra_eq_not P x y : (P -> x != y) -> x = y -> ~ P.\nProof. by move=> imp /eqP; apply: contraTnot. Qed.",
    "Lemma contra_neq_not P x y : (P -> x = y) -> x != y -> ~ P.\nProof. by move=> imp;apply: contraNnot => /imp->. Qed.",
    "Lemma contra_eq z1 z2 x1 x2 : (x1 != x2 -> z1 != z2) -> z1 = z2 -> x1 = x2.\nProof. by move=> imp /eqP; apply: contraTeq. Qed.",
    "Lemma contra_neq z1 z2 x1 x2 : (x1 = x2 -> z1 = z2) -> z1 != z2 -> x1 != x2.\nProof. by move=> imp; apply: contraNneq => /imp->. Qed.",
    "Lemma contra_neq_eq z1 z2 x1 x2 : (x1 != x2 -> z1 = z2) -> z1 != z2 -> x1 = x2.\nProof. by move=> imp; apply: contraNeq => /imp->. Qed.",
    "Lemma contra_eq_neq z1 z2 x1 x2 : (z1 = z2 -> x1 != x2) -> x1 = x2 -> z1 != z2.\nProof. by move=> imp; apply: contra_eqN => /eqP /imp. Qed.",
    "Lemma memPn A x : reflect {in A, forall y, y != x} (x \\notin A).\nProof.\napply: (iffP idP) => [notDx y | notDx]; first by apply: contraTneq => ->.\nexact: contraL (notDx x) _.\nQed.",
    "Lemma memPnC A x : reflect {in A, forall y, x != y} (x \\notin A).\nProof. by apply: (iffP (memPn A x)) => A'x y /A'x; rewrite eq_sym. Qed.",
    "Lemma ifN_eq R x y vT vF : x != y -> (if x == y then vT else vF) = vF :> R.\nProof. exact: ifN. Qed.",
    "Lemma ifN_eqC R x y vT vF : x != y -> (if y == x then vT else vF) = vF :> R.\nProof. by rewrite eq_sym; apply: ifN. Qed.",
    "Lemma unit_eqP : Equality.axiom (fun _ _ : unit => true).\nProof. by do 2!case; left. Qed.",
    "Lemma eqbP : Equality.axiom eqb.\nProof. by do 2!case; constructor. Qed.",
    "Lemma eqbE : eqb = eq_op. Proof. by []. Qed.",
    "Lemma bool_irrelevance (b : bool) (p1 p2 : b) : p1 = p2.\nProof. exact: eq_irrelevance. Qed.",
    "Lemma negb_add b1 b2 : ~~ (b1 (+) b2) = (b1 == b2).\nProof. by rewrite -addNb. Qed.",
    "Lemma negb_eqb b1 b2 : (b1 != b2) = b1 (+) b2.\nProof. by rewrite -addNb negbK. Qed.",
    "Lemma eqb_id b : (b == true) = b.\nProof. by case: b. Qed.",
    "Lemma eqbF_neg b : (b == false) = ~~ b.\nProof. by case: b. Qed.",
    "Lemma eqb_negLR b1 b2 : (~~ b1 == b2) = (b1 == ~~ b2).\nProof. by case: b1; case: b2. Qed.",
    "Lemma pred1E : pred1 =2 eq_op. Proof. by move=> x y; apply: eq_sym. Qed.",
    "Lemma predU1P : reflect (x = y \\/ b) ((x == y) || b).\nProof. by apply: (iffP orP); do [case=> [/eqP|]; [left | right]]. Qed.",
    "Lemma pred2P : reflect (x = y \\/ z = u) ((x == y) || (z == u)).\nProof. by apply: (iffP orP); do [case=> /eqP; [left | right]]. Qed.",
    "Lemma predD1P : reflect (x <> y /\\ b) ((x != y) && b).\nProof. by apply: (iffP andP)=> [] [] // /eqP. Qed.",
    "Lemma predU1l : x = y -> (x == y) || b.\nProof. by move->; rewrite eqxx. Qed.",
    "Lemma predU1r : b -> (x == y) || b.\nProof. by move->; rewrite orbT. Qed.",
    "Lemma inj_eq : injective f -> forall x y, (f x == f y) = (x == y).\nProof. by move=> inj_f x y; apply/eqP/eqP=> [|-> //]; apply: inj_f. Qed.",
    "Lemma can_eq : cancel f g -> forall x y, (f x == f y) = (x == y).\nProof. by move/can_inj; apply: inj_eq. Qed.",
    "Lemma bij_eq : bijective f -> forall x y, (f x == f y) = (x == y).\nProof. by move/bij_inj; apply: inj_eq. Qed.",
    "Lemma can2_eq : cancel f g -> cancel g f -> forall x y, (f x == y) = (x == g y).\nProof. by move=> fK gK x y; rewrite -[y in LHS]gK; apply: can_eq. Qed.",
    "Lemma inj_in_eq :\n  {in D &, injective f} -> {in D &, forall x y, (f x == f y) = (x == y)}.\nProof. by move=> inj_f x y Dx Dy; apply/eqP/eqP=> [|-> //]; apply: inj_f. Qed.",
    "Lemma can_in_eq :\n  {in D, cancel f g} -> {in D &, forall x y, (f x == f y) = (x == y)}.\nProof. by move/can_in_inj; apply: inj_in_eq. Qed.",
    "Lemma inv_eq f : involutive f -> forall x y : T, (f x == y) = (x == f y).\nProof. by move=> fK; apply: can2_eq. Qed.",
    "Lemma eq_frel f f' : f =1 f' -> frel f =2 frel f'.\nProof. by move=> eq_f x y; rewrite /= eq_f. Qed.",
    "Lemma invariant_comp : subpred (invariant f k) (invariant f (h \\o k)).\nProof. by move=> x eq_kfx; rewrite /= (eqP eq_kfx). Qed.",
    "Lemma invariant_inj : injective h -> invariant f (h \\o k) =1 invariant f k.\nProof. by move=> inj_h x; apply: (inj_eq inj_h). Qed.",
    "Lemma dfwith_in i x : dfwith x i = x.\nProof. by rewrite /dfwith; case: eqP => // ii; rewrite eq_axiomK. Qed.",
    "Lemma dfwith_out i (x : T i) j : i != j -> dfwith x j = f j.\nProof. by rewrite /dfwith; case: eqP. Qed.",
    "Lemma dfwithP i (x : T i) (j : I) : dfwith_spec x (dfwith x j).\nProof.\nby case: (eqVneq i j) => [<-|nij];\n   [rewrite dfwith_in|rewrite dfwith_out//]; constructor.\nQed.",
    "Lemma compareP : Equality.axiom compareb.\nProof. by move=> x y; apply: sumboolP. Qed.",
    "Lemma vrefl : forall x, P x -> x = x. Proof. by []. Qed.",
    "Lemma SubK x Px : val (@Sub x Px) = x. Proof. exact: SubK_subproof. Qed.",
    "Lemma SubP u : Sub_spec u.\nProof. by elim/(@Sub_rect _ _ sT) : u. Qed.",
    "Lemma insubP x : insub_spec x (insub x).\nProof.\nby rewrite /insub; case: {-}_ / idP; [left; rewrite ?SubK | right; apply/negP].\nQed.",
    "Lemma insubT x Px : insub x = Some (Sub x Px).\nProof.\ndo [case: insubP => [/SubP[y Py] _ <- | /negP// ]; rewrite SubK]  in Px *.\nby rewrite (bool_irrelevance Px Py).\nQed.",
    "Lemma insubF x : P x = false -> insub x = None.\nProof. by move/idP; case: insubP. Qed.",
    "Lemma insubN x : ~~ P x -> insub x = None.\nProof. by move/negPf/insubF. Qed.",
    "Lemma isSome_insub : ([eta insub] : pred T) =1 P.\nProof. by apply: fsym => x; case: insubP => // /negPf. Qed.",
    "Lemma insubK : ocancel insub val.\nProof. by move=> x; case: insubP. Qed.",
    "Lemma valP u : P (val u).\nProof. by case/SubP: u => x Px; rewrite SubK. Qed.",
    "Lemma valK : pcancel val insub.\nProof. by case/SubP=> x Px; rewrite SubK; apply: insubT. Qed.",
    "Lemma val_inj : injective val.\nProof. exact: pcan_inj valK. Qed.",
    "Lemma valKd u0 : cancel val (insubd u0).\nProof. by move=> u; rewrite /insubd valK. Qed.",
    "Lemma val_insubd u0 x : val (insubd u0 x) = if P x then x else val u0.\nProof. by rewrite /insubd; case: insubP => [u -> | /negPf->]. Qed.",
    "Lemma insubdK u0 : {in P, cancel (insubd u0) val}.\nProof. by move=> x Px; rewrite val_insubd [P x]Px. Qed.",
    "Lemma insub_eqE : insub_eq =1 insub.\nProof.\nrewrite /insub_eq => x; set b := P x; rewrite [in LHS]/b in (Db := erefl b) *.\nby case: b in Db *; [rewrite insubT | rewrite insubF].\nQed.",
    "Lemma innew_val T nT : cancel val (@innew T nT).\nProof. by move=> u; apply: val_inj; apply: SubK. Qed.",
    "Lemma inj_eqAxiom : injective f -> Equality.axiom (fun x y => f x == f y).\nProof. by move=> f_inj x y; apply: (iffP eqP) => [|-> //]; apply: f_inj. Qed.",
    "Lemma val_eqP : ev_ax sT val. Proof. exact: inj_eqAxiom val_inj. Qed.",
    "Lemma val_eqE (T : eqType) (P : pred T) (sT : subEqType P)\n   (u v : sT) : (val u == val v) = (u == v).\nProof. exact/val_eqP/eqP. Qed.",
    "Lemma pair_eqP : Equality.axiom pair_eq.\nProof.\nmove=> [x1 x2] [y1 y2] /=; apply: (iffP andP) => [[]|[<- <-]] //=.\nby do 2!move/eqP->.\nQed.",
    "Lemma pair_eqE : pair_eq = eq_op :> rel _. Proof. by []. Qed.",
    "Lemma xpair_eqE (x1 y1 : T1) (x2 y2 : T2) :\n  ((x1, x2) == (y1, y2)) = ((x1 == y1) && (x2 == y2)).\nProof. by []. Qed.",
    "Lemma pair_eq1 (u v : T1 * T2) : u == v -> u.1 == v.1.\nProof. by case/andP. Qed.",
    "Lemma pair_eq2 (u v : T1 * T2) : u == v -> u.2 == v.2.\nProof. by case/andP. Qed.",
    "Lemma opt_eqP : Equality.axiom opt_eq.\nProof.\ncase=> [x|] [y|] /=; by [constructor | apply: (iffP eqP) => [|[]] ->].\nQed.",
    "Lemma tagged_asE u x : tagged_as u (Tagged T_ x) = x.\nProof.\nby rewrite /tagged_as /=; case: eqP => // eq_uu; rewrite [eq_uu]eq_axiomK.\nQed.",
    "Lemma tag_eqP : Equality.axiom tag_eq.\nProof.\nrewrite /tag_eq => [] [i x] [j] /=.\ncase: eqP => [<-|Hij] y; last by right; case.\nby apply: (iffP eqP) => [->|<-]; rewrite tagged_asE.\nQed.",
    "Lemma tag_eqE : tag_eq = eq_op. Proof. by []. Qed.",
    "Lemma eq_tag u v : u == v -> tag u = tag v.\nProof. by move/eqP->. Qed.",
    "Lemma eq_Tagged u x :(u == Tagged _ x) = (tagged u == x).\nProof. by rewrite -tag_eqE /tag_eq eqxx tagged_asE. Qed.",
    "Lemma sum_eqP : Equality.axiom sum_eq.\nProof. case=> x [] y /=; by [right | apply: (iffP eqP) => [->|[->]]]. Qed.",
    "Lemma sum_eqE : sum_eq = eq_op. Proof. by []. Qed.",
    "Lemma homoW_in : {in D & D', {homo f : x y / aR' x y >-> rR' x y}} ->\n                 {in D & D', {homo f : x y / aR x y >-> rR x y}}.\nProof.\nby move=> mf x y xD yD /[!aRE]/orP[/eqP->|/mf]; rewrite rRE ?eqxx// orbC => ->.\nQed.",
    "Lemma inj_homo_in : {in D & D', injective f} ->\n  {in D & D', {homo f : x y / aR x y >-> rR x y}} ->\n  {in D & D', {homo f : x y / aR' x y >-> rR' x y}}.\nProof.\nmove=> fI mf x y xD yD /[!(aR'E, rR'E)] /andP[neq_xy xy].\nby rewrite mf ?andbT//; apply: contra_neq neq_xy; apply: fI.\nQed.",
    "Lemma mono_inj_in : {in D &, {mono f : x y / aR x y >-> rR x y}} ->\n                 {in D &, injective f}.\nProof. by move=> mf x y ?? eqf; apply/aR_anti; rewrite -!mf// eqf rR_refl. Qed.",
    "Lemma anti_mono_in : {in D &, {mono f : x y / aR x y >-> rR x y}} ->\n                     {in D &, {mono f : x y / aR' x y >-> rR' x y}}.\nProof.\nmove=> mf x y ??; rewrite rR'E aR'E mf// (@inj_in_eq _ _ D)//.\nexact: mono_inj_in.\nQed.",
    "Lemma total_homo_mono_in : total aR ->\n    {in D &, {homo f : x y / aR' x y >-> rR' x y}} ->\n   {in D &, {mono f : x y / aR x y >-> rR x y}}.\nProof.\nmove=> aR_tot mf x y xD yD.\nhave [->|neq_xy] := eqVneq x y; first by rewrite ?eqxx ?aR_refl ?rR_refl.\nhave [xy|] := (boolP (aR x y)); first by rewrite rRE mf ?orbT// aR'E neq_xy.\nhave /orP [->//|] := aR_tot x y.\nrewrite aRE eq_sym (negPf neq_xy) /= => /mf -/(_ yD xD).\nrewrite rR'E => /andP[Nfxfy fyfx] _; apply: contra_neqF Nfxfy => fxfy.\nby apply/rR_anti; rewrite fyfx fxfy.\nQed.",
    "Lemma homoW : {homo f : x y / aR' x y >-> rR' x y} ->\n                 {homo f : x y / aR x y >-> rR x y}.\nProof. by move=> mf ???; apply: (@homoW_in D D) => // ????; apply: mf. Qed.",
    "Lemma inj_homo : injective f ->\n  {homo f : x y / aR x y >-> rR x y} ->\n  {homo f : x y / aR' x y >-> rR' x y}.\nProof.\nby move=> fI mf ???; apply: (@inj_homo_in D D) => //????; [apply: fI|apply: mf].\nQed.",
    "Lemma mono_inj : {mono f : x y / aR x y >-> rR x y} -> injective f.\nProof. by move=> mf x y eqf; apply/aR_anti; rewrite -!mf eqf rR_refl. Qed.",
    "Lemma anti_mono : {mono f : x y / aR x y >-> rR x y} ->\n                  {mono f : x y / aR' x y >-> rR' x y}.\nProof. by move=> mf x y; rewrite rR'E aR'E mf inj_eq //; apply: mono_inj. Qed.",
    "Lemma total_homo_mono : total aR ->\n    {homo f : x y / aR' x y >-> rR' x y} ->\n   {mono f : x y / aR x y >-> rR x y}.\nProof.\nmove=> /(@total_homo_mono_in D rR_anti) hmf hf => x y.\nby apply: hmf => // ?? _ _; apply: hf.\nQed.",
    "Lemma in_set pA x : x \\in finset pA = pA x.\nProof. by rewrite [@finset]unlock unlock [x \\in _]ffunE. Qed.",
    "Lemma setP A B : A =i B <-> A = B.\nProof.\nby split=> [eqAB|-> //]; apply/val_inj/ffunP=> x; have:= eqAB x; rewrite unlock.\nQed.",
    "Lemma in_setT x : x \\in setTfor.\nProof. by rewrite in_set. Qed.",
    "Lemma eqsVneq A B : eq_xor_neq A B (B == A) (A == B).\nProof. exact: eqVneq. Qed.",
    "Lemma eq_finset (pA pB : pred T) : pA =1 pB -> finset pA = finset pB.\nProof. by move=> eq_p; apply/setP => x; rewrite !(in_set, inE) eq_p. Qed.",
    "Lemma eqEsubset A B : (A == B) = (A \\subset B) && (B \\subset A).\nProof. by apply/eqP/subset_eqP=> /setP. Qed.",
    "Lemma subEproper A B : A \\subset B = (A == B) || (A \\proper B).\nProof. by rewrite eqEsubset -andb_orr orbN andbT. Qed.",
    "Lemma eqVproper A B : A \\subset B -> A = B \\/ A \\proper B.\nProof. by rewrite subEproper => /predU1P. Qed.",
    "Lemma properEneq A B : A \\proper B = (A != B) && (A \\subset B).\nProof. by rewrite andbC eqEsubset negb_and andb_orr andbN. Qed.",
    "Lemma proper_neq A B : A \\proper B -> A != B.\nProof. by rewrite properEneq; case/andP. Qed.",
    "Lemma eqEproper A B : (A == B) = (A \\subset B) && ~~ (A \\proper B).\nProof. by rewrite negb_and negbK andb_orr andbN eqEsubset. Qed.",
    "Lemma eqEcard A B : (A == B) = (A \\subset B) && (#|B| <= #|A|).\nProof.\nrewrite eqEsubset; apply: andb_id2l => sAB.\nby rewrite (geq_leqif (subset_leqif_card sAB)).\nQed.",
    "Lemma properEcard A B : (A \\proper B) = (A \\subset B) && (#|A| < #|B|).\nProof. by rewrite properEneq ltnNge andbC eqEcard; case: (A \\subset B). Qed.",
    "Lemma subset_leqif_cards A B : A \\subset B -> (#|A| <= #|B| ?= iff (A == B)).\nProof. by move=> sAB; rewrite eqEsubset sAB; apply: subset_leqif_card. Qed.",
    "Lemma in_set0 x : x \\in set0 = false.\nProof. by rewrite in_set. Qed.",
    "Lemma sub0set A : set0 \\subset A.\nProof. by apply/subsetP=> x; rewrite in_set. Qed.",
    "Lemma subset0 A : (A \\subset set0) = (A == set0).\nProof. by rewrite eqEsubset sub0set andbT. Qed.",
    "Lemma proper0 A : (set0 \\proper A) = (A != set0).\nProof. by rewrite properE sub0set subset0. Qed.",
    "Lemma subset_neq0 A B : A \\subset B -> A != set0 -> B != set0.\nProof. by rewrite -!proper0 => sAB /proper_sub_trans->. Qed.",
    "Lemma set_0Vmem A : (A = set0) + {x : T | x \\in A}.\nProof.\ncase: (pickP (mem A)) => [x Ax | A0]; [by right; exists x | left].\nby apply/setP=> x; rewrite in_set; apply: A0.\nQed.",
    "Lemma set_enum A : [set x | x \\in enum A] = A.\nProof. by apply/setP => x; rewrite in_set mem_enum. Qed.",
    "Lemma enum_set0 : enum set0 = [::] :> seq T.\nProof. by rewrite (eq_enum (in_set _)) enum0. Qed.",
    "Lemma subsetT A : A \\subset setT.\nProof. by apply/subsetP=> x; rewrite in_set. Qed.",
    "Lemma subsetT_hint mA : subset mA (mem [set: T]).\nProof. by rewrite unlock; apply/pred0P=> x; rewrite !inE in_set. Qed.",
    "Lemma subTset A : (setT \\subset A) = (A == setT).\nProof. by rewrite eqEsubset subsetT. Qed.",
    "Lemma properT A : (A \\proper setT) = (A != setT).\nProof. by rewrite properEneq subsetT andbT. Qed.",
    "Lemma set1P x a : reflect (x = a) (x \\in [set a]).\nProof. by rewrite set1.unlock in_set; apply: eqP. Qed.",
    "Lemma enum_setT : enum [set: T] = Finite.enum T.\nProof. by rewrite (eq_enum (in_set _)) enumT. Qed.",
    "Lemma in_set1 x a : (x \\in [set a]) = (x == a).\nProof. by rewrite set1.unlock in_set. Qed.",
    "Lemma set11 x : x \\in [set x].\nProof. by rewrite !inE. Qed.",
    "Lemma set1_inj : injective (@set1 T).\nProof. by move=> a b eqsab; apply/set1P; rewrite -eqsab set11. Qed.",
    "Lemma enum_set1 a : enum [set a] = [:: a].\nProof. by rewrite set1.unlock (eq_enum (in_set _)) enum1. Qed.",
    "Lemma setU1P x a B : reflect (x = a \\/ x \\in B) (x \\in a |: B).\nProof. by rewrite !inE; apply: predU1P. Qed.",
    "Lemma in_setU1 x a B : (x \\in a |: B) = (x == a) || (x \\in B).\nProof. by rewrite !inE. Qed.",
    "Lemma set_nil : [set:: nil] = @set0 T. Proof. by rewrite -enum_set0 set_enum. Qed.",
    "Lemma set_seq1 a : [set:: [:: a]] = [set a].\nProof. by rewrite -enum_set1 set_enum. Qed.",
    "Lemma set_cons a s : [set:: a :: s] = a |: [set:: s].\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma setU11 x B : x \\in x |: B.\nProof. by rewrite !inE eqxx. Qed.",
    "Lemma setU1r x a B : x \\in B -> x \\in a |: B.\nProof. by move=> Bx; rewrite !inE predU1r. Qed.",
    "Lemma set1Ul x A b : x \\in A -> x \\in A :|: [set b].\nProof. by move=> Ax; rewrite !inE Ax. Qed.",
    "Lemma set1Ur A b : b \\in A :|: [set b].\nProof. by rewrite !inE eqxx orbT. Qed.",
    "Lemma in_setC1 x a : (x \\in [set~ a]) = (x != a).\nProof. by rewrite !inE. Qed.",
    "Lemma setC11 x : (x \\in [set~ x]) = false.\nProof. by rewrite !inE eqxx. Qed.",
    "Lemma setD1P x A b : reflect (x != b /\\ x \\in A) (x \\in A :\\ b).\nProof. by rewrite !inE; apply: andP. Qed.",
    "Lemma in_setD1 x A b : (x \\in A :\\ b) = (x != b) && (x \\in A) .\nProof. by rewrite !inE. Qed.",
    "Lemma setD11 b A : (b \\in A :\\ b) = false.\nProof. by rewrite !inE eqxx. Qed.",
    "Lemma setD1K a A : a \\in A -> a |: (A :\\ a) = A.\nProof. by move=> Aa; apply/setP=> x /[!inE]; case: eqP => // ->. Qed.",
    "Lemma setU1K a B : a \\notin B -> (a |: B) :\\ a = B.\nProof.\nby move/negPf=> nBa; apply/setP=> x /[!inE]; case: eqP => // ->.\nQed.",
    "Lemma set2P x a b : reflect (x = a \\/ x = b) (x \\in [set a; b]).\nProof. by rewrite !inE; apply: pred2P. Qed.",
    "Lemma in_set2 x a b : (x \\in [set a; b]) = (x == a) || (x == b).\nProof. by rewrite !inE. Qed.",
    "Lemma set21 a b : a \\in [set a; b].\nProof. by rewrite !inE eqxx. Qed.",
    "Lemma set22 a b : b \\in [set a; b].\nProof. by rewrite !inE eqxx orbT. Qed.",
    "Lemma setUP x A B : reflect (x \\in A \\/ x \\in B) (x \\in A :|: B).\nProof. by rewrite !inE; apply: orP. Qed.",
    "Lemma in_setU x A B : (x \\in A :|: B) = (x \\in A) || (x \\in B).\nProof. exact: in_set. Qed.",
    "Lemma setUC A B : A :|: B = B :|: A.\nProof. by apply/setP => x; rewrite !inE orbC. Qed.",
    "Lemma setUS A B C : A \\subset B -> C :|: A \\subset C :|: B.\nProof.\nmove=> sAB; apply/subsetP=> x; rewrite !inE.\nby case: (x \\in C) => //; apply: (subsetP sAB).\nQed.",
    "Lemma setSU A B C : A \\subset B -> A :|: C \\subset B :|: C.\nProof. by move=> sAB; rewrite -!(setUC C) setUS. Qed.",
    "Lemma setUSS A B C D : A \\subset C -> B \\subset D -> A :|: B \\subset C :|: D.\nProof. by move=> /(setSU B) /subset_trans sAC /(setUS C)/sAC. Qed.",
    "Lemma set0U A : set0 :|: A = A.\nProof. by apply/setP => x; rewrite !inE orFb. Qed.",
    "Lemma setU0 A : A :|: set0 = A.\nProof. by rewrite setUC set0U. Qed.",
    "Lemma setUA A B C : A :|: (B :|: C) = A :|: B :|: C.\nProof. by apply/setP => x; rewrite !inE orbA. Qed.",
    "Lemma setUCA A B C : A :|: (B :|: C) = B :|: (A :|: C).\nProof. by rewrite !setUA (setUC B). Qed.",
    "Lemma setUAC A B C : A :|: B :|: C = A :|: C :|: B.\nProof. by rewrite -!setUA (setUC B). Qed.",
    "Lemma setUACA A B C D : (A :|: B) :|: (C :|: D) = (A :|: C) :|: (B :|: D).\nProof. by rewrite -!setUA (setUCA B). Qed.",
    "Lemma setTU A : setT :|: A = setT.\nProof. by apply/setP => x; rewrite !inE orTb. Qed.",
    "Lemma setUT A : A :|: setT = setT.\nProof. by rewrite setUC setTU. Qed.",
    "Lemma setUid A : A :|: A = A.\nProof. by apply/setP=> x; rewrite inE orbb. Qed.",
    "Lemma setUUl A B C : A :|: B :|: C = (A :|: C) :|: (B :|: C).\nProof. by rewrite setUA !(setUAC _ C) -(setUA _ C) setUid. Qed.",
    "Lemma setUUr A B C : A :|: (B :|: C) = (A :|: B) :|: (A :|: C).\nProof. by rewrite !(setUC A) setUUl. Qed.",
    "Lemma setIdP x pA pB : reflect (pA x /\\ pB x) (x \\in [set y | pA y & pB y]).\nProof. by rewrite !inE; apply: andP. Qed.",
    "Lemma setId2P x pA pB pC :\n  reflect [/\\ pA x, pB x & pC x] (x \\in [set y | pA y & pB y && pC y]).\nProof. by rewrite !inE; apply: and3P. Qed.",
    "Lemma setIdE A pB : [set x in A | pB x] = A :&: [set x | pB x].\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma setIP x A B : reflect (x \\in A /\\ x \\in B) (x \\in A :&: B).\nProof. exact: (iffP (@setIdP _ _ _)). Qed.",
    "Lemma in_setI x A B : (x \\in A :&: B) = (x \\in A) && (x \\in B).\nProof. exact: in_set. Qed.",
    "Lemma setIC A B : A :&: B = B :&: A.\nProof. by apply/setP => x; rewrite !inE andbC. Qed.",
    "Lemma setIS A B C : A \\subset B -> C :&: A \\subset C :&: B.\nProof.\nmove=> sAB; apply/subsetP=> x; rewrite !inE.\nby case: (x \\in C) => //; apply: (subsetP sAB).\nQed.",
    "Lemma setSI A B C : A \\subset B -> A :&: C \\subset B :&: C.\nProof. by move=> sAB; rewrite -!(setIC C) setIS. Qed.",
    "Lemma setISS A B C D : A \\subset C -> B \\subset D -> A :&: B \\subset C :&: D.\nProof. by move=> /(setSI B) /subset_trans sAC /(setIS C) /sAC. Qed.",
    "Lemma setTI A : setT :&: A = A.\nProof. by apply/setP => x; rewrite !inE andTb. Qed.",
    "Lemma setIT A : A :&: setT = A.\nProof. by rewrite setIC setTI. Qed.",
    "Lemma set0I A : set0 :&: A = set0.\nProof. by apply/setP => x; rewrite !inE andFb. Qed.",
    "Lemma setI0 A : A :&: set0 = set0.\nProof. by rewrite setIC set0I. Qed.",
    "Lemma setIA A B C : A :&: (B :&: C) = A :&: B :&: C.\nProof. by apply/setP=> x; rewrite !inE andbA. Qed.",
    "Lemma setICA A B C : A :&: (B :&: C) = B :&: (A :&: C).\nProof. by rewrite !setIA (setIC A). Qed.",
    "Lemma setIAC A B C : A :&: B :&: C = A :&: C :&: B.\nProof. by rewrite -!setIA (setIC B). Qed.",
    "Lemma setIACA A B C D : (A :&: B) :&: (C :&: D) = (A :&: C) :&: (B :&: D).\nProof. by rewrite -!setIA (setICA B). Qed.",
    "Lemma setIid A : A :&: A = A.\nProof. by apply/setP=> x; rewrite inE andbb. Qed.",
    "Lemma setIIl A B C : A :&: B :&: C = (A :&: C) :&: (B :&: C).\nProof. by rewrite setIA !(setIAC _ C) -(setIA _ C) setIid. Qed.",
    "Lemma setIIr A B C : A :&: (B :&: C) = (A :&: B) :&: (A :&: C).\nProof. by rewrite !(setIC A) setIIl. Qed.",
    "Lemma setIUr A B C : A :&: (B :|: C) = (A :&: B) :|: (A :&: C).\nProof. by apply/setP=> x; rewrite !inE andb_orr. Qed.",
    "Lemma setIUl A B C : (A :|: B) :&: C = (A :&: C) :|: (B :&: C).\nProof. by apply/setP=> x; rewrite !inE andb_orl. Qed.",
    "Lemma setUIr A B C : A :|: (B :&: C) = (A :|: B) :&: (A :|: C).\nProof. by apply/setP=> x; rewrite !inE orb_andr. Qed.",
    "Lemma setUIl A B C : (A :&: B) :|: C = (A :|: C) :&: (B :|: C).\nProof. by apply/setP=> x; rewrite !inE orb_andl. Qed.",
    "Lemma setUK A B : (A :|: B) :&: A = A.\nProof. by apply/setP=> x; rewrite !inE orbK. Qed.",
    "Lemma setKU A B : A :&: (B :|: A) = A.\nProof. by apply/setP=> x; rewrite !inE orKb. Qed.",
    "Lemma setIK A B : (A :&: B) :|: A = A.\nProof. by apply/setP=> x; rewrite !inE andbK. Qed.",
    "Lemma setKI A B : A :|: (B :&: A) = A.\nProof. by apply/setP=> x; rewrite !inE andKb. Qed.",
    "Lemma setCP x A : reflect (~ x \\in A) (x \\in ~: A).\nProof. by rewrite !inE; apply: negP. Qed.",
    "Lemma in_setC x A : (x \\in ~: A) = (x \\notin A).\nProof. exact: in_set. Qed.",
    "Lemma setCK : involutive (@setC T).\nProof. by move=> A; apply/setP=> x; rewrite !inE negbK. Qed.",
    "Lemma setC_inj : injective (@setC T).\nProof. exact: can_inj setCK. Qed.",
    "Lemma subsets_disjoint A B : (A \\subset B) = [disjoint A & ~: B].\nProof. by rewrite subset_disjoint; apply: eq_disjoint_r => x; rewrite !inE. Qed.",
    "Lemma disjoints_subset A B : [disjoint A & B] = (A \\subset ~: B).\nProof. by rewrite subsets_disjoint setCK. Qed.",
    "Lemma powersetCE A B : (A \\in powerset (~: B)) = [disjoint A & B].\nProof. by rewrite inE disjoints_subset. Qed.",
    "Lemma setCS A B : (~: A \\subset ~: B) = (B \\subset A).\nProof. by rewrite !subsets_disjoint setCK disjoint_sym. Qed.",
    "Lemma setCU A B : ~: (A :|: B) = ~: A :&: ~: B.\nProof. by apply/setP=> x; rewrite !inE negb_or. Qed.",
    "Lemma setCI A B : ~: (A :&: B) = ~: A :|: ~: B.\nProof. by apply/setP=> x; rewrite !inE negb_and. Qed.",
    "Lemma setUCr A : A :|: ~: A = setT.\nProof. by apply/setP=> x; rewrite !inE orbN. Qed.",
    "Lemma setICr A : A :&: ~: A = set0.\nProof. by apply/setP=> x; rewrite !inE andbN. Qed.",
    "Lemma setC0 : ~: set0 = [set: T].\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma setCT : ~: [set: T] = set0.\nProof. by rewrite -setC0 setCK. Qed.",
    "Lemma properC A B : (~: B \\proper ~: A) = (A \\proper B).\nProof. by rewrite !properE !setCS. Qed.",
    "Lemma setDP A B x : reflect (x \\in A /\\ x \\notin B) (x \\in A :\\: B).\nProof. by rewrite inE andbC; apply: andP. Qed.",
    "Lemma in_setD A B x : (x \\in A :\\: B) = (x \\notin B) && (x \\in A).\nProof. exact: in_set. Qed.",
    "Lemma setDE A B : A :\\: B = A :&: ~: B.\nProof. by apply/setP => x; rewrite !inE andbC. Qed.",
    "Lemma setSD A B C : A \\subset B -> A :\\: C \\subset B :\\: C.\nProof. by rewrite !setDE; apply: setSI. Qed.",
    "Lemma setDS A B C : A \\subset B -> C :\\: B \\subset C :\\: A.\nProof. by rewrite !setDE -setCS; apply: setIS. Qed.",
    "Lemma setDSS A B C D : A \\subset C -> D \\subset B -> A :\\: B \\subset C :\\: D.\nProof. by move=> /(setSD B) /subset_trans sAC /(setDS C) /sAC. Qed.",
    "Lemma setD0 A : A :\\: set0 = A.\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma set0D A : set0 :\\: A = set0.\nProof. by apply/setP=> x; rewrite !inE andbF. Qed.",
    "Lemma setDT A : A :\\: setT = set0.\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma setTD A : setT :\\: A = ~: A.\nProof. by apply/setP=> x; rewrite !inE andbT. Qed.",
    "Lemma setDv A : A :\\: A = set0.\nProof. by apply/setP=> x; rewrite !inE andNb. Qed.",
    "Lemma setCD A B : ~: (A :\\: B) = ~: A :|: B.\nProof. by rewrite !setDE setCI setCK. Qed.",
    "Lemma setID A B : A :&: B :|: A :\\: B = A.\nProof. by rewrite setDE -setIUr setUCr setIT. Qed.",
    "Lemma setDUl A B C : (A :|: B) :\\: C = (A :\\: C) :|: (B :\\: C).\nProof. by rewrite !setDE setIUl. Qed.",
    "Lemma setDUr A B C : A :\\: (B :|: C) = (A :\\: B) :&: (A :\\: C).\nProof. by rewrite !setDE setCU setIIr. Qed.",
    "Lemma setDIl A B C : (A :&: B) :\\: C = (A :\\: C) :&: (B :\\: C).\nProof. by rewrite !setDE setIIl. Qed.",
    "Lemma setIDA A B C : A :&: (B :\\: C) = (A :&: B) :\\: C.\nProof. by rewrite !setDE setIA. Qed.",
    "Lemma setIDAC A B C : (A :\\: B) :&: C = (A :&: C) :\\: B.\nProof. by rewrite !setDE setIAC. Qed.",
    "Lemma setDIr A B C : A :\\: (B :&: C) = (A :\\: B) :|: (A :\\: C).\nProof. by rewrite !setDE setCI setIUr. Qed.",
    "Lemma setDDl A B C : (A :\\: B) :\\: C = A :\\: (B :|: C).\nProof. by rewrite !setDE setCU setIA. Qed.",
    "Lemma setDDr A B C : A :\\: (B :\\: C) = (A :\\: B) :|: (A :&: C).\nProof. by rewrite !setDE setCI setIUr setCK. Qed.",
    "Lemma powersetE A B : (A \\in powerset B) = (A \\subset B).\nProof. by rewrite inE. Qed.",
    "Lemma powersetS A B : (powerset A \\subset powerset B) = (A \\subset B).\nProof.\napply/subsetP/idP=> [sAB | sAB C /[!inE]/subset_trans->//].\nby rewrite -powersetE sAB // inE.\nQed.",
    "Lemma powerset0 : powerset set0 = [set set0] :> {set {set T}}.\nProof. by apply/setP=> A; rewrite set1.unlock !inE subset0. Qed.",
    "Lemma powersetT : powerset [set: T] = [set: {set T}].\nProof. by apply/setP=> A; rewrite !inE subsetT. Qed.",
    "Lemma setI_powerset P A : P :&: powerset A = P ::&: A.\nProof. by apply/setP=> B; rewrite !inE. Qed.",
    "Lemma cardsE pA : #|[set x in pA]| = #|pA|.\nProof. exact/eq_card/in_set. Qed.",
    "Lemma sum1dep_card pA : \\sum_(x | pA x) 1 = #|[set x | pA x]|.\nProof. by rewrite sum1_card cardsE. Qed.",
    "Lemma sum_nat_cond_const pA n : \\sum_(x | pA x) n = #|[set x | pA x]| * n.\nProof. by rewrite sum_nat_const cardsE. Qed.",
    "Lemma cards0 : #|@set0 T| = 0.\nProof. by rewrite cardsE card0. Qed.",
    "Lemma cards_eq0 A : (#|A| == 0) = (A == set0).\nProof. by rewrite (eq_sym A) eqEcard sub0set cards0 leqn0. Qed.",
    "Lemma set0Pn A : reflect (exists x, x \\in A) (A != set0).\nProof. by rewrite -cards_eq0; apply: existsP. Qed.",
    "Lemma card_gt0 A : (0 < #|A|) = (A != set0).\nProof. by rewrite lt0n cards_eq0. Qed.",
    "Lemma cards0_eq A : #|A| = 0 -> A = set0.\nProof. by move=> A_0; apply/setP=> x; rewrite inE (card0_eq A_0). Qed.",
    "Lemma cards1 x : #|[set x]| = 1.\nProof. by rewrite set1.unlock cardsE card1. Qed.",
    "Lemma cardsUI A B : #|A :|: B| + #|A :&: B| = #|A| + #|B|.\nProof. by rewrite !cardsE cardUI. Qed.",
    "Lemma cardsU A B : #|A :|: B| = (#|A| + #|B| - #|A :&: B|)%N.\nProof. by rewrite -cardsUI addnK. Qed.",
    "Lemma cardsI A B : #|A :&: B| = (#|A| + #|B| - #|A :|: B|)%N.\nProof. by rewrite -cardsUI addKn. Qed.",
    "Lemma cardsT : #|[set: T]| = #|T|.\nProof. by rewrite cardsE. Qed.",
    "Lemma cardsID B A : #|A :&: B| + #|A :\\: B| = #|A|.\nProof. by rewrite !cardsE cardID. Qed.",
    "Lemma cardsD A B : #|A :\\: B| = (#|A| - #|A :&: B|)%N.\nProof. by rewrite -(cardsID B A) addKn. Qed.",
    "Lemma cardsC A : #|A| + #|~: A| = #|T|.\nProof. by rewrite cardsE cardC. Qed.",
    "Lemma cardsCs A : #|A| = #|T| - #|~: A|.\nProof. by rewrite -(cardsC A) addnK. Qed.",
    "Lemma cardsU1 a A : #|a |: A| = (a \\notin A) + #|A|.\nProof. by rewrite -cardU1; apply: eq_card=> x; rewrite !inE. Qed.",
    "Lemma cards2 a b : #|[set a; b]| = (a != b).+1.\nProof. by rewrite -card2; apply: eq_card=> x; rewrite !inE. Qed.",
    "Lemma cardsC1 a : #|[set~ a]| = #|T|.-1.\nProof. by rewrite -(cardC1 a); apply: eq_card=> x; rewrite !inE. Qed.",
    "Lemma cardsD1 a A : #|A| = (a \\in A) + #|A :\\ a|.\nProof.\nby rewrite (cardD1 a); congr (_ + _); apply: eq_card => x; rewrite !inE.\nQed.",
    "Lemma subsetIl A B : A :&: B \\subset A.\nProof. by apply/subsetP=> x /[!inE] /andP[]. Qed.",
    "Lemma subsetIr A B : A :&: B \\subset B.\nProof. by apply/subsetP=> x /[!inE] /andP[]. Qed.",
    "Lemma subsetUl A B : A \\subset A :|: B.\nProof. by apply/subsetP=> x /[!inE] ->. Qed.",
    "Lemma subsetUr A B : B \\subset A :|: B.\nProof. by apply/subsetP=> x; rewrite inE orbC => ->. Qed.",
    "Lemma subsetU1 x A : A \\subset x |: A.\nProof. exact: subsetUr. Qed.",
    "Lemma subsetDl A B : A :\\: B \\subset A.\nProof. by rewrite setDE subsetIl. Qed.",
    "Lemma subD1set A x : A :\\ x \\subset A.\nProof. by rewrite subsetDl. Qed.",
    "Lemma subsetDr A B : A :\\: B \\subset ~: B.\nProof. by rewrite setDE subsetIr. Qed.",
    "Lemma sub1set A x : ([set x] \\subset A) = (x \\in A).\nProof. by rewrite -subset_pred1; apply: eq_subset=> y; rewrite !inE. Qed.",
    "Lemma cards_eqP A : cards_eq_spec A (enum A) A #|A|.\nProof.\nby move: (enum A) (cardE A) (set_enum A) (enum_uniq A) => s -> <-; constructor.\nQed.",
    "Lemma cards1P A : reflect (exists x, A = [set x]) (#|A| == 1).\nProof.\napply: (iffP idP) => [|[x ->]]; last by rewrite cards1.\nby have [[|x []]// _] := cards_eqP; exists x; apply/setP => y; rewrite !inE.\nQed.",
    "Lemma cards2P A : reflect (exists x y : T, x != y /\\ A = [set x; y])\n                          (#|A| == 2).\nProof.\napply: (iffP idP) => [|[x] [y] [xy ->]]; last by rewrite cards2 xy.\nhave [[|x [|y []]]//=] := cards_eqP; rewrite !inE andbT => neq_xy.\nby exists x, y; split=> //; apply/setP => z; rewrite !inE.\nQed.",
    "Lemma subset1 A x : (A \\subset [set x]) = (A == [set x]) || (A == set0).\nProof.\nrewrite eqEcard cards1 -cards_eq0 orbC andbC.\nby case: posnP => // A0; rewrite (cards0_eq A0) sub0set.\nQed.",
    "Lemma powerset1 x : powerset [set x] = [set set0; [set x]].\nProof. by apply/setP=> A; rewrite inE subset1 orbC set1.unlock !inE. Qed.",
    "Lemma setIidPl A B : reflect (A :&: B = A) (A \\subset B).\nProof.\napply: (iffP subsetP) => [sAB | <- x /setIP[] //].\nby apply/setP=> x /[1!inE]; apply/andb_idr/sAB.\nQed.",
    "Lemma setIidPr A B : reflect (A :&: B = B) (B \\subset A).\nProof. by rewrite setIC; apply: setIidPl. Qed.",
    "Lemma cardsDS A B : B \\subset A -> #|A :\\: B| = (#|A| - #|B|)%N.\nProof. by rewrite cardsD => /setIidPr->. Qed.",
    "Lemma setUidPl A B : reflect (A :|: B = A) (B \\subset A).\nProof.\nby rewrite -setCS (sameP setIidPl eqP) -setCU (inj_eq setC_inj); apply: eqP.\nQed.",
    "Lemma setUidPr A B : reflect (A :|: B = B) (A \\subset B).\nProof. by rewrite setUC; apply: setUidPl. Qed.",
    "Lemma setDidPl A B : reflect (A :\\: B = A) [disjoint A & B].\nProof. by rewrite setDE disjoints_subset; apply: setIidPl. Qed.",
    "Lemma subIset A B C : (B \\subset A) || (C \\subset A) -> (B :&: C \\subset A).\nProof. by case/orP; apply: subset_trans; rewrite (subsetIl, subsetIr). Qed.",
    "Lemma subsetI A B C : (A \\subset B :&: C) = (A \\subset B) && (A \\subset C).\nProof.\nrewrite !(sameP setIidPl eqP) setIA; have [-> //|] := eqVneq (A :&: B) A.\nby apply: contraNF => /eqP <-; rewrite -setIA -setIIl setIAC.\nQed.",
    "Lemma subsetIP A B C : reflect (A \\subset B /\\ A \\subset C) (A \\subset B :&: C).\nProof. by rewrite subsetI; apply: andP. Qed.",
    "Lemma subsetIidl A B : (A \\subset A :&: B) = (A \\subset B).\nProof. by rewrite subsetI subxx. Qed.",
    "Lemma subsetIidr A B : (B \\subset A :&: B) = (B \\subset A).\nProof. by rewrite setIC subsetIidl. Qed.",
    "Lemma powersetI A B : powerset (A :&: B) = powerset A :&: powerset B.\nProof. by apply/setP=> C; rewrite !inE subsetI. Qed.",
    "Lemma subUset A B C : (B :|: C \\subset A) = (B \\subset A) && (C \\subset A).\nProof. by rewrite -setCS setCU subsetI !setCS. Qed.",
    "Lemma subsetU A B C : (A \\subset B) || (A \\subset C) -> A \\subset B :|: C.\nProof. by rewrite -!(setCS _ A) setCU; apply: subIset. Qed.",
    "Lemma subUsetP A B C : reflect (A \\subset C /\\ B \\subset C) (A :|: B \\subset C).\nProof. by rewrite subUset; apply: andP. Qed.",
    "Lemma subsetC A B : (A \\subset ~: B) = (B \\subset ~: A).\nProof. by rewrite -setCS setCK. Qed.",
    "Lemma subCset A B : (~: A \\subset B) = (~: B \\subset A).\nProof. by rewrite -setCS setCK. Qed.",
    "Lemma subsetD A B C : (A \\subset B :\\: C) = (A \\subset B) && [disjoint A & C].\nProof. by rewrite setDE subsetI -disjoints_subset. Qed.",
    "Lemma subDset A B C : (A :\\: B \\subset C) = (A \\subset B :|: C).\nProof.\napply/subsetP/subsetP=> sABC x; rewrite !inE.\n  by case Bx: (x \\in B) => // Ax; rewrite sABC ?inE ?Bx.\nby case Bx: (x \\in B) => // /sABC; rewrite inE Bx.\nQed.",
    "Lemma subsetDP A B C :\n  reflect (A \\subset B /\\ [disjoint A & C]) (A \\subset B :\\: C).\nProof. by rewrite subsetD; apply: andP. Qed.",
    "Lemma setU_eq0 A B : (A :|: B == set0) = (A == set0) && (B == set0).\nProof. by rewrite -!subset0 subUset. Qed.",
    "Lemma setD_eq0 A B : (A :\\: B == set0) = (A \\subset B).\nProof. by rewrite -subset0 subDset setU0. Qed.",
    "Lemma setI_eq0 A B : (A :&: B == set0) = [disjoint A & B].\nProof. by rewrite disjoints_subset -setD_eq0 setDE setCK. Qed.",
    "Lemma disjoint_setI0 A B : [disjoint A & B] -> A :&: B = set0.\nProof. by rewrite -setI_eq0; move/eqP. Qed.",
    "Lemma disjoints1 A x : [disjoint [set x] & A] = (x \\notin A).\nProof. by rewrite (@eq_disjoint1 _ x) // => y; rewrite !inE. Qed.",
    "Lemma subsetD1 A B x : (A \\subset B :\\ x) = (A \\subset B) && (x \\notin A).\nProof. by rewrite setDE subsetI subsetC sub1set inE. Qed.",
    "Lemma subsetD1P A B x : reflect (A \\subset B /\\ x \\notin A) (A \\subset B :\\ x).\nProof. by rewrite subsetD1; apply: andP. Qed.",
    "Lemma properD1 A x : x \\in A -> A :\\ x \\proper A.\nProof.\nmove=> Ax; rewrite properE subsetDl; apply/subsetPn; exists x=> //.\nby rewrite in_setD1 Ax eqxx.\nQed.",
    "Lemma properIr A B : ~~ (B \\subset A) -> A :&: B \\proper B.\nProof. by move=> nsAB; rewrite properE subsetIr subsetI negb_and nsAB. Qed.",
    "Lemma properIl A B : ~~ (A \\subset B) -> A :&: B \\proper A.\nProof. by move=> nsBA; rewrite properE subsetIl subsetI negb_and nsBA orbT. Qed.",
    "Lemma properUr A B : ~~ (A \\subset B) ->  B \\proper A :|: B.\nProof. by rewrite properE subsetUr subUset subxx /= andbT. Qed.",
    "Lemma properUl A B : ~~ (B \\subset A) ->  A \\proper A :|: B.\nProof. by move=> not_sBA; rewrite setUC properUr. Qed.",
    "Lemma proper1set A x : ([set x] \\proper A) -> (x \\in A).\nProof. by move/proper_sub; rewrite sub1set. Qed.",
    "Lemma properIset A B C : (B \\proper A) || (C \\proper A) -> (B :&: C \\proper A).\nProof. by case/orP; apply: sub_proper_trans; rewrite (subsetIl, subsetIr). Qed.",
    "Lemma properI A B C : (A \\proper B :&: C) -> (A \\proper B) && (A \\proper C).\nProof.\nmove=> pAI; apply/andP.\nby split; apply: (proper_sub_trans pAI); rewrite (subsetIl, subsetIr).\nQed.",
    "Lemma properU A B C : (B :|: C \\proper A) -> (B \\proper A) && (C \\proper A).\nProof.\nmove=> pUA; apply/andP.\nby split; apply: sub_proper_trans pUA; rewrite (subsetUr, subsetUl).\nQed.",
    "Lemma properD A B C : (A \\proper B :\\: C) -> (A \\proper B) && [disjoint A & C].\nProof. by rewrite setDE disjoints_subset => /properI/andP[-> /proper_sub]. Qed.",
    "Lemma properCr A B : (A \\proper ~: B) = (B \\proper ~: A).\nProof. by rewrite -properC setCK. Qed.",
    "Lemma properCl A B : (~: A \\proper B) = (~: B \\proper A).\nProof. by rewrite -properC setCK. Qed.",
    "Lemma enum_setU A B : perm_eq (enum (A :|: B)) (undup (enum A ++ enum B)).\nProof.\napply: uniq_perm; rewrite ?enum_uniq ?undup_uniq//.\nby move=> i; rewrite mem_undup mem_enum inE mem_cat !mem_enum.\nQed.",
    "Lemma enum_setI A B : perm_eq (enum (A :&: B)) (filter [in B] (enum A)).\nProof.\napply: uniq_perm; rewrite ?enum_uniq// 1?filter_uniq// ?enum_uniq//.\nby move=> x; rewrite /= mem_enum mem_filter inE mem_enum andbC.\nQed.",
    "Lemma has_set1 pA A a : has pA (enum [set a]) = pA a.\nProof. by rewrite enum_set1 has_seq1. Qed.",
    "Lemma has_setU pA A B :\n  has pA (enum (A :|: B)) = (has pA (enum A)) || (has pA (enum B)).\nProof. by rewrite (perm_has _ (enum_setU _ _)) has_undup has_cat. Qed.",
    "Lemma all_set1 pA A a : all pA (enum [set a]) = pA a.\nProof. by rewrite enum_set1 all_seq1. Qed.",
    "Lemma all_setU pA A B :\n  all pA (enum (A :|: B)) = (all pA (enum A)) && (all pA (enum B)).\nProof. by rewrite (perm_all _ (enum_setU _ _)) all_undup all_cat. Qed.",
    "Lemma in_setX x1 x2 : ((x1, x2) \\in setX) = (x1 \\in A1) && (x2 \\in A2).\nProof. by rewrite inE. Qed.",
    "Lemma setXP x1 x2 : reflect (x1 \\in A1 /\\ x2 \\in A2) ((x1, x2) \\in setX).\nProof. by rewrite inE; apply: andP. Qed.",
    "Lemma cardsX : #|setX| = #|A1| * #|A2|.\nProof. by rewrite cardsE cardX. Qed.",
    "Lemma in_setXn x : (x \\in setXn) = [forall i, x i \\in A i].\nProof. by rewrite inE. Qed.",
    "Lemma setXnP x : reflect (forall i, x i \\in A i) (x \\in setXn).\nProof. by rewrite inE; apply: forallP. Qed.",
    "Lemma cardsXn : #|setXn| = \\prod_i #|A i|.\nProof. by rewrite cardsE card_family foldrE big_map big_enum. Qed.",
    "Lemma imsetP D y : reflect (exists2 x, in_mem x D & y = f x) (y \\in imset f D).\nProof. by rewrite [@imset]unlock inE; apply: imageP. Qed.",
    "Lemma imset2P D1 D2 y : reflect (imset2_spec D1 D2 y) (y \\in imset2 f2 D1 D2).\nProof.\nrewrite [@imset2]unlock inE.\napply: (iffP imageP) => [[[x1 x2] Dx12] | [x1 x2 Dx1 Dx2]] -> {y}.\n  by case/andP: Dx12; exists x1 x2.\nby exists (x1, x2); rewrite //= !inE Dx1.\nQed.",
    "Lemma imset_f (D : {pred aT}) x : x \\in D -> f x \\in f @: D.\nProof. by move=> Dx; apply/imsetP; exists x. Qed.",
    "Lemma mem_imset (D : {pred aT}) x : injective f -> f x \\in f @: D = (x \\in D).\nProof.\nby move=> f_inj; apply/imsetP/idP;[case=> [y] ? /f_inj -> | move=> ?; exists x].\nQed.",
    "Lemma imset0 : f @: set0 = set0.\nProof. by apply/setP => y /[!inE]; apply/imsetP => -[x /[!inE]]. Qed.",
    "Lemma imset_eq0 (A : {set aT}) : (f @: A == set0) = (A == set0).\nProof.\nhave [-> | [x Ax]] := set_0Vmem A; first by rewrite imset0 !eqxx.\nby rewrite -!cards_eq0 (cardsD1 x) Ax (cardsD1 (f x)) imset_f.\nQed.",
    "Lemma imset_set1 x : f @: [set x] = [set f x].\nProof.\napply/setP => y.\nby apply/imsetP/set1P=> [[x' /set1P-> //]| ->]; exists x; rewrite ?set11.\nQed.",
    "Lemma imset_inj : injective f -> injective (fun A : {set aT} => f @: A).\nProof.\nmove=> inj_f A B => /setP E; apply/setP => x.\nby rewrite -(mem_imset A x inj_f) E mem_imset.\nQed.",
    "Lemma imset_disjoint (A B : {pred aT}) :\n  injective f -> [disjoint f @: A & f @: B] = [disjoint A & B].\nProof.\nmove=> inj_f; apply/pred0Pn/pred0Pn => /= [[_ /andP[/imsetP[x xA ->]] xB]|].\n  by exists x; rewrite xA -(mem_imset B x inj_f).\nby move=> [x /andP[xA xB]]; exists (f x); rewrite !mem_imset ?xA.\nQed.",
    "Lemma imset2_f (D : {pred aT}) (D2 : aT -> {pred aT2}) x x2 :\n    x \\in D -> x2 \\in D2 x ->\n  f2 x x2 \\in [set f2 y y2 | y in D, y2 in D2 y].\nProof. by move=> Dx Dx2; apply/imset2P; exists x x2. Qed.",
    "Lemma mem_imset2 (D : {pred aT}) (D2 : aT -> {pred aT2}) x x2 :\n    injective2 f2 ->\n  (f2 x x2 \\in [set f2 y y2 | y in D, y2 in D2 y])\n    = (x \\in D) && (x2 \\in D2 x).\nProof.\nmove=> inj2_f; apply/imset2P/andP => [|[xD xD2]]; last by exists x x2.\nby move => [x' x2' xD xD2 eq_f2]; case: (inj2_f _ _ _ _ eq_f2) => -> ->.\nQed.",
    "Lemma sub_imset_pre (A : {pred aT}) (B : {pred rT}) :\n  (f @: A \\subset B) = (A \\subset f @^-1: B).\nProof.\napply/subsetP/subsetP=> [sfAB x Ax | sAf'B fx].\n  by rewrite inE sfAB ?imset_f.\nby move=> /imsetP[a + ->] => /sAf'B /[!inE].\nQed.",
    "Lemma preimsetS (A B : {pred rT}) :\n  A \\subset B -> (f @^-1: A) \\subset (f @^-1: B).\nProof. by move=> sAB; apply/subsetP=> y /[!inE]; apply: subsetP. Qed.",
    "Lemma preimset0 : f @^-1: set0 = set0.\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma preimsetT : f @^-1: setT = setT.\nProof. by apply/setP=> x; rewrite !inE. Qed.",
    "Lemma preimsetI (A B : {set rT}) :\n  f @^-1: (A :&: B) = (f @^-1: A) :&: (f @^-1: B).\nProof. by apply/setP=> y; rewrite !inE. Qed.",
    "Lemma preimsetU (A B : {set rT}) :\n  f @^-1: (A :|: B) = (f @^-1: A) :|: (f @^-1: B).\nProof. by apply/setP=> y; rewrite !inE. Qed.",
    "Lemma preimsetD (A B : {set rT}) :\n  f @^-1: (A :\\: B) = (f @^-1: A) :\\: (f @^-1: B).\nProof. by apply/setP=> y; rewrite !inE. Qed.",
    "Lemma preimsetC (A : {set rT}) : f @^-1: (~: A) = ~: f @^-1: A.\nProof. by apply/setP=> y; rewrite !inE. Qed.",
    "Lemma imsetS (A B : {pred aT}) : A \\subset B -> f @: A \\subset f @: B.\nProof.\nmove=> sAB; apply/subsetP => _ /imsetP[x Ax ->].\nby apply/imsetP; exists x; rewrite ?(subsetP sAB).\nQed.",
    "Lemma imset_proper (A B : {set aT}) :\n   {in B &, injective f} -> A \\proper B -> f @: A \\proper f @: B.\nProof.\nmove=> injf /properP[sAB [x Bx nAx]]; rewrite properE imsetS //=.\napply: contra nAx => sfBA.\nhave: f x \\in f @: A by rewrite (subsetP sfBA) ?imset_f.\nby case/imsetP=> y Ay /injf-> //; apply: subsetP sAB y Ay.\nQed.",
    "Lemma preimset_proper (A B : {set rT}) :\n  B \\subset codom f -> A \\proper B -> (f @^-1: A) \\proper (f @^-1: B).\nProof.\nmove=> sBc /properP[sAB [u Bu nAu]]; rewrite properE preimsetS //=.\nby apply/subsetPn; exists (iinv (subsetP sBc  _ Bu)); rewrite inE /= f_iinv.\nQed.",
    "Lemma imsetU (A B : {set aT}) : f @: (A :|: B) = (f @: A) :|: (f @: B).\nProof.\napply/eqP; rewrite eqEsubset subUset.\nrewrite 2?imsetS (andbT, subsetUl, subsetUr) // andbT.\napply/subsetP=> _ /imsetP[x ABx ->]; apply/setUP.\nby case/setUP: ABx => [Ax | Bx]; [left | right]; apply/imsetP; exists x.\nQed.",
    "Lemma imsetU1 a (A : {set aT}) : f @: (a |: A) = f a |: (f @: A).\nProof. by rewrite imsetU imset_set1. Qed.",
    "Lemma imsetI (A B : {set aT}) :\n  {in A & B, injective f} -> f @: (A :&: B) = f @: A :&: f @: B.\nProof.\nmove=> injf; apply/eqP; rewrite eqEsubset subsetI.\nrewrite 2?imsetS (andTb, subsetIl, subsetIr) //=.\napply/subsetP=> _ /setIP[/imsetP[x Ax ->] /imsetP[z Bz /injf eqxz]].\nby rewrite imset_f // inE Ax eqxz.\nQed.",
    "Lemma imset2Sl (A B : {pred aT}) (C : {pred aT2}) :\n  A \\subset B -> f2 @2: (A, C) \\subset f2 @2: (B, C).\nProof.\nmove=> sAB; apply/subsetP=> _ /imset2P[x y Ax Cy ->].\nby apply/imset2P; exists x y; rewrite ?(subsetP sAB).\nQed.",
    "Lemma imset2Sr (A B : {pred aT2}) (C : {pred aT}) :\n  A \\subset B -> f2 @2: (C, A) \\subset f2 @2: (C, B).\nProof.\nmove=> sAB; apply/subsetP=> _ /imset2P[x y Ax Cy ->].\nby apply/imset2P; exists x y; rewrite ?(subsetP sAB).\nQed.",
    "Lemma imset2S (A B : {pred aT}) (A2 B2 : {pred aT2}) :\n  A \\subset B ->  A2 \\subset B2 -> f2 @2: (A, A2) \\subset f2 @2: (B, B2).\nProof.  by move=> /(imset2Sl B2) sBA /(imset2Sr A)/subset_trans->. Qed.",
    "Lemma eq_preimset f g R : f =1 g -> f @^-1: R = g @^-1: R.\nProof. by move=> eqfg; apply/setP => y; rewrite !inE eqfg. Qed.",
    "Lemma eq_imset f g D : f =1 g -> f @: D = g @: D.\nProof.\nmove=> eqfg; apply/setP=> y.\nby apply/imsetP/imsetP=> [] [x Dx ->]; exists x; rewrite ?eqfg.\nQed.",
    "Lemma eq_in_imset f g D : {in D, f =1 g} -> f @: D = g @: D.\nProof.\nmove=> eqfg; apply/setP => y.\nby apply/imsetP/imsetP=> [] [x Dx ->]; exists x; rewrite ?eqfg.\nQed.",
    "Lemma eq_in_imset2 (f g : aT -> aT2 -> rT) (D : {pred aT}) (D2 : {pred aT2}) :\n  {in D & D2, f =2 g} -> f @2: (D, D2) = g @2: (D, D2).\nProof.\nmove=> eqfg; apply/setP => y.\nby apply/imset2P/imset2P=> [] [x x2 Dx Dx2 ->]; exists x x2; rewrite ?eqfg.\nQed.",
    "Lemma imset2_pair (A : {set aT}) (B : {set aT2}) :\n  [set (x, y) | x in A, y in B] = setX A B.\nProof.\napply/setP=> [[x y]]; rewrite !inE /=.\nby apply/imset2P/andP=> [[_ _ _ _ [-> ->]//]| []]; exists x y.\nQed.",
    "Lemma setXS (A1 B1 : {set aT}) (A2 B2 : {set aT2}) :\n  A1 \\subset B1 -> A2 \\subset B2 -> setX A1 A2 \\subset setX B1 B2.\nProof. by move=> sAB1 sAB2; rewrite -!imset2_pair imset2S. Qed.",
    "Lemma setXnS (I : finType) (T : I -> finType) (A B : forall i, {set T i}) :\n  (forall i, A i \\subset B i) -> setXn A \\subset setXn B.\nProof.\nmove=> sAB; apply/subsetP => x /setXnP xA.\nby apply/setXnP => i; apply/subsetP: (xA i).\nQed.",
    "Lemma eq_setXn (I : finType) (T : I -> finType) (A B : forall i, {set T i}) :\n  (forall i, A i = B i) -> setXn A = setXn B.\nProof.\nby move=> eqAB; apply/eqP; rewrite eqEsubset !setXnS// => j; rewrite eqAB.\nQed.",
    "Lemma big_set0 F : \\big[op/x]_(i in set0) F i = x.\nProof. by apply: big_pred0 => i; rewrite inE. Qed.",
    "Lemma big_set1E j F : \\big[op/x]_(i in [set j]) F i = op (F j) x.\nProof. by rewrite -big_pred1_eq_id; apply: eq_bigl => i; apply: in_set1. Qed.",
    "Lemma big_set (A : pred I) F :\n  \\big[op/x]_(i in [set i | A i]) (F i) = \\big[op/x]_(i in A) (F i).\nProof. by apply: eq_bigl => i; rewrite inE. Qed.",
    "Lemma subset_le_big_cond (I : finType) (A A' P P' : {pred I}) (F : I -> R) :\n    [set i in A | P i]  \\subset [set i in A' | P' i] ->\n  le (\\big[op/x]_(i in A | P i) F i) (\\big[op/x]_(i in A' | P' i) F i).\nProof.\nby move=> /subsetP AP; apply: sub_le_big => // i; have /[!inE] := AP i.\nQed.",
    "Lemma big_imset_idem [I J : finType] (h : I -> J) (A : pred I) F :\n    idempotent_op op ->\n  \\big[op/x]_(j in h @: A) F j = \\big[op/x]_(i in A) F (h i).\nProof.\nrewrite -!big_image => op_idem; rewrite -big_undup// -[RHS]big_undup//.\napply/perm_big/perm_undup => j; apply/imageP.\nhave [mem_j | /imageP mem_j] := boolP (j \\in [seq h j | j in A]).\n- by exists j => //; apply/imsetP; apply: imageP mem_j.\n- by case=> k /imsetP [i j_in_A ->] eq_i; apply: mem_j; exists i.\nQed.",
    "Lemma big_set1 a F : \\big[op/idx]_(i in [set a]) F i = F a.\nProof. by apply: big_pred1 => i; rewrite !inE. Qed.",
    "Lemma big_setID A B F :\n  \\big[aop/idx]_(i in A) F i =\n     aop (\\big[aop/idx]_(i in A :&: B) F i)\n         (\\big[aop/idx]_(i in A :\\: B) F i).\nProof.\nrewrite (bigID [in B]) setDE.\nby congr (aop _ _); apply: eq_bigl => i; rewrite !inE.\nQed.",
    "Lemma big_setIDcond A B P F :\n  \\big[aop/idx]_(i in A | P i) F i =\n     aop (\\big[aop/idx]_(i in A :&: B | P i) F i)\n         (\\big[aop/idx]_(i in A :\\: B | P i) F i).\nProof. by rewrite !big_mkcondr; apply: big_setID. Qed.",
    "Lemma big_setD1 a A F : a \\in A ->\n  \\big[aop/idx]_(i in A) F i = aop (F a) (\\big[aop/idx]_(i in A :\\ a) F i).\nProof.\nmove=> Aa; rewrite (bigD1 a Aa); congr (aop _).\nby apply: eq_bigl => x; rewrite !inE andbC.\nQed.",
    "Lemma big_setU1 a A F : a \\notin A ->\n  \\big[aop/idx]_(i in a |: A) F i = aop (F a) (\\big[aop/idx]_(i in A) F i).\nProof. by move=> notAa; rewrite (@big_setD1 a) ?setU11 //= setU1K. Qed.",
    "Lemma big_subset_idem_cond A B P F :\n    idempotent_op aop ->\n    A \\subset B ->\n  aop (\\big[aop/idx]_(i in A | P i) F i) (\\big[aop/idx]_(i in B | P i) F i)\n    = \\big[aop/idx]_(i in B | P i) F i.\nProof.\nby move=> idaop /setIidPr <-; rewrite (big_setIDcond B A) Monoid.mulmA /= idaop.\nQed.",
    "Lemma big_subset_idem A B F :\n    idempotent_op aop ->\n    A \\subset B ->\n  aop (\\big[aop/idx]_(i in A) F i) (\\big[aop/idx]_(i in B) F i)\n    = \\big[aop/idx]_(i in B) F i.\nProof. by rewrite -2!big_condT; apply: big_subset_idem_cond. Qed.",
    "Lemma big_setU_cond A B P F :\n    idempotent_op aop ->\n  \\big[aop/idx]_(i in A :|: B | P i) F i\n    = aop (\\big[aop/idx]_(i in A | P i) F i) (\\big[aop/idx]_(i in B | P i) F i).\nProof.\nmove=> idemaop; rewrite (big_setIDcond _ A) setUK setDUl setDv set0U.\nrewrite (big_setIDcond B A) Monoid.mulmCA Monoid.mulmA /=.\nby rewrite (@big_subset_idem_cond (B :&: A)) // subsetIr.\nQed.",
    "Lemma big_setU A B F :\n    idempotent_op aop ->\n  \\big[aop/idx]_(i in A :|: B) F i\n    = aop (\\big[aop/idx]_(i in A) F i) (\\big[aop/idx]_(i in B) F i).\nProof. by rewrite -3!big_condT; apply: big_setU_cond. Qed.",
    "Lemma big_imset h (A : {pred I}) G : {in A &, injective h} ->\n  \\big[aop/idx]_(j in h @: A) G j = \\big[aop/idx]_(i in A) G (h i).\nProof.\nmove=> injh; pose hA := mem (image h A).\nrewrite (eq_bigl hA) => [|j]; last exact/imsetP/imageP.\npose h' := omap (fun u : {j | hA j} => iinv (svalP u)) \\o insub.\nrewrite (reindex_omap h h') => [|j hAj]; rewrite {}/h'/= ?insubT/= ?f_iinv//.\napply: eq_bigl => i; case: insubP => [u /= -> def_u | nhAhi]; last first.\n  by apply/andP/idP => [[]//| Ai]; case/imageP: nhAhi; exists i.\nset i' := iinv _; have Ai' : i' \\in A := mem_iinv (svalP u).\nby apply/eqP/idP => [[<-] // | Ai]; congr Some; apply: injh; rewrite ?f_iinv.\nQed.",
    "Lemma big_imset_cond h (A : {pred I}) (P : pred J) G : {in A &, injective h} ->\n  \\big[aop/idx]_(j in h @: A | P j) G j =\n    \\big[aop/idx]_(i in A | P (h i)) G (h i).\nProof. by move=> h_inj; rewrite 2!big_mkcondr big_imset. Qed.",
    "Lemma partition_big_imset h (A : {pred I}) F :\n  \\big[aop/idx]_(i in A) F i =\n     \\big[aop/idx]_(j in h @: A) \\big[aop/idx]_(i in A | h i == j) F i.\nProof. by apply: partition_big => i Ai; apply/imsetP; exists i. Qed.",
    "Lemma bigA_distr (R : Type) (zero one : R) (mul : Monoid.mul_law zero)\n  (add : Monoid.add_law zero mul) (I : finType) (F G : I -> R) :\n  \\big[mul/one]_i add (F i) (G i) =\n  \\big[add/zero]_(J in {set I}) \\big[mul/one]_i (if i \\in J then F i else G i).\nProof.\nunder eq_bigr => i _ do rewrite -(big_bool _ (fun b => if b then F i else G i)).\nrewrite bigA_distr_bigA.\nset f := fun J : {set I} => val J.\ntransitivity (\\big[add/zero]_(f0 in (imset f (mem setT)))\n                \\big[mul/one]_i (if f0 i then F i else G i)).\n  suff <-: setT = imset f (mem setT) by apply: congr_big=>// i; rewrite in_setT.\n  apply/esym/eqP; rewrite -subTset; apply/subsetP => b _.\n  by apply/imsetP; exists (FinSet b).\nrewrite big_imset; last by case=> g; case=> h _ _; rewrite /f => /= ->.\napply: congr_big => //; case=> g; first exact: in_setT.\nby move=> _; apply: eq_bigr => i _; congr (if _ then _ else _); rewrite unlock.\nQed.",
    "Lemma imset2_set1l x1 (D2 : {pred aT2}) : f @2: ([set x1], D2) = f x1 @: D2.\nProof.\napply/setP=> y; apply/imset2P/imsetP=> [[x x2 /set1P->]| [x2 Dx2 ->]].\n  by exists x2.\nby exists x1 x2; rewrite ?set11.\nQed.",
    "Lemma imset2_set1r x2 (D1 : {pred aT1}) : f @2: (D1, [set x2]) = f^~ x2 @: D1.\nProof.\napply/setP=> y; apply/imset2P/imsetP=> [[x1 x Dx1 /set1P->]| [x1 Dx1 ->]].\n  by exists x1.\nby exists x1 x2; rewrite ?set11.\nQed.",
    "Lemma imset_card : #|f @: D| = #|image f D|.\nProof. by rewrite [@imset]unlock cardsE. Qed.",
    "Lemma leq_imset_card : #|f @: D| <= #|D|.\nProof. by rewrite imset_card leq_image_card. Qed.",
    "Lemma card_in_imset : {in D &, injective f} -> #|f @: D| = #|D|.\nProof. by move=> injf; rewrite imset_card card_in_image. Qed.",
    "Lemma card_imset : injective f -> #|f @: D| = #|D|.\nProof. by move=> injf; rewrite imset_card card_image. Qed.",
    "Lemma imset_injP : reflect {in D &, injective f} (#|f @: D| == #|D|).\nProof. by rewrite [@imset]unlock cardsE; apply: image_injP. Qed.",
    "Lemma can2_in_imset_pre :\n  {in D, cancel f g} -> {on D, cancel g & f} -> f @: D = g @^-1: D.\nProof.\nmove=> fK gK; apply/setP=> y; rewrite inE.\nby apply/imsetP/idP=> [[x Ax ->] | Agy]; last exists (g y); rewrite ?(fK, gK).\nQed.",
    "Lemma can2_imset_pre : cancel f g -> cancel g f -> f @: D = g @^-1: D.\nProof. by move=> fK gK; apply: can2_in_imset_pre; apply: in1W. Qed.",
    "Lemma on_card_preimset (aT rT : finType) (f : aT -> rT) (R : {pred rT}) :\n  {on R, bijective f} -> #|f @^-1: R| = #|R|.\nProof.\ncase=> g fK gK; rewrite -(can2_in_imset_pre gK) // card_in_imset //.\nexact: can_in_inj gK.\nQed.",
    "Lemma can_imset_pre (T : finType) f g (A : {set T}) :\n  cancel f g -> f @: A = g @^-1: A :> {set T}.\nProof.\nmove=> fK; apply: can2_imset_pre => // x.\nsuffices fx: x \\in codom f by rewrite -(f_iinv fx) fK.\nexact/(subset_cardP (card_codom (can_inj fK)))/subsetP.\nQed.",
    "Lemma imset_id (T : finType) (A : {set T}) : [set x | x in A] = A.\nProof. by apply/setP=> x; rewrite (@can_imset_pre _ _ id) ?inE. Qed.",
    "Lemma card_preimset (T : finType) (f : T -> T) (A : {set T}) :\n  injective f -> #|f @^-1: A| = #|A|.\nProof.\nmove=> injf; apply: on_card_preimset; apply: onW_bij.\nhave ontof: _ \\in codom f by apply/(subset_cardP (card_codom injf))/subsetP.\nby exists (fun x => iinv (ontof x)) => x; rewrite (f_iinv, iinv_f).\nQed.",
    "Lemma card_powerset (T : finType) (A : {set T}) : #|powerset A| = 2 ^ #|A|.\nProof.\nrewrite -card_bool -(card_pffun_on false) -(card_imset _ val_inj).\napply: eq_card => f; pose sf := false.-support f; pose D := finset sf.\nhave sDA: (D \\subset A) = (sf \\subset A) by apply: eq_subset; apply: in_set.\nhave eq_sf x : sf x = f x by rewrite /= negb_eqb addbF.\nhave valD: val D = f by rewrite /D unlock; apply/ffunP=> x; rewrite ffunE eq_sf.\napply/imsetP/pffun_onP=> [[B] | [sBA _]]; last by exists D; rewrite // inE ?sDA.\nby rewrite inE -sDA -valD => sBA /val_inj->.\nQed.",
    "Lemma imset_comp (f : T' -> U) (g : T -> T') (H : {pred T}) :\n  (f \\o g) @: H = f @: (g @: H).\nProof.\napply/setP/subset_eqP/andP.\nsplit; apply/subsetP=> _ /imsetP[x0 Hx0 ->]; apply/imsetP.\n  by exists (g x0); first apply: imset_f.\nby move/imsetP: Hx0 => [x1 Hx1 ->]; exists x1.\nQed.",
    "Lemma bigcup_sup j P F : P j -> F j \\subset \\bigcup_(i | P i) F i.\nProof. by move=> Pj; rewrite (bigD1 j) //= subsetUl. Qed.",
    "Lemma bigcup_max j U P F :\n  P j -> U \\subset F j -> U \\subset \\bigcup_(i | P i) F i.\nProof. by move=> Pj sUF; apply: subset_trans (bigcup_sup _ Pj). Qed.",
    "Lemma bigcupP x P F :\n  reflect (exists2 i, P i & x \\in F i) (x \\in \\bigcup_(i | P i) F i).\nProof.\napply: (iffP idP) => [|[i Pi]]; last first.\n  by apply: subsetP x; apply: bigcup_sup.\nby elim/big_rec: _ => [|i _ Pi _ /setUP[|//]]; [rewrite inE | exists i].\nQed.",
    "Lemma bigcupsP U P F :\n  reflect (forall i, P i -> F i \\subset U) (\\bigcup_(i | P i) F i \\subset U).\nProof.\napply: (iffP idP) => [sFU i Pi| sFU].\n  by apply: subset_trans sFU; apply: bigcup_sup.\nby apply/subsetP=> x /bigcupP[i Pi]; apply: (subsetP (sFU i Pi)).\nQed.",
    "Lemma bigcup0P P F :\n  reflect (forall i, P i -> F i = set0) (\\bigcup_(i | P i) F i == set0).\nProof.\nrewrite -subset0; apply: (iffP (bigcupsP _ _ _)) => sub0 i /sub0; last by move->.\nby rewrite subset0 => /eqP.\nQed.",
    "Lemma bigcup_disjointP U P F  :\n  reflect (forall i : I, P i -> [disjoint U & F i])\n          [disjoint U & \\bigcup_(i | P i) F i].\nProof.\napply: (iffP idP) => [dUF i Pp|dUF].\n  by apply: disjointWr dUF; apply: bigcup_sup.\nrewrite disjoint_sym disjoint_subset.\nby apply/bigcupsP=> i /dUF; rewrite disjoint_sym disjoint_subset.\nQed.",
    "Lemma bigcup_disjoint U P F :\n  (forall i, P i -> [disjoint U & F i]) -> [disjoint U & \\bigcup_(i | P i) F i].\nProof. by move/bigcup_disjointP. Qed.",
    "Lemma bigcup_setU A B F :\n  \\bigcup_(i in A :|: B) F i =\n     (\\bigcup_(i in A) F i) :|: (\\bigcup_ (i in B) F i).\nProof.\napply/setP=> x; apply/bigcupP/setUP=> [[i] | ].\n  by case/setUP; [left | right]; apply/bigcupP; exists i.\nby case=> /bigcupP[i Pi]; exists i; rewrite // inE Pi ?orbT.\nQed.",
    "Lemma bigcup_seq r F : \\bigcup_(i <- r) F i = \\bigcup_(i in r) F i.\nProof.\nelim: r => [|i r IHr]; first by rewrite big_nil big_pred0.\nrewrite big_cons {}IHr; case r_i: (i \\in r).\n  rewrite (setUidPr _) ?bigcup_sup //.\n  by apply: eq_bigl => j /[!inE]; case: eqP => // ->.\nrewrite (bigD1 i (mem_head i r)) /=; congr (_ :|: _).\nby apply: eq_bigl => j /=; rewrite andbC; case: eqP => // ->.\nQed.",
    "Lemma bigcap_inf j P F : P j -> \\bigcap_(i | P i) F i \\subset F j.\nProof. by move=> Pj; rewrite (bigD1 j) //= subsetIl. Qed.",
    "Lemma bigcap_min j U P F :\n  P j -> F j \\subset U -> \\bigcap_(i | P i) F i \\subset U.\nProof. by move=> Pj; apply: subset_trans (bigcap_inf _ Pj). Qed.",
    "Lemma bigcapsP U P F :\n  reflect (forall i, P i -> U \\subset F i) (U \\subset \\bigcap_(i | P i) F i).\nProof.\napply: (iffP idP) => [sUF i Pi | sUF].\n  by apply: subset_trans sUF _; apply: bigcap_inf.\nelim/big_rec: _ => [|i V Pi sUV]; apply/subsetP=> x Ux; rewrite inE //.\nby rewrite !(subsetP _ x Ux) ?sUF.\nQed.",
    "Lemma bigcapP x P F :\n  reflect (forall i, P i -> x \\in F i) (x \\in \\bigcap_(i | P i) F i).\nProof.\nrewrite -sub1set.\nby apply: (iffP (bigcapsP _ _ _)) => Fx i /Fx; rewrite sub1set.\nQed.",
    "Lemma setC_bigcup J r (P : pred J) (F : J -> {set T}) :\n  ~: (\\bigcup_(j <- r | P j) F j) = \\bigcap_(j <- r | P j) ~: F j.\nProof. by apply: big_morph => [A B|]; rewrite ?setC0 ?setCU. Qed.",
    "Lemma setC_bigcap J r (P : pred J) (F : J -> {set T}) :\n  ~: (\\bigcap_(j <- r | P j) F j) = \\bigcup_(j <- r | P j) ~: F j.\nProof. by apply: big_morph => [A B|]; rewrite ?setCT ?setCI. Qed.",
    "Lemma bigcap_setU A B F :\n  (\\bigcap_(i in A :|: B) F i) =\n    (\\bigcap_(i in A) F i) :&: (\\bigcap_(i in B) F i).\nProof. by apply: setC_inj; rewrite setCI !setC_bigcap bigcup_setU. Qed.",
    "Lemma bigcap_seq r F : \\bigcap_(i <- r) F i = \\bigcap_(i in r) F i.\nProof. by apply: setC_inj; rewrite !setC_bigcap bigcup_seq. Qed.",
    "Lemma curry_imset2X : f @2: (A1, A2) = uncurry f @: (setX A1 A2).\nProof.\nrewrite [@imset]unlock unlock; apply/setP=> x; rewrite !in_set; congr (x \\in _).\nby apply: eq_image => u //=; rewrite !inE.\nQed.",
    "Lemma curry_imset2l : f @2: (D1, D2) = \\bigcup_(x1 in D1) f x1 @: D2.\nProof.\napply/setP=> y; apply/imset2P/bigcupP => [[x1 x2 Dx1 Dx2 ->{y}] | [x1 Dx1]].\n  by exists x1; rewrite // imset_f.\nby case/imsetP=> x2 Dx2 ->{y}; exists x1 x2.\nQed.",
    "Lemma curry_imset2r : f @2: (D1, D2) = \\bigcup_(x2 in D2) f^~ x2 @: D1.\nProof.\napply/setP=> y; apply/imset2P/bigcupP => [[x1 x2 Dx1 Dx2 ->{y}] | [x2 Dx2]].\n  by exists x2; rewrite // (imset_f (f^~ x2)).\nby case/imsetP=> x1 Dx1 ->{y}; exists x1 x2.\nQed.",
    "Lemma imset2Ul (A B : {set aT1}) (C : {set aT2}) :\n  f @2: (A :|: B, C) = f @2: (A, C) :|: f @2: (B, C).\nProof. by rewrite !curry_imset2l bigcup_setU. Qed.",
    "Lemma imset2Ur (A : {set aT1}) (B C : {set aT2}) :\n  f @2: (A, B :|: C) = f @2: (A, B) :|: f @2: (A, C).\nProof. by rewrite !curry_imset2r bigcup_setU. Qed.",
    "Lemma leq_card_setU A B : #|A :|: B| <= #|A| + #|B| ?= iff [disjoint A & B].\nProof.\nrewrite -(addn0 #|_|) -setI_eq0 -cards_eq0 -cardsUI eq_sym.\nby rewrite (mono_leqif (leq_add2l _)).\nQed.",
    "Lemma leq_card_cover P : #|cover P| <= \\sum_(A in P) #|A| ?= iff trivIset P.\nProof.\nsplit; last exact: eq_sym.\nrewrite /cover; elim/big_rec2: _ => [|A n U _ leUn]; first by rewrite cards0.\nby rewrite (leq_trans (leq_card_setU A U).1) ?leq_add2l.\nQed.",
    "Lemma imset_cover (T' : finType) P  (f : T -> T') :\n  [set f x | x in cover P] = \\bigcup_(i in P) [set f x | x in i].\nProof.\napply/setP=> y; apply/imsetP/bigcupP => [|[A AP /imsetP[x xA ->]]].\n  by move=> [x /bigcupP[A AP xA] ->]; exists A => //; rewrite imset_f.\nby exists x => //; apply/bigcupP; exists A.\nQed.",
    "Lemma cover1 A : cover [set A] = A.\nProof. by rewrite /cover big_set1. Qed.",
    "Lemma trivIset1 A : trivIset [set A].\nProof. by rewrite /trivIset cover1 big_set1. Qed.",
    "Lemma trivIsetP P :\n  reflect {in P &, forall A B, A != B -> [disjoint A & B]} (trivIset P).\nProof.\nrewrite -[P]set_enum; elim: {P}(enum _) (enum_uniq P) => [_ | A e IHe] /=.\n  by rewrite /trivIset /cover !big_set0 cards0; left=> A; rewrite inE.\ncase/andP; rewrite set_cons -(in_set (fun B => B \\in e)) => PA {}/IHe.\nmove: {e}[set x in e] PA => P PA IHP.\nrewrite /trivIset /cover !big_setU1 //= eq_sym.\nhave:= leq_card_cover P; rewrite -(mono_leqif (leq_add2l #|A|)).\nmove/(leqif_trans (leq_card_setU _ _))->; rewrite disjoints_subset setC_bigcup.\ncase: bigcapsP => [disjA | meetA]; last first.\n  right=> [tI]; case: meetA => B PB; rewrite -disjoints_subset.\n  by rewrite tI ?setU11 ?setU1r //; apply: contraNneq PA => ->.\napply: (iffP IHP) => [] tI B C PB PC; last by apply: tI; apply: setU1r.\nby case/setU1P: PC PB => [->|PC] /setU1P[->|PB]; try by [apply: tI | case/eqP];\n  first rewrite disjoint_sym; rewrite disjoints_subset disjA.\nQed.",
    "Lemma trivIsetS P Q : P \\subset Q -> trivIset Q -> trivIset P.\nProof. by move/subsetP/sub_in2=> sPQ /trivIsetP/sPQ/trivIsetP. Qed.",
    "Lemma trivIsetD P Q : trivIset P -> trivIset (P :\\: Q).\nProof.\nmove/trivIsetP => tP; apply/trivIsetP => A B /setDP[TA _] /setDP[TB _]; exact: tP.\nQed.",
    "Lemma trivIsetU P Q :\n  trivIset Q -> trivIset P -> [disjoint cover Q & cover P] -> trivIset (Q :|: P).\nProof.\nmove => /trivIsetP tQ /trivIsetP tP dQP; apply/trivIsetP => A B.\nmove => /setUP[?|?] /setUP[?|?]; first [exact:tQ|exact:tP|move => _].\n  by apply: disjointW dQP; rewrite bigcup_sup.\nby rewrite disjoint_sym; apply: disjointW dQP; rewrite bigcup_sup.\nQed.",
    "Lemma coverD1 P B : trivIset P -> B \\in P -> cover (P :\\ B) = cover P :\\: B.\nProof.\nmove/trivIsetP => tP SP; apply/setP => x; rewrite inE.\napply/bigcupP/idP => [[A /setD1P [ADS AP] xA]|/andP[xNS /bigcupP[A AP xA]]].\n  by rewrite (disjointFr (tP _ _ _ _ ADS)) //=; apply/bigcupP; exists A.\nby exists A; rewrite // !inE AP andbT; apply: contraNneq xNS => <-.\nQed.",
    "Lemma trivIsetI P D : trivIset P -> trivIset (P ::&: D).\nProof. by apply: trivIsetS; rewrite -setI_powerset subsetIl. Qed.",
    "Lemma cover_setI P D : cover (P ::&: D) \\subset cover P :&: D.\nProof.\nby apply/bigcupsP=> A /setIdP[PA sAD]; rewrite subsetI sAD andbT (bigcup_max A).\nQed.",
    "Lemma mem_pblock P x : (x \\in pblock P x) = (x \\in cover P).\nProof.\nrewrite /pblock; apply/esym/bigcupP.\ncase: pickP => /= [A /andP[PA Ax]| noA]; first by rewrite Ax; exists A.\nby rewrite inE => [[A PA Ax]]; case/andP: (noA A).\nQed.",
    "Lemma pblock_mem P x : x \\in cover P -> pblock P x \\in P.\nProof.\nby rewrite -mem_pblock /pblock; case: pickP => [A /andP[]| _] //=; rewrite inE.\nQed.",
    "Lemma def_pblock P B x : trivIset P -> B \\in P -> x \\in B -> pblock P x = B.\nProof.\nmove/trivIsetP=> tiP PB Bx; have Px: x \\in cover P by apply/bigcupP; exists B.\napply: (contraNeq (tiP _ _ _ PB)); first by rewrite pblock_mem.\nby apply/pred0Pn; exists x; rewrite /= mem_pblock Px.\nQed.",
    "Lemma same_pblock P x y :\n  trivIset P -> x \\in pblock P y -> pblock P x = pblock P y.\nProof.\nrewrite {1 3}/pblock => tI; case: pickP => [A|]; last by rewrite inE.\nby case/andP=> PA _{y} /= Ax; apply: def_pblock.\nQed.",
    "Lemma eq_pblock P x y :\n    trivIset P -> x \\in cover P ->\n  (pblock P x == pblock P y) = (y \\in pblock P x).\nProof.\nmove=> tiP Px; apply/eqP/idP=> [eq_xy | /same_pblock-> //].\nmove: Px; rewrite -mem_pblock eq_xy /pblock.\nby case: pickP => [B /andP[] // | _] /[1!inE].\nQed.",
    "Lemma trivIsetU1 A P :\n    {in P, forall B, [disjoint A & B]} -> trivIset P -> set0 \\notin P ->\n  trivIset (A |: P) /\\ A \\notin P.\nProof.\nmove=> tiAP tiP notPset0; split; last first.\n  apply: contra notPset0 => P_A.\n  by have:= tiAP A P_A; rewrite -setI_eq0 setIid => /eqP <-.\napply/trivIsetP=> B1 B2 /setU1P[->|PB1] /setU1P[->|PB2];\n  by [apply: (trivIsetP _ tiP) | rewrite ?eqxx // ?(tiAP, disjoint_sym)].\nQed.",
    "Lemma cover_imset J F : cover (F @: J) = \\bigcup_(i in J) F i.\nProof.\napply/setP=> x.\napply/bigcupP/bigcupP=> [[_ /imsetP[i Ji ->]] | [i]]; first by exists i.\nby exists (F i); first apply: imset_f.\nQed.",
    "Lemma trivIimset J F (P := F @: J) :\n    {in J &, forall i j, j != i -> [disjoint F i & F j]} -> set0 \\notin P ->\n  trivIset P /\\ {in J &, injective F}.\nProof.\nmove=> tiF notPset0; split=> [|i j Ji Jj /= eqFij].\n  apply/trivIsetP=> _ _ /imsetP[i Ji ->] /imsetP[j Jj ->] neqFij.\n  by rewrite tiF // (contraNneq _ neqFij) // => ->.\napply: contraNeq notPset0 => neq_ij; apply/imsetP; exists i => //; apply/eqP.\nby rewrite eq_sym -[F i]setIid setI_eq0 {1}eqFij tiF.\nQed.",
    "Lemma cover_partition P D : partition P D -> cover P = D.\nProof. by case/and3P=> /eqP. Qed.",
    "Lemma partition0 P D : partition P D -> set0 \\in P = false.\nProof. case/and3P => _ _. by apply: contraNF. Qed.",
    "Lemma partition_neq0 P D B : partition P D -> B \\in P -> B != set0.\nProof. by move=> partP; apply: contraTneq => ->; rewrite (partition0 partP). Qed.",
    "Lemma partition_trivIset P D : partition P D -> trivIset P.\nProof. by case/and3P. Qed.",
    "Lemma partitionS P D B : partition P D -> B \\in P -> B \\subset D.\nProof.\nby move=> partP BP; rewrite -(cover_partition partP); apply: bigcup_max BP _.\nQed.",
    "Lemma partitionD1 P D B :\n  partition P D -> B \\in P -> partition (P :\\ B) (D :\\: B).\nProof.\ncase/and3P => /eqP covP trivP set0P SP.\nby rewrite /partition inE (negbTE set0P) trivIsetD ?coverD1 -?covP ?eqxx ?andbF.\nQed.",
    "Lemma partitionU1 P D B :\n  partition P D -> B != set0 -> [disjoint B & D] -> partition (B |: P) (B :|: D).\nProof.\ncase/and3P => /eqP covP trivP set0P BD0 disSD.\nrewrite /partition !inE (negbTE set0P) orbF [_ == B]eq_sym BD0 andbT.\nrewrite /cover bigcup_setU /= big_set1 -covP eqxx /=.\nby move: disSD; rewrite -covP=> /bigcup_disjointP/trivIsetU1 => -[].\nQed.",
    "Lemma partition_set0 P : partition P set0 = (P == set0).\nProof.\napply/and3P/eqP => [[/bigcup0P covP _ ]|->]; last first.\n  by rewrite /partition inE /trivIset/cover !big_set0 cards0 !eqxx.\nby apply: contraNeq => /set0Pn[B BP]; rewrite -(covP B BP).\nQed.",
    "Lemma card_partition P D : partition P D -> #|D| = \\sum_(A in P) #|A|.\nProof. by case/and3P=> /eqP <- /eqnP. Qed.",
    "Lemma card_uniform_partition n P D :\n  {in P, forall A, #|A| = n} -> partition P D -> #|D| = #|P| * n.\nProof.\nby move=> uniP /card_partition->; rewrite -sum_nat_const; apply: eq_bigr.\nQed.",
    "Lemma partition_pigeonhole P D A :\n  partition P D -> #|P| <= #|A| -> A \\subset D -> {in P, forall B, #|A :&: B| <= 1} ->\n  {in P, forall B, A :&: B != set0}.\nProof.\nmove=> partP card_A_P /subsetP subAD sub1; apply/forall_inP.\napply: contraTT card_A_P => /forall_inPn [B BP]; rewrite negbK => AB0.\nrewrite -!ltnNge -(setD1K BP) cardsU1 !inE eqxx /= add1n ltnS.\nhave [tP covP] := (partition_trivIset partP,cover_partition partP).\nhave APx x : x \\in A -> x \\in pblock P x by rewrite mem_pblock covP; apply: subAD.\nhave inj_f : {in A &, injective (pblock P)}.\n  move=> x y xA yA /eqP; rewrite eq_pblock ?covP ?subAD // => Pxy.\n  apply: (@card_le1_eqP _ (A :&: pblock P x)); rewrite ?inE ?Pxy ?APx ?andbT //.\n  by apply: sub1; rewrite pblock_mem ?covP ?subAD.\nrewrite -(card_in_imset inj_f); apply: subset_leq_card.\napply/subsetP => ? /imsetP[x xA ->].\nrewrite !inE pblock_mem ?covP ?subAD ?andbT //.\nby apply: contraTneq AB0 => <-; apply/set0Pn; exists x; rewrite inE APx ?andbT.\nQed.",
    "Lemma big_trivIset_cond P (K : pred T) (E : T -> R) :\n  trivIset P -> \\big[op/idx]_(x in cover P | K x) E x = rhs_cond P K E.\nProof.\nmove=> tiP; rewrite (partition_big (pblock P) [in P]) -/op => /= [|x].\n  apply: eq_bigr => A PA; apply: eq_bigl => x; rewrite andbAC; congr (_ && _).\n  rewrite -mem_pblock; apply/andP/idP=> [[Px /eqP <- //] | Ax].\n  by rewrite (def_pblock tiP PA Ax).\nby case/andP=> Px _; apply: pblock_mem.\nQed.",
    "Lemma big_trivIset P (E : T -> R) :\n  trivIset P -> \\big[op/idx]_(x in cover P) E x = rhs P E.\nProof.\nhave biginT := eq_bigl _ _ (fun _ => andbT _) => tiP.\nby rewrite -biginT big_trivIset_cond //; apply: eq_bigr => A _; apply: biginT.\nQed.",
    "Lemma set_partition_big_cond P D (K : pred T) (E : T -> R) :\n  partition P D -> \\big[op/idx]_(x in D | K x) E x = rhs_cond P K E.\nProof. by case/and3P=> /eqP <- tI_P _; apply: big_trivIset_cond. Qed.",
    "Lemma set_partition_big P D (E : T -> R) :\n  partition P D -> \\big[op/idx]_(x in D) E x = rhs P E.\nProof. by case/and3P=> /eqP <- tI_P _; apply: big_trivIset. Qed.",
    "Lemma partition_disjoint_bigcup (F : I -> {set T}) E :\n    (forall i j, i != j -> [disjoint F i & F j]) ->\n  \\big[op/idx]_(x in \\bigcup_i F i) E x =\n    \\big[op/idx]_i \\big[op/idx]_(x in F i) E x.\nProof.\nmove=> disjF; pose P := [set F i | i in I & F i != set0].\nhave trivP: trivIset P.\n  apply/trivIsetP=> _ _ /imsetP[i _ ->] /imsetP[j _ ->] neqFij.\n  by apply: disjF; apply: contraNneq neqFij => ->.\nhave ->: \\bigcup_i F i = cover P.\n  apply/esym; rewrite cover_imset big_mkcond; apply: eq_bigr => i _.\n  by rewrite inE; case: eqP.\nrewrite big_trivIset // /rhs big_imset => [|i j _ /setIdP[_ notFj0] eqFij].\n  rewrite big_mkcond; apply: eq_bigr => i _; rewrite inE.\n  by case: eqP => //= ->; rewrite big_set0.\nby apply: contraNeq (disjF _ _) _; rewrite -setI_eq0 eqFij setIid.\nQed.",
    "Lemma equivalence_partitionP : partition P D.\nProof.\nhave defD: cover P == D.\n  rewrite eqEsubset; apply/andP; split.\n    by apply/bigcupsP=> _ /imsetP[x Dx ->]; rewrite /Px setIdE subsetIl.\n  by apply/subsetP=> x Dx; apply/bigcupP; exists (Px x); rewrite (Pxx, PPx).\nhave tiP: trivIset P.\n  apply/trivIsetP=> _ _ /imsetP[x Dx ->] /imsetP[y Dy ->]; apply: contraR.\n  case/pred0Pn=> z /andP[] /[!inE] /andP[Dz Rxz] /andP[_ Ryz].\n  apply/eqP/setP=> t /[!inE]; apply: andb_id2l => Dt.\n  by rewrite (eqiR Dx Dz Dt) // (eqiR Dy Dz Dt).\nrewrite /partition tiP defD /=.\nby apply/imsetP=> [[x /Pxx Px_x Px0]]; rewrite -Px0 inE in Px_x.\nQed.",
    "Lemma pblock_equivalence_partition :\n  {in D &, forall x y, (y \\in pblock P x) = R x y}.\nProof.\nhave [_ tiP _] := and3P equivalence_partitionP.\nby move=> x y Dx Dy; rewrite /= (def_pblock tiP (PPx Dx) (Pxx Dx)) inE Dy.\nQed.",
    "Lemma pblock_equivalence P D :\n  partition P D -> {in D & &, equivalence_rel (fun x y => y \\in pblock P x)}.\nProof.\ncase/and3P=> /eqP <- tiP _ x y z Px Py Pz.\nby rewrite mem_pblock; split=> // /same_pblock->.\nQed.",
    "Lemma equivalence_partition_pblock P D :\n  partition P D -> equivalence_partition (fun x y => y \\in pblock P x) D = P.\nProof.\ncase/and3P=> /eqP <-{D} tiP notP0; apply/setP=> B /=; set D := cover P.\nhave defP x: x \\in D -> [set y in D | y \\in pblock P x] = pblock P x.\n  by move=> Dx; apply/setIidPr; rewrite (bigcup_max (pblock P x)) ?pblock_mem.\napply/imsetP/idP=> [[x Px ->{B}] | PB]; first by rewrite defP ?pblock_mem.\nhave /set0Pn[x Bx]: B != set0 := memPn notP0 B PB.\nhave Px: x \\in cover P by apply/bigcupP; exists B.\nby exists x; rewrite // defP // (def_pblock tiP PB Bx).\nQed.",
    "Lemma preim_partitionP D : partition (preim_partition D) D.\nProof. by apply/equivalence_partitionP; split=> // /eqP->. Qed.",
    "Lemma preim_partition_pblock P D :\n  partition P D -> preim_partition (pblock P) D = P.\nProof.\nmove=> partP; have [/eqP defD tiP _] := and3P partP.\nrewrite -{2}(equivalence_partition_pblock partP); apply: eq_in_imset => x Dx.\nby apply/setP=> y; rewrite !inE eq_pblock ?defD.\nQed.",
    "Lemma transversalP P D : partition P D -> is_transversal (transversal P D) P D.\nProof.\ncase/and3P=> /eqP <- tiP notP0; apply/and3P; split; first exact/and3P.\n  apply/subsetP=> _ /imsetP[x Px ->]; case: pickP => //= y Pxy.\n  by apply/bigcupP; exists (pblock P x); rewrite ?pblock_mem //.\napply/forall_inP=> B PB; have /set0Pn[x Bx]: B != set0 := memPn notP0 B PB.\napply/cards1P; exists (odflt x [pick y in pblock P x]); apply/esym/eqP.\nrewrite eqEsubset sub1set !inE -andbA; apply/andP; split.\n  by apply/imset_f/bigcupP; exists B.\nrewrite (def_pblock tiP PB Bx); case def_y: _ / pickP => [y By | /(_ x)/idP//].\nrewrite By /=; apply/subsetP=> _ /setIP[/imsetP[z Pz ->]].\ncase: {1}_ / pickP => [t zPt Bt | /(_ z)/idP[]]; last by rewrite mem_pblock.\nby rewrite -(same_pblock tiP zPt) (def_pblock tiP PB Bt) def_y inE.\nQed.",
    "Lemma transversal_sub : X \\subset D. Proof. by case/and3P: trPX. Qed.",
    "Lemma setI_transversal_pblock x0 B :\n  B \\in P -> X :&: B = [set transversal_repr x0 X B].\nProof.\nby case/trX/cards1P=> x defXB; rewrite /transversal_repr defXB /pick enum_set1.\nQed.",
    "Lemma repr_mem_pblock x0 B : B \\in P -> transversal_repr x0 X B \\in B.\nProof. by move=> PB; rewrite -sub1set -setI_transversal_pblock ?subsetIr. Qed.",
    "Lemma repr_mem_transversal x0 B : B \\in P -> transversal_repr x0 X B \\in X.\nProof. by move=> PB; rewrite -sub1set -setI_transversal_pblock ?subsetIl. Qed.",
    "Lemma transversal_reprK x0 : {in P, cancel (transversal_repr x0 X) (pblock P)}.\nProof. by move=> B PB; rewrite /= (def_pblock tiP PB) ?repr_mem_pblock. Qed.",
    "Lemma pblockK x0 : {in X, cancel (pblock P) (transversal_repr x0 X)}.\nProof.\nmove=> x Xx; have /bigcupP[B PB Bx] := sXP Xx; rewrite (def_pblock tiP PB Bx).\nby apply/esym/set1P; rewrite -setI_transversal_pblock // inE Xx.\nQed.",
    "Lemma pblock_inj : {in X &, injective (pblock P)}.\nProof. by move=> x0; apply: (can_in_inj (pblockK x0)). Qed.",
    "Lemma pblock_transversal : pblock P @: X = P.\nProof.\napply/setP=> B; apply/imsetP/idP=> [[x Xx ->] | PB].\n  by rewrite pblock_mem ?sXP.\nhave /cards1P[x0 _] := trX PB; set x := transversal_repr x0 X B.\nby exists x; rewrite ?transversal_reprK ?repr_mem_transversal.\nQed.",
    "Lemma card_transversal : #|X| = #|P|.\nProof. by rewrite -pblock_transversal card_in_imset //; apply: pblock_inj. Qed.",
    "Lemma im_transversal_repr x0 : transversal_repr x0 X @: P = X.\nProof.\nrewrite -{2}[X]imset_id -pblock_transversal -imset_comp.\nby apply: eq_in_imset; apply: pblockK.\nQed.",
    "Lemma partition_partition (T : finType) (D : {set T}) P Q :\n    partition P D -> partition Q P ->\n  partition (cover @: Q) D /\\ {in Q &, injective cover}.\nProof.\nmove=> /and3P[/eqP defG tiP notP0] /and3P[/eqP defP tiQ notQ0].\nhave sQP E: E \\in Q -> {subset E <= P}.\n  by move=> Q_E; apply/subsetP; rewrite -defP (bigcup_max E).\nrewrite /partition cover_imset -(big_trivIset _ tiQ) defP -defG eqxx /= andbC.\nhave{} notQ0: set0 \\notin cover @: Q.\n  apply: contra notP0 => /imsetP[E Q_E E0].\n  have /set0Pn[/= A E_A] := memPn notQ0 E Q_E.\n  congr (_ \\in P): (sQP E Q_E A E_A).\n  by apply/eqP; rewrite -subset0 E0 (bigcup_max A).\nrewrite notQ0; apply: trivIimset => // E F Q_E Q_F.\napply: contraR => /pred0Pn[x /andP[/bigcupP[A E_A Ax] /bigcupP[B F_B Bx]]].\nrewrite -(def_pblock tiQ Q_E E_A) -(def_pblock tiP _ Ax) ?(sQP E) //.\nby rewrite -(def_pblock tiQ Q_F F_B) -(def_pblock tiP _ Bx) ?(sQP F).\nQed.",
    "Lemma indexed_partition (I T : finType) (J : {pred I}) (B : I -> {set T}) :\n  let P := [set B i | i in J] in\n  {in J &, forall i j : I, j != i -> [disjoint B i & B j]} ->\n  (forall i : I, J i -> B i != set0) -> partition P (cover P) /\\ {in J &, injective B}.\nProof.\nmove=> P disjB inhB; have s0NP : set0 \\notin P.\n  by apply/negP => /imsetP[x xI /eqP]; apply/negP; rewrite eq_sym inhB.\nby rewrite /partition eqxx s0NP andbT /=; apply: trivIimset.\nQed.",
    "Lemma imset_trivIset : trivIset fP = trivIset P.\nProof.\napply/trivIsetP/trivIsetP => [trivP A B AP BP|].\n- rewrite -(imset_disjoint inj_f) -(inj_eq (imset_inj inj_f)).\n  by apply: trivP; rewrite imset_f.\n- move=> trivP ? ? /imsetP[A AP ->] /imsetP[B BP ->].\n  by rewrite (inj_eq (imset_inj inj_f)) imset_disjoint //; apply: trivP.\nQed.",
    "Lemma imset0mem : (set0 \\in fP) = (set0 \\in P).\nProof.\napply/imsetP/idP => [[A AP /esym/eqP]|P0]; last by exists set0; rewrite ?imset0.\nby rewrite imset_eq0 => /eqP<-.\nQed.",
    "Lemma imset_partition : partition fP (f @: D) = partition P D.\nProof.\nsuff cov: (cover fP == f @:D) = (cover P == D).\n  by rewrite /partition -imset_trivIset imset0mem cov.\nby rewrite /fP cover_imset -imset_cover (inj_eq (imset_inj inj_f)).\nQed.",
    "Lemma minset_eq P1 P2 A : P1 =1 P2 -> minset P1 A = minset P2 A.\nProof. by move=> eP12; apply: eq_forallb => B; rewrite eP12. Qed.",
    "Lemma minsetP P A :\n  reflect ((P A) /\\ (forall B, P B -> B \\subset A -> B = A)) (minset P A).\nProof.\napply: (iffP forallP) => [minA | [PA minA] B].\n  split; first by have:= minA A; rewrite subxx eqxx /= => /eqP.\n  by move=> B PB sBA; have:= minA B; rewrite PB sBA /= eqb_id => /eqP.\nby apply/implyP=> sBA; apply/eqP; apply/eqP/idP=> [-> // | /minA]; apply.\nQed.",
    "Lemma minsetp P A : minset P A -> P A.\nProof. by case/minsetP. Qed.",
    "Lemma minsetinf P A B : minset P A -> P B -> B \\subset A -> B = A.\nProof. by case/minsetP=> _; apply. Qed.",
    "Lemma ex_minset P : (exists A, P A) -> {A | minset P A}.\nProof.\nmove=> exP; pose pS n := [pred B | P B & #|B| == n].\npose p n := ~~ pred0b (pS n); have{exP}: exists n, p n.\n  by case: exP => A PA; exists #|A|; apply/existsP; exists A; rewrite /= PA /=.\ncase/ex_minnP=> n /pred0P; case: (pickP (pS n)) => // A /andP[PA] /eqP <-{n} _.\nmove=> minA; exists A => //; apply/minsetP; split=> // B PB sBA; apply/eqP.\nby rewrite eqEcard sBA minA //; apply/pred0Pn; exists B; rewrite /= PB /=.\nQed.",
    "Lemma minset_exists P C : P C -> {A | minset P A & A \\subset C}.\nProof.\nmove=> PC; have{PC}: exists A, P A && (A \\subset C) by exists C; rewrite PC /=.\ncase/ex_minset=> A /minsetP[/andP[PA sAC] minA]; exists A => //; apply/minsetP.\nby split=> // B PB sBA; rewrite (minA B) // PB (subset_trans sBA).\nQed.",
    "Lemma maxset_eq P1 P2 A : P1 =1 P2 -> maxset P1 A = maxset P2 A.\nProof. by move=> eP12; apply: minset_eq => x /=; rewrite !unlock_with eP12. Qed.",
    "Lemma maxminset P A : maxset P A = minset [pred B | P (~: B)] (~: A).\nProof. by rewrite /maxset unlock. Qed.",
    "Lemma minmaxset P A : minset P A = maxset [pred B | P (~: B)] (~: A).\nProof.\nby rewrite /maxset unlock setCK; apply: minset_eq => B /=; rewrite setCK.\nQed.",
    "Lemma maxsetP P A :\n  reflect ((P A) /\\ (forall B, P B -> A \\subset B -> B = A)) (maxset P A).\nProof.\napply: (iffP minsetP); rewrite ?setCK unlock_with => [] [PA minA].\n  by split=> // B PB sAB; rewrite -[B]setCK [~: B]minA (setCK, setCS).\nby split=> // B PB' sBA'; rewrite -(minA _ PB') -1?setCS setCK.\nQed.",
    "Lemma maxsetp P A : maxset P A -> P A.\nProof. by case/maxsetP. Qed.",
    "Lemma maxsetsup P A B : maxset P A -> P B -> A \\subset B -> B = A.\nProof. by case/maxsetP=> _; apply. Qed.",
    "Lemma ex_maxset P : (exists A, P A) -> {A | maxset P A}.\nProof.\nmove=> exP; have{exP}: exists A, P (~: A).\n  by case: exP => A PA; exists (~: A); rewrite setCK.\nby case/ex_minset=> A minA; exists (~: A); rewrite /maxset unlock setCK.\nQed.",
    "Lemma maxset_exists P C : P C -> {A : sT | maxset P A & C \\subset A}.\nProof.\nmove=> PC; pose P' B := P (~: B); have: P' (~: C) by rewrite /P' setCK.\ncase/minset_exists=> B; rewrite -[B]setCK setCS.\nby exists (~: B); rewrite // /maxset unlock.\nQed.",
    "Lemma subset_iterS i : iterF i \\subset iterF i.+1.\nProof. by elim: i => [| i IHi]; rewrite /= ?sub0set ?F_mono. Qed.",
    "Lemma subset_iter : {homo iterF : i j / i <= j >-> i \\subset j}.\nProof.\nby apply: homo_leq => //[? ? ?|]; [apply: subset_trans|apply: subset_iterS].\nQed.",
    "Lemma fixsetK : F fixset = fixset.\nProof.\nsuff /'exists_eqP[x /= e]: [exists k : 'I_n.+1, iterF k == iterF k.+1].\n  by rewrite /fixset -(subnK (leq_ord x)) /iterF iterD iter_fix.\napply: contraT => /existsPn /(_ (Ordinal _)) /= neq_iter.\nsuff iter_big k : k <= n.+1 -> k <= #|iter k F set0|.\n  by have := iter_big _ (leqnn _); rewrite ltnNge max_card.\nelim: k => [|k IHk] k_lt //=; apply: (leq_ltn_trans (IHk (ltnW k_lt))).\nby rewrite proper_card// properEneq// subset_iterS neq_iter.\nQed.",
    "Lemma minset_fix : minset [pred X | F X == X] fixset.\nProof.\napply/minsetP; rewrite inE fixsetK eqxx; split=> // X /eqP FXeqX Xsubfix.\napply/eqP; rewrite eqEsubset Xsubfix/=.\nsuff: fixset \\subset iter n F X by rewrite iter_fix.\nby rewrite /fixset; elim: n => //= [|m IHm]; rewrite ?sub0set ?F_mono.\nQed.",
    "Lemma fixsetKn k : iter k F fixset = fixset.\nProof. by rewrite iter_fix. Qed.",
    "Lemma iter_sub_fix k : iterF k \\subset fixset.\nProof.\nhave [/subset_iter //|/ltnW/subnK<-] := leqP k n;\nby rewrite /iterF iterD fixsetKn.\nQed.",
    "Lemma fix_order_proof x : x \\in fixset -> exists n, x \\in iterF n.\nProof. by move=> x_fix; exists n. Qed.",
    "Lemma fix_order_le_max (x : T) : fix_order x <= n.\nProof.\nrewrite /fix_order; case: eqP => //= x_in.\nby case: ex_minnP => //= ? ?; apply.\nQed.",
    "Lemma in_iter_fix_orderE (x : T) :\n  (x \\in iterF (fix_order x)) = (x \\in fixset).\nProof.\nrewrite /fix_order; case: eqP => [x_in | /negP/negPf-> /[1!inE]//].\nby case: ex_minnP => m ->; rewrite x_in.\nQed.",
    "Lemma fix_order_gt0 (x : T) : (fix_order x > 0) = (x \\in fixset).\nProof.\nrewrite /fix_order; case: eqP => [x_in | /negP/negPf->//].\nby rewrite x_in; case: ex_minnP => -[/[!inE] | m].\nQed.",
    "Lemma fix_order_eq0 (x : T) : (fix_order x == 0) = (x \\notin fixset).\nProof. by rewrite -fix_order_gt0 -ltnNge ltnS leqn0. Qed.",
    "Lemma in_iter_fixE (x : T) k : (x \\in iterF k) = (0 < fix_order x <= k).\nProof.\nrewrite /fix_order; case: eqP => //= [x_in|/negP xNin]; last first.\n  by apply: contraNF xNin; apply/subsetP/iter_sub_fix.\ncase: ex_minnP => -[/[!inE]//|m] xm mP.\nby apply/idP/idP=> [/mP//|lt_mk]; apply: subsetP xm; apply: subset_iter.\nQed.",
    "Lemma in_iter (x : T) k : x \\in fixset -> fix_order x <= k -> x \\in iterF k.\nProof. by move=> x_in xk; rewrite in_iter_fixE fix_order_gt0 x_in xk. Qed.",
    "Lemma notin_iter (x : T) k : k < fix_order x -> x \\notin iterF k.\nProof. by move=> k_le; rewrite in_iter_fixE negb_and orbC -ltnNge k_le. Qed.",
    "Lemma fix_order_small x k : x \\in iterF k -> fix_order x <= k.\nProof. by rewrite in_iter_fixE => /andP[]. Qed.",
    "Lemma fix_order_big x k : x \\in fixset -> x \\notin iterF k -> fix_order x > k.\nProof. by move=> x_in; rewrite in_iter_fixE fix_order_gt0 x_in /= -ltnNge. Qed.",
    "Lemma le_fix_order (x y : T) : y \\in iterF (fix_order x) ->\n  fix_order y <= fix_order x.\nProof. exact: fix_order_small. Qed.",
    "Lemma funsetC_mono : {homo funsetC : X Y / X \\subset Y}.\nProof. by move=> *; rewrite subCset setCK F_mono// subCset setCK. Qed.",
    "Lemma cofixsetK : F cofixset = cofixset.\nProof. by rewrite /cofixset -[in RHS]fixsetK ?setCK. Qed.",
    "Lemma maxset_cofix : maxset [pred X | F X == X] cofixset.\nProof.\nrewrite maxminset setCK.\nrewrite (@minset_eq _ _ [pred X | funsetC X == X]) ?minset_fix//.\nby move=> X /=; rewrite (can2_eq setCK setCK).\nQed.",
    "Lemma ffunE g x : (finfun g : fT) x = g x.\nProof.\nrewrite unlock /=; set s := enum aT; set s_x : mem_seq s x := mem_enum _ _.\nby elim: s s_x => //= x1 s IHs; case: eqP => [|_]; [case: x1 / | apply: IHs].\nQed.",
    "Lemma ffunP (f1 f2 : fT) : (forall x, f1 x = f2 x) <-> f1 = f2.\nProof.\nsuffices ffunK f g: (forall x, f x = g x) -> f = finfun g.\n  by split=> [/ffunK|] -> //; apply/esym/ffunK.\ncase: f => f Dg; rewrite unlock; congr FinfunOf.\nhave{} Dg x (aTx : mem_seq (enum aT) x): g x = fun_of_fin_rec f aTx.\n  by rewrite -Dg /= (bool_irrelevance (mem_enum _ _) aTx).\nelim: (enum aT) / f (enum_uniq aT) => //= x1 s y f IHf /andP[s'x1 Us] in Dg *.\nrewrite Dg ?eqxx //=; case: eqP => // /eq_axiomK-> /= _.\nrewrite {}IHf // => x s_x; rewrite Dg ?s_x ?orbT //.\nby case: eqP (memPn s'x1 x s_x) => // _ _ /(bool_irrelevance s_x) <-.\nQed.",
    "Lemma ffunK : @cancel (finPi aT rT) fT fun_of_fin finfun.\nProof. by move=> f; apply/ffunP=> x; rewrite ffunE. Qed.",
    "Lemma eq_dffun (g1 g2 : forall x, rT x) :\n   (forall x, g1 x = g2 x) -> finfun g1 = finfun g2.\nProof. by move=> eq_g; apply/ffunP => x; rewrite !ffunE eq_g. Qed.",
    "Lemma codom_tffun f : codom (total_fun f) = tfgraph f. Proof. by []. Qed.",
    "Lemma tfgraphK : pcancel tfgraph tfgraph_inv.\nProof.\nmove=> f; have Dg x: tnth (tfgraph f) (enum_rank x) = total_fun f x.\n  by rewrite tnth_map -[tnth _ _]enum_val_nth enum_rankK.\nrewrite /tfgraph_inv; case: eqfunP => /= [Dtg | [] x]; last by rewrite Dg.\ncongr (Some _); apply/ffunP=> x; rewrite ffunE.\nby rewrite Dg in (Dx := Dtg x) *; rewrite eq_axiomK.\nQed.",
    "Lemma tfgraph_inj : injective tfgraph. Proof. exact: pcan_inj tfgraphK. Qed.",
    "Lemma familyP f : reflect (forall x, f x \\in F x) (f \\in family_mem (fmem F)).\nProof. exact: forallP. Qed.",
    "Lemma finfun_of_tupleK : cancel finfun_of_tuple tuple_of_finfun.\nProof.\nby move=> t; apply: eq_from_tnth => i; rewrite tnth_map ffunE tnth_ord_tuple.\nQed.",
    "Lemma tuple_of_finfunK : cancel tuple_of_finfun finfun_of_tuple.\nProof.\nby move=> f; apply/ffunP => i; rewrite ffunE tnth_map tnth_ord_tuple.\nQed.",
    "Lemma tnth_fgraph f i : tnth (fgraph f) i = f (enum_val i).\nProof. by rewrite tnth_map /tnth -enum_val_nth. Qed.",
    "Lemma FinfunK : cancel Finfun fgraph.\nProof.\nby move=> G; apply/eq_from_tnth=> i; rewrite tnth_fgraph ffunE enum_valK.\nQed.",
    "Lemma fgraphK : cancel fgraph Finfun.\nProof. by move=> f; apply/ffunP=> x; rewrite ffunE tnth_fgraph enum_rankK. Qed.",
    "Lemma fgraph_ffun0 aT0 : fgraph (ffun0 aT0) = nil :> seq rT.\nProof. by apply/nilP/eqP; rewrite size_tuple. Qed.",
    "Lemma codom_ffun f : codom f = fgraph f. Proof. by []. Qed.",
    "Lemma tagged_tfgraph f : @map _ rT tagged (tfgraph f) = fgraph f.\nProof. by rewrite -map_comp. Qed.",
    "Lemma eq_ffun (g1 g2 : aT -> rT) : g1 =1 g2 -> finfun g1 = finfun g2.\nProof. exact: eq_dffun. Qed.",
    "Lemma fgraph_codom f : fgraph f = codom_tuple f.\nProof. exact/esym/val_inj/codom_ffun. Qed.",
    "Lemma ffun_onP R f : reflect (forall x, f x \\in R) (f \\in ffun_on_mem (mem R)).\nProof. exact: forallP. Qed.",
    "Lemma nth_fgraph_ord T n (x0 : T) (i : 'I_n) f : nth x0 (fgraph f) i = f i.\nProof.\nby rewrite -[i in RHS]enum_rankK -tnth_fgraph  (tnth_nth x0) enum_rank_ord.\nQed.",
    "Lemma supportE x y f : (x \\in support_for y f) = (f x != y). Proof. by []. Qed.",
    "Lemma supportP y D g :\n  reflect (forall x, x \\notin D -> g x = y) (y.-support g \\subset D).\nProof.\nby apply: (iffP subsetP) => Dg x; [apply: contraNeq | apply: contraR] => /Dg->.\nQed.",
    "Lemma pfamilyP (pT : predType rT) y D (F : aT -> pT) f :\n  reflect (y.-support f \\subset D /\\ {in D, forall x, f x \\in F x})\n          (f \\in pfamily_mem y (mem D) (fmem F)).\nProof.\napply: (iffP familyP) => [/= f_pfam | [/supportP f_supp f_fam] x].\n  split=> [|x Ax]; last by have:= f_pfam x; rewrite Ax.\n  by apply/subsetP=> x; case: ifP (f_pfam x) => //= _ fx0 /negP[].\nby case: ifPn => Ax /=; rewrite inE /= (f_fam, f_supp).\nQed.",
    "Lemma pffun_onP y D R f :\n  reflect (y.-support f \\subset D /\\ {subset image f D <= R})\n          (f \\in pffun_on_mem y (mem D) (mem R)).\nProof.\napply: (iffP (pfamilyP y D (fun _ => R) f)) => [] [-> f_fam]; split=> //.\n  by move=> _ /imageP[x Ax ->]; apply: f_fam.\nby move=> x Ax; apply: f_fam; apply/imageP; exists x.\nQed.",
    "Lemma card_family (F : forall x, pred (rT x)) :\n  #|(family F : simpl_pred fT)| = foldr muln 1 [seq #|F x| | x : aT].\nProof.\nrewrite /image_mem; set E := enum aT in (uniqE := enum_uniq aT) *.\nhave trivF x: x \\notin E -> #|F x| = 1 by rewrite mem_enum.\nelim: E uniqE => /= [_ | x0 E IH_E /andP[E'x0 uniqE]] in F trivF *.\n  have /fin_all_exists[f0 Ff0] x: exists y0, F x =i pred1 y0.\n    have /pred0Pn[y Fy]: #|F x| != 0 by rewrite trivF.\n    by exists y; apply/fsym/subset_cardP; rewrite ?subset_pred1 // card1 trivF.\n  apply: eq_card1 (finfun f0 : fT) _ _ => f; apply/familyP/eqP=> [Ff | {f}-> x].\n    by apply/ffunP=> x; have /[!(Ff0, ffunE)]/eqP := Ff x.\n  by rewrite ffunE Ff0 inE /=.\nhave [y0 Fxy0 | Fx00] := pickP (F x0); last first.\n  by rewrite !eq_card0 // => f; apply: contraFF (Fx00 (f x0))=> /familyP; apply.\npose F1 x := if eqP is ReflectT Dx then xpred1 (ecast x (rT x) Dx y0) else F x.\ntransitivity (#|[predX F x0 & family F1 : pred fT]|); last first.\n  rewrite cardX {}IH_E {uniqE}// => [|x E'x]; last first.\n    rewrite /F1; case: eqP => [Dx | /nesym/eqP-x0'x]; first exact: card1.\n    by rewrite trivF // negb_or x0'x.\n  congr (_ * foldr _ _ _); apply/eq_in_map=> x Ex.\n  by rewrite /F1; case: eqP => // Dx0; rewrite Dx0 Ex in E'x0.\npose g yf : fT := let: (y, f) := yf : rT x0 * fT in\n  [ffun x => if eqP is ReflectT Dx then ecast x (rT x) Dx y else f x].\nhave gK: cancel (fun f : fT => (f x0, g (y0, f))) g.\n  by move=> f; apply/ffunP=> x; rewrite !ffunE; case: eqP => //; case: x /.\nrewrite -(card_image (can_inj gK)); apply: eq_card => [] [y f] /=.\napply/imageP/andP=> [[f1 /familyP/=Ff1] [-> ->]| [/=Fx0y /familyP/=Ff]].\n  split=> //; apply/familyP=> x; rewrite ffunE /F1 /=.\n  by case: eqP => // Dx; apply: eqxx.\nexists (g (y, f)).\n  by apply/familyP=> x; have:= Ff x; rewrite ffunE /F1; case: eqP; [case: x /|].\ncongr (_, _); first by rewrite /= ffunE; case: eqP => // Dx; rewrite eq_axiomK.\nby apply/ffunP=> x; have:= Ff x; rewrite !ffunE /F1; case: eqP => // Dx /eqP.\nQed.",
    "Lemma card_dep_ffun : #|fT| = foldr muln 1 [seq #|rT x| | x : aT].\nProof. by rewrite -card_family; apply/esym/eq_card=> f; apply/familyP. Qed.",
    "Lemma card_pfamily y0 D F :\n  #|pfamily y0 D F| = foldr muln 1 [seq #|F x| | x in D].\nProof.\nrewrite card_family !/(image _ _) /(enum D) -enumT /=.\nby elim: (enum aT) => //= x E ->; have [// | D'x] := ifP; rewrite card1 mul1n.\nQed.",
    "Lemma card_pffun_on y0 D R : #|pffun_on y0 D R| = #|R| ^ #|D|.\nProof.\nrewrite (cardE D) card_pfamily /image_mem.\nby elim: (enum D) => //= _ e ->; rewrite expnS.\nQed.",
    "Lemma card_ffun_on R : #|@ffun_on aT R| = #|R| ^ #|aT|.\nProof.\nrewrite card_family /image_mem cardT.\nby elim: (enum aT) => //= _ e ->; rewrite expnS.\nQed.",
    "Lemma card_ffun : #|fT| = #|rT| ^ #|aT|.\nProof. by rewrite -card_ffun_on; apply/esym/eq_card=> f; apply/forallP. Qed.",
    "Lemma size_tuple t : size t = n.\nProof. exact: (eqP (valP t)). Qed.",
    "Lemma tnth_default t : 'I_n -> T.\nProof. by rewrite -(size_tuple t); case: (tval t) => [|//] []. Qed.",
    "Lemma tnth_nth x t i : tnth t i = nth x t i.\nProof. by apply: set_nth_default; rewrite size_tuple. Qed.",
    "Lemma tnth_onth x t i : tnth t i = x <-> onth t i = Some x.\nProof.\nrewrite (tnth_nth x) onthE (nth_map x) ?size_tuple//.\nby split; [move->|case].\nQed.",
    "Lemma map_tnth_enum t : map (tnth t) (enum 'I_n) = t.\nProof.\ncase def_t: {-}(val t) => [|x0 t'].\n  by rewrite [enum _]size0nil // -cardE card_ord -(size_tuple t) def_t.\napply: (@eq_from_nth _ x0) => [|i]; rewrite size_map.\n  by rewrite -cardE size_tuple card_ord.\nmove=> lt_i_e; have lt_i_n: i < n by rewrite -cardE card_ord in lt_i_e.\nby rewrite (nth_map (Ordinal lt_i_n)) // (tnth_nth x0) nth_enum_ord.\nQed.",
    "Lemma eq_from_tnth t1 t2 : tnth t1 =1 tnth t2 -> t1 = t2.\nProof.\nby move/eq_map=> eq_t; apply: val_inj; rewrite /= -!map_tnth_enum eq_t.\nQed.",
    "Lemma tupleE t : tuple (fun sP => @Tuple t sP) = t.\nProof. by case: t. Qed.",
    "Lemma tcastE m n (eq_mn : m = n) t i :\n  tnth (tcast eq_mn t) i = tnth t (cast_ord (esym eq_mn) i).\nProof. by case: n / eq_mn in i *; rewrite cast_ord_id. Qed.",
    "Lemma tcast_id n (eq_nn : n = n) t : tcast eq_nn t = t.\nProof. by rewrite (eq_axiomK eq_nn). Qed.",
    "Lemma tcastK m n (eq_mn : m = n) : cancel (tcast eq_mn) (tcast (esym eq_mn)).\nProof. by case: n / eq_mn. Qed.",
    "Lemma tcastKV m n (eq_mn : m = n) : cancel (tcast (esym eq_mn)) (tcast eq_mn).\nProof. by case: n / eq_mn. Qed.",
    "Lemma tcast_trans m n p (eq_mn : m = n) (eq_np : n = p) t:\n  tcast (etrans eq_mn eq_np) t = tcast eq_np (tcast eq_mn t).\nProof. by case: n / eq_mn eq_np; case: p /. Qed.",
    "Lemma tvalK n (t : n.-tuple T) : in_tuple t = tcast (esym (size_tuple t)) t.\nProof. by apply: val_inj => /=; case: _ / (esym _). Qed.",
    "Lemma val_tcast m n (eq_mn : m = n) (t : m.-tuple T) :\n  tcast eq_mn t = t :> seq T.\nProof. by case: n / eq_mn. Qed.",
    "Lemma in_tupleE s : in_tuple s = s :> seq T. Proof. by []. Qed.",
    "Lemma rcons_tupleP t x : size (rcons t x) == n.+1.\nProof. by rewrite size_rcons size_tuple. Qed.",
    "Lemma nseq_tupleP x : @size T (nseq n x) == n.\nProof. by rewrite size_nseq. Qed.",
    "Lemma iota_tupleP : size (iota m n) == n.\nProof. by rewrite size_iota. Qed.",
    "Lemma behead_tupleP t : size (behead t) == n.-1.\nProof. by rewrite size_behead size_tuple. Qed.",
    "Lemma belast_tupleP x t : size (belast x t) == n.\nProof. by rewrite size_belast size_tuple. Qed.",
    "Lemma cat_tupleP t (u : m.-tuple T) : size (t ++ u) == n + m.\nProof. by rewrite size_cat !size_tuple. Qed.",
    "Lemma take_tupleP t : size (take m t) == minn m n.\nProof. by rewrite size_take size_tuple eqxx. Qed.",
    "Lemma drop_tupleP t : size (drop m t) == n - m.\nProof. by rewrite size_drop size_tuple. Qed.",
    "Lemma rev_tupleP t : size (rev t) == n.\nProof. by rewrite size_rev size_tuple. Qed.",
    "Lemma rot_tupleP t : size (rot m t) == n.\nProof. by rewrite size_rot size_tuple. Qed.",
    "Lemma rotr_tupleP t : size (rotr m t) == n.\nProof. by rewrite size_rotr size_tuple. Qed.",
    "Lemma map_tupleP f t : @size rT (map f t) == n.\nProof. by rewrite size_map size_tuple. Qed.",
    "Lemma scanl_tupleP f x t : @size rT (scanl f x t) == n.\nProof. by rewrite size_scanl size_tuple. Qed.",
    "Lemma pairmap_tupleP f x t : @size rT (pairmap f x t) == n.\nProof. by rewrite size_pairmap size_tuple. Qed.",
    "Lemma zip_tupleP t (u : n.-tuple U) : size (zip t u) == n.\nProof. by rewrite size1_zip !size_tuple. Qed.",
    "Lemma allpairs_tupleP f t (u : m.-tuple U) : @size rT (allpairs f t u) == n * m.\nProof. by rewrite size_allpairs !size_tuple. Qed.",
    "Lemma sort_tupleP r t : size (sort r t) == n.\nProof. by rewrite size_sort size_tuple. Qed.",
    "Lemma tnth0 x t : tnth [tuple of x :: t] ord0 = x.\nProof. by []. Qed.",
    "Lemma tnthS x t i : tnth [tuple of x :: t] (lift ord0 i) = tnth t i.\nProof. by rewrite (tnth_nth (tnth_default t i)). Qed.",
    "Lemma theadE x t : thead [tuple of x :: t] = x.\nProof. by []. Qed.",
    "Lemma tuple0 : all_equal_to ([tuple] : 0.-tuple T).\nProof. by move=> t; apply: val_inj; case: t => [[]]. Qed.",
    "Lemma tupleP u : tuple1_spec u.\nProof.\ncase: u => [[|x s] //= sz_s]; pose t := @Tuple n _ s sz_s.\nby rewrite (_ : Tuple _ = [tuple of x :: t]) //; apply: val_inj.\nQed.",
    "Lemma tnth_map f t i : tnth [tuple of map f t] i = f (tnth t i) :> rT.\nProof. by apply: nth_map; rewrite size_tuple. Qed.",
    "Lemma tnth_nseq x i : tnth [tuple of nseq n x] i = x.\nProof.\nby rewrite !(tnth_nth (tnth_default (nseq_tuple x) i)) nth_nseq ltn_ord.\nQed.",
    "Lemma tnth_behead n T (t : n.+1.-tuple T) i :\n  tnth [tuple of behead t] i = tnth t (inord i.+1).\nProof. by case/tupleP: t => x t; rewrite !(tnth_nth x) inordK ?ltnS. Qed.",
    "Lemma tuple_eta n T (t : n.+1.-tuple T) : t = [tuple of thead t :: behead t].\nProof. by case/tupleP: t => x t; apply: val_inj. Qed.",
    "Lemma tnth_lshift i : tnth [tuple of t1 ++ t2] (lshift n2 i) = tnth t1 i.\nProof.\nhave x0 := tnth_default t1 i; rewrite !(tnth_nth x0).\nby rewrite nth_cat size_tuple /= ltn_ord.\nQed.",
    "Lemma tnth_rshift j : tnth [tuple of t1 ++ t2] (rshift n1 j) = tnth t2 j.\nProof.\nhave x0 := tnth_default t2 j; rewrite !(tnth_nth x0).\nby rewrite nth_cat size_tuple ltnNge leq_addr /= addKn.\nQed.",
    "Lemma forallb_tnth a t : [forall i, a (tnth t i)] = all a t.\nProof.\napply: negb_inj; rewrite -has_predC -has_map negb_forall.\napply/existsP/(has_nthP true) => [[i a_t_i] | [i lt_i_n a_t_i]].\n  by exists i; rewrite ?size_tuple // -tnth_nth tnth_map.\nrewrite size_tuple in lt_i_n; exists (Ordinal lt_i_n).\nby rewrite -tnth_map (tnth_nth true).\nQed.",
    "Lemma existsb_tnth a t : [exists i, a (tnth t i)] = has a t.\nProof. by apply: negb_inj; rewrite negb_exists -all_predC -forallb_tnth. Qed.",
    "Lemma all_tnthP a t : reflect (forall i, a (tnth t i)) (all a t).\nProof. by rewrite -forallb_tnth; apply: forallP. Qed.",
    "Lemma has_tnthP a t : reflect (exists i, a (tnth t i)) (has a t).\nProof. by rewrite -existsb_tnth; apply: existsP. Qed.",
    "Lemma eqEtuple (t1 t2 : n.-tuple T) :\n  (t1 == t2) = [forall i, tnth t1 i == tnth t2 i].\nProof. by apply/eqP/'forall_eqP => [->|/eq_from_tnth]. Qed.",
    "Lemma memtE (t : n.-tuple T) : mem t = mem (tval t).\nProof. by []. Qed.",
    "Lemma mem_tnth i (t : n.-tuple T) : tnth t i \\in t.\nProof. by rewrite mem_nth ?size_tuple. Qed.",
    "Lemma memt_nth x0 (t : n.-tuple T) i : i < n -> nth x0 t i \\in t.\nProof. by move=> i_lt_n; rewrite mem_nth ?size_tuple. Qed.",
    "Lemma tnthP (t : n.-tuple T) x : reflect (exists i, x = tnth t i) (x \\in t).\nProof.\napply: (iffP idP) => [/(nthP x)[i ltin <-] | [i ->]]; last exact: mem_tnth.\nby rewrite size_tuple in ltin; exists (Ordinal ltin); rewrite (tnth_nth x).\nQed.",
    "Lemma seq_tnthP (s : seq T) x : x \\in s -> {i | x = tnth (in_tuple s) i}.\nProof.\nmove=> s_x; pose i := index x s; have lt_i: i < size s by rewrite index_mem.\nby exists (Ordinal lt_i); rewrite (tnth_nth x) nth_index.\nQed.",
    "Lemma tuple_uniqP (t : n.-tuple T) : reflect (injective (tnth t)) (uniq t).\nProof.\ncase: {+}n => [|m] in t *; first by rewrite tuple0; constructor => -[].\npose x0 := tnth t ord0; apply/(equivP (uniqP x0)); split=> tinj i j.\n  by rewrite !(tnth_nth x0) => /tinj/val_inj; apply; rewrite size_tuple inE.\nrewrite !size_tuple !inE => im jm; have := tinj (Ordinal im) (Ordinal jm).\nby rewrite !(tnth_nth x0) => /[apply]-[].\nQed.",
    "Lemma enumP : Finite.axiom enum.\nProof.\ncase=> /= t t_n; rewrite -(count_map _ (pred1 t)) (pmap_filter (insubK _)).\nrewrite count_filter -(@eq_count _ (pred1 t)) => [|s /=]; last first.\n  by rewrite isSome_insub; case: eqP=> // ->.\nelim: n t t_n => [|m IHm] [|x t] //= {}/IHm; move: (iter m _ _) => em IHm.\ntransitivity (x \\in T : nat); rewrite // -mem_enum codomE.\nelim: (fintype.enum T) (enum_uniq T) => //= y e IHe /andP[/negPf ney].\nrewrite count_cat count_map inE /preim /= [in LHS]/eq_op /= eq_sym => /IHe->.\nby case: eqP => [->|_]; rewrite ?(ney, count_pred0, IHm).\nQed.",
    "Lemma size_enum : size enum = #|T| ^ n.\nProof.\nrewrite /= cardE size_pmap_sub; elim: n => //= m IHm.\nrewrite expnS /codom /image_mem; elim: {2 3}(fintype.enum T) => //= x e IHe.\nby rewrite count_cat {}IHe count_map IHm.\nQed.",
    "Lemma card_tuple : #|{:n.-tuple T}| = #|T| ^ n.\nProof. by rewrite [#|_|]cardT enumT unlock FinTuple.size_enum. Qed.",
    "Lemma enum_tupleP (A : {pred T}) : size (enum A) == #|A|.\nProof. by rewrite -cardE. Qed.",
    "Lemma val_ord_tuple : val ord_tuple = enum 'I_n. Proof. by []. Qed.",
    "Lemma tuple_map_ord U (t : n.-tuple U) : t = [tuple of map (tnth t) ord_tuple].\nProof. by apply: val_inj => /=; rewrite map_tnth_enum. Qed.",
    "Lemma tnth_ord_tuple i : tnth ord_tuple i = i.\nProof.\napply: val_inj; rewrite (tnth_nth i) -(nth_map _ 0) ?size_tuple //.\nby rewrite /= enumT unlock val_ord_enum nth_iota.\nQed.",
    "Lemma tnth_mktuple i : tnth mktuple i = f i.\nProof. by rewrite tnth_map tnth_ord_tuple. Qed.",
    "Lemma nth_mktuple x0 (i : 'I_n) : nth x0 mktuple i = f i.\nProof. by rewrite -tnth_nth tnth_mktuple. Qed.",
    "Lemma eq_mktuple T' (f1 f2 : 'I_n -> T') :\n  f1 =1 f2 -> mktuple f1 = mktuple f2.\nProof. by move=> eq_f; apply eq_from_tnth=> i; rewrite !tnth_map eq_f. Qed.",
    "Lemma size_bseq bs : size bs <= n.\nProof. by case: bs. Qed.",
    "Lemma bseqE bs : bseq (fun sP => @Bseq bs sP) = bs.\nProof. by case: bs. Qed.",
    "Lemma size_insub_bseq n T (s : seq T) : size (insub_bseq n s) <= size s.\nProof. by rewrite /insub_bseq /insubd; case: insubP => // ? ? ->. Qed.",
    "Lemma cast_bseq_id n (eq_nn : n = n) bs : cast_bseq eq_nn bs = bs.\nProof. by rewrite (eq_axiomK eq_nn). Qed.",
    "Lemma cast_bseqK m n (eq_mn : m = n) :\n  cancel (cast_bseq eq_mn) (cast_bseq (esym eq_mn)).\nProof. by case: n / eq_mn. Qed.",
    "Lemma cast_bseqKV m n (eq_mn : m = n) :\n  cancel (cast_bseq (esym eq_mn)) (cast_bseq eq_mn).\nProof. by case: n / eq_mn. Qed.",
    "Lemma cast_bseq_trans m n p (eq_mn : m = n) (eq_np : n = p) bs :\n  cast_bseq (etrans eq_mn eq_np) bs = cast_bseq eq_np (cast_bseq eq_mn bs).\nProof. by case: n / eq_mn eq_np; case: p /. Qed.",
    "Lemma size_cast_bseq m n (eq_mn : m = n) (bs : m.-bseq T) :\n  size (cast_bseq eq_mn bs) = size bs.\nProof. by case: n / eq_mn. Qed.",
    "Lemma widen_bseq_id n (lenn : n <= n) (bs : n.-bseq T) :\n  widen_bseq lenn bs = bs.\nProof. exact: val_inj. Qed.",
    "Lemma cast_bseqEwiden m n (eq_mn : m = n) (bs : m.-bseq T) :\n  cast_bseq eq_mn bs = widen_bseq (eq_leq eq_mn) bs.\nProof. by case: n / eq_mn; rewrite widen_bseq_id. Qed.",
    "Lemma widen_bseqK m n (lemn : m <= n) (lenm : n <= m) :\n   cancel (@widen_bseq m n lemn) (widen_bseq lenm).\nProof. by move=> t; apply: val_inj. Qed.",
    "Lemma widen_bseq_trans m n p (lemn : m <= n) (lenp : n <= p) (bs : m.-bseq T) :\n  widen_bseq (leq_trans lemn lenp) bs = widen_bseq lenp (widen_bseq lemn bs).\nProof. exact/val_inj. Qed.",
    "Lemma size_widen_bseq m n (lemn : m <= n) (bs : m.-bseq T) :\n  size (widen_bseq lemn bs) = size bs.\nProof. by []. Qed.",
    "Lemma in_bseqE s : in_bseq s = s :> seq T. Proof. by []. Qed.",
    "Lemma widen_bseq_in_bseq n (bs : n.-bseq T) :\n  widen_bseq (size_bseq bs) (in_bseq bs) = bs.\nProof. exact: val_inj. Qed.",
    "Lemma rcons_bseqP s x : size (rcons s x) <= n.+1.\nProof. by rewrite size_rcons ltnS size_bseq. Qed.",
    "Lemma behead_bseqP s : size (behead s) <= n.-1.\nProof. rewrite size_behead -!subn1; apply/leq_sub2r/size_bseq. Qed.",
    "Lemma belast_bseqP x s : size (belast x s) <= n.\nProof. by rewrite size_belast; apply/size_bseq. Qed.",
    "Lemma cat_bseqP s (s' : m.-bseq T) : size (s ++ s') <= n + m.\nProof. by rewrite size_cat; apply/leq_add/size_bseq/size_bseq. Qed.",
    "Lemma take_bseqP s : size (take m s) <= n.\nProof.\nby rewrite size_take_min (leq_trans _ (size_bseq s)) // geq_minr.\nQed.",
    "Lemma drop_bseqP s : size (drop m s) <= n - m.\nProof. by rewrite size_drop; apply/leq_sub2r/size_bseq. Qed.",
    "Lemma rev_bseqP s : size (rev s) <= n.\nProof. by rewrite size_rev size_bseq. Qed.",
    "Lemma rot_bseqP s : size (rot m s) <= n.\nProof. by rewrite size_rot size_bseq. Qed.",
    "Lemma rotr_bseqP s : size (rotr m s) <= n.\nProof. by rewrite size_rotr size_bseq. Qed.",
    "Lemma map_bseqP f s : @size rT (map f s) <= n.\nProof. by rewrite size_map size_bseq. Qed.",
    "Lemma scanl_bseqP f x s : @size rT (scanl f x s) <= n.\nProof. by rewrite size_scanl size_bseq. Qed.",
    "Lemma pairmap_bseqP f x s : @size rT (pairmap f x s) <= n.\nProof. by rewrite size_pairmap size_bseq. Qed.",
    "Lemma allpairs_bseqP f s (s' : m.-bseq U) : @size rT (allpairs f s s') <= n * m.\nProof. by rewrite size_allpairs; apply/leq_mul/size_bseq/size_bseq. Qed.",
    "Lemma sort_bseqP r s : size (sort r s) <= n.\nProof. by rewrite size_sort size_bseq. Qed.",
    "Lemma bseq0 : all_equal_to ([bseq] : 0.-bseq T).\nProof. by move=> s; apply: val_inj; case: s => [[]]. Qed.",
    "Lemma membsE n (T : eqType) (bs : n.-bseq T) : mem bs = mem (bseqval bs).\nProof. by []. Qed.",
    "Lemma bseq_tagged_tupleK {n T} :\n  cancel (@bseq_tagged_tuple n T) tagged_tuple_bseq.\nProof. by move=> bs; apply/val_inj. Qed.",
    "Lemma tagged_tuple_bseqK {n T} :\n  cancel (@tagged_tuple_bseq n T) bseq_tagged_tuple.\nProof.\nmove=> [[k lt_kn] t]; apply: eq_existT_curried => [|k_eq]; apply/val_inj.\n  by rewrite /= size_tuple.\nby refine (let: erefl := k_eq in _).\nQed.",
    "Lemma bseq_tagged_tuple_bij {n T} : bijective (@bseq_tagged_tuple n T).\nProof. exact/Bijective/tagged_tuple_bseqK/bseq_tagged_tupleK. Qed.",
    "Lemma tagged_tuple_bseq_bij {n T} : bijective (@tagged_tuple_bseq n T).\nProof. exact/Bijective/bseq_tagged_tupleK/tagged_tuple_bseqK. Qed.",
    "Lemma nat_of_succ_bin b : nat_of_bin (Nsucc b) = 1 + nat_of_bin b :> nat.\nProof. by case: b => [//|p /=]; rewrite nat_of_succ_pos. Qed.",
    "Lemma serial_Op s1 s2 : Op s1 s2 = s1 ++ s2 :> seq _.\nProof.\nrewrite /serial; set loop := (X in X [::]); rewrite -/loop.\nelim: s1 (loop [::] s2) => [n|s11 IHs1 s12 IHs2] //= l.\nby rewrite IHs1 [in RHS]IHs1 IHs2 catA.\nQed.",
    "Lemma pos_set_pos (f : T -> T) e (p p' : positive) :\n  pos (set_pos f e p) p' = if p == p' then f (pos e p) else pos e p'.\nProof. by elim: p e p' => [p IHp|p IHp|] [|???] [?|?|]//=; rewrite IHp. Qed.",
    "Lemma set_pos_trecE f z e p : set_pos_trec f z e p = unzip z (set_pos f e p).\nProof. by elim: p e z => [p IHp|p IHp|] [|???] [|[??]?] //=; rewrite ?IHp. Qed.",
    "Lemma count_memE x (t : syntax) :\n  count_mem x t = nat_of_bin (pos N0 (content t) x).\nProof.\nrewrite /content; set loop := (X in X Empty); rewrite -/loop.\nrewrite -[LHS]addn0.\nhave <- : nat_of_bin (pos N0 Empty x) = 0 :> nat by elim: x.\nelim: t Empty => [n|s IHs s' IHs'] e //=; last first.\n  by rewrite serial_Op count_cat -addnA IHs' IHs.\nrewrite ?addn0 set_pos_trecE pos_set_pos; case: (altP eqP) => [->|] //=.\nby rewrite Pos.nat_of_succ_bin.\nQed.",
    "Lemma cforallP N T R : (forall e : env T, R e) -> forall (e : env N), cforall e R.\nProof.\nmove=> Re e; elim: e R Re => [|? e /= IHe e' IHe' ?? x] //=.\nby apply: IHe => ?; apply: IHe' => /=.\nQed.",
    "Lemma proof (p s : syntax) : content p = content s ->\n  forall env, eval idx op env p = eval idx op env s.\nProof.\nsuff evalE env t : eval idx op env t = \\big[op/idx]_(i <- t) (pos idx env i).\n  move=> cps e; rewrite !evalE; apply: perm_big.\n  by apply/allP => x _ /=; rewrite !count_memE cps.\nelim: t => //= [n|t -> t' ->]; last by rewrite serial_Op big_cat.\nby rewrite big_cons big_nil Monoid.mulm1.\nQed.",
    "Lemma uniq_enumP (T : eqType) e : uniq e -> e =i T -> axiom e.\nProof. by move=> Ue sT x; rewrite count_uniq_mem ?sT. Qed.",
    "Lemma count_enumP : axiom count_enum.\nProof.\napply: uniq_enumP (pmap_uniq (@pickle_invK T) (iota_uniq _ _)) _ => x.\nby rewrite mem_pmap -pickleK_inv map_f // mem_iota ubT.\nQed.",
    "Lemma fin_pickleK : pcancel fin_pickle fin_unpickle.\nProof.\nmove=> x; rewrite /fin_pickle/fin_unpickle.\nrewrite -(index_map Some_inj) nth_index ?map_f//.\nby apply/count_memPn=> /eqP; rewrite f.\nQed.",
    "Lemma enumP : Finite.axiom (Finite.enum T).\nProof. by rewrite unlock; apply: enumP_subdef. Qed.",
    "Lemma enumT : enum T = Finite.enum T.\nProof. exact: filter_predT. Qed.",
    "Lemma mem_enum A : enum A =i A.\nProof. by move=> x; rewrite mem_filter andbC -has_pred1 has_count enumP. Qed.",
    "Lemma enum_uniq A : uniq (enum A).\nProof.\nby apply/filter_uniq/count_mem_uniq => x; rewrite enumP -enumT mem_enum.\nQed.",
    "Lemma enum0 : enum pred0 = Nil T. Proof. exact: filter_pred0. Qed.",
    "Lemma enum1 x : enum (pred1 x) = [:: x].\nProof.\nrewrite [enum _](all_pred1P x _ _); first by rewrite size_filter enumP.\nby apply/allP=> y; rewrite mem_enum.\nQed.",
    "Lemma pickP : pick_spec (pick P).\nProof.\nrewrite /pick; case: (enum _) (mem_enum P) => [|x s] Pxs /=.\n  by right; apply: fsym.\nby left; rewrite -[P _]Pxs mem_head.\nQed.",
    "Lemma eq_enum A B : A =i B -> enum A = enum B.\nProof. by move=> eqAB; apply: eq_filter. Qed.",
    "Lemma eq_pick P Q : P =1 Q -> pick P = pick Q.\nProof. by move=> eqPQ; rewrite /pick (eq_enum eqPQ). Qed.",
    "Lemma cardE A : #|A| = size (enum A).\nProof. by rewrite unlock. Qed.",
    "Lemma eq_card A B : A =i B -> #|A| = #|B|.\nProof. by move=> eqAB; rewrite !cardE (eq_enum eqAB). Qed.",
    "Lemma eq_card_trans A B n : #|A| = n -> B =i A -> #|B| = n.\nProof. by move <-; apply: eq_card. Qed.",
    "Lemma card0 : #|@pred0 T| = 0. Proof. by rewrite cardE enum0. Qed.",
    "Lemma cardT : #|T| = size (enum T). Proof. by rewrite cardE. Qed.",
    "Lemma card1 x : #|pred1 x| = 1.\nProof. by rewrite cardE enum1. Qed.",
    "Lemma eq_card0 A : A =i pred0 -> #|A| = 0.\nProof. exact: eq_card_trans card0. Qed.",
    "Lemma eq_cardT A : A =i predT -> #|A| = size (enum T).\nProof. exact: eq_card_trans cardT. Qed.",
    "Lemma eq_card1 x A : A =i pred1 x -> #|A| = 1.\nProof. exact: eq_card_trans (card1 x). Qed.",
    "Lemma cardUI A B : #|[predU A & B]| + #|[predI A & B]| = #|A| + #|B|.\nProof. by rewrite !cardE !size_filter count_predUI. Qed.",
    "Lemma cardID B A : #|[predI A & B]| + #|[predD A & B]| = #|A|.\nProof.\nrewrite -cardUI addnC [#|predI _ _|]eq_card0 => [|x] /=.\n  by apply: eq_card => x; rewrite !inE andbC -andb_orl orbN.\nby rewrite !inE -!andbA andbC andbA andbN.\nQed.",
    "Lemma cardC A : #|A| + #|[predC A]| = #|T|.\nProof. by rewrite !cardE !size_filter count_predC. Qed.",
    "Lemma cardU1 x A : #|[predU1 x & A]| = (x \\notin A) + #|A|.\nProof.\ncase Ax: (x \\in A).\n  by apply: eq_card => y /[1!inE]/=; case: eqP => // ->.\nrewrite /= -(card1 x) -cardUI addnC.\nrewrite [#|predI _ _|]eq_card0 => [|y /=]; first exact: eq_card.\nby rewrite !inE; case: eqP => // ->.\nQed.",
    "Lemma card2 x y : #|pred2 x y| = (x != y).+1.\nProof. by rewrite cardU1 card1 addn1. Qed.",
    "Lemma cardC1 x : #|predC1 x| = #|T|.-1.\nProof. by rewrite -(cardC (pred1 x)) card1. Qed.",
    "Lemma cardD1 x A : #|A| = (x \\in A) + #|[predD1 A & x]|.\nProof.\ncase Ax: (x \\in A); last first.\n  by apply: eq_card => y /[!inE]/=; case: eqP => // ->.\nrewrite /= -(card1 x) -cardUI addnC /=.\nrewrite [#|predI _ _|]eq_card0 => [|y]; last by rewrite !inE; case: eqP.\nby apply: eq_card => y /[!inE]; case: eqP => // ->.\nQed.",
    "Lemma max_card A : #|A| <= #|T|.\nProof. by rewrite -(cardC A) leq_addr. Qed.",
    "Lemma card_size s : #|s| <= size s.\nProof.\nelim: s => [|x s IHs] /=; first by rewrite card0.\nby rewrite cardU1 /=; case: (~~ _) => //; apply: leqW.\nQed.",
    "Lemma card_uniqP s : reflect (#|s| = size s) (uniq s).\nProof.\nelim: s => [|x s IHs]; first by left; apply: card0.\nrewrite cardU1 /= /addn; case: {+}(x \\in s) => /=.\n  by right=> card_Ssz; have:= card_size s; rewrite card_Ssz ltnn.\nby apply: (iffP IHs) => [<-| [<-]].\nQed.",
    "Lemma card0_eq A : #|A| = 0 -> A =i pred0.\nProof. by move=> A0 x; apply/idP => Ax; rewrite (cardD1 x) Ax in A0. Qed.",
    "Lemma fintype0 : T -> #|T| <> 0. Proof. by move=> x /card0_eq/(_ x). Qed.",
    "Lemma pred0P P : reflect (P =1 pred0) (pred0b P).\nProof. by apply: (iffP eqP); [apply: card0_eq | apply: eq_card0]. Qed.",
    "Lemma pred0Pn P : reflect (exists x, P x) (~~ pred0b P).\nProof.\ncase: (pickP P) => [x Px | P0].\n  by rewrite (introN (pred0P P)) => [|P0]; [left; exists x | rewrite P0 in Px].\nby rewrite -lt0n eq_card0 //; right=> [[x]]; rewrite P0.\nQed.",
    "Lemma card_gt0P A : reflect (exists i, i \\in A) (#|A| > 0).\nProof. by rewrite lt0n; apply: pred0Pn. Qed.",
    "Lemma card_le1P {A} : reflect {in A, forall x, A =i pred1 x} (#|A| <= 1).\nProof.\napply: (iffP idP) => [A1 x xA y|]; last first.\n  by have [/= x xA /(_ _ xA)/eq_card1->|/eq_card0->//] := pickP [in A].\nmove: A1; rewrite (cardD1 x) xA ltnS leqn0 => /eqP/card0_eq/(_ y).\nby rewrite !inE; have [->|]:= eqP.\nQed.",
    "Lemma mem_card1 A : #|A| = 1 -> {x | A =i pred1 x}.\nProof.\nmove=> A1; have /card_gt0P/sigW[x xA]: #|A| > 0 by rewrite A1.\nby exists x; apply/card_le1P; rewrite ?A1.\nQed.",
    "Lemma card1P A : reflect (exists x, A =i pred1 x) (#|A| == 1).\nProof.\nby apply: (iffP idP) => [/eqP/mem_card1[x inA]|[x /eq_card1/eqP//]]; exists x.\nQed.",
    "Lemma card_le1_eqP A :\n  reflect {in A &, forall x, all_equal_to x} (#|A| <= 1).\nProof.\napply: (iffP card_le1P) => [Ale1 x y xA yA /=|all_eq x xA y].\n  by apply/eqP; rewrite -[_ == _]/(y \\in pred1 x) -Ale1.\nby rewrite inE; case: (altP (y =P x)) => [->//|]; exact/contra_neqF/all_eq.\nQed.",
    "Lemma fintype_le1P : reflect (forall x : T, all_equal_to x) (#|T| <= 1).\nProof. apply: (iffP (card_le1_eqP {:T})); [exact: in2T | exact: in2W]. Qed.",
    "Lemma fintype1 : #|T| = 1 -> {x : T | all_equal_to x}.\nProof.\nby move=> /mem_card1[x ex]; exists x => y; suff: y \\in T by rewrite ex => /eqP.\nQed.",
    "Lemma fintype1P : reflect (exists x, all_equal_to x) (#|T| == 1).\nProof.\napply: (iffP idP) => [/eqP/fintype1|] [x eqx]; first by exists x.\nby apply/card1P; exists x => y; rewrite eqx !inE eqxx.\nQed.",
    "Lemma subsetE A B : (A \\subset B) = pred0b [predD A & B].\nProof. by rewrite unlock. Qed.",
    "Lemma subsetP A B : reflect {subset A <= B} (A \\subset B).\nProof.\nrewrite unlock; apply: (iffP (pred0P _)) => [AB0 x | sAB x /=].\n  by apply/implyP; apply/idPn; rewrite negb_imply andbC [_ && _]AB0.\nby rewrite andbC -negb_imply; apply/negbF/implyP; apply: sAB.\nQed.",
    "Lemma subsetPn A B :\n  reflect (exists2 x, x \\in A & x \\notin B) (~~ (A \\subset B)).\nProof.\nrewrite unlock; apply: (iffP (pred0Pn _)) => [[x] | [x Ax nBx]].\n  by case/andP; exists x.\nby exists x; rewrite /= nBx.\nQed.",
    "Lemma subset_leq_card A B : A \\subset B -> #|A| <= #|B|.\nProof.\nmove=> sAB.\nrewrite -(cardID A B) [#|predI _ _|](@eq_card _ A) ?leq_addr //= => x.\nby rewrite !inE andbC; case Ax: (x \\in A) => //; apply: subsetP Ax.\nQed.",
    "Lemma subxx_hint (mA : mem_pred T) : subset mA mA.\nProof.\nby case: mA => A; have:= introT (subsetP A A); rewrite !unlock => ->.\nQed.",
    "Lemma subxx (pT : predType T) (pA : pT) : pA \\subset pA.\nProof. by []. Qed.",
    "Lemma eq_subset A B : A =i B -> subset (mem A) =1 subset (mem B).\nProof.\nmove=> eqAB [C]; rewrite !unlock; congr (_ == 0).\nby apply: eq_card => x; rewrite inE /= eqAB.\nQed.",
    "Lemma eq_subset_r A B :\n   A =i B -> (@subset T)^~ (mem A) =1 (@subset T)^~ (mem B).\nProof.\nmove=> eqAB [C]; rewrite !unlock; congr (_ == 0).\nby apply: eq_card => x; rewrite !inE /= eqAB.\nQed.",
    "Lemma eq_subxx A B : A =i B -> A \\subset B.\nProof. by move/eq_subset->. Qed.",
    "Lemma subset_predT A : A \\subset T.\nProof. exact/subsetP. Qed.",
    "Lemma predT_subset A : T \\subset A -> forall x, x \\in A.\nProof. by move/subsetP=> allA x; apply: allA. Qed.",
    "Lemma subset_pred1 A x : (pred1 x \\subset A) = (x \\in A).\nProof. by apply/subsetP/idP=> [-> // | Ax y /eqP-> //]; apply: eqxx. Qed.",
    "Lemma subset_eqP A B : reflect (A =i B) ((A \\subset B) && (B \\subset A)).\nProof.\napply: (iffP andP) => [[sAB sBA] x| eqAB]; last by rewrite !eq_subxx.\nby apply/idP/idP; apply: subsetP.\nQed.",
    "Lemma subset_cardP A B : #|A| = #|B| -> reflect (A =i B) (A \\subset B).\nProof.\nmove=> eqcAB; case: (subsetP A B) (subset_eqP A B) => //= sAB.\ncase: (subsetP B A) => [//|[]] x Bx; apply/idPn => Ax.\ncase/idP: (ltnn #|A|); rewrite {2}eqcAB (cardD1 x B) Bx /=.\napply: subset_leq_card; apply/subsetP=> y Ay; rewrite inE /= andbC.\nby rewrite sAB //; apply/eqP => eqyx; rewrite -eqyx Ay in Ax.\nQed.",
    "Lemma subset_leqif_card A B : A \\subset B -> #|A| <= #|B| ?= iff (B \\subset A).\nProof.\nmove=> sAB; split; [exact: subset_leq_card | apply/eqP/idP].\n  by move/subset_cardP=> sABP; rewrite (eq_subset_r (sABP sAB)).\nby move=> sBA; apply: eq_card; apply/subset_eqP; rewrite sAB.\nQed.",
    "Lemma subset_trans A B C : A \\subset B -> B \\subset C -> A \\subset C.\nProof.\nby move/subsetP=> sAB /subsetP=> sBC; apply/subsetP=> x /sAB; apply: sBC.\nQed.",
    "Lemma subset_all s A : (s \\subset A) = all [in A] s.\nProof. exact: (sameP (subsetP _ _) allP). Qed.",
    "Lemma subset_cons s x : s \\subset x :: s.\nProof. by apply/subsetP => y /[!inE] ->; rewrite orbT. Qed.",
    "Lemma subset_cons2 s1 s2 x : s1 \\subset s2 -> x :: s1 \\subset x :: s2.\nProof.\nby move=> ?; apply/subsetP => y /[!inE]; case: eqP => // _; apply: subsetP.\nQed.",
    "Lemma subset_catl s s' : s \\subset s ++ s'.\nProof. by apply/subsetP=> x xins; rewrite mem_cat xins. Qed.",
    "Lemma subset_catr s s' : s \\subset s' ++ s.\nProof. by apply/subsetP => x xins; rewrite mem_cat xins orbT. Qed.",
    "Lemma subset_cat2 s1 s2 s3 : s1 \\subset s2 -> s3 ++ s1 \\subset s3 ++ s2.\nProof.\nmove=> /subsetP s12; apply/subsetP => x.\nby rewrite !mem_cat => /orP[->|/s12->]; rewrite ?orbT.\nQed.",
    "Lemma filter_subset p s : [seq a <- s | p a] \\subset s.\nProof. by apply/subsetP=> x; rewrite mem_filter => /andP[]. Qed.",
    "Lemma subset_filter p s1 s2 :\n  s1 \\subset s2 -> [seq a <- s1 | p a] \\subset [seq a <- s2 | p a].\nProof.\nby move/subsetP=> s12; apply/subsetP=> x; rewrite !mem_filter=> /andP[-> /s12].\nQed.",
    "Lemma properE A B : A \\proper B = (A \\subset B) && ~~ (B \\subset A).\nProof. by []. Qed.",
    "Lemma properP A B :\n  reflect (A \\subset B /\\ (exists2 x, x \\in B & x \\notin A)) (A \\proper B).\nProof. by rewrite properE; apply: (iffP andP) => [] [-> /subsetPn]. Qed.",
    "Lemma proper_sub A B : A \\proper B -> A \\subset B.\nProof. by case/andP. Qed.",
    "Lemma proper_subn A B : A \\proper B -> ~~ (B \\subset A).\nProof. by case/andP. Qed.",
    "Lemma proper_trans A B C : A \\proper B -> B \\proper C -> A \\proper C.\nProof.\ncase/properP=> sAB [x Bx nAx] /properP[sBC [y Cy nBy]].\nrewrite properE (subset_trans sAB) //=; apply/subsetPn; exists y => //.\nby apply: contra nBy; apply: subsetP.\nQed.",
    "Lemma proper_sub_trans A B C : A \\proper B -> B \\subset C -> A \\proper C.\nProof.\ncase/properP=> sAB [x Bx nAx] sBC; rewrite properE (subset_trans sAB) //.\nby apply/subsetPn; exists x; rewrite ?(subsetP _ _ sBC).\nQed.",
    "Lemma sub_proper_trans A B C : A \\subset B -> B \\proper C -> A \\proper C.\nProof.\nmove=> sAB /properP[sBC [x Cx nBx]]; rewrite properE (subset_trans sAB) //.\nby apply/subsetPn; exists x => //; apply: contra nBx; apply: subsetP.\nQed.",
    "Lemma proper_card A B : A \\proper B -> #|A| < #|B|.\nProof.\nby case/andP=> sAB nsBA; rewrite ltn_neqAle !(subset_leqif_card sAB) andbT.\nQed.",
    "Lemma proper_irrefl A : ~~ (A \\proper A).\nProof. by rewrite properE subxx. Qed.",
    "Lemma properxx A : (A \\proper A) = false.\nProof. by rewrite properE subxx. Qed.",
    "Lemma eq_proper A B : A =i B -> proper (mem A) =1 proper (mem B).\nProof.\nmove=> eAB [C]; congr (_ && _); first exact: (eq_subset eAB).\nby rewrite (eq_subset_r eAB).\nQed.",
    "Lemma eq_proper_r A B :\n  A =i B -> (@proper T)^~ (mem A) =1 (@proper T)^~ (mem B).\nProof.\nmove=> eAB [C]; congr (_ && _); first exact: (eq_subset_r eAB).\nby rewrite (eq_subset eAB).\nQed.",
    "Lemma card_geqP {A n} :\n  reflect (exists s, [/\\ uniq s, size s = n & {subset s <= A}]) (n <= #|A|).\nProof.\napply: (iffP idP) => [n_le_A|[s] [uniq_s size_s /subsetP subA]]; last first.\n  by rewrite -size_s -(card_uniqP _ uniq_s); exact: subset_leq_card.\nexists (take n (enum A)); rewrite take_uniq ?enum_uniq // size_take.\nsplit => //; last by move => x /mem_take; rewrite mem_enum.\ncase: (ltnP n (size (enum A))) => // size_A.\nby apply/eqP; rewrite eqn_leq size_A -cardE n_le_A.\nQed.",
    "Lemma card_gt1P A :\n  reflect (exists x y, [/\\ x \\in A, y \\in A & x != y]) (1 < #|A|).\nProof.\napply: (iffP card_geqP) => [[s] []|[x] [y] [xA yA xDy]].\n  case: s => [|a [|b []]]//= /[!(inE, andbT)] aDb _ subD.\n  by exists a, b; rewrite aDb !subD ?inE ?eqxx ?orbT.\nby exists [:: x; y]; rewrite /= !inE xDy; split=> // z /[!inE] /pred2P[]->.\nQed.",
    "Lemma card_gt2P A :\n  reflect (exists x y z,\n              [/\\ x \\in A, y \\in A & z \\in A] /\\ [/\\ x != y, y != z & z != x])\n          (2 < #|A|).\nProof.\napply: (iffP card_geqP) => [[s] []|[x] [y] [z] [[xD yD zD] [xDy xDz yDz]]].\n  case: s => [|x [|y [|z []]]]//=; rewrite !inE !andbT negb_or -andbA.\n  case/and3P => xDy xDz yDz _ subA.\n  by exists x, y, z; rewrite xDy yDz eq_sym xDz !subA ?inE ?eqxx ?orbT.\nexists [:: x; y; z]; rewrite /= !inE negb_or xDy xDz eq_sym yDz; split=> // u.\nby rewrite !inE => /or3P [] /eqP->.\nQed.",
    "Lemma disjoint_sym A B : [disjoint A & B] = [disjoint B & A].\nProof. by congr (_ == 0); apply: eq_card => x; apply: andbC. Qed.",
    "Lemma eq_disjoint A B : A =i B -> disjoint (mem A) =1 disjoint (mem B).\nProof.\nby move=> eqAB [C]; congr (_ == 0); apply: eq_card => x; rewrite !inE eqAB.\nQed.",
    "Lemma eq_disjoint_r A B : A =i B ->\n  (@disjoint T)^~ (mem A) =1 (@disjoint T)^~ (mem B).\nProof.\nby move=> eqAB [C]; congr (_ == 0); apply: eq_card => x; rewrite !inE eqAB.\nQed.",
    "Lemma subset_disjoint A B : (A \\subset B) = [disjoint A & [predC B]].\nProof. by rewrite disjoint_sym unlock. Qed.",
    "Lemma disjoint_subset A B : [disjoint A & B] = (A \\subset [predC B]).\nProof.\nby rewrite subset_disjoint; apply: eq_disjoint_r => x; rewrite !inE /= negbK.\nQed.",
    "Lemma disjointFr A B x : [disjoint A & B] -> x \\in A -> x \\in B = false.\nProof. by move/pred0P/(_ x) => /=; case: (x \\in A). Qed.",
    "Lemma disjointFl A B x : [disjoint A & B] -> x \\in B -> x \\in A = false.\nProof. rewrite disjoint_sym; exact: disjointFr. Qed.",
    "Lemma disjointWl A B C :\n   A \\subset B -> [disjoint B & C] -> [disjoint A & C].\nProof. by rewrite 2!disjoint_subset; apply: subset_trans. Qed.",
    "Lemma disjointWr A B C : A \\subset B -> [disjoint C & B] -> [disjoint C & A].\nProof. rewrite ![[disjoint C & _]]disjoint_sym. exact:disjointWl. Qed.",
    "Lemma disjointW A B C D :\n  A \\subset B -> C \\subset D -> [disjoint B & D] -> [disjoint A & C].\nProof.\nby move=> subAB subCD BD; apply/(disjointWl subAB)/(disjointWr subCD).\nQed.",
    "Lemma disjoint0 A : [disjoint pred0 & A].\nProof. exact/pred0P. Qed.",
    "Lemma eq_disjoint0 A B : A =i pred0 -> [disjoint A & B].\nProof. by move/eq_disjoint->; apply: disjoint0. Qed.",
    "Lemma disjoint1 x A : [disjoint pred1 x & A] = (x \\notin A).\nProof.\napply/negbRL/(sameP (pred0Pn _))=> /=.\napply: introP => [Ax | notAx [_ /andP[/eqP->]]]; last exact: negP.\nby exists x; rewrite inE eqxx.\nQed.",
    "Lemma eq_disjoint1 x A B :\n  A =i pred1 x ->  [disjoint A & B] = (x \\notin B).\nProof. by move/eq_disjoint->; apply: disjoint1. Qed.",
    "Lemma disjointU A B C :\n  [disjoint predU A B & C] = [disjoint A & C] && [disjoint B & C].\nProof.\ncase: [disjoint A & C] / (pred0P (xpredI A C)) => [A0 | nA0] /=.\n  by congr (_ == 0); apply: eq_card => x; rewrite [x \\in _]andb_orl A0.\napply/pred0P=> nABC; case: nA0 => x; apply/idPn=> /=; move/(_ x): nABC.\nby rewrite [_ x]andb_orl; case/norP.\nQed.",
    "Lemma disjointU1 x A B :\n  [disjoint predU1 x A & B] = (x \\notin B) && [disjoint A & B].\nProof. by rewrite disjointU disjoint1. Qed.",
    "Lemma disjoint_cons x s B :\n  [disjoint x :: s & B] = (x \\notin B) && [disjoint s & B].\nProof. exact: disjointU1. Qed.",
    "Lemma disjoint_has s A : [disjoint s & A] = ~~ has [in A] s.\nProof.\napply/negbRL; apply/pred0Pn/hasP => [[x /andP[]]|[x]]; exists x => //.\nexact/andP.\nQed.",
    "Lemma disjoint_cat s1 s2 A :\n  [disjoint s1 ++ s2 & A] = [disjoint s1 & A] && [disjoint s2 & A].\nProof. by rewrite !disjoint_has has_cat negb_or. Qed.",
    "Lemma map_subset {T T' : finType} (s1 s2 : seq T) (f : T -> T') :\n  s1 \\subset s2 -> [seq f x | x <- s1 ] \\subset [seq f x | x <- s2].\nProof.\nmove=> s1s2; apply/subsetP => _ /mapP[y] /[swap] -> ys1.\nby apply/mapP; exists y => //; move/subsetP : s1s2; exact.\nQed.",
    "Lemma existsPP : reflect (exists x, PP x) [exists x, P x].\nProof. by apply: (iffP pred0Pn) => -[x /viewP]; exists x. Qed.",
    "Lemma forallPP : reflect (forall x, PP x) [forall x, P x].\nProof. by apply: (iffP pred0P) => /= allP x; have /viewP//=-> := allP x. Qed.",
    "Lemma forallP P : reflect (forall x, P x) [forall x, P x].\nProof. exact: 'forall_idP. Qed.",
    "Lemma eqfunP f1 f2 : reflect (forall x, f1 x = f2 x) [forall x, f1 x == f2 x].\nProof. exact: 'forall_eqP. Qed.",
    "Lemma forall_inP D P : reflect (forall x, D x -> P x) [forall (x | D x), P x].\nProof. exact: 'forall_implyP. Qed.",
    "Lemma forall_inPP D P PP : (forall x, reflect (PP x) (P x)) ->\n  reflect (forall x, D x -> PP x) [forall (x | D x), P x].\nProof. by move=> vP; apply: (iffP (forall_inP _ _)) => /(_ _ _) /vP. Qed.",
    "Lemma eqfun_inP D f1 f2 :\n  reflect {in D, forall x, f1 x = f2 x} [forall (x | x \\in D), f1 x == f2 x].\nProof. exact: (forall_inPP _ (fun=> eqP)). Qed.",
    "Lemma existsP P : reflect (exists x, P x) [exists x, P x].\nProof. exact: 'exists_idP. Qed.",
    "Lemma existsb P (x : T) : P x -> [exists x, P x].\nProof. by move=> Px; apply/existsP; exists x. Qed.",
    "Lemma exists_eqP f1 f2 :\n  reflect (exists x, f1 x = f2 x) [exists x, f1 x == f2 x].\nProof. exact: 'exists_eqP. Qed.",
    "Lemma exists_inP D P : reflect (exists2 x, D x & P x) [exists (x | D x), P x].\nProof. by apply: (iffP 'exists_andP) => [[x []] | [x]]; exists x. Qed.",
    "Lemma exists_inb D P (x : T) : D x -> P x -> [exists (x | D x), P x].\nProof. by move=> Dx Px; apply/exists_inP; exists x. Qed.",
    "Lemma exists_inPP D P PP : (forall x, reflect (PP x) (P x)) ->\n  reflect (exists2 x, D x & PP x) [exists (x | D x), P x].\nProof. by move=> vP; apply: (iffP (exists_inP _ _)) => -[x?/vP]; exists x. Qed.",
    "Lemma exists_eq_inP D f1 f2 :\n  reflect (exists2 x, D x & f1 x = f2 x) [exists (x | D x), f1 x == f2 x].\nProof. exact: (exists_inPP _ (fun=> eqP)). Qed.",
    "Lemma eq_existsb P1 P2 : P1 =1 P2 -> [exists x, P1 x] = [exists x, P2 x].\nProof. by move=> eqP12; congr (_ != 0); apply: eq_card. Qed.",
    "Lemma eq_existsb_in D P1 P2 :\n    (forall x, D x -> P1 x = P2 x) ->\n  [exists (x | D x), P1 x] = [exists (x | D x), P2 x].\nProof. by move=> eqP12; apply: eq_existsb => x; apply: andb_id2l => /eqP12. Qed.",
    "Lemma eq_forallb P1 P2 : P1 =1 P2 -> [forall x, P1 x] = [forall x, P2 x].\nProof. by move=> eqP12; apply/negb_inj/eq_existsb=> /= x; rewrite eqP12. Qed.",
    "Lemma eq_forallb_in D P1 P2 :\n    (forall x, D x -> P1 x = P2 x) ->\n  [forall (x | D x), P1 x] = [forall (x | D x), P2 x].\nProof.\nby move=> eqP12; apply: eq_forallb => i; case Di: (D i); rewrite // eqP12.\nQed.",
    "Lemma negb_forall P : ~~ [forall x, P x] = [exists x, ~~ P x].\nProof. by []. Qed.",
    "Lemma negb_forall_in D P :\n  ~~ [forall (x | D x), P x] = [exists (x | D x), ~~ P x].\nProof. by apply: eq_existsb => x; rewrite negb_imply. Qed.",
    "Lemma negb_exists P : ~~ [exists x, P x] = [forall x, ~~ P x].\nProof. by apply/negbLR/esym/eq_existsb=> x; apply: negbK. Qed.",
    "Lemma negb_exists_in D P :\n  ~~ [exists (x | D x), P x] = [forall (x | D x), ~~ P x].\nProof. by rewrite negb_exists; apply/eq_forallb => x; rewrite [~~ _]fun_if. Qed.",
    "Lemma existsPn P :\n  reflect (forall x, ~~ P x) (~~ [exists x, P x]).\nProof. rewrite negb_exists. exact: forallP. Qed.",
    "Lemma forallPn P :\n  reflect (exists x, ~~ P x) (~~ [forall x, P x]).\nProof. rewrite negb_forall. exact: existsP. Qed.",
    "Lemma exists_inPn D P :\n  reflect (forall x, x \\in D -> ~~ P x) (~~ [exists x in D, P x]).\nProof. rewrite negb_exists_in. exact: forall_inP. Qed.",
    "Lemma forall_inPn D P :\n  reflect (exists2 x, x \\in D & ~~ P x) (~~ [forall x in D, P x]).\nProof. rewrite negb_forall_in. exact: exists_inP. Qed.",
    "Lemma dinjectivePn D :\n  reflect (exists2 x, x \\in D & exists2 y, y \\in [predD1 D & x] & f x = f y)\n          (~~ dinjectiveb D).\nProof.\napply: (iffP idP) => [injf | [x Dx [y Dxy eqfxy]]]; last first.\n  move: Dx; rewrite -(mem_enum D) => /rot_to[i E defE].\n  rewrite /dinjectiveb -(rot_uniq i) -map_rot defE /=; apply/nandP; left.\n  rewrite inE /= -(mem_enum D) -(mem_rot i) defE inE in Dxy.\n  rewrite andb_orr andbC andbN in Dxy.\n  by rewrite eqfxy map_f //; case/andP: Dxy.\npose p := [pred x in D | [exists (y | y \\in [predD1 D & x]), f x == f y]].\ncase: (pickP p) => [x /= /andP[Dx /exists_inP[y Dxy /eqP eqfxy]] | no_p].\n  by exists x; last exists y.\nrewrite /dinjectiveb map_inj_in_uniq ?enum_uniq // in injf => x y Dx Dy eqfxy.\napply: contraNeq (negbT (no_p x)) => ne_xy /=; rewrite -mem_enum Dx.\nby apply/existsP; exists y; rewrite /= !inE eq_sym ne_xy -mem_enum Dy eqfxy /=.\nQed.",
    "Lemma dinjectiveP D : reflect {in D &, injective f} (dinjectiveb D).\nProof.\nrewrite -[dinjectiveb D]negbK.\ncase: dinjectivePn=> [noinjf | injf]; constructor.\n  case: noinjf => x Dx [y /andP[neqxy /= Dy] eqfxy] injf.\n  by case/eqP: neqxy; apply: injf.\nmove=> x y Dx Dy /= eqfxy; apply/eqP; apply/idPn=> nxy; case: injf.\nby exists x => //; exists y => //=; rewrite inE /= eq_sym nxy.\nQed.",
    "Lemma injectivePn :\n  reflect (exists x, exists2 y, x != y & f x = f y) (~~ injectiveb).\nProof.\napply: (iffP (dinjectivePn _)) => [[x _ [y nxy eqfxy]] | [x [y nxy eqfxy]]];\n by exists x => //; exists y => //; rewrite inE /= andbT eq_sym in nxy *.\nQed.",
    "Lemma injectiveP : reflect (injective f) injectiveb.\nProof. by apply: (iffP (dinjectiveP _)) => injf x y => [|_ _]; apply: injf. Qed.",
    "Lemma size_image A : size (image f A) = #|A|.\nProof. by rewrite size_map -cardE. Qed.",
    "Lemma size_codom : size (codom f) = #|T|.\nProof. exact: size_image. Qed.",
    "Lemma codomE : codom f = map f (enum T).\nProof. by []. Qed.",
    "Lemma imageP A y : reflect (exists2 x, x \\in A & y = f x) (y \\in image f A).\nProof.\nby apply: (iffP mapP) => [] [x Ax y_fx]; exists x; rewrite // mem_enum in Ax *.\nQed.",
    "Lemma codomP y : reflect (exists x, y = f x) (y \\in codom f).\nProof. by apply: (iffP (imageP _ y)) => [][x]; exists x. Qed.",
    "Lemma f_iinv A y fAy : f (@iinv A y fAy) = y.\nProof. exact: s2valP' (iinv_proof fAy). Qed.",
    "Lemma mem_iinv A y fAy : @iinv A y fAy \\in A.\nProof. exact: s2valP (iinv_proof fAy). Qed.",
    "Lemma in_iinv_f A : {in A &, injective f} ->\n  forall x fAfx, x \\in A -> @iinv A (f x) fAfx = x.\nProof.\nby move=> injf x fAfx Ax; apply: injf => //; [apply: mem_iinv | apply: f_iinv].\nQed.",
    "Lemma preim_iinv A B y fAy : preim f B (@iinv A y fAy) = B y.\nProof. by rewrite /= f_iinv. Qed.",
    "Lemma image_f A x : x \\in A -> f x \\in image f A.\nProof. by move=> Ax; apply/imageP; exists x. Qed.",
    "Lemma codom_f x : f x \\in codom f.\nProof. exact: image_f. Qed.",
    "Lemma image_codom A : {subset image f A <= codom f}.\nProof. by move=> _ /imageP[x _ ->]; apply: codom_f. Qed.",
    "Lemma image_pred0 : image f pred0 =i pred0.\nProof. by move=> x; rewrite /image_mem /= enum0. Qed.",
    "Lemma mem_image A x : (f x \\in image f A) = (x \\in A).\nProof. by rewrite mem_map ?mem_enum. Qed.",
    "Lemma pre_image A : [preim f of image f A] =i A.\nProof. by move=> x; rewrite inE /= mem_image. Qed.",
    "Lemma image_iinv A y (fTy : y \\in codom f) :\n  (y \\in image f A) = (iinv fTy \\in A).\nProof. by rewrite -mem_image ?f_iinv. Qed.",
    "Lemma iinv_f x fTfx : @iinv T (f x) fTfx = x.\nProof. by apply: in_iinv_f; first apply: in2W. Qed.",
    "Lemma image_pre (B : pred T') : image f [preim f of B] =i [predI B & codom f].\nProof. by move=> y; rewrite /image_mem -filter_map /= mem_filter -enumT. Qed.",
    "Lemma bij_on_codom (x0 : T) : {on [pred y in codom f], bijective f}.\nProof.\npose g y := iinv (valP (insigd (codom_f x0) y)).\nby exists g => [x fAfx | y fAy]; first apply: injf; rewrite f_iinv insubdK.\nQed.",
    "Lemma bij_on_image A (x0 : T) : {on [pred y in image f A], bijective f}.\nProof. exact: subon_bij (@image_codom A) (bij_on_codom x0). Qed.",
    "Lemma map_preim (s : seq T') : {subset s <= codom f} -> map f (preim_seq s) = s.\nProof.\nelim: s => //= y s IHs; case: pickP => [x /eqP fx_y | nfTy] fTs.\n  by rewrite /= fx_y IHs // => z s_z; apply: fTs; apply: predU1r.\nby case/imageP: (fTs y (mem_head y s)) => x _ fx_y; case/eqP: (nfTy x).\nQed.",
    "Lemma flatten_imageP (aT : finType) (rT : eqType)\n                     (A : aT -> seq rT) (P : {pred aT}) (y : rT) :\n  reflect (exists2 x, x \\in P & y \\in A x) (y \\in flatten [seq A x | x in P]).\nProof.\nby apply: (iffP flatten_mapP) => [][x Px]; exists x; rewrite ?mem_enum in Px *.\nQed.",
    "Lemma leq_image_card A : #|image f A| <= #|A|.\nProof. by rewrite (cardE A) -(size_map f) card_size. Qed.",
    "Lemma card_in_image A : {in A &, injective f} -> #|image f A| = #|A|.\nProof.\nmove=> injf; rewrite (cardE A) -(size_map f); apply/card_uniqP.\nby rewrite map_inj_in_uniq ?enum_uniq // => x y; rewrite !mem_enum; apply: injf.\nQed.",
    "Lemma image_injP A : reflect {in A &, injective f} (#|image f A| == #|A|).\nProof.\napply: (iffP eqP) => [eqfA |]; last exact: card_in_image.\nby apply/dinjectiveP; apply/card_uniqP; rewrite size_map -cardE.\nQed.",
    "Lemma leq_card_in A : {in A &, injective f} -> #|A| <= #|T'|.\nProof. by move=> /card_in_image <-; rewrite max_card. Qed.",
    "Lemma card_image A : #|image f A| = #|A|.\nProof. by apply: card_in_image; apply: in2W. Qed.",
    "Lemma card_codom : #|codom f| = #|T|.\nProof. exact: card_image. Qed.",
    "Lemma card_preim (B : {pred T'}) : #|[preim f of B]| = #|[predI codom f & B]|.\nProof.\nrewrite -card_image /=; apply: eq_card => y.\nby rewrite [y \\in _]image_pre !inE andbC.\nQed.",
    "Lemma leq_card : #|T| <= #|T'|. Proof. exact: (leq_card_in (in2W _)). Qed.",
    "Lemma inj_card_onto y : y \\in codom f.\nProof. by move: y; apply/subset_cardP; rewrite ?card_codom ?subset_predT. Qed.",
    "Lemma inj_card_bij :  bijective f.\nProof.\nby exists (fun y => iinv (inj_card_onto y)) => y; rewrite ?iinv_f ?f_iinv.\nQed.",
    "Lemma bij_eq_card (T T' : finType) (f : T -> T') : bijective f -> #|T| = #|T'|.\nProof. by move=> [g /can_inj/leq_card + /can_inj/leq_card]; case: ltngtP. Qed.",
    "Lemma injF_onto y : y \\in codom f. Proof. exact: inj_card_onto. Qed.",
    "Lemma invF_f : cancel f invF. Proof. by move=> x; apply: iinv_f. Qed.",
    "Lemma f_invF : cancel invF f. Proof. by move=> y; apply: f_iinv. Qed.",
    "Lemma injF_bij : bijective f. Proof. exact: inj_card_bij. Qed.",
    "Lemma canF_sym : cancel g f.\nProof. exact/(bij_can_sym (injF_bij (can_inj fK))). Qed.",
    "Lemma canF_LR x y : x = g y -> f x = y.\nProof. exact: canLR canF_sym. Qed.",
    "Lemma canF_RL x y : g x = y -> x = f y.\nProof. exact: canRL canF_sym. Qed.",
    "Lemma canF_eq x y : (f x == y) = (x == g y).\nProof. exact: (can2_eq fK canF_sym). Qed.",
    "Lemma canF_invF : g =1 invF (can_inj fK).\nProof. by move=> y; apply: (canLR fK); rewrite f_invF. Qed.",
    "Lemma eq_image (A B : {pred T}) (f g : T -> T') :\n  A =i B -> f =1 g -> image f A = image g B.\nProof.\nby move=> eqAB eqfg; rewrite /image_mem (eq_enum eqAB) (eq_map eqfg).\nQed.",
    "Lemma eq_codom (f g : T -> T') : f =1 g -> codom f = codom g.\nProof. exact: eq_image. Qed.",
    "Lemma eq_invF f g injf injg : f =1 g -> @invF T f injf =1 @invF T g injg.\nProof.\nby move=> eq_fg x; apply: (canLR (invF_f injf)); rewrite eq_fg f_invF.\nQed.",
    "Lemma unit_enumP : Finite.axiom [::tt]. Proof. by case. Qed.",
    "Lemma card_unit : #|{: unit}| = 1. Proof. by rewrite cardT enumT unlock. Qed.",
    "Lemma bool_enumP : Finite.axiom [:: true; false]. Proof. by case. Qed.",
    "Lemma card_bool : #|{: bool}| = 2. Proof. by rewrite cardT enumT unlock. Qed.",
    "Lemma void_enumP : Finite.axiom (Nil void). Proof. by case. Qed.",
    "Lemma card_void : #|{: void}| = 0. Proof. by rewrite cardT enumT unlock. Qed.",
    "Lemma option_enumP : Finite.axiom option_enum.\nProof. by case=> [x|]; rewrite /= count_map (count_pred0, enumP). Qed.",
    "Lemma card_option : #|{: option T}| = #|T|.+1.\nProof. by rewrite !cardT !enumT [in LHS]unlock /= !size_map. Qed.",
    "Lemma pcan_enumP g : pcancel f g -> Finite.axiom (undup (pmap g (enumF fT))).\nProof.\nmove=> fK x; rewrite count_uniq_mem ?undup_uniq // mem_undup.\nby rewrite mem_pmap -fK map_f // -enumT mem_enum.\nQed.",
    "Lemma codom_val sT x : (x \\in codom (val : sT -> T)) = P x.\nProof.\nby apply/codomP/idP=> [[u ->]|Px]; last exists (Sub x Px); rewrite ?valP ?SubK.\nQed.",
    "Lemma mem_sub_enum u : u \\in sub_enum.\nProof. by rewrite mem_pmap_sub -enumT mem_enum. Qed.",
    "Lemma sub_enum_uniq : uniq sub_enum.\nProof. by rewrite pmap_sub_uniq // -enumT enum_uniq. Qed.",
    "Lemma val_sub_enum : map val sub_enum = enum P.\nProof.\nrewrite pmap_filter; last exact: insubK.\nby apply: eq_filter => x; apply: isSome_insub.\nQed.",
    "Lemma card_sub : #|sfT| = #|[pred x | P x]|.\nProof. by rewrite -(eq_card (codom_val sfT)) (card_image val_inj). Qed.",
    "Lemma eq_card_sub (A : {pred sfT}) : A =i predT -> #|A| = #|[pred x | P x]|.\nProof. exact: eq_card_trans card_sub. Qed.",
    "Lemma card_sig : #|{: {x | P x}}| = #|[pred x | P x]|.\nProof. exact: card_sub. Qed.",
    "Lemma mem_seq_sub_enum x : x \\in seq_sub_enum.\nProof. by rewrite mem_undup mem_pmap -valK map_f ?ssvalP. Qed.",
    "Lemma val_seq_sub_enum : uniq s -> map val seq_sub_enum = s.\nProof.\nmove=> Us; rewrite /seq_sub_enum undup_id ?pmap_sub_uniq //.\nrewrite (pmap_filter (insubK _)); apply/all_filterP.\nby apply/allP => x; rewrite isSome_insub.\nQed.",
    "Lemma seq_sub_pickleK : pcancel seq_sub_pickle seq_sub_unpickle.\nProof.\nrewrite /seq_sub_unpickle => x.\nby rewrite (nth_map x) ?nth_index ?index_mem ?mem_seq_sub_enum.\nQed.",
    "Lemma seq_sub_default s : size s > 0 -> seq_sub s.\nProof. by case: s => // x s _; exists x; rewrite mem_head. Qed.",
    "Lemma seq_subE s (s_gt0 : size s > 0) :\n  s = map val (map (insubd (seq_sub_default s_gt0)) s : seq (seq_sub s)).\nProof. by rewrite -map_comp map_id_in// => x x_in_s /=; rewrite insubdK. Qed.",
    "Lemma card_seq_sub : uniq s -> #|{:sT}| = size s.\nProof.\nby move=> Us; rewrite cardE enumT -(size_map val) unlock val_seq_sub_enum.\nQed.",
    "Lemma extremumP : extremum_spec ord P F extremum.\nProof.\nrewrite /extremum; case: pickP => [i /andP[Pi /'forall_implyP/= min_i] | no_i].\n  by split=> // j; apply/implyP.\nhave := sort_sorted ord_total [seq F i | i <- enum P].\nset s := sort _ _ => ss; have s_gt0 : size s > 0\n   by rewrite size_sort size_map -cardE; apply/card_gt0P; exists i0.\npose t0 := nth (F i0) s 0; have: t0 \\in s by rewrite mem_nth.\nrewrite mem_sort => /mapP/sig2_eqW[it0]; rewrite mem_enum => it0P def_t0.\nhave /negP[/=] := no_i it0; rewrite [P _]it0P/=; apply/'forall_implyP=> j Pj.\nhave /(nthP (F i0))[k g_lt <-] : F j \\in s by rewrite mem_sort map_f ?mem_enum.\nby rewrite -def_t0 sorted_leq_nth.\nQed.",
    "Lemma extremum_inP : extremum_spec ord P F (extremum ord i0 P F).\nProof.\nrewrite /extremum; case: pickP => [i /andP[Pi /'forall_implyP/= min_i] | no_i].\n  by split=> // j; apply/implyP.\npose TP := seq_sub [seq F i | i <- enum P].\nhave FPP (iP : {i | P i}) : F (proj1_sig iP) \\in [seq F i | i <- enum P].\n  by rewrite map_f// mem_enum; apply: valP.\npose FP := SeqSub (FPP _).\nhave []//= := @extremumP _ _ (relpre val ord) (exist P i0 Pi0) xpredT FP.\n- by move=> [/= _/mapP[i iP ->]]; apply: ord_refl; rewrite mem_enum in iP.\n- move=> [/= _/mapP[j jP ->]] [/= _/mapP[i iP ->]] [/= _/mapP[k kP ->]].\n  by apply: ord_trans; rewrite !mem_enum in iP jP kP.\n- move=> [/= _/mapP[i iP ->]] [/= _/mapP[j jP ->]].\n  by apply: ord_total; rewrite !mem_enum in iP jP.\n- rewrite /FP => -[/= i Pi] _ /(_ (exist _ _ _))/= ordF.\n  have /negP/negP/= := no_i i; rewrite Pi/= negb_forall => /existsP/sigW[j].\n  by rewrite negb_imply => /andP[Pj]; rewrite ordF.\nQed.",
    "Lemma arg_minnP : extremum_spec leq P F arg_min.\nProof. by apply: extremumP => //; [apply: leq_trans|apply: leq_total]. Qed.",
    "Lemma arg_maxnP : extremum_spec geq P F arg_max.\nProof.\napply: extremumP => //; first exact: leqnn.\n  by move=> n m p mn np; apply: leq_trans mn.\nby move=> ??; apply: leq_total.\nQed.",
    "Lemma ltn_ord (i : ordinal) : i < n. Proof. exact: valP i. Qed.",
    "Lemma ord_inj : injective nat_of_ord. Proof. exact: val_inj. Qed.",
    "Lemma val_ord_enum : map val ord_enum = iota 0 n.\nProof.\nrewrite pmap_filter; last exact: insubK.\nby apply/all_filterP; apply/allP=> i; rewrite mem_iota isSome_insub.\nQed.",
    "Lemma ord_enum_uniq : uniq ord_enum.\nProof. by rewrite pmap_sub_uniq ?iota_uniq. Qed.",
    "Lemma mem_ord_enum i : i \\in ord_enum.\nProof. by rewrite -(mem_map ord_inj) val_ord_enum mem_iota ltn_ord. Qed.",
    "Lemma val_enum_ord : map val (enum 'I_n) = iota 0 n.\nProof. by rewrite enumT unlock val_ord_enum. Qed.",
    "Lemma size_enum_ord : size (enum 'I_n) = n.\nProof. by rewrite -(size_map val) val_enum_ord size_iota. Qed.",
    "Lemma card_ord : #|'I_n| = n.\nProof. by rewrite cardE size_enum_ord. Qed.",
    "Lemma nth_enum_ord i0 m : m < n -> nth i0 (enum 'I_n) m = m :> nat.\nProof.\nby move=> ?; rewrite -(nth_map _ 0) (size_enum_ord, val_enum_ord) // nth_iota.\nQed.",
    "Lemma nth_ord_enum (i0 i : 'I_n) : nth i0 (enum 'I_n) i = i.\nProof. by apply: val_inj; apply: nth_enum_ord. Qed.",
    "Lemma index_enum_ord (i : 'I_n) : index i (enum 'I_n) = i.\nProof.\nby rewrite -[in LHS](nth_ord_enum i i) index_uniq ?(enum_uniq, size_enum_ord).\nQed.",
    "Lemma mask_enum_ord m :\n  mask m (enum 'I_n) = [seq i <- enum 'I_n | nth false m (val i)].\nProof.\nrewrite mask_filter ?enum_uniq//; apply: eq_filter => i.\nby rewrite in_mask ?enum_uniq ?mem_enum// index_enum_ord.\nQed.",
    "Lemma enum_ord0 : enum 'I_0 = [::].\nProof. by apply/eqP; rewrite -size_eq0 size_enum_ord. Qed.",
    "Lemma widen_ord_proof n m (i : 'I_n) : n <= m -> i < m.\nProof. exact: leq_trans. Qed.",
    "Lemma cast_ord_proof n m (i : 'I_n) : n = m -> i < m.\nProof. by move <-. Qed.",
    "Lemma cast_ord_id n eq_n i : cast_ord eq_n i = i :> 'I_n.\nProof. exact: val_inj. Qed.",
    "Lemma cast_ord_comp n1 n2 n3 eq_n2 eq_n3 i :\n  @cast_ord n2 n3 eq_n3 (@cast_ord n1 n2 eq_n2 i) =\n    cast_ord (etrans eq_n2 eq_n3) i.\nProof. exact: val_inj. Qed.",
    "Lemma cast_ordK n1 n2 eq_n :\n  cancel (@cast_ord n1 n2 eq_n) (cast_ord (esym eq_n)).\nProof. by move=> i; apply: val_inj. Qed.",
    "Lemma cast_ordKV n1 n2 eq_n :\n  cancel (cast_ord (esym eq_n)) (@cast_ord n1 n2 eq_n).\nProof. by move=> i; apply: val_inj. Qed.",
    "Lemma cast_ord_inj n1 n2 eq_n : injective (@cast_ord n1 n2 eq_n).\nProof. exact: can_inj (cast_ordK eq_n). Qed.",
    "Lemma ordSK n : cancel (@ordS n) (@ord_pred n).\nProof.\nmove=> [i ilt]; apply/val_inj => /=.\ncase: (ltngtP i.+1) (ilt) => // [Silt|<-]; last by rewrite modnn/= modn_small.\nby rewrite [i.+1 %% n]modn_small// addSn/= modnDr modn_small.\nQed.",
    "Lemma ord_predK n : cancel (@ord_pred n) (@ordS n).\nProof.\nmove=> [[|i] ilt]; apply/val_inj => /=.\n  by rewrite [n.-1 %% n]modn_small// prednK// modnn.\nby rewrite modnDr [i %% n]modn_small ?modn_small// ltnW.\nQed.",
    "Lemma ordS_bij n : bijective (@ordS n).\nProof. exact: (Bijective (@ordSK n) (@ord_predK n)). Qed.",
    "Lemma ordS_inj n : injective (@ordS n).\nProof. exact: (bij_inj (ordS_bij n)). Qed.",
    "Lemma ord_pred_bij n : bijective (@ord_pred n).\nProof. exact (Bijective (@ord_predK n) (@ordSK n)). Qed.",
    "Lemma ord_pred_inj n : injective (@ord_pred n).\nProof. exact: (bij_inj (ord_pred_bij n)). Qed.",
    "Lemma rev_ord_proof n (i : 'I_n) : n - i.+1  < n.\nProof. by case: n i => [|n] [i lt_i_n] //; rewrite ltnS subSS leq_subr. Qed.",
    "Lemma rev_ordK {n} : involutive (@rev_ord n).\nProof.\nby case: n => [|n] [i lti] //; apply: val_inj; rewrite /= !subSS subKn.\nQed.",
    "Lemma rev_ord_inj {n} : injective (@rev_ord n).\nProof. exact: inv_inj rev_ordK. Qed.",
    "Lemma inj_leq m n (f : 'I_m -> 'I_n) : injective f -> m <= n.\nProof. by move=> /leq_card; rewrite !card_ord. Qed.",
    "Lemma enum_rank_subproof (T : finType) x0 (A : {pred T}) : x0 \\in A -> 0 < #|A|.\nProof. by move=> Ax0; rewrite (cardD1 x0) Ax0. Qed.",
    "Lemma enum_default A : 'I_(#|A|) -> T.\nProof. by rewrite cardE; case: (enum A) => [|//] []. Qed.",
    "Lemma enum_valP A i : @enum_val A i \\in A.\nProof. by rewrite -mem_enum mem_nth -?cardE. Qed.",
    "Lemma enum_val_nth A x i : @enum_val A i = nth x (enum A) i.\nProof. by apply: set_nth_default; rewrite cardE in i *; apply: ltn_ord. Qed.",
    "Lemma nth_image T' y0 (f : T -> T') A (i : 'I_#|A|) :\n  nth y0 (image f A) i = f (enum_val i).\nProof. by rewrite -(nth_map _ y0) // -cardE. Qed.",
    "Lemma nth_codom T' y0 (f : T -> T') (i : 'I_#|T|) :\n  nth y0 (codom f) i = f (enum_val i).\nProof. exact: nth_image. Qed.",
    "Lemma nth_enum_rank_in x00 x0 A Ax0 :\n  {in A, cancel (@enum_rank_in T x0 A Ax0) (nth x00 (enum A))}.\nProof.\nmove=> x Ax; rewrite enum_rank_in.unlock insubdK ?nth_index ?mem_enum //.\nby rewrite cardE [_ \\in _]index_mem mem_enum.\nQed.",
    "Lemma nth_enum_rank x0 : cancel enum_rank (nth x0 (enum T)).\nProof. by move=> x; apply: nth_enum_rank_in. Qed.",
    "Lemma enum_rankK_in x0 A Ax0 :\n   {in A, cancel (@enum_rank_in T x0 A Ax0) enum_val}.\nProof. by move=> x; apply: nth_enum_rank_in. Qed.",
    "Lemma enum_rankK : cancel enum_rank enum_val.\nProof. by move=> x; apply: enum_rankK_in. Qed.",
    "Lemma enum_valK_in x0 A Ax0 : cancel enum_val (@enum_rank_in T x0 A Ax0).\nProof.\nmove=> x; apply: ord_inj; rewrite enum_rank_in.unlock insubdK; last first.\n  by rewrite cardE [_ \\in _]index_mem mem_nth // -cardE.\nby rewrite index_uniq ?enum_uniq // -cardE.\nQed.",
    "Lemma enum_valK : cancel enum_val enum_rank.\nProof. by move=> x; apply: enum_valK_in. Qed.",
    "Lemma enum_rank_inj : injective enum_rank.\nProof. exact: can_inj enum_rankK. Qed.",
    "Lemma enum_val_inj A : injective (@enum_val A).\nProof. by move=> i; apply: can_inj (enum_valK_in (enum_valP i)) (i). Qed.",
    "Lemma enum_val_bij_in x0 A : x0 \\in A -> {on A, bijective (@enum_val A)}.\nProof.\nmove=> Ax0; exists (enum_rank_in Ax0) => [i _|]; last exact: enum_rankK_in.\nexact: enum_valK_in.\nQed.",
    "Lemma eq_enum_rank_in (x0 y0 : T) A (Ax0 : x0 \\in A) (Ay0 : y0 \\in A) :\n  {in A, enum_rank_in Ax0 =1 enum_rank_in Ay0}.\nProof. by move=> x xA; apply: enum_val_inj; rewrite !enum_rankK_in. Qed.",
    "Lemma enum_rank_in_inj (x0 y0 : T) A (Ax0 : x0 \\in A) (Ay0 : y0 \\in A) :\n  {in A &, forall x y, enum_rank_in Ax0 x = enum_rank_in Ay0 y -> x = y}.\nProof. by move=> x y xA yA /(congr1 enum_val); rewrite !enum_rankK_in. Qed.",
    "Lemma enum_rank_bij : bijective enum_rank.\nProof. by move: enum_rankK enum_valK; exists (@enum_val T). Qed.",
    "Lemma enum_val_bij : bijective (@enum_val T).\nProof. by move: enum_rankK enum_valK; exists enum_rank. Qed.",
    "Lemma fin_all_exists U (P : forall x : T, U x -> Prop) :\n  (forall x, exists u, P x u) -> (exists u, forall x, P x (u x)).\nProof.\nmove=> ex_u; pose Q m x := enum_rank x < m -> {ux | P x ux}.\nsuffices: forall m, m <= #|T| -> exists w : forall x, Q m x, True.\n  case/(_ #|T|)=> // w _; pose u x := sval (w x (ltn_ord _)).\n  by exists u => x; rewrite {}/u; case: (w x _).\nelim=> [|m IHm] ltmX; first by have w x: Q 0 x by []; exists w.\nhave{IHm} [w _] := IHm (ltnW ltmX); pose i := Ordinal ltmX.\nhave [u Pu] := ex_u (enum_val i); suffices w' x: Q m.+1 x by exists w'.\nrewrite /Q ltnS leq_eqVlt (val_eqE _ i); case: eqP => [def_i _ | _ /w //].\nby rewrite -def_i enum_rankK in u Pu; exists u.\nQed.",
    "Lemma fin_all_exists2 U (P Q : forall x : T, U x -> Prop) :\n    (forall x, exists2 u, P x u & Q x u) ->\n  (exists2 u, forall x, P x (u x) & forall x, Q x (u x)).\nProof.\nmove=> ex_u; have (x): exists u, P x u /\\ Q x u by have [u] := ex_u x; exists u.\nby case/fin_all_exists=> u /all_and2[]; exists u.\nQed.",
    "Lemma enum_rank_ord n i : enum_rank i = cast_ord (esym (card_ord n)) i.\nProof.\napply: val_inj; rewrite /enum_rank enum_rank_in.unlock.\nby rewrite insubdK ?index_enum_ord // card_ord [_ \\in _]ltn_ord.\nQed.",
    "Lemma enum_val_ord n i : enum_val i = cast_ord (card_ord n) i.\nProof.\nby apply: canLR (@enum_rankK _) _; apply: val_inj; rewrite enum_rank_ord.\nQed.",
    "Lemma bumpK h : cancel (bump h) (unbump h).\nProof.\nrewrite /bump /unbump => i.\nhave [le_hi | lt_ih] := leqP h i; first by rewrite ltnS le_hi subn1.\nby rewrite ltnNge ltnW ?subn0.\nQed.",
    "Lemma neq_bump h i : h != bump h i.\nProof.\nrewrite /bump eqn_leq; have [le_hi | lt_ih] := leqP h i.\n  by rewrite ltnNge le_hi andbF.\nby rewrite leqNgt lt_ih.\nQed.",
    "Lemma unbumpKcond h i : bump h (unbump h i) = (i == h) + i.\nProof.\nrewrite /bump /unbump leqNgt -subSKn.\ncase: (ltngtP i h) => /= [-> | ltih | ->] //; last by rewrite ltnn.\nby rewrite subn1 /= leqNgt !(ltn_predK ltih, ltih, add1n).\nQed.",
    "Lemma unbumpK {h} : {in predC1 h, cancel (unbump h) (bump h)}.\nProof. by move=> i /negbTE-neq_h_i; rewrite unbumpKcond neq_h_i. Qed.",
    "Lemma bumpDl h i k : bump (k + h) (k + i) = k + bump h i.\nProof. by rewrite /bump leq_add2l addnCA. Qed.",
    "Lemma bumpS h i : bump h.+1 i.+1 = (bump h i).+1.\nProof. exact: addnS. Qed.",
    "Lemma unbumpDl h i k : unbump (k + h) (k + i) = k + unbump h i.\nProof.\napply: (can_inj (bumpK (k + h))).\nby rewrite bumpDl !unbumpKcond eqn_add2l addnCA.\nQed.",
    "Lemma unbumpS h i : unbump h.+1 i.+1 = (unbump h i).+1.\nProof. exact: unbumpDl 1. Qed.",
    "Lemma leq_bump h i j : (i <= bump h j) = (unbump h i <= j).\nProof.\nrewrite /bump leq_subLR.\ncase: (leqP i h) (leqP h j) => [le_i_h | lt_h_i] [le_h_j | lt_j_h] //.\n  by rewrite leqW (leq_trans le_i_h).\nby rewrite !(leqNgt i) ltnW (leq_trans _ lt_h_i).\nQed.",
    "Lemma leq_bump2 h i j : (bump h i <= bump h j) = (i <= j).\nProof. by rewrite leq_bump bumpK. Qed.",
    "Lemma bumpC h1 h2 i :\n  bump h1 (bump h2 i) = bump (bump h1 h2) (bump (unbump h2 h1) i).\nProof.\nrewrite {1 5}/bump -leq_bump addnCA; congr (_ + (_ + _)).\nrewrite 2!leq_bump /unbump /bump; case: (leqP h1 h2) => [le_h12 | lt_h21].\n  by rewrite subn0 ltnS le_h12 subn1.\nby rewrite subn1 (ltn_predK lt_h21) (leqNgt h1) lt_h21 subn0.\nQed.",
    "Lemma lift_subproof n h (i : 'I_n.-1) : bump h i < n.\nProof. by case: n i => [[]|n] //= i; rewrite -addnS (leq_add (leq_b1 _)). Qed.",
    "Lemma unlift_subproof n (h : 'I_n) (u : {j | j != h}) : unbump h (val u) < n.-1.\nProof.\ncase: n h u => [|n h] [] //= j ne_jh.\nrewrite -(leq_bump2 h.+1) bumpS unbumpK // /bump.\ncase: (ltngtP n h) => [|_|eq_nh]; rewrite ?(leqNgt _ h) ?ltn_ord //.\nby rewrite ltn_neqAle [j <= _](valP j) {2}eq_nh andbT.\nQed.",
    "Lemma unliftP n (h i : 'I_n) : unlift_spec h i (unlift h i).\nProof.\nrewrite /unlift; case: insubP => [u nhi | ] def_i /=; constructor.\n  by apply: val_inj; rewrite /= def_i unbumpK.\nby rewrite negbK in def_i; apply/eqP.\nQed.",
    "Lemma neq_lift n (h : 'I_n) i : h != lift h i.\nProof. exact: neq_bump. Qed.",
    "Lemma eq_liftF n (h : 'I_n) i : (h == lift h i) = false.\nProof. exact/negbTE/neq_lift. Qed.",
    "Lemma lift_eqF n (h : 'I_n) i : (lift h i == h) = false.\nProof. by rewrite eq_sym eq_liftF. Qed.",
    "Lemma unlift_none n (h : 'I_n) : unlift h h = None.\nProof. by case: unliftP => // j Dh; case/eqP: (neq_lift h j). Qed.",
    "Lemma unlift_some n (h i : 'I_n) :\n  h != i -> {j | i = lift h j & unlift h i = Some j}.\nProof.\nrewrite eq_sym => /eqP neq_ih.\nby case Dui: (unlift h i) / (unliftP h i) => [j Dh|//]; exists j.\nQed.",
    "Lemma lift_inj n (h : 'I_n) : injective (lift h).\nProof. by move=> i1 i2 [/(can_inj (bumpK h))/val_inj]. Qed.",
    "Lemma liftK n (h : 'I_n) : pcancel (lift h) (unlift h).\nProof. by move=> i; case: (unlift_some (neq_lift h i)) => j /lift_inj->. Qed.",
    "Lemma lshift_subproof m n (i : 'I_m) : i < m + n.\nProof. by apply: leq_trans (valP i) _; apply: leq_addr. Qed.",
    "Lemma rshift_subproof m n (i : 'I_n) : m + i < m + n.\nProof. by rewrite ltn_add2l. Qed.",
    "Lemma lshift_inj m n : injective (@lshift m n).\nProof. by move=> ? ? /(f_equal val) /= /val_inj. Qed.",
    "Lemma rshift_inj m n : injective (@rshift m n).\nProof. by move=> ? ? /(f_equal val) /addnI /val_inj. Qed.",
    "Lemma eq_lshift m n i j : (@lshift m n i == @lshift m n j) = (i == j).\nProof. by rewrite (inj_eq (@lshift_inj _ _)). Qed.",
    "Lemma eq_rshift m n i j : (@rshift m n i == @rshift m n j) = (i == j).\nProof. by rewrite (inj_eq (@rshift_inj _ _)). Qed.",
    "Lemma eq_lrshift m n i j : (@lshift m n i == @rshift m n j) = false.\nProof.\napply/eqP=> /(congr1 val)/= def_i; have := ltn_ord i.\nby rewrite def_i -ltn_subRL subnn.\nQed.",
    "Lemma eq_rlshift m n i j : (@rshift m n i == @lshift m n j) = false.\nProof. by rewrite eq_sym eq_lrshift. Qed.",
    "Lemma split_subproof m n (i : 'I_(m + n)) : i >= m -> i - m < n.\nProof. by move/subSn <-; rewrite leq_subLR. Qed.",
    "Lemma splitP m n (i : 'I_(m + n)) : split_spec i (split i) (i < m).\nProof.\n\n\n\n\nset lt_i_m := i < m; rewrite /split.\nby case: _ _ _ _ {-}_ lt_i_m / ltnP; [left | right; rewrite subnKC].\nQed.",
    "Lemma split_ordP m n (i : 'I_(m + n)) : split_ord_spec i (split i) (i < m).\nProof. by case: splitP; [left|right]; apply: val_inj. Qed.",
    "Lemma ltn_unsplit m n (jk : 'I_m + 'I_n) : (unsplit jk < m) = jk.\nProof. by case: jk => [j|k]; rewrite /= ?ltn_ord // ltnNge leq_addr. Qed.",
    "Lemma splitK {m n} : cancel (@split m n) unsplit.\nProof. by move=> i; case: split_ordP. Qed.",
    "Lemma unsplitK {m n} : cancel (@unsplit m n) split.\nProof.\nby move=> [j|k]; case: split_ordP => ? /eqP; rewrite eq_shift// => /eqP->.\nQed.",
    "Lemma leq_ord (i : 'I_n) : i <= n'. Proof. exact: valP i. Qed.",
    "Lemma sub_ord_proof m : n' - m < n.\nProof.  by rewrite ltnS leq_subr. Qed.",
    "Lemma sub_ordK (i : 'I_n) : n' - (n' - i) = i.\nProof. by rewrite subKn ?leq_ord. Qed.",
    "Lemma inordK m : m < n -> inord m = m :> nat.\nProof. by move=> lt_m; rewrite val_insubd lt_m. Qed.",
    "Lemma inord_val (i : 'I_n) : inord i = i.\nProof. by rewrite /inord /insubd valK. Qed.",
    "Lemma enum_ordSl : enum 'I_n = ord0 :: map (lift ord0) (enum 'I_n').\nProof.\napply: (inj_map val_inj); rewrite val_enum_ord /= -map_comp.\nby rewrite (map_comp (addn 1)) val_enum_ord -iotaDl.\nQed.",
    "Lemma enum_ordSr :\n  enum 'I_n = rcons (map (widen_ord (leqnSn _)) (enum 'I_n')) ord_max.\nProof.\napply: (inj_map val_inj); rewrite val_enum_ord.\nrewrite -[in iota _  _]addn1 iotaD/= cats1 map_rcons; congr (rcons _ _).\nby rewrite -map_comp/= (@eq_map _ _ _ val) ?val_enum_ord.\nQed.",
    "Lemma lift_max (i : 'I_n') : lift ord_max i = i :> nat.\nProof. by rewrite /= /bump leqNgt ltn_ord. Qed.",
    "Lemma lift0 (i : 'I_n') : lift ord0 i = i.+1 :> nat. Proof. by []. Qed.",
    "Lemma ord1 : all_equal_to (ord0 : 'I_1).\nProof. by case=> [[] // ?]; apply: val_inj. Qed.",
    "Lemma predX_prod_enum (A1 : {pred T1}) (A2 : {pred T2}) :\n  count [predX A1 & A2] prod_enum = #|A1| * #|A2|.\nProof.\nrewrite !cardE !size_filter -!enumT /prod_enum.\nelim: (enum T1) => //= x1 s1 IHs; rewrite count_cat {}IHs count_map /preim /=.\nby case: (x1 \\in A1); rewrite ?count_pred0.\nQed.",
    "Lemma prod_enumP : Finite.axiom prod_enum.\nProof.\nby case=> x1 x2; rewrite (predX_prod_enum (pred1 x1) (pred1 x2)) !card1.\nQed.",
    "Lemma cardX (A1 : {pred T1}) (A2 : {pred T2}) :\n  #|[predX A1 & A2]| = #|A1| * #|A2|.\nProof. by rewrite -predX_prod_enum unlock size_filter unlock. Qed.",
    "Lemma card_prod : #|{: T1 * T2}| = #|T1| * #|T2|.\nProof. by rewrite -cardX; apply: eq_card; case. Qed.",
    "Lemma eq_card_prod (A : {pred (T1 * T2)}) : A =i predT -> #|A| = #|T1| * #|T2|.\nProof. exact: eq_card_trans card_prod. Qed.",
    "Lemma tag_enumP : Finite.axiom tag_enum.\nProof.\ncase=> i x; rewrite -(enumP i) /tag_enum -enumT.\nelim: (enum I) => //= j e IHe.\nrewrite count_cat count_map {}IHe; congr (_ + _).\nrewrite -size_filter -cardE /=; case: eqP => [-> | ne_j_i].\n  by apply: (@eq_card1 _ x) => y; rewrite -topredE /= tagged_asE ?eqxx.\nby apply: eq_card0 => y.\nQed.",
    "Lemma card_tagged :\n  #|{: {i : I & T_ i}}| = sumn (map (fun i => #|T_ i|) (enum I)).\nProof.\nrewrite cardE !enumT [in LHS]unlock size_flatten /shape -map_comp.\nby congr (sumn _); apply: eq_map => i; rewrite /= size_map -enumT -cardE.\nQed.",
    "Lemma sum_enum_uniq : uniq sum_enum.\nProof.\nrewrite cat_uniq -!enumT !(enum_uniq, map_inj_uniq); try by move=> ? ? [].\nby rewrite andbT; apply/hasP=> [[_ /mapP[x _ ->] /mapP[]]].\nQed.",
    "Lemma mem_sum_enum u : u \\in sum_enum.\nProof. by case: u => x; rewrite mem_cat -!enumT map_f ?mem_enum ?orbT. Qed.",
    "Lemma card_sum : #|{: T1 + T2}| = #|T1| + #|T2|.\nProof. by rewrite !cardT !enumT [in LHS]unlock size_cat !size_map. Qed.",
    "Lemma classic_sigW T (P : T -> Prop) :\n  classically (exists x, P x) <-> classically ({x | P x}).\nProof. by split; apply: classic_bind => -[x Px]; apply/classicW; exists x. Qed.",
    "Lemma classic_ex T (P : T -> Prop) :\n  ~ (forall x, ~ P x) -> classically (exists x, P x).\nProof.\nmove=> NfNP; apply/classicP => exPF; apply: NfNP => x Px.\nby apply: exPF; exists x.\nQed.",
    "Lemma homo_mono1 [aT rT : Type] [f : aT -> rT] [g : rT -> aT]\n    [aP : pred aT] [rP : pred rT] :\n  cancel g f ->\n  {homo f : x / aP x >-> rP x} ->\n  {homo g : x / rP x >-> aP x} -> {mono g : x / rP x >-> aP x}.\nProof. by move=> gK fP gP x; apply/idP/idP => [/fP|/gP//]; rewrite gK. Qed.",
    "Lemma if_and b1 b2 T (x y : T) :\n  (if b1 && b2 then x else y) = (if b1 then if b2 then x else y else y).\nProof. by case: b1 b2 => [] []. Qed.",
    "Lemma if_or b1 b2 T (x y : T) :\n  (if b1 || b2 then x else y) = (if b1 then x else if b2 then x else y).\nProof. by case: b1 b2 => [] []. Qed.",
    "Lemma if_implyb b1 b2 T (x y : T) :\n  (if b1 ==> b2 then x else y) = (if b1 then if b2 then x else y else x).\nProof. by case: b1 b2 => [] []. Qed.",
    "Lemma if_implybC b1 b2 T (x y : T) :\n  (if b1 ==> b2 then x else y) = (if b2 then x else if b1 then y else x).\nProof. by case: b1 b2 => [] []. Qed.",
    "Lemma if_add b1 b2 T (x y : T) :\n  (if b1 (+) b2 then x else y) = (if b1 then if b2 then y else x else if b2 then x else y).\nProof. by case: b1 b2 => [] []. Qed.",
    "Lemma relpre_trans {T' T : Type} {leT : rel T} {f : T' -> T} :\n  transitive leT -> transitive (relpre f leT).\nProof. by move=> + y x z; apply. Qed.",
    "Lemma inj_omap {aT rT : Type} (f : aT -> rT) :\n  injective f -> injective (omap f).\nProof. by move=> injf [?|] [?|] //= [/injf->]. Qed.",
    "Lemma omap_id {T : Type} (x : option T) : omap id x = x.\nProof. by case: x. Qed.",
    "Lemma eq_omap {aT rT : Type} (f g : aT -> rT) : f =1 g -> omap f =1 omap g.\nProof. by move=> Ef [?|] //=; rewrite Ef. Qed.",
    "Lemma omapK {aT rT : Type} (f : aT -> rT) (g : rT -> aT) :\n  cancel f g -> cancel (omap f) (omap g).\nProof. by move=> fK [?|] //=; rewrite fK. Qed.",
    "Lemma inr_inj {A B} : injective (@inr A B). Proof. by move=> ? ? []. Qed.",
    "Lemma inl_inj {A B} : injective (@inl A B). Proof. by move=> ? ? []. Qed.",
    "Lemma edivnP m d : edivn_spec m d (edivn m d).\nProof.\nrewrite -[m in edivn_spec m]/(0 * d + m) /edivn; case: d => //= d.\nelim/ltn_ind: m 0 => -[|m] IHm q //=; rewrite subn_if_gt.\ncase: ltnP => // le_dm; rewrite -[in m.+1](subnKC le_dm) -addSn.\nby rewrite addnA -mulSnr; apply/IHm/leq_subr.\nQed.",
    "Lemma edivn_eq d q r : r < d -> edivn (q * d + r) d = (q, r).\nProof.\nmove=> lt_rd; have d_gt0: 0 < d by apply: leq_trans lt_rd.\ncase: edivnP lt_rd => q' r'; rewrite d_gt0 /=.\nwlog: q q' r r' / q <= q' by case/orP: (leq_total q q'); last symmetry; eauto.\nhave [||-> _ /addnI ->] //= := ltngtP q q'.\nrewrite -(leq_pmul2r d_gt0) => /leq_add lt_qr _ eq_qr _ /lt_qr {lt_qr}.\nby rewrite addnS ltnNge mulSn -addnA eq_qr addnCA addnA leq_addr.\nQed.",
    "Lemma modn_def m d : m %% d = (edivn m d).2.\nProof.\ncase: d => //= d; rewrite /modn /edivn /=; elim/ltn_ind: m 0 => -[|m] IHm q //=.\nby rewrite !subn_if_gt; case: (d <= m) => //; apply/IHm/leq_subr.\nQed.",
    "Lemma edivn_def m d : edivn m d = (m %/ d, m %% d).\nProof. by rewrite /divn modn_def; case: (edivn m d). Qed.",
    "Lemma divn_eq m d : m = m %/ d * d + m %% d.\nProof. by rewrite /divn modn_def; case: edivnP. Qed.",
    "Lemma div0n d : 0 %/ d = 0. Proof. by case: d. Qed.",
    "Lemma divn0 m : m %/ 0 = 0. Proof. by []. Qed.",
    "Lemma mod0n d : 0 %% d = 0. Proof. by case: d. Qed.",
    "Lemma modn0 m : m %% 0 = m. Proof. by []. Qed.",
    "Lemma divn_small m d : m < d -> m %/ d = 0.\nProof. by move=> lt_md; rewrite /divn (edivn_eq 0). Qed.",
    "Lemma divnMDl q m d : 0 < d -> (q * d + m) %/ d = q + m %/ d.\nProof.\nmove=> d_gt0; rewrite [in LHS](divn_eq m d) addnA -mulnDl.\nby rewrite /divn edivn_eq // modn_def; case: edivnP; rewrite d_gt0.\nQed.",
    "Lemma mulnK m d : 0 < d -> m * d %/ d = m.\nProof. by move=> d_gt0; rewrite -[m * d]addn0 divnMDl // div0n addn0. Qed.",
    "Lemma mulKn m d : 0 < d -> d * m %/ d = m.\nProof. by move=> d_gt0; rewrite mulnC mulnK. Qed.",
    "Lemma expnB p m n : p > 0 -> m >= n -> p ^ (m - n) = p ^ m %/ p ^ n.\nProof.\nby move=> p_gt0 /subnK-Dm; rewrite -[in RHS]Dm expnD mulnK // expn_gt0 p_gt0.\nQed.",
    "Lemma modn1 m : m %% 1 = 0.\nProof. by rewrite modn_def; case: edivnP => ? []. Qed.",
    "Lemma divn1 m : m %/ 1 = m.\nProof. by rewrite [RHS](@divn_eq m 1) // modn1 addn0 muln1. Qed.",
    "Lemma divnn d : d %/ d = (0 < d).\nProof. by case: d => // d; rewrite -[n in n %/ _]muln1 mulKn. Qed.",
    "Lemma divnMl p m d : p > 0 -> p * m %/ (p * d) = m %/ d.\nProof.\nmove=> p_gt0; have [->|d_gt0] := posnP d; first by rewrite muln0.\nrewrite [RHS]/divn; case: edivnP; rewrite d_gt0 /= => q r ->{m} lt_rd.\nrewrite mulnDr mulnCA divnMDl; last by rewrite muln_gt0 p_gt0.\nby rewrite addnC divn_small // ltn_pmul2l.\nQed.",
    "Lemma divnMr p m d : p > 0 -> m * p %/ (d * p) = m %/ d.\nProof. by move=> p_gt0; rewrite -!(mulnC p) divnMl. Qed.",
    "Lemma ltn_mod m d : (m %% d < d) = (0 < d).\nProof. by case: d => // d; rewrite modn_def; case: edivnP. Qed.",
    "Lemma ltn_pmod m d : 0 < d -> m %% d < d.\nProof. by rewrite ltn_mod. Qed.",
    "Lemma leq_divM m d : m %/ d * d <= m.\nProof. by rewrite [leqRHS](divn_eq m d) leq_addr. Qed.",
    "Lemma leq_mod m d : m %% d <= m.\nProof. by rewrite [leqRHS](divn_eq m d) leq_addl. Qed.",
    "Lemma leq_div m d : m %/ d <= m.\nProof.\nby case: d => // d; apply: leq_trans (leq_pmulr _ _) (leq_divM _ _).\nQed.",
    "Lemma ltn_ceil m d : 0 < d -> m < (m %/ d).+1 * d.\nProof.\nby move=> d_gt0; rewrite [in m.+1](divn_eq m d) -addnS mulSnr leq_add2l ltn_mod.\nQed.",
    "Lemma ltn_divLR m n d : d > 0 -> (m %/ d < n) = (m < n * d).\nProof.\nmove=> d_gt0; apply/idP/idP.\n  by rewrite -(leq_pmul2r d_gt0); apply: leq_trans (ltn_ceil _ _).\nrewrite !ltnNge -(@leq_pmul2r d n) //; apply: contra => le_nd_floor.\nexact: leq_trans le_nd_floor (leq_divM _ _).\nQed.",
    "Lemma leq_divRL m n d : d > 0 -> (m <= n %/ d) = (m * d <= n).\nProof. by move=> d_gt0; rewrite leqNgt ltn_divLR // -leqNgt. Qed.",
    "Lemma ltn_Pdiv m d : 1 < d -> 0 < m -> m %/ d < m.\nProof. by move=> d_gt1 m_gt0; rewrite ltn_divLR ?ltn_Pmulr // ltnW. Qed.",
    "Lemma divn_gt0 d m : 0 < d -> (0 < m %/ d) = (d <= m).\nProof. by move=> d_gt0; rewrite leq_divRL ?mul1n. Qed.",
    "Lemma leq_div2r d m n : m <= n -> m %/ d <= n %/ d.\nProof.\nhave [-> //| d_gt0 le_mn] := posnP d.\nby rewrite leq_divRL // (leq_trans _ le_mn) -?leq_divRL.\nQed.",
    "Lemma leq_div2l m d e : 0 < d -> d <= e -> m %/ e <= m %/ d.\nProof.\nmove/leq_divRL=> -> le_de.\nby apply: leq_trans (leq_divM m e); apply: leq_mul.\nQed.",
    "Lemma edivnD m n d (offset := m %% d + n %% d >= d) : 0 < d ->\n   edivn (m + n) d = (m %/ d + n %/ d + offset, m %% d + n %% d - offset * d).\nProof.\nrewrite {}/offset; case: d => // d _; rewrite /divn !modn_def.\ncase: (edivnP m d.+1) (edivnP n d.+1) => [/= q r -> r_lt] [/= p s -> s_lt].\nrewrite addnACA -mulnDl; have [r_le s_le] := (ltnW r_lt, ltnW s_lt).\nhave [d_ge|d_lt] := leqP; first by rewrite addn0 mul0n subn0 edivn_eq.\nrewrite addn1 mul1n -[in LHS](subnKC d_lt) addnA -mulSnr edivn_eq//.\nby rewrite ltn_subLR// -addnS leq_add.\nQed.",
    "Lemma divnD m n d : 0 < d ->\n  (m + n) %/ d = (m %/ d) + (n %/ d) + (m %% d + n %% d >= d).\nProof. by move=> /(@edivnD m n); rewrite edivn_def => -[]. Qed.",
    "Lemma modnD m n d : 0 < d ->\n  (m + n) %% d = m %% d + n %% d - (m %% d + n %% d >= d) * d.\nProof. by move=> /(@edivnD m n); rewrite edivn_def => -[]. Qed.",
    "Lemma leqDmod m n d : 0 < d ->\n  (d <= m %% d + n %% d) = ((m + n) %% d < n %% d).\nProof.\nmove=> d_gt0; rewrite modnD//.\nhave [d_le|_] := leqP d; last by rewrite subn0 ltnNge leq_addl.\nby rewrite -(ltn_add2r d) mul1n (subnK d_le) addnC ltn_add2l ltn_pmod.\nQed.",
    "Lemma divnB n m d : 0 < d ->\n  (m - n) %/ d = (m %/ d) - (n %/ d) - (m %% d < n %% d).\nProof.\nmove=> d_gt0; have [mn|/ltnW nm] := leqP m n.\n  by rewrite (eqP mn) (eqP (leq_div2r _ _)) ?div0n.\nby rewrite -[in m %/ d](subnK nm) divnD// addnAC addnK leqDmod ?subnK ?addnK.\nQed.",
    "Lemma modnB m n d : 0 < d -> n <= m ->\n  (m - n) %% d = (m %% d < n %% d) * d + m %% d - n %% d.\nProof.\nmove=> d_gt0 nm; rewrite -[in m %% _](subnK nm) -leqDmod// modnD//.\nhave [d_le|_] := leqP d; last by rewrite mul0n add0n subn0 addnK.\nby rewrite mul1n addnBA// addnC !addnK.\nQed.",
    "Lemma edivnB m n d (offset := m %% d < n %% d) : 0 < d -> n <= m ->\n   edivn (m - n) d = (m %/ d - n %/ d - offset, offset * d + m %% d - n %% d).\nProof. by move=> d_gt0 le_nm; rewrite edivn_def divnB// modnB. Qed.",
    "Lemma leq_divDl p m n : (m + n) %/ p <= m %/ p + n %/ p + 1.\nProof. by have [->//|p_gt0] := posnP p; rewrite divnD// !leq_add// leq_b1. Qed.",
    "Lemma geq_divBl k m p : k %/ p - m %/ p <= (k - m) %/ p + 1.\nProof.\nrewrite leq_subLR addnA; apply: leq_trans (leq_divDl _ _ _).\nby rewrite -maxnE leq_div2r ?leq_maxr.\nQed.",
    "Lemma divnMA m n p : m %/ (n * p) = m %/ n %/ p.\nProof.\ncase: n p => [|n] [|p]; rewrite ?muln0 ?div0n //.\nrewrite [in RHS](divn_eq m (n.+1 * p.+1)) mulnA mulnAC !divnMDl //.\nby rewrite [_ %/ p.+1]divn_small ?addn0 // ltn_divLR // mulnC ltn_mod.\nQed.",
    "Lemma divnAC m n p : m %/ n %/ p =  m %/ p %/ n.\nProof. by rewrite -!divnMA mulnC. Qed.",
    "Lemma modn_small m d : m < d -> m %% d = m.\nProof. by move=> lt_md; rewrite [RHS](divn_eq m d) divn_small. Qed.",
    "Lemma modn_mod m d : m %% d = m %[mod d].\nProof. by case: d => // d; apply: modn_small; rewrite ltn_mod. Qed.",
    "Lemma modnMDl p m d : p * d + m = m %[mod d].\nProof.\nhave [->|d_gt0] := posnP d; first by rewrite muln0.\nby rewrite [in LHS](divn_eq m d) addnA -mulnDl modn_def edivn_eq // ltn_mod.\nQed.",
    "Lemma muln_modr p m d : p * (m %% d) = (p * m) %% (p * d).\nProof.\nhave [->//|p_gt0] := posnP p; apply: (@addnI (p * (m %/ d * d))).\nby rewrite -mulnDr -divn_eq mulnCA -(divnMl p_gt0) -divn_eq.\nQed.",
    "Lemma muln_modl p m d : (m %% d) * p = (m * p) %% (d * p).\nProof. by rewrite -!(mulnC p); apply: muln_modr. Qed.",
    "Lemma modn_divl m n d : (m %/ d) %% n = m %% (n * d) %/ d.\nProof.\ncase: d n => [|d] [|n] //; rewrite [in LHS]/divn [in LHS]modn_def.\ncase: (edivnP m d.+1) edivnP => [/= _ r -> le_rd] [/= q s -> le_sn].\nrewrite mulnDl -mulnA -addnA modnMDl modn_small ?divnMDl ?divn_small ?addn0//.\nby rewrite mulSnr -addnS leq_add ?leq_mul2r.\nQed.",
    "Lemma modnDl m d : d + m = m %[mod d].\nProof. by rewrite -[m %% _](modnMDl 1) mul1n. Qed.",
    "Lemma modnDr m d : m + d = m %[mod d]. Proof. by rewrite addnC modnDl. Qed.",
    "Lemma modnn d : d %% d = 0. Proof. by rewrite [d %% d](modnDr 0) mod0n. Qed.",
    "Lemma modnMl p d : p * d %% d = 0.\nProof. by rewrite -[p * d]addn0 modnMDl mod0n. Qed.",
    "Lemma modnMr p d : d * p %% d = 0. Proof. by rewrite mulnC modnMl. Qed.",
    "Lemma modnDml m n d : m %% d + n = m + n %[mod d].\nProof. by rewrite [in RHS](divn_eq m d) -addnA modnMDl. Qed.",
    "Lemma modnDmr m n d : m + n %% d = m + n %[mod d].\nProof. by rewrite !(addnC m) modnDml. Qed.",
    "Lemma modnDm m n d : m %% d + n %% d = m + n %[mod d].\nProof. by rewrite modnDml modnDmr. Qed.",
    "Lemma eqn_modDl p m n d : (p + m == p + n %[mod d]) = (m == n %[mod d]).\nProof.\ncase: d => [|d]; first by rewrite !modn0 eqn_add2l.\napply/eqP/eqP=> eq_mn; last by rewrite -modnDmr eq_mn modnDmr.\nrewrite -(modnMDl p m) -(modnMDl p n) !mulnSr -!addnA.\nby rewrite -modnDmr eq_mn modnDmr.\nQed.",
    "Lemma eqn_modDr p m n d : (m + p == n + p %[mod d]) = (m == n %[mod d]).\nProof. by rewrite -!(addnC p) eqn_modDl. Qed.",
    "Lemma modnMml m n d : m %% d * n = m * n %[mod d].\nProof. by rewrite [in RHS](divn_eq m d) mulnDl mulnAC modnMDl. Qed.",
    "Lemma modnMmr m n d : m * (n %% d) = m * n %[mod d].\nProof. by rewrite !(mulnC m) modnMml. Qed.",
    "Lemma modnMm m n d : m %% d * (n %% d) = m * n %[mod d].\nProof. by rewrite modnMml modnMmr. Qed.",
    "Lemma modn2 m : m %% 2 = odd m.\nProof. by elim: m => //= m IHm; rewrite -addn1 -modnDml IHm; case odd. Qed.",
    "Lemma divn2 m : m %/ 2 = m./2.\nProof. by rewrite [in RHS](divn_eq m 2) modn2 muln2 addnC half_bit_double. Qed.",
    "Lemma odd_mod m d : odd d = false -> odd (m %% d) = odd m.\nProof.\nby move=> d_even; rewrite [in RHS](divn_eq m d) oddD oddM d_even andbF.\nQed.",
    "Lemma modnXm m n a : (a %% n) ^ m = a ^ m %[mod n].\nProof. by elim: m => // m IHm; rewrite !expnS -modnMmr IHm modnMml modnMmr. Qed.",
    "Lemma dvdnP d m : reflect (exists k, m = k * d) (d %| m).\nProof.\napply: (iffP eqP) => [md0 | [k ->]]; last by rewrite modnMl.\nby exists (m %/ d); rewrite [LHS](divn_eq m d) md0 addn0.\nQed.",
    "Lemma dvdn0 d : d %| 0.\nProof. by case: d. Qed.",
    "Lemma dvd0n n : (0 %| n) = (n == 0).\nProof. by case: n. Qed.",
    "Lemma dvdn1 d : (d %| 1) = (d == 1).\nProof. by case: d => [|[|d]] //; rewrite /dvdn modn_small. Qed.",
    "Lemma dvd1n m : 1 %| m.\nProof. by rewrite /dvdn modn1. Qed.",
    "Lemma dvdn_gt0 d m : m > 0 -> d %| m -> d > 0.\nProof. by case: d => // /prednK <-. Qed.",
    "Lemma dvdnn m : m %| m.\nProof. by rewrite /dvdn modnn. Qed.",
    "Lemma dvdn_mull d m n : d %| n -> d %| m * n.\nProof. by case/dvdnP=> n' ->; rewrite /dvdn mulnA modnMl. Qed.",
    "Lemma dvdn_mulr d m n : d %| m -> d %| m * n.\nProof. by move=> d_m; rewrite mulnC dvdn_mull. Qed.",
    "Lemma dvdn_mul d1 d2 m1 m2 : d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2.\nProof.\nby move=> /dvdnP[q1 ->] /dvdnP[q2 ->]; rewrite mulnCA -mulnA 2?dvdn_mull.\nQed.",
    "Lemma dvdn_trans n d m : d %| n -> n %| m -> d %| m.\nProof. by move=> d_dv_n /dvdnP[n1 ->]; apply: dvdn_mull. Qed.",
    "Lemma dvdn_eq d m : (d %| m) = (m %/ d * d == m).\nProof.\napply/eqP/eqP=> [modm0 | <-]; last exact: modnMl.\nby rewrite [RHS](divn_eq m d) modm0 addn0.\nQed.",
    "Lemma dvdn2 n : (2 %| n) = ~~ odd n.\nProof. by rewrite /dvdn modn2; case (odd n). Qed.",
    "Lemma dvdn_odd m n : m %| n -> odd n -> odd m.\nProof. by move=> m_dv_n; apply: contraTT; rewrite -!dvdn2 => /dvdn_trans->. Qed.",
    "Lemma divnK d m : d %| m -> m %/ d * d = m.\nProof. by rewrite dvdn_eq; move/eqP. Qed.",
    "Lemma leq_divLR d m n : d %| m -> (m %/ d <= n) = (m <= n * d).\nProof. by case: d m => [|d] [|m] ///divnK=> {2}<-; rewrite leq_pmul2r. Qed.",
    "Lemma ltn_divRL d m n : d %| m -> (n < m %/ d) = (n * d < m).\nProof. by move=> dv_d_m; rewrite !ltnNge leq_divLR. Qed.",
    "Lemma eqn_div d m n : d > 0 -> d %| m -> (n == m %/ d) = (n * d == m).\nProof. by move=> d_gt0 dv_d_m; rewrite -(eqn_pmul2r d_gt0) divnK. Qed.",
    "Lemma eqn_mul d m n : d > 0 -> d %| m -> (m == n * d) = (m %/ d == n).\nProof. by move=> d_gt0 dv_d_m; rewrite eq_sym -eqn_div // eq_sym. Qed.",
    "Lemma divn_mulAC d m n : d %| m -> m %/ d * n = m * n %/ d.\nProof.\ncase: d m => [[] //| d m] dv_d_m; apply/eqP.\nby rewrite eqn_div ?dvdn_mulr // mulnAC divnK.\nQed.",
    "Lemma muln_divA d m n : d %| n -> m * (n %/ d) = m * n %/ d.\nProof. by move=> dv_d_m; rewrite !(mulnC m) divn_mulAC. Qed.",
    "Lemma muln_divCA d m n : d %| m -> d %| n -> m * (n %/ d) = n * (m %/ d).\nProof. by move=> dv_d_m dv_d_n; rewrite mulnC divn_mulAC ?muln_divA. Qed.",
    "Lemma divnA m n p : p %| n -> m %/ (n %/ p) = m * p %/ n.\nProof. by case: p => [|p] dv_n; rewrite -[in RHS](divnK dv_n) // divnMr. Qed.",
    "Lemma modn_dvdm m n d : d %| m -> n %% m = n %[mod d].\nProof.\nby case/dvdnP=> q def_m; rewrite [in RHS](divn_eq n m) def_m mulnA modnMDl.\nQed.",
    "Lemma dvdn_leq d m : 0 < m -> d %| m -> d <= m.\nProof. by move=> m_gt0 /dvdnP[[|k] Dm]; rewrite Dm // leq_addr in m_gt0 *. Qed.",
    "Lemma gtnNdvd n d : 0 < n -> n < d -> (d %| n) = false.\nProof. by move=> n_gt0 lt_nd; rewrite /dvdn eqn0Ngt modn_small ?n_gt0. Qed.",
    "Lemma eqn_dvd m n : (m == n) = (m %| n) && (n %| m).\nProof.\ncase: m n => [|m] [|n] //; apply/idP/andP => [/eqP -> //| []].\nby rewrite eqn_leq => Hmn Hnm; do 2 rewrite dvdn_leq //.\nQed.",
    "Lemma dvdn_pmul2l p d m : 0 < p -> (p * d %| p * m) = (d %| m).\nProof. by case: p => // p _; rewrite /dvdn -muln_modr // muln_eq0. Qed.",
    "Lemma dvdn_pmul2r p d m : 0 < p -> (d * p %| m * p) = (d %| m).\nProof. by move=> p_gt0; rewrite -!(mulnC p) dvdn_pmul2l. Qed.",
    "Lemma dvdn_divLR p d m : 0 < p -> p %| d -> (d %/ p %| m) = (d %| m * p).\nProof. by move=> /(@dvdn_pmul2r p _ m) <- /divnK->. Qed.",
    "Lemma dvdn_divRL p d m : p %| m -> (d %| m %/ p) = (d * p %| m).\nProof.\nhave [-> | /(@dvdn_pmul2r p d) <- /divnK-> //] := posnP p.\nby rewrite divn0 muln0 dvdn0.\nQed.",
    "Lemma dvdn_div d m : d %| m -> m %/ d %| m.\nProof. by move/divnK=> {2}<-; apply: dvdn_mulr. Qed.",
    "Lemma dvdn_exp2l p m n : m <= n -> p ^ m %| p ^ n.\nProof. by move/subnK <-; rewrite expnD dvdn_mull. Qed.",
    "Lemma dvdn_Pexp2l p m n : p > 1 -> (p ^ m %| p ^ n) = (m <= n).\nProof.\nmove=> p_gt1; case: leqP => [|gt_n_m]; first exact: dvdn_exp2l.\nby rewrite gtnNdvd ?ltn_exp2l ?expn_gt0 // ltnW.\nQed.",
    "Lemma dvdn_exp2r m n k : m %| n -> m ^ k %| n ^ k.\nProof. by case/dvdnP=> q ->; rewrite expnMn dvdn_mull. Qed.",
    "Lemma divn_modl m n d : d %| n -> (m %% n) %/ d = (m %/ d) %% (n %/ d).\nProof. by move=> dvd_dn; rewrite modn_divl divnK. Qed.",
    "Lemma dvdn_addr m d n : d %| m -> (d %| m + n) = (d %| n).\nProof. by case/dvdnP=> q ->; rewrite /dvdn modnMDl. Qed.",
    "Lemma dvdn_addl n d m : d %| n -> (d %| m + n) = (d %| m).\nProof. by rewrite addnC; apply: dvdn_addr. Qed.",
    "Lemma dvdn_add d m n : d %| m -> d %| n -> d %| m + n.\nProof. by move/dvdn_addr->. Qed.",
    "Lemma dvdn_add_eq d m n : d %| m + n -> (d %| m) = (d %| n).\nProof. by move=> dv_d_mn; apply/idP/idP => [/dvdn_addr | /dvdn_addl] <-. Qed.",
    "Lemma dvdn_subr d m n : n <= m -> d %| m -> (d %| m - n) = (d %| n).\nProof. by move=> le_n_m dv_d_m; apply: dvdn_add_eq; rewrite subnK. Qed.",
    "Lemma dvdn_subl d m n : n <= m -> d %| n -> (d %| m - n) = (d %| m).\nProof. by move=> le_n_m dv_d_m; rewrite -(dvdn_addl _ dv_d_m) subnK. Qed.",
    "Lemma dvdn_sub d m n : d %| m -> d %| n -> d %| m - n.\nProof.\nby case: (leqP n m) => [le_nm /dvdn_subr <- // | /ltnW/eqnP ->]; rewrite dvdn0.\nQed.",
    "Lemma dvdn_exp k d m : 0 < k -> d %| m -> d %| (m ^ k).\nProof. by case: k => // k _ d_dv_m; rewrite expnS dvdn_mulr. Qed.",
    "Lemma dvdn_fact m n : 0 < m <= n -> m %| n`!.\nProof.\ncase: m => //= m; elim: n => //= n IHn; rewrite ltnS.\nhave [/IHn/dvdn_mull->||-> _] // := ltngtP m n; exact: dvdn_mulr.\nQed.",
    "Lemma eqn_mod_dvd d m n : n <= m -> (m == n %[mod d]) = (d %| m - n).\nProof.\nby move/subnK=> Dm; rewrite -[n in LHS]add0n -[in LHS]Dm eqn_modDr mod0n.\nQed.",
    "Lemma divnDMl q m d : 0 < d -> (m + q * d) %/ d = (m %/ d) + q.\nProof. by move=> d_gt0; rewrite addnC divnMDl// addnC. Qed.",
    "Lemma divnMBl q m d : 0 < d -> (q * d - m) %/ d = q - (m %/ d) - (~~ (d %| m)).\nProof. by move=> d_gt0; rewrite divnB// mulnK// modnMl lt0n. Qed.",
    "Lemma divnBMl q m d : (m - q * d) %/ d = (m %/ d) - q.\nProof. by case: d => [|d]//=; rewrite divnB// mulnK// modnMl ltn0 subn0. Qed.",
    "Lemma divnDl m n d : d %| m -> (m + n) %/ d = m %/ d + n %/ d.\nProof. by case: d => // d /divnK-Dm; rewrite -[in LHS]Dm divnMDl. Qed.",
    "Lemma divnDr m n d : d %| n -> (m + n) %/ d = m %/ d + n %/ d.\nProof. by move=> dv_n; rewrite addnC divnDl // addnC. Qed.",
    "Lemma divnBl m n d : d %| m -> (m - n) %/ d = m %/ d - (n %/ d) - (~~ (d %| n)).\nProof. by case: d => [|d] // /divnK-Dm; rewrite -[in LHS]Dm divnMBl. Qed.",
    "Lemma divnBr m n d : d %| n -> (m - n) %/ d = m %/ d - n %/ d.\nProof. by case: d => [|d]// /divnK-Dm; rewrite -[in LHS]Dm divnBMl. Qed.",
    "Lemma edivnS m d : 0 < d -> edivn m.+1 d =\n  if d %| m.+1 then ((m %/ d).+1, 0) else (m %/ d, (m %% d).+1).\nProof.\ncase: d => [|[|d]] //= _; first by rewrite edivn_def modn1 dvd1n !divn1.\nrewrite -addn1 /dvdn modn_def edivnD//= (@modn_small 1)// (@divn_small 1)//.\nrewrite addn1 addn0 ltnS; have [||<-] := ltngtP d.+1.\n- by rewrite ltnNge -ltnS ltn_pmod.\n- by rewrite addn0 mul0n subn0.\n- by rewrite addn1 mul1n subnn.\nQed.",
    "Lemma modnS m d : m.+1 %% d = if d %| m.+1 then 0 else (m %% d).+1.\nProof. by case: d => [|d]//; rewrite modn_def edivnS//; case: ifP. Qed.",
    "Lemma divnS m d : 0 < d -> m.+1 %/ d = (d %| m.+1) + m %/ d.\nProof. by move=> d_gt0; rewrite /divn edivnS//; case: ifP. Qed.",
    "Lemma divn_pred m d : m.-1 %/ d = (m %/ d) - (d %| m).\nProof.\nby case: d m => [|d] [|m]; rewrite ?divn1 ?dvd1n ?subn1//= divnS// addnC addnK.\nQed.",
    "Lemma modn_pred m d : d != 1 -> 0 < m ->\n  m.-1 %% d = if d %| m then d.-1 else (m %% d).-1.\nProof.\nrewrite -subn1; case: d m => [|[|d]] [|m]//= _ _.\n  by rewrite ?modn1 ?dvd1n ?modn0 ?subn1.\nrewrite modnB// (@modn_small 1)// [_ < _]leqn0 /dvdn mulnbl/= subn1.\nby case: eqP => // ->; rewrite addn0.\nQed.",
    "Lemma edivn_pred m d : d != 1 -> 0 < m ->\n  edivn m.-1 d = if d %| m then ((m %/ d).-1, d.-1) else (m %/ d, (m %% d).-1).\nProof.\nmove=> d_neq1 m_gt0; rewrite edivn_def divn_pred modn_pred//.\nby case: ifP; rewrite ?subn0 ?subn1.\nQed.",
    "Lemma gcdnE m n : gcdn m n = if m == 0 then n else gcdn (n %% m) m.\nProof.\nelim/ltn_ind: m n => -[|m] IHm [|n] //=; rewrite /gcdn -/gcdn.\ncase def_p: (_ %% _) => // [p].\nhave{def_p} lt_pm: p.+1 < m.+1 by rewrite -def_p ltn_pmod.\nrewrite {}IHm // subn_if_gt ltnW //=; congr gcdn.\nby rewrite -(subnK (ltnW lt_pm)) modnDr.\nQed.",
    "Lemma gcdnn : idempotent_op gcdn.\nProof. by case=> // n; rewrite gcdnE modnn. Qed.",
    "Lemma gcdnC : commutative gcdn.\nProof.\nmove=> m n; wlog lt_nm: m n / n < m by have [? ->|? <-|-> //] := ltngtP n m.\nby rewrite gcdnE -[in m == 0](ltn_predK lt_nm) modn_small.\nQed.",
    "Lemma gcd0n : left_id 0 gcdn. Proof. by case. Qed.",
    "Lemma gcdn0 : right_id 0 gcdn. Proof. by case. Qed.",
    "Lemma gcd1n : left_zero 1 gcdn.\nProof. by move=> n; rewrite gcdnE modn1. Qed.",
    "Lemma gcdn1 : right_zero 1 gcdn.\nProof. by move=> n; rewrite gcdnC gcd1n. Qed.",
    "Lemma dvdn_gcdr m n : gcdn m n %| n.\nProof.\nelim/ltn_ind: m n => -[|m] IHm [|n] //=.\nrewrite gcdnE; case def_p: (_ %% _) => [|p]; first by rewrite /dvdn def_p.\nhave lt_pm: p < m by rewrite -ltnS -def_p ltn_pmod.\nrewrite /= (divn_eq n.+1 m.+1) def_p dvdn_addr ?dvdn_mull //; last exact: IHm.\nby rewrite gcdnE /= IHm // (ltn_trans (ltn_pmod _ _)).\nQed.",
    "Lemma dvdn_gcdl m n : gcdn m n %| m.\nProof. by rewrite gcdnC dvdn_gcdr. Qed.",
    "Lemma gcdn_gt0 m n : (0 < gcdn m n) = (0 < m) || (0 < n).\nProof.\nby case: m n => [|m] [|n] //; apply: (@dvdn_gt0 _ m.+1) => //; apply: dvdn_gcdl.\nQed.",
    "Lemma gcdnMDl k m n : gcdn m (k * m + n) = gcdn m n.\nProof. by rewrite !(gcdnE m) modnMDl mulnC; case: m. Qed.",
    "Lemma gcdnDl m n : gcdn m (m + n) = gcdn m n.\nProof. by rewrite -[m in m + n]mul1n gcdnMDl. Qed.",
    "Lemma gcdnDr m n : gcdn m (n + m) = gcdn m n.\nProof. by rewrite addnC gcdnDl. Qed.",
    "Lemma gcdnMl n m : gcdn n (m * n) = n.\nProof. by case: n => [|n]; rewrite gcdnE modnMl // muln0. Qed.",
    "Lemma gcdnMr n m : gcdn n (n * m) = n.\nProof. by rewrite mulnC gcdnMl. Qed.",
    "Lemma gcdn_idPl {m n} : reflect (gcdn m n = m) (m %| n).\nProof.\nby apply: (iffP idP) => [/dvdnP[q ->] | <-]; rewrite (gcdnMl, dvdn_gcdr).\nQed.",
    "Lemma gcdn_idPr {m n} : reflect (gcdn m n = n) (n %| m).\nProof. by rewrite gcdnC; apply: gcdn_idPl. Qed.",
    "Lemma expn_min e m n : e ^ minn m n = gcdn (e ^ m) (e ^ n).\nProof. by case: leqP => [|/ltnW] /(dvdn_exp2l e) /gcdn_idPl; rewrite gcdnC. Qed.",
    "Lemma gcdn_modr m n : gcdn m (n %% m) = gcdn m n.\nProof. by rewrite [in RHS](divn_eq n m) gcdnMDl. Qed.",
    "Lemma gcdn_modl m n : gcdn (m %% n) n = gcdn m n.\nProof. by rewrite !(gcdnC _ n) gcdn_modr. Qed.",
    "Lemma egcd0n n : egcdn 0 n = (1, 0).\nProof. by case: n. Qed.",
    "Lemma egcdnP m n : m > 0 -> egcdn_spec m n (egcdn m n).\nProof.\nhave [-> /= | n_gt0 m_gt0] := posnP n; first by split; rewrite // mul1n gcdn0.\nrewrite /egcdn; set s := (s in egcdn_rec _ _ s); pose bz := Bezout_rec n m [::].\nhave: n < s.+1 by []; move defSpec: (egcdn_spec bz.2 bz.1) s => Spec s.\nelim: s => [[]|s IHs] //= in n m (qs := [::]) bz defSpec n_gt0 m_gt0 *.\ncase: edivnP => q r def_m; rewrite n_gt0 ltnS /= => lt_rn le_ns1.\ncase: posnP => [r0 {s le_ns1 IHs lt_rn}|r_gt0]; last first.\n  by apply: IHs => //=; [rewrite natTrecE -def_m | rewrite (leq_trans lt_rn)].\nrewrite {r}r0 addn0 in def_m; set b := odd _; pose d := gcdn m n.\npose km := ~~ b : nat; pose kn := if b then 1 else q.-1.\nrewrite [bz in Spec bz](_ : _ = Bezout_rec km kn qs); last first.\n  by rewrite /kn /km; case: (b) => //=; rewrite natTrecE addn0 muln1.\nhave def_d: d = n by rewrite /d def_m gcdnC gcdnE modnMl gcd0n -[n]prednK.\nhave: km * m + 2 * b * d = kn * n + d.\n  rewrite {}/kn {}/km def_m def_d -mulSnr; case: b; rewrite //= addn0 mul1n.\n  by rewrite prednK //; apply: dvdn_gt0 m_gt0 _; rewrite def_m dvdn_mulr.\nhave{def_m}: kn * d <= m.\n  have q_gt0 : 0 < q by rewrite def_m muln_gt0 n_gt0 ?andbT in m_gt0.\n  by rewrite /kn; case b; rewrite def_d def_m leq_pmul2r // leq_pred.\nhave{def_d}: km * d <= n by rewrite -[n]mul1n def_d leq_pmul2r // leq_b1.\nmove: km {q}kn m_gt0 n_gt0 defSpec; rewrite {}/b {}/d {}/bz.\nelim: qs m n => [|q qs IHq] n r kn kr n_gt0 r_gt0 /=.\n  set d := gcdn n r; rewrite mul0n addn0 => <- le_kn_r _ def_d; split=> //.\n  have d_gt0: 0 < d by rewrite gcdn_gt0 n_gt0.\n  have /ltn_pmul2l<-: 0 < kn by rewrite -(ltn_pmul2r n_gt0) def_d ltn_addl.\n  by rewrite def_d -addn1 leq_add // mulnCA leq_mul2l le_kn_r orbT.\nrewrite !natTrecE; set m := _ + r; set km := _ + kn; pose d := gcdn m n.\nhave ->: gcdn n r = d by rewrite [d]gcdnC gcdnMDl.\nhave m_gt0: 0 < m by rewrite addn_gt0 r_gt0 orbT.\nhave d_gt0: 0 < d by rewrite gcdn_gt0 m_gt0.\nmove=> {}/IHq IHq le_kn_r le_kr_n def_d; apply: IHq => //; rewrite -/d.\n  by rewrite mulnDl leq_add // -mulnA leq_mul2l le_kr_n orbT.\napply: (@addIn d); rewrite mulnDr -addnA addnACA -def_d addnACA mulnA.\nrewrite -!mulnDl -mulnDr -addnA [kr * _]mulnC; congr addn.\nby rewrite addnC addn_negb muln1 mul2n addnn.\nQed.",
    "Lemma Bezoutl m n : m > 0 -> {a | a < m & m %| gcdn m n + a * n}.\nProof.\nmove=> m_gt0; case: (egcdnP n m_gt0) => km kn def_d lt_kn_m.\nexists kn; last by rewrite addnC -def_d dvdn_mull.\napply: leq_ltn_trans lt_kn_m.\nby rewrite -{1}[kn]muln1 leq_mul2l gcdn_gt0 m_gt0 orbT.\nQed.",
    "Lemma Bezoutr m n : n > 0 -> {a | a < n & n %| gcdn m n + a * m}.\nProof. by rewrite gcdnC; apply: Bezoutl. Qed.",
    "Lemma dvdn_gcd p m n : p %| gcdn m n = (p %| m) && (p %| n).\nProof.\napply/idP/andP=> [dv_pmn | [dv_pm dv_pn]].\n  by rewrite !(dvdn_trans dv_pmn) ?dvdn_gcdl ?dvdn_gcdr.\nhave [->|n_gt0] := posnP n; first by rewrite gcdn0.\ncase: (Bezoutr m n_gt0) => // km _ /(dvdn_trans dv_pn).\nby rewrite dvdn_addl // dvdn_mull.\nQed.",
    "Lemma gcdnAC : right_commutative gcdn.\nProof.\nsuffices dvd m n p: gcdn (gcdn m n) p %| gcdn (gcdn m p) n.\n  by move=> m n p; apply/eqP; rewrite eqn_dvd !dvd.\nrewrite !dvdn_gcd dvdn_gcdr.\nby rewrite !(dvdn_trans (dvdn_gcdl _ p)) ?dvdn_gcdl ?dvdn_gcdr.\nQed.",
    "Lemma gcdnA : associative gcdn.\nProof. by move=> m n p; rewrite !(gcdnC m) gcdnAC. Qed.",
    "Lemma gcdnCA : left_commutative gcdn.\nProof. by move=> m n p; rewrite !gcdnA (gcdnC m). Qed.",
    "Lemma gcdnACA : interchange gcdn gcdn.\nProof. by move=> m n p q; rewrite -!gcdnA (gcdnCA n). Qed.",
    "Lemma muln_gcdr : right_distributive muln gcdn.\nProof.\nmove=> p m n; have [-> //|p_gt0] := posnP p.\nelim/ltn_ind: m n => m IHm n; rewrite gcdnE [RHS]gcdnE muln_eq0 (gtn_eqF p_gt0).\nby case: posnP => // m_gt0; rewrite -muln_modr //=; apply/IHm/ltn_pmod.\nQed.",
    "Lemma muln_gcdl : left_distributive muln gcdn.\nProof. by move=> m n p; rewrite -!(mulnC p) muln_gcdr. Qed.",
    "Lemma gcdn_def d m n :\n    d %| m -> d %| n -> (forall d', d' %| m -> d' %| n -> d' %| d) ->\n  gcdn m n = d.\nProof.\nmove=> dv_dm dv_dn gdv_d; apply/eqP.\nby rewrite eqn_dvd dvdn_gcd dv_dm dv_dn gdv_d ?dvdn_gcdl ?dvdn_gcdr.\nQed.",
    "Lemma muln_divCA_gcd n m : n * (m %/ gcdn n m)  = m * (n %/ gcdn n m).\nProof. by rewrite muln_divCA ?dvdn_gcdl ?dvdn_gcdr. Qed.",
    "Lemma lcmnC : commutative lcmn.\nProof. by move=> m n; rewrite /lcmn mulnC gcdnC. Qed.",
    "Lemma lcm0n : left_zero 0 lcmn.  Proof. by move=> n; apply: div0n. Qed.",
    "Lemma lcmn0 : right_zero 0 lcmn. Proof. by move=> n; rewrite lcmnC lcm0n. Qed.",
    "Lemma lcm1n : left_id 1 lcmn.\nProof. by move=> n; rewrite /lcmn gcd1n mul1n divn1. Qed.",
    "Lemma lcmn1 : right_id 1 lcmn.\nProof. by move=> n; rewrite lcmnC lcm1n. Qed.",
    "Lemma muln_lcm_gcd m n : lcmn m n * gcdn m n = m * n.\nProof. by apply/eqP; rewrite divnK ?dvdn_mull ?dvdn_gcdr. Qed.",
    "Lemma lcmn_gt0 m n : (0 < lcmn m n) = (0 < m) && (0 < n).\nProof. by rewrite -muln_gt0 ltn_divRL ?dvdn_mull ?dvdn_gcdr. Qed.",
    "Lemma muln_lcmr : right_distributive muln lcmn.\nProof.\ncase=> // m n p; rewrite /lcmn -muln_gcdr -!mulnA divnMl // mulnCA.\nby rewrite muln_divA ?dvdn_mull ?dvdn_gcdr.\nQed.",
    "Lemma muln_lcml : left_distributive muln lcmn.\nProof. by move=> m n p; rewrite -!(mulnC p) muln_lcmr. Qed.",
    "Lemma lcmnA : associative lcmn.\nProof.\nmove=> m n p; rewrite [LHS]/lcmn [RHS]/lcmn mulnC.\nrewrite !divn_mulAC ?dvdn_mull ?dvdn_gcdr // -!divnMA ?dvdn_mulr ?dvdn_gcdl //.\nrewrite mulnC mulnA !muln_gcdr; congr (_ %/ _).\nby rewrite ![_ * lcmn _ _]mulnC !muln_lcm_gcd !muln_gcdl -!(mulnC m) gcdnA.\nQed.",
    "Lemma lcmnCA : left_commutative lcmn.\nProof. by move=> m n p; rewrite !lcmnA (lcmnC m). Qed.",
    "Lemma lcmnAC : right_commutative lcmn.\nProof. by move=> m n p; rewrite -!lcmnA (lcmnC n). Qed.",
    "Lemma lcmnACA : interchange lcmn lcmn.\nProof. by move=> m n p q; rewrite -!lcmnA (lcmnCA n). Qed.",
    "Lemma dvdn_lcml d1 d2 : d1 %| lcmn d1 d2.\nProof. by rewrite /lcmn -muln_divA ?dvdn_gcdr ?dvdn_mulr. Qed.",
    "Lemma dvdn_lcmr d1 d2 : d2 %| lcmn d1 d2.\nProof. by rewrite lcmnC dvdn_lcml. Qed.",
    "Lemma dvdn_lcm d1 d2 m : lcmn d1 d2 %| m = (d1 %| m) && (d2 %| m).\nProof.\ncase: d1 d2 => [|d1] [|d2]; try by case: m => [|m]; rewrite ?lcmn0 ?andbF.\nrewrite -(@dvdn_pmul2r (gcdn d1.+1 d2.+1)) ?gcdn_gt0 // muln_lcm_gcd.\nby rewrite muln_gcdr dvdn_gcd {1}mulnC andbC !dvdn_pmul2r.\nQed.",
    "Lemma lcmnMl m n : lcmn m (m * n) = m * n.\nProof. by case: m => // m; rewrite /lcmn gcdnMr mulKn. Qed.",
    "Lemma lcmnMr m n : lcmn n (m * n) = m * n.\nProof. by rewrite mulnC lcmnMl. Qed.",
    "Lemma lcmn_idPr {m n} : reflect (lcmn m n = n) (m %| n).\nProof.\nby apply: (iffP idP) => [/dvdnP[q ->] | <-]; rewrite (lcmnMr, dvdn_lcml).\nQed.",
    "Lemma lcmn_idPl {m n} : reflect (lcmn m n = m) (n %| m).\nProof. by rewrite lcmnC; apply: lcmn_idPr. Qed.",
    "Lemma expn_max e m n : e ^ maxn m n = lcmn (e ^ m) (e ^ n).\nProof. by case: leqP => [|/ltnW] /(dvdn_exp2l e) /lcmn_idPl; rewrite lcmnC. Qed.",
    "Lemma coprime1n n : coprime 1 n.\nProof. by rewrite /coprime gcd1n. Qed.",
    "Lemma coprimen1 n : coprime n 1.\nProof. by rewrite /coprime gcdn1. Qed.",
    "Lemma coprime_sym m n : coprime m n = coprime n m.\nProof. by rewrite /coprime gcdnC. Qed.",
    "Lemma coprime_modl m n : coprime (m %% n) n = coprime m n.\nProof. by rewrite /coprime gcdn_modl. Qed.",
    "Lemma coprime_modr m n : coprime m (n %% m) = coprime m n.\nProof. by rewrite /coprime gcdn_modr. Qed.",
    "Lemma coprime2n n : coprime 2 n = odd n.\nProof. by rewrite -coprime_modr modn2; case: (odd n). Qed.",
    "Lemma coprimen2 n : coprime n 2 = odd n.\nProof. by rewrite coprime_sym coprime2n. Qed.",
    "Lemma coprimeSn n : coprime n.+1 n.\nProof. by rewrite -coprime_modl (modnDr 1) coprime_modl coprime1n. Qed.",
    "Lemma coprimenS n : coprime n n.+1.\nProof. by rewrite coprime_sym coprimeSn. Qed.",
    "Lemma coprimePn n : n > 0 -> coprime n.-1 n.\nProof. by case: n => // n _; rewrite coprimenS. Qed.",
    "Lemma coprimenP n : n > 0 -> coprime n n.-1.\nProof. by case: n => // n _; rewrite coprimeSn. Qed.",
    "Lemma coprimeP n m :\n  n > 0 -> reflect (exists u, u.1 * n - u.2 * m = 1) (coprime n m).\nProof.\nmove=> n_gt0; apply: (iffP eqP) => [<-| [[kn km] /= kn_km_1]].\n  by have [kn km kg _] := egcdnP m n_gt0; exists (kn, km); rewrite kg addKn.\napply gcdn_def; rewrite ?dvd1n // => d dv_d_n dv_d_m.\nby rewrite -kn_km_1 dvdn_subr ?dvdn_mull // ltnW // -subn_gt0 kn_km_1.\nQed.",
    "Lemma modn_coprime k n : 0 < k -> (exists u, (k * u) %% n = 1) -> coprime k n.\nProof.\nmove=> k_gt0 [u Hu]; apply/coprimeP=> //.\nby exists (u, k * u %/ n); rewrite /= mulnC {1}(divn_eq (k * u) n) addKn.\nQed.",
    "Lemma Gauss_dvd m n p : coprime m n -> (m * n %| p) = (m %| p) && (n %| p).\nProof. by move=> co_mn; rewrite -muln_lcm_gcd (eqnP co_mn) muln1 dvdn_lcm. Qed.",
    "Lemma Gauss_dvdr m n p : coprime m n -> (m %| n * p) = (m %| p).\nProof.\ncase: n => [|n] co_mn; first by case: m co_mn => [|[]] // _; rewrite !dvd1n.\nby symmetry; rewrite mulnC -(@dvdn_pmul2r n.+1) ?Gauss_dvd // andbC dvdn_mull.\nQed.",
    "Lemma Gauss_dvdl m n p : coprime m p -> (m %| n * p) = (m %| n).\nProof. by rewrite mulnC; apply: Gauss_dvdr. Qed.",
    "Lemma dvdn_double_leq m n : m %| n -> odd m -> ~~ odd n -> 0 < n -> m.*2 <= n.\nProof.\nmove=> m_dv_n odd_m even_n n_gt0.\nby rewrite -muln2 dvdn_leq // Gauss_dvd ?coprimen2 ?m_dv_n ?dvdn2.\nQed.",
    "Lemma dvdn_double_ltn m n : m %| n.-1 -> odd m -> odd n -> 1 < n -> m.*2 < n.\nProof. by case: n => //; apply: dvdn_double_leq. Qed.",
    "Lemma Gauss_gcdr p m n : coprime p m -> gcdn p (m * n) = gcdn p n.\nProof.\nmove=> co_pm; apply/eqP; rewrite eqn_dvd !dvdn_gcd !dvdn_gcdl /=.\nrewrite andbC dvdn_mull ?dvdn_gcdr //= -(@Gauss_dvdr _ m) ?dvdn_gcdr //.\nby rewrite /coprime gcdnAC (eqnP co_pm) gcd1n.\nQed.",
    "Lemma Gauss_gcdl p m n : coprime p n -> gcdn p (m * n) = gcdn p m.\nProof. by move=> co_pn; rewrite mulnC Gauss_gcdr. Qed.",
    "Lemma coprimeMr p m n : coprime p (m * n) = coprime p m && coprime p n.\nProof.\ncase co_pm: (coprime p m) => /=; first by rewrite /coprime Gauss_gcdr.\napply/eqP=> co_p_mn; case/eqnP: co_pm; apply gcdn_def => // d dv_dp dv_dm.\nby rewrite -co_p_mn dvdn_gcd dv_dp dvdn_mulr.\nQed.",
    "Lemma coprimeMl p m n : coprime (m * n) p = coprime m p && coprime n p.\nProof. by rewrite -!(coprime_sym p) coprimeMr. Qed.",
    "Lemma coprime_pexpl k m n : 0 < k -> coprime (m ^ k) n = coprime m n.\nProof.\ncase: k => // k _; elim: k => [|k IHk]; first by rewrite expn1.\nby rewrite expnS coprimeMl -IHk; case coprime.\nQed.",
    "Lemma coprime_pexpr k m n : 0 < k -> coprime m (n ^ k) = coprime m n.\nProof. by move=> k_gt0; rewrite !(coprime_sym m) coprime_pexpl. Qed.",
    "Lemma coprimeXl k m n : coprime m n -> coprime (m ^ k) n.\nProof. by case: k => [|k] co_pm; rewrite ?coprime1n // coprime_pexpl. Qed.",
    "Lemma coprimeXr k m n : coprime m n -> coprime m (n ^ k).\nProof. by rewrite !(coprime_sym m); apply: coprimeXl. Qed.",
    "Lemma coprime_dvdl m n p : m %| n -> coprime n p -> coprime m p.\nProof. by case/dvdnP=> d ->; rewrite coprimeMl => /andP[]. Qed.",
    "Lemma coprime_dvdr m n p : m %| n -> coprime p n -> coprime p m.\nProof. by rewrite !(coprime_sym p); apply: coprime_dvdl. Qed.",
    "Lemma coprime_egcdn n m : n > 0 -> coprime (egcdn n m).1 (egcdn n m).2.\nProof.\nmove=> n_gt0; case: (egcdnP m n_gt0) => kn km /= /eqP.\nhave [/dvdnP[u defn] /dvdnP[v defm]] := (dvdn_gcdl n m, dvdn_gcdr n m).\nrewrite -[gcdn n m]mul1n {1}defm {1}defn !mulnA -mulnDl addnC.\nrewrite eqn_pmul2r ?gcdn_gt0 ?n_gt0 //; case: kn => // kn /eqP def_knu _.\nby apply/coprimeP=> //; exists (u, v); rewrite mulnC def_knu mulnC addnK.\nQed.",
    "Lemma dvdn_pexp2r m n k : k > 0 -> (m ^ k %| n ^ k) = (m %| n).\nProof.\nmove=> k_gt0; apply/idP/idP=> [dv_mn_k|]; last exact: dvdn_exp2r.\nhave [->|n_gt0] := posnP n; first by rewrite dvdn0.\nhave [n' def_n] := dvdnP (dvdn_gcdr m n); set d := gcdn m n in def_n.\nhave [m' def_m] := dvdnP (dvdn_gcdl m n); rewrite -/d in def_m.\nhave d_gt0: d > 0 by rewrite gcdn_gt0 n_gt0 orbT.\nrewrite def_m def_n !expnMn dvdn_pmul2r ?expn_gt0 ?d_gt0 // in dv_mn_k.\nhave: coprime (m' ^ k) (n' ^ k).\n  rewrite coprime_pexpl // coprime_pexpr // /coprime -(eqn_pmul2r d_gt0) mul1n.\n  by rewrite muln_gcdl -def_m -def_n.\nrewrite /coprime -gcdn_modr (eqnP dv_mn_k) gcdn0 -(exp1n k).\nby rewrite (inj_eq (expIn k_gt0)) def_m; move/eqP->; rewrite mul1n dvdn_gcdr.\nQed.",
    "Lemma chinese_remainder x y :\n  (x == y %[mod m1 * m2]) = (x == y %[mod m1]) && (x == y %[mod m2]).\nProof.\nwlog le_yx : x y / y <= x; last by rewrite !eqn_mod_dvd // Gauss_dvd.\nby have [?|/ltnW ?] := leqP y x; last rewrite !(eq_sym (x %% _)); apply.\nQed.",
    "Lemma chinese_modl r1 r2 : chinese r1 r2 = r1 %[mod m1].\nProof.\nrewrite /chinese; case: (posnP m2) co_m12 => [-> /eqnP | m2_gt0 _].\n  by rewrite gcdn0 => ->; rewrite !modn1.\ncase: egcdnP => // k2 k1 def_m1 _.\nrewrite mulnAC -mulnA def_m1 gcdnC (eqnP co_m12) mulnDr mulnA muln1.\nby rewrite addnAC (mulnAC _ m1) -mulnDl modnMDl.\nQed.",
    "Lemma chinese_modr r1 r2 : chinese r1 r2 = r2 %[mod m2].\nProof.\nrewrite /chinese; case: (posnP m1) co_m12 => [-> /eqnP | m1_gt0 _].\n  by rewrite gcd0n => ->; rewrite !modn1.\ncase: (egcdnP m2) => // k1 k2 def_m2 _.\nrewrite addnC mulnAC -mulnA def_m2 (eqnP co_m12) mulnDr mulnA muln1.\nby rewrite addnAC (mulnAC _ m2) -mulnDl modnMDl.\nQed.",
    "Lemma chinese_mod x : x = chinese (x %% m1) (x %% m2) %[mod m1 * m2].\nProof.\napply/eqP; rewrite chinese_remainder //.\nby rewrite chinese_modl chinese_modr !modn_mod !eqxx.\nQed.",
    "Lemma fact_prod n : n`! = \\prod_(1 <= i < n.+1) i.\nProof.\nelim: n => [|n IHn] //; first by rewrite big_nil.\nby apply/esym; rewrite factS IHn // !big_add1 big_nat_recr //= mulnC.\nQed.",
    "Lemma fact_split n m : m <= n -> n`! = m`! * \\prod_(m.+1 <= k < n.+1) k.\nProof. by move=> leq_mn; rewrite !fact_prod -big_cat_nat. Qed.",
    "Lemma logn_fact p n : prime p -> logn p n`! = \\sum_(1 <= k < n.+1) n %/ p ^ k.\nProof.\nmove=> p_prime; transitivity (\\sum_(1 <= i < n.+1) logn p i).\n  rewrite big_add1; elim: n => /= [|n IHn]; first by rewrite logn1 big_geq.\n  by rewrite big_nat_recr // -IHn /= factS mulnC lognM ?fact_gt0.\ntransitivity (\\sum_(1 <= i < n.+1) \\sum_(1 <= k < n.+1) (p ^ k %| i)).\n  apply: eq_big_nat => i /andP[i_gt0 le_i_n]; rewrite logn_count_dvd //.\n  rewrite -!big_mkcond (big_nat_widen _ _ n.+1) 1?ltnW //; apply: eq_bigl => k.\n  by apply: andb_idr => /dvdn_leq/(leq_trans (ltn_expl _ (prime_gt1 _)))->.\nby rewrite exchange_big_nat; apply: eq_bigr => i _; rewrite divn_count_dvd.\nQed.",
    "Lemma ffactE : falling_factorial = ffact_rec. Proof. by []. Qed.",
    "Lemma ffactn0 n : n ^_ 0 = 1. Proof. by []. Qed.",
    "Lemma ffact0n m : 0 ^_ m = (m == 0). Proof. by case: m. Qed.",
    "Lemma ffactnS n m : n ^_ m.+1 = n * n.-1 ^_ m. Proof. by []. Qed.",
    "Lemma ffactSS n m : n.+1 ^_ m.+1 = n.+1 * n ^_ m. Proof. by []. Qed.",
    "Lemma ffactn1 n : n ^_ 1 = n. Proof. exact: muln1. Qed.",
    "Lemma ffactnSr n m : n ^_ m.+1 = n ^_ m * (n - m).\nProof.\nelim: n m => [|n IHn] [|m] //=; first by rewrite ffactn1 mul1n.\nby rewrite !ffactSS IHn mulnA.\nQed.",
    "Lemma ffact_prod n m : n ^_ m = \\prod_(i < m) (n - i).\nProof.\nelim: m n => [n | m IH [|n] //]; first by rewrite ffactn0 big_ord0.\n  by rewrite big_ord_recr /= sub0n muln0.\nby rewrite ffactSS IH big_ord_recl subn0.\nQed.",
    "Lemma ffact_gt0 n m : (0 < n ^_ m) = (m <= n).\nProof. by elim: n m => [|n IHn] [|m] //=; rewrite ffactSS muln_gt0 IHn. Qed.",
    "Lemma ffact_small n m : n < m -> n ^_ m = 0.\nProof. by rewrite ltnNge -ffact_gt0; case: posnP. Qed.",
    "Lemma ffactnn n : n ^_ n = n`!.\nProof. by elim: n => [|n IHn] //; rewrite ffactnS IHn. Qed.",
    "Lemma ffact_fact n m : m <= n -> n ^_ m * (n - m)`! = n`!.\nProof.\nby elim: n m => [|n IHn] [|m] //= le_m_n; rewrite ?mul1n // -mulnA IHn.\nQed.",
    "Lemma ffact_factd n m : m <= n -> n ^_ m = n`! %/ (n - m)`!.\nProof. by move/ffact_fact <-; rewrite mulnK ?fact_gt0. Qed.",
    "Lemma binE n m : binomial n m =\n  match n, m with\n  | n'.+1, m'.+1 => binomial n' m + binomial n' m'\n  | _, 0 => 1\n  | 0, _.+1 => 0\n  end.\nProof. by case: n. Qed.",
    "Lemma bin0 n : 'C(n, 0) = 1. Proof. by case: n. Qed.",
    "Lemma bin0n m : 'C(0, m) = (m == 0). Proof. by case: m. Qed.",
    "Lemma binS n m : 'C(n.+1, m.+1) = 'C(n, m.+1) + 'C(n, m). Proof. by []. Qed.",
    "Lemma bin1 n : 'C(n, 1) = n.\nProof. by elim: n => //= n IHn; rewrite binS bin0 IHn addn1. Qed.",
    "Lemma bin_gt0 n m : (0 < 'C(n, m)) = (m <= n).\nProof.\nby elim: n m => [|n IHn] [|m] //; rewrite addn_gt0 !IHn orbC ltn_neqAle andKb.\nQed.",
    "Lemma leq_bin2l n1 n2 m : n1 <= n2 -> 'C(n1, m) <= 'C(n2, m).\nProof.\nby elim: n1 n2 m  => [|n1 IHn] [|n2] [|n] le_n12 //; rewrite leq_add ?IHn.\nQed.",
    "Lemma bin_small n m : n < m -> 'C(n, m) = 0.\nProof. by rewrite ltnNge -bin_gt0; case: posnP. Qed.",
    "Lemma binn n : 'C(n, n) = 1.\nProof. by elim: n => [|n IHn] //; rewrite binS bin_small. Qed.",
    "Lemma mul_bin_diag n m : n * 'C(n.-1, m) = m.+1 * 'C(n, m.+1).\nProof.\nrewrite [RHS]mulnC; elim: n m => [|[|n] IHn] [|m] //=; first by rewrite bin1.\nby rewrite mulSn [in _ * _]binS mulnDr addnCA !IHn -mulnS -mulnDl -binS.\nQed.",
    "Lemma bin_fact n m : m <= n -> 'C(n, m) * (m`! * (n - m)`!) = n`!.\nProof.\nelim: n m => [|n IHn] [|m] // le_m_n; first by rewrite bin0 !mul1n.\nby rewrite !factS -!mulnA mulnCA mulnA -mul_bin_diag -mulnA IHn.\nQed.",
    "Lemma bin_factd n m : 0 < n -> 'C(n, m) = n`! %/ (m`! * (n - m)`!).\nProof.\nhave [/bin_fact<-|*] := leqP m n; first by rewrite mulnK ?muln_gt0 ?fact_gt0.\nby rewrite divnMA bin_small ?divn_small ?fact_gt0 ?ltn_fact.\nQed.",
    "Lemma bin_ffact n m : 'C(n, m) * m`! = n ^_ m.\nProof.\nhave [lt_n_m | le_m_n] := ltnP n m; first by rewrite bin_small ?ffact_small.\nby rewrite ffact_factd // -(bin_fact le_m_n) mulnA mulnK ?fact_gt0.\nQed.",
    "Lemma bin_ffactd n m : 'C(n, m) = n ^_ m %/ m`!.\nProof. by rewrite -bin_ffact mulnK ?fact_gt0. Qed.",
    "Lemma bin_sub n m : m <= n -> 'C(n, n - m) = 'C(n, m).\nProof.\nby move=> le_m_n; rewrite !bin_ffactd !ffact_factd ?leq_subr // divnAC subKn.\nQed.",
    "Lemma mul_bin_down n m : n * 'C(n.-1, m) = (n - m) * 'C(n, m).\nProof.\ncase: n => //= n; have [lt_n_m | le_m_n] := ltnP n m.\n  by rewrite (eqnP lt_n_m) mulnC bin_small.\nby rewrite -!['C(_, m)]bin_sub ?leqW ?subSn ?mul_bin_diag.\nQed.",
    "Lemma mul_bin_left n m : m.+1 * 'C(n, m.+1) = (n - m) * 'C(n, m).\nProof. by rewrite -mul_bin_diag mul_bin_down. Qed.",
    "Lemma binSn n : 'C(n.+1, n) = n.+1.\nProof. by rewrite -bin_sub ?leqnSn // subSnn bin1. Qed.",
    "Lemma bin2 n : 'C(n, 2) = (n * n.-1)./2.\nProof. by rewrite -[n.-1]bin1 mul_bin_diag -divn2 mulKn. Qed.",
    "Lemma bin2odd n : odd n -> 'C(n, 2) = n * n.-1./2.\nProof. by case: n => // n oddn; rewrite bin2 -!divn2 muln_divA ?dvdn2. Qed.",
    "Lemma prime_dvd_bin k p : prime p -> 0 < k < p -> p %| 'C(p, k).\nProof.\nmove=> p_pr /andP[k_gt0 lt_k_p].\nsuffices /Gauss_dvdr<-: coprime p (p - k) by rewrite -mul_bin_down dvdn_mulr.\nby rewrite prime_coprime // dvdn_subr 1?ltnW // gtnNdvd.\nQed.",
    "Lemma bin2_sum n : \\sum_(0 <= i < n) i = 'C(n, 2).\nProof.\nelim: n => [|n IHn]; first by rewrite big_geq.\nby rewrite big_nat_recr // IHn binS bin1.\nQed.",
    "Lemma Vandermonde k l i :\n  \\sum_(j < i.+1) 'C(k, j) * 'C(l, i - j) = 'C(k + l , i).\nProof.\npose f k i := \\sum_(j < i.+1) 'C(k, j) * 'C(l, i - j).\nsuffices{k i} fxx k i: f k.+1 i.+1 = f k i.+1 + f k i.\n  elim: k i => [i | k IHk [|i]]; last by rewrite -/(f _ _) fxx /f !IHk -binS.\n    by rewrite big_ord_recl big1_eq addn0 mul1n subn0.\n  by rewrite big_ord_recl big_ord0 addn0 !bin0 muln1.\nrewrite {}/f big_ord_recl (big_ord_recl (i.+1)) !bin0 !mul1n.\nrewrite -addnA -big_split /=; congr (_ + _).\nby apply: eq_bigr => j _; rewrite -mulnDl.\nQed.",
    "Lemma subn_exp m n k :\n  m ^ k - n ^ k = (m - n) * (\\sum_(i < k) m ^ (k.-1 -i) * n ^ i).\nProof.\ncase: k => [|k]; first by rewrite big_ord0 muln0.\nrewrite mulnBl !big_distrr big_ord_recl big_ord_recr /= subn0 muln1.\nrewrite subnn mul1n -!expnS subnDA; congr (_ - _); apply: canRL (addnK _) _.\ncongr (_ + _); apply: eq_bigr => i _.\nby rewrite (mulnCA n) -expnS mulnA -expnS subnSK /=.\nQed.",
    "Lemma predn_exp m k : (m ^ k).-1 = m.-1 * (\\sum_(i < k) m ^ i).\nProof.\nrewrite -!subn1 -[in LHS](exp1n k) subn_exp; congr (_ * _).\nsymmetry; rewrite (reindex_inj rev_ord_inj); apply: eq_bigr => i _ /=.\nby rewrite -subn1 -subnDA exp1n muln1.\nQed.",
    "Lemma dvdn_pred_predX n e : (n.-1 %| (n ^ e).-1)%N.\nProof. by rewrite predn_exp dvdn_mulr. Qed.",
    "Lemma modn_summ I r (P : pred I) F d :\n  \\sum_(i <- r | P i) F i %% d = \\sum_(i <- r | P i) F i %[mod d].\nProof.\nby apply/eqP; elim/big_rec2: _ => // i m n _; rewrite modnDml eqn_modDl.\nQed.",
    "Lemma prime_modn_expSn p n : prime p -> n.+1 ^ p = (n ^ p).+1 %[mod p].\nProof.\ncase: p => // p pP.\nrewrite -[(_ ^ _).+1]addn0 (expnDn 1) big_ord_recr big_ord_recl /=.\nrewrite subnn binn exp1n !mul1n addnAC -modnDmr; congr ((_ + _) %% _).\napply/eqP/dvdn_sum => -[i ?] _; exact/dvdn_mulr/prime_dvd_bin.\nQed.",
    "Lemma fermat_little a p : prime p -> a ^ p = a %[mod p].\nProof.\nmove=> pP.\nelim: a => [|a IH]; first by rewrite exp0n // prime_gt0.\nby rewrite prime_modn_expSn // -addn1 -modnDml IH modnDml addn1.\nQed.",
    "Lemma card_uniq_tuples T n (A : pred T) :\n  #|[set t : n.-tuple T | all A t & uniq t]| = #|A| ^_ n.\nProof.\nelim: n A => [|n IHn] A.\n  by rewrite (@eq_card1 _ [tuple]) // => t; rewrite [t]tuple0 inE.\nrewrite -sum1dep_card (partition_big (@thead _ _) A) /= => [|t]; last first.\n  by case/tupleP: t => x t; do 2!case/andP.\nrewrite ffactnS -sum_nat_const; apply: eq_bigr => x Ax.\nrewrite (cardD1 x) [x \\in A]Ax /= -(IHn [predD1 A & x]) -sum1dep_card.\nrewrite (reindex (fun t : n.-tuple T => [tuple of x :: t])) /=; last first.\n  pose ttail (t : n.+1.-tuple T) := [tuple of behead t].\n  exists ttail => [t _ | t /andP[_ /eqP <-]]; first exact: val_inj.\n  by rewrite -tuple_eta.\napply: eq_bigl=> t; rewrite Ax theadE eqxx andbT /= andbA; congr (_ && _).\nby rewrite all_predI all_predC has_pred1 andbC.\nQed.",
    "Lemma card_inj_ffuns_on D T (R : pred T) :\n  #|[set f : {ffun D -> T} in ffun_on R | injectiveb f]| = #|R| ^_ #|D|.\nProof.\nrewrite -card_uniq_tuples.\nhave bijFF: {on (_ : pred _), bijective (@Finfun D T)}.\n  by exists fgraph => x _; [apply: FinfunK | apply: fgraphK].\nrewrite -(on_card_preimset (bijFF _)); apply: eq_card => /= t.\nrewrite !inE -(big_andE predT) -big_image /= big_all.\nby rewrite -[t in RHS]FinfunK -codom_ffun.\nQed.",
    "Lemma card_inj_ffuns D T :\n  #|[set f : {ffun D -> T} | injectiveb f]| = #|T| ^_ #|D|.\nProof.\nrewrite -card_inj_ffuns_on; apply: eq_card => f.\nby rewrite 2!inE; case: ffun_onP.\nQed.",
    "Lemma cards_draws T (B : {set T}) k :\n  #|[set A : {set T} | A \\subset B & #|A| == k]| = 'C(#|B|, k).\nProof.\nhave [ltTk | lekT] := ltnP #|B| k.\n  rewrite bin_small // eq_card0 // => A.\n  rewrite inE eqn_leq [k <= _]leqNgt.\n  have [AsubB /=|//] := boolP (A \\subset B).\n  by rewrite (leq_ltn_trans (subset_leq_card AsubB)) ?andbF.\napply/eqP; rewrite -(eqn_pmul2r (fact_gt0 k)) bin_ffact // eq_sym.\nrewrite -sum_nat_cond_const -{1 3}(card_ord k).\nrewrite -card_inj_ffuns_on -sum1dep_card.\npose imIk (f : {ffun 'I_k -> T}) := f @: 'I_k.\nrewrite (partition_big imIk (fun A => (A \\subset B) && (#|A| == k))) /=\n  => [|f]; last first.\n  move=> /andP [/ffun_onP f_ffun /injectiveP inj_f].\n  rewrite card_imset ?card_ord // eqxx andbT.\n  by apply/subsetP => x /imsetP [i _ ->]; rewrite f_ffun.\napply/eqP; apply: eq_bigr => A /andP [AsubB /eqP cardAk].\nhave [f0 inj_f0 im_f0]: exists2 f, injective f & f @: 'I_k = A.\n  rewrite -cardAk; exists enum_val; first exact: enum_val_inj.\n  apply/setP=> a; apply/imsetP/idP=> [[i _ ->] | Aa]; first exact: enum_valP.\n  by exists (enum_rank_in Aa a); rewrite ?enum_rankK_in.\nrewrite (reindex (fun p : {ffun _} => [ffun i => f0 (p i)])) /=; last first.\n  pose ff0' f i := odflt i [pick j | f i == f0 j].\n  exists (fun f => [ffun i => ff0' f i]) => [p _ | f].\n    apply/ffunP=> i; rewrite ffunE /ff0'; case: pickP => [j | /(_ (p i))].\n      by rewrite ffunE (inj_eq inj_f0) => /eqP.\n    by rewrite ffunE eqxx.\n  rewrite -im_f0 => /andP[/andP[/ffun_onP f_ffun /injectiveP injf] /eqP im_f].\n  apply/ffunP=> i; rewrite !ffunE /ff0'; case: pickP => [y /eqP //|].\n  have /imsetP[j _ eq_f0j_fi]: f i \\in f0 @: 'I_k by rewrite -im_f imset_f.\n  by move/(_ j)/eqP.\nrewrite -ffactnn -card_inj_ffuns -sum1dep_card; apply: eq_bigl => p.\nrewrite -andbA.\napply/and3P/injectiveP=> [[_ /injectiveP inj_f0p _] i j eq_pij | inj_p].\n  by apply: inj_f0p; rewrite !ffunE eq_pij.\nset f := finfun _.\nhave injf: injective f by move=> i j /[!ffunE] /inj_f0; apply: inj_p.\nhave imIkf : imIk f == A.\n  rewrite eqEcard card_imset // cardAk card_ord leqnn andbT -im_f0.\n  by apply/subsetP=> x /imsetP[i _ ->]; rewrite ffunE imset_f.\nsplit; [|exact/injectiveP|exact: imIkf].\nby apply/ffun_onP => x; apply: (subsetP AsubB); rewrite -(eqP imIkf) imset_f.\nQed.",
    "Lemma card_draws T k : #|[set A : {set T} | #|A| == k]| = 'C(#|T|, k).\nProof.\nby rewrite -cardsT -cards_draws; apply: eq_card => A; rewrite !inE subsetT.\nQed.",
    "Lemma card_ltn_sorted_tuples m n :\n  #|[set t : m.-tuple 'I_n | sorted ltn (map val t)]| = 'C(n, m).\nProof.\nhave [-> | n_gt0] := posnP n; last pose i0 := Ordinal n_gt0.\n  case: m => [|m]; last by apply: eq_card0; case/tupleP=> [[]].\n  by apply: (@eq_card1 _ [tuple]) => t; rewrite [t]tuple0 inE.\nrewrite -[n in RHS]card_ord -card_draws.\npose f_t (t : m.-tuple 'I_n) := [set i in t].\npose f_A (A : {set 'I_n}) := [tuple of mkseq (nth i0 (enum A)) m].\nhave val_fA (A : {set 'I_n}) : #|A| = m -> val (f_A A) = enum A.\n  by move=> Am; rewrite -[enum _](mkseq_nth i0) -cardE Am.\nhave inc_A (A : {set 'I_n}) : sorted ltn (map val (enum A)).\n  rewrite -[enum _](eq_filter (mem_enum _)).\n  rewrite -(eq_filter (mem_map val_inj _)) -filter_map.\n  by rewrite (sorted_filter ltn_trans) // unlock val_ord_enum iota_ltn_sorted.\nrewrite -!sum1dep_card (reindex_onto f_t f_A) /= => [|A]; last first.\n  by move/eqP=> cardAm; apply/setP=> x; rewrite inE -(mem_enum A) -val_fA.\napply: eq_bigl => t.\napply/idP/idP => [inc_t|/andP [/eqP t_m /eqP <-]]; last by rewrite val_fA.\nhave ft_m: #|f_t t| = m.\n  rewrite cardsE (card_uniqP _) ?size_tuple // -(map_inj_uniq val_inj).\n  exact: (sorted_uniq ltn_trans ltnn).\nrewrite ft_m eqxx -val_eqE val_fA // -(inj_eq (inj_map val_inj)) /=.\napply/eqP/(irr_sorted_eq ltn_trans ltnn) => // y.\nby apply/mapP/mapP=> [] [x t_x ->]; exists x; rewrite // mem_enum inE in t_x *.\nQed.",
    "Lemma card_sorted_tuples m n :\n  #|[set t : m.-tuple 'I_n.+1 | sorted leq (map val t)]| = 'C(m + n, m).\nProof.\nset In1 := 'I_n.+1; pose x0 : In1 := ord0.\nhave add_mnP (i : 'I_m) (x : In1) : i + x < m + n.\n  by rewrite -ltnS -addSn -!addnS leq_add.\npose add_mn t i := Ordinal (add_mnP i (tnth t i)).\npose add_mn_nat (t : m.-tuple In1) i := i + nth x0 t i.\nhave add_mnC t: val \\o add_mn t =1 add_mn_nat t \\o val.\n  by move=> i; rewrite /= (tnth_nth x0).\npose f_add t := [tuple of map (add_mn t) (ord_tuple m)].\nrewrite -card_ltn_sorted_tuples -!sum1dep_card (reindex f_add) /=.\n  apply: eq_bigl => t; rewrite -map_comp (eq_map (add_mnC t)) map_comp.\n  rewrite enumT unlock val_ord_enum -[in LHS](drop0 t).\n  have [m0 | m_gt0] := posnP m.\n    by rewrite {2}m0 /= drop_oversize // size_tuple m0.\n  have def_m := subnK m_gt0; rewrite -{2}def_m addn1 /= {1}/add_mn_nat.\n  move: 0 (m - 1) def_m => i k; rewrite -[in RHS](size_tuple t) => def_m.\n  rewrite (drop_nth x0) /=; last by rewrite -def_m leq_addl.\n  elim: k i (nth x0 t i) def_m => [|k IHk] i x /=.\n    by rewrite add0n => ->; rewrite drop_size.\n  rewrite addSnnS => def_m; rewrite -addSn leq_add2l -IHk //.\n  by rewrite (drop_nth x0) // -def_m leq_addl.\npose sub_mn (t : m.-tuple 'I_(m + n)) i : In1 := inord (tnth t i - i).\nexists (fun t => [tuple of map (sub_mn t) (ord_tuple m)]) => [t _ | t].\n  apply: eq_from_tnth => i; apply: val_inj.\n  by rewrite /sub_mn !(tnth_ord_tuple, tnth_map) addKn inord_val.\nrewrite inE /= => inc_t; apply: eq_from_tnth => i; apply: val_inj.\nrewrite tnth_map tnth_ord_tuple /= tnth_map tnth_ord_tuple.\nsuffices [le_i_ti le_ti_ni]: i <= tnth t i /\\ tnth t i <= i + n.\n  by rewrite /sub_mn inordK ?subnKC // ltnS leq_subLR.\npose y0 := tnth t i; rewrite (tnth_nth y0) -(nth_map _ (val i)) ?size_tuple //.\ncase def_e: (map _ _) => [|x e] /=; first by rewrite nth_nil ?leq_addr.\nset nth_i := nth (i : nat); rewrite def_e in inc_t; split.\n  have: i < size (x :: e) by rewrite -def_e size_map size_tuple ltn_ord.\n  elim: (val i) => //= j IHj lt_j_e.\n  by apply: leq_trans (pathP (val i) inc_t _ lt_j_e); rewrite ltnS IHj 1?ltnW.\nmove: (_ - _) (subnK (valP i)) => k /=.\nelim: k (val i) => /= [|k IHk] j; rewrite -ltnS -addSn ?add0n => def_m.\n  by rewrite def_m -def_e /nth_i (nth_map y0) ?ltn_ord // size_tuple -def_m.\nrewrite (leq_trans _ (IHk _ _)) -1?addSnnS //; apply: (pathP _ inc_t).\nrewrite -ltnS (leq_trans (leq_addl k _)) // -addSnnS def_m.\nby rewrite -(size_tuple t) -(size_map val) def_e.\nQed.",
    "Lemma card_partial_ord_partitions m n :\n  #|[set t : m.-tuple 'I_n.+1 | \\sum_(i <- t) i <= n]| = 'C(m + n, m).\nProof.\nsymmetry; set In1 := 'I_n.+1; pose x0 : In1 := ord0.\npose add_mn (i j : In1) : In1 := inord (i + j).\npose f_add (t : m.-tuple In1) := [tuple of scanl add_mn x0 t].\nrewrite -card_sorted_tuples -!sum1dep_card (reindex f_add) /=.\n  apply: eq_bigl => t; rewrite -[\\sum_(i <- t) i]add0n.\n  transitivity (path leq x0 (map val (f_add t))) => /=; first by case: map.\n  rewrite -{1 2}[0]/(val x0); elim: {t}(val t) (x0) => /= [|x t IHt] s.\n    by rewrite big_nil addn0 -ltnS ltn_ord.\n  rewrite big_cons addnA IHt /= val_insubd ltnS.\n  have [_ | ltn_n_sx] := leqP (s + x) n; first by rewrite leq_addr.\n  rewrite -(leq_add2r x) leqNgt (leq_trans (valP x)) //=.\n  by rewrite leqNgt (leq_trans ltn_n_sx) ?leq_addr.\npose sub_mn (i j : In1) := Ordinal (leq_ltn_trans (leq_subr i j) (valP j)).\nexists (fun t : m.-tuple In1 => [tuple of pairmap sub_mn x0 t]) => /= t inc_t.\n  apply: val_inj => /=; have{inc_t}: path leq x0 (map val (f_add t)).\n    by move: inc_t; rewrite inE /=; case: map.\n  rewrite [map _ _]/=; elim: {t}(val t) (x0) => //= x t IHt s.\n  case/andP=> le_s_sx /IHt->; congr (_ :: _); apply: val_inj => /=.\n  move: le_s_sx; rewrite val_insubd.\n  case le_sx_n: (_ < n.+1); first by rewrite addKn.\n  by case: (val s) le_sx_n; rewrite ?ltn_ord.\napply: val_inj => /=; have{inc_t}: path leq x0 (map val t).\n  by move: inc_t; rewrite inE /=; case: map.\nelim: {t}(val t) (x0) => //= x t IHt s /andP[le_s_sx inc_t].\nsuffices ->: add_mn s (sub_mn s x) = x by rewrite IHt.\nby apply: val_inj; rewrite /add_mn /= subnKC ?inord_val.\nQed.",
    "Lemma card_ord_partitions m n :\n  #|[set t : m.+1.-tuple 'I_n.+1 | \\sum_(i <- t) i == n]| = 'C(m + n, m).\nProof.\nsymmetry; set In1 := 'I_n.+1; pose x0 : In1 := ord0.\npose f_add (t : m.-tuple In1) := [tuple of sub_ord (\\sum_(x <- t) x) :: t].\nrewrite -card_partial_ord_partitions -!sum1dep_card (reindex f_add) /=.\n  by apply: eq_bigl => t; rewrite big_cons /= addnC (sameP maxn_idPr eqP) maxnE.\nexists (fun t : m.+1.-tuple In1 => [tuple of behead t]) => [t _|].\n  exact: val_inj.\ncase/tupleP=> x t /[!(inE, big_cons)] /eqP def_n.\nby apply: val_inj; congr (_ :: _); apply: val_inj; rewrite /= -{1}def_n addnK.\nQed.",
    "Lemma repr_ofK : cancel (@repr_of _ _) \\pi.\nProof. exact: repr_ofK_subproof. Qed.",
    "Lemma reprK : cancel repr \\pi_qT.\nProof. by move=> x; rewrite !unlock repr_ofK. Qed.",
    "Lemma piP (x : T) : pi_spec x (repr (\\pi_qT x)).\nProof. by constructor; rewrite reprK. Qed.",
    "Lemma mpiE : \\mpi =1 \\pi_qT.\nProof. by move=> x; rewrite !unlock. Qed.",
    "Lemma quotW P : (forall y : T, P (\\pi_qT y)) -> forall x : qT, P x.\nProof. by move=> Py x; rewrite -[x]reprK; apply: Py. Qed.",
    "Lemma quotP P : (forall y : T, repr (\\pi_qT y) = y -> P (\\pi_qT y))\n  -> forall x : qT, P x.\nProof. by move=> Py x; rewrite -[x]reprK; apply: Py; rewrite reprK. Qed.",
    "Lemma equal_toE (T : Type) (x : T) (m : equal_to x) : equal_val m = x.\nProof. by case: m. Qed.",
    "Lemma pi_morph1 : \\pi (f a) = fq (equal_val x). Proof. by rewrite !piE. Qed.",
    "Lemma pi_morph2 : \\pi (g a b) = gq (equal_val x) (equal_val y). Proof. by rewrite !piE. Qed.",
    "Lemma pi_mono1 : p a = pq (equal_val x). Proof. by rewrite !piE. Qed.",
    "Lemma pi_mono2 : r a b = rq (equal_val x) (equal_val y). Proof. by rewrite !piE. Qed.",
    "Lemma pi_morph11 : \\pi (h a) = hq (equal_val x). Proof. by rewrite !piE. Qed.",
    "Lemma eq_lock T T' e : e =1 (@locked (T -> T') (fun x : T => e x)).\nProof. by rewrite -lock. Qed.",
    "Lemma qreprK x Px : repr (@Sub x Px) = x.\nProof. by rewrite /Sub (eqP Px). Qed.",
    "Lemma sortPx (x : qT) : repr (\\pi_qT (repr x)) == repr x.\nProof. by rewrite !reprK eqxx. Qed.",
    "Lemma sort_Sub (x : qT) : x = Sub (sortPx x).\nProof. by rewrite /Sub reprK. Qed.",
    "Lemma reprP K (PK : forall x Px, K (@Sub x Px)) u : K u.\nProof. by rewrite (sort_Sub u); apply: PK. Qed.",
    "Lemma left_trans (e : rel T) :\n  symmetric e -> transitive e -> left_transitive e.\nProof. by move=> s t ? * ?; apply/idP/idP; apply: t; rewrite // s. Qed.",
    "Lemma right_trans (e : rel T) :\n  symmetric e -> transitive e -> right_transitive e.\nProof. by move=> s t ? * x; rewrite ![e x _]s; apply: left_trans. Qed.",
    "Lemma equiv_refl x : e x x. Proof. by case: e => [] ? []. Qed.",
    "Lemma equiv_sym : symmetric e. Proof. by case: e => [] ? []. Qed.",
    "Lemma equiv_trans : transitive e. Proof. by case: e => [] ? []. Qed.",
    "Lemma eq_op_trans (T' : eqType) : transitive (@eq_op T').\nProof. by move=> x y z /eqP -> /eqP ->. Qed.",
    "Lemma equiv_ltrans: left_transitive e.\nProof. by apply: left_trans; [apply: equiv_sym|apply: equiv_trans]. Qed.",
    "Lemma equiv_rtrans: right_transitive e.\nProof. by apply: right_trans; [apply: equiv_sym|apply: equiv_trans]. Qed.",
    "Lemma enc_mod_rel_is_equiv : equiv_class_of (enc_mod_rel r).\nProof.\nsplit => [x|x y|y x z]; rewrite !encModRelE //; first by rewrite equiv_sym.\nby move=> exy /(equiv_trans exy).\nQed.",
    "Lemma encoded_equivE : e' =2 [rel x y | e (ED x) (ED y)].\nProof. by move=> x y; rewrite /encoded_equiv /= encModRelE. Qed.",
    "Lemma encoded_equiv_is_equiv : equiv_class_of e'.\nProof.\nsplit => [x|x y|y x z]; rewrite !e'E //=; first by rewrite equiv_sym.\nby move=> exy /(equiv_trans exy).\nQed.",
    "Lemma encoded_equivP x : e' (DE (ED x)) x.\nProof. by rewrite /encoded_equiv /= encModEquivP. Qed.",
    "Lemma canon_id : forall x, (invariant canon canon) x.\nProof.\nmove=> x /=; rewrite /canon (@eq_choose _ _ (eC x)).\n  by rewrite (@choose_id _ (eC x) _ x) ?chooseP ?equiv_refl.\nby move=> y; apply: equiv_ltrans; rewrite equiv_sym /= chooseP.\nQed.",
    "Lemma ereprK : cancel erepr pi.\nProof.\npose T : subType _ := HB.pack equivQuotient [isSub for erepr].\nby unlock pi; case=> x hx; apply/(@val_inj _ _ T)/eqP.\nQed.",
    "Lemma pi_CD (x y : C) : reflect (pi x = pi y) (eC x y).\nProof.\napply: (iffP idP) => hxy.\n  apply: (can_inj ereprK); unlock pi canon => /=.\n  rewrite -(@eq_choose _ (eC x) (eC y)); last first.\n    by move=> z; rewrite /eC /=; apply: equiv_ltrans.\n  by apply: choose_id; rewrite ?equiv_refl //.\nrewrite (equiv_trans (chooseP (equiv_refl _ _))) //=.\nmove: hxy => /(f_equal erepr) /=; unlock pi canon => /= ->.\nby rewrite equiv_sym /= chooseP.\nQed.",
    "Lemma pi_DC (x y : D) :\n  reflect (pi (DC x) = pi (DC y)) (eD x y).\nProof.\napply: (iffP idP)=> hxy.\n  apply/pi_CD; rewrite /eC /=.\n  by rewrite (equiv_ltrans (encDP _)) (equiv_rtrans (encDP _)) /= encDE.\nrewrite -encDE -(equiv_ltrans (encDP _)) -(equiv_rtrans (encDP _)) /=.\nexact/pi_CD.\nQed.",
    "Lemma equivQTP : cancel (CD \\o erepr) (pi \\o DC).\nProof. by move=> x; rewrite /= (pi_CD _ (erepr x) _) ?ereprK /eC /= ?encDP. Qed.",
    "Lemma eqmodP x y : reflect (x = y %[mod qT]) (eD x y).\nProof. by apply: (iffP (pi_DC _ _)); rewrite !unlock. Qed.",
    "Lemma eqmodE x y : x == y %[mod qT] = eD x y.\nProof. exact: sameP eqP (@eqmodP _ _). Qed.",
    "Lemma eqmodE x y : x == y %[mod_eq e] = e x y.\nProof. by rewrite pi_eq_quot. Qed.",
    "Lemma eqmodP x y : reflect (x = y %[mod_eq e]) (e x y).\nProof. by rewrite -eqmodE; apply/eqP. Qed.",
    "Lemma eqquotE x y : x == y %[mod Q] = e x y.\nProof. by rewrite pi_eq_quot. Qed.",
    "Lemma eqquotP x y : reflect (x = y %[mod Q]) (e x y).\nProof. by rewrite -eqquotE; apply/eqP. Qed.",
    "Lemma edivn2P n : edivn_spec n 2 (edivn2 0 n).\nProof.\nrewrite -[n]odd_double_half addnC -{1}[n./2]addn0 -{1}mul2n mulnC.\nelim: n./2 {1 4}0 => [|r IHr] q; first by case (odd n) => /=.\nby rewrite addSnnS; apply: IHr.\nQed.",
    "Lemma elogn2P n : elogn2_spec n.+1 (elogn2 0 n n).\nProof.\nrewrite -[n.+1]mul1n -[1]/(2 ^ 0) -[n in _ * n.+1](addKn n n) addnn.\nelim: n {1 4 6}n {2 3}0 (leqnn n) => [|q IHq] [|[|r]] e //=; last first.\n  by move/ltnW; apply: IHq.\nrewrite subn1 prednK // -mul2n mulnA -expnSr.\nby rewrite -[q in _ * q.+1](addKn q q) addnn => _; apply: IHq.\nQed.",
    "Lemma ifnzP T n (x y : T) : ifnz_spec n x y (ifnz n x y).\nProof. by case: n => [|n]; [right | left]. Qed.",
    "Lemma prime_decomp_correct :\n  let pd_val pd := \\prod_(f <- pd) pfactor f.1 f.2 in\n  let lb_dvd q m := ~~ has [pred d | d %| m] (index_iota 2 q) in\n  let pf_ok f := lb_dvd f.1 f.1 && (0 < f.2) in\n  let pd_ord q pd := path ltn q (unzip1 pd) in\n  let pd_ok q n pd := [/\\ n = pd_val pd, all pf_ok pd & pd_ord q pd] in\n  forall n, n > 0 -> pd_ok 1 n (prime_decomp n).\nProof.\nrewrite unlock => pd_val lb_dvd pf_ok pd_ord pd_ok.\nhave leq_pd_ok m p q pd: q <= p -> pd_ok p m pd -> pd_ok q m pd.\n  rewrite /pd_ok /pd_ord; case: pd => [|[r _] pd] //= leqp [<- ->].\n  by case/andP=> /(leq_trans _)->.\nhave apd_ok m e q p pd: lb_dvd p p || (e == 0) -> q < p ->\n     pd_ok p m pd -> pd_ok q (p ^ e * m) (p ^? e :: pd).\n- case: e => [|e]; rewrite orbC /= => pr_p ltqp.\n    by rewrite mul1n; apply: leq_pd_ok; apply: ltnW.\n  by rewrite /pd_ok /pd_ord /pf_ok /= pr_p ltqp => [[<- -> ->]].\ncase=> // n _; rewrite /prime_decomp.\ncase: elogn2P => e2 m2 -> {n}; case: m2 => [|[|abc]]; try exact: apd_ok.\nrewrite [_.-2]/= !ltnS ltn0 natTrecE; case: edivnP => a bc ->{abc}.\ncase: edivnP => b c def_bc /= ltc2 ltbc3; apply: (apd_ok) => //.\nmove def_m: _.*2.+1 => m; set k := {2}1; rewrite -[2]/k.*2; set e := 0.\npose p := k.*2.+1; rewrite -{1}[m]mul1n -[1]/(p ^ e)%N.\nhave{def_m bc def_bc ltc2 ltbc3}:\n   let kb := (ifnz e k 1).*2 in\n   [&& k > 0, p < m, lb_dvd p m, c < kb & lb_dvd p p || (e == 0)]\n    /\\ m + (b * kb + c).*2 = p ^ 2 + (a * p).*2.\n- rewrite -def_m [in lb_dvd _ _]def_m; split=> //=; last first.\n    by rewrite -def_bc addSn -doubleD 2!addSn -addnA subnKC // addnC.\n  rewrite ltc2 /lb_dvd /index_iota /= dvdn2 -def_m.\n  by rewrite [_.+2]lock /= odd_double.\nhave [n] := ubnP a.\nelim: n => // n IHn in a (k) p m b c (e) * => /ltnSE-le_a_n [].\nset kb := _.*2; set d := _ + c => /and5P[lt0k ltpm leppm ltc pr_p def_m].\nhave def_k1: k.-1.+1 = k := ltn_predK lt0k.\nhave def_kb1: kb.-1.+1 = kb by rewrite /kb -def_k1; case e.\nhave eq_bc_0: (b == 0) && (c == 0) = (d == 0).\n  by rewrite addn_eq0 muln_eq0 orbC -def_kb1.\nhave lt1p: 1 < p by rewrite ltnS double_gt0.\nhave co_p_2: coprime p 2 by rewrite /coprime gcdnC gcdnE modn2 /= odd_double.\nhave if_d0: d = 0 -> [/\\ m = (p + a.*2) * p, lb_dvd p p & lb_dvd p (p + a.*2)].\n  move=> d0; have{d0} def_m: m = (p + a.*2) * p.\n    by rewrite d0 addn0 -!mul2n mulnA -mulnDl in def_m *.\n  split=> //; apply/hasPn=> r /(hasPn leppm); apply: contra => /= dv_r.\n    by rewrite def_m dvdn_mull.\n  by rewrite def_m dvdn_mulr.\ncase def_a: a => [|a'] /= in le_a_n *; rewrite !natTrecE -/p {}eq_bc_0.\n  case: d if_d0 def_m => [[//| def_m {}pr_p pr_m'] _ | d _ def_m] /=.\n    rewrite def_m def_a addn0 mulnA -2!expnSr.\n    by split; rewrite /pd_ord /pf_ok /= ?muln1 ?pr_p ?leqnn.\n  apply: apd_ok; rewrite // /pd_ok /= /pfactor expn1 muln1 /pd_ord /= ltpm.\n  rewrite /pf_ok !andbT /=; split=> //; apply: contra leppm.\n  case/hasP=> r /=; rewrite mem_index_iota => /andP[lt1r ltrm] dvrm; apply/hasP.\n  have [ltrp | lepr] := ltnP r p.\n    by exists r; rewrite // mem_index_iota lt1r.\n  case/dvdnP: dvrm => q def_q; exists q; last by rewrite def_q /= dvdn_mulr.\n  rewrite mem_index_iota -(ltn_pmul2r (ltnW lt1r)) -def_q mul1n ltrm.\n  move: def_m; rewrite def_a addn0 -(@ltn_pmul2r p) // mulnn => <-.\n  apply: (@leq_ltn_trans m); first by rewrite def_q leq_mul.\n  by rewrite -addn1 leq_add2l.\nhave def_k2: k.*2 = ifnz e 1 k * kb.\n  by rewrite /kb; case: (e) => [|e']; rewrite (mul1n, muln2).\ncase def_b': (b - _) => [|b']; last first.\n  have ->: ifnz e k.*2.-1 1 = kb.-1 by rewrite /kb; case e.\n  apply: IHn => {n le_a_n}//; rewrite -/p -/kb; split=> //.\n    rewrite lt0k ltpm leppm pr_p andbT /=.\n    by case: ifnzP; [move/ltn_predK->; apply: ltnW | rewrite def_kb1].\n  apply: (@addIn p.*2).\n  rewrite -2!addnA -!doubleD -addnA -mulSnr -def_a -def_m /d.\n  have ->: b * kb = b' * kb + (k.*2 - c * kb + kb).\n    rewrite addnCA addnC -mulSnr -def_b' def_k2 -mulnBl -mulnDl subnK //.\n    by rewrite ltnW // -subn_gt0 def_b'.\n  rewrite -addnA; congr (_ + (_ + _).*2).\n  case: (c) ltc; first by rewrite -addSnnS def_kb1 subn0 addn0 addnC.\n  rewrite /kb; case e => [[] // _ | e' c' _] /=; last first.\n    by rewrite subnDA subnn addnC addSnnS.\n  by rewrite mul1n -doubleB -doubleD subn1 !addn1 def_k1.\nhave ltdp: d < p.\n  move/eqP: def_b'; rewrite subn_eq0 -(@leq_pmul2r kb); last first.\n    by rewrite -def_kb1.\n  rewrite mulnBl -def_k2 ltnS -(leq_add2r c); move/leq_trans; apply.\n  have{} ltc: c < k.*2.\n    by apply: (leq_trans ltc); rewrite leq_double /kb; case e.\n  rewrite -{2}(subnK (ltnW ltc)) leq_add2r leq_sub2l //.\n  by rewrite -def_kb1 mulnS leq_addr.\ncase def_d: d if_d0 => [|d'] => [[//|{ltdp pr_p}def_m pr_p pr_m'] | _].\n  rewrite eqxx -doubleS -addnS -def_a doubleD -addSn -/p def_m.\n  rewrite mulnCA mulnC -expnSr.\n  apply: IHn => {n le_a_n}//; rewrite -/p -/kb; split.\n    rewrite lt0k -addn1 leq_add2l {1}def_a pr_m' pr_p /= def_k1 -addnn.\n    by rewrite leq_addr.\n  rewrite -addnA -doubleD addnCA def_a addSnnS def_k1 -(addnC k) -mulnSr.\n  by rewrite -[_.*2.+1]/p mulnDl doubleD addnA -mul2n mulnA mul2n -mulSn.\nhave next_pm: lb_dvd p.+2 m.\n  rewrite /lb_dvd /index_iota (addKn 2) -(subnK lt1p) iotaD has_cat.\n  apply/norP; split; rewrite //= orbF subnKC // orbC.\n  apply/norP; split; apply/dvdnP=> [[q def_q]].\n     case/hasP: leppm; exists 2; first by rewrite /p -(subnKC lt0k).\n    by rewrite /= def_q dvdn_mull // dvdn2 /= odd_double.\n  move/(congr1 (dvdn p)): def_m; rewrite -!mul2n mulnA -mulnDl.\n  rewrite dvdn_mull // dvdn_addr; last by rewrite def_q dvdn_mull.\n  case/dvdnP=> r; rewrite mul2n => def_r; move: ltdp (congr1 odd def_r).\n  rewrite odd_double -ltn_double def_r -mul2n ltn_pmul2r //.\n  by case: r def_r => [|[|[]]] //; rewrite def_d // mul1n /= odd_double.\napply: apd_ok => //; case: a' def_a le_a_n => [|a'] def_a => [_ | lta] /=.\n  rewrite /pd_ok /= /pfactor expn1 muln1 /pd_ord /= ltpm /pf_ok !andbT /=.\n  split=> //; apply: contra next_pm.\n  case/hasP=> q; rewrite mem_index_iota => /andP[lt1q ltqm] dvqm; apply/hasP.\n  have [ltqp | lepq] := ltnP q p.+2.\n    by exists q; rewrite // mem_index_iota lt1q.\n  case/dvdnP: dvqm => r def_r; exists r; last by rewrite def_r /= dvdn_mulr.\n  rewrite mem_index_iota -(ltn_pmul2r (ltnW lt1q)) -def_r mul1n ltqm /=.\n  rewrite -(@ltn_pmul2l p.+2) //; apply: (@leq_ltn_trans m).\n    by rewrite def_r mulnC leq_mul.\n  rewrite -addn2 mulnn sqrnD mul2n muln2 -addnn addnACA.\n  by rewrite def_a mul1n in def_m; rewrite -def_m addnS /= ltnS -addnA leq_addr.\nset bc := ifnz _ _ _; apply: leq_pd_ok (leqnSn _) _.\nrewrite -doubleS -{1}[m]mul1n -[1]/(k.+1.*2.+1 ^ 0)%N.\napply: IHn; first exact: ltnW.\nrewrite doubleS -/p [ifnz 0 _ _]/=; do 2?split => //.\n  rewrite orbT next_pm /= -(leq_add2r d.*2) def_m 2!addSnnS -doubleS leq_add.\n  - move: ltc; rewrite /kb {}/bc andbT; case e => //= e' _; case: ifnzP => //.\n    by case: edivn2P.\n  - by rewrite -[ltnLHS]muln1 ltn_pmul2l.\n  by rewrite leq_double def_a mulSn (leq_trans ltdp) ?leq_addr.\nrewrite mulnDl !muln2 -addnA addnCA doubleD addnCA.\nrewrite (_ : _ + bc.2 = d); last first.\n  rewrite /d {}/bc /kb -muln2.\n  case: (e) (b) def_b' => //= _ []; first by case: edivn2P.\n  by case c; do 2?case; rewrite // mul1n /= muln2.\nrewrite def_m 3!doubleS addnC -(addn2 p) sqrnD mul2n muln2 -3!addnA.\ncongr (_ + _); rewrite 4!addnS -!doubleD; congr _.*2.+2.+2.\nby rewrite def_a -add2n mulnDl -addnA -muln2 -mulnDr mul2n.\nQed.",
    "Lemma primePn n :\n  reflect (n < 2 \\/ exists2 d, 1 < d < n & d %| n) (~~ prime n).\nProof.\nrewrite /prime; case: n => [|[|p2]]; try by do 2!left.\ncase: (@prime_decomp_correct p2.+2) => //; rewrite unlock.\ncase: prime_decomp => [|[q [|[|e]]] pd] //=; last first; last by rewrite andbF.\n  rewrite {1}/pfactor 2!expnS -!mulnA /=.\n  case: (_ ^ _ * _) => [|u -> _ /andP[lt1q _]]; first by rewrite !muln0.\n  left; right; exists q; last by rewrite dvdn_mulr.\n  have lt0q := ltnW lt1q; rewrite lt1q -[ltnLHS]muln1 ltn_pmul2l //.\n  by rewrite -[2]muln1 leq_mul.\nrewrite {1}/pfactor expn1; case: pd => [|[r e] pd] /=; last first.\n  case: e => [|e] /=; first by rewrite !andbF.\n  rewrite {1}/pfactor expnS -mulnA.\n  case: (_ ^ _ * _) => [|u -> _ /and3P[lt1q ltqr _]]; first by rewrite !muln0.\n  left; right; exists q; last by rewrite dvdn_mulr.\n  by rewrite lt1q -[ltnLHS]mul1n ltn_mul // -[q.+1]muln1 leq_mul.\nrewrite muln1 !andbT => def_q pr_q lt1q; right=> [[]] // [d].\nby rewrite def_q -mem_index_iota => in_d_2q dv_d_q; case/hasP: pr_q; exists d.\nQed.",
    "Lemma primeNsig n : ~~ prime n -> 2 <= n -> { d : nat | 1 < d < n & d %| n }.\nProof.\nby move=> /primePn; case: ltnP => // lt1n nP _; apply/sig2W; case: nP.\nQed.",
    "Lemma primeP p :\n  reflect (p > 1 /\\ forall d, d %| p -> xpred2 1 p d) (prime p).\nProof.\nrewrite -[prime p]negbK; have [npr_p | pr_p] := primePn p.\n  right=> [[lt1p pr_p]]; case: npr_p => [|[d n1pd]].\n    by rewrite ltnNge lt1p.\n  by move/pr_p=> /orP[] /eqP def_d; rewrite def_d ltnn ?andbF in n1pd.\nhave [lep1 | lt1p] := leqP; first by case: pr_p; left.\nleft; split=> // d dv_d_p; apply/norP=> [[nd1 ndp]]; case: pr_p; right.\nexists d; rewrite // andbC 2!ltn_neqAle ndp eq_sym nd1.\nby have lt0p := ltnW lt1p; rewrite dvdn_leq // (dvdn_gt0 lt0p).\nQed.",
    "Lemma prime_nt_dvdP d p : prime p -> d != 1 -> reflect (d = p) (d %| p).\nProof.\ncase/primeP=> _ min_p d_neq1; apply: (iffP idP) => [/min_p|-> //].\nby rewrite (negPf d_neq1) /= => /eqP.\nQed.",
    "Lemma prime_gt1 p : prime p -> 1 < p.\nProof. by case/primeP. Qed.",
    "Lemma prime_gt0 p : prime p -> 0 < p.\nProof. by move/prime_gt1; apply: ltnW. Qed.",
    "Lemma prod_prime_decomp n :\n  n > 0 -> n = \\prod_(f <- prime_decomp n) f.1 ^ f.2.\nProof. by case/prime_decomp_correct. Qed.",
    "Lemma even_prime p : prime p -> p = 2 \\/ odd p.\nProof.\nmove=> pr_p; case odd_p: (odd p); [by right | left].\nhave: 2 %| p by rewrite dvdn2 odd_p.\nby case/primeP: pr_p => _ dv_p /dv_p/(2 =P p).\nQed.",
    "Lemma prime_oddPn p : prime p -> reflect (p = 2) (~~ odd p).\nProof.\nby move=> p_pr; apply: (iffP idP) => [|-> //]; case/even_prime: p_pr => ->.\nQed.",
    "Lemma odd_prime_gt2 p : odd p -> prime p -> p > 2.\nProof. by move=> odd_p /prime_gt1; apply: odd_gt2. Qed.",
    "Lemma mem_prime_decomp n p e :\n  (p, e) \\in prime_decomp n -> [/\\ prime p, e > 0 & p ^ e %| n].\nProof.\ncase: (posnP n) => [-> //| /prime_decomp_correct[def_n mem_pd ord_pd pd_pe]].\nhave /andP[pr_p ->] := allP mem_pd _ pd_pe; split=> //; last first.\n  case/splitPr: pd_pe def_n => pd1 pd2 ->.\n  by rewrite big_cat big_cons /= mulnCA dvdn_mulr.\nhave lt1p: 1 < p.\n  apply: (allP (order_path_min ltn_trans ord_pd)).\n  by apply/mapP; exists (p, e).\napply/primeP; split=> // d dv_d_p; apply/norP=> [[nd1 ndp]].\ncase/hasP: pr_p; exists d => //.\nrewrite mem_index_iota andbC 2!ltn_neqAle ndp eq_sym nd1.\nby have lt0p := ltnW lt1p; rewrite dvdn_leq // (dvdn_gt0 lt0p).\nQed.",
    "Lemma prime_coprime p m : prime p -> coprime p m = ~~ (p %| m).\nProof.\ncase/primeP=> p_gt1 p_pr; apply/eqP/negP=> [d1 | ndv_pm].\n  case/dvdnP=> k def_m; rewrite -(addn0 m) def_m gcdnMDl gcdn0 in d1.\n  by rewrite d1 in p_gt1.\nby apply: gcdn_def => // d /p_pr /orP[] /eqP->.\nQed.",
    "Lemma dvdn_prime2 p q : prime p -> prime q -> (p %| q) = (p == q).\nProof.\nmove=> pr_p pr_q; apply: negb_inj.\nby rewrite eqn_dvd negb_and -!prime_coprime // coprime_sym orbb.\nQed.",
    "Lemma Euclid_dvd1 p : prime p -> (p %| 1) = false.\nProof. by rewrite dvdn1; case: eqP => // ->. Qed.",
    "Lemma Euclid_dvdM m n p : prime p -> (p %| m * n) = (p %| m) || (p %| n).\nProof.\nmove=> pr_p; case dv_pm: (p %| m); first exact: dvdn_mulr.\nby rewrite Gauss_dvdr // prime_coprime // dv_pm.\nQed.",
    "Lemma Euclid_dvd_prod (I : Type) (r : seq I) (P : pred I) (f : I -> nat) p :\n  prime p ->\n  p %| \\prod_(i <- r | P i) f i = \\big[orb/false]_(i <- r | P i) (p %| f i).\nProof.\nmove=> pP; apply: big_morph=> [x y|]; [exact: Euclid_dvdM | exact: Euclid_dvd1].\nQed.",
    "Lemma Euclid_dvdX m n p : prime p -> (p %| m ^ n) = (p %| m) && (n > 0).\nProof.\ncase: n => [|n] pr_p; first by rewrite andbF Euclid_dvd1.\nby apply: (inv_inj negbK); rewrite !andbT -!prime_coprime // coprime_pexpr.\nQed.",
    "Lemma mem_primes p n : (p \\in primes n) = [&& prime p, n > 0 & p %| n].\nProof.\nrewrite andbCA; have [-> // | /= n_gt0] := posnP.\napply/mapP/andP=> [[[q e]]|[pr_p]] /=.\n  case/mem_prime_decomp=> pr_q e_gt0 /dvdnP [u ->] -> {p}.\n  by rewrite -(prednK e_gt0) expnS mulnCA dvdn_mulr.\nrewrite [n in _ %| n]prod_prime_decomp // big_seq.\napply big_ind => [| u v IHu IHv | [q e] /= mem_qe dv_p_qe].\n- by rewrite Euclid_dvd1.\n- by rewrite Euclid_dvdM // => /orP[].\nexists (q, e) => //=; case/mem_prime_decomp: mem_qe => pr_q _ _.\nby rewrite Euclid_dvdX // dvdn_prime2 // in dv_p_qe; case: eqP dv_p_qe.\nQed.",
    "Lemma sorted_primes n : sorted ltn (primes n).\nProof.\nby case: (posnP n) => [-> // | /prime_decomp_correct[_ _]]; apply: path_sorted.\nQed.",
    "Lemma all_prime_primes n : all prime (primes n).\nProof. by apply/allP => p; rewrite mem_primes => /and3P[]. Qed.",
    "Lemma eq_primes m n : (primes m =i primes n) <-> (primes m = primes n).\nProof.\nsplit=> [eqpr| -> //].\nby apply: (irr_sorted_eq ltn_trans ltnn); rewrite ?sorted_primes.\nQed.",
    "Lemma primes_uniq n : uniq (primes n).\nProof. exact: (sorted_uniq ltn_trans ltnn (sorted_primes n)). Qed.",
    "Lemma pi_pdiv n : (pdiv n \\in \\pi(n)) = (n > 1).\nProof.\ncase: n => [|[|n]] //; rewrite /pdiv !inE /primes.\nhave:= prod_prime_decomp (ltn0Sn n.+1); rewrite unlock.\nby case: prime_decomp => //= pf pd _; rewrite mem_head.\nQed.",
    "Lemma pdiv_prime n : 1 < n -> prime (pdiv n).\nProof. by rewrite -pi_pdiv mem_primes; case/and3P. Qed.",
    "Lemma pdiv_dvd n : pdiv n %| n.\nProof. by case: n (pi_pdiv n) => [|[|n]] //; rewrite mem_primes=> /and3P[]. Qed.",
    "Lemma pi_max_pdiv n : (max_pdiv n \\in \\pi(n)) = (n > 1).\nProof.\nrewrite !inE -pi_pdiv /max_pdiv /pdiv !inE.\nby case: (primes n) => //= p ps; rewrite mem_head mem_last.\nQed.",
    "Lemma max_pdiv_prime n : n > 1 -> prime (max_pdiv n).\nProof. by rewrite -pi_max_pdiv mem_primes => /andP[]. Qed.",
    "Lemma max_pdiv_dvd n : max_pdiv n %| n.\nProof.\nby case: n (pi_max_pdiv n) => [|[|n]] //; rewrite mem_primes => /andP[].\nQed.",
    "Lemma pdiv_leq n : 0 < n -> pdiv n <= n.\nProof. by move=> n_gt0; rewrite dvdn_leq // pdiv_dvd. Qed.",
    "Lemma max_pdiv_leq n : 0 < n -> max_pdiv n <= n.\nProof. by move=> n_gt0; rewrite dvdn_leq // max_pdiv_dvd. Qed.",
    "Lemma pdiv_gt0 n : 0 < pdiv n.\nProof. by case: n => [|[|n]] //; rewrite prime_gt0 ?pdiv_prime. Qed.",
    "Lemma max_pdiv_gt0 n : 0 < max_pdiv n.\nProof. by case: n => [|[|n]] //; rewrite prime_gt0 ?max_pdiv_prime. Qed.",
    "Lemma pdiv_min_dvd m d : 1 < d -> d %| m -> pdiv m <= d.\nProof.\ncase: (posnP m) => [->|mpos] lt1d dv_d_m; first exact: ltnW.\nrewrite /pdiv; apply: leq_trans (pdiv_leq (ltnW lt1d)).\nhave: pdiv d \\in primes m.\n  by rewrite mem_primes mpos pdiv_prime // (dvdn_trans (pdiv_dvd d)).\ncase: (primes m) (sorted_primes m) => //= p pm ord_pm; rewrite inE.\nby case/predU1P => [-> | /(allP (order_path_min ltn_trans ord_pm)) /ltnW].\nQed.",
    "Lemma max_pdiv_max n p : p \\in \\pi(n) -> p <= max_pdiv n.\nProof.\nrewrite /max_pdiv !inE => n_p.\ncase/splitPr: n_p (sorted_primes n) => p1 p2; rewrite last_cat -cat_rcons /=.\nrewrite headI /= cat_path -(last_cons 0) -headI last_rcons; case/andP=> _.\nmove/(order_path_min ltn_trans); case/lastP: p2 => //= p2 q.\nby rewrite all_rcons last_rcons ltn_neqAle -andbA => /and3P[].\nQed.",
    "Lemma ltn_pdiv2_prime n : 0 < n -> n < pdiv n ^ 2 -> prime n.\nProof.\ncase def_n: n => [|[|n']] // _; rewrite -def_n => lt_n_p2.\nsuffices ->: n = pdiv n by rewrite pdiv_prime ?def_n.\napply/eqP; rewrite eqn_leq leqNgt andbC pdiv_leq; last by rewrite def_n.\napply/contraL: lt_n_p2 => lt_pm_m; case/dvdnP: (pdiv_dvd n) => q def_q.\nrewrite -leqNgt [leqRHS]def_q leq_pmul2r // pdiv_min_dvd //.\n  by rewrite -[pdiv n]mul1n [ltnRHS]def_q ltn_pmul2r in lt_pm_m.\nby rewrite def_q dvdn_mulr.\nQed.",
    "Lemma primePns n :\n  reflect (n < 2 \\/ exists p, [/\\ prime p, p ^ 2 <= n & p %| n]) (~~ prime n).\nProof.\napply: (iffP idP) => [npr_p|]; last first.\n  case=> [|[p [pr_p le_p2_n dv_p_n]]]; first by case: n => [|[]].\n  apply/negP=> pr_n; move: dv_p_n le_p2_n; rewrite dvdn_prime2 //; move/eqP->.\n  by rewrite leqNgt -[ltnLHS]muln1 ltn_pmul2l ?prime_gt1 ?prime_gt0.\nhave [lt1p|] := leqP; [right | by left].\nexists (pdiv n); rewrite pdiv_dvd pdiv_prime //; split=> //.\nby case: leqP npr_p => // /ltn_pdiv2_prime -> //; exact: ltnW.\nQed.",
    "Lemma pdivP n : n > 1 -> {p | prime p & p %| n}.\nProof. by move=> lt1n; exists (pdiv n); rewrite ?pdiv_dvd ?pdiv_prime. Qed.",
    "Lemma primes_eq0 n : (primes n == [::]) = (n < 2).\nProof.\ncase: n => [|[|n']]//=; have [//|p pp pn] := @pdivP (n'.+2).\nsuff: p \\in primes n'.+2 by case: primes.\nby rewrite mem_primes pp pn.\nQed.",
    "Lemma primesM m n p : m > 0 -> n > 0 ->\n  (p \\in primes (m * n)) = (p \\in primes m) || (p \\in primes n).\nProof.\nmove=> m_gt0 n_gt0; rewrite !mem_primes muln_gt0 m_gt0 n_gt0.\nby case pr_p: (prime p); rewrite // Euclid_dvdM.\nQed.",
    "Lemma primesX m n : n > 0 -> primes (m ^ n) = primes m.\nProof.\ncase: n => // n _; rewrite expnS; have [-> // | m_gt0] := posnP m.\napply/eq_primes => /= p; elim: n => [|n IHn]; first by rewrite muln1.\nby rewrite primesM ?(expn_gt0, expnS, IHn, orbb, m_gt0).\nQed.",
    "Lemma primes_prime p : prime p -> primes p = [:: p].\nProof.\nmove=> pr_p; apply: (irr_sorted_eq ltn_trans ltnn) => // [|q].\n  exact: sorted_primes.\nrewrite mem_seq1 mem_primes prime_gt0 //=.\nby apply/andP/idP=> [[pr_q q_p] | /eqP-> //]; rewrite -dvdn_prime2.\nQed.",
    "Lemma coprime_has_primes m n :\n  0 < m -> 0 < n -> coprime m n = ~~ has [in primes m] (primes n).\nProof.\nmove=> m_gt0 n_gt0; apply/eqP/hasPn=> [mn1 p | no_p_mn].\n  rewrite /= !mem_primes m_gt0 n_gt0 /= => /andP[pr_p p_n].\n  have:= prime_gt1 pr_p; rewrite pr_p ltnNge -mn1 /=; apply: contra => p_m.\n  by rewrite dvdn_leq ?gcdn_gt0 ?m_gt0 // dvdn_gcd ?p_m.\napply/eqP; rewrite eqn_leq gcdn_gt0 m_gt0 andbT leqNgt; apply/negP.\nmove/pdiv_prime; set p := pdiv _ => pr_p.\nmove/implyP: (no_p_mn p); rewrite /= !mem_primes m_gt0 n_gt0 pr_p /=.\nby rewrite !(dvdn_trans (pdiv_dvd _)) // (dvdn_gcdl, dvdn_gcdr).\nQed.",
    "Lemma pdiv_id p : prime p -> pdiv p = p.\nProof. by move=> p_pr; rewrite /pdiv primes_prime. Qed.",
    "Lemma pdiv_pfactor p k : prime p -> pdiv (p ^ k.+1) = p.\nProof. by move=> p_pr; rewrite /pdiv primesX ?primes_prime. Qed.",
    "Lemma prime_above m : {p | m < p & prime p}.\nProof.\nhave /pdivP[p pr_p p_dv_m1]: 1 < m`! + 1 by rewrite addn1 ltnS fact_gt0.\nexists p => //; rewrite ltnNge; apply: contraL p_dv_m1 => p_le_m.\nby rewrite dvdn_addr ?dvdn_fact ?prime_gt0 // gtnNdvd ?prime_gt1.\nQed.",
    "Lemma lognE p m :\n  logn p m = if [&& prime p, 0 < m & p %| m] then (logn p (m %/ p)).+1 else 0.\nProof.\nrewrite /logn /dvdn; case p_pr: (prime p) => //.\ncase def_m: m => // [m']; rewrite !andTb [LHS]/= -def_m /divn modn_def.\ncase: edivnP def_m => [[|q] [|r] -> _] // def_m; congr _.+1; rewrite [_.1]/=.\nhave{m def_m}: q < m'.\n  by rewrite -ltnS -def_m addn0 mulnC -{1}[q.+1]mul1n ltn_pmul2r // prime_gt1.\nelim/ltn_ind: m' {q}q.+1 (ltn0Sn q) => -[_ []|r IHr m] //= m_gt0 le_mr.\nrewrite -[m in logn_rec _ _ m]prednK //=.\ncase: edivnP => [[|q] [|_] def_q _] //; rewrite addn0 in def_q.\nhave{def_q} lt_qm1: q < m.-1.\n  by rewrite -[q.+1]muln1 -ltnS prednK // def_q ltn_pmul2l // prime_gt1.\nhave{le_mr} le_m1r: m.-1 <= r by rewrite -ltnS prednK.\nby rewrite (IHr r) ?(IHr m.-1) // (leq_trans lt_qm1).\nQed.",
    "Lemma logn_gt0 p n : (0 < logn p n) = (p \\in primes n).\nProof. by rewrite lognE -mem_primes; case: {+}(p \\in _). Qed.",
    "Lemma ltn_log0 p n : n < p -> logn p n = 0.\nProof. by case: n => [|n] ltnp; rewrite lognE ?andbF // gtnNdvd ?andbF. Qed.",
    "Lemma logn0 p : logn p 0 = 0.\nProof. by rewrite /logn if_same. Qed.",
    "Lemma logn1 p : logn p 1 = 0.\nProof. by rewrite lognE dvdn1 /= andbC; case: eqP => // ->. Qed.",
    "Lemma pfactor_gt0 p n : 0 < p ^ logn p n.\nProof. by rewrite expn_gt0 lognE; case: (posnP p) => // ->. Qed.",
    "Lemma pfactor_dvdn p n m : prime p -> m > 0 -> (p ^ n %| m) = (n <= logn p m).\nProof.\nmove=> p_pr; elim: n m => [|n IHn] m m_gt0; first exact: dvd1n.\nrewrite lognE p_pr m_gt0 /=; case dv_pm: (p %| m); last first.\n  apply/dvdnP=> [] [/= q def_m].\n  by rewrite def_m expnS mulnCA dvdn_mulr in dv_pm.\ncase/dvdnP: dv_pm m_gt0 => q ->{m}; rewrite muln_gt0 => /andP[p_gt0 q_gt0].\nby rewrite expnSr dvdn_pmul2r // mulnK // IHn.\nQed.",
    "Lemma pfactor_dvdnn p n : p ^ logn p n %| n.\nProof.\ncase: n => // n; case pr_p: (prime p); first by rewrite pfactor_dvdn.\nby rewrite lognE pr_p dvd1n.\nQed.",
    "Lemma logn_prime p q : prime q -> logn p q = (p == q).\nProof.\nmove=> pr_q; have q_gt0 := prime_gt0 pr_q; rewrite lognE q_gt0 /=.\ncase pr_p: (prime p); last by case: eqP pr_p pr_q => // -> ->.\nby rewrite dvdn_prime2 //; case: eqP => // ->; rewrite divnn q_gt0 logn1.\nQed.",
    "Lemma pfactor_coprime p n :\n  prime p -> n > 0 -> {m | coprime p m & n = m * p ^ logn p n}.\nProof.\nmove=> p_pr n_gt0; set k := logn p n.\nhave dv_pk_n: p ^ k %| n by rewrite pfactor_dvdn.\nexists (n %/ p ^ k); last by rewrite divnK.\nrewrite prime_coprime // -(@dvdn_pmul2r (p ^ k)) ?expn_gt0 ?prime_gt0 //.\nby rewrite -expnS divnK // pfactor_dvdn // ltnn.\nQed.",
    "Lemma pfactorK p n : prime p -> logn p (p ^ n) = n.\nProof.\nmove=> p_pr; have pn_gt0: p ^ n > 0 by rewrite expn_gt0 prime_gt0.\napply/eqP; rewrite eqn_leq -pfactor_dvdn // dvdnn andbT.\nby rewrite -(leq_exp2l _ _ (prime_gt1 p_pr)) dvdn_leq // pfactor_dvdn.\nQed.",
    "Lemma pfactorKpdiv p n : prime p -> logn (pdiv (p ^ n)) (p ^ n) = n.\nProof. by case: n => // n p_pr; rewrite pdiv_pfactor ?pfactorK. Qed.",
    "Lemma dvdn_leq_log p m n : 0 < n -> m %| n -> logn p m <= logn p n.\nProof.\nmove=> n_gt0 dv_m_n; have m_gt0 := dvdn_gt0 n_gt0 dv_m_n.\ncase p_pr: (prime p); last by do 2!rewrite lognE p_pr /=.\nby rewrite -pfactor_dvdn //; apply: dvdn_trans dv_m_n; rewrite pfactor_dvdn.\nQed.",
    "Lemma ltn_logl p n : 0 < n -> logn p n < n.\nProof.\nmove=> n_gt0; have [p_gt1 | p_le1] := boolP (1 < p).\n  by rewrite (leq_trans (ltn_expl _ p_gt1)) // dvdn_leq ?pfactor_dvdnn.\nby rewrite lognE (contraNF (@prime_gt1 _)).\nQed.",
    "Lemma logn_Gauss p m n : coprime p m -> logn p (m * n) = logn p n.\nProof.\nmove=> co_pm; case p_pr: (prime p); last by rewrite /logn p_pr.\nhave [-> | n_gt0] := posnP n; first by rewrite muln0.\nhave [m0 | m_gt0] := posnP m; first by rewrite m0 prime_coprime ?dvdn0 in co_pm.\nhave mn_gt0: m * n > 0 by rewrite muln_gt0 m_gt0.\napply/eqP; rewrite eqn_leq andbC dvdn_leq_log ?dvdn_mull //.\nset k := logn p _; have: p ^ k %| m * n by rewrite pfactor_dvdn.\nby rewrite Gauss_dvdr ?coprimeXl // -pfactor_dvdn.\nQed.",
    "Lemma logn_coprime p m : coprime p m -> logn p m = 0.\nProof. by move=> coprime_pm; rewrite -[m]muln1 logn_Gauss// logn1. Qed.",
    "Lemma lognM p m n : 0 < m -> 0 < n -> logn p (m * n) = logn p m + logn p n.\nProof.\ncase p_pr: (prime p); last by rewrite /logn p_pr.\nhave xlp := pfactor_coprime p_pr.\ncase/xlp=> m' co_m' def_m /xlp[n' co_n' def_n] {xlp}.\nrewrite [in LHS]def_m [in LHS]def_n mulnCA -mulnA -expnD !logn_Gauss //.\nexact: pfactorK.\nQed.",
    "Lemma lognX p m n : logn p (m ^ n) = n * logn p m.\nProof.\ncase p_pr: (prime p); last by rewrite /logn p_pr muln0.\nelim: n => [|n IHn]; first by rewrite logn1.\nhave [->|m_gt0] := posnP m; first by rewrite exp0n // lognE andbF muln0.\nby rewrite expnS lognM ?IHn // expn_gt0 m_gt0.\nQed.",
    "Lemma logn_div p m n : m %| n -> logn p (n %/ m) = logn p n - logn p m.\nProof.\nrewrite dvdn_eq => /eqP def_n.\ncase: (posnP n) => [-> |]; first by rewrite div0n logn0.\nby rewrite -{1 3}def_n muln_gt0 => /andP[q_gt0 m_gt0]; rewrite lognM ?addnK.\nQed.",
    "Lemma dvdn_pfactor p d n : prime p ->\n  reflect (exists2 m, m <= n & d = p ^ m) (d %| p ^ n).\nProof.\nmove=> p_pr; have pn_gt0: p ^ n > 0 by rewrite expn_gt0 prime_gt0.\napply: (iffP idP) => [dv_d_pn|[m le_m_n ->]]; last first.\n  by rewrite -(subnK le_m_n) expnD dvdn_mull.\nexists (logn p d); first by rewrite -(pfactorK n p_pr) dvdn_leq_log.\nhave d_gt0: d > 0 by apply: dvdn_gt0 dv_d_pn.\ncase: (pfactor_coprime p_pr d_gt0) => q co_p_q def_d.\nrewrite [LHS]def_d ((q =P 1) _) ?mul1n // -dvdn1.\nsuff: q %| p ^ n * 1 by rewrite Gauss_dvdr // coprime_sym coprimeXl.\nby rewrite muln1 (dvdn_trans _ dv_d_pn) // def_d dvdn_mulr.\nQed.",
    "Lemma prime_decompE n : prime_decomp n = [seq (p, logn p n) | p <- primes n].\nProof.\ncase: n => // n; pose f0 := (0, 0); rewrite -map_comp.\napply: (@eq_from_nth _ f0) => [|i lt_i_n]; first by rewrite size_map.\nrewrite (nth_map f0) //; case def_f: (nth _ _ i) => [p e] /=.\ncongr (_, _); rewrite [n.+1]prod_prime_decomp //.\nhave: (p, e) \\in prime_decomp n.+1 by rewrite -def_f mem_nth.\ncase/mem_prime_decomp=> pr_p _ _.\nrewrite (big_nth f0) big_mkord (bigD1 (Ordinal lt_i_n)) //=.\nrewrite def_f mulnC logn_Gauss ?pfactorK //.\napply big_ind => [|m1 m2 com1 com2| [j ltj] /=]; first exact: coprimen1.\n  by rewrite coprimeMr com1.\nrewrite -val_eqE /= => nji; case def_j: (nth _ _ j) => [q e1] /=.\nhave: (q, e1) \\in prime_decomp n.+1 by rewrite -def_j mem_nth.\ncase/mem_prime_decomp=> pr_q e1_gt0 _; rewrite coprime_pexpr //.\nrewrite prime_coprime // dvdn_prime2 //; apply: contra nji => eq_pq.\nrewrite -(nth_uniq 0 _ _ (primes_uniq n.+1)) ?size_map //=.\nby rewrite !(nth_map f0) //  def_f def_j /= eq_sym.\nQed.",
    "Lemma divn_count_dvd d n : n %/ d = \\sum_(1 <= i < n.+1) (d %| i).\nProof.\nhave [-> | d_gt0] := posnP d; first by rewrite big_add1 divn0 big1.\napply: (@addnI (d %| 0)); rewrite -(@big_ltn _ 0 _ 0 _ (dvdn d)) // big_mkord.\nrewrite (partition_big (fun i : 'I_n.+1 => inord (i %/ d)) 'I_(n %/ d).+1) //=.\nrewrite dvdn0 add1n -[_.+1 in LHS]card_ord -sum1_card.\napply: eq_bigr => [[q ?] _].\nrewrite (bigD1 (inord (q * d))) /eq_op /= !inordK ?ltnS -?leq_divRL ?mulnK //.\nrewrite dvdn_mull ?big1 // => [[i /= ?] /andP[/eqP <- /negPf]].\nby rewrite eq_sym dvdn_eq inordK ?ltnS ?leq_div2r // => ->.\nQed.",
    "Lemma logn_count_dvd p n : prime p -> logn p n = \\sum_(1 <= k < n) (p ^ k %| n).\nProof.\nrewrite big_add1 => p_prime; case: n => [|n]; first by rewrite logn0 big_geq.\nrewrite big_mkord -big_mkcond (eq_bigl _ _ (fun _ => pfactor_dvdn _ _ _)) //=.\nby rewrite big_ord_narrow ?sum1_card ?card_ord // -ltnS ltn_logl.\nQed.",
    "Lemma trunc_log0 p : trunc_log p 0 = 0.\nProof. by case: p => [] // []. Qed.",
    "Lemma trunc_log1 p : trunc_log p 1 = 0.\nProof. by case: p => [|[]]. Qed.",
    "Lemma trunc_log_bounds p n :\n  1 < p -> 0 < n -> let k := trunc_log p n in p ^ k <= n < p ^ k.+1.\nProof.\nrewrite {+}/trunc_log => p_gt1; have p_gt0 := ltnW p_gt1.\nrewrite [p <= 1]leqNgt p_gt1 /=.\nset loop := (loop in loop n n); set m := n; rewrite [in n in loop m n]/m.\nhave: m <= n by []; elim: n m => [|n IHn] [|m] //= /ltnSE-le_m_n _.\nhave [le_p_n | // ] := leqP p _; rewrite 2!expnSr -leq_divRL -?ltn_divLR //.\nby apply: IHn; rewrite ?divn_gt0 // -ltnS (leq_trans (ltn_Pdiv _ _)).\nQed.",
    "Lemma trunc_logP p n : 1 < p -> 0 < n -> p ^ trunc_log p n <= n.\nProof. by move=> p_gt1 /(trunc_log_bounds p_gt1)/andP[]. Qed.",
    "Lemma trunc_log_ltn p n : 1 < p -> n < p ^ (trunc_log p n).+1.\nProof.\nhave [-> | n_gt0] := posnP n; first by rewrite trunc_log0 => /ltnW.\nby case/trunc_log_bounds/(_ n_gt0)/andP.\nQed.",
    "Lemma trunc_log_max p k j : 1 < p -> p ^ j <= k -> j <= trunc_log p k.\nProof.\nmove=> p_gt1 le_pj_k; rewrite -ltnS -(@ltn_exp2l p) //.\nexact: leq_ltn_trans (trunc_log_ltn _ _).\nQed.",
    "Lemma trunc_log_eq0 p n : (trunc_log p n == 0) = (p <= 1) || (n <= p.-1).\nProof.\ncase: p => [|[|p]]; case: n => // n; rewrite /= ltnS.\nhave /= /andP[] := trunc_log_bounds (isT : 1 < p.+2) (isT : 0 < n.+1).\ncase: trunc_log => [//|k] b1 b2.\napply/idP/idP => [/eqP sk0 | nlep]; first by move: b2; rewrite sk0.\nsymmetry; rewrite -[_ == _]/false /is_true -b1; apply/negbTE; rewrite -ltnNge.\nmove: nlep; rewrite -ltnS => nlep; apply: (leq_ltn_trans nlep).\nby rewrite -[leqLHS]expn1; apply: leq_pexp2l.\nQed.",
    "Lemma trunc_log_gt0 p n : (0 < trunc_log p n) = (1 < p) && (p.-1 < n).\nProof. by rewrite ltnNge leqn0 trunc_log_eq0 negb_or -!ltnNge. Qed.",
    "Lemma trunc_log0n n : trunc_log 0 n = 0.\nProof. by []. Qed.",
    "Lemma trunc_log1n n : trunc_log 1 n = 0.\nProof. by []. Qed.",
    "Lemma leq_trunc_log p m n : m <= n -> trunc_log p m <= trunc_log p n.\nProof.\nmove=> mlen; case: p => [|[|p]]; rewrite ?trunc_log0n ?trunc_log1n //.\ncase: m mlen => [|m] mlen; first by rewrite trunc_log0.\napply/trunc_log_max => //; apply: leq_trans mlen; exact: trunc_logP.\nQed.",
    "Lemma trunc_log_eq p n k : 1 < p -> p ^ n <= k < p ^ n.+1 -> trunc_log p k = n.\nProof.\nmove=> p_gt1 /andP[npLk kLpn]; apply/anti_leq.\nrewrite trunc_log_max// andbT -ltnS -(ltn_exp2l _ _ p_gt1).\napply: leq_ltn_trans kLpn; apply: trunc_logP => //.\nby apply: leq_trans npLk; rewrite expn_gt0 ltnW.\nQed.",
    "Lemma trunc_lognn p : 1 < p -> trunc_log p p = 1.\nProof. by case: p => [|[|p]] // _; rewrite /trunc_log ltnSn divnn. Qed.",
    "Lemma trunc_expnK p n : 1 < p -> trunc_log p (p ^ n) = n.\nProof. by move=> ?; apply: trunc_log_eq; rewrite // leqnn ltn_exp2l /=. Qed.",
    "Lemma trunc_logMp p n : 1 < p -> 0 < n ->\n  trunc_log p (p * n) = (trunc_log p n).+1.\nProof.\ncase: p => [//|p] => p_gt0 n_gt0; apply: trunc_log_eq => //.\nrewrite expnS leq_pmul2l// trunc_logP//=.\nby rewrite expnS ltn_pmul2l// trunc_log_ltn.\nQed.",
    "Lemma trunc_log2_double n : 0 < n -> trunc_log 2 n.*2 = (trunc_log 2 n).+1.\nProof. by move=> n_gt0; rewrite -mul2n trunc_logMp. Qed.",
    "Lemma trunc_log2S n : 1 < n -> trunc_log 2 n = (trunc_log 2 n./2).+1.\nProof.\nmove=> n_gt1.\nrewrite -trunc_log2_double ?half_gt0//.\nrewrite -[n in LHS]odd_double_half.\ncase: odd => //; rewrite add1n.\napply: trunc_log_eq => //.\nrewrite leqW ?trunc_logP //= ?double_gt0 ?half_gt0//.\nrewrite trunc_log2_double ?half_gt0// expnS.\nby rewrite -doubleS mul2n leq_double trunc_log_ltn.\nQed.",
    "Lemma up_log0 p : up_log p 0 = 0.\nProof. by case: p => // [] []. Qed.",
    "Lemma up_log1 p : up_log p 1 = 0.\nProof. by case: p => // [] []. Qed.",
    "Lemma up_log_eq0 p n : (up_log p n == 0) = (p <= 1) || (n <= 1).\nProof.\ncase: p => // [] [] // p.\ncase: n => [|[|n]]; rewrite /up_log //=.\nhave /= := trunc_log_bounds (isT : 1 < p.+2) (isT : 0 < n.+2).\nby case: (leqP _ n.+1); case: trunc_log.\nQed.",
    "Lemma up_log_gt0 p n : (0 < up_log p n) = (1 < p) && (1 < n).\nProof. by rewrite ltnNge leqn0 up_log_eq0 negb_or -!ltnNge. Qed.",
    "Lemma up_log_bounds p n :\n  1 < p -> 1 < n -> let k := up_log p n in p ^ k.-1 < n <= p ^ k.\nProof.\nmove=> p_gt1 n_gt1.\nhave n_gt0 : 0 < n by apply: leq_trans n_gt1.\nrewrite /up_log (leqNgt p 1) p_gt1 /=.\nhave /= /andP[tpLn nLtpS] := trunc_log_bounds p_gt1 n_gt0.\nhave [nLnp|npLn] := leqP n (p ^ trunc_log p n); last by rewrite npLn ltnW.\nrewrite nLnp (leq_trans _ tpLn) // ltn_exp2l // prednK ?leqnn //.\nby case: trunc_log (leq_trans n_gt1 nLnp).\nQed.",
    "Lemma up_logP p n : 1 < p -> n <= p ^ up_log p n.\nProof.\ncase: n => [|[|n]] // p_gt1; first by rewrite up_log1.\nby have /andP[] := up_log_bounds p_gt1 (isT: 1 < n.+2).\nQed.",
    "Lemma up_log_gtn p n : 1 < p -> 1 < n -> p ^ (up_log p n).-1 < n.\nProof.\nby case: n => [|[|n]] p_gt1 n_gt1 //; have /andP[] := up_log_bounds p_gt1 n_gt1.\nQed.",
    "Lemma up_log_min p k j : 1 < p -> k <= p ^ j -> up_log p k <= j.\nProof.\ncase: k => [|[|k]] // p_gt1 kLj; rewrite ?(up_log0, up_log1) //.\nrewrite -[up_log _ _]prednK ?up_log_gt0 ?p_gt1 // -(@ltn_exp2l p) //.\nby apply: leq_trans (up_log_gtn p_gt1 (isT : 1 < k.+2)) _.\nQed.",
    "Lemma leq_up_log p m n : m <= n -> up_log p m <= up_log p n.\nProof.\nmove=> mLn; case: p => [|[|p]] //.\nby apply/up_log_min => //; apply: leq_trans mLn (up_logP _ _).\nQed.",
    "Lemma up_log_eq p n k : 1 < p -> p ^ n < k <= p ^ n.+1 -> up_log p k = n.+1.\nProof.\nmove=> p_gt1 /andP[npLk kLpn]; apply/eqP; rewrite eqn_leq.\napply/andP; split; first by apply: up_log_min.\nrewrite -(ltn_exp2l _ _ p_gt1) //.\nby apply: leq_trans npLk (up_logP _ _).\nQed.",
    "Lemma up_lognn p : 1 < p -> up_log p p = 1.\nProof. by move=> p_gt1; apply: up_log_eq; rewrite p_gt1 /=. Qed.",
    "Lemma up_expnK p n : 1 < p -> up_log p (p ^ n) = n.\nProof.\ncase: n => [|n] p_gt1 /=; first by rewrite up_log1.\nby apply: up_log_eq; rewrite // leqnn andbT ltn_exp2l.\nQed.",
    "Lemma up_logMp p n : 1 < p -> 0 < n -> up_log p (p * n) = (up_log p n).+1.\nProof.\ncase: p => [//|p] p_gt0.\ncase: n => [//|[|n]] _; first by rewrite muln1 up_lognn// up_log1.\napply: up_log_eq => //.\nrewrite expnS leq_pmul2l// up_logP// andbT.\nrewrite -[up_log _ _]prednK ?up_log_gt0 ?p_gt0 //.\nby rewrite expnS ltn_pmul2l// up_log_gtn.\nQed.",
    "Lemma up_log2_double n : 0 < n -> up_log 2 n.*2 = (up_log 2 n).+1.\nProof. by move=> n_gt0; rewrite -mul2n up_logMp. Qed.",
    "Lemma up_log2S n : 0 < n -> up_log 2 n.+1 = (up_log 2 (n./2.+1)).+1.\nProof.\ncase: n=> // [] [|n] // _.\napply: up_log_eq => //; apply/andP; split.\n  apply: leq_trans (_ : n./2.+1.*2 < n.+3); last first.\n    by rewrite doubleS !ltnS -[leqRHS]odd_double_half leq_addl.\n  have /= /andP[H1n _] := up_log_bounds (isT : 1 < 2) (isT : 1 < n./2.+2).\n  by rewrite ltnS -leq_double -mul2n -expnS prednK ?up_log_gt0 // in H1n.\nrewrite -[_./2.+1]/(n./2.+2).\nhave /= /andP[_ H2n] := up_log_bounds (isT : 1 < 2) (isT : 1 < n./2.+2).\nrewrite -leq_double -!mul2n -expnS in H2n.\napply: leq_trans H2n.\nrewrite mul2n !doubleS !ltnS.\nby rewrite -[leqLHS]odd_double_half -add1n leq_add2r; case: odd.\nQed.",
    "Lemma up_log_trunc_log p n :\n  1 < p -> 1 < n -> up_log p n = (trunc_log p n.-1).+1.\nProof.\nmove=> p_gt1 n_gt1; apply: up_log_eq => //.\nrewrite -[n]prednK ?ltnS -?pred_Sn ?[0 < n]ltnW//.\nby rewrite trunc_logP ?ltn_predRL// trunc_log_ltn.\nQed.",
    "Lemma trunc_log_up_log p n :\n  1 < p -> 0 < n -> trunc_log p n = (up_log p n.+1).-1.\nProof. by move=> ? ?; rewrite up_log_trunc_log.\nQed.",
    "Lemma negnK pi : pi^'^' =i pi.\nProof. by move=> p; apply: negbK. Qed.",
    "Lemma eq_negn pi1 pi2 : pi1 =i pi2 -> pi1^' =i pi2^'.\nProof. by move=> eq_pi n; rewrite inE eq_pi. Qed.",
    "Lemma eq_piP m n : \\pi(m) =i \\pi(n) <-> \\pi(m) = \\pi(n).\nProof.\nrewrite /pi_of; have eqs := irr_sorted_eq ltn_trans ltnn.\nby split=> [|-> //] /(eqs _ _ (sorted_primes m) (sorted_primes n)) ->.\nQed.",
    "Lemma part_gt0 pi n : 0 < n`_pi.\nProof. exact: prodn_gt0. Qed.",
    "Lemma sub_in_partn pi1 pi2 n :\n  {in \\pi(n), {subset pi1 <= pi2}} -> n`_pi1 %| n`_pi2.\nProof.\nmove=> pi12; rewrite ![n`__]big_mkcond /=.\napply (big_ind2 (fun m1 m2 => m1 %| m2)) => // [*|p _]; first exact: dvdn_mul.\nrewrite lognE -mem_primes; case: ifP => pi1p; last exact: dvd1n.\nby case: ifP => pr_p; [rewrite pi12 | rewrite if_same].\nQed.",
    "Lemma eq_in_partn pi1 pi2 n : {in \\pi(n), pi1 =i pi2} -> n`_pi1 = n`_pi2.\nProof.\nby move=> pi12; apply/eqP; rewrite eqn_dvd ?sub_in_partn // => p /pi12->.\nQed.",
    "Lemma eq_partn pi1 pi2 n : pi1 =i pi2 -> n`_pi1 = n`_pi2.\nProof. by move=> pi12; apply: eq_in_partn => p _. Qed.",
    "Lemma partnNK pi n : n`_pi^'^' = n`_pi.\nProof. by apply: eq_partn; apply: negnK. Qed.",
    "Lemma widen_partn m pi n :\n  n <= m -> n`_pi = \\prod_(0 <= p < m.+1 | p \\in pi) p ^ logn p n.\nProof.\nmove=> le_n_m; rewrite big_mkcond /=.\nrewrite [n`_pi](big_nat_widen _ _ m.+1) // big_mkcond /=.\napply: eq_bigr => p _; rewrite ltnS lognE.\nby case: and3P => [[_ n_gt0 p_dv_n]|]; rewrite ?if_same // andbC dvdn_leq.\nQed.",
    "Lemma eq_partn_from_log m n (pi : nat_pred) : 0 < m -> 0 < n ->\n  {in pi, logn^~ m =1 logn^~ n} -> m`_pi = n`_pi.\nProof.\nmove=> m0 n0 eq_log; rewrite !(@widen_partn (maxn m n)) ?leq_maxl ?leq_maxr//.\nby apply: eq_bigr => p /eq_log ->.\nQed.",
    "Lemma partn0 pi : 0`_pi = 1.\nProof. by apply: big1_seq => [] [|n]; rewrite andbC. Qed.",
    "Lemma partn1 pi : 1`_pi = 1.\nProof. by apply: big1_seq => [] [|[|n]]; rewrite andbC. Qed.",
    "Lemma partnM pi m n : m > 0 -> n > 0 -> (m * n)`_pi = m`_pi * n`_pi.\nProof.\nhave le_pmul m' n': m' > 0 -> n' <= m' * n' by move/prednK <-; apply: leq_addr.\nmove=> mpos npos; rewrite !(@widen_partn (n * m)) 3?(le_pmul, mulnC) //.\nrewrite !big_mkord -big_split; apply: eq_bigr => p _ /=.\nby rewrite lognM // expnD.\nQed.",
    "Lemma partnX pi m n : (m ^ n)`_pi = m`_pi ^ n.\nProof.\nelim: n => [|n IHn]; first exact: partn1.\nrewrite expnS; have [->|m_gt0] := posnP m; first by rewrite partn0 exp1n.\nby rewrite expnS partnM ?IHn // expn_gt0 m_gt0.\nQed.",
    "Lemma partn_dvd pi m n : n > 0 -> m %| n -> m`_pi %| n`_pi.\nProof.\nmove=> n_gt0 dvmn; case/dvdnP: dvmn n_gt0 => q ->{n}.\nby rewrite muln_gt0 => /andP[q_gt0 m_gt0]; rewrite partnM ?dvdn_mull.\nQed.",
    "Lemma p_part p n : n`_p = p ^ logn p n.\nProof.\ncase (posnP (logn p n)) => [log0 |].\n  by rewrite log0 [n`_p]big1_seq // => q /andP [/eqP ->]; rewrite log0.\nrewrite logn_gt0 mem_primes; case/and3P=> _ n_gt0 dv_p_n.\nhave le_p_n: p < n.+1 by rewrite ltnS dvdn_leq.\nby rewrite [n`_p]big_mkord (big_pred1 (Ordinal le_p_n)).\nQed.",
    "Lemma p_part_eq1 p n : (n`_p == 1) = (p \\notin \\pi(n)).\nProof.\nrewrite mem_primes p_part lognE; case: and3P => // [[p_pr _ _]].\nby rewrite -dvdn1 pfactor_dvdn // logn1.\nQed.",
    "Lemma p_part_gt1 p n : (n`_p > 1) = (p \\in \\pi(n)).\nProof. by rewrite ltn_neqAle part_gt0 andbT eq_sym p_part_eq1 negbK. Qed.",
    "Lemma primes_part pi n : primes n`_pi = filter [in pi] (primes n).\nProof.\nhave ltnT := ltn_trans; have [->|n_gt0] := posnP n; first by rewrite partn0.\napply: (irr_sorted_eq ltnT ltnn); rewrite ?(sorted_primes, sorted_filter) //.\nmove=> p; rewrite mem_filter /= !mem_primes n_gt0 part_gt0 /=.\napply/andP/and3P=> [[p_pr] | [pi_p p_pr dv_p_n]].\n  rewrite /partn; apply big_ind => [|n1 n2 IHn1 IHn2|q pi_q].\n  - by rewrite dvdn1; case: eqP p_pr => // ->.\n  - by rewrite Euclid_dvdM //; case/orP.\n  rewrite -{1}(expn1 p) pfactor_dvdn // lognX muln_gt0.\n  rewrite logn_gt0 mem_primes n_gt0 - andbA /=; case/and3P=> pr_q dv_q_n.\n  by rewrite logn_prime //; case: eqP => // ->.\nhave le_p_n: p < n.+1 by rewrite ltnS dvdn_leq.\nrewrite [n`_pi]big_mkord (bigD1 (Ordinal le_p_n)) //= dvdn_mulr //.\nby rewrite lognE p_pr n_gt0 dv_p_n expnS dvdn_mulr.\nQed.",
    "Lemma filter_pi_of n m : n < m -> filter \\pi(n) (index_iota 0 m) = primes n.\nProof.\nmove=> lt_n_m; have ltnT := ltn_trans; apply: (irr_sorted_eq ltnT ltnn).\n- by rewrite sorted_filter // iota_ltn_sorted.\n- exact: sorted_primes.\nmove=> p; rewrite mem_filter mem_index_iota /= mem_primes; case: and3P => //.\nby case=> _ n_gt0 dv_p_n; apply: leq_ltn_trans lt_n_m; apply: dvdn_leq.\nQed.",
    "Lemma partn_pi n : n > 0 -> n`_\\pi(n) = n.\nProof.\nmove=> n_gt0; rewrite [RHS]prod_prime_decomp // prime_decompE big_map.\nby rewrite -[n`__]big_filter filter_pi_of.\nQed.",
    "Lemma partnT n : n > 0 -> n`_predT = n.\nProof.\nmove=> n_gt0; rewrite -[RHS]partn_pi // [RHS]/partn big_mkcond /=.\nby apply: eq_bigr => p _; rewrite -logn_gt0; case: (logn p _).\nQed.",
    "Lemma eqn_from_log m n : 0 < m -> 0 < n -> logn^~ m =1 logn^~ n -> m = n.\nProof.\nby move=> ? ? /(@in1W _ predT)/eq_partn_from_log; rewrite !partnT// => ->.\nQed.",
    "Lemma partnC pi n : n > 0 -> n`_pi * n`_pi^' = n.\nProof.\nmove=> n_gt0; rewrite -[RHS]partnT /partn //.\ndo 2!rewrite mulnC big_mkcond /=; rewrite -big_split; apply: eq_bigr => p _ /=.\nby rewrite mulnC inE /=; case: (p \\in pi); rewrite /= (muln1, mul1n).\nQed.",
    "Lemma dvdn_part pi n : n`_pi %| n.\nProof. by case: n => // n; rewrite -{2}[n.+1](@partnC pi) // dvdn_mulr. Qed.",
    "Lemma logn_part p m : logn p m`_p = logn p m.\nProof.\ncase p_pr: (prime p); first by rewrite p_part pfactorK.\nby rewrite lognE (lognE p m) p_pr.\nQed.",
    "Lemma partn_lcm pi m n : m > 0 -> n > 0 -> (lcmn m n)`_pi = lcmn m`_pi n`_pi.\nProof.\nmove=> m_gt0 n_gt0; have p_gt0: lcmn m n > 0 by rewrite lcmn_gt0 m_gt0.\napply/eqP; rewrite eqn_dvd dvdn_lcm !partn_dvd ?dvdn_lcml ?dvdn_lcmr //.\nrewrite -(dvdn_pmul2r (part_gt0 pi^' (lcmn m n))) partnC // dvdn_lcm !andbT.\nrewrite -[m in m %| _](partnC pi m_gt0) andbC -[n in n %| _](partnC pi n_gt0).\nby rewrite !dvdn_mul ?partn_dvd ?dvdn_lcml ?dvdn_lcmr.\nQed.",
    "Lemma partn_gcd pi m n : m > 0 -> n > 0 -> (gcdn m n)`_pi = gcdn m`_pi n`_pi.\nProof.\nmove=> m_gt0 n_gt0; have p_gt0: gcdn m n > 0 by rewrite gcdn_gt0 m_gt0.\napply/eqP; rewrite eqn_dvd dvdn_gcd !partn_dvd ?dvdn_gcdl ?dvdn_gcdr //=.\nrewrite -(dvdn_pmul2r (part_gt0 pi^' (gcdn m n))) partnC // dvdn_gcd.\nrewrite -[m in _ %| m](partnC pi m_gt0) andbC -[n in _%| n](partnC pi n_gt0).\nby rewrite !dvdn_mul ?partn_dvd ?dvdn_gcdl ?dvdn_gcdr.\nQed.",
    "Lemma partn_biglcm (I : finType) (P : pred I) F pi :\n    (forall i, P i -> F i > 0) ->\n  (\\big[lcmn/1%N]_(i | P i) F i)`_pi = \\big[lcmn/1%N]_(i | P i) (F i)`_pi.\nProof.\nmove=> F_gt0; set m := \\big[lcmn/1%N]_(i | P i) F i.\nhave m_gt0: 0 < m by elim/big_ind: m => // p q p_gt0; rewrite lcmn_gt0 p_gt0.\napply/eqP; rewrite eqn_dvd andbC; apply/andP; split.\n  by apply/dvdn_biglcmP=> i Pi; rewrite partn_dvd // (@biglcmn_sup _ i).\nrewrite -(dvdn_pmul2r (part_gt0 pi^' m)) partnC //.\napply/dvdn_biglcmP=> i Pi; rewrite -(partnC pi (F_gt0 i Pi)) dvdn_mul //.\n  by rewrite (@biglcmn_sup _ i).\nby rewrite partn_dvd // (@biglcmn_sup _ i).\nQed.",
    "Lemma partn_biggcd (I : finType) (P : pred I) F pi :\n    #|SimplPred P| > 0 -> (forall i, P i -> F i > 0) ->\n  (\\big[gcdn/0]_(i | P i) F i)`_pi = \\big[gcdn/0]_(i | P i) (F i)`_pi.\nProof.\nmove=> ntP F_gt0; set d := \\big[gcdn/0]_(i | P i) F i.\nhave d_gt0: 0 < d.\n  case/card_gt0P: ntP => i /= Pi; have:= F_gt0 i Pi.\n  rewrite !lt0n -!dvd0n; apply: contra => dv0d.\n  by rewrite (dvdn_trans dv0d) // (@biggcdn_inf _ i).\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  by apply/dvdn_biggcdP=> i Pi; rewrite partn_dvd ?F_gt0 // (@biggcdn_inf _ i).\nrewrite -(dvdn_pmul2r (part_gt0 pi^' d)) partnC //.\napply/dvdn_biggcdP=> i Pi; rewrite -(partnC pi (F_gt0 i Pi)) dvdn_mul //.\n  by rewrite (@biggcdn_inf _ i).\nby rewrite partn_dvd ?F_gt0 // (@biggcdn_inf _ i).\nQed.",
    "Lemma logn_gcd p m n : 0 < m -> 0 < n ->\n  logn p (gcdn m n) = minn (logn p m) (logn p n).\nProof.\nmove=> m_gt0 n_gt0; case p_pr: (prime p); last by rewrite /logn p_pr.\nby apply: (@expnI p); rewrite ?prime_gt1// expn_min -!p_part partn_gcd.\nQed.",
    "Lemma logn_lcm p m n : 0 < m -> 0 < n ->\n  logn p (lcmn m n) = maxn (logn p m) (logn p n).\nProof.\nmove=> m_gt0 n_gt0; rewrite /lcmn logn_div ?dvdn_mull ?dvdn_gcdr//.\nby rewrite lognM// logn_gcd// -addn_min_max addnC addnK.\nQed.",
    "Lemma sub_in_pnat pi rho n :\n  {in \\pi(n), {subset pi <= rho}} -> pi.-nat n -> rho.-nat n.\nProof.\nrewrite /pnat => subpi /andP[-> pi_n].\nby apply/allP=> p pr_p; apply: subpi => //; apply: (allP pi_n).\nQed.",
    "Lemma eq_in_pnat pi rho n : {in \\pi(n), pi =i rho} -> pi.-nat n = rho.-nat n.\nProof. by move=> eqpi; apply/idP/idP; apply: sub_in_pnat => p /eqpi->. Qed.",
    "Lemma eq_pnat pi rho n : pi =i rho -> pi.-nat n = rho.-nat n.\nProof. by move=> eqpi; apply: eq_in_pnat => p _. Qed.",
    "Lemma pnatNK pi n : pi^'^'.-nat n = pi.-nat n.\nProof. exact: eq_pnat (negnK pi). Qed.",
    "Lemma pnatI pi rho n : [predI pi & rho].-nat n = pi.-nat n && rho.-nat n.\nProof. by rewrite /pnat andbCA all_predI !andbA andbb. Qed.",
    "Lemma pnatM pi m n : pi.-nat (m * n) = pi.-nat m && pi.-nat n.\nProof.\nrewrite /pnat muln_gt0 andbCA -andbA andbCA.\ncase: posnP => // n_gt0; case: posnP => //= m_gt0.\napply/allP/andP=> [pi_mn | [pi_m pi_n] p].\n  by split; apply/allP=> p m_p; apply: pi_mn; rewrite primesM // m_p ?orbT.\nby rewrite primesM // => /orP[]; [apply: (allP pi_m) | apply: (allP pi_n)].\nQed.",
    "Lemma pnatX pi m n : pi.-nat (m ^ n) = pi.-nat m || (n == 0).\nProof. by case: n => [|n]; rewrite orbC // /pnat expn_gt0 orbC primesX. Qed.",
    "Lemma part_pnat pi n : pi.-nat n`_pi.\nProof.\nrewrite /pnat primes_part part_gt0.\nby apply/allP=> p; rewrite mem_filter => /andP[].\nQed.",
    "Lemma pnatE pi p : prime p -> pi.-nat p = (p \\in pi).\nProof. by move=> pr_p; rewrite /pnat prime_gt0 ?primes_prime //= andbT. Qed.",
    "Lemma pnat_id p : prime p -> p.-nat p.\nProof. by move=> pr_p; rewrite pnatE ?inE /=. Qed.",
    "Lemma coprime_pi' m n : m > 0 -> n > 0 -> coprime m n = \\pi(m)^'.-nat n.\nProof.\nby move=> m_gt0 n_gt0; rewrite /pnat n_gt0 all_predC coprime_has_primes.\nQed.",
    "Lemma pnat_pi n : n > 0 -> \\pi(n).-nat n.\nProof. by rewrite /pnat => ->; apply/allP. Qed.",
    "Lemma pi_of_dvd m n : m %| n -> n > 0 -> {subset \\pi(m) <= \\pi(n)}.\nProof.\nmove=> m_dv_n n_gt0 p; rewrite !mem_primes n_gt0 => /and3P[-> _ p_dv_m].\nexact: dvdn_trans p_dv_m m_dv_n.\nQed.",
    "Lemma pi_ofM m n : m > 0 -> n > 0 -> \\pi(m * n) =i [predU \\pi(m) & \\pi(n)].\nProof. by move=> m_gt0 n_gt0 p; apply: primesM. Qed.",
    "Lemma pi_of_part pi n : n > 0 -> \\pi(n`_pi) =i [predI \\pi(n) & pi].\nProof. by move=> n_gt0 p; rewrite /pi_of primes_part mem_filter andbC. Qed.",
    "Lemma pi_of_exp p n : n > 0 -> \\pi(p ^ n) = \\pi(p).\nProof. by move=> n_gt0; rewrite /pi_of primesX. Qed.",
    "Lemma pi_of_prime p : prime p -> \\pi(p) =i (p : nat_pred).\nProof. by move=> pr_p q; rewrite /pi_of primes_prime // mem_seq1. Qed.",
    "Lemma p'natEpi p n : n > 0 -> p^'.-nat n = (p \\notin \\pi(n)).\nProof. by case: n => // n _; rewrite /pnat all_predC has_pred1. Qed.",
    "Lemma p'natE p n : prime p -> p^'.-nat n = ~~ (p %| n).\nProof.\ncase: n => [|n] p_pr; first by case: p p_pr.\nby rewrite p'natEpi // mem_primes p_pr.\nQed.",
    "Lemma pnatPpi pi n p : pi.-nat n -> p \\in \\pi(n) -> p \\in pi.\nProof. by case/andP=> _ /allP; apply. Qed.",
    "Lemma pnat_dvd m n pi : m %| n -> pi.-nat n -> pi.-nat m.\nProof. by case/dvdnP=> q ->; rewrite pnatM; case/andP. Qed.",
    "Lemma pnat_div m n pi : m %| n -> pi.-nat n -> pi.-nat (n %/ m).\nProof.\ncase/dvdnP=> q ->; rewrite pnatM andbC => /andP[].\nby case: m => // m _; rewrite mulnK.\nQed.",
    "Lemma pnat_coprime pi m n : pi.-nat m -> pi^'.-nat n -> coprime m n.\nProof.\ncase/andP=> m_gt0 pi_m /andP[n_gt0 pi'_n]; rewrite coprime_has_primes //.\nby apply/hasPn=> p /(allP pi'_n); apply/contra/allP.\nQed.",
    "Lemma p'nat_coprime pi m n : pi^'.-nat m -> pi.-nat n -> coprime m n.\nProof. by move=> pi'm pi_n; rewrite (pnat_coprime pi'm) ?pnatNK. Qed.",
    "Lemma sub_pnat_coprime pi rho m n :\n  {subset rho <= pi^'} -> pi.-nat m -> rho.-nat n -> coprime m n.\nProof.\nby move=> pi'rho pi_m /(sub_in_pnat (in1W pi'rho)); apply: pnat_coprime.\nQed.",
    "Lemma coprime_partC pi m n : coprime m`_pi n`_pi^'.\nProof. by apply: (@pnat_coprime pi); apply: part_pnat. Qed.",
    "Lemma pnat_1 pi n : pi.-nat n -> pi^'.-nat n -> n = 1.\nProof.\nby move=> pi_n pi'_n; rewrite -(eqnP (pnat_coprime pi_n pi'_n)) gcdnn.\nQed.",
    "Lemma part_pnat_id pi n : pi.-nat n -> n`_pi = n.\nProof.\ncase/andP=> n_gt0 pi_n; rewrite -[RHS]partnT // /partn big_mkcond /=.\napply: eq_bigr=> p _; have [->|] := posnP (logn p n); first by rewrite if_same.\nby rewrite logn_gt0 => /(allP pi_n)/= ->.\nQed.",
    "Lemma part_p'nat pi n : pi^'.-nat n -> n`_pi = 1.\nProof.\ncase/andP=> n_gt0 pi'_n; apply: big1_seq => p /andP[pi_p _].\nby have [-> //|] := posnP (logn p n); rewrite logn_gt0; case/(allP pi'_n)/negP.\nQed.",
    "Lemma partn_eq1 pi n : n > 0 -> (n`_pi == 1) = pi^'.-nat n.\nProof.\nmove=> n_gt0; apply/eqP/idP=> [pi_n_1|]; last exact: part_p'nat.\nby rewrite -(partnC pi n_gt0) pi_n_1 mul1n part_pnat.\nQed.",
    "Lemma pnatP pi n :\n  n > 0 -> reflect (forall p, prime p -> p %| n -> p \\in pi) (pi.-nat n).\nProof.\nmove=> n_gt0; rewrite /pnat n_gt0.\napply: (iffP allP) => /= pi_n p => [pr_p p_n|].\n  by rewrite pi_n // mem_primes pr_p n_gt0.\nby rewrite mem_primes n_gt0 /=; case/andP; move: p.\nQed.",
    "Lemma pi_pnat pi p n : p.-nat n -> p \\in pi -> pi.-nat n.\nProof.\nmove=> p_n pi_p; have [n_gt0 _] := andP p_n.\nby apply/pnatP=> // q q_pr /(pnatP _ n_gt0 p_n _ q_pr)/eqnP->.\nQed.",
    "Lemma p_natP p n : p.-nat n -> {k | n = p ^ k}.\nProof. by move=> p_n; exists (logn p n); rewrite -p_part part_pnat_id. Qed.",
    "Lemma pi'_p'nat pi p n : pi^'.-nat n -> p \\in pi -> p^'.-nat n.\nProof.\nby move=> pi'n pi_p; apply: sub_in_pnat pi'n => q _; apply: contraNneq => ->.\nQed.",
    "Lemma pi_p'nat p pi n : pi.-nat n -> p \\in pi^' -> p^'.-nat n.\nProof. by move=> pi_n; apply: pi'_p'nat; rewrite pnatNK. Qed.",
    "Lemma partn_part pi rho n : {subset pi <= rho} -> n`_rho`_pi = n`_pi.\nProof.\nmove=> pi_sub_rho; have [->|n_gt0] := posnP n; first by rewrite !partn0 partn1.\nrewrite -[in RHS](partnC rho n_gt0) partnM //.\nsuffices: pi^'.-nat n`_rho^' by move/part_p'nat->; rewrite muln1.\nby apply: sub_in_pnat (part_pnat _ _) => q _; apply/contra/pi_sub_rho.\nQed.",
    "Lemma partnI pi rho n : n`_[predI pi & rho] = n`_pi`_rho.\nProof.\nrewrite -(@partnC [predI pi & rho] _`_rho) //.\nsymmetry; rewrite 2?partn_part; try by move=> p /andP [].\nrewrite mulnC part_p'nat ?mul1n // pnatNK pnatI part_pnat andbT.\nexact: pnat_dvd (dvdn_part _ _) (part_pnat _ _).\nQed.",
    "Lemma odd_2'nat n : odd n = 2^'.-nat n.\nProof. by case: n => // n; rewrite p'natE // dvdn2 negbK. Qed.",
    "Lemma divisors_correct n : n > 0 ->\n  [/\\ uniq (divisors n), sorted leq (divisors n)\n    & forall d, (d \\in divisors n) = (d %| n)].\nProof.\nmove/prod_prime_decomp=> def_n; rewrite {4}def_n {def_n}.\nhave: all prime (primes n) by apply/allP=> p; rewrite mem_primes; case/andP.\nhave:= primes_uniq n; rewrite /primes /divisors; move/prime_decomp: n.\nelim=> [|[p e] pd] /=; first by split=> // d; rewrite big_nil dvdn1 mem_seq1.\nrewrite big_cons /=; move: (foldr _ _ pd) => divs.\nmove=> IHpd /andP[npd_p Upd] /andP[pr_p pr_pd].\nhave lt0p: 0 < p by apply: prime_gt0.\nhave {IHpd Upd}[Udivs Odivs mem_divs] := IHpd Upd pr_pd.\nhave ndivs_p m: p * m \\notin divs.\n  suffices: p \\notin divs; rewrite !mem_divs.\n    by apply: contra => /dvdnP[n ->]; rewrite mulnCA dvdn_mulr.\n  have ndv_p_1: ~~(p %| 1) by rewrite dvdn1 neq_ltn orbC prime_gt1.\n  rewrite big_seq; elim/big_ind: _ => [//|u v npu npv|[q f] /= pd_qf].\n    by rewrite Euclid_dvdM //; apply/norP.\n  elim: (f) => // f'; rewrite expnS Euclid_dvdM // orbC negb_or => -> {f'}/=.\n  have pd_q: q \\in unzip1 pd by apply/mapP; exists (q, f).\n  by apply: contra npd_p; rewrite dvdn_prime2 // ?(allP pr_pd) // => /eqP->.\nelim: e => [|e] /=; first by split=> // d; rewrite mul1n.\nhave Tmulp_inj: injective (NatTrec.mul p).\n  by move=> u v /eqP; rewrite !natTrecE eqn_pmul2l // => /eqP.\nmove: (iter e _ _) => divs' [Udivs' Odivs' mem_divs']; split=> [||d].\n- rewrite merge_uniq cat_uniq map_inj_uniq // Udivs Udivs' andbT /=.\n  apply/hasP=> [[d dv_d /mapP[d' _ def_d]]].\n  by case/idPn: dv_d; rewrite def_d natTrecE.\n- rewrite (merge_sorted leq_total) //; case: (divs') Odivs' => //= d ds.\n  rewrite (@map_path _ _ _ _ leq xpred0) ?has_pred0 // => u v _.\n  by rewrite !natTrecE leq_pmul2l.\nrewrite mem_merge mem_cat; case dv_d_p: (p %| d).\n  case/dvdnP: dv_d_p => d' ->{d}; rewrite mulnC (negbTE (ndivs_p d')) orbF.\n  rewrite expnS -mulnA dvdn_pmul2l // -mem_divs'.\n  by rewrite -(mem_map Tmulp_inj divs') natTrecE.\ncase pdiv_d: (_ \\in _).\n  by case/mapP: pdiv_d dv_d_p => d' _ ->; rewrite natTrecE dvdn_mulr.\nrewrite mem_divs Gauss_dvdr // coprime_sym.\nby rewrite coprimeXl ?prime_coprime ?dv_d_p.\nQed.",
    "Lemma sorted_divisors n : sorted leq (divisors n).\nProof. by case: (posnP n) => [-> | /divisors_correct[]]. Qed.",
    "Lemma divisors_uniq n : uniq (divisors n).\nProof. by case: (posnP n) => [-> | /divisors_correct[]]. Qed.",
    "Lemma sorted_divisors_ltn n : sorted ltn (divisors n).\nProof. by rewrite ltn_sorted_uniq_leq divisors_uniq sorted_divisors. Qed.",
    "Lemma dvdn_divisors d m : 0 < m -> (d %| m) = (d \\in divisors m).\nProof. by case/divisors_correct. Qed.",
    "Lemma divisor1 n : 1 \\in divisors n.\nProof. by case: n => // n; rewrite -dvdn_divisors // dvd1n. Qed.",
    "Lemma divisors_id n : 0 < n -> n \\in divisors n.\nProof. by move/dvdn_divisors <-. Qed.",
    "Lemma dvdn_sum d I r (K : pred I) F :\n  (forall i, K i -> d %| F i) -> d %| \\sum_(i <- r | K i) F i.\nProof. by move=> dF; elim/big_ind: _ => //; apply: dvdn_add. Qed.",
    "Lemma dvdn_partP n m : 0 < n ->\n  reflect (forall p, p \\in \\pi(n) -> n`_p %| m) (n %| m).\nProof.\nmove=> n_gt0; apply: (iffP idP) => n_dvd_m => [p _|].\n  by apply: dvdn_trans n_dvd_m; apply: dvdn_part.\nhave [-> // | m_gt0] := posnP m.\nrewrite -(partnT n_gt0) -(partnT m_gt0).\nrewrite !(@widen_partn (m + n)) ?leq_addl ?leq_addr // /in_mem /=.\nelim/big_ind2: _ => // [* | q _]; first exact: dvdn_mul.\nhave [-> // | ] := posnP (logn q n); rewrite logn_gt0 => q_n.\nhave pr_q: prime q by move: q_n; rewrite mem_primes; case/andP.\nby have:= n_dvd_m q q_n; rewrite p_part !pfactor_dvdn // pfactorK.\nQed.",
    "Lemma modn_partP n a b : 0 < n ->\n  reflect (forall p : nat, p \\in \\pi(n) -> a = b %[mod n`_p]) (a == b %[mod n]).\nProof.\nmove=> n_gt0; wlog le_b_a: a b / b <= a.\n  move=> IH; case: (leqP b a) => [|/ltnW] /IH {IH}// IH.\n  by rewrite eq_sym; apply: (iffP IH) => eqab p /eqab.\nrewrite eqn_mod_dvd //; apply: (iffP (dvdn_partP _ n_gt0)) => eqab p /eqab;\n  by rewrite -eqn_mod_dvd // => /eqP.\nQed.",
    "Lemma totientE n :\n  n > 0 -> totient n = \\prod_(p <- primes n) (p.-1 * p ^ (logn p n).-1).\nProof.\nmove=> n_gt0; rewrite /totient n_gt0 prime_decompE unlock.\nby elim: (primes n) => //= [p pr ->]; rewrite !natTrecE.\nQed.",
    "Lemma totient_gt0 n : (0 < totient n) = (0 < n).\nProof.\ncase: n => // n; rewrite totientE // big_seq_cond prodn_cond_gt0 // => p.\nby rewrite mem_primes muln_gt0 expn_gt0; case: p => [|[|]].\nQed.",
    "Lemma totient_pfactor p e :\n  prime p -> e > 0 -> totient (p ^ e) = p.-1 * p ^ e.-1.\nProof.\nmove=> p_pr e_gt0; rewrite totientE ?expn_gt0 ?prime_gt0 //.\nby rewrite primesX // primes_prime // unlock /= muln1 pfactorK.\nQed.",
    "Lemma totient_prime p : prime p -> totient p = p.-1.\nProof. by move=> p_prime; rewrite -{1}[p]expn1 totient_pfactor // muln1. Qed.",
    "Lemma totient_coprime m n :\n  coprime m n -> totient (m * n) = totient m * totient n.\nProof.\nmove=> co_mn; have [-> //| m_gt0] := posnP m.\nhave [->|n_gt0] := posnP n; first by rewrite !muln0.\nrewrite !totientE ?muln_gt0 ?m_gt0 //.\nhave /(perm_big _)->: perm_eq (primes (m * n)) (primes m ++ primes n).\n  apply: uniq_perm => [||p]; first exact: primes_uniq.\n    by rewrite cat_uniq !primes_uniq -coprime_has_primes // co_mn.\n  by rewrite mem_cat primesM.\nrewrite big_cat /= !big_seq.\ncongr (_ * _); apply: eq_bigr => p; rewrite mem_primes => /and3P[_ _ dvp].\n  rewrite (mulnC m) logn_Gauss //; move: co_mn.\n  by rewrite -(divnK dvp) coprimeMl => /andP[].\nrewrite logn_Gauss //; move: co_mn.\nby rewrite coprime_sym -(divnK dvp) coprimeMl => /andP[].\nQed.",
    "Lemma totient_count_coprime n : totient n = \\sum_(0 <= d < n) coprime n d.\nProof.\nelim/ltn_ind: n => // n IHn.\ncase: (leqP n 1) => [|lt1n]; first by rewrite unlock; case: (n) => [|[]].\npose p := pdiv n; have p_pr: prime p by apply: pdiv_prime.\nhave p1 := prime_gt1 p_pr; have p0 := ltnW p1.\npose np := n`_p; pose np' := n`_p^'.\nhave co_npp': coprime np np' by rewrite coprime_partC.\nhave [n0 np0 np'0]: [/\\ n > 0, np > 0 & np' > 0] by rewrite ltnW ?part_gt0.\nhave def_n: n = np * np' by rewrite partnC.\nhave lnp0: 0 < logn p n by rewrite lognE p_pr n0 pdiv_dvd.\npose in_mod k (k0 : k > 0) d := Ordinal (ltn_pmod d k0).\nrewrite {1}def_n totient_coprime // {IHn}(IHn np') ?big_mkord; last first.\n  by rewrite def_n ltn_Pmull // /np p_part -(expn0 p) ltn_exp2l.\nhave ->: totient np = #|[pred d : 'I_np | coprime np d]|.\n  rewrite [np in LHS]p_part totient_pfactor //=; set q := p ^ _.\n  apply: (@addnI (1 * q)); rewrite -mulnDl [1 + _]prednK // mul1n.\n  have def_np: np = p * q by rewrite -expnS prednK // -p_part.\n  pose mulp := [fun d : 'I_q => in_mod _ np0 (p * d)].\n  rewrite -def_np -{1}[np]card_ord -(cardC [in codom mulp]).\n  rewrite card_in_image => [|[d1 ltd1] [d2 ltd2] /= _ _ []]; last first.\n    move/eqP; rewrite def_np -!muln_modr ?modn_small //.\n    by rewrite eqn_pmul2l // => eq_op12; apply/eqP.\n  rewrite card_ord; congr (q + _); apply: eq_card => d /=.\n  rewrite !inE [np in coprime np _]p_part coprime_pexpl ?prime_coprime //.\n  congr (~~ _); apply/codomP/idP=> [[d' -> /=] | /dvdnP[r def_d]].\n    by rewrite def_np -muln_modr // dvdn_mulr.\n  do [rewrite mulnC; case: d => d ltd /=] in def_d *.\n  have ltr: r < q by rewrite -(ltn_pmul2l p0) -def_np -def_d.\n  by exists (Ordinal ltr); apply: val_inj; rewrite /= -def_d modn_small.\npose h (d : 'I_n) := (in_mod _ np0 d, in_mod _ np'0 d).\npose h' (d : 'I_np * 'I_np') := in_mod _ n0 (chinese np np' d.1 d.2).\nrewrite -!big_mkcond -sum_nat_const pair_big (reindex_onto h h') => [|[d d'] _].\n  apply: eq_bigl => [[d ltd] /=]; rewrite !inE -val_eqE /= andbC !coprime_modr.\n  by rewrite def_n -chinese_mod // -coprimeMl -def_n modn_small ?eqxx.\napply/eqP; rewrite /eq_op /= /eq_op /= !modn_dvdm ?dvdn_part //.\nby rewrite chinese_modl // chinese_modr // !modn_small ?eqxx ?ltn_ord.\nQed.",
    "Lemma totient_gt1 n : (totient n > 1) = (n > 2).\nProof.\ncase: n => [|[|[|[|n']]]]//=; set n := n'.+4; rewrite [RHS]isT.\nwlog [q] : / exists k, k.+3 \\in primes n; last first.\n  rewrite mem_primes => /and3P[qp ngt0 qn].\n  have [[|k]// cqk ->] := pfactor_coprime qp ngt0.\n  rewrite totient_coprime 1?coprime_sym ?coprimeXl//.\n  rewrite totient_pfactor// -?pfactor_dvdn// mulnCA/= (@leq_trans q.+2)//.\n  by rewrite leq_pmulr// muln_gt0 totient_gt0 expn_gt0.\nhave := @prod_prime_decomp n isT; rewrite prime_decompE big_map/=.\ncase: (primes n) (all_prime_primes n) (sorted_primes n) =>\n    [|[|[|p']]// [|[|[|[|q']]] r]]//=; first by rewrite big_nil.\n  case: p' => [_ _|p' _ _ _]; last by apply; exists p'; rewrite ?mem_head.\n  rewrite big_seq1; case: logn => [|[|k]]//= ->.\n  by rewrite totient_pfactor//= mul1n (@leq_pexp2l 2 1)//.\nby move=> _ _ _; apply; exists q'=> //; rewrite !in_cons eqxx orbT.\nQed.",
    "Lemma subset_dfs n v a : v \\subset foldl (dfs n) v a.\nProof.\nelim: n a v => [|n IHn]; first by elim=> //= *; rewrite if_same.\nelim=> //= x a IHa v; apply: subset_trans {IHa}(IHa _); case: ifP => // _.\nby apply: subset_trans (IHn _ _); apply/subsetP=> y; apply: predU1r.\nQed.",
    "Lemma dfs_pathP n x y v :\n  #|T| <= #|v| + n -> y \\notin v -> reflect (dfs_path v x y) (y \\in dfs n v x).\nProof.\nhave dfs_id w z: z \\notin w -> dfs_path w z z.\n  by exists [::]; rewrite ?disjoint_has //= orbF.\nelim: n => [|n IHn] /= in x y v * => le_v'_n not_vy.\n  rewrite addn0 (geq_leqif (subset_leqif_card (subset_predT _))) in le_v'_n.\n  by rewrite predT_subset in not_vy.\nhave [v_x | not_vx] := ifPn.\n  by rewrite (negPf not_vy); right=> [] [p _ _]; rewrite disjoint_has /= v_x.\nset v1 := x :: v; set a := g x; have sub_dfs := subsetP (subset_dfs n _ _).\nhave [-> | neq_yx] := eqVneq y x.\n  by rewrite sub_dfs ?mem_head //; left; apply: dfs_id.\napply: (@equivP (exists2 x1, x1 \\in a & dfs_path v1 x1 y)); last first.\n  split=> {IHn} [[x1 a_x1 [p g_p p_y]] | [p /shortenP[]]].\n    rewrite disjoint_has has_sym /= has_sym /= => /norP[_ not_pv].\n    by exists (x1 :: p); rewrite /= ?a_x1 // disjoint_has negb_or not_vx.\n  case=> [_ _ _ eq_yx | x1 p1 /=]; first by case/eqP: neq_yx.\n  case/andP=> a_x1 g_p1 /andP[not_p1x _] /subsetP p_p1 p1y not_pv.\n  exists x1 => //; exists p1 => //.\n  rewrite disjoint_sym disjoint_cons not_p1x disjoint_sym.\n  by move: not_pv; rewrite disjoint_cons => /andP[_ /disjointWl->].\nhave{neq_yx not_vy}: y \\notin v1 by apply/norP.\nhave{le_v'_n not_vx}: #|T| <= #|v1| + n by rewrite cardU1 not_vx addSnnS.\nelim: {x v}a v1 => [|x a IHa] v /= le_v'_n not_vy.\n  by rewrite (negPf not_vy); right=> [] [].\nset v2 := dfs n v x; have v2v: v \\subset v2 := subset_dfs n v [:: x].\nhave [v2y | not_v2y] := boolP (y \\in v2).\n  by rewrite sub_dfs //; left; exists x; [apply: mem_head | apply: IHn].\napply: {IHa}(equivP (IHa _ _ not_v2y)).\n  by rewrite (leq_trans le_v'_n) // leq_add2r subset_leq_card.\nsplit=> [] [x1 a_x1 [p g_p p_y not_pv]].\n  exists x1; [exact: predU1r | exists p => //].\n  by rewrite disjoint_sym (disjointWl v2v) // disjoint_sym.\nsuffices not_p1v2: [disjoint x1 :: p & v2].\n  case/predU1P: a_x1 => [def_x1 | ]; last by exists x1; last exists p.\n  case/pred0Pn: not_p1v2; exists x; rewrite /= def_x1 mem_head /=.\n  suffices not_vx: x \\notin v by apply/IHn; last apply: dfs_id.\n  by move: not_pv; rewrite disjoint_cons def_x1 => /andP[].\napply: contraR not_v2y => /pred0Pn[x2 /andP[/= p_x2 v2x2]].\ncase/splitPl: p_x2 p_y g_p not_pv => p0 p2 p0x2.\nrewrite last_cat cat_path -cat_cons lastI cat_rcons {}p0x2 => p2y /andP[_ g_p2].\nrewrite disjoint_cat disjoint_cons => /and3P[{p0}_ not_vx2 not_p2v].\nhave{not_vx2 v2x2} [p1 g_p1 p1_x2 not_p1v] := IHn _ _ v le_v'_n not_vx2 v2x2.\napply/IHn=> //; exists (p1 ++ p2); rewrite ?cat_path ?last_cat -?p1_x2 ?g_p1 //.\nby rewrite -cat_cons disjoint_cat not_p1v.\nQed.",
    "Lemma dfsP x y :\n  reflect (exists2 p, path (grel g) x p & y = last x p) (y \\in dfs #|T| [::] x).\nProof.\napply: (iffP (dfs_pathP _ _ _)); rewrite ?card0 // => [] [p]; exists p => //.\nby rewrite disjoint_sym disjoint0.\nQed.",
    "Lemma rgraphK : grel rgraph =2 e.\nProof. by move=> x y; rewrite /= mem_enum. Qed.",
    "Lemma connectP x y :\n  reflect (exists2 p, path e x p & y = last x p) (connect x y).\nProof.\napply: (equivP (dfsP _ x y)).\nby split=> [] [p e_p ->]; exists p => //; rewrite (eq_path rgraphK) in e_p *.\nQed.",
    "Lemma connect_trans : transitive connect.\nProof.\nmove=> x y z /connectP[p e_p ->] /connectP[q e_q ->]; apply/connectP.\nby exists (p ++ q); rewrite ?cat_path ?e_p ?last_cat.\nQed.",
    "Lemma connect0 x : connect x x.\nProof. by apply/connectP; exists [::]. Qed.",
    "Lemma eq_connect0 x y : x = y -> connect x y.\nProof. by move->; apply: connect0. Qed.",
    "Lemma connect1 x y : e x y -> connect x y.\nProof. by move=> e_xy; apply/connectP; exists [:: y]; rewrite /= ?e_xy. Qed.",
    "Lemma path_connect x p : path e x p -> subpred [in x :: p] (connect x).\nProof.\nmove=> e_p y p_y; case/splitPl: p / p_y e_p => p q <-.\nby rewrite cat_path => /andP[e_p _]; apply/connectP; exists p.\nQed.",
    "Lemma connect_cycle p : cycle e p -> {in p &, forall x y, connect x y}.\nProof.\nmove=> e_p x y /rot_to[i q rip]; rewrite -(mem_rot i) rip => yqx.\nhave /= : cycle e (x :: q) by rewrite -rip rot_cycle.\ncase/splitPl: yqx => r s lxr; rewrite rcons_cat cat_path => /andP[xr _].\nby apply/connectP; exists r.\nQed.",
    "Lemma connect_root x : connect x (root x).\nProof. by rewrite /root; case: pickP; rewrite ?connect0. Qed.",
    "Lemma same_connect : left_transitive connect.\nProof. exact: sym_left_transitive connect_trans. Qed.",
    "Lemma same_connect_r : right_transitive connect.\nProof. exact: sym_right_transitive connect_trans. Qed.",
    "Lemma same_connect1 x y : e x y -> connect x =1 connect y.\nProof. by move/connect1; apply: same_connect. Qed.",
    "Lemma same_connect1r x y : e x y -> connect^~ x =1 connect^~ y.\nProof. by move/connect1; apply: same_connect_r. Qed.",
    "Lemma rootP x y : reflect (root x = root y) (connect x y).\nProof.\napply: (iffP idP) => e_xy.\n  by rewrite /root -(eq_pick (same_connect e_xy)); case: pickP e_xy => // ->.\nby apply: (connect_trans (connect_root x)); rewrite e_xy sym_e connect_root.\nQed.",
    "Lemma root_root x : root (root x) = root x.\nProof. exact/esym/rootP/connect_root. Qed.",
    "Lemma roots_root x : roots (root x).\nProof. exact/eqP/root_root. Qed.",
    "Lemma root_connect x y : (root x == root y) = connect x y.\nProof. exact: sameP eqP (rootP x y). Qed.",
    "Lemma connect_sub e e' :\n  subrel e (connect e') -> subrel (connect e) (connect e').\nProof.\nmove=> e'e x _ /connectP[p e_p ->]; elim: p x e_p => //= y p IHp x /andP[exy].\nby move/IHp; apply: connect_trans; apply: e'e.\nQed.",
    "Lemma relU_sym e e' :\n  connect_sym e -> connect_sym e' -> connect_sym (relU e e').\nProof.\nmove=> sym_e sym_e'; apply: symmetric_from_pre => x _ /connectP[p e_p ->].\nelim: p x e_p => //= y p IHp x /andP[e_xy /IHp{IHp}/connect_trans]; apply.\ncase/orP: e_xy => /connect1; rewrite (sym_e, sym_e');\n  by apply: connect_sub y x => x y e_xy; rewrite connect1 //= e_xy ?orbT.\nQed.",
    "Lemma eq_connect e e' : e =2 e' -> connect e =2 connect e'.\nProof.\nmove=> eq_e x y; apply/connectP/connectP=> [] [p e_p ->];\n  by exists p; rewrite // (eq_path eq_e) in e_p *.\nQed.",
    "Lemma eq_n_comp e e' : connect e =2 connect e' -> n_comp_mem e =1 n_comp_mem e'.\nProof.\nmove=> eq_e [a]; apply: eq_card => x /=.\nby rewrite !inE /= /roots /root /= (eq_pick (eq_e x)).\nQed.",
    "Lemma eq_n_comp_r {e} a a' : a =i a' -> n_comp e a = n_comp e a'.\nProof. by move=> eq_a; apply: eq_card => x; rewrite inE /= eq_a. Qed.",
    "Lemma n_compC a e : n_comp e T = n_comp e a + n_comp e [predC a].\nProof.\nrewrite /n_comp_mem (eq_card (fun _ => andbT _)) -(cardID a); congr (_ + _).\nby apply: eq_card => x; rewrite !inE andbC.\nQed.",
    "Lemma eq_root e e' : e =2 e' -> root e =1 root e'.\nProof. by move=> eq_e x; rewrite /root (eq_pick (eq_connect eq_e x)). Qed.",
    "Lemma eq_roots e e' : e =2 e' -> roots e =1 roots e'.\nProof. by move=> eq_e x; rewrite /roots (eq_root eq_e). Qed.",
    "Lemma connect_rev e : connect [rel x y | e y x] =2 [rel x y | connect e y x].\nProof.\nsuff crev e': subrel (connect [rel x y | e' y x]) [rel x y | connect e' y x].\n  by move=> x y; apply/idP/idP; apply: crev.\nmove=> x y /connectP[p e_p p_y]; apply/connectP.\nexists (rev (belast x p)); first by rewrite p_y rev_path.\nby rewrite -(last_cons x) -rev_rcons p_y -lastI rev_cons last_rcons.\nQed.",
    "Lemma sym_connect_sym e : symmetric e -> connect_sym e.\nProof. by move=> sym_e x y; rewrite (eq_connect sym_e) connect_rev. Qed.",
    "Lemma same_connect_rev : connect e =2 connect [rel x y | e y x].\nProof. by move=> x y; rewrite sym_e connect_rev. Qed.",
    "Lemma intro_closed a : (forall x y, e x y -> x \\in a -> y \\in a) -> closed e a.\nProof.\nmove=> cl_a x y e_xy; apply/idP/idP=> [|a_y]; first exact: cl_a.\nhave{x e_xy} /connectP[p e_p ->]: connect e y x by rewrite sym_e connect1.\nby elim: p y a_y e_p => //= y p IHp x a_x /andP[/cl_a/(_ a_x)]; apply: IHp.\nQed.",
    "Lemma closed_connect a :\n  closed e a -> forall x y, connect e x y -> (x \\in a) = (y \\in a).\nProof.\nmove=> cl_a x _ /connectP[p e_p ->].\nby elim: p x e_p => //= y p IHp x /andP[/cl_a->]; apply: IHp.\nQed.",
    "Lemma connect_closed x : closed e (connect e x).\nProof. by move=> y z /connect1/same_connect_r; apply. Qed.",
    "Lemma predC_closed a : closed e a -> closed e [predC a].\nProof. by move=> cl_a x y /cl_a /[!inE] ->. Qed.",
    "Lemma closure_closed a : closed e (closure e a).\nProof.\napply: intro_closed => x y /connect1 e_xy; congr (~~ _).\nby apply: eq_disjoint; apply: same_connect.\nQed.",
    "Lemma mem_closure a : {subset a <= closure e a}.\nProof. by move=> x a_x; apply/existsP; exists x; rewrite !inE connect0. Qed.",
    "Lemma subset_closure a : a \\subset closure e a.\nProof. by apply/subsetP; apply: mem_closure. Qed.",
    "Lemma n_comp_closure2 x y :\n  n_comp e (closure e (pred2 x y)) = (~~ connect e x y).+1.\nProof.\nrewrite -(root_connect sym_e) -card2; apply: eq_card => z.\napply/idP/idP=> [/andP[/eqP {2}<- /pred0Pn[t /andP[/= ezt exyt]]] |].\n  by case/pred2P: exyt => <-; rewrite (rootP sym_e ezt) !inE eqxx ?orbT.\nby case/pred2P=> ->; rewrite !inE roots_root //; apply/existsP;\n  [exists x | exists y]; rewrite !inE eqxx ?orbT sym_e connect_root.\nQed.",
    "Lemma n_comp_connect x : n_comp e (connect e x) = 1.\nProof.\nrewrite -(card1 (root e x)); apply: eq_card => y.\napply/andP/eqP => [[/eqP r_y /rootP-> //] | ->] /=.\nby rewrite inE connect_root roots_root.\nQed.",
    "Lemma fconnect_iter n x : fconnect f x (iter n f x).\nProof.\napply/connectP.\nby exists (traject f (f x) n); [apply: fpath_traject | rewrite last_traject].\nQed.",
    "Lemma fconnect1 x : fconnect f x (f x).\nProof. exact: (fconnect_iter 1). Qed.",
    "Lemma fconnect_finv x : fconnect f x (finv x).\nProof. exact: fconnect_iter. Qed.",
    "Lemma orderSpred x : (order x).-1.+1 = order x.\nProof. by rewrite /order (cardD1 x) [_ x _]connect0. Qed.",
    "Lemma size_orbit x : size (orbit x) = order x.\nProof. exact: size_traject. Qed.",
    "Lemma looping_order x : looping f x (order x).\nProof.\napply: contraFT (ltnn (order x)); rewrite -looping_uniq => /card_uniqP.\nrewrite size_traject => <-; apply: subset_leq_card.\nby apply/subsetP=> _ /trajectP[i _ ->]; apply: fconnect_iter.\nQed.",
    "Lemma fconnect_orbit x y : fconnect f x y = (y \\in orbit x).\nProof.\napply/idP/idP=> [/connectP[_ /fpathP[m ->] ->] | /trajectP[i _ ->]].\n  by rewrite last_traject; apply/loopingP/looping_order.\nexact: fconnect_iter.\nQed.",
    "Lemma in_orbit x : x \\in orbit x. Proof. by rewrite -fconnect_orbit. Qed.",
    "Lemma order_gt0 x : order x > 0. Proof. by rewrite -orderSpred. Qed.",
    "Lemma orbit_uniq x : uniq (orbit x).\nProof.\nrewrite /orbit -orderSpred looping_uniq; set n := (order x).-1.\napply: contraFN (ltnn n) => /trajectP[i lt_i_n eq_fnx_fix].\nrewrite orderSpred -(size_traject f x n).\napply: (leq_trans (subset_leq_card _) (card_size _)); apply/subsetP=> z.\nrewrite inE fconnect_orbit => /trajectP[j le_jn ->{z}].\nrewrite -orderSpred -/n ltnS leq_eqVlt in le_jn.\nby apply/trajectP; case/predU1P: le_jn => [->|]; [exists i | exists j].\nQed.",
    "Lemma findex_max x y : fconnect f x y -> findex x y < order x.\nProof. by rewrite [_ y]fconnect_orbit -index_mem size_orbit. Qed.",
    "Lemma findex_iter x i : i < order x -> findex x (iter i f x) = i.\nProof.\nmove=> lt_ix; rewrite -(nth_traject f lt_ix) /findex index_uniq ?orbit_uniq //.\nby rewrite size_orbit.\nQed.",
    "Lemma iter_findex x y : fconnect f x y -> iter (findex x y) f x = y.\nProof.\nrewrite [_ y]fconnect_orbit => fxy; pose i := index y (orbit x).\nhave lt_ix: i < order x by rewrite -size_orbit index_mem.\nby rewrite -(nth_traject f lt_ix) nth_index.\nQed.",
    "Lemma findex0 x : findex x x = 0.\nProof. by rewrite /findex /orbit -orderSpred /= eqxx. Qed.",
    "Lemma findex_eq0 x y : (findex x y == 0) = (x == y).\nProof. by rewrite /findex /orbit -orderSpred /=; case: (x == y). Qed.",
    "Lemma fconnect_invariant (T' : eqType) (k : T -> T') :\n  invariant f k =1 xpredT -> forall x y, fconnect f x y -> k x = k y.\nProof.\nmove=> eq_k_f x y /iter_findex <-; elim: {y}(findex x y) => //= n ->.\nby rewrite (eqP (eq_k_f _)).\nQed.",
    "Lemma mem_orbit x : {homo f : y / y \\in orbit x}.\nProof.\nby move=> y; rewrite -!fconnect_orbit => /connect_trans->//; apply: fconnect1.\nQed.",
    "Lemma image_orbit x : {subset image f (orbit x) <= orbit x}.\nProof.\nby move=> _ /mapP[y yin ->]; apply: mem_orbit; rewrite ?mem_enum in yin.\nQed.",
    "Lemma finv_in : {homo finv : x / x \\in S}.\nProof. by move=> x xS; rewrite iter_in. Qed.",
    "Lemma f_finv_in : {in S, cancel finv f}.\nProof.\nmove=> x xS; move: (looping_order x) (orbit_uniq x).\nrewrite /looping /orbit -orderSpred looping_uniq /= /looping; set n := _.-1.\ncase/predU1P=> // /trajectP[i lt_i_n]; rewrite -iterSr.\nby move=> /injf ->; rewrite ?(iter_in _ f_in) //; case/trajectP; exists i.\nQed.",
    "Lemma finv_f_in : {in S, cancel f finv}.\nProof. by move=> x xS; apply/injf; rewrite ?iter_in ?f_finv_in ?f_in. Qed.",
    "Lemma finv_inj_in : {in S &, injective finv}.\nProof. by move=> x y xS yS q; rewrite -(f_finv_in xS) q f_finv_in. Qed.",
    "Lemma fconnect_sym_in : {in S &, forall x y, fconnect f x y = fconnect f y x}.\nProof.\nsuff Sf : {in S &, forall x y, fconnect f x y -> fconnect f y x}.\n  by move=> *; apply/idP/idP=> /Sf->.\nmove=> x _ xS _ /connectP [p f_p ->]; elim: p => //= y p IHp in x xS f_p *.\ncase/andP: f_p => /eqP <- /(IHp _ (f_in xS)) /connect_trans -> //.\nby apply: (connect_trans (fconnect_finv _)); rewrite finv_f_in.\nQed.",
    "Lemma iter_order_in : {in S, forall x, iter (order x) f x = x}.\nProof. by move=> x xS; rewrite -orderSpred iterS; apply: f_finv_in. Qed.",
    "Lemma iter_finv_in n :\n  {in S, forall x, n <= order x -> iter n finv x = iter (order x - n) f x}.\nProof.\nmove=> x xS; rewrite -[x in LHS]iter_order_in => // /subnKC {1}<-.\nmove: (_ - n) => m; rewrite iterD; elim: n => // n {2}<-.\nby rewrite iterSr /= finv_f_in // -iterD iter_in.\nQed.",
    "Lemma cycle_orbit_in : {in S, forall x, (fcycle f) (orbit x)}.\nProof.\nmove=> x xS; rewrite /orbit -orderSpred (cycle_path x) /= last_traject.\nby rewrite -/(finv x) fpath_traject f_finv_in ?eqxx.\nQed.",
    "Lemma fpath_finv_in p x :\n  (x \\in S) && (fpath finv x p) =\n    (last x p \\in S) && (fpath f (last x p) (rev (belast x p))).\nProof.\nelim: p x => //= y p IHp x; rewrite rev_cons rcons_path.\ntransitivity [&& y \\in S, f y == x & fpath finv y p].\n  apply/and3P/and3P => -[xS /eqP<- fxp]; split;\n  by rewrite ?f_finv_in ?finv_f_in ?finv_in ?f_in.\nrewrite andbCA {}IHp !andbA [RHS]andbC -andbA; congr [&& _, _ & _].\nby case: p => //= z p; rewrite rev_cons last_rcons.\nQed.",
    "Lemma fpath_finv_f_in p : {in S, forall x,\n  fpath finv x p -> fpath f (last x p) (rev (belast x p))}.\nProof. by move=> x xS /(conj xS)/andP; rewrite fpath_finv_in => /andP[]. Qed.",
    "Lemma fpath_f_finv_in p x : last x p \\in S ->\n  fpath f (last x p) (rev (belast x p)) -> fpath finv x p.\nProof. by move=> lS /(conj lS)/andP; rewrite -fpath_finv_in => /andP[]. Qed.",
    "Lemma injectivePcycle x :\n  reflect {in orbit x &, injective f} (fcycle f (orbit x)).\nProof.\napply: (iffP idP) => [/inj_cycle//|/cycle_orbit_in].\nby apply; [apply: mem_orbit|apply: in_orbit].\nQed.",
    "Lemma f_finv : cancel finv f. Proof. exact: (in1T (f_finv_in _ (in2W _))). Qed.",
    "Lemma finv_f : cancel f finv. Proof. exact: (in1T (finv_f_in _ (in2W _))). Qed.",
    "Lemma finv_bij : bijective finv.\nProof. by exists f; [apply: f_finv|apply: finv_f]. Qed.",
    "Lemma finv_inj : injective finv. Proof. exact: (can_inj f_finv). Qed.",
    "Lemma fconnect_sym x y : fconnect f x y = fconnect f y x.\nProof. exact: (in2T (fconnect_sym_in _ (in2W _))). Qed.",
    "Lemma iter_order x : iter (order x) f x = x.\nProof. exact: (in1T (iter_order_in _ (in2W _))). Qed.",
    "Lemma iter_finv n x : n <= order x -> iter n finv x = iter (order x - n) f x.\nProof. exact: (in1T (@iter_finv_in _ _ (in2W _) _)). Qed.",
    "Lemma cycle_orbit x : fcycle f (orbit x).\nProof. exact: (in1T (cycle_orbit_in _ (in2W _))). Qed.",
    "Lemma fpath_finv x p : fpath finv x p = fpath f (last x p) (rev (belast x p)).\nProof. exact: (@fpath_finv_in T _ (in2W _)). Qed.",
    "Lemma same_fconnect_finv : fconnect finv =2 fconnect f.\nProof.\nmove=> x y; rewrite (same_connect_rev symf); apply: {x y}eq_connect => x y /=.\nby rewrite (canF_eq finv_f) eq_sym.\nQed.",
    "Lemma fcard_finv : fcard_mem finv =1 fcard_mem f.\nProof. exact: eq_n_comp same_fconnect_finv. Qed.",
    "Lemma fcard_order_set n (a : {pred T}) :\n  a \\subset order_set n -> fclosed f a -> fcard f a * n = #|a|.\nProof.\nmove=> a_n cl_a; rewrite /n_comp_mem; set b := [predI froots f & a].\nsuff <-: #|preim (froot f) b| = #|b| * n.\n  apply: eq_card => x; rewrite !inE (roots_root fconnect_sym).\n  exact/esym/(closed_connect cl_a)/connect_root.\nhave{cl_a a_n} (x): b x -> froot f x = x /\\ order x = n.\n  by case/andP=> /eqP-> /(subsetP a_n)/eqnP->.\nelim: {a b}#|b| {1 3 4}b (eqxx #|b|) => [|m IHm] b def_m f_b.\n  by rewrite eq_card0 // => x; apply: (pred0P def_m).\nhave [x b_x | b0] := pickP b; last by rewrite (eq_card0 b0) in def_m.\nhave [r_x ox_n] := f_b x b_x; rewrite (cardD1 x) [x \\in b]b_x eqSS in def_m.\nrewrite mulSn -{1}ox_n -(IHm _ def_m) => [|_ /andP[_ /f_b //]].\nrewrite -(cardID (fconnect f x)); congr (_ + _); apply: eq_card => y.\n  by apply: andb_idl => /= fxy; rewrite !inE -(rootP symf fxy) r_x.\nby congr (~~ _ && _); rewrite /= /in_mem /= symf -(root_connect symf) r_x.\nQed.",
    "Lemma fclosed1 (a : {pred T}) :\n  fclosed f a -> forall x, (x \\in a) = (f x \\in a).\nProof. by move=> cl_a x; apply: cl_a (eqxx _). Qed.",
    "Lemma same_fconnect1 x : fconnect f x =1 fconnect f (f x).\nProof. by apply: same_connect1 => /=. Qed.",
    "Lemma same_fconnect1_r x y : fconnect f x y = fconnect f x (f y).\nProof. by apply: same_connect1r x => /=. Qed.",
    "Lemma fcard_gt0P (a : {pred T}) : \n  fclosed f a -> reflect (exists x, x \\in a) (0 < fcard f a).\nProof.\nmove=> clfA; apply: (iffP card_gt0P) => [[x /andP[]]|[x xA]]; first by exists x.\nexists (froot f x); rewrite inE roots_root /=; last exact: fconnect_sym.\nby rewrite -(closed_connect clfA (connect_root _ x)).\nQed.",
    "Lemma fcard_gt1P (A : {pred T}) :\n  fclosed f A ->\n  reflect (exists2 x, x \\in A & exists2 y, y \\in A & ~~ fconnect f x y)\n          (1 < fcard f A).\nProof.\nmove=> clAf; apply: (iffP card_gt1P) => [|[x xA [y yA not_xfy]]].\n  move=> [x [y [/andP [/= rfx xA] /andP[/= rfy yA] xDy]]].\n  by exists x; try exists y; rewrite // -root_connect // (eqP rfx) (eqP rfy).\nexists (froot f x), (froot f y); rewrite !inE !roots_root ?root_connect //=.\nby split => //; rewrite -(closed_connect clAf (connect_root _ _)).\nQed.",
    "Lemma fconnect_cycle y : fconnect f x y = (y \\in p).\nProof.\nhave [i q def_p] := rot_to p_x; rewrite -(mem_rot i p) def_p.\nhave{i def_p} /andP[/eqP q_x f_q]: (f (last x q) == x) && fpath f x q.\n  by have:= f_p; rewrite -(rot_cycle i) def_p (cycle_path x).\napply/idP/idP=> [/connectP[_ /fpathP[j ->] ->] | ]; last exact: path_connect.\ncase/fpathP: f_q q_x => n ->; rewrite !last_traject -iterS => def_x.\nby apply: (@loopingP _ f x n.+1); rewrite /looping def_x /= mem_head.\nQed.",
    "Lemma order_le_cycle : order x <= size p.\nProof.\napply: leq_trans (card_size _); apply/subset_leq_card/subsetP=> y.\nby rewrite !(fconnect_cycle, inE) ?eqxx.\nQed.",
    "Lemma order_cycle : order x = size p.\nProof. by rewrite -(card_uniqP Up); apply: (eq_card fconnect_cycle). Qed.",
    "Lemma orbitE : orbit x = rot (index x p) p.\nProof.\nset i := index _ _; rewrite /orbit order_cycle -(size_rot i) rot_index// -/i.\nset q := _ ++ _; suffices /fpathP[j ->]: fpath f x q by rewrite /= size_traject.\nby move: f_p; rewrite -(rot_cycle i) rot_index// (cycle_path x); case/andP.\nQed.",
    "Lemma orbit_rot_cycle : {i : nat | orbit x = rot i p}.\nProof. by rewrite orbitE; exists (index x p). Qed.",
    "Lemma finv_cycle : {homo finv : x / x \\in p}. Proof. exact: finv_in. Qed.",
    "Lemma f_finv_cycle : {in p, cancel finv f}. Proof. exact: f_finv_in. Qed.",
    "Lemma finv_f_cycle : {in p, cancel f finv}. Proof. exact: finv_f_in. Qed.",
    "Lemma finv_inj_cycle : {in p &, injective finv}. Proof. exact: finv_inj_in. Qed.",
    "Lemma iter_finv_cycle n :\n  {in p, forall x, n <= order x -> iter n finv x = iter (order x - n) f x}.\nProof. exact: iter_finv_in. Qed.",
    "Lemma cycle_orbit_cycle : {in p, forall x, fcycle f (orbit x)}.\nProof. exact: cycle_orbit_in. Qed.",
    "Lemma fpath_finv_cycle q x : (x \\in p) && (fpath finv x q) =\n  (last x q \\in p) && fpath f (last x q) (rev (belast x q)).\nProof. exact: fpath_finv_in. Qed.",
    "Lemma fpath_finv_f_cycle q : {in p, forall x,\n  fpath finv x q -> fpath f (last x q) (rev (belast x q))}.\nProof. exact: fpath_finv_f_in. Qed.",
    "Lemma fpath_f_finv_cycle q x : last x q \\in p ->\n  fpath f (last x q) (rev (belast x q)) -> fpath finv x q.\nProof. exact: fpath_f_finv_in. Qed.",
    "Lemma prevE x : x \\in p -> prev p x = finv x.\nProof.\nmove=> x_p; have /eqP/(congr1 finv) := prev_cycle f_p x_p.\nby rewrite finv_f_cycle// mem_prev.\nQed.",
    "Lemma fcycle_rconsE : rcons (x :: p) x = traject f x (size p).+2.\nProof. by rewrite rcons_cons; have /fpathE-> := f_p; rewrite size_rcons. Qed.",
    "Lemma fcycle_consE : x :: p = traject f x (size p).+1.\nProof. by have := fcycle_rconsE; rewrite trajectSr => /rcons_inj[/= <-]. Qed.",
    "Lemma fcycle_consEflatten : exists k, x :: p = flatten (nseq k.+1 (orbit x)).\nProof.\nmove: f_p; rewrite fcycle_consE; elim/ltn_ind: (size p) => n IHn t_cycle.\nhave := order_le_cycle t_cycle (mem_head _ _); rewrite size_traject.\ncase: ltngtP => [||<-] //; last by exists 0; rewrite /= cats0.\nrewrite ltnS => n_ge _; have := t_cycle.\nrewrite -(subnKC n_ge) -addnS trajectD.\nrewrite (iter_order_in (mem_fcycle f_p) (inj_cycle f_p)) ?mem_head//.\nset m := (_ - _) => cycle_cat.\nhave [||k->] := IHn m; last by exists k.+1.\n  by rewrite ltn_subrL (leq_trans _ n_ge) ?order_gt0.\nmove: cycle_cat; rewrite -orderSpred/= rcons_cat rcons_cons -cat_rcons.\nby rewrite cat_path last_rcons => /andP[].\nQed.",
    "Lemma undup_cycle_cons : undup (x :: p) = orbit x.\nProof.\nby have [n {1}->] := fcycle_consEflatten; rewrite undup_flatten_nseq ?undup_id.\nQed.",
    "Lemma fcycleEflatten : exists k, p = flatten (nseq k (undup p)).\nProof.\ncase: p f_p => [//|x q] f_q; first by exists 0.\nhave [k {1}->] := @fcycle_consEflatten x q f_q.\nby exists k.+1; rewrite undup_cycle_cons.\nQed.",
    "Lemma fcycle_undup : fcycle f (undup p).\nProof.\ncase: p f_p => [//|x q] f_q; rewrite undup_cycle_cons//.\nby rewrite (cycle_orbit_in (mem_fcycle f_q) (inj_cycle f_q)) ?mem_head.\nQed.",
    "Lemma in_orbit_cycle : {in p &, forall x, orbit x =i p}.\nProof.\nby move=> x y xp yp; rewrite (orbitE fcycle_undup)// ?mem_rot ?mem_undup.\nQed.",
    "Lemma eq_order_cycle : {in p &, forall x y, order y = order x}.\nProof. by move=> x y xp yp; rewrite !(order_cycle fcycle_undup) ?mem_undup. Qed.",
    "Lemma iter_order_cycle : {in p &, forall x y, iter (order x) f y = y}.\nProof.\nby move=> x y xp yp; rewrite (eq_order_cycle yp) ?(iter_order_in homo_f f_inj).\nQed.",
    "Lemma fconnect_eqVf x y : fconnect f x y = (x == y) || fconnect f (f x) y.\nProof.\napply/idP/idP => [/iter_findex <-|/predU1P [<-|] //]; last first.\n  exact/connect_trans/fconnect1.\nby case: findex => [|i]; rewrite ?eqxx// iterSr fconnect_iter orbT.\nQed.",
    "Lemma orbitPcycle {x} : [<->\n   fcycle f (orbit x);\n   order (f x) = order x;\n   x \\in fconnect f (f x);\n   exists k, iter k.+1 f x = x;\n   iter (order x) f x = x;\n   {in orbit x &, injective f}].\nProof.\ntfae=> [xorbit_cycle|||[k fkx]|fx y z|/injectivePcycle//].\n- by apply: eq_order_cycle xorbit_cycle _ _ _ _; rewrite ?mem_orbit.\n- move=> /subset_cardP/(_ _)->; rewrite ?inE//; apply/subsetP=> y.\n  by apply: connect_trans; apply: fconnect1.\n- by exists (findex (f x) x); rewrite // iterSr iter_findex.\n- apply: (@iter_order_cycle (traject f x k.+1)); rewrite /= ?mem_head//.\n  by apply/fpathP; exists k.+1; rewrite trajectSr -iterSr fkx.\n- rewrite -!fconnect_orbit => /iter_findex <- /iter_findex <-.\n  move/(congr1 (iter (order x).-1 f)).\n  by rewrite -!iterSr !orderSpred -!iterD ![order _ + _]addnC !iterD fx.\nQed.",
    "Lemma order_id_cycle x : fcycle f (orbit x) -> order (f x) = order x.\nProof. by move/(orbitPcycle 0 1). Qed.",
    "Lemma orderPcycle x : order_spec_cycle x (fcycle f (orbit x)).\nProof.\nhave [xcycle|Ncycle] := boolP (fcycle f (orbit x)); constructor => //.\n  by rewrite order_id_cycle.\nrewrite /order (eq_card (_ : _ =1 [predU1 x & fconnect f (f x)])).\n  by rewrite cardU1 inE (contraNN (all_iffLR orbitPcycle 2 0)).\nby move=> y; rewrite !inE fconnect_eqVf eq_sym.\nQed.",
    "Lemma fconnect_f x : fconnect f (f x) x = fcycle f (orbit x).\nProof. by apply/idP/idP => /(orbitPcycle 0 2). Qed.",
    "Lemma fconnect_findex x y :\n  fconnect f x y -> y != x -> findex x y = (findex (f x) y).+1.\nProof.\nrewrite /findex fconnect_orbit /orbit -orderSpred /= inE => /orP [-> //|].\nrewrite eq_sym; move=> yin /negPf->; have [_ eq_o|_ ->//] := orderPcycle x.\nby rewrite -(orderSpred (f x)) trajectSr -cats1 index_cat -eq_o yin.\nQed.",
    "Lemma fconnect_id (x : T) : fconnect id x =1 xpred1 x.\nProof. by move=> y; rewrite (@fconnect_cycle _ _ [:: x]) //= ?inE ?eqxx. Qed.",
    "Lemma order_id (x : T) : order id x = 1.\nProof. by rewrite /order (eq_card (fconnect_id x)) card1. Qed.",
    "Lemma orbit_id (x : T) : orbit id x = [:: x].\nProof. by rewrite /orbit order_id. Qed.",
    "Lemma froots_id (x : T) : froots id x.\nProof. by rewrite /roots -fconnect_id connect_root. Qed.",
    "Lemma froot_id (x : T) : froot id x = x.\nProof. by apply/eqP; apply: froots_id. Qed.",
    "Lemma fcard_id (a : {pred T}) : fcard id a = #|a|.\nProof. by apply: eq_card => x; rewrite inE froots_id. Qed.",
    "Lemma finv_eq_can : cancel f f' -> finv f =1 f'.\nProof.\nmove=> fK; have inj_f := can_inj fK.\nby apply: bij_can_eq fK; [apply: injF_bij | apply: finv_f].\nQed.",
    "Lemma eq_fconnect : fconnect f =2 fconnect f'.\nProof. exact: eq_connect eq_rf. Qed.",
    "Lemma eq_fcard : fcard_mem f =1 fcard_mem f'.\nProof. exact: eq_n_comp eq_fconnect. Qed.",
    "Lemma eq_finv : finv f =1 finv f'.\nProof.\nby move=> x; rewrite /finv /order (eq_card (@eq_fconnect x)) (eq_iter eq_f).\nQed.",
    "Lemma eq_froot : froot f =1 froot f'.\nProof. exact: eq_root eq_rf. Qed.",
    "Lemma eq_froots : froots f =1 froots f'.\nProof. exact: eq_roots eq_rf. Qed.",
    "Lemma finv_inv : finv (finv f) =1 f.\nProof. exact: (finv_eq_can (f_finv injf)). Qed.",
    "Lemma order_finv : order (finv f) =1 order f.\nProof. by move=> x; apply: eq_card (@same_fconnect_finv _ _ injf x). Qed.",
    "Lemma order_set_finv n : order_set (finv f) n =i order_set f n.\nProof. by move=> x; rewrite !inE order_finv. Qed.",
    "Lemma intro_adjunction (h' : forall x, x \\in a -> T') :\n   (forall x a_x,\n      [/\\ connect e x (h (h' x a_x))\n        & forall y a_y, e x y -> connect e' (h' x a_x) (h' y a_y)]) ->\n   (forall x' a_x,\n      [/\\ connect e' x' (h' (h x') a_x)\n        & forall y', e' x' y' -> connect e (h x') (h y')]) ->\n  rel_adjunction.\nProof.\nmove=> Aee' Ae'e; split=> [y a_y | x' z' a_x].\n  by exists (h' y a_y); case/Aee': (a_y).\napply/idP/idP=> [/connectP[p e'p ->{z'}] | /connectP[p e_p p_z']].\n  elim: p x' a_x e'p => //= y' p IHp x' a_x.\n  case: (Ae'e x' a_x) => _ Ae'x /andP[/Ae'x e_xy /IHp e_yz] {Ae'x}.\n  by apply: connect_trans (e_yz _); rewrite // -(closed_connect cl_a e_xy).\ncase: (Ae'e x' a_x) => /connect_trans-> //.\nelim: p {x'}(h x') p_z' a_x e_p => /= [|y p IHp] x p_z' a_x.\n  by rewrite -p_z' in a_x *; case: (Ae'e _ a_x); rewrite sym_e'.\ncase/andP=> e_xy /(IHp _ p_z') e'yz; have a_y: y \\in a by rewrite -(cl_a e_xy).\nby apply: connect_trans (e'yz a_y); case: (Aee' _ a_x) => _ ->.\nQed.",
    "Lemma strict_adjunction :\n    injective h -> a \\subset codom h -> rel_base h e e' [predC a] ->\n  rel_adjunction.\nProof.\nmove=> /= injh h_a a_ee'; pose h' x Hx := iinv (subsetP h_a x Hx).\napply: (@intro_adjunction h') => [x a_x | x' a_x].\n  rewrite f_iinv connect0; split=> // y a_y e_xy.\n  by rewrite connect1 // -a_ee' !f_iinv ?negbK.\nrewrite [h' _ _]iinv_f //; split=> // y' e'xy.\nby rewrite connect1 // a_ee' ?negbK.\nQed.",
    "Lemma adjunction_closed : rel_adjunction -> closed e' [preim h of a].\nProof.\ncase=> _ Ae'e; apply: intro_closed => // x' y' /connect1 e'xy a_x.\nby rewrite Ae'e // in e'xy; rewrite !inE -(ccl_a e'xy).\nQed.",
    "Lemma adjunction_n_comp :\n  rel_adjunction -> n_comp e a = n_comp e' [preim h of a].\nProof.\ncase=> Aee' Ae'e.\nhave inj_h: {in predI (roots e') [preim h of a] &, injective (root e \\o h)}.\n  move=> x' y' /andP[/eqP r_x' /= a_x'] /andP[/eqP r_y' _] /(rootP sym_e).\n  by rewrite -Ae'e // => /(rootP sym_e'); rewrite r_x' r_y'.\nrewrite /n_comp_mem -(card_in_image inj_h); apply: eq_card => x.\napply/andP/imageP=> [[/eqP rx a_x] | [x' /andP[/eqP r_x' a_x'] ->]]; last first.\n  by rewrite /= -(ccl_a (connect_root _ _)) roots_root.\nhave [y' e_xy]:= Aee' x a_x; pose x' := root e' y'.\nhave ay': h y' \\in a by rewrite -(ccl_a e_xy).\nhave e_yx: connect e (h y') (h x') by rewrite -Ae'e ?connect_root.\nexists x'; first by rewrite inE /= -(ccl_a e_yx) ?roots_root.\nby rewrite /= -(rootP sym_e e_yx) -(rootP sym_e e_xy).\nQed.",
    "Lemma mulmA : associative mul. Proof. exact: opA. Qed.",
    "Lemma mulmC : commutative mul. Proof. exact: opC. Qed.",
    "Lemma mulmCA : left_commutative mul.\nProof. by move=> x y z; rewrite !mulmA [_ x _]mulmC. Qed.",
    "Lemma mulmAC : right_commutative mul.\nProof. by move=> x y z; rewrite -!mulmA [_ y _]mulmC. Qed.",
    "Lemma mulmACA : interchange mul mul.\nProof. by move=> x y z t; rewrite -!mulmA [_ y _]mulmCA. Qed.",
    "Lemma opm1 : right_id idm op. Proof. by move=> x; rewrite opC op1m. Qed.",
    "Lemma mulC_id : left_id one mul -> right_id one mul.\nProof. by move=> mul1x x; rewrite mulC. Qed.",
    "Lemma mulC_zero : left_zero zero mul -> right_zero zero mul.\nProof. by move=> mul0x x; rewrite mulC. Qed.",
    "Lemma mulC_dist : left_distributive mul add -> right_distributive mul add.\nProof. by move=> mul_addl x y z; rewrite !(mulC x). Qed.",
    "Lemma mul1m : left_id idm mul. Proof. exact: op1m. Qed.",
    "Lemma mulm1 : right_id idm mul. Proof. exact: opm1. Qed.",
    "Lemma iteropE n x : iterop n mul x idm = iter n (mul x) idm.\nProof. by case: n => // n; rewrite iterSr mulm1 iteropS. Qed.",
    "Lemma mul0m : left_zero idm mul. Proof. exact: mul_zerol. Qed.",
    "Lemma mulm0 : right_zero idm mul. Proof. exact: mul_zeror. Qed.",
    "Lemma addmA : associative add. Proof. exact: mulmA. Qed.",
    "Lemma addmC : commutative add. Proof. exact: mulmC. Qed.",
    "Lemma addmCA : left_commutative add. Proof. exact: mulmCA. Qed.",
    "Lemma addmAC : right_commutative add. Proof. exact: mulmAC. Qed.",
    "Lemma add0m : left_id idm add. Proof. exact: mul1m. Qed.",
    "Lemma addm0 : right_id idm add. Proof. exact: mulm1. Qed.",
    "Lemma mulmDl : left_distributive mul add. Proof. exact: mul_op_Dl. Qed.",
    "Lemma mulmDr : right_distributive mul add. Proof. exact: mul_op_Dr. Qed.",
    "Lemma mem_index_iota m n i : i \\in index_iota m n = (m <= i < n).\nProof.\nrewrite mem_iota; case le_m_i: (m <= i) => //=.\nby rewrite -leq_subLR subSn // -subn_gt0 -subnDA subnKC // subn_gt0.\nQed.",
    "Lemma deprecated_filter_index_enum T P : filter P (index_enum T) = enum P.\nProof. by rewrite [index_enum T]unlock. Qed.",
    "Lemma mem_index_enum T i : i \\in index_enum T.\nProof. by rewrite [index_enum T]unlock -enumT mem_enum. Qed.",
    "Lemma index_enum_uniq T : uniq (index_enum T).\nProof. by rewrite [index_enum T]unlock -enumT enum_uniq. Qed.",
    "Lemma big_load R (K K' : R -> Type) idx op I r (P : pred I) F :\n  K (\\big[op/idx]_(i <- r | P i) F i) * K' (\\big[op/idx]_(i <- r | P i) F i)\n  -> K' (\\big[op/idx]_(i <- r | P i) F i).\nProof. by case. Qed.",
    "Lemma big_rec3 I r (P : pred I) F1 F2 F3\n    (K_F : forall i y1 y2 y3, P i -> K y1 y2 y3 ->\n       K (op1 (F1 i) y1) (op2 (F2 i) y2) (op3 (F3 i) y3)) :\n  K (\\big[op1/id1]_(i <- r | P i) F1 i)\n    (\\big[op2/id2]_(i <- r | P i) F2 i)\n    (\\big[op3/id3]_(i <- r | P i) F3 i).\nProof. by rewrite unlock; elim: r => //= i r; case: ifP => //; apply: K_F. Qed.",
    "Lemma big_ind3 I r (P : pred I) F1 F2 F3\n   (K_F : forall i, P i -> K (F1 i) (F2 i) (F3 i)) :\n  K (\\big[op1/id1]_(i <- r | P i) F1 i)\n    (\\big[op2/id2]_(i <- r | P i) F2 i)\n    (\\big[op3/id3]_(i <- r | P i) F3 i).\nProof. by apply: big_rec3 => i x1 x2 x3 /K_F; apply: Kop. Qed.",
    "Lemma big_rec2 I r (P : pred I) F1 F2\n    (K_F : forall i y1 y2, P i -> K y1 y2 ->\n       K (op1 (F1 i) y1) (op2 (F2 i) y2)) :\n  K (\\big[op1/id1]_(i <- r | P i) F1 i) (\\big[op2/id2]_(i <- r | P i) F2 i).\nProof. by rewrite unlock; elim: r => //= i r; case: ifP => //; apply: K_F. Qed.",
    "Lemma big_ind2 I r (P : pred I) F1 F2 (K_F : forall i, P i -> K (F1 i) (F2 i)) :\n  K (\\big[op1/id1]_(i <- r | P i) F1 i) (\\big[op2/id2]_(i <- r | P i) F2 i).\nProof. by apply: big_rec2 => i x1 x2 /K_F; apply: Kop. Qed.",
    "Lemma big_morph I r (P : pred I) F :\n  f (\\big[op2/id2]_(i <- r | P i) F i) = \\big[op1/id1]_(i <- r | P i) f (F i).\nProof. by rewrite unlock; elim: r => //= i r <-; rewrite -f_op -fun_if. Qed.",
    "Lemma big_rec I r (P : pred I) F\n    (Kop : forall i x, P i -> K x -> K (op (F i) x)) :\n  K (\\big[op/idx]_(i <- r | P i) F i).\nProof. by rewrite unlock; elim: r => //= i r; case: ifP => //; apply: Kop. Qed.",
    "Lemma big_ind I r (P : pred I) F (K_F : forall i, P i -> K (F i)) :\n  K (\\big[op/idx]_(i <- r | P i) F i).\nProof. by apply: big_rec => // i x /K_F /Kop; apply. Qed.",
    "Lemma eq_big_op I r (P : pred I) F (K_F : forall i, P i -> K (F i)) :\n  \\big[op/idx]_(i <- r | P i) F i = \\big[op'/idx]_(i <- r | P i) F i.\nProof.\nby elim/(big_load K): _; elim/big_rec2: _ => // i _ y Pi [Ky <-]; auto.\nQed.",
    "Lemma big_endo I r (P : pred I) F :\n  f (\\big[op/idx]_(i <- r | P i) F i) = \\big[op/idx]_(i <- r | P i) f (F i).\nProof. exact: big_morph. Qed.",
    "Lemma big_morph_in (R1 R2 : Type) (Q : {pred R2}) (f : R2 -> R1)\n    (id1 : R1) (op1 : R1 -> R1 -> R1)\n    (id2 : R2) (op2 : R2 -> R2 -> R2) :\n    {in Q &, forall x y, op2 x y \\in Q} ->\n    id2 \\in Q ->\n    {in Q &, {morph f : x y / op2 x y >-> op1 x y}} ->\n    f id2 = id1 ->\n    forall [I : Type] (r : seq I) (P : pred I) (F : I -> R2),\n      (forall i, P i -> F i \\in Q) ->\n  f (\\big[op2/id2]_(i <- r | P i) F i) = \\big[op1/id1]_(i <- r | P i) f (F i).\nProof.\nmove=> Qop Qid fop fid I r P F QF; elim/(big_load Q): _.\nby elim/big_rec2: _ => // j x y Pj [Qx <-]; rewrite [Q _]Qop ?fop ?QF.\nQed.",
    "Lemma oACE x y : oop (Some x) (Some y) = some (op x y). Proof. by []. Qed.",
    "Lemma oopA_subdef : associative oop.\nProof. by move=> [x|] [y|] [z|]//; rewrite /oAC/= opA. Qed.",
    "Lemma oopx1_subdef : left_id None oop. Proof. by case. Qed.",
    "Lemma oop1x_subdef : right_id None oop. Proof. by []. Qed.",
    "Lemma oopC_subdef : commutative oop.\nProof. by move=> [x|] [y|]//; rewrite /oAC/= opC. Qed.",
    "Lemma some_big_AC_mk_monoid [I : Type] r P (F : I -> T) :\n  Some (\\big[op/x]_(i <- r | P i) F i) =\n    oop (\\big[oop/None]_(i <- r | P i) Some (F i)) (Some x).\nProof. by elim/big_rec2 : _ => //= i [y|] _ Pi [] -> //=; rewrite opA. Qed.",
    "Lemma big_AC_mk_monoid [I : Type] r P (F : I -> T) :\n  \\big[op/x]_(i <- r | P i) F i =\n    odflt x (oop (\\big[oop/None]_(i <- r | P i) Some (F i)) (Some x)).\nProof. by apply: Some_inj; rewrite some_big_AC_mk_monoid. Qed.",
    "Lemma foldrE r : foldr op idx r = \\big[op/idx]_(x <- r) x.\nProof. by rewrite unlock. Qed.",
    "Lemma big_filter r (P : pred I) F :\n  \\big[op/idx]_(i <- filter P r) F i = \\big[op/idx]_(i <- r | P i) F i.\nProof. by rewrite unlock; elim: r => //= i r <-; case (P i). Qed.",
    "Lemma big_filter_cond r (P1 P2 : pred I) F :\n  \\big[op/idx]_(i <- filter P1 r | P2 i) F i\n     = \\big[op/idx]_(i <- r | P1 i && P2 i) F i.\nProof.\nrewrite -big_filter -(big_filter r); congr bigop.\nby rewrite -filter_predI; apply: eq_filter => i; apply: andbC.\nQed.",
    "Lemma eq_bigl r (P1 P2 : pred I) F :\n    P1 =1 P2 ->\n  \\big[op/idx]_(i <- r | P1 i) F i = \\big[op/idx]_(i <- r | P2 i) F i.\nProof. by move=> eqP12; rewrite -!(big_filter r) (eq_filter eqP12). Qed.",
    "Lemma big_andbC r (P Q : pred I) F :\n  \\big[op/idx]_(i <- r | P i && Q i) F i\n    = \\big[op/idx]_(i <- r | Q i && P i) F i.\nProof. by apply: eq_bigl => i; apply: andbC. Qed.",
    "Lemma eq_bigr r (P : pred I) F1 F2 : (forall i, P i -> F1 i = F2 i) ->\n  \\big[op/idx]_(i <- r | P i) F1 i = \\big[op/idx]_(i <- r | P i) F2 i.\nProof. by move=> eqF12; elim/big_rec2: _ => // i x _ /eqF12-> ->. Qed.",
    "Lemma eq_big r (P1 P2 : pred I) F1 F2 :\n    P1 =1 P2 -> (forall i, P1 i -> F1 i = F2 i) ->\n  \\big[op/idx]_(i <- r | P1 i) F1 i = \\big[op/idx]_(i <- r | P2 i) F2 i.\nProof. by move/eq_bigl <-; move/eq_bigr->. Qed.",
    "Lemma congr_big r1 r2 (P1 P2 : pred I) F1 F2 :\n    r1 = r2 -> P1 =1 P2 -> (forall i, P1 i -> F1 i = F2 i) ->\n  \\big[op/idx]_(i <- r1 | P1 i) F1 i = \\big[op/idx]_(i <- r2 | P2 i) F2 i.\nProof. by move=> <-{r2}; apply: eq_big. Qed.",
    "Lemma big_nil (P : pred I) F : \\big[op/idx]_(i <- [::] | P i) F i = idx.\nProof. by rewrite unlock. Qed.",
    "Lemma big_cons i r (P : pred I) F :\n    let x := \\big[op/idx]_(j <- r | P j) F j in\n  \\big[op/idx]_(j <- i :: r | P j) F j = if P i then op (F i) x else x.\nProof. by rewrite unlock. Qed.",
    "Lemma big_rcons_op i r (P : pred I) F :\n    let idx' := if P i then op (F i) idx else idx in\n  \\big[op/idx]_(j <- rcons r i | P j) F j = \\big[op/idx']_(j <- r | P j) F j.\nProof.\nby elim: r => /= [|j r]; rewrite !(big_nil, big_cons, unlock)// => ->.\nQed.",
    "Lemma big_map J (h : J -> I) r (P : pred I) F :\n  \\big[op/idx]_(i <- map h r | P i) F i\n     = \\big[op/idx]_(j <- r | P (h j)) F (h j).\nProof. by rewrite unlock; elim: r => //= j r ->. Qed.",
    "Lemma big_nth x0 r (P : pred I) F :\n  \\big[op/idx]_(i <- r | P i) F i\n     = \\big[op/idx]_(0 <= i < size r | P (nth x0 r i)) (F (nth x0 r i)).\nProof. by rewrite -[r in LHS](mkseq_nth x0) big_map /index_iota subn0. Qed.",
    "Lemma big_hasC r (P : pred I) F :\n  ~~ has P r -> \\big[op/idx]_(i <- r | P i) F i = idx.\nProof.\nby rewrite -big_filter has_count -size_filter -eqn0Ngt unlock => /nilP->.\nQed.",
    "Lemma big_pred0_eq (r : seq I) F : \\big[op/idx]_(i <- r | false) F i = idx.\nProof. by rewrite big_hasC // has_pred0. Qed.",
    "Lemma big_pred0 r (P : pred I) F :\n  P =1 xpred0 -> \\big[op/idx]_(i <- r | P i) F i = idx.\nProof. by move/eq_bigl->; apply: big_pred0_eq. Qed.",
    "Lemma big_cat_nested r1 r2 (P : pred I) F :\n    let x := \\big[op/idx]_(i <- r2 | P i) F i in\n  \\big[op/idx]_(i <- r1 ++ r2 | P i) F i = \\big[op/x]_(i <- r1 | P i) F i.\nProof. by rewrite unlock /reducebig foldr_cat. Qed.",
    "Lemma big_catl r1 r2 (P : pred I) F :\n    ~~ has P r2 ->\n  \\big[op/idx]_(i <- r1 ++ r2 | P i) F i = \\big[op/idx]_(i <- r1 | P i) F i.\nProof. by rewrite big_cat_nested => /big_hasC->. Qed.",
    "Lemma big_catr r1 r2 (P : pred I) F :\n     ~~ has P r1 ->\n  \\big[op/idx]_(i <- r1 ++ r2 | P i) F i = \\big[op/idx]_(i <- r2 | P i) F i.\nProof.\nrewrite -big_filter -(big_filter r2) filter_cat.\nby rewrite has_count -size_filter; case: filter.\nQed.",
    "Lemma big_map_id J (h : J -> R) r (P : pred R) :\n  \\big[op/idx]_(i <- map h r | P i) i\n     = \\big[op/idx]_(j <- r | P (h j)) h j.\nProof. exact: big_map. Qed.",
    "Lemma big_condT (J : finType) (A : {pred J}) F :\n  \\big[op/idx]_(i in A | true) F i = \\big[op/idx]_(i in A) F i.\nProof. by apply: eq_bigl => i; exact: andbT. Qed.",
    "Lemma big_seq_cond (I : eqType) r (P : pred I) F :\n  \\big[op/idx]_(i <- r | P i) F i\n    = \\big[op/idx]_(i <- r | (i \\in r) && P i) F i.\nProof.\nby rewrite -!(big_filter r); congr bigop; apply: eq_in_filter => i ->.\nQed.",
    "Lemma big_seq (I : eqType) (r : seq I) F :\n  \\big[op/idx]_(i <- r) F i = \\big[op/idx]_(i <- r | i \\in r) F i.\nProof. by rewrite big_seq_cond big_andbC. Qed.",
    "Lemma eq_big_seq (I : eqType) (r : seq I) F1 F2 :\n  {in r, F1 =1 F2} -> \\big[op/idx]_(i <- r) F1 i = \\big[op/idx]_(i <- r) F2 i.\nProof. by move=> eqF; rewrite !big_seq (eq_bigr _ eqF). Qed.",
    "Lemma big_nat_cond m n (P : pred nat) F :\n  \\big[op/idx]_(m <= i < n | P i) F i\n    = \\big[op/idx]_(m <= i < n | (m <= i < n) && P i) F i.\nProof.\nby rewrite big_seq_cond; apply: eq_bigl => i; rewrite mem_index_iota.\nQed.",
    "Lemma big_nat m n F :\n  \\big[op/idx]_(m <= i < n) F i = \\big[op/idx]_(m <= i < n | m <= i < n) F i.\nProof. by rewrite big_nat_cond big_andbC. Qed.",
    "Lemma congr_big_nat m1 n1 m2 n2 P1 P2 F1 F2 :\n    m1 = m2 -> n1 = n2 ->\n    (forall i, m1 <= i < n2 -> P1 i = P2 i) ->\n    (forall i, P1 i && (m1 <= i < n2) -> F1 i = F2 i) ->\n  \\big[op/idx]_(m1 <= i < n1 | P1 i) F1 i\n    = \\big[op/idx]_(m2 <= i < n2 | P2 i) F2 i.\nProof.\nmove=> <- <- eqP12 eqF12; rewrite big_seq_cond (big_seq_cond _ P2).\napply: eq_big => i; rewrite ?inE /= !mem_index_iota.\n  by apply: andb_id2l; apply: eqP12.\nby rewrite andbC; apply: eqF12.\nQed.",
    "Lemma eq_big_nat m n F1 F2 :\n    (forall i, m <= i < n -> F1 i = F2 i) ->\n  \\big[op/idx]_(m <= i < n) F1 i = \\big[op/idx]_(m <= i < n) F2 i.\nProof. by move=> eqF; apply: congr_big_nat. Qed.",
    "Lemma big_geq m n (P : pred nat) F :\n  m >= n -> \\big[op/idx]_(m <= i < n | P i) F i = idx.\nProof. by move=> ge_m_n; rewrite /index_iota (eqnP ge_m_n) big_nil. Qed.",
    "Lemma big_ltn_cond m n (P : pred nat) F :\n    m < n -> let x := \\big[op/idx]_(m.+1 <= i < n | P i) F i in\n  \\big[op/idx]_(m <= i < n | P i) F i = if P m then op (F m) x else x.\nProof. by case: n => [//|n] le_m_n; rewrite /index_iota subSn // big_cons. Qed.",
    "Lemma big_ltn m n F :\n     m < n ->\n  \\big[op/idx]_(m <= i < n) F i = op (F m) (\\big[op/idx]_(m.+1 <= i < n) F i).\nProof. by move=> lt_mn; apply: big_ltn_cond. Qed.",
    "Lemma big_addn m n a (P : pred nat) F :\n  \\big[op/idx]_(m + a <= i < n | P i) F i =\n     \\big[op/idx]_(m <= i < n - a | P (i + a)) F (i + a).\nProof.\nrewrite /index_iota -subnDA addnC iotaDl big_map.\nby apply: eq_big => ? *; rewrite addnC.\nQed.",
    "Lemma big_add1 m n (P : pred nat) F :\n  \\big[op/idx]_(m.+1 <= i < n | P i) F i =\n     \\big[op/idx]_(m <= i < n.-1 | P (i.+1)) F (i.+1).\nProof.\nby rewrite -addn1 big_addn subn1; apply: eq_big => ? *; rewrite addn1.\nQed.",
    "Lemma big_nat_recl n m F : m <= n ->\n  \\big[op/idx]_(m <= i < n.+1) F i =\n     op (F m) (\\big[op/idx]_(m <= i < n) F i.+1).\nProof. by move=> lemn; rewrite big_ltn // big_add1. Qed.",
    "Lemma big_mkord n (P : pred nat) F :\n  \\big[op/idx]_(0 <= i < n | P i) F i = \\big[op/idx]_(i < n | P i) F i.\nProof.\nrewrite /index_iota subn0 -(big_map (@nat_of_ord n)).\nby congr bigop; rewrite /index_enum 2!unlock val_ord_enum.\nQed.",
    "Lemma big_mknat n (P : pred 'I_n.+1) F :\n  \\big[op/idx]_(i < n.+1 | P i) F i\n  = \\big[op/idx]_(0 <= i < n.+1 | P (inord i)) F (inord i).\nProof. by rewrite big_mkord; apply: eq_big => ?; rewrite inord_val. Qed.",
    "Lemma big_nat_widen m n1 n2 (P : pred nat) F :\n     n1 <= n2 ->\n  \\big[op/idx]_(m <= i < n1 | P i) F i\n      = \\big[op/idx]_(m <= i < n2 | P i && (i < n1)) F i.\nProof.\nmove=> len12; symmetry; rewrite -big_filter filter_predI big_filter.\nhave [ltn_trans eq_by_mem] := (ltn_trans, irr_sorted_eq ltn_trans ltnn).\ncongr bigop; apply: eq_by_mem; rewrite ?sorted_filter ?iota_ltn_sorted // => i.\nrewrite mem_filter !mem_index_iota andbCA andbA andb_idr => // /andP[_].\nby move/leq_trans->.\nQed.",
    "Lemma big_ord_widen_cond n1 n2 (P : pred nat) (F : nat -> R) :\n     n1 <= n2 ->\n  \\big[op/idx]_(i < n1 | P i) F i\n      = \\big[op/idx]_(i < n2 | P i && (i < n1)) F i.\nProof. by move/big_nat_widen=> len12; rewrite -big_mkord len12 big_mkord. Qed.",
    "Lemma big_ord_widen n1 n2 (F : nat -> R) :\n    n1 <= n2 ->\n  \\big[op/idx]_(i < n1) F i = \\big[op/idx]_(i < n2 | i < n1) F i.\nProof. by move=> le_n12; apply: (big_ord_widen_cond (predT)). Qed.",
    "Lemma big_ord_widen_leq n1 n2 (P : pred 'I_(n1.+1)) F :\n    n1 < n2 ->\n  \\big[op/idx]_(i < n1.+1 | P i) F i\n      = \\big[op/idx]_(i < n2 | P (inord i) && (i <= n1)) F (inord i).\nProof.\nmove=> len12; pose g G i := G (inord i : 'I_(n1.+1)).\nrewrite -(big_ord_widen_cond (g _ P) (g _ F) len12) {}/g.\nby apply: eq_big => i *; rewrite inord_val.\nQed.",
    "Lemma big_ord0 P F : \\big[op/idx]_(i < 0 | P i) F i = idx.\nProof. by rewrite big_pred0 => [|[]]. Qed.",
    "Lemma big_mask_tuple I n m (t : n.-tuple I) (P : pred I) F :\n  \\big[op/idx]_(i <- mask m t | P i) F i\n    = \\big[op/idx]_(i < n | nth false m i && P (tnth t i)) F (tnth t i).\nProof.\nrewrite [t in LHS]tuple_map_ord/= -map_mask big_map.\nby rewrite mask_enum_ord big_filter_cond/= enumT.\nQed.",
    "Lemma big_mask I r m (P : pred I) (F : I -> R) (r_ := tnth (in_tuple r)) :\n  \\big[op/idx]_(i <- mask m r | P i) F i\n    = \\big[op/idx]_(i < size r | nth false m i && P (r_ i)) F (r_ i).\nProof. exact: (big_mask_tuple _ (in_tuple r)). Qed.",
    "Lemma big_tnth I r (P : pred I) F (r_ := tnth (in_tuple r)) :\n  \\big[op/idx]_(i <- r | P i) F i\n    = \\big[op/idx]_(i < size r | P (r_ i)) (F (r_ i)).\nProof.\nrewrite /= -[r in LHS](mask_true (leqnn (size r))) big_mask//.\nby apply: eq_bigl => i /=; rewrite nth_nseq ltn_ord.\nQed.",
    "Lemma big_index_uniq (I : eqType) (r : seq I) (E : 'I_(size r) -> R) :\n    uniq r ->\n  \\big[op/idx]_i E i = \\big[op/idx]_(x <- r) oapp E idx (insub (index x r)).\nProof.\nmove=> Ur; apply/esym; rewrite big_tnth.\nby under [LHS]eq_bigr do rewrite index_uniq// valK.\nQed.",
    "Lemma big_tuple I n (t : n.-tuple I) (P : pred I) F :\n  \\big[op/idx]_(i <- t | P i) F i\n     = \\big[op/idx]_(i < n | P (tnth t i)) F (tnth t i).\nProof. by rewrite big_tnth tvalK; case: _ / (esym _). Qed.",
    "Lemma big_ord_narrow_cond n1 n2 (P : pred 'I_n2) F (le_n12 : n1 <= n2) :\n    let w := widen_ord le_n12 in\n  \\big[op/idx]_(i < n2 | P i && (i < n1)) F i\n    = \\big[op/idx]_(i < n1 | P (w i)) F (w i).\nProof.\ncase: n1 => [|n1] /= in le_n12 *.\n  by rewrite big_ord0 big_pred0 // => i; rewrite andbF.\nrewrite (big_ord_widen_leq _ _ le_n12); apply: eq_big => i.\n  by apply: andb_id2r => le_i_n1; congr P; apply: val_inj; rewrite /= inordK.\nby case/andP=> _ le_i_n1; congr F; apply: val_inj; rewrite /= inordK.\nQed.",
    "Lemma big_ord_narrow_cond_leq n1 n2 (P : pred _) F (le_n12 : n1 <= n2) :\n    let w := @widen_ord n1.+1 n2.+1 le_n12 in\n  \\big[op/idx]_(i < n2.+1 | P i && (i <= n1)) F i\n  = \\big[op/idx]_(i < n1.+1 | P (w i)) F (w i).\nProof. exact: (@big_ord_narrow_cond n1.+1 n2.+1). Qed.",
    "Lemma big_ord_narrow n1 n2 F (le_n12 : n1 <= n2) :\n    let w := widen_ord le_n12 in\n  \\big[op/idx]_(i < n2 | i < n1) F i = \\big[op/idx]_(i < n1) F (w i).\nProof. exact: (big_ord_narrow_cond (predT)). Qed.",
    "Lemma big_ord_narrow_leq n1 n2 F (le_n12 : n1 <= n2) :\n    let w := @widen_ord n1.+1 n2.+1 le_n12 in\n  \\big[op/idx]_(i < n2.+1 | i <= n1) F i = \\big[op/idx]_(i < n1.+1) F (w i).\nProof. exact: (big_ord_narrow_cond_leq (predT)). Qed.",
    "Lemma big_ord_recl n F :\n  \\big[op/idx]_(i < n.+1) F i =\n     op (F ord0) (\\big[op/idx]_(i < n) F (@lift n.+1 ord0 i)).\nProof.\npose G i := F (inord i); have eqFG i: F i = G i by rewrite /G inord_val.\nunder eq_bigr do rewrite eqFG; under [in RHS]eq_bigr do rewrite eqFG.\nby rewrite -(big_mkord _ (fun _ => _) G) eqFG big_ltn // big_add1 /= big_mkord.\nQed.",
    "Lemma big_nseq_cond I n a (P : pred I) F :\n  \\big[op/idx]_(i <- nseq n a | P i) F i\n    = if P a then iter n (op (F a)) idx else idx.\nProof. by rewrite unlock; elim: n => /= [|n ->]; case: (P a). Qed.",
    "Lemma big_nseq I n a (F : I -> R):\n  \\big[op/idx]_(i <- nseq n a) F i = iter n (op (F a)) idx.\nProof. exact: big_nseq_cond. Qed.",
    "Lemma big_enumP I P : big_enum_spec P (filter P (index_enum I)).\nProof.\nset e := filter P _; have Ue: uniq e by apply/filter_uniq/index_enum_uniq.\nhave mem_e i: i \\in e = P i by rewrite mem_filter mem_index_enum andbT.\nsplit=> // [R idx op F | cP]; first by rewrite big_filter.\nsuffices De: perm_eq e (enum cP) by rewrite (perm_size De) cardE.\nby apply/uniq_perm=> // [|i]; rewrite ?enum_uniq ?mem_enum ?mem_e.\nQed.",
    "Lemma big_const_seq I r (P : pred I) x :\n  \\big[op/idx]_(i <- r | P i) x = iter (count P r) (op x) idx.\nProof. by rewrite unlock; elim: r => //= i r ->; case: (P i). Qed.",
    "Lemma big_const (I : finType) (A : {pred I}) x :\n  \\big[op/idx]_(i in A) x = iter #|A| (op x) idx.\nProof.\nby have [e <- _ [_ <-]] := big_enumP A; rewrite big_const_seq count_predT.\nQed.",
    "Lemma big_const_nat m n x :\n  \\big[op/idx]_(m <= i < n) x = iter (n - m) (op x) idx.\nProof. by rewrite big_const_seq count_predT size_iota. Qed.",
    "Lemma big_const_ord n x :\n  \\big[op/idx]_(i < n) x = iter n (op x) idx.\nProof. by rewrite big_const card_ord. Qed.",
    "Lemma big_seq1_id I (i : I) (F : I -> R) :\n  \\big[op/x]_(j <- [:: i]) F j = op (F i) x.\nProof. by rewrite big_cons big_nil. Qed.",
    "Lemma big_nat1_id n F : \\big[op/x]_(n <= i < n.+1) F i = op (F n) x.\nProof. by rewrite big_ltn // big_geq // mulm1. Qed.",
    "Lemma big_pred1_eq_id (I : finType) (i : I) F :\n  \\big[op/x]_(j | j == i) F j = op (F i) x.\nProof.\nhave [e1 <- _ [e_enum _]] := big_enumP (pred1 i).\nby rewrite (perm_small_eq _ e_enum) enum1 ?big_seq1_id.\nQed.",
    "Lemma big_pred1_id (I : finType) i (P : pred I) F :\n  P =1 pred1 i -> \\big[op/x]_(j | P j) F j = op (F i) x.\nProof. by move/(eq_bigl _ _)->; apply: big_pred1_eq_id. Qed.",
    "Lemma big_const_idem I (r : seq I) P : \\big[op/x]_(i <- r | P i) x = x.\nProof. by elim/big_ind : _ => // _ _ -> ->. Qed.",
    "Lemma big1_idem I r (P : pred I) F :\n  (forall i, P i -> F i = x) -> \\big[op/x]_(i <- r | P i) F i = x.\nProof.\nmove=> Fix; under eq_bigr => ? ? do rewrite Fix//; exact: big_const_idem.\nQed.",
    "Lemma big_id_idem I (r : seq I) P F :\n  op (\\big[op/x]_(i <- r | P i) F i) x = \\big[op/x]_(i <- r | P i) F i.\nProof. by elim/big_rec : _ => // ? ? ?; rewrite -opA => ->. Qed.",
    "Lemma big_rem_AC (I : eqType) (r : seq I) z (P : pred I) F : z \\in r ->\n  \\big[op/x]_(y <- r | P y) F y\n    = if P z then op (F z) (\\big[op/x]_(y <- rem z r | P y) F y)\n      else \\big[op/x]_(y <- rem z r | P y) F y.\nProof.\nelim: r =>// i r ih; rewrite big_cons rem_cons inE =>/predU1P[-> /[!eqxx]//|zr].\nby case: eqP => [-> //|]; rewrite ih// big_cons; case: ifPn; case: ifPn.\nQed.",
    "Lemma big_undup (I : eqType) (r : seq I) (P : pred I) F :\n    idempotent_op op ->\n  \\big[op/x]_(i <- undup r | P i) F i = \\big[op/x]_(i <- r | P i) F i.\nProof.\nmove=> opxx; rewrite -!(big_filter _ _ _ P) filter_undup.\nelim: {P r}(filter P r) => //= i r IHr.\ncase: ifP => [r_i | _]; rewrite !big_cons {}IHr //.\nby rewrite (big_rem_AC _ _ r_i) opA /= opxx.\nQed.",
    "Lemma perm_big (I : eqType) r1 r2 (P : pred I) F :\n    perm_eq r1 r2 ->\n  \\big[op/x]_(i <- r1 | P i) F i = \\big[op/x]_(i <- r2 | P i) F i.\nProof.\nelim: r1 r2 => [|i r1 IHr1] r2 eq_r12.\n  by case: r2 eq_r12 => [//|i r2] /[1!perm_sym] /perm_nilP.\nhave r2i: i \\in r2 by rewrite -has_pred1 has_count -(permP eq_r12) /= eqxx.\nrewrite big_cons (IHr1 (rem i r2)) -?big_rem_AC// -(perm_cons i).\nexact: perm_trans (perm_to_rem _).\nQed.",
    "Lemma big_enum_cond (I : finType) (A : {pred I}) (P : pred I) F :\n  \\big[op/x]_(i <- enum A | P i) F i = \\big[op/x]_(i in A | P i) F i.\nProof.\nby rewrite -big_filter_cond; have [e _ _ [/perm_big->]] := big_enumP.\nQed.",
    "Lemma big_enum (I : finType) (A : {pred I}) F :\n  \\big[op/x]_(i <- enum A) F i = \\big[op/x]_(i in A) F i.\nProof. by rewrite big_enum_cond big_andbC. Qed.",
    "Lemma big_uniq (I : finType) (r : seq I) F :\n  uniq r -> \\big[op/x]_(i <- r) F i = \\big[op/x]_(i in r) F i.\nProof.\nmove=> uniq_r; rewrite -big_enum; apply: perm_big.\nby rewrite uniq_perm ?enum_uniq // => i; rewrite mem_enum.\nQed.",
    "Lemma bigD1 (I : finType) j (P : pred I) F :\n  P j -> \\big[op/x]_(i | P i) F i\n    = op (F j) (\\big[op/x]_(i | P i && (i != j)) F i).\nProof.\nrewrite (big_rem_AC _ _ (mem_index_enum j)) => ->.\nby rewrite rem_filter ?index_enum_uniq// big_filter_cond big_andbC.\nQed.",
    "Lemma bigD1_seq (I : eqType) (r : seq I) j F :\n    j \\in r -> uniq r ->\n  \\big[op/x]_(i <- r) F i = op (F j) (\\big[op/x]_(i <- r | i != j) F i).\nProof. by move=> /big_rem_AC-> /rem_filter->; rewrite big_filter. Qed.",
    "Lemma big_image_cond I (J : finType) (h : J -> I) (A : pred J) (P : pred I) F :\n  \\big[op/x]_(i <- [seq h j | j in A] | P i) F i\n     = \\big[op/x]_(j in A | P (h j)) F (h j).\nProof. by rewrite big_map big_enum_cond. Qed.",
    "Lemma big_image I (J : finType) (h : J -> I) (A : pred J) F :\n  \\big[op/x]_(i <- [seq h j | j in A]) F i = \\big[op/x]_(j in A) F (h j).\nProof. by rewrite big_map big_enum. Qed.",
    "Lemma cardD1x (I : finType) (A : pred I) j :\n  A j -> #|SimplPred A| = 1 + #|[pred i | A i & i != j]|.\nProof.\nmove=> Aj; rewrite (cardD1 j) [j \\in A]Aj; congr (_ + _).\nby apply: eq_card => i; rewrite inE /= andbC.\nQed.",
    "Lemma reindex_omap (I J : finType) (h : J -> I) h' (P : pred I) F :\n    (forall i, P i -> omap h (h' i) = some i) ->\n  \\big[op/x]_(i | P i) F i =\n    \\big[op/x]_(j | P (h j) && (h' (h j) == some j)) F (h j).\nProof.\nmove=> h'K; have [n lePn] := ubnP #|P|; elim: n => // n IHn in P h'K lePn *.\ncase: (pickP P) => [i Pi | P0]; last first.\n  by rewrite !big_pred0 // => j; rewrite P0.\nhave := h'K i Pi; case h'i_eq : (h' i) => [/= j|//] [hj_eq].\nrewrite (bigD1 i Pi) (bigD1 j) hj_eq ?Pi ?h'i_eq ?eqxx //=; congr (op : _ -> _).\nrewrite {}IHn => [|k /andP[]|]; [|by auto | by rewrite (cardD1x i) in lePn].\napply: eq_bigl => k; rewrite andbC -andbA (andbCA (P _)); case: eqP => //= hK.\ncongr (_ && ~~ _); apply/eqP/eqP => [|->//].\nby move=> /(congr1 h'); rewrite h'i_eq hK => -[].\nQed.",
    "Lemma reindex_onto (I J : finType) (h : J -> I) h' (P : pred I) F :\n    (forall i, P i -> h (h' i) = i) ->\n  \\big[op/x]_(i | P i) F i =\n    \\big[op/x]_(j | P (h j) && (h' (h j) == j)) F (h j).\nProof.\nby move=> h'K; rewrite (reindex_omap h (some \\o h'))//= => i Pi; rewrite h'K.\nQed.",
    "Lemma reindex (I J : finType) (h : J -> I) (P : pred I) F :\n    {on [pred i | P i], bijective h} ->\n  \\big[op/x]_(i | P i) F i = \\big[op/x]_(j | P (h j)) F (h j).\nProof.\ncase=> h' hK h'K; rewrite (reindex_onto h h' h'K).\nby apply: eq_bigl => j /[!inE]; case Pi: (P _); rewrite //= hK ?eqxx.\nQed.",
    "Lemma reindex_inj (I : finType) (h : I -> I) (P : pred I) F :\n  injective h -> \\big[op/x]_(i | P i) F i = \\big[op/x]_(j | P (h j)) F (h j).\nProof. by move=> injh; apply: reindex (onW_bij _ (injF_bij injh)). Qed.",
    "Lemma bigD1_ord n j (P : pred 'I_n) F :\n  P j -> \\big[op/x]_(i < n | P i) F i\n    = op (F j) (\\big[op/x]_(i < n.-1 | P (lift j i)) F (lift j i)).\nProof.\nmove=> Pj; rewrite (bigD1 j Pj) (reindex_omap (lift j) (unlift j))/=.\n  by under eq_bigl do rewrite liftK eq_sym eqxx neq_lift ?andbT.\nby move=> i; case: unliftP => [k ->|->]; rewrite ?eqxx ?andbF.\nQed.",
    "Lemma big_enum_val_cond (I : finType) (A : pred I) (P : pred I) F :\n  \\big[op/x]_(x in A | P x) F x =\n  \\big[op/x]_(i < #|A| | P (enum_val i)) F (enum_val i).\nProof.\nhave [A_eq0|/card_gt0P[x0 x0A]] := posnP #|A|.\n  rewrite !big_pred0 // => i; last by rewrite card0_eq.\n  by have: false by move: i => []; rewrite A_eq0.\nrewrite (reindex (enum_val : 'I_#|A| -> I)).\n  by apply: eq_big => [y|y Py]; rewrite ?enum_valP.\nby apply: subon_bij (enum_val_bij_in x0A) => y /andP[].\nQed.",
    "Lemma big_enum_rank_cond (I : finType) (A : pred I) z (zA : z \\in A) P F\n  (h := enum_rank_in zA) :\n  \\big[op/x]_(i < #|A| | P i) F i = \\big[op/x]_(s in A | P (h s)) F (h s).\nProof.\nrewrite big_enum_val_cond {}/h.\nby apply: eq_big => [i|i Pi]; rewrite ?enum_valK_in.\nQed.",
    "Lemma big_nat_rev m n P F :\n  \\big[op/x]_(m <= i < n | P i) F i\n     = \\big[op/x]_(m <= i < n | P (m + n - i.+1)) F (m + n - i.+1).\nProof.\ncase: (ltnP m n) => ltmn; last by rewrite !big_geq.\nrewrite -{3 4}(subnK (ltnW ltmn)) addnA.\ndo 2!rewrite (big_addn _ _ 0) big_mkord; rewrite (reindex_inj rev_ord_inj)/=.\nby apply: eq_big => [i | i _]; rewrite /= -addSn subnDr addnC addnBA.\nQed.",
    "Lemma big_rev_mkord m n P F :\n \\big[op/x]_(m <= k < n | P k) F k\n    = \\big[op/x]_(k < n - m | P (n - k.+1)) F (n - k.+1).\nProof.\nrewrite big_nat_rev (big_addn _ _ 0) big_mkord.\nby apply: eq_big => [i|i _]; rewrite -addSn addnC subnDr.\nQed.",
    "Lemma big_mkcond_idem I r (P : pred I) F :\n  \\big[op/x]_(i <- r | P i) F i = \\big[op/x]_(i <- r) (if P i then F i else x).\nProof.\nelim: r => [|i r]; rewrite ?(big_nil, big_cons)//.\nby case: ifPn => Pi ->//; rewrite -[in LHS]big_id_idem // opC.\nQed.",
    "Lemma big_mkcondr_idem I r (P Q : pred I) F :\n  \\big[op/x]_(i <- r | P i && Q i) F i =\n    \\big[op/x]_(i <- r | P i) (if Q i then F i else x).\nProof. by rewrite -big_filter_cond big_mkcond_idem big_filter. Qed.",
    "Lemma big_mkcondl_idem I r (P Q : pred I) F :\n  \\big[op/x]_(i <- r | P i && Q i) F i =\n    \\big[op/x]_(i <- r | Q i) (if P i then F i else x).\nProof. by rewrite big_andbC big_mkcondr_idem. Qed.",
    "Lemma big_rmcond_idem I (r : seq I) (P : pred I) F :\n  (forall i, ~~ P i -> F i = x) ->\n  \\big[op/x]_(i <- r | P i) F i = \\big[op/x]_(i <- r) F i.\nProof.\nmove=> F_eq1; rewrite big_mkcond_idem; apply: eq_bigr => i.\nby case: (P i) (F_eq1 i) => // ->.\nQed.",
    "Lemma big_rmcond_in_idem (I : eqType) (r : seq I) (P : pred I) F :\n  (forall i, i \\in r -> ~~ P i -> F i = x) ->\n  \\big[op/x]_(i <- r | P i) F i = \\big[op/x]_(i <- r) F i.\nProof.\nmove=> F_eq1; rewrite big_seq_cond [RHS]big_seq_cond !big_mkcondl_idem.\nby rewrite big_rmcond_idem => // i /F_eq1; case: ifP => // _ ->.\nQed.",
    "Lemma big_cat_idem I r1 r2 (P : pred I) F :\n  \\big[op/x]_(i <- r1 ++ r2 | P i) F i =\n    op (\\big[op/x]_(i <- r1 | P i) F i) (\\big[op/x]_(i <- r2 | P i) F i).\nProof.\nelim: r1 => [/=|i r1 IHr1]; first by rewrite big_nil opC big_id_idem.\nby rewrite /= big_cons IHr1 big_cons; case: (P i); rewrite // opA.\nQed.",
    "Lemma big_allpairs_dep_idem I1 (I2 : I1 -> Type) J (h : forall i1, I2 i1 -> J)\n    (r1 : seq I1) (r2 : forall i1, seq (I2 i1)) (F : J -> R) :\n  \\big[op/x]_(i <- [seq h i1 i2 | i1 <- r1, i2 <- r2 i1]) F i =\n    \\big[op/x]_(i1 <- r1) \\big[op/x]_(i2 <- r2 i1) F (h i1 i2).\nProof.\nelim: r1 => [|i1 r1 IHr1]; first by rewrite !big_nil.\nby rewrite big_cat_idem IHr1 big_cons big_map.\nQed.",
    "Lemma big_allpairs_idem I1 I2 (r1 : seq I1) (r2 : seq I2) F :\n  \\big[op/x]_(i <- [seq (i1, i2) | i1 <- r1, i2 <- r2]) F i =\n    \\big[op/x]_(i1 <- r1) \\big[op/x]_(i2 <- r2) F (i1, i2).\nProof. exact: big_allpairs_dep_idem. Qed.",
    "Lemma big_cat_nat_idem n m p (P : pred nat) F : m <= n -> n <= p ->\n  \\big[op/x]_(m <= i < p | P i) F i =\n    op (\\big[op/x]_(m <= i < n | P i) F i) (\\big[op/x]_(n <= i < p | P i) F i).\nProof.\nmove=> le_mn le_np; rewrite -big_cat_idem -{2}(subnKC le_mn) -iotaD subnDA.\nby rewrite subnKC // leq_sub.\nQed.",
    "Lemma big_split_idem I r (P : pred I) F1 F2 :\n  \\big[op/x]_(i <- r | P i) op (F1 i) (F2 i) =\n    op (\\big[op/x]_(i <- r | P i) F1 i) (\\big[op/x]_(i <- r | P i) F2 i).\nProof.\nby elim/big_rec3: _ => [|i x' y _ _ ->]; rewrite ?opxx// opCA -!opA opCA.\nQed.",
    "Lemma big_id_idem_AC I (r : seq I) P F :\n  \\big[op/x]_(i <- r | P i) op (F i) x = \\big[op/x]_(i <- r | P i) F i.\nProof. by rewrite big_split_idem big_const_idem ?big_id_idem. Qed.",
    "Lemma bigID_idem I r (a P : pred I) F :\n  \\big[op/x]_(i <- r | P i) F i =\n    op (\\big[op/x]_(i <- r | P i && a i) F i)\n       (\\big[op/x]_(i <- r | P i && ~~ a i) F i).\nProof.\nrewrite -big_id_idem_AC big_mkcond_idem !(big_mkcond_idem _ _ F) -big_split_idem.\nby apply: eq_bigr => i; case: ifPn => //=; case: ifPn; rewrite // opC.\nQed.",
    "Lemma bigU_idem (I : finType) (A B : pred I) F :\n    [disjoint A & B] ->\n  \\big[op/x]_(i in [predU A & B]) F i =\n    op (\\big[op/x]_(i in A) F i) (\\big[op/x]_(i in B) F i).\nProof.\nmove=> dAB; rewrite (bigID_idem (mem A)).\ncongr (op : _ -> _); apply: eq_bigl => i; first by rewrite orbK.\nby have:= pred0P dAB i; rewrite andbC /= !inE; case: (i \\in A).\nQed.",
    "Lemma partition_big_idem I (s : seq I)\n      (J : finType) (P : pred I) (p : I -> J) (Q : pred J) F :\n  (forall i, P i -> Q (p i)) ->\n  \\big[op/x]_(i <- s | P i) F i =\n  \\big[op/x]_(j : J | Q j) \\big[op/x]_(i <- s | (P i) && (p i == j)) F i.\nProof.\nmove=> Qp; transitivity (\\big[op/x]_(i <- s | P i && Q (p i)) F i).\n  by apply: eq_bigl => i; case Pi: (P i); rewrite // Qp.\nhave [n leQn] := ubnP #|Q|; elim: n => // n IHn in Q {Qp} leQn *.\ncase: (pickP Q) => [j Qj | Q0]; last first.\n  by rewrite !big_pred0 // => i; rewrite Q0 andbF.\nrewrite (bigD1 j) // -IHn; last by rewrite ltnS (cardD1x j Qj) in leQn.\nrewrite (bigID_idem (fun i => p i == j)).\ncongr (op : _ -> _); apply: eq_bigl => i; last by rewrite andbA.\nby case: eqP => [->|_]; rewrite !(Qj, andbT, andbF).\nQed.",
    "Lemma sig_big_dep_idem (I : finType) (J : I -> finType)\n    (P : pred I) (Q : forall {i}, pred (J i)) (F : forall {i}, J i -> R) :\n  \\big[op/x]_(i | P i) \\big[op/x]_(j : J i | Q j) F j =\n  \\big[op/x]_(p : {i : I & J i} | P (tag p) && Q (tagged p)) F (tagged p).\nProof.\npose s := [seq Tagged J j | i <- index_enum I, j <- index_enum (J i)].\nrewrite [LHS]big_mkcond_idem big_mkcondl_idem.\nrewrite [RHS]big_mkcond_idem -[RHS](@perm_big _ s).\n  rewrite big_allpairs_dep_idem/=; apply: eq_bigr => i _.\n  by rewrite -big_mkcond_idem/=; case: P; rewrite // big1_idem.\nrewrite uniq_perm ?index_enum_uniq//.\n  by rewrite allpairs_uniq_dep// => [|i|[i j] []]; rewrite ?index_enum_uniq.\nby move=> [i j]; rewrite ?mem_index_enum; apply/allpairsPdep; exists i, j.\nQed.",
    "Lemma pair_big_dep_idem (I J : finType) (P : pred I) (Q : I -> pred J) F :\n  \\big[op/x]_(i | P i) \\big[op/x]_(j | Q i j) F i j =\n    \\big[op/x]_(p | P p.1 && Q p.1 p.2) F p.1 p.2.\nProof.\nrewrite sig_big_dep_idem; apply: (reindex (fun x => Tagged (fun=> J) x.2)).\nby exists (fun x => (projT1 x, projT2 x)) => -[].\nQed.",
    "Lemma pair_big_idem (I J : finType) (P : pred I) (Q : pred J) F :\n  \\big[op/x]_(i | P i) \\big[op/x]_(j | Q j) F i j =\n    \\big[op/x]_(p | P p.1 && Q p.2) F p.1 p.2.\nProof. exact: pair_big_dep_idem. Qed.",
    "Lemma pair_bigA_idem (I J : finType) (F : I -> J -> R) :\n  \\big[op/x]_i \\big[op/x]_j F i j = \\big[op/x]_p F p.1 p.2.\nProof. exact: pair_big_dep_idem. Qed.",
    "Lemma exchange_big_dep_idem I J rI rJ (P : pred I) (Q : I -> pred J)\n                       (xQ : pred J) F :\n    (forall i j, P i -> Q i j -> xQ j) ->\n  \\big[op/x]_(i <- rI | P i) \\big[op/x]_(j <- rJ | Q i j) F i j =\n    \\big[op/x]_(j <- rJ | xQ j) \\big[op/x]_(i <- rI | P i && Q i j) F i j.\nProof.\nmove=> PQxQ; pose p u := (u.2, u.1).\nunder [LHS]eq_bigr do rewrite big_tnth; rewrite [LHS]big_tnth.\nunder [RHS]eq_bigr do rewrite big_tnth; rewrite [RHS]big_tnth.\nrewrite !pair_big_dep_idem (reindex_onto (p _ _) (p _ _)) => [|[]] //=.\napply: eq_big => [] [j i] //=; symmetry; rewrite eqxx andbT andb_idl //.\nby case/andP; apply: PQxQ.\nQed.",
    "Lemma exchange_big_idem I J rI rJ (P : pred I) (Q : pred J) F :\n  \\big[op/x]_(i <- rI | P i) \\big[op/x]_(j <- rJ | Q j) F i j =\n    \\big[op/x]_(j <- rJ | Q j) \\big[op/x]_(i <- rI | P i) F i j.\nProof.\nrewrite (exchange_big_dep_idem Q) //.\nby under eq_bigr => i Qi do under eq_bigl do rewrite Qi andbT.\nQed.",
    "Lemma exchange_big_dep_nat_idem m1 n1 m2 n2 (P : pred nat) (Q : rel nat)\n                           (xQ : pred nat) F :\n    (forall i j, m1 <= i < n1 -> m2 <= j < n2 -> P i -> Q i j -> xQ j) ->\n  \\big[op/x]_(m1 <= i < n1 | P i) \\big[op/x]_(m2 <= j < n2 | Q i j) F i j =\n    \\big[op/x]_(m2 <= j < n2 | xQ j)\n       \\big[op/x]_(m1 <= i < n1 | P i && Q i j) F i j.\nProof.\nmove=> PQxQ; under eq_bigr do rewrite big_seq_cond.\nrewrite big_seq_cond /= (exchange_big_dep_idem xQ) => [|i j]; last first.\n  by rewrite !mem_index_iota => /andP[mn_i Pi] /andP[mn_j /PQxQ->].\nrewrite 2!(big_seq_cond _ _ _ xQ); apply: eq_bigr => j /andP[-> _] /=.\nby rewrite [rhs in _ = rhs]big_seq_cond; apply: eq_bigl => i; rewrite -andbA.\nQed.",
    "Lemma exchange_big_nat_idem m1 n1 m2 n2 (P Q : pred nat) F :\n  \\big[op/x]_(m1 <= i < n1 | P i) \\big[op/x]_(m2 <= j < n2 | Q j) F i j =\n    \\big[op/x]_(m2 <= j < n2 | Q j) \\big[op/x]_(m1 <= i < n1 | P i) F i j.\nProof.\nrewrite (exchange_big_dep_nat_idem Q) //.\nby under eq_bigr => i Qi do under eq_bigl do rewrite Qi andbT.\nQed.",
    "Lemma foldlE x r : foldl *%M x r = \\big[*%M/1]_(y <- x :: r) y.\nProof.\nby rewrite -foldrE; elim: r => [|y r IHr]/= in x *; rewrite ?mulm1 ?mulmA ?IHr.\nQed.",
    "Lemma foldl_idx r : foldl *%M 1 r = \\big[*%M/1]_(x <- r) x.\nProof. by rewrite foldlE big_cons mul1m. Qed.",
    "Lemma eq_big_idx_seq idx' I r (P : pred I) F :\n     right_id idx' *%M -> has P r ->\n   \\big[*%M/idx']_(i <- r | P i) F i = \\big[*%M/1]_(i <- r | P i) F i.\nProof.\nmove=> op_idx'; rewrite -!(big_filter _ _ r) has_count -size_filter.\ncase/lastP: (filter P r) => {r}// r i _.\nby rewrite -cats1 !(big_cat_nested, big_cons, big_nil) op_idx' mulm1.\nQed.",
    "Lemma eq_big_idx idx' (I : finType) i0 (P : pred I) F :\n     P i0 -> right_id idx' *%M ->\n  \\big[*%M/idx']_(i | P i) F i = \\big[*%M/1]_(i | P i) F i.\nProof.\nby move=> Pi0 op_idx'; apply: eq_big_idx_seq => //; apply/hasP; exists i0.\nQed.",
    "Lemma big_change_idx I x r (P : pred I) F :\n  \\big[*%M/x]_(j <- r | P j) F j = (\\big[*%M/1]_(j <- r | P j) F j) * x.\nProof.\nelim: r => [|i r]; rewrite ?(big_nil, big_cons, mul1m)// => ->.\nby case: ifP => // Pi; rewrite mulmA.\nQed.",
    "Lemma big1_eq I r (P : pred I) : \\big[*%M/1]_(i <- r | P i) 1 = 1.\nProof. by rewrite big1_idem //= mul1m. Qed.",
    "Lemma big1 I r (P : pred I) F :\n  (forall i, P i -> F i = 1) -> \\big[*%M/1]_(i <- r | P i) F i = 1.\nProof. by move/(eq_bigr _)->; apply: big1_eq. Qed.",
    "Lemma big1_seq (I : eqType) r (P : pred I) F :\n    (forall i, P i && (i \\in r) -> F i = 1) ->\n  \\big[*%M/1]_(i <- r | P i) F i = 1.\nProof. by move=> eqF1; rewrite big_seq_cond big_andbC big1. Qed.",
    "Lemma big_seq1 I (i : I) F : \\big[*%M/1]_(j <- [:: i]) F j = F i.\nProof. by rewrite big_seq1_id mulm1. Qed.",
    "Lemma big_rcons I i r (P : pred I) F :\n  \\big[*%M/1]_(j <- rcons r i | P j) F j =\n  (\\big[*%M/1]_(j <- r | P j) F j) * (if P i then F i else idx).\nProof. by rewrite big_rcons_op big_change_idx mulm1. Qed.",
    "Lemma big_mkcond I r (P : pred I) F :\n  \\big[*%M/1]_(i <- r | P i) F i =\n     \\big[*%M/1]_(i <- r) (if P i then F i else 1).\nProof. by rewrite unlock; elim: r => //= i r ->; case P; rewrite ?mul1m. Qed.",
    "Lemma big_mkcondr I r (P Q : pred I) F :\n  \\big[*%M/1]_(i <- r | P i && Q i) F i =\n     \\big[*%M/1]_(i <- r | P i) (if Q i then F i else 1).\nProof. by rewrite -big_filter_cond big_mkcond big_filter. Qed.",
    "Lemma big_mkcondl I r (P Q : pred I) F :\n  \\big[*%M/1]_(i <- r | P i && Q i) F i =\n     \\big[*%M/1]_(i <- r | Q i) (if P i then F i else 1).\nProof. by rewrite big_andbC big_mkcondr. Qed.",
    "Lemma big_rmcond I (r : seq I) (P : pred I) F :\n  (forall i, ~~ P i -> F i = 1) ->\n  \\big[*%M/1]_(i <- r | P i) F i = \\big[*%M/1]_(i <- r) F i.\nProof.\nmove=> F_eq1; rewrite big_mkcond; apply: eq_bigr => i.\nby case: (P i) (F_eq1 i) => // ->.\nQed.",
    "Lemma big_rmcond_in (I : eqType) (r : seq I) (P : pred I) F :\n  (forall i, i \\in r -> ~~ P i -> F i = 1) ->\n  \\big[*%M/1]_(i <- r | P i) F i = \\big[*%M/1]_(i <- r) F i.\nProof.\nmove=> F_eq1; rewrite big_seq_cond [RHS]big_seq_cond !big_mkcondl big_rmcond//.\nby move=> i /F_eq1; case: ifP => // _ ->.\nQed.",
    "Lemma big_cat I r1 r2 (P : pred I) F :\n  \\big[*%M/1]_(i <- r1 ++ r2 | P i) F i =\n     \\big[*%M/1]_(i <- r1 | P i) F i * \\big[*%M/1]_(i <- r2 | P i) F i.\nProof.\nrewrite !(big_mkcond _ P) unlock.\nby elim: r1 => /= [|i r1 ->]; rewrite (mul1m, mulmA).\nQed.",
    "Lemma big_allpairs_dep I1 (I2 : I1 -> Type) J (h : forall i1, I2 i1 -> J)\n    (r1 : seq I1) (r2 : forall i1, seq (I2 i1)) (F : J -> R) :\n  \\big[*%M/1]_(i <- [seq h i1 i2 | i1 <- r1, i2 <- r2 i1]) F i =\n    \\big[*%M/1]_(i1 <- r1) \\big[*%M/1]_(i2 <- r2 i1) F (h i1 i2).\nProof.\nelim: r1 => [|i1 r1 IHr1]; first by rewrite !big_nil.\nby rewrite big_cat IHr1 big_cons big_map.\nQed.",
    "Lemma big_allpairs I1 I2 (r1 : seq I1) (r2 : seq I2) F :\n  \\big[*%M/1]_(i <- [seq (i1, i2) | i1 <- r1, i2 <- r2]) F i =\n    \\big[*%M/1]_(i1 <- r1) \\big[op/idx]_(i2 <- r2) F (i1, i2).\nProof. exact: big_allpairs_dep. Qed.",
    "Lemma rev_big_rev I (r : seq I) P F :\n  \\big[*%M/1]_(i <- rev r | P i) F i =\n  \\big[(fun x y => y * x)/1]_(i <- r | P i) F i.\nProof.\nelim: r => [|i r IHr]; rewrite ?big_nil// big_cons rev_cons big_rcons IHr.\nby case: (P i); rewrite ?mulm1.\nQed.",
    "Lemma big_only1 (I : finType) (i : I) (P : pred I) (F : I -> R) : P i ->\n    (forall j, j != i -> P j -> F j = idx) ->\n  \\big[op/idx]_(j | P j) F j = F i.\nProof.\nmove=> Pi Fisx; have := index_enum_uniq I.\nhave : i \\in index_enum I by rewrite mem_index_enum.\nelim: index_enum => //= j r IHr /[!inE]; case: eqVneq => [<-|nij]//=.\n  move=> _ /andP[iNr runiq]; rewrite big_cons/= Pi big1_seq ?Monoid.mulm1//.\n  by move=> {}j /andP[/Fisx + jr] => ->//; apply: contraNneq iNr => <-.\nmove=> ir /andP[jNr runiq]; rewrite big_cons IHr//.\nby case: ifPn => // /Fisx->; rewrite 1?eq_sym// Monoid.mul1m.\nQed.",
    "Lemma big_pred1_eq (I : finType) (i : I) F : \\big[*%M/1]_(j | j == i) F j = F i.\nProof. by rewrite (@big_only1 _ i)// => j /negPf->. Qed.",
    "Lemma big_pred1 (I : finType) i (P : pred I) F :\n  P =1 pred1 i -> \\big[*%M/1]_(j | P j) F j = F i.\nProof. by move/(eq_bigl _ _)->; apply: big_pred1_eq. Qed.",
    "Lemma big_ord1 F : \\big[op/idx]_(i < 1) F i = F ord0.\nProof. by rewrite big_ord_recl big_ord0 Monoid.mulm1. Qed.",
    "Lemma big_ord1_cond P F :\n  \\big[op/idx]_(i < 1 | P i) F i = if P ord0 then F ord0 else idx.\nProof. by rewrite big_mkcond big_ord1. Qed.",
    "Lemma big_ord1_eq (F : nat -> R) i n :\n  \\big[op/idx]_(j < n | j == i :> nat) F j = if i < n then F i else idx.\nProof.\ncase: ltnP => [i_lt|i_ge]; first by rewrite (big_pred1_eq (Ordinal _)).\nby rewrite big_pred0// => j; apply: contra_leqF i_ge => /eqP <-.\nQed.",
    "Lemma big_ord1_cond_eq (F : nat -> R) (P : pred nat) i n :\n  \\big[op/idx]_(j < n | P j && (j == i :> nat)) F j =\n    if (i < n) && P i then F i else idx.\nProof.\nby rewrite big_mkcondl if_and (big_ord1_eq (fun j => if P j then F j else _)).\nQed.",
    "Lemma big_cat_nat n m p (P : pred nat) F : m <= n -> n <= p ->\n  \\big[*%M/1]_(m <= i < p | P i) F i =\n   (\\big[*%M/1]_(m <= i < n | P i) F i) * (\\big[*%M/1]_(n <= i < p | P i) F i).\nProof.\nmove=> le_mn le_np; rewrite -big_cat -{2}(subnKC le_mn) -iotaD subnDA.\nby rewrite subnKC // leq_sub.\nQed.",
    "Lemma big_nat_widenl (m1 m2 n : nat) (P : pred nat) F :\n  m2 <= m1 ->\n  \\big[op/idx]_(m1 <= i < n | P i) F i =\n  \\big[op/idx]_(m2 <= i < n | P i && (m1 <= i)) F i.\nProof.\nmove=> le_m21; have [le_nm1|lt_m1n] := leqP n m1.\n  rewrite big_geq// big_nat_cond big1//.\n  by move=> i /and3P[/andP[_ /leq_trans/(_ le_nm1)/ltn_geF->]].\nrewrite big_mkcond big_mkcondl (big_cat_nat _ _ le_m21) 1?ltnW//.\nrewrite [X in op X]big_nat_cond [X in op X]big_pred0; last first.\n  by move=> k; case: ltnP; rewrite andbF.\nby rewrite Monoid.mul1m; apply: congr_big_nat => // k /andP[].\nQed.",
    "Lemma big_geq_mkord (m n : nat) (P : pred nat) F :\n  \\big[op/idx]_(m <= i < n | P i) F i =\n  \\big[op/idx]_(i < n | P i && (m <= i)) F i.\nProof. by rewrite (@big_nat_widenl _ 0)// big_mkord. Qed.",
    "Lemma big_nat1_eq (F : nat -> R) i m n :\n  \\big[op/idx]_(m <= j < n | j == i) F j = if m <= i < n then F i else idx.\nProof. by rewrite big_geq_mkord big_andbC big_ord1_cond_eq andbC. Qed.",
    "Lemma big_nat1_cond_eq (F : nat -> R) (P : pred nat) i m n :\n  \\big[op/idx]_(m <= j < n | P j && (j == i)) F j =\n    if (m <= i < n) && P i then F i else idx.\nProof. by rewrite big_mkcondl big_nat1_eq -if_and. Qed.",
    "Lemma big_nat1 n F : \\big[*%M/1]_(n <= i < n.+1) F i = F n.\nProof. by rewrite big_ltn // big_geq // mulm1. Qed.",
    "Lemma big_nat_recr n m F : m <= n ->\n  \\big[*%M/1]_(m <= i < n.+1) F i = (\\big[*%M/1]_(m <= i < n) F i) * F n.\nProof. by move=> lemn; rewrite (@big_cat_nat n) ?leqnSn // big_nat1. Qed.",
    "Lemma big_nat_mul n k F :\n  \\big[*%M/1]_(0 <= i < n * k) F i =\n  \\big[*%M/1]_(0 <= i < n) \\big[*%M/1]_(i * k <= j < i.+1 * k) F j.\nProof.\nelim: n => [|n ih]; first by rewrite mul0n 2!big_nil.\nrewrite [in RHS]big_nat_recr//= -ih mulSn addnC [in LHS]/index_iota subn0 iotaD.\nrewrite big_cat /= [in X in _ = X * _]/index_iota subn0; congr (_ * _).\nby rewrite add0n /index_iota (addnC _ k) addnK.\nQed.",
    "Lemma big_ord_recr n F :\n  \\big[*%M/1]_(i < n.+1) F i =\n     (\\big[*%M/1]_(i < n) F (widen_ord (leqnSn n) i)) * F ord_max.\nProof.\ntransitivity (\\big[*%M/1]_(0 <= i < n.+1) F (inord i)).\n  by rewrite big_mkord; apply: eq_bigr=> i _; rewrite inord_val.\nrewrite big_nat_recr // big_mkord; congr (_ * F _); last first.\n  by apply: val_inj; rewrite /= inordK.\nby apply: eq_bigr => [] i _; congr F; apply: ord_inj; rewrite inordK //= leqW.\nQed.",
    "Lemma big_sumType (I1 I2 : finType) (P : pred (I1 + I2)) F :\n  \\big[*%M/1]_(i | P i) F i =\n        (\\big[*%M/1]_(i | P (inl _ i)) F (inl _ i))\n      * (\\big[*%M/1]_(i | P (inr _ i)) F (inr _ i)).\nProof.\nby rewrite ![index_enum _]unlock [@Finite.enum in LHS]unlock/= big_cat !big_map.\nQed.",
    "Lemma big_split_ord m n (P : pred 'I_(m + n)) F :\n  \\big[*%M/1]_(i | P i) F i =\n        (\\big[*%M/1]_(i | P (lshift n i)) F (lshift n i))\n      * (\\big[*%M/1]_(i | P (rshift m i)) F (rshift m i)).\nProof.\nrewrite -(big_map _ _ (lshift n) _ P F) -(big_map _ _ (@rshift m _) _ P F).\nrewrite -big_cat; congr bigop; apply: (inj_map val_inj).\nrewrite map_cat -!map_comp (map_comp (addn m)) /=.\nby rewrite ![index_enum _]unlock unlock !val_ord_enum -iotaDl addn0 iotaD.\nQed.",
    "Lemma big_flatten I rr (P : pred I) F :\n  \\big[*%M/1]_(i <- flatten rr | P i) F i\n    = \\big[*%M/1]_(r <- rr) \\big[*%M/1]_(i <- r | P i) F i.\nProof.\nby elim: rr => [|r rr IHrr]; rewrite ?big_nil //= big_cat big_cons -IHrr.\nQed.",
    "Lemma big_pmap J I (h : J -> option I) (r : seq J) F :\n  \\big[op/idx]_(i <- pmap h r) F i = \\big[op/idx]_(j <- r) oapp F idx (h j).\nProof.\nelim: r => [| r0 r IHr]/=; first by rewrite !big_nil.\nrewrite /= big_cons; case: (h r0) => [i|] /=; last by rewrite mul1m.\nby rewrite big_cons IHr.\nQed.",
    "Lemma telescope_big (f : nat -> nat -> R) (n m : nat) :\n  (forall k, n < k < m -> op (f n k) (f k k.+1) = f n k.+1) ->\n  \\big[op/idx]_(n <= i < m) f i i.+1 = if n < m then f n m else idx.\nProof.\nelim: m => [//| m IHm]; first by rewrite ltn0 big_geq.\nmove=> tm; rewrite ltnS; case: ltnP=> // mn; first by rewrite big_geq.\nrewrite big_nat_recr// IHm//; last first.\n  by move=> k /andP[nk /ltnW nm]; rewrite tm// nk.\nby case: ltngtP mn=> //= [nm|<-]; rewrite ?mul1m// tm// nm leqnn.\nQed.",
    "Lemma big_rem (I : eqType) r x (P : pred I) F :\n    x \\in r ->\n  \\big[*%M/1]_(y <- r | P y) F y\n    = (if P x then F x else 1) * \\big[*%M/1]_(y <- rem x r | P y) F y.\nProof.\nby move/perm_to_rem/(perm_big _)->; rewrite !(big_mkcond _ _ P) big_cons.\nQed.",
    "Lemma big_rev I (r : seq I) P F :\n  \\big[*%M/1]_(i <- rev r | P i) F i = \\big[*%M/1]_(i <- r | P i) F i.\nProof.\nby rewrite rev_big_rev; apply: (eq_big_op (fun=> True)) => // *; apply: mulmC.\nQed.",
    "Lemma eq_big_idem (I : eqType) (r1 r2 : seq I) (P : pred I) F :\n    idempotent_op *%M -> r1 =i r2 ->\n  \\big[*%M/1]_(i <- r1 | P i) F i = \\big[*%M/1]_(i <- r2 | P i) F i.\nProof.\nmove=> idM eq_r; rewrite -big_undup // -(big_undup r2) //; apply/perm_big.\nby rewrite uniq_perm ?undup_uniq // => i; rewrite !mem_undup eq_r.\nQed.",
    "Lemma big_undup_iterop_count (I : eqType) (r : seq I) (P : pred I) F :\n  \\big[*%M/1]_(i <- undup r | P i) iterop (count_mem i r) *%M (F i) 1\n    = \\big[*%M/1]_(i <- r | P i) F i.\nProof.\nrewrite -[RHS](perm_big _ F (perm_count_undup _)) big_flatten big_map.\nby rewrite [LHS]big_mkcond; apply: eq_bigr=> i _; rewrite big_nseq_cond iteropE.\nQed.",
    "Lemma big_split I r (P : pred I) F1 F2 :\n  \\big[*%M/1]_(i <- r | P i) (F1 i * F2 i) =\n    \\big[*%M/1]_(i <- r | P i) F1 i * \\big[*%M/1]_(i <- r | P i) F2 i.\nProof. exact/big_split_idem/mul1m. Qed.",
    "Lemma bigID I r (a P : pred I) F :\n  \\big[*%M/1]_(i <- r | P i) F i =\n    \\big[*%M/1]_(i <- r | P i && a i) F i *\n    \\big[*%M/1]_(i <- r | P i && ~~ a i) F i.\nProof. exact/bigID_idem/mul1m. Qed.",
    "Lemma big_if I r (P Q : pred I) F G :\n  \\big[*%M/1]_(i <- r | P i) (if Q i then F i else G i) =\n    \\big[*%M/1]_(i <- r | P i && Q i) F i *\n    \\big[*%M/1]_(i <- r | P i && ~~ Q i) G i.\nProof.\nrewrite (bigID Q); congr (_ * _); apply: eq_bigr => i /andP[_].\n  by move=> ->.\nby move=> /negPf ->.\nQed.",
    "Lemma bigU (I : finType) (A B : pred I) F :\n    [disjoint A & B] ->\n  \\big[*%M/1]_(i in [predU A & B]) F i =\n    (\\big[*%M/1]_(i in A) F i) * (\\big[*%M/1]_(i in B) F i).\nProof. exact/bigU_idem/mul1m. Qed.",
    "Lemma partition_big I (s : seq I)\n      (J : finType) (P : pred I) (p : I -> J) (Q : pred J) F :\n  (forall i, P i -> Q (p i)) ->\n  \\big[*%M/1]_(i <- s | P i) F i =\n  \\big[*%M/1]_(j : J | Q j) \\big[*%M/1]_(i <- s | (P i) && (p i == j)) F i.\nProof.\nmove=> Qp; transitivity (\\big[*%M/1]_(i <- s | P i && Q (p i)) F i).\n  by apply: eq_bigl => i; case Pi: (P i); rewrite // Qp.\nhave [n leQn] := ubnP #|Q|; elim: n => // n IHn in Q {Qp} leQn *.\ncase: (pickP Q) => [j Qj | Q0]; last first.\n  by rewrite !big_pred0 // => i; rewrite Q0 andbF.\nrewrite (bigD1 j) // -IHn; last by rewrite ltnS (cardD1x Qj) in leQn.\nrewrite (bigID (fun i => p i == j)); congr (_ * _); apply: eq_bigl => i.\n  by case: eqP => [-> | _]; rewrite !(Qj, simpm).\nby rewrite andbA.\nQed.",
    "Lemma big_enum_val (I : finType) (A : pred I) F :\n  \\big[op/idx]_(x in A) F x = \\big[op/idx]_(i < #|A|) F (enum_val i).\nProof. by rewrite -(big_enum_val_cond predT) big_mkcondr. Qed.",
    "Lemma big_enum_rank (I : finType) (A : pred I) x (xA : x \\in A) F\n  (h := enum_rank_in xA) :\n  \\big[op/idx]_(i < #|A|) F i = \\big[op/idx]_(s in A) F (h s).\nProof. by rewrite (big_enum_rank_cond xA) big_mkcondr. Qed.",
    "Lemma sig_big_dep (I : finType) (J : I -> finType)\n    (P : pred I) (Q : forall {i}, pred (J i)) (F : forall {i}, J i -> R) :\n  \\big[op/idx]_(i | P i) \\big[op/idx]_(j : J i | Q j) F j =\n  \\big[op/idx]_(p : {i : I & J i} | P (tag p) && Q (tagged p)) F (tagged p).\nProof. exact/sig_big_dep_idem/mul1m. Qed.",
    "Lemma pair_big_dep (I J : finType) (P : pred I) (Q : I -> pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[*%M/1]_(j | Q i j) F i j =\n    \\big[*%M/1]_(p | P p.1 && Q p.1 p.2) F p.1 p.2.\nProof. exact/pair_big_dep_idem/mul1m. Qed.",
    "Lemma pair_big (I J : finType) (P : pred I) (Q : pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[*%M/1]_(j | Q j) F i j =\n    \\big[*%M/1]_(p | P p.1 && Q p.2) F p.1 p.2.\nProof. exact/pair_big_idem/mul1m. Qed.",
    "Lemma pair_bigA (I J : finType) (F : I -> J -> R) :\n  \\big[*%M/1]_i \\big[*%M/1]_j F i j = \\big[*%M/1]_p F p.1 p.2.\nProof. exact/pair_bigA_idem/mul1m. Qed.",
    "Lemma exchange_big_dep I J rI rJ (P : pred I) (Q : I -> pred J)\n                       (xQ : pred J) F :\n    (forall i j, P i -> Q i j -> xQ j) ->\n  \\big[*%M/1]_(i <- rI | P i) \\big[*%M/1]_(j <- rJ | Q i j) F i j =\n    \\big[*%M/1]_(j <- rJ | xQ j) \\big[*%M/1]_(i <- rI | P i && Q i j) F i j.\nProof. exact/exchange_big_dep_idem/mul1m. Qed.",
    "Lemma exchange_big I J rI rJ (P : pred I) (Q : pred J) F :\n  \\big[*%M/1]_(i <- rI | P i) \\big[*%M/1]_(j <- rJ | Q j) F i j =\n    \\big[*%M/1]_(j <- rJ | Q j) \\big[*%M/1]_(i <- rI | P i) F i j.\nProof. exact/exchange_big_idem/mul1m. Qed.",
    "Lemma exchange_big_dep_nat m1 n1 m2 n2 (P : pred nat) (Q : rel nat)\n                           (xQ : pred nat) F :\n    (forall i j, m1 <= i < n1 -> m2 <= j < n2 -> P i -> Q i j -> xQ j) ->\n  \\big[*%M/1]_(m1 <= i < n1 | P i) \\big[*%M/1]_(m2 <= j < n2 | Q i j) F i j =\n    \\big[*%M/1]_(m2 <= j < n2 | xQ j)\n       \\big[*%M/1]_(m1 <= i < n1 | P i && Q i j) F i j.\nProof. exact/exchange_big_dep_nat_idem/mul1m. Qed.",
    "Lemma exchange_big_nat m1 n1 m2 n2 (P Q : pred nat) F :\n  \\big[*%M/1]_(m1 <= i < n1 | P i) \\big[*%M/1]_(m2 <= j < n2 | Q j) F i j =\n    \\big[*%M/1]_(m2 <= j < n2 | Q j) \\big[*%M/1]_(m1 <= i < n1 | P i) F i j.\nProof. exact/exchange_big_nat_idem/mul1m. Qed.",
    "Lemma sub_le_big I [s] (P P' : {pred I}) (F : I -> R) :\n    (forall i, P i -> P' i) ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s | P' i) F i).\nProof.\nmove=> PP'; rewrite [X in le _ X](big_AC_mk_monoid opA opC) (bigID P P') /=.\nunder [in X in le _ X]eq_bigl do rewrite (andb_idl (PP' _)).\nrewrite [X in le X _](big_AC_mk_monoid opA opC).\ncase: (bigop _ _ _) (bigop _ _ _) => [y|] [z|]//=.\n  by rewrite -opA [_ y x]opC opA op_incr.\nby rewrite opC op_incr.\nQed.",
    "Lemma sub_le_big_seq (I : eqType) s s' P (F : I -> R) :\n    (forall i, count_mem i s <= count_mem i s')%N ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P i) F i).\nProof.\nrewrite (big_AC_mk_monoid opA opC) => /count_subseqP[_ /subseqP[m sm ->]].\nmove/(perm_big _)->; rewrite big_mask big_tnth.\nby rewrite -!(big_AC_mk_monoid opA opC) sub_le_big // => j /andP[].\nQed.",
    "Lemma sub_le_big_seq_cond (I : eqType) s s' P P' (F : I -> R) :\n    (forall i, count_mem i (filter P s) <= count_mem i (filter P' s'))%N ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P' i) F i).\nProof. by  move=> /(sub_le_big_seq xpredT F); rewrite !big_filter. Qed.",
    "Lemma uniq_sub_le_big (I : eqType) s s' P (F : I -> R) : uniq s -> uniq s' ->\n    {subset s <= s'} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P i) F i).\nProof.\nmove=> us us' ss'; rewrite sub_le_big_seq => // i; rewrite !count_uniq_mem//.\nby have /implyP := ss' i; case: (_ \\in s) (_ \\in s') => [] [].\nQed.",
    "Lemma uniq_sub_le_big_cond (I : eqType) s s' P P' (F : I -> R) :\n    uniq (filter P s) -> uniq (filter P' s') ->\n    {subset [seq i <- s | P i] <= [seq i <- s' | P' i]} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P' i) F i).\nProof. by move=> u v /(uniq_sub_le_big xpredT F u v); rewrite !big_filter. Qed.",
    "Lemma idem_sub_le_big (I : eqType) s s' P (F : I -> R) :\n    {subset s <= s'} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P i) F i).\nProof.\nmove=> ss'; rewrite -big_undup// -[X in le _ X]big_undup//.\nby rewrite uniq_sub_le_big ?undup_uniq// => i; rewrite !mem_undup; apply: ss'.\nQed.",
    "Lemma idem_sub_le_big_cond (I : eqType) s s' P P' (F : I -> R) :\n  {subset [seq i <- s | P i] <= [seq i <- s' | P' i]} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s' | P' i) F i).\nProof. by  move=> /(idem_sub_le_big xpredT F); rewrite !big_filter. Qed.",
    "Lemma sub_in_le_big [I : eqType] (s : seq I) (P P' : {pred I}) (F : I -> R) :\n    {in s, forall i, P i -> P' i} ->\n  le (\\big[op/x]_(i <- s | P i) F i) (\\big[op/x]_(i <- s | P' i) F i).\nProof.\nmove=> PP'; apply: sub_le_big_seq_cond => i; rewrite leq_count_subseq//.\nrewrite subseq_filter filter_subseq andbT; apply/allP => j.\nby rewrite !mem_filter => /andP[/PP'/[apply]->].\nQed.",
    "Lemma le_big_ord n m [P : {pred nat}] [F : nat -> R] : (n <= m)%N ->\n  le (\\big[op/x]_(i < n | P i) F i) (\\big[op/x]_(i < m | P i) F i).\nProof.\nby move=> nm; rewrite (big_ord_widen_cond m)// sub_le_big => //= ? /andP[].\nQed.",
    "Lemma subset_le_big [I : finType] [A A' P : {pred I}] (F : I -> R) :\n    A \\subset A' ->\n  le (\\big[op/x]_(i in A | P i) F i) (\\big[op/x]_(i in A' | P i) F i).\nProof.\nmove=> AA'; apply: sub_le_big => y /andP[yA yP]; apply/andP; split => //.\nexact: subsetP yA.\nQed.",
    "Lemma le_big_nat_cond n m n' m' (P P' : {pred nat}) (F : nat -> R) :\n    (n' <= n)%N -> (m <= m')%N -> (forall i, (n <= i < m)%N -> P i -> P' i) ->\n  le (\\big[op/x]_(n <= i < m | P i) F i) (\\big[op/x]_(n' <= i < m' | P' i) F i).\nProof.\nmove=> len'n lemm' PP'i; rewrite uniq_sub_le_big_cond ?filter_uniq ?iota_uniq//.\nmove=> i; rewrite !mem_filter !mem_index_iota => /and3P[Pi ni im].\nby rewrite PP'i ?ni//= (leq_trans _ ni)// (leq_trans im).\nQed.",
    "Lemma le_big_nat n m n' m' [P] [F : nat -> R] : (n' <= n)%N -> (m <= m')%N ->\n  le (\\big[op/x]_(n <= i < m | P i) F i) (\\big[op/x]_(n' <= i < m' | P i) F i).\nProof. by move=> len'n lemm'; rewrite le_big_nat_cond. Qed.",
    "Lemma le_big_ord_cond n m (P P' : {pred nat}) (F : nat -> R) :\n    (n <= m)%N -> (forall i : 'I_n, P i -> P' i) ->\n  le (\\big[op/x]_(i < n | P i) F i) (\\big[op/x]_(i < m | P' i) F i).\nProof.\nmove=> nm PP'; rewrite -!big_mkord le_big_nat_cond//= => i ni.\nby have := PP' (Ordinal ni).\nQed.",
    "Lemma eq_bigl_supp (r : seq I) (P1 : pred I) (P2 : pred I) (F : I -> R) :\n  {in [pred x | F x != idx], P1 =1 P2} ->\n  \\big[op/idx]_(i <- r | P1 i) F i = \\big[op/idx]_(i <- r | P2 i) F i.\nProof.\nmove=> P12; rewrite big_mkcond [RHS]big_mkcond; apply: eq_bigr => i _.\nby case: (eqVneq (F i) idx) => [->|/P12->]; rewrite ?if_same.\nQed.",
    "Lemma perm_big_supp_cond [r s : seq I] [P : pred I] (F : I -> R) :\n  perm_eq\n    [seq i <- r | P i && (F i != idx)]\n    [seq i <- s | P i && (F i != idx)] ->\n  \\big[op/idx]_(i <- r | P i) F i = \\big[op/idx]_(i <- s | P i) F i.\nProof.\nmove=> prs; rewrite !(bigID [pred i | F i == idx] P F)/=.\nrewrite big1 ?Monoid.mul1m; last by move=> i /andP[_ /eqP->].\nrewrite [in RHS]big1 ?Monoid.mul1m; last by move=> i /andP[_ /eqP->].\nby rewrite -[in LHS]big_filter -[in RHS]big_filter; apply perm_big.\nQed.",
    "Lemma perm_big_supp [r s : seq I] [P : pred I] (F : I -> R) :\n  perm_eq [seq i <- r | F i != idx] [seq i <- s | F i != idx] ->\n  \\big[op/idx]_(i <- r | P i) F i = \\big[op/idx]_(i <- s | P i) F i.\nProof.\nby move=> ?; apply: perm_big_supp_cond; rewrite !filter_predI perm_filter.\nQed.",
    "Lemma big_distrl I r a (P : pred I) F :\n  \\big[+%M/0]_(i <- r | P i) F i * a = \\big[+%M/0]_(i <- r | P i) (F i * a).\nProof. by rewrite (big_endo ( *%M^~ a)) ?mul0m // => x y; apply: mulmDl. Qed.",
    "Lemma big_distrr I r a (P : pred I) F :\n  a * \\big[+%M/0]_(i <- r | P i) F i = \\big[+%M/0]_(i <- r | P i) (a * F i).\nProof. by rewrite big_endo ?mulm0 // => x y; apply: mulmDr. Qed.",
    "Lemma big_distrlr I J rI rJ (pI : pred I) (pJ : pred J) F G :\n  (\\big[+%M/0]_(i <- rI | pI i) F i) * (\\big[+%M/0]_(j <- rJ | pJ j) G j)\n   = \\big[+%M/0]_(i <- rI | pI i) \\big[+%M/0]_(j <- rJ | pJ j) (F i * G j).\nProof. by rewrite big_distrl; under eq_bigr do rewrite big_distrr. Qed.",
    "Lemma big_distr_big_dep (I J : finType) j0 (P : pred I) (Q : I -> pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[+%M/0]_(j | Q i j) F i j =\n     \\big[+%M/0]_(f in pfamily j0 P Q) \\big[*%M/1]_(i | P i) F i (f i).\nProof.\npose fIJ := {ffun I -> J}; pose Pf := pfamily j0 (_ : seq I) Q.\nhave [r big_r [Ur mem_r] _] := big_enumP P.\nsymmetry; transitivity (\\big[+%M/0]_(f in Pf r) \\big[*%M/1]_(i <- r) F i (f i)).\n  by apply: eq_big => // f; apply: eq_forallb => i; rewrite /= mem_r.\nrewrite -{P mem_r}big_r; elim: r Ur => /= [_ | i r IHr].\n  rewrite (big_pred1 [ffun=> j0]) ?big_nil //= => f.\n  apply/familyP/eqP=> /= [Df |->{f} i]; last by rewrite ffunE !inE.\n  by apply/ffunP=> i; rewrite ffunE; apply/eqP/Df.\ncase/andP=> /negbTE nri; rewrite big_cons big_distrl => {}/IHr<-.\nrewrite (partition_big (fun f : fIJ => f i) (Q i)) => [|f]; last first.\n  by move/familyP/(_ i); rewrite /= inE /= eqxx.\npose seti j (f : fIJ) := [ffun k => if k == i then j else f k].\napply: eq_bigr => j Qij.\nrewrite (reindex_onto (seti j) (seti j0)) => [|f /andP[_ /eqP fi]]; last first.\n  by apply/ffunP=> k; rewrite !ffunE; case: eqP => // ->.\nrewrite big_distrr; apply: eq_big => [f | f eq_f]; last first.\n  rewrite big_cons ffunE eqxx !big_seq; congr (_ * _).\n  by apply: eq_bigr => k; rewrite ffunE; case: eqP nri => // -> ->.\nrewrite !ffunE !eqxx andbT; apply/andP/familyP=> /= [[Pjf fij0] k | Pff].\n  have /[!(ffunE, inE)] := familyP Pjf k; case: eqP => // -> _.\n  by rewrite nri -(eqP fij0) !ffunE !inE !eqxx.\nsplit; [apply/familyP | apply/eqP/ffunP] => k; have /[!(ffunE, inE)]:= Pff k.\n  by case: eqP => // ->.\nby case: eqP => // ->; rewrite nri /= => /eqP.\nQed.",
    "Lemma big_distr_big (I J : finType) j0 (P : pred I) (Q : pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[+%M/0]_(j | Q j) F i j =\n     \\big[+%M/0]_(f in pffun_on j0 P Q) \\big[*%M/1]_(i | P i) F i (f i).\nProof.\nrewrite (big_distr_big_dep j0); apply: eq_bigl => f.\nby apply/familyP/familyP=> Pf i; case: ifP (Pf i).\nQed.",
    "Lemma bigA_distr_big_dep (I J : finType) (Q : I -> pred J) F :\n  \\big[*%M/1]_i \\big[+%M/0]_(j | Q i j) F i j\n    = \\big[+%M/0]_(f in family Q) \\big[*%M/1]_i F i (f i).\nProof.\nhave [j _ | J0] := pickP J; first by rewrite (big_distr_big_dep j).\nhave Q0 i: Q i =i pred0 by move=> /J0/esym/notF[].\ntransitivity (iter #|I| ( *%M 0) 1).\n  by rewrite -big_const; apply/eq_bigr=> i; have /(big_pred0 _)-> := Q0 i.\nhave [i _ | I0] := pickP I.\n  rewrite (cardD1 i) //= mul0m big_pred0 // => f.\n  by apply/familyP=> /(_ i); rewrite Q0.\nhave f: I -> J by move=> /I0/esym/notF[].\nrewrite eq_card0 // (big_pred1 (finfun f)) ?big_pred0 // => g.\nby apply/familyP/eqP=> _; first apply/ffunP; move=> /I0/esym/notF[].\nQed.",
    "Lemma bigA_distr_big (I J : finType) (Q : pred J) (F : I -> J -> R) :\n  \\big[*%M/1]_i \\big[+%M/0]_(j | Q j) F i j\n    = \\big[+%M/0]_(f in ffun_on Q) \\big[*%M/1]_i F i (f i).\nProof. exact: bigA_distr_big_dep. Qed.",
    "Lemma bigA_distr_bigA (I J : finType) F :\n  \\big[*%M/1]_(i : I) \\big[+%M/0]_(j : J) F i j\n    = \\big[+%M/0]_(f : {ffun I -> J}) \\big[*%M/1]_i F i (f i).\nProof. by rewrite bigA_distr_big; apply: eq_bigl => ?; apply/familyP. Qed.",
    "Lemma big_has : \\big[orb/false]_(i <- r) B i = has B r.\nProof. by rewrite unlock. Qed.",
    "Lemma big_all : \\big[andb/true]_(i <- r) B i = all B r.\nProof. by rewrite unlock. Qed.",
    "Lemma big_has_cond : \\big[orb/false]_(i <- r | P i) B i = has (predI P B) r.\nProof. by rewrite big_mkcond unlock. Qed.",
    "Lemma big_all_cond :\n  \\big[andb/true]_(i <- r | P i) B i = all [pred i | P i ==> B i] r.\nProof. by rewrite big_mkcond unlock. Qed.",
    "Lemma big_bool R (idx : R) (op : Monoid.com_law idx) (F : bool -> R):\n  \\big[op/idx]_(i : bool) F i = op (F true) (F false).\nProof. by rewrite /index_enum !unlock /= Monoid.mulm1. Qed.",
    "Lemma big_orE : \\big[orb/false]_(i | P i) B i = [exists (i | P i), B i].\nProof. by rewrite big_has_cond; apply/hasP/existsP=> [] [i]; exists i. Qed.",
    "Lemma big_andE : \\big[andb/true]_(i | P i) B i = [forall (i | P i), B i].\nProof.\nrewrite big_all_cond; apply/allP/forallP=> /= allB i; rewrite allB //.\nexact: mem_index_enum.\nQed.",
    "Lemma sum_nat_const n : \\sum_(i in A) n = #|A| * n.\nProof. by rewrite big_const iter_addn_0 mulnC. Qed.",
    "Lemma sum1_card : \\sum_(i in A) 1 = #|A|.\nProof. by rewrite sum_nat_const muln1. Qed.",
    "Lemma sum1_count J (r : seq J) (a : pred J) : \\sum_(j <- r | a j) 1 = count a r.\nProof. by rewrite big_const_seq iter_addn_0 mul1n. Qed.",
    "Lemma sum1_size J (r : seq J) : \\sum_(j <- r) 1 = size r.\nProof. by rewrite sum1_count count_predT. Qed.",
    "Lemma prod_nat_const n : \\prod_(i in A) n = n ^ #|A|.\nProof. by rewrite big_const -Monoid.iteropE. Qed.",
    "Lemma sum_nat_const_nat n1 n2 n : \\sum_(n1 <= i < n2) n = (n2 - n1) * n.\nProof. by rewrite big_const_nat iter_addn_0 mulnC. Qed.",
    "Lemma prod_nat_const_nat n1 n2 n : \\prod_(n1 <= i < n2) n = n ^ (n2 - n1).\nProof. by rewrite big_const_nat -Monoid.iteropE. Qed.",
    "Lemma telescope_sumn_in n m f : n <= m ->\n    (forall i, n <= i < m -> f i <= f i.+1) ->\n  \\sum_(n <= k < m) (f k.+1 - f k) = f m - f n.\nProof.\nmove=> nm fle; rewrite (telescope_big (fun i j => f j - f i)).\n  by case: ltngtP nm => // ->; rewrite subnn.\nmove=> k /andP[nk km]; rewrite /= addnBAC ?subnKC ?fle ?(ltnW nk)//.\nelim: k nk km => [//| k IHk /[!ltnS]/[1!leq_eqVlt]+ km].\n  move=> /predU1P[/[dup]nk -> | nk]; first by rewrite fle ?nk ?leqnn 1?ltnW.\nby rewrite (leq_trans (IHk _ _) (fle _ _))// ltnW// ltnW.\nQed.",
    "Lemma telescope_sumn n m f : {homo f : x y / x <= y} ->\n  \\sum_(n <= k < m) (f k.+1 - f k) = f m - f n.\nProof.\nmove=> fle; case: (ltnP n m) => nm.\n  by apply: (telescope_sumn_in (ltnW nm)) => ? ?; apply: fle.\nby apply/esym/eqP; rewrite big_geq// subn_eq0 fle.\nQed.",
    "Lemma sumnE r : sumn r = \\sum_(i <- r) i. Proof. exact: foldrE. Qed.",
    "Lemma card_bseq n (T : finType) : #|{bseq n of T}| = \\sum_(i < n.+1) #|T| ^ i.\nProof.\nrewrite (bij_eq_card bseq_tagged_tuple_bij) card_tagged sumnE big_map big_enum.\nby under eq_bigr do rewrite card_tuple.\nQed.",
    "Lemma leqif_sum (I : finType) (P C : pred I) (E1 E2 : I -> nat) :\n    (forall i, P i -> E1 i <= E2 i ?= iff C i) ->\n  \\sum_(i | P i) E1 i <= \\sum_(i | P i) E2 i ?= iff [forall (i | P i), C i].\nProof.\nmove=> leE12; rewrite -big_andE.\nby elim/big_rec3: _ => // i Ci m1 m2 /leE12; apply: leqif_add.\nQed.",
    "Lemma leq_sum I r (P : pred I) (E1 E2 : I -> nat) :\n    (forall i, P i -> E1 i <= E2 i) ->\n  \\sum_(i <- r | P i) E1 i <= \\sum_(i <- r | P i) E2 i.\nProof. by move=> leE12; elim/big_ind2: _ => // m1 m2 n1 n2; apply: leq_add. Qed.",
    "Lemma sumnB I r (P : pred I) (E1 E2 : I -> nat) :\n     (forall i, P i -> E1 i <= E2 i) ->\n  \\sum_(i <- r | P i) (E2 i - E1 i) =\n  \\sum_(i <- r | P i) E2 i - \\sum_(i <- r | P i) E1 i.\nProof. by move=> /(_ _ _)/subnK-/(eq_bigr _)<-; rewrite big_split addnK. Qed.",
    "Lemma sum_nat_eq0 (I : finType) (P : pred I) (E : I -> nat) :\n  (\\sum_(i | P i) E i == 0)%N = [forall (i | P i), E i == 0%N].\nProof. by rewrite eq_sym -(@leqif_sum I P _ (fun _ => 0%N) E) ?big1_eq. Qed.",
    "Lemma sum_nat_seq_eq0 I r (P : pred I) F :\n  (\\sum_(i <- r | P i) F i == 0)%N = all (fun i => P i ==> (F i == 0%N)) r.\nProof. by rewrite (big_morph _ (id1:=true) addn_eq0)// big_all_cond. Qed.",
    "Lemma sum_nat_seq_neq0 I r (P : pred I) F :\n  (\\sum_(i <- r | P i) F i != 0)%N = has (fun i => P i && (F i != 0)%N) r.\nProof.\nby rewrite sum_nat_seq_eq0// -has_predC; apply: eq_has => x /=; case Px: (P x).\nQed.",
    "Lemma sum_nat_eq1 (I : finType) (P : pred I) (F : I -> nat) :\n  reflect\n    (exists i : I, [/\\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]%N)\n    (\\sum_(i | P i) F i == 1)%N.\nProof.\napply/(iffP idP) => [sumF_eq1 | [i [Pi Fi1 zFj]]]; last first.\n  rewrite (bigD1 i)//= Fi1 addn_eq1//= orbF sum_nat_eq0.\n  by apply/forall_inP => j /andP[Pj ji]; apply/eqP/zFj.\nhave /forall_inPn [i Pi FiN0]: ~~ [forall i in P, F i == 0].\n  by apply: contraTN sumF_eq1 => /'forall_in_eqP F0; rewrite big1.\nmove: sumF_eq1; rewrite (bigD1 i)//= addn_eq1 (negPf FiN0)/= orbF.\nmove=> /andP[/eqP Fi1]; rewrite sum_nat_eq0 => /'forall_in_eqP FNi0.\nby exists i; split; rewrite // => j /[swap] Nij /(conj Nij)/andP/FNi0.\nQed.",
    "Lemma sum_nat_seq_eq1 (I : eqType) r (P : pred I) (F : I -> nat) :\n    (\\sum_(i <- r | P i) F i = 1)%N ->\n  exists i, [/\\ i \\in r, P i, F i = 1\n            & forall j, j != i -> j \\in r -> P j -> F j = 0]%N.\nProof.\nrewrite big_tnth/= => /eqP/sum_nat_eq1[/= i [Pi Fi FNi]].\nexists (tnth (in_tuple r) i); split;  rewrite //= ?mem_tnth// => j.\nmove=> /[swap] /(tnthP (in_tuple r))[{} j -> Nij /FNi->//].\nby apply: contra_neq Nij => ->.\nQed.",
    "Lemma prod_nat_seq_eq0 I r (P : pred I) F :\n  (\\prod_(i <- r | P i) F i == 0)%N = has (fun i => P i && (F i == 0%N)) r.\nProof. by rewrite (big_morph _ (id1 := false) muln_eq0)// big_has_cond. Qed.",
    "Lemma prod_nat_seq_neq0 I r (P : pred I) F :\n  (\\prod_(i <- r | P i) F i != 0)%N = all (fun i => P i ==> (F i != 0%N)) r.\nProof.\nby rewrite prod_nat_seq_eq0 -all_predC; apply: eq_all => i /=; case: (P i).\nQed.",
    "Lemma prod_nat_seq_eq1 I r (P : pred I) F :\n  (\\prod_(i <- r | P i) F i == 1)%N = all (fun i => P i ==> (F i == 1%N)) r.\nProof. by rewrite (big_morph _ (id1:=true) muln_eq1)// big_all_cond. Qed.",
    "Lemma prod_nat_seq_neq1 I r (P : pred I) F :\n  (\\prod_(i <- r | P i) F i != 1)%N = has (fun i => P i && (F i != 1%N)) r.\nProof.\nby rewrite prod_nat_seq_eq1 -has_predC; apply: eq_has => i /=; case: (P i).\nQed.",
    "Lemma leq_prod I r (P : pred I) (E1 E2 : I -> nat) :\n    (forall i, P i -> E1 i <= E2 i) ->\n  \\prod_(i <- r | P i) E1 i <= \\prod_(i <- r | P i) E2 i.\nProof. by move=> leE12; elim/big_ind2: _ => // m1 m2 n1 n2; apply: leq_mul. Qed.",
    "Lemma prodn_cond_gt0 I r (P : pred I) F :\n  (forall i, P i -> 0 < F i) -> 0 < \\prod_(i <- r | P i) F i.\nProof. by move=> Fpos; elim/big_ind: _ => // n1 n2; rewrite muln_gt0 => ->. Qed.",
    "Lemma prodn_gt0 I r (P : pred I) F :\n  (forall i, 0 < F i) -> 0 < \\prod_(i <- r | P i) F i.\nProof. by move=> Fpos; apply: prodn_cond_gt0. Qed.",
    "Lemma leq_bigmax_seq (I : eqType) r (P : pred I) F i0 :\n  i0 \\in r -> P i0 -> F i0 <= \\max_(i <- r | P i) F i.\nProof.\nmove=> + Pi0; elim: r => // h t ih; rewrite inE big_cons.\nmove=> /predU1P[<-|i0t]; first by rewrite Pi0 leq_maxl.\nby case: ifPn => Ph; [rewrite leq_max ih// orbT|rewrite ih].\nQed.",
    "Lemma leq_bigmax_cond (I : finType) (P : pred I) F i0 :\n  P i0 -> F i0 <= \\max_(i | P i) F i.\nProof. exact: leq_bigmax_seq. Qed.",
    "Lemma leq_bigmax (I : finType) F (i0 : I) : F i0 <= \\max_i F i.\nProof. exact: leq_bigmax_cond. Qed.",
    "Lemma bigmax_leqP (I : finType) (P : pred I) m F :\n  reflect (forall i, P i -> F i <= m) (\\max_(i | P i) F i <= m).\nProof.\napply: (iffP idP) => leFm => [i Pi|].\n  by apply: leq_trans leFm; apply: leq_bigmax_cond.\nby elim/big_ind: _ => // m1 m2; rewrite geq_max => ->.\nQed.",
    "Lemma bigmax_leqP_seq (I : eqType) r (P : pred I) m F :\n  reflect (forall i, i \\in r -> P i -> F i <= m) (\\max_(i <- r | P i) F i <= m).\nProof.\napply: (iffP idP) => leFm => [i ri Pi|].\n  exact/(leq_trans _ leFm)/leq_bigmax_seq.\nrewrite big_seq_cond; elim/big_ind: _ => // [m1 m2|i /andP[ri]].\n  by rewrite geq_max => ->.\nexact: leFm.\nQed.",
    "Lemma bigmax_sup (I : finType) i0 (P : pred I) m F :\n  P i0 -> m <= F i0 -> m <= \\max_(i | P i) F i.\nProof. by move=> Pi0 le_m_Fi0; apply: leq_trans (leq_bigmax_cond i0 Pi0). Qed.",
    "Lemma bigmax_sup_seq (I : eqType) r i0 (P : pred I) m F :\n  i0 \\in r -> P i0 -> m <= F i0 -> m <= \\max_(i <- r | P i) F i.\nProof. by move=> i0r Pi0 ?; apply: leq_trans (leq_bigmax_seq i0 _ _). Qed.",
    "Lemma bigmax_eq_arg (I : finType) i0 (P : pred I) F :\n  P i0 -> \\max_(i | P i) F i = F [arg max_(i > i0 | P i) F i].\nProof.\nmove=> Pi0; case: arg_maxnP => //= i Pi maxFi.\nby apply/eqP; rewrite eqn_leq leq_bigmax_cond // andbT; apply/bigmax_leqP.\nQed.",
    "Lemma eq_bigmax_cond (I : finType) (A : pred I) F :\n  #|A| > 0 -> {i0 | i0 \\in A & \\max_(i in A) F i = F i0}.\nProof.\ncase: (pickP A) => [i0 Ai0 _ | ]; last by move/eq_card0->.\nby exists [arg max_(i > i0 in A) F i]; [case: arg_maxnP | apply: bigmax_eq_arg].\nQed.",
    "Lemma eq_bigmax (I : finType) F : #|I| > 0 -> {i0 : I | \\max_i F i = F i0}.\nProof. by case/(eq_bigmax_cond F) => x _ ->; exists x. Qed.",
    "Lemma expn_sum m I r (P : pred I) F :\n  (m ^ (\\sum_(i <- r | P i) F i) = \\prod_(i <- r | P i) m ^ F i)%N.\nProof. exact: (big_morph _ (expnD m)). Qed.",
    "Lemma dvdn_biglcmP (I : finType) (P : pred I) F m :\n  reflect (forall i, P i -> F i %| m) (\\big[lcmn/1%N]_(i | P i) F i %| m).\nProof.\napply: (iffP idP) => [dvFm i Pi | dvFm].\n  by rewrite (bigD1 i) // dvdn_lcm in dvFm; case/andP: dvFm.\nby elim/big_ind: _ => // p q p_m; rewrite dvdn_lcm p_m.\nQed.",
    "Lemma biglcmn_sup (I : finType) i0 (P : pred I) F m :\n  P i0 -> m %| F i0 -> m %| \\big[lcmn/1%N]_(i | P i) F i.\nProof.\nby move=> Pi0 m_Fi0; rewrite (dvdn_trans m_Fi0) // (bigD1 i0) ?dvdn_lcml.\nQed.",
    "Lemma dvdn_biggcdP (I : finType) (P : pred I) F m :\n  reflect (forall i, P i -> m %| F i) (m %| \\big[gcdn/0]_(i | P i) F i).\nProof.\napply: (iffP idP) => [dvmF i Pi | dvmF].\n  by rewrite (bigD1 i) // dvdn_gcd in dvmF; case/andP: dvmF.\nby elim/big_ind: _ => // p q m_p; rewrite dvdn_gcd m_p.\nQed.",
    "Lemma biggcdn_inf (I : finType) i0 (P : pred I) F m :\n  P i0 -> F i0 %| m -> \\big[gcdn/0]_(i | P i) F i %| m.\nProof. by move=> Pi0; apply: dvdn_trans; rewrite (bigD1 i0) ?dvdn_gcdl. Qed.",
    "Lemma cat_path x p1 p2 : path x (p1 ++ p2) = path x p1 && path (last x p1) p2.\nProof. by elim: p1 x => [|y p1 Hrec] x //=; rewrite Hrec -!andbA. Qed.",
    "Lemma rcons_path x p y : path x (rcons p y) = path x p && e (last x p) y.\nProof. by rewrite -cats1 cat_path /= andbT. Qed.",
    "Lemma take_path x p i : path x p -> path x (take i p).\nProof. elim: p x i => [//| x p] IHp x' [//| i] /= /andP[-> ?]; exact: IHp. Qed.",
    "Lemma pathP x p x0 :\n  reflect (forall i, i < size p -> e (nth x0 (x :: p) i) (nth x0 p i))\n          (path x p).\nProof.\nelim: p x => [|y p IHp] x /=; first by left.\napply: (iffP andP) => [[e_xy /IHp e_p [] //] | e_p].\nby split; [apply: (e_p 0) | apply/(IHp y) => i; apply: e_p i.+1].\nQed.",
    "Lemma cycle_path p : cycle p = path (last x0_cycle p) p.\nProof. by case: p => //= x p; rewrite rcons_path andbC. Qed.",
    "Lemma cycle_catC p q : cycle (p ++ q) = cycle (q ++ p).\nProof.\ncase: p q => [|x p] [|y q]; rewrite /= ?cats0 //=.\nby rewrite !rcons_path !cat_path !last_cat /= -!andbA; do !bool_congr.\nQed.",
    "Lemma rot_cycle p : cycle (rot n0 p) = cycle p.\nProof. by rewrite cycle_catC cat_take_drop. Qed.",
    "Lemma rotr_cycle p : cycle (rotr n0 p) = cycle p.\nProof. by rewrite -rot_cycle rotrK. Qed.",
    "Lemma sortedP s x :\n  reflect (forall i, i.+1 < size s -> e (nth x s i) (nth x s i.+1)) (sorted s).\nProof. by case: s => *; [constructor|apply: (iffP (pathP _ _ _)); apply]. Qed.",
    "Lemma path_sorted x s : path x s -> sorted s.\nProof. by case: s => //= y s /andP[]. Qed.",
    "Lemma path_min_sorted x s : all (e x) s -> path x s = sorted s.\nProof. by case: s => //= y s /andP [->]. Qed.",
    "Lemma pairwise_sorted s : pairwise e s -> sorted s.\nProof. by elim: s => //= x s IHs /andP[/path_min_sorted -> /IHs]. Qed.",
    "Lemma sorted_cat_cons s1 x s2 :\n  sorted (s1 ++ x :: s2) = sorted (rcons s1 x) && path x s2.\nProof.\nby case: s1 => [ | e1 s1] //=; rewrite -cat_rcons cat_path last_rcons.\nQed.",
    "Lemma rev_path x p :\n  path e (last x p) (rev (belast x p)) = path (fun z => e^~ z) x p.\nProof.\nelim: p x => //= y p IHp x; rewrite rev_cons rcons_path -{}IHp andbC.\nby rewrite -(last_cons x) -rev_rcons -lastI rev_cons last_rcons.\nQed.",
    "Lemma rev_cycle p : cycle e (rev p) = cycle (fun z => e^~ z) p.\nProof.\ncase: p => //= x p; rewrite -rev_path last_rcons belast_rcons rev_cons.\nby rewrite -[in LHS]cats1 cycle_catC.\nQed.",
    "Lemma rev_sorted p : sorted e (rev p) = sorted (fun z => e^~ z) p.\nProof. by case: p => //= x p; rewrite -rev_path lastI rev_rcons. Qed.",
    "Lemma path_relI x s :\n  path [rel x y | e x y && e' x y] x s = path e x s && path e' x s.\nProof. by elim: s x => //= y s IHs x; rewrite andbACA IHs. Qed.",
    "Lemma cycle_relI s :\n  cycle [rel x y | e x y && e' x y] s = cycle e s && cycle e' s.\nProof. by case: s => [|? ?]; last apply: path_relI. Qed.",
    "Lemma sorted_relI s :\n  sorted [rel x y | e x y && e' x y] s = sorted e s && sorted e' s.\nProof. by case: s; last apply: path_relI. Qed.",
    "Lemma sub_in_path x s : all P (x :: s) -> path e x s -> path e' x s.\nProof.\nby elim: s x => //= y s ihs x /and3P [? ? ?] /andP [/ee' -> //]; apply/ihs/andP.\nQed.",
    "Lemma sub_in_cycle s : all P s -> cycle e s -> cycle e' s.\nProof.\ncase: s => //= x s /andP [Px Ps].\nby apply: sub_in_path; rewrite /= all_rcons Px.\nQed.",
    "Lemma sub_in_sorted s : all P s -> sorted e s -> sorted e' s.\nProof. by case: s => //; apply: sub_in_path. Qed.",
    "Lemma eq_in_path x s : all P (x :: s) -> path e x s = path e' x s.\nProof. by move=> Pxs; apply/idP/idP; apply: sub_in_path Pxs. Qed.",
    "Lemma eq_in_cycle s : all P s -> cycle e s = cycle e' s.\nProof. by move=> Ps; apply/idP/idP; apply: sub_in_cycle Ps. Qed.",
    "Lemma eq_in_sorted s : all P s -> sorted e s = sorted e' s.\nProof. by move=> Ps; apply/idP/idP; apply: sub_in_sorted Ps. Qed.",
    "Lemma sub_path : subrel e e' -> forall x p, path e x p -> path e' x p.\nProof. by move=> ? ? ?; apply/sub_in_path/all_predT; apply: in2W. Qed.",
    "Lemma sub_cycle : subrel e e' -> subpred (cycle e) (cycle e').\nProof. by move=> ee' [] // ? ?; apply: sub_path. Qed.",
    "Lemma sub_sorted : subrel e e' -> subpred (sorted e) (sorted e').\nProof. by move=> ee' [] //=; apply: sub_path. Qed.",
    "Lemma eq_path : e =2 e' -> path e =2 path e'.\nProof. by move=> ? ? ?; apply/eq_in_path/all_predT; apply: in2W. Qed.",
    "Lemma eq_cycle : e =2 e' -> cycle e =1 cycle e'.\nProof. by move=> ee' [] // ? ?; apply: eq_path. Qed.",
    "Lemma eq_sorted : e =2 e' -> sorted e =1 sorted e'.\nProof. by move=> ee' [] // ? ?; apply: eq_path. Qed.",
    "Lemma order_path_min_in x s :\n  {in P & &, transitive leT} -> all P (x :: s) -> path leT x s -> all (leT x) s.\nProof.\nmove=> leT_tr; elim: s => //= y s ihs /and3P [Px Py Ps] /andP [xy ys].\nrewrite xy {}ihs ?Px //=; case: s Ps ys => //= z s /andP [Pz Ps] /andP [yz ->].\nby rewrite (leT_tr _ _ _ Py Px Pz).\nQed.",
    "Lemma path_sorted_inE x s :\n  all P (x :: s) -> path leT x s = all (leT x) s && sorted leT s.\nProof.\nmove=> Pxs; apply/idP/idP => [xs|/andP[/path_min_sorted<-//]].\nby rewrite (order_path_min_in leT_tr) //; apply: path_sorted xs.\nQed.",
    "Lemma sorted_pairwise_in s : all P s -> sorted leT s = pairwise leT s.\nProof.\nby elim: s => //= x s IHs /andP [Px Ps]; rewrite path_sorted_inE ?IHs //= Px.\nQed.",
    "Lemma path_pairwise_in x s :\n  all P (x :: s) -> path leT x s = pairwise leT (x :: s).\nProof. by move=> Pxs; rewrite -sorted_pairwise_in. Qed.",
    "Lemma cat_sorted2 s s' : sorted leT (s ++ s') -> sorted leT s * sorted leT s'.\nProof. by case: s => //= x s; rewrite cat_path => /andP[-> /path_sorted]. Qed.",
    "Lemma sorted_mask_in m s : all P s -> sorted leT s -> sorted leT (mask m s).\nProof.\nby move=> Ps; rewrite !sorted_pairwise_in ?all_mask //; exact: pairwise_mask.\nQed.",
    "Lemma sorted_filter_in a s : all P s -> sorted leT s -> sorted leT (filter a s).\nProof. rewrite filter_mask; exact: sorted_mask_in. Qed.",
    "Lemma path_mask_in x m s :\n  all P (x :: s) -> path leT x s -> path leT x (mask m s).\nProof. exact/(sorted_mask_in (true :: m)). Qed.",
    "Lemma path_filter_in x a s :\n  all P (x :: s) -> path leT x s -> path leT x (filter a s).\nProof. by move=> Pxs; rewrite filter_mask; exact: path_mask_in. Qed.",
    "Lemma sorted_ltn_nth_in x0 s : all P s -> sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i < j >-> leT i j}}.\nProof. by move=> Ps; rewrite sorted_pairwise_in //; apply/pairwiseP. Qed.",
    "Lemma sorted_leq_nth_in x0 s : all P s -> sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i <= j >-> leT i j}}.\nProof.\nmove=> Ps s_sorted x y xs ys; rewrite leq_eqVlt=> /predU1P[->|].\n  exact/leT_refl/all_nthP.\nexact: sorted_ltn_nth_in.\nQed.",
    "Lemma order_path_min x s : transitive leT -> path leT x s -> all (leT x) s.\nProof.\nby move=> leT_tr; apply/order_path_min_in/all_predT => //; apply: in3W.\nQed.",
    "Lemma path_le x x' s : leT x x' -> path leT x' s -> path leT x s.\nProof.\nby case: s => [//| x'' s xlex' /= /andP[x'lex'' ->]]; rewrite (leT_tr xlex').\nQed.",
    "Lemma path_sortedE x s : path leT x s = all (leT x) s && sorted leT s.\nProof. exact/path_sorted_inE/all_predT. Qed.",
    "Lemma sorted_pairwise s : sorted leT s = pairwise leT s.\nProof. exact/sorted_pairwise_in/all_predT. Qed.",
    "Lemma path_pairwise x s : path leT x s = pairwise leT (x :: s).\nProof. exact/path_pairwise_in/all_predT. Qed.",
    "Lemma sorted_mask m s : sorted leT s -> sorted leT (mask m s).\nProof. exact/sorted_mask_in/all_predT. Qed.",
    "Lemma sorted_filter a s : sorted leT s -> sorted leT (filter a s).\nProof. exact/sorted_filter_in/all_predT. Qed.",
    "Lemma path_mask x m s : path leT x s -> path leT x (mask m s).\nProof. exact/path_mask_in/all_predT. Qed.",
    "Lemma path_filter x a s : path leT x s -> path leT x (filter a s).\nProof. exact/path_filter_in/all_predT. Qed.",
    "Lemma sorted_ltn_nth x0 s : sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i < j >-> leT i j}}.\nProof. exact/sorted_ltn_nth_in/all_predT. Qed.",
    "Lemma sorted_leq_nth x0 s : sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i <= j >-> leT i j}}.\nProof. exact/sorted_leq_nth_in/all_predT. Qed.",
    "Lemma take_sorted n s : sorted leT s -> sorted leT (take n s).\nProof. by rewrite -[s in sorted _ s](cat_take_drop n) => /cat_sorted2[]. Qed.",
    "Lemma drop_sorted n s : sorted leT s -> sorted leT (drop n s).\nProof. by rewrite -[s in sorted _ s](cat_take_drop n) => /cat_sorted2[]. Qed.",
    "Lemma path_map x s : path e' (f x) (map f s) = path (relpre f e') x s.\nProof. by elim: s x => //= y s <-. Qed.",
    "Lemma cycle_map s : cycle e' (map f s) = cycle (relpre f e') s.\nProof. by case: s => //= ? ?; rewrite -map_rcons path_map. Qed.",
    "Lemma sorted_map s : sorted e' (map f s) = sorted (relpre f e') s.\nProof. by case: s; last apply: path_map. Qed.",
    "Lemma homo_path_in x s : {in P &, {homo f : x y / e x y >-> e' x y}} ->\n  all P (x :: s) -> path e x s -> path e' (f x) (map f s).\nProof. by move=> f_mono; rewrite path_map; apply: sub_in_path. Qed.",
    "Lemma homo_cycle_in s : {in P &, {homo f : x y / e x y >-> e' x y}} ->\n  all P s -> cycle e s -> cycle e' (map f s).\nProof. by move=> f_mono; rewrite cycle_map; apply: sub_in_cycle. Qed.",
    "Lemma homo_sorted_in s : {in P &, {homo f : x y / e x y >-> e' x y}} ->\n  all P s -> sorted e s -> sorted e' (map f s).\nProof. by move=> f_mono; rewrite sorted_map; apply: sub_in_sorted. Qed.",
    "Lemma mono_path_in x s : {in P &, {mono f : x y / e x y >-> e' x y}} ->\n  all P (x :: s) -> path e' (f x) (map f s) = path e x s.\nProof. by move=> f_mono; rewrite path_map; apply: eq_in_path. Qed.",
    "Lemma mono_cycle_in s : {in P &, {mono f : x y / e x y >-> e' x y}} ->\n  all P s -> cycle e' (map f s) = cycle e s.\nProof. by move=> f_mono; rewrite cycle_map; apply: eq_in_cycle. Qed.",
    "Lemma mono_sorted_in s : {in P &, {mono f : x y / e x y >-> e' x y}} ->\n  all P s -> sorted e' (map f s) = sorted e s.\nProof. by case: s => // x s; apply: mono_path_in. Qed.",
    "Lemma homo_path x s : {homo f : x y / e x y >-> e' x y} ->\n  path e x s -> path e' (f x) (map f s).\nProof. by move=> f_homo; rewrite path_map; apply: sub_path. Qed.",
    "Lemma homo_cycle : {homo f : x y / e x y >-> e' x y} ->\n  {homo map f : s / cycle e s >-> cycle e' s}.\nProof. by move=> f_homo s hs; rewrite cycle_map (sub_cycle _ hs). Qed.",
    "Lemma homo_sorted : {homo f : x y / e x y >-> e' x y} ->\n  {homo map f : s / sorted e s >-> sorted e' s}.\nProof. by move/homo_path => ? []. Qed.",
    "Lemma mono_path x s : {mono f : x y / e x y >-> e' x y} ->\n  path e' (f x) (map f s) = path e x s.\nProof. by move=> f_mon; rewrite path_map; apply: eq_path. Qed.",
    "Lemma mono_cycle : {mono f : x y / e x y >-> e' x y} ->\n  {mono map f : s / cycle e s >-> cycle e' s}.\nProof. by move=> ? ?; rewrite cycle_map; apply: eq_cycle. Qed.",
    "Lemma mono_sorted : {mono f : x y / e x y >-> e' x y} ->\n  {mono map f : s / sorted e s >-> sorted e' s}.\nProof. by move=> f_mon [] //= x s; apply: mono_path. Qed.",
    "Lemma cycle_all2rel (T : Type) (leT : rel T) :\n  transitive leT -> forall s, cycle leT s = all2rel leT s.\nProof.\nmove=> leT_tr; elim=> //= x s IHs.\nrewrite allrel_cons2 -{}IHs // (path_sortedE leT_tr) /= all_rcons -rev_sorted.\nrewrite rev_rcons /= (path_sortedE (rev_trans leT_tr)) all_rev !andbA.\ncase: (boolP (leT x x && _ && _)) => //=.\ncase: s => //= y s /and3P[/and3P[_ xy _] yx sx].\nrewrite rev_sorted rcons_path /= (leT_tr _ _ _ _ xy) ?andbT //.\nby case: (lastP s) sx => //= {}s z; rewrite all_rcons last_rcons => /andP [->].\nQed.",
    "Lemma cycle_all2rel_in (T : Type) (P : {pred T}) (leT : rel T) :\n  {in P & &, transitive leT} ->\n  forall s, all P s -> cycle leT s = all2rel leT s.\nProof.\nmove=> /in3_sig leT_tr _ /all_sigP [s ->].\nby rewrite cycle_map allrel_mapl allrel_mapr; apply: cycle_all2rel.\nQed.",
    "Lemma prefix_path x s1 s2 : prefix s1 s2 -> path x s2 -> path x s1.\nProof. by rewrite prefixE => /eqP <-; exact: take_path. Qed.",
    "Lemma prefix_sorted s1 s2 : prefix s1 s2 -> sorted s2 -> sorted s1.\nProof. by rewrite prefixE => /eqP <-; exact: take_sorted. Qed.",
    "Lemma infix_sorted s1 s2 : infix s1 s2 -> sorted s2 -> sorted s1.\nProof. by rewrite infixE => /eqP <- ?; apply/take_sorted/drop_sorted. Qed.",
    "Lemma suffix_sorted s1 s2 : suffix s1 s2 -> sorted s2 -> sorted s1.\nProof. by rewrite suffixE => /eqP <-; exact: drop_sorted. Qed.",
    "Lemma subseq_path_in x s1 s2 :\n  {in x :: s2 & &, transitive leT} -> subseq s1 s2 -> path x s2 -> path x s1.\nProof. by move=> tr /subseqP [m _ ->]; apply/(path_mask_in tr). Qed.",
    "Lemma subseq_sorted_in s1 s2 :\n  {in s2 & &, transitive leT} -> subseq s1 s2 -> sorted s2 -> sorted s1.\nProof. by move=> tr /subseqP [m _ ->]; apply/(sorted_mask_in tr). Qed.",
    "Lemma sorted_ltn_index_in s : {in s & &, transitive leT} -> sorted s ->\n  {in s &, forall x y, index x s < index y s -> leT x y}.\nProof.\ncase: s => // x0 s' leT_tr s_sorted x y xs ys.\nmove/(sorted_ltn_nth_in leT_tr x0 (allss (_ :: _)) s_sorted).\nby rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.\nQed.",
    "Lemma sorted_leq_index_in s :\n  {in s & &, transitive leT} -> {in s, reflexive leT} -> sorted s ->\n  {in s &, forall x y, index x s <= index y s -> leT x y}.\nProof.\ncase: s => // x0 s' leT_tr leT_refl s_sorted x y xs ys.\nmove/(sorted_leq_nth_in leT_tr leT_refl x0 (allss (_ :: _)) s_sorted).\nby rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.\nQed.",
    "Lemma subseq_path x s1 s2 : subseq s1 s2 -> path x s2 -> path x s1.\nProof. by apply: subseq_path_in; apply: in3W. Qed.",
    "Lemma subseq_sorted s1 s2 : subseq s1 s2 -> sorted s2 -> sorted s1.\nProof. by apply: subseq_sorted_in; apply: in3W. Qed.",
    "Lemma sorted_uniq : irreflexive leT -> forall s, sorted s -> uniq s.\nProof. by move=> irr s; rewrite sorted_pairwise //; apply/pairwise_uniq. Qed.",
    "Lemma sorted_eq : antisymmetric leT ->\n  forall s1 s2, sorted s1 -> sorted s2 -> perm_eq s1 s2 -> s1 = s2.\nProof.\nby move=> leT_asym s1 s2; rewrite !sorted_pairwise //; apply: pairwise_eq.\nQed.",
    "Lemma irr_sorted_eq : irreflexive leT ->\n  forall s1 s2, sorted s1 -> sorted s2 -> s1 =i s2 -> s1 = s2.\nProof.\nmove=> leT_irr s1 s2 s1_sort s2_sort eq_s12.\nhave: antisymmetric leT.\n  by move=> m n /andP[? ltnm]; case/idP: (leT_irr m); apply: leT_tr ltnm.\nby move/sorted_eq; apply=> //; apply: uniq_perm => //; apply: sorted_uniq.\nQed.",
    "Lemma sorted_ltn_index s :\n  sorted s -> {in s &, forall x y, index x s < index y s -> leT x y}.\nProof.\ncase: s => // x0 s' s_sorted x y xs ys /(sorted_ltn_nth leT_tr x0 s_sorted).\nby rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.\nQed.",
    "Lemma undup_path x s : path x s -> path x (undup s).\nProof. exact/subseq_path/undup_subseq. Qed.",
    "Lemma undup_sorted s : sorted s -> sorted (undup s).\nProof. exact/subseq_sorted/undup_subseq. Qed.",
    "Lemma sorted_leq_index s :\n  sorted s -> {in s &, forall x y, index x s <= index y s -> leT x y}.\nProof.\ncase: s => // x0 s' s_sorted x y xs ys.\nmove/(sorted_leq_nth leT_tr leT_refl x0 s_sorted).\nby rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.\nQed.",
    "Lemma sorted_uniq_in s :\n  {in s & &, transitive leT} -> {in s, irreflexive leT} ->\n  sorted leT s -> uniq s.\nProof.\nmove=> /in3_sig leT_tr /in1_sig leT_irr; case/all_sigP: (allss s) => s' ->.\nby rewrite sorted_map (map_inj_uniq val_inj); exact: sorted_uniq.\nQed.",
    "Lemma sorted_eq_in s1 s2 :\n  {in s1 & &, transitive leT} -> {in s1 &, antisymmetric leT} ->\n  sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2.\nProof.\nmove=> /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_anti + + /[dup] s1s2.\nhave /all_sigP[s1' ->] := allss s1.\nhave /all_sigP[{s1s2}s2 ->] : all [in s1] s2 by rewrite -(perm_all _ s1s2).\nby rewrite !sorted_map => ss1' ss2 /(perm_map_inj val_inj)/(sorted_eq leT_tr)->.\nQed.",
    "Lemma irr_sorted_eq_in s1 s2 :\n  {in s1 & &, transitive leT} -> {in s1, irreflexive leT} ->\n  sorted leT s1 -> sorted leT s2 -> s1 =i s2 -> s1 = s2.\nProof.\nmove=> /in3_sig leT_tr /in1_sig leT_irr + + /[dup] s1s2.\nhave /all_sigP[s1' ->] := allss s1.\nhave /all_sigP[s2' ->] : all [in s1] s2 by rewrite -(eq_all_r s1s2).\nrewrite !sorted_map => ss1' ss2' {}s1s2; congr map.\nby apply: (irr_sorted_eq leT_tr) => // x; rewrite -!(mem_map val_inj).\nQed.",
    "Lemma splitP p x (i := index x p) :\n  x \\in p -> split x p (take i p) (drop i.+1 p).\nProof. by rewrite -has_pred1 => /split_find[? ? ? /eqP->]; constructor. Qed.",
    "Lemma splitPl x1 p x : x \\in x1 :: p -> splitl x1 x p.\nProof.\nrewrite inE; case: eqP => [->| _ /splitP[]]; first by rewrite -(cat0s p).\nby split; apply: last_rcons.\nQed.",
    "Lemma splitPr p x : x \\in p -> splitr x p.\nProof. by case/splitP=> p1 p2; rewrite cat_rcons. Qed.",
    "Lemma next_nth p x :\n  next p x = if x \\in p then\n               if p is y :: p' then nth y p' (index x p) else x\n             else x.\nProof.\ncase: p => //= y0 p.\nelim: p {2 3 5}y0 => [|y' p IHp] y /=; rewrite (eq_sym y) inE;\n  by case: ifP => // _; apply: IHp.\nQed.",
    "Lemma prev_nth p x :\n  prev p x = if x \\in p then\n               if p is y :: p' then nth y p (index x p') else x\n             else x.\nProof.\ncase: p => //= y0 p; rewrite inE orbC.\nelim: p {2 5}y0 => [|y' p IHp] y; rewrite /= ?inE // (eq_sym y').\nby case: ifP => // _; apply: IHp.\nQed.",
    "Lemma mem_next p x : (next p x \\in p) = (x \\in p).\nProof.\nrewrite next_nth; case p_x: (x \\in p) => //.\ncase: p (index x p) p_x => [|y0 p'] //= i _; rewrite inE.\nhave [lt_ip | ge_ip] := ltnP i (size p'); first by rewrite orbC mem_nth.\nby rewrite nth_default ?eqxx.\nQed.",
    "Lemma mem_prev p x : (prev p x \\in p) = (x \\in p).\nProof.\nrewrite prev_nth; case p_x: (x \\in p) => //; case: p => [|y0 p] // in p_x *.\nby apply mem_nth; rewrite /= ltnS index_size.\nQed.",
    "Lemma ucycle_cycle p : ucycle p -> cycle e p.\nProof. by case/andP. Qed.",
    "Lemma ucycle_uniq p : ucycle p -> uniq p.\nProof. by case/andP. Qed.",
    "Lemma next_cycle p x : cycle e p -> x \\in p -> e x (next p x).\nProof.\ncase: p => //= y0 p; elim: p {1 3 5}y0 => [|z p IHp] y /=; rewrite inE.\n  by rewrite andbT; case: (x =P y) => // ->.\nby case/andP=> eyz /IHp; case: (x =P y) => // ->.\nQed.",
    "Lemma prev_cycle p x : cycle e p -> x \\in p -> e (prev p x) x.\nProof.\ncase: p => //= y0 p; rewrite inE orbC.\nelim: p {1 5}y0 => [|z p IHp] y /=; rewrite ?inE.\n  by rewrite andbT; case: (x =P y0) => // ->.\nby case/andP=> eyz /IHp; case: (x =P z) => // ->.\nQed.",
    "Lemma rot_ucycle p : ucycle (rot n0 p) = ucycle p.\nProof. by rewrite /ucycle rot_uniq rot_cycle. Qed.",
    "Lemma rotr_ucycle p : ucycle (rotr n0 p) = ucycle p.\nProof. by rewrite /ucycle rotr_uniq rotr_cycle. Qed.",
    "Lemma mem2l p x y : mem2 p x y -> x \\in p.\nProof.\nby rewrite /mem2 -!index_mem size_drop ltn_subRL; apply/leq_ltn_trans/leq_addr.\nQed.",
    "Lemma mem2lf {p x y} : x \\notin p -> mem2 p x y = false.\nProof. exact/contraNF/mem2l. Qed.",
    "Lemma mem2r p x y : mem2 p x y -> y \\in p.\nProof.\nby rewrite -[in y \\in p](cat_take_drop (index x p) p) mem_cat orbC /mem2 => ->.\nQed.",
    "Lemma mem2rf {p x y} : y \\notin p -> mem2 p x y = false.\nProof. exact/contraNF/mem2r. Qed.",
    "Lemma mem2_cat p1 p2 x y :\n  mem2 (p1 ++ p2) x y = mem2 p1 x y || mem2 p2 x y || (x \\in p1) && (y \\in p2).\nProof.\nrewrite [LHS]/mem2 index_cat fun_if if_arg !drop_cat addKn.\ncase: ifPn => [p1x | /mem2lf->]; last by rewrite ltnNge leq_addr orbF.\nby rewrite index_mem p1x mem_cat -orbA (orb_idl (@mem2r _ _ _)).\nQed.",
    "Lemma mem2_splice p1 p3 x y p2 :\n  mem2 (p1 ++ p3) x y -> mem2 (p1 ++ p2 ++ p3) x y.\nProof.\nby rewrite !mem2_cat mem_cat andb_orr orbC => /or3P[]->; rewrite ?orbT.\nQed.",
    "Lemma mem2_splice1 p1 p3 x y z :\n  mem2 (p1 ++ p3) x y -> mem2 (p1 ++ z :: p3) x y.\nProof. exact: mem2_splice [::z]. Qed.",
    "Lemma mem2_cons x p y z :\n  mem2 (x :: p) y z = (if x == y then z \\in x :: p else mem2 p y z).\nProof. by rewrite [LHS]/mem2 /=; case: ifP. Qed.",
    "Lemma mem2_seq1 x y z : mem2 [:: x] y z = (y == x) && (z == x).\nProof. by rewrite mem2_cons eq_sym inE. Qed.",
    "Lemma mem2_last y0 p x : mem2 p x (last y0 p) = (x \\in p).\nProof.\napply/idP/idP; first exact: mem2l; rewrite -index_mem /mem2 => p_x.\nby rewrite -nth_last -(subnKC p_x) -nth_drop mem_nth // size_drop subnSK.\nQed.",
    "Lemma mem2l_cat {p1 p2 x} : x \\notin p1 -> mem2 (p1 ++ p2) x =1 mem2 p2 x.\nProof. by move=> p1'x y; rewrite mem2_cat (negPf p1'x) mem2lf ?orbF. Qed.",
    "Lemma mem2r_cat {p1 p2 x y} : y \\notin p2 -> mem2 (p1 ++ p2) x y = mem2 p1 x y.\nProof.\nby move=> p2'y; rewrite mem2_cat (negPf p2'y) -orbA orbC andbF mem2rf.\nQed.",
    "Lemma mem2lr_splice {p1 p2 p3 x y} :\n  x \\notin p2 -> y \\notin p2 -> mem2 (p1 ++ p2 ++ p3) x y = mem2 (p1 ++ p3) x y.\nProof.\nmove=> p2'x p2'y; rewrite catA !mem2_cat !mem_cat.\nby rewrite (negPf p2'x) (negPf p2'y) (mem2lf p2'x) andbF !orbF.\nQed.",
    "Lemma mem2E s x y :\n  mem2 s x y = subseq (if x == y then [:: x] else [:: x; y]) s.\nProof.\nelim: s => [| h s]; first by case: ifP.\nrewrite mem2_cons => ->.\ndo 2 rewrite inE (fun_if subseq) !if_arg !sub1seq /=.\nby have [->|] := eqVneq; case: eqVneq.\nQed.",
    "Lemma splitP2r p x y : mem2 p x y -> split2r x y p.\nProof.\nmove=> pxy; have px := mem2l pxy.\nhave:= pxy; rewrite /mem2 (drop_nth x) ?index_mem ?nth_index //.\nby case/splitP: px => p1 p2; rewrite cat_rcons.\nQed.",
    "Lemma shortenP x p : path e x p -> shorten_spec x p (last x p) (shorten x p).\nProof.\nmove=> e_p; have: x \\in x :: p by apply: mem_head.\nelim: p x {1 3 5}x e_p => [|y2 p IHp] x y1.\n  by rewrite mem_seq1 => _ /eqP->.\nrewrite inE orbC /= => /andP[ey12 {}/IHp IHp].\ncase: ifPn => [y2p_x _ | not_y2p_x /eqP def_x].\n  have [p' e_p' Up' p'p] := IHp _ y2p_x.\n  by split=> // y /p'p; apply: predU1r.\nhave [p' e_p' Up' p'p] := IHp y2 (mem_head y2 p).\nhave{} p'p z: z \\in y2 :: p' -> z \\in y2 :: p.\n  by rewrite !inE; case: (z == y2) => // /p'p.\nrewrite -(last_cons y1) def_x; split=> //=; first by rewrite ey12.\nby rewrite (contra (p'p y1)) -?def_x.\nQed.",
    "Lemma sortE s : sort s = sort_rec1 [::] s.\nProof.\ntransitivity (sort_rec1 [:: nil] s); last by case: s.\nrewrite /sort; move: [::] {2}_.+1 (ltnSn (size s)./2) => ss n.\nby elim: n => // n IHn in ss s *; case: s => [|x [|y s]] //= /IHn->.\nQed.",
    "Lemma count_merge (p : pred T) s1 s2 :\n  count p (merge s1 s2) = count p (s1 ++ s2).\nProof.\nrewrite count_cat; elim: s1 s2 => // x s1 IH1.\nelim=> //= [|y s2 IH2]; first by rewrite addn0.\nby case: leT; rewrite /= ?IH1 ?IH2 !addnA [_ + p y]addnAC [p x + p y]addnC.\nQed.",
    "Lemma size_merge s1 s2 : size (merge s1 s2) = size (s1 ++ s2).\nProof. exact: (count_merge predT). Qed.",
    "Lemma allrel_merge s1 s2 : allrel leT s1 s2 -> merge s1 s2 = s1 ++ s2.\nProof.\nelim: s1 s2 => [|x s1 IHs1] [|y s2]; rewrite ?cats0 //=.\nby rewrite allrel_consl /= -andbA => /and3P [-> _ /IHs1->].\nQed.",
    "Lemma count_sort (p : pred T) s : count p (sort s) = count p s.\nProof.\nrewrite sortE -[RHS]/(sumn [seq count p x | x <- [::]] + count p s).\nelim: s [::] => [|x s ihs] ss.\n  rewrite [LHS]/=; elim: ss [::] => //= s ss ihss t.\n  by rewrite ihss count_merge count_cat addnCA addnA.\nrewrite {}ihs -[in RHS]cat1s count_cat addnA; congr addn; rewrite addnC.\nelim: {x s} ss [:: x] => [|[|x s] ss ihss] t //.\nby rewrite [LHS]/= add0n ihss count_merge count_cat -addnA addnCA.\nQed.",
    "Lemma pairwise_sort s : pairwise leT s -> sort s = s.\nProof.\npose catss := foldr (fun x => cat ^~ x) (Nil T).\nrewrite -{1 3}[s]/(catss [::] ++ s) sortE; elim: s [::] => /= [|x s ihs] ss.\n  elim: ss [::] => //= s ss ihss t; rewrite -catA => ssst.\n  rewrite -ihss ?allrel_merge //; move: ssst; rewrite !pairwise_cat.\n  by case/and4P.\nrewrite (catA _ [:: _]) => ssxs.\nsuff x_ss_E: catss (merge_sort_push [:: x] ss) = catss ([:: x] :: ss).\n  by rewrite -[catss _ ++ _]/(catss ([:: x] :: ss)) -x_ss_E ihs // x_ss_E.\nmove: ssxs; rewrite pairwise_cat => /and3P [_ + _].\nelim: ss [:: x] => {x s ihs} //= -[|x s] ss ihss t h_pairwise;\n  rewrite /= cats0 // allrel_merge ?ihss ?catA //.\nby move: h_pairwise; rewrite -catA !pairwise_cat => /and4P [].\nQed.",
    "Lemma merge_stable_path x s1 s2 :\n  allrel leT' s1 s2 -> path leT_lex x s1 -> path leT_lex x s2 ->\n  path leT_lex x (merge s1 s2).\nProof.\nelim: s1 s2 x => //= x s1 ih1; elim => //= y s2 ih2 h.\nrewrite allrel_cons2 => /and4P [xy' xs2 ys1 s1s2] /andP [hx xs1] /andP [hy ys2].\ncase: ifP => xy /=; rewrite (hx, hy) /=.\n- by apply: ih1; rewrite ?allrel_consr ?ys1 //= xy xy' implybT.\n- by apply: ih2; have:= leT_total x y; rewrite ?allrel_consl ?xs2 ?xy //= => ->.\nQed.",
    "Lemma merge_stable_sorted s1 s2 :\n  allrel leT' s1 s2 -> sorted leT_lex s1 -> sorted leT_lex s2 ->\n  sorted leT_lex (merge s1 s2).\nProof.\ncase: s1 s2 => [|x s1] [|y s2] //=; rewrite allrel_consl allrel_consr /= -andbA.\ncase/and4P => [xy' xs2 ys1 s1s2] xs1 ys2; rewrite -/(merge (_ :: _)).\nby case: ifP (leT_total x y) => /= xy yx; apply/merge_stable_path;\n  rewrite /= ?(allrel_consl, allrel_consr, xs2, ys1, xy, yx, xy', implybT).\nQed.",
    "Lemma merge_path x s1 s2 :\n  path leT x s1 -> path leT x s2 -> path leT x (merge s1 s2).\nProof. by rewrite !(eq_path leElex); apply/merge_stable_path/allrelT. Qed.",
    "Lemma merge_sorted s1 s2 :\n  sorted leT s1 -> sorted leT s2 -> sorted leT (merge s1 s2).\nProof. by rewrite !(eq_sorted leElex); apply/merge_stable_sorted/allrelT. Qed.",
    "Lemma sorted_merge s t : sorted leT (s ++ t) -> merge s t = s ++ t.\nProof. by rewrite sorted_pairwise // pairwise_cat => /and3P[/allrel_merge]. Qed.",
    "Lemma sorted_sort s : sorted leT s -> sort s = s.\nProof. by rewrite sorted_pairwise //; apply/pairwise_sort. Qed.",
    "Lemma mergeA : associative merge.\nProof.\nelim=> // x xs IHxs; elim=> // y ys IHys; elim=> [|z zs IHzs] /=.\n  by case: ifP.\ncase: ifP; case: ifP => /= lexy leyz.\n- by rewrite lexy (leT_tr lexy leyz) -IHxs /= leyz.\n- by rewrite lexy leyz -IHys.\n- case: ifP => lexz; first by rewrite -IHxs //= leyz.\n  by rewrite -!/(merge (_ :: _)) IHzs /= lexy.\n- suff->: leT x z = false by rewrite leyz // -!/(merge (_ :: _)) IHzs /= lexy.\n  by apply/contraFF/leT_tr: leyz; have := leT_total x y; rewrite lexy.\nQed.",
    "Lemma map_merge : {morph map f : s1 s2 / merge leT' s1 s2 >-> merge leT s1 s2}.\nProof.\nelim=> //= x s1 IHs1; elim => [|y s2 IHs2] //=; rewrite f_mono.\nby case: leT'; rewrite /= ?IHs1 ?IHs2.\nQed.",
    "Lemma map_sort : {morph map f : s1 / sort leT' s1 >-> sort leT s1}.\nProof.\nmove=> s; rewrite !sortE -[[::] in RHS]/(map (map f) [::]).\nelim: s [::] => /= [|x s ihs] ss; rewrite -/(map f [::]) -/(map f [:: _]);\n  first by elim: ss [::] => //= x ss ihss ?; rewrite ihss map_merge.\nrewrite ihs -/(map f [:: x]); congr sort_rec1.\nby elim: ss [:: x] => {x s ihs} [|[|x s] ss ihss] //= ?; rewrite ihss map_merge.\nQed.",
    "Lemma merge_map s1 s2 :\n  merge leT (map f s1) (map f s2) = map f (merge (relpre f leT) s1 s2).\nProof. exact/esym/map_merge. Qed.",
    "Lemma sort_map s : sort leT (map f s) = map f (sort (relpre f leT) s).\nProof. exact/esym/map_sort. Qed.",
    "Lemma sorted_sort_in T (P : {pred T}) (leT : rel T) :\n  {in P & &, transitive leT} ->\n  forall s : seq T, all P s -> sorted leT s -> sort leT s = s.\nProof.\nmove=> /in3_sig ? _ /all_sigP[s ->].\nby rewrite sort_map sorted_map => /sorted_sort->.\nQed.",
    "Lemma perm_merge s1 s2 : perm_eql (merge leT s1 s2) (s1 ++ s2).\nProof. by apply/permPl/permP => ?; rewrite count_merge. Qed.",
    "Lemma mem_merge s1 s2 : merge leT s1 s2 =i s1 ++ s2.\nProof. by apply: perm_mem; rewrite perm_merge. Qed.",
    "Lemma merge_uniq s1 s2 : uniq (merge leT s1 s2) = uniq (s1 ++ s2).\nProof. by apply: perm_uniq; rewrite perm_merge. Qed.",
    "Lemma perm_sort s : perm_eql (sort leT s) s.\nProof. by apply/permPl/permP => ?; rewrite count_sort. Qed.",
    "Lemma mem_sort s : sort leT s =i s. Proof. exact/perm_mem/permPl/perm_sort. Qed.",
    "Lemma sort_uniq s : uniq (sort leT s) = uniq s.\nProof. exact/perm_uniq/permPl/perm_sort. Qed.",
    "Lemma eq_count_merge (p : pred T) s1 s1' s2 s2' :\n  count p s1 = count p s1' -> count p s2 = count p s2' ->\n  count p (merge leT s1 s2) = count p (merge leT s1' s2').\nProof. by rewrite !count_merge !count_cat => -> ->. Qed.",
    "Lemma perm_iota_sort (T : Type) (leT : rel T) x0 s :\n  {i_s : seq nat | perm_eq i_s (iota 0 (size s)) &\n                   sort leT s = map (nth x0 s) i_s}.\nProof.\nexists (sort (relpre (nth x0 s) leT) (iota 0 (size s))).\n  by rewrite perm_sort.\nby rewrite -[s in LHS](mkseq_nth x0) sort_map.\nQed.",
    "Lemma all_merge (T : Type) (P : {pred T}) (leT : rel T) s1 s2 :\n  all P (merge leT s1 s2) = all P s1 && all P s2.\nProof.\nelim: s1 s2 => //= x s1 IHs1; elim=> [|y s2 IHs2]; rewrite ?andbT //=.\nby case: ifP => _; rewrite /= ?IHs1 ?IHs2 //=; bool_congr.\nQed.",
    "Lemma all_sort (T : Type) (P : {pred T}) (leT : rel T) s :\n  all P (sort leT s) = all P s.\nProof.\ncase: s => // x s; move: (x :: s) => {}s.\nby rewrite -(mkseq_nth x s) sort_map !all_map; apply/perm_all/permPl/perm_sort.\nQed.",
    "Lemma size_sort (T : Type) (leT : rel T) s : size (sort leT s) = size s.\nProof. exact: (count_sort _ predT). Qed.",
    "Lemma ltn_sorted_uniq_leq s : sorted ltn s = uniq s && sorted leq s.\nProof.\nrewrite (sorted_pairwise leq_trans) (sorted_pairwise ltn_trans) uniq_pairwise.\nby rewrite -pairwise_relI; apply/eq_pairwise => ? ?; rewrite ltn_neqAle.\nQed.",
    "Lemma gtn_sorted_uniq_geq s : sorted gtn s = uniq s && sorted geq s.\nProof. by rewrite -rev_sorted ltn_sorted_uniq_leq rev_sorted rev_uniq. Qed.",
    "Lemma iota_sorted i n : sorted leq (iota i n).\nProof. by elim: n i => // [[|n] //= IHn] i; rewrite IHn leqW. Qed.",
    "Lemma iota_ltn_sorted i n : sorted ltn (iota i n).\nProof. by rewrite ltn_sorted_uniq_leq iota_sorted iota_uniq. Qed.",
    "Lemma sort_iota_stable n : sorted lt_lex (sort leN (iota 0 n)).\nProof.\nrewrite sortE.\nhave/andP[]: all (gtn 0) (flatten [::]) && push_invariant [::] by [].\nelim: n 0 [::] => [|n ihn] m ss hss1 hss2; first exact: pop_stable.\napply/ihn/push_stable; last by rewrite /= allrel1l hss1.\nhave: all (gtn m.+1) (flatten ([:: m] :: ss)).\n  by rewrite /= leqnn; apply: sub_all hss1 => ? /leqW.\nelim: ss [:: _] {hss1 hss2} => [|[|? ?] ? ihss] //= ? ?.\nby rewrite ihss //= all_cat all_merge -andbA andbCA -!all_cat.\nQed.",
    "Lemma sort_pairwise_stable T (leT leT' : rel T) :\n  total leT -> forall s : seq T, pairwise leT' s ->\n  sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (sort leT s).\nProof.\nmove=> leT_total s pairwise_s; case Ds: s => // [x s1].\nrewrite -{s1}Ds -(mkseq_nth x s) sort_map.\napply/homo_sorted_in/sort_iota_stable/(fun _ _ => leT_total _ _)/allss => y z.\nrewrite !mem_sort !mem_iota !leq0n add0n /= => ys zs /andP [->] /=.\nby case: (leT _ _); first apply: pairwiseP.\nQed.",
    "Lemma sort_stable T (leT leT' : rel T) :\n  total leT -> transitive leT' -> forall s : seq T, sorted leT' s ->\n  sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (sort leT s).\nProof.\nmove=> leT_total leT'_tr s; rewrite sorted_pairwise //.\nexact: sort_pairwise_stable.\nQed.",
    "Lemma sort_stable_in T (P : {pred T}) (leT leT' : rel T) :\n  {in P &, total leT} -> {in P & &, transitive leT'} ->\n  forall s : seq T, all P s -> sorted leT' s ->\n  sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (sort leT s).\nProof.\nmove=> /in2_sig leT_total /in3_sig leT_tr _ /all_sigP[s ->].\nby rewrite sort_map !sorted_map; apply: sort_stable.\nQed.",
    "Lemma filter_sort T (leT : rel T) :\n  total leT -> transitive leT ->\n  forall p s, filter p (sort leT s) = sort leT (filter p s).\nProof.\nmove=> leT_total leT_tr p s; case Ds: s => // [x s1].\npose leN := relpre (nth x s) leT.\npose lt_lex := [rel n m | leN n m && (leN m n ==> (n < m))].\nhave lt_lex_tr: transitive lt_lex.\n  rewrite /lt_lex /leN => ? ? ? /= /andP [xy xy'] /andP [yz yz'].\n  rewrite (leT_tr _ _ _ xy yz); apply/implyP => zx; move: xy' yz'.\n  by rewrite (leT_tr _ _ _ yz zx) (leT_tr _ _ _ zx xy); apply: ltn_trans.\nrewrite -{s1}Ds -(mkseq_nth x s) !(filter_map, sort_map); congr map.\napply/(@irr_sorted_eq _ lt_lex); rewrite /lt_lex /leN //=.\n- by move=> ?; rewrite /= ltnn implybF andbN.\n- exact/sorted_filter/sort_iota_stable.\n- exact/sort_stable/sorted_filter/iota_ltn_sorted/ltn_trans/ltn_trans.\n- by move=> ?; rewrite !(mem_filter, mem_sort).\nQed.",
    "Lemma filter_sort_in T (P : {pred T}) (leT : rel T) :\n  {in P &, total leT} -> {in P & &, transitive leT} ->\n  forall p s, all P s -> filter p (sort leT s) = sort leT (filter p s).\nProof.\nmove=> /in2_sig leT_total /in3_sig leT_tr p _ /all_sigP[s ->].\nby rewrite !(sort_map, filter_map) filter_sort.\nQed.",
    "Lemma mask_sort s m :\n  {m_s : bitseq | mask m_s (sort leT s) = sort leT (mask m s)}.\nProof.\ncase Ds: {-}s => [|x s1]; [by rewrite Ds; case: m; exists [::] | clear s1 Ds].\nrewrite -(mkseq_nth x s) -map_mask !sort_map.\nexists [seq i \\in mask m (iota 0 (size s)) |\n            i <- sort (xrelpre (nth x s) leT) (iota 0 (size s))].\nrewrite -map_mask -filter_mask [in RHS]mask_filter ?iota_uniq ?filter_sort //.\nby move=> ? ? ?; exact: leT_tr.\nQed.",
    "Lemma sorted_mask_sort s m :\n  sorted leT (mask m s) -> {m_s | mask m_s (sort leT s) = mask m s}.\nProof. by move/(sorted_sort leT_tr) <-; exact: mask_sort. Qed.",
    "Lemma mask_sort_in s m :\n  all P s -> {m_s : bitseq | mask m_s (sort leT s) = sort leT (mask m s)}.\nProof.\nmove=> /all_sigP [{}s ->]; case: (mask_sort (leT := le_sT) _ _ s m) => //.\nby move=> m' m'E; exists m'; rewrite -map_mask !sort_map -map_mask m'E.\nQed.",
    "Lemma sorted_mask_sort_in s m :\n  all P s -> sorted leT (mask m s) -> {m_s | mask m_s (sort leT s) = mask m s}.\nProof.\nmove=> ? /(sorted_sort_in leT_tr _) <-; [exact: mask_sort_in | exact: all_mask].\nQed.",
    "Lemma subseq_sort : {homo sort leT : t s / subseq t s}.\nProof.\nmove=> _ s /subseqP [m _ ->]; have [m' <-] := mask_sort leT_total leT_tr s m.\nexact: mask_subseq.\nQed.",
    "Lemma sorted_subseq_sort t s :\n  subseq t s -> sorted leT t -> subseq t (sort leT s).\nProof. by move=> subseq_ts /(sorted_sort leT_tr) <-; exact: subseq_sort. Qed.",
    "Lemma mem2_sort s x y : leT x y -> mem2 s x y -> mem2 (sort leT s) x y.\nProof.\nmove=> lexy /[!mem2E] /subseq_sort.\nby case: eqP => // _; rewrite {1}/sort /= lexy /=.\nQed.",
    "Lemma subseq_sort_in t s :\n  {in s &, total leT} -> {in s & &, transitive leT} ->\n  subseq t s -> subseq (sort leT t) (sort leT s).\nProof.\nmove=> leT_total leT_tr /subseqP [m _ ->].\nhave [m' <-] := mask_sort_in leT_total leT_tr m (allss _).\nexact: mask_subseq.\nQed.",
    "Lemma sorted_subseq_sort_in t s :\n  {in s &, total leT} -> {in s & &, transitive leT} ->\n  subseq t s -> sorted leT t -> subseq t (sort leT s).\nProof.\nmove=> ? leT_tr ? /(sorted_sort_in leT_tr) <-; last exact/allP/mem_subseq.\nexact: subseq_sort_in.\nQed.",
    "Lemma mem2_sort_in s :\n  {in s &, total leT} -> {in s & &, transitive leT} ->\n  forall x y, leT x y -> mem2 s x y -> mem2 (sort leT s) x y.\nProof.\nmove=> leT_total leT_tr x y lexy; rewrite !mem2E.\nby move/subseq_sort_in; case: (_ == _); rewrite /sort /= ?lexy; apply.\nQed.",
    "Lemma sort_sorted T (leT : rel T) :\n  total leT -> forall s, sorted leT (sort leT s).\nProof.\nmove=> leT_total s; apply/sub_sorted/sort_stable => //= [? ? /andP[] //|].\nby case: s => // x s; elim: s x => /=.\nQed.",
    "Lemma sort_sorted_in T (P : {pred T}) (leT : rel T) :\n  {in P &, total leT} -> forall s : seq T, all P s -> sorted leT (sort leT s).\nProof.\nby move=> /in2_sig ? _ /all_sigP[s ->]; rewrite sort_map sorted_map sort_sorted.\nQed.",
    "Lemma perm_sortP (T : eqType) (leT : rel T) :\n  total leT -> transitive leT -> antisymmetric leT ->\n  forall s1 s2, reflect (sort leT s1 = sort leT s2) (perm_eq s1 s2).\nProof.\nmove=> leT_total leT_tr leT_asym s1 s2.\napply: (iffP idP) => eq12; last by rewrite -(perm_sort leT) eq12 perm_sort.\napply: (sorted_eq leT_tr leT_asym); rewrite ?sort_sorted //.\nby rewrite perm_sort (permPl eq12) -(perm_sort leT).\nQed.",
    "Lemma perm_sort_inP (T : eqType) (leT : rel T) (s1 s2 : seq T) :\n  {in s1 &, total leT} -> {in s1 & &, transitive leT} ->\n  {in s1 &, antisymmetric leT} ->\n  reflect (sort leT s1 = sort leT s2) (perm_eq s1 s2).\nProof.\nmove=> /in2_sig leT_total /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_asym.\napply: (iffP idP) => s1s2; last by rewrite -(perm_sort leT) s1s2 perm_sort.\nmove: (s1s2); have /all_sigP[s1' ->] := allss s1.\nhave /all_sigP[{s1s2}s2 ->] : all [in s1] s2 by rewrite -(perm_all _ s1s2).\nby rewrite !sort_map => /(perm_map_inj val_inj) /(perm_sortP leT_total)->.\nQed.",
    "Lemma homo_sort_map (T : Type) (T' : eqType) (f : T -> T') leT leT' :\n  antisymmetric (relpre f leT') -> transitive (relpre f leT') -> total leT ->\n  {homo f : x y / leT x y >-> leT' x y} ->\n  forall s : seq T, sort leT' (map f s) = map f (sort leT s).\nProof.\nmove=> leT'_asym leT'_trans leT_total f_homo s; case Ds: s => // [x s'].\nrewrite -{}Ds -(mkseq_nth x s) [in RHS]sort_map -!map_comp /comp.\napply: (@sorted_eq_in _ leT') => [? ? ?|? ?|||]; rewrite ?mem_sort.\n- by move=> /mapP[? _ ->] /mapP[? _ ->] /mapP[? _ ->]; apply/leT'_trans.\n- by move=> /mapP[? _ ->] /mapP[? _ ->] /leT'_asym ->.\n- apply: (sort_sorted_in _ (allss _)) => _ _ /mapP[y _ ->] /mapP[z _ ->].\n  by case/orP: (leT_total (nth x s y) (nth x s z)) => /f_homo ->; rewrite ?orbT.\n- by rewrite map_comp -sort_map; exact/homo_sorted/sort_sorted.\n- by rewrite perm_sort perm_map // perm_sym perm_sort.\nQed.",
    "Lemma homo_sort_map_in\n      (T : Type) (T' : eqType) (P : {pred T}) (f : T -> T') leT leT' :\n  {in P &, antisymmetric (relpre f leT')} ->\n  {in P & &, transitive (relpre f leT')} -> {in P &, total leT} ->\n  {in P &, {homo f : x y / leT x y >-> leT' x y}} ->\n  forall s : seq T, all P s ->\n        sort leT' [seq f x | x <- s] = [seq f x | x <- sort leT s].\nProof.\nmove=> /in2_sig leT'_asym /in3_sig leT'_trans /in2_sig leT_total.\nmove=> /in2_sig f_homo _ /all_sigP[s ->].\nrewrite [in RHS]sort_map -!map_comp /comp.\nby apply: homo_sort_map => // ? ? /leT'_asym /val_inj.\nQed.",
    "Lemma trajectS x n : traject x n.+1 = x :: traject (f x) n.\nProof. by []. Qed.",
    "Lemma trajectSr x n : traject x n.+1 = rcons (traject x n) (iter n f x).\nProof. by elim: n x => //= n IHn x; rewrite IHn -iterSr. Qed.",
    "Lemma last_traject x n : last x (traject (f x) n) = iter n f x.\nProof. by case: n => // n; rewrite iterSr trajectSr last_rcons. Qed.",
    "Lemma traject_iteri x n :\n  traject x n = iteri n (fun i => rcons^~ (iter i f x)) [::].\nProof. by elim: n => //= n <-; rewrite -trajectSr. Qed.",
    "Lemma size_traject x n : size (traject x n) = n.\nProof. by elim: n x => //= n IHn x //=; rewrite IHn. Qed.",
    "Lemma nth_traject i n : i < n -> forall x, nth x (traject x n) i = iter i f x.\nProof.\nelim: n => // n IHn; rewrite ltnS => le_i_n x.\nrewrite trajectSr nth_rcons size_traject.\nby case: ltngtP le_i_n => [? _||->] //; apply: IHn.\nQed.",
    "Lemma trajectD m n x :\n  traject x (m + n) = traject x m ++ traject (iter m f x) n.\nProof. by elim: m => //m IHm in x *; rewrite addSn !trajectS IHm -iterSr. Qed.",
    "Lemma take_traject n k x : k <= n -> take k (traject x n) = traject x k.\nProof. by move=> /subnKC<-; rewrite trajectD take_size_cat ?size_traject. Qed.",
    "Lemma eq_fpath f' : f =1 f' -> fpath f =2 fpath f'.\nProof. by move/eq_frel/eq_path. Qed.",
    "Lemma eq_fcycle f' : f =1 f' -> fcycle f =1 fcycle f'.\nProof. by move/eq_frel/eq_cycle. Qed.",
    "Lemma fpathE x p : fpath f x p -> p = traject f (f x) (size p).\nProof. by elim: p => //= y p IHp in x * => /andP[/eqP{y}<- /IHp<-]. Qed.",
    "Lemma fpathP x p : reflect (exists n, p = traject f (f x) n) (fpath f x p).\nProof.\napply: (iffP idP) => [/fpathE->|[n->]]; first by exists (size p).\nby elim: n => //= n IHn in x *; rewrite eqxx IHn.\nQed.",
    "Lemma fpath_traject x n : fpath f x (traject f (f x) n).\nProof. by apply/(fpathP x); exists n. Qed.",
    "Lemma loopingP x n :\n  reflect (forall m, iter m f x \\in traject f x n) (looping x n).\nProof.\napply: (iffP idP) => loop_n; last exact: loop_n.\ncase: n => // n in loop_n *; elim=> [|m /= IHm]; first exact: mem_head.\nmove: (fpath_traject x n) loop_n; rewrite /looping !iterS -last_traject /=.\nmove: (iter m f x) IHm => y /splitPl[p1 p2 def_y].\nrewrite cat_path last_cat def_y; case: p2 => // z p2 /and3P[_ /eqP-> _] _.\nby rewrite inE mem_cat mem_head !orbT.\nQed.",
    "Lemma trajectP x n y :\n  reflect (exists2 i, i < n & y = iter i f x) (y \\in traject f x n).\nProof.\nelim: n x => [|n IHn] x /=; first by right; case.\nrewrite inE; have [-> | /= neq_xy] := eqP; first by left; exists 0.\napply: {IHn}(iffP (IHn _)) => [[i] | [[|i]]] // lt_i_n ->.\n  by exists i.+1; rewrite ?iterSr.\nby exists i; rewrite ?iterSr.\nQed.",
    "Lemma looping_uniq x n : uniq (traject f x n.+1) = ~~ looping x n.\nProof.\nrewrite /looping; elim: n x => [|n IHn] x //.\nrewrite [n.+1 in LHS]lock [iter]lock /= -!lock {}IHn -iterSr -negb_or inE.\ncongr (~~ _); apply: orb_id2r => /trajectP no_loop.\napply/idP/eqP => [/trajectP[m le_m_n def_x] | {1}<-]; last first.\n  by rewrite iterSr -last_traject mem_last.\nhave loop_m: looping x m.+1 by rewrite /looping iterSr -def_x mem_head.\nhave/trajectP[[|i] // le_i_m def_fn1x] := loopingP _ _ loop_m n.+1.\nby case: no_loop; exists i; rewrite -?iterSr // -ltnS (leq_trans le_i_m).\nQed.",
    "Lemma nextE (x : T) (p_x : x \\in p) : next p x = f x.\nProof. exact/esym/eqP/(next_cycle f_p). Qed.",
    "Lemma mem_fcycle : {homo f : x / x \\in p}.\nProof. by move=> x xp; rewrite -nextE// mem_next. Qed.",
    "Lemma inj_cycle : {in p &, injective f}.\nProof.\napply: can_in_inj (iter (size p).-1 f) _ => x /rot_to[i q rip].\nhave /fpathE qxE : fcycle f (x :: q) by rewrite -rip rot_cycle.\nhave -> : size p = size (rcons q x) by rewrite size_rcons -(size_rot i) rip.\nby rewrite -iterSr -last_traject prednK -?qxE ?size_rcons// last_rcons.\nQed.",
    "Lemma prev_next : cancel (next p) (prev p).\nProof.\nmove=> x; rewrite prev_nth mem_next next_nth; case p_x: (x \\in p) => //.\ncase Dp: p Up p_x => // [y q]; rewrite [uniq _]/= -Dp => /andP[q'y Uq] p_x.\nrewrite -[RHS](nth_index y p_x); congr (nth y _ _); set i := index x p.\nhave: i <= size q by rewrite -index_mem -/i Dp in p_x.\ncase: ltngtP => // [lt_i_q|->] _; first by rewrite index_uniq.\nby apply/eqP; rewrite nth_default // eqn_leq index_size leqNgt index_mem.\nQed.",
    "Lemma next_prev : cancel (prev p) (next p).\nProof.\nmove=> x; rewrite next_nth mem_prev prev_nth; case p_x: (x \\in p) => //.\ncase def_p: p p_x => // [y q]; rewrite -def_p => p_x.\nrewrite index_uniq //; last by rewrite def_p ltnS index_size.\ncase q_x: (x \\in q); first exact: nth_index.\nrewrite nth_default; last by rewrite leqNgt index_mem q_x.\nby apply/eqP; rewrite def_p inE q_x orbF eq_sym in p_x.\nQed.",
    "Lemma cycle_next : fcycle (next p) p.\nProof.\ncase def_p: p Up => [|x q] Uq //; rewrite -[in next _]def_p.\napply/(pathP x)=> i; rewrite size_rcons => le_i_q.\nrewrite -cats1 -cat_cons nth_cat le_i_q /= next_nth {}def_p mem_nth //.\nrewrite index_uniq // nth_cat /= ltn_neqAle andbC -ltnS le_i_q.\nby case: (i =P _) => //= ->; rewrite subnn nth_default.\nQed.",
    "Lemma cycle_prev : cycle (fun x y => x == prev p y) p.\nProof.\napply: etrans cycle_next; symmetry; case def_p: p => [|x q] //.\nby apply: eq_path; rewrite -def_p; apply: (can2_eq prev_next next_prev).\nQed.",
    "Lemma cycle_from_next : (forall x, x \\in p -> e x (next p x)) -> cycle e p.\nProof.\ncase: p (next p) cycle_next => //= [x q] n; rewrite -(belast_rcons x q x).\nmove: {q}(rcons q x) => q n_q /allP.\nby elim: q x n_q => //= _ q IHq x /andP[/eqP <- n_q] /andP[-> /IHq->].\nQed.",
    "Lemma cycle_from_prev : (forall x, x \\in p -> e (prev p x) x) -> cycle e p.\nProof.\nmove=> e_p; apply: cycle_from_next => x.\nby rewrite -mem_next => /e_p; rewrite prev_next.\nQed.",
    "Lemma next_rot : next (rot n0 p) =1 next p.\nProof.\nmove=> x; have n_p := cycle_next; rewrite -(rot_cycle n0) in n_p.\ncase p_x: (x \\in p); last by rewrite !next_nth mem_rot p_x.\nby rewrite (eqP (next_cycle n_p _)) ?mem_rot.\nQed.",
    "Lemma prev_rot : prev (rot n0 p) =1 prev p.\nProof.\nmove=> x; have p_p := cycle_prev; rewrite -(rot_cycle n0) in p_p.\ncase p_x: (x \\in p); last by rewrite !prev_nth mem_rot p_x.\nby rewrite (eqP (prev_cycle p_p _)) ?mem_rot.\nQed.",
    "Lemma next_rotr : next (rotr n0 p) =1 next p. Proof. exact: next_rot. Qed.",
    "Lemma prev_rotr : prev (rotr n0 p) =1 prev p. Proof. exact: prev_rot. Qed.",
    "Lemma prev_rev p : uniq p -> prev (rev p) =1 next p.\nProof.\nmove=> Up x; case p_x: (x \\in p); last first.\n  by rewrite next_nth prev_nth mem_rev p_x.\ncase/rot_to: p_x (Up) => [i q def_p] Urp; rewrite -rev_uniq in Urp.\nrewrite -(prev_rotr i Urp); do 2 rewrite -(prev_rotr 1) ?rotr_uniq //.\nrewrite -rev_rot -(next_rot i Up) {i p Up Urp}def_p.\nby case: q => // y q; rewrite !rev_cons !(=^~ rcons_cons, rotr1_rcons) /= eqxx.\nQed.",
    "Lemma next_rev p : uniq p -> next (rev p) =1 prev p.\nProof. by move=> Up x; rewrite -[p in RHS]revK prev_rev // rev_uniq. Qed.",
    "Lemma map_path b x' p' (Bb : rel_base b) :\n    ~~ has (preim h b) (belast x' p') ->\n  path e (h x') (map h p') = path e' x' p'.\nProof. by elim: p' x' => [|y' p' IHp'] x' //= /norP[/Bb-> /IHp'->]. Qed.",
    "Lemma mem2_map x' y' p' : mem2 (map h p') (h x') (h y') = mem2 p' x' y'.\nProof. by rewrite [LHS]/mem2 (index_map Ih) -map_drop mem_map. Qed.",
    "Lemma next_map p : uniq p -> forall x, next (map h p) (h x) = h (next p x).\nProof.\nmove=> Up x; case p_x: (x \\in p); last by rewrite !next_nth (mem_map Ih) p_x.\ncase/rot_to: p_x => i p' def_p.\nrewrite -(next_rot i Up); rewrite -(map_inj_uniq Ih) in Up.\nrewrite -(next_rot i Up) -map_rot {i p Up}def_p /=.\nby case: p' => [|y p''] //=; rewrite !eqxx.\nQed.",
    "Lemma prev_map p : uniq p -> forall x, prev (map h p) (h x) = h (prev p x).\nProof.\nmove=> Up x; rewrite -[x in LHS](next_prev Up) -(next_map Up).\nby rewrite prev_next ?map_inj_uniq.\nQed.",
    "Lemma arc_rot i p : uniq p -> {in p, arc (rot i p) =2 arc p}.\nProof.\nmove=> Up x p_x y; congr (fun q => take (index y q) q); move: Up p_x {y}.\nrewrite -{1 2 5 6}(cat_take_drop i p) /rot cat_uniq => /and3P[_ Up12 _].\nrewrite !drop_cat !take_cat !index_cat mem_cat orbC.\ncase p2x: (x \\in drop i p) => /= => [_ | p1x].\n  rewrite index_mem p2x [x \\in _](negbTE (hasPn Up12 _ p2x)) /= addKn.\n  by rewrite ltnNge leq_addr catA.\nby rewrite p1x index_mem p1x addKn ltnNge leq_addr /= catA.\nQed.",
    "Lemma left_arc x y p1 p2 (p := x :: p1 ++ y :: p2) :\n  uniq p -> arc p x y = x :: p1.\nProof.\nrewrite /arc /p [index x _]/= eqxx rot0 -cat_cons cat_uniq index_cat.\nmove: (x :: p1) => xp1 /and3P[_ /norP[/= /negbTE-> _] _].\nby rewrite eqxx addn0 take_size_cat.\nQed.",
    "Lemma right_arc x y p1 p2 (p := x :: p1 ++ y :: p2) :\n  uniq p -> arc p y x = y :: p2.\nProof.\nrewrite -[p]cat_cons -rot_size_cat rot_uniq => Up.\nby rewrite arc_rot ?left_arc ?mem_head.\nQed.",
    "Lemma rot_to_arc p x y :\n  uniq p -> x \\in p -> y \\in p -> x != y -> rot_to_arc_spec p x y.\nProof.\nmove=> Up p_x p_y ne_xy; case: (rot_to p_x) (p_y) (Up) => [i q def_p] q_y.\nrewrite -(mem_rot i) def_p inE eq_sym (negbTE ne_xy) in q_y.\nrewrite -(rot_uniq i) def_p.\ncase/splitPr: q / q_y def_p => q1 q2 def_p Uq12; exists i q1 q2 => //.\n  by rewrite -(arc_rot i Up p_x) def_p left_arc.\nby rewrite -(arc_rot i Up p_y) def_p right_arc.\nQed.",
    "Lemma size0nil s : size s = 0 -> s = [::]. Proof. by case: s. Qed.",
    "Lemma nilP s : reflect (s = [::]) (nilp s).\nProof. by case: s => [|x s]; constructor. Qed.",
    "Lemma size_behead s : size (behead s) = (size s).-1.\nProof. by case: s. Qed.",
    "Lemma size_ncons n x s : size (ncons n x s) = n + size s.\nProof. by elim: n => //= n ->. Qed.",
    "Lemma size_nseq n x : size (nseq n x) = n.\nProof. by rewrite size_ncons addn0. Qed.",
    "Lemma cat0s s : [::] ++ s = s. Proof. by []. Qed.",
    "Lemma cat1s x s : [:: x] ++ s = x :: s. Proof. by []. Qed.",
    "Lemma cat_cons x s1 s2 : (x :: s1) ++ s2 = x :: s1 ++ s2. Proof. by []. Qed.",
    "Lemma cat_nseq n x s : nseq n x ++ s = ncons n x s.\nProof. by elim: n => //= n ->. Qed.",
    "Lemma nseqD n1 n2 x : nseq (n1 + n2) x = nseq n1 x ++ nseq n2 x.\nProof. by rewrite cat_nseq /nseq /ncons iterD. Qed.",
    "Lemma cats0 s : s ++ [::] = s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma catA s1 s2 s3 : s1 ++ s2 ++ s3 = (s1 ++ s2) ++ s3.\nProof. by elim: s1 => //= x s1 ->. Qed.",
    "Lemma size_cat s1 s2 : size (s1 ++ s2) = size s1 + size s2.\nProof. by elim: s1 => //= x s1 ->. Qed.",
    "Lemma cat_nilp s1 s2 : nilp (s1 ++ s2) = nilp s1 && nilp s2.\nProof. by case: s1. Qed.",
    "Lemma rcons_cons x s z : rcons (x :: s) z = x :: rcons s z.\nProof. by []. Qed.",
    "Lemma cats1 s z : s ++ [:: z] = rcons s z.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma lastI x s : x :: s = rcons (belast x s) (last x s).\nProof. by elim: s x => [|y s IHs] x //=; rewrite IHs. Qed.",
    "Lemma last_cons x y s : last x (y :: s) = last y s.\nProof. by []. Qed.",
    "Lemma size_rcons s x : size (rcons s x) = (size s).+1.\nProof. by rewrite -cats1 size_cat addnC. Qed.",
    "Lemma size_belast x s : size (belast x s) = size s.\nProof. by elim: s x => [|y s IHs] x //=; rewrite IHs. Qed.",
    "Lemma last_cat x s1 s2 : last x (s1 ++ s2) = last (last x s1) s2.\nProof. by elim: s1 x => [|y s1 IHs] x //=; rewrite IHs. Qed.",
    "Lemma last_rcons x s z : last x (rcons s z) = z.\nProof. by rewrite -cats1 last_cat. Qed.",
    "Lemma belast_cat x s1 s2 :\n  belast x (s1 ++ s2) = belast x s1 ++ belast (last x s1) s2.\nProof. by elim: s1 x => [|y s1 IHs] x //=; rewrite IHs. Qed.",
    "Lemma belast_rcons x s z : belast x (rcons s z) = x :: s.\nProof. by rewrite lastI -!cats1 belast_cat. Qed.",
    "Lemma cat_rcons x s1 s2 : rcons s1 x ++ s2 = s1 ++ x :: s2.\nProof. by rewrite -cats1 -catA. Qed.",
    "Lemma rcons_cat x s1 s2 : rcons (s1 ++ s2) x = s1 ++ rcons s2 x.\nProof. by rewrite -!cats1 catA. Qed.",
    "Lemma lastP s : last_spec s.\nProof. case: s => [|x s]; [left | rewrite lastI; right]. Qed.",
    "Lemma last_ind P :\n  P [::] -> (forall s x, P s -> P (rcons s x)) -> forall s, P s.\nProof.\nmove=> Hnil Hlast s; rewrite -(cat0s s).\nelim: s [::] Hnil => [|x s2 IHs] s1 Hs1; first by rewrite cats0.\nby rewrite -cat_rcons; apply/IHs/Hlast.\nQed.",
    "Lemma nth0 s : nth s 0 = head s. Proof. by []. Qed.",
    "Lemma nth_default s n : size s <= n -> nth s n = x0.\nProof. by elim: s n => [|x s IHs] []. Qed.",
    "Lemma if_nth s b n : b || (size s <= n) ->\n  (if b then nth s n else x0) = nth s n.\nProof. by case: leqP; case: ifP => //= *; rewrite nth_default. Qed.",
    "Lemma nth_nil n : nth [::] n = x0.\nProof. by case: n. Qed.",
    "Lemma nth_seq1 n x : nth [:: x] n = if n == 0 then x else x0.\nProof. by case: n => [|[]]. Qed.",
    "Lemma last_nth x s : last x s = nth (x :: s) (size s).\nProof. by elim: s x => [|y s IHs] x /=. Qed.",
    "Lemma nth_last s : nth s (size s).-1 = last x0 s.\nProof. by case: s => //= x s; rewrite last_nth. Qed.",
    "Lemma nth_behead s n : nth (behead s) n = nth s n.+1.\nProof. by case: s n => [|x s] [|n]. Qed.",
    "Lemma nth_cat s1 s2 n :\n  nth (s1 ++ s2) n = if n < size s1 then nth s1 n else nth s2 (n - size s1).\nProof. by elim: s1 n => [|x s1 IHs] []. Qed.",
    "Lemma nth_rcons s x n :\n  nth (rcons s x) n =\n    if n < size s then nth s n else if n == size s then x else x0.\nProof. by elim: s n => [|y s IHs] [] //=; apply: nth_nil. Qed.",
    "Lemma nth_rcons_default s i : nth (rcons s x0) i = nth s i.\nProof.\nby rewrite nth_rcons; case: ltngtP => //[/ltnW ?|->]; rewrite nth_default.\nQed.",
    "Lemma nth_ncons m x s n :\n  nth (ncons m x s) n = if n < m then x else nth s (n - m).\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma nth_nseq m x n : nth (nseq m x) n = (if n < m then x else x0).\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma eq_from_nth s1 s2 :\n    size s1 = size s2 -> (forall i, i < size s1 -> nth s1 i = nth s2 i) ->\n  s1 = s2.\nProof.\nelim: s1 s2 => [|x1 s1 IHs1] [|x2 s2] //= [eq_sz] eq_s12.\nby rewrite [x1](eq_s12 0) // (IHs1 s2) // => i; apply: (eq_s12 i.+1).\nQed.",
    "Lemma size_set_nth s n y : size (set_nth s n y) = maxn n.+1 (size s).\nProof.\nrewrite maxnC; elim: s n => [|x s IHs] [|n] //=.\n- by rewrite size_ncons addn1.\n- by rewrite IHs maxnSS.\nQed.",
    "Lemma set_nth_nil n y : set_nth [::] n y = ncons n x0 [:: y].\nProof. by case: n. Qed.",
    "Lemma nth_set_nth s n y : nth (set_nth s n y) =1 [eta nth s with n |-> y].\nProof.\nelim: s n => [|x s IHs] [|n] [|m] //=; rewrite ?nth_nil ?IHs // nth_ncons eqSS.\ncase: ltngtP => // [lt_nm | ->]; last by rewrite subnn.\nby rewrite nth_default // subn_gt0.\nQed.",
    "Lemma set_set_nth s n1 y1 n2 y2 (s2 := set_nth s n2 y2) :\n  set_nth (set_nth s n1 y1) n2 y2 = if n1 == n2 then s2 else set_nth s2 n1 y1.\nProof.\nhave [-> | ne_n12] := eqVneq.\n  apply: eq_from_nth => [|i _]; first by rewrite !size_set_nth maxnA maxnn.\n  by do 2!rewrite !nth_set_nth /=; case: eqP.\napply: eq_from_nth => [|i _]; first by rewrite !size_set_nth maxnCA.\nby do 2!rewrite !nth_set_nth /=; case: eqP => // ->; case: eqVneq ne_n12.\nQed.",
    "Lemma size_filter s : size (filter s) = count s.\nProof. by elim: s => //= x s <-; case (a x). Qed.",
    "Lemma has_count s : has s = (0 < count s).\nProof. by elim: s => //= x s ->; case (a x). Qed.",
    "Lemma count_size s : count s <= size s.\nProof. by elim: s => //= x s; case: (a x); last apply: leqW. Qed.",
    "Lemma all_count s : all s = (count s == size s).\nProof.\nelim: s => //= x s; case: (a x) => _ //=.\nby rewrite add0n eqn_leq andbC ltnNge count_size.\nQed.",
    "Lemma filter_all s : all (filter s).\nProof. by elim: s => //= x s IHs; case: ifP => //= ->. Qed.",
    "Lemma all_filterP s : reflect (filter s = s) (all s).\nProof.\napply: (iffP idP) => [| <-]; last exact: filter_all.\nby elim: s => //= x s IHs /andP[-> Hs]; rewrite IHs.\nQed.",
    "Lemma filter_id s : filter (filter s) = filter s.\nProof. by apply/all_filterP; apply: filter_all. Qed.",
    "Lemma has_find s : has s = (find s < size s).\nProof. by elim: s => //= x s IHs; case (a x); rewrite ?leqnn. Qed.",
    "Lemma find_size s : find s <= size s.\nProof. by elim: s => //= x s IHs; case (a x). Qed.",
    "Lemma find_cat s1 s2 :\n  find (s1 ++ s2) = if has s1 then find s1 else size s1 + find s2.\nProof.\nby elim: s1 => //= x s1 IHs; case: (a x) => //; rewrite IHs (fun_if succn).\nQed.",
    "Lemma has_nil : has [::] = false. Proof. by []. Qed.",
    "Lemma has_seq1 x : has [:: x] = a x.\nProof. exact: orbF. Qed.",
    "Lemma has_nseq n x : has (nseq n x) = (0 < n) && a x.\nProof. by elim: n => //= n ->; apply: andKb. Qed.",
    "Lemma has_seqb (b : bool) x : has (nseq b x) = b && a x.\nProof. by rewrite has_nseq lt0b. Qed.",
    "Lemma all_nil : all [::] = true. Proof. by []. Qed.",
    "Lemma all_seq1 x : all [:: x] = a x.\nProof. exact: andbT. Qed.",
    "Lemma all_nseq n x : all (nseq n x) = (n == 0) || a x.\nProof. by elim: n => //= n ->; apply: orKb. Qed.",
    "Lemma all_nseqb (b : bool) x : all (nseq b x) = b ==> a x.\nProof. by rewrite all_nseq eqb0 implybE. Qed.",
    "Lemma filter_nseq n x : filter (nseq n x) = nseq (a x * n) x.\nProof. by elim: n => /= [|n ->]; case: (a x). Qed.",
    "Lemma count_nseq n x : count (nseq n x) = a x * n.\nProof. by rewrite -size_filter filter_nseq size_nseq. Qed.",
    "Lemma find_nseq n x : find (nseq n x) = ~~ a x * n.\nProof. by elim: n => /= [|n ->]; case: (a x). Qed.",
    "Lemma nth_find s : has s -> a (nth s (find s)).\nProof. by elim: s => //= x s IHs; case a_x: (a x). Qed.",
    "Lemma before_find s i : i < find s -> a (nth s i) = false.\nProof. by elim: s i => //= x s IHs; case: ifP => // a'x [|i] // /(IHs i). Qed.",
    "Lemma hasNfind s : ~~ has s -> find s = size s.\nProof. by rewrite has_find; case: ltngtP (find_size s). Qed.",
    "Lemma filter_cat s1 s2 : filter (s1 ++ s2) = filter s1 ++ filter s2.\nProof. by elim: s1 => //= x s1 ->; case (a x). Qed.",
    "Lemma filter_rcons s x :\n  filter (rcons s x) = if a x then rcons (filter s) x else filter s.\nProof. by rewrite -!cats1 filter_cat /=; case (a x); rewrite /= ?cats0. Qed.",
    "Lemma count_cat s1 s2 : count (s1 ++ s2) = count s1 + count s2.\nProof. by rewrite -!size_filter filter_cat size_cat. Qed.",
    "Lemma has_cat s1 s2 : has (s1 ++ s2) = has s1 || has s2.\nProof. by elim: s1 => [|x s1 IHs] //=; rewrite IHs orbA. Qed.",
    "Lemma has_rcons s x : has (rcons s x) = a x || has s.\nProof. by rewrite -cats1 has_cat has_seq1 orbC. Qed.",
    "Lemma all_cat s1 s2 : all (s1 ++ s2) = all s1 && all s2.\nProof. by elim: s1 => [|x s1 IHs] //=; rewrite IHs andbA. Qed.",
    "Lemma all_rcons s x : all (rcons s x) = a x && all s.\nProof. by rewrite -cats1 all_cat all_seq1 andbC. Qed.",
    "Lemma find_pred0 s : find pred0 s = size s. Proof. by []. Qed.",
    "Lemma find_predT s : find predT s = 0.\nProof. by case: s. Qed.",
    "Lemma eq_find a1 a2 : a1 =1 a2 -> find a1 =1 find a2.\nProof. by move=> Ea; elim=> //= x s IHs; rewrite Ea IHs. Qed.",
    "Lemma eq_filter a1 a2 : a1 =1 a2 -> filter a1 =1 filter a2.\nProof. by move=> Ea; elim=> //= x s IHs; rewrite Ea IHs. Qed.",
    "Lemma eq_count a1 a2 : a1 =1 a2 -> count a1 =1 count a2.\nProof. by move=> Ea s; rewrite -!size_filter (eq_filter Ea). Qed.",
    "Lemma eq_has a1 a2 : a1 =1 a2 -> has a1 =1 has a2.\nProof. by move=> Ea s; rewrite !has_count (eq_count Ea). Qed.",
    "Lemma eq_all a1 a2 : a1 =1 a2 -> all a1 =1 all a2.\nProof. by move=> Ea s; rewrite !all_count (eq_count Ea). Qed.",
    "Lemma all_filter (p q : pred T) xs :\n  all p (filter q xs) = all [pred i | q i ==> p i] xs.\nProof. by elim: xs => //= x xs <-; case: (q x). Qed.",
    "Lemma sub_find s : find a2 s <= find a1 s.\nProof. by elim: s => //= x s IHs; case: ifP => // /(contraFF (@s12 x))->. Qed.",
    "Lemma sub_has s : has a1 s -> has a2 s.\nProof. by rewrite !has_find; apply: leq_ltn_trans (sub_find s). Qed.",
    "Lemma sub_count s : count a1 s <= count a2 s.\nProof.\nby elim: s => //= x s; apply: leq_add; case a1x: (a1 x); rewrite // s12.\nQed.",
    "Lemma sub_all s : all a1 s -> all a2 s.\nProof.\nby rewrite !all_count !eqn_leq !count_size => /leq_trans-> //; apply: sub_count.\nQed.",
    "Lemma filter_pred0 s : filter pred0 s = [::]. Proof. by elim: s. Qed.",
    "Lemma filter_predT s : filter predT s = s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma filter_predI a1 a2 s : filter (predI a1 a2) s = filter a1 (filter a2 s).\nProof. by elim: s => //= x s ->; rewrite andbC; case: (a2 x). Qed.",
    "Lemma count_pred0 s : count pred0 s = 0.\nProof. by rewrite -size_filter filter_pred0. Qed.",
    "Lemma count_predT s : count predT s = size s.\nProof. by rewrite -size_filter filter_predT. Qed.",
    "Lemma count_predUI a1 a2 s :\n  count (predU a1 a2) s + count (predI a1 a2) s = count a1 s + count a2 s.\nProof.\nelim: s => //= x s IHs; rewrite /= addnACA [RHS]addnACA IHs.\nby case: (a1 x) => //; rewrite addn0.\nQed.",
    "Lemma count_predC a s : count a s + count (predC a) s = size s.\nProof. by elim: s => //= x s IHs; rewrite addnACA IHs; case: (a _). Qed.",
    "Lemma count_filter a1 a2 s : count a1 (filter a2 s) = count (predI a1 a2) s.\nProof. by rewrite -!size_filter filter_predI. Qed.",
    "Lemma has_pred0 s : has pred0 s = false.\nProof. by rewrite has_count count_pred0. Qed.",
    "Lemma has_predT s : has predT s = (0 < size s).\nProof. by rewrite has_count count_predT. Qed.",
    "Lemma has_predC a s : has (predC a) s = ~~ all a s.\nProof. by elim: s => //= x s ->; case (a x). Qed.",
    "Lemma has_predU a1 a2 s : has (predU a1 a2) s = has a1 s || has a2 s.\nProof. by elim: s => //= x s ->; rewrite -!orbA; do !bool_congr. Qed.",
    "Lemma all_pred0 s : all pred0 s = (size s == 0).\nProof. by rewrite all_count count_pred0 eq_sym. Qed.",
    "Lemma all_predT s : all predT s.\nProof. by rewrite all_count count_predT. Qed.",
    "Lemma allT (a : pred T) s : (forall x, a x) -> all a s.\nProof. by move/eq_all->; apply/all_predT. Qed.",
    "Lemma all_predC a s : all (predC a) s = ~~ has a s.\nProof. by elim: s => //= x s ->; case (a x). Qed.",
    "Lemma all_predI a1 a2 s : all (predI a1 a2) s = all a1 s && all a2 s.\nProof.\napply: (can_inj negbK); rewrite negb_and -!has_predC -has_predU.\nby apply: eq_has => x; rewrite /= negb_and.\nQed.",
    "Lemma drop_behead : drop n0 =1 iter n0 behead.\nProof. by elim: n0 => [|n IHn] [|x s] //; rewrite iterSr -IHn. Qed.",
    "Lemma drop0 s : drop 0 s = s. Proof. by case: s. Qed.",
    "Lemma drop1 : drop 1 =1 behead. Proof. by case=> [|x [|y s]]. Qed.",
    "Lemma drop_oversize n s : size s <= n -> drop n s = [::].\nProof. by elim: s n => [|x s IHs] []. Qed.",
    "Lemma drop_size s : drop (size s) s = [::].\nProof. by rewrite drop_oversize // leqnn. Qed.",
    "Lemma drop_cons x s :\n  drop n0 (x :: s) = if n0 is n.+1 then drop n s else x :: s.\nProof. by []. Qed.",
    "Lemma size_drop s : size (drop n0 s) = size s - n0.\nProof. by elim: s n0 => [|x s IHs] []. Qed.",
    "Lemma drop_cat s1 s2 :\n  drop n0 (s1 ++ s2) =\n    if n0 < size s1 then drop n0 s1 ++ s2 else drop (n0 - size s1) s2.\nProof. by elim: s1 n0 => [|x s1 IHs] []. Qed.",
    "Lemma drop_size_cat n s1 s2 : size s1 = n -> drop n (s1 ++ s2) = s2.\nProof. by move <-; elim: s1 => //=; rewrite drop0. Qed.",
    "Lemma nconsK n x : cancel (ncons n x) (drop n).\nProof. by elim: n => // -[]. Qed.",
    "Lemma drop_drop s n1 n2 : drop n1 (drop n2 s) = drop (n1 + n2) s.\nProof. by elim: s n2 => // x s ihs [|n2]; rewrite ?drop0 ?addn0 ?addnS /=. Qed.",
    "Lemma take0 s : take 0 s = [::]. Proof. by case: s. Qed.",
    "Lemma take_oversize n s : size s <= n -> take n s = s.\nProof. by elim: s n => [|x s IHs] [|n] //= /IHs->. Qed.",
    "Lemma take_size s : take (size s) s = s.\nProof. exact: take_oversize. Qed.",
    "Lemma take_cons x s :\n  take n0 (x :: s) = if n0 is n.+1 then x :: (take n s) else [::].\nProof. by []. Qed.",
    "Lemma drop_rcons s : n0 <= size s ->\n  forall x, drop n0 (rcons s x) = rcons (drop n0 s) x.\nProof. by elim: s n0 => [|y s IHs] []. Qed.",
    "Lemma cat_take_drop s : take n0 s ++ drop n0 s = s.\nProof. by elim: s n0 => [|x s IHs] [|n] //=; rewrite IHs. Qed.",
    "Lemma size_takel s : n0 <= size s -> size (take n0 s) = n0.\nProof.\nby move/subKn; rewrite -size_drop -[in size s](cat_take_drop s) size_cat addnK.\nQed.",
    "Lemma size_take s : size (take n0 s) = if n0 < size s then n0 else size s.\nProof.\nhave [le_sn | lt_ns] := leqP (size s) n0; first by rewrite take_oversize.\nby rewrite size_takel // ltnW.\nQed.",
    "Lemma size_take_min s : size (take n0 s) = minn n0 (size s).\nProof. exact: size_take. Qed.",
    "Lemma take_cat s1 s2 :\n  take n0 (s1 ++ s2) =\n    if n0 < size s1 then take n0 s1 else s1 ++ take (n0 - size s1) s2.\nProof.\nelim: s1 n0 => [|x s1 IHs] [|n] //=.\nby rewrite ltnS subSS -(fun_if (cons x)) -IHs.\nQed.",
    "Lemma take_size_cat n s1 s2 : size s1 = n -> take n (s1 ++ s2) = s1.\nProof. by move <-; elim: s1 => [|x s1 IHs]; rewrite ?take0 //= IHs. Qed.",
    "Lemma takel_cat s1 s2 : n0 <= size s1 -> take n0 (s1 ++ s2) = take n0 s1.\nProof.\nby rewrite take_cat; case: ltngtP => // ->; rewrite subnn take0 take_size cats0.\nQed.",
    "Lemma nth_drop s i : nth (drop n0 s) i = nth s (n0 + i).\nProof.\nrewrite -[s in RHS]cat_take_drop nth_cat size_take ltnNge.\ncase: ltnP => [?|le_s_n0]; rewrite ?(leq_trans le_s_n0) ?leq_addr ?addKn //=.\nby rewrite drop_oversize // !nth_default.\nQed.",
    "Lemma find_ltn p s i : has p (take i s) -> find p s < i.\nProof. by elim: s i => [|y s ihs] [|i]//=; case: (p _) => //= /ihs. Qed.",
    "Lemma has_take p s i : has p s -> has p (take i s) = (find p s < i).\nProof. by elim: s i => [|y s ihs] [|i]//=; case: (p _) => //= /ihs ->. Qed.",
    "Lemma has_take_leq (p : pred T) (s : seq T) i : i <= size s ->\n  has p (take i s) = (find p s < i).\nProof. by elim: s i => [|y s ihs] [|i]//=; case: (p _) => //= /ihs ->. Qed.",
    "Lemma nth_take i : i < n0 -> forall s, nth (take n0 s) i = nth s i.\nProof.\nmove=> lt_i_n0 s; case lt_n0_s: (n0 < size s).\n  by rewrite -[s in RHS]cat_take_drop nth_cat size_take lt_n0_s /= lt_i_n0.\nby rewrite -[s in LHS]cats0 take_cat lt_n0_s /= cats0.\nQed.",
    "Lemma take_min i j s : take (minn i j) s = take i (take j s).\nProof. by elim: s i j => //= a l IH [|i] [|j] //=; rewrite minnSS IH. Qed.",
    "Lemma take_takel i j s : i <= j -> take i (take j s) = take i s.\nProof. by move=> ?; rewrite -take_min (minn_idPl _). Qed.",
    "Lemma take_taker i j s : j <= i -> take i (take j s) = take j s.\nProof. by move=> ?; rewrite -take_min (minn_idPr _). Qed.",
    "Lemma take_drop i j s : take i (drop j s) = drop j (take (i + j) s).\nProof. by rewrite addnC; elim: s i j => // x s IHs [|i] [|j] /=. Qed.",
    "Lemma takeD i j s : take (i + j) s = take i s ++ take j (drop i s).\nProof.\nelim: i j s => [|i IHi] [|j] [|a s] //; first by rewrite take0 addn0 cats0.\nby rewrite addSn /= IHi.\nQed.",
    "Lemma takeC i j s : take i (take j s) = take j (take i s).\nProof. by rewrite -!take_min minnC. Qed.",
    "Lemma take_nseq i j x : i <= j -> take i (nseq j x) = nseq i x.\nProof. by move=>/subnKC <-; rewrite nseqD take_size_cat // size_nseq. Qed.",
    "Lemma drop_nseq i j x : drop i (nseq j x) = nseq (j - i) x.\nProof.\ncase: (leqP i j) => [/subnKC {1}<-|/ltnW j_le_i].\n  by rewrite nseqD drop_size_cat // size_nseq.\nby rewrite drop_oversize ?size_nseq // (eqP j_le_i).\nQed.",
    "Lemma drop_nth n s : n < size s -> drop n s = nth s n :: drop n.+1 s.\nProof. by elim: s n => [|x s IHs] [|n] Hn //=; rewrite ?drop0 1?IHs. Qed.",
    "Lemma take_nth n s : n < size s -> take n.+1 s = rcons (take n s) (nth s n).\nProof. by elim: s n => [|x s IHs] //= [|n] Hn /=; rewrite ?take0 -?IHs. Qed.",
    "Lemma rot0 s : rot 0 s = s.\nProof. by rewrite /rot drop0 take0 cats0. Qed.",
    "Lemma size_rot s : size (rot n0 s) = size s.\nProof. by rewrite -[s in RHS]cat_take_drop /rot !size_cat addnC. Qed.",
    "Lemma rot_oversize n s : size s <= n -> rot n s = s.\nProof. by move=> le_s_n; rewrite /rot take_oversize ?drop_oversize. Qed.",
    "Lemma rot_size s : rot (size s) s = s.\nProof. exact: rot_oversize. Qed.",
    "Lemma has_rot s a : has a (rot n0 s) = has a s.\nProof. by rewrite has_cat orbC -has_cat cat_take_drop. Qed.",
    "Lemma rot_size_cat s1 s2 : rot (size s1) (s1 ++ s2) = s2 ++ s1.\nProof. by rewrite /rot take_size_cat ?drop_size_cat. Qed.",
    "Lemma rotK : cancel (rot n0) (rotr n0).\nProof.\nmove=> s; rewrite /rotr size_rot -size_drop {2}/rot.\nby rewrite rot_size_cat cat_take_drop.\nQed.",
    "Lemma rot_inj : injective (rot n0). Proof. exact (can_inj rotK). Qed.",
    "Lemma catrev_catl s t u : catrev (s ++ t) u = catrev t (catrev s u).\nProof. by elim: s u => /=. Qed.",
    "Lemma catrev_catr s t u : catrev s (t ++ u) = catrev s t ++ u.\nProof. by elim: s t => //= x s IHs t; rewrite -IHs. Qed.",
    "Lemma catrevE s t : catrev s t = rev s ++ t.\nProof. by rewrite -catrev_catr. Qed.",
    "Lemma rev_cons x s : rev (x :: s) = rcons (rev s) x.\nProof. by rewrite -cats1 -catrevE. Qed.",
    "Lemma size_rev s : size (rev s) = size s.\nProof. by elim: s => // x s IHs; rewrite rev_cons size_rcons IHs. Qed.",
    "Lemma rev_nilp s : nilp (rev s) = nilp s.\nProof. by rewrite /nilp size_rev. Qed.",
    "Lemma rev_cat s t : rev (s ++ t) = rev t ++ rev s.\nProof. by rewrite -catrev_catr -catrev_catl. Qed.",
    "Lemma rev_rcons s x : rev (rcons s x) = x :: rev s.\nProof. by rewrite -cats1 rev_cat. Qed.",
    "Lemma revK : involutive rev.\nProof. by elim=> //= x s IHs; rewrite rev_cons rev_rcons IHs. Qed.",
    "Lemma nth_rev n s : n < size s -> nth (rev s) n = nth s (size s - n.+1).\nProof.\nelim/last_ind: s => // s x IHs in n *.\nrewrite rev_rcons size_rcons ltnS subSS -cats1 nth_cat /=.\ncase: n => [|n] lt_n_s; first by rewrite subn0 ltnn subnn.\nby rewrite subnSK //= leq_subr IHs.\nQed.",
    "Lemma filter_rev a s : filter a (rev s) = rev (filter a s).\nProof. by elim: s => //= x s IH; rewrite fun_if !rev_cons filter_rcons IH. Qed.",
    "Lemma count_rev a s : count a (rev s) = count a s.\nProof. by rewrite -!size_filter filter_rev size_rev. Qed.",
    "Lemma has_rev a s : has a (rev s) = has a s.\nProof. by rewrite !has_count count_rev. Qed.",
    "Lemma all_rev a s : all a (rev s) = all a s.\nProof. by rewrite !all_count count_rev size_rev. Qed.",
    "Lemma rev_nseq n x : rev (nseq n x) = nseq n x.\nProof. by elim: n => // n IHn; rewrite -[in LHS]addn1 nseqD rev_cat IHn. Qed.",
    "Lemma seq_ind2 {S T} (P : seq S -> seq T -> Type) :\n    P [::] [::] ->\n    (forall x y s t, size s = size t -> P s t -> P (x :: s) (y :: t)) ->\n  forall s t, size s = size t -> P s t.\nProof.\nby move=> Pnil Pcons; elim=> [|x s IHs] [|y t] //= [eq_sz]; apply/Pcons/IHs.\nQed.",
    "Lemma all_iffLR P0 Ps : all_iff P0 Ps ->\n  forall m n, nth P0 (P0 :: Ps) m -> nth P0 (P0 :: Ps) n.\nProof.\nmove=> iffPs; have PsS n: nth P0 Ps n -> nth P0 Ps n.+1.\n  elim: n P0 Ps iffPs => [|n IHn] P0 [|P [|Q Ps]] //= [iP0P] //; first by case.\n    by rewrite nth_nil.\n  by case=> iPQ iffPs; apply: IHn; split=> // /iP0P.\nhave{PsS} lePs: {homo nth P0 Ps : m n / m <= n >-> (m -> n)}.\n  by move=> m n /subnK<-; elim: {n}(n - m) => // n IHn /IHn; apply: PsS.\nmove=> m n P_m; have{m P_m} hP0: P0.\n  case: m P_m => //= m /(lePs m _ (leq_maxl m (size Ps))).\n  by rewrite nth_default ?leq_maxr.\ncase: n =>// n; apply: lePs 0 n (leq0n n) _.\nby case: Ps iffPs hP0 => // P Ps [].\nQed.",
    "Lemma all_iffP P0 Ps :\n   all_iff P0 Ps -> forall m n, nth P0 (P0 :: Ps) m <-> nth P0 (P0 :: Ps) n.\nProof. by move=> /all_iffLR-iffPs m n; split => /iffPs. Qed.",
    "Lemma findP : find_spec (has a s) (find a s).\nProof.\nhave [a_s|aNs] := boolP (has a s); last by rewrite hasNfind//; constructor.\nby constructor=> [|x0|x0]; rewrite -?has_find ?nth_find//; apply: before_find.\nQed.",
    "Lemma rot1_cons x s : rot 1 (x :: s) = rcons s x.\nProof. by rewrite /rot /= take0 drop0 -cats1. Qed.",
    "Lemma rcons_inj s1 s2 x1 x2 :\n  rcons s1 x1 = rcons s2 x2 :> seq T -> (s1, x1) = (s2, x2).\nProof. by rewrite -!rot1_cons => /rot_inj[-> ->]. Qed.",
    "Lemma rcons_injl x : injective (rcons^~ x).\nProof. by move=> s1 s2 /rcons_inj[]. Qed.",
    "Lemma rcons_injr s : injective (rcons s).\nProof. by move=> x1 x2 /rcons_inj[]. Qed.",
    "Lemma eqseqP : Equality.axiom eqseq.\nProof.\nmove; elim=> [|x1 s1 IHs] [|x2 s2]; do [by constructor | simpl].\nhave [<-|neqx] := x1 =P x2; last by right; case.\nby apply: (iffP (IHs s2)) => [<-|[]].\nQed.",
    "Lemma eqseqE : eqseq = eq_op. Proof. by []. Qed.",
    "Lemma eqseq_cons x1 x2 s1 s2 :\n  (x1 :: s1 == x2 :: s2) = (x1 == x2) && (s1 == s2).\nProof. by []. Qed.",
    "Lemma eqseq_cat s1 s2 s3 s4 :\n  size s1 = size s2 -> (s1 ++ s3 == s2 ++ s4) = (s1 == s2) && (s3 == s4).\nProof.\nelim: s1 s2 => [|x1 s1 IHs] [|x2 s2] //= [sz12].\nby rewrite !eqseq_cons -andbA IHs.\nQed.",
    "Lemma eqseq_rcons s1 s2 x1 x2 :\n  (rcons s1 x1 == rcons s2 x2) = (s1 == s2) && (x1 == x2).\nProof. by rewrite -(can_eq revK) !rev_rcons eqseq_cons andbC (can_eq revK). Qed.",
    "Lemma size_eq0 s : (size s == 0) = (s == [::]).\nProof. exact: (sameP nilP eqP). Qed.",
    "Lemma nilpE s : nilp s = (s == [::]). Proof. by case: s. Qed.",
    "Lemma has_filter a s : has a s = (filter a s != [::]).\nProof. by rewrite -size_eq0 size_filter has_count lt0n. Qed.",
    "Lemma in_cons y s x : (x \\in y :: s) = (x == y) || (x \\in s).\nProof. by []. Qed.",
    "Lemma in_nil x : (x \\in [::]) = false.\nProof. by []. Qed.",
    "Lemma mem_seq1 x y : (x \\in [:: y]) = (x == y).\nProof. by rewrite in_cons orbF. Qed.",
    "Lemma forall_cons {P : T -> Prop} {a s} :\n  {in a::s, forall x, P x} <-> P a /\\ {in s, forall x, P x}.\nProof.\nsplit=> [A|[A B]]; last by move => x /predU1P [-> //|]; apply: B.\nby split=> [|b Hb]; apply: A; rewrite !inE ?eqxx ?Hb ?orbT.\nQed.",
    "Lemma exists_cons {P : T -> Prop} {a s} :\n  (exists2 x, x \\in a::s & P x) <-> P a \\/ exists2 x, x \\in s & P x.\nProof.\nsplit=> [[x /predU1P[->|x_s] Px]|]; [by left| by right; exists x|].\nby move=> [?|[x x_s ?]]; [exists a|exists x]; rewrite ?inE ?eqxx ?x_s ?orbT.\nQed.",
    "Lemma mem_seq2 x y z : (x \\in [:: y; z]) = xpred2 y z x.\nProof. by rewrite !inE. Qed.",
    "Lemma mem_seq3 x y z t : (x \\in [:: y; z; t]) = xpred3 y z t x.\nProof. by rewrite !inE. Qed.",
    "Lemma mem_seq4 x y z t u : (x \\in [:: y; z; t; u]) = xpred4 y z t u x.\nProof. by rewrite !inE. Qed.",
    "Lemma mem_cat x s1 s2 : (x \\in s1 ++ s2) = (x \\in s1) || (x \\in s2).\nProof. by elim: s1 => //= y s1 IHs; rewrite !inE /= -orbA -IHs. Qed.",
    "Lemma mem_rcons s y : rcons s y =i y :: s.\nProof. by move=> x; rewrite -cats1 /= mem_cat mem_seq1 orbC in_cons. Qed.",
    "Lemma mem_head x s : x \\in x :: s.\nProof. exact: predU1l. Qed.",
    "Lemma mem_last x s : last x s \\in x :: s.\nProof. by rewrite lastI mem_rcons mem_head. Qed.",
    "Lemma mem_behead s : {subset behead s <= s}.\nProof. by case: s => // y s x; apply: predU1r. Qed.",
    "Lemma mem_belast s y : {subset belast y s <= y :: s}.\nProof. by move=> x ys'x; rewrite lastI mem_rcons mem_behead. Qed.",
    "Lemma mem_nth s n : n < size s -> nth s n \\in s.\nProof.\nby elim: s n => // x s IHs [_|n sz_s]; rewrite ?mem_head // mem_behead ?IHs.\nQed.",
    "Lemma mem_take s x : x \\in take n0 s -> x \\in s.\nProof. by move=> s0x; rewrite -(cat_take_drop n0 s) mem_cat /= s0x. Qed.",
    "Lemma mem_drop s x : x \\in drop n0 s -> x \\in s.\nProof. by move=> s0'x; rewrite -(cat_take_drop n0 s) mem_cat /= s0'x orbT. Qed.",
    "Lemma last_eq s z x y : x != y -> z != y -> (last x s == y) = (last z s == y).\nProof. by move=> /negPf xz /negPf yz; case: s => [|t s]//; rewrite xz yz. Qed.",
    "Lemma hasP {a s} : reflect (exists2 x, x \\in s & a x) (has a s).\nProof.\nelim: s => [|y s IHs] /=; first by right; case.\nexact: equivP (orPP idP IHs) (iff_sym exists_cons).\nQed.",
    "Lemma allP {a s} : reflect {in s, forall x, a x} (all a s).\nProof.\nelim: s => [|/= y s IHs]; first by left.\nexact: equivP (andPP idP IHs) (iff_sym forall_cons).\nQed.",
    "Lemma hasPn a s : reflect {in s, forall x, ~~ a x} (~~ has a s).\nProof. by rewrite -all_predC; apply: allP. Qed.",
    "Lemma allPn a s : reflect (exists2 x, x \\in s & ~~ a x) (~~ all a s).\nProof. by rewrite -has_predC; apply: hasP. Qed.",
    "Lemma allss s : all [in s] s. Proof. exact/allP. Qed.",
    "Lemma mem_filter a x s : (x \\in filter a s) = a x && (x \\in s).\nProof.\nrewrite andbC; elim: s => //= y s IHs.\nrewrite (fun_if (fun s' : seq T => x \\in s')) !in_cons {}IHs.\nby case: eqP => [->|_]; case (a y); rewrite /= ?andbF.\nQed.",
    "Lemma hasPP : reflect (exists2 x, x \\in s & A x) (has a s).\nProof. by apply: (iffP hasP) => -[x ? /aP]; exists x. Qed.",
    "Lemma allPP : reflect {in s, forall x, A x} (all a s).\nProof. by apply: (iffP allP) => a_s x /a_s/aP. Qed.",
    "Lemma eq_in_filter s : {in s, a1 =1 a2} -> filter a1 s = filter a2 s.\nProof. by elim: s => //= x s IHs /forall_cons [-> /IHs ->]. Qed.",
    "Lemma eq_in_find s : {in s, a1 =1 a2} -> find a1 s = find a2 s.\nProof. by elim: s => //= x s IHs /forall_cons [-> /IHs ->]. Qed.",
    "Lemma eq_in_count s : {in s, a1 =1 a2} -> count a1 s = count a2 s.\nProof. by move/eq_in_filter=> eq_a12; rewrite -!size_filter eq_a12. Qed.",
    "Lemma eq_in_all s : {in s, a1 =1 a2} -> all a1 s = all a2 s.\nProof. by move=> eq_a12; rewrite !all_count eq_in_count. Qed.",
    "Lemma eq_in_has s : {in s, a1 =1 a2} -> has a1 s = has a2 s.\nProof. by move/eq_in_filter=> eq_a12; rewrite !has_filter eq_a12. Qed.",
    "Lemma eq_has_r s1 s2 : s1 =i s2 -> has^~ s1 =1 has^~ s2.\nProof.\nby move=> Es a; apply/hasP/hasP=> -[x sx ax]; exists x; rewrite ?Es in sx *.\nQed.",
    "Lemma eq_all_r s1 s2 : s1 =i s2 -> all^~ s1 =1 all^~ s2.\nProof. by move=> Es a; apply/negb_inj; rewrite -!has_predC (eq_has_r Es). Qed.",
    "Lemma has_sym s1 s2 : has [in s1] s2 = has [in s2] s1.\nProof. by apply/hasP/hasP=> -[x]; exists x. Qed.",
    "Lemma has_pred1 x s : has (pred1 x) s = (x \\in s).\nProof. by rewrite -(eq_has (mem_seq1^~ x)) (has_sym [:: x]) /= orbF. Qed.",
    "Lemma mem_rev s : rev s =i s.\nProof. by move=> a; rewrite -!has_pred1 has_rev. Qed.",
    "Lemma all_pred1P x s : reflect (s = nseq (size s) x) (all (pred1 x) s).\nProof.\nelim: s => [|y s IHs] /=; first by left.\ncase: eqP => [->{y} | ne_xy]; last by right=> [] [? _]; case ne_xy.\nby apply: (iffP IHs) => [<- //| []].\nQed.",
    "Lemma all_pred1_constant x s : all (pred1 x) s -> constant s.\nProof. by case: s => //= y s /andP[/eqP->]. Qed.",
    "Lemma all_pred1_nseq x n : all (pred1 x) (nseq n x).\nProof. by rewrite all_nseq /= eqxx orbT. Qed.",
    "Lemma mem_nseq n x y : (y \\in nseq n x) = (0 < n) && (y == x).\nProof. by rewrite -has_pred1 has_nseq eq_sym.  Qed.",
    "Lemma nseqP n x y : reflect (y = x /\\ n > 0) (y \\in nseq n x).\nProof. by rewrite mem_nseq andbC; apply: (iffP andP) => -[/eqP]. Qed.",
    "Lemma constant_nseq n x : constant (nseq n x).\nProof. exact: all_pred1_constant (all_pred1_nseq x n). Qed.",
    "Lemma constantP s : reflect (exists x, s = nseq (size s) x) (constant s).\nProof.\napply: (iffP idP) => [| [x ->]]; last exact: constant_nseq.\ncase: s => [|x s] /=; first by exists x0.\nby move/all_pred1P=> def_s; exists x; rewrite -def_s.\nQed.",
    "Lemma cons_uniq x s : uniq (x :: s) = (x \\notin s) && uniq s.\nProof. by []. Qed.",
    "Lemma cat_uniq s1 s2 :\n  uniq (s1 ++ s2) = [&& uniq s1, ~~ has [in s1] s2 & uniq s2].\nProof.\nelim: s1 => [|x s1 IHs]; first by rewrite /= has_pred0.\nby rewrite has_sym /= mem_cat !negb_or has_sym IHs -!andbA; do !bool_congr.\nQed.",
    "Lemma uniq_catC s1 s2 : uniq (s1 ++ s2) = uniq (s2 ++ s1).\nProof. by rewrite !cat_uniq has_sym andbCA andbA andbC. Qed.",
    "Lemma uniq_catCA s1 s2 s3 : uniq (s1 ++ s2 ++ s3) = uniq (s2 ++ s1 ++ s3).\nProof.\nby rewrite !catA -!(uniq_catC s3) !(cat_uniq s3) uniq_catC !has_cat orbC.\nQed.",
    "Lemma rcons_uniq s x : uniq (rcons s x) = (x \\notin s) && uniq s.\nProof. by rewrite -cats1 uniq_catC. Qed.",
    "Lemma filter_uniq s a : uniq s -> uniq (filter a s).\nProof.\nelim: s => //= x s IHs /andP[s'x]; case: ifP => //= a_x /IHs->.\nby rewrite mem_filter a_x s'x.\nQed.",
    "Lemma rot_uniq s : uniq (rot n0 s) = uniq s.\nProof. by rewrite /rot uniq_catC cat_take_drop. Qed.",
    "Lemma rev_uniq s : uniq (rev s) = uniq s.\nProof.\nelim: s => // x s IHs.\nby rewrite rev_cons -cats1 cat_uniq /= andbT andbC mem_rev orbF IHs.\nQed.",
    "Lemma count_memPn x s : reflect (count_mem x s = 0) (x \\notin s).\nProof. by rewrite -has_pred1 has_count -eqn0Ngt; apply: eqP. Qed.",
    "Lemma count_uniq_mem s x : uniq s -> count_mem x s = (x \\in s).\nProof.\nelim: s => //= y s IHs /andP[/negbTE s'y /IHs-> {IHs}].\nby rewrite in_cons; case: (eqVneq y x) => // <-; rewrite s'y.\nQed.",
    "Lemma leq_uniq_countP x s1 s2 : uniq s1 ->\n  reflect (x \\in s1 -> x \\in s2) (count_mem x s1 <= count_mem x s2).\nProof.\nmove/count_uniq_mem->; case: (boolP (_ \\in _)) => //= _; last by constructor.\nby rewrite -has_pred1 has_count; apply: (iffP idP) => //; apply.\nQed.",
    "Lemma leq_uniq_count s1 s2 : uniq s1 -> {subset s1 <= s2} ->\n  (forall x, count_mem x s1 <= count_mem x s2).\nProof. by move=> s1_uniq s1_s2 x; apply/leq_uniq_countP/s1_s2. Qed.",
    "Lemma filter_pred1_uniq s x : uniq s -> x \\in s -> filter (pred1 x) s = [:: x].\nProof.\nmove=> uniq_s s_x; rewrite (all_pred1P _ _ (filter_all _ _)).\nby rewrite size_filter count_uniq_mem ?s_x.\nQed.",
    "Lemma size_undup s : size (undup s) <= size s.\nProof. by elim: s => //= x s IHs; case: (x \\in s) => //=; apply: ltnW. Qed.",
    "Lemma mem_undup s : undup s =i s.\nProof.\nmove=> x; elim: s => //= y s IHs.\nby case s_y: (y \\in s); rewrite !inE IHs //; case: eqP => [->|].\nQed.",
    "Lemma undup_uniq s : uniq (undup s).\nProof.\nby elim: s => //= x s IHs; case s_x: (x \\in s); rewrite //= mem_undup s_x.\nQed.",
    "Lemma undup_id s : uniq s -> undup s = s.\nProof. by elim: s => //= x s IHs /andP[/negbTE-> /IHs->]. Qed.",
    "Lemma ltn_size_undup s : (size (undup s) < size s) = ~~ uniq s.\nProof.\nby elim: s => //= x s IHs; case s_x: (x \\in s); rewrite //= ltnS size_undup.\nQed.",
    "Lemma filter_undup p s : filter p (undup s) = undup (filter p s).\nProof.\nelim: s => //= x s IHs; rewrite (fun_if undup) fun_if /= mem_filter /=.\nby rewrite (fun_if (filter p)) /= IHs; case: ifP => -> //=; apply: if_same.\nQed.",
    "Lemma undup_nil s : undup s = [::] -> s = [::].\nProof. by case: s => //= x s; rewrite -mem_undup; case: ifP; case: undup. Qed.",
    "Lemma undup_cat s t :\n  undup (s ++ t) = [seq x <- undup s | x \\notin t] ++ undup t.\nProof. by elim: s => //= x s ->; rewrite mem_cat; do 2 case: in_mem => //=. Qed.",
    "Lemma undup_rcons s x : undup (rcons s x) = rcons [seq y <- undup s | y != x] x.\nProof.\nby rewrite -!cats1 undup_cat; congr cat; apply: eq_filter => y; rewrite inE.\nQed.",
    "Lemma count_undup s p : count p (undup s) <= count p s.\nProof. by rewrite -!size_filter filter_undup size_undup. Qed.",
    "Lemma has_undup p s : has p (undup s) = has p s.\nProof. by apply: eq_has_r => x; rewrite mem_undup. Qed.",
    "Lemma all_undup p s : all p (undup s) = all p s.\nProof. by apply: eq_all_r => x; rewrite mem_undup. Qed.",
    "Lemma index_size x s : index x s <= size s.\nProof. by rewrite /index find_size. Qed.",
    "Lemma index_mem x s : (index x s < size s) = (x \\in s).\nProof. by rewrite -has_pred1 has_find. Qed.",
    "Lemma memNindex x s :  x \\notin s -> index x s = size s.\nProof. by rewrite -has_pred1 => /hasNfind. Qed.",
    "Lemma nth_index x s : x \\in s -> nth s (index x s) = x.\nProof. by rewrite -has_pred1 => /(nth_find x0)/eqP. Qed.",
    "Lemma index_cat x s1 s2 :\n index x (s1 ++ s2) = if x \\in s1 then index x s1 else size s1 + index x s2.\nProof. by rewrite /index find_cat has_pred1. Qed.",
    "Lemma index_ltn x s i : x \\in take i s -> index x s < i.\nProof. by rewrite -has_pred1; apply: find_ltn. Qed.",
    "Lemma in_take x s i : x \\in s -> (x \\in take i s) = (index x s < i).\nProof. by rewrite -?has_pred1; apply: has_take. Qed.",
    "Lemma in_take_leq x s i : i <= size s -> (x \\in take i s) = (index x s < i).\nProof. by rewrite -?has_pred1; apply: has_take_leq. Qed.",
    "Lemma index_nth i s : i < size s -> index (nth s i) s <= i.\nProof.\nmove=> lti; rewrite -ltnS index_ltn// -(@nth_take i.+1)// mem_nth // size_take.\nby case: ifP.\nQed.",
    "Lemma nthK s: uniq s -> {in gtn (size s), cancel (nth s) (index^~ s)}.\nProof.\nelim: s => //= x s IHs /andP[s'x Us] i; rewrite inE ltnS eq_sym -if_neg.\nby case: i => /= [_|i lt_i_s]; rewrite ?eqxx ?IHs ?(memPn s'x) ?mem_nth.\nQed.",
    "Lemma index_uniq i s : i < size s -> uniq s -> index (nth s i) s = i.\nProof. by move/nthK. Qed.",
    "Lemma index_head x s : index x (x :: s) = 0.\nProof. by rewrite /= eqxx. Qed.",
    "Lemma index_last x s : uniq (x :: s) -> index (last x s) (x :: s) = size s.\nProof.\nrewrite lastI rcons_uniq -cats1 index_cat size_belast.\nby case: ifP => //=; rewrite eqxx addn0.\nQed.",
    "Lemma nth_uniq s i j :\n  i < size s -> j < size s -> uniq s -> (nth s i == nth s j) = (i == j).\nProof. by move=> lti ltj /nthK/can_in_eq->. Qed.",
    "Lemma uniqPn s :\n  reflect (exists i j, [/\\ i < j, j < size s & nth s i = nth s j]) (~~ uniq s).\nProof.\napply: (iffP idP) => [|[i [j [ltij ltjs]]]]; last first.\n  by apply: contra_eqN => Us; rewrite nth_uniq ?ltn_eqF // (ltn_trans ltij).\nelim: s => // x s IHs /nandP[/negbNE | /IHs[i [j]]]; last by exists i.+1, j.+1.\nby exists 0, (index x s).+1; rewrite !ltnS index_mem /= nth_index.\nQed.",
    "Lemma uniqP s : reflect {in gtn (size s) &, injective (nth s)} (uniq s).\nProof.\napply: (iffP idP) => [/nthK/can_in_inj// | nth_inj].\napply/uniqPn => -[i [j [ltij ltjs /nth_inj/eqP/idPn]]].\nby rewrite !inE (ltn_trans ltij ltjs) ltn_eqF //=; case.\nQed.",
    "Lemma mem_rot s : rot n0 s =i s.\nProof. by move=> x; rewrite -[s in RHS](cat_take_drop n0) !mem_cat /= orbC. Qed.",
    "Lemma eqseq_rot s1 s2 : (rot n0 s1 == rot n0 s2) = (s1 == s2).\nProof. exact/inj_eq/rot_inj. Qed.",
    "Lemma drop_index s (n := index x0 s) : x0 \\in s -> drop n s = x0 :: drop n.+1 s.\nProof. by move=> xs; rewrite (drop_nth x0) ?index_mem ?nth_index. Qed.",
    "Lemma index_pivot x s1 s2 (s := s1 ++ x :: s2) : x \\notin s1 ->\n  index x s = size s1.\nProof. by rewrite index_cat/= eqxx addn0; case: ifPn. Qed.",
    "Lemma take_pivot x s2 s1 (s := s1 ++ x :: s2) : x \\notin s1 ->\n  take (index x s) s = s1.\nProof. by move=> /index_pivot->; rewrite take_size_cat. Qed.",
    "Lemma rev_pivot x s1 s2 : rev (s1 ++ x :: s2) = rev s2 ++ x :: rev s1.\nProof. by rewrite rev_cat rev_cons cat_rcons. Qed.",
    "Lemma eqseq_pivot2l x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s3 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof.\nmove=> xNs1 xNs3; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\nsuff S : size s1 = size s3 by rewrite eqseq_cat// eqseq_cons eqxx in E.\nby rewrite -(index_pivot s2 xNs1) (eqP E) index_pivot.\nQed.",
    "Lemma eqseq_pivot2r x s1 s2 s3 s4 : x \\notin s2 -> x \\notin s4 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof.\nmove=> xNs2 xNs4; rewrite -(can_eq revK) !rev_pivot.\nby rewrite eqseq_pivot2l ?mem_rev // !(can_eq revK) andbC.\nQed.",
    "Lemma eqseq_pivotl x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s2 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof.\nmove=> xNs1 xNs2; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\nrewrite -(@eqseq_pivot2l x)//; have /eqP/(congr1 (count_mem x)) := E.\nrewrite !count_cat/= eqxx !addnS (count_memPn _ _ xNs1) (count_memPn _ _ xNs2).\nby move=> -[/esym/eqP]; rewrite addn_eq0 => /andP[/eqP/count_memPn].\nQed.",
    "Lemma eqseq_pivotr x s1 s2 s3 s4 : x \\notin s3 -> x \\notin s4 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof. by move=> *; rewrite eq_sym eqseq_pivotl//; case: eqVneq => /=. Qed.",
    "Lemma uniq_eqseq_pivotl x s1 s2 s3 s4 : uniq (s1 ++ x :: s2) ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof.\nby rewrite uniq_catC/= mem_cat => /andP[/norP[? ?] _]; rewrite eqseq_pivotl.\nQed.",
    "Lemma uniq_eqseq_pivotr x s1 s2 s3 s4 : uniq (s3 ++ x :: s4) ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\nProof. by move=> ?; rewrite eq_sym uniq_eqseq_pivotl//; case: eqVneq => /=. Qed.",
    "Lemma rot_index s x (i := index x s) : x \\in s ->\n  rot i s = x :: (drop i.+1 s ++ take i s).\nProof. by move=> x_s; rewrite /rot drop_index. Qed.",
    "Lemma rot_to s x : x \\in s -> rot_to_spec s x.\nProof. by move=> /rot_index /RotToSpec. Qed.",
    "Lemma nthP (T : eqType) (s : seq T) x x0 :\n  reflect (exists2 i, i < size s & nth x0 s i = x) (x \\in s).\nProof.\napply: (iffP idP) => [|[n Hn <-]]; last exact: mem_nth.\nby exists (index x s); [rewrite index_mem | apply nth_index].\nQed.",
    "Lemma has_nthP a s x0 :\n  reflect (exists2 i, i < size s & a (nth x0 s i)) (has a s).\nProof.\nelim: s => [|x s IHs] /=; first by right; case.\ncase nax: (a x); first by left; exists 0.\nby apply: (iffP IHs) => [[i]|[[|i]]]; [exists i.+1 | rewrite nax | exists i].\nQed.",
    "Lemma all_nthP a s x0 :\n  reflect (forall i, i < size s -> a (nth x0 s i)) (all a s).\nProof.\nrewrite -(eq_all (fun x => negbK (a x))) all_predC.\ncase: (has_nthP _ _ x0) => [na_s | a_s]; [right=> a_s | left=> i lti].\n  by case: na_s => i lti; rewrite a_s.\nby apply/idPn=> na_si; case: a_s; exists i.\nQed.",
    "Lemma set_nthE s x0 n x :\n  set_nth x0 s n x = if n < size s\n    then take n s ++ x :: drop n.+1 s\n    else s ++ ncons (n - size s) x0 [:: x].\nProof.\nelim: s n => [|a s IH] n /=; first by rewrite subn0 set_nth_nil.\ncase: n => [|n]; first by rewrite drop0.\nby rewrite ltnS /=; case: ltnP (IH n) => _ ->.\nQed.",
    "Lemma count_set_nth a s x0 n x :\n  count a (set_nth x0 s n x) =\n    count a s + a x - a (nth x0 s n) * (n < size s) + (a x0) * (n - size s).\nProof.\nrewrite set_nthE; case: ltnP => [nlts|nges]; last first.\n  rewrite -cat_nseq !count_cat count_nseq /=.\n  by rewrite muln0 addn0 subn0 addnAC addnA.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nrewrite -[in count a s](cat_take_drop n s) [drop n s](drop_nth x0)//.\nby rewrite !count_cat/= muln1 muln0 addn0 addnAC !addnA [in RHS]addnAC addnK.\nQed.",
    "Lemma count_set_nth_ltn a s x0 n x : n < size s ->\n  count a (set_nth x0 s n x) = count a s + a x - a (nth x0 s n).\nProof.\nmove=> nlts; rewrite count_set_nth nlts muln1.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nby rewrite muln0 addn0.\nQed.",
    "Lemma count_set_nthF a s x0 n x : ~~ a x0 ->\n  count a (set_nth x0 s n x) = count a s + a x - a (nth x0 s n).\nProof.\nmove=> /negbTE ax0; rewrite count_set_nth ax0 mul0n addn0.\ncase: ltnP => [_|nges]; first by rewrite muln1.\nby rewrite nth_default// ax0 subn0.\nQed.",
    "Lemma set_nth_default T s (y0 x0 : T) n : n < size s -> nth x0 s n = nth y0 s n.\nProof. by elim: s n => [|y s' IHs] [|n] //= /IHs. Qed.",
    "Lemma headI T s (x : T) : rcons s x = head x s :: behead (rcons s x).\nProof. by case: s. Qed.",
    "Lemma split_find_nth x0 p s (i := find p s) :\n  has p s -> split_find_nth_spec p s (take i s) (drop i.+1 s) (nth x0 s i).\nProof.\nmove=> p_s; rewrite -[X in split_find_nth_spec _ X](cat_take_drop i s).\nrewrite (drop_nth x0 _) -?has_find// -cat_rcons.\nby constructor; [apply: nth_find | rewrite has_take -?leqNgt].\nQed.",
    "Lemma split_find p s (i := find p s) :\n  has p s -> split_find_spec p s (take i s) (drop i.+1 s).\nProof.\nby case: s => // x ? in i * => ?; case: split_find_nth => //; constructor.\nQed.",
    "Lemma nth_rcons_cat_find x0 p s1 s2 x (s := rcons s1 x ++ s2) :\n   p x -> ~~ has p s1 -> nth x0 s (find p s) = x.\nProof.\nmove=> pz pNs1; rewrite /s  cat_rcons find_cat (negPf pNs1).\nby rewrite nth_cat/= pz addn0 subnn ltnn.\nQed.",
    "Lemma nth_incr_nth v i j : nth 0 (incr_nth v i) j = (i == j) + nth 0 v j.\nProof.\nelim: v i j => [|n v IHv] [|i] [|j] //=; rewrite ?eqSS ?addn0 //; try by case j.\nelim: i j => [|i IHv] [|j] //=; rewrite ?eqSS //; by case j.\nQed.",
    "Lemma size_incr_nth v i :\n  size (incr_nth v i) = if i < size v then size v else i.+1.\nProof.\nelim: v i => [|n v IHv] [|i] //=; first by rewrite size_ncons /= addn1.\nby rewrite IHv; apply: fun_if.\nQed.",
    "Lemma incr_nth_inj v : injective (incr_nth v).\nProof.\nmove=> i j /(congr1 (nth 0 ^~ i)); apply: contra_eq => neq_ij.\nby rewrite !nth_incr_nth eqn_add2r eqxx /nat_of_bool ifN_eqC.\nQed.",
    "Lemma incr_nthC v i j :\n  incr_nth (incr_nth v i) j = incr_nth (incr_nth v j) i.\nProof.\napply: (@eq_from_nth _ 0) => [|k _]; last by rewrite !nth_incr_nth addnCA.\nby do !rewrite size_incr_nth leqNgt if_neg -/(maxn _ _); apply: maxnAC.\nQed.",
    "Lemma permP s1 s2 : reflect (count^~ s1 =1 count^~ s2) (perm_eq s1 s2).\nProof.\napply: (iffP allP) => /= [eq_cnt1 a | eq_cnt x _]; last exact/eqP.\nhave [n le_an] := ubnP (count a (s1 ++ s2)); elim: n => // n IHn in a le_an *.\nhave [/eqP|] := posnP (count a (s1 ++ s2)).\n  by rewrite count_cat addn_eq0; do 2!case: eqP => // ->.\nrewrite -has_count => /hasP[x s12x a_x]; pose a' := predD1 a x.\nhave cnt_a' s: count a s = count_mem x s + count a' s.\n  rewrite -count_predUI -[LHS]addn0 -(count_pred0 s).\n  by congr (_ + _); apply: eq_count => y /=; case: eqP => // ->.\nrewrite !cnt_a' (eqnP (eq_cnt1 _ s12x)) (IHn a') // -ltnS.\napply: leq_trans le_an.\nby rewrite ltnS cnt_a' -add1n leq_add2r -has_count has_pred1.\nQed.",
    "Lemma perm_refl s : perm_eq s s.\nProof. exact/permP. Qed.",
    "Lemma perm_sym : symmetric perm_eq.\nProof. by move=> s1 s2; apply/permP/permP=> eq_s12 a. Qed.",
    "Lemma perm_trans : transitive perm_eq.\nProof. by move=> s2 s1 s3 /permP-eq12 /permP/(ftrans eq12)/permP. Qed.",
    "Lemma permEl s1 s2 : perm_eql s1 s2 -> perm_eq s1 s2. Proof. by move->. Qed.",
    "Lemma permPl s1 s2 : reflect (perm_eql s1 s2) (perm_eq s1 s2).\nProof.\napply: (iffP idP) => [eq12 s3 | -> //]; apply/idP/idP; last exact: perm_trans.\nby rewrite -!(perm_sym s3) => /perm_trans; apply.\nQed.",
    "Lemma permPr s1 s2 : reflect (perm_eqr s1 s2) (perm_eq s1 s2).\nProof.\nby apply/(iffP idP) => [/permPl eq12 s3| <- //]; rewrite !(perm_sym s3) eq12.\nQed.",
    "Lemma perm_catC s1 s2 : perm_eql (s1 ++ s2) (s2 ++ s1).\nProof. by apply/permPl/permP=> a; rewrite !count_cat addnC. Qed.",
    "Lemma perm_cat2l s1 s2 s3 : perm_eq (s1 ++ s2) (s1 ++ s3) = perm_eq s2 s3.\nProof.\napply/permP/permP=> eq23 a; apply/eqP;\n  by move/(_ a)/eqP: eq23; rewrite !count_cat eqn_add2l.\nQed.",
    "Lemma perm_catl s t1 t2 : perm_eq t1 t2 -> perm_eql (s ++ t1) (s ++ t2).\nProof. by move=> eq_t12; apply/permPl; rewrite perm_cat2l. Qed.",
    "Lemma perm_cons x s1 s2 : perm_eq (x :: s1) (x :: s2) = perm_eq s1 s2.\nProof. exact: (perm_cat2l [::x]). Qed.",
    "Lemma perm_cat2r s1 s2 s3 : perm_eq (s2 ++ s1) (s3 ++ s1) = perm_eq s2 s3.\nProof. by do 2!rewrite perm_sym perm_catC; apply: perm_cat2l. Qed.",
    "Lemma perm_catr s1 s2 t : perm_eq s1 s2 -> perm_eql (s1 ++ t) (s2 ++ t).\nProof. by move=> eq_s12; apply/permPl; rewrite perm_cat2r. Qed.",
    "Lemma perm_cat s1 s2 t1 t2 :\n  perm_eq s1 s2 -> perm_eq t1 t2 -> perm_eq (s1 ++ t1) (s2 ++ t2).\nProof. by move=> /perm_catr-> /perm_catl->. Qed.",
    "Lemma perm_catAC s1 s2 s3 : perm_eql ((s1 ++ s2) ++ s3) ((s1 ++ s3) ++ s2).\nProof. by apply/permPl; rewrite -!catA perm_cat2l perm_catC. Qed.",
    "Lemma perm_catCA s1 s2 s3 : perm_eql (s1 ++ s2 ++ s3) (s2 ++ s1 ++ s3).\nProof. by apply/permPl; rewrite !catA perm_cat2r perm_catC. Qed.",
    "Lemma perm_catACA s1 s2 s3 s4 :\n  perm_eql ((s1 ++ s2) ++ (s3 ++ s4)) ((s1 ++ s3) ++ (s2 ++ s4)).\nProof. by apply/permPl; rewrite perm_catAC !catA perm_catAC. Qed.",
    "Lemma perm_rcons x s : perm_eql (rcons s x) (x :: s).\nProof. by move=> /= s2; rewrite -cats1 perm_catC. Qed.",
    "Lemma perm_rot n s : perm_eql (rot n s) s.\nProof. by move=> /= s2; rewrite perm_catC cat_take_drop. Qed.",
    "Lemma perm_rotr n s : perm_eql (rotr n s) s.\nProof. exact: perm_rot. Qed.",
    "Lemma perm_rev s : perm_eql (rev s) s.\nProof. by apply/permPl/permP=> i; rewrite count_rev. Qed.",
    "Lemma perm_filter s1 s2 a :\n  perm_eq s1 s2 -> perm_eq (filter a s1) (filter a s2).\nProof. by move/permP=> s12_count; apply/permP=> Q; rewrite !count_filter. Qed.",
    "Lemma perm_filterC a s : perm_eql (filter a s ++ filter (predC a) s) s.\nProof.\napply/permPl; elim: s => //= x s IHs.\nby case: (a x); last rewrite /= -cat1s perm_catCA; rewrite perm_cons.\nQed.",
    "Lemma perm_size s1 s2 : perm_eq s1 s2 -> size s1 = size s2.\nProof. by move/permP=> eq12; rewrite -!count_predT eq12. Qed.",
    "Lemma perm_mem s1 s2 : perm_eq s1 s2 -> s1 =i s2.\nProof. by move/permP=> eq12 x; rewrite -!has_pred1 !has_count eq12. Qed.",
    "Lemma perm_nilP s : reflect (s = [::]) (perm_eq s [::]).\nProof. by apply: (iffP idP) => [/perm_size/eqP/nilP | ->]. Qed.",
    "Lemma perm_consP x s t :\n  reflect (exists i u, rot i t = x :: u /\\ perm_eq u s)\n          (perm_eq t (x :: s)).\nProof.\napply: (iffP idP) => [eq_txs | [i [u [Dt eq_us]]]].\n  have /rot_to[i u Dt]: x \\in t by rewrite (perm_mem eq_txs) mem_head.\n  by exists i, u; rewrite -(perm_cons x) -Dt perm_rot.\nby rewrite -(perm_rot i) Dt perm_cons.\nQed.",
    "Lemma perm_has s1 s2 a : perm_eq s1 s2 -> has a s1 = has a s2.\nProof. by move/perm_mem/eq_has_r. Qed.",
    "Lemma perm_all s1 s2 a : perm_eq s1 s2 -> all a s1 = all a s2.\nProof. by move/perm_mem/eq_all_r. Qed.",
    "Lemma perm_small_eq s1 s2 : size s2 <= 1 -> perm_eq s1 s2 -> s1 = s2.\nProof.\nmove=> s2_le1 eqs12; move/perm_size: eqs12 s2_le1 (perm_mem eqs12).\nby case: s2 s1 => [|x []] // [|y []] // _ _ /(_ x) /[!(inE, eqxx)] /eqP->.\nQed.",
    "Lemma uniq_leq_size s1 s2 : uniq s1 -> {subset s1 <= s2} -> size s1 <= size s2.\nProof.\nelim: s1 s2 => //= x s1 IHs s2 /andP[not_s1x Us1] /forall_cons[s2x ss12].\nhave [i s3 def_s2] := rot_to s2x; rewrite -(size_rot i s2) def_s2.\napply: IHs => // y s1y; have:= ss12 y s1y.\nby rewrite -(mem_rot i) def_s2 inE (negPf (memPn _ y s1y)).\nQed.",
    "Lemma leq_size_uniq s1 s2 :\n  uniq s1 -> {subset s1 <= s2} -> size s2 <= size s1 -> uniq s2.\nProof.\nelim: s1 s2 => [[] | x s1 IHs s2] // Us1x; have /andP[not_s1x Us1] := Us1x.\ncase/forall_cons => /rot_to[i s3 def_s2] ss12 le_s21.\nrewrite -(rot_uniq i) -(size_rot i) def_s2 /= in le_s21 *.\nhave ss13 y (s1y : y \\in s1): y \\in s3.\n  by have:= ss12 y s1y; rewrite -(mem_rot i) def_s2 inE (negPf (memPn _ y s1y)).\nrewrite IHs // andbT; apply: contraL _ le_s21 => s3x; rewrite -leqNgt.\nby apply/(uniq_leq_size Us1x)/allP; rewrite /= s3x; apply/allP.\nQed.",
    "Lemma uniq_size_uniq s1 s2 :\n  uniq s1 -> s1 =i s2 -> uniq s2 = (size s2 == size s1).\nProof.\nmove=> Us1 eqs12; apply/idP/idP=> [Us2 | /eqP eq_sz12].\n  by rewrite eqn_leq !uniq_leq_size // => y; rewrite eqs12.\nby apply: (leq_size_uniq Us1) => [y|]; rewrite (eqs12, eq_sz12).\nQed.",
    "Lemma uniq_min_size s1 s2 :\n    uniq s1 -> {subset s1 <= s2} -> size s2 <= size s1 ->\n  (size s1 = size s2) * (s1 =i s2).\nProof.\nmove=> Us1 ss12 le_s21; have Us2: uniq s2 := leq_size_uniq Us1 ss12 le_s21.\nsuffices: s1 =i s2 by split; first by apply/eqP; rewrite -uniq_size_uniq.\nmove=> x; apply/idP/idP=> [/ss12// | s2x]; apply: contraLR le_s21 => not_s1x.\nrewrite -ltnNge (@uniq_leq_size (x :: s1)) /= ?not_s1x //.\nby apply/allP; rewrite /= s2x; apply/allP.\nQed.",
    "Lemma eq_uniq s1 s2 : size s1 = size s2 -> s1 =i s2 -> uniq s1 = uniq s2.\nProof.\nmove=> eq_sz12 eq_s12.\nby apply/idP/idP=> Us; rewrite (uniq_size_uniq Us) ?eq_sz12 ?eqxx.\nQed.",
    "Lemma perm_uniq s1 s2 : perm_eq s1 s2 -> uniq s1 = uniq s2.\nProof. by move=> eq_s12; apply/eq_uniq; [apply/perm_size | apply/perm_mem]. Qed.",
    "Lemma uniq_perm s1 s2 : uniq s1 -> uniq s2 -> s1 =i s2 -> perm_eq s1 s2.\nProof.\nmove=> Us1 Us2 eq12; apply/allP=> x _; apply/eqP.\nby rewrite !count_uniq_mem ?eq12.\nQed.",
    "Lemma perm_undup s1 s2 : s1 =i s2 -> perm_eq (undup s1) (undup s2).\nProof.\nby move=> Es12; rewrite uniq_perm ?undup_uniq // => s; rewrite !mem_undup.\nQed.",
    "Lemma count_mem_uniq s : (forall x, count_mem x s = (x \\in s)) -> uniq s.\nProof.\nmove=> count1_s; have Uus := undup_uniq s.\nsuffices: perm_eq s (undup s) by move/perm_uniq->.\nby apply/allP=> x _; apply/eqP; rewrite (count_uniq_mem x Uus) mem_undup.\nQed.",
    "Lemma eq_count_undup a s1 s2 :\n  {in a, s1 =i s2} -> count a (undup s1) = count a (undup s2).\nProof.\nmove=> s1_eq_s2; rewrite -!size_filter !filter_undup.\napply/perm_size/perm_undup => x.\nby rewrite !mem_filter; case: (boolP (a x)) => //= /s1_eq_s2.\nQed.",
    "Lemma catCA_perm_ind P :\n    (forall s1 s2 s3, P (s1 ++ s2 ++ s3) -> P (s2 ++ s1 ++ s3)) ->\n  (forall s1 s2, perm_eq s1 s2 -> P s1 -> P s2).\nProof.\nmove=> PcatCA s1 s2 eq_s12; rewrite -[s1]cats0 -[s2]cats0.\nelim: s2 nil => [|x s2 IHs] s3 in s1 eq_s12 *.\n  by case: s1 {eq_s12}(perm_size eq_s12).\nhave /rot_to[i s' def_s1]: x \\in s1 by rewrite (perm_mem eq_s12) mem_head.\nrewrite -(cat_take_drop i s1) -catA => /PcatCA.\nrewrite catA -/(rot i s1) def_s1 /= -cat1s => /PcatCA/IHs/PcatCA; apply.\nby rewrite -(perm_cons x) -def_s1 perm_rot.\nQed.",
    "Lemma catCA_perm_subst R F :\n    (forall s1 s2 s3, F (s1 ++ s2 ++ s3) = F (s2 ++ s1 ++ s3) :> R) ->\n  (forall s1 s2, perm_eq s1 s2 -> F s1 = F s2).\nProof.\nmove=> FcatCA s1 s2 /catCA_perm_ind => ind_s12.\nby apply: (ind_s12 (eq _ \\o F)) => //= *; rewrite FcatCA.\nQed.",
    "Lemma size_rotr s : size (rotr n0 s) = size s.\nProof. by rewrite size_rot. Qed.",
    "Lemma mem_rotr (s : seq T') : rotr n0 s =i s.\nProof. by move=> x; rewrite mem_rot. Qed.",
    "Lemma rotr_size_cat s1 s2 : rotr (size s2) (s1 ++ s2) = s2 ++ s1.\nProof. by rewrite /rotr size_cat addnK rot_size_cat. Qed.",
    "Lemma rotr1_rcons x s : rotr 1 (rcons s x) = x :: s.\nProof. by rewrite -rot1_cons rotK. Qed.",
    "Lemma has_rotr a s : has a (rotr n0 s) = has a s.\nProof. by rewrite has_rot. Qed.",
    "Lemma rotr_uniq (s : seq T') : uniq (rotr n0 s) = uniq s.\nProof. by rewrite rot_uniq. Qed.",
    "Lemma rotrK : cancel (@rotr T n0) (rot n0).\nProof.\nmove=> s; have [lt_n0s | ge_n0s] := ltnP n0 (size s).\n  by rewrite -{1}(subKn (ltnW lt_n0s)) -{1}[size s]size_rotr; apply: rotK.\nby rewrite -[in RHS](rot_oversize ge_n0s) /rotr (eqnP ge_n0s) rot0.\nQed.",
    "Lemma rotr_inj : injective (@rotr T n0).\nProof. exact (can_inj rotrK). Qed.",
    "Lemma take_rev s : take n0 (rev s) = rev (drop (size s - n0) s).\nProof.\nset m := _ - n0; rewrite -[s in LHS](cat_take_drop m) rev_cat take_cat.\nrewrite size_rev size_drop -minnE minnC leq_min ltnn /m.\nby have [_|/eqnP->] := ltnP; rewrite ?subnn take0 cats0.\nQed.",
    "Lemma rev_take s : rev (take n0 s) = drop (size s - n0) (rev s).\nProof. by rewrite -[s in take _ s]revK take_rev revK size_rev. Qed.",
    "Lemma drop_rev s : drop n0 (rev s) = rev (take (size s - n0) s).\nProof.\nset m := _ - n0; rewrite -[s in LHS](cat_take_drop m) rev_cat drop_cat.\nrewrite size_rev size_drop -minnE minnC leq_min ltnn /m.\nby have [_|/eqnP->] := ltnP; rewrite ?take0 // subnn drop0.\nQed.",
    "Lemma rev_drop s : rev (drop n0 s) = take (size s - n0) (rev s).\nProof. by rewrite -[s in drop _ s]revK drop_rev revK size_rev. Qed.",
    "Lemma rev_rotr s : rev (rotr n0 s) = rot n0 (rev s).\nProof. by rewrite rev_cat -take_rev -drop_rev. Qed.",
    "Lemma rev_rot s : rev (rot n0 s) = rotr n0 (rev s).\nProof. by apply: canLR revK _; rewrite rev_rotr revK. Qed.",
    "Lemma rotD m n s : m + n <= size s -> rot (m + n) s = rot m (rot n s).\nProof.\nmove=> sz_s; rewrite [LHS]/rot -[take _ s](cat_take_drop n).\nrewrite 5!(catA, =^~ rot_size_cat) !cat_take_drop.\nby rewrite size_drop !size_takel ?leq_addl ?addnK.\nQed.",
    "Lemma rotS n s : n < size s -> rot n.+1 s = rot 1 (rot n s).\nProof. exact: (@rotD 1). Qed.",
    "Lemma rot_add_mod m n s : n <= size s -> m <= size s ->\n  rot m (rot n s) = rot (if m + n <= size s then m + n else m + n - size s) s.\nProof.\nmove=> Hn Hm; case: leqP => [/rotD // | /ltnW Hmn]; symmetry.\nby rewrite -{2}(rotK n s) /rotr -rotD size_rot addnBA ?subnK ?addnK.\nQed.",
    "Lemma rot_minn n s : rot n s = rot (minn n (size s)) s.\nProof.\nby case: (leqP n (size s)) => // /leqW ?; rewrite rot_size rot_oversize.\nQed.",
    "Lemma leq_rot_add n m s : rot_add s n m <= size s.\nProof.\nby unlock rot_add; case: ifP; rewrite // leq_subLR leq_add // geq_minr.\nQed.",
    "Lemma rot_addC n m s : rot_add s n m = rot_add s m n.\nProof. by unlock rot_add; rewrite ![minn n _ + _]addnC. Qed.",
    "Lemma rot_rot_add n m s : rot m (rot n s) = rot (rot_add s n m) s.\nProof.\nunlock rot_add.\nby rewrite (rot_minn n) (rot_minn m) rot_add_mod ?size_rot ?geq_minr.\nQed.",
    "Lemma rot_rot m n s : rot m (rot n s) = rot n (rot m s).\nProof. by rewrite rot_rot_add rot_addC -rot_rot_add. Qed.",
    "Lemma rot_rotr m n s : rot m (rotr n s) = rotr n (rot m s).\nProof. by rewrite [RHS]/rotr size_rot rot_rot. Qed.",
    "Lemma rotr_rotr m n s : rotr m (rotr n s) = rotr n (rotr m s).\nProof. by rewrite /rotr !size_rot rot_rot. Qed.",
    "Lemma mask_false s n : mask (nseq n false) s = [::].\nProof. by elim: s n => [|x s IHs] [|n] /=. Qed.",
    "Lemma mask_true s n : size s <= n -> mask (nseq n true) s = s.\nProof. by elim: s n => [|x s IHs] [|n] //= Hn; congr (_ :: _); apply: IHs. Qed.",
    "Lemma mask0 m : mask m [::] = [::].\nProof. by case: m. Qed.",
    "Lemma mask0s s : mask [::] s = [::]. Proof. by []. Qed.",
    "Lemma mask1 b x : mask [:: b] [:: x] = nseq b x.\nProof. by case: b. Qed.",
    "Lemma mask_cons b m x s : mask (b :: m) (x :: s) = nseq b x ++ mask m s.\nProof. by case: b. Qed.",
    "Lemma size_mask m s : size m = size s -> size (mask m s) = count id m.\nProof. by move: m s; apply: seq_ind2 => // -[] x m s /= _ ->. Qed.",
    "Lemma mask_cat m1 m2 s1 s2 :\n  size m1 = size s1 -> mask (m1 ++ m2) (s1 ++ s2) = mask m1 s1 ++ mask m2 s2.\nProof. by move: m1 s1; apply: seq_ind2 => // -[] m1 x1 s1 /= _ ->. Qed.",
    "Lemma mask_rcons b m x s : size m = size s ->\n  mask (rcons m b) (rcons s x) = mask m s ++ nseq b x.\nProof. by move=> ms; rewrite -!cats1 mask_cat//; case: b. Qed.",
    "Lemma all_mask a m s : all a s -> all a (mask m s).\nProof. by elim: s m => [|x s IHs] [|[] m]//= /andP[ax /IHs->]; rewrite ?ax. Qed.",
    "Lemma has_mask_cons a b m x s :\n  has a (mask (b :: m) (x :: s)) = b && a x || has a (mask m s).\nProof. by case: b. Qed.",
    "Lemma has_mask a m s : has a (mask m s) -> has a s.\nProof. by apply/contraTT; rewrite -!all_predC; apply: all_mask. Qed.",
    "Lemma rev_mask m s : size m = size s -> rev (mask m s) = mask (rev m) (rev s).\nProof.\nmove: m s; apply: seq_ind2 => //= b x m s eq_size_sm IH.\nby case: b; rewrite !rev_cons mask_rcons ?IH ?size_rev// (cats1, cats0).\nQed.",
    "Lemma mask_rot m s : size m = size s ->\n   mask (rot n0 m) (rot n0 s) = rot (count id (take n0 m)) (mask m s).\nProof.\nmove=> Ems; rewrite mask_cat ?size_drop ?Ems // -rot_size_cat.\nby rewrite size_mask -?mask_cat ?size_take ?Ems // !cat_take_drop.\nQed.",
    "Lemma resize_mask m s : {m1 | size m1 = size s & mask m s = mask m1 s}.\nProof.\nexists (take (size s) m ++ nseq (size s - size m) false).\n  by elim: s m => [|x s IHs] [|b m] //=; rewrite (size_nseq, IHs).\nby elim: s m => [|x s IHs] [|b m] //=; rewrite (mask_false, IHs).\nQed.",
    "Lemma takeEmask i s : take i s = mask (nseq i true) s.\nProof. by elim: i s => [s|i IHi []// ? ?]; rewrite ?take0 //= IHi. Qed.",
    "Lemma dropEmask i s :\n  drop i s = mask (nseq i false ++ nseq (size s - i) true) s.\nProof. by elim: i s => [s|? ? []//]; rewrite drop0/= mask_true// subn0. Qed.",
    "Lemma mem_mask_cons x b m y s :\n  (x \\in mask (b :: m) (y :: s)) = b && (x == y) || (x \\in mask m s).\nProof. by case: b. Qed.",
    "Lemma mem_mask x m s : x \\in mask m s -> x \\in s.\nProof. by rewrite -!has_pred1 => /has_mask. Qed.",
    "Lemma in_mask x m s :\n  uniq s -> x \\in mask m s = (x \\in s) && nth false m (index x s).\nProof.\nelim: s m => [|y s IHs] [|[] m]//= /andP[yNs ?]; rewrite ?in_cons ?IHs //=;\nby have [->|neq_xy] //= := eqVneq; rewrite ?andbF // (negPf yNs).\nQed.",
    "Lemma mask_uniq s : uniq s -> forall m, uniq (mask m s).\nProof.\nelim: s => [|x s IHs] Uxs [|b m] //=.\ncase: b Uxs => //= /andP[s'x Us]; rewrite {}IHs // andbT.\nby apply: contra s'x; apply: mem_mask.\nQed.",
    "Lemma mem_mask_rot m s :\n  size m = size s -> mask (rot n0 m) (rot n0 s) =i mask m s.\nProof. by move=> Ems x; rewrite mask_rot // mem_rot. Qed.",
    "Lemma sub0seq s : subseq [::] s. Proof. by case: s. Qed.",
    "Lemma subseq0 s : subseq s [::] = (s == [::]). Proof. by []. Qed.",
    "Lemma subseq_refl s : subseq s s.\nProof. by elim: s => //= x s IHs; rewrite eqxx. Qed.",
    "Lemma subseqP s1 s2 :\n  reflect (exists2 m, size m = size s2 & s1 = mask m s2) (subseq s1 s2).\nProof.\nelim: s2 s1 => [|y s2 IHs2] [|x s1].\n- by left; exists [::].\n- by right=> -[m /eqP/nilP->].\n- by left; exists (nseq (size s2).+1 false); rewrite ?size_nseq //= mask_false.\napply: {IHs2}(iffP (IHs2 _)) => [] [m sz_m def_s1].\n  by exists ((x == y) :: m); rewrite /= ?sz_m // -def_s1; case: eqP => // ->.\ncase: eqP => [_ | ne_xy]; last first.\n  by case: m def_s1 sz_m => [|[] m] //; [case | move=> -> [<-]; exists m].\npose i := index true m; have def_m_i: take i m = nseq (size (take i m)) false.\n  apply/all_pred1P; apply/(all_nthP true) => j.\n  rewrite size_take ltnNge geq_min negb_or -ltnNge => /andP[lt_j_i _].\n  rewrite nth_take //= -negb_add addbF -addbT -negb_eqb.\n  by rewrite [_ == _](before_find _ lt_j_i).\nhave lt_i_m: i < size m.\n  rewrite ltnNge; apply/negP=> le_m_i; rewrite take_oversize // in def_m_i.\n  by rewrite def_m_i mask_false in def_s1.\nrewrite size_take lt_i_m in def_m_i.\nexists (take i m ++ drop i.+1 m).\n  rewrite size_cat size_take size_drop lt_i_m.\n  by rewrite sz_m in lt_i_m *; rewrite subnKC.\nrewrite {s1 def_s1}[s1](congr1 behead def_s1).\nrewrite -[s2](cat_take_drop i) -[m in LHS](cat_take_drop i) {}def_m_i -cat_cons.\nhave sz_i_s2: size (take i s2) = i by apply: size_takel; rewrite sz_m in lt_i_m.\nrewrite lastI cat_rcons !mask_cat ?size_nseq ?size_belast ?mask_false //=.\nby rewrite (drop_nth true) // nth_index -?index_mem.\nQed.",
    "Lemma mask_subseq m s : subseq (mask m s) s.\nProof. by apply/subseqP; have [m1] := resize_mask m s; exists m1. Qed.",
    "Lemma subseq_trans : transitive subseq.\nProof.\nmove=> _ _ s /subseqP[m2 _ ->] /subseqP[m1 _ ->].\nelim: s => [|x s IHs] in m2 m1 *; first by rewrite !mask0.\ncase: m1 => [|[] m1]; first by rewrite mask0.\n  case: m2 => [|[] m2] //; first by rewrite /= eqxx IHs.\n  case/subseqP: (IHs m2 m1) => m sz_m def_s; apply/subseqP.\n  by exists (false :: m); rewrite //= sz_m.\ncase/subseqP: (IHs m2 m1) => m sz_m def_s; apply/subseqP.\nby exists (false :: m); rewrite //= sz_m.\nQed.",
    "Lemma cat_subseq s1 s2 s3 s4 :\n  subseq s1 s3 -> subseq s2 s4 -> subseq (s1 ++ s2) (s3 ++ s4).\nProof.\ncase/subseqP=> m1 sz_m1 -> /subseqP [m2 sz_m2 ->]; apply/subseqP.\nby exists (m1 ++ m2); rewrite ?size_cat ?mask_cat ?sz_m1 ?sz_m2.\nQed.",
    "Lemma prefix_subseq s1 s2 : subseq s1 (s1 ++ s2).\nProof. by rewrite -[s1 in subseq s1]cats0 cat_subseq ?sub0seq. Qed.",
    "Lemma suffix_subseq s1 s2 : subseq s2 (s1 ++ s2).\nProof. exact: cat_subseq (sub0seq s1) _. Qed.",
    "Lemma take_subseq s i : subseq (take i s) s.\nProof. by rewrite -[s in X in subseq _ X](cat_take_drop i) prefix_subseq. Qed.",
    "Lemma drop_subseq s i : subseq (drop i s) s.\nProof. by rewrite -[s in X in subseq _ X](cat_take_drop i) suffix_subseq. Qed.",
    "Lemma mem_subseq s1 s2 : subseq s1 s2 -> {subset s1 <= s2}.\nProof. by case/subseqP=> m _ -> x; apply: mem_mask. Qed.",
    "Lemma sub1seq x s : subseq [:: x] s = (x \\in s).\nProof. by elim: s => //= y s /[1!inE]; case: ifP; rewrite ?sub0seq. Qed.",
    "Lemma size_subseq s1 s2 : subseq s1 s2 -> size s1 <= size s2.\nProof. by case/subseqP=> m sz_m ->; rewrite size_mask -sz_m ?count_size. Qed.",
    "Lemma size_subseq_leqif s1 s2 :\n  subseq s1 s2 -> size s1 <= size s2 ?= iff (s1 == s2).\nProof.\nmove=> sub12; split; first exact: size_subseq.\napply/idP/eqP=> [|-> //]; case/subseqP: sub12 => m sz_m ->{s1}.\nrewrite size_mask -sz_m // -all_count -(eq_all eqb_id).\nby move/(@all_pred1P _ true)->; rewrite sz_m mask_true.\nQed.",
    "Lemma subseq_anti : antisymmetric subseq.\nProof.\nmove=> s1 s2 /andP[] /size_subseq_leqif /leqifP.\nby case: eqP => [//|_] + /size_subseq; rewrite ltnNge => /negP.\nQed.",
    "Lemma subseq_cons s x : subseq s (x :: s).\nProof. exact: suffix_subseq [:: x] s. Qed.",
    "Lemma cons_subseq s1 s2 x : subseq (x :: s1) s2 -> subseq s1 s2.\nProof. exact/subseq_trans/subseq_cons. Qed.",
    "Lemma subseq_rcons s x : subseq s (rcons s x).\nProof. by rewrite -cats1 prefix_subseq. Qed.",
    "Lemma subseq_uniq s1 s2 : subseq s1 s2 -> uniq s2 -> uniq s1.\nProof. by case/subseqP=> m _ -> Us2; apply: mask_uniq. Qed.",
    "Lemma take_uniq s n : uniq s -> uniq (take n s).\nProof. exact/subseq_uniq/take_subseq. Qed.",
    "Lemma drop_uniq s n : uniq s -> uniq (drop n s).\nProof. exact/subseq_uniq/drop_subseq. Qed.",
    "Lemma undup_subseq s : subseq (undup s) s.\nProof.\nelim: s => //= x s; case: (_ \\in _); last by rewrite eqxx.\nby case: (undup s) => //= y u; case: (_ == _) => //=; apply: cons_subseq.\nQed.",
    "Lemma subseq_rev s1 s2 : subseq (rev s1) (rev s2) = subseq s1 s2.\nProof.\nwlog suff W : s1 s2 / subseq s1 s2 -> subseq (rev s1) (rev s2).\n  by apply/idP/idP => /W //; rewrite !revK.\nby case/subseqP => m size_m ->; rewrite rev_mask // mask_subseq.\nQed.",
    "Lemma subseq_cat2l s s1 s2 : subseq (s ++ s1) (s ++ s2) = subseq s1 s2.\nProof. by elim: s => // x s IHs; rewrite !cat_cons /= eqxx. Qed.",
    "Lemma subseq_cat2r s s1 s2 : subseq (s1 ++ s) (s2 ++ s) = subseq s1 s2.\nProof. by rewrite -subseq_rev !rev_cat subseq_cat2l subseq_rev. Qed.",
    "Lemma subseq_rot p s n :\n  subseq p s -> exists2 k, k <= n & subseq (rot k p) (rot n s).\nProof.\nmove=> /subseqP[m size_m ->].\nexists (count id (take n m)); last by rewrite -mask_rot // mask_subseq.\nby rewrite (leq_trans (count_size _ _))// size_take_min geq_minl.\nQed.",
    "Lemma rem_cons y s : rem (y :: s) = if y == x then s else y :: rem s.\nProof. by []. Qed.",
    "Lemma remE s : rem s = take (index x s) s ++ drop (index x s).+1 s.\nProof. by elim: s => //= y s ->; case: eqVneq; rewrite ?drop0. Qed.",
    "Lemma rem_id s : x \\notin s -> rem s = s.\nProof. by elim: s => //= y s IHs /norP[neq_yx /IHs->]; case: eqVneq neq_yx. Qed.",
    "Lemma perm_to_rem s : x \\in s -> perm_eq s (x :: rem s).\nProof.\nmove=> xs; rewrite remE -[X in perm_eq X](cat_take_drop (index x s)).\nby rewrite drop_index// -cat1s perm_catCA cat1s.\nQed.",
    "Lemma size_rem s : x \\in s -> size (rem s) = (size s).-1.\nProof. by move/perm_to_rem/perm_size->. Qed.",
    "Lemma rem_subseq s : subseq (rem s) s.\nProof.\nelim: s => //= y s IHs; rewrite eq_sym.\nby case: ifP => _; [apply: subseq_cons | rewrite eqxx].\nQed.",
    "Lemma rem_uniq s : uniq s -> uniq (rem s).\nProof. by apply: subseq_uniq; apply: rem_subseq. Qed.",
    "Lemma mem_rem s : {subset rem s <= s}.\nProof. exact: mem_subseq (rem_subseq s). Qed.",
    "Lemma rem_mem y s : y != x -> y \\in s -> y \\in rem s.\nProof.\nmove=> yx; elim: s => [//|z s IHs] /=.\nrewrite inE => /orP[/eqP<-|ys]; first by rewrite (negbTE yx) inE eqxx.\nby case: ifP => _ //; rewrite inE IHs ?orbT.\nQed.",
    "Lemma rem_filter s : uniq s -> rem s = filter (predC1 x) s.\nProof.\nelim: s => //= y s IHs /andP[not_s_y /IHs->].\nby case: eqP => //= <-; apply/esym/all_filterP; rewrite all_predC has_pred1.\nQed.",
    "Lemma mem_rem_uniq s : uniq s -> rem s =i [predD1 s & x].\nProof. by move/rem_filter=> -> y; rewrite mem_filter. Qed.",
    "Lemma mem_rem_uniqF s : uniq s -> x \\in rem s = false.\nProof. by move/mem_rem_uniq->; rewrite inE eqxx. Qed.",
    "Lemma count_rem P s : count P (rem s) = count P s - (x \\in s) && P x.\nProof.\nhave [/perm_to_rem/permP->|xNs]/= := boolP (x \\in s); first by rewrite addKn.\nby rewrite subn0 rem_id.\nQed.",
    "Lemma count_mem_rem y s : count_mem y (rem s) = count_mem y s - (x == y).\nProof.\nrewrite count_rem; have []//= := boolP (x \\in s).\nby case: eqP => // <- /count_memPn->.\nQed.",
    "Lemma map_cons x s : map (x :: s) = f x :: map s.\nProof. by []. Qed.",
    "Lemma map_nseq x : map (nseq n0 x) = nseq n0 (f x).\nProof. by elim: n0 => // *; congr (_ :: _). Qed.",
    "Lemma map_cat s1 s2 : map (s1 ++ s2) = map s1 ++ map s2.\nProof. by elim: s1 => [|x s1 IHs] //=; rewrite IHs. Qed.",
    "Lemma size_map s : size (map s) = size s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma behead_map s : behead (map s) = map (behead s).\nProof. by case: s. Qed.",
    "Lemma nth_map n s : n < size s -> nth x2 (map s) n = f (nth x1 s n).\nProof. by elim: s n => [|x s IHs] []. Qed.",
    "Lemma map_rcons s x : map (rcons s x) = rcons (map s) (f x).\nProof. by rewrite -!cats1 map_cat. Qed.",
    "Lemma last_map s x : last (f x) (map s) = f (last x s).\nProof. by elim: s x => /=. Qed.",
    "Lemma belast_map s x : belast (f x) (map s) = map (belast x s).\nProof. by elim: s x => //= y s IHs x; rewrite IHs. Qed.",
    "Lemma filter_map a s : filter a (map s) = map (filter (preim f a) s).\nProof. by elim: s => //= x s IHs; rewrite (fun_if map) /= IHs. Qed.",
    "Lemma find_map a s : find a (map s) = find (preim f a) s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma has_map a s : has a (map s) = has (preim f a) s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma all_map a s : all a (map s) = all (preim f a) s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma all_mapT (a : pred T2) s : (forall x, a (f x)) -> all a (map s).\nProof. by rewrite all_map => /allT->. Qed.",
    "Lemma count_map a s : count a (map s) = count (preim f a) s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma map_take s : map (take n0 s) = take n0 (map s).\nProof. by elim: n0 s => [|n IHn] [|x s] //=; rewrite IHn. Qed.",
    "Lemma map_drop s : map (drop n0 s) = drop n0 (map s).\nProof. by elim: n0 s => [|n IHn] [|x s] //=; rewrite IHn. Qed.",
    "Lemma map_rot s : map (rot n0 s) = rot n0 (map s).\nProof. by rewrite /rot map_cat map_take map_drop. Qed.",
    "Lemma map_rotr s : map (rotr n0 s) = rotr n0 (map s).\nProof. by apply: canRL (rotK n0) _; rewrite -map_rot rotrK. Qed.",
    "Lemma map_rev s : map (rev s) = rev (map s).\nProof. by elim: s => //= x s IHs; rewrite !rev_cons -!cats1 map_cat IHs. Qed.",
    "Lemma map_mask m s : map (mask m s) = mask m (map s).\nProof. by elim: m s => [|[|] m IHm] [|x p] //=; rewrite IHm. Qed.",
    "Lemma inj_map : injective f -> injective map.\nProof. by move=> injf; elim=> [|x s IHs] [|y t] //= [/injf-> /IHs->]. Qed.",
    "Lemma inj_in_map (A : {pred T1}) :\n  {in A &, injective f} -> {in [pred s | all [in A] s] &, injective map}.\nProof.\nmove=> injf; elim=> [|x s IHs] [|y t] //= /andP[Ax As] /andP[Ay At].\nby case=> /injf-> // /IHs->.\nQed.",
    "Lemma odflt_onth x0 s n : odflt x0 (onth s n) = nth x0 s n.\nProof. by elim: n s => [|? ?] []. Qed.",
    "Lemma onthE s : onth s =1 nth None (map Some s).\nProof. by move=> n; elim: n s => [|? ?] []. Qed.",
    "Lemma onth_nth x0 x t n : onth t n = Some x -> nth x0 t n = x.\nProof. by move=> tn; rewrite -odflt_onth tn. Qed.",
    "Lemma onth0n n : onth [::] n = None. Proof. by case: n. Qed.",
    "Lemma onth1P x y n : onth [:: x] n = Some y <-> n = 0 /\\ x = y.\nProof. by case: n => [|[]]; split=> // -[] // _ ->. Qed.",
    "Lemma onthTE s n : onth s n = (n < size s) :> bool.\nProof. by elim: n s => [|? ?] []. Qed.",
    "Lemma onthNE s n: ~~ onth s n = (size s <= n).\nProof. by rewrite onthTE -leqNgt. Qed.",
    "Lemma onth_default n s : size s <= n -> onth s n = None.\nProof. by rewrite -onthNE; case: onth. Qed.",
    "Lemma onth_cat s1 s2 n :\n  onth (s1 ++ s2) n = if n < size s1 then onth s1 n else onth s2 (n - size s1).\nProof. by elim: n s1 => [|? ?] []. Qed.",
    "Lemma onth_nseq x n m : onth (nseq n x) m = if m < n then Some x else None.\nProof. by rewrite onthE/= -nth_nseq map_nseq. Qed.",
    "Lemma eq_onthP {s1 s2} :\n  [<-> s1 = s2;\n   forall i : nat, i < maxn (size s1) (size s2) -> onth s1 i = onth s2 i;\n   forall i : nat, onth s1 i = onth s2 i].\nProof.\ntfae=> [->//|eqs12 i|eqs12].\n  have := eqs12 i; case: ltnP => [_ ->//|].\n  by rewrite geq_max => /andP[is1 is2] _; rewrite !onth_default.\nhave /eqP eq_size_12 : size s1 == size s2.\n  by rewrite eqn_leq -!onthNE eqs12 onthNE -eqs12 onthNE !leqnn.\napply/(inj_map Some_inj)/(@eq_from_nth _ None); rewrite !size_map//.\nby move=> i _; rewrite -!onthE eqs12.\nQed.",
    "Lemma eq_from_onth [s1 s2 : seq T] :\n  (forall i : nat, onth s1 i = onth s2 i) -> s1 = s2.\nProof. by move/(eq_onthP 0 2). Qed.",
    "Lemma eq_from_onth_le [s1 s2 : seq T] :\n    (forall i : nat, i < maxn (size s1) (size s2) -> onth s1 i = onth s2 i) ->\n  s1 = s2.\nProof. by move/(eq_onthP 0 1). Qed.",
    "Lemma onth_map {T S} n (s : seq T) (f : T -> S) :\n  onth (map f s) n = omap f (onth s n).\nProof. by elim: s n => [|x s IHs] []. Qed.",
    "Lemma inj_onth_map {T S} n (s : seq T) (f : T -> S) x :\n  injective f -> onth (map f s) n = Some (f x) -> onth s n = Some x.\nProof. by rewrite onth_map => /inj_omap + fs; apply. Qed.",
    "Lemma onthP s x : reflect (exists i, onth s i = Some x) (x \\in s).\nProof.\nelim: s => [|y s IHs]; first by constructor=> -[] [].\nrewrite in_cons; case: eqVneq => [->|/= Nxy]; first by constructor; exists 0.\napply: (iffP idP) => [/IHs[i <-]|[[|i]//=]]; first by exists i.+1.\n  by move=> [eq_xy]; rewrite eq_xy eqxx in Nxy.\nby move=> six; apply/IHs; exists i.\nQed.",
    "Lemma onthPn s x : reflect (forall i, onth s i != Some x) (x \\notin s).\nProof.\napply: (iffP idP); first by move=> /onthP + i; apply: contra_not_neq; exists i.\nby move=> nsix; apply/onthP => -[n /eqP/negPn]; rewrite nsix.\nQed.",
    "Lemma onth_inj s n m : uniq s -> minn m n < size s ->\n  onth s n = onth s m -> n = m.\nProof.\nelim: s m n => [|x s IHs]//= [|m] [|n]//=; rewrite ?minnSS !ltnS.\n- by move=> /andP[+ _] _ /eqP => /onthPn/(_ _)/negPf->.\n- by move=> /andP[+ _] _ /esym /eqP => /onthPn/(_ _)/negPf->.\nby move=> /andP[xNs /IHs]/[apply]/[apply]->.\nQed.",
    "Lemma filter_mask T a (s : seq T) : filter a s = mask (map a s) s.\nProof. by elim: s => //= x s <-; case: (a x). Qed.",
    "Lemma all_sigP T a (s : seq T) : all a s -> {s' : seq (sig a) | s = map sval s'}.\nProof.\nelim: s => /= [_|x s ihs /andP [ax /ihs [s' ->]]]; first by exists [::].\nby exists (exist a x ax :: s').\nQed.",
    "Lemma leq_count_mask T (P : {pred T}) m s : count P (mask m s) <= count P s.\nProof.\nby elim: s m => [|x s IHs] [|[] m]//=;\n   rewrite ?leq_add2l (leq_trans (IHs _)) ?leq_addl.\nQed.",
    "Lemma mask_filter s m : uniq s -> mask m s = [seq i <- s | i \\in mask m s].\nProof.\nelim: m s => [|[] m IH] [|x s /= /andP[/negP xS uS]]; rewrite ?filter_pred0 //.\n  rewrite inE eqxx /=; congr cons; rewrite [LHS]IH//.\n  by apply/eq_in_filter => ? /[1!inE]; case: eqP => [->|].\nby case: ifP => [/mem_mask //|_]; apply: IH.\nQed.",
    "Lemma leq_count_subseq P s1 s2 : subseq s1 s2 -> count P s1 <= count P s2.\nProof. by move=> /subseqP[m _ ->]; rewrite leq_count_mask. Qed.",
    "Lemma count_maskP s1 s2 :\n  (forall x, count_mem x s1 <= count_mem x s2) <->\n    exists2 m : bitseq, size m = size s2 & perm_eq s1 (mask m s2).\nProof.\nsplit=> [s1_le|[m _ /permP s1ms2 x]]; last by rewrite s1ms2 leq_count_mask.\nsuff [m mP]: exists m, perm_eq s1 (mask m s2).\n  by have [m' sm' eqm] := resize_mask m s2; exists m'; rewrite -?eqm.\nelim: s2 => [|x s2 IHs]//= in s1 s1_le *.\n  by exists [::]; apply/allP => x _/=; rewrite eqn_leq s1_le.\nhave [y|m s1s2] := IHs (rem x s1); first by rewrite count_mem_rem leq_subLR.\nexists ((x \\in s1) :: m); have [|/rem_id<-//] := boolP (x \\in s1).\nby move/perm_to_rem/permPl->; rewrite perm_cons.\nQed.",
    "Lemma count_subseqP s1 s2 :\n  (forall x, count_mem x s1 <= count_mem x s2) <->\n    exists2 s, subseq s s2 & perm_eq s1 s.\nProof.\nsplit=> [/count_maskP[m _]|]; first by exists (mask m s2); rewrite ?mask_subseq.\nby move=> -[_/subseqP[m sm ->] ?]; apply/count_maskP; exists m.\nQed.",
    "Lemma filter_subseq a s : subseq (filter a s) s.\nProof. by apply/subseqP; exists (map a s); rewrite ?size_map ?filter_mask. Qed.",
    "Lemma subseq_filter s1 s2 a :\n  subseq s1 (filter a s2) = all a s1 && subseq s1 s2.\nProof.\nelim: s2 s1 => [|x s2 IHs] [|y s1] //=; rewrite ?andbF ?sub0seq //.\nby case a_x: (a x); rewrite /= !IHs /=; case: eqP => // ->; rewrite a_x.\nQed.",
    "Lemma subseq_uniqP s1 s2 :\n  uniq s2 -> reflect (s1 = filter [in s1] s2) (subseq s1 s2).\nProof.\nmove=> uniq_s2; apply: (iffP idP) => [ss12 | ->]; last exact: filter_subseq.\napply/eqP; rewrite -size_subseq_leqif ?subseq_filter ?(introT allP) //.\napply/eqP/esym/perm_size.\nrewrite uniq_perm ?filter_uniq ?(subseq_uniq ss12) // => x.\nby rewrite mem_filter; apply: andb_idr; apply: (mem_subseq ss12).\nQed.",
    "Lemma uniq_subseq_pivot x (s1 s2 s3 s4 : seq T) (s := s3 ++ x :: s4) :\n  uniq s -> subseq (s1 ++ x :: s2) s = (subseq s1 s3 && subseq s2 s4).\nProof.\nmove=> uniq_s; apply/idP/idP => [sub_s'_s|/andP[? ?]]; last first.\n  by rewrite cat_subseq //= eqxx.\nhave uniq_s' := subseq_uniq sub_s'_s uniq_s.\nhave/eqP {sub_s'_s uniq_s} := subseq_uniqP _ uniq_s sub_s'_s.\nrewrite !filter_cat /= mem_cat inE eqxx orbT /=.\nrewrite uniq_eqseq_pivotl // => /andP [/eqP -> /eqP ->].\nby rewrite !filter_subseq.\nQed.",
    "Lemma perm_to_subseq s1 s2 :\n  subseq s1 s2 -> {s3 | perm_eq s2 (s1 ++ s3)}.\nProof.\nelim Ds2: s2 s1 => [|y s2' IHs] [|x s1] //=; try by exists s2; rewrite Ds2.\ncase: eqP => [-> | _] /IHs[s3 perm_s2] {IHs}.\n  by exists s3; rewrite perm_cons.\nby exists (rcons s3 y); rewrite -cat_cons -perm_rcons -!cats1 catA perm_cat2r.\nQed.",
    "Lemma subseq_rem x : {homo rem x : s1 s2 / @subseq T s1 s2}.\nProof.\nmove=> s1 s2; elim: s2 s1 => [|x2 s2 IHs2] [|x1 s1]; rewrite ?sub0seq //=.\nhave [->|_] := eqVneq x1 x2; first by case: eqP => //= _ /IHs2; rewrite eqxx.\nmove=> /IHs2/subseq_trans->//.\nby have [->|_] := eqVneq x x2; [apply: rem_subseq|apply: subseq_cons].\nQed.",
    "Lemma map_f s x : x \\in s -> f x \\in map f s.\nProof.\nby elim: s => //= y s IHs /predU1P[->|/IHs]; [apply: predU1l | apply: predU1r].\nQed.",
    "Lemma mapP s y : reflect (exists2 x, x \\in s & y = f x) (y \\in map f s).\nProof.\nelim: s => [|x s IHs]; [by right; case|rewrite /= inE].\nexact: equivP (orPP eqP IHs) (iff_sym exists_cons).\nQed.",
    "Lemma subset_mapP (s : seq T1) (s' : seq T2) :\n    {subset s' <= map f s} <-> exists2 t, all (mem s) t & s' = map f t.\nProof.\nsplit => [|[r /allP/= rE ->] _ /mapP[x xr ->]]; last by rewrite map_f ?rE.\nelim: s' => [|x s' IHs'] subss'; first by exists [::].\nhave /mapP[y ys ->] := subss' _ (mem_head _ _).\nhave [x' x's'|t st ->] := IHs'; first by rewrite subss'// inE x's' orbT.\nby exists (y :: t); rewrite //= ys st.\nQed.",
    "Lemma map_uniq s : uniq (map f s) -> uniq s.\nProof.\nelim: s => //= x s IHs /andP[not_sfx /IHs->]; rewrite andbT.\nby apply: contra not_sfx => sx; apply/mapP; exists x.\nQed.",
    "Lemma map_inj_in_uniq s : {in s &, injective f} -> uniq (map f s) = uniq s.\nProof.\nelim: s => //= x s IHs //= injf; congr (~~ _ && _).\n  apply/mapP/idP=> [[y sy /injf] | ]; last by exists x.\n  by rewrite mem_head mem_behead // => ->.\nby apply: IHs => y z sy sz; apply: injf => //; apply: predU1r.\nQed.",
    "Lemma map_subseq s1 s2 : subseq s1 s2 -> subseq (map f s1) (map f s2).\nProof.\ncase/subseqP=> m sz_m ->; apply/subseqP.\nby exists m; rewrite ?size_map ?map_mask.\nQed.",
    "Lemma nth_index_map s x0 x :\n  {in s &, injective f} -> x \\in s -> nth x0 s (index (f x) (map f s)) = x.\nProof.\nelim: s => //= y s IHs inj_f s_x; rewrite (inj_in_eq inj_f) ?mem_head //.\nmove: s_x; rewrite inE; have [-> // | _] := eqVneq; apply: IHs.\nby apply: sub_in2 inj_f => z; apply: predU1r.\nQed.",
    "Lemma perm_map s t : perm_eq s t -> perm_eq (map f s) (map f t).\nProof. by move/permP=> Est; apply/permP=> a; rewrite !count_map Est. Qed.",
    "Lemma sub_map s1 s2 : {subset s1 <= s2} -> {subset map f s1 <= map f s2}.\nProof. by move=> sub_s ? /mapP[x x_s ->]; rewrite map_f ?sub_s. Qed.",
    "Lemma eq_mem_map s1 s2 : s1 =i s2 -> map f s1 =i map f s2.\nProof. by move=> Es x; apply/idP/idP; apply: sub_map => ?; rewrite Es. Qed.",
    "Lemma mem_map s x : (f x \\in map f s) = (x \\in s).\nProof. by apply/mapP/idP=> [[y Hy /Hf->] //|]; exists x. Qed.",
    "Lemma index_map s x : index (f x) (map f s) = index x s.\nProof. by rewrite /index; elim: s => //= y s IHs; rewrite (inj_eq Hf) IHs. Qed.",
    "Lemma map_inj_uniq s : uniq (map f s) = uniq s.\nProof. by apply: map_inj_in_uniq; apply: in2W. Qed.",
    "Lemma undup_map_inj s : undup (map f s) = map f (undup s).\nProof. by elim: s => //= s0 s ->; rewrite mem_map //; case: (_ \\in _). Qed.",
    "Lemma perm_map_inj s t : perm_eq (map f s) (map f t) -> perm_eq s t.\nProof.\nmove/permP=> Est; apply/allP=> x _ /=.\nhave Dx: pred1 x =1 preim f (pred1 (f x)) by move=> y /=; rewrite inj_eq.\nby rewrite !(eq_count Dx) -!count_map Est.\nQed.",
    "Lemma map_of_seq (T1 : eqType) T2 (s : seq T1) (fs : seq T2) (y0 : T2) :\n  {f | uniq s -> size fs = size s -> map f s = fs}.\nProof.\nexists (fun x => nth y0 fs (index x s)) => uAs eq_sz.\napply/esym/(@eq_from_nth _ y0); rewrite ?size_map eq_sz // => i ltis.\nby have x0 : T1 by [case: (s) ltis]; rewrite (nth_map x0) // index_uniq.\nQed.",
    "Lemma map_id (s : seq T) : map id s = s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma eq_map (f g : S -> T) : f =1 g -> map f =1 map g.\nProof. by move=> Ef; elim=> //= x s ->; rewrite Ef. Qed.",
    "Lemma map_comp (f : T -> U) (g : S -> T) s : map (f \\o g) s = map f (map g s).\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma mapK (f : S -> T) (g : T -> S) : cancel f g -> cancel (map f) (map g).\nProof. by move=> fK; elim=> //= x s ->; rewrite fK. Qed.",
    "Lemma mapK_in (A : {pred S}) (f : S -> T) (g : T -> S) :\n  {in A, cancel f g} -> {in [pred s | all [in A] s], cancel (map f) (map g)}.\nProof. by move=> fK; elim=> //= x s IHs /andP[/fK-> /IHs->]. Qed.",
    "Lemma eq_in_map (S : eqType) T (f g : S -> T) (s : seq S) :\n  {in s, f =1 g} <-> map f s = map g s.\nProof.\nelim: s => //= x s IHs; split=> [/forall_cons[-> ?]|]; first by rewrite IHs.1.\nby move=> -[? ?]; apply/forall_cons; split=> [//|]; apply: IHs.2.\nQed.",
    "Lemma map_id_in (T : eqType) f (s : seq T) : {in s, f =1 id} -> map f s = s.\nProof. by move/eq_in_map->; apply: map_id. Qed.",
    "Lemma map_pK : pcancel g f -> cancel (map g) pmap.\nProof. by move=> gK; elim=> //= x s ->; rewrite gK. Qed.",
    "Lemma size_pmap s : size (pmap s) = count [eta f] s.\nProof. by elim: s => //= x s <-; case: (f _). Qed.",
    "Lemma pmapS_filter s : map some (pmap s) = map f (filter [eta f] s).\nProof. by elim: s => //= x s; case fx: (f x) => //= [u] <-; congr (_ :: _). Qed.",
    "Lemma pmap_filter s : map g (pmap s) = filter [eta f] s.\nProof. by elim: s => //= x s <-; rewrite -{3}(fK x); case: (f _). Qed.",
    "Lemma pmap_cat s t : pmap (s ++ t) = pmap s ++ pmap t.\nProof. by elim: s => //= x s ->; case/f: x. Qed.",
    "Lemma all_pmap (p : pred rT) s :\n  all p (pmap s) = all [pred i | oapp p true (f i)] s.\nProof. by elim: s => //= x s <-; case: f. Qed.",
    "Lemma eq_in_pmap (aT : eqType) rT (f1 f2 : aT -> option rT) s :\n  {in s, f1 =1 f2} -> pmap f1 s = pmap f2 s.\nProof. by elim: s => //= a s IHs /forall_cons [-> /IHs ->]. Qed.",
    "Lemma eq_pmap aT rT (f1 f2 : aT -> option rT) :\n  f1 =1 f2 -> pmap f1 =1 pmap f2.\nProof. by move=> Ef; elim => //= a s ->; rewrite Ef. Qed.",
    "Lemma mem_pmap s u : (u \\in pmap f s) = (Some u \\in map f s).\nProof. by elim: s => //= x s IHs; rewrite in_cons -IHs; case: (f x). Qed.",
    "Lemma can2_mem_pmap : pcancel g f -> forall s u, (u \\in pmap f s) = (g u \\in s).\nProof.\nby move=> gK s u; rewrite -(mem_map (pcan_inj gK)) pmap_filter // mem_filter gK.\nQed.",
    "Lemma pmap_uniq s : uniq s -> uniq (pmap f s).\nProof. move/(filter_uniq f); rewrite -(pmap_filter fK); exact: map_uniq. Qed.",
    "Lemma perm_pmap s t : perm_eq s t -> perm_eq (pmap f s) (pmap f t).\nProof.\nmove=> eq_st; apply/(perm_map_inj Some_inj); rewrite !pmapS_filter.\nexact/perm_map/perm_filter.\nQed.",
    "Lemma size_pmap_sub s : size (pmap (insub : T -> option sT) s) = count p s.\nProof. by rewrite size_pmap (eq_count (isSome_insub _)). Qed.",
    "Lemma mem_pmap_sub s u : (u \\in pmap insT s) = (val u \\in s).\nProof. exact/(can2_mem_pmap (insubK _))/valK. Qed.",
    "Lemma pmap_sub_uniq s : uniq s -> uniq (pmap insT s).\nProof. exact: (pmap_uniq (insubK _)). Qed.",
    "Lemma size_iota m n : size (iota m n) = n.\nProof. by elim: n m => //= n IHn m; rewrite IHn. Qed.",
    "Lemma iotaD m n1 n2 : iota m (n1 + n2) = iota m n1 ++ iota (m + n1) n2.\nProof. by elim: n1 m => [|n1 IHn1] m; rewrite ?addn0 // -addSnnS /= -IHn1. Qed.",
    "Lemma iotaDl m1 m2 n : iota (m1 + m2) n = map (addn m1) (iota m2 n).\nProof. by elim: n m2 => //= n IHn m2; rewrite -addnS IHn. Qed.",
    "Lemma nth_iota p m n i : i < n -> nth p (iota m n) i = m + i.\nProof.\nby move/subnKC <-; rewrite addSnnS iotaD nth_cat size_iota ltnn subnn.\nQed.",
    "Lemma mem_iota m n i : (i \\in iota m n) = (m <= i < m + n).\nProof.\nelim: n m => [|n IHn] /= m; first by rewrite addn0 ltnNge andbN.\nby rewrite in_cons IHn addnS ltnS; case: ltngtP => // ->; rewrite leq_addr.\nQed.",
    "Lemma iota_uniq m n : uniq (iota m n).\nProof. by elim: n m => //= n IHn m; rewrite mem_iota ltnn /=. Qed.",
    "Lemma take_iota k m n : take k (iota m n) = iota m (minn k n).\nProof.\nhave [lt_k_n|le_n_k] := ltnP.\n  by elim: k n lt_k_n m => [|k IHk] [|n] //= H m; rewrite IHk.\nby apply: take_oversize; rewrite size_iota.\nQed.",
    "Lemma drop_iota k m n : drop k (iota m n) = iota (m + k) (n - k).\nProof.\nby elim: k m n => [|k IHk] m [|n] //=; rewrite ?addn0 // IHk addnS subSS.\nQed.",
    "Lemma filter_iota_ltn m n j : j <= n ->\n  [seq i <- iota m n | i < m + j] = iota m j.\nProof.\nelim: n m j => [m j|n IHn m [|j] jlen]; first by rewrite leqn0 => /eqP ->.\n  rewrite (@eq_in_filter _ _ pred0) ?filter_pred0// => i.\n  by rewrite addn0 ltnNge mem_iota => /andP[->].\nby rewrite /= addnS leq_addr -addSn IHn.\nQed.",
    "Lemma filter_iota_leq n m j : j < n ->\n  [seq i <- iota m n | i <= m + j] = iota m j.+1.\nProof.\nelim: n m j => [//|n IHn] m [|j] jlen /=; rewrite leq_addr.\n  rewrite (@eq_in_filter _ _ pred0) ?filter_pred0// => i.\n  by rewrite addn0 leqNgt mem_iota => /andP[->].\nby rewrite addnS -addSn IHn -1?ltnS.\nQed.",
    "Lemma size_mkseq f n : size (mkseq f n) = n.\nProof. by rewrite size_map size_iota. Qed.",
    "Lemma mkseqS f n :\n  mkseq f n.+1 = rcons (mkseq f n) (f n).\nProof. by rewrite /mkseq -addn1 iotaD add0n map_cat cats1. Qed.",
    "Lemma eq_mkseq f g : f =1 g -> mkseq f =1 mkseq g.\nProof. by move=> Efg n; apply: eq_map Efg _. Qed.",
    "Lemma nth_mkseq f n i : i < n -> nth x0 (mkseq f n) i = f i.\nProof. by move=> Hi; rewrite (nth_map 0) ?nth_iota ?size_iota. Qed.",
    "Lemma mkseq_nth s : mkseq (nth x0 s) (size s) = s.\nProof.\nby apply: (@eq_from_nth _ x0); rewrite size_mkseq // => i Hi; rewrite nth_mkseq.\nQed.",
    "Lemma mkseqP s : mkseq_spec s s.\nProof. by rewrite -[s]mkseq_nth; constructor. Qed.",
    "Lemma map_nth_iota0 s i :\n  i <= size s -> [seq nth x0 s j | j <- iota 0 i] = take i s.\nProof.\nby move=> ile; rewrite -[s in RHS]mkseq_nth -map_take take_iota (minn_idPl _).\nQed.",
    "Lemma map_nth_iota s i j : j <= size s - i ->\n  [seq nth x0 s k | k <- iota i j] = take j (drop i s).\nProof.\nelim: i => [|i IH] in s j *; first by rewrite subn0 drop0 => /map_nth_iota0->.\ncase: s => [|x s /IH<-]; first by rewrite leqn0 => /eqP->.\nby rewrite -add1n iotaDl -map_comp.\nQed.",
    "Lemma mkseq_uniqP (f : nat -> T) n :\n  reflect {in gtn n &, injective f} (uniq (mkseq f n)).\nProof.\napply: (equivP (uniqP (f 0))); rewrite size_mkseq.\nby split=> injf i j lti ltj; have:= injf i j lti ltj; rewrite !nth_mkseq.\nQed.",
    "Lemma mkseq_uniq (f : nat -> T) n : injective f -> uniq (mkseq f n).\nProof. by move/map_inj_uniq->; apply: iota_uniq. Qed.",
    "Lemma perm_iotaP {s t : seq T} x0 (It := iota 0 (size t)) :\n  reflect (exists2 Is, perm_eq Is It & s = map (nth x0 t) Is) (perm_eq s t).\nProof.\napply: (iffP idP) => [Est | [Is eqIst ->]]; last first.\n  by rewrite -{2}[t](mkseq_nth x0) perm_map.\nelim: t => [|x t IHt] in s It Est *.\n  by rewrite (perm_small_eq _ Est) //; exists [::].\nhave /rot_to[k s1 Ds]: x \\in s by rewrite (perm_mem Est) mem_head.\nhave [|Is1 eqIst1 Ds1] := IHt s1; first by rewrite -(perm_cons x) -Ds perm_rot.\nexists (rotr k (0 :: map succn Is1)).\n  by rewrite perm_rot /It /= perm_cons (iotaDl 1) perm_map.\nby rewrite map_rotr /= -map_comp -(@eq_map _ _ (nth x0 t)) // -Ds1 -Ds rotK.\nQed.",
    "Lemma foldr_cat s1 s2 : foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1.\nProof. by elim: s1 => //= x s1 ->. Qed.",
    "Lemma foldr_rcons s x : foldr f z0 (rcons s x) = foldr f (f x z0) s.\nProof. by rewrite -cats1 foldr_cat. Qed.",
    "Lemma foldr_map s : foldr f z0 (map h s) = foldr (fun x z => f (h x) z) z0 s.\nProof. by elim: s => //= x s ->. Qed.",
    "Lemma sumn_ncons x n s : sumn (ncons n x s) = x * n + sumn s.\nProof. by rewrite mulnC; elim: n => //= n ->; rewrite addnA. Qed.",
    "Lemma sumn_nseq x n : sumn (nseq n x) = x * n.\nProof. by rewrite sumn_ncons addn0. Qed.",
    "Lemma sumn_cat s1 s2 : sumn (s1 ++ s2) = sumn s1 + sumn s2.\nProof. by elim: s1 => //= x s1 ->; rewrite addnA. Qed.",
    "Lemma sumn_count T (a : pred T) s : sumn [seq a i : nat | i <- s] = count a s.\nProof. by elim: s => //= s0 s /= ->. Qed.",
    "Lemma sumn_rcons s n : sumn (rcons s n) = sumn s + n.\nProof. by rewrite -cats1 sumn_cat /= addn0. Qed.",
    "Lemma perm_sumn s1 s2 : perm_eq s1 s2 -> sumn s1 = sumn s2.\nProof.\nby apply/catCA_perm_subst: s1 s2 => s1 s2 s3; rewrite !sumn_cat addnCA.\nQed.",
    "Lemma sumn_rot s n : sumn (rot n s) = sumn s.\nProof. by apply/perm_sumn; rewrite perm_rot. Qed.",
    "Lemma sumn_rev s : sumn (rev s) = sumn s.\nProof. by apply/perm_sumn; rewrite perm_rev. Qed.",
    "Lemma natnseq0P s : reflect (s = nseq (size s) 0) (sumn s == 0).\nProof.\napply: (iffP idP) => [|->]; last by rewrite sumn_nseq.\nby elim: s => //= x s IHs; rewrite addn_eq0 => /andP[/eqP-> /IHs <-].\nQed.",
    "Lemma sumn_set_nth s x0 n x :\n  sumn (set_nth x0 s n x) =\n    sumn s + x - (nth x0 s n) * (n < size s) + x0 * (n - size s).\nProof.\nrewrite set_nthE; case: ltnP => [nlts|nges]; last first.\n  by rewrite sumn_cat sumn_ncons /= addn0 muln0 subn0 addnAC addnA.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nrewrite -[in sumn s](cat_take_drop n s) [drop n s](drop_nth x0)//.\nby rewrite !sumn_cat /= muln1 muln0 addn0 addnAC !addnA [in RHS]addnAC addnK.\nQed.",
    "Lemma sumn_set_nth_ltn s x0 n x : n < size s ->\n  sumn (set_nth x0 s n x) = sumn s + x - nth x0 s n.\nProof.\nmove=> nlts; rewrite sumn_set_nth nlts muln1.\nhave -> : n - size s = 0 by apply/eqP; rewrite subn_eq0 ltnW.\nby rewrite muln0 addn0.\nQed.",
    "Lemma sumn_set_nth0 s n x : sumn (set_nth 0 s n x) = sumn s + x - nth 0 s n.\nProof.\nrewrite sumn_set_nth mul0n addn0.\nby case: ltnP => [_|nges]; rewrite ?muln1// nth_default.\nQed.",
    "Lemma foldl_rev z s : foldl z (rev s) = foldr (fun x z => f z x) z s.\nProof.\nby elim/last_ind: s z => // s x IHs z; rewrite rev_rcons -cats1 foldr_cat -IHs.\nQed.",
    "Lemma foldl_cat z s1 s2 : foldl z (s1 ++ s2) = foldl (foldl z s1) s2.\nProof.\nby rewrite -(revK (s1 ++ s2)) foldl_rev rev_cat foldr_cat -!foldl_rev !revK.\nQed.",
    "Lemma foldl_rcons z s x : foldl z (rcons s x) = f (foldl z s) x.\nProof. by rewrite -cats1 foldl_cat. Qed.",
    "Lemma foldl_foldr x0 l : foldl f x0 l = foldr f x0 l.\nProof.\nelim: l x0 => [//|x1 l IHl] x0 /=; rewrite {}IHl.\nby elim: l x0 x1 => [//|x2 l IHl] x0 x1 /=; rewrite IHl !fA [f x2 x1]fC.\nQed.",
    "Lemma size_pairmap x s : size (pairmap x s) = size s.\nProof. by elim: s x => //= y s IHs x; rewrite IHs. Qed.",
    "Lemma pairmap_cat x s1 s2 :\n  pairmap x (s1 ++ s2) = pairmap x s1 ++ pairmap (last x s1) s2.\nProof. by elim: s1 x => //= y s1 IHs1 x; rewrite IHs1. Qed.",
    "Lemma nth_pairmap s n : n < size s ->\n  forall x, nth x2 (pairmap x s) n = f (nth x1 (x :: s) n) (nth x1 s n).\nProof. by elim: s n => [|y s IHs] [|n] //= Hn x; apply: IHs. Qed.",
    "Lemma size_scanl x s : size (scanl x s) = size s.\nProof. by elim: s x => //= y s IHs x; rewrite IHs. Qed.",
    "Lemma scanl_cat x s1 s2 :\n  scanl x (s1 ++ s2) = scanl x s1 ++ scanl (foldl g x s1) s2.\nProof. by elim: s1 x => //= y s1 IHs1 x; rewrite IHs1. Qed.",
    "Lemma scanl_rcons x s1 y  :\n  scanl x (rcons s1 y) =  rcons (scanl x s1) (foldl g x (rcons s1 y)).\nProof. by rewrite -!cats1 scanl_cat foldl_cat. Qed.",
    "Lemma nth_cons_scanl s n : n <= size s ->\n  forall x, nth x1 (x :: scanl x s) n = foldl g x (take n s).\nProof. by elim: s n => [|y s IHs] [|n] Hn x //=; rewrite IHs. Qed.",
    "Lemma nth_scanl s n : n < size s ->\n  forall x, nth x1 (scanl x s) n = foldl g x (take n.+1 s).\nProof. by move=> n_lt x; rewrite -nth_cons_scanl. Qed.",
    "Lemma scanlK :\n  (forall x, cancel (g x) (f x)) -> forall x, cancel (scanl x) (pairmap x).\nProof. by move=> Hfg x s; elim: s x => //= y s IHs x; rewrite Hfg IHs. Qed.",
    "Lemma pairmapK :\n  (forall x, cancel (f x) (g x)) -> forall x, cancel (pairmap x) (scanl x).\nProof. by move=> Hgf x s; elim: s x => //= y s IHs x; rewrite Hgf IHs. Qed.",
    "Lemma zip_unzip s : zip (unzip1 s) (unzip2 s) = s.\nProof. by elim: s => [|[x y] s /= ->]. Qed.",
    "Lemma unzip1_zip s t : size s <= size t -> unzip1 (zip s t) = s.\nProof. by elim: s t => [|x s IHs] [|y t] //= le_s_t; rewrite IHs. Qed.",
    "Lemma unzip2_zip s t : size t <= size s -> unzip2 (zip s t) = t.\nProof. by elim: s t => [|x s IHs] [|y t] //= le_t_s; rewrite IHs. Qed.",
    "Lemma size1_zip s t : size s <= size t -> size (zip s t) = size s.\nProof. by elim: s t => [|x s IHs] [|y t] //= Hs; rewrite IHs. Qed.",
    "Lemma size2_zip s t : size t <= size s -> size (zip s t) = size t.\nProof. by elim: s t => [|x s IHs] [|y t] //= Hs; rewrite IHs. Qed.",
    "Lemma size_zip s t : size (zip s t) = minn (size s) (size t).\nProof. by elim: s t => [|x s IHs] [|t2 t] //=; rewrite IHs minnSS. Qed.",
    "Lemma zip_cat s1 s2 t1 t2 :\n  size s1 = size t1 -> zip (s1 ++ s2) (t1 ++ t2) = zip s1 t1 ++ zip s2 t2.\nProof. by move: s1 t1; apply: seq_ind2 => //= x y s1 t1 _ ->. Qed.",
    "Lemma nth_zip x y s t i :\n  size s = size t -> nth (x, y) (zip s t) i = (nth x s i, nth y t i).\nProof. by elim: i s t => [|i IHi] [|y1 s1] [|y2 t] //= [/IHi->]. Qed.",
    "Lemma nth_zip_cond p s t i :\n   nth p (zip s t) i\n     = (if i < size (zip s t) then (nth p.1 s i, nth p.2 t i) else p).\nProof.\nrewrite size_zip ltnNge geq_min.\nby elim: s t i => [|x s IHs] [|y t] [|i] //=; rewrite ?orbT -?IHs.\nQed.",
    "Lemma zip_rcons s t x y :\n  size s = size t -> zip (rcons s x) (rcons t y) = rcons (zip s t) (x, y).\nProof. by move=> eq_sz; rewrite -!cats1 zip_cat //= eq_sz. Qed.",
    "Lemma rev_zip s t : size s = size t -> rev (zip s t) = zip (rev s) (rev t).\nProof.\nmove: s t; apply: seq_ind2 => //= x y s t eq_sz IHs.\nby rewrite !rev_cons IHs zip_rcons ?size_rev.\nQed.",
    "Lemma all2E s t :\n  all2 s t = (size s == size t) && all [pred xy | r xy.1 xy.2] (zip s t).\nProof. by elim: s t => [|x s IHs] [|y t] //=; rewrite IHs andbCA. Qed.",
    "Lemma zip_map I f g (s : seq I) :\n  zip (map f s) (map g s) = [seq (f i, g i) | i <- s].\nProof. by elim: s => //= i s ->. Qed.",
    "Lemma unzip1_map_nth_zip x y s t l :\n  size s = size t -> \n  unzip1 [seq nth (x, y) (zip s t) i | i <- l] = [seq nth x s i | i <- l].\nProof. by move=> st; elim: l => [//=|n l IH /=]; rewrite nth_zip ?IH ?st. Qed.",
    "Lemma unzip2_map_nth_zip x y s t l :\n  size s = size t -> \n  unzip2 [seq nth (x, y) (zip s t) i | i <- l] = [seq nth y t i | i <- l].\nProof. by move=> st; elim: l => [//=|n l IH /=]; rewrite nth_zip ?IH ?st. Qed.",
    "Lemma zip_uniql (S T : eqType) (s : seq S) (t : seq T) : \n  uniq s -> uniq (zip s t).\nProof.\ncase: s t => [|s0 s] [|t0 t] //; apply: contraTT => /(uniqPn (s0, t0)) [i [j]].\ncase=> o z; rewrite !nth_zip_cond !ifT ?js ?(ltn_trans o)// => -[n _].\nby apply/(uniqPn s0); exists i, j; rewrite o n (leq_trans z) ?size_zip?geq_minl.\nQed.",
    "Lemma zip_uniqr (S T : eqType) (s : seq S) (t : seq T) : \n  uniq t -> uniq (zip s t).\nProof.\ncase: s t => [|s0 s] [|t0 t] //; apply: contraTT => /(uniqPn (s0, t0)) [i [j]].\ncase=> o z; rewrite !nth_zip_cond !ifT ?js ?(ltn_trans o)// => -[_ n].\nby apply/(uniqPn t0); exists i, j; rewrite o n (leq_trans z) ?size_zip?geq_minr.\nQed.",
    "Lemma perm_zip_sym (S T : eqType) (s1 s2 : seq S) (t1 t2 : seq T) : \n  perm_eq (zip s1 t1) (zip s2 t2) -> perm_eq (zip t1 s1) (zip t2 s2).\nProof.\nhave swap t s : zip t s = map (fun u => (u.2, u.1)) (zip s t).\n  by elim: s t => [|x s +] [|y t]//= => ->.\nby rewrite [zip t1 s1]swap [zip t2 s2]swap; apply: perm_map.\nQed.",
    "Lemma perm_zip1 {S T : eqType} (t1 t2 : seq T) (s1 s2 : seq S): \n  size s1 = size t1 -> size s2 = size t2 -> \n  perm_eq (zip s1 t1) (zip s2 t2) -> perm_eq s1 s2.\nProof.\nwlog [x y] : s1 s2 t1 t2 / (S * T)%type => [hwlog|].\n  case: s2 t2 => [|x s2] [|y t2] //; last exact: hwlog.\n  by case: s1 t1 => [|u s1] [|v t1]//= _ _ /perm_nilP.\nmove=> eq1 eq2 /(perm_iotaP (x, y))[ns nsP /(congr1 (@unzip1 _ _))].\nrewrite unzip1_zip ?unzip1_map_nth_zip -?eq1// => ->.\nby apply/(perm_iotaP x); exists ns; rewrite // size_zip -eq2 minnn in nsP.\nQed.",
    "Lemma perm_zip2 {S T : eqType} (s1 s2 : seq S) (t1 t2 : seq T) :\n  size s1 = size t1 -> size s2 = size t2 ->\n  perm_eq (zip s1 t1) (zip s2 t2) -> perm_eq t1 t2.\nProof. by move=> ? ? ?; rewrite (@perm_zip1 _ _ s1 s2) 1?perm_zip_sym. Qed.",
    "Lemma eqseq_all (T : eqType) (s t : seq T) : (s == t) = all2 eq_op s t.\nProof. by elim: s t => [|x s +] [|y t]//= => <-. Qed.",
    "Lemma eq_map_all I (T : eqType) (f g : I -> T) (s : seq I) :\n  (map f s == map g s) = all [pred xy | xy.1 == xy.2] [seq (f i, g i) | i <- s].\nProof. by rewrite eqseq_all all2E !size_map eqxx zip_map. Qed.",
    "Lemma size_flatten ss : size (flatten ss) = sumn (shape ss).\nProof. by elim: ss => //= s ss <-; rewrite size_cat. Qed.",
    "Lemma flatten_cat ss1 ss2 : flatten (ss1 ++ ss2) = flatten ss1 ++ flatten ss2.\nProof. by elim: ss1 => //= s ss1 ->; rewrite catA. Qed.",
    "Lemma size_reshape sh s : size (reshape sh s) = size sh.\nProof. by elim: sh s => //= s0 sh IHsh s; rewrite IHsh. Qed.",
    "Lemma nth_reshape (sh : seq nat) l n :\n  nth [::] (reshape sh l) n = take (nth 0 sh n) (drop (sumn (take n sh)) l).\nProof.\nelim: n sh l => [| n IHn] [| sh0 sh] l; rewrite ?take0 ?drop0 //=.\nby rewrite addnC -drop_drop; apply: IHn.\nQed.",
    "Lemma flattenK ss : reshape (shape ss) (flatten ss) = ss.\nProof.\nby elim: ss => //= s ss IHss; rewrite take_size_cat ?drop_size_cat ?IHss.\nQed.",
    "Lemma reshapeKr sh s : size s <= sumn sh -> flatten (reshape sh s) = s.\nProof.\nelim: sh s => [[]|n sh IHsh] //= s sz_s; rewrite IHsh ?cat_take_drop //.\nby rewrite size_drop leq_subLR.\nQed.",
    "Lemma reshapeKl sh s : size s >= sumn sh -> shape (reshape sh s) = sh.\nProof.\nelim: sh s => [[]|n sh IHsh] //= s sz_s.\nrewrite size_takel; last exact: leq_trans (leq_addr _ _) sz_s.\nby rewrite IHsh // -(leq_add2l n) size_drop -maxnE leq_max sz_s orbT.\nQed.",
    "Lemma flatten_rcons ss s : flatten (rcons ss s) = flatten ss ++ s.\nProof. by rewrite -cats1 flatten_cat /= cats0. Qed.",
    "Lemma flatten_seq1 s : flatten [seq [:: x] | x <- s] = s.\nProof. by elim: s => //= s0 s ->. Qed.",
    "Lemma count_flatten ss P :\n  count P (flatten ss) = sumn [seq count P x | x <- ss].\nProof. by elim: ss => //= s ss IHss; rewrite count_cat IHss. Qed.",
    "Lemma filter_flatten ss (P : pred T) :\n  filter P (flatten ss) = flatten [seq filter P i | i <- ss].\nProof. by elim: ss => // s ss /= <-; apply: filter_cat. Qed.",
    "Lemma rev_flatten ss :\n  rev (flatten ss) = flatten (rev (map rev ss)).\nProof.\nby elim: ss => //= s ss IHss; rewrite rev_cons flatten_rcons -IHss rev_cat.\nQed.",
    "Lemma nth_shape ss i : nth 0 (shape ss) i = size (nth [::] ss i).\nProof.\nrewrite /shape; case: (ltnP i (size ss)) => Hi; first exact: nth_map.\nby rewrite !nth_default // size_map.\nQed.",
    "Lemma shape_rev ss : shape (rev ss) = rev (shape ss).\nProof. exact: map_rev. Qed.",
    "Lemma eq_from_flatten_shape ss1 ss2 :\n  flatten ss1 = flatten ss2 -> shape ss1 = shape ss2 -> ss1 = ss2.\nProof. by move=> Eflat Esh; rewrite -[LHS]flattenK Eflat Esh flattenK. Qed.",
    "Lemma rev_reshape sh s :\n  size s = sumn sh -> rev (reshape sh s) = map rev (reshape (rev sh) (rev s)).\nProof.\nmove=> sz_s; apply/(canLR revK)/eq_from_flatten_shape.\n  rewrite reshapeKr ?sz_s // -rev_flatten reshapeKr ?revK //.\n  by rewrite size_rev sumn_rev sz_s.\ntransitivity (rev (shape (reshape (rev sh) (rev s)))).\n  by rewrite !reshapeKl ?revK ?size_rev ?sz_s ?sumn_rev.\nrewrite shape_rev; congr (rev _); rewrite -[RHS]map_comp.\nby under eq_map do rewrite /= size_rev.\nQed.",
    "Lemma reshape_rcons s sh n (m := sumn sh) :\n  m + n = size s ->\n  reshape (rcons sh n) s = rcons (reshape sh (take m s)) (drop m s).\nProof.\nmove=> Dmn; apply/(can_inj revK); rewrite rev_reshape ?rev_rcons ?sumn_rcons //.\nrewrite /= take_rev drop_rev -Dmn addnK revK -rev_reshape //.\nby rewrite size_takel // -Dmn leq_addr.\nQed.",
    "Lemma flatten_indexP sh r c :\n  c < nth 0 sh r -> flatten_index sh r c < sumn sh.\nProof.\nmove=> lt_c_sh; rewrite -[sh in sumn sh](cat_take_drop r) sumn_cat ltn_add2l.\nsuffices lt_r_sh: r < size sh by rewrite (drop_nth 0 lt_r_sh) ltn_addr.\nby case: ltnP => // le_sh_r; rewrite nth_default in lt_c_sh.\nQed.",
    "Lemma reshape_indexP sh i : i < sumn sh -> reshape_index sh i < size sh.\nProof.\nrewrite /reshape_index; elim: sh => //= n sh IHsh in i *; rewrite subn_eq0.\nby have [// | le_n_i] := ltnP i n; rewrite -leq_subLR subSn // => /IHsh.\nQed.",
    "Lemma reshape_offsetP sh i :\n  i < sumn sh -> reshape_offset sh i < nth 0 sh (reshape_index sh i).\nProof.\nrewrite /reshape_offset /reshape_index; elim: sh => //= n sh IHsh in i *.\nrewrite subn_eq0; have [| le_n_i] := ltnP i n; first by rewrite subn0.\nby rewrite -leq_subLR /= subnDA subSn // => /IHsh.\nQed.",
    "Lemma reshape_indexK sh i :\n  flatten_index sh (reshape_index sh i) (reshape_offset sh i) = i.\nProof.\nrewrite /reshape_offset /reshape_index /flatten_index -subSKn.\nelim: sh => //= n sh IHsh in i *; rewrite subn_eq0; have [//|le_n_i] := ltnP.\nby rewrite /= subnDA subSn // -addnA IHsh subnKC.\nQed.",
    "Lemma flatten_indexKl sh r c :\n  c < nth 0 sh r -> reshape_index sh (flatten_index sh r c) = r.\nProof.\nrewrite /reshape_index /flatten_index.\nelim: sh r => [|n sh IHsh] [|r] //= lt_c_sh; first by rewrite ifT.\nby rewrite -addnA -addnS addKn IHsh.\nQed.",
    "Lemma flatten_indexKr sh r c :\n  c < nth 0 sh r -> reshape_offset sh (flatten_index sh r c) = c.\nProof.\nrewrite /reshape_offset /reshape_index /flatten_index.\nelim: sh r => [|n sh IHsh] [|r] //= lt_c_sh; first by rewrite ifT ?subn0.\nby rewrite -addnA -addnS addKn /= subnDl IHsh.\nQed.",
    "Lemma nth_flatten x0 ss i (r := reshape_index (shape ss) i) :\n  nth x0 (flatten ss) i = nth x0 (nth [::] ss r) (reshape_offset (shape ss) i).\nProof.\nrewrite /reshape_offset -subSKn {}/r /reshape_index.\nelim: ss => //= s ss IHss in i *; rewrite subn_eq0 nth_cat.\nby have [//|le_s_i] := ltnP; rewrite subnDA subSn /=.\nQed.",
    "Lemma reshape_leq sh i1 i2\n  (r1 := reshape_index sh i1) (c1 := reshape_offset sh i1)\n  (r2 := reshape_index sh i2) (c2 := reshape_offset sh i2) :\n  (i1 <= i2) = ((r1 < r2) || ((r1 == r2) && (c1 <= c2))).\nProof.\nrewrite {}/r1 {}/c1 {}/r2 {}/c2 /reshape_offset /reshape_index.\nelim: sh => [|s0 s IHs] /= in i1 i2 *; rewrite ?subn0 ?subn_eq0 //.\nhave [[] i1s0 [] i2s0] := (ltnP i1 s0, ltnP i2 s0); first by rewrite !subn0.\n- by apply: leq_trans i2s0; apply/ltnW.\n- by apply/negP => /(leq_trans i1s0); rewrite leqNgt i2s0.\nby rewrite !subSn // !eqSS !ltnS !subnDA -IHs leq_subLR subnKC.\nQed.",
    "Lemma map_flatten S T (f : T -> S) ss :\n  map f (flatten ss) = flatten (map (map f) ss).\nProof. by elim: ss => // s ss /= <-; apply: map_cat. Qed.",
    "Lemma flatten_map1 (S T : Type) (f : S -> T) s :\n  flatten [seq [:: f x] | x <- s] = map f s.\nProof. by elim: s => //= s0 s ->. Qed.",
    "Lemma undup_flatten_nseq n (T : eqType) (s : seq T) : 0 < n ->\n  undup (flatten (nseq n s)) = undup s.\nProof.\nelim: n => [|[|n]/= IHn]//= _; rewrite ?cats0// undup_cat {}IHn//.\nrewrite (@eq_in_filter _ _ pred0) ?filter_pred0// => x.\nby rewrite mem_undup mem_cat => ->.\nQed.",
    "Lemma sumn_flatten (ss : seq (seq nat)) :\n  sumn (flatten ss) = sumn (map sumn ss).\nProof. by elim: ss => // s ss /= <-; apply: sumn_cat. Qed.",
    "Lemma map_reshape T S (f : T -> S) sh s :\n  map (map f) (reshape sh s) = reshape sh (map f s).\nProof. by elim: sh s => //= sh0 sh IHsh s; rewrite map_take IHsh map_drop. Qed.",
    "Lemma flattenP (A : seq (seq T)) x :\n  reflect (exists2 s, s \\in A & x \\in s) (x \\in flatten A).\nProof.\nelim: A => /= [|s A IH_A]; [by right; case | rewrite mem_cat].\nby apply: equivP (iff_sym exists_cons); apply: (orPP idP IH_A).\nQed.",
    "Lemma flatten_mapP (A : S -> seq T) s y :\n  reflect (exists2 x, x \\in s & y \\in A x) (y \\in flatten (map A s)).\nProof.\napply: (iffP flattenP) => [[_ /mapP[x sx ->]] | [x sx]] Axy; first by exists x.\nby exists (A x); rewrite ?map_f.\nQed.",
    "Lemma perm_flatten (ss1 ss2 : seq (seq T)) :\n  perm_eq ss1 ss2 -> perm_eq (flatten ss1) (flatten ss2).\nProof.\nmove=> eq_ss; apply/permP=> a; apply/catCA_perm_subst: ss1 ss2 eq_ss.\nby move=> ss1 ss2 ss3; rewrite !flatten_cat !count_cat addnCA.\nQed.",
    "Lemma prefixE s1 s2 : prefix s1 s2 = (take (size s1) s2 == s1).\nProof. by elim: s2 s1 => [|y s2 +] [|x s1]//= => ->; rewrite eq_sym. Qed.",
    "Lemma prefix_refl s : prefix s s. Proof. by rewrite prefixE take_size. Qed.",
    "Lemma prefixs0 s : prefix s [::] = (s == [::]). Proof. by case: s. Qed.",
    "Lemma prefix0s s : prefix [::] s. Proof. by case: s. Qed.",
    "Lemma prefix_cons s1 s2 x y :\n  prefix (x :: s1) (y :: s2) = (x == y) && prefix s1 s2.\nProof. by []. Qed.",
    "Lemma prefix_catr s1 s2 s1' s3 : size s1 = size s1' ->\n  prefix (s1 ++ s2) (s1' ++ s3) = (s1 == s1') && prefix s2 s3.\nProof.\nelim: s1 s1' => [|x s1 IHs1] [|y s1']//= [eqs1].\nby rewrite IHs1// eqseq_cons andbA.\nQed.",
    "Lemma prefix_prefix s1 s2 : prefix s1 (s1 ++ s2).\nProof. by rewrite prefixE take_cat ltnn subnn take0 cats0. Qed.",
    "Lemma prefixP {s1 s2} :\n  reflect (exists s2' : seq T, s2 = s1 ++ s2') (prefix s1 s2).\nProof.\napply: (iffP idP) => [|[{}s2 ->]]; last exact: prefix_prefix.\nby rewrite prefixE => /eqP<-; exists (drop (size s1) s2); rewrite cat_take_drop.\nQed.",
    "Lemma prefix_trans : transitive prefix.\nProof. by move=> _ s2 _ /prefixP[s1 ->] /prefixP[s3 ->]; rewrite -catA. Qed.",
    "Lemma prefixs1 s x : prefix s [:: x] = (s == [::]) || (s == [:: x]).\nProof. by case: s => //= y s; rewrite prefixs0 eqseq_cons. Qed.",
    "Lemma catl_prefix s1 s2 s3 : prefix (s1 ++ s3) s2 -> prefix s1 s2.\nProof. by move=> /prefixP [s2'] ->; rewrite -catA. Qed.",
    "Lemma prefix_catl s1 s2 s3 : prefix s1 s2 -> prefix s1 (s2 ++ s3).\nProof. by move=> /prefixP [s2'] ->; rewrite -catA. Qed.",
    "Lemma prefix_rcons s x : prefix s (rcons s x).\nProof. by rewrite -cats1 prefix_prefix. Qed.",
    "Lemma suffixE s1 s2 : suffix s1 s2 = (drop (size s2 - size s1) s2 == s1).\nProof. by rewrite /suffix prefixE take_rev (can_eq revK) size_rev. Qed.",
    "Lemma suffix_refl s : suffix s s.\nProof. exact: prefix_refl. Qed.",
    "Lemma suffixs0 s : suffix s [::] = (s == [::]).\nProof. by rewrite /suffix prefixs0 -!nilpE rev_nilp. Qed.",
    "Lemma suffix0s s : suffix [::] s.\nProof. exact: prefix0s. Qed.",
    "Lemma prefix_rev s1 s2 : prefix (rev s1) (rev s2) = suffix s1 s2.\nProof. by []. Qed.",
    "Lemma prefix_revLR s1 s2 : prefix (rev s1) s2 = suffix s1 (rev s2).\nProof. by rewrite -prefix_rev revK. Qed.",
    "Lemma suffix_rev s1 s2 : suffix (rev s1) (rev s2) = prefix s1 s2.\nProof. by rewrite -prefix_rev !revK. Qed.",
    "Lemma suffix_revLR s1 s2 : suffix (rev s1) s2 = prefix s1 (rev s2).\nProof. by rewrite -prefix_rev revK. Qed.",
    "Lemma suffix_suffix s1 s2 : suffix s2 (s1 ++ s2).\nProof. by rewrite /suffix rev_cat prefix_prefix. Qed.",
    "Lemma suffixP {s1 s2} :\n  reflect (exists s2' : seq T, s2 = s2' ++ s1) (suffix s1 s2).\nProof.\napply: (iffP prefixP) => [[s2' rev_s2]|[s2' ->]]; exists (rev s2'); last first.\n  by rewrite rev_cat.\nby rewrite -[s2]revK rev_s2 rev_cat revK.\nQed.",
    "Lemma suffix_trans : transitive suffix.\nProof. by move=> _ s2 _ /suffixP[s1 ->] /suffixP[s3 ->]; rewrite catA. Qed.",
    "Lemma suffix_rcons s1 s2 x y :\n  suffix (rcons s1 x) (rcons s2 y) = (x == y) && suffix s1 s2.\nProof. by rewrite /suffix 2!rev_rcons prefix_cons. Qed.",
    "Lemma suffix_catl s1 s2 s3 s3' : size s3 = size s3' ->\n  suffix (s1 ++ s3) (s2 ++ s3') = (s3 == s3') && suffix s1 s2.\nProof.\nby move=> eqs3; rewrite /suffix !rev_cat prefix_catr ?size_rev// (can_eq revK).\nQed.",
    "Lemma suffix_catr s1 s2 s3 : suffix s1 s2 -> suffix s1 (s3 ++ s2).\nProof. by move=> /suffixP [s2'] ->; rewrite catA suffix_suffix. Qed.",
    "Lemma catl_suffix s s1 s2 : suffix (s ++ s1) s2 -> suffix s1 s2.\nProof. by move=> /suffixP [s2'] ->; rewrite catA suffix_suffix. Qed.",
    "Lemma suffix_cons s x : suffix s (x :: s).\nProof. by rewrite /suffix rev_cons prefix_rcons. Qed.",
    "Lemma infix0s s : infix [::] s. Proof. by case: s. Qed.",
    "Lemma infixs0 s : infix s [::] = (s == [::]). Proof. by case: s. Qed.",
    "Lemma infix_consl s1 y s2 :\n  infix s1 (y :: s2) = prefix s1 (y :: s2) || infix s1 s2.\nProof. by []. Qed.",
    "Lemma infix_indexss s : infix_index s s = 0.\nProof. by case: s => //= x s; rewrite eqxx prefix_refl. Qed.",
    "Lemma infix_index_le s1 s2 : infix_index s1 s2 <= (size s2).+1.\nProof. by elim: s2 => [|x s2'] /=; case: ifP. Qed.",
    "Lemma infixTindex s1 s2 : (infix_index s1 s2 <= size s2) = infix s1 s2.\nProof. by elim: s2 s1 => [|y s2 +] [|x s1]//= => <-; case: ifP. Qed.",
    "Lemma infixPn s1 s2 :\n  reflect (infix_index s1 s2 = (size s2).+1) (~~ infix s1 s2).\nProof.\nrewrite -infixTindex -ltnNge; apply: (iffP idP) => [s2lt|->//].\nby apply/eqP; rewrite eqn_leq s2lt infix_index_le.\nQed.",
    "Lemma infix_index0s s : infix_index [::] s = 0.\nProof. by case: s. Qed.",
    "Lemma infix_indexs0 s : infix_index s [::] = (s != [::]).\nProof. by case: s. Qed.",
    "Lemma infixE s1 s2 : infix s1 s2 =\n   (take (size s1) (drop (infix_index s1 s2) s2) == s1).\nProof.\nelim: s2 s1 => [|y s2 +] [|x s1]//= => -> /=.\nby case: ifP => // /andP[/eqP-> ps1s2/=]; rewrite eqseq_cons -prefixE eqxx.\nQed.",
    "Lemma infix_refl s : infix s s.\nProof. by rewrite infixE infix_indexss// drop0 take_size. Qed.",
    "Lemma prefixW s1 s2 : prefix s1 s2 -> infix s1 s2.\nProof. by elim: s2 s1 => [|y s2 IHs2] [|x s1]//=->. Qed.",
    "Lemma prefix_infix s1 s2 : infix s1 (s1 ++ s2).\nProof. exact: prefixW. Qed.",
    "Lemma infix_infix s1 s2 s3 : infix s2 (s1 ++ s2 ++ s3).\nProof. by elim: s1 => //= x s1 ->; rewrite orbT. Qed.",
    "Lemma suffix_infix s1 s2 : infix s2 (s1 ++ s2).\nProof. by rewrite -[X in s1 ++ X]cats0. Qed.",
    "Lemma infixP {s1 s2} :\n  reflect (exists s s' : seq T, s2 = s ++ s1 ++ s') (infix s1 s2).\nProof.\napply: (iffP idP) => [|[p [s {s2}->]]]//=; rewrite infixE => /eqP<-.\nset k := infix_index _ _; exists (take k s2), (drop (size s1 + k) s2).\nby rewrite -drop_drop !cat_take_drop.\nQed.",
    "Lemma infix_rev s1 s2 : infix (rev s1) (rev s2) = infix s1 s2.\nProof.\ngen have sr : s1 s2 / infix s1 s2 -> infix (rev s1) (rev s2); last first.\n  by apply/idP/idP => /sr; rewrite ?revK.\nby move=> /infixP[s [p ->]]; rewrite !rev_cat -catA.\nQed.",
    "Lemma suffixW s1 s2 : suffix s1 s2 -> infix s1 s2.\nProof. by rewrite -infix_rev; apply: prefixW. Qed.",
    "Lemma infix_trans : transitive infix.\nProof.\nmove=> s s1 s2 /infixP[s1p [s1s def_s]] /infixP[sp [ss def_s2]].\nby apply/infixP; exists (sp ++ s1p),(s1s ++ ss); rewrite def_s2 def_s -!catA.\nQed.",
    "Lemma infix_revLR s1 s2 : infix (rev s1) s2 = infix s1 (rev s2).\nProof. by rewrite -infix_rev revK. Qed.",
    "Lemma infix_rconsl s1 s2 y :\n  infix s1 (rcons s2 y) = suffix s1 (rcons s2 y) || infix s1 s2.\nProof.\nrewrite -infix_rev rev_rcons infix_consl.\nby rewrite -rev_rcons prefix_rev infix_rev.\nQed.",
    "Lemma infix_cons s x : infix s (x :: s).\nProof. by rewrite -cat1s suffix_infix. Qed.",
    "Lemma infixs1 s x : infix s [:: x] = (s == [::]) || (s == [:: x]).\nProof. by rewrite infix_consl prefixs1 orbC orbA orbb. Qed.",
    "Lemma catl_infix s s1 s2 : infix (s ++ s1) s2 -> infix s1 s2.\nProof. apply: infix_trans; exact/suffixW/suffix_suffix. Qed.",
    "Lemma catr_infix s s1 s2 : infix (s1 ++ s) s2 -> infix s1 s2.\nProof.\nby rewrite -infix_rev rev_cat => /catl_infix; rewrite infix_rev.\nQed.",
    "Lemma cons2_infix s1 s2 x : infix (x :: s1) (x :: s2) -> infix s1 s2.\nProof.\nby rewrite /= eqxx /= -cat1s => /orP[/prefixW//|]; exact: catl_infix.\nQed.",
    "Lemma rcons2_infix s1 s2 x : infix (rcons s1 x) (rcons s2 x) -> infix s1 s2.\nProof. by rewrite -infix_rev !rev_rcons => /cons2_infix; rewrite infix_rev. Qed.",
    "Lemma catr2_infix s s1 s2 : infix (s ++ s1) (s ++ s2) -> infix s1 s2.\nProof. by elim: s => //= x s IHs /cons2_infix. Qed.",
    "Lemma catl2_infix s s1 s2 : infix (s1 ++ s) (s2 ++ s) -> infix s1 s2.\nProof. by rewrite -infix_rev !rev_cat => /catr2_infix; rewrite infix_rev. Qed.",
    "Lemma infix_catl s1 s2 s3 : infix s1 s2 -> infix s1 (s3 ++ s2).\nProof. by move=> is12; apply: infix_trans is12 (suffix_infix _ _). Qed.",
    "Lemma infix_catr s1 s2 s3 : infix s1 s2 -> infix s1 (s2 ++ s3).\nProof.\ncase: s3 => [|x s /infixP [p [sf]] ->]; first by rewrite cats0.\nby rewrite -catA; apply: infix_catl; rewrite -catA prefix_infix.\nQed.",
    "Lemma prefix_infix_trans s2 s1 s3 :\n  prefix s1 s2 -> infix s2 s3 -> infix s1 s3.\nProof. by move=> /prefixW/infix_trans; apply. Qed.",
    "Lemma suffix_infix_trans s2 s1 s3 :\n  suffix s1 s2 -> infix s2 s3 -> infix s1 s3.\nProof. by move=> /suffixW/infix_trans; apply. Qed.",
    "Lemma infix_prefix_trans s2 s1 s3 :\n  infix s1 s2 -> prefix s2 s3 -> infix s1 s3.\nProof. by move=> + /prefixW; apply: infix_trans. Qed.",
    "Lemma infix_suffix_trans s2 s1 s3 :\n  infix s1 s2 -> suffix s2 s3 -> infix s1 s3.\nProof. by move=> + /suffixW; apply: infix_trans. Qed.",
    "Lemma prefix_suffix_trans s2 s1 s3 :\n  prefix s1 s2 -> suffix s2 s3 -> infix s1 s3.\nProof. by move=> /prefixW + /suffixW +; apply: infix_trans. Qed.",
    "Lemma suffix_prefix_trans s2 s1 s3 :\n  suffix s1 s2 -> prefix s2 s3 -> infix s1 s3.\nProof. by move=> /suffixW + /prefixW +; apply: infix_trans. Qed.",
    "Lemma infixW s1 s2 : infix s1 s2 -> subseq s1 s2.\nProof.\nmove=> /infixP[sp [ss ->]].\nexact: subseq_trans (prefix_subseq _ _) (suffix_subseq _ _).\nQed.",
    "Lemma mem_infix s1 s2 : infix s1 s2 -> {subset s1 <= s2}.\nProof. by move=> /infixW subH; apply: mem_subseq. Qed.",
    "Lemma infix1s s x : infix [:: x] s = (x \\in s).\nProof. by elim: s => // x' s /= ->; rewrite in_cons prefix0s andbT. Qed.",
    "Lemma prefix1s s x : prefix [:: x] s -> x \\in s.\nProof. by rewrite -infix1s => /prefixW. Qed.",
    "Lemma suffix1s s x : suffix [:: x] s -> x \\in s.\nProof. by rewrite -infix1s => /suffixW. Qed.",
    "Lemma infix_rcons s x : infix s (rcons s x).\nProof. by rewrite -cats1 prefix_infix. Qed.",
    "Lemma infix_uniq s1 s2 : infix s1 s2 -> uniq s2 -> uniq s1.\nProof. by move=> /infixW /subseq_uniq subH. Qed.",
    "Lemma prefix_uniq s1 s2 : prefix s1 s2 -> uniq s2 -> uniq s1.\nProof. by move=> /prefixW /infix_uniq preH. Qed.",
    "Lemma suffix_uniq s1 s2 : suffix s1 s2 -> uniq s2 -> uniq s1.\nProof. by move=> /suffixW /infix_uniq preH. Qed.",
    "Lemma prefix_take s i : prefix (take i s) s.\nProof. by rewrite -{2}[s](cat_take_drop i). Qed.",
    "Lemma suffix_drop s i : suffix (drop i s) s.\nProof. by rewrite -{2}[s](cat_take_drop i). Qed.",
    "Lemma infix_take s i : infix (take i s) s.\nProof. by rewrite prefixW // prefix_take. Qed.",
    "Lemma prefix_drop_gt0 s i : ~~ prefix (drop i s) s -> i > 0.\nProof. by case: i => //=; rewrite drop0 ltnn prefix_refl. Qed.",
    "Lemma infix_drop s i : infix (drop i s) s.\nProof. by rewrite -{2}[s](cat_take_drop i). Qed.",
    "Lemma consr_infix s1 s2 x : infix (x :: s1) s2 -> infix [:: x] s2.\nProof. by rewrite -cat1s => /catr_infix. Qed.",
    "Lemma consl_infix s1 s2 x : infix (x :: s1) s2 -> infix s1 s2.\nProof. by rewrite -cat1s => /catl_infix. Qed.",
    "Lemma prefix_index s1 s2 : prefix s1 s2 -> infix_index s1 s2 = 0.\nProof. by case: s1 s2 => [|x s1] [|y s2] //= ->. Qed.",
    "Lemma size_infix s1 s2 : infix s1 s2 -> size s1 <= size s2.\nProof. by move=> /infixW; apply: size_subseq. Qed.",
    "Lemma size_prefix s1 s2 : prefix s1 s2 -> size s1 <= size s2.\nProof. by move=> /prefixW; apply: size_infix. Qed.",
    "Lemma size_suffix s1 s2 : suffix s1 s2 -> size s1 <= size s2.\nProof. by move=> /suffixW; apply: size_infix. Qed.",
    "Lemma size_allpairs_dep f s t :\n  size [seq f x y | x <- s, y <- t x] = sumn [seq size (t x) | x <- s].\nProof. by elim: s => //= x s IHs; rewrite size_cat size_map IHs. Qed.",
    "Lemma allpairs0l f t : [seq f x y | x <- [::], y <- t x] = [::].\nProof. by []. Qed.",
    "Lemma allpairs0r f s : [seq f x y | x <- s, y <- [::]] = [::].\nProof. by elim: s. Qed.",
    "Lemma allpairs1l f x t :\n   [seq f x y | x <- [:: x], y <- t x] = [seq f x y | y <- t x].\nProof. exact: cats0. Qed.",
    "Lemma allpairs1r f s y :\n  [seq f x y | x <- s, y <- [:: y x]] = [seq f x (y x) | x <- s].\nProof. exact: flatten_map1. Qed.",
    "Lemma allpairs_cons f x s t :\n  [seq f x y | x <- x :: s, y <- t x] =\n    [seq f x y | y <- t x] ++ [seq f x y | x <- s, y <- t x].\nProof. by []. Qed.",
    "Lemma eq_allpairs (f1 f2 : forall x, T x -> R) s t :\n    (forall x, f1 x =1 f2 x) ->\n  [seq f1 x y | x <- s, y <- t x] = [seq f2 x y | x <- s, y <- t x].\nProof. by move=> eq_f; under eq_map do under eq_map do rewrite eq_f. Qed.",
    "Lemma eq_allpairsr (f : forall x, T x -> R) s t1 t2 : (forall x, t1 x = t2 x) ->\n  [seq f x y | x <- s, y <- t1 x] = [seq f x y | x <- s, y <- t2 x].\nProof. by move=> eq_t; under eq_map do rewrite eq_t. Qed.",
    "Lemma allpairs_cat f s1 s2 t :\n  [seq f x y | x <- s1 ++ s2, y <- t x] =\n    [seq f x y | x <- s1, y <- t x] ++ [seq f x y | x <- s2, y <- t x].\nProof. by rewrite map_cat flatten_cat. Qed.",
    "Lemma allpairs_rcons f x s t :\n  [seq f x y | x <- rcons s x, y <- t x] =\n    [seq f x y | x <- s, y <- t x] ++ [seq f x y | y <- t x].\nProof. by rewrite -cats1 allpairs_cat allpairs1l. Qed.",
    "Lemma allpairs_mapl f (g : S' -> S) s t :\n  [seq f x y | x <- map g s, y <- t x] = [seq f (g x) y | x <- s, y <- t (g x)].\nProof. by rewrite -map_comp. Qed.",
    "Lemma allpairs_mapr f (g : forall x, T' x -> T x) s t :\n  [seq f x y | x <- s, y <- map (g x) (t x)] =\n    [seq f x (g x y) | x <- s, y <- t x].\nProof. by under eq_map do rewrite -map_comp. Qed.",
    "Lemma map_allpairs S T R R' (g : R' -> R) f s t :\n  map g [seq f x y | x : S <- s, y : T x <- t x] =\n    [seq g (f x y) | x <- s, y <- t x].\nProof. by rewrite map_flatten allpairs_mapl allpairs_mapr. Qed.",
    "Lemma size_allpairs s t : size [seq f x y | x <- s, y <- t] = size s * size t.\nProof. by elim: s => //= x s IHs; rewrite size_cat size_map IHs. Qed.",
    "Lemma allpairsPdep R (f : forall x, T x -> R) s t (z : R) :\n  reflect (exists x y, [/\\ x \\in s, y \\in t x & z = f x y])\n          (z \\in [seq f x y | x <- s, y <- t x]).\nProof.\napply: (iffP flatten_mapP); first by case=> x sx /mapP[y ty ->]; exists x, y.\nby case=> x [y [sx ty ->]]; exists x; last apply: map_f.\nQed.",
    "Lemma allpairs_f_dep f s t x y :\n  x \\in s -> y \\in t x -> f x y \\in [seq f x y | x <- s, y <- t x].\nProof. by move=> sx ty; apply/allpairsPdep; exists x, y. Qed.",
    "Lemma eq_in_allpairs_dep f1 f2 s t :\n    {in s, forall x, {in t x, f1 x =1 f2 x}} <->\n  [seq f1 x y : R | x <- s, y <- t x] = [seq f2 x y | x <- s, y <- t x].\nProof.\nsplit=> [eq_f | eq_fst x s_x].\n  by congr flatten; apply/eq_in_map=> x s_x; apply/eq_in_map/eq_f.\napply/eq_in_map; apply/eq_in_map: x s_x; apply/eq_from_flatten_shape => //.\nby rewrite /shape -!map_comp; apply/eq_map=> x /=; rewrite !size_map.\nQed.",
    "Lemma perm_allpairs_dep f s1 t1 s2 t2 :\n    perm_eq s1 s2 -> {in s1, forall x, perm_eq (t1 x) (t2 x)} ->\n  perm_eq [seq f x y | x <- s1, y <- t1 x] [seq f x y | x <- s2, y <- t2 x].\nProof.\nelim: s1 s2 t1 t2 => [s2 t1 t2 |a s1 IH s2 t1 t2 perm_s2 perm_t1].\n  by rewrite perm_sym => /perm_nilP->.\nhave mem_a : a \\in s2 by rewrite -(perm_mem perm_s2) inE eqxx.\nrewrite -[s2](cat_take_drop (index a s2)).\nrewrite allpairs_cat (drop_nth a) ?index_mem //= nth_index //=.\nrewrite perm_sym perm_catC -catA perm_cat //; last first.\n  rewrite perm_catC -allpairs_cat.\n  rewrite -remE perm_sym IH // => [|x xI]; last first.\n    by apply: perm_t1; rewrite inE xI orbT.\n  by rewrite -(perm_cons a) (perm_trans perm_s2 (perm_to_rem _)).\nhave /perm_t1 : a \\in a :: s1  by rewrite inE eqxx.\nrewrite perm_sym; elim: (t2 a) (t1 a) => /= [s4|b s3 IH1 s4 perm_s4].\n  by rewrite perm_sym => /perm_nilP->.\nhave mem_b : b \\in s4 by rewrite -(perm_mem perm_s4) inE eqxx.\nrewrite -[s4](cat_take_drop (index b s4)).\nrewrite map_cat /= (drop_nth b) ?index_mem //= nth_index //=.\nrewrite perm_sym perm_catC /= perm_cons // perm_catC -map_cat.\nrewrite -remE perm_sym IH1 // -(perm_cons b).\nby apply: perm_trans perm_s4 (perm_to_rem _).\nQed.",
    "Lemma mem_allpairs_dep f s1 t1 s2 t2 :\n    s1 =i s2 -> {in s1, forall x, t1 x =i t2 x} ->\n  [seq f x y | x <- s1, y <- t1 x] =i [seq f x y | x <- s2, y <- t2 x].\nProof.\nmove=> eq_s eq_t z; apply/allpairsPdep/allpairsPdep=> -[x [y [sx ty ->]]];\nby exists x, y; rewrite -eq_s in sx *; rewrite eq_t in ty *.\nQed.",
    "Lemma allpairs_uniq_dep f s t (st := [seq Tagged T y | x <- s, y <- t x]) :\n  let g (p : {x : S & T x}) : R := f (tag p) (tagged p) in\n    uniq s -> {in s, forall x, uniq (t x)} -> {in st &, injective g} ->\n  uniq [seq f x y | x <- s, y <- t x].\nProof.\nmove=> g Us Ut; rewrite -(map_allpairs g (existT T)) => /map_inj_in_uniq->{f g}.\nelim: s Us => //= x s IHs /andP[s'x Us] in st Ut *; rewrite {st}cat_uniq.\nrewrite {}IHs {Us}// ?andbT => [|x1 s_s1]; last exact/Ut/mem_behead.\nhave injT: injective (existT T x) by move=> y z /eqP; rewrite eq_Tagged => /eqP.\nrewrite (map_inj_in_uniq (in2W injT)) {injT}Ut ?mem_head // has_sym has_map.\nby apply: contra s'x => /hasP[y _ /allpairsPdep[z [_ [? _ /(congr1 tag)/=->]]]].\nQed.",
    "Lemma perm_allpairs_catr f s t1 t2 :\n  perm_eql [seq f x y | x <- s, y <- t1 x ++ t2 x]\n           ([seq f x y | x <- s, y <- t1 x] ++ [seq f x y | x <- s, y <- t2 x]).\nProof.\napply/permPl; rewrite perm_sym; elim: s => //= x s ihs.\nby rewrite perm_catACA perm_cat ?map_cat.\nQed.",
    "Lemma mem_allpairs_catr f s y0 t :\n  [seq f x y | x <- s, y <- y0 x ++ t x] =i\n    [seq f x y | x <- s, y <- y0 x] ++ [seq f x y | x <- s, y <- t x].\nProof. exact/perm_mem/permPl/perm_allpairs_catr. Qed.",
    "Lemma perm_allpairs_consr f s y0 t :\n  perm_eql [seq f x y | x <- s, y <- y0 x :: t x]\n           ([seq f x (y0 x) | x <- s] ++ [seq f x y | x <- s, y <- t x]).\nProof.\nby apply/permPl; rewrite (perm_allpairs_catr _ _ (fun=> [:: _])) allpairs1r.\nQed.",
    "Lemma mem_allpairs_consr f s t y0 :\n  [seq f x y | x <- s, y <- y0 x :: t x] =i\n  [seq f x (y0 x) | x <- s] ++ [seq f x y | x <- s, y <- t x].\nProof. exact/perm_mem/permPl/perm_allpairs_consr. Qed.",
    "Lemma allpairs_rconsr f s y0 t :\n  perm_eql [seq f x y | x <- s, y <- rcons (t x) (y0 x)]\n           ([seq f x y | x <- s, y <- t x] ++ [seq f x (y0 x) | x <- s]).\nProof.\napply/permPl; rewrite -(eq_allpairsr _ _ (fun=> cats1 _ _)).\nby rewrite perm_allpairs_catr allpairs1r.\nQed.",
    "Lemma mem_allpairs_rconsr f s t y0 :\n  [seq f x y | x <- s, y <- rcons (t x) (y0 x)] =i\n    ([seq f x y | x <- s, y <- t x] ++ [seq f x (y0 x) | x <- s]).\nProof. exact/perm_mem/permPl/allpairs_rconsr. Qed.",
    "Lemma all_allpairsP\n      (S : eqType) (T : S -> eqType) (R : Type)\n      (p : pred R) (f : forall x : S, T x -> R)\n      (s : seq S) (t : forall x : S, seq (T x)) :\n  reflect (forall (x : S) (y : T x), x \\in s -> y \\in t x -> p (f x y))\n          (all p [seq f x y | x <- s, y <- t x]).\nProof.\nelim: s => [|x s IHs]; first by constructor.\nrewrite /= all_cat all_map /preim.\napply/(iffP andP)=> [[/allP /= ? ? x' y x'_in_xs]|p_xs_t].\n  by move: x'_in_xs y => /[1!inE] /predU1P [-> //|? ?]; exact: IHs.\nsplit; first by apply/allP => ?; exact/p_xs_t/mem_head.\nby apply/IHs => x' y x'_in_s; apply: p_xs_t; rewrite inE x'_in_s orbT.\nQed.",
    "Lemma allpairsP f s t (z : R) :\n  reflect (exists p, [/\\ p.1 \\in s, p.2 \\in t & z = f p.1 p.2])\n          (z \\in [seq f x y | x <- s, y <- t]).\nProof.\nby apply: (iffP allpairsPdep) => [[x[y]]|[[x y]]]; [exists (x, y)|exists x, y].\nQed.",
    "Lemma allpairs_f f s t x y :\n  x \\in s -> y \\in t -> f x y \\in [seq f x y | x <- s, y <- t].\nProof. exact: allpairs_f_dep. Qed.",
    "Lemma eq_in_allpairs f1 f2 s t :\n    {in s & t, f1 =2 f2} <->\n  [seq f1 x y : R | x <- s, y <- t] = [seq f2 x y | x <- s, y <- t].\nProof.\nsplit=> [eq_f | /eq_in_allpairs_dep-eq_f x y /eq_f/(_ y)//].\nby apply/eq_in_allpairs_dep=> x /eq_f.\nQed.",
    "Lemma perm_allpairs f s1 t1 s2 t2 :\n    perm_eq s1 s2 -> perm_eq t1 t2 ->\n  perm_eq [seq f x y | x <- s1, y <- t1] [seq f x y | x <- s2, y <- t2].\nProof. by move=> perm_s perm_t; apply: perm_allpairs_dep. Qed.",
    "Lemma mem_allpairs f s1 t1 s2 t2 :\n    s1 =i s2 -> t1 =i t2 ->\n  [seq f x y | x <- s1, y <- t1] =i [seq f x y | x <- s2, y <- t2].\nProof. by move=> eq_s eq_t; apply: mem_allpairs_dep. Qed.",
    "Lemma allpairs_uniq f s t (st := [seq (x, y) | x <- s, y <- t]) :\n    uniq s -> uniq t -> {in st &, injective (uncurry f)} ->\n  uniq [seq f x y | x <- s, y <- t].\nProof.\nmove=> Us Ut inj_f; rewrite -(map_allpairs (uncurry f) (@pair S T)) -/st.\nrewrite map_inj_in_uniq // allpairs_uniq_dep {Us Ut st inj_f}//.\nby apply: in2W => -[x1 y1] [x2 y2] /= [-> ->].\nQed.",
    "Lemma allrel0l ys : allrel [::] ys. Proof. by []. Qed.",
    "Lemma allrel0r xs : allrel xs [::]. Proof. by elim: xs. Qed.",
    "Lemma allrel_consl x xs ys : allrel (x :: xs) ys = all (r x) ys && allrel xs ys.\nProof. by []. Qed.",
    "Lemma allrel_consr xs y ys :\n  allrel xs (y :: ys) = all (r^~ y) xs && allrel xs ys.\nProof. exact: all_predI. Qed.",
    "Lemma allrel_cons2 x y xs ys :\n  allrel (x :: xs) (y :: ys) =\n  [&& r x y, all (r x) ys, all (r^~ y) xs & allrel xs ys].\nProof. by rewrite /= allrel_consr -andbA. Qed.",
    "Lemma allrel1l x ys : allrel [:: x] ys = all (r x) ys. Proof. exact: andbT. Qed.",
    "Lemma allrel1r xs y : allrel xs [:: y] = all (r^~ y) xs.\nProof. by rewrite allrel_consr allrel0r andbT. Qed.",
    "Lemma allrel_catl xs xs' ys :\n  allrel (xs ++ xs') ys = allrel xs ys && allrel xs' ys.\nProof. exact: all_cat. Qed.",
    "Lemma allrel_catr xs ys ys' :\n  allrel xs (ys ++ ys') = allrel xs ys && allrel xs ys'.\nProof.\nelim: ys => /= [|y ys ihys]; first by rewrite allrel0r.\nby rewrite !allrel_consr ihys andbA.\nQed.",
    "Lemma allrel_maskl m xs ys : allrel xs ys -> allrel (mask m xs) ys.\nProof.\nby elim: m xs => [|[] m IHm] [|x xs] //= /andP [xys /IHm->]; rewrite ?xys.\nQed.",
    "Lemma allrel_maskr m xs ys : allrel xs ys -> allrel xs (mask m ys).\nProof. by elim: xs => //= x xs IHxs /andP [/all_mask->]. Qed.",
    "Lemma allrel_filterl a xs ys : allrel xs ys -> allrel (filter a xs) ys.\nProof. by rewrite filter_mask; apply: allrel_maskl. Qed.",
    "Lemma allrel_filterr a xs ys : allrel xs ys -> allrel xs (filter a ys).\nProof. by rewrite filter_mask; apply: allrel_maskr. Qed.",
    "Lemma allrel_allpairsE xs ys :\n  allrel xs ys = all id [seq r x y | x <- xs, y <- ys].\nProof. by elim: xs => //= x xs ->; rewrite all_cat all_map. Qed.",
    "Lemma sub_in_allrel\n      {T S : Type} (P : {pred T}) (Q : {pred S}) (r r' : T -> S -> bool) :\n  {in P & Q, forall x y, r x y -> r' x y} ->\n  forall xs ys, all P xs -> all Q ys -> allrel r xs ys -> allrel r' xs ys.\nProof.\nmove=> rr' + ys; elim=> //= x xs IHxs /andP [Px Pxs] Qys.\nrewrite !allrel_consl => /andP [+ {}/IHxs-> //]; rewrite andbT.\nby elim: ys Qys => //= y ys IHys /andP [Qy Qys] /andP [/rr'-> // /IHys->].\nQed.",
    "Lemma sub_allrel {T S : Type} (r r' : T -> S -> bool) :\n  (forall x y, r x y -> r' x y) ->\n  forall xs ys, allrel r xs ys -> allrel r' xs ys.\nProof.\nby move=> rr' xs ys; apply/sub_in_allrel/all_predT/all_predT; apply: in2W.\nQed.",
    "Lemma eq_in_allrel {T S : Type} (P : {pred T}) (Q : {pred S}) r r' :\n  {in P & Q, r =2 r'} ->\n  forall xs ys, all P xs -> all Q ys -> allrel r xs ys = allrel r' xs ys.\nProof.\nmove=> rr' xs ys Pxs Qys.\nby apply/idP/idP; apply/sub_in_allrel/Qys/Pxs => ? ? ? ?; rewrite rr'.\nQed.",
    "Lemma eq_allrel {T S : Type} (r r' : T -> S -> bool) :\n  r =2 r' -> allrel r =2 allrel r'.\nProof. by move=> rr' xs ys; apply/eq_in_allrel/all_predT/all_predT. Qed.",
    "Lemma allrelC {T S : Type} (r : T -> S -> bool) xs ys :\n  allrel r xs ys = allrel (fun y => r^~ y) ys xs.\nProof. by elim: xs => [|x xs ih]; [elim: ys | rewrite allrel_consr -ih]. Qed.",
    "Lemma allrel_mapl {T T' S : Type} (f : T' -> T) (r : T -> S -> bool) xs ys :\n  allrel r (map f xs) ys = allrel (fun x => r (f x)) xs ys.\nProof. exact: all_map. Qed.",
    "Lemma allrel_mapr {T S S' : Type} (f : S' -> S) (r : T -> S -> bool) xs ys :\n  allrel r xs (map f ys) = allrel (fun x y => r x (f y)) xs ys.\nProof. by rewrite allrelC allrel_mapl allrelC. Qed.",
    "Lemma allrelP {T S : eqType} {r : T -> S -> bool} {xs ys} :\n  reflect {in xs & ys, forall x y, r x y} (allrel r xs ys).\nProof. by rewrite allrel_allpairsE; exact: all_allpairsP. Qed.",
    "Lemma allrelT {T S : Type} (xs : seq T) (ys : seq S) :\n  allrel (fun _ _ => true) xs ys = true.\nProof. by elim: xs => //= ? ?; rewrite allrel_consl all_predT. Qed.",
    "Lemma allrel_relI {T S : Type} (r r' : T -> S -> bool) xs ys :\n  allrel (fun x y => r x y && r' x y) xs ys = allrel r xs ys && allrel r' xs ys.\nProof. by rewrite -all_predI; apply: eq_all => ?; rewrite /= -all_predI. Qed.",
    "Lemma allrel_revl {T S : Type} (r : T -> S -> bool) (s1 : seq T) (s2 : seq S) :\n  allrel r (rev s1) s2 = allrel r s1 s2.\nProof. exact: all_rev. Qed.",
    "Lemma allrel_revr {T S : Type} (r : T -> S -> bool) (s1 : seq T) (s2 : seq S) :\n  allrel r s1 (rev s2) = allrel r s1 s2.\nProof. by rewrite allrelC allrel_revl allrelC. Qed.",
    "Lemma allrel_rev2 {T S : Type} (r : T -> S -> bool) (s1 : seq T) (s2 : seq S) :\n  allrel r (rev s1) (rev s2) = allrel r s1 s2.\nProof. by rewrite allrel_revr allrel_revl. Qed.",
    "Lemma eq_allrel_meml {T : eqType} {S} (r : T -> S -> bool) (s1 s1' : seq T) s2 :\n  s1 =i s1' -> allrel r s1 s2 = allrel r s1' s2.\nProof. by move=> eqs1; apply: eq_all_r. Qed.",
    "Lemma eq_allrel_memr {T} {S : eqType} (r : T -> S -> bool) s1 (s2 s2' : seq S) :\n  s2 =i s2' -> allrel r s1 s2 = allrel r s1 s2'.\nProof. by rewrite ![allrel _ s1 _]allrelC; apply: eq_allrel_meml. Qed.",
    "Lemma eq_allrel_mem2 {T S : eqType} (r : T -> S -> bool)\n    (s1 s1' : seq T) (s2 s2' : seq S) :\n  s1 =i s1' -> s2 =i s2' -> allrel r s1 s2 = allrel r s1' s2'.\nProof. by move=> /eq_allrel_meml -> /eq_allrel_memr ->. Qed.",
    "Lemma all2rel1 x : all2rel r [:: x] = r x x.\nProof. by rewrite /allrel /= !andbT. Qed.",
    "Lemma all2rel2 x y : all2rel r [:: x; y] = r x x && r y y && r x y.\nProof. by rewrite /allrel /= rsym; do 3 case: r. Qed.",
    "Lemma all2rel_cons x xs :\n  all2rel r (x :: xs) = [&& r x x, all (r x) xs & all2rel r xs].\nProof.\nrewrite allrel_cons2; congr andb; rewrite andbA -all_predI; congr andb.\nby elim: xs => //= y xs ->; rewrite rsym andbb.\nQed.",
    "Lemma pairwise_cons x xs : pairwise (x :: xs) = all (r x) xs && pairwise xs.\nProof. by []. Qed.",
    "Lemma pairwise_cat xs ys :\n  pairwise (xs ++ ys) = [&& allrel r xs ys, pairwise xs & pairwise ys].\nProof. by elim: xs => //= x xs ->; rewrite all_cat -!andbA; bool_congr. Qed.",
    "Lemma pairwise_rcons xs x :\n  pairwise (rcons xs x) = all (r^~ x) xs && pairwise xs.\nProof. by rewrite -cats1 pairwise_cat allrel1r andbT. Qed.",
    "Lemma pairwise2 x y : pairwise [:: x; y] = r x y.\nProof. by rewrite /= !andbT. Qed.",
    "Lemma pairwise_mask m xs : pairwise xs -> pairwise (mask m xs).\nProof.\nby elim: m xs => [|[] m IHm] [|x xs] //= /andP [? ?]; rewrite ?IHm // all_mask.\nQed.",
    "Lemma pairwise_filter a xs : pairwise xs -> pairwise (filter a xs).\nProof. by rewrite filter_mask; apply: pairwise_mask. Qed.",
    "Lemma pairwiseP x0 xs :\n  reflect {in gtn (size xs) &, {homo nth x0 xs : i j / i < j >-> r i j}}\n          (pairwise xs).\nProof.\nelim: xs => /= [|x xs IHxs]; first exact: (iffP idP).\napply: (iffP andP) => [[r_x_xs pxs] i j|Hnth]; rewrite -?topredE /= ?ltnS.\n  by case: i j => [|i] [|j] //= gti gtj ij; [exact/all_nthP | exact/IHxs].\nsplit; last by apply/IHxs => // i j; apply/(Hnth i.+1 j.+1).\nby apply/(all_nthP x0) => i gti; apply/(Hnth 0 i.+1).\nQed.",
    "Lemma pairwise_all2rel :\n  reflexive r -> symmetric r -> forall xs, pairwise xs = all2rel r xs.\nProof.\nby move=> r_refl r_sym; elim => //= x xs ->; rewrite all2rel_cons // r_refl.\nQed.",
    "Lemma sub_in_pairwise {T : Type} (P : {pred T}) (r r' : rel T) :\n  {in P &, subrel r r'} ->\n  forall xs, all P xs -> pairwise r xs -> pairwise r' xs.\nProof.\nmove=> rr'; elim=> //= x xs IHxs /andP [Px Pxs] /andP [+ {}/IHxs->] //.\nrewrite andbT; elim: xs Pxs => //= x' xs IHxs /andP [? ?] /andP [+ /IHxs->] //.\nby rewrite andbT; apply: rr'.\nQed.",
    "Lemma sub_pairwise {T : Type} (r r' : rel T) xs :\n  subrel r r' -> pairwise r xs -> pairwise r' xs.\nProof. by move=> rr'; apply/sub_in_pairwise/all_predT; apply: in2W. Qed.",
    "Lemma eq_in_pairwise {T : Type} (P : {pred T}) (r r' : rel T) :\n  {in P &, r =2 r'} -> forall xs, all P xs -> pairwise r xs = pairwise r' xs.\nProof.\nmove=> rr' xs Pxs.\nby apply/idP/idP; apply/sub_in_pairwise/Pxs => ? ? ? ?; rewrite rr'.\nQed.",
    "Lemma eq_pairwise {T : Type} (r r' : rel T) :\n  r =2 r' -> pairwise r =i pairwise r'.\nProof. by move=> rr' xs; apply/eq_in_pairwise/all_predT. Qed.",
    "Lemma pairwise_map {T T' : Type} (f : T' -> T) (r : rel T) xs :\n  pairwise r (map f xs) = pairwise (relpre f r) xs.\nProof. by elim: xs => //= x xs ->; rewrite all_map. Qed.",
    "Lemma pairwise_relI {T : Type} (r r' : rel T) (s : seq T) :\n  pairwise [rel x y | r x y && r' x y] s = pairwise r s && pairwise r' s.\nProof. by elim: s => //= x s ->; rewrite andbACA all_predI. Qed.",
    "Lemma subseq_pairwise xs ys : subseq xs ys -> pairwise r ys -> pairwise r xs.\nProof. by case/subseqP => m _ ->; apply: pairwise_mask. Qed.",
    "Lemma uniq_pairwise xs : uniq xs = pairwise [rel x y | x != y] xs.\nProof.\nelim: xs => //= x xs ->; congr andb; rewrite -has_pred1 -all_predC.\nby elim: xs => //= x' xs ->; case: eqVneq.\nQed.",
    "Lemma pairwise_uniq xs : irreflexive r -> pairwise r xs -> uniq xs.\nProof.\nmove=> r_irr; rewrite uniq_pairwise; apply/sub_pairwise => x y.\nby apply: contraTneq => ->; rewrite r_irr.\nQed.",
    "Lemma pairwise_eq : antisymmetric r ->\n  forall xs ys, pairwise r xs -> pairwise r ys -> perm_eq xs ys -> xs = ys.\nProof.\nmove=> r_asym; elim=> [|x xs IHxs] [|y ys] //=; try by move=> ? ? /perm_size.\nmove=> /andP [r_x_xs pxs] /andP [r_y_ys pys] eq_xs_ys.\nmove: (mem_head y ys) (mem_head x xs).\nrewrite -(perm_mem eq_xs_ys) [x \\in _](perm_mem eq_xs_ys) !inE.\ncase: eqVneq eq_xs_ys => /= [->|ne_xy] eq_xs_ys ys_x xs_y.\n  by rewrite (IHxs ys) // -(perm_cons x).\nby case/eqP: ne_xy; apply: r_asym; rewrite (allP r_x_xs) ?(allP r_y_ys).\nQed.",
    "Lemma pairwise_trans s : antisymmetric r ->\n   pairwise r s -> {in s & &, transitive r}.\nProof.\nmove=> /(_ _ _ _)/eqP r_anti + y x z => /pairwiseP-/(_ y) ltP ys xs zs.\nhave [-> //|neqxy] := eqVneq x y; have [-> //|neqzy] := eqVneq z y.\nmove=> lxy lyz; move: ys xs zs lxy neqxy lyz neqzy.\nmove=> /(nthP y)[j jlt <-] /(nthP y)[i ilt <-] /(nthP y)[k klt <-].\nhave [ltij|ltji|->] := ltngtP i j; last 2 first.\n- by move=> leij; rewrite r_anti// leij ltP.\n- by move=> lejj; rewrite r_anti// lejj.\nmove=> _ _; have [ltjk|ltkj|->] := ltngtP j k; last 2 first.\n- by move=> lejk; rewrite r_anti// lejk ltP.\n- by move=> lekk; rewrite r_anti// lekk.\nby move=> _ _; apply: (ltP) => //; apply: ltn_trans ltjk.\nQed.",
    "Lemma size_tally_seq bs : size (tally_seq bs) = sumn (unzip2 bs).\nProof.\nby rewrite size_flatten /shape -map_comp; under eq_map do rewrite /= size_nseq.\nQed.",
    "Lemma tally_seqK : {in wf_tally, cancel tally_seq tally}.\nProof.\nmove=> bs /andP[]; elim: bs => [|[x [|n]] bs IHbs] //= /andP[bs'x Ubs] bs'0.\nrewrite inE /tseq /tally /= -[n.+1]addn1 in bs'0 *.\nelim: n 1 => /= [|n IHn] m; last by rewrite eqxx IHn addnS.\nrewrite -{}[in RHS]IHbs {Ubs bs'0}// /tally /tally_seq add0n.\nelim: bs bs'x [::] => [|[y n] bs IHbs] //= /[1!inE] /norP[y'x bs'x].\nby elim: n => [|n IHn] bs1 /=; [rewrite IHbs | rewrite eq_sym ifN // IHn].\nQed.",
    "Lemma incr_tallyP x : {homo incr_tally^~ x : bs / bs \\in wf_tally}.\nProof.\nmove=> bs /andP[]; rewrite unfold_in.\nelim: bs => [|[y [|n]] bs IHbs] //= /andP[bs'y Ubs] /[1!inE] /= bs'0.\nhave [<- | y'x] /= := eqVneq y; first by rewrite bs'y Ubs.\nrewrite -andbA {}IHbs {Ubs bs'0}// andbT.\nelim: bs bs'y => [|b bs IHbs] /=; rewrite inE ?y'x // => /norP[b'y bs'y].\nby case: ifP => _; rewrite /= inE negb_or ?y'x // b'y IHbs.\nQed.",
    "Lemma tallyP s : tally s \\is a wf_tally.\nProof.\nrewrite /tally; set bs := [::]; have: bs \\in wf_tally by [].\nby elim: s bs => //= x s IHs bs /(incr_tallyP x)/IHs.\nQed.",
    "Lemma tallyK s : perm_eq (tally_seq (tally s)) s.\nProof.\nrewrite -[s in perm_eq _ s]cats0 -[nil]/(tseq [::]) /tally.\nelim: s [::] => //= x s IHs bs; rewrite {IHs}(permPl (IHs _)).\nrewrite perm_sym -cat1s perm_catCA {s}perm_cat2l.\nelim: bs => //= b bs IHbs; case: eqP => [-> | _] //=.\nby rewrite -cat1s perm_catCA perm_cat2l.\nQed.",
    "Lemma tallyEl s : perm_eq (unzip1 (tally s)) (undup s).\nProof.\nhave /andP[Ubs bs'0] := tallyP s; set bs := tally s in Ubs bs'0 *.\nrewrite uniq_perm ?undup_uniq {Ubs}// => x.\nrewrite mem_undup -(perm_mem (tallyK s)) -/bs.\nelim: bs => [|[y [|m]] bs IHbs] //= in bs'0 *.\nby rewrite inE IHbs // mem_cat mem_nseq.\nQed.",
    "Lemma tallyE s : perm_eq (tally s) [seq (x, count_mem x s) | x <- undup s].\nProof.\nhave /andP[Ubs _] := tallyP s; pose b := [fun s x => (x, count_mem x (tseq s))].\nsuffices /permPl->: perm_eq (tally s) (map (b (tally s)) (unzip1 (tally s))).\n  congr perm_eq: (perm_map (b (tally s)) (tallyEl s)).\n  by under eq_map do rewrite /= (permP (tallyK s)).\nelim: (tally s) Ubs => [|[x m] bs IH] //= /andP[bs'x /IH-IHbs {IH}].\nrewrite /tseq /= -/(tseq _) count_cat count_nseq /= eqxx mul1n.\nrewrite (count_memPn _) ?addn0 ?perm_cons; last first.\n  apply: contra bs'x; elim: {b IHbs}bs => //= b bs IHbs.\n  by rewrite mem_cat mem_nseq inE andbC; case: (_ == _).\ncongr perm_eq: IHbs; apply/eq_in_map=> y bs_y; congr (y, _).\nby rewrite count_cat count_nseq /= (negPf (memPnC bs'x y bs_y)).\nQed.",
    "Lemma perm_tally s1 s2 : perm_eq s1 s2 -> perm_eq (tally s1) (tally s2).\nProof.\nmove=> eq_s12; apply: (@perm_trans _ [seq (x, count_mem x s2) | x <- undup s1]).\n  by congr perm_eq: (tallyE s1); under eq_map do rewrite (permP eq_s12).\nby rewrite (permPr (tallyE s2)); apply/perm_map/perm_undup/(perm_mem eq_s12).\nQed.",
    "Lemma perm_tally_seq bs1 bs2 :\n  perm_eq bs1 bs2 -> perm_eq (tally_seq bs1) (tally_seq bs2).\nProof. by move=> Ebs12; rewrite perm_flatten ?perm_map. Qed.",
    "Lemma perm_count_undup s :\n  perm_eq (flatten [seq nseq (count_mem x s) x | x <- undup s]) s.\nProof.\nby rewrite -(permPr (tallyK s)) (permPr (perm_tseq (tallyE s))) /tseq -map_comp.\nQed.",
    "Lemma mem_permutations s t : (t \\in permutations s) = perm_eq t s.\nProof.\nhave{s} [n [bs [-> Dn /permPr<- _]]] := permsP s.\nelim: n => [|n IHn] /= in t bs Dn *.\n  by rewrite inE (nilP Dn); apply/eqP/perm_nilP.\nrewrite -[bs in tseq bs]cats0 in Dn *; have x0 : T by case: (tseq _) Dn.\nrewrite -[RHS](@andb_idl (last x0 t \\in tseq bs)); last first.\n  case/lastP: t {IHn} => [|t x] Dt; first by rewrite -(perm_size Dt) in Dn.\n  by rewrite -[bs]cats0 -(perm_mem Dt) last_rcons mem_rcons mem_head.\nelim: bs [::] => [|[x [|m]] bs IHbs] //= bs2 in Dn *.\nrewrite cons_permsE -!cat_cons !mem_cat (mem_nseq m.+1) orbC andb_orl.\nrewrite {}IHbs ?(perm_size (perm_tseq bsCA)) //= (permPr (perm_tseq bsCA)).\ncongr (_ || _); apply/mapP/andP=> [[t1 Dt1 ->] | [/eqP]].\n  by rewrite last_rcons perm_rcons perm_cons IHn in Dt1 *.\ncase/lastP: t => [_ /perm_size//|t y]; rewrite last_rcons perm_rcons => ->.\nby rewrite perm_cons; exists t; rewrite ?IHn.\nQed.",
    "Lemma permutations_uniq s : uniq (permutations s).\nProof.\nhave{s} [n [bs [-> Dn _ Ubs]]] := permsP s.\nelim: n => //= n IHn in bs Dn Ubs *; rewrite -[bs]cats0 /unzip1 in Dn Ubs.\nelim: bs [::] => [|[x [|m]] bs IHbs] //= bs2 in Dn Ubs *.\n  by case/andP: Ubs => _ /IHbs->.\nrewrite /= cons_permsE cat_uniq has_sym andbCA andbC.\nrewrite {}IHbs; first 1 last; first by rewrite (perm_size (perm_tseq bsCA)).\n  by rewrite (perm_uniq (perm_map _ bsCA)).\nrewrite (map_inj_uniq (rcons_injl x)) {}IHn {Dn}//=.\nhave: x \\notin unzip1 bs by apply: contraL Ubs; rewrite map_cat mem_cat => ->.\nmove: {bs2 m Ubs}(perms_rec n _ _ _) (_ :: bs2) => ts.\nelim: bs => [|[y [|m]] bs IHbs] //= /[1!inE] bs2 /norP[x'y /IHbs//].\nrewrite cons_permsE has_cat negb_or has_map => ->.\nby apply/hasPn=> t _; apply: contra x'y => /mapP[t1 _ /rcons_inj[_ ->]].\nQed.",
    "Lemma permutationsE s :\n    0 < size s ->\n  perm_eq (perms s) [seq x :: t | x <- undup s, t <- perms (rem x s)].\nProof.\nmove=> nt_s; apply/uniq_perm=> [||t]; first exact: permutations_uniq.\n  apply/allpairs_uniq_dep=> [|x _|]; rewrite ?undup_uniq  ?permutations_uniq //.\n  by case=> [_ _] [x t] _ _ [-> ->].\nrewrite mem_permutations; apply/idP/allpairsPdep=> [Dt | [x [t1 []]]].\n  rewrite -(perm_size Dt) in nt_s; case: t nt_s => // x t _ in Dt *.\n  have s_x: x \\in s by rewrite -(perm_mem Dt) mem_head.\n  exists x, t; rewrite mem_undup mem_permutations; split=> //.\n  by rewrite -(perm_cons x) (permPl Dt) perm_to_rem.\nrewrite mem_undup mem_permutations -(perm_cons x) => s_x Dt1 ->.\nby rewrite (permPl Dt1) perm_sym perm_to_rem.\nQed.",
    "Lemma permutationsErot x s (le_x := fun t => iota 0 (index x t + 1)) :\n  perm_eq (perms (x :: s)) [seq rot i (x :: t) | t <- perms s, i <- le_x t].\nProof.\nhave take'x t i: i <= index x t -> i <= size t /\\ x \\notin take i t.\n  move=> le_i_x; have le_i_t: i <= size t := leq_trans le_i_x (index_size x t).\n  case: (nthP x) => // -[j lt_j_i /eqP]; rewrite size_takel // in lt_j_i.\n  by rewrite nth_take // [_ == _](before_find x (leq_trans lt_j_i le_i_x)).\npose xrot t i := rot i (x :: t); pose xrotV t := index x (rev (rot 1 t)).\nhave xrotK t: {in le_x t, cancel (xrot t) xrotV}.\n  move=> i; rewrite mem_iota addn1 /xrotV => /take'x[le_i_t ti'x].\n  rewrite -rotD ?rev_cat //= rev_cons cat_rcons index_cat mem_rev size_rev.\n  by rewrite ifN // size_takel //= eqxx addn0.\napply/uniq_perm=> [||t]; first exact: permutations_uniq.\n  apply/allpairs_uniq_dep=> [|t _|]; rewrite ?permutations_uniq ?iota_uniq //.\n  move=> _ _ /allpairsPdep[t [i [_ ? ->]]] /allpairsPdep[u [j [_ ? ->]]] Etu.\n  have Eij: i = j by rewrite -(xrotK t i) // /xrot Etu xrotK.\n  by move: Etu; rewrite Eij => /rot_inj[->].\nrewrite mem_permutations; apply/esym; apply/allpairsPdep/idP=> [[u [i]] | Dt].\n  rewrite mem_permutations => -[Du _ /(canLR (rotK i))]; rewrite /rotr.\n  by set j := (j in rot j _) => Dt; apply/perm_consP; exists j, u.\npose r := rev (rot 1 t); pose i := index x r; pose u := rev (take i r).\nhave r_x: x \\in r by rewrite mem_rev mem_rot (perm_mem Dt) mem_head.\nhave [v Duv]: {v | rot i (x :: u ++ v) = t}; first exists (rev (drop i.+1 r)).\n  rewrite -rev_cat -rev_rcons -rot1_cons -cat_cons -(nth_index x r_x).\n  by rewrite -drop_nth ?index_mem // rot_rot !rev_rot revK rotK rotrK.\nexists (u ++ v), i; rewrite mem_permutations -(perm_cons x) -(perm_rot i) Duv.\nrewrite mem_iota addn1 ltnS /= index_cat mem_rev size_rev.\nby have /take'x[le_i_t ti'x] := leqnn i; rewrite ifN ?size_takel ?leq_addr.\nQed.",
    "Lemma size_permutations s : uniq s -> size (permutations s) = (size s)`!.\nProof.\nmove Dn: (size s) => n Us; elim: n s => [[]|n IHn s] //= in Dn Us *.\nrewrite (perm_size (permutationsE _)) ?Dn // undup_id // factS -Dn.\nrewrite -(size_iota 0 n`!) -(size_allpairs (fun=>id)) !size_allpairs_dep.\nby apply/congr1/eq_in_map=> x sx; rewrite size_iota IHn ?size_rem ?Dn ?rem_uniq.\nQed.",
    "Lemma permutations_all_uniq s : uniq s -> all uniq (permutations s).\nProof.\nby move=> Us; apply/allP=> t; rewrite mem_permutations => /perm_uniq->.\nQed.",
    "Lemma perm_permutations s t :\n  perm_eq s t -> perm_eq (permutations s) (permutations t).\nProof.\nmove=> Est; apply/uniq_perm; try exact: permutations_uniq.\nby move=> u; rewrite !mem_permutations (permPr Est).\nQed.",
    "Lemma succnK : cancel succn predn. Proof. by []. Qed.",
    "Lemma succn_inj : injective succn. Proof. by move=> n m []. Qed.",
    "Lemma eqnP : Equality.axiom eqn.\nProof.\nmove=> n m; apply: (iffP idP) => [|<-]; last by elim n.\nby elim: n m => [|n IHn] [|m] //= /IHn->.\nQed.",
    "Lemma eqnE : eqn = eq_op. Proof. by []. Qed.",
    "Lemma eqSS m n : (m.+1 == n.+1) = (m == n). Proof. by []. Qed.",
    "Lemma nat_irrelevance (x y : nat) (E E' : x = y) : E = E'.\nProof. exact: eq_irrelevance. Qed.",
    "Lemma addnE : addn = plus. Proof. by []. Qed.",
    "Lemma plusE : plus = addn. Proof. by []. Qed.",
    "Lemma add0n : left_id 0 addn.            Proof. by []. Qed.",
    "Lemma addSn m n : m.+1 + n = (m + n).+1. Proof. by []. Qed.",
    "Lemma add1n n : 1 + n = n.+1.            Proof. by []. Qed.",
    "Lemma addn0 : right_id 0 addn. Proof. by move=> n; apply/eqP; elim: n. Qed.",
    "Lemma addnS m n : m + n.+1 = (m + n).+1. Proof. by apply/eqP; elim: m. Qed.",
    "Lemma addSnnS m n : m.+1 + n = m + n.+1. Proof. by rewrite addnS. Qed.",
    "Lemma addnCA : left_commutative addn.\nProof. by move=> m n p; elim: m => //= m; rewrite addnS => <-. Qed.",
    "Lemma addnC : commutative addn.\nProof. by move=> m n; rewrite -[n in LHS]addn0 addnCA addn0. Qed.",
    "Lemma addn1 n : n + 1 = n.+1. Proof. by rewrite addnC. Qed.",
    "Lemma addnA : associative addn.\nProof. by move=> m n p; rewrite (addnC n) addnCA addnC. Qed.",
    "Lemma addnAC : right_commutative addn.\nProof. by move=> m n p; rewrite -!addnA (addnC n). Qed.",
    "Lemma addnCAC m n p : m + n + p = p + n + m.\nProof. by rewrite addnC addnA addnAC. Qed.",
    "Lemma addnACl m n p: m + n + p = n + (p + m).\nProof. by rewrite (addnC m) addnC addnCA. Qed.",
    "Lemma addnACA : interchange addn addn.\nProof. by move=> m n p q; rewrite -!addnA (addnCA n). Qed.",
    "Lemma addn_eq0 m n : (m + n == 0) = (m == 0) && (n == 0).\nProof. by case: m; case: n. Qed.",
    "Lemma addn_eq1 m n :\n  (m + n == 1) = ((m == 1) && (n == 0)) || ((m == 0) && (n == 1)).\nProof. by case: m n => [|[|m]] [|[|n]]. Qed.",
    "Lemma eqn_add2l p m n : (p + m == p + n) = (m == n).\nProof. by elim: p. Qed.",
    "Lemma eqn_add2r p m n : (m + p == n + p) = (m == n).\nProof. by rewrite -!(addnC p) eqn_add2l. Qed.",
    "Lemma addnI : right_injective addn.\nProof. by move=> p m n Heq; apply: eqP; rewrite -(eqn_add2l p) Heq eqxx. Qed.",
    "Lemma addIn : left_injective addn.\nProof. move=> p m n; rewrite -!(addnC p); apply addnI. Qed.",
    "Lemma addn2 m : m + 2 = m.+2. Proof. by rewrite addnC. Qed.",
    "Lemma add2n m : 2 + m = m.+2. Proof. by []. Qed.",
    "Lemma addn3 m : m + 3 = m.+3. Proof. by rewrite addnC. Qed.",
    "Lemma add3n m : 3 + m = m.+3. Proof. by []. Qed.",
    "Lemma addn4 m : m + 4 = m.+4. Proof. by rewrite addnC. Qed.",
    "Lemma add4n m : 4 + m = m.+4. Proof. by []. Qed.",
    "Lemma subnE : subn = minus. Proof. by []. Qed.",
    "Lemma minusE : minus = subn.   Proof. by []. Qed.",
    "Lemma sub0n : left_zero 0 subn.    Proof. by []. Qed.",
    "Lemma subn0 : right_id 0 subn.   Proof. by case. Qed.",
    "Lemma subnn : self_inverse 0 subn. Proof. by elim. Qed.",
    "Lemma subSS n m : m.+1 - n.+1 = m - n. Proof. by []. Qed.",
    "Lemma subn1 n : n - 1 = n.-1.          Proof. by case: n => [|[]]. Qed.",
    "Lemma subn2 n : (n - 2)%N = n.-2.      Proof. by case: n => [|[|[]]]. Qed.",
    "Lemma subnDl p m n : (p + m) - (p + n) = m - n.\nProof. by elim: p. Qed.",
    "Lemma subnDr p m n : (m + p) - (n + p) = m - n.\nProof. by rewrite -!(addnC p) subnDl. Qed.",
    "Lemma addnK n : cancel (addn^~ n) (subn^~ n).\nProof. by move=> m; rewrite (subnDr n m 0) subn0. Qed.",
    "Lemma addKn n : cancel (addn n) (subn^~ n).\nProof. by move=> m; rewrite addnC addnK. Qed.",
    "Lemma subSnn n : n.+1 - n = 1.\nProof. exact (addnK n 1). Qed.",
    "Lemma subnDA m n p : n - (m + p) = (n - m) - p.\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma subnAC : right_commutative subn.\nProof. by move=> m n p; rewrite -!subnDA addnC. Qed.",
    "Lemma subnS m n : m - n.+1 = (m - n).-1.\nProof. by rewrite -addn1 subnDA subn1. Qed.",
    "Lemma subSKn m n : (m.+1 - n).-1 = m - n.\nProof. by rewrite -subnS. Qed.",
    "Lemma ltnS m n : (m < n.+1) = (m <= n). Proof. by []. Qed.",
    "Lemma leq0n n : 0 <= n.                 Proof. by []. Qed.",
    "Lemma ltn0Sn n : 0 < n.+1.              Proof. by []. Qed.",
    "Lemma ltn0 n : n < 0 = false.           Proof. by []. Qed.",
    "Lemma leqnn n : n <= n.                 Proof. by elim: n. Qed.",
    "Lemma ltnSn n : n < n.+1.               Proof. by []. Qed.",
    "Lemma eq_leq m n : m = n -> m <= n.     Proof. by move->. Qed.",
    "Lemma leqnSn n : n <= n.+1.             Proof. by elim: n. Qed.",
    "Lemma leq_pred n : n.-1 <= n.           Proof. by case: n => /=. Qed.",
    "Lemma leqSpred n : n <= n.-1.+1.        Proof. by case: n => /=. Qed.",
    "Lemma ltn_predL n : (n.-1 < n) = (0 < n).\nProof. by case: n => [//|n]; rewrite ltnSn. Qed.",
    "Lemma ltn_predRL m n : (m < n.-1) = (m.+1 < n).\nProof. by case: n => [//|n]; rewrite succnK. Qed.",
    "Lemma ltn_predK m n : m < n -> n.-1.+1 = n.\nProof. by case: n. Qed.",
    "Lemma prednK n : 0 < n -> n.-1.+1 = n.\nProof. exact: ltn_predK. Qed.",
    "Lemma leqNgt m n : (m <= n) = ~~ (n < m).\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma leqVgt m n : (m <= n) || (n < m). Proof. by rewrite leqNgt orNb. Qed.",
    "Lemma ltnNge m n : (m < n) = ~~ (n <= m).\nProof. by rewrite leqNgt. Qed.",
    "Lemma ltnn n : n < n = false.\nProof. by rewrite ltnNge leqnn. Qed.",
    "Lemma leqn0 n : (n <= 0) = (n == 0).           Proof. by case: n. Qed.",
    "Lemma lt0n n : (0 < n) = (n != 0).             Proof. by case: n. Qed.",
    "Lemma lt0n_neq0 n : 0 < n -> n != 0.           Proof. by case: n. Qed.",
    "Lemma eqn0Ngt n : (n == 0) = ~~ (n > 0).       Proof. by case: n. Qed.",
    "Lemma neq0_lt0n n : (n == 0) = false -> 0 < n. Proof. by case: n. Qed.",
    "Lemma eqn_leq m n : (m == n) = (m <= n <= m).\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma anti_leq : antisymmetric leq.\nProof. by move=> m n; rewrite -eqn_leq => /eqP. Qed.",
    "Lemma neq_ltn m n : (m != n) = (m < n) || (n < m).\nProof. by rewrite eqn_leq negb_and orbC -!ltnNge. Qed.",
    "Lemma gtn_eqF m n : m < n -> n == m = false.\nProof. by rewrite eqn_leq (leqNgt n) => ->. Qed.",
    "Lemma ltn_eqF m n : m < n -> m == n = false.\nProof. by move/gtn_eqF; rewrite eq_sym. Qed.",
    "Lemma ltn_geF m n : m < n -> m >= n = false.\nProof. by rewrite (leqNgt n) => ->. Qed.",
    "Lemma leq_gtF m n : m <= n -> m > n = false.\nProof. by rewrite (ltnNge n) => ->. Qed.",
    "Lemma leq_eqVlt m n : (m <= n) = (m == n) || (m < n).\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma ltn_neqAle m n : (m < n) = (m != n) && (m <= n).\nProof. by rewrite ltnNge leq_eqVlt negb_or -leqNgt eq_sym. Qed.",
    "Lemma leq_trans n m p : m <= n -> n <= p -> m <= p.\nProof. by elim: n m p => [|i IHn] [|m] [|p] //; apply: IHn m p. Qed.",
    "Lemma leq_ltn_trans n m p : m <= n -> n < p -> m < p.\nProof. by move=> Hmn; apply: leq_trans. Qed.",
    "Lemma ltnW m n : m < n -> m <= n.\nProof. exact: leq_trans. Qed.",
    "Lemma leqW m n : m <= n -> m <= n.+1.\nProof. by move=> le_mn; apply: ltnW. Qed.",
    "Lemma ltn_trans n m p : m < n -> n < p -> m < p.\nProof. by move=> lt_mn /ltnW; apply: leq_trans. Qed.",
    "Lemma leq_total m n : (m <= n) || (m >= n).\nProof. by rewrite -implyNb -ltnNge; apply/implyP; apply: ltnW. Qed.",
    "Lemma ubnP m : {n | m < n}.             Proof. by exists m.+1. Qed.",
    "Lemma ltnSE m n : m < n.+1 -> m <= n.   Proof. by []. Qed.",
    "Lemma ubnPleq m : ubn_leq_spec m m.    Proof. by []. Qed.",
    "Lemma ubnPgeq m : ubn_geq_spec m m.    Proof. by []. Qed.",
    "Lemma ubnPeq m : ubn_eq_spec m m.      Proof. by []. Qed.",
    "Lemma ltn_ind P : (forall n, (forall m, m < n -> P m) -> P n) -> forall n, P n.\nProof.\nmove=> accP M; have [n leMn] := ubnP M; elim: n => // n IHn in M leMn *.\nby apply/accP=> p /leq_trans/(_ leMn)/IHn.\nQed.",
    "Lemma leP m n : reflect (m <= n)%coq_nat (m <= n).\nProof.\napply: (iffP idP); last by elim: n / => // n _ /leq_trans->.\nelim: n => [|n IHn]; first by case: m.\nby rewrite leq_eqVlt ltnS => /predU1P[<- // | /IHn]; right.\nQed.",
    "Lemma le_irrelevance m n le_mn1 le_mn2 : le_mn1 = le_mn2 :> (m <= n)%coq_nat.\nProof.\nelim/ltn_ind: n => n IHn in le_mn1 le_mn2 *; set n1 := n in le_mn1 *.\npose def_n : n = n1 := erefl n; transitivity (eq_ind _ _ le_mn2 _ def_n) => //.\ncase: n1 / le_mn1 le_mn2 => [|n1 le_mn1] {n}[|n le_mn2] in (def_n) IHn *.\n- by rewrite [def_n]eq_axiomK.\n- by case/leP/idPn: (le_mn2); rewrite -def_n ltnn.\n- by case/leP/idPn: (le_mn1); rewrite def_n ltnn.\ncase: def_n (def_n) => <-{n1} def_n in le_mn1 *.\nby rewrite [def_n]eq_axiomK /=; congr le_S; apply: IHn.\nQed.",
    "Lemma ltP m n : reflect (m < n)%coq_nat (m < n).\nProof. exact leP. Qed.",
    "Lemma lt_irrelevance m n lt_mn1 lt_mn2 : lt_mn1 = lt_mn2 :> (m < n)%coq_nat.\nProof. exact: (@le_irrelevance m.+1). Qed.",
    "Lemma leq_add2l p m n : (p + m <= p + n) = (m <= n).\nProof. by elim: p. Qed.",
    "Lemma ltn_add2l p m n : (p + m < p + n) = (m < n).\nProof. by rewrite -addnS; apply: leq_add2l. Qed.",
    "Lemma leq_add2r p m n : (m + p <= n + p) = (m <= n).\nProof. by rewrite -!(addnC p); apply: leq_add2l. Qed.",
    "Lemma ltn_add2r p m n : (m + p < n + p) = (m < n).\nProof. exact: leq_add2r p m.+1 n. Qed.",
    "Lemma leq_add m1 m2 n1 n2 : m1 <= n1 -> m2 <= n2 -> m1 + m2 <= n1 + n2.\nProof.\nby move=> le_mn1 le_mn2; rewrite (@leq_trans (m1 + n2)) ?leq_add2l ?leq_add2r.\nQed.",
    "Lemma leq_addl m n : n <= m + n. Proof. exact: (leq_add2r n 0). Qed.",
    "Lemma leq_addr m n : n <= n + m. Proof. by rewrite addnC leq_addl. Qed.",
    "Lemma ltn_addl m n p : m < n -> m < p + n.\nProof. by move/leq_trans=> -> //; apply: leq_addl. Qed.",
    "Lemma ltn_addr m n p : m < n -> m < n + p.\nProof. by move/leq_trans=> -> //; apply: leq_addr. Qed.",
    "Lemma addn_gt0 m n : (0 < m + n) = (0 < m) || (0 < n).\nProof. by rewrite !lt0n -negb_and addn_eq0. Qed.",
    "Lemma subn_gt0 m n : (0 < n - m) = (m < n).\nProof. by elim: m n => [|m IHm] [|n] //; apply: IHm n. Qed.",
    "Lemma subn_eq0 m n : (m - n == 0) = (m <= n).\nProof. by []. Qed.",
    "Lemma leq_subLR m n p : (m - n <= p) = (m <= n + p).\nProof. by rewrite -subn_eq0 -subnDA. Qed.",
    "Lemma leq_subr m n : n - m <= n.\nProof. by rewrite leq_subLR leq_addl. Qed.",
    "Lemma ltn_subrR m n : (n < n - m) = false.\nProof. by rewrite ltnNge leq_subr. Qed.",
    "Lemma leq_subrR m n : (n <= n - m) = (m == 0) || (n == 0).\nProof. by case: m n => [|m] [|n]; rewrite ?subn0 ?leqnn ?ltn_subrR. Qed.",
    "Lemma ltn_subrL m n : (n - m < n) = (0 < m) && (0 < n).\nProof. by rewrite ltnNge leq_subrR negb_or !lt0n. Qed.",
    "Lemma subnKC m n : m <= n -> m + (n - m) = n.\nProof. by elim: m n => [|m IHm] [|n] // /(IHm n) {2}<-. Qed.",
    "Lemma addnBn m n : m + (n - m) = m - n + n.\nProof. by elim: m n => [|m IHm] [|n] //; rewrite addSn addnS IHm. Qed.",
    "Lemma subnK m n : m <= n -> (n - m) + m = n.\nProof. by rewrite addnC; apply: subnKC. Qed.",
    "Lemma addnBA m n p : p <= n -> m + (n - p) = m + n - p.\nProof. by move=> le_pn; rewrite -[in RHS](subnK le_pn) addnA addnK. Qed.",
    "Lemma addnBAC m n p : n <= m -> m - n + p = m + p - n.\nProof. by move=> le_nm; rewrite addnC addnBA // addnC. Qed.",
    "Lemma addnBCA m n p : p <= m -> p <= n -> m + (n - p) = n + (m - p).\nProof. by move=> le_pm le_pn; rewrite !addnBA // addnC. Qed.",
    "Lemma addnABC m n p : p <= m -> p <= n -> m + (n - p) = m - p + n.\nProof. by move=> le_pm le_pn; rewrite addnBA // addnBAC. Qed.",
    "Lemma subnBA m n p : p <= n -> m - (n - p) = m + p - n.\nProof. by move=> le_pn; rewrite -[in RHS](subnK le_pn) subnDr. Qed.",
    "Lemma subnA m n p : p <= n -> n <= m -> m - (n - p) = m - n + p.\nProof. by move=> le_pn lr_nm; rewrite addnBAC // subnBA. Qed.",
    "Lemma subKn m n : m <= n -> n - (n - m) = m.\nProof. by move/subnBA->; rewrite addKn. Qed.",
    "Lemma subSn m n : m <= n -> n.+1 - m = (n - m).+1.\nProof. by rewrite -add1n => /addnBA <-. Qed.",
    "Lemma subnSK m n : m < n -> (n - m.+1).+1 = n - m. Proof. by move/subSn. Qed.",
    "Lemma addnCBA m n p : p <= n -> m + (n - p) = n + m - p.\nProof. by move=> pn; rewrite (addnC n m) addnBA. Qed.",
    "Lemma addnBr_leq n p m : n <= p -> m + (n - p) = m.\nProof. by rewrite -subn_eq0 => /eqP->; rewrite addn0. Qed.",
    "Lemma addnBl_leq m n p : m <= n -> m - n + p = p.\nProof. by rewrite -subn_eq0; move/eqP => ->; rewrite add0n. Qed.",
    "Lemma subnDAC m n p : m - (n + p) = m - p - n.\nProof. by rewrite addnC subnDA. Qed.",
    "Lemma subnCBA m n p : p <= n ->\tm - (n - p) = p + m - n.\nProof. by move=> pn; rewrite addnC subnBA. Qed.",
    "Lemma subnBr_leq n p m : n <= p -> m - (n - p) = m.\nProof. by rewrite -subn_eq0 => /eqP->; rewrite subn0. Qed.",
    "Lemma subnBl_leq m n p : m <= n -> (m - n) - p = 0.\nProof. by rewrite -subn_eq0 => /eqP->. Qed.",
    "Lemma subnBAC m n p : p <= n -> n <= m -> m - (n - p) = p + (m - n).\nProof. by move=> pn nm; rewrite subnA // addnC. Qed.",
    "Lemma subDnAC m n p : p <= n -> m + n - p = n - p + m.\nProof. by move=> pn; rewrite addnC -addnBAC. Qed.",
    "Lemma subDnCA m n p : p <= m -> m + n - p = n + (m - p).\nProof. by move=> pm; rewrite addnC -addnBA. Qed.",
    "Lemma subDnCAC m n p : m <= p -> m + n - p = n - (p - m).\nProof. by move=> mp; rewrite addnC -subnBA. Qed.",
    "Lemma addnBC m n : m - n + n = n - m + m.\nProof. by rewrite -[in RHS]addnBn addnC. Qed.",
    "Lemma addnCB m n : m - n + n = m + (n - m).\nProof. by rewrite addnBC addnC. Qed.",
    "Lemma addBnAC m n p : n <= m -> m - n + p = p + m - n.\nProof. by move=> nm; rewrite [p + m]addnC addnBAC. Qed.",
    "Lemma addBnCAC m n p : n <= m -> n <= p -> m - n + p = p - n + m.\nProof. by move=> nm np; rewrite addnC addnBA // subDnCA // addnC. Qed.",
    "Lemma addBnA m n p : n <= m -> p <= n -> m - n + p = m - (n - p).\nProof. by move=> nm pn; rewrite subnBA // -subDnAC // addnC. Qed.",
    "Lemma subBnAC m n p : m - n - p = m - (p + n).\nProof. by rewrite addnC -subnDA. Qed.",
    "Lemma predn_sub m n : (m - n).-1 = (m.-1 - n).\nProof. by case: m => // m; rewrite subSKn. Qed.",
    "Lemma leq_sub2r p m n : m <= n -> m - p <= n - p.\nProof. by move=> le_mn; rewrite leq_subLR (leq_trans le_mn) // -leq_subLR. Qed.",
    "Lemma leq_sub2l p m n : m <= n -> p - n <= p - m.\nProof.\nrewrite -(leq_add2r (p - m)) leq_subLR.\nby apply: leq_trans; rewrite -leq_subLR.\nQed.",
    "Lemma leq_sub m1 m2 n1 n2 : m1 <= m2 -> n2 <= n1 -> m1 - n1 <= m2 - n2.\nProof. by move/(leq_sub2r n1)=> le_m12 /(leq_sub2l m2); apply: leq_trans. Qed.",
    "Lemma ltn_sub2r p m n : p < n -> m < n -> m - p < n - p.\nProof. by move/subnSK <-; apply: (@leq_sub2r p.+1). Qed.",
    "Lemma ltn_sub2l p m n : m < p -> m < n -> p - n < p - m.\nProof. by move/subnSK <-; apply: leq_sub2l. Qed.",
    "Lemma ltn_subRL m n p : (n < p - m) = (m + n < p).\nProof. by rewrite !ltnNge leq_subLR. Qed.",
    "Lemma leq_psubRL m n p : 0 < n -> (n <= p - m) = (m + n <= p).\nProof. by move=> /prednK<-; rewrite ltn_subRL addnS. Qed.",
    "Lemma ltn_psubLR m n p : 0 < p -> (m - n < p) = (m < n + p).\nProof. by move=> /prednK<-; rewrite ltnS leq_subLR addnS. Qed.",
    "Lemma leq_subRL m n p : m <= p -> (n <= p - m) = (m + n <= p).\nProof. by move=> /subnKC{2}<-; rewrite leq_add2l. Qed.",
    "Lemma ltn_subLR m n p : n <= m -> (m - n < p) = (m < n + p).\nProof. by move=> /subnKC{2}<-; rewrite ltn_add2l. Qed.",
    "Lemma leq_subCl m n p : (m - n <= p) = (m - p <= n).\nProof. by rewrite !leq_subLR // addnC. Qed.",
    "Lemma ltn_subCr m n p : (p < m - n) = (n < m - p).\nProof. by rewrite !ltn_subRL // addnC. Qed.",
    "Lemma leq_psubCr m n p : 0 < p -> 0 < n -> (p <= m - n) = (n <= m - p).\nProof. by move=> p_gt0 n_gt0; rewrite !leq_psubRL // addnC. Qed.",
    "Lemma ltn_psubCl m n p : 0 < p -> 0 < n -> (m - n < p) = (m - p < n).\nProof. by move=> p_gt0 n_gt0; rewrite !ltn_psubLR // addnC. Qed.",
    "Lemma leq_subCr m n p : n <= m -> p <= m -> (p <= m - n) = (n <= m - p).\nProof. by move=> np pm; rewrite !leq_subRL // addnC. Qed.",
    "Lemma ltn_subCl m n p : n <= m -> p <= m -> (m - n < p) = (m - p < n).\nProof. by move=> nm pm; rewrite !ltn_subLR // addnC. Qed.",
    "Lemma leq_sub2rE p m n : p <= n -> (m - p <= n - p) = (m <= n).\nProof. by move=> pn; rewrite leq_subLR subnKC. Qed.",
    "Lemma leq_sub2lE m n p : n <= m -> (m - p <= m - n) = (n <= p).\nProof. by move=> nm; rewrite leq_subCl subKn. Qed.",
    "Lemma ltn_sub2rE p m n : p <= m -> (m - p < n - p) = (m < n).\nProof. by move=> pn; rewrite ltn_subRL addnC subnK. Qed.",
    "Lemma ltn_sub2lE m n p : p <= m -> (m - p < m - n) = (n < p).\nProof. by move=> pm; rewrite ltn_subCr subKn. Qed.",
    "Lemma eqn_sub2rE p m n : p <= m -> p <= n -> (m - p == n - p) = (m == n).\nProof. by move=> pm pn; rewrite !eqn_leq !leq_sub2rE. Qed.",
    "Lemma eqn_sub2lE m n p : p <= m -> n <= m -> (m - p == m - n) = (p == n).\nProof. by move=> pm nm; rewrite !eqn_leq !leq_sub2lE // -!eqn_leq eq_sym. Qed.",
    "Lemma max0n : left_id 0 maxn.  Proof. by case. Qed.",
    "Lemma maxn0 : right_id 0 maxn. Proof. by []. Qed.",
    "Lemma maxnC : commutative maxn.\nProof. by rewrite /maxn; elim=> [|m ih] [] // n; rewrite !ltnS -!fun_if ih. Qed.",
    "Lemma maxnE m n : maxn m n = m + (n - m).\nProof.\nrewrite /maxn; elim: m n => [|m ih] [|n]; rewrite ?addn0 //.\nby rewrite ltnS subSS addSn -ih; case: leq.\nQed.",
    "Lemma maxnAC : right_commutative maxn.\nProof. by move=> m n p; rewrite !maxnE -!addnA !subnDA -!maxnE maxnC. Qed.",
    "Lemma maxnA : associative maxn.\nProof. by move=> m n p; rewrite !(maxnC m) maxnAC. Qed.",
    "Lemma maxnCA : left_commutative maxn.\nProof. by move=> m n p; rewrite !maxnA (maxnC m). Qed.",
    "Lemma maxnACA : interchange maxn maxn.\nProof. by move=> m n p q; rewrite -!maxnA (maxnCA n). Qed.",
    "Lemma maxn_idPl {m n} : reflect (maxn m n = m) (m >= n).\nProof. by rewrite -subn_eq0 -(eqn_add2l m) addn0 -maxnE; apply: eqP. Qed.",
    "Lemma maxn_idPr {m n} : reflect (maxn m n = n) (m <= n).\nProof. by rewrite maxnC; apply: maxn_idPl. Qed.",
    "Lemma maxnn : idempotent_op maxn.\nProof. by move=> n; apply/maxn_idPl. Qed.",
    "Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).\nProof.\nwithout loss le_n21: n1 n2 / n2 <= n1.\n  by case/orP: (leq_total n2 n1) => le_n12; last rewrite maxnC orbC; apply.\nby rewrite (maxn_idPl le_n21) orb_idr // => /leq_trans->.\nQed.",
    "Lemma leq_maxl m n : m <= maxn m n. Proof. by rewrite leq_max leqnn. Qed.",
    "Lemma leq_maxr m n : n <= maxn m n. Proof. by rewrite maxnC leq_maxl. Qed.",
    "Lemma gtn_max m n1 n2 : (m > maxn n1 n2) = (m > n1) && (m > n2).\nProof. by rewrite !ltnNge leq_max negb_or. Qed.",
    "Lemma geq_max m n1 n2 : (m >= maxn n1 n2) = (m >= n1) && (m >= n2).\nProof. by rewrite -ltnS gtn_max. Qed.",
    "Lemma maxnSS m n : maxn m.+1 n.+1 = (maxn m n).+1.\nProof. by rewrite !maxnE. Qed.",
    "Lemma addn_maxl : left_distributive addn maxn.\nProof. by move=> m1 m2 n; rewrite !maxnE subnDr addnAC. Qed.",
    "Lemma addn_maxr : right_distributive addn maxn.\nProof. by move=> m n1 n2; rewrite !(addnC m) addn_maxl. Qed.",
    "Lemma subn_maxl : left_distributive subn maxn.\nProof.\nmove=> m n p; apply/eqP.\nrewrite eqn_leq !geq_max !leq_sub2r leq_max ?leqnn ?andbT ?orbT // /maxn.\nby case: (_ < _); rewrite leqnn // orbT.\nQed.",
    "Lemma min0n : left_zero 0 minn. Proof. by case. Qed.",
    "Lemma minn0 : right_zero 0 minn. Proof. by []. Qed.",
    "Lemma minnC : commutative minn.\nProof. by rewrite /minn; elim=> [|m ih] [] // n; rewrite !ltnS -!fun_if ih. Qed.",
    "Lemma addn_min_max m n : minn m n + maxn m n = m + n.\nProof. by rewrite /minn /maxn; case: (m < n) => //; exact: addnC. Qed.",
    "Lemma minnE m n : minn m n = m - (m - n).\nProof. by rewrite -(subnDl n) -maxnE -addn_min_max addnK minnC. Qed.",
    "Lemma minnAC : right_commutative minn.\nProof.\nby move=> m n p; rewrite !minnE -subnDA subnAC -maxnE maxnC maxnE subnAC subnDA.\nQed.",
    "Lemma minnA : associative minn.\nProof. by move=> m n p; rewrite minnC minnAC (minnC n). Qed.",
    "Lemma minnCA : left_commutative minn.\nProof. by move=> m n p; rewrite !minnA (minnC n). Qed.",
    "Lemma minnACA : interchange minn minn.\nProof. by move=> m n p q; rewrite -!minnA (minnCA n). Qed.",
    "Lemma minn_idPl {m n} : reflect (minn m n = m) (m <= n).\nProof.\nrewrite (sameP maxn_idPr eqP) -(eqn_add2l m) eq_sym -addn_min_max eqn_add2r.\nexact: eqP.\nQed.",
    "Lemma minn_idPr {m n} : reflect (minn m n = n) (m >= n).\nProof. by rewrite minnC; apply: minn_idPl. Qed.",
    "Lemma minnn : idempotent_op minn.\nProof. by move=> n; apply/minn_idPl. Qed.",
    "Lemma leq_min m n1 n2 : (m <= minn n1 n2) = (m <= n1) && (m <= n2).\nProof.\nwlog le_n21: n1 n2 / n2 <= n1.\n  by case/orP: (leq_total n2 n1) => ?; last rewrite minnC andbC; apply.\nrewrite /minn ltnNge le_n21 /=; case le_m_n1: (m <= n1) => //=.\napply/contraFF: le_m_n1 => /leq_trans; exact.\nQed.",
    "Lemma gtn_min m n1 n2 : (m > minn n1 n2) = (m > n1) || (m > n2).\nProof. by rewrite !ltnNge leq_min negb_and. Qed.",
    "Lemma geq_min m n1 n2 : (m >= minn n1 n2) = (m >= n1) || (m >= n2).\nProof. by rewrite -ltnS gtn_min. Qed.",
    "Lemma ltn_min m n1 n2 : (m < minn n1 n2) = (m < n1) && (m < n2).\nProof. exact: leq_min. Qed.",
    "Lemma geq_minl m n : minn m n <= m. Proof. by rewrite geq_min leqnn. Qed.",
    "Lemma geq_minr m n : minn m n <= n. Proof. by rewrite minnC geq_minl. Qed.",
    "Lemma addn_minr : right_distributive addn minn.\nProof. by move=> m1 m2 n; rewrite !minnE subnDl addnBA ?leq_subr. Qed.",
    "Lemma addn_minl : left_distributive addn minn.\nProof. by move=> m1 m2 n; rewrite -!(addnC n) addn_minr. Qed.",
    "Lemma subn_minl : left_distributive subn minn.\nProof.\nmove=> m n p; apply/eqP.\nrewrite eqn_leq !leq_min !leq_sub2r geq_min ?leqnn ?orbT //= /minn.\nby case: (_ < _); rewrite leqnn // orbT.\nQed.",
    "Lemma minnSS m n : minn m.+1 n.+1 = (minn m n).+1.\nProof. by rewrite -(addn_minr 1). Qed.",
    "Lemma maxnK m n : minn (maxn m n) m = m.\nProof. exact/minn_idPr/leq_maxl. Qed.",
    "Lemma maxKn m n : minn n (maxn m n) = n.\nProof. exact/minn_idPl/leq_maxr. Qed.",
    "Lemma minnK m n : maxn (minn m n) m = m.\nProof. exact/maxn_idPr/geq_minl. Qed.",
    "Lemma minKn m n : maxn n (minn m n) = n.\nProof. exact/maxn_idPl/geq_minr. Qed.",
    "Lemma maxn_minl : left_distributive maxn minn.\nProof.\nmove=> m1 m2 n; wlog le_m21: m1 m2 / m2 <= m1.\n  move=> IH; case/orP: (leq_total m2 m1) => /IH //.\n  by rewrite minnC [in R in _ = R]minnC.\nrewrite (minn_idPr le_m21); apply/esym/minn_idPr.\nby rewrite geq_max leq_maxr leq_max le_m21.\nQed.",
    "Lemma maxn_minr : right_distributive maxn minn.\nProof. by move=> m n1 n2; rewrite !(maxnC m) maxn_minl. Qed.",
    "Lemma minn_maxl : left_distributive minn maxn.\nProof.\nby move=> m1 m2 n; rewrite maxn_minr !maxn_minl -minnA maxnn (maxnC _ n) !maxnK.\nQed.",
    "Lemma minn_maxr : right_distributive minn maxn.\nProof. by move=> m n1 n2; rewrite !(minnC m) minn_maxl. Qed.",
    "Lemma leqP m n : leq_xor_gtn m n (minn n m) (minn m n) (maxn n m) (maxn m n)\n                                 (m <= n) (n < m).\nProof.\nrewrite (minnC m) /minn (maxnC m) /maxn ltnNge.\nby case le_mn: (m <= n); constructor; rewrite //= ltnNge le_mn.\nQed.",
    "Lemma ltnP m n : ltn_xor_geq m n (minn n m) (minn m n) (maxn n m) (maxn m n)\n                                 (n <= m) (m < n).\nProof. by case: leqP; constructor. Qed.",
    "Lemma posnP n : eqn0_xor_gt0 n (n == 0) (0 < n).\nProof. by case: n; constructor. Qed.",
    "Lemma ltngtP m n :\n  compare_nat m n (minn n m) (minn m n) (maxn n m) (maxn m n)\n                  (n == m) (m == n) (n <= m) (m <= n) (n < m) (m < n).\nProof.\nrewrite !ltn_neqAle [_ == n]eq_sym; have [mn|] := ltnP m n.\n  by rewrite ltnW // gtn_eqF //; constructor.\nrewrite leq_eqVlt; case: ltnP; rewrite ?(orbT, orbF) => //= lt_nm eq_nm.\n  by rewrite ltn_eqF //; constructor.\nby rewrite eq_nm (eqP eq_nm); constructor.\nQed.",
    "Lemma subn_if_gt T m n F (E : T) :\n  (if m.+1 - n is m'.+1 then F m' else E) = (if n <= m then F (m - n) else E).\nProof.\nby have [le_nm|/eqnP-> //] := leqP; rewrite -{1}(subnK le_nm) -addSn addnK.\nQed.",
    "Lemma find_ex_minn : {m | P m & forall n, P n -> n >= m}.\nProof.\nhave: forall n, P n -> n >= 0 by [].\nhave: acc_nat 0.\n  case exP => n; rewrite -(addn0 n); elim: n 0 => [|n IHn] j; first by left.\n  by rewrite addSnnS; right; apply: IHn.\nmove: 0; fix find_ex_minn 2 => m IHm m_lb; case Pm: (P m); first by exists m.\napply: find_ex_minn m.+1 _ _ => [|n Pn]; first by case: IHm; rewrite ?Pm.\nby rewrite ltn_neqAle m_lb //; case: eqP Pm => // -> /idP[].\nQed.",
    "Lemma ex_minnP : ex_minn_spec ex_minn.\nProof. by rewrite /ex_minn; case: find_ex_minn. Qed.",
    "Lemma ex_maxn_subproof : exists i, P (m - i).\nProof. by case: exP => i Pi; exists (m - i); rewrite subKn ?ubP. Qed.",
    "Lemma ex_maxnP : ex_maxn_spec ex_maxn.\nProof.\nrewrite /ex_maxn; case: ex_minnP => i Pmi min_i; split=> // j Pj.\nhave le_i_mj: i <= m - j by rewrite min_i // subKn // ubP.\nrewrite -subn_eq0 subnBA ?(leq_trans le_i_mj) ?leq_subr //.\nby rewrite addnC -subnBA ?ubP.\nQed.",
    "Lemma eq_ex_minn P Q exP exQ : P =1 Q -> @ex_minn P exP = @ex_minn Q exQ.\nProof.\nmove=> eqPQ; case: ex_minnP => m1 Pm1 m1_lb; case: ex_minnP => m2 Pm2 m2_lb.\nby apply/eqP; rewrite eqn_leq m1_lb (m2_lb, eqPQ) // -eqPQ.\nQed.",
    "Lemma eq_ex_maxn (P Q : pred nat) m n exP ubP exQ ubQ :\n  P =1 Q -> @ex_maxn P m exP ubP = @ex_maxn Q n exQ ubQ.\nProof.\nmove=> eqPQ; case: ex_maxnP => i Pi max_i; case: ex_maxnP => j Pj max_j.\nby apply/eqP; rewrite eqn_leq max_i ?eqPQ // max_j -?eqPQ.\nQed.",
    "Lemma iterSr n f x : iter n.+1 f x = iter n f (f x).\nProof. by elim: n => //= n <-. Qed.",
    "Lemma iterS n f x : iter n.+1 f x = f (iter n f x). Proof. by []. Qed.",
    "Lemma iterD n m f x : iter (n + m) f x = iter n f (iter m f x).\nProof. by elim: n => //= n ->. Qed.",
    "Lemma iteriS n f x : iteri n.+1 f x = f n (iteri n f x).\nProof. by []. Qed.",
    "Lemma iteropS idx n op x : iterop n.+1 op x idx = iter n (op x) x.\nProof. by elim: n => //= n ->. Qed.",
    "Lemma eq_iter f f' : f =1 f' -> forall n, iter n f =1 iter n f'.\nProof. by move=> eq_f n x; elim: n => //= n ->; rewrite eq_f. Qed.",
    "Lemma iter_fix n f x : f x = x -> iter n f x = x.\nProof. by move=> fixf; elim: n => //= n ->. Qed.",
    "Lemma eq_iteri f f' : f =2 f' -> forall n, iteri n f =1 iteri n f'.\nProof. by move=> eq_f n x; elim: n => //= n ->; rewrite eq_f. Qed.",
    "Lemma eq_iterop n op op' : op =2 op' -> iterop n op =2 iterop n op'.\nProof. by move=> eq_op x; apply: eq_iteri; case. Qed.",
    "Lemma iter_in f S i : {homo f : x / x \\in S} -> {homo iter i f : x / x \\in S}.\nProof. by move=> f_in x xS; elim: i => [|i /f_in]. Qed.",
    "Lemma iter_succn m n : iter n succn m = m + n.\nProof. by rewrite addnC; elim: n => //= n ->. Qed.",
    "Lemma iter_succn_0 n : iter n succn 0 = n.\nProof. exact: iter_succn. Qed.",
    "Lemma iter_predn m n : iter n predn m = m - n.\nProof. by elim: n m => /= [|n IHn] m; rewrite ?subn0 // IHn subnS. Qed.",
    "Lemma multE : mult = muln. Proof. by []. Qed.",
    "Lemma mulnE : muln = mult. Proof. by []. Qed.",
    "Lemma mul0n : left_zero 0 muln.          Proof. by []. Qed.",
    "Lemma muln0 : right_zero 0 muln.         Proof. by elim. Qed.",
    "Lemma mul1n : left_id 1 muln.            Proof. exact: addn0. Qed.",
    "Lemma mulSn m n : m.+1 * n = n + m * n.  Proof. by []. Qed.",
    "Lemma mulSnr m n : m.+1 * n = m * n + n. Proof. exact: addnC. Qed.",
    "Lemma mulnS m n : m * n.+1 = m + m * n.\nProof. by elim: m => // m; rewrite !mulSn !addSn addnCA => ->. Qed.",
    "Lemma mulnSr m n : m * n.+1 = m * n + m.\nProof. by rewrite addnC mulnS. Qed.",
    "Lemma iter_addn m n p : iter n (addn m) p = m * n + p.\nProof. by elim: n => /= [|n ->]; rewrite ?muln0 // mulnS addnA. Qed.",
    "Lemma iter_addn_0 m n : iter n (addn m) 0 = m * n.\nProof. by rewrite iter_addn addn0. Qed.",
    "Lemma muln1 : right_id 1 muln.\nProof. by move=> n; rewrite mulnSr muln0. Qed.",
    "Lemma mulnC : commutative muln.\nProof.\nby move=> m n; elim: m => [|m]; rewrite (muln0, mulnS) // mulSn => ->.\nQed.",
    "Lemma mulnDl : left_distributive muln addn.\nProof. by move=> m1 m2 n; elim: m1 => //= m1 IHm; rewrite -addnA -IHm. Qed.",
    "Lemma mulnDr : right_distributive muln addn.\nProof. by move=> m n1 n2; rewrite !(mulnC m) mulnDl. Qed.",
    "Lemma mulnBl : left_distributive muln subn.\nProof.\nmove=> m n [|p]; first by rewrite !muln0.\nby elim: m n => // [m IHm] [|n] //; rewrite mulSn subnDl -IHm.\nQed.",
    "Lemma mulnBr : right_distributive muln subn.\nProof. by move=> m n p; rewrite !(mulnC m) mulnBl. Qed.",
    "Lemma mulnA : associative muln.\nProof. by move=> m n p; elim: m => //= m; rewrite mulSn mulnDl => ->. Qed.",
    "Lemma mulnCA : left_commutative muln.\nProof. by move=> m n1 n2; rewrite !mulnA (mulnC m). Qed.",
    "Lemma mulnAC : right_commutative muln.\nProof. by move=> m n p; rewrite -!mulnA (mulnC n). Qed.",
    "Lemma mulnACA : interchange muln muln.\nProof. by move=> m n p q; rewrite -!mulnA (mulnCA n). Qed.",
    "Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).\nProof. by case: m n => // m [|n] //=; rewrite muln0. Qed.",
    "Lemma muln_eq1 m n : (m * n == 1) = (m == 1) && (n == 1).\nProof. by case: m n => [|[|m]] [|[|n]] //; rewrite muln0. Qed.",
    "Lemma muln_gt0 m n : (0 < m * n) = (0 < m) && (0 < n).\nProof. by case: m n => // m [|n] //=; rewrite muln0. Qed.",
    "Lemma leq_pmull m n : n > 0 -> m <= n * m.\nProof. by move/prednK <-; apply: leq_addr. Qed.",
    "Lemma leq_pmulr m n : n > 0 -> m <= m * n.\nProof. by move/leq_pmull; rewrite mulnC. Qed.",
    "Lemma leq_mul2l m n1 n2 : (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).\nProof. by rewrite [LHS]/leq -mulnBr muln_eq0. Qed.",
    "Lemma leq_mul2r m n1 n2 : (n1 * m <= n2 * m) = (m == 0) || (n1 <= n2).\nProof. by rewrite -!(mulnC m) leq_mul2l. Qed.",
    "Lemma leq_mul m1 m2 n1 n2 : m1 <= n1 -> m2 <= n2 -> m1 * m2 <= n1 * n2.\nProof.\nmove=> le_mn1 le_mn2; apply (@leq_trans (m1 * n2)).\n  by rewrite leq_mul2l le_mn2 orbT.\nby rewrite leq_mul2r le_mn1 orbT.\nQed.",
    "Lemma eqn_mul2l m n1 n2 : (m * n1 == m * n2) = (m == 0) || (n1 == n2).\nProof. by rewrite eqn_leq !leq_mul2l -orb_andr -eqn_leq. Qed.",
    "Lemma eqn_mul2r m n1 n2 : (n1 * m == n2 * m) = (m == 0) || (n1 == n2).\nProof. by rewrite eqn_leq !leq_mul2r -orb_andr -eqn_leq. Qed.",
    "Lemma leq_pmul2l m n1 n2 : 0 < m -> (m * n1 <= m * n2) = (n1 <= n2).\nProof. by move/prednK=> <-; rewrite leq_mul2l. Qed.",
    "Lemma leq_pmul2r m n1 n2 : 0 < m -> (n1 * m <= n2 * m) = (n1 <= n2).\nProof. by move/prednK <-; rewrite leq_mul2r. Qed.",
    "Lemma eqn_pmul2l m n1 n2 : 0 < m -> (m * n1 == m * n2) = (n1 == n2).\nProof. by move/prednK <-; rewrite eqn_mul2l. Qed.",
    "Lemma eqn_pmul2r m n1 n2 : 0 < m -> (n1 * m == n2 * m) = (n1 == n2).\nProof. by move/prednK <-; rewrite eqn_mul2r. Qed.",
    "Lemma ltn_mul2l m n1 n2 : (m * n1 < m * n2) = (0 < m) && (n1 < n2).\nProof. by rewrite lt0n !ltnNge leq_mul2l negb_or. Qed.",
    "Lemma ltn_mul2r m n1 n2 : (n1 * m < n2 * m) = (0 < m) && (n1 < n2).\nProof. by rewrite lt0n !ltnNge leq_mul2r negb_or. Qed.",
    "Lemma ltn_pmul2l m n1 n2 : 0 < m -> (m * n1 < m * n2) = (n1 < n2).\nProof. by move/prednK <-; rewrite ltn_mul2l. Qed.",
    "Lemma ltn_pmul2r m n1 n2 : 0 < m -> (n1 * m < n2 * m) = (n1 < n2).\nProof. by move/prednK <-; rewrite ltn_mul2r. Qed.",
    "Lemma ltn_Pmull m n : 1 < n -> 0 < m -> m < n * m.\nProof. by move=> lt1n m_gt0; rewrite -[ltnLHS]mul1n ltn_pmul2r. Qed.",
    "Lemma ltn_Pmulr m n : 1 < n -> 0 < m -> m < m * n.\nProof. by move=> lt1n m_gt0; rewrite mulnC ltn_Pmull. Qed.",
    "Lemma ltn_mull m1 m2 n1 n2 : 0 < n2 -> m1 < n1 -> m2 <= n2 -> m1 * m2 < n1 * n2.\nProof.\nmove=> n20 lt_mn1 le_mn2.\nrewrite (@leq_ltn_trans (m1 * n2)) ?leq_mul2l ?le_mn2 ?orbT//.\nby rewrite ltn_mul2r lt_mn1 n20.\nQed.",
    "Lemma ltn_mulr m1 m2 n1 n2 : 0 < n1 -> m1 <= n1 -> m2 < n2 -> m1 * m2 < n1 * n2.\nProof. by move=> ? ? ?; rewrite mulnC [ltnRHS]mulnC ltn_mull. Qed.",
    "Lemma ltn_mul m1 m2 n1 n2 : m1 < n1 -> m2 < n2 -> m1 * m2 < n1 * n2.\nProof. by move=> ? lt2; rewrite ltn_mull ?(leq_ltn_trans _ lt2)// ltnW. Qed.",
    "Lemma maxnMr : right_distributive muln maxn.\nProof. by case=> // m n1 n2; rewrite /maxn (fun_if (muln _)) ltn_pmul2l. Qed.",
    "Lemma maxnMl : left_distributive muln maxn.\nProof. by move=> m1 m2 n; rewrite -!(mulnC n) maxnMr. Qed.",
    "Lemma minnMr : right_distributive muln minn.\nProof. by case=> // m n1 n2; rewrite /minn (fun_if (muln _)) ltn_pmul2l. Qed.",
    "Lemma minnMl : left_distributive muln minn.\nProof. by move=> m1 m2 n; rewrite -!(mulnC n) minnMr. Qed.",
    "Lemma iterM (T : Type) (n m : nat) (f : T -> T) :\n  iter (n * m) f =1 iter n (iter m f).\nProof. by move=> x; elim: n => //= n <-; rewrite mulSn iterD. Qed.",
    "Lemma expnE n m : expn m n = iterop n muln m 1. Proof. by []. Qed.",
    "Lemma expn0 m : m ^ 0 = 1. Proof. by []. Qed.",
    "Lemma expn1 m : m ^ 1 = m. Proof. by []. Qed.",
    "Lemma expnS m n : m ^ n.+1 = m * m ^ n. Proof. by case: n; rewrite ?muln1. Qed.",
    "Lemma expnSr m n : m ^ n.+1 = m ^ n * m. Proof. by rewrite mulnC expnS. Qed.",
    "Lemma iter_muln m n p : iter n (muln m) p = m ^ n * p.\nProof. by elim: n => /= [|n ->]; rewrite ?mul1n // expnS mulnA. Qed.",
    "Lemma iter_muln_1 m n : iter n (muln m) 1 = m ^ n.\nProof. by rewrite iter_muln muln1. Qed.",
    "Lemma exp0n n : 0 < n -> 0 ^ n = 0. Proof. by case: n => [|[]]. Qed.",
    "Lemma exp1n n : 1 ^ n = 1.\nProof. by elim: n => // n; rewrite expnS mul1n. Qed.",
    "Lemma expnD m n1 n2 : m ^ (n1 + n2) = m ^ n1 * m ^ n2.\nProof. by elim: n1 => [|n1 IHn]; rewrite !(mul1n, expnS) // IHn mulnA. Qed.",
    "Lemma expnMn m1 m2 n : (m1 * m2) ^ n = m1 ^ n * m2 ^ n.\nProof. by elim: n => // n IHn; rewrite !expnS IHn -!mulnA (mulnCA m2). Qed.",
    "Lemma expnM m n1 n2 : m ^ (n1 * n2) = (m ^ n1) ^ n2.\nProof.\nelim: n1 => [|n1 IHn]; first by rewrite exp1n.\nby rewrite expnD expnS expnMn IHn.\nQed.",
    "Lemma expnAC m n1 n2 : (m ^ n1) ^ n2 = (m ^ n2) ^ n1.\nProof. by rewrite -!expnM mulnC. Qed.",
    "Lemma expn_gt0 m n : (0 < m ^ n) = (0 < m) || (n == 0).\nProof.\nby case: m => [|m]; elim: n => //= n IHn; rewrite expnS // addn_gt0 IHn.\nQed.",
    "Lemma expn_eq0 m e : (m ^ e == 0) = (m == 0) && (e > 0).\nProof. by rewrite !eqn0Ngt expn_gt0 negb_or -lt0n. Qed.",
    "Lemma ltn_expl m n : 1 < m -> n < m ^ n.\nProof.\nmove=> m_gt1; elim: n => //= n; rewrite -(leq_pmul2l (ltnW m_gt1)) expnS.\nby apply: leq_trans; apply: ltn_Pmull.\nQed.",
    "Lemma leq_exp2l m n1 n2 : 1 < m -> (m ^ n1 <= m ^ n2) = (n1 <= n2).\nProof.\nmove=> m_gt1; elim: n1 n2 => [|n1 IHn] [|n2] //; last 1 first.\n- by rewrite !expnS leq_pmul2l ?IHn // ltnW.\n- by rewrite expn_gt0 ltnW.\nby rewrite leqNgt (leq_trans m_gt1) // expnS leq_pmulr // expn_gt0 ltnW.\nQed.",
    "Lemma ltn_exp2l m n1 n2 : 1 < m -> (m ^ n1 < m ^ n2) = (n1 < n2).\nProof. by move=> m_gt1; rewrite !ltnNge leq_exp2l. Qed.",
    "Lemma eqn_exp2l m n1 n2 : 1 < m -> (m ^ n1 == m ^ n2) = (n1 == n2).\nProof. by move=> m_gt1; rewrite !eqn_leq !leq_exp2l. Qed.",
    "Lemma expnI m : 1 < m -> injective (expn m).\nProof. by move=> m_gt1 e1 e2 /eqP; rewrite eqn_exp2l // => /eqP. Qed.",
    "Lemma leq_pexp2l m n1 n2 : 0 < m -> n1 <= n2 -> m ^ n1 <= m ^ n2.\nProof. by case: m => [|[|m]] // _; [rewrite !exp1n | rewrite leq_exp2l]. Qed.",
    "Lemma ltn_pexp2l m n1 n2 : 0 < m -> m ^ n1 < m ^ n2 -> n1 < n2.\nProof. by case: m => [|[|m]] // _; [rewrite !exp1n | rewrite ltn_exp2l]. Qed.",
    "Lemma ltn_exp2r m n e : e > 0 -> (m ^ e < n ^ e) = (m < n).\nProof.\nmove=> e_gt0; apply/idP/idP=> [|ltmn].\n  rewrite !ltnNge; apply: contra => lemn.\n  by elim: e {e_gt0} => // e IHe; rewrite !expnS leq_mul.\nby elim: e e_gt0 => // [[|e] IHe] _; rewrite ?expn1 // ltn_mul // IHe.\nQed.",
    "Lemma leq_exp2r m n e : e > 0 -> (m ^ e <= n ^ e) = (m <= n).\nProof. by move=> e_gt0; rewrite leqNgt ltn_exp2r // -leqNgt. Qed.",
    "Lemma eqn_exp2r m n e : e > 0 -> (m ^ e == n ^ e) = (m == n).\nProof. by move=> e_gt0; rewrite !eqn_leq !leq_exp2r. Qed.",
    "Lemma expIn e : e > 0 -> injective (expn^~ e).\nProof. by move=> e_gt1 m n /eqP; rewrite eqn_exp2r // => /eqP. Qed.",
    "Lemma iterX (T : Type) (n m : nat) (f : T -> T) :\n  iter (n ^ m) f =1 iter m (iter n) f.\nProof. elim: m => //= m ihm x; rewrite expnS iterM; exact/eq_iter. Qed.",
    "Lemma factE n : factorial n = if n is n'.+1 then n * factorial n' else 1.\nProof. by case: n. Qed.",
    "Lemma fact0 : 0`! = 1. Proof. by []. Qed.",
    "Lemma factS n : (n.+1)`!  = n.+1 * n`!. Proof. by []. Qed.",
    "Lemma fact_gt0 n : n`! > 0.\nProof. by elim: n => //= n IHn; rewrite muln_gt0. Qed.",
    "Lemma fact_geq n : n <= n`!.\nProof. by case: n => // n; rewrite factS -(addn1 n) leq_pmulr ?fact_gt0. Qed.",
    "Lemma ltn_fact m n : 0 < m -> m < n -> m`! < n`!.\nProof.\ncase: m n => // m n _; elim: n m => // n ih [|m] ?; last by rewrite ltn_mul ?ih.\nby rewrite -[_.+1]muln1 leq_mul ?fact_gt0.\nQed.",
    "Lemma leq_b1 (b : bool) : b <= 1. Proof. by case: b. Qed.",
    "Lemma addn_negb (b : bool) : ~~ b + b = 1. Proof. by case: b. Qed.",
    "Lemma eqb0 (b : bool) : (b == 0 :> nat) = ~~ b. Proof. by case: b. Qed.",
    "Lemma eqb1 (b : bool) : (b == 1 :> nat) = b. Proof. by case: b. Qed.",
    "Lemma lt0b (b : bool) : (b > 0) = b. Proof. by case: b. Qed.",
    "Lemma sub1b (b : bool) : 1 - b = ~~ b. Proof. by case: b. Qed.",
    "Lemma mulnb (b1 b2 : bool) : b1 * b2 = b1 && b2.\nProof. by case: b1; case: b2. Qed.",
    "Lemma mulnbl (b : bool) n : b * n = (if b then n else 0).\nProof. by case: b; rewrite ?mul1n. Qed.",
    "Lemma mulnbr (b : bool) n : n * b = (if b then n else 0).\nProof. by rewrite mulnC mulnbl. Qed.",
    "Lemma oddS n : odd n.+1 = ~~ odd n. Proof. by []. Qed.",
    "Lemma oddb (b : bool) : odd b = b. Proof. by case: b. Qed.",
    "Lemma oddD m n : odd (m + n) = odd m (+) odd n.\nProof. by elim: m => [|m IHn] //=; rewrite -addTb IHn addbA addTb. Qed.",
    "Lemma oddB m n : n <= m -> odd (m - n) = odd m (+) odd n.\nProof.\nby move=> le_nm; apply: (@canRL bool) (addbK _) _; rewrite -oddD subnK.\nQed.",
    "Lemma oddN i m : odd m = false -> i <= m -> odd (m - i) = odd i.\nProof. by move=> oddm /oddB ->; rewrite oddm. Qed.",
    "Lemma oddM m n : odd (m * n) = odd m && odd n.\nProof. by elim: m => //= m IHm; rewrite oddD -addTb andb_addl -IHm. Qed.",
    "Lemma oddX m n : odd (m ^ n) = (n == 0) || odd m.\nProof. by elim: n => // n IHn; rewrite expnS oddM {}IHn orbC; case odd. Qed.",
    "Lemma doubleE n : double n = if n is n'.+1 then (double n').+2 else 0.\nProof. by case: n. Qed.",
    "Lemma double0 : 0.*2 = 0. Proof. by []. Qed.",
    "Lemma doubleS n : n.+1.*2 = n.*2.+2. Proof. by []. Qed.",
    "Lemma double_pred n : n.-1.*2 = n.*2.-2. Proof. by case: n. Qed.",
    "Lemma addnn n : n + n = n.*2.\nProof. by apply: eqP; elim: n => // n IHn; rewrite addnS. Qed.",
    "Lemma mul2n m : 2 * m = m.*2.\nProof. by rewrite mulSn mul1n addnn. Qed.",
    "Lemma muln2 m : m * 2 = m.*2.\nProof. by rewrite mulnC mul2n. Qed.",
    "Lemma doubleD m n : (m + n).*2 = m.*2 + n.*2.\nProof. by rewrite -!mul2n mulnDr. Qed.",
    "Lemma doubleB m n : (m - n).*2 = m.*2 - n.*2.\nProof. by elim: m n => [|m IHm] []. Qed.",
    "Lemma leq_double m n : (m.*2 <= n.*2) = (m <= n).\nProof. by rewrite /leq -doubleB; case (m - n). Qed.",
    "Lemma ltn_double m n : (m.*2 < n.*2) = (m < n).\nProof. by rewrite 2!ltnNge leq_double. Qed.",
    "Lemma ltn_Sdouble m n : (m.*2.+1 < n.*2) = (m < n).\nProof. by rewrite -doubleS leq_double. Qed.",
    "Lemma leq_Sdouble m n : (m.*2 <= n.*2.+1) = (m <= n).\nProof. by rewrite leqNgt ltn_Sdouble -leqNgt. Qed.",
    "Lemma odd_double n : odd n.*2 = false.\nProof. by rewrite -addnn oddD addbb. Qed.",
    "Lemma double_gt0 n : (0 < n.*2) = (0 < n).\nProof. by case: n. Qed.",
    "Lemma double_eq0 n : (n.*2 == 0) = (n == 0).\nProof. by case: n. Qed.",
    "Lemma doubleMl m n : (m * n).*2 = m.*2 * n.\nProof. by rewrite -!mul2n mulnA. Qed.",
    "Lemma doubleMr m n : (m * n).*2 = m * n.*2.\nProof. by rewrite -!muln2 mulnA. Qed.",
    "Lemma uphalfE n : uphalf n = n.+1./2.\nProof. by []. Qed.",
    "Lemma doubleK : cancel double half.\nProof. by elim=> //= n ->. Qed.",
    "Lemma uphalf_double n : uphalf n.*2 = n.\nProof. by elim: n => //= n ->. Qed.",
    "Lemma uphalf_half n : uphalf n = odd n + n./2.\nProof. by elim: n => //= n ->; rewrite addnA addn_negb. Qed.",
    "Lemma odd_double_half n : odd n + n./2.*2 = n.\nProof.\nby elim: n => //= n {3}<-; rewrite uphalf_half doubleD; case (odd n).\nQed.",
    "Lemma halfK n : n./2.*2 = n - odd n.\nProof. by rewrite -[n in n - _]odd_double_half addnC addnK. Qed.",
    "Lemma uphalfK n : (uphalf n).*2 = odd n + n.\nProof. by rewrite uphalfE halfK/=; case: odd; rewrite ?subn1. Qed.",
    "Lemma odd_halfK n : odd n -> n./2.*2 = n.-1.\nProof. by rewrite halfK => ->; rewrite subn1. Qed.",
    "Lemma even_halfK n : ~~ odd n -> n./2.*2 = n.\nProof. by rewrite halfK => /negbTE->; rewrite subn0. Qed.",
    "Lemma odd_uphalfK n : odd n -> (uphalf n).*2 = n.+1.\nProof. by rewrite uphalfK => ->. Qed.",
    "Lemma even_uphalfK n : ~~ odd n -> (uphalf n).*2 = n.\nProof. by rewrite uphalfK => /negbTE->. Qed.",
    "Lemma half_bit_double n (b : bool) : (b + n.*2)./2 = n.\nProof. by case: b; rewrite /= (half_double, uphalf_double). Qed.",
    "Lemma halfD m n : (m + n)./2 = (odd m && odd n) + (m./2 + n./2).\nProof.\nrewrite -[n in LHS]odd_double_half addnCA.\nrewrite -[m in LHS]odd_double_half -addnA -doubleD.\nby do 2!case: odd; rewrite /= ?add0n ?half_double ?uphalf_double.\nQed.",
    "Lemma half_leq m n : m <= n -> m./2 <= n./2.\nProof. by move/subnK <-; rewrite halfD addnA leq_addl. Qed.",
    "Lemma geq_half_double m n : (m <= n./2) = (m.*2 <= n).\nProof.\nrewrite -[X in _.*2 <= X]odd_double_half.\ncase: odd; last by rewrite leq_double.\nby case: m => // m; rewrite doubleS ltnS ltn_double.\nQed.",
    "Lemma ltn_half_double m n : (m./2 < n) = (m < n.*2).\nProof. by rewrite ltnNge geq_half_double -ltnNge. Qed.",
    "Lemma leq_half_double m n : (m./2 <= n) = (m <= n.*2.+1).\nProof. by case: m => [|[|m]] //; rewrite ltnS ltn_half_double. Qed.",
    "Lemma gtn_half_double m n : (n < m./2) = (n.*2.+1 < m).\nProof. by rewrite ltnNge leq_half_double -ltnNge. Qed.",
    "Lemma half_gt0 n : (0 < n./2) = (1 < n).\nProof. by case: n => [|[]]. Qed.",
    "Lemma uphalf_leq m n : m <= n -> uphalf m <= uphalf n.\nProof.\nmove/subnK <-; rewrite !uphalf_half oddD halfD !addnA.\nby do 2 case: odd; apply: leq_addl.\nQed.",
    "Lemma leq_uphalf_double m n : (uphalf m <= n) = (m <= n.*2).\nProof. by rewrite uphalfE leq_half_double. Qed.",
    "Lemma geq_uphalf_double m n : (m <= uphalf n) = (m.*2 <= n.+1).\nProof. by rewrite uphalfE geq_half_double. Qed.",
    "Lemma gtn_uphalf_double m n : (n < uphalf m) = (n.*2 < m).\nProof. by rewrite uphalfE gtn_half_double. Qed.",
    "Lemma ltn_uphalf_double m n : (uphalf m < n) = (m.+1 < n.*2).\nProof. by rewrite uphalfE ltn_half_double. Qed.",
    "Lemma uphalf_gt0 n : (0 < uphalf n) = (0 < n).\nProof. by case: n. Qed.",
    "Lemma odd_geq m n : odd n -> (m <= n) = (m./2.*2 <= n).\nProof.\nmove=> odd_n; rewrite -[m in LHS]odd_double_half -[n]odd_double_half odd_n.\nby case: (odd m); rewrite // leq_Sdouble ltnS leq_double.\nQed.",
    "Lemma odd_ltn m n : odd n -> (n < m) = (n < m./2.*2).\nProof. by move=> odd_n; rewrite !ltnNge odd_geq. Qed.",
    "Lemma odd_gt0 n : odd n -> n > 0. Proof. by case: n. Qed.",
    "Lemma odd_gt2 n : odd n -> n > 1 -> n > 2.\nProof. by move=> odd_n n_gt1; rewrite odd_geq. Qed.",
    "Lemma mulnn m : m * m = m ^ 2.\nProof. by rewrite !expnS muln1. Qed.",
    "Lemma sqrnD m n : (m + n) ^ 2 = m ^ 2 + n ^ 2 + 2 * (m * n).\nProof.\nrewrite -!mulnn mul2n mulnDr !mulnDl (mulnC n) -!addnA.\nby congr (_ + _); rewrite addnA addnn addnC.\nQed.",
    "Lemma sqrnB m n : n <= m -> (m - n) ^ 2 = m ^ 2 + n ^ 2 - 2 * (m * n).\nProof.\nmove/subnK <-; rewrite addnK sqrnD -addnA -addnACA -addnA.\nby rewrite addnn -mul2n -mulnDr -mulnDl addnK.\nQed.",
    "Lemma sqrnD_sub m n : n <= m -> (m + n) ^ 2 - 4 * (m * n) = (m - n) ^ 2.\nProof.\nmove=> le_nm; rewrite -[4]/(2 * 2) -mulnA mul2n -addnn subnDA.\nby rewrite sqrnD addnK sqrnB.\nQed.",
    "Lemma subn_sqr m n : m ^ 2 - n ^ 2 = (m - n) * (m + n).\nProof. by rewrite mulnBl !mulnDr addnC (mulnC m) subnDl. Qed.",
    "Lemma ltn_sqr m n : (m ^ 2 < n ^ 2) = (m < n).\nProof. by rewrite ltn_exp2r. Qed.",
    "Lemma leq_sqr m n : (m ^ 2 <= n ^ 2) = (m <= n).\nProof. by rewrite leq_exp2r. Qed.",
    "Lemma sqrn_gt0 n : (0 < n ^ 2) = (0 < n).\nProof. exact: (ltn_sqr 0). Qed.",
    "Lemma eqn_sqr m n : (m ^ 2 == n ^ 2) = (m == n).\nProof. by rewrite eqn_exp2r. Qed.",
    "Lemma sqrn_inj : injective (expn ^~ 2).\nProof. exact: expIn. Qed.",
    "Lemma leqifP m n C : reflect (m <= n ?= iff C) (if C then m == n else m < n).\nProof.\nrewrite ltn_neqAle; apply: (iffP idP) => [|lte]; last by rewrite !lte; case C.\nby case C => [/eqP-> | /andP[/negPf]]; split=> //; apply: eqxx.\nQed.",
    "Lemma leqif_refl m C : reflect (m <= m ?= iff C) C.\nProof. by apply: (iffP idP) => [-> | <-] //; split; rewrite ?eqxx. Qed.",
    "Lemma leqif_trans m1 m2 m3 C12 C23 :\n  m1 <= m2 ?= iff C12 -> m2 <= m3 ?= iff C23 -> m1 <= m3 ?= iff C12 && C23.\nProof.\nmove=> ltm12 ltm23; apply/leqifP; rewrite -ltm12.\nhave [->|eqm12] := eqVneq; first by rewrite ltn_neqAle !ltm23 andbT; case C23.\nby rewrite (@leq_trans m2) ?ltm23 // ltn_neqAle eqm12 ltm12.\nQed.",
    "Lemma mono_leqif f : {mono f : m n / m <= n} ->\n  forall m n C, (f m <= f n ?= iff C) = (m <= n ?= iff C).\nProof. by move=> f_mono m n C; rewrite /leqif !eqn_leq !f_mono. Qed.",
    "Lemma leqif_geq m n : m <= n -> m <= n ?= iff (m >= n).\nProof. by move=> lemn; split=> //; rewrite eqn_leq lemn. Qed.",
    "Lemma leqif_eq m n : m <= n -> m <= n ?= iff (m == n).\nProof. by []. Qed.",
    "Lemma geq_leqif a b C : a <= b ?= iff C -> (b <= a) = C.\nProof. by case=> le_ab; rewrite eqn_leq le_ab. Qed.",
    "Lemma ltn_leqif a b C : a <= b ?= iff C -> (a < b) = ~~ C.\nProof. by move=> le_ab; rewrite ltnNge (geq_leqif le_ab). Qed.",
    "Lemma ltnNleqif x y C : x <= y ?= iff ~~ C -> (x < y) = C.\nProof. by move=> /ltn_leqif; rewrite negbK. Qed.",
    "Lemma eq_leqif x y C : x <= y ?= iff C -> (x == y) = C.\nProof. by move=> /leqifP; case: C ltngtP => [] []. Qed.",
    "Lemma eqTleqif x y C : x <= y ?= iff C -> C -> x = y.\nProof. by move=> /eq_leqif<-/eqP. Qed.",
    "Lemma leqif_add m1 n1 C1 m2 n2 C2 :\n    m1 <= n1 ?= iff C1 -> m2 <= n2 ?= iff C2 ->\n  m1 + m2 <= n1 + n2 ?= iff C1 && C2.\nProof.\nrewrite -(mono_leqif (leq_add2r m2)) -(mono_leqif (leq_add2l n1) m2).\nexact: leqif_trans.\nQed.",
    "Lemma leqif_mul m1 n1 C1 m2 n2 C2 :\n    m1 <= n1 ?= iff C1 -> m2 <= n2 ?= iff C2 ->\n  m1 * m2 <= n1 * n2 ?= iff (n1 * n2 == 0) || (C1 && C2).\nProof.\ncase: n1 => [|n1] le1; first by case: m1 le1 => [|m1] [_ <-] //.\ncase: n2 m2 => [|n2] [|m2] /=; try by case=> // _ <-; rewrite !muln0 ?andbF.\nhave /leq_pmul2l-/mono_leqif<-: 0 < n1.+1 by [].\nby apply: leqif_trans; have /leq_pmul2r-/mono_leqif->: 0 < m2.+1.\nQed.",
    "Lemma nat_Cauchy m n : 2 * (m * n) <= m ^ 2 + n ^ 2 ?= iff (m == n).\nProof.\nwithout loss le_nm: m n / n <= m.\n  by have [?|/ltnW ?] := leqP n m; last rewrite eq_sym addnC (mulnC m); apply.\napply/leqifP; have [-> | ne_mn] := eqVneq; first by rewrite addnn mul2n.\nby rewrite -subn_gt0 -sqrnB // sqrn_gt0 subn_gt0 ltn_neqAle eq_sym ne_mn.\nQed.",
    "Lemma nat_AGM2 m n : 4 * (m * n) <= (m + n) ^ 2 ?= iff (m == n).\nProof.\nrewrite -[4]/(2 * 2) -mulnA mul2n -addnn sqrnD; apply/leqifP.\nby rewrite ltn_add2r eqn_add2r ltn_neqAle !nat_Cauchy; case: eqVneq.\nQed.",
    "Lemma contraTleq b m n : (n < m -> ~~ b) -> (b -> m <= n).\nProof. by rewrite ltnNge; apply: contraTT. Qed.",
    "Lemma contraTltn b m n : (n <= m -> ~~ b) -> (b -> m < n).\nProof. by rewrite ltnNge; apply: contraTN. Qed.",
    "Lemma contraPleq P m n : (n < m -> ~ P) -> (P -> m <= n).\nProof. by rewrite ltnNge; apply: contraPT. Qed.",
    "Lemma contraPltn P m n : (n <= m -> ~ P) -> (P -> m < n).\nProof. by rewrite ltnNge; apply: contraPN. Qed.",
    "Lemma contraNleq b m n : (n < m -> b) -> (~~ b -> m <= n).\nProof. by rewrite ltnNge; apply: contraNT. Qed.",
    "Lemma contraNltn b m n : (n <= m -> b) -> (~~ b -> m < n).\nProof. by rewrite ltnNge; apply: contraNN. Qed.",
    "Lemma contra_not_leq P m n : (n < m -> P) -> (~ P -> m <= n).\nProof. by rewrite ltnNge; apply: contra_notT. Qed.",
    "Lemma contra_not_ltn P m n : (n <= m -> P) -> (~ P -> m < n).\nProof. by rewrite ltnNge; apply: contra_notN. Qed.",
    "Lemma contraFleq b m n : (n < m -> b) -> (b = false -> m <= n).\nProof. by rewrite ltnNge; apply: contraFT. Qed.",
    "Lemma contraFltn b m n : (n <= m -> b) -> (b = false -> m < n).\nProof. by rewrite ltnNge; apply: contraFN. Qed.",
    "Lemma contra_leqT b m n : (~~ b -> m < n) -> (n <= m -> b).\nProof. by rewrite ltnNge; apply: contraTT. Qed.",
    "Lemma contra_ltnT b m n : (~~ b -> m <= n) -> (n < m -> b).\nProof. by rewrite ltnNge; apply: contraNT. Qed.",
    "Lemma contra_leqN b m n : (b -> m < n) -> (n <= m -> ~~ b).\nProof. by rewrite ltnNge; apply: contraTN. Qed.",
    "Lemma contra_ltnN b m n : (b -> m <= n) -> (n < m -> ~~ b).\nProof. by rewrite ltnNge; apply: contraNN. Qed.",
    "Lemma contra_leq_not P m n : (P -> m < n) -> (n <= m -> ~ P).\nProof. by rewrite ltnNge; apply: contraTnot. Qed.",
    "Lemma contra_ltn_not P m n : (P -> m <= n) -> (n < m -> ~ P).\nProof. by rewrite ltnNge; apply: contraNnot. Qed.",
    "Lemma contra_leqF b m n : (b -> m < n) -> (n <= m -> b = false).\nProof. by rewrite ltnNge; apply: contraTF. Qed.",
    "Lemma contra_ltnF b m n : (b -> m <= n) -> (n < m -> b = false).\nProof. by rewrite ltnNge; apply: contraNF. Qed.",
    "Lemma contra_leq m n p q : (q < p -> n < m) -> (m <= n -> p <= q).\nProof. by rewrite !ltnNge; apply: contraTT. Qed.",
    "Lemma contra_leq_ltn m n p q : (q <= p -> n < m) -> (m <= n -> p < q).\nProof. by rewrite !ltnNge; apply: contraTN. Qed.",
    "Lemma contra_ltn_leq m n p q : (q < p -> n <= m) -> (m < n -> p <= q).\nProof. by rewrite !ltnNge; apply: contraNT. Qed.",
    "Lemma contra_ltn m n p q : (q <= p -> n <= m) -> (m < n -> p < q).\nProof. by rewrite !ltnNge; apply: contraNN. Qed.",
    "Lemma homo_ltn_in (D : {pred nat}) (f : nat -> T) (r : T -> T -> Prop) :\n  (forall y x z, r x y -> r y z -> r x z) ->\n  {in D &, forall i j k, i < k < j -> k \\in D} ->\n  {in D, forall i, i.+1 \\in D -> r (f i) (f i.+1)} ->\n  {in D &, {homo f : i j / i < j >-> r i j}}.\nProof.\nmove=> r_trans Dcx r_incr i j iD jD lt_ij; move: (lt_ij) (jD) => /subnKC<-.\nelim: (_ - _) => [|k ihk]; first by rewrite addn0 => Dsi; apply: r_incr.\nmove=> DSiSk [: DSik]; apply: (r_trans _ _ _ (ihk _)); rewrite ?addnS.\n  by abstract: DSik; apply: (Dcx _ _ iD DSiSk); rewrite ltn_addr ?addnS /=.\nby apply: r_incr; rewrite -?addnS.\nQed.",
    "Lemma homo_ltn (f : nat -> T) (r : T -> T -> Prop) :\n  (forall y x z, r x y -> r y z -> r x z) ->\n  (forall i, r (f i) (f i.+1)) -> {homo f : i j / i < j >-> r i j}.\nProof. by move=> /(@homo_ltn_in predT f) fr fS i j; apply: fr. Qed.",
    "Lemma homo_leq_in (D : {pred nat}) (f : nat -> T) (r : T -> T -> Prop) :\n  (forall x, r x x) -> (forall y x z, r x y -> r y z -> r x z) ->\n  {in D &, forall i j k, i < k < j -> k \\in D} ->\n  {in D, forall i, i.+1 \\in D -> r (f i) (f i.+1)} ->\n  {in D &, {homo f : i j / i <= j >-> r i j}}.\nProof.\nmove=> r_refl r_trans Dcx /(homo_ltn_in r_trans Dcx) lt_r i j iD jD.\ncase: ltngtP => [? _||->] //; exact: lt_r.\nQed.",
    "Lemma homo_leq (f : nat -> T) (r : T -> T -> Prop) :\n   (forall x, r x x) -> (forall y x z, r x y -> r y z -> r x z) ->\n  (forall i, r (f i) (f i.+1)) -> {homo f : i j / i <= j >-> r i j}.\nProof. by move=> rrefl /(@homo_leq_in predT f r) fr fS i j; apply: fr. Qed.",
    "Lemma ltnW_homo : {homo f : m n / m < n} -> {homo f : m n / m <= n}.\nProof. exact: homoW. Qed.",
    "Lemma inj_homo_ltn : injective f -> {homo f : m n / m <= n} ->\n  {homo f : m n / m < n}.\nProof. exact: inj_homo. Qed.",
    "Lemma ltnW_nhomo : {homo f : m n /~ m < n} -> {homo f : m n /~ m <= n}.\nProof. exact: homoW. Qed.",
    "Lemma inj_nhomo_ltn : injective f -> {homo f : m n /~ m <= n} ->\n  {homo f : m n /~ m < n}.\nProof. exact: inj_homo. Qed.",
    "Lemma incn_inj : {mono f : m n / m <= n} -> injective f.\nProof. exact: mono_inj. Qed.",
    "Lemma decn_inj : {mono f : m n /~ m <= n} -> injective f.\nProof. exact: mono_inj. Qed.",
    "Lemma leqW_mono : {mono f : m n / m <= n} -> {mono f : m n / m < n}.\nProof. exact: anti_mono. Qed.",
    "Lemma leqW_nmono : {mono f : m n /~ m <= n} -> {mono f : m n /~ m < n}.\nProof. exact: anti_mono. Qed.",
    "Lemma leq_mono : {homo f : m n / m < n} -> {mono f : m n / m <= n}.\nProof. exact: total_homo_mono. Qed.",
    "Lemma leq_nmono : {homo f : m n /~ m < n} -> {mono f : m n /~ m <= n}.\nProof. exact: total_homo_mono. Qed.",
    "Lemma ltnW_homo_in : {in D & D', {homo f : m n / m < n}} ->\n  {in D & D', {homo f : m n / m <= n}}.\nProof. exact: homoW_in. Qed.",
    "Lemma ltnW_nhomo_in : {in D & D', {homo f : m n /~ m < n}} ->\n                 {in D & D', {homo f : m n /~ m <= n}}.\nProof. exact: homoW_in. Qed.",
    "Lemma inj_homo_ltn_in : {in D & D', injective f} ->\n                        {in D & D', {homo f : m n / m <= n}} ->\n  {in D & D', {homo f : m n / m < n}}.\nProof. exact: inj_homo_in. Qed.",
    "Lemma inj_nhomo_ltn_in : {in D & D', injective f} ->\n                        {in D & D', {homo f : m n /~ m <= n}} ->\n  {in D & D', {homo f : m n /~ m < n}}.\nProof. exact: inj_homo_in. Qed.",
    "Lemma incn_inj_in : {in D &, {mono f : m n / m <= n}} ->\n  {in D &, injective f}.\nProof. exact: mono_inj_in. Qed.",
    "Lemma decn_inj_in : {in D &, {mono f : m n /~ m <= n}} ->\n  {in D &, injective f}.\nProof. exact: mono_inj_in. Qed.",
    "Lemma leqW_mono_in : {in D &, {mono f : m n / m <= n}} ->\n  {in D &, {mono f : m n / m < n}}.\nProof. exact: anti_mono_in. Qed.",
    "Lemma leqW_nmono_in : {in D &, {mono f : m n /~ m <= n}} ->\n  {in D &, {mono f : m n /~ m < n}}.\nProof. exact: anti_mono_in. Qed.",
    "Lemma leq_mono_in : {in D &, {homo f : m n / m < n}} ->\n  {in D &, {mono f : m n / m <= n}}.\nProof. exact: total_homo_mono_in. Qed.",
    "Lemma leq_nmono_in : {in D &, {homo f : m n /~ m < n}} ->\n  {in D &, {mono f : m n /~ m <= n}}.\nProof. exact: total_homo_mono_in. Qed.",
    "Lemma leq_pfact : {in [pred n | 0 < n] &, {mono factorial : m n / m <= n}}.\nProof. by apply: leq_mono_in => n m n0 m0; apply: ltn_fact. Qed.",
    "Lemma leq_fact : {homo factorial : m n / m <= n}.\nProof.\nby move=> [m|m n mn]; rewrite ?fact_gt0// leq_pfact// inE (leq_trans _ mn).\nQed.",
    "Lemma ltn_pfact : {in [pred n | 0 < n] &, {mono factorial : m n / m < n}}.\nProof. exact/leqW_mono_in/leq_pfact. Qed.",
    "Lemma addE : add =2 addn.\nProof. by elim=> //= n IHn m; rewrite IHn addSnnS. Qed.",
    "Lemma doubleE : double =1 doublen.\nProof. by case=> // n; rewrite -addnn -addE. Qed.",
    "Lemma add_mulE n m s : add_mul n m s = addn (muln n m) s.\nProof. by elim: n => //= n IHn in m s *; rewrite IHn addE addnCA addnA. Qed.",
    "Lemma mulE : mul =2 muln.\nProof. by case=> //= n m; rewrite add_mulE addnC. Qed.",
    "Lemma mul_expE m n p : mul_exp m n p = muln (expn m n) p.\nProof.\nby elim: n => [|n IHn] in p *; rewrite ?mul1n //= expnS IHn mulE mulnCA mulnA.\nQed.",
    "Lemma expE : exp =2 expn.\nProof. by move=> m [|n] //=; rewrite mul_expE expnS mulnC. Qed.",
    "Lemma oddE : odd =1 oddn.\nProof.\nmove=> n; rewrite -[n in LHS]odd_double_half addnC.\nby elim: n./2 => //=; case (oddn n).\nQed.",
    "Lemma eq_binP : Equality.axiom N_eqb.\nProof.\nmove=> p q; apply: (iffP idP) => [|<-]; last by case: p => //; elim.\nby case: q; case: p => //; elim=> [p IHp|p IHp|] [q|q|] //= /IHp [->].\nQed.",
    "Lemma bin_of_natK : cancel bin_of_nat nat_of_bin.\nProof.\nhave sub2nn n : n.*2 - n = n by rewrite -addnn addKn.\ncase=> //= n; rewrite -[n in RHS]sub2nn.\nby elim: n {2 4}n => // m IHm [|[|n]] //=; rewrite IHm // natTrecE sub2nn.\nQed.",
    "Lemma nat_of_binK : cancel nat_of_bin bin_of_nat.\nProof.\ncase=> //=; elim=> //= p; case: (nat_of_pos p) => //= n [<-].\n  by rewrite natTrecE !addnS {2}addnn; elim: {1 3}n.\nby rewrite natTrecE addnS /= addnS {2}addnn; elim: {1 3}n.\nQed.",
    "Lemma nat_of_succ_pos p : Pos.succ p = p.+1 :> nat.\nProof. by elim: p => //= p ->; rewrite !natTrecE. Qed.",
    "Lemma nat_of_add_pos p q : Pos.add p q = p + q :> nat.\nProof.\napply: @fst _ (Pos.add_carry p q = (p + q).+1 :> nat) _.\nelim: p q => [p IHp|p IHp|] [q|q|] //=; rewrite !natTrecE //;\n  by rewrite ?IHp ?nat_of_succ_pos ?(doubleS, doubleD, addn1, addnS).\nQed.",
    "Lemma nat_of_mul_pos p q : Pos.mul p q = p * q :> nat.\nProof.\nelim: p => [p IHp|p IHp|] /=; rewrite ?mul1n //;\n  by rewrite ?nat_of_add_pos /= !natTrecE IHp doubleMl.\nQed.",
    "Lemma decodeK : cancel decode code.\nProof.\nhave m2s: forall n, n.*2 - n = n by move=> n; rewrite -addnn addnK.\ncase=> //= n; rewrite -[n.+1]mul1n -(expn0 2) -[n in RHS]m2s.\nelim: n {2 4}n {1 3}0 => [|q IHq] [|[|r]] v //=; rewrite {}IHq ?mul1n ?m2s //.\nby rewrite expnSr -mulnA mul2n.\nQed.",
    "Lemma codeK : cancel code decode.\nProof.\nelim=> //= v s IHs; rewrite -[_ * _]prednK ?muln_gt0 ?expn_gt0 //=.\nset two := 2; rewrite -[v in RHS]addn0; elim: v 0 => [|v IHv {IHs}] q.\n  rewrite mul1n add0n /= -{}[in RHS]IHs; case: (code s) => // u; pose n := u.+1.\n  by transitivity [rec q, n + u.+1, n.*2]; [rewrite addnn | elim: n => //=].\nrewrite expnS -mulnA mul2n -{1}addnn -[_ * _]prednK ?muln_gt0 ?expn_gt0 //.\nset u := _.-1 in IHv *; set n := u; rewrite [in u1 in _ + u1]/n.\nby rewrite [in RHS]addSnnS -{}IHv; elim: n.\nQed.",
    "Lemma ltn_code s : all (fun j => j < code s) s.\nProof.\nelim: s => //= i s IHs; rewrite -[_.+1]muln1 leq_mul 1?ltn_expl //=.\napply: sub_all IHs => j /leqW lejs; rewrite -[j.+1]mul1n leq_mul ?expn_gt0 //.\nby rewrite ltnS -[j]mul1n -mul2n leq_mul.\nQed.",
    "Lemma gtn_decode n : all (ltn^~ n) (decode n).\nProof. by rewrite -{1}[n]decodeK ltn_code. Qed.",
    "Lemma seq_of_optK : cancel seq_of_opt ohead. Proof. by case. Qed.",
    "Lemma tag_of_pairK : cancel tag_of_pair pair_of_tag. Proof. by case. Qed.",
    "Lemma pair_of_tagK : cancel pair_of_tag tag_of_pair. Proof. by case. Qed.",
    "Lemma opair_of_sumK : pcancel opair_of_sum sum_of_opair. Proof. by case. Qed.",
    "Lemma bool_of_unitK : cancel (fun _ => true) (fun _ => tt).\nProof. by case. Qed.",
    "Lemma codeK : pcancel encode decode.\nProof.\nmove=> t; rewrite /decode; set fs := (_, _).\nsuffices ->: foldr decode_step fs (encode t) = (t :: fs.1, fs.2) by [].\nelim: t => //= n f IHt in (fs) *; elim: f IHt => //= t f IHf [].\nby rewrite rcons_cat foldr_cat => -> /= /IHf[-> -> ->].\nQed.",
    "Lemma xchooseP P exP : P (@xchoose P exP).\nProof. by rewrite /xchoose; case: (xchoose_subproof exP) => x /= /correct. Qed.",
    "Lemma eq_xchoose P Q exP exQ : P =1 Q -> @xchoose P exP = @xchoose Q exQ.\nProof.\nrewrite /xchoose => eqPQ.\ncase: (xchoose_subproof exP) => x; case: (xchoose_subproof exQ) => y /=.\ncase: ex_minnP => n; rewrite -(extensional eqPQ) => Pn minQn.\ncase: ex_minnP => m; rewrite !(extensional eqPQ) => Qm minPm.\nby case: (eqVneq m n) => [-> -> [] //|]; rewrite eqn_leq minQn ?minPm.\nQed.",
    "Lemma sigW P : (exists x, P x) -> {x | P x}.\nProof. by move=> exP; exists (xchoose exP); apply: xchooseP. Qed.",
    "Lemma sig2W P Q : (exists2 x, P x & Q x) -> {x | P x & Q x}.\nProof.\nmove=> exPQ; have [|x /andP[]] := @sigW (predI P Q); last by exists x.\nby have [x Px Qx] := exPQ; exists x; apply/andP.\nQed.",
    "Lemma sig_eqW (vT : eqType) (lhs rhs : T -> vT) :\n  (exists x, lhs x = rhs x) -> {x | lhs x = rhs x}.\nProof.\nmove=> exP; suffices [x /eqP Ex]: {x | lhs x == rhs x} by exists x.\nby apply: sigW; have [x /eqP Ex] := exP; exists x.\nQed.",
    "Lemma sig2_eqW (vT : eqType) (P : pred T) (lhs rhs : T -> vT) :\n  (exists2 x, P x & lhs x = rhs x) -> {x | P x & lhs x = rhs x}.\nProof.\nmove=> exP; suffices [x Px /eqP Ex]: {x | P x & lhs x == rhs x} by exists x.\nby apply: sig2W; have [x Px /eqP Ex] := exP; exists x.\nQed.",
    "Lemma chooseP P x0 : P x0 -> P (choose P x0).\nProof. by move=> Px0; rewrite /choose insubT xchooseP. Qed.",
    "Lemma choose_id P x0 y0 : P x0 -> P y0 -> choose P x0 = choose P y0.\nProof. by move=> Px0 Py0; rewrite /choose !insubT /=; apply: eq_xchoose. Qed.",
    "Lemma eq_choose P Q : P =1 Q -> choose P =1 choose Q.\nProof.\nrewrite /choose => eqPQ x0.\ndo [case: insubP; rewrite eqPQ] => [[x Px] Qx0 _| ?]; last by rewrite insubN.\nby rewrite insubT; apply: eq_xchoose.\nQed.",
    "Lemma PCanHasChoice f' : pcancel f f' -> hasChoice sT.\nProof.\nmove=> fK; pose liftP sP := [pred x | oapp sP false (f' x)].\npose sf sP := [fun n => obind f' (find (liftP sP) n)].\nexists sf => [sP n x | sP [y sPy] | sP sQ eqPQ n] /=.\n- by case Df: (find _ n) => //= [?] Dx; have:= correct Df; rewrite /= Dx.\n- have [|n Pn] := @complete T (liftP sP); first by exists (f y); rewrite /= fK.\n  exists n; case Df: (find _ n) Pn => //= [x] _.\n  by have:= correct Df => /=; case: (f' x).\nby congr (obind _ _); apply: extensional => x /=; case: (f' x) => /=.\nQed.",
    "Lemma pickle_invK : ocancel pickle_inv pickle.\nProof.\nby rewrite /pickle_inv => n; case def_x: (unpickle n) => //= [x]; case: eqP.\nQed.",
    "Lemma pickleK_inv : pcancel pickle pickle_inv.\nProof. by rewrite /pickle_inv => x; rewrite pickleK /= eqxx. Qed.",
    "Lemma pcan_pickleK sT f f' :\n  @pcancel T sT f f' -> pcancel (pickle \\o f) (pcomp f' unpickle).\nProof. by move=> fK x; rewrite /pcomp pickleK /= fK. Qed.",
    "Lemma pickle_seqK : pcancel pickle_seq unpickle_seq.\nProof. by move=> s; rewrite /unpickle_seq CodeSeq.codeK (map_pK pickleK). Qed.",
    "Lemma pickle_taggedK : pcancel pickle_tagged unpickle_tagged.\nProof.\nby case=> i x; rewrite /unpickle_tagged CodeSeq.codeK /= pickleK /= pickleK.\nQed.",
    "Lemma nat_pickleK : pcancel id (@Some nat). Proof. by []. Qed.",
    "Lemma test_orb (a b c d : bool) : (a || b) || (c || d) = (a || c) || (b || d).\nProof. time by rewrite orbACA. Restart.\nProof. time by rewrite (AC (2*2) ((1*3)*(2*4))). Restart.\nProof. time by rewrite orb.[AC (2*2) ((1*3)*(2*4))]. Qed.",
    "Lemma test_addn (a b c d : nat) : a + b + c + d = a + c + b + d.\nProof. time by rewrite -addnA addnAC addnA addnAC. Restart.\nProof. time by rewrite (ACl (1*3*2*4)). Restart.\nProof. time by rewrite addn.[ACl 1*3*2*4]. Qed.",
    "Lemma test_addr (R : comRingType) (a b c d : R) : (a + b + c + d = a + c + b + d)%R.\nProof. time by rewrite -GRing.addrA GRing.addrAC GRing.addrA GRing.addrAC. Restart.\nProof. time by rewrite (ACl (1*3*2*4)). Restart.\nProof. time by rewrite (@GRing.add R).[ACl 1*3*2*4]. Qed.",
    "Lemma addr0 : @right_id V V 0 +%R.\nProof. by move=> x; rewrite addrC add0r. Qed.",
    "Lemma addrCA : @left_commutative V V +%R. Proof. exact: mulmCA. Qed.",
    "Lemma addrAC : @right_commutative V V +%R. Proof. exact: mulmAC. Qed.",
    "Lemma addrACA : @interchange V +%R +%R. Proof. exact: mulmACA. Qed.",
    "Lemma mulr0n x : x *+ 0 = 0. Proof. by []. Qed.",
    "Lemma mulr1n x : x *+ 1 = x. Proof. by []. Qed.",
    "Lemma mulr2n x : x *+ 2 = x + x. Proof. by []. Qed.",
    "Lemma mulrS x n : x *+ n.+1 = x + x *+ n.\nProof. by case: n => //=; rewrite addr0. Qed.",
    "Lemma mulrSr x n : x *+ n.+1 = x *+ n + x.\nProof. by rewrite addrC mulrS. Qed.",
    "Lemma mulrb x (b : bool) : x *+ b = (if b then x else 0).\nProof. by case: b. Qed.",
    "Lemma mul0rn n : 0 *+ n = 0 :> V.\nProof. by elim: n => // n IHn; rewrite mulrS add0r. Qed.",
    "Lemma mulrnDl n : {morph (fun x => x *+ n) : x y / x + y}.\nProof.\nmove=> x y; elim: n => [|n IHn]; rewrite ?addr0 // !mulrS.\nby rewrite addrCA -!addrA -IHn -addrCA.\nQed.",
    "Lemma mulrnDr x m n : x *+ (m + n) = x *+ m + x *+ n.\nProof.\nelim: m => [|m IHm]; first by rewrite add0r.\nby rewrite !mulrS IHm addrA.\nQed.",
    "Lemma mulrnA x m n : x *+ (m * n) = x *+ m *+ n.\nProof.\nby rewrite mulnC; elim: n => //= n IHn; rewrite mulrS mulrnDr IHn.\nQed.",
    "Lemma mulrnAC x m n : x *+ m *+ n = x *+ n *+ m.\nProof. by rewrite -!mulrnA mulnC. Qed.",
    "Lemma iter_addr n x y : iter n (+%R x) y = x *+ n + y.\nProof. by elim: n => [|n ih]; rewrite ?add0r //= ih mulrS addrA. Qed.",
    "Lemma iter_addr_0 n x : iter n (+%R x) 0 = x *+ n.\nProof. by rewrite iter_addr addr0. Qed.",
    "Lemma sumrMnl I r P (F : I -> V) n :\n  \\sum_(i <- r | P i) F i *+ n = (\\sum_(i <- r | P i) F i) *+ n.\nProof. by rewrite (big_morph _ (mulrnDl n) (mul0rn _)). Qed.",
    "Lemma sumrMnr x I r P (F : I -> nat) :\n  \\sum_(i <- r | P i) x *+ F i = x *+ (\\sum_(i <- r | P i) F i).\nProof. by rewrite (big_morph _ (mulrnDr x) (erefl _)). Qed.",
    "Lemma sumr_const (I : finType) (A : pred I) x : \\sum_(i in A) x = x *+ #|A|.\nProof. by rewrite big_const -iteropE. Qed.",
    "Lemma sumr_const_nat m n x : \\sum_(n <= i < m) x = x *+ (m - n).\nProof. by rewrite big_const_nat iter_addr_0. Qed.",
    "Lemma addrN : @right_inverse V V V 0 -%R +%R.\nProof. by move=> x; rewrite addrC addNr. Qed.",
    "Lemma addKr : @left_loop V V -%R +%R.\nProof. by move=> x y; rewrite addrA addNr add0r. Qed.",
    "Lemma addNKr : @rev_left_loop V V -%R +%R.\nProof. by move=> x y; rewrite addrA addrN add0r. Qed.",
    "Lemma addrK : @right_loop V V -%R +%R.\nProof. by move=> x y; rewrite -addrA addrN addr0. Qed.",
    "Lemma addrNK : @rev_right_loop V V -%R +%R.\nProof. by move=> x y; rewrite -addrA addNr addr0. Qed.",
    "Lemma subKr x : involutive (fun y => x - y).\nProof. by move=> y; apply: (canLR (addrK _)); rewrite addrC subrK. Qed.",
    "Lemma addrI : @right_injective V V V +%R.\nProof. by move=> x; apply: can_inj (addKr x). Qed.",
    "Lemma addIr : @left_injective V V V +%R.\nProof. by move=> y; apply: can_inj (addrK y). Qed.",
    "Lemma subrI : right_injective (fun x y => x - y).\nProof. by move=> x; apply: can_inj (subKr x). Qed.",
    "Lemma subIr : left_injective (fun x y => x - y).\nProof. by move=> y; apply: addIr. Qed.",
    "Lemma opprK : @involutive V -%R.\nProof. by move=> x; apply: (@subIr x); rewrite addNr addrN. Qed.",
    "Lemma oppr_inj : @injective V V -%R.\nProof. exact: inv_inj opprK. Qed.",
    "Lemma oppr0 : -0 = 0 :> V.\nProof. by rewrite -[-0]add0r subrr. Qed.",
    "Lemma oppr_eq0 x : (- x == 0) = (x == 0).\nProof. by rewrite (inv_eq opprK) oppr0. Qed.",
    "Lemma subr0 x : x - 0 = x. Proof. by rewrite oppr0 addr0. Qed.",
    "Lemma sub0r x : 0 - x = - x. Proof. by rewrite add0r. Qed.",
    "Lemma opprB x y : - (x - y) = y - x.\nProof. by apply: (canRL (addrK x)); rewrite addrC subKr. Qed.",
    "Lemma opprD : {morph -%R: x y / x + y : V}.\nProof. by move=> x y; rewrite -[y in LHS]opprK opprB addrC. Qed.",
    "Lemma addrKA z x y : (x + z) - (z + y) = x - y.\nProof. by rewrite opprD addrA addrK. Qed.",
    "Lemma subrKA z x y : (x - z) + (z + y) = x + y.\nProof. by rewrite addrA addrNK. Qed.",
    "Lemma addr0_eq x y : x + y = 0 -> - x = y.\nProof. by rewrite -[-x]addr0 => <-; rewrite addKr. Qed.",
    "Lemma subr0_eq x y : x - y = 0 -> x = y. Proof. by move/addr0_eq/oppr_inj. Qed.",
    "Lemma subr_eq x y z : (x - z == y) = (x == y + z).\nProof. exact: can2_eq (subrK z) (addrK z) x y. Qed.",
    "Lemma subr_eq0 x y : (x - y == 0) = (x == y).\nProof. by rewrite subr_eq add0r. Qed.",
    "Lemma addr_eq0 x y : (x + y == 0) = (x == - y).\nProof. by rewrite -[y in LHS]opprK subr_eq0. Qed.",
    "Lemma eqr_opp x y : (- x == - y) = (x == y).\nProof. exact: can_eq opprK x y. Qed.",
    "Lemma eqr_oppLR x y : (- x == y) = (x == - y).\nProof. exact: inv_eq opprK x y. Qed.",
    "Lemma mulNrn x n : (- x) *+ n = x *- n.\nProof. by elim: n => [|n IHn]; rewrite ?oppr0 // !mulrS opprD IHn. Qed.",
    "Lemma mulrnBl n : {morph (fun x => x *+ n) : x y / x - y}.\nProof.\nmove=> x y; elim: n => [|n IHn]; rewrite ?subr0 // !mulrS -!addrA; congr(_ + _).\nby rewrite addrC IHn -!addrA opprD [_ - y]addrC.\nQed.",
    "Lemma mulrnBr x m n : n <= m -> x *+ (m - n) = x *+ m - x *+ n.\nProof.\nelim: m n => [|m IHm] [|n le_n_m]; rewrite ?subr0 // {}IHm //.\nby rewrite mulrSr mulrS opprD addrA addrK.\nQed.",
    "Lemma sumrN I r P (F : I -> V) :\n  (\\sum_(i <- r | P i) - F i = - (\\sum_(i <- r | P i) F i)).\nProof. by rewrite (big_morph _ opprD oppr0). Qed.",
    "Lemma sumrB I r (P : pred I) (F1 F2 : I -> V) :\n  \\sum_(i <- r | P i) (F1 i - F2 i)\n     = \\sum_(i <- r | P i) F1 i - \\sum_(i <- r | P i) F2 i.\nProof. by rewrite -sumrN -big_split /=. Qed.",
    "Lemma telescope_sumr n m (f : nat -> V) : n <= m ->\n  \\sum_(n <= k < m) (f k.+1 - f k) = f m - f n.\nProof.\nmove=> nm; rewrite (telescope_big (fun i j => f j - f i)).\n  by case: ltngtP nm => // ->; rewrite subrr.\nby move=> k /andP[nk km]/=; rewrite addrC subrKA.\nQed.",
    "Lemma telescope_sumr_eq n m (f u : nat -> V) : n <= m ->\n    (forall k, (n <= k < m)%N -> u k = f k.+1 - f k) ->\n  \\sum_(n <= k < m) u k = f m - f n.\nProof.\nby move=> ? uE; under eq_big_nat do rewrite uE //=; exact: telescope_sumr.\nQed.",
    "Lemma zmod_closedN : zmod_closed -> oppr_closed.\nProof. by case=> S0 SB y Sy; rewrite -sub0r !SB. Qed.",
    "Lemma zmod_closedD : zmod_closed -> addr_closed S.\nProof.\nby case=> S0 SB; split=> // y z Sy Sz; rewrite -[z]opprK -[- z]sub0r !SB.\nQed.",
    "Lemma mulr_suml I r P (F : I -> R) x :\n  (\\sum_(i <- r | P i) F i) * x = \\sum_(i <- r | P i) F i * x.\nProof. exact: big_distrl. Qed.",
    "Lemma mulr_sumr I r P (F : I -> R) x :\n  x * (\\sum_(i <- r | P i) F i) = \\sum_(i <- r | P i) x * F i.\nProof. exact: big_distrr. Qed.",
    "Lemma mulrnAl x y n : (x *+ n) * y = (x * y) *+ n.\nProof. by elim: n => [|n IHn]; rewrite ?mul0r // !mulrS mulrDl IHn. Qed.",
    "Lemma mulrnAr x y n : x * (y *+ n) = (x * y) *+ n.\nProof. by elim: n => [|n IHn]; rewrite ?mulr0 // !mulrS mulrDr IHn. Qed.",
    "Lemma mulr_natl x n : n%:R * x = x *+ n.\nProof. by rewrite mulrnAl mul1r. Qed.",
    "Lemma mulr_natr x n : x * n%:R = x *+ n.\nProof. by rewrite mulrnAr mulr1. Qed.",
    "Lemma natrD m n : (m + n)%:R = m%:R + n%:R :> R.\nProof. exact: mulrnDr. Qed.",
    "Lemma natr1 n : n%:R + 1 = n.+1%:R :> R. Proof. by rewrite mulrSr. Qed.",
    "Lemma nat1r n : 1 + n%:R = n.+1%:R :> R. Proof. by rewrite mulrS. Qed.",
    "Lemma natrM m n : (m * n)%:R = m%:R * n%:R :> R.\nProof. by rewrite mulrnA mulr_natr. Qed.",
    "Lemma expr0 x : x ^+ 0 = 1. Proof. by []. Qed.",
    "Lemma expr1 x : x ^+ 1 = x. Proof. by []. Qed.",
    "Lemma expr2 x : x ^+ 2 = x * x. Proof. by []. Qed.",
    "Lemma exprS x n : x ^+ n.+1 = x * x ^+ n.\nProof. by case: n => //; rewrite mulr1. Qed.",
    "Lemma expr0n n : 0 ^+ n = (n == 0%N)%:R :> R.\nProof. by case: n => // n; rewrite exprS mul0r. Qed.",
    "Lemma expr1n n : 1 ^+ n = 1 :> R.\nProof. by elim: n => // n IHn; rewrite exprS mul1r. Qed.",
    "Lemma exprD x m n : x ^+ (m + n) = x ^+ m * x ^+ n.\nProof. by elim: m => [|m IHm]; rewrite ?mul1r // !exprS -mulrA -IHm. Qed.",
    "Lemma exprSr x n : x ^+ n.+1 = x ^+ n * x.\nProof. by rewrite -addn1 exprD expr1. Qed.",
    "Lemma expr_sum x (I : Type) (s : seq I) (P : pred I) F :\n  x ^+ (\\sum_(i <- s | P i) F i) = \\prod_(i <- s | P i) x ^+ F i :> R.\nProof. exact: (big_morph _ (exprD _)). Qed.",
    "Lemma commr_sym x y : comm x y -> comm y x. Proof. by []. Qed.",
    "Lemma commr_refl x : comm x x. Proof. by []. Qed.",
    "Lemma commr0 x : comm x 0.\nProof. by rewrite /comm mulr0 mul0r. Qed.",
    "Lemma commr1 x : comm x 1.\nProof. by rewrite /comm mulr1 mul1r. Qed.",
    "Lemma commrD x y z : comm x y -> comm x z -> comm x (y + z).\nProof. by rewrite /comm mulrDl mulrDr => -> ->. Qed.",
    "Lemma commr_sum (I : Type) (s : seq I) (P : pred I) (F : I -> R) x :\n  (forall i, P i -> comm x (F i)) -> comm x (\\sum_(i <- s | P i) F i).\nProof.\nmove=> comm_x_F; rewrite /comm mulr_suml mulr_sumr.\nby apply: eq_bigr => i /comm_x_F.\nQed.",
    "Lemma commrMn x y n : comm x y -> comm x (y *+ n).\nProof.\nrewrite /comm => com_xy.\nby elim: n => [|n IHn]; rewrite ?commr0 // mulrS commrD.\nQed.",
    "Lemma commrM x y z : comm x y -> comm x z -> comm x (y * z).\nProof. by move=> com_xy; rewrite /comm mulrA com_xy -!mulrA => ->. Qed.",
    "Lemma commr_prod (I : Type) (s : seq I) (P : pred I) (F : I -> R) x :\n  (forall i, P i -> comm x (F i)) -> comm x (\\prod_(i <- s | P i) F i).\nProof. exact: (big_ind _ (commr1 x) (@commrM x)). Qed.",
    "Lemma commr_nat x n : comm x n%:R.\nProof. exact/commrMn/commr1. Qed.",
    "Lemma commrX x y n : comm x y -> comm x (y ^+ n).\nProof.\nrewrite /comm => com_xy.\nby elim: n => [|n IHn]; rewrite ?commr1 // exprS commrM.\nQed.",
    "Lemma exprMn_comm x y n : comm x y -> (x * y) ^+ n = x ^+ n * y ^+ n.\nProof.\nmove=> com_xy; elim: n => /= [|n IHn]; first by rewrite mulr1.\nby rewrite !exprS IHn !mulrA; congr (_ * _); rewrite -!mulrA -commrX.\nQed.",
    "Lemma exprMn_n x m n : (x *+ m) ^+ n = x ^+ n *+ (m ^ n) :> R.\nProof.\nelim: n => [|n IHn]; first by rewrite mulr1n.\nrewrite exprS IHn -mulr_natr -mulrA -commr_nat mulr_natr -mulrnA -expnSr.\nby rewrite -mulr_natr mulrA -exprS mulr_natr.\nQed.",
    "Lemma exprM x m n : x ^+ (m * n) = x ^+ m ^+ n.\nProof.\nelim: m => [|m IHm]; first by rewrite expr1n.\nby rewrite mulSn exprD IHm exprS exprMn_comm //; apply: commrX.\nQed.",
    "Lemma exprAC x m n : (x ^+ m) ^+ n = (x ^+ n) ^+ m.\nProof. by rewrite -!exprM mulnC. Qed.",
    "Lemma expr_mod n x i : x ^+ n = 1 -> x ^+ (i %% n) = x ^+ i.\nProof.\nmove=> xn1; rewrite {2}(divn_eq i n) exprD mulnC exprM xn1.\nby rewrite expr1n mul1r.\nQed.",
    "Lemma expr_dvd n x i : x ^+ n = 1 -> n %| i -> x ^+ i = 1.\nProof.\nby move=> xn1 dvd_n_i; rewrite -(expr_mod i xn1) (eqnP dvd_n_i).\nQed.",
    "Lemma natrX n k : (n ^ k)%:R = n%:R ^+ k :> R.\nProof. by rewrite exprMn_n expr1n. Qed.",
    "Lemma mulrI_eq0 x y : lreg x -> (x * y == 0) = (y == 0).\nProof. by move=> reg_x; rewrite -{1}(mulr0 x) (inj_eq reg_x). Qed.",
    "Lemma lreg1 : lreg (1 : R).\nProof. by move=> x y; rewrite !mul1r. Qed.",
    "Lemma lregM x y : lreg x -> lreg y -> lreg (x * y).\nProof. by move=> reg_x reg_y z t; rewrite -!mulrA => /reg_x/reg_y. Qed.",
    "Lemma lregMl (a b: R) : lreg (a * b) -> lreg b.\nProof. by move=> rab c c' eq_bc; apply/rab; rewrite -!mulrA eq_bc. Qed.",
    "Lemma rregMr (a b: R) : rreg (a * b) -> rreg a.\nProof. by move=> rab c c' eq_ca; apply/rab; rewrite !mulrA eq_ca. Qed.",
    "Lemma lregX x n : lreg x -> lreg (x ^+ n).\nProof.\nby move=> reg_x; elim: n => [|n]; [apply: lreg1 | rewrite exprS; apply: lregM].\nQed.",
    "Lemma iter_mulr n x y : iter n ( *%R x) y = x ^+ n * y.\nProof. by elim: n => [|n ih]; rewrite ?expr0 ?mul1r //= ih exprS -mulrA. Qed.",
    "Lemma iter_mulr_1 n x : iter n ( *%R x) 1 = x ^+ n.\nProof. by rewrite iter_mulr mulr1. Qed.",
    "Lemma prodr_const (I : finType) (A : pred I) x : \\prod_(i in A) x = x ^+ #|A|.\nProof. by rewrite big_const -iteropE. Qed.",
    "Lemma prodr_const_nat n m x : \\prod_(n <= i < m) x = x ^+ (m - n).\nProof. by rewrite big_const_nat -iteropE. Qed.",
    "Lemma prodrXr x I r P (F : I -> nat) :\n  \\prod_(i <- r | P i) x ^+ F i = x ^+ (\\sum_(i <- r | P i) F i).\nProof. by rewrite (big_morph _ (exprD _) (erefl _)). Qed.",
    "Lemma prodrM_comm {I : eqType} r (P : pred I) (F G : I -> R) :\n    (forall i j, P i -> P j -> comm (F i) (G j)) ->\n  \\prod_(i <- r | P i) (F i * G i) =\n    \\prod_(i <- r | P i) F i * \\prod_(i <- r | P i) G i.\nProof.\nmove=> FG; elim: r => [|i r IHr]; rewrite !(big_nil, big_cons) ?mulr1//.\ncase: ifPn => // Pi; rewrite IHr !mulrA; congr (_ * _); rewrite -!mulrA.\nby rewrite commr_prod // => j Pj; apply/commr_sym/FG.\nQed.",
    "Lemma prodrMl_comm {I : finType} (A : pred I) (x : R) F :\n    (forall i, A i -> comm x (F i)) ->\n  \\prod_(i in A) (x * F i) = x ^+ #|A| * \\prod_(i in A) F i.\nProof. by move=> xF; rewrite prodrM_comm ?prodr_const// => i j _ /xF. Qed.",
    "Lemma prodrMr_comm {I : finType} (A : pred I) (x : R) F :\n    (forall i, A i -> comm x (F i)) ->\n  \\prod_(i in A) (F i * x) = \\prod_(i in A) F i * x ^+ #|A|.\nProof. by move=> xF; rewrite prodrM_comm ?prodr_const// => i j /xF. Qed.",
    "Lemma prodrMn (I : Type) (s : seq I) (P : pred I) (F : I -> R) (g : I -> nat) :\n  \\prod_(i <- s | P i) (F i *+ g i) =\n  \\prod_(i <- s | P i) (F i) *+ \\prod_(i <- s | P i) g i.\nProof.\nby elim/big_rec3: _ => // i y1 y2 y3 _ ->; rewrite mulrnAr mulrnAl -mulrnA.\nQed.",
    "Lemma prodrMn_const n (I : finType) (A : pred I) (F : I -> R) :\n  \\prod_(i in A) (F i *+ n) = \\prod_(i in A) F i *+ n ^ #|A|.\nProof. by rewrite prodrMn prod_nat_const. Qed.",
    "Lemma natr_prod I r P (F : I -> nat) :\n  (\\prod_(i <- r | P i) F i)%:R = \\prod_(i <- r | P i) (F i)%:R :> R.\nProof. exact: (big_morph _ natrM). Qed.",
    "Lemma exprDn_comm x y n (cxy : comm x y) :\n  (x + y) ^+ n = \\sum_(i < n.+1) (x ^+ (n - i) * y ^+ i) *+ 'C(n, i).\nProof.\nelim: n => [|n IHn]; rewrite big_ord_recl mulr1 ?big_ord0 ?addr0 //=.\nrewrite exprS {}IHn /= mulrDl !big_distrr /= big_ord_recl mulr1 subn0.\nrewrite !big_ord_recr /= !binn !subnn !mul1r !subn0 bin0 !exprS -addrA.\ncongr (_ + _); rewrite addrA -big_split /=; congr (_ + _).\napply: eq_bigr => i _; rewrite !mulrnAr !mulrA -exprS -subSn ?(valP i) //.\nby rewrite subSS (commrX _ (commr_sym cxy)) -mulrA -exprS -mulrnDr.\nQed.",
    "Lemma exprD1n x n : (x + 1) ^+ n = \\sum_(i < n.+1) x ^+ i *+ 'C(n, i).\nProof.\nrewrite addrC (exprDn_comm n (commr_sym (commr1 x))).\nby apply: eq_bigr => i _; rewrite expr1n mul1r.\nQed.",
    "Lemma sqrrD1 x : (x + 1) ^+ 2 = x ^+ 2 + x *+ 2 + 1.\nProof.\nrewrite exprD1n !big_ord_recr big_ord0 /= add0r.\nby rewrite addrC addrA addrAC.\nQed.",
    "Lemma semiring_closedD : semiring_closed -> addr_closed S. Proof. by case. Qed.",
    "Lemma semiring_closedM : semiring_closed -> mulr_closed. Proof. by case. Qed.",
    "Lemma oner_eq0 : (1 == 0 :> R) = false. Proof. exact: negbTE oner_neq0. Qed.",
    "Lemma lastr_eq0 (s : seq R) x : x != 0 -> (last x s == 0) = (last 1 s == 0).\nProof. by case: s => [|y s] /negPf // ->; rewrite oner_eq0. Qed.",
    "Lemma lreg_neq0 x : lreg x -> x != 0.\nProof. by move=> reg_x; rewrite -[x]mulr1 mulrI_eq0 ?oner_eq0. Qed.",
    "Lemma pcharf0 : p%:R = 0 :> R. Proof. by apply/eqP; case/andP: pcharFp. Qed.",
    "Lemma pcharf_prime : prime p. Proof. by case/andP: pcharFp. Qed.",
    "Lemma mulrn_pchar x : x *+ p = 0. Proof. by rewrite -mulr_natl pcharf0 mul0r. Qed.",
    "Lemma natr_mod_pchar n : (n %% p)%:R = n%:R :> R.\nProof. by rewrite {2}(divn_eq n p) natrD mulrnA mulrn_pchar add0r. Qed.",
    "Lemma dvdn_pcharf n : (p %| n)%N = (n%:R == 0 :> R).\nProof.\napply/idP/eqP=> [/dvdnP[n' ->]|n0]; first by rewrite natrM pcharf0 mulr0.\napply/idPn; rewrite -prime_coprime // => /eqnP pn1.\nhave [a _ /dvdnP[b]] := Bezoutl n (prime_gt0 pcharf_prime).\nmove/(congr1 (fun m => m%:R : R))/eqP.\nby rewrite natrD !natrM pcharf0 n0 !mulr0 pn1 addr0 oner_eq0.\nQed.",
    "Lemma pcharf_eq : pchar R =i (p : nat_pred).\nProof.\nmove=> q; apply/andP/eqP=> [[q_pr q0] | ->]; last by rewrite pcharf0.\nby apply/eqP; rewrite eq_sym -dvdn_prime2 // dvdn_pcharf.\nQed.",
    "Lemma bin_lt_pcharf_0 k : 0 < k < p -> 'C(p, k)%:R = 0 :> R.\nProof. by move=> lt0kp; apply/eqP; rewrite -dvdn_pcharf prime_dvd_bin. Qed.",
    "Lemma pFrobenius_autE x : x^f = x ^+ p. Proof. by []. Qed.",
    "Lemma pFrobenius_aut0 : 0^f = 0.\nProof. by rewrite f'E -(prednK (prime_gt0 pcharf_prime)) exprS mul0r. Qed.",
    "Lemma pFrobenius_aut1 : 1^f = 1.\nProof. by rewrite f'E expr1n. Qed.",
    "Lemma pFrobenius_autD_comm x y (cxy : comm x y) : (x + y)^f = x^f + y^f.\nProof.\nhave defp := prednK (prime_gt0 pcharf_prime).\nrewrite !f'E exprDn_comm // big_ord_recr subnn -defp big_ord_recl /= defp.\nrewrite subn0 mulr1 mul1r bin0 binn big1 ?addr0 // => i _.\nby rewrite -mulr_natl bin_lt_pcharf_0 ?mul0r //= -{2}defp ltnS (valP i).\nQed.",
    "Lemma pFrobenius_autMn x n : (x *+ n)^f = x^f *+ n.\nProof.\nelim: n => [|n IHn]; first exact: pFrobenius_aut0.\nby rewrite !mulrS pFrobenius_autD_comm ?IHn //; apply: commrMn.\nQed.",
    "Lemma pFrobenius_aut_nat n : (n%:R)^f = n%:R.\nProof. by rewrite pFrobenius_autMn pFrobenius_aut1. Qed.",
    "Lemma pFrobenius_autM_comm x y : comm x y -> (x * y)^f = x^f * y^f.\nProof. exact: exprMn_comm. Qed.",
    "Lemma pFrobenius_autX x n : (x ^+ n)^f = x^f ^+ n.\nProof. by rewrite !f'E -!exprM mulnC. Qed.",
    "Lemma addrr_pchar2 x : x + x = 0. Proof. by rewrite -mulr2n mulrn_pchar. Qed.",
    "Lemma mul0r : @left_zero R R 0 mul.\n  Proof. by move=> x; apply: (addIr (1 * x)); rewrite -mulrDl !add0r mul1r. Qed.",
    "Lemma mulr0 : @right_zero R R 0 mul.\n  Proof. by move=> x; apply: (addIr (x * 1)); rewrite -mulrDr !add0r mulr1. Qed.",
    "Lemma mulrN x y : x * (- y) = - (x * y).\nProof. by apply: (addrI (x * y)); rewrite -mulrDr !subrr mulr0. Qed.",
    "Lemma mulNr x y : (- x) * y = - (x * y).\nProof. by apply: (addrI (x * y)); rewrite -mulrDl !subrr mul0r. Qed.",
    "Lemma mulrNN x y : (- x) * (- y) = x * y.\nProof. by rewrite mulrN mulNr opprK. Qed.",
    "Lemma mulN1r x : -1 * x = - x.\nProof. by rewrite mulNr mul1r. Qed.",
    "Lemma mulrN1 x : x * -1 = - x.\nProof. by rewrite mulrN mulr1. Qed.",
    "Lemma mulrBl x y z : (y - z) * x = y * x - z * x.\nProof. by rewrite mulrDl mulNr. Qed.",
    "Lemma mulrBr x y z : x * (y - z) = x * y - x * z.\nProof. by rewrite mulrDr mulrN. Qed.",
    "Lemma natrB m n : n <= m -> (m - n)%:R = m%:R - n%:R :> R.\nProof. exact: mulrnBr. Qed.",
    "Lemma commrN x y : comm x y -> comm x (- y).\nProof. by move=> com_xy; rewrite /comm mulrN com_xy mulNr. Qed.",
    "Lemma commrN1 x : comm x (-1).\nProof. exact/commrN/commr1. Qed.",
    "Lemma commrB x y z : comm x y -> comm x z -> comm x (y - z).\nProof. by move=> com_xy com_xz; apply: commrD => //; apply: commrN. Qed.",
    "Lemma commr_sign x n : comm x ((-1) ^+ n).\nProof. exact: (commrX n (commrN1 x)). Qed.",
    "Lemma signr_odd n : (-1) ^+ (odd n) = (-1) ^+ n :> R.\nProof.\nelim: n => //= n IHn; rewrite exprS -{}IHn.\nby case/odd: n; rewrite !mulN1r ?opprK.\nQed.",
    "Lemma mulr_sign (b : bool) x : (-1) ^+ b * x = (if b then - x else x).\nProof. by case: b; rewrite ?mulNr mul1r. Qed.",
    "Lemma signr_addb b1 b2 : (-1) ^+ (b1 (+) b2) = (-1) ^+ b1 * (-1) ^+ b2 :> R.\nProof. by rewrite mulr_sign; case: b1 b2 => [] []; rewrite ?opprK. Qed.",
    "Lemma signrE (b : bool) : (-1) ^+ b = 1 - b.*2%:R :> R.\nProof. by case: b; rewrite ?subr0 // opprD addNKr. Qed.",
    "Lemma signrN b : (-1) ^+ (~~ b) = - (-1) ^+ b :> R.\nProof. by case: b; rewrite ?opprK. Qed.",
    "Lemma mulr_signM (b1 b2 : bool) x1 x2 :\n  ((-1) ^+ b1 * x1) * ((-1) ^+ b2 * x2) = (-1) ^+ (b1 (+) b2) * (x1 * x2).\nProof.\nby rewrite signr_addb -!mulrA; congr (_ * _); rewrite !mulrA commr_sign.\nQed.",
    "Lemma exprNn x n : (- x) ^+ n = (-1) ^+ n * x ^+ n :> R.\nProof. by rewrite -mulN1r exprMn_comm // /comm mulN1r mulrN mulr1. Qed.",
    "Lemma sqrrN x : (- x) ^+ 2 = x ^+ 2.\nProof. exact: mulrNN. Qed.",
    "Lemma sqrr_sign n : ((-1) ^+ n) ^+ 2 = 1 :> R.\nProof. by rewrite exprAC sqrrN !expr1n. Qed.",
    "Lemma signrMK n : @involutive R ( *%R ((-1) ^+ n)).\nProof. by move=> x; rewrite mulrA -expr2 sqrr_sign mul1r. Qed.",
    "Lemma mulrI0_lreg x : (forall y, x * y = 0 -> y = 0) -> lreg x.\nProof.\nmove=> reg_x y z eq_xy_xz; apply/eqP; rewrite -subr_eq0 [y - z]reg_x //.\nby rewrite mulrBr eq_xy_xz subrr.\nQed.",
    "Lemma lregN x : lreg x -> lreg (- x).\nProof. by move=> reg_x y z; rewrite !mulNr => /oppr_inj/reg_x. Qed.",
    "Lemma lreg_sign n : lreg ((-1) ^+ n : R). Proof. exact/lregX/lregN/lreg1. Qed.",
    "Lemma prodrN (I : finType) (A : pred I) (F : I -> R) :\n  \\prod_(i in A) - F i = (- 1) ^+ #|A| * \\prod_(i in A) F i.\nProof.\nrewrite -sum1_card; elim/big_rec3: _ => [|i x n _ _ ->]; first by rewrite mulr1.\nby rewrite exprS !mulrA mulN1r !mulNr commrX //; apply: commrN1.\nQed.",
    "Lemma exprBn_comm x y n (cxy : comm x y) :\n  (x - y) ^+ n =\n    \\sum_(i < n.+1) ((-1) ^+ i * x ^+ (n - i) * y ^+ i) *+ 'C(n, i).\nProof.\nrewrite exprDn_comm; last exact: commrN.\nby apply: eq_bigr => i _; congr (_ *+ _); rewrite -commr_sign -mulrA -exprNn.\nQed.",
    "Lemma subrXX_comm x y n (cxy : comm x y) :\n  x ^+ n - y ^+ n = (x - y) * (\\sum_(i < n) x ^+ (n.-1 - i) * y ^+ i).\nProof.\ncase: n => [|n]; first by rewrite big_ord0 mulr0 subrr.\nrewrite mulrBl !big_distrr big_ord_recl big_ord_recr /= subnn mulr1 mul1r.\nrewrite subn0 -!exprS opprD -!addrA; congr (_ + _); rewrite addrA -sumrB.\nrewrite big1 ?add0r // => i _; rewrite !mulrA -exprS -subSn ?(valP i) //.\nby rewrite subSS (commrX _ (commr_sym cxy)) -mulrA -exprS subrr.\nQed.",
    "Lemma subrX1 x n : x ^+ n - 1 = (x - 1) * (\\sum_(i < n) x ^+ i).\nProof.\nrewrite -!(opprB 1) mulNr -{1}(expr1n _ n).\nrewrite (subrXX_comm _ (commr_sym (commr1 x))); congr (- (_ * _)).\nby apply: eq_bigr => i _; rewrite expr1n mul1r.\nQed.",
    "Lemma sqrrB1 x : (x - 1) ^+ 2 = x ^+ 2 - x *+ 2 + 1.\nProof. by rewrite -sqrrN opprB addrC sqrrD1 sqrrN mulNrn. Qed.",
    "Lemma subr_sqr_1 x : x ^+ 2 - 1 = (x - 1) * (x + 1).\nProof. by rewrite subrX1 !big_ord_recr big_ord0 /= addrAC add0r. Qed.",
    "Lemma smulr_closedM : smulr_closed -> mulr_closed S.\nProof. by case=> SN1 SM; split=> //; rewrite -[1]mulr1 -mulrNN SM. Qed.",
    "Lemma smulr_closedN : smulr_closed -> oppr_closed S.\nProof. by case=> SN1 SM x Sx; rewrite -mulN1r SM. Qed.",
    "Lemma subring_closedB : subring_closed -> zmod_closed S.\nProof. by case=> S1 SB _; split; rewrite // -(subrr 1) SB. Qed.",
    "Lemma subring_closedM : subring_closed -> smulr_closed.\nProof.\nby case=> S1 SB SM; split; rewrite ?(zmod_closedN (subring_closedB _)).\nQed.",
    "Lemma subring_closed_semi : subring_closed -> semiring_closed S.\nProof.\nby move=> ringS; split; [apply/zmod_closedD/subring_closedB | case: ringS].\nQed.",
    "Lemma signr_eq0 n : ((-1) ^+ n == 0 :> R) = false.\nProof. by rewrite -signr_odd; case: odd; rewrite ?oppr_eq0 oner_eq0. Qed.",
    "Lemma pFrobenius_autN x : (- x)^f = - x^f.\nProof.\napply/eqP; rewrite -subr_eq0 opprK addrC.\nby rewrite -(pFrobenius_autD_comm _ (commrN _)) // subrr pFrobenius_aut0.\nQed.",
    "Lemma pFrobenius_autB_comm x y : comm x y -> (x - y)^f = x^f - y^f.\nProof.\nby move/commrN/pFrobenius_autD_comm->; rewrite pFrobenius_autN.\nQed.",
    "Lemma exprNn_pchar x n : (pchar R).-nat n -> (- x) ^+ n = - (x ^+ n).\nProof.\npose p := pdiv n; have [|n_gt1 pcharRn] := leqP n 1; first by case: (n) => [|[]].\nhave pcharRp: p \\in pchar R by rewrite (pnatPpi pcharRn) // pi_pdiv.\nhave /p_natP[e ->]: p.-nat n by rewrite -(eq_pnat _ (pcharf_eq pcharRp)).\nelim: e => // e IHe; rewrite expnSr !exprM {}IHe.\nby rewrite -pFrobenius_autE pFrobenius_autN.\nQed.",
    "Lemma oppr_pchar2 x : - x = x.\nProof. by apply/esym/eqP; rewrite -addr_eq0 addrr_pchar2. Qed.",
    "Lemma subr_pchar2 x y : x - y = x + y. Proof. by rewrite oppr_pchar2. Qed.",
    "Lemma addrK_pchar2 x : involutive (+%R^~ x).\nProof. by move=> y; rewrite /= -subr_pchar2 addrK. Qed.",
    "Lemma addKr_pchar2 x : involutive (+%R x).\nProof. by move=> y; rewrite -{1}[x]oppr_pchar2 addKr. Qed.",
    "Lemma rev_prodr (R : pzSemiRingType)\n  (I : Type) (r : seq I) (P : pred I) (E : I -> R) :\n  \\prod_(i <- r | P i) (E i : R^c) = \\prod_(i <- rev r | P i) E i.\nProof. by rewrite rev_big_rev. Qed.",
    "Lemma mulIr_eq0 x y : rreg x -> (y * x == 0) = (y == 0).\nProof. exact: (@mulrI_eq0 R^c). Qed.",
    "Lemma rreg1 : rreg (1 : R).\nProof. exact: (@lreg1 R^c). Qed.",
    "Lemma rregM x y : rreg x -> rreg y -> rreg (x * y).\nProof. by move=> reg_x reg_y; apply: (@lregM R^c). Qed.",
    "Lemma revrX x n : (x : R^c) ^+ n = (x : R) ^+ n.\nProof. by elim: n => // n IHn; rewrite exprS exprSr IHn. Qed.",
    "Lemma rregX x n : rreg x -> rreg (x ^+ n).\nProof. by move/(@lregX R^c x n); rewrite revrX. Qed.",
    "Lemma rreg_neq0 (R : nzSemiRingType) (x : R) : rreg x -> x != 0.\nProof. exact: (@lreg_neq0 R^c). Qed.",
    "Lemma mulIr0_rreg x : (forall y, y * x = 0 -> y = 0) -> rreg x.\nProof. exact: (@mulrI0_lreg R^c). Qed.",
    "Lemma rregN x : rreg x -> rreg (- x).\nProof. exact: (@lregN R^c). Qed.",
    "Lemma scale0r v : scale 0 v = 0.\nProof. by apply: (addIr (scale 1 v)); rewrite -scalerDl !add0r. Qed.",
    "Lemma addNr : left_inverse 0 opp +%R.\nProof.\nmove=> v; suff : scale (-1 + 1) v = 0 by rewrite scalerDl scale1r.\nby rewrite addNr scale0r.\nQed.",
    "Lemma scaler0 a : a *: 0 = 0 :> V.\nProof. by rewrite -[0 in LHS](scale0r 0) scalerA mulr0 scale0r. Qed.",
    "Lemma scaler_nat n v : n%:R *: v = v *+ n.\nProof.\nelim: n => /= [|n]; first by rewrite scale0r.\nby rewrite !mulrS scalerDl ?scale1r => ->.\nQed.",
    "Lemma scalerMnl a v n : a *: v *+ n = (a *+ n) *: v.\nProof.\nelim: n => [|n IHn]; first by rewrite !mulr0n scale0r.\nby rewrite !mulrSr IHn scalerDl.\nQed.",
    "Lemma scalerMnr a v n : a *: v *+ n = a *: (v *+ n).\nProof.\nelim: n => [|n IHn]; first by rewrite !mulr0n scaler0.\nby rewrite !mulrSr IHn scalerDr.\nQed.",
    "Lemma scaler_suml v I r (P : pred I) F :\n  (\\sum_(i <- r | P i) F i) *: v = \\sum_(i <- r | P i) F i *: v.\nProof. exact: (big_morph _ (scalerDl v) (scale0r v)). Qed.",
    "Lemma scaler_sumr a I r (P : pred I) (F : I -> V) :\n  a *: (\\sum_(i <- r | P i) F i) = \\sum_(i <- r | P i) a *: F i.\nProof. exact: big_endo (scalerDr a) (scaler0 a) I r P F. Qed.",
    "Lemma subsemimod_closedD : subsemimod_closed -> addr_closed S.\nProof. by case. Qed.",
    "Lemma subsemimod_closedZ : subsemimod_closed -> scaler_closed.\nProof. by case. Qed.",
    "Lemma scaleNr a v : - a *: v = - (a *: v).\nProof. by apply: (addIr (a *: v)); rewrite -scalerDl !addNr scale0r. Qed.",
    "Lemma scaleN1r v : - 1 *: v = - v.\nProof. by rewrite scaleNr scale1r. Qed.",
    "Lemma scalerN a v : a *: - v = - (a *: v).\nProof. by apply: (addIr (a *: v)); rewrite -scalerDr !addNr scaler0. Qed.",
    "Lemma scalerBl a b v : (a - b) *: v = a *: v - b *: v.\nProof. by rewrite scalerDl scaleNr. Qed.",
    "Lemma scalerBr a u v : a *: (u - v) = a *: u - a *: v.\nProof. by rewrite scalerDr scalerN. Qed.",
    "Lemma scaler_sign (b : bool) v : (-1) ^+ b *: v = (if b then - v else v).\nProof. by case: b; rewrite ?scaleNr scale1r. Qed.",
    "Lemma signrZK n : @involutive V ( *:%R ((-1) ^+ n)).\nProof. by move=> u; rewrite scalerA -expr2 sqrr_sign scale1r. Qed.",
    "Lemma linear_closedB : linear_closed -> subr_2closed S.\nProof. by move=> Slin u v Su Sv; rewrite addrC -scaleN1r Slin. Qed.",
    "Lemma submod_closedB : submod_closed -> zmod_closed S.\nProof. by case=> S0 /linear_closedB. Qed.",
    "Lemma submod_closed_semi : submod_closed -> subsemimod_closed S.\nProof.\nmove=> /[dup] /submod_closedB /zmod_closedD SD [S0 Slin]; split => // a v Sv.\nby rewrite -[a *: v]addr0 Slin.\nQed.",
    "Lemma mulr_algl (a : R) (x : A) : (a *: 1) * x = a *: x.\nProof. by rewrite -scalerAl mul1r. Qed.",
    "Lemma subalg_closedZ : subalg_closed -> submod_closed S.\nProof. by case=> S1 Slin _; split; rewrite // -(subrr 1) linear_closedB. Qed.",
    "Lemma subalg_closedBM : subalg_closed -> subring_closed S.\nProof. by case=> S1 Slin SM; split=> //; apply: linear_closedB. Qed.",
    "Lemma raddf0 : apply 0 = 0.\nProof. by rewrite -[0]subr0 additive_subproof subrr. Qed.",
    "Lemma raddfD : {morph apply : x y / x + y}.\nProof.\nmove=> x y; rewrite -[y in LHS]opprK -[- y]add0r.\nby rewrite !additive_subproof raddf0 sub0r opprK.\nQed.",
    "Lemma raddf0 : f 0 = 0.\nProof. exact: semi_additive_subproof.1. Qed.",
    "Lemma raddf_eq0 x : injective f -> (f x == 0) = (x == 0).\nProof. by move=> /inj_eq <-; rewrite raddf0. Qed.",
    "Lemma raddfD : {morph f : x y / x + y}.\nProof. exact: semi_additive_subproof.2. Qed.",
    "Lemma raddfMn n : {morph f : x / x *+ n}.\nProof. by elim: n => [|n IHn] x /=; rewrite ?raddf0 // !mulrS raddfD IHn. Qed.",
    "Lemma raddf_sum I r (P : pred I) E :\n  f (\\sum_(i <- r | P i) E i) = \\sum_(i <- r | P i) f (E i).\nProof. exact: (big_morph f raddfD raddf0). Qed.",
    "Lemma can2_semi_additive f' : cancel f f' -> cancel f' f -> semi_additive f'.\nProof.\nmove=> fK f'K.\nby split=> [|x y]; apply: (canLR fK); rewrite ?raddf0// raddfD !f'K.\nQed.",
    "Lemma raddfMnat n x : f (n%:R * x) = n%:R * f x.\nProof. by rewrite !mulr_natl raddfMn. Qed.",
    "Lemma raddfZnat n u : h (n%:R *: u) = n%:R *: h u.\nProof. by rewrite !scaler_nat raddfMn. Qed.",
    "Lemma raddfN : {morph f : x / - x}.\nProof.\nmove=> x.\nby rewrite -[LHS]addr0 -(subrr (f x)) addrA -raddfD addNr raddf0 sub0r.\nQed.",
    "Lemma raddfB : {morph f : x y / x - y}.\nProof. by move=> x y; rewrite raddfD -raddfN. Qed.",
    "Lemma raddf_inj : (forall x, f x = 0 -> x = 0) -> injective f.\nProof. by move=> fI x y eqxy; apply/subr0_eq/fI; rewrite raddfB eqxy subrr. Qed.",
    "Lemma raddfMNn n : {morph f : x / x *- n}.\nProof. by move=> x /=; rewrite raddfN raddfMn. Qed.",
    "Lemma can2_additive f' : cancel f f' -> cancel f' f -> additive f'.\nProof. by move=> fK f'K x y /=; apply: (canLR fK); rewrite raddfB !f'K. Qed.",
    "Lemma raddfMsign n x : f ((-1) ^+ n * x) = (-1) ^+ n * f x.\nProof. by rewrite !(mulr_sign, =^~ signr_odd) (fun_if f) raddfN. Qed.",
    "Lemma raddfZsign n u : h ((-1) ^+ n *: u) = (-1) ^+ n *: h u.\nProof. by rewrite !(scaler_sign, =^~ signr_odd) (fun_if h) raddfN. Qed.",
    "Lemma rmorph0 : f 0 = 0. Proof. exact: raddf0. Qed.",
    "Lemma rmorphD : {morph f : x y / x + y}. Proof. exact: raddfD. Qed.",
    "Lemma rmorphMn n : {morph f : x / x *+ n}. Proof. exact: raddfMn. Qed.",
    "Lemma rmorph_sum I r (P : pred I) E :\n  f (\\sum_(i <- r | P i) E i) = \\sum_(i <- r | P i) f (E i).\nProof. exact: raddf_sum. Qed.",
    "Lemma rmorphismMP : multiplicative f. Proof. exact: rmorphism_subproof. Qed.",
    "Lemma rmorph1 : f 1 = 1. Proof. by case: rmorphismMP. Qed.",
    "Lemma rmorphM : {morph f: x y  / x * y}. Proof. by case: rmorphismMP. Qed.",
    "Lemma rmorph_prod I r (P : pred I) E :\n  f (\\prod_(i <- r | P i) E i) = \\prod_(i <- r | P i) f (E i).\nProof. exact: (big_morph f rmorphM rmorph1). Qed.",
    "Lemma rmorphXn n : {morph f : x / x ^+ n}.\nProof. by elim: n => [|n IHn] x; rewrite ?rmorph1 // !exprS rmorphM IHn. Qed.",
    "Lemma rmorph_nat n : f n%:R = n%:R. Proof. by rewrite rmorphMn rmorph1. Qed.",
    "Lemma rmorph_eq_nat x n : injective f -> (f x == n%:R) = (x == n%:R).\nProof. by move/inj_eq <-; rewrite rmorph_nat. Qed.",
    "Lemma rmorph_eq1 x : injective f -> (f x == 1) = (x == 1).\nProof. exact: rmorph_eq_nat 1%N. Qed.",
    "Lemma can2_rmorphism f' : cancel f f' -> cancel f' f -> multiplicative f'.\nProof.\nmove=> fK f'K.\nby split=> [x y|]; apply: (canLR fK); rewrite /= (rmorphM, rmorph1) ?f'K.\nQed.",
    "Lemma rmorph_pchar (R S : nzSemiRingType) (f : {rmorphism R -> S}) p :\n  p \\in pchar R -> p \\in pchar S.\nProof.\nby rewrite !inE -(rmorph_nat f) => /andP[-> /= /eqP->]; rewrite rmorph0.\nQed.",
    "Lemma rmorphN : {morph f : x / - x}. Proof. exact: raddfN. Qed.",
    "Lemma rmorphB : {morph f: x y / x - y}. Proof. exact: raddfB. Qed.",
    "Lemma rmorphMNn n : {morph f : x / x *- n}. Proof. exact: raddfMNn. Qed.",
    "Lemma rmorphMsign n : {morph f : x / (- 1) ^+ n * x}.\nProof. exact: raddfMsign. Qed.",
    "Lemma rmorphN1 : f (- 1) = (- 1). Proof. by rewrite rmorphN rmorph1. Qed.",
    "Lemma rmorph_sign n : f ((- 1) ^+ n) = (- 1) ^+ n.\nProof. by rewrite rmorphXn /= rmorphN1. Qed.",
    "Lemma in_algE a : in_alg A a = a%:A. Proof. by []. Qed.",
    "Lemma additive_semilinear (R : pzSemiRingType)\n    (U : lSemiModType R) (V : nmodType) (s : Scale.semiLaw R V) (f : U -> V) :\n  semilinear_for s f -> semi_additive f.\nProof.\nby case=> sf Df; split => //; rewrite -[0 in LHS](scale0r 0) sf Scale.op0v.\nQed.",
    "Lemma scalable_semilinear (R : pzSemiRingType)\n    (U : lSemiModType R) (V : nmodType) (s : Scale.preLaw R V) (f : U -> V) :\n  semilinear_for s f -> scalable_for s f.\nProof. by case. Qed.",
    "Lemma additive_linear (R : pzRingType) (U : lmodType R) V\n  (s : Scale.law R V) (f : U -> V) : linear_for s f -> additive f.\nProof. by move=> Lsf x y; rewrite -scaleN1r addrC Lsf Scale.N1op addrC. Qed.",
    "Lemma scalable_linear (R : pzRingType) (U : lmodType R) V\n  (s : Scale.law R V) (f : U -> V) : linear_for s f -> scalable_for s f.\nProof.\nby move=> Lsf a v; rewrite -[a *:v](addrK v) (additive_linear Lsf) Lsf addrK.\nQed.",
    "Lemma semilinear_linear (R : pzRingType) (U : lmodType R) V\n  (s : Scale.law R V) (f : U -> V) : linear_for s f -> semilinear_for s f.\nProof.\nmove=> Lsf; split=> [a x|x y]; first exact: (scalable_linear Lsf).\nhave f0: f 0 = 0 by rewrite -[0 in LHS]subr0 (additive_linear Lsf) subrr.\nby rewrite -[y in LHS]opprK -[- y]add0r !(additive_linear Lsf) f0 sub0r opprK.\nQed.",
    "Lemma linear0 : f 0 = 0. Proof. exact: raddf0. Qed.",
    "Lemma linearD : {morph f : x y / x + y}. Proof. exact: raddfD. Qed.",
    "Lemma linearMn n : {morph f : x / x *+ n}. Proof. exact: raddfMn. Qed.",
    "Lemma linear_sum I r (P : pred I) E :\n  f (\\sum_(i <- r | P i) E i) = \\sum_(i <- r | P i) f (E i).\nProof. exact: raddf_sum. Qed.",
    "Lemma linearZ_LR : scalable_for s f. Proof. exact: semi_linear_subproof. Qed.",
    "Lemma semilinearP : semilinear_for s f.\nProof. split; [exact: linearZ_LR | exact: linearD]. Qed.",
    "Lemma linearP : linear_for s f.\nProof. by move=> a u v /=; rewrite !semilinearP. Qed.",
    "Lemma linearN : {morph f : x / - x}. Proof. exact: raddfN. Qed.",
    "Lemma linearB : {morph f : x y / x - y}. Proof. exact: raddfB. Qed.",
    "Lemma linearMNn n : {morph f : x / x *- n}. Proof. exact: raddfMNn. Qed.",
    "Lemma linearZ (R : pzSemiRingType) (U : lSemiModType R) (V : nmodType)\n  (s : R -> V -> V) (S : pzSemiRingType) (h : Scale.preLaw S V)\n  (c : S) (a : R) (h_c := h c) (f : Linear.map_for U s a h_c) (u : U) :\n  f (a *: u) = h_c (Linear.wrap f u).\nProof. by rewrite linearZ_LR; case: f => f /= ->. Qed.",
    "Lemma linearZZ : scalable f. Proof. exact: linearZ_LR. Qed.",
    "Lemma semilinearPZ : semilinear f. Proof. exact: semilinearP. Qed.",
    "Lemma linearPZ : linear f. Proof. exact: linearP. Qed.",
    "Lemma can2_scalable f' : cancel f f' -> cancel f' f -> scalable f'.\nProof. by move=> fK f'K a x; apply: (canLR fK); rewrite linearZZ f'K. Qed.",
    "Lemma can2_semilinear f' : cancel f f' -> cancel f' f -> semilinear f'.\nProof.\nby move=> fK f'K; split=> ? ?; apply: (canLR fK); rewrite semilinearPZ !f'K.\nQed.",
    "Lemma can2_linear f' : cancel f f' -> cancel f' f -> linear f'.\nProof. by move=> fK f'K a x y /=; apply: (canLR fK); rewrite linearP !f'K. Qed.",
    "Lemma scalarZ : scalable_for *%R f. Proof. exact: linearZ_LR. Qed.",
    "Lemma semiscalarP : semiscalar f. Proof. exact: semilinearP. Qed.",
    "Lemma scalarP : scalar f. Proof. exact: linearP. Qed.",
    "Lemma idfun_is_scalable : scalable (@idfun U). Proof. by []. Qed.",
    "Lemma comp_is_scalable : scalable_for s (f \\o g).\nProof. by move=> a v /=; rewrite !linearZ_LR. Qed.",
    "Lemma null_fun_is_scalable : scalable_for s (\\0 : U -> V).\nProof. by move=> a v /=; rewrite raddf0. Qed.",
    "Lemma add_fun_is_scalable : scalable_for s (f \\+ g).\nProof. by move=> a u; rewrite /= !linearZ_LR raddfD. Qed.",
    "Lemma opp_is_scalable : scalable (-%R : U -> U).\nProof. by move=> a v /=; rewrite scalerN. Qed.",
    "Lemma sub_fun_is_scalable : scalable_for s (f \\- g).\nProof. by move=> a u; rewrite /= !linearZ_LR raddfB. Qed.",
    "Lemma opp_fun_is_scalable : scalable_for s (\\- f).\nProof. by move=> a u; rewrite /= linearZ_LR raddfN. Qed.",
    "Lemma rmorph_alg a : f a%:A = a%:A.\nProof. by rewrite linearZ /= rmorph1. Qed.",
    "Lemma mulr0 : right_zero zero mul.\n  Proof. by move=> x; rewrite mulrC mul0r. Qed.",
    "Lemma mulr0 : right_zero zero mul.\n  Proof. by move=> x; rewrite mulrC mul0r. Qed.",
    "Lemma mulrCA : @left_commutative R R *%R. Proof. exact: mulmCA. Qed.",
    "Lemma mulrAC : @right_commutative R R *%R. Proof. exact: mulmAC. Qed.",
    "Lemma mulrACA : @interchange R *%R *%R. Proof. exact: mulmACA. Qed.",
    "Lemma exprMn n : {morph (fun x => x ^+ n) : x y / x * y}.\nProof. by move=> x y; exact/exprMn_comm/mulrC. Qed.",
    "Lemma prodrXl n I r (P : pred I) (F : I -> R) :\n  \\prod_(i <- r | P i) F i ^+ n = (\\prod_(i <- r | P i) F i) ^+ n.\nProof. by rewrite (big_morph _ (exprMn n) (expr1n _ n)). Qed.",
    "Lemma prodr_undup_exp_count (I : eqType) r (P : pred I) (F : I -> R) :\n  \\prod_(i <- undup r | P i) F i ^+ count_mem i r = \\prod_(i <- r | P i) F i.\nProof. exact: big_undup_iterop_count.  Qed.",
    "Lemma prodrMl {I : finType} (A : pred I) (x : R) F :\n  \\prod_(i in A) (x * F i) = x ^+ #|A| * \\prod_(i in A) F i.\nProof. by rewrite big_split ?prodr_const. Qed.",
    "Lemma prodrMr {I : finType} (A : pred I) (x : R) F :\n  \\prod_(i in A) (F i * x) = \\prod_(i in A) F i * x ^+ #|A|.\nProof. by rewrite big_split ?prodr_const. Qed.",
    "Lemma exprDn x y n :\n  (x + y) ^+ n = \\sum_(i < n.+1) (x ^+ (n - i) * y ^+ i) *+ 'C(n, i).\nProof. by rewrite exprDn_comm //; apply: mulrC. Qed.",
    "Lemma sqrrD x y : (x + y) ^+ 2 = x ^+ 2 + x * y *+ 2 + y ^+ 2.\nProof. by rewrite exprDn !big_ord_recr big_ord0 /= add0r mulr1 mul1r. Qed.",
    "Lemma pFrobenius_aut_is_semi_additive : semi_additive (pFrobenius_aut pcharRp).\nProof.\nby split=> [|x y]; [exact: pFrobenius_aut0 | exact/pFrobenius_autD_comm/mulrC].\nQed.",
    "Lemma pFrobenius_aut_is_multiplicative : multiplicative (pFrobenius_aut pcharRp).\nProof.\nby split=> [x y|]; [exact/pFrobenius_autM_comm/mulrC | exact: pFrobenius_aut1].\nQed.",
    "Lemma exprDn_pchar x y n : (pchar R).-nat n -> (x + y) ^+ n = x ^+ n + y ^+ n.\nProof.\npose p := pdiv n; have [|n_gt1 pcharRn] := leqP n 1; first by case: (n) => [|[]].\nhave pcharRp: p \\in pchar R by rewrite (pnatPpi pcharRn) ?pi_pdiv.\nhave{pcharRn} /p_natP[e ->]: p.-nat n by rewrite -(eq_pnat _ (pcharf_eq pcharRp)).\nby elim: e => // e IHe; rewrite !expnSr !exprM IHe -pFrobenius_autE rmorphD.\nQed.",
    "Lemma rmorph_comm (S : nzSemiRingType) (f : {rmorphism R -> S}) x y :\n  comm (f x) (f y).\nProof. by red; rewrite -!rmorphM mulrC. Qed.",
    "Lemma scale_is_scalable : scalable ( *:%R b : V -> V).\nProof. by move=> a v /=; rewrite !scalerA mulrC. Qed.",
    "Lemma scale_fun_is_scalable : scalable (b \\*: f).\nProof. by move=> a v /=; rewrite !linearZ. Qed.",
    "Lemma exprBn x y n :\n  (x - y) ^+ n =\n     \\sum_(i < n.+1) ((-1) ^+ i * x ^+ (n - i) * y ^+ i) *+ 'C(n, i).\nProof. by rewrite exprBn_comm //; apply: mulrC. Qed.",
    "Lemma subrXX x y n :\n  x ^+ n - y ^+ n = (x - y) * (\\sum_(i < n) x ^+ (n.-1 - i) * y ^+ i).\nProof. by rewrite -subrXX_comm //; apply: mulrC. Qed.",
    "Lemma sqrrB x y : (x - y) ^+ 2 = x ^+ 2 - x * y *+ 2 + y ^+ 2.\nProof. by rewrite sqrrD mulrN mulNrn sqrrN. Qed.",
    "Lemma subr_sqr x y : x ^+ 2 - y ^+ 2 = (x - y) * (x + y).\nProof. by rewrite subrXX !big_ord_recr big_ord0 /= add0r mulr1 mul1r. Qed.",
    "Lemma subr_sqrDB x y : (x + y) ^+ 2 - (x - y) ^+ 2 = x * y *+ 4.\nProof.\nrewrite sqrrD sqrrB -!(addrAC _ (y ^+ 2)) opprB.\nby rewrite addrC addrA subrK -mulrnDr.\nQed.",
    "Lemma scalarAr k (x y : V) : k *: (x * y) = x * (k *: y).\nProof. by rewrite mulrC scalerAl mulrC. Qed.",
    "Lemma scalarAr k (x y : V) : k *: (x * y) = x * (k *: y).\nProof. by rewrite mulrC scalerAl mulrC. Qed.",
    "Lemma scalerCA k x y : k *: x * y = x * (k *: y).\nProof. by rewrite -scalerAl scalerAr. Qed.",
    "Lemma mulr_algr a x : x * a%:A = a *: x.\nProof. by rewrite -scalerAr mulr1. Qed.",
    "Lemma comm_alg a x : comm a%:A x.\nProof. by rewrite /comm mulr_algr mulr_algl. Qed.",
    "Lemma exprZn k x n : (k *: x) ^+ n = k ^+ n *: x ^+ n.\nProof.\nelim: n => [|n IHn]; first by rewrite !expr0 scale1r.\nby rewrite !exprS IHn -scalerA scalerAr scalerAl.\nQed.",
    "Lemma scaler_prod I r (P : pred I) (F : I -> R) (G : I -> A) :\n  \\prod_(i <- r | P i) (F i *: G i) =\n    \\prod_(i <- r | P i) F i *: \\prod_(i <- r | P i) G i.\nProof.\nelim/big_rec3: _ => [|i x a _ _ ->]; first by rewrite scale1r.\nby rewrite -scalerAl -scalerAr scalerA.\nQed.",
    "Lemma scaler_prodl (I : finType) (S : pred I) (F : I -> A) k :\n  \\prod_(i in S) (k *: F i)  = k ^+ #|S| *: \\prod_(i in S) F i.\nProof. by rewrite scaler_prod prodr_const. Qed.",
    "Lemma scaler_prodr (I : finType) (S : pred I) (F : I -> R) x :\n  \\prod_(i in S) (F i *: x)  = \\prod_(i in S) F i *: x ^+ #|S|.\nProof. by rewrite scaler_prod prodr_const. Qed.",
    "Lemma mull_fun_is_scalable : scalable (a \\*o f).\nProof. by move=> k x /=; rewrite linearZ scalerAr. Qed.",
    "Lemma divrr : {in unit, right_inverse 1 (@inv R) *%R}.\nProof. exact: divrr_subproof. Qed.",
    "Lemma mulVr : {in unit, left_inverse 1 (@inv R) *%R}.\nProof. exact: mulVr_subproof. Qed.",
    "Lemma invr_out x : x \\isn't a unit -> x^-1 = x.\nProof. exact: invr_out_subproof. Qed.",
    "Lemma unitrP x : reflect (exists y, y * x = 1 /\\ x * y = 1) (x \\is a unit).\nProof.\napply: (iffP idP) => [Ux | []]; last exact: unitrP_subproof.\nby exists x^-1; rewrite divrr ?mulVr.\nQed.",
    "Lemma mulKr : {in unit, left_loop (@inv R) *%R}.\nProof. by move=> x Ux y; rewrite mulrA mulVr ?mul1r. Qed.",
    "Lemma mulVKr : {in unit, rev_left_loop (@inv R) *%R}.\nProof. by move=> x Ux y; rewrite mulrA mulrV ?mul1r. Qed.",
    "Lemma mulrK : {in unit, right_loop (@inv R) *%R}.\nProof. by move=> x Ux y; rewrite -mulrA divrr ?mulr1. Qed.",
    "Lemma mulrVK : {in unit, rev_right_loop (@inv R) *%R}.\nProof. by move=> x Ux y; rewrite -mulrA mulVr ?mulr1. Qed.",
    "Lemma mulrI : {in @unit R, right_injective *%R}.\nProof. by move=> x Ux; apply: can_inj (mulKr Ux). Qed.",
    "Lemma mulIr : {in @unit R, left_injective *%R}.\nProof. by move=> x Ux; apply: can_inj (mulrK Ux). Qed.",
    "Lemma telescope_prodr n m (f : nat -> R) :\n    (forall k, n < k < m -> f k \\is a unit) -> n < m ->\n  \\prod_(n <= k < m) (f k / f k.+1) = f n / f m.\nProof.\nmove=> Uf ltnm; rewrite (telescope_big (fun i j => f i / f j)) ?ltnm//.\nby move=> k ltnkm /=; rewrite mulrA divrK// Uf.\nQed.",
    "Lemma telescope_prodr_eq n m (f u : nat -> R) : n < m ->\n    (forall k, n < k < m -> f k \\is a unit) ->\n    (forall k, (n <= k < m)%N -> u k = f k / f k.+1) ->\n  \\prod_(n <= k < m) u k = f n / f m.\nProof.\nby move=> ? ? uE; under eq_big_nat do rewrite uE //=; exact: telescope_prodr.\nQed.",
    "Lemma commrV x y : comm x y -> comm x y^-1.\nProof.\nhave [Uy cxy | /invr_out-> //] := boolP (y \\in unit).\nby apply: (canLR (mulrK Uy)); rewrite -mulrA cxy mulKr.\nQed.",
    "Lemma unitrE x : (x \\is a unit) = (x / x == 1).\nProof.\napply/idP/eqP=> [Ux | xx1]; first exact: divrr.\nby apply/unitrP; exists x^-1; rewrite -commrV.\nQed.",
    "Lemma invrK : involutive (@inv R).\nProof.\nmove=> x; case Ux: (x \\in unit); last by rewrite !invr_out ?Ux.\nrewrite -(mulrK Ux _^-1) -mulrA commrV ?mulKr //.\nby apply/unitrP; exists x; rewrite divrr ?mulVr.\nQed.",
    "Lemma invr_inj : injective (@inv R).\nProof. exact: inv_inj invrK. Qed.",
    "Lemma unitrV x : (x^-1 \\in unit) = (x \\in unit).\nProof. by rewrite !unitrE invrK commrV. Qed.",
    "Lemma unitr1 : 1 \\in @unit R.\nProof. by apply/unitrP; exists 1; rewrite mulr1. Qed.",
    "Lemma invr1 : 1^-1 = 1 :> R.\nProof. by rewrite -{2}(mulVr unitr1) mulr1. Qed.",
    "Lemma div1r x : 1 / x = x^-1. Proof. by rewrite mul1r. Qed.",
    "Lemma divr1 x : x / 1 = x. Proof. by rewrite invr1 mulr1. Qed.",
    "Lemma natr_div m d :\n  d %| m -> d%:R \\is a @unit R -> (m %/ d)%:R = m%:R / d%:R :> R.\nProof.\nby rewrite dvdn_eq => /eqP def_m unit_d; rewrite -{2}def_m natrM mulrK.\nQed.",
    "Lemma divrI : {in unit, right_injective (fun x y => x / y)}.\nProof. by move=> x /mulrI/inj_comp; apply; apply: invr_inj. Qed.",
    "Lemma divIr : {in unit, left_injective (fun x y => x / y)}.\nProof. by move=> x; rewrite -unitrV => /mulIr. Qed.",
    "Lemma unitr0 : (0 \\is a @unit R) = false.\nProof. by apply/unitrP=> [[x [_ /esym/eqP]]]; rewrite mul0r oner_eq0. Qed.",
    "Lemma invr0 : 0^-1 = 0 :> R.\nProof. by rewrite invr_out ?unitr0. Qed.",
    "Lemma unitrN1 : -1 \\is a @unit R.\nProof. by apply/unitrP; exists (-1); rewrite mulrNN mulr1. Qed.",
    "Lemma invrN1 : (-1)^-1 = -1 :> R.\nProof. by rewrite -{2}(divrr unitrN1) mulN1r opprK. Qed.",
    "Lemma invr_sign n : ((-1) ^- n) = (-1) ^+ n :> R.\nProof. by rewrite -signr_odd; case: (odd n); rewrite (invr1, invrN1). Qed.",
    "Lemma unitrMl x y : y \\is a unit -> (x * y \\is a unit) = (x \\is a unit).\nProof.\nmove=> Uy; wlog Ux: x y Uy / x \\is a unit => [WHxy|].\n  by apply/idP/idP=> Ux; first rewrite -(mulrK Uy x); rewrite WHxy ?unitrV.\nrewrite Ux; apply/unitrP; exists (y^-1 * x^-1).\nby rewrite -!mulrA mulKr ?mulrA ?mulrK ?divrr ?mulVr.\nQed.",
    "Lemma unitrMr x y : x \\is a unit -> (x * y \\is a unit) = (y \\is a unit).\nProof.\nmove=> Ux; apply/idP/idP=> [Uxy | Uy]; last by rewrite unitrMl.\nby rewrite -(mulKr Ux y) unitrMl ?unitrV.\nQed.",
    "Lemma unitr_prod {I : Type} (P : pred I) (E : I -> R) (r : seq I) :\n  (forall i, P i -> E i \\is a GRing.unit) ->\n    (\\prod_(i <- r | P i) E i \\is a GRing.unit).\nProof.\nby move=> Eunit; elim/big_rec: _ => [/[!unitr1] |i x /Eunit/unitrMr->].\nQed.",
    "Lemma unitr_prod_in {I : eqType} (P : pred I) (E : I -> R) (r : seq I) :\n  {in r, forall i, P i -> E i \\is a GRing.unit} ->\n    (\\prod_(i <- r | P i) E i \\is a GRing.unit).\nProof.\nby rewrite big_seq_cond => H; apply: unitr_prod => i /andP[]; exact: H.\nQed.",
    "Lemma invrM : {in unit &, forall x y, (x * y)^-1 = y^-1 * x^-1}.\nProof.\nmove=> x y Ux Uy; have Uxy: (x * y \\in unit) by rewrite unitrMl.\nby apply: (mulrI Uxy); rewrite divrr ?mulrA ?mulrK ?divrr.\nQed.",
    "Lemma unitrM_comm x y :\n  comm x y -> (x * y \\is a unit) = (x \\is a unit) && (y \\is a unit).\nProof.\nmove=> cxy; apply/idP/andP=> [Uxy | [Ux Uy]]; last by rewrite unitrMl.\nsuffices Ux: x \\in unit by rewrite unitrMr in Uxy.\napply/unitrP; case/unitrP: Uxy => z [zxy xyz]; exists (y * z).\nrewrite mulrA xyz -{1}[y]mul1r -{1}zxy cxy -!mulrA (mulrA x) (mulrA _ z) xyz.\nby rewrite mul1r -cxy.\nQed.",
    "Lemma unitrX x n : x \\is a unit -> x ^+ n \\is a unit.\nProof.\nby move=> Ux; elim: n => [|n IHn]; rewrite ?unitr1 // exprS unitrMl.\nQed.",
    "Lemma unitrX_pos x n : n > 0 -> (x ^+ n \\in unit) = (x \\in unit).\nProof.\ncase: n => // n _; rewrite exprS unitrM_comm; last exact: commrX.\nby case Ux: (x \\is a unit); rewrite // unitrX.\nQed.",
    "Lemma exprVn x n : x^-1 ^+ n = x ^- n.\nProof.\nelim: n => [|n IHn]; first by rewrite !expr0 ?invr1.\ncase Ux: (x \\is a unit); first by rewrite exprSr exprS IHn -invrM // unitrX.\nby rewrite !invr_out ?unitrX_pos ?Ux.\nQed.",
    "Lemma exprB m n x : n <= m -> x \\is a unit -> x ^+ (m - n) = x ^+ m / x ^+ n.\nProof. by move/subnK=> {2}<- Ux; rewrite exprD mulrK ?unitrX. Qed.",
    "Lemma invr_neq0 x : x != 0 -> x^-1 != 0.\nProof.\nmove=> nx0; case Ux: (x \\is a unit); last by rewrite invr_out ?Ux.\nby apply/eqP=> x'0; rewrite -unitrV x'0 unitr0 in Ux.\nQed.",
    "Lemma invr_eq0 x : (x^-1 == 0) = (x == 0).\nProof. by apply: negb_inj; apply/idP/idP; move/invr_neq0; rewrite ?invrK. Qed.",
    "Lemma invr_eq1 x : (x^-1 == 1) = (x == 1).\nProof. by rewrite (inv_eq invrK) invr1. Qed.",
    "Lemma rev_unitrP (x y : R^c) : y * x = 1 /\\ x * y = 1 -> x \\is a unit.\nProof. by case=> [yx1 xy1]; apply/unitrP; exists y. Qed.",
    "Lemma rev_prodrV (R : unitRingType)\n  (I : Type) (r : seq I) (P : pred I) (E : I -> R) :\n  (forall i, P i -> E i \\is a GRing.unit) ->\n  \\prod_(i <- r | P i) (E i)^-1 = ((\\prod_(i <- r | P i) (E i : R^c))^-1).\nProof.\nmove=> Eunit; symmetry.\napply: (big_morph_in GRing.unit _ _ (unitr1 R^c) (@invrM _) (invr1 _)) Eunit.\nby move=> x y xunit; rewrite unitrMr.\nQed.",
    "Lemma divr_closedV : divr_closed -> invr_closed.\nProof. by case=> S1 Sdiv x Sx; rewrite -[x^-1]mul1r Sdiv. Qed.",
    "Lemma divr_closedM : divr_closed -> mulr_closed S.\nProof.\nby case=> S1 Sdiv; split=> // x y Sx Sy; rewrite -[y]invrK -[y^-1]mul1r !Sdiv.\nQed.",
    "Lemma sdivr_closed_div : sdivr_closed -> divr_closed.\nProof. by case=> SN1 Sdiv; split; rewrite // -(divrr (@unitrN1 _)) Sdiv. Qed.",
    "Lemma sdivr_closedM : sdivr_closed -> smulr_closed S.\nProof.\nby move=> Sdiv; have [_ SM] := divr_closedM (sdivr_closed_div Sdiv); case: Sdiv.\nQed.",
    "Lemma divring_closedBM : divring_closed -> subring_closed S.\nProof. by case=> S1 SB Sdiv; split=> //; case: divr_closedM. Qed.",
    "Lemma divring_closed_div : divring_closed -> sdivr_closed.\nProof.\ncase=> S1 SB Sdiv; split; rewrite ?zmod_closedN //.\nexact/subring_closedB/divring_closedBM.\nQed.",
    "Lemma rmorph_unit x : x \\in unit -> f x \\in unit.\nProof.\ncase/unitrP=> y [yx1 xy1]; apply/unitrP.\nby exists (f y); rewrite -!rmorphM // yx1 xy1 rmorph1.\nQed.",
    "Lemma rmorphV : {in unit, {morph f: x / x^-1}}.\nProof.\nmove=> x Ux; rewrite /= -[(f x)^-1]mul1r.\nby apply: (canRL (mulrK (rmorph_unit Ux))); rewrite -rmorphM mulVr ?rmorph1.\nQed.",
    "Lemma rmorph_div x y : y \\in unit -> f (x / y) = f x / f y.\nProof. by move=> Uy; rewrite rmorphM /= rmorphV. Qed.",
    "Lemma unitrM x y : (x * y \\in unit) = (x \\in unit) && (y \\in unit).\nProof. exact/unitrM_comm/mulrC. Qed.",
    "Lemma unitrPr x : reflect (exists y, x * y = 1) (x \\in unit).\nProof.\nby apply: (iffP (unitrP x)) => [[y []] | [y]]; exists y; rewrite // mulrC.\nQed.",
    "Lemma mulr1_eq x y : x * y = 1 -> x^-1 = y.\nProof.\nby move=> xy_eq1; rewrite -[LHS]mulr1 -xy_eq1; apply/mulKr/unitrPr; exists y.\nQed.",
    "Lemma divr1_eq x y : x / y = 1 -> x = y. Proof. by move/mulr1_eq/invr_inj. Qed.",
    "Lemma divKr x : x \\is a unit -> {in unit, involutive (fun y => x / y)}.\nProof. by move=> Ux y Uy; rewrite /= invrM ?unitrV // invrK mulrC divrK. Qed.",
    "Lemma expr_div_n x y n : (x / y) ^+ n = x ^+ n / y ^+ n.\nProof. by rewrite exprMn exprVn. Qed.",
    "Lemma unitr_prodP (I : eqType) (r : seq I) (P : pred I) (E : I -> R) :\n  reflect {in r, forall i, P i -> E i \\is a GRing.unit}\n    (\\prod_(i <- r | P i) E i \\is a GRing.unit).\nProof.\nrewrite (big_morph [in unit] unitrM (@unitr1 _) ) big_all_cond.\nexact: 'all_implyP.\nQed.",
    "Lemma prodrV (I : eqType) (r : seq I) (P : pred I) (E : I -> R) :\n  (forall i, P i -> E i \\is a GRing.unit) ->\n  \\prod_(i <- r | P i) (E i)^-1 = (\\prod_(i <- r | P i) E i)^-1.\nProof.\nby move=> /rev_prodrV->; rewrite rev_prodr (perm_big r)// perm_rev.\nQed.",
    "Lemma scaler_injl : {in unit, @right_injective R A A *:%R}.\nProof.\nmove=> k Uk x1 x2 Hx1x2.\nby rewrite -[x1]scale1r -(mulVr Uk) -scalerA Hx1x2 scalerA mulVr // scale1r.\nQed.",
    "Lemma scaler_unit k x : k \\in unit -> (k *: x \\in unit) = (x \\in unit).\nProof.\nmove=> Uk; apply/idP/idP=> [Ukx | Ux]; apply/unitrP; last first.\n  exists (k^-1 *: x^-1).\n  by rewrite -!scalerAl -!scalerAr !scalerA !mulVr // !mulrV // scale1r.\nexists (k *: (k *: x)^-1); split.\n  apply: (mulrI Ukx).\n  by rewrite mulr1 mulrA -scalerAr mulrV // -scalerAl mul1r.\napply: (mulIr Ukx).\nby rewrite mul1r -mulrA -scalerAl mulVr // -scalerAr mulr1.\nQed.",
    "Lemma invrZ k x : k \\in unit -> x \\in unit -> (k *: x)^-1 = k^-1 *: x^-1.\nProof.\nmove=> Uk Ux; have Ukx: (k *: x \\in unit) by rewrite scaler_unit.\napply: (mulIr Ukx).\nby rewrite mulVr // -scalerAl -scalerAr scalerA !mulVr // scale1r.\nQed.",
    "Lemma divalg_closedBdiv : divalg_closed -> divring_closed S.\nProof. by case=> S1 /linear_closedB. Qed.",
    "Lemma divalg_closedZ : divalg_closed -> subalg_closed S.\nProof. by case=> S1 Slin Sdiv; split=> //; have [] := @divr_closedM A S. Qed.",
    "Lemma eq_eval e e' t : same_env e e' -> eval e t = eval e' t.\nProof. by move=> eq_e; elim: t => //= t1 -> // t2 ->. Qed.",
    "Lemma eval_tsubst e t s :\n  eval e (tsubst t s) = eval (set_nth 0 e s.1 (eval e s.2)) t.\nProof.\ncase: s => i u; elim: t => //=; do 2?[move=> ? -> //] => j.\nby rewrite nth_set_nth /=; case: (_ == _).\nQed.",
    "Lemma same_env_sym e e' : same_env e e' -> same_env e' e.\nProof. exact: fsym. Qed.",
    "Lemma eq_holds e e' f : same_env e e' -> holds e f -> holds e' f.\nProof.\npose sv := set_nth (0 : R).\nhave eq_i i v e1 e2: same_env e1 e2 -> same_env (sv e1 i v) (sv e2 i v).\n  by move=> eq_e j; rewrite !nth_set_nth /= eq_e.\nelim: f e e' => //=.\n- by move=> t1 t2 e e' eq_e; rewrite !(eq_eval _ eq_e).\n- by move=> t e e' eq_e; rewrite (eq_eval _ eq_e).\n- by move=> f1 IH1 f2 IH2 e e' eq_e; move/IH2: (eq_e); move/IH1: eq_e; tauto.\n- by move=> f1 IH1 f2 IH2 e e' eq_e; move/IH2: (eq_e); move/IH1: eq_e; tauto.\n- by move=> f1 IH1 f2 IH2 e e' eq_e f12; move/IH1: (same_env_sym eq_e); eauto.\n- by move=> f1 IH1 e e'; move/same_env_sym; move/IH1; tauto.\n- by move=> i f1 IH1 e e'; move/(eq_i i)=> eq_e [x f_ex]; exists x; eauto.\nby move=> i f1 IH1 e e'; move/(eq_i i); eauto.\nQed.",
    "Lemma holds_fsubst e f i v :\n  holds e (fsubst f (i, v%:T)%T) <-> holds (set_nth 0 e i v) f.\nProof.\nelim: f e => //=; do [\n  by move=> *; rewrite !eval_tsubst\n| move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto\n| move=> f IHf e; move: (IHf e); tauto\n| move=> j f IHf e].\n- case eq_ji: (j == i); first rewrite (eqP eq_ji).\n    by split=> [] [x f_x]; exists x; rewrite set_set_nth eqxx in f_x *.\n  split=> [] [x f_x]; exists x; move: f_x; rewrite set_set_nth eq_sym eq_ji;\n     have:= IHf (set_nth 0 e j x); tauto.\ncase eq_ji: (j == i); first rewrite (eqP eq_ji).\n  by split=> [] f_ x; move: (f_ x); rewrite set_set_nth eqxx.\nsplit=> [] f_ x; move: (IHf (set_nth 0 e j x)) (f_ x);\n  by rewrite set_set_nth eq_sym eq_ji; tauto.\nQed.",
    "Lemma to_rterm_id t r n : rterm t -> to_rterm t r n = (t, r).\nProof.\nelim: t r n => //.\n- by move=> t1 IHt1 t2 IHt2 r n /= /andP[rt1 rt2]; rewrite {}IHt1 // IHt2.\n- by move=> t IHt r n /= rt; rewrite {}IHt.\n- by move=> t IHt r n m /= rt; rewrite {}IHt.\n- by move=> t1 IHt1 t2 IHt2 r n /= /andP[rt1 rt2]; rewrite {}IHt1 // IHt2.\n- by move=> t IHt r n m /= rt; rewrite {}IHt.\nQed.",
    "Lemma to_rform_rformula f : rformula (to_rform f).\nProof.\nsuffices eq0_ring t1: rformula (eq0_rform t1) by elim: f => //= => f1 ->.\nrewrite /eq0_rform; move: (ub_var t1) => m; set tr := _ m.\nsuffices: all rterm (tr.1 :: tr.2).\n  case: tr => {}t1 r /= /andP[t1_r].\n  by elim: r m => [|t r IHr] m; rewrite /= ?andbT // => /andP[->]; apply: IHr.\nhave: all rterm [::] by [].\nrewrite {}/tr; elim: t1 [::] => //=.\n- move=> t1 IHt1 t2 IHt2 r.\n  move/IHt1; case: to_rterm => {r IHt1}t1 r /= /andP[t1_r].\n  move/IHt2; case: to_rterm => {r IHt2}t2 r /= /andP[t2_r].\n  by rewrite t1_r t2_r.\n- by move=> t1 IHt1 r /IHt1; case: to_rterm.\n- by move=> t1 IHt1 n r /IHt1; case: to_rterm.\n- move=> t1 IHt1 t2 IHt2 r.\n  move/IHt1; case: to_rterm => {r IHt1}t1 r /= /andP[t1_r].\n  move/IHt2; case: to_rterm => {r IHt2}t2 r /= /andP[t2_r].\n  by rewrite t1_r t2_r.\n- move=> t1 IHt1 r.\n  by move/IHt1; case: to_rterm => {r IHt1}t1 r /=; rewrite all_rcons.\n- by move=> t1 IHt1 n r /IHt1; case: to_rterm.\nQed.",
    "Lemma to_rformP e f : holds e (to_rform f) <-> holds e f.\nProof.\nsuffices{e f} equal0_equiv e t1 t2:\n  holds e (eq0_rform (t1 - t2)) <-> (eval e t1 == eval e t2).\n- elim: f e => /=; try tauto.\n  + move=> t1 t2 e.\n    by split; [move/equal0_equiv/eqP | move/eqP/equal0_equiv].\n  + by move=> t1 e; rewrite unitrE; apply: equal0_equiv.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 e; move: (IHf1 e); tauto.\n  + by move=> n f1 IHf1 e; split=> [] [x] /IHf1; exists x.\n  + by move=> n f1 IHf1 e; split=> Hx x; apply/IHf1.\nrewrite -(add0r (eval e t2)) -(can2_eq (subrK _) (addrK _)).\nrewrite -/(eval e (t1 - t2)); move: (t1 - t2)%T => {t1 t2} t.\nhave sub_var_tsubst s t0: s.1 >= ub_var t0 -> tsubst t0 s = t0.\n  elim: t0 {t} => //=.\n  - by move=> n; case: ltngtP.\n  - by move=> t1 IHt1 t2 IHt2; rewrite geq_max => /andP[/IHt1-> /IHt2->].\n  - by move=> t1 IHt1 /IHt1->.\n  - by move=> t1 IHt1 n /IHt1->.\n  - by move=> t1 IHt1 t2 IHt2; rewrite geq_max => /andP[/IHt1-> /IHt2->].\n  - by move=> t1 IHt1 /IHt1->.\n  - by move=> t1 IHt1 n /IHt1->.\npose fix rsub t' m r : term R :=\n  if r is u :: r' then tsubst (rsub t' m.+1 r') (m, u^-1)%T else t'.\npose fix ub_sub m r : Prop :=\n  if r is u :: r' then ub_var u <= m /\\ ub_sub m.+1 r' else true.\nsuffices{t} rsub_to_r t r0 m: m >= ub_var t -> ub_sub m r0 ->\n  let: (t', r) := to_rterm t r0 m in\n  [/\\ take (size r0) r = r0,\n      ub_var t' <= m + size r, ub_sub m r & rsub t' m r = t].\n- have:= rsub_to_r t [::] _ (leqnn _); rewrite /eq0_rform.\n  case: (to_rterm _ _ _) => [t1' r1] [//|_ _ ub_r1 def_t].\n  rewrite -{2}def_t {def_t}.\n  elim: r1 (ub_var t) e ub_r1 => [|u r1 IHr1] m e /= => [_|[ub_u ub_r1]].\n    by split=> /eqP.\n  rewrite eval_tsubst /=; set y := eval e u; split=> t_eq0.\n    apply/IHr1=> //; apply: t_eq0.\n    rewrite nth_set_nth /= eqxx -(eval_tsubst e u (m, Const _)).\n    rewrite sub_var_tsubst //= -/y.\n    case Uy: (y \\in unit); [left | right]; first by rewrite mulVr ?divrr.\n    split=> [|[z]]; first by rewrite invr_out ?Uy.\n    rewrite nth_set_nth /= eqxx.\n    rewrite -!(eval_tsubst _ _ (m, Const _)) !sub_var_tsubst // -/y => yz1.\n    by case/unitrP: Uy; exists z.\n  move=> x def_x; apply/IHr1=> //; suff ->: x = y^-1 by []; move: def_x.\n  rewrite nth_set_nth /= eqxx -(eval_tsubst e u (m, Const _)).\n  rewrite sub_var_tsubst //= -/y; case=> [[xy1 yx1] | [xy nUy]].\n    by rewrite -[y^-1]mul1r -[1]xy1 mulrK //; apply/unitrP; exists x.\n  rewrite invr_out //; apply/unitrP=> [[z yz1]]; case: nUy; exists z.\n  rewrite nth_set_nth /= eqxx -!(eval_tsubst _ _ (m, _%:T)%T).\n  by rewrite !sub_var_tsubst.\nhave rsub_id r t0 n: ub_var t0 <= n -> rsub t0 n r = t0.\n  by elim: r n => //= t1 r IHr n let0n; rewrite IHr ?sub_var_tsubst ?leqW.\nhave rsub_acc r s t1 m1:\n  ub_var t1 <= m1 + size r -> rsub t1 m1 (r ++ s) = rsub t1 m1 r.\n  elim: r t1 m1 => [|t1 r IHr] t2 m1 /=; first by rewrite addn0; apply: rsub_id.\n  by move=> letmr; rewrite IHr ?addSnnS.\nelim: t r0 m => /=; try do [\n  by move=> n r m hlt hub; rewrite take_size (ltn_addr _ hlt) rsub_id\n| by move=> n r m hlt hub; rewrite leq0n take_size rsub_id\n| move=> t1 IHt1 t2 IHt2 r m; rewrite geq_max; case/andP=> hub1 hub2 hmr;\n  case: to_rterm {hub1 hmr}(IHt1 r m hub1 hmr) => t1' r1;\n  case=> htake1 hub1' hsub1 <-;\n  case: to_rterm {IHt2 hub2 hsub1}(IHt2 r1 m hub2 hsub1) => t2' r2 /=;\n  rewrite geq_max; case=> htake2 -> hsub2 /= <-;\n  rewrite -{1 2}(cat_take_drop (size r1) r2) htake2; set r3 := drop _ _;\n  rewrite size_cat addnA (leq_trans _ (leq_addr _ _)) //;\n  split=> {hsub2}//;\n   first by [rewrite takel_cat // -htake1 size_take geq_min leqnn orbT];\n  rewrite -(rsub_acc r1 r3 t1') {hub1'}// -{htake1}htake2 {r3}cat_take_drop;\n  by elim: r2 m => //= u r2 IHr2 m; rewrite IHr2\n| do [ move=> t1 IHt1 r m; do 2!move=> /IHt1{}IHt1\n     | move=> t1 IHt1 n r m; do 2!move=> /IHt1{}IHt1];\n  case: to_rterm IHt1 => t1' r1 [-> -> hsub1 <-]; split=> {hsub1}//;\n  by elim: r1 m => //= u r1 IHr1 m; rewrite IHr1].\nmove=> t1 IH r m letm /IH {IH} /(_ letm) {letm}.\ncase: to_rterm => t1' r1 /= [def_r ub_t1' ub_r1 <-].\nrewrite size_rcons addnS leqnn -{1}cats1 takel_cat ?def_r; last first.\n  by rewrite -def_r size_take geq_min leqnn orbT.\nelim: r1 m ub_r1 ub_t1' {def_r} => /= [|u r1 IHr1] m => [_|[->]].\n  by rewrite addn0 eqxx.\nby rewrite -addSnnS => /IHr1 IH /IH[_ _ ub_r1 ->].\nQed.",
    "Lemma qf_evalP e f : qf_form f -> reflect (holds e f) (qf_eval e f).\nProof.\nelim: f => //=; try by move=> *; apply: idP.\n- by move=> t1 t2 _; apply: eqP.\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1T]; last by right; case.\n  by case/IHf2; [left | right; case].\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1F]; first by do 2 left.\n  by case/IHf2; [left; right | right; case].\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1T]; last by left.\n  by case/IHf2; [left | right; move/(_ f1T)].\nby move=> f1 IHf1 /IHf1[]; [right | left].\nQed.",
    "Lemma cat_dnfP e bcs1 bcs2 :\n  qf_eval e (dnf_to_form (bcs1 ++ bcs2))\n    = qf_eval e (dnf_to_form bcs1 \\/ dnf_to_form bcs2).\nProof.\nby elim: bcs1 => //= bc1 bcs1 IH1; rewrite -orbA; congr orb; rewrite IH1.\nQed.",
    "Lemma and_dnfP e bcs1 bcs2 :\n  qf_eval e (dnf_to_form (and_dnf bcs1 bcs2))\n   = qf_eval e (dnf_to_form bcs1 /\\ dnf_to_form bcs2).\nProof.\nelim: bcs1 => [|bc1 bcs1 IH1] /=; first by rewrite /and_dnf big_nil.\nrewrite /and_dnf big_cons -/(and_dnf bcs1 bcs2) cat_dnfP  /=.\nrewrite {}IH1 /= andb_orl; congr orb.\nelim: bcs2 bc1 {bcs1} => [|bc2 bcs2 IH] bc1 /=; first by rewrite andbF.\nrewrite {}IH /= andb_orr; congr orb => {bcs2}.\nsuffices aux (l1 l2 : seq (term R)) g : let redg := foldr (And \\o g) True in\n  qf_eval e (redg (l1 ++ l2)) = qf_eval e (redg l1 /\\ redg l2)%T.\n+ by rewrite 2!aux /= 2!andbA -andbA -andbCA andbA andbCA andbA.\nby elim: l1 => [| t1 l1 IHl1] //=; rewrite -andbA IHl1.\nQed.",
    "Lemma qf_to_dnfP e :\n  let qev f b := qf_eval e (dnf_to_form (qf_to_dnf f b)) in\n  forall f, qf_form f && rformula f -> qev f false = qf_eval e f.\nProof.\nmove=> qev; have qevT f: qev f true = ~~ qev f false.\n  rewrite {}/qev; elim: f => //=; do [by case | move=> f1 IH1 f2 IH2 | ].\n  - by move=> t1 t2; rewrite !andbT !orbF.\n  - by rewrite and_dnfP cat_dnfP negb_and -IH1 -IH2.\n  - by rewrite and_dnfP cat_dnfP negb_or -IH1 -IH2.\n  - by rewrite and_dnfP cat_dnfP /= negb_or IH1 -IH2 negbK.\n  by move=> t1 ->; rewrite negbK.\nrewrite /qev; elim=> //=; first by case.\n- by move=> t1 t2 _; rewrite subr_eq0 !andbT orbF.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite and_dnfP /= => /IH1-> /IH2->.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite cat_dnfP /= => /IH1-> => /IH2->.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite cat_dnfP /= [qf_eval _ _]qevT -implybE => /IH1 <- /IH2->.\nby move=> f1 IH1 /IH1 <-; rewrite -qevT.\nQed.",
    "Lemma dnf_to_form_qf bcs : qf_form (dnf_to_form bcs).\nProof.\nby elim: bcs => //= [[clT clF] _ ->] /=; elim: clT => //=; elim: clF.\nQed.",
    "Lemma qf_to_dnf_rterm f b : rformula f -> all dnf_rterm (qf_to_dnf f b).\nProof.\nset ok := all dnf_rterm.\nhave cat_ok bcs1 bcs2: ok bcs1 -> ok bcs2 -> ok (bcs1 ++ bcs2).\n  by move=> ok1 ok2; rewrite [ok _]all_cat; apply/andP.\nhave and_ok bcs1 bcs2: ok bcs1 -> ok bcs2 -> ok (and_dnf bcs1 bcs2).\n  rewrite /and_dnf unlock; elim: bcs1 => //= cl1 bcs1 IH1; rewrite -andbA.\n  case/and3P=> ok11 ok12 ok1 ok2; rewrite cat_ok ?{}IH1 {bcs1 ok1}//.\n  elim: bcs2 ok2 => //= cl2 bcs2 IH2 /andP[ok2 /IH2->].\n  by rewrite /dnf_rterm !all_cat ok11 ok12 /= !andbT.\nelim: f b => //=; [ by do 2!case | | | | | by auto | | ];\n  try by repeat case/andP || intro; case: ifP; auto.\nby rewrite /dnf_rterm => ?? [] /= ->.\nQed.",
    "Lemma dnf_to_rform bcs : rformula (dnf_to_form bcs) = all dnf_rterm bcs.\nProof.\nelim: bcs => //= [[cl1 cl2] bcs ->]; rewrite {2}/dnf_rterm /=; congr (_ && _).\nby congr andb; [elim: cl1 | elim: cl2] => //= t cl ->; rewrite andbT.\nQed.",
    "Lemma If_form_qf :\n  qf_form pred_f -> qf_form then_f -> qf_form else_f -> qf_form If.\nProof. by move=> /= -> -> ->. Qed.",
    "Lemma If_form_rf :\n  rformula pred_f -> rformula then_f -> rformula else_f -> rformula If.\nProof. by move=> /= -> -> ->. Qed.",
    "Lemma eval_If e :\n  let ev := qf_eval e in ev If = (if ev pred_f then ev then_f else ev else_f).\nProof. by rewrite /=; case: ifP => _; rewrite ?orbF. Qed.",
    "Lemma Pick_form_qf :\n   (forall i, qf_form (pred_f i)) ->\n   (forall i, qf_form (then_f i)) ->\n    qf_form else_f ->\n  qf_form Pick.\nProof.\nmove=> qfp qft qfe; have mA := (big_morph qf_form) true andb.\nrewrite mA // big1 //= => p _.\nrewrite mA // big1 => [|i _]; first by case: pick.\nby rewrite fun_if if_same /= qfp.\nQed.",
    "Lemma eval_Pick e (qev := qf_eval e) :\n  let P i := qev (pred_f i) in\n  qev Pick = (if pick P is Some i then qev (then_f i) else qev else_f).\nProof.\nmove=> P; rewrite ((big_morph qev) false orb) //= big_orE /=.\napply/existsP/idP=> [[p] | true_at_P].\n  rewrite ((big_morph qev) true andb) //= big_andE /=.\n  case/andP=> /forallP-eq_p_P.\n  rewrite (@eq_pick _ _ P) => [|i]; first by case: pick.\n  by move/(_ i): eq_p_P => /=; case: (p i) => //= /negPf.\nexists [ffun i => P i] => /=; apply/andP; split.\n  rewrite ((big_morph qev) true andb) //= big_andE /=.\n  by apply/forallP=> i; rewrite /= ffunE; case Pi: (P i) => //=; apply: negbT.\nrewrite (@eq_pick _ _ P) => [|i]; first by case: pick true_at_P.\nby rewrite ffunE.\nQed.",
    "Lemma foldExistsP I e :\n  (exists2 e', {in [predC I], same_env e e'} & holds e' f)\n    <-> holds e (foldr Exists f I).\nProof.\nelim: I e => /= [|i I IHi] e.\n  by split=> [[e' eq_e] |]; [apply: eq_holds => i; rewrite eq_e | exists e].\nsplit=> [[e' eq_e f_e'] | [x]]; last set e_x := set_nth 0 e i x.\n  exists e'`_i; apply/IHi; exists e' => // j.\n  by have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP => // ->.\ncase/IHi=> e' eq_e f_e'; exists e' => // j.\nby have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP.\nQed.",
    "Lemma foldForallP I e :\n  (forall e', {in [predC I], same_env e e'} -> holds e' f)\n    <-> holds e (foldr Forall f I).\nProof.\nelim: I e => /= [|i I IHi] e.\n  by split=> [|f_e e' eq_e]; [apply | apply: eq_holds f_e => i; rewrite eq_e].\nsplit=> [f_e' x | f_e e' eq_e]; first set e_x := set_nth 0 e i x.\n  apply/IHi=> e' eq_e; apply: f_e' => j.\n  by have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP.\nmove/IHi: (f_e e'`_i); apply=> j.\nby have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP => // ->.\nQed.",
    "Lemma mulf_eq0 x y : (x * y == 0) = (x == 0) || (y == 0).\nProof.\napply/eqP/idP; first exact: mulf_eq0_subproof.\nby case/pred2P=> ->; rewrite (mulr0, mul0r).\nQed.",
    "Lemma prodf_eq0 (I : finType) (P : pred I) (F : I -> R) :\n  reflect (exists2 i, P i & (F i == 0)) (\\prod_(i | P i) F i == 0).\nProof.\napply: (iffP idP) => [|[i Pi /eqP Fi0]]; last first.\n  by rewrite (bigD1 i) //= Fi0 mul0r.\nelim: (index_enum _) => [|i r IHr]; first by rewrite big_nil oner_eq0.\nrewrite big_cons /=; have [Pi | _] := ifP; last exact: IHr.\nby rewrite mulf_eq0; case/orP=> // Fi0; exists i.\nQed.",
    "Lemma prodf_seq_eq0 I r (P : pred I) (F : I -> R) :\n  (\\prod_(i <- r | P i) F i == 0) = has (fun i => P i && (F i == 0)) r.\nProof. by rewrite (big_morph _ mulf_eq0 (oner_eq0 _)) big_has_cond. Qed.",
    "Lemma mulf_neq0 x y : x != 0 -> y != 0 -> x * y != 0.\nProof. by move=> x0 y0; rewrite mulf_eq0; apply/norP. Qed.",
    "Lemma prodf_neq0 (I : finType) (P : pred I) (F : I -> R) :\n  reflect (forall i, P i -> (F i != 0)) (\\prod_(i | P i) F i != 0).\nProof. by rewrite (sameP (prodf_eq0 _ _) exists_inP); apply: exists_inPn. Qed.",
    "Lemma prodf_seq_neq0 I r (P : pred I) (F : I -> R) :\n  (\\prod_(i <- r | P i) F i != 0) = all (fun i => P i ==> (F i != 0)) r.\nProof.\nrewrite prodf_seq_eq0 -all_predC; apply: eq_all => i /=.\nby rewrite implybE negb_and.\nQed.",
    "Lemma expf_eq0 x n : (x ^+ n == 0) = (n > 0) && (x == 0).\nProof.\nelim: n => [|n IHn]; first by rewrite oner_eq0.\nby rewrite exprS mulf_eq0 IHn andKb.\nQed.",
    "Lemma sqrf_eq0 x : (x ^+ 2 == 0) = (x == 0). Proof. exact: expf_eq0. Qed.",
    "Lemma expf_neq0 x m : x != 0 -> x ^+ m != 0.\nProof. by move=> x_nz; rewrite expf_eq0; apply/nandP; right. Qed.",
    "Lemma natf_neq0_pchar n : (n%:R != 0 :> R) = (pchar R)^'.-nat n.\nProof.\nhave [-> | /prod_prime_decomp->] := posnP n; first by rewrite eqxx.\nrewrite !big_seq; elim/big_rec: _ => [|[p e] s /=]; first by rewrite oner_eq0.\ncase/mem_prime_decomp=> p_pr _ _; rewrite pnatM pnatX eqn0Ngt orbC => <-.\nby rewrite natrM natrX mulf_eq0 expf_eq0 negb_or negb_and pnatE ?inE p_pr.\nQed.",
    "Lemma natf0_pchar n : n > 0 -> n%:R == 0 :> R -> exists p, p \\in pchar R.\nProof.\nmove=> n_gt0 nR_0; exists (pdiv n`_(pchar R)).\napply: pnatP (pdiv_dvd _); rewrite ?part_pnat // ?pdiv_prime //.\nby rewrite ltn_neqAle eq_sym partn_eq1 // -natf_neq0_pchar nR_0 /=.\nQed.",
    "Lemma pcharf'_nat n : (pchar R)^'.-nat n = (n%:R != 0 :> R).\nProof.\nhave [-> | n_gt0] := posnP n; first by rewrite eqxx.\napply/idP/idP => [|nz_n]; last first.\n  by apply/pnatP=> // p p_pr p_dvd_n; apply: contra nz_n => /dvdn_pcharf <-.\napply: contraL => n0; have [// | p pcharRp] := natf0_pchar _ n0.\nhave [p_pr _] := andP pcharRp; rewrite (eq_pnat _ (eq_negn (pcharf_eq pcharRp))).\nby rewrite p'natE // (dvdn_pcharf pcharRp) n0.\nQed.",
    "Lemma pcharf0P : pchar R =i pred0 <-> (forall n, (n%:R == 0 :> R) = (n == 0)%N).\nProof.\nsplit=> pcharF0 n; last by rewrite !inE pcharF0 andbC; case: eqP => // ->.\nhave [-> | n_gt0] := posnP; first exact: eqxx.\nby apply/negP; case/natf0_pchar=> // p; rewrite pcharF0.\nQed.",
    "Lemma eqf_sqr x y : (x ^+ 2 == y ^+ 2) = (x == y) || (x == - y).\nProof. by rewrite -subr_eq0 subr_sqr mulf_eq0 subr_eq0 addr_eq0. Qed.",
    "Lemma mulfI x : x != 0 -> injective ( *%R x).\nProof.\nmove=> nz_x y z; apply: contra_eq => neq_yz.\nby rewrite -subr_eq0 -mulrBr mulf_neq0 ?subr_eq0.\nQed.",
    "Lemma mulIf x : x != 0 -> injective ( *%R^~ x).\nProof. by move=> nz_x y z; rewrite -!(mulrC x); apply: mulfI. Qed.",
    "Lemma divfI x : x != 0 -> injective (fun y => x / y).\nProof. by move/mulfI/inj_comp; apply; apply: invr_inj. Qed.",
    "Lemma divIf y : y != 0 -> injective (fun x => x / y).\nProof. by rewrite -invr_eq0; apply: mulIf. Qed.",
    "Lemma sqrf_eq1 x : (x ^+ 2 == 1) = (x == 1) || (x == -1).\nProof. by rewrite -subr_eq0 subr_sqr_1 mulf_eq0 subr_eq0 addr_eq0. Qed.",
    "Lemma expfS_eq1 x n :\n  (x ^+ n.+1 == 1) = (x == 1) || (\\sum_(i < n.+1) x ^+ i == 0).\nProof. by rewrite -![_ == 1]subr_eq0 subrX1 mulf_eq0. Qed.",
    "Lemma lregP x : reflect (lreg x) (x != 0).\nProof. by apply: (iffP idP) => [/mulfI | /lreg_neq0]. Qed.",
    "Lemma rregP x : reflect (rreg x) (x != 0).\nProof. by apply: (iffP idP) => [/mulIf | /rreg_neq0]. Qed.",
    "Lemma IdomainMixin (R : unitRingType): Field.axiom R -> IntegralDomain.axiom R.\nProof.\nmove=> m x y xy0; apply/norP=> [[]] /m Ux /m.\nby rewrite -(unitrMr _ Ux) xy0 unitr0.\nQed.",
    "Lemma unitfE x : (x \\in unit) = (x != 0).\nProof. by apply/idP/idP=> [/(memPn _)-> | /fieldP]; rewrite ?unitr0. Qed.",
    "Lemma mulVf x : x != 0 -> x^-1 * x = 1.\nProof. by rewrite -unitfE; apply: mulVr. Qed.",
    "Lemma divff x : x != 0 -> x / x = 1.\nProof. by rewrite -unitfE; apply: divrr. Qed.",
    "Lemma mulKf x : x != 0 -> cancel ( *%R x) ( *%R x^-1).\nProof. by rewrite -unitfE; apply: mulKr. Qed.",
    "Lemma mulVKf x : x != 0 -> cancel ( *%R x^-1) ( *%R x).\nProof. by rewrite -unitfE; apply: mulVKr. Qed.",
    "Lemma mulfK x : x != 0 -> cancel ( *%R^~ x) ( *%R^~ x^-1).\nProof. by rewrite -unitfE; apply: mulrK. Qed.",
    "Lemma mulfVK x : x != 0 -> cancel ( *%R^~ x^-1) ( *%R^~ x).\nProof. by rewrite -unitfE; apply: divrK. Qed.",
    "Lemma invfM : {morph @inv F : x y / x * y}.\nProof.\nmove=> x y; have [->|nzx] := eqVneq x 0; first by rewrite !(mul0r, invr0).\nhave [->|nzy] := eqVneq y 0; first by rewrite !(mulr0, invr0).\nby rewrite mulrC invrM ?unitfE.\nQed.",
    "Lemma invf_div x y : (x / y)^-1 = y / x.\nProof. by rewrite invfM invrK mulrC. Qed.",
    "Lemma divKf x : x != 0 -> involutive (fun y => x / y).\nProof. by move=> nz_x y; rewrite invf_div mulrC divfK. Qed.",
    "Lemma expfB_cond m n x : (x == 0) + n <= m -> x ^+ (m - n) = x ^+ m / x ^+ n.\nProof.\nmove/subnK=> <-; rewrite addnA addnK !exprD.\nhave [-> | nz_x] := eqVneq; first by rewrite !mulr0 !mul0r.\nby rewrite mulfK ?expf_neq0.\nQed.",
    "Lemma expfB m n x : n < m -> x ^+ (m - n) = x ^+ m / x ^+ n.\nProof. by move=> lt_n_m; apply: expfB_cond; case: eqP => // _; apply: ltnW. Qed.",
    "Lemma prodfV I r (P : pred I) (E : I -> F) :\n  \\prod_(i <- r | P i) (E i)^-1 = (\\prod_(i <- r | P i) E i)^-1.\nProof. by rewrite (big_morph _ invfM (invr1 F)). Qed.",
    "Lemma prodf_div I r (P : pred I) (E D : I -> F) :\n  \\prod_(i <- r | P i) (E i / D i) =\n     \\prod_(i <- r | P i) E i / \\prod_(i <- r | P i) D i.\nProof. by rewrite big_split prodfV. Qed.",
    "Lemma telescope_prodf n m (f : nat -> F) :\n    (forall k, n < k < m -> f k != 0) -> n < m ->\n  \\prod_(n <= k < m) (f k.+1 / f k) = f m / f n.\nProof.\nmove=> nz_f ltnm; apply: invr_inj; rewrite prodf_div !invf_div -prodf_div.\nby apply: telescope_prodr => // k /nz_f; rewrite unitfE.\nQed.",
    "Lemma telescope_prodf_eq n m (f u : nat -> F) :\n    (forall k, n < k < m -> f k != 0) -> n < m ->\n    (forall k, n <= k < m -> u k = f k.+1 / f k) ->\n  \\prod_(n <= k < m) u k = f m / f n.\nProof.\nby move=> ? ? uE; under eq_big_nat do rewrite uE //=; exact: telescope_prodf.\nQed.",
    "Lemma addf_div x1 y1 x2 y2 :\n  y1 != 0 -> y2 != 0 -> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) / (y1 * y2).\nProof. by move=> nzy1 nzy2; rewrite invfM mulrDl !mulrA mulrAC !mulfK. Qed.",
    "Lemma mulf_div x1 y1 x2 y2 : (x1 / y1) * (x2 / y2) = (x1 * x2) / (y1 * y2).\nProof. by rewrite mulrACA -invfM. Qed.",
    "Lemma eqr_div x y z t : y != 0 -> t != 0 -> (x / y == z / t) = (x * t == z * y).\nProof.\nmove=> yD0 tD0; rewrite -[x in RHS](divfK yD0) -[z in RHS](divfK tD0) mulrAC.\nby apply/eqP/eqP => [->|/(mulIf yD0)/(mulIf tD0)].\nQed.",
    "Lemma eqr_sum_div I r P (f : I -> F) c a : c != 0 ->\n  \\big[+%R/0]_(x <- r | P x) (f x / c) == a\n  = (\\big[+%R/0]_(x <- r | P x) f x == a * c).\nProof.\nby move=> ?; rewrite -mulr_suml -(divr1 a) eqr_div ?oner_eq0// mulr1 divr1.\nQed.",
    "Lemma pchar0_natf_div :\n  pchar F =i pred0 -> forall m d, d %| m -> (m %/ d)%:R = m%:R / d%:R :> F.\nProof.\nmove/pcharf0P=> pchar0F m [|d] d_dv_m; first by rewrite divn0 invr0 mulr0.\nby rewrite natr_div // unitfE pchar0F.\nQed.",
    "Lemma fmorph_eq0 x : (f x == 0) = (x == 0).\nProof.\nhave [-> | nz_x] := eqVneq x; first by rewrite rmorph0 eqxx.\napply/eqP; move/(congr1 ( *%R (f x^-1)))/eqP.\nby rewrite -rmorphM mulVf // mulr0 rmorph1 ?oner_eq0.\nQed.",
    "Lemma fmorph_inj : injective f.\nProof. by apply/raddf_inj => x /eqP; rewrite fmorph_eq0 => /eqP. Qed.",
    "Lemma fmorph_eq : {mono f : x y / x == y}.\nProof. exact: inj_eq fmorph_inj. Qed.",
    "Lemma fmorph_eq1 x : (f x == 1) = (x == 1).\nProof. by rewrite -(inj_eq fmorph_inj) rmorph1. Qed.",
    "Lemma fmorph_pchar : pchar R =i pchar F.\nProof. by move=> p; rewrite !inE -fmorph_eq0 rmorph_nat. Qed.",
    "Lemma fmorph_unit x : (f x \\in unit) = (x != 0).\nProof.\nhave [-> |] := eqVneq x; first by rewrite rmorph0 unitr0.\nby rewrite -unitfE; apply: rmorph_unit.\nQed.",
    "Lemma fmorphV : {morph f: x / x^-1}.\nProof.\nmove=> x; have [-> | nz_x] := eqVneq x 0; first by rewrite !(invr0, rmorph0).\nby rewrite rmorphV ?unitfE.\nQed.",
    "Lemma fmorph_div : {morph f : x y / x / y}.\nProof. by move=> x y; rewrite rmorphM /= fmorphV. Qed.",
    "Lemma scalerK a : a != 0 -> cancel ( *:%R a : V -> V) ( *:%R a^-1).\nProof. by move=> nz_a v; rewrite scalerA mulVf // scale1r. Qed.",
    "Lemma scalerKV a : a != 0 -> cancel ( *:%R a^-1 : V -> V) ( *:%R a).\nProof. by rewrite -invr_eq0 -{3}[a]invrK; apply: scalerK. Qed.",
    "Lemma scalerI a : a != 0 -> injective ( *:%R a : V -> V).\nProof. by move=> nz_a; apply: can_inj (scalerK nz_a). Qed.",
    "Lemma scaler_eq0 a v : (a *: v == 0) = (a == 0) || (v == 0).\nProof.\nhave [-> | nz_a] := eqVneq a; first by rewrite scale0r eqxx.\nby rewrite (can2_eq (scalerK nz_a) (scalerKV nz_a)) scaler0.\nQed.",
    "Lemma pchar_lalg (A : lalgType F) : pchar A =i pchar F.\nProof. by move=> p; rewrite inE -scaler_nat scaler_eq0 oner_eq0 orbF. Qed.",
    "Lemma size_sol n f : size (sol n f) = n.\nProof.\nrewrite /sol; case: sol_subproof => [sP | _]; last exact: size_nseq.\nby case/andP: (xchooseP sP) => /eqP.\nQed.",
    "Lemma solP n f : reflect (exists2 s, size s = n & holds s f) (sat (sol n f) f).\nProof.\nrewrite /sol; case: sol_subproof => [sP | sPn].\n  case/andP: (xchooseP sP) => _ ->; left.\n  by case: sP => s; case/andP; move/eqP=> <-; move/satP; exists s.\napply: (iffP (satP _ _)); first by exists (nseq n 0); rewrite ?size_nseq.\nby case=> s sz_s; move/satP=> f_s; case: sPn; exists s; rewrite sz_s eqxx.\nQed.",
    "Lemma eq_sat f1 f2 :\n  (forall e, holds e f1 <-> holds e f2) -> sat^~ f1 =1 sat^~ f2.\nProof. by move=> eqf12 e; apply/satP/satP; case: (eqf12 e). Qed.",
    "Lemma eq_sol f1 f2 :\n  (forall e, holds e f1 <-> holds e f2) -> sol^~ f1 =1 sol^~ f2.\nProof.\nrewrite /sol => /eq_sat eqf12 n.\ndo 2![case: sol_subproof] => //= [f1s f2s | ns1 [s f2s] | [s f1s] []].\n- by apply: eq_xchoose => s; rewrite eqf12.\n- by case: ns1; exists s; rewrite -eqf12.\nby exists s; rewrite eqf12.\nQed.",
    "Lemma quantifier_elim_wf f :\n  let qf := quantifier_elim f in rformula f -> qf_form qf && rformula qf.\nProof.\nsuffices aux_wf f0 n : let qf := elim_aux f0 n in\n  rformula f0 -> qf_form qf && rformula qf.\n- by elim: f => //=; do ?[  move=> f1 IH1 f2 IH2;\n                     case/andP=> rf1 rf2;\n                     case/andP:(IH1 rf1)=> -> ->;\n                     case/andP:(IH2 rf2)=> -> -> //\n                  |  move=> n f1 IH rf1;\n                     case/andP: (IH rf1)=> qff rf;\n                     rewrite aux_wf ].\nrewrite /elim_aux => rf.\nsuffices or_wf fs : let ofs := foldr Or False fs in\n  all (@qf_form F) fs && all (@rformula F) fs -> qf_form ofs && rformula ofs.\n- apply: or_wf.\n  suffices map_proj_wf bcs: let mbcs := map (proj n) bcs in\n    all dnf_rterm bcs -> all (@qf_form _) mbcs && all (@rformula _) mbcs.\n    by apply/map_proj_wf/qf_to_dnf_rterm.\n  elim: bcs => [|bc bcs ihb] bcsr //= /andP[rbc rbcs].\n  by rewrite andbAC andbA wf_proj //= andbC ihb.\nelim: fs => //= g gs ihg; rewrite -andbA => /and4P[-> qgs -> rgs] /=.\nby apply: ihg; rewrite qgs rgs.\nQed.",
    "Lemma quantifier_elim_rformP e f :\n  rformula f -> reflect (holds e f) (qf_eval e (quantifier_elim f)).\nProof.\npose rc e n f := exists x, qf_eval (set_nth 0 e n x) f.\nhave auxP f0 e0 n0: qf_form f0 && rformula f0 ->\n  reflect (rc e0 n0 f0) (qf_eval e0 (elim_aux f0 n0)).\n+ rewrite /elim_aux => cf; set bcs := qf_to_dnf f0 false.\n  apply: (@iffP (rc e0 n0 (dnf_to_form bcs))); last first.\n  - by case=> x; rewrite -qf_to_dnfP //; exists x.\n  - by case=> x; rewrite qf_to_dnfP //; exists x.\n  have: all dnf_rterm bcs by case/andP: cf => _; apply: qf_to_dnf_rterm.\n  elim: {f0 cf}bcs => [|bc bcs IHbcs] /=; first by right; case.\n  case/andP=> r_bc /IHbcs {IHbcs}bcsP.\n  have f_qf := dnf_to_form_qf [:: bc].\n  case: ok_proj => //= [ex_x|no_x].\n    left; case: ex_x => x /(qf_evalP _ f_qf); rewrite /= orbF => bc_x.\n    by exists x; rewrite /= bc_x.\n  apply: (iffP bcsP) => [[x bcs_x] | [x]] /=.\n    by exists x; rewrite /= bcs_x orbT.\n  case/orP => [bc_x|]; last by exists x.\n  by case: no_x; exists x; apply/(qf_evalP _ f_qf); rewrite /= bc_x.\nelim: f e => //.\n- by move=> b e _; apply: idP.\n- by move=> t1 t2 e _; apply: eqP.\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; last by right; case.\n  by case/IH2; [left | right; case].\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; first by do 2!left.\n  by case/IH2; [left; right | right; case].\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; last by left.\n  by case/IH2; [left | right; move/(_ f1e)].\n- by move=> f IHf e /= /IHf[]; [right | left].\n- move=> n f IHf e /= rf; have rqf := quantifier_elim_wf rf.\n  by apply: (iffP (auxP _ _ _ rqf)) => [] [x]; exists x; apply/IHf.\nmove=> n f IHf e /= rf; have rqf := quantifier_elim_wf rf.\ncase: auxP => // [f_x|no_x]; first by right=> no_x; case: f_x => x /IHf[].\nby left=> x; apply/IHf=> //; apply/idPn=> f_x; case: no_x; exists x.\nQed.",
    "Lemma proj_satP : DecidableField.axiom proj_sat.\nProof.\nmove=> e f; have fP := quantifier_elim_rformP e (to_rform_rformula f).\nby apply: (iffP fP); move/to_rformP.\nQed.",
    "Lemma imaginary_exists : {i : F | i ^+ 2 = -1}.\nProof.\nhave /sig_eqW[i Di2] := @solve_monicpoly F 2 (nth 0 [:: -1]) isT.\nby exists i; rewrite Di2 !big_ord_recl big_ord0 mul0r mulr1 !addr0.\nQed.",
    "Lemma lalgMixin (R : pzRingType) (A : lalgType R) (B : lmodType R) (f : B -> A) :\n     phant B -> injective f -> scalable f ->\n   forall mulB, {morph f : x y / mulB x y >-> x * y} ->\n forall a u v, a *: (mulB u v) = mulB (a *: u) v.\nProof.\nby move=> _ injf fZ mulB fM a x y; apply: injf; rewrite !(fZ, fM) scalerAl.\nQed.",
    "Lemma comRingMixin (R : comPzRingType) (T : pzRingType) (f : T -> R) :\n  phant T -> injective f -> {morph f : x y / x * y} -> commutative (@mul T).\nProof. by move=> _ inj_f fM x y; apply: inj_f; rewrite !fM mulrC. Qed.",
    "Lemma algMixin (R : pzRingType) (A : algType R) (B : lalgType R) (f : B -> A) :\n    phant B -> injective f -> {morph f : x y / x * y} -> scalable f ->\n  forall k (x y : B), k *: (x * y) = x * (k *: y).\nProof.\nby move=> _ inj_f fM fZ a x y; apply: inj_f; rewrite !(fM, fZ) scalerAr.\nQed.",
    "Lemma rpred0 : 0 \\in S.\nProof. by case: (@rpred0D _ S). Qed.",
    "Lemma rpredD : {in S &, forall u v, u + v \\in S}.\nProof. by case: (@rpred0D _ S). Qed.",
    "Lemma rpred_sum I r (P : pred I) F :\n  (forall i, P i -> F i \\in S) -> \\sum_(i <- r | P i) F i \\in S.\nProof. by move=> IH; elim/big_ind: _; [apply: rpred0 | apply: rpredD |]. Qed.",
    "Lemma rpredMn n : {in S, forall u, u *+ n \\in S}.\nProof. by move=> u Su; rewrite -(card_ord n) -sumr_const rpred_sum. Qed.",
    "Lemma rpredN : {mono -%R: u / u \\in S}.\nProof. by move=> u; apply/idP/idP=> /rpredNr; rewrite ?opprK; apply. Qed.",
    "Lemma rpredB : {in S &, forall u v, u - v \\in S}.\nProof. by move=> u v Su Sv; rewrite /= rpredD ?rpredN. Qed.",
    "Lemma rpredBC u v : u - v \\in S = (v - u \\in S).\nProof. by rewrite -rpredN opprB. Qed.",
    "Lemma rpredMNn n : {in S, forall u, u *- n \\in S}.\nProof. by move=> u Su; rewrite /= rpredN rpredMn. Qed.",
    "Lemma rpredDr x y : x \\in S -> (y + x \\in S) = (y \\in S).\nProof.\nmove=> Sx; apply/idP/idP=> [Sxy | /rpredD-> //].\nby rewrite -(addrK x y) rpredB.\nQed.",
    "Lemma rpredDl x y : x \\in S -> (x + y \\in S) = (y \\in S).\nProof. by rewrite addrC; apply: rpredDr. Qed.",
    "Lemma rpredBr x y : x \\in S -> (y - x \\in S) = (y \\in S).\nProof. by rewrite -rpredN; apply: rpredDr. Qed.",
    "Lemma rpredBl x y : x \\in S -> (x - y \\in S) = (y \\in S).\nProof. by rewrite -(rpredN _ y); apply: rpredDl. Qed.",
    "Lemma zmodClosedP : zmod_closed S.\nProof. split; [ exact: rpred0D.1 | exact: rpredB ]. Qed.",
    "Lemma rpred1M : mulr_closed S.\nProof. exact: (conj rpred1 rpredM). Qed.",
    "Lemma rpred_prod I r (P : pred I) F :\n  (forall i, P i -> F i \\in S) -> \\prod_(i <- r | P i) F i \\in S.\nProof. by move=> IH; elim/big_ind: _; [apply: rpred1 | apply: rpredM |]. Qed.",
    "Lemma rpredX n : {in S, forall u, u ^+ n \\in S}.\nProof. by move=> u Su; rewrite -(card_ord n) -prodr_const rpred_prod. Qed.",
    "Lemma rpred_nat (S : semiringClosed R) n : n%:R \\in S.\nProof. by rewrite rpredMn ?rpred1. Qed.",
    "Lemma semiringClosedP (rngS : semiringClosed R) : semiring_closed rngS.\nProof. split; [ exact: rpred0D | exact: rpred1M ]. Qed.",
    "Lemma rpredMsign (S : opprClosed R) n x : ((-1) ^+ n * x \\in S) = (x \\in S).\nProof. by rewrite -signr_odd mulr_sign; case: ifP => // _; rewrite rpredN. Qed.",
    "Lemma rpredN1 (S : smulClosed R) : -1 \\in S.\nProof. by rewrite rpredN rpred1. Qed.",
    "Lemma rpred_sign (S : smulClosed R) n : (-1) ^+ n \\in S.\nProof. by rewrite rpredX ?rpredN1. Qed.",
    "Lemma subringClosedP (rngS : subringClosed R) : subring_closed rngS.\nProof.\nsplit; [ exact: rpred1 | exact: (zmodClosedP rngS).2 | exact: rpredM ].\nQed.",
    "Lemma rpredZnat (S : addrClosed V) n : {in S, forall u, n%:R *: u \\in S}.\nProof. by move=> u Su; rewrite /= scaler_nat rpredMn. Qed.",
    "Lemma subsemimodClosedP (modS : submodClosed V) : subsemimod_closed modS.\nProof. by split; [exact rpred0D | exact: rpredZ]. Qed.",
    "Lemma rpredZsign (S : opprClosed V) n u : ((-1) ^+ n *: u \\in S) = (u \\in S).\nProof. by rewrite -signr_odd scaler_sign fun_if if_arg rpredN if_same. Qed.",
    "Lemma submodClosedP (modS : submodClosed V) : submod_closed modS.\nProof.\nsplit; first exact rpred0D.1.\nby move=> a u v uS vS; apply: rpredD; first exact: rpredZ.\nQed.",
    "Lemma subalgClosedP (algS : subalgClosed A) : subalg_closed algS.\nProof.\nsplit; [ exact: rpred1 | | exact: rpredM ].\nby move=> a u v uS vS; apply: rpredD; first exact: rpredZ.\nQed.",
    "Lemma rpredV x : (x^-1 \\in S) = (x \\in S).\nProof. by apply/idP/idP=> /rpredVr; rewrite ?invrK. Qed.",
    "Lemma rpred_div : {in S &, forall x y, x / y \\in S}.\nProof. by move=> x y Sx Sy; rewrite /= rpredM ?rpredV. Qed.",
    "Lemma rpredXN n : {in S, forall x, x ^- n \\in S}.\nProof. by move=> x Sx; rewrite /= rpredV rpredX. Qed.",
    "Lemma rpredMl x y : x \\in S -> x \\is a unit-> (x * y \\in S) = (y \\in S).\nProof.\nmove=> Sx Ux; apply/idP/idP=> [Sxy | /(rpredM _ _ Sx)-> //].\nby rewrite -(mulKr Ux y); rewrite rpredM ?rpredV.\nQed.",
    "Lemma rpredMr x y : x \\in S -> x \\is a unit -> (y * x \\in S) = (y \\in S).\nProof.\nmove=> Sx Ux; apply/idP/idP=> [Sxy | /rpredM-> //].\nby rewrite -(mulrK Ux y); rewrite rpred_div.\nQed.",
    "Lemma rpred_divr x y : x \\in S -> x \\is a unit -> (y / x \\in S) = (y \\in S).\nProof. by rewrite -rpredV -unitrV; apply: rpredMr. Qed.",
    "Lemma rpred_divl x y : x \\in S -> x \\is a unit -> (x / y \\in S) = (y \\in S).\nProof. by rewrite -(rpredV y); apply: rpredMl. Qed.",
    "Lemma divringClosedP (divS : divringClosed R) : divring_closed divS.\nProof. split; [ exact: rpred1 | exact: rpredB | exact: rpred_div ]. Qed.",
    "Lemma unitrN x : (- x \\is a unit) = (x \\is a unit). Proof. exact: rpredN. Qed.",
    "Lemma invrN x : (- x)^-1 = - x^-1.\nProof.\nhave [Ux | U'x] := boolP (x \\is a unit); last by rewrite !invr_out ?unitrN.\nby rewrite -mulN1r invrM ?unitrN1 // invrN1 mulrN1.\nQed.",
    "Lemma divrNN x y : (- x) / (- y) = x / y.\nProof. by rewrite invrN mulrNN. Qed.",
    "Lemma divrN x y : x / (- y) = - (x / y).\nProof. by rewrite invrN mulrN. Qed.",
    "Lemma invr_signM n x : ((-1) ^+ n * x)^-1 = (-1) ^+ n * x^-1.\nProof. by rewrite -signr_odd !mulr_sign; case: ifP => // _; rewrite invrN. Qed.",
    "Lemma divr_signM (b1 b2 : bool) x1 x2:\n  ((-1) ^+ b1 * x1) / ((-1) ^+ b2 * x2) = (-1) ^+ (b1 (+) b2) * (x1 / x2).\nProof. by rewrite invr_signM mulr_signM. Qed.",
    "Lemma rpredZeq (S : submodClosed V) a v :\n  (a *: v \\in S) = (a == 0) || (v \\in S).\nProof.\nhave [-> | nz_a] := eqVneq; first by rewrite scale0r rpred0.\nby apply/idP/idP; first rewrite -{2}(scalerK nz_a v); apply: rpredZ.\nQed.",
    "Lemma fpredMl x y : x \\in S -> x != 0 -> (x * y \\in S) = (y \\in S).\nProof. by rewrite -!unitfE; apply: rpredMl. Qed.",
    "Lemma fpredMr x y : x \\in S -> x != 0 -> (y * x \\in S) = (y \\in S).\nProof. by rewrite -!unitfE; apply: rpredMr. Qed.",
    "Lemma fpred_divl x y : x \\in S -> x != 0 -> (x / y \\in S) = (y \\in S).\nProof. by rewrite -!unitfE; apply: rpred_divl. Qed.",
    "Lemma fpred_divr x y : x \\in S -> x != 0 -> (y / x \\in S) = (y \\in S).\nProof. by rewrite -!unitfE; apply: rpred_divr. Qed.",
    "Lemma valD : {morph val : x y / x + y}. Proof. exact: raddfD. Qed.",
    "Lemma val0 : val 0 = 0. Proof. exact: raddf0. Qed.",
    "Lemma addUA : associative addU.\nProof. by move=> x y z; apply/val_inj; rewrite !SubK addrA. Qed.",
    "Lemma addUC : commutative addU.\nProof. by move=> x y; apply/val_inj; rewrite !SubK addrC. Qed.",
    "Lemma add0U : left_id zeroU addU.\nProof. by move=> x; apply/val_inj; rewrite !SubK add0r. Qed.",
    "Lemma val0 : (val : U -> V) 0 = 0. Proof. by rewrite !SubK. Qed.",
    "Lemma valD : semi_additive (val : U -> V).\nProof. by split=> [|x y]; rewrite !SubK. Qed.",
    "Lemma valB : {morph val : x y / x - y}. Proof. exact: raddfB. Qed.",
    "Lemma valN : {morph val : x / - x}. Proof. exact: raddfN. Qed.",
    "Lemma addNr : left_inverse zeroU oppU addU.\nProof. by move=> x; apply: val_inj; rewrite !SubK addNr. Qed.",
    "Lemma valD : semi_additive (val : U -> V).\nProof. by split=> [|x y]; rewrite !SubK. Qed.",
    "Lemma valB : additive (val : U -> V).\nProof. by move=> x y; rewrite !SubK. Qed.",
    "Lemma val1 : val 1 = 1. Proof. exact: rmorph1. Qed.",
    "Lemma valM : {morph val : x y / x * y}. Proof. exact: rmorphM. Qed.",
    "Lemma valM1 : multiplicative val. Proof. exact: valM_subproof. Qed.",
    "Lemma mulrA : associative mulU.\nProof. by move=> x y z; apply: val_inj; rewrite !SubK mulrA. Qed.",
    "Lemma mul1r : left_id oneU mulU.\nProof. by move=> x; apply: val_inj; rewrite !SubK mul1r. Qed.",
    "Lemma mulr1 : right_id oneU mulU.\nProof. by move=> x; apply: val_inj; rewrite !SubK mulr1. Qed.",
    "Lemma mulrDl : left_distributive mulU +%R.\nProof.\nby move=> x y z; apply: val_inj; rewrite !(SubK, raddfD)/= !SubK mulrDl.\nQed.",
    "Lemma mulrDr : right_distributive mulU +%R.\nProof.\nby move=> x y z; apply: val_inj; rewrite !(SubK, raddfD)/= !SubK mulrDr.\nQed.",
    "Lemma mul0r : left_zero 0%R mulU.\nProof. by move=> x; apply: val_inj; rewrite SubK val0 mul0r. Qed.",
    "Lemma mulr0 : right_zero 0%R mulU.\nProof. by move=> x; apply: val_inj; rewrite SubK val0 mulr0. Qed.",
    "Lemma valM : multiplicative (val : U -> R).\nProof. by split=> [x y|] /=; rewrite !SubK. Qed.",
    "Lemma oner_neq0 : (1 : U) != 0.\nProof. by rewrite -(inj_eq val_inj) SubK raddf0 oner_neq0. Qed.",
    "Lemma mulrC : @commutative U U *%R.\nProof. by move=> x y; apply: val_inj; rewrite !rmorphM mulrC. Qed.",
    "Lemma mulrC : @commutative U U *%R.\nProof. by move=> x y; apply: val_inj; rewrite !rmorphM mulrC. Qed.",
    "Lemma scalerA' a b v : scaleW a (scaleW b v) = scaleW (a * b) v.\nProof. by apply: val_inj; rewrite !SubK scalerA. Qed.",
    "Lemma scale0r v : scaleW 0 v = 0.\nProof. by apply: val_inj; rewrite SubK scale0r raddf0. Qed.",
    "Lemma scale1r : left_id 1 scaleW.\nProof. by move=> x; apply: val_inj; rewrite SubK scale1r. Qed.",
    "Lemma scalerDr : right_distributive scaleW +%R.\nProof.\nby move=> a u v; apply: val_inj; rewrite !(SubK, raddfD)/= !SubK.\nQed.",
    "Lemma scalerDl v : {morph scaleW^~ v : a b / a + b}.\nProof.\nby move=> a b; apply: val_inj; rewrite !(SubK, raddfD)/= !SubK scalerDl.\nQed.",
    "Lemma scalerAl (a : R) (u v : W) : a *: (u * v) = a *: u * v.\nProof. by apply: val_inj; rewrite !(linearZ, rmorphM) /= linearZ scalerAl. Qed.",
    "Lemma scalerAr (k : R) (x y : W) : k *: (x * y) = x * (k *: y).\nProof. by apply: val_inj; rewrite !(linearZ, rmorphM)/= linearZ scalerAr. Qed.",
    "Lemma mulVr : {in [pred x | val x \\is a unit], left_inverse 1 invU *%R}.\nProof.\nby move=> x /[!inE] xu; apply: val_inj; rewrite rmorphM rmorph1 /= SubK mulVr.\nQed.",
    "Lemma divrr : {in [pred x | val x \\is a unit], right_inverse 1 invU *%R}.\nProof.\nby move=> x /[!inE] xu; apply: val_inj; rewrite rmorphM rmorph1 /= SubK mulrV.\nQed.",
    "Lemma unitrP (x y : U) : y * x = 1 /\\ x * y = 1 -> val x \\is a unit.\nProof.\nmove=> -[/(congr1 val) yx1 /(congr1 val) xy1].\nby apply: rev_unitrP (val y) _; rewrite !rmorphM rmorph1 /= in yx1 xy1.\nQed.",
    "Lemma invr_out : {in [pred x | val x \\isn't a unit], invU =1 id}.\nProof.\nby move=> x /[!inE] xNU; apply: val_inj; rewrite SubK invr_out.\nQed.",
    "Lemma id : IntegralDomain.axiom U.\nProof.\nmove=> x y /(congr1 val)/eqP; rewrite rmorphM /=.\nby rewrite -!(inj_eq val_inj) rmorph0 -mulf_eq0.\nQed.",
    "Lemma fieldP : Field.axiom U.\nProof.\nby move=> u; rewrite -(inj_eq val_inj) rmorph0 -unitfE subfield_subproof.\nQed.",
    "Lemma sum_ffunE x : (\\sum_(i <- r | P i) F i) x = \\sum_(i <- r | P i) F i x.\nProof. by elim/big_rec2: _ => // [|i _ y _ <-]; rewrite !ffunE. Qed.",
    "Lemma sum_ffun :\n  \\sum_(i <- r | P i) F i = [ffun x => \\sum_(i <- r | P i) F i x].\nProof. by apply/ffunP=> i; rewrite sum_ffunE ffunE. Qed.",
    "Lemma ffunMnE f n x : (f *+ n) x = f x *+ n.\nProof. by rewrite -[n]card_ord -!sumr_const sum_ffunE. Qed.",
    "Lemma pair_mulVl : {in pair_unitr, left_inverse 1 pair_invr *%R}.\nProof.\nrewrite /pair_invr=> x; case: ifP => // /andP[Ux1 Ux2] _.\nby congr (_, _); apply: mulVr.\nQed.",
    "Lemma pair_mulVr : {in pair_unitr, right_inverse 1 pair_invr *%R}.\nProof.\nrewrite /pair_invr=> x; case: ifP => // /andP[Ux1 Ux2] _.\nby congr (_, _); apply: mulrV.\nQed.",
    "Lemma pair_unitP x y : y * x = 1 /\\ x * y = 1 -> x \\is a pair_unitr.\nProof.\ncase=> [[y1x y2x] [x1y x2y]]; apply/andP.\nby split; apply/unitrP; [exists y.1 | exists y.2].\nQed.",
    "Lemma pair_invr_out : {in [predC pair_unitr], pair_invr =1 id}.\nProof. by rewrite /pair_invr => x /negPf/= ->. Qed.",
    "Lemma pairMnE (M1 M2 : zmodType) (x : M1 * M2) n :\n  x *+ n = (x.1 *+ n, x.2 *+ n).\nProof. by case: x => x y; elim: n => //= n; rewrite !mulrS => ->. Qed.",
    "Lemma bool_fieldP : Field.axiom bool. Proof. by []. Qed.",
    "Lemma natr0E : 0 = 0%N. Proof. by []. Qed.",
    "Lemma natr1E : 1 = 1%N. Proof. by []. Qed.",
    "Lemma natn n : n%:R = n.\nProof. by elim: n => [//|n IHn]; rewrite -nat1r IHn. Qed.",
    "Lemma natrDE n m : n + m = (n + m)%N. Proof. by []. Qed.",
    "Lemma natrME n m : n * m = (n * m)%N. Proof. by []. Qed.",
    "Lemma natrXE n m : n ^+ m = (n ^ m)%N. Proof. by []. Qed.",
    "Lemma pi_is_additive : additive \\pi_Q.\nProof. by move=> x y /=; rewrite !piE. Qed.",
    "Lemma pi_is_multiplicative : multiplicative \\pi_Q.\nProof. by split; do ?move=> x y /=; rewrite !piE. Qed.",
    "Lemma idealr_closed_nontrivial R S : @idealr_closed R S -> proper_ideal S.\nProof. by case=> S0 S1 hS; split => // a x xS; rewrite -[_ * _]addr0 hS. Qed.",
    "Lemma idealr_closedB R S : @idealr_closed R S -> zmod_closed S.\nProof. by case=> S0 _ hS; split=> // x y xS yS; rewrite -mulN1r addrC hS. Qed.",
    "Lemma idealr1 : 1 \\in I = false.\nProof. apply: negPf; exact: proper_ideal_subproof.1. Qed.",
    "Lemma idealMr a u : u \\in I -> a * u \\in I.\nProof. exact: proper_ideal_subproof.2. Qed.",
    "Lemma idealr0 : 0 \\in I. Proof. exact: rpred0. Qed.",
    "Lemma prime_idealrM u v : (u * v \\in I) = (u \\in I) || (v \\in I).\nProof.\napply/idP/idP; last by case/orP => /idealMr hI; rewrite // mulrC.\nexact: prime_idealr_closed_subproof.\nQed.",
    "Lemma equivE x y : (equiv x y) = (x - y \\in I). Proof. by []. Qed.",
    "Lemma equiv_is_equiv : equiv_class_of equiv.\nProof.\nsplit=> [x|x y|y x z]; rewrite !equivE ?subrr ?rpred0 //.\n   by rewrite -opprB rpredN.\nby move=> *; rewrite -[x](addrNK y) -addrA rpredD.\nQed.",
    "Lemma idealrBE x y : (x - y) \\in I = (x == y %[mod quot]).\nProof. by rewrite piE equivE. Qed.",
    "Lemma idealrDE x y : (x + y) \\in I = (x == - y %[mod quot]).\nProof. by rewrite -idealrBE opprK. Qed.",
    "Lemma pi_opp : {morph \\pi : x / - x >-> opp x}.\nProof.\nmove=> x; unlock opp; apply/eqP; rewrite piE equivE.\nby rewrite -opprD rpredN idealrDE opprK reprK.\nQed.",
    "Lemma pi_add : {morph \\pi : x y / x + y >-> add x y}.\nProof.\nmove=> x y /=; unlock add; apply/eqP; rewrite piE equivE.\nrewrite opprD addrAC addrA -addrA.\nby rewrite rpredD // (idealrBE, idealrDE) ?pi_opp ?reprK.\nQed.",
    "Lemma addqA: associative add.\nProof. by move=> x y z; rewrite -[x]reprK -[y]reprK -[z]reprK !piE addrA. Qed.",
    "Lemma addqC: commutative add.\nProof. by move=> x y; rewrite -[x]reprK -[y]reprK !piE addrC. Qed.",
    "Lemma add0q: left_id zero add.\nProof. by move=> x; rewrite -[x]reprK !piE add0r. Qed.",
    "Lemma addNq: left_inverse zero opp add.\nProof. by move=> x; rewrite -[x]reprK !piE addNr. Qed.",
    "Lemma pi_mul: {morph \\pi : x y / x * y >-> mul x y}.\nProof.\nmove=> x y; unlock mul; apply/eqP; rewrite piE equivE.\nrewrite -[_ * _](addrNK (x * repr (\\pi_{quot idealI} y))) -mulrBr.\nrewrite -addrA -mulrBl rpredD //.\n  by rewrite idealMr // idealrDE opprK reprK.\nby rewrite mulrC idealMr // idealrDE opprK reprK.\nQed.",
    "Lemma mulqA: associative mul.\nProof. by move=> x y z; rewrite -[x]reprK -[y]reprK -[z]reprK !piE mulrA. Qed.",
    "Lemma mulqC: commutative mul.\nProof. by move=> x y; rewrite -[x]reprK -[y]reprK !piE mulrC. Qed.",
    "Lemma mul1q: left_id one mul.\nProof. by move=> x; rewrite -[x]reprK !piE mul1r. Qed.",
    "Lemma mulq_addl: left_distributive mul +%R.\nProof.\nmove=> x y z; rewrite -[x]reprK -[y]reprK -[z]reprK.\nby apply/eqP; rewrite piE /= mulrDl equiv_refl.\nQed.",
    "Lemma nonzero1q: one != 0.\nProof. by rewrite piE equivE subr0 idealr1. Qed.",
    "Lemma rquot_IdomainAxiom (x y : {quot I}): x * y = 0 -> (x == 0) || (y == 0).\nProof.\nby move=> /eqP; rewrite -[x]reprK -[y]reprK !piE !equivE !subr0 prime_idealrM.\nQed.",
    "Lemma npoly_submod_closed : submod_closed poly_of_size.\nProof.\nsplit=> [|x p q sp sq]; rewrite qualifE/= ?size_polyC ?eqxx//.\nrewrite (leq_trans (size_polyD _ _)) // geq_max.\nby rewrite (leq_trans (size_scale_leq _ _)).\nQed.",
    "Lemma npoly_is_a_poly_of_size (p : npoly) : val p \\is a poly_of_size n.\nProof. by case: p. Qed.",
    "Lemma size_npoly (p : npoly) : size p <= n.\nProof. exact: npoly_is_a_poly_of_size. Qed.",
    "Lemma npoly_rV_K : cancel npoly_rV rVnpoly.\nProof.\nmove=> p /=; apply/val_inj.\nby rewrite val_insubd [_ \\is a _]size_poly ?poly_rV_K.\nQed.",
    "Lemma rVnpolyK : cancel rVnpoly npoly_rV.\nProof. by move=> p /=; rewrite val_insubd [_ \\is a _]size_poly rVpolyK. Qed.",
    "Lemma npoly_vect_axiom : Vector.axiom n npoly.\nProof. by exists npoly_rV; [exact:linearPZ | exists rVnpoly]. Qed.",
    "Lemma polyn_is_linear : linear (@polyn _ _ : {poly_n R} -> _).\nProof. by []. Qed.",
    "Lemma npolyP (p q : {poly_n R}) : nth 0 p =1 nth 0 q <-> p = q.\nProof. by split => [/polyP/val_inj|->]. Qed.",
    "Lemma coef_npolyp (p : {poly R}) i : (npolyp p)`_i = if i < n then p`_i else 0.\nProof. by rewrite /npolyp unlock /= coef_poly. Qed.",
    "Lemma big_coef_npoly (p : {poly_n R}) i : n <= i -> p`_i = 0.\nProof.\nby move=> i_big; rewrite nth_default // (leq_trans _ i_big) ?size_npoly.\nQed.",
    "Lemma npolypK (p : {poly R}) : size p <= n -> npolyp p = p :> {poly R}.\nProof.\nmove=> spn; apply/polyP=> i; rewrite coef_npolyp.\nby have [i_big|i_small] // := ltnP; rewrite nth_default ?(leq_trans spn).\nQed.",
    "Lemma coefn_sum (I : Type) (r : seq I) (P : pred I)\n  (F : I -> {poly_n R}) (k : nat) :\n  (\\sum_(i <- r | P i) F i)`_k = \\sum_(i <- r | P i) (F i)`_k.\nProof. by rewrite !raddf_sum //= coef_sum. Qed.",
    "Lemma npoly_enum_uniq : uniq npoly_enum.\nProof.\nrewrite /npoly_enum; case: n=> [|k] //.\nrewrite pmap_sub_uniq // map_inj_uniq => [|f g eqfg]; rewrite ?enum_uniq //.\napply/ffunP => /= i; have /(congr1 (fun p : {poly _} => p`_i)) := eqfg.\nby rewrite !coef_poly ltn_ord inord_val.\nQed.",
    "Lemma mem_npoly_enum p : p \\in npoly_enum.\nProof.\nrewrite /npoly_enum; case: n => [|k] // in p *.\n  case: p => [p sp] /=.\n  by rewrite in_cons -val_eqE /= -size_poly_leq0 [size _ <= _]sp.\nrewrite mem_pmap_sub; apply/mapP.\neexists [ffun i : 'I__ => p`_i]; first by rewrite mem_enum.\napply/polyP => i; rewrite coef_poly.\nhave [i_small|i_big] := ltnP; first by rewrite ffunE /= inordK.\nby rewrite nth_default // 1?(leq_trans _ i_big) // size_npoly.\nQed.",
    "Lemma card_npoly : #|{poly_n R}| = (#|R| ^ n)%N.\nProof.\nrewrite -(card_imset _ (can_inj (@npoly_rV_K _ _))) eq_cardT.\n  by rewrite -cardT /= card_mx mul1n.\nby move=> v; apply/imsetP; exists (rVnpoly v); rewrite ?rVnpolyK //.\nQed.",
    "Lemma irreducibleP : reflect (irreducible_poly p) irreducibleb.\nProof.\nrewrite /irreducibleb /irreducible_poly.\napply: (iffP idP) => [/andP[sp /'forall_implyP /= Fp]|[sp Fpoly]].\n  have sp_gt0 : size p > 0 by case: size sp.\n  have p_neq0 : p != 0 by rewrite -size_poly_eq0; case: size sp.\n  split => // q sq_neq1 dvd_qp; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  apply: contraNT sq_neq1; rewrite -ltnNge => sq_lt_sp.\n  have q_small: (size q <= (size p).-1)%N by rewrite -ltnS prednK.\n  rewrite Pdiv.Idomain.dvdpE in dvd_qp.\n  have /= := Fp (NPoly q_small) dvd_qp.\n  rewrite leq_eqVlt ltnS => /orP[//|]; rewrite size_poly_leq0 => /eqP q_eq0.\n  by rewrite -Pdiv.Idomain.dvdpE q_eq0 dvd0p (negPf p_neq0) in dvd_qp.\nhave sp_gt0 : size p > 0 by case: size sp.\nrewrite sp /=; apply/'forall_implyP => /= q.\nrewrite -Pdiv.Idomain.dvdpE=> dvd_qp.\nhave [/eqP->//|/Fpoly/(_ dvd_qp)/eqp_size sq_eq_sp] := boolP (size q == 1%N).\nby have := size_npoly q; rewrite sq_eq_sp -ltnS prednK ?ltnn.\nQed.",
    "Lemma dim_polyn : \\dim (fullv : {vspace {poly_n K}}) = n.\nProof. by rewrite [LHS]mxrank_gen mxrank1. Qed.",
    "Lemma npolyXE (i : 'I_n) : 'nX^i = 'X^i :> {poly _}.\nProof. by rewrite tnth_map tnth_ord_tuple npolypK // size_polyXn. Qed.",
    "Lemma nth_npolyX (i : 'I_n) : npolyX`_i = 'nX^i.\nProof. by rewrite -tnth_nth. Qed.",
    "Lemma npolyX_free : free npolyX.\nProof.\napply/freeP=> u /= sum_uX_eq0 i; have /npolyP /(_ i) := sum_uX_eq0.\nrewrite (@big_morph _ _ _ 0%R +%R) // coef_sum coef0.\nrewrite (bigD1 i) ?big1 /= ?addr0 ?coefZ ?(nth_map 0%N) ?size_iota //.\n  by rewrite nth_npolyX npolyXE coefXn eqxx mulr1.\nmove=> j; rewrite -val_eqE /= => neq_ji.\nby rewrite nth_npolyX npolyXE coefZ coefXn eq_sym (negPf neq_ji) mulr0.\nQed.",
    "Lemma npolyX_full : basis_of fullv npolyX.\nProof.\nby rewrite basisEfree npolyX_free subvf size_map size_enum_ord dim_polyn /=.\nQed.",
    "Lemma npolyX_coords (p : {poly_n K}) i : coord npolyX i p = p`_i.\nProof.\nrewrite [p in RHS](coord_basis npolyX_full) ?memvf // coefn_sum.\nrewrite (bigD1 i) //= coefZ nth_npolyX npolyXE coefXn eqxx mulr1 big1 ?addr0//.\nmove=> j; rewrite -val_eqE => /= neq_ji.\nby rewrite coefZ nth_npolyX npolyXE coefXn eq_sym (negPf neq_ji) mulr0.\nQed.",
    "Lemma npolyX_gen (p : {poly K}) : (size p <= n)%N ->\n  p = \\sum_(i < n) p`_i *: 'nX^i.\nProof.\nmove=> sp; rewrite -[p](@npolypK _ n) //.\nrewrite [npolyp _ _ in LHS](coord_basis npolyX_full) ?memvf //.\nrewrite (@big_morph _ _ _ 0%R +%R) // !raddf_sum.\nby apply: eq_bigr=> i _; rewrite npolyX_coords //= nth_npolyX npolyXE.\nQed.",
    "Lemma lagrangeE i : lagrange_ i = lagrange_def i :> {poly _}.\nProof.\nrewrite [lagrange]unlock tnth_map.\nby rewrite [val _]npolypK tnth_ord_tuple // size_lagrange_def.\nQed.",
    "Lemma nth_lagrange (i : 'I_n) : lagrange`_i = lagrange_ i.\nProof. by rewrite -tnth_nth. Qed.",
    "Lemma size_lagrange_ i : size (lagrange_ i) = n.\nProof. by rewrite lagrangeE size_lagrange_def. Qed.",
    "Lemma size_lagrange : size lagrange = n.\nProof. by rewrite size_tuple. Qed.",
    "Lemma lagrange_sample (i j : 'I_n) : (lagrange_ i).[x j] = (i == j)%:R.\nProof. by rewrite lagrangeE lagrange_def_sample. Qed.",
    "Lemma lagrange_free : free lagrange.\nProof.\napply/freeP=> lambda eq_l i.\nhave /(congr1 (fun p : {poly__ _} => p.[x i])) := eq_l.\nrewrite (@big_morph _ _ _ 0%R +%R) // horner_sum horner0.\nrewrite (bigD1 i) // big1 => [|j /= /negPf ji] /=;\nby rewrite ?hornerE nth_lagrange lagrange_sample ?eqxx ?ji ?mulr1 ?mulr0.\nQed.",
    "Lemma lagrange_full : basis_of fullv lagrange.\nProof.\nby rewrite basisEfree lagrange_free subvf size_lagrange dim_polyn /=.\nQed.",
    "Lemma lagrange_coords (p : {poly_n K}) i : coord lagrange i p = p.[x i].\nProof.\nrewrite [p in RHS](coord_basis lagrange_full) ?memvf //.\nrewrite (@big_morph _ _ _ 0%R +%R) // horner_sum.\nrewrite (bigD1 i) // big1 => [|j /= /negPf ji] /=;\nby rewrite ?hornerE nth_lagrange lagrange_sample ?eqxx ?ji ?mulr1 ?mulr0.\nQed.",
    "Lemma lagrange_gen (p : {poly K}) : (size p <= n)%N ->\n  p = \\sum_(i < n) p.[x i]%:P * lagrange_ i.\nProof.\nmove=> sp; rewrite -[p](@npolypK _ n) //.\nrewrite [npolyp _ _ in LHS](coord_basis lagrange_full) ?memvf //.\nrewrite (@big_morph _ _ _ 0%R +%R) //; apply: eq_bigr=> i _.\nby rewrite lagrange_coords mul_polyC nth_lagrange.\nQed.",
    "Lemma monic_mk_monic : (mk_monic h) \\is monic.\nProof.\nrewrite /mk_monic; case: leqP=> [_|/=]; first by apply: monicX.\nby case E : (h \\is monic) => [->//|] => _; apply: monicX.\nQed.",
    "Lemma size_mk_monic_gt1 : (1 < size (mk_monic h))%N.\nProof. \nby rewrite !fun_if size_polyX; case: leqP => //=; rewrite if_same.\nQed.",
    "Lemma size_mk_monic_gt0 : (0 < size (mk_monic h))%N.\nProof. by rewrite (leq_trans _ size_mk_monic_gt1). Qed.",
    "Lemma mk_monic_neq0 : mk_monic h != 0.\nProof. by rewrite -size_poly_gt0 size_mk_monic_gt0. Qed.",
    "Lemma size_mk_monic (p : {poly %/ h}) : size p < size (mk_monic h).\nProof.\nhave: (p : {poly R}) \\is a poly_of_size (size (mk_monic h)).-1 by case: p.\nby rewrite qualifE/= -ltnS prednK // size_mk_monic_gt0.\nQed.",
    "Lemma poly_of_size_mod p :\n  rmodp p (mk_monic h) \\is a poly_of_size (size (mk_monic h)).-1.\nProof.\nrewrite qualifE/= -ltnS prednK ?size_mk_monic_gt0 //.\nby apply: ltn_rmodpN0; rewrite mk_monic_neq0.\nQed.",
    "Lemma in_qpoly_small (p : {poly R}) :\n  size p < size (mk_monic h) -> in_qpoly p = p :> {poly R}.\nProof. exact: rmodp_small. Qed.",
    "Lemma in_qpoly0 : in_qpoly 0 = 0.\nProof. by apply/val_eqP; rewrite /= rmod0p. Qed.",
    "Lemma in_qpolyD p q : in_qpoly (p + q) = in_qpoly p + in_qpoly q.\nProof. by apply/val_eqP=> /=; rewrite rmodpD ?monic_mk_monic. Qed.",
    "Lemma in_qpolyZ a p : in_qpoly (a *: p) = a *: in_qpoly p.\nProof. apply/val_eqP=> /=; rewrite rmodpZ ?monic_mk_monic //. Qed.",
    "Lemma qpolyC_proof k :\n  (k%:P : {poly R}) \\is a poly_of_size (size (mk_monic h)).-1.\nProof.\nrewrite qualifE/= -ltnS size_polyC prednK ?size_mk_monic_gt0 //.\nby rewrite (leq_ltn_trans _ size_mk_monic_gt1) //; case: eqP.\nQed.",
    "Lemma qpolyCE k : qpolyC k = k%:P :> {poly R}.\nProof. by []. Qed.",
    "Lemma qpolyC0 : qpolyC 0 = 0.\nProof. by apply/val_eqP/eqP. Qed.",
    "Lemma qpoly_mul1z : left_id qpoly1 qpoly_mul.\nProof.\nby move=> x; apply: val_inj; rewrite /= mul1r rmodp_small // size_mk_monic.\nQed.",
    "Lemma qpoly_mulz1 : right_id qpoly1 qpoly_mul.\nProof.\nby move=> x; apply: val_inj; rewrite /= mulr1 rmodp_small // size_mk_monic.\nQed.",
    "Lemma qpoly_nontrivial : qpoly1 != 0.\nProof. by apply/eqP/val_eqP; rewrite /= oner_eq0. Qed.",
    "Lemma qpolyXE : 2 < size h -> h \\is monic -> 'qX = 'X :> {poly R}.\nProof.\nmove=> sh_gt2 h_mo.\nby rewrite in_qpoly_small // size_polyX /mk_monic ifT // (ltn_trans _ sh_gt2).\nQed.",
    "Lemma mk_monic_X (R : nzRingType) : mk_monic 'X = 'X :> {poly R}.\nProof. by rewrite /mk_monic size_polyX monicX. Qed.",
    "Lemma mk_monic_Xn (R : nzRingType) n : mk_monic 'X^n = 'X^n.-1.+1 :> {poly R}.\nProof. by case: n => [|n]; rewrite /mk_monic size_polyXn monicXn /= ?expr1. Qed.",
    "Lemma card_qpoly (R : finNzRingType) (h : {poly R}):\n   #|{poly %/ h}| = #|R| ^ (size (mk_monic h)).-1.\nProof. by rewrite card_npoly. Qed.",
    "Lemma card_monic_qpoly (R : finNzRingType) (h : {poly R}):\n  1 < size h -> h \\is monic ->  #|{poly %/ h}| = #|R| ^ (size h).-1.\nProof. by move=> sh_gt1 hM; rewrite card_qpoly /mk_monic sh_gt1 hM. Qed.",
    "Lemma qpoly_mulC : commutative (@qpoly_mul A h).\nProof. by move=> p q; apply: val_inj; rewrite /= mulrC. Qed.",
    "Lemma qpoly_mulA : associative (@qpoly_mul A h).\nProof.\nhave rPM := monic_mk_monic h; move=> p q r; apply: val_inj.\nby rewrite /= rmodp_mulml // rmodp_mulmr // mulrA.\nQed.",
    "Lemma qpoly_mul_addr : right_distributive (@qpoly_mul A h) +%R.\nProof.\nhave rPM := monic_mk_monic h; move=> p q r; apply: val_inj.\nby rewrite /= !(mulrDr, rmodp_mulmr, rmodpD).\nQed.",
    "Lemma qpoly_mul_addl : left_distributive (@qpoly_mul A h) +%R.\nProof. by move=> p q r; rewrite -!(qpoly_mulC r) qpoly_mul_addr. Qed.",
    "Lemma in_qpoly1 : in_qpoly h 1 = 1.\nProof.\napply/val_eqP/eqP/in_qpoly_small.\nby rewrite size_polyC oner_eq0 /= size_mk_monic_gt1.\nQed.",
    "Lemma in_qpolyM q1 q2 : in_qpoly h (q1 * q2) = in_qpoly h q1 * in_qpoly h q2.\nProof.\napply/val_eqP => /=.\nby rewrite rmodp_mulml ?rmodp_mulmr // monic_mk_monic.\nQed.",
    "Lemma poly_of_qpoly_sum I (r : seq I) (P1 : pred I) (F : I -> {poly %/ h}) :\n  ((\\sum_(i <- r | P1 i) F i) =\n    \\sum_(p <- r | P1 p) ((F p) : {poly A}) :> {poly A})%R.\nProof. by elim/big_rec2: _ => // i p q IH <-. Qed.",
    "Lemma poly_of_qpolyD (p q : {poly %/ h}) :\n  p + q= (p : {poly A}) + q :> {poly A}.\nProof. by []. Qed.",
    "Lemma qpolyC_natr p : (p%:R : {poly %/ h}) = p%:R :> {poly A}.\nProof. by elim: p => //= p IH; rewrite !mulrS poly_of_qpolyD IH. Qed.",
    "Lemma pchar_qpoly : [pchar {poly %/ h}] =i [pchar A].\nProof.\nmove=> p; rewrite !inE; congr (_ && _).\napply/eqP/eqP=> [/(congr1 val) /=|pE]; last first.\n  by apply: val_inj => //=; rewrite qpolyC_natr /= -polyC_natr pE.\nrewrite !qpolyC_natr -!polyC_natr => /(congr1 val) /=.\nby rewrite polyseqC polyseq0; case: eqP.\nQed.",
    "Lemma poly_of_qpolyM (p q : {poly %/ h}) :\n  p * q = rmodp ((p : {poly A}) * q) (mk_monic h) :> {poly A}.\nProof. by []. Qed.",
    "Lemma poly_of_qpolyX (p : {poly %/ h}) n :\n  p ^+ n = rmodp ((p : {poly A}) ^+ n) (mk_monic h) :> {poly A}.\nProof.\nhave HhQ := monic_mk_monic h.\nelim: n => //= [|n IH].\n  rewrite rmodp_small // size_polyC ?(leq_ltn_trans _ (size_mk_monic_gt1 _)) //.\n  by case: eqP.\nby rewrite exprS /= IH // rmodp_mulmr // -exprS.\nQed.",
    "Lemma qpolyCN (a : A) : qpolyC h (- a) = -(qpolyC h a).\nProof. apply: val_inj; rewrite /= raddfN //= raddfN. Qed.",
    "Lemma qpolyCD : {morph (qpolyC h) : a b / a + b >-> a + b}%R.\nProof. by move=> a b; apply/val_eqP/eqP=> /=; rewrite -!raddfD. Qed.",
    "Lemma qpolyCM : {morph (qpolyC h) : a b / a * b >-> a * b}%R.\nProof.\nmove=> a b; apply/val_eqP/eqP=> /=; rewrite -polyCM rmodp_small //=.\nhave := qpolyC_proof h (a * b).\nby rewrite qualifE/= -ltnS prednK // size_mk_monic_gt0.\nQed.",
    "Lemma qpolyC_is_additive : additive (qpolyC h).\nProof. by move=> x y; rewrite qpolyCD qpolyCN. Qed.",
    "Lemma qpolyC_is_multiplicative : multiplicative (qpolyC h).\nProof. by split=> // x y; rewrite qpolyCM. Qed.",
    "Lemma poly_of_qpolyZ (p : {poly %/ h}) a :\n  a *: p = a *: (p : {poly A})  :> {poly A}.\nProof. by []. Qed.",
    "Lemma qpoly_mulVz (p : {poly %/ h}) : coprimep hQ p -> (qpoly_inv p * p = 1)%R.\nProof.\nhave hQM := monic_mk_monic h.\nmove=> hCp; apply: val_inj; rewrite /qpoly_inv /in_qpoly hCp /=.\nhave p_neq0 : p != 0%R.\n  apply/eqP=> pZ; move: hCp; rewrite pZ.\n  rewrite coprimep0 -size_poly_eq1.\n  by case: size (size_mk_monic_gt1 h) => [|[]].\nhave F : (egcdp hQ p).1 * hQ + (egcdp hQ p).2 * p %= 1.\n  apply: eqp_trans _ (_ : gcdp hQ p %= _).\n    rewrite eqp_sym.\n    by case: (egcdpP (mk_monic_neq0 h) p_neq0).\n  by rewrite -size_poly_eq1.\nrewrite rmodp_mulml // -scalerAl rmodpZ // rmodp_mulml //.\nrewrite -[rmodp]/Pdiv.Ring.rmodp -!Pdiv.IdomainMonic.modpE //.\nhave := eqp_modpl hQ F.\nrewrite modpD // modp_mull add0r // .\nrewrite [(1 %% _)%R]modp_small => // [egcdE|]; last first.\n  by rewrite size_polyC oner_eq0 size_mk_monic_gt1.\nrewrite {2}(eqpfP egcdE) lead_coefC divr1 alg_polyC scale_polyC mulVf //.\nrewrite lead_coef_eq0.\napply/eqP => egcdZ.\nby move: egcdE; rewrite -size_poly_eq1 egcdZ size_polyC eq_sym  eqxx.\nQed.",
    "Lemma qpoly_mulzV (p : {poly %/ h}) :\n  coprimep hQ p -> (p * (qpoly_inv p) = 1)%R.\nProof. by move=> hCp; rewrite /= mulrC qpoly_mulVz. Qed.",
    "Lemma qpoly_intro_unit (p q : {poly %/ h}) : (q * p = 1)%R -> coprimep hQ p.\nProof.\nhave hQM := monic_mk_monic h.\ncase; rewrite -[rmodp]/Pdiv.Ring.rmodp -!Pdiv.IdomainMonic.modpE // => qp1.\nhave:= coprimep1 hQ.\nrewrite -coprimep_modr -[1%R]qp1 !coprimep_modr coprimepMr; by case/andP.\nQed.",
    "Lemma qpoly_inv_out (p : {poly %/ h}) : ~~ coprimep hQ p -> qpoly_inv p = p.\nProof. by rewrite /qpoly_inv => /negPf->. Qed.",
    "Lemma irreducible_poly_coprime (A : idomainType) (p q : {poly A}) :\n  irreducible_poly p -> coprimep p q = ~~(p %| q)%R.\nProof.\ncase => H1 H2; apply/coprimepP/negP.\n  move=> sPq H.\n  by have := sPq p (dvdpp _) H; rewrite -size_poly_eq1; case: size H1 => [|[]].\nmove=> pNDq d dDp dPq.\nrewrite -size_poly_eq1; case: eqP => // /eqP /(H2 _) => /(_ dDp) dEp.\nby case: pNDq; rewrite -(eqp_dvdl _ dEp).\nQed.",
    "Lemma poly_inj : injective polyseq. Proof. exact: val_inj. Qed.",
    "Lemma lead_coefE p : lead_coef p = p`_(size p).-1. Proof. by []. Qed.",
    "Lemma polyseqC c : c%:P = nseq (c != 0) c :> seq R.\nProof. by rewrite val_insubd /=; case: (c == 0). Qed.",
    "Lemma size_polyC c : size c%:P = (c != 0).\nProof. by rewrite polyseqC size_nseq. Qed.",
    "Lemma coefC c i : c%:P`_i = if i == 0 then c else 0.\nProof. by rewrite polyseqC; case: i => [|[]]; case: eqP. Qed.",
    "Lemma polyCK : cancel polyC (coefp 0).\nProof. by move=> c; rewrite [coefp 0 _]coefC. Qed.",
    "Lemma polyC_inj : injective polyC.\nProof. by move=> c1 c2 eqc12; have:= coefC c2 0; rewrite -eqc12 coefC. Qed.",
    "Lemma lead_coefC c : lead_coef c%:P = c.\nProof. by rewrite /lead_coef polyseqC; case: eqP. Qed.",
    "Lemma polyP p q : nth 0 p =1 nth 0 q <-> p = q.\nProof.\nsplit=> [eq_pq | -> //]; apply: poly_inj.\nwithout loss lt_pq: p q eq_pq / size p < size q.\n  move=> IH; case: (ltngtP (size p) (size q)); try by move/IH->.\n  by move/(@eq_from_nth _ 0); apply.\ncase: q => q nz_q /= in lt_pq eq_pq *; case/eqP: nz_q.\nby rewrite (last_nth 0) -(subnKC lt_pq) /= -eq_pq nth_default ?leq_addr.\nQed.",
    "Lemma size1_polyC p : size p <= 1 -> p = (p`_0)%:P.\nProof.\nmove=> le_p_1; apply/polyP=> i; rewrite coefC.\nby case: i => // i; rewrite nth_default // (leq_trans le_p_1).\nQed.",
    "Lemma polyseq_cons c p :\n  cons_poly c p = (if ~~ nilp p then c :: p else c%:P) :> seq R.\nProof. by case: p => [[]]. Qed.",
    "Lemma size_cons_poly c p :\n  size (cons_poly c p) = (if nilp p && (c == 0) then 0 else (size p).+1).\nProof. by case: p => [[|c' s] _] //=; rewrite size_polyC; case: eqP. Qed.",
    "Lemma coef_cons c p i : (cons_poly c p)`_i = if i == 0 then c else p`_i.-1.\nProof.\nby case: p i => [[|c' s] _] [] //=; rewrite polyseqC; case: eqP => //= _ [].\nQed.",
    "Lemma PolyK c s : last c s != 0 -> Poly s = s :> seq R.\nProof.\ncase: s => {c}/= [_ |c s]; first by rewrite polyseqC eqxx.\nelim: s c => /= [|a s IHs] c nz_c; rewrite polyseq_cons ?{}IHs //.\nby rewrite !polyseqC !eqxx nz_c.\nQed.",
    "Lemma polyseqK p : Poly p = p.\nProof. by apply: poly_inj; apply: PolyK (valP p). Qed.",
    "Lemma size_Poly s : size (Poly s) <= size s.\nProof.\nelim: s => [|c s IHs] /=; first by rewrite polyseqC eqxx.\nby rewrite polyseq_cons; case: ifP => // _; rewrite size_polyC; case: (~~ _).\nQed.",
    "Lemma coef_Poly s i : (Poly s)`_i = s`_i.\nProof.\nby elim: s i => [|c s IHs] /= [|i]; rewrite !(coefC, eqxx, coef_cons) /=.\nQed.",
    "Lemma polyseq_poly n E :\n  E n.-1 != 0 -> \\poly_(i < n) E i = mkseq [eta E] n :> seq R.\nProof.\nrewrite unlock; case: n => [|n] nzEn; first by rewrite polyseqC eqxx.\nby rewrite (@PolyK 0) // -nth_last nth_mkseq size_mkseq.\nQed.",
    "Lemma size_poly n E : size (\\poly_(i < n) E i) <= n.\nProof. by rewrite unlock (leq_trans (size_Poly _)) ?size_mkseq. Qed.",
    "Lemma size_poly_eq n E : E n.-1 != 0 -> size (\\poly_(i < n) E i) = n.\nProof. by move/polyseq_poly->; apply: size_mkseq. Qed.",
    "Lemma coef_poly n E k : (\\poly_(i < n) E i)`_k = (if k < n then E k else 0).\nProof.\nrewrite unlock coef_Poly.\nhave [lt_kn | le_nk] := ltnP k n; first by rewrite nth_mkseq.\nby rewrite nth_default // size_mkseq.\nQed.",
    "Lemma lead_coef_poly n E :\n  n > 0 -> E n.-1 != 0 -> lead_coef (\\poly_(i < n) E i) = E n.-1.\nProof.\nby case: n => // n _ nzE; rewrite /lead_coef size_poly_eq // coef_poly leqnn.\nQed.",
    "Lemma coefK p : \\poly_(i < size p) p`_i = p.\nProof.\nby apply/polyP=> i; rewrite coef_poly; case: ltnP => // /(nth_default 0)->.\nQed.",
    "Lemma polyC0 : 0%:P = 0 :> {poly R}. Proof. by []. Qed.",
    "Lemma polyseq0 : (0 : {poly R}) = [::] :> seq R.\nProof. by rewrite polyseqC eqxx. Qed.",
    "Lemma size_poly0 : size (0 : {poly R}) = 0%N.\nProof. by rewrite polyseq0. Qed.",
    "Lemma coef0 i : (0 : {poly R})`_i = 0.\nProof. by rewrite coefC if_same. Qed.",
    "Lemma lead_coef0 : lead_coef 0 = 0 :> R. Proof. exact: lead_coefC. Qed.",
    "Lemma size_poly_eq0 p : (size p == 0) = (p == 0).\nProof. by rewrite size_eq0 -polyseq0. Qed.",
    "Lemma size_poly_leq0 p : (size p <= 0) = (p == 0).\nProof. by rewrite leqn0 size_poly_eq0. Qed.",
    "Lemma size_poly_leq0P p : reflect (p = 0) (size p <= 0).\nProof. by apply: (iffP idP); rewrite size_poly_leq0; move/eqP. Qed.",
    "Lemma size_poly_gt0 p : (0 < size p) = (p != 0).\nProof. by rewrite lt0n size_poly_eq0. Qed.",
    "Lemma gt_size_poly_neq0 p n : (size p > n)%N -> p != 0.\nProof. by move=> /(leq_ltn_trans _) h; rewrite -size_poly_eq0 lt0n_neq0 ?h. Qed.",
    "Lemma nil_poly p : nilp p = (p == 0).\nProof. exact: size_poly_eq0. Qed.",
    "Lemma poly0Vpos p : {p = 0} + {size p > 0}.\nProof. by rewrite lt0n size_poly_eq0; case: eqVneq; [left | right]. Qed.",
    "Lemma polySpred p : p != 0 -> size p = (size p).-1.+1.\nProof. by rewrite -size_poly_eq0 -lt0n => /prednK. Qed.",
    "Lemma lead_coef_eq0 p : (lead_coef p == 0) = (p == 0).\nProof.\nrewrite -nil_poly /lead_coef nth_last.\nby case: p => [[|x s] /= /negbTE // _]; rewrite eqxx.\nQed.",
    "Lemma polyC_eq0 (c : R) : (c%:P == 0) = (c == 0).\nProof. by rewrite -nil_poly polyseqC; case: (c == 0). Qed.",
    "Lemma size_poly1P p : reflect (exists2 c, c != 0 & p = c%:P) (size p == 1).\nProof.\napply: (iffP eqP) => [pC | [c nz_c ->]]; last by rewrite size_polyC nz_c.\nhave def_p: p = (p`_0)%:P by rewrite -size1_polyC ?pC.\nby exists p`_0; rewrite // -polyC_eq0 -def_p -size_poly_eq0 pC.\nQed.",
    "Lemma size_polyC_leq1 (c : R) : (size c%:P <= 1)%N.\nProof. by rewrite size_polyC; case: (c == 0). Qed.",
    "Lemma leq_sizeP p i : reflect (forall j, i <= j -> p`_j = 0) (size p <= i).\nProof.\napply: (iffP idP) => [hp j hij| hp].\n  by apply: nth_default; apply: leq_trans hij.\ncase: (eqVneq p) (lead_coef_eq0 p) => [->|p0]; first by rewrite size_poly0.\nrewrite leqNgt; apply/contraFN => hs.\nby apply/eqP/hp; rewrite -ltnS (ltn_predK hs).\nQed.",
    "Lemma coefD p q i : (p + q)`_i = p`_i + q`_i.\nProof. exact: coef_add_poly. Qed.",
    "Lemma polyCD : {morph polyC : a b / a + b}.\nProof. by move=> a b; apply/polyP=> [[|i]]; rewrite coefD !coefC ?addr0. Qed.",
    "Lemma size_polyD p q : size (p + q) <= maxn (size p) (size q).\nProof. by rewrite -[+%R]/add_poly unlock; exact: size_poly. Qed.",
    "Lemma size_polyDl p q : size p > size q -> size (p + q) = size p.\nProof.\nmove=> ltqp; rewrite -[+%R]/add_poly unlock size_poly_eq (maxn_idPl (ltnW _))//.\nby rewrite addrC nth_default ?simp ?nth_last //; case: p ltqp => [[]].\nQed.",
    "Lemma size_sum I (r : seq I) (P : pred I) (F : I -> {poly R}) :\n  size (\\sum_(i <- r | P i) F i) <= \\max_(i <- r | P i) size (F i).\nProof.\nelim/big_rec2: _ => [|i p q _ IHp]; first by rewrite size_poly0.\nby rewrite -(maxn_idPr IHp) maxnA leq_max size_polyD.\nQed.",
    "Lemma lead_coefDl p q : size p > size q -> lead_coef (p + q) = lead_coef p.\nProof.\nmove=> ltqp; rewrite /lead_coef coefD size_polyDl //.\nby rewrite addrC nth_default ?simp // -ltnS (ltn_predK ltqp).\nQed.",
    "Lemma lead_coefDr p q : size q > size p -> lead_coef (p + q) = lead_coef q.\nProof. by move/lead_coefDl<-; rewrite addrC. Qed.",
    "Lemma polyC1 : 1%:P = 1 :> {poly R}. Proof. by []. Qed.",
    "Lemma polyseq1 : (1 : {poly R}) = [:: 1] :> seq R.\nProof. by rewrite polyseqC oner_neq0. Qed.",
    "Lemma size_poly1 : size (1 : {poly R}) = 1.\nProof. by rewrite polyseq1. Qed.",
    "Lemma coef1 i : (1 : {poly R})`_i = (i == 0)%:R.\nProof. by case: i => [|i]; rewrite polyseq1 /= ?nth_nil. Qed.",
    "Lemma lead_coef1 : lead_coef 1 = 1 :> R. Proof. exact: lead_coefC. Qed.",
    "Lemma coefM p q i : (p * q)`_i = \\sum_(j < i.+1) p`_j * q`_(i - j)%N.\nProof. exact: coef_mul_poly. Qed.",
    "Lemma coefMr p q i : (p * q)`_i = \\sum_(j < i.+1) p`_(i - j)%N * q`_j.\nProof. exact: coef_mul_poly_rev. Qed.",
    "Lemma coef0M p q : (p * q)`_0 = p`_0 * q`_0.\nProof. by rewrite coefM big_ord1. Qed.",
    "Lemma coef0_prod I rI (F : I -> {poly R}) P :\n  (\\prod_(i <- rI| P i) F i)`_0 = \\prod_(i <- rI | P i) (F i)`_0.\nProof. by apply: (big_morph _ coef0M); rewrite coef1 eqxx. Qed.",
    "Lemma size_polyMleq p q : size (p * q) <= (size p + size q).-1.\nProof. by rewrite -[*%R]/mul_poly unlock size_poly. Qed.",
    "Lemma mul_lead_coef p q :\n  lead_coef p * lead_coef q = (p * q)`_(size p + size q).-2.\nProof.\npose dp := (size p).-1; pose dq := (size q).-1.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite lead_coef0 !mul0r coef0.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite lead_coef0 !mulr0 coef0.\nhave ->: (size p + size q).-2 = (dp + dq)%N.\n  by do 2!rewrite polySpred // addSn addnC.\nhave lt_p_pq: dp < (dp + dq).+1 by rewrite ltnS leq_addr.\nrewrite coefM (bigD1 (Ordinal lt_p_pq)) ?big1 ?simp ?addKn //= => i.\nrewrite -val_eqE neq_ltn /= => /orP[lt_i_p | gt_i_p]; last first.\n  by rewrite nth_default ?mul0r //; rewrite -polySpred in gt_i_p.\nrewrite [q`__]nth_default ?mulr0 //= -subSS -{1}addnS -polySpred //.\nby rewrite addnC -addnBA ?leq_addr.\nQed.",
    "Lemma size_proper_mul p q :\n  lead_coef p * lead_coef q != 0 -> size (p * q) = (size p + size q).-1.\nProof.\napply: contraNeq; rewrite mul_lead_coef eqn_leq size_polyMleq -ltnNge => lt_pq.\nby rewrite nth_default // -subn1 -(leq_add2l 1) -leq_subLR leq_sub2r.\nQed.",
    "Lemma lead_coef_proper_mul p q :\n  let c := lead_coef p * lead_coef q in c != 0 -> lead_coef (p * q) = c.\nProof. by move=> /= nz_c; rewrite mul_lead_coef -size_proper_mul. Qed.",
    "Lemma size_poly_prod_leq (I : finType) (P : pred I) (F : I -> {poly R}) :\n  size (\\prod_(i | P i) F i) <= (\\sum_(i | P i) size (F i)).+1 - #|P|.\nProof.\nrewrite -sum1_card.\nelim/big_rec3: _ => [|i n m p _ IHp]; first by rewrite size_poly1.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite mulr0 size_poly0.\nrewrite (leq_trans (size_polyMleq _ _)) // subnS -!subn1 leq_sub2r //.\nrewrite -addnS -addnBA ?leq_add2l // ltnW // -subn_gt0 (leq_trans _ IHp) //.\nby rewrite polySpred.\nQed.",
    "Lemma coefCM c p i : (c%:P * p)`_i = c * p`_i.\nProof.\nrewrite coefM big_ord_recl subn0.\nby rewrite big1 => [|j _]; rewrite coefC !simp.\nQed.",
    "Lemma coefMC c p i : (p * c%:P)`_i = p`_i * c.\nProof.\nrewrite coefMr big_ord_recl subn0.\nby rewrite big1 => [|j _]; rewrite coefC !simp.\nQed.",
    "Lemma polyCM : {morph polyC : a b / a * b}.\nProof. by move=> a b; apply/polyP=> [[|i]]; rewrite coefCM !coefC ?simp. Qed.",
    "Lemma size_poly_exp_leq p n : size (p ^+ n) <= ((size p).-1 * n).+1.\nProof.\nelim: n => [|n IHn]; first by rewrite size_poly1.\nhave [-> | nzp] := poly0Vpos p; first by rewrite exprS mul0r size_poly0.\nrewrite exprS (leq_trans (size_polyMleq _ _)) //.\nby rewrite -{1}(prednK nzp) mulnS -addnS leq_add2l.\nQed.",
    "Lemma coefN p i : (- p)`_i = - p`_i.\nProof. exact: coef_opp_poly. Qed.",
    "Lemma coefB p q i : (p - q)`_i = p`_i - q`_i.\nProof. by rewrite coefD coefN. Qed.",
    "Lemma coefMn p n i : (p *+ n)`_i = p`_i *+ n.\nProof. exact: (raddfMn (coefp i)). Qed.",
    "Lemma coefMNn p n i : (p *- n)`_i = p`_i *- n.\nProof. by rewrite coefN coefMn. Qed.",
    "Lemma coef_sum I (r : seq I) (P : pred I) (F : I -> {poly R}) k :\n  (\\sum_(i <- r | P i) F i)`_k = \\sum_(i <- r | P i) (F i)`_k.\nProof. exact: (raddf_sum (coefp k)). Qed.",
    "Lemma polyCN : {morph (@polyC R) : c / - c}.\nProof. by move=> c; apply/polyP=> [[|i]]; rewrite coefN !coefC ?oppr0. Qed.",
    "Lemma polyCB : {morph (@polyC R) : a b / a - b}.\nProof. by move=> a b; rewrite polyCD polyCN. Qed.",
    "Lemma polyCMn n : {morph (@polyC R) : c / c *+ n}. Proof. exact: raddfMn. Qed.",
    "Lemma size_polyN p : size (- p) = size p.\nProof.\nby apply/eqP; rewrite eqn_leq -{3}(opprK p) -[-%R]/opp_poly unlock !size_poly.\nQed.",
    "Lemma lead_coefN p : lead_coef (- p) = - lead_coef p.\nProof. by rewrite /lead_coef size_polyN coefN. Qed.",
    "Lemma polyC_exp n : {morph (@polyC R) : c / c ^+ n}. Proof. exact: rmorphXn. Qed.",
    "Lemma polyC_natr n : n%:R%:P = n%:R :> {poly R}.\nProof. by rewrite rmorph_nat. Qed.",
    "Lemma pchar_poly : [pchar {poly R}] =i [pchar R].\nProof.\nmove=> p; rewrite !inE; congr (_ && _).\napply/eqP/eqP=> [/(congr1 val) /=|]; last by rewrite -polyC_natr => ->.\nby rewrite polyseq0 -polyC_natr polyseqC; case: eqP.\nQed.",
    "Lemma size_Msign p n : size ((-1) ^+ n * p) = size p.\nProof.\nby rewrite -signr_odd; case: (odd n); rewrite ?mul1r// mulN1r size_polyN.\nQed.",
    "Lemma mul_polyC a p : a%:P * p = a *: p.\nProof. by rewrite -scale_polyE. Qed.",
    "Lemma scale_polyC a b : a *: b%:P = (a * b)%:P.\nProof. by rewrite -mul_polyC polyCM. Qed.",
    "Lemma alg_polyC a : a%:A = a%:P :> {poly R}.\nProof. by rewrite -mul_polyC mulr1. Qed.",
    "Lemma coefZ a p i : (a *: p)`_i = a * p`_i.\nProof.\nrewrite -[*:%R]/scale_poly unlock coef_poly.\nby case: leqP => // le_p_n; rewrite nth_default ?mulr0.\nQed.",
    "Lemma size_scale_leq a p : size (a *: p) <= size p.\nProof. by rewrite -[*:%R]/scale_poly unlock size_poly. Qed.",
    "Lemma polyseqX : 'X = [:: 0; 1] :> seq R.\nProof. by rewrite unlock !polyseq_cons nil_poly eqxx /= polyseq1. Qed.",
    "Lemma size_polyX : size 'X = 2. Proof. by rewrite polyseqX. Qed.",
    "Lemma polyX_eq0 : ('X == 0) = false.\nProof. by rewrite -size_poly_eq0 size_polyX. Qed.",
    "Lemma coefX i : 'X`_i = (i == 1)%:R.\nProof. by case: i => [|[|i]]; rewrite polyseqX //= nth_nil. Qed.",
    "Lemma lead_coefX : lead_coef 'X = 1.\nProof. by rewrite /lead_coef polyseqX. Qed.",
    "Lemma commr_polyX p : GRing.comm p 'X.\nProof.\napply/polyP=> i; rewrite coefMr coefM.\nby apply: eq_bigr => j _; rewrite coefX commr_nat.\nQed.",
    "Lemma coefMX p i : (p * 'X)`_i = (if (i == 0)%N then 0 else p`_i.-1).\nProof.\nrewrite coefMr big_ord_recl coefX ?simp.\ncase: i => [|i]; rewrite ?big_ord0 //= big_ord_recl polyseqX subn1 /=.\nby rewrite big1 ?simp // => j _; rewrite nth_nil !simp.\nQed.",
    "Lemma coefXM p i : ('X * p)`_i = (if (i == 0)%N then 0 else p`_i.-1).\nProof. by rewrite -commr_polyX coefMX. Qed.",
    "Lemma cons_poly_def p a : cons_poly a p = p * 'X + a%:P.\nProof.\napply/polyP=> i; rewrite coef_cons coefD coefMX coefC.\nby case: ifP; rewrite !simp.\nQed.",
    "Lemma poly_ind (K : {poly R} -> Type) :\n  K 0 -> (forall p c, K p -> K (p * 'X + c%:P)) -> (forall p, K p).\nProof.\nmove=> K0 Kcons p; rewrite -[p]polyseqK.\nby elim: {p}(p : seq R) => //= p c IHp; rewrite cons_poly_def; apply: Kcons.\nQed.",
    "Lemma polyseqXaddC a : 'X + a%:P = [:: a; 1] :> seq R.\nProof. by rewrite -['X]mul1r -cons_poly_def polyseq_cons polyseq1. Qed.",
    "Lemma polyseqXsubC a : 'X - a%:P = [:: - a; 1] :> seq R.\nProof. by rewrite -polyCN polyseqXaddC. Qed.",
    "Lemma size_XsubC a : size ('X - a%:P) = 2.\nProof. by rewrite polyseqXsubC. Qed.",
    "Lemma size_XaddC b : size ('X + b%:P) = 2.\nProof. by rewrite -[b]opprK rmorphN size_XsubC. Qed.",
    "Lemma lead_coefXaddC a : lead_coef ('X + a%:P) = 1.\nProof. by rewrite lead_coefE polyseqXaddC. Qed.",
    "Lemma lead_coefXsubC a : lead_coef ('X - a%:P) = 1.\nProof. by rewrite lead_coefE polyseqXsubC. Qed.",
    "Lemma polyXsubC_eq0 a : ('X - a%:P == 0) = false.\nProof. by rewrite -nil_poly polyseqXsubC. Qed.",
    "Lemma size_MXaddC p c :\n  size (p * 'X + c%:P) = (if (p == 0) && (c == 0) then 0 else (size p).+1).\nProof. by rewrite -cons_poly_def size_cons_poly nil_poly. Qed.",
    "Lemma polyseqMX p : p != 0 -> p * 'X = 0 :: p :> seq R.\nProof.\nby move=> nz_p; rewrite -[p * _]addr0 -cons_poly_def polyseq_cons nil_poly nz_p.\nQed.",
    "Lemma size_mulX p : p != 0 -> size (p * 'X) = (size p).+1.\nProof. by move/polyseqMX->. Qed.",
    "Lemma lead_coefMX p : lead_coef (p * 'X) = lead_coef p.\nProof.\nhave [-> | nzp] := eqVneq p 0; first by rewrite mul0r.\nby rewrite /lead_coef !nth_last polyseqMX.\nQed.",
    "Lemma size_XmulC a : a != 0 -> size ('X * a%:P) = 2.\nProof.\nby move=> nz_a; rewrite -commr_polyX size_mulX ?polyC_eq0 ?size_polyC nz_a.\nQed.",
    "Lemma coefXn n i : 'X^n`_i = (i == n)%:R.\nProof.\nby elim: n i => [|n IHn] [|i]; rewrite ?coef1 // exprS coefXM ?IHn.\nQed.",
    "Lemma polyseqXn n : 'X^n = rcons (nseq n 0) 1 :> seq R.\nProof.\nelim: n => [|n IHn]; rewrite ?polyseq1 // exprSr.\nby rewrite polyseqMX -?size_poly_eq0 IHn ?size_rcons.\nQed.",
    "Lemma size_polyXn n : size 'X^n = n.+1.\nProof. by rewrite polyseqXn size_rcons size_nseq. Qed.",
    "Lemma commr_polyXn p n : GRing.comm p 'X^n.\nProof. exact/commrX/commr_polyX. Qed.",
    "Lemma lead_coefXn n : lead_coef 'X^n = 1.\nProof. by rewrite /lead_coef nth_last polyseqXn last_rcons. Qed.",
    "Lemma lead_coefXnaddC n c : 0 < n -> lead_coef ('X^n + c%:P) = 1.\nProof.\nmove=> n_gt0; rewrite lead_coefDl ?lead_coefXn//.\nby rewrite size_polyC size_polyXn ltnS (leq_trans (leq_b1 _)).\nQed.",
    "Lemma lead_coefXnsubC n c : 0 < n -> lead_coef ('X^n - c%:P) = 1.\nProof. by move=> n_gt0; rewrite -polyCN lead_coefXnaddC. Qed.",
    "Lemma size_XnaddC n c : 0 < n -> size ('X^n + c%:P) = n.+1.\nProof.\nby move=> *; rewrite size_polyDl ?size_polyXn// size_polyC; case: eqP.\nQed.",
    "Lemma size_XnsubC n c : 0 < n -> size ('X^n - c%:P) = n.+1.\nProof. by move=> *; rewrite -polyCN size_XnaddC. Qed.",
    "Lemma polyseqMXn n p : p != 0 -> p * 'X^n = ncons n 0 p :> seq R.\nProof.\ncase: n => [|n] nz_p; first by rewrite mulr1.\nelim: n => [|n IHn]; first exact: polyseqMX.\nby rewrite exprSr mulrA polyseqMX -?nil_poly IHn.\nQed.",
    "Lemma coefMXn n p i : (p * 'X^n)`_i = if i < n then 0 else p`_(i - n).\nProof.\nhave [-> | /polyseqMXn->] := eqVneq p 0; last exact: nth_ncons.\nby rewrite mul0r !coef0 if_same.\nQed.",
    "Lemma size_mulXn n p : p != 0 -> size (p * 'X^n) = (n + size p)%N.\nProof.\nelim: n p => [p p_neq0| n IH p p_neq0]; first by rewrite mulr1.\nby rewrite exprS mulrA IH -?size_poly_eq0 size_mulX // addnS.\nQed.",
    "Lemma coefXnM n p i : ('X^n * p)`_i = if i < n then 0 else p`_(i - n).\nProof. by rewrite -commr_polyXn coefMXn. Qed.",
    "Lemma coef_sumMXn I (r : seq I) (P : pred I) (p : I -> R) (n : I -> nat) k :\n  (\\sum_(i <- r | P i) p i *: 'X^(n i))`_k =\n    \\sum_(i <- r | P i && (n i == k)) p i.\nProof.\nrewrite coef_sum big_mkcondr; apply: eq_bigr => i Pi.\nby rewrite coefZ coefXn mulr_natr mulrb eq_sym.\nQed.",
    "Lemma poly_def n E : \\poly_(i < n) E i = \\sum_(i < n) E i *: 'X^i.\nProof. by apply/polyP => i; rewrite coef_sumMXn coef_poly big_ord1_eq. Qed.",
    "Lemma monicE p : (p \\is monic) = (lead_coef p == 1). Proof. by []. Qed.",
    "Lemma monicP p : reflect (lead_coef p = 1) (p \\is monic).\nProof. exact: eqP. Qed.",
    "Lemma monic1 : 1 \\is monic. Proof. exact/eqP/lead_coef1. Qed.",
    "Lemma monicX : 'X \\is monic. Proof. exact/eqP/lead_coefX. Qed.",
    "Lemma monicXn n : 'X^n \\is monic. Proof. exact/eqP/lead_coefXn. Qed.",
    "Lemma monic_neq0 p : p \\is monic -> p != 0.\nProof. by rewrite -lead_coef_eq0 => /eqP->; apply: oner_neq0. Qed.",
    "Lemma lead_coef_monicM p q : p \\is monic -> lead_coef (p * q) = lead_coef q.\nProof.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite mulr0.\nby move/monicP=> mon_p; rewrite lead_coef_proper_mul mon_p mul1r ?lead_coef_eq0.\nQed.",
    "Lemma lead_coef_Mmonic p q : q \\is monic -> lead_coef (p * q) = lead_coef p.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite mul0r.\nby move/monicP=> mon_q; rewrite lead_coef_proper_mul mon_q mulr1 ?lead_coef_eq0.\nQed.",
    "Lemma size_monicM p q :\n  p \\is monic -> q != 0 -> size (p * q) = (size p + size q).-1.\nProof.\nmove/monicP=> mon_p nz_q.\nby rewrite size_proper_mul // mon_p mul1r lead_coef_eq0.\nQed.",
    "Lemma size_Mmonic p q :\n  p != 0 -> q \\is monic -> size (p * q) = (size p + size q).-1.\nProof.\nmove=> nz_p /monicP mon_q.\nby rewrite size_proper_mul // mon_q mulr1 lead_coef_eq0.\nQed.",
    "Lemma monicMl p q : p \\is monic -> (p * q \\is monic) = (q \\is monic).\nProof. by move=> mon_p; rewrite !monicE lead_coef_monicM. Qed.",
    "Lemma monicMr p q : q \\is monic -> (p * q \\is monic) = (p \\is monic).\nProof. by move=> mon_q; rewrite !monicE lead_coef_Mmonic. Qed.",
    "Lemma monic_exp p n : p \\is monic -> p ^+ n \\is monic.\nProof. exact: rpredX. Qed.",
    "Lemma monic_prod I rI (P : pred I) (F : I -> {poly R}):\n  (forall i, P i -> F i \\is monic) -> \\prod_(i <- rI | P i) F i \\is monic.\nProof. exact: rpred_prod. Qed.",
    "Lemma monicXaddC c : 'X + c%:P \\is monic.\nProof. exact/eqP/lead_coefXaddC. Qed.",
    "Lemma monicXsubC c : 'X - c%:P \\is monic.\nProof. exact/eqP/lead_coefXsubC. Qed.",
    "Lemma monic_prod_XsubC I rI (P : pred I) (F : I -> R) :\n  \\prod_(i <- rI | P i) ('X - (F i)%:P) \\is monic.\nProof. by apply: monic_prod => i _; apply: monicXsubC. Qed.",
    "Lemma lead_coef_prod_XsubC I rI (P : pred I) (F : I -> R) :\n  lead_coef (\\prod_(i <- rI | P i) ('X - (F i)%:P)) = 1.\nProof. exact/eqP/monic_prod_XsubC. Qed.",
    "Lemma size_prod_XsubC I rI (F : I -> R) :\n  size (\\prod_(i <- rI) ('X - (F i)%:P)) = (size rI).+1.\nProof.\nelim: rI => [|i r /= <-]; rewrite ?big_nil ?size_poly1 // big_cons.\nrewrite size_monicM ?monicXsubC ?monic_neq0 ?monic_prod_XsubC //.\nby rewrite size_XsubC.\nQed.",
    "Lemma size_exp_XsubC n a : size (('X - a%:P) ^+ n) = n.+1.\nProof.\nrewrite -[n]card_ord -prodr_const -big_filter size_prod_XsubC.\nby have [e _ _ [_ ->]] := big_enumP.\nQed.",
    "Lemma monicXnaddC n c : 0 < n -> 'X^n + c%:P \\is monic.\nProof. by move=> n_gt0; rewrite monicE lead_coefXnaddC. Qed.",
    "Lemma monicXnsubC n c : 0 < n -> 'X^n - c%:P \\is monic.\nProof. by move=> n_gt0; rewrite monicE lead_coefXnsubC. Qed.",
    "Lemma lreg_lead p : GRing.lreg (lead_coef p) -> GRing.lreg p.\nProof.\nmove/mulrI_eq0=> reg_p; apply: mulrI0_lreg => q /eqP; apply: contraTeq => nz_q.\nby rewrite -lead_coef_eq0 lead_coef_proper_mul reg_p lead_coef_eq0.\nQed.",
    "Lemma rreg_lead p : GRing.rreg (lead_coef p) -> GRing.rreg p.\nProof.\nmove/mulIr_eq0=> reg_p; apply: mulIr0_rreg => q /eqP; apply: contraTeq => nz_q.\nby rewrite -lead_coef_eq0 lead_coef_proper_mul reg_p lead_coef_eq0.\nQed.",
    "Lemma lreg_lead0 p : GRing.lreg (lead_coef p) -> p != 0.\nProof. by move/lreg_neq0; rewrite lead_coef_eq0. Qed.",
    "Lemma rreg_lead0 p : GRing.rreg (lead_coef p) -> p != 0.\nProof. by move/rreg_neq0; rewrite lead_coef_eq0. Qed.",
    "Lemma lreg_size c p : GRing.lreg c -> size (c *: p) = size p.\nProof.\nmove=> reg_c; have [-> | nz_p] := eqVneq p 0; first by rewrite scaler0.\nrewrite -mul_polyC size_proper_mul; first by rewrite size_polyC lreg_neq0.\nby rewrite lead_coefC mulrI_eq0 ?lead_coef_eq0.\nQed.",
    "Lemma lreg_polyZ_eq0 c p : GRing.lreg c -> (c *: p == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 => /lreg_size->. Qed.",
    "Lemma lead_coef_lreg c p :\n  GRing.lreg c -> lead_coef (c *: p) = c * lead_coef p.\nProof. by move=> reg_c; rewrite !lead_coefE coefZ lreg_size. Qed.",
    "Lemma rreg_size c p : GRing.rreg c -> size (p * c%:P) =  size p.\nProof.\nmove=> reg_c; have [-> | nz_p] := eqVneq p 0; first by rewrite mul0r.\nrewrite size_proper_mul; first by rewrite size_polyC rreg_neq0 ?addn1.\nby rewrite lead_coefC mulIr_eq0 ?lead_coef_eq0.\nQed.",
    "Lemma rreg_polyMC_eq0 c p : GRing.rreg c -> (p * c%:P == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 => /rreg_size->. Qed.",
    "Lemma rreg_div0 q r d :\n    GRing.rreg (lead_coef d) -> size r < size d ->\n  (q * d + r == 0) = (q == 0) && (r == 0).\nProof.\nmove=> reg_d lt_r_d; rewrite addrC addr_eq0.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite mul0r oppr0.\napply: contraTF lt_r_d => /eqP->; rewrite -leqNgt size_polyN.\nrewrite size_proper_mul ?mulIr_eq0 ?lead_coef_eq0 //.\nby rewrite (polySpred nz_q) leq_addl.\nQed.",
    "Lemma monic_comreg p :\n  p \\is monic -> GRing.comm p (lead_coef p)%:P /\\ GRing.rreg (lead_coef p).\nProof. by move/monicP->; split; [apply: commr1 | apply: rreg1]. Qed.",
    "Lemma monic_lreg p : p \\is monic -> GRing.lreg p.\nProof. by move=> /eqP lp1; apply/lreg_lead; rewrite lp1; apply/lreg1. Qed.",
    "Lemma monic_rreg p : p \\is monic -> GRing.rreg p.\nProof. by move=> /eqP lp1; apply/rreg_lead; rewrite lp1; apply/rreg1. Qed.",
    "Lemma horner0 x : (0 : {poly R}).[x] = 0.\nProof. by rewrite /horner polyseq0. Qed.",
    "Lemma hornerC c x : (c%:P).[x] = c.\nProof. by rewrite /horner polyseqC; case: eqP; rewrite /= ?simp. Qed.",
    "Lemma hornerX x : 'X.[x] = x.\nProof. by rewrite /horner polyseqX /= !simp. Qed.",
    "Lemma horner_cons p c x : (cons_poly c p).[x] = p.[x] * x + c.\nProof.\nrewrite /horner polyseq_cons; case: nilP => //= ->.\nby rewrite !simp -/(_.[x]) hornerC.\nQed.",
    "Lemma horner_coef0 p : p.[0] = p`_0.\nProof. by rewrite /horner; case: (p : seq R) => //= c p'; rewrite !simp. Qed.",
    "Lemma hornerMXaddC p c x : (p * 'X + c%:P).[x] = p.[x] * x + c.\nProof. by rewrite -cons_poly_def horner_cons. Qed.",
    "Lemma hornerMX p x : (p * 'X).[x] = p.[x] * x.\nProof. by rewrite -[p * 'X]addr0 hornerMXaddC addr0. Qed.",
    "Lemma horner_Poly s x : (Poly s).[x] = horner_rec s x.\nProof. by elim: s => [|a s /= <-]; rewrite (horner0, horner_cons). Qed.",
    "Lemma horner_coef p x : p.[x] = \\sum_(i < size p) p`_i * x ^+ i.\nProof.\nrewrite /horner.\nelim: {p}(p : seq R) => /= [|a s ->]; first by rewrite big_ord0.\nrewrite big_ord_recl simp addrC big_distrl /=.\nby congr (_ + _); apply: eq_bigr => i _; rewrite -mulrA exprSr.\nQed.",
    "Lemma horner_coef_wide n p x :\n  size p <= n -> p.[x] = \\sum_(i < n) p`_i * x ^+ i.\nProof.\nmove=> le_p_n.\nrewrite horner_coef (big_ord_widen n (fun i => p`_i * x ^+ i)) // big_mkcond.\nby apply: eq_bigr => i _; case: ltnP => // le_p_i; rewrite nth_default ?simp.\nQed.",
    "Lemma horner_poly n E x : (\\poly_(i < n) E i).[x] = \\sum_(i < n) E i * x ^+ i.\nProof.\nrewrite (@horner_coef_wide n) ?size_poly //.\nby apply: eq_bigr => i _; rewrite coef_poly ltn_ord.\nQed.",
    "Lemma hornerN p x : (- p).[x] = - p.[x].\nProof.\nrewrite -[-%R]/opp_poly unlock horner_poly horner_coef -sumrN /=.\nby apply: eq_bigr => i _; rewrite mulNr.\nQed.",
    "Lemma hornerD p q x : (p + q).[x] = p.[x] + q.[x].\nProof.\nrewrite -[+%R]/(@add_poly R) unlock horner_poly; set m := maxn _ _.\nrewrite !(@horner_coef_wide m) ?leq_max ?leqnn ?orbT // -big_split /=.\nby apply: eq_bigr => i _; rewrite -mulrDl.\nQed.",
    "Lemma hornerXsubC a x : ('X - a%:P).[x] = x - a.\nProof. by rewrite hornerD hornerN hornerC hornerX. Qed.",
    "Lemma horner_sum I (r : seq I) (P : pred I) F x :\n  (\\sum_(i <- r | P i) F i).[x] = \\sum_(i <- r | P i) (F i).[x].\nProof. by elim/big_rec2: _ => [|i _ p _ <-]; rewrite (horner0, hornerD). Qed.",
    "Lemma hornerCM a p x : (a%:P * p).[x] = a * p.[x].\nProof.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !(mulr0, horner0).\nby rewrite mulrDr mulrA -polyCM !hornerMXaddC IHp mulrDr mulrA.\nQed.",
    "Lemma hornerZ c p x : (c *: p).[x] = c * p.[x].\nProof. by rewrite -mul_polyC hornerCM. Qed.",
    "Lemma hornerMn n p x : (p *+ n).[x] = p.[x] *+ n.\nProof. by elim: n => [| n IHn]; rewrite ?horner0 // !mulrS hornerD IHn. Qed.",
    "Lemma comm_coef_poly p x : comm_coef p x -> comm_poly p x.\nProof.\nmove=> cpx; rewrite /comm_poly !horner_coef big_distrl big_distrr /=.\nby apply: eq_bigr => i _; rewrite /= mulrA -cpx -!mulrA commrX.\nQed.",
    "Lemma comm_poly0 x : comm_poly 0 x.\nProof. by rewrite /comm_poly !horner0 !simp. Qed.",
    "Lemma comm_poly1 x : comm_poly 1 x.\nProof. by rewrite /comm_poly !hornerC !simp. Qed.",
    "Lemma comm_polyX x : comm_poly 'X x.\nProof. by rewrite /comm_poly !hornerX. Qed.",
    "Lemma comm_polyD p q x: comm_poly p x -> comm_poly q x -> comm_poly (p + q) x.\nProof. by rewrite /comm_poly hornerD mulrDr mulrDl => -> ->. Qed.",
    "Lemma commr_horner a b p : GRing.comm a b -> comm_coef p a -> GRing.comm a p.[b].\nProof.\nmove=> cab cpa; rewrite horner_coef; apply: commr_sum => i _.\nby apply: commrM => //; apply: commrX.\nQed.",
    "Lemma hornerM_comm p q x : comm_poly q x -> (p * q).[x] = p.[x] * q.[x].\nProof.\nmove=> comm_qx.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !(simp, horner0).\nrewrite mulrDl hornerD hornerCM -mulrA -commr_polyX mulrA hornerMX.\nby rewrite {}IHp -mulrA -comm_qx mulrA -mulrDl hornerMXaddC.\nQed.",
    "Lemma comm_polyM p q x: comm_poly p x -> comm_poly q x -> comm_poly (p * q) x.\nProof.\nby move=> px qx; rewrite /comm_poly hornerM_comm// mulrA px -mulrA qx mulrA.\nQed.",
    "Lemma horner_exp_comm p x n : comm_poly p x -> (p ^+ n).[x] = p.[x] ^+ n.\nProof.\nmove=> comm_px; elim: n => [|n IHn]; first by rewrite hornerC.\nby rewrite !exprSr -IHn hornerM_comm.\nQed.",
    "Lemma comm_poly_exp p n x: comm_poly p x -> comm_poly (p ^+ n) x.\nProof. by move=> px; rewrite /comm_poly !horner_exp_comm// commrX. Qed.",
    "Lemma hornerXn x n : ('X^n).[x] = x ^+ n.\nProof. by rewrite horner_exp_comm /comm_poly hornerX. Qed.",
    "Lemma mem_root p x : x \\in root p = (p.[x] == 0).\nProof. by []. Qed.",
    "Lemma rootE p x : (root p x = (p.[x] == 0)) * ((x \\in root p) = (p.[x] == 0)).\nProof. by []. Qed.",
    "Lemma rootP p x : reflect (p.[x] = 0) (root p x).\nProof. exact: eqP. Qed.",
    "Lemma rootPt p x : reflect (p.[x] == 0) (root p x).\nProof. exact: idP. Qed.",
    "Lemma rootPf p x : reflect ((p.[x] == 0) = false) (~~ root p x).\nProof. exact: negPf. Qed.",
    "Lemma rootC a x : root a%:P x = (a == 0).\nProof. by rewrite rootE hornerC. Qed.",
    "Lemma root0 x : root 0 x.\nProof. by rewrite rootC. Qed.",
    "Lemma root1 x : ~~ root 1 x.\nProof. by rewrite rootC oner_eq0. Qed.",
    "Lemma rootX x : root 'X x = (x == 0).\nProof. by rewrite rootE hornerX. Qed.",
    "Lemma rootN p x : root (- p) x = root p x.\nProof. by rewrite rootE hornerN oppr_eq0. Qed.",
    "Lemma root_size_gt1 a p : p != 0 -> root p a -> 1 < size p.\nProof.\nrewrite ltnNge => nz_p; apply: contraL => /size1_polyC Dp.\nby rewrite Dp rootC -polyC_eq0 -Dp.\nQed.",
    "Lemma root_XsubC a x : root ('X - a%:P) x = (x == a).\nProof. by rewrite rootE hornerXsubC subr_eq0. Qed.",
    "Lemma root_XaddC a x : root ('X + a%:P) x = (x == - a).\nProof. by rewrite -root_XsubC rmorphN opprK. Qed.",
    "Lemma multiplicity_XsubC p a :\n  {m | exists2 q, (p != 0) ==> ~~ root q a & p = q * ('X - a%:P) ^+ m}.\nProof.\nhave [n le_p_n] := ubnP (size p); elim: n => // n IHn in p le_p_n *.\nhave [-> | nz_p /=] := eqVneq p 0; first by exists 0, 0; rewrite ?mul0r.\nhave [/sig_eqW[p1 Dp] | nz_pa] := altP (factor_theorem p a); last first.\n  by exists 0%N, p; rewrite ?mulr1.\nhave nz_p1: p1 != 0 by apply: contraNneq nz_p => p1_0; rewrite Dp p1_0 mul0r.\nhave /IHn[m /sig2_eqW[q nz_qa Dp1]]: size p1 < n.\n  by rewrite Dp size_Mmonic ?monicXsubC // size_XsubC addn2 in le_p_n.\nby exists m.+1, q; [rewrite nz_p1 in nz_qa | rewrite exprSr mulrA -Dp1].\nQed.",
    "Lemma size_Xn_sub_1 n : n > 0 -> size ('X^n - 1 : {poly R}) = n.+1.\nProof. exact/size_XnsubC. Qed.",
    "Lemma monic_Xn_sub_1 n : n > 0 -> 'X^n - 1 \\is monic.\nProof. exact/monicXnsubC. Qed.",
    "Lemma unity_rootE n z : n.-unity_root z = (z ^+ n == 1).\nProof.\nby rewrite /root_of_unity rootE hornerD hornerN hornerXn hornerC subr_eq0.\nQed.",
    "Lemma unity_rootP n z : reflect (z ^+ n = 1) (n.-unity_root z).\nProof. by rewrite unity_rootE; apply: eqP. Qed.",
    "Lemma prim_order_exists n z :\n  n > 0 -> z ^+ n = 1 -> {m | m.-primitive_root z & (m %| n)}.\nProof.\nmove=> n_gt0 zn1.\nhave: exists m, (m > 0) && (z ^+ m == 1) by exists n; rewrite n_gt0 /= zn1.\ncase/ex_minnP=> m /andP[m_gt0 /eqP zm1] m_min.\nexists m.\n  apply/andP; split=> //; apply/eqfunP=> [[i]] /=.\n  rewrite leq_eqVlt unity_rootE.\n  case: eqP => [-> _ | _]; first by rewrite zm1 eqxx.\n  by apply: contraTF => zi1; rewrite -leqNgt m_min.\nhave: n %% m < m by rewrite ltn_mod.\napply: contraLR; rewrite -lt0n -leqNgt => nm_gt0; apply: m_min.\nby rewrite nm_gt0 /= expr_mod ?zn1.\nQed.",
    "Lemma prim_order_gt0 : n > 0. Proof. by case/andP: prim_z. Qed.",
    "Lemma prim_expr_order : z ^+ n = 1.\nProof.\ncase/andP: prim_z => _; rewrite -(prednK n_gt0) => /forallP/(_ ord_max).\nby rewrite unity_rootE eqxx eqb_id => /eqP.\nQed.",
    "Lemma prim_expr_mod i : z ^+ (i %% n) = z ^+ i.\nProof. exact: expr_mod prim_expr_order. Qed.",
    "Lemma prim_order_dvd i : (n %| i) = (z ^+ i == 1).\nProof.\nmove: n_gt0; rewrite -prim_expr_mod /dvdn -(ltn_mod i).\ncase: {i}(i %% n)%N => [|i] lt_i; first by rewrite !eqxx.\ncase/andP: prim_z => _ /forallP/(_ (Ordinal (ltnW lt_i)))/eqP.\nby rewrite unity_rootE eqn_leq andbC leqNgt lt_i.\nQed.",
    "Lemma eq_prim_root_expr i j : (z ^+ i == z ^+ j) = (i == j %[mod n]).\nProof.\nwlog le_ji: i j / j <= i.\n  move=> IH; case: (leqP j i) => [|/ltnW] /IH //.\n  by rewrite eq_sym (eq_sym (j %% n)%N).\nrewrite -{1}(subnKC le_ji) exprD -prim_expr_mod eqn_mod_dvd //.\nrewrite prim_order_dvd; apply/eqP/eqP=> [|->]; last by rewrite mulr1.\nmove/(congr1 ( *%R (z ^+ (n - j %% n)))); rewrite mulrA -exprD.\nby rewrite subnK ?prim_expr_order ?mul1r // ltnW ?ltn_mod.\nQed.",
    "Lemma exp_prim_root k : (n %/ gcdn k n).-primitive_root (z ^+ k).\nProof.\nset d := gcdn k n; have d_gt0: (0 < d)%N by rewrite gcdn_gt0 orbC n_gt0.\nhave [d_dv_k d_dv_n]: (d %| k /\\ d %| n)%N by rewrite dvdn_gcdl dvdn_gcdr.\nset q := (n %/ d)%N; rewrite /q.-primitive_root ltn_divRL // n_gt0.\napply/forallP=> i; rewrite unity_rootE -exprM -prim_order_dvd.\nrewrite -(divnK d_dv_n) -/q -(divnK d_dv_k) mulnAC dvdn_pmul2r //.\napply/eqP; apply/idP/idP=> [|/eqP->]; last by rewrite dvdn_mull.\nrewrite Gauss_dvdr; first by rewrite eqn_leq ltn_ord; apply: dvdn_leq.\nby rewrite /coprime gcdnC -(eqn_pmul2r d_gt0) mul1n muln_gcdl !divnK.\nQed.",
    "Lemma dvdn_prim_root m : (m %| n)%N -> m.-primitive_root (z ^+ (n %/ m)).\nProof.\nset k := (n %/ m)%N => m_dv_n; rewrite -{1}(mulKn m n_gt0) -divnA // -/k.\nby rewrite -{1}(@gcdn_idPl k n _) ?exp_prim_root // -(divnK m_dv_n) dvdn_mulr.\nQed.",
    "Lemma prim_root_eq0 : (z == 0) = (n == 0%N).\nProof.\nrewrite gtn_eqF//; apply/eqP => z0; have /esym/eqP := prim_expr_order.\nby rewrite z0 expr0n gtn_eqF//= oner_eq0.\nQed.",
    "Lemma prim_root_exp_coprime n z k :\n  n.-primitive_root z -> n.-primitive_root (z ^+ k) = coprime k n.\nProof.\nmove=> prim_z; have n_gt0 := prim_order_gt0 prim_z.\napply/idP/idP=> [prim_zk | co_k_n].\n  set d := gcdn k n; have dv_d_n: (d %| n)%N := dvdn_gcdr _ _.\n  rewrite /coprime -/d -(eqn_pmul2r n_gt0) mul1n -{2}(gcdnMl n d).\n  rewrite -{2}(divnK dv_d_n) (mulnC _ d) -muln_gcdr (gcdn_idPr _) //.\n  rewrite (prim_order_dvd prim_zk) -exprM -(prim_order_dvd prim_z).\n  by rewrite muln_divCA_gcd dvdn_mulr.\nhave zkn_1: z ^+ k ^+ n = 1 by rewrite exprAC (prim_expr_order prim_z) expr1n.\nhave{zkn_1} [m prim_zk dv_m_n]:= prim_order_exists n_gt0 zkn_1.\nsuffices /eqP <-: m == n by [].\nrewrite eqn_dvd dv_m_n -(@Gauss_dvdr n k m) 1?coprime_sym //=.\nby rewrite (prim_order_dvd prim_z) exprM (prim_expr_order prim_zk).\nQed.",
    "Lemma polyOverS (S1 S2 : {pred R}) :\n  {subset S1 <= S2} -> {subset polyOver S1 <= polyOver S2}.\nProof.\nby move=> sS12 p /(all_nthP 0)S1p; apply/(all_nthP 0)=> i /S1p; apply: sS12.\nQed.",
    "Lemma polyOver0 S : 0 \\is a polyOver S.\nProof. by rewrite qualifE /= polyseq0. Qed.",
    "Lemma polyOver_poly S n E :\n  (forall i, i < n -> E i \\in S) -> \\poly_(i < n) E i \\is a polyOver S.\nProof.\nmove=> S_E; apply/(all_nthP 0)=> i lt_i_p /=; rewrite coef_poly.\nby case: ifP => [/S_E// | /idP[]]; apply: leq_trans lt_i_p (size_poly n E).\nQed.",
    "Lemma polyOverP {p} : reflect (forall i, p`_i \\in S) (p \\in polyOver S).\nProof.\napply: (iffP (all_nthP 0)) => [Sp i | Sp i _]; last exact: Sp.\nby have [/Sp // | /(nth_default 0)->] := ltnP i (size p); apply: rpred0.\nQed.",
    "Lemma polyOverC c : (c%:P \\in polyOver S) = (c \\in S).\nProof.\nby rewrite qualifE /= polyseqC; case: eqP => [->|] /=; rewrite ?andbT ?rpred0.\nQed.",
    "Lemma polyOver_mulr_2closed : GRing.mulr_2closed (polyOver S).\nProof.\nmove=> p q /polyOverP Sp /polyOverP Sq; apply/polyOverP=> i.\nby rewrite coefM rpred_sum // => j _; rewrite rpredM.\nQed.",
    "Lemma polyOverZ : {in S & polyOver S, forall c p, c *: p \\is a polyOver S}.\nProof.\nby move=> c p Sc /polyOverP Sp; apply/polyOverP=> i; rewrite coefZ rpredM ?Sp.\nQed.",
    "Lemma polyOverX : 'X \\in polyOver S.\nProof. by rewrite qualifE /= polyseqX /= rpred0 rpred1. Qed.",
    "Lemma polyOverXn n : 'X^n \\in polyOver S.\nProof. by rewrite rpredX// polyOverX. Qed.",
    "Lemma rpred_horner : {in polyOver S & S, forall p x, p.[x] \\in S}.\nProof.\nmove=> p x /polyOverP Sp Sx; rewrite horner_coef rpred_sum // => i _.\nby rewrite rpredM ?rpredX.\nQed.",
    "Lemma polyOverXaddC c : ('X + c%:P \\in polyOver S) = (c \\in S).\nProof. by rewrite rpredDl ?polyOverX ?polyOverC. Qed.",
    "Lemma polyOverXnaddC n c : ('X^n + c%:P \\is a polyOver S) = (c \\in S).\nProof. by rewrite rpredDl ?polyOverXn// ?polyOverC. Qed.",
    "Lemma polyOverXsubC c : ('X - c%:P \\in polyOver S) = (c \\in S).\nProof. by rewrite rpredBl ?polyOverX ?polyOverC. Qed.",
    "Lemma polyOverXnsubC n c : ('X^n - c%:P \\is a polyOver S) = (c \\in S).\nProof. by rewrite rpredBl ?polyOverXn// ?polyOverC. Qed.",
    "Lemma coef_deriv p i : p^`()`_i = p`_i.+1 *+ i.+1.\nProof.\nrewrite coef_poly -subn1 ltn_subRL.\nby case: leqP => // /(nth_default 0) ->; rewrite mul0rn.\nQed.",
    "Lemma polyOver_deriv (ringS : semiringClosed R) :\n  {in polyOver ringS, forall p, p^`() \\is a polyOver ringS}.\nProof.\nby move=> p /polyOverP Kp; apply/polyOverP=> i; rewrite coef_deriv rpredMn ?Kp.\nQed.",
    "Lemma derivC c : c%:P^`() = 0.\nProof. by apply/polyP=> i; rewrite coef_deriv coef0 coefC mul0rn. Qed.",
    "Lemma derivX : ('X)^`() = 1.\nProof. by apply/polyP=> [[|i]]; rewrite coef_deriv coef1 coefX ?mul0rn. Qed.",
    "Lemma derivXn n : 'X^n^`() = 'X^n.-1 *+ n.\nProof.\ncase: n => [|n]; first exact: derivC.\napply/polyP=> i; rewrite coef_deriv coefMn !coefXn eqSS.\nby case: eqP => [-> // | _]; rewrite !mul0rn.\nQed.",
    "Lemma deriv0 : 0^`() = 0.\nProof. exact: linear0. Qed.",
    "Lemma derivD : {morph deriv : p q / p + q}.\nProof. exact: linearD. Qed.",
    "Lemma derivN : {morph deriv : p / - p}.\nProof. exact: linearN. Qed.",
    "Lemma derivB : {morph deriv : p q / p - q}.\nProof. exact: linearB. Qed.",
    "Lemma derivXsubC (a : R) : ('X - a%:P)^`() = 1.\nProof. by rewrite derivB derivX derivC subr0. Qed.",
    "Lemma derivMn n p : (p *+ n)^`() = p^`() *+ n.\nProof. exact: linearMn. Qed.",
    "Lemma derivMNn n p : (p *- n)^`() = p^`() *- n.\nProof. exact: linearMNn. Qed.",
    "Lemma derivZ c p : (c *: p)^`() = c *: p^`().\nProof. exact: linearZ. Qed.",
    "Lemma deriv_mulC c p : (c%:P * p)^`() = c%:P * p^`().\nProof. by rewrite !mul_polyC derivZ. Qed.",
    "Lemma derivMXaddC p c : (p * 'X + c%:P)^`() = p + p^`() * 'X.\nProof.\napply/polyP=> i; rewrite raddfD /= derivC addr0 coefD !(coefMX, coef_deriv).\nby case: i; rewrite ?addr0.\nQed.",
    "Lemma derivM p q : (p * q)^`() = p^`() * q + p * q^`().\nProof.\nelim/poly_ind: p => [|p b IHp]; first by rewrite !(mul0r, add0r, derivC).\nrewrite mulrDl -mulrA -commr_polyX mulrA -[_ * 'X]addr0 raddfD /= !derivMXaddC.\nby rewrite deriv_mulC IHp !mulrDl -!mulrA !commr_polyX !addrA.\nQed.",
    "Lemma derivn0 p : p^`(0) = p.\nProof. by []. Qed.",
    "Lemma derivn1 p : p^`(1) = p^`().\nProof. by []. Qed.",
    "Lemma derivnS p n : p^`(n.+1) = p^`(n)^`().\nProof. by []. Qed.",
    "Lemma derivSn p n : p^`(n.+1) = p^`()^`(n).\nProof. exact: iterSr. Qed.",
    "Lemma coef_derivn n p i : p^`(n)`_i = p`_(n + i) *+ (n + i) ^_ n.\nProof.\nelim: n i => [|n IHn] i; first by rewrite ffactn0 mulr1n.\nby rewrite derivnS coef_deriv IHn -mulrnA ffactnSr addSnnS addKn.\nQed.",
    "Lemma polyOver_derivn (ringS : semiringClosed R) :\n  {in polyOver ringS, forall p n, p^`(n) \\is a polyOver ringS}.\nProof.\nmove=> p /polyOverP Kp /= n; apply/polyOverP=> i.\nby rewrite coef_derivn rpredMn.\nQed.",
    "Lemma derivnC c n : c%:P^`(n) = if n == 0 then c%:P else 0.\nProof. by case: n => // n; rewrite derivSn derivC linear0. Qed.",
    "Lemma derivnD n : {morph derivn n : p q / p + q}.\nProof. exact: linearD. Qed.",
    "Lemma derivnB n : {morph derivn n : p q / p - q}.\nProof. exact: linearB. Qed.",
    "Lemma derivnMn n m p : (p *+ m)^`(n) = p^`(n) *+ m.\nProof. exact: linearMn. Qed.",
    "Lemma derivnMNn n m p : (p *- m)^`(n) = p^`(n) *- m.\nProof. exact: linearMNn. Qed.",
    "Lemma derivnN n : {morph derivn n : p / - p}.\nProof. exact: linearN. Qed.",
    "Lemma derivnZ n : scalable (derivn n).\nProof. exact: linearZZ. Qed.",
    "Lemma derivnXn m n : 'X^m^`(n) = 'X^(m - n) *+ m ^_ n.\nProof.\napply/polyP=>i; rewrite coef_derivn coefMn !coefXn.\ncase: (ltnP m n) => [lt_m_n | le_m_n].\n  by rewrite eqn_leq leqNgt ltn_addr // mul0rn ffact_small.\nby rewrite -{1 3}(subnKC le_m_n) eqn_add2l; case: eqP => [->|]; rewrite ?mul0rn.\nQed.",
    "Lemma derivnMXaddC n p c :\n  (p * 'X + c%:P)^`(n.+1) = p^`(n) *+ n.+1 + p^`(n.+1) * 'X.\nProof.\nelim: n => [|n IHn]; first by rewrite derivn1 derivMXaddC.\nrewrite derivnS IHn derivD derivM derivX mulr1 derivMn -!derivnS.\nby rewrite addrA addrAC -mulrSr.\nQed.",
    "Lemma derivn_poly0 p n : size p <= n -> p^`(n) = 0.\nProof.\nmove=> le_p_n; apply/polyP=> i; rewrite coef_derivn.\nrewrite nth_default; first by rewrite mul0rn coef0.\nexact/(leq_trans le_p_n)/leq_addr.\nQed.",
    "Lemma lt_size_deriv (p : {poly R}) : p != 0 -> size p^`() < size p.\nProof. by move=> /polySpred->; apply: size_poly. Qed.",
    "Lemma coef_nderivn n p i : p^`N(n)`_i = p`_(n + i) *+  'C(n + i, n).\nProof.\nrewrite coef_poly ltn_subRL; case: leqP => // le_p_ni.\nby rewrite nth_default ?mul0rn.\nQed.",
    "Lemma nderivn_def n p : p^`(n) = p^`N(n) *+ n`!.\nProof.\nby apply/polyP=> i; rewrite coefMn coef_nderivn coef_derivn -mulrnA bin_ffact.\nQed.",
    "Lemma polyOver_nderivn (ringS : semiringClosed R) :\n  {in polyOver ringS, forall p n, p^`N(n) \\in polyOver ringS}.\nProof.\nmove=> p /polyOverP Sp /= n; apply/polyOverP=> i.\nby rewrite coef_nderivn rpredMn.\nQed.",
    "Lemma nderivn0 p : p^`N(0) = p.\nProof. by rewrite -[p^`N(0)](nderivn_def 0). Qed.",
    "Lemma nderivn1 p : p^`N(1) = p^`().\nProof. by rewrite -[p^`N(1)](nderivn_def 1). Qed.",
    "Lemma nderivnC c n : (c%:P)^`N(n) = if n == 0 then c%:P else 0.\nProof.\napply/polyP=> i; rewrite coef_nderivn.\nby case: n => [|n]; rewrite ?bin0 // coef0 coefC mul0rn.\nQed.",
    "Lemma nderivnXn m n : 'X^m^`N(n) = 'X^(m - n) *+ 'C(m, n).\nProof.\napply/polyP=> i; rewrite coef_nderivn coefMn !coefXn.\nhave [lt_m_n | le_n_m] := ltnP m n.\n  by rewrite eqn_leq leqNgt ltn_addr // mul0rn bin_small.\nby rewrite -{1 3}(subnKC le_n_m) eqn_add2l; case: eqP => [->|]; rewrite ?mul0rn.\nQed.",
    "Lemma nderivnD n : {morph nderivn n : p q / p + q}.\nProof. exact: linearD. Qed.",
    "Lemma nderivnB n : {morph nderivn n : p q / p - q}.\nProof. exact: linearB. Qed.",
    "Lemma nderivnMn n m p : (p *+ m)^`N(n) = p^`N(n) *+ m.\nProof. exact: linearMn. Qed.",
    "Lemma nderivnMNn n m p : (p *- m)^`N(n) = p^`N(n) *- m.\nProof. exact: linearMNn. Qed.",
    "Lemma nderivnN n : {morph nderivn n : p / - p}.\nProof. exact: linearN. Qed.",
    "Lemma nderivnZ n : scalable (nderivn n).\nProof. exact: linearZZ. Qed.",
    "Lemma nderivnMXaddC n p c :\n  (p * 'X + c%:P)^`N(n.+1) = p^`N(n) + p^`N(n.+1) * 'X.\nProof.\napply/polyP=> i; rewrite coef_nderivn !coefD !coefMX coefC.\nrewrite !addSn /= !coef_nderivn addr0 binS mulrnDr addrC; congr (_ + _).\nby rewrite addSnnS; case: i; rewrite // addn0 bin_small.\nQed.",
    "Lemma nderivn_poly0 p n : size p <= n -> p^`N(n) = 0.\nProof.\nmove=> le_p_n; apply/polyP=> i; rewrite coef_nderivn.\nrewrite nth_default; first by rewrite mul0rn coef0.\nexact/(leq_trans le_p_n)/leq_addr.\nQed.",
    "Lemma nderiv_taylor p x h :\n  GRing.comm x h -> p.[x + h] = \\sum_(i < size p) p^`N(i).[x] * h ^+ i.\nProof.\nmove/commrX=> cxh; elim/poly_ind: p => [|p c IHp].\n  by rewrite size_poly0 big_ord0 horner0.\nrewrite hornerMXaddC size_MXaddC.\nhave [-> | nz_p] := eqVneq p 0.\n  rewrite horner0 !simp; have [-> | _] := c =P 0; first by rewrite big_ord0.\n  by rewrite size_poly0 big_ord_recl big_ord0 nderivn0 hornerC !simp.\nrewrite big_ord_recl nderivn0 !simp hornerMXaddC addrAC; congr (_ + _).\nrewrite mulrDr {}IHp !big_distrl polySpred //= big_ord_recl /= mulr1 -addrA.\nrewrite nderivn0 /bump /(addn 1) /=; congr (_ + _).\nrewrite !big_ord_recr /= nderivnMXaddC -mulrA -exprSr -polySpred // !addrA.\ncongr (_ + _); last by rewrite (nderivn_poly0 (leqnn _)) !simp.\nrewrite addrC -big_split /=; apply: eq_bigr => i _.\nby rewrite nderivnMXaddC !hornerE_comm /= mulrDl -!mulrA -exprSr cxh.\nQed.",
    "Lemma nderiv_taylor_wide n p x h :\n    GRing.comm x h -> size p <= n ->\n  p.[x + h] = \\sum_(i < n) p^`N(i).[x] * h ^+ i.\nProof.\nmove/nderiv_taylor=> -> le_p_n.\nrewrite (big_ord_widen n (fun i => p^`N(i).[x] * h ^+ i)) // big_mkcond.\napply: eq_bigr => i _; case: leqP => // /nderivn_poly0->.\nby rewrite horner0 simp.\nQed.",
    "Lemma eq_poly n E1 E2 : (forall i, i < n -> E1 i = E2 i) ->\n  poly n E1 = poly n E2 :> {poly R}.\nProof. by move=> E; rewrite !poly_def; apply: eq_bigr => i _; rewrite E. Qed.",
    "Lemma prim_root_pcharF p : (p %| n)%N -> p \\in [pchar R] = false.\nProof.\nmove=> pn; apply: contraTF isT => pchar_p; have p_prime := pcharf_prime pchar_p.\nhave /dvdnP[[|k] n_eq_kp] := pn; first by rewrite n_eq_kp in (n_gt0).\nhave /eqP := prim_expr_order prim_z; rewrite n_eq_kp exprM.\nrewrite -pFrobenius_autE -(pFrobenius_aut1 pchar_p) -subr_eq0 -rmorphB/=.\nrewrite pFrobenius_autE expf_eq0// prime_gt0//= subr_eq0 => /eqP.\nmove=> /eqP; rewrite -(prim_order_dvd prim_z) n_eq_kp.\nrewrite -[X in _ %| X]muln1 dvdn_pmul2l ?dvdn1// => /eqP peq1.\nby rewrite peq1 in p_prime.\nQed.",
    "Lemma pchar_prim_root : [pchar R]^'.-nat n.\nProof. by apply/pnatP=> // p pp pn; rewrite inE/= prim_root_pcharF. Qed.",
    "Lemma prim_root_pi_eq0 m : \\pi(n).-nat m -> m%:R != 0 :> R.\nProof.\nby rewrite natf_neq0_pchar; apply: sub_in_pnat => p _; apply: pnatPpi pchar_prim_root.\nQed.",
    "Lemma prim_root_dvd_eq0 m : (m %| n)%N -> m%:R != 0 :> R.\nProof.\ncase: m => [|m mn]; first by rewrite dvd0n gtn_eqF.\nby rewrite prim_root_pi_eq0 ?(sub_in_pnat (in1W (pi_of_dvd mn _))) ?pnat_pi.\nQed.",
    "Lemma prim_root_natf_neq0 : n%:R != 0 :> R.\nProof. by rewrite prim_root_dvd_eq0. Qed.",
    "Lemma map_polyE p : map_poly p = Poly (map f p).\nProof.\nrewrite /map_poly unlock; congr Poly.\napply: (@eq_from_nth _ 0); rewrite size_mkseq ?size_map // => i lt_i_p.\nby rewrite [RHS](nth_map 0) ?nth_mkseq.\nQed.",
    "Lemma map_poly0 : 0^f = 0.\nProof. by rewrite map_polyE polyseq0. Qed.",
    "Lemma eq_map_poly (g : aR -> rR) : f =1 g -> map_poly f =1 map_poly g.\nProof. by move=> eq_fg p; rewrite !map_polyE (eq_map eq_fg). Qed.",
    "Lemma map_poly_id g (p : {poly iR}) :\n  {in (p : seq iR), g =1 id} -> map_poly g p = p.\nProof. by move=> g_id; rewrite map_polyE map_id_in ?polyseqK. Qed.",
    "Lemma coef_map_id0 p i : f 0 = 0 -> (p^f)`_i = f p`_i.\nProof.\nby move=> f0; rewrite coef_poly; case: ltnP => // le_p_i; rewrite nth_default.\nQed.",
    "Lemma map_Poly_id0 s : f 0 = 0 -> (Poly s)^f = Poly (map f s).\nProof.\nmove=> f0; apply/polyP=> j; rewrite coef_map_id0 ?coef_Poly //.\nhave [/(nth_map 0 0)->// | le_s_j] := ltnP j (size s).\nby rewrite !nth_default ?size_map.\nQed.",
    "Lemma map_poly_comp_id0 (g : iR -> aR) p :\n  f 0 = 0 -> map_poly (f \\o g) p = (map_poly g p)^f.\nProof. by move=> f0; rewrite map_polyE map_comp -map_Poly_id0 -?map_polyE. Qed.",
    "Lemma size_map_poly_id0 p : f (lead_coef p) != 0 -> size p^f = size p.\nProof. by move=> nz_fp; apply: size_poly_eq. Qed.",
    "Lemma map_poly_eq0_id0 p : f (lead_coef p) != 0 -> (p^f == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 => /size_map_poly_id0->. Qed.",
    "Lemma lead_coef_map_id0 p :\n  f 0 = 0 -> f (lead_coef p) != 0 -> lead_coef p^f = f (lead_coef p).\nProof.\nby move=> f0 nz_fp; rewrite lead_coefE coef_map_id0 ?size_map_poly_id0.\nQed.",
    "Lemma size_map_inj_poly p : size p^f = size p.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite map_poly0 !size_poly0.\nby rewrite size_map_poly_id0 // -f_0 (inj_eq inj_f) lead_coef_eq0.\nQed.",
    "Lemma map_inj_poly : injective (map_poly f).\nProof.\nmove=> p q /polyP eq_pq; apply/polyP=> i; apply: inj_f.\nby rewrite -!coef_map_id0 ?eq_pq.\nQed.",
    "Lemma lead_coef_map_inj p : lead_coef p^f = f (lead_coef p).\nProof. by rewrite !lead_coefE size_map_inj_poly coef_map_id0. Qed.",
    "Lemma map_polyK (f : aR -> rR) g :\n  cancel g f -> f 0 = 0 -> cancel (map_poly g) (map_poly f).\nProof.\nby move=> gK f_0 p; rewrite /= -map_poly_comp_id0 ?map_poly_id // => x _ //=.\nQed.",
    "Lemma eq_in_map_poly_id0 (f g : aR -> rR) (S : addrClosed aR) :\n    f 0 = 0 -> g 0 = 0 -> {in S, f =1 g} ->\n  {in polyOver S, map_poly f =1 map_poly g}.\nProof.\nmove=> f0 g0 eq_fg p pP; apply/polyP => i.\nby rewrite !coef_map_id0// eq_fg// (polyOverP _).\nQed.",
    "Lemma eq_in_map_poly (f g : {additive aR -> rR}) (S : addrClosed aR) :\n  {in S, f =1 g} -> {in polyOver S, map_poly f =1 map_poly g}.\nProof. by move=> /eq_in_map_poly_id0; apply; rewrite //?raddf0. Qed.",
    "Lemma coef_map p i : p^f`_i = f p`_i.\nProof. exact: coef_map_id0 (raddf0 f). Qed.",
    "Lemma map_Poly s : (Poly s)^f = Poly (map f s).\nProof. exact: map_Poly_id0 (raddf0 f). Qed.",
    "Lemma map_poly_comp (g : iR -> aR) p :\n  map_poly (f \\o g) p = map_poly f (map_poly g p).\nProof. exact: map_poly_comp_id0 (raddf0 f). Qed.",
    "Lemma map_polyC a : (a%:P)^f = (f a)%:P.\nProof. by apply/polyP=> i; rewrite !(coef_map, coefC) -!mulrb raddfMn. Qed.",
    "Lemma lead_coef_map_eq p :\n  f (lead_coef p) != 0 -> lead_coef p^f = f (lead_coef p).\nProof. exact: lead_coef_map_id0 (raddf0 f). Qed.",
    "Lemma map_polyZ c p : (c *: p)^f = f c *: p^f.\nProof. by apply/polyP=> i; rewrite !(coef_map, coefZ) /= rmorphM. Qed.",
    "Lemma map_polyX : ('X)^f = 'X.\nProof. by apply/polyP=> i; rewrite coef_map !coefX /= rmorph_nat. Qed.",
    "Lemma map_polyXn n : ('X^n)^f = 'X^n.\nProof. by rewrite rmorphXn /= map_polyX. Qed.",
    "Lemma map_polyXaddC x :  ('X + x%:P)^f = 'X + (f x)%:P.\nProof. by rewrite raddfD/= map_polyX map_polyC. Qed.",
    "Lemma map_polyXsubC x : ('X - x%:P)^f = 'X - (f x)%:P.\nProof. by rewrite raddfB/= map_polyX map_polyC. Qed.",
    "Lemma map_prod_XsubC I (rI : seq I) P F :\n  (\\prod_(i <- rI | P i) ('X - (F i)%:P))^f =\n    \\prod_(i <- rI | P i) ('X - (f (F i))%:P).\nProof.\nby rewrite rmorph_prod//; apply/eq_bigr => x /=; rewrite map_polyXsubC.\nQed.",
    "Lemma prod_map_poly (ar : seq aR) P :\n  \\prod_(x <- map f ar | P x) ('X - x%:P) =\n    (\\prod_(x <- ar | P (f x)) ('X - x%:P))^f.\nProof. by rewrite big_map map_prod_XsubC. Qed.",
    "Lemma monic_map p : p \\is monic -> p^f \\is monic.\nProof.\nmove/monicP=> mon_p; rewrite monicE.\nby rewrite lead_coef_map_eq mon_p /= rmorph1 ?oner_neq0.\nQed.",
    "Lemma horner_map p x : p^f.[f x] = f p.[x].\nProof.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !(rmorph0, horner0).\nrewrite hornerMXaddC !rmorphD !rmorphM /=.\nby rewrite map_polyX map_polyC hornerMXaddC IHp.\nQed.",
    "Lemma map_comm_poly p x : comm_poly p x -> comm_poly p^f (f x).\nProof. by rewrite /comm_poly horner_map -!rmorphM // => ->. Qed.",
    "Lemma map_comm_coef p x : comm_coef p x -> comm_coef p^f (f x).\nProof. by move=> cpx i; rewrite coef_map -!rmorphM ?cpx. Qed.",
    "Lemma rmorph_root p x : root p x -> root p^f (f x).\nProof. by move/eqP=> px0; rewrite rootE horner_map px0 rmorph0. Qed.",
    "Lemma rmorph_unity_root n z : n.-unity_root z -> n.-unity_root (f z).\nProof.\nmove/rmorph_root; rewrite rootE rmorphB hornerD hornerN.\nby rewrite /= map_polyXn rmorph1 hornerC hornerXn subr_eq0 unity_rootE.\nQed.",
    "Lemma horner_morphC a : horner_morph cfu a%:P = f a.\nProof. by rewrite /horner_morph map_polyC hornerC. Qed.",
    "Lemma horner_morphX : horner_morph cfu 'X = u.\nProof. by rewrite /horner_morph map_polyX hornerX. Qed.",
    "Lemma deriv_map p : p^f^`() = (p^`())^f.\nProof. by apply/polyP => i; rewrite !(coef_map, coef_deriv) //= rmorphMn. Qed.",
    "Lemma derivn_map p n : p^f^`(n) = (p^`(n))^f.\nProof. by apply/polyP => i; rewrite !(coef_map, coef_derivn) //= rmorphMn. Qed.",
    "Lemma nderivn_map p n : p^f^`N(n) = (p^`N(n))^f.\nProof. by apply/polyP => i; rewrite !(coef_map, coef_nderivn) //= rmorphMn. Qed.",
    "Lemma mapf_root (F : fieldType) (R : nzRingType) (f : {rmorphism F -> R})\n  (p : {poly F}) (x : F) : root (map_poly f p) (f x) = root p x.\nProof. by rewrite !rootE horner_map fmorph_eq0. Qed.",
    "Lemma poly_morphX_comm : commr_rmorph (pf \\o polyC) (pf 'X).\nProof. by move=> a; rewrite /GRing.comm /= -!rmorphM // commr_polyX. Qed.",
    "Lemma poly_initial : pf =1 horner_morph poly_morphX_comm.\nProof.\napply: poly_ind => [|p a IHp]; first by rewrite !rmorph0.\nby rewrite !rmorphD !rmorphM /= -{}IHp horner_morphC ?horner_morphX.\nQed.",
    "Lemma size_map_polyC p : size p^:P = size p.\nProof. exact/(size_map_inj_poly polyC_inj). Qed.",
    "Lemma map_polyC_eq0 p : (p^:P == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 size_map_polyC. Qed.",
    "Lemma root_polyC p x : root p^:P x%:P = root p x.\nProof. by rewrite rootE horner_map polyC_eq0. Qed.",
    "Lemma comp_polyE p q : p \\Po q = \\sum_(i < size p) p`_i *: q^+i.\nProof.\nby rewrite [p \\Po q]horner_poly; apply: eq_bigr => i _; rewrite mul_polyC.\nQed.",
    "Lemma coef_comp_poly p q n :\n  (p \\Po q)`_n = \\sum_(i < size p) p`_i * (q ^+ i)`_n.\nProof. by rewrite comp_polyE coef_sum; apply: eq_bigr => i; rewrite coefZ. Qed.",
    "Lemma polyOver_comp (ringS : semiringClosed R) :\n  {in polyOver ringS &, forall p q, p \\Po q \\in polyOver ringS}.\nProof.\nmove=> p q /polyOverP Sp Sq; rewrite comp_polyE rpred_sum // => i _.\nby rewrite polyOverZ ?rpredX.\nQed.",
    "Lemma comp_polyCr p c : p \\Po c%:P = p.[c]%:P.\nProof. exact: horner_map. Qed.",
    "Lemma comp_poly0r p : p \\Po 0 = (p`_0)%:P.\nProof. by rewrite comp_polyCr horner_coef0. Qed.",
    "Lemma comp_polyC c p : c%:P \\Po p = c%:P.\nProof. by rewrite /(_ \\Po p) map_polyC hornerC. Qed.",
    "Lemma comp_poly0 p : 0 \\Po p = 0.\nProof. exact: raddf0. Qed.",
    "Lemma comp_polyD p q r : (p + q) \\Po r = (p \\Po r) + (q \\Po r).\nProof. exact: raddfD. Qed.",
    "Lemma comp_polyB p q r : (p - q) \\Po r = (p \\Po r) - (q \\Po r).\nProof. exact: raddfB. Qed.",
    "Lemma comp_polyZ c p q : (c *: p) \\Po q = c *: (p \\Po q).\nProof. exact: linearZZ. Qed.",
    "Lemma comp_polyXr p : p \\Po 'X = p.\nProof. by rewrite -{2}/(idfun p) poly_initial. Qed.",
    "Lemma comp_polyX p : 'X \\Po p = p.\nProof. by rewrite /(_ \\Po p) map_polyX hornerX. Qed.",
    "Lemma comp_poly_MXaddC c p q : (p * 'X + c%:P) \\Po q = (p \\Po q) * q + c%:P.\nProof.\nby rewrite /(_ \\Po q) rmorphD rmorphM /= map_polyX map_polyC hornerMXaddC.\nQed.",
    "Lemma comp_polyXaddC_K p z : (p \\Po ('X + z%:P)) \\Po ('X - z%:P) = p.\nProof.\nhave addzK: ('X + z%:P) \\Po ('X - z%:P) = 'X.\n  by rewrite raddfD /= comp_polyC comp_polyX subrK.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !comp_poly0.\nrewrite comp_poly_MXaddC linearD /= comp_polyC {1}/comp_poly rmorphM /=.\nby rewrite hornerM_comm /comm_poly -!/(_ \\Po _) ?IHp ?addzK ?commr_polyX.\nQed.",
    "Lemma size_comp_poly_leq p q :\n  size (p \\Po q) <= ((size p).-1 * (size q).-1).+1.\nProof.\nrewrite comp_polyE (leq_trans (size_sum _ _ _)) //; apply/bigmax_leqP => i _.\nrewrite (leq_trans (size_scale_leq _ _))//.\nrewrite (leq_trans (size_poly_exp_leq _ _))//.\nby rewrite ltnS mulnC leq_mul // -{2}(subnKC (valP i)) leq_addr.\nQed.",
    "Lemma comp_Xn_poly p n : 'X^n \\Po p = p ^+ n.\nProof. by rewrite /(_ \\Po p) map_polyXn hornerXn. Qed.",
    "Lemma coef_comp_poly_Xn p n i : 0 < n ->\n  (p \\Po 'X^n)`_i = if n %| i then p`_(i %/ n) else 0.\nProof.\nmove=> n_gt0; rewrite comp_polyE; under eq_bigr do rewrite -exprM mulnC.\nrewrite coef_sumMXn/=; case: dvdnP => [[j ->]|nD]; last first.\n   by rewrite big1// => j /eqP ?; case: nD; exists j.\nunder eq_bigl do rewrite eqn_mul2r gtn_eqF//.\nby rewrite big_ord1_eq if_nth ?leqVgt ?mulnK.\nQed.",
    "Lemma comp_poly_Xn p n : 0 < n ->\n  p \\Po 'X^n = \\poly_(i < size p * n) if n %| i then p`_(i %/ n) else 0.\nProof.\nmove=> n_gt0; apply/polyP => i; rewrite coef_comp_poly_Xn // coef_poly.\ncase: dvdnP => [[k ->]|]; last by rewrite if_same.\nby rewrite mulnK // ltn_mul2r n_gt0 if_nth ?leqVgt.\nQed.",
    "Lemma map_comp_poly (aR rR : nzRingType) (f : {rmorphism aR -> rR}) p q :\n  map_poly f (p \\Po q) = map_poly f p \\Po map_poly f q.\nProof.\nelim/poly_ind: p => [|p a IHp]; first by rewrite !raddf0.\nrewrite comp_poly_MXaddC !rmorphD !rmorphM /= !map_polyC map_polyX.\nby rewrite comp_poly_MXaddC -IHp.\nQed.",
    "Lemma size_even_poly p : size (even_poly p) <= uphalf (size p).\nProof. exact: size_poly. Qed.",
    "Lemma coef_even_poly p i : (even_poly p)`_i = p`_i.*2.\nProof. by rewrite coef_poly gtn_uphalf_double if_nth ?leqVgt. Qed.",
    "Lemma even_polyE s p : size p <= s.*2 -> even_poly p = \\poly_(i < s) p`_i.*2.\nProof.\nmove=> pLs2; apply/polyP => i; rewrite coef_even_poly !coef_poly if_nth //.\nby case: ltnP => //= ?; rewrite (leq_trans pLs2) ?leq_double.\nQed.",
    "Lemma size_even_poly_eq p : odd (size p) ->\n  size (even_poly p) = uphalf (size p).\nProof.\nmove=> p_even; rewrite size_poly_eq// double_pred odd_uphalfK//=.\nby rewrite lead_coef_eq0 -size_poly_eq0; case: size p_even.\nQed.",
    "Lemma even_polyD p q : even_poly (p + q) = even_poly p + even_poly q.\nProof. by apply/polyP => i; rewrite !(coef_even_poly, coefD). Qed.",
    "Lemma even_polyZ k p : even_poly (k *: p) = k *: even_poly p.\nProof. by apply/polyP => i; rewrite !(coefZ, coef_even_poly). Qed.",
    "Lemma even_polyC (c : R) : even_poly c%:P = c%:P.\nProof. by apply/polyP => i; rewrite coef_even_poly !coefC; case: i. Qed.",
    "Lemma size_odd_poly p : size (odd_poly p) <= (size p)./2.\nProof. exact: size_poly. Qed.",
    "Lemma coef_odd_poly p i : (odd_poly p)`_i = p`_i.*2.+1.\nProof. by rewrite coef_poly gtn_half_double if_nth ?leqVgt. Qed.",
    "Lemma odd_polyE s p :\n  size p <= s.*2.+1 -> odd_poly p = \\poly_(i < s) p`_i.*2.+1.\nProof.\nmove=> pLs2; apply/polyP => i; rewrite coef_odd_poly !coef_poly if_nth //.\nby case: ltnP => //= ?; rewrite (leq_trans pLs2) ?ltnS ?leq_double.\nQed.",
    "Lemma odd_polyC (c : R) : odd_poly c%:P = 0.\nProof. by apply/polyP => i; rewrite coef_odd_poly !coefC; case: i. Qed.",
    "Lemma odd_polyD p q : odd_poly (p + q) = odd_poly p + odd_poly q.\nProof. by apply/polyP => i; rewrite !(coef_odd_poly, coefD). Qed.",
    "Lemma odd_polyZ k p : odd_poly (k *: p) = k *: odd_poly p.\nProof. by apply/polyP => i; rewrite !(coefZ, coef_odd_poly). Qed.",
    "Lemma size_odd_poly_eq p : ~~ odd (size p) -> size (odd_poly p) = (size p)./2.\nProof.\nhave [->|p_neq0] := eqVneq p 0; first by rewrite odd_polyC size_poly0.\nmove=> p_odd; rewrite size_poly_eq// -subn1 doubleB subn2 even_halfK//.\nrewrite prednK ?lead_coef_eq0// ltn_predRL.\nby move: p_neq0 p_odd; rewrite -size_poly_eq0; case: (size p) => [|[]].\nQed.",
    "Lemma odd_polyMX p : odd_poly (p * 'X) = even_poly p.\nProof.\nhave [->|pN0] := eqVneq p 0; first by rewrite mul0r even_polyC odd_polyC.\nby apply/polyP => i; rewrite !coef_poly size_mulX // coefMX.\nQed.",
    "Lemma even_polyMX p : even_poly (p * 'X) = odd_poly p * 'X.\nProof.\nhave [->|pN0] := eqVneq p 0; first by rewrite mul0r even_polyC odd_polyC mul0r.\nby apply/polyP => -[|i]; rewrite !(coefMX, coef_poly, if_same, size_mulX).\nQed.",
    "Lemma sum_even_poly p :\n  \\sum_(i < size p | ~~ odd i) p`_i *: 'X^i = even_poly p \\Po 'X^2.\nProof.\napply/polyP => i; rewrite coef_comp_poly_Xn// coef_sumMXn coef_even_poly.\nrewrite (big_ord1_cond_eq _ _ (negb \\o _))/= -dvdn2 andbC -muln2.\nby case: dvdnP => //= -[k ->]; rewrite mulnK// if_nth ?leqVgt.\nQed.",
    "Lemma sum_odd_poly p :\n  \\sum_(i < size p | odd i) p`_i *: 'X^i = (odd_poly p \\Po 'X^2) * 'X.\nProof.\napply/polyP => i; rewrite coefMX coef_comp_poly_Xn// coef_sumMXn coef_odd_poly/=.\ncase: i => [|i]//=; first by rewrite big_andbC big1// => -[[|j]//].\nrewrite big_ord1_cond_eq/= -dvdn2 andbC -muln2.\nby case: dvdnP => //= -[k ->]; rewrite mulnK// if_nth ?leqVgt.\nQed.",
    "Lemma poly_even_odd p : even_poly p \\Po 'X^2 + (odd_poly p \\Po 'X^2) * 'X = p.\nProof.\nrewrite -sum_even_poly -sum_odd_poly addrC -(bigID _ xpredT).\nby rewrite -[RHS]coefK poly_def.\nQed.",
    "Lemma size_take_poly m p : size (take_poly m p) <= m.\nProof. exact: size_poly. Qed.",
    "Lemma coef_take_poly m p i : (take_poly m p)`_i = if i < m then p`_i else 0.\nProof. exact: coef_poly. Qed.",
    "Lemma take_poly_id m p : size p <= m -> take_poly m p = p.\nProof.\nmove=> /leq_trans gep; apply/polyP => i; rewrite coef_poly if_nth//=.\nby case: ltnP => // /gep->.\nQed.",
    "Lemma take_polyD m p q : take_poly m (p + q) = take_poly m p + take_poly m q.\nProof.\nby apply/polyP => i; rewrite !(coefD, coef_poly); case: leqP; rewrite ?add0r.\nQed.",
    "Lemma take_polyZ k m p : take_poly m (k *: p) = k *: take_poly m p.\nProof.\napply/polyP => i; rewrite !(coefZ, coef_take_poly); case: leqP => //.\nby rewrite mulr0.\nQed.",
    "Lemma take_poly_sum m I r P (p : I -> {poly R}) :\n  take_poly m (\\sum_(i <- r | P i) p i) = \\sum_(i <- r| P i) take_poly m (p i).\nProof. exact: linear_sum. Qed.",
    "Lemma take_poly0l p : take_poly 0 p = 0.\nProof. exact/size_poly_leq0P/size_take_poly. Qed.",
    "Lemma take_poly0r m : take_poly m 0 = 0.\nProof. exact: linear0. Qed.",
    "Lemma take_polyMXn m n p :\n  take_poly m (p * 'X^n) = take_poly (m - n) p * 'X^n.\nProof.\nhave [->|/eqP p_neq0] := p =P 0; first by rewrite !(mul0r, take_poly0r).\napply/polyP => i; rewrite !(coef_take_poly, coefMXn).\nby have [iLn|nLi] := leqP n i; rewrite ?if_same// ltn_sub2rE.\nQed.",
    "Lemma take_polyMXn_0 n p : take_poly n (p * 'X^n) = 0.\nProof. by rewrite take_polyMXn subnn take_poly0l mul0r. Qed.",
    "Lemma take_polyDMXn n p q : size p <= n -> take_poly n (p + q * 'X^n) = p.\nProof. by move=> ?; rewrite take_polyD take_poly_id// take_polyMXn_0 addr0. Qed.",
    "Lemma coef_drop_poly m p i : (drop_poly m p)`_i = p`_(i + m).\nProof. by rewrite coef_poly ltn_subRL addnC if_nth ?leqVgt. Qed.",
    "Lemma drop_poly_eq0 m p : size p <= m -> drop_poly m p = 0.\nProof.\nmove=> sLm; apply/polyP => i; rewrite coef_poly coef0 ltn_subRL addnC.\nby rewrite if_nth ?leqVgt// nth_default// (leq_trans _ (leq_addl _ _)).\nQed.",
    "Lemma size_drop_poly n p : size (drop_poly n p) = (size p - n)%N.\nProof.\nhave [pLn|nLp] := leqP (size p) n.\n  by rewrite (eqP pLn) drop_poly_eq0 ?size_poly0.\nhave p_neq0 : p != 0 by rewrite -size_poly_gt0 (leq_trans _ nLp).\nby rewrite size_poly_eq// predn_sub subnK ?lead_coef_eq0// -ltnS -polySpred.\nQed.",
    "Lemma sum_drop_poly n p :\n  \\sum_(n <= i < size p) p`_i *: 'X^i = drop_poly n p * 'X^n.\nProof.\nrewrite (big_addn 0) big_mkord /drop_poly poly_def mulr_suml.\nby apply: eq_bigr => i _; rewrite exprD scalerAl.\nQed.",
    "Lemma drop_polyD m p q : drop_poly m (p + q) = drop_poly m p + drop_poly m q.\nProof. by apply/polyP => i; rewrite coefD !coef_drop_poly coefD. Qed.",
    "Lemma drop_polyZ k m p : drop_poly m (k *: p) = k *: drop_poly m p.\nProof. by apply/polyP => i; rewrite coefZ !coef_drop_poly coefZ. Qed.",
    "Lemma drop_poly_sum m I r P (p : I -> {poly R}) :\n  drop_poly m (\\sum_(i <- r | P i) p i) = \\sum_(i <- r | P i) drop_poly m (p i).\nProof. exact: linear_sum. Qed.",
    "Lemma drop_poly0l p : drop_poly 0 p = p.\nProof. by apply/polyP => i; rewrite coef_poly subn0 addn0 if_nth ?leqVgt. Qed.",
    "Lemma drop_poly0r m : drop_poly m 0 = 0. Proof. exact: linear0. Qed.",
    "Lemma drop_polyMXn m n p :\n  drop_poly m (p * 'X^n) = drop_poly (m - n) p * 'X^(n - m).\nProof.\nhave [->|p_neq0] := eqVneq p 0; first by rewrite mul0r !drop_poly0r mul0r.\napply/polyP => i; rewrite !(coefMXn, coef_drop_poly) ltn_subRL [(m + i)%N]addnC.\nhave [i_small|i_big]// := ltnP; congr nth.\nby have [mn|/ltnW mn] := leqP m n;\n   rewrite (eqP mn) (addn0, subn0) (subnBA, addnBA).\nQed.",
    "Lemma drop_polyMXn_id n p : drop_poly n (p * 'X^ n) = p.\nProof. by rewrite drop_polyMXn subnn drop_poly0l expr0 mulr1. Qed.",
    "Lemma drop_polyDMXn n p q : size p <= n -> drop_poly n (p + q * 'X^n) = q.\nProof. by move=> ?; rewrite drop_polyD drop_poly_eq0// drop_polyMXn_id add0r. Qed.",
    "Lemma poly_take_drop n p : take_poly n p + drop_poly n p * 'X^n = p.\nProof.\napply/polyP => i; rewrite coefD coefMXn coef_take_poly coef_drop_poly.\nby case: ltnP => ni; rewrite ?addr0 ?add0r//= subnK.\nQed.",
    "Lemma eqp_take_drop n p q :\n  take_poly n p = take_poly n q -> drop_poly n p = drop_poly n q -> p = q.\nProof.\nby move=> tpq dpq; rewrite -[p](poly_take_drop n) -[q](poly_take_drop n) tpq dpq.\nQed.",
    "Lemma coef_prod_XsubC (ps : seq R) (n : nat) :\n  (n <= size ps)%N ->\n  (\\prod_(p <- ps) ('X - p%:P))`_n =\n  (-1) ^+ (size ps - n)%N *\n    \\sum_(I in {set 'I_(size ps)} | #|I| == (size ps - n)%N)\n        \\prod_(i in I) ps`_i.\nProof.\nmove=> nle.\nunder eq_bigr => i _ do rewrite addrC -raddfN/=.\nrewrite -{1}(in_tupleE ps) -(map_tnth_enum (_ ps)) big_map.\nrewrite enumT bigA_distr /= coef_sum.\ntransitivity (\\sum_(I in {set 'I_(size ps)}) if #|I| == (size ps - n)%N then\n                  \\prod_(i < size ps | i \\in I) - ps`_i else 0).\n  apply eq_bigr => I _.\n  rewrite big_if/= big_const iter_mulr_1 -rmorph_prod/= coefCM coefXn.\n  under eq_bigr => i _ do rewrite (tnth_nth 0)/=.\n  rewrite -[#|I| == _](eqn_add2r n) subnK//.\n  rewrite -[X in (_ + _)%N == X]card_ord -(cardC I) eqn_add2l.\n  by case: ifP; rewrite ?mulr1 ?mulr0.\nby rewrite -big_mkcond mulr_sumr/=; apply: eq_bigr => I /eqP <-; rewrite prodrN.\nQed.",
    "Lemma coefPn_prod_XsubC (ps : seq R) : size ps != 0 ->\n  (\\prod_(p <- ps) ('X - p%:P))`_((size ps).-1) =\n  - \\sum_(p <- ps) p.\nProof.\nrewrite coef_prod_XsubC ?leq_pred// => ps0.\nhave -> : (size ps - (size ps).-1 = 1)%N.\n  by move: ps0; case: (size ps) => // n _; exact: subSnn.\nrewrite expr1 mulN1r; congr GRing.opp.\nset f : 'I_(size ps) -> {set 'I_(size ps)} := fun a => [set a].\ntransitivity (\\sum_(I in imset f (mem setT)) \\prod_(i in I) ps`_i).\n  apply: congr_big => // I /=.\n  by apply/cards1P/imsetP => [[a ->] | [a _ ->]]; exists a.\nrewrite big_imset/=; last first.\n  by move=> i j _ _ ij; apply/set1P; rewrite -/(f j) -ij set11.\nrewrite -[in RHS](in_tupleE ps) -(map_tnth_enum (_ ps)) big_map enumT.\napply: congr_big => // i; first exact: in_setT.\nby rewrite big_set1 (tnth_nth 0).\nQed.",
    "Lemma coef0_prod_XsubC (ps : seq R) :\n  (\\prod_(p <- ps) ('X - p%:P))`_0 =\n  (-1) ^+ (size ps) * \\prod_(p <- ps) p.\nProof.\nrewrite coef_prod_XsubC// subn0; congr GRing.mul.\ntransitivity (\\sum_(I in [set setT : {set 'I_(size ps)}]) \\prod_(i in I) ps`_i).\n  apply: congr_big =>// i/=.\n  apply/idP/set1P => [/eqP cardE | ->]; last by rewrite cardsT card_ord.\n  by apply/eqP; rewrite eqEcard subsetT cardsT card_ord cardE leqnn.\nrewrite big_set1 -[in RHS](in_tupleE ps) -(map_tnth_enum (_ ps)) big_map enumT.\napply: congr_big => // i; first exact: in_setT.\nby rewrite (tnth_nth 0).\nQed.",
    "Lemma hornerM p q x : (p * q).[x] = p.[x] * q.[x].\nProof. by rewrite hornerM_comm //; apply: mulrC. Qed.",
    "Lemma horner_exp p x n : (p ^+ n).[x] = p.[x] ^+ n.\nProof. by rewrite horner_exp_comm //; apply: mulrC. Qed.",
    "Lemma horner_prod I r (P : pred I) (F : I -> {poly R}) x :\n  (\\prod_(i <- r | P i) F i).[x] = \\prod_(i <- r | P i) (F i).[x].\nProof. by elim/big_rec2: _ => [|i _ p _ <-]; rewrite (hornerM, hornerC). Qed.",
    "Lemma horner_evalE x p : horner_eval x p = p.[x]. Proof. by []. Qed.",
    "Lemma in_alg_comm : commr_rmorph (in_alg A) a.\nProof. move=> r /=; by rewrite /GRing.comm comm_alg. Qed.",
    "Lemma horner_algC c : horner_alg c%:P = c%:A.\nProof. exact: horner_morphC. Qed.",
    "Lemma horner_algX : horner_alg 'X = a.\nProof. exact:  horner_morphX. Qed.",
    "Lemma poly_alg_initial : pf =1 horner_alg (pf 'X).\nProof.\napply: poly_ind => [|p a IHp]; first by rewrite !rmorph0.\nrewrite !rmorphD !rmorphM /= -{}IHp horner_algC ?horner_algX.\nby rewrite -alg_polyC rmorph_alg.\nQed.",
    "Lemma comp_polyM p q r : (p * q) \\Po r = (p \\Po r) * (q \\Po r).\nProof. exact: rmorphM. Qed.",
    "Lemma comp_polyA p q r : p \\Po (q \\Po r) = (p \\Po q) \\Po r.\nProof.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !comp_polyC.\nby rewrite !comp_polyD !comp_polyM !comp_polyX IHp !comp_polyC.\nQed.",
    "Lemma horner_comp p q x : (p \\Po q).[x] = p.[q.[x]].\nProof. by apply: polyC_inj; rewrite -!comp_polyCr comp_polyA. Qed.",
    "Lemma root_comp p q x : root (p \\Po q) x = root p (q.[x]).\nProof. by rewrite !rootE horner_comp. Qed.",
    "Lemma deriv_comp p q : (p \\Po q) ^`() = (p ^`() \\Po q) * q^`().\nProof.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !(deriv0, comp_poly0) mul0r.\nrewrite comp_poly_MXaddC derivD derivC derivM IHp derivMXaddC comp_polyD.\nby rewrite comp_polyM comp_polyX addr0 addrC mulrAC -mulrDl.\nQed.",
    "Lemma deriv_exp p n : (p ^+ n)^`() = p^`() * p ^+ n.-1 *+ n.\nProof.\nelim: n => [|n IHn]; first by rewrite expr0 mulr0n derivC.\nby rewrite exprS derivM {}IHn (mulrC p) mulrnAl -mulrA -exprSr mulrS; case n.\nQed.",
    "Lemma size_mul p q : p != 0 -> q != 0 -> size (p * q) = (size p + size q).-1.\nProof.\nby move=> nz_p nz_q; rewrite -size_proper_mul ?mulf_neq0 ?lead_coef_eq0.\nQed.",
    "Lemma poly_unitE p :\n  (p \\in GRing.unit) = (size p == 1) && (p`_0 \\in GRing.unit).\nProof. by []. Qed.",
    "Lemma poly_invE p : p ^-1 = if p \\in GRing.unit then (p`_0)^-1%:P else p.\nProof. by []. Qed.",
    "Lemma polyCV c : c%:P^-1 = (c^-1)%:P.\nProof.\nhave [/rmorphV-> // | nUc] := boolP (c \\in GRing.unit).\nby rewrite !invr_out // poly_unitE coefC (negbTE nUc) andbF.\nQed.",
    "Lemma rootM p q x : root (p * q) x = root p x || root q x.\nProof. by rewrite !rootE hornerM mulf_eq0. Qed.",
    "Lemma rootZ x a p : a != 0 -> root (a *: p) x = root p x.\nProof. by move=> nz_a; rewrite -mul_polyC rootM rootC (negPf nz_a). Qed.",
    "Lemma root_exp p n a: comm_poly p a -> (0 < n)%N -> root (p ^+ n) a = root p a.\nProof. by move=> ? n0; rewrite !rootE horner_exp_comm// expf_eq0 n0. Qed.",
    "Lemma size_scale a p : a != 0 -> size (a *: p) = size p.\nProof. by move/lregP/lreg_size->. Qed.",
    "Lemma size_Cmul a p : a != 0 -> size (a%:P * p) = size p.\nProof. by rewrite mul_polyC => /size_scale->. Qed.",
    "Lemma lead_coefM p q : lead_coef (p * q) = lead_coef p * lead_coef q.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite !(mul0r, lead_coef0).\nhave [-> | nz_q] := eqVneq q 0; first by rewrite !(mulr0, lead_coef0).\nby rewrite lead_coef_proper_mul // mulf_neq0 ?lead_coef_eq0.\nQed.",
    "Lemma lead_coef_prod I rI (P : {pred I}) (p : I -> {poly R}) :\n  lead_coef (\\prod_(i <- rI | P i) p i) = \\prod_(i <- rI | P i) lead_coef (p i).\nProof. by apply/big_morph/lead_coef1; apply: lead_coefM. Qed.",
    "Lemma lead_coefZ a p : lead_coef (a *: p) = a * lead_coef p.\nProof. by rewrite -mul_polyC lead_coefM lead_coefC. Qed.",
    "Lemma scale_poly_eq0 a p : (a *: p == 0) = (a == 0) || (p == 0).\nProof. by rewrite -mul_polyC mulf_eq0 polyC_eq0. Qed.",
    "Lemma size_prod (I : finType) (P : pred I) (F : I -> {poly R}) :\n    (forall i, P i -> F i != 0) ->\n  size (\\prod_(i | P i) F i) = ((\\sum_(i | P i) size (F i)).+1 - #|P|)%N.\nProof.\nmove=> nzF; transitivity (\\sum_(i | P i) (size (F i)).-1).+1; last first.\n  apply: canRL (addKn _) _; rewrite addnS -sum1_card -big_split /=.\n  by congr _.+1; apply: eq_bigr => i /nzF/polySpred.\nelim/big_rec2: _ => [|i d p /nzF nzFi IHp]; first by rewrite size_poly1.\nby rewrite size_mul // -?size_poly_eq0 IHp // addnS polySpred.\nQed.",
    "Lemma size_prod_seq (I : eqType)  (s : seq I) (F : I -> {poly R}) :\n    (forall i, i \\in s -> F i != 0) ->\n  size (\\prod_(i <- s) F i) = ((\\sum_(i <- s) size (F i)).+1 - size s)%N.\nProof.\nmove=> nzF; rewrite big_tnth size_prod; last by move=> i; rewrite nzF ?mem_tnth.\nby rewrite cardT /= size_enum_ord [in RHS]big_tnth.\nQed.",
    "Lemma size_mul_eq1 p q : (size (p * q) == 1) = ((size p == 1) && (size q == 1)).\nProof.\nhave [->|pNZ] := eqVneq p 0; first by rewrite mul0r size_poly0.\nhave [->|qNZ] := eqVneq q 0; first by rewrite mulr0 size_poly0 andbF.\nrewrite size_mul //.\nby move: pNZ qNZ; rewrite -!size_poly_gt0; (do 2 case: size) => //= n [|[|]].\nQed.",
    "Lemma size_prod_seq_eq1 (I : eqType) (s : seq I) (P : pred I) (F : I -> {poly R}) :\n  reflect (forall i, P i && (i \\in s) -> size (F i) = 1)\n          (size (\\prod_(i <- s | P i) F i) == 1%N).\nProof.\nrewrite (big_morph _ (id1:=true) size_mul_eq1) ?size_polyC ?oner_neq0//.\nrewrite big_all_cond; apply/(iffP allP).\n  by move=> h i /andP[Pi ins]; apply/eqP/(implyP (h i ins) Pi).\nby move=> h i ins; apply/implyP => Pi; rewrite h ?Pi.\nQed.",
    "Lemma size_prod_eq1 (I : finType) (P : pred I) (F : I -> {poly R}) :\n  reflect (forall i, P i -> size (F i) = 1)\n          (size (\\prod_(i | P i) F i) == 1).\nProof.\napply: (iffP (size_prod_seq_eq1 _ _ _)) => Hi i.\n  by move=> Pi; apply: Hi; rewrite Pi /= mem_index_enum.\nby rewrite mem_index_enum andbT; apply: Hi.\nQed.",
    "Lemma size_exp p n : (size (p ^+ n)).-1 = ((size p).-1 * n)%N.\nProof.\nelim: n => [|n IHn]; first by rewrite size_poly1 muln0.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite exprS mul0r size_poly0.\nrewrite exprS size_mul ?expf_neq0 // mulnS -{}IHn.\nby rewrite polySpred // [size (p ^+ n)]polySpred ?expf_neq0 ?addnS.\nQed.",
    "Lemma lead_coef_exp p n : lead_coef (p ^+ n) = lead_coef p ^+ n.\nProof.\nelim: n => [|n IHn]; first by rewrite !expr0 lead_coef1.\nby rewrite !exprS lead_coefM IHn.\nQed.",
    "Lemma root_prod_XsubC rs x :\n  root (\\prod_(a <- rs) ('X - a%:P)) x = (x \\in rs).\nProof.\nelim: rs => [|a rs IHrs]; first by rewrite rootE big_nil hornerC oner_eq0.\nby rewrite big_cons rootM IHrs root_XsubC.\nQed.",
    "Lemma root_exp_XsubC n a x : root (('X - a%:P) ^+ n.+1) x = (x == a).\nProof. by rewrite rootE horner_exp expf_eq0 [_ == 0]root_XsubC. Qed.",
    "Lemma size_comp_poly p q :\n  (size (p \\Po q)).-1 = ((size p).-1 * (size q).-1)%N.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite comp_poly0 size_poly0.\nhave [/size1_polyC-> | nc_q] := leqP (size q) 1.\n  by rewrite comp_polyCr !size_polyC -!sub1b -!subnS muln0.\nhave nz_q: q != 0 by rewrite -size_poly_eq0 -(subnKC nc_q).\nrewrite mulnC comp_polyE (polySpred nz_p) /= big_ord_recr /= addrC.\nrewrite size_polyDl size_scale ?lead_coef_eq0 ?size_exp //=.\nrewrite [ltnRHS]polySpred ?expf_neq0 // ltnS size_exp.\nrewrite (leq_trans (size_sum _ _ _)) //; apply/bigmax_leqP => i _.\nrewrite (leq_trans (size_scale_leq _ _)) // polySpred ?expf_neq0 //.\nby rewrite size_exp -(subnKC nc_q) ltn_pmul2l.\nQed.",
    "Lemma lead_coef_comp p q : size q > 1 ->\n  lead_coef (p \\Po q) = (lead_coef p) * lead_coef q ^+ (size p).-1.\nProof.\nmove=> q_gt1; rewrite !lead_coefE coef_comp_poly size_comp_poly.\nhave [->|nz_p] := eqVneq p 0; first by rewrite size_poly0 big_ord0 coef0 mul0r.\nrewrite polySpred //= big_ord_recr /= big1 ?add0r => [|i _].\n  by rewrite -!lead_coefE -lead_coef_exp !lead_coefE size_exp mulnC.\nrewrite [X in _ * X]nth_default ?mulr0 ?(leq_trans (size_poly_exp_leq _ _)) //.\nby rewrite mulnC ltn_mul2r -subn1 subn_gt0 q_gt1 /=.\nQed.",
    "Lemma comp_poly_eq0 p q : size q > 1 -> (p \\Po q == 0) = (p == 0).\nProof.\nmove=> sq_gt1; rewrite -!lead_coef_eq0 lead_coef_comp //.\nrewrite mulf_eq0 expf_eq0 !lead_coef_eq0 -[q == 0]size_poly_leq0.\nby rewrite [_ <= 0]leqNgt (leq_ltn_trans _ sq_gt1) ?andbF ?orbF.\nQed.",
    "Lemma size_comp_poly2 p q : size q = 2 -> size (p \\Po q) = size p.\nProof.\nmove=> sq2; have [->|pN0] := eqVneq p 0; first by rewrite comp_polyC.\nby rewrite polySpred ?size_comp_poly ?comp_poly_eq0 ?sq2 // muln1 polySpred.\nQed.",
    "Lemma comp_poly2_eq0 p q : size q = 2 -> (p \\Po q == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 => /size_comp_poly2->. Qed.",
    "Lemma roots_geq_poly_eq0 p (rs : seq R) : all (root p) rs -> uniq rs ->\n  (size rs >= size p)%N -> p = 0.\nProof. by move=> ??; apply: contraTeq => ?; rewrite leqNgt max_poly_roots. Qed.",
    "Lemma size_map_poly p : size p^f = size p.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite rmorph0 !size_poly0.\nby rewrite size_poly_eq // fmorph_eq0 // lead_coef_eq0.\nQed.",
    "Lemma lead_coef_map p : lead_coef p^f = f (lead_coef p).\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite !(rmorph0, lead_coef0).\nby rewrite lead_coef_map_eq // fmorph_eq0 // lead_coef_eq0.\nQed.",
    "Lemma map_poly_eq0 p : (p^f == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 size_map_poly. Qed.",
    "Lemma map_poly_inj : injective (map_poly f).\nProof.\nmove=> p q eqfpq; apply/eqP; rewrite -subr_eq0 -map_poly_eq0.\nby rewrite rmorphB /= eqfpq subrr.\nQed.",
    "Lemma map_monic p : (p^f \\is monic) = (p \\is monic).\nProof. by rewrite [in LHS]monicE lead_coef_map fmorph_eq1. Qed.",
    "Lemma map_poly_com p x : comm_poly p^f (f x).\nProof. exact: map_comm_poly (mulrC x _). Qed.",
    "Lemma fmorph_root p x : root p^f (f x) = root p x.\nProof. by rewrite rootE horner_map // fmorph_eq0. Qed.",
    "Lemma fmorph_unity_root n z : n.-unity_root (f z) = n.-unity_root z.\nProof. by rewrite !unity_rootE -(inj_eq (fmorph_inj f)) rmorphXn ?rmorph1. Qed.",
    "Lemma fmorph_primitive_root n z :\n  n.-primitive_root (f z) = n.-primitive_root z.\nProof.\nby congr (_ && _); apply: eq_forallb => i; rewrite fmorph_unity_root.\nQed.",
    "Lemma uniq_roots_prod_XsubC p rs :\n    all (root p) rs -> uniq_roots rs ->\n  exists q, p = q * \\prod_(z <- rs) ('X - z%:P).\nProof.\nelim: rs => [|z rs IHrs] /=; first by rewrite big_nil; exists p; rewrite mulr1.\ncase/andP=> rpz rprs /andP[drs urs]; case: IHrs => {urs rprs}// q def_p.\nhave [|q' def_q] := factor_theorem q z _; last first.\n  by exists q'; rewrite big_cons mulrA -def_q.\nrewrite {p}def_p in rpz.\nelim/last_ind: rs drs rpz => [|rs t IHrs] /=; first by rewrite big_nil mulr1.\nrewrite all_rcons => /andP[/andP[/eqP czt Uzt] /IHrs{}IHrs].\nrewrite -cats1 big_cat big_seq1 /= mulrA rootE hornerM_comm; last first.\n  by rewrite /comm_poly hornerXsubC mulrBl mulrBr czt.\nrewrite hornerXsubC -opprB mulrN oppr_eq0 -(mul0r (t - z)).\nby rewrite (inj_eq (mulIr Uzt)) => /IHrs.\nQed.",
    "Lemma all_roots_prod_XsubC p rs :\n    size p = (size rs).+1 -> all (root p) rs -> uniq_roots rs ->\n  p = lead_coef p *: \\prod_(z <- rs) ('X - z%:P).\nProof.\nmove=> size_p /uniq_roots_prod_XsubC def_p Urs.\ncase/def_p: Urs => q -> {p def_p} in size_p *.\nhave [q0 | nz_q] := eqVneq q 0; first by rewrite q0 mul0r size_poly0 in size_p.\nhave{q nz_q size_p} /size_poly1P[c _ ->]: size q == 1.\n  rewrite -(eqn_add2r (size rs)) add1n -size_p.\n  by rewrite size_Mmonic ?monic_prod_XsubC // size_prod_XsubC addnS.\nby rewrite lead_coef_Mmonic ?monic_prod_XsubC // lead_coefC mul_polyC.\nQed.",
    "Lemma poly2_root p : size p = 2 -> {r | root p r}.\nProof.\ncase: p => [[|p0 [|p1 []]] //= nz_p1]; exists (- p0 / p1).\nby rewrite /root addr_eq0 /= mul0r add0r mulrC divfK ?opprK.\nQed.",
    "Lemma uniq_rootsE rs : uniq_roots rs = uniq rs.\nProof.\nelim: rs => //= r rs ->; congr (_ && _); rewrite -has_pred1 -all_predC.\nby apply: eq_all => t; rewrite /diff_roots mulrC eqxx unitfE subr_eq0.\nQed.",
    "Lemma root_ZXsubC (a b r : F) : a != 0 ->\n  root (a *: 'X - b%:P) r = (r == b / a).\nProof.\nmove=> a0; rewrite rootE !hornerE.\nby rewrite -[r in RHS]divr1 eqr_div ?oner_neq0// mulr1 mulrC subr_eq0.\nQed.",
    "Lemma max_unity_roots rs :\n  n > 0 -> all n.-unity_root rs -> uniq rs -> size rs <= n.\nProof.\nmove=> n_gt0 rs_n_1 Urs; have szPn := size_XnsubC (1 : F) n_gt0.\nby rewrite -ltnS -szPn max_poly_roots -?size_poly_eq0 ?szPn.\nQed.",
    "Lemma mem_unity_roots rs :\n    n > 0 -> all n.-unity_root rs -> uniq rs -> size rs = n ->\n  n.-unity_root =i rs.\nProof.\nmove=> n_gt0 rs_n_1 Urs sz_rs_n x; rewrite -topredE /=.\napply/idP/idP=> xn1; last exact: (allP rs_n_1).\napply: contraFT (ltnn n) => not_rs_x.\nby rewrite -{1}sz_rs_n (@max_unity_roots (x :: rs)) //= ?xn1 ?not_rs_x.\nQed.",
    "Lemma factor_Xn_sub_1 : \\prod_(0 <= i < n) ('X - (z ^+ i)%:P) = 'X^n - 1.\nProof.\ntransitivity (\\prod_(w <- zn) ('X - w%:P)); first by rewrite big_map.\nhave n_gt0: n > 0 := prim_order_gt0 prim_z.\nrewrite (@all_roots_prod_XsubC _ ('X^n - 1) zn); first 1 last.\n- by rewrite size_XnsubC // size_map size_iota subn0.\n- apply/allP=> _ /mapP[i _ ->] /=; rewrite rootE !hornerE.\n  by rewrite exprAC (prim_expr_order prim_z) expr1n subrr.\n- rewrite uniq_rootsE map_inj_in_uniq ?iota_uniq // => i j.\n  rewrite !mem_index_iota => ltin ltjn /eqP.\n  by rewrite (eq_prim_root_expr prim_z) !modn_small // => /eqP.\nby rewrite (monicP (monicXnsubC 1 n_gt0)) scale1r.\nQed.",
    "Lemma prim_rootP x : x ^+ n = 1 -> {i : 'I_n | x = z ^+ i}.\nProof.\nmove=> xn1; pose logx := [pred i : 'I_n | x == z ^+ i].\ncase: (pickP logx) => [i /eqP-> | no_i]; first by exists i.\ncase: notF; suffices{no_i}: x \\in zn.\n  case/mapP=> i; rewrite mem_index_iota => lt_i_n def_x.\n  by rewrite -(no_i (Ordinal lt_i_n)) /= -def_x.\nrewrite -root_prod_XsubC big_map factor_Xn_sub_1.\nby rewrite [root _ x]unity_rootE xn1.\nQed.",
    "Lemma map_diff_roots x y : diff_roots (f x) (f y) = (x != y).\nProof.\nrewrite /diff_roots -rmorphB // fmorph_unit // subr_eq0 //.\nby rewrite rmorph_comm // eqxx eq_sym.\nQed.",
    "Lemma map_uniq_roots s : uniq_roots (map f s) = uniq s.\nProof.\nelim: s => //= x s ->; congr (_ && _); elim: s => //= y s ->.\nby rewrite map_diff_roots -negb_or.\nQed.",
    "Lemma aut_prim_rootP u z n :\n  n.-primitive_root z -> {k | coprime k n & u z = z ^+ k}.\nProof.\nmove=> prim_z; have:= prim_z; rewrite -(fmorph_primitive_root u) => prim_uz.\nhave [[k _] /= def_uz] := prim_rootP prim_z (prim_expr_order prim_uz).\nby exists k; rewrite // -(prim_root_exp_coprime _ prim_z) -def_uz.\nQed.",
    "Lemma aut_unity_rootP u z n : n > 0 -> z ^+ n = 1 -> {k | u z = z ^+ k}.\nProof.\nby move=> _ /prim_order_exists[// | m /(aut_prim_rootP u)[k]]; exists k.\nQed.",
    "Lemma aut_unity_rootC u v z n : n > 0 -> z ^+ n = 1 -> u (v z) = v (u z).\nProof.\nmove=> n_gt0 /(aut_unity_rootP _ n_gt0) def_z.\nhave [[i def_uz] [j def_vz]] := (def_z u, def_z v).\nby rewrite def_vz def_uz !rmorphXn /= def_vz def_uz exprAC.\nQed.",
    "Lemma deg2_poly_canonical :\n  p = a *: (('X + (b / (2 * a))%:P)^+2 - (delta / (4 * a ^+ 2))%:P).\nProof.\nrewrite pE sqrrD -!addrA scalerDr; congr +%R; rewrite addrA scalerDr; congr +%R.\n- rewrite -mulrDr -polyCD -!mul_polyC mulrA mulrAC -polyCM.\n  by rewrite [a * _]mulrC mulrDl invfM -!mulrA mulVf// mulr1 -splitr.\n- rewrite [a ^+ 2]expr2 mulrA aa4 -polyC_exp -polyCB expr_div_n -mulrBl subKr.\n  by rewrite scale_polyC mulrCA mulrACA aa4 mulrCA mulfV// mulr1.\nQed.",
    "Lemma deg2_poly_factor : p = a *: ('X - r1%:P) * ('X - r2%:P).\nProof.\nrewrite [p]deg2_poly_canonical//= -/a -/b -/c -/delta /r1 /r2.\nrewrite ![(- b + _) * _]mulrDl 2!polyCD 2!opprD 2!addrA !mulNr !polyCN !opprK.\nrewrite -scalerAl [in RHS]mulrC -subr_sqr -polyC_exp -[4]/(2 * 2)%:R natrM.\nby rewrite -expr2 -exprMn [in RHS]exprMn exprVn r_sqrt_delta.\nQed.",
    "Lemma deg2_poly_root1 : root p r1.\nProof.\napply/factor_theorem.\nby exists (a *: ('X - r2%:P)); rewrite deg2_poly_factor -!scalerAl mulrC.\nQed.",
    "Lemma deg2_poly_root2 : root p r2.\nProof.\napply/factor_theorem.\nby exists (a *: ('X - r1%:P)); rewrite deg2_poly_factor -!scalerAl.\nQed.",
    "Lemma deg2_poly_canonical : p = (('X + (b / 2)%:P)^+2 - (delta / 4)%:P).\nProof. by rewrite [p]deg2_poly_canonical// -/a a1 scale1r expr1n !mulr1. Qed.",
    "Lemma deg2_poly_factor : p = ('X - r1%:P) * ('X - r2%:P).\nProof.\nby rewrite [p](@deg2_poly_factor _ _ _ _ r)// -/a a1 !mulr1 ?scale1r.\nQed.",
    "Lemma deg2_poly_root1 : root p r1.\nProof.\nrewrite /r1 -[2]mulr1 -[X in 2 * X]a1.\nby apply: deg2_poly_root1; rewrite // -/a a1 mulr1.\nQed.",
    "Lemma deg2_poly_root2 : root p r2.\nProof.\nrewrite /r2 -[2]mulr1 -[X in 2 * X]a1.\nby apply: deg2_poly_root2; rewrite // -/a a1 mulr1.\nQed.",
    "Lemma dec_factor_theorem (p : {poly F}) :\n  {s : seq F & {q : {poly F} | p = q * \\prod_(x <- s) ('X - x%:P)\n                             /\\ (q != 0 -> forall x, ~~ root q x)}}.\nProof.\npose polyT (p : seq F) := (foldr (fun c f => f * 'X_0 + c%:T) (0%R)%:T p)%T.\nhave eval_polyT (q : {poly F}) x : GRing.eval [:: x] (polyT q) = q.[x].\n  by rewrite /horner; elim: (val q) => //= ? ? ->.\nhave [n] := ubnP (size p); elim: n => // n IHn in p *.\nhave /decPcases /= := @satP F [::] ('exists 'X_0, polyT p == 0%T).\ncase: ifP => [_ /sig_eqW[x]|_ noroot]; last first.\n  exists [::], p; rewrite big_nil mulr1; split => // p_neq0 x.\n  by apply/negP=> /rootP rpx; apply: noroot; exists x; rewrite eval_polyT.\nrewrite eval_polyT => /rootP/factor_theorem/sig_eqW[p1 ->].\nhave [->|nz_p1] := eqVneq p1 0; first by exists [::], 0; rewrite !mul0r eqxx.\nrewrite size_Mmonic ?monicXsubC // size_XsubC addn2 => /IHn[s [q [-> irr_q]]].\nby exists (rcons s x), q; rewrite -cats1 big_cat big_seq1 mulrA.\nQed.",
    "Lemma closed_rootP p : reflect (exists x, root p x) (size p != 1).\nProof.\nhave [-> | nz_p] := eqVneq p 0.\n  by rewrite size_poly0; left; exists 0; rewrite root0.\nrewrite neq_ltn [in _ < 1]polySpred //=.\napply: (iffP idP) => [p_gt1 | [a]]; last exact: root_size_gt1.\npose n := (size p).-1; have n_gt0: n > 0 by rewrite -ltnS -polySpred.\nhave [a Dan] := closedF (fun i => - p`_i / lead_coef p) n_gt0.\nexists a; apply/rootP; rewrite horner_coef polySpred // big_ord_recr /= -/n.\nrewrite {}Dan mulr_sumr -big_split big1 //= => i _.\nby rewrite -!mulrA mulrCA mulNr mulVKf ?subrr ?lead_coef_eq0.\nQed.",
    "Lemma closed_nonrootP p : reflect (exists x, ~~ root p x) (p != 0).\nProof.\napply: (iffP idP) => [nz_p | [x]]; last first.\n  by apply: contraNneq => ->; apply: root0.\nhave [[x /rootP p1x0]|] := altP (closed_rootP (p - 1)).\n  by exists x; rewrite -[p](subrK 1) /root hornerD p1x0 add0r hornerC oner_eq0.\nrewrite negbK => /size_poly1P[c _ /(canRL (subrK 1)) Dp].\nby exists 0; rewrite Dp -raddfD polyC_eq0 rootC in nz_p *.\nQed.",
    "Lemma closed_rootP p : reflect (exists x, root p x) (size p != 1).\nProof. exact: PreClosedField.closed_rootP. Qed.",
    "Lemma closed_nonrootP p : reflect (exists x, ~~ root p x) (p != 0).\nProof. exact: PreClosedField.closed_nonrootP. Qed.",
    "Lemma closed_field_poly_normal p :\n  {r : seq F | p = lead_coef p *: \\prod_(z <- r) ('X - z%:P)}.\nProof.\napply: sig_eqW; have [r [q [->]]] /= := dec_factor_theorem p.\nhave [->|] := eqVneq; first by exists [::]; rewrite mul0r lead_coef0 scale0r.\nhave [[x rqx ? /(_ isT x) /negP /(_ rqx)] //|] := altP (closed_rootP q).\nrewrite negbK => /size_poly1P [c c_neq0-> _ _]; exists r.\nrewrite mul_polyC lead_coefZ (monicP _) ?mulr1 //.\nby rewrite monic_prod => // i; rewrite monicXsubC.\nQed.",
    "Lemma eq_map_mx_id (R : nzRingType) m n (M : 'M[R]_(m, n)) (f : R -> R) :\n  f =1 id -> M ^ f = M.\nProof. by move=> /eq_map_mx->; rewrite map_mx_id. Qed.",
    "Lemma rmorphK (f : involutive_rmorphism R) : involutive f.\nProof. by move: f => [? [? ? []]]. Qed.",
    "Lemma map_mxCK {C : numClosedFieldType}  m n (A : 'M[C]_(m, n)) :\n  (A ^ conjC) ^ conjC = A.\nProof. by apply/matrixP=> i j; rewrite !mxE conjCK. Qed.",
    "Lemma linear0r : f z 0 = 0. Proof. by rewrite raddf0. Qed.",
    "Lemma linearNr : {morph f z : x / - x}. Proof. exact: raddfN. Qed.",
    "Lemma linearDr : {morph f z : x y / x + y}. Proof. exact: raddfD. Qed.",
    "Lemma linearBr : {morph f z : x y / x - y}. Proof. exact: raddfB. Qed.",
    "Lemma linearMnr n : {morph f z : x / x *+ n}. Proof. exact: raddfMn. Qed.",
    "Lemma linearMNnr n : {morph f z : x / x *- n}. Proof. exact: raddfMNn. Qed.",
    "Lemma linear_sumr I r (P : pred I) E :\n  f z (\\sum_(i <- r | P i) E i) = \\sum_(i <- r | P i) f z (E i).\nProof. exact: raddf_sum. Qed.",
    "Lemma linearZr_LR : scalable_for s' (f z). Proof. exact: linearZ_LR. Qed.",
    "Lemma linearPr a : {morph f z : u v / a *: u + v >-> s' a u + v}.\nProof. exact: linearP. Qed.",
    "Lemma applyrE x : applyr f x =1 f^~ x. Proof. by []. Qed.",
    "Lemma linear0l : f 0 z = 0. Proof. by rewrite -applyrE raddf0. Qed.",
    "Lemma linearNl : {morph f^~ z : x / - x}.\nProof. by move=> ?; rewrite -applyrE raddfN. Qed.",
    "Lemma linearDl : {morph f^~ z : x y / x + y}.\nProof. by move=> ? ?; rewrite -applyrE raddfD. Qed.",
    "Lemma linearBl : {morph f^~ z : x y / x - y}.\nProof. by move=> ? ?; rewrite -applyrE raddfB. Qed.",
    "Lemma linearMnl n : {morph f^~ z : x / x *+ n}.\nProof. by move=> ?; rewrite -applyrE raddfMn. Qed.",
    "Lemma linearMNnl n : {morph f^~ z : x / x *- n}.\nProof. by move=> ?; rewrite -applyrE raddfMNn. Qed.",
    "Lemma linear_sumlz I r (P : pred I) E :\n  f (\\sum_(i <- r | P i) E i) z = \\sum_(i <- r | P i) f (E i) z.\nProof. by rewrite -applyrE raddf_sum. Qed.",
    "Lemma linearZl_LR : scalable_for s (f ^~ z).\nProof. by move=> ? ?; rewrite -applyrE linearZ_LR. Qed.",
    "Lemma linearPl a : {morph f^~ z : u v / a *: u + v >-> s a u + v}.\nProof. by move=> ? ?; rewrite -applyrE linearP. Qed.",
    "Lemma linearZl z (c : S) (a : R) (h_c := h c)\n    (f : Bilinear.map_for_left U U' s s' a h_c) u :\n  f (a *: u) z = h_c (Bilinear.wrap f u z).\nProof. by rewrite linearZl_LR; case: f => f /= ->. Qed.",
    "Lemma linearZr z c' b (h'_c' := h' c')\n    (f : Bilinear.map_for_right U U' s s' b h'_c') u :\n  f z (b *: u) = h'_c' (Bilinear.wrap f z u).\nProof. by rewrite linearZr_LR; case: f => f /= ->. Qed.",
    "Lemma linearZlr c c' a b (h_c := h c) (h'_c' := h' c')\n    (f : Bilinear.map_for_both U U' s s' a b h_c h'_c') u v :\n  f (a *: u) (b *: v) = h_c (h'_c' (Bilinear.wrap f u v)).\nProof. by rewrite linearZl_LR linearZ_LR; case: f => f /= -> ->. Qed.",
    "Lemma linearZrl c c' a b (h_c := h c) (h'_c' := h' c')\n    (f : Bilinear.map_for_both U U' s s' a b h_c h'_c') u v :\n  f (a *: u) (b *: v) = h'_c' (h_c (Bilinear.wrap f u v)).\nProof. by rewrite linearZ_LR/= linearZl_LR; case: f => f /= -> ->. Qed.",
    "Lemma mulmx_is_bilinear (R : comNzRingType) m n p : bilinear_for\n  (GRing.Scale.Law.clone _ _ *:%R _) (GRing.Scale.Law.clone _ _ *:%R _)\n  (@mulmx R m n p).\nProof.\nsplit=> [u'|u] a x y /=.\n- by rewrite mulmxDl scalemxAl.\n- by rewrite mulmxDr scalemxAr.\nQed.",
    "Lemma form0l u : '[0, u] = 0. Proof. by rewrite /form !mul0mx mxE. Qed.",
    "Lemma form0r u : '[u, 0] = 0.\nProof. by rewrite /form trmx0 map_mx0 mulmx0 mxE. Qed.",
    "Lemma formDl u v w : '[u + v, w] = '[u, w] + '[v, w].\nProof. by rewrite /form !mulmxDl mxE. Qed.",
    "Lemma formDr u v w : '[u, v + w] = '[u, v] + '[u, w].\nProof. by rewrite /form linearD !map_mxD !mulmxDr mxE. Qed.",
    "Lemma formZr a u v : '[u, a *: v] = theta a * '[u, v].\nProof. by rewrite /form !(linearZ, map_mxZ) /= mxE. Qed.",
    "Lemma formZl a u v : '[a *: u, v] = a * '[u, v].\nProof.\nby do !rewrite /form  -[_ *: _ *m _]/(mulmxr _ _) linearZ /=; rewrite mxE.\nQed.",
    "Lemma formNl u v : '[- u, v] = - '[u, v].\nProof. by rewrite -scaleN1r formZl mulN1r. Qed.",
    "Lemma formNr u v : '[u, - v] = - '[u, v].\nProof. by rewrite -scaleN1r formZr rmorphN1 mulN1r. Qed.",
    "Lemma formee i j : '['e_i, 'e_j] = M i j.\nProof.\nrewrite /form -rowE -map_trmx map_delta_mx -[M in LHS]trmxK.\nby rewrite -tr_col -trmx_mul -rowE !mxE.\nQed.",
    "Lemma form0_eq0 : M = 0 -> forall u v, '[u, v] = 0.\nProof. by rewrite/form=> -> u v; rewrite mulmx0 mul0mx mxE. Qed.",
    "Lemma sesquiE : (M \\is (eps, theta).-sesqui) = (M == (-1) ^+ eps *: M ^t theta).\nProof. by rewrite qualifE. Qed.",
    "Lemma sesquiP : reflect (M = (-1) ^+ eps *: M ^t theta)\n                        (M \\is (eps, theta).-sesqui).\nProof. by rewrite sesquiE; exact/eqP. Qed.",
    "Lemma trmx_sesqui : M^T = (-1) ^+ eps *: M ^ theta.\nProof.\nrewrite [in LHS](sesquiP _) // -mul_scalar_mx trmx_mul.\nby rewrite tr_scalar_mx mul_mx_scalar map_trmx trmxK.\nQed.",
    "Lemma maptrmx_sesqui : M^t theta = (-1) ^+ eps *: M.\nProof.\nby rewrite trmx_sesqui map_mxZ rmorph_sign -map_mx_comp eq_map_mx_id.\nQed.",
    "Lemma formC u v : '[u, v] = (-1) ^+ eps * theta '[v, u].\nProof.\nrewrite /form [M in LHS](sesquiP _) // -mulmxA !mxE rmorph_sum mulr_sumr.\napply: eq_bigr => /= i _; rewrite !(mxE, mulr_sumr, mulr_suml, rmorph_sum).\napply: eq_bigr => /= j _; rewrite !mxE !rmorphM  mulrCA -!mulrA.\nby congr (_ * _); rewrite mulrA mulrC /= thetaK.\nQed.",
    "Lemma form_eq0C u v : ('[u, v] == 0) = ('[v, u] == 0).\nProof. by rewrite formC mulf_eq0 signr_eq0 /= fmorph_eq0. Qed.",
    "Lemma normalE u v : (u '_|_ v) = ('[u, v] == 0).\nProof.\nby rewrite (sameP sub_kermxP eqP) mulmxA [_ *m _^t _]mx11_scalar fmorph_eq0.\nQed.",
    "Lemma form_eq0P {u v} : reflect ('[u, v] = 0) (u '_|_ v).\nProof. by rewrite normalE; apply/eqP. Qed.",
    "Lemma normalP p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  reflect (forall (u v : 'rV_n), (u <= A)%MS -> (v <= B)%MS -> u '_|_ v)\n          (A '_|_ B).\nProof.\napply: (iffP idP) => AnB.\n  move=> u v uA vB; rewrite (submx_trans uA) // (submx_trans AnB) //.\n  apply/sub_kermxP; have /submxP [w ->] := vB.\n  rewrite trmx_mul map_mxM !mulmxA -[kermx _ *m _ *m _]mulmxA.\n  by rewrite [kermx _ *m _](sub_kermxP _) // mul0mx.\napply/rV_subP => u /AnB /(_ _) /sub_kermxP uMv; apply/sub_kermxP.\nsuff: forall m (v : 'rV[R]_m),\n  (forall i, v *m 'e_i ^t theta = 0 :> 'M_1) -> v = 0.\n  apply => i; rewrite !mulmxA -!mulmxA -map_mxM -trmx_mul uMv //.\n  by apply/submxP; exists 'e_i.\nmove=> /= m v Hv; apply: (can_inj (@trmxK _ _ _)).\nrewrite trmx0; apply/row_matrixP=> i; rewrite row0 rowE.\napply: (can_inj (@trmxK _ _ _)); rewrite trmx0 trmx_mul trmxK.\nby rewrite -(map_delta_mx theta) map_trmx Hv.\nQed.",
    "Lemma normalC p q (A : 'M_(p, n)) (B : 'M_(q, n)) : (A '_|_ B) = (B '_|_ A).\nProof.\ngen have nC : p q A B / A '_|_ B -> B '_|_ A; last by apply/idP/idP; apply/nC.\nmove=> AnB; apply/normalP => u v ? ?; rewrite normalE.\nrewrite formC mulf_eq0 ?fmorph_eq0 ?signr_eq0 /=.\nby rewrite -normalE (normalP _ _ AnB).\nQed.",
    "Lemma normal_ortho_mx p (A : 'M_(p, n)) : ((A^_|_) '_|_ A).\nProof. by []. Qed.",
    "Lemma normal_mx_ortho p (A : 'M_(p, n)) : (A '_|_ (A^_|_)).\nProof. by rewrite normalC. Qed.",
    "Lemma rank_normal u : (\\rank (u ^_|_) >= n.-1)%N.\nProof.\nrewrite mxrank_ker -subn1 leq_sub2l //.\nby rewrite (leq_trans (mxrankM_maxr  _ _)) // rank_leq_col.\nQed.",
    "Lemma rad_ker : rad = kermx M.\nProof. by rewrite /rad /ortho /orthomx trmx1 map_mx1 mulmx1. Qed.",
    "Lemma formZ a u : '[a *: u]= (a * theta a) * '[u].\nProof. by rewrite formZl formZr mulrA. Qed.",
    "Lemma formN u : '[- u] = '[u].\nProof. by rewrite formNr formNl opprK. Qed.",
    "Lemma form_sign m u : '[(-1) ^+ m *: u] = '[u].\nProof. by rewrite -signr_odd scaler_sign; case: odd; rewrite ?formN. Qed.",
    "Lemma formD u v : let d := '[u, v] in\n  '[u + v] = '[u] + '[v] + (d + (-1) ^+ eps * theta d).\nProof. by rewrite formDl !formDr ['[v, _]]formC [_ + '[v]]addrC addrACA. Qed.",
    "Lemma formB u v : let d := '[u, v] in\n  '[u - v] = '[u] + '[v] - (d + (-1) ^+ eps * theta d).\nProof. by rewrite formD formN !formNr rmorphN mulrN -opprD. Qed.",
    "Lemma formBd u v : u '_|_ v -> '[u - v] = '[u] + '[v].\nProof.\nby move=> uTv; rewrite formDd ?formN // normalE formNr oppr_eq0 -normalE.\nQed.",
    "Lemma hermC u v : '[u, v] = (-1) ^+ eps * theta '[v, u].\nProof. by move: form => [? [[? ? ? ?] []]] /=. Qed.",
    "Lemma hnormN u : '[- u] = '[u].\nProof. by rewrite linearNl linearNr opprK. Qed.",
    "Lemma hnorm_sign n u : '[(-1) ^+ n *: u] = '[u].\nProof. by rewrite -signr_odd scaler_sign; case: (odd n); rewrite ?hnormN. Qed.",
    "Lemma hnormD u v :\n  let d := '[u, v] in '[u + v] = '[u] + '[v] + (d + (-1) ^+ eps * theta d).\nProof. by rewrite /= addrAC -hermC linearDl 2!linearDr !addrA. Qed.",
    "Lemma hnormB u v :\n  let d := '[u, v] in '[u - v] = '[u] + '[v] - (d + (-1) ^+ eps * theta d).\nProof.\nby rewrite /= hnormD hnormN linearNr addrA rmorphN mulrN opprD addrA.\nQed.",
    "Lemma hnormDd u v : '[u, v] = 0 -> '[u + v] = '[u] + '[v].\nProof. by move=> ouv; rewrite hnormD ouv rmorph0 mulr0 !addr0. Qed.",
    "Lemma hnormBd u v : '[u, v] = 0 -> '[u - v] = '[u] + '[v].\nProof.\nby move=> ouv; rewrite hnormDd ?hnormN// linearNr [X in - X]ouv oppr0.\nQed.",
    "Lemma orthogonal_cons u us vs :\n  orthogonal (u :: us) vs = orthogonal [:: u] vs && orthogonal us vs.\nProof. by rewrite /orthogonal /= andbT. Qed.",
    "Lemma orthonormal_not0 S : orthonormal S -> 0 \\notin S.\nProof.\nby case/andP=> /allP S1 _; rewrite (contra (S1 _)) //= linear0r eq_sym oner_eq0.\nQed.",
    "Lemma orthonormalE S :\n  orthonormal S = all [pred phi | '[phi] == 1] S && pairwise_orthogonal S.\nProof. by rewrite -(andb_idl (@orthonormal_not0 S)) andbCA. Qed.",
    "Lemma orthonormal_orthogonal S : orthonormal S -> pairwise_orthogonal S.\nProof. by rewrite orthonormalE => /andP[_]. Qed.",
    "Lemma herm_eq0C u v : ('[u, v] == 0) = ('[v, u] == 0).\nProof. by rewrite hermC mulf_eq0 signr_eq0 /= fmorph_eq0. Qed.",
    "Lemma mem_orthovPn V u : reflect (exists2 v, v \\in V & '[u, v] != 0) (u \\notin orthov V).\nProof.\napply: (iffP idP) => [u_orthovV|[v /coord_vbasis-> uvNorthov]]; last first.\n  apply/subv_bigcapP => uP.\n  rewrite linear_sumr big1 ?eqxx//= in uvNorthov.\n  move=> i _; have := uP i isT.\n  by rewrite -memvE memv_ker lfunE/= linearZr/= => /eqP/= ->; rewrite mulr0.\nsuff /existsP [i ui_neq0] : [exists i : 'I_(\\dim V), '[u, (vbasis V)`_i] != 0].\n  by exists (vbasis V)`_i => //; rewrite vbasis_mem ?mem_nth ?size_tuple.\napply: contraNT u_orthovV; rewrite negb_exists => /forallP ui_eq0.\napply/subv_bigcapP => i _.\nby rewrite -memvE memv_ker lfunE /= -[_ == _]negbK.\nQed.",
    "Lemma mem_orthovP V u : reflect {in V, forall v, '[u, v] = 0} (u \\in orthov V).\nProof.\napply: (iffP idP) => [/mem_orthovPn orthovNu v vV|/(_ _ _)/eqP orthov_u].\n  by apply/eqP/negP=> /negP Northov_uv; apply: orthovNu; exists v.\nby apply/mem_orthovPn => -[v /orthov_u->].\nQed.",
    "Lemma orthov1E u : orthov <[u]> = lker (alpha u).\nProof.\napply/eqP; rewrite eqEsubv; apply/andP.\nsplit; apply/subvP=> v; rewrite memv_ker lfunE /=.\n   by move=> /mem_orthovP-> //; rewrite ?memv_line.\nmove=> vu_eq0; apply/mem_orthovP => w /vlineP[k->].\nby apply/eqP; rewrite linearZ mulf_eq0 vu_eq0 orbT.\nQed.",
    "Lemma orthovP U V : reflect {in U & V, forall u v, '[u, v] = 0} (U '_|_ V)%VS.\nProof.\napply: (iffP subvP); last by move=> H ??; apply/mem_orthovP=> ??; apply: H.\nby move=> /(_ _ _)/mem_orthovP; move=> H ????; apply: H.\nQed.",
    "Lemma orthov_sym U V : (U '_|_ V)%VS = (V '_|_ U)%VS.\nProof. by apply/orthovP/orthovP => eq0 ????; apply/eqP; rewrite herm_eq0C eq0. Qed.",
    "Lemma mem_orthov1 v u : (u \\in orthov <[v]>) = ('[u, v] == 0).\nProof. by rewrite orthov1E memv_ker lfunE. Qed.",
    "Lemma orthov11 u v : (<[u]> '_|_ <[v]>)%VS = ('[u, v] == 0).\nProof. exact: mem_orthov1. Qed.",
    "Lemma mem_orthov1_sym v u : (u \\in orthov <[v]>) = (v \\in orthov <[u]>).\nProof. exact: orthov_sym. Qed.",
    "Lemma orthov0 : orthov 0 = fullv.\nProof.\napply/eqP; rewrite eqEsubv subvf.\napply/subvP => x _; rewrite mem_orthov1.\nby rewrite linear0r.\nQed.",
    "Lemma mem_orthov_sym V u : (u \\in orthov V) = (V <= orthov <[u]>)%VS.\nProof. exact: orthov_sym. Qed.",
    "Lemma leq_dim_orthov1 u V : ((\\dim V).-1 <= \\dim (V :&: orthov <[u]>))%N.\nProof.\nrewrite -(limg_ker_dim (alpha u) V) -orthov1E.\nhave := dimvS (subvf (alpha u @: V)); rewrite dimvf addnC.\nby case: (\\dim _) => [|[]] // _; rewrite leq_pred.\nQed.",
    "Lemma dim_img_form_eq1 u V : u \\notin orthov V -> \\dim (alpha u @: V)%VS = 1%N.\nProof.\nmove=> /mem_orthovPn [v vV Northov_uv]; apply/eqP; rewrite eqn_leq /=.\nrewrite -[1%N as X in (_ <= X)%N](dimvf [the vectType F of F^o]) dimvS ?subvf//=.\nhave := @dimvS _ _ <['[v, u] : F^o]> (alpha u @: V).\nrewrite -memvE dim_vline herm_eq0C Northov_uv; apply.\nby apply/memv_imgP; exists v; rewrite ?memvf// !lfunE /=.\nQed.",
    "Lemma eq_dim_orthov1 u V : u \\notin orthov V -> (\\dim V).-1 = \\dim (V :&: orthov <[u]>).\nProof.\nrewrite -(limg_ker_dim (alpha u) V) => /dim_img_form_eq1->.\nby rewrite -orthov1E addn1.\nQed.",
    "Lemma dim_img_form_eq0 u V : u \\in orthov V -> \\dim (alpha u @: V)%VS = 0%N.\nProof. by move=> uV; apply/eqP; rewrite dimv_eq0 -lkerE -orthov1E orthov_sym. Qed.",
    "Lemma neq_dim_orthov1 u V : (\\dim V > 0)%N ->\n  u \\in orthov V -> ((\\dim V).-1 < \\dim (V :&: orthov <[u]>))%N.\nProof.\nmove=> V_gt0; rewrite -(limg_ker_dim (alpha u) V) -orthov1E => u_in.\nrewrite dim_img_form_eq0 // addn0 (capv_idPl _) 1?orthov_sym //.\nby case: (\\dim _) V_gt0.\nQed.",
    "Lemma leqif_dim_orthov1 u V : (\\dim V > 0)%N ->\n  ((\\dim V).-1 <= \\dim (V :&: orthov <[u]>) ?= iff (u \\notin orthov V))%N.\nProof.\nmove=> Vr_gt0; apply/leqifP.\nby case: (boolP (u \\in _)) => /= [/neq_dim_orthov1->|/eq_dim_orthov1->].\nQed.",
    "Lemma leqif_dim_orthov1_full u : (n > 0)%N ->\n   ((\\dim {:vT}).-1 <= \\dim (orthov <[u]>) ?= iff (u \\notin orthov fullv))%N.\nProof.\nby move=> n_gt0; have := @leqif_dim_orthov1 u fullv; rewrite capfv; apply.\nQed.",
    "Lemma orthogonal1P u v : reflect ('[u, v] = 0) (orthogonal form [:: u] [:: v]).\nProof. by rewrite /orthogonal /= !andbT; apply: eqP. Qed.",
    "Lemma orthogonalP us vs :\n  reflect {in us & vs, forall u v, '[u, v] = 0} (orthogonal form us vs).\nProof.\napply: (iffP allP) => ousvs u => [v /ousvs/allP opus /opus/eqP // | /ousvs opus].\nby apply/allP=> v /= /opus->.\nQed.",
    "Lemma orthogonal_oppr S R : orthogonal form S (map -%R R) = orthogonal form S R.\nProof.\nwlog suffices IH: S R / orthogonal form S R -> orthogonal form S (map -%R R).\n  by apply/idP/idP=> /IH; rewrite ?mapK //; apply: opprK.\nmove/orthogonalP=> oSR; apply/orthogonalP=> xi1 _ Sxi1 /mapP[xi2 Rxi2 ->].\nby rewrite linearNr /= oSR ?oppr0.\nQed.",
    "Lemma orthogonalE us vs : (orthogonal form us vs) = (<<us>> '_|_ <<vs>>)%VS.\nProof.\napply/orthogonalP/orthovP => uvsP u v; last first.\n  by move=> uus vvs; rewrite uvsP // memv_span.\nrewrite -[us]in_tupleE -[vs]in_tupleE => /coord_span-> /coord_span->.\nrewrite linear_sumr big1 //= => i _.\nrewrite linear_sumlz big1 //= => j _.\nby rewrite linearZlr/= uvsP ?mulr0// mem_nth.\nQed.",
    "Lemma orthovE U V : (U '_|_ V)%VS = orthogonal form (vbasis U) (vbasis V).\nProof. by rewrite orthogonalE !(span_basis (vbasisP _)). Qed.",
    "Lemma orthoDv U V W : (U + V '_|_ W)%VS = (U '_|_ W)%VS && (V '_|_ W)%VS.\nProof. by rewrite subv_add. Qed.",
    "Lemma orthovD U V W : (U '_|_ V + W)%VS = (U '_|_ V)%VS && (U '_|_ W)%VS.\nProof. by rewrite ![(U '_|_ _)%VS]orthov_sym orthoDv. Qed.",
    "Lemma dnorm_geiff0 u : 0 <= '[u] ?= iff (u == 0).\nProof.\nby apply/leifP; have [->|uN0] := altP eqP; rewrite ?linear0r ?neq0_dnorm_gt0.\nQed.",
    "Lemma dnorm_ge0 u : 0 <= '[u]. Proof. by rewrite dnorm_geiff0. Qed.",
    "Lemma dnorm_eq0 u : ('[u] == 0) = (u == 0).\nProof. by rewrite -dnorm_geiff0 eq_sym. Qed.",
    "Lemma dnorm_gt0 u : (0 < '[u]) = (u != 0).\nProof. by rewrite lt_def dnorm_eq0 dnorm_ge0 andbT. Qed.",
    "Lemma sqrt_dnorm_ge0 u : 0 <= sqrtC '[u].\nProof. by rewrite sqrtC_ge0 dnorm_ge0. Qed.",
    "Lemma sqrt_dnorm_eq0 u : (sqrtC '[u] == 0) = (u == 0).\nProof. by rewrite sqrtC_eq0 dnorm_eq0. Qed.",
    "Lemma sqrt_dnorm_gt0 u : (sqrtC '[u] > 0) = (u != 0).\nProof. by rewrite sqrtC_gt0 dnorm_gt0. Qed.",
    "Lemma dnormZ a u : '[a *: u]= `|a| ^+ 2 * '[u].\nProof. by rewrite linearZl_LR linearZr_LR/= mulrA normCK. Qed.",
    "Lemma dnormD u v : let d := '[u, v] in '[u + v] = '[u] + '[v] + (d + d^*).\nProof. by rewrite hnormD mul1r. Qed.",
    "Lemma dnormB u v : let d := '[u, v] in '[u - v] = '[u] + '[v] - (d + d^*).\nProof. by rewrite hnormB mul1r. Qed.",
    "Lemma pairwise_orthogonalP  S :\n  reflect (uniq (0 :: S)\n             /\\ {in S &, forall phi psi, phi != psi -> '[phi, psi] = 0})\n          (pairwise_orthogonal form S).\nProof.\nrewrite /pairwise_orthogonal /=; case notS0: (~~ _); last by right; case.\nelim: S notS0 => [|phi S IH] /=; first by left.\nrewrite inE eq_sym andbT => /norP[nz_phi {}/IH IH].\nhave [opS | not_opS] := allP; last first.\n  right=> [[/andP[notSp _] opS]]; case: not_opS => psi Spsi /=.\n  by rewrite opS ?mem_head 1?mem_behead // (memPnC notSp).\nrewrite (contra (opS _)) /= ?dnorm_eq0 //.\napply: (iffP IH) => [] [uniqS oSS]; last first.\n  by split=> //; apply: sub_in2 oSS => psi Spsi; apply: mem_behead.\nsplit=> // psi xi; rewrite !inE => /predU1P[-> // | Spsi].\n  by case/predU1P=> [-> | /opS] /eqP.\ncase/predU1P=> [-> _ | Sxi /oSS-> //].\napply/eqP; rewrite hermC.\nby move: (opS psi Spsi) => /= /eqP ->; rewrite rmorph0 mulr0.\nQed.",
    "Lemma pairwise_orthogonal_cat R S :\n  pairwise_orthogonal form (R ++ S) =\n  [&& pairwise_orthogonal form R, pairwise_orthogonal form  S & orthogonal form R S].\nProof.\nrewrite /pairwise_orthogonal mem_cat negb_or -!andbA; do !bool_congr.\nelim: R => [|phi R /= ->]; rewrite ?andbT// all_cat -!andbA /=.\nby do !bool_congr.\nQed.",
    "Lemma orthonormal_cat R S :\n  orthonormal form (R ++ S) =\n  [&& orthonormal form R, orthonormal form S & orthogonal form R S].\nProof.\nrewrite !orthonormalE pairwise_orthogonal_cat all_cat -!andbA.\nby do !bool_congr.\nQed.",
    "Lemma orthonormalP S :\n  reflect (uniq S /\\ {in S &, forall phi psi, '[phi, psi] = (phi == psi)%:R})\n          (orthonormal form S).\nProof.\nrewrite orthonormalE; have [/= normS | not_normS] := allP; last first.\n  by right=> [[_ o1S]]; case: not_normS => phi Sphi; rewrite /= o1S ?eqxx.\napply: (iffP (pairwise_orthogonalP S)) => [] [uniqS oSS].\n  split=> // [|phi psi]; first by case/andP: uniqS.\n  by have [-> _ /normS/eqP | /oSS] := altP eqP.\nsplit=> // [|phi psi Sphi Spsi /negbTE]; last by rewrite oSS // => ->.\nby rewrite /= (contra (normS _)) // linear0r  eq_sym oner_eq0.\nQed.",
    "Lemma sub_orthonormal S1 S2 :\n  {subset S1 <= S2} -> uniq S1 -> orthonormal form S2 -> orthonormal form S1.\nProof.\nmove=> sS12 uniqS1 /orthonormalP[_ oS1].\nby apply/orthonormalP; split; last apply: sub_in2 sS12 _ _.\nQed.",
    "Lemma orthonormal2P phi psi :\n  reflect [/\\ '[phi, psi] = 0, '[phi] = 1 & '[psi] = 1]\n          (orthonormal form [:: phi; psi]).\nProof.\nrewrite /orthonormal /= !andbT andbC.\nby apply: (iffP and3P) => [] []; do 3!move/eqP->.\nQed.",
    "Lemma sub_pairwise_orthogonal S1 S2 :\n    {subset S1 <= S2} ->  uniq S1 ->\n  pairwise_orthogonal form S2 -> pairwise_orthogonal form S1.\nProof.\nmove=> sS12 uniqS1 /pairwise_orthogonalP[/andP[notS2_0 _] oS2].\napply/pairwise_orthogonalP; rewrite /= (contra (sS12 0)) //.\nby split=> //; apply: sub_in2 oS2.\nQed.",
    "Lemma orthogonal_free S : pairwise_orthogonal form S -> free S.\nProof.\ncase/pairwise_orthogonalP=> [/=/andP[notS0 uniqS] oSS].\nrewrite -(in_tupleE S); apply/freeP => a aS0 i.\nhave S_i: S`_i \\in S by apply: mem_nth.\nhave /eqP: '[S`_i, 0] = 0 := linear0r _ _.\nrewrite -{2}aS0 raddf_sum /= (bigD1 i) //= big1 => [|j neq_ji]; last 1 first.\n  by rewrite linearZ /= oSS ?mulr0 ?mem_nth // eq_sym nth_uniq.\nrewrite addr0 linearZ mulf_eq0 conjC_eq0 dnorm_eq0.\nby case/pred2P=> // Si0; rewrite -Si0 S_i in notS0.\nQed.",
    "Lemma filter_pairwise_orthogonal S p :\n  pairwise_orthogonal form S -> pairwise_orthogonal form (filter p S).\nProof.\nmove=> orthoS; apply: sub_pairwise_orthogonal (orthoS).\n  exact: mem_subseq (filter_subseq p S).\nexact/filter_uniq/free_uniq/orthogonal_free.\nQed.",
    "Lemma orthonormal_free S : orthonormal form  S -> free S.\nProof. by move/orthonormal_orthogonal/orthogonal_free. Qed.",
    "Lemma CauchySchwarz_sqrt u v :\n  `|'[u, v]| <= sqrtC '[u] * sqrtC '[v] ?= iff ~~ free [:: u; v].\nProof.\nrewrite -(sqrCK (normr_ge0 _)) -sqrtCM ?nnegrE//.\nrewrite (mono_in_leif (@ler_sqrtC _)) 1?rpredM//= ?nnegrE//=.\nexact: CauchySchwarz.\nQed.",
    "Lemma orthoP phi psi : reflect ('[phi, psi] = 0) (orthogonal form  [:: phi] [:: psi]).\nProof. by rewrite /orthogonal /= !andbT; apply: eqP. Qed.",
    "Lemma orthoPl phi S :\n  reflect {in S, forall psi, '[phi, psi] = 0} (orthogonal form [:: phi] S).\nProof.\nby rewrite [orthogonal form _ S]andbT /=; apply: (iffP allP) => ophiS ? /ophiS/eqP.\nQed.",
    "Lemma orthogonal_sym : symmetric (orthogonal form).\nProof.\napply: symmetric_from_pre => R S /orthogonalP oRS.\nby apply/orthogonalP=> phi psi Rpsi Sphi; rewrite hermC /= oRS  ?rmorph0 ?mulr0.\nQed.",
    "Lemma orthoPr S psi :\n  reflect {in S, forall phi, '[phi, psi] = 0} (orthogonal form S [:: psi]).\nProof.\nrewrite orthogonal_sym.\nby apply: (iffP orthoPl) => oSpsi phi Sphi; rewrite hermC /= oSpsi //= conjC0 mulr0.\nQed.",
    "Lemma orthogonal_catl R1 R2 S :\n  orthogonal form (R1 ++ R2) S = orthogonal form R1 S && orthogonal form R2 S.\nProof. exact: all_cat. Qed.",
    "Lemma orthogonal_catr R S1 S2 :\n  orthogonal form R (S1 ++ S2) = orthogonal form R S1 && orthogonal form R S2.\nProof. by rewrite !(orthogonal_sym R) orthogonal_catl. Qed.",
    "Lemma eq_pairwise_orthogonal R S :\n  perm_eq R S -> pairwise_orthogonal form R = pairwise_orthogonal form  S.\nProof.\napply: catCA_perm_subst R S => R S S'.\nrewrite !pairwise_orthogonal_cat !orthogonal_catr (orthogonal_sym R S) -!andbA.\nby do !bool_congr.\nQed.",
    "Lemma eq_orthonormal S0 S : perm_eq S0 S -> orthonormal form S0 = orthonormal form S.\nProof.\nmove=> eqRS; rewrite !orthonormalE (eq_all_r (perm_mem eqRS)).\nby rewrite (eq_pairwise_orthogonal eqRS).\nQed.",
    "Lemma orthogonal_oppl S R : orthogonal form  (map -%R S) R = orthogonal form S R.\nProof. by rewrite -!(orthogonal_sym R) orthogonal_oppr. Qed.",
    "Lemma triangle_lerif u v :\n  sqrtC '[u + v] <= sqrtC '[u] + sqrtC '[v]\n           ?= iff ~~ free [:: u; v] && (0 <= coord [tuple v] 0 u).\nProof.\nrewrite -(mono_in_leif ler_sqr) ?rpredD ?nnegrE ?sqrtC_ge0//.\nrewrite andbC sqrrD !sqrtCK addrAC dnormD (mono_leif (lerD2l _))/=.\nrewrite -mulr_natr -[_ + _](divfK (negbT (pnatr_eq0 C 2))) -/('Re _).\nrewrite (mono_leif (ler_pM2r _)) ?ltr0n//.\nhave := leif_trans (leif_Re_Creal '[u, v]) (CauchySchwarz_sqrt u v).\nrewrite ReE; congr (_ <= _ ?= iff _); apply: andb_id2r.\nrewrite free_cons span_seq1 seq1_free -negb_or negbK orbC.\nhave [-> | nz_v] := altP (v =P 0); first by rewrite linear0 coord0.\ncase/vlineP=> [x ->]; rewrite linearZl linearZ/= pmulr_lge0 ?dnorm_gt0 //=.\nby rewrite (coord_free 0) ?seq1_free // eqxx mulr1.\nQed.",
    "Lemma span_orthogonal S1 S2 phi1 phi2 :\n    orthogonal form S1 S2 -> phi1 \\in <<S1>>%VS -> phi2 \\in <<S2>>%VS ->\n '[phi1, phi2] = 0.\nProof.\nmove/orthogonalP=> oS12; do 2!move/(@coord_span _ _ _ (in_tuple _))->.\nrewrite linear_sumlz big1 // => i _; rewrite linear_sumr big1 // => j _.\nby rewrite linearZlr/= oS12 ?mem_nth ?mulr0.\nQed.",
    "Lemma orthogonal_split S beta :\n  {X : U  & X \\in <<S>>%VS &\n      {Y :U | [/\\ beta = X + Y, '[X, Y] = 0 & orthogonal form [:: Y] S]}}.\nProof.\nsuffices [X S_X [Y -> oYS]]:\n  {X : _ & X \\in <<S>>%VS & {Y | beta = X + Y & orthogonal form [:: Y] S}}.\n- exists X => //; exists Y.\n  by rewrite hermC /= (span_orthogonal oYS) ?memv_span1 ?conjC0 // mulr0.\nelim: S beta => [|phi S IHS] beta.\n  by exists 0; last exists beta; rewrite ?mem0v ?add0r.\nhave [[UU S_U [V -> oVS]] [X S_X [Y -> oYS]]] := (IHS phi, IHS beta).\npose Z := '[Y, V] / '[V] *: V; exists (X + Z).\n  rewrite /Z -{4}(addKr UU V) scalerDr scalerN addrA addrC span_cons.\n  by rewrite memv_add ?memvB ?memvZ ?memv_line.\nexists (Y - Z); first by rewrite addrCA !addrA addrK addrC.\napply/orthoPl=> psi; rewrite !inE => /predU1P[-> | Spsi]; last first.\n  by rewrite linearBl linearZl_LR /= (orthoPl oVS _ Spsi) mulr0 subr0 (orthoPl oYS).\nrewrite linearBl !linearDr /= (span_orthogonal oYS) // ?memv_span ?mem_head //.\nrewrite !linearZl_LR /= (span_orthogonal oVS _ S_U) ?mulr0 ?memv_span ?mem_head //.\nhave [-> | nzV] := eqVneq V 0; first by rewrite linear0r !mul0r subrr.\nby rewrite divfK ?dnorm_eq0 ?subrr.\nQed.",
    "Lemma isometry_of_dnorm S tauS :\n    pairwise_orthogonal form1 S -> pairwise_orthogonal form2 tauS ->\n    map normf2 tauS = map normf1 S ->\n  {tau : {linear U1 -> U2} | map tau S = tauS\n                                   & {in <<S>>%VS &, isometry form2 form1 tau}}.\nProof.\nmove=> oS oT eq_nST; have freeS := orthogonal_free oS.\nhave eq_sz: size tauS = size S by have:= congr1 size eq_nST; rewrite !size_map.\nhave [tau defT] := linear_of_free S tauS; rewrite -[S]/(tval (in_tuple S)).\nexists tau => [|u v /coord_span-> /coord_span->]; rewrite ?raddf_sum ?defT //=.\napply: eq_bigr => i _ /=; rewrite !linearZ/= !linear_sumlz; congr (_ * _).\napply: eq_bigr => j _ /=; rewrite linearZ !linearZl; congr (_ * _).\nrewrite -!(nth_map 0 0 tau) ?{}defT //; have [-> | neq_ji] := eqVneq j i.\n  by rewrite /=  -[RHS](nth_map 0 0 normf1) -?[LHS](nth_map 0 0 normf2) ?eq_sz // eq_nST.\nhave{oS} [/=/andP[_ uS] oS] := pairwise_orthogonalP oS.\nhave{oT} [/=/andP[_ uT] oT] := pairwise_orthogonalP oT.\nby rewrite oS ?oT ?mem_nth ?nth_uniq ?eq_sz.\nQed.",
    "Lemma isometry_of_free S f :\n    free S -> {in S &, isometry form2 form1 f} ->\n  {tau : {linear U1 -> U2} |\n    {in S, tau =1 f} & {in <<S>>%VS &, isometry form2 form1 tau}}.\nProof.\nmove=> freeS If; have defS := free_span freeS.\nhave [tau /(_ freeS (size_map f S))Dtau] := linear_of_free S (map f S).\nhave {}Dtau: {in S, tau =1 f}.\n  by move=> _ /(nthP 0)[i ltiS <-]; rewrite -!(nth_map 0 0) ?Dtau.\nexists tau => // _ _ /defS[a -> _] /defS[b -> _] /=.\nrewrite  2!{1}linear_sum /= !{1}linear_sumlz /=;  apply/eq_big_seq=> xi1 Sxi1.\nrewrite !{1}linear_sumr; apply/eq_big_seq=> xi2 Sxi2 /=.\nby rewrite !linearZ /= !linearZl !Dtau //= If.\nQed.",
    "Lemma isometry_raddf_inj (tau : {additive U1 -> U2}) :\n    {in U1 &, isometry form2 form1 tau} ->\n    {in U1 &, forall u v, u - v \\in U1} ->\n  {in U1 &, injective tau}.\nProof.\nmove=> Itau linU phi psi Uphi Upsi /eqP; rewrite -subr_eq0 -raddfB.\nby rewrite -(dnorm_eq0 form2)  Itau ?linU // dnorm_eq0 subr_eq0 => /eqP.\nQed.",
    "Lemma matrix_of_formE form i j : matrix_of_form form i j = form 'e_i 'e_j.\nProof. by rewrite mxE. Qed.",
    "Lemma form_of_matrix_is_bilinear :\n  bilinear_for\n    (GRing.Scale.Law.clone _ _ ( *%R ) _) (GRing.Scale.Law.clone _ _ (theta \\; *%R ) _)\n    (@form_of_matrix theta m M).\nProof.\nsplit=> [u'|u] a x y /=.\n- by rewrite /form_of_matrix !mulmxDl linearD/= -!scalemxAl linearZ.\n- rewrite /form_of_matrix -linearZ/= -linearD/= [in LHS]linearD/= map_mxD.\n  rewrite mulmxDr; congr (\\tr (_ + _)).\n  rewrite scalemxAr; congr (_ *m _).\n  by rewrite linearZ/= map_mxZ.\nQed.",
    "Lemma rV_formee i j : '['e_i :'rV__, 'e_j] = M i j.\nProof.\nrewrite /form_of_matrix -rowE -map_trmx map_delta_mx -[M in LHS]trmxK.\nby rewrite -tr_col -trmx_mul -rowE trace_mx11 !mxE.\nQed.",
    "Lemma form_of_matrixK : matrix_of_form (form_of_matrix theta M) = M.\nProof. by apply/matrixP => i j; rewrite !mxE rV_formee. Qed.",
    "Lemma rV_form0_eq0 : M = 0 -> forall u v, '[u, v] = 0.\nProof.\nby rewrite /form_of_matrix => -> u v; rewrite mulmx0 mul0mx trace_mx11 mxE.\nQed.",
    "Lemma matrix_of_formK : form_of_matrix theta (matrix_of_form form) =2 form.\nProof.\nset f := (X in X =2 _); have f_eq i j : f 'e_i 'e_j = form 'e_i 'e_j.\n  by rewrite /f rV_formee mxE.\nmove=> u v; rewrite [u]row_sum_delta [v]row_sum_delta /f.\nrewrite !linear_sum/=; apply: eq_bigr => j _.\nrewrite !linear_sumlz/=; apply: eq_bigr => i _.\nby rewrite !linearZlr/= -f_eq.\nQed.",
    "Lemma is_hermitianmxE M :\n  (M \\is hermitianmx) = (M == (-1) ^+ eps *: M ^t theta).\nProof. by rewrite qualifE. Qed.",
    "Lemma is_hermitianmxP M :\n  reflect (M = (-1) ^+ eps *: M ^t theta) (M \\is hermitianmx).\nProof. by rewrite is_hermitianmxE; apply/eqP. Qed.",
    "Lemma hermitianmxE (M : hermitian_matrix) :\n  M = ((-1) ^+ eps) *: M ^t theta :> 'M__.\nProof. by apply/eqP; case: M. Qed.",
    "Lemma trmx_hermitian (M : hermitian_matrix) :\n  M^T = ((-1) ^+ eps) *: M ^ theta :> 'M__.\nProof. by rewrite {1}hermitianmxE linearZ /= map_trmx trmxK. Qed.",
    "Lemma maptrmx_hermitian : M^t theta = (-1) ^+ eps *: (M : 'M__).\nProof.\nrewrite trmx_hermitian map_mxZ rmorph_sign -map_mx_comp.\nby rewrite (map_mx_id (rmorphK _)).\nQed.",
    "Lemma form_of_matrix_is_hermitian m x y :\n  (@form_of_matrix theta m M) x y =\n  (-1) ^+ eps * theta ((@form_of_matrix theta m M) y x).\nProof.\nrewrite {1}hermitianmxE /form_of_matrix.\nrewrite -!(scalemxAr, scalemxAl) linearZ/=; congr (_ * _).\nrewrite -mxtrace_tr -trace_map_mx !(trmx_mul, map_mxM, map_trmx, trmxK).\nby rewrite -mulmxA -!map_mx_comp !(map_mx_id (rmorphK _)).\nQed.",
    "Lemma orthomxE u v : (u '_|_ v)%MS = ('[u, v] == 0).\nProof.\nrewrite (sameP sub_kermxP eqP) mulmxA.\nby rewrite [_ *m _^t _]mx11_scalar -trace_mx11 fmorph_eq0.\nQed.",
    "Lemma hermmx_eq0P {u v} : reflect ('[u, v] = 0) (u '_|_ v)%MS.\nProof. by rewrite orthomxE; apply/eqP. Qed.",
    "Lemma orthomxP p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  reflect (forall (u v : 'rV_n), u <= A -> v <= B -> u '_|_ v)%MS\n          (A '_|_ B)%MS.\nProof.\napply: (iffP idP) => AnB.\n  move=> u v uA vB; rewrite (submx_trans uA) // (submx_trans AnB) //.\n  apply/sub_kermxP; have /submxP [w ->] := vB.\n  rewrite trmx_mul map_mxM !mulmxA -[kermx _ *m _ *m _]mulmxA.\n  by rewrite [kermx _ *m _](sub_kermxP _) // mul0mx.\napply/rV_subP => u /AnB /(_ _) /sub_kermxP uMv; apply/sub_kermxP.\nsuff: forall m (v : 'rV[R]_m),\n  (forall i, v *m 'e_i ^t theta = 0 :> 'M_1) -> v = 0.\n  apply => i; rewrite !mulmxA -!mulmxA -map_mxM -trmx_mul uMv //.\n  by apply/submxP; exists 'e_i.\nmove=> /= m v Hv; apply: (can_inj (@trmxK _ _ _)).\nrewrite trmx0; apply/row_matrixP=> i; rewrite row0 rowE.\napply: (can_inj (@trmxK _ _ _)); rewrite trmx0 trmx_mul trmxK.\nby rewrite -(map_delta_mx theta) map_trmx Hv.\nQed.",
    "Lemma orthomx_sym p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  (A '_|_ B)%MS = (B '_|_ A)%MS.\nProof.\ngen have nC : p q A B / (A '_|_ B -> B '_|_ A)%MS; last by apply/idP/idP; apply/nC.\nmove=> AnB; apply/orthomxP => u v ? ?; rewrite orthomxE.\nrewrite hermC mulf_eq0 ?fmorph_eq0 ?signr_eq0 /=.\nby rewrite -orthomxE (orthomxP _ _ AnB).\nQed.",
    "Lemma ortho_ortho_mx p (A : 'M_(p, n)) : (A^! '_|_ A)%MS. Proof. by []. Qed.",
    "Lemma ortho_mx_ortho p (A : 'M_(p, n)) : (A '_|_ A^!)%MS.\nProof. by rewrite orthomx_sym. Qed.",
    "Lemma rank_orthomx u : (\\rank (u ^!) >= n.-1)%N.\nProof.\nrewrite mxrank_ker -subn1 leq_sub2l //.\nby rewrite (leq_trans (mxrankM_maxr  _ _)) // rank_leq_col.\nQed.",
    "Lemma radmxE : radmx = kermx M.\nProof. by rewrite /orthomx /orthomx trmx1 map_mx1 mulmx1. Qed.",
    "Lemma orthoNmx k m (A : 'M[R]_(k, n)) (B : 'M[R]_(m, n)) :\n  ((- A) '_|_ B)%MS = (A '_|_ B)%MS.\nProof. by rewrite eqmx_opp. Qed.",
    "Lemma orthomxN k m (A : 'M[R]_(k, n)) (B : 'M[R]_(m, n)) :\n  (A '_|_ (- B))%MS = (A '_|_ B)%MS.\nProof. by rewrite ![(A '_|_ _)%MS]orthomx_sym orthoNmx. Qed.",
    "Lemma orthoDmx k m p (A : 'M[R]_(k, n)) (B : 'M[R]_(m, n)) (C : 'M[R]_(p, n)) :\n  (A + B '_|_ C)%MS = (A '_|_ C)%MS && (B '_|_ C)%MS.\nProof. by rewrite addsmxE !(sameP sub_kermxP eqP) mul_col_mx col_mx_eq0. Qed.",
    "Lemma orthomxD  k m p (A : 'M[R]_(k, n)) (B : 'M[R]_(m, n)) (C : 'M[R]_(p, n)) :\n  (A '_|_ B + C)%MS = (A '_|_ B)%MS && (A '_|_ C)%MS.\nProof. by rewrite ![(A '_|_ _)%MS]orthomx_sym orthoDmx. Qed.",
    "Lemma orthoZmx p m a (A : 'M[R]_(p, n)) (B : 'M[R]_(m, n)) : a != 0 ->\n  (a *: A '_|_ B)%MS = (A '_|_ B)%MS.\nProof. by move=> a_neq0; rewrite eqmx_scale. Qed.",
    "Lemma orthomxZ p m a (A : 'M[R]_(p, n)) (B : 'M[R]_(m, n)) : a != 0 ->\n  (A '_|_ (a *: B))%MS = (A '_|_ B)%MS.\nProof. by move=> a_neq0; rewrite ![(A '_|_ _)%MS]orthomx_sym orthoZmx. Qed.",
    "Lemma eqmx_ortho p m (A : 'M[R]_(p, n)) (B : 'M[R]_(m, n)) :\n  (A :=: B)%MS -> (A^! :=: B^!)%MS.\nProof.\nmove=> eqAB; apply/eqmxP.\nby rewrite orthomx_sym -eqAB ortho_mx_ortho orthomx_sym eqAB ortho_mx_ortho.\nQed.",
    "Lemma genmx_ortho p (A : 'M[R]_(p, n)) : (<<A>>^! :=: A^!)%MS.\nProof. exact: (eqmx_ortho (genmxE _)). Qed.",
    "Lemma hermitian1mx_subproof {C : numClosedFieldType} n : (1%:M : 'M[C]_n) \\is hermsymmx.\nProof.\nby rewrite qualifE /= expr0 scale1r tr_scalar_mx map_scalar_mx conjC1.\nQed.",
    "Lemma divz_nat (n d : nat) : (n %/ d)%Z = (n %/ d)%N.\nProof. by case: d => // d; rewrite /divz /= mul1r. Qed.",
    "Lemma divzN m d : (m %/ - d)%Z = - (m %/ d)%Z.\nProof. by case: m => n; rewrite /divz /= sgzN abszN mulNr. Qed.",
    "Lemma divz_abs (m d : int) : (m %/ `|d|)%Z = (-1) ^+ (d < 0)%R * (m %/ d)%Z.\nProof.\nby rewrite {3}[d]intEsign !mulr_sign; case: ifP => -> //; rewrite divzN opprK.\nQed.",
    "Lemma div0z d : (0 %/ d)%Z = 0.\nProof.\nby rewrite -(canLR (signrMK _) (divz_abs _ _)) (divz_nat 0) div0n mulr0.\nQed.",
    "Lemma divNz_nat m d : (d > 0)%N -> (Negz m %/ d)%Z = - (m %/ d).+1%:Z.\nProof. by case: d => // d _; apply: mul1r. Qed.",
    "Lemma divz_eq m d : m = (m %/ d)%Z * d + (m %% d)%Z.\nProof. by rewrite addrC subrK. Qed.",
    "Lemma modzN m d : (m %% - d)%Z = (m %% d)%Z.\nProof. by rewrite /modz divzN mulrNN. Qed.",
    "Lemma modz_abs m d : (m %% `|d|%N)%Z = (m %% d)%Z.\nProof. by rewrite {2}[d]intEsign mulr_sign; case: ifP; rewrite ?modzN. Qed.",
    "Lemma modz_nat (m d : nat) : (m %% d)%Z = (m %% d)%N.\nProof.\nby apply: (canLR (addrK _)); rewrite addrC divz_nat {1}(divn_eq m d).\nQed.",
    "Lemma modNz_nat m d : (d > 0)%N -> (Negz m %% d)%Z = d%:Z - 1 - (m %% d)%:Z.\nProof.\nrewrite /modz => /divNz_nat->; apply: (canLR (addrK _)).\nrewrite -!addrA -!opprD -!PoszD -opprB mulnSr !addnA PoszD addrK.\nby rewrite addnAC -addnA mulnC -divn_eq.\nQed.",
    "Lemma modz_ge0 m d : d != 0 -> 0 <= (m %% d)%Z.\nProof.\nrewrite -absz_gt0 -modz_abs => d_gt0.\ncase: m => n; rewrite ?modNz_nat ?modz_nat // -addrA -opprD subr_ge0.\nby rewrite lez_nat ltn_mod.\nQed.",
    "Lemma divz0 m : (m %/ 0)%Z = 0. Proof. by case: m. Qed.",
    "Lemma mod0z d : (0 %% d)%Z = 0. Proof. by rewrite /modz div0z mul0r subrr. Qed.",
    "Lemma modz0 m : (m %% 0)%Z = m. Proof. by rewrite /modz mulr0 subr0. Qed.",
    "Lemma divz_small m d : 0 <= m < `|d|%:Z -> (m %/ d)%Z = 0.\nProof.\nrewrite -(canLR (signrMK _) (divz_abs _ _)); case: m => // n /divn_small.\nby rewrite divz_nat => ->; rewrite mulr0.\nQed.",
    "Lemma divzMDl q m d : d != 0 -> ((q * d + m) %/ d)%Z = q + (m %/ d)%Z.\nProof.\nrewrite neq_lt -oppr_gt0 => nz_d.\nwlog{nz_d} d_gt0: q d / d > 0; last case: d => // d in d_gt0 *.\n  move=> IH; case/orP: nz_d => /IH// /(_  (- q)).\n  by rewrite mulrNN !divzN -opprD => /oppr_inj.\nwlog q_gt0: q m / q >= 0; last case: q q_gt0 => // q _.\n  move=> IH; case: q => n; first exact: IH; rewrite NegzE mulNr.\n  by apply: canRL (addKr _) _; rewrite -IH ?addNKr.\ncase: m => n; first by rewrite !divz_nat divnMDl.\nhave [le_qd_n | lt_qd_n] := leqP (q * d) n.\n  rewrite divNz_nat // NegzE -(subnKC le_qd_n) divnMDl //.\n  by rewrite -!addnS !PoszD !opprD !addNKr divNz_nat.\nrewrite divNz_nat // NegzE -PoszM subzn // divz_nat.\napply: canRL (addrK _) _; congr _%:Z; rewrite addnC -divnMDl // mulSnr.\nrewrite -{3}(subnKC (ltn_pmod n d_gt0)) addnA addnS -divn_eq addnAC.\nby rewrite subnKC // divnMDl // divn_small ?addn0 // subnSK ?ltn_mod ?leq_subr.\nQed.",
    "Lemma mulzK m d : d != 0 -> (m * d %/ d)%Z = m.\nProof. by move=> d_nz; rewrite -[m * d]addr0 divzMDl // div0z addr0. Qed.",
    "Lemma mulKz m d : d != 0 -> (d * m %/ d)%Z = m.\nProof. by move=> d_nz; rewrite mulrC mulzK. Qed.",
    "Lemma expzB p m n : p != 0 -> (m >= n)%N -> p ^+ (m - n) = (p ^+ m %/ p ^+ n)%Z.\nProof. by move=> p_nz /subnK{2}<-; rewrite exprD mulzK // expf_neq0. Qed.",
    "Lemma modz1 m : (m %% 1)%Z = 0.\nProof. by case: m => n; rewrite (modNz_nat, modz_nat) ?modn1. Qed.",
    "Lemma divz1 m : (m %/ 1)%Z = m. Proof. by rewrite -{1}[m]mulr1 mulzK. Qed.",
    "Lemma divzz d : (d %/ d)%Z = (d != 0).\nProof. by have [-> // | d_nz] := eqVneq; rewrite -{1}[d]mul1r mulzK. Qed.",
    "Lemma ltz_pmod m d : d > 0 -> (m %% d)%Z < d.\nProof.\ncase: m d => n [] // d d_gt0; first by rewrite modz_nat ltz_nat ltn_pmod.\nby rewrite modNz_nat // -lezD1 addrAC subrK gerDl oppr_le0.\nQed.",
    "Lemma ltz_mod m d : d != 0 -> (m %% d)%Z < `|d|.\nProof. by rewrite -absz_gt0 -modz_abs => d_gt0; apply: ltz_pmod. Qed.",
    "Lemma divzMpl p m d : p > 0 -> (p * m %/ (p * d) = m %/ d)%Z.\nProof.\ncase: p => // p p_gt0; wlog d_gt0: d / d > 0; last case: d => // d in d_gt0 *.\n  by move=> IH; case/intP: d => [|d|d]; rewrite ?mulr0 ?divz0 ?mulrN ?divzN ?IH.\nrewrite {1}(divz_eq m d) mulrDr mulrCA divzMDl ?mulf_neq0 ?gt_eqF // addrC.\nrewrite divz_small ?add0r // PoszM pmulr_rge0 ?modz_ge0 ?gt_eqF //=.\nby rewrite ltr_pM2l ?ltz_pmod.\nQed.",
    "Lemma divzMpr p m d : p > 0 -> (m * p %/ (d * p) = m %/ d)%Z.\nProof. by move=> p_gt0; rewrite -!(mulrC p) divzMpl. Qed.",
    "Lemma lez_floor m d : d != 0 -> (m %/ d)%Z * d <= m.\nProof. by rewrite -subr_ge0; apply: modz_ge0. Qed.",
    "Lemma lez_div m d : (`|(m %/ d)%Z| <= `|m|)%N.\nProof.\nwlog d_gt0: d / d > 0; last case: d d_gt0 => // d d_gt0.\n  by move=> IH; case/intP: d => [|n|n]; rewrite ?divz0 ?divzN ?abszN // IH.\ncase: m => n; first by rewrite divz_nat leq_div.\nby rewrite divNz_nat // NegzE !abszN ltnS leq_div.\nQed.",
    "Lemma ltz_ceil m d : d > 0 -> m < ((m %/ d)%Z + 1) * d.\nProof.\nby case: d => // d d_gt0; rewrite mulrDl mul1r -ltrBlDl ltz_mod ?gt_eqF.\nQed.",
    "Lemma ltz_divLR m n d : d > 0 -> ((m %/ d)%Z < n) = (m < n * d).\nProof.\nmove=> d_gt0; apply/idP/idP.\n  by rewrite -[_ < n]lezD1 -(ler_pM2r d_gt0); exact/lt_le_trans/ltz_ceil.\nby rewrite -(ltr_pM2r d_gt0 _ n); apply/le_lt_trans/lez_floor; rewrite gt_eqF.\nQed.",
    "Lemma lez_divRL m n d : d > 0 -> (m <= (n %/ d)%Z) = (m * d <= n).\nProof. by move=> d_gt0; rewrite !leNgt ltz_divLR. Qed.",
    "Lemma lez_pdiv2r d : 0 <= d -> {homo divz^~ d : m n / m <= n}.\nProof.\nby case: d => [[|d]|]// _ [] m [] n //; rewrite /divz !mul1r; apply: leq_div2r.\nQed.",
    "Lemma divz_ge0 m d : d > 0 -> ((m %/ d)%Z >= 0) = (m >= 0).\nProof. by case: d m => // d [] n d_gt0; rewrite (divz_nat, divNz_nat). Qed.",
    "Lemma divzMA_ge0 m n p : n >= 0 -> (m %/ (n * p) = (m %/ n)%Z %/ p)%Z.\nProof.\ncase: n => // [[|n]] _; first by rewrite mul0r !divz0 div0z.\nwlog p_gt0: p / p > 0; last case: p => // p in p_gt0 *.\n  by case/intP: p => [|p|p] IH; rewrite ?mulr0 ?divz0 ?mulrN ?divzN // IH.\nrewrite {2}(divz_eq m (n.+1%:Z * p)) mulrA mulrAC !divzMDl // ?gt_eqF //.\nrewrite [rhs in _ + rhs]divz_small ?addr0 // ltz_divLR // divz_ge0 //.\nby rewrite mulrC ltz_pmod ?modz_ge0 ?gt_eqF ?pmulr_lgt0.\nQed.",
    "Lemma modz_small m d : 0 <= m < d -> (m %% d)%Z = m.\nProof. by case: m d => //= m [] // d; rewrite modz_nat => /modn_small->. Qed.",
    "Lemma modz_mod m d : ((m %% d)%Z = m %[mod d])%Z.\nProof.\nrewrite -!(modz_abs _ d); case: {d}`|d|%N => [|d]; first by rewrite !modz0.\nby rewrite modz_small ?modz_ge0 ?ltz_mod.\nQed.",
    "Lemma modzMDl p m d : (p * d + m = m %[mod d])%Z.\nProof.\nhave [-> | d_nz] := eqVneq d 0; first by rewrite mulr0 add0r.\nby rewrite /modz divzMDl // mulrDl opprD addrACA subrr add0r.\nQed.",
    "Lemma mulz_modr {p m d} : 0 < p -> p * (m %% d)%Z = ((p * m) %% (p * d))%Z.\nProof.\ncase: p => // p p_gt0; rewrite mulrBr; apply: canLR (addrK _) _.\nby rewrite mulrCA -(divzMpl p_gt0) subrK.\nQed.",
    "Lemma mulz_modl {p m d} : 0 < p -> (m %% d)%Z * p = ((m * p) %% (d * p))%Z.\nProof. by rewrite -!(mulrC p); apply: mulz_modr. Qed.",
    "Lemma modzDl m d : (d + m = m %[mod d])%Z.\nProof. by rewrite -{1}[d]mul1r modzMDl. Qed.",
    "Lemma modzDr m d : (m + d = m %[mod d])%Z.\nProof. by rewrite addrC modzDl. Qed.",
    "Lemma modzz d : (d %% d)%Z = 0.\nProof. by rewrite -{1}[d]addr0 modzDl mod0z. Qed.",
    "Lemma modzMl p d : (p * d %% d)%Z = 0.\nProof. by rewrite -[p * d]addr0 modzMDl mod0z. Qed.",
    "Lemma modzMr p d : (d * p %% d)%Z = 0.\nProof. by rewrite mulrC modzMl. Qed.",
    "Lemma modzDml m n d : ((m %% d)%Z + n = m + n %[mod d])%Z.\nProof. by rewrite {2}(divz_eq m d) -[_ * d + _ + n]addrA modzMDl. Qed.",
    "Lemma modzDmr m n d : (m + (n %% d)%Z = m + n %[mod d])%Z.\nProof. by rewrite !(addrC m) modzDml. Qed.",
    "Lemma modzDm m n d : ((m %% d)%Z + (n %% d)%Z = m + n %[mod d])%Z.\nProof. by rewrite modzDml modzDmr. Qed.",
    "Lemma eqz_modDl p m n d : (p + m == p + n %[mod d])%Z = (m == n %[mod d])%Z.\nProof.\nhave [-> | d_nz] := eqVneq d 0; first by rewrite !modz0 (inj_eq (addrI p)).\napply/eqP/eqP=> eq_mn; last by rewrite -modzDmr eq_mn modzDmr.\nby rewrite -(addKr p m) -modzDmr eq_mn modzDmr addKr.\nQed.",
    "Lemma eqz_modDr p m n d : (m + p == n + p %[mod d])%Z = (m == n %[mod d])%Z.\nProof. by rewrite -!(addrC p) eqz_modDl. Qed.",
    "Lemma modzMml m n d : ((m %% d)%Z * n = m * n %[mod d])%Z.\nProof. by rewrite {2}(divz_eq m d) [in RHS]mulrDl mulrAC modzMDl. Qed.",
    "Lemma modzMmr m n d : (m * (n %% d)%Z = m * n %[mod d])%Z.\nProof. by rewrite !(mulrC m) modzMml. Qed.",
    "Lemma modzMm m n d : ((m %% d)%Z * (n %% d)%Z = m * n %[mod d])%Z.\nProof. by rewrite modzMml modzMmr. Qed.",
    "Lemma modzXm k m d : ((m %% d)%Z ^+ k = m ^+ k %[mod d])%Z.\nProof. by elim: k => // k IHk; rewrite !exprS -modzMmr IHk modzMm. Qed.",
    "Lemma modzNm m d : (- (m %% d)%Z = - m %[mod d])%Z.\nProof. by rewrite -mulN1r modzMmr mulN1r. Qed.",
    "Lemma modz_absm m d : ((-1) ^+ (m < 0)%R * (m %% d)%Z = `|m|%:Z %[mod d])%Z.\nProof. by rewrite modzMmr -abszEsign. Qed.",
    "Lemma dvdzE d m : (d %| m)%Z = (`|d| %| `|m|)%N. Proof. by []. Qed.",
    "Lemma dvdz0 d : (d %| 0)%Z. Proof. exact: dvdn0. Qed.",
    "Lemma dvd0z n : (0 %| n)%Z = (n == 0). Proof. by rewrite -absz_eq0 -dvd0n. Qed.",
    "Lemma dvdz1 d : (d %| 1)%Z = (`|d|%N == 1). Proof. exact: dvdn1. Qed.",
    "Lemma dvd1z m : (1 %| m)%Z. Proof. exact: dvd1n. Qed.",
    "Lemma dvdzz m : (m %| m)%Z. Proof. exact: dvdnn. Qed.",
    "Lemma dvdz_mull d m n : (d %| n)%Z -> (d %| m * n)%Z.\nProof. by rewrite !dvdzE abszM; apply: dvdn_mull. Qed.",
    "Lemma dvdz_mulr d m n : (d %| m)%Z -> (d %| m * n)%Z.\nProof. by move=> d_m; rewrite mulrC dvdz_mull. Qed.",
    "Lemma dvdz_mul d1 d2 m1 m2 : (d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2)%Z.\nProof. by rewrite !dvdzE !abszM; apply: dvdn_mul. Qed.",
    "Lemma dvdz_trans n d m : (d %| n -> n %| m -> d %| m)%Z.\nProof. by rewrite !dvdzE; apply: dvdn_trans. Qed.",
    "Lemma dvdzP d m : reflect (exists q, m = q * d) (d %| m)%Z.\nProof.\napply: (iffP dvdnP) => [] [q Dm]; last by exists `|q|%N; rewrite Dm abszM.\nexists ((-1) ^+ (m < 0)%R * q%:Z * (-1) ^+ (d < 0)%R).\nby rewrite -!mulrA -abszEsign -PoszM -Dm -intEsign.\nQed.",
    "Lemma dvdz_mod0P d m : reflect (m %% d = 0)%Z (d %| m)%Z.\nProof.\napply: (iffP dvdzP) => [[q ->] | md0]; first by rewrite modzMl.\nby rewrite (divz_eq m d) md0 addr0; exists (m %/ d)%Z.\nQed.",
    "Lemma dvdz_eq d m : (d %| m)%Z = ((m %/ d)%Z * d == m).\nProof. by rewrite (sameP dvdz_mod0P eqP) subr_eq0 eq_sym. Qed.",
    "Lemma divzK d m : (d %| m)%Z -> (m %/ d)%Z * d = m.\nProof. by rewrite dvdz_eq => /eqP. Qed.",
    "Lemma lez_divLR d m n : 0 < d -> (d %| m)%Z -> ((m %/ d)%Z <= n) = (m <= n * d).\nProof. by move=> /ler_pM2r <- /divzK->. Qed.",
    "Lemma ltz_divRL d m n : 0 < d -> (d %| m)%Z -> (n < m %/ d)%Z = (n * d < m).\nProof. by move=> /ltr_pM2r/(_ n)<- /divzK->. Qed.",
    "Lemma eqz_div d m n : d != 0 -> (d %| m)%Z -> (n == m %/ d)%Z = (n * d == m).\nProof. by move=> /mulIf/inj_eq <- /divzK->. Qed.",
    "Lemma eqz_mul d m n : d != 0 -> (d %| m)%Z -> (m == n * d) = (m %/ d == n)%Z.\nProof. by move=> d_gt0 dv_d_m; rewrite eq_sym -eqz_div // eq_sym. Qed.",
    "Lemma divz_mulAC d m n : (d %| m)%Z -> (m %/ d)%Z * n = (m * n %/ d)%Z.\nProof.\nhave [-> | d_nz] := eqVneq d 0; first by rewrite !divz0 mul0r.\nby move/divzK=> {2} <-; rewrite mulrAC mulzK.\nQed.",
    "Lemma mulz_divA d m n : (d %| n)%Z -> m * (n %/ d)%Z = (m * n %/ d)%Z.\nProof. by move=> dv_d_m; rewrite !(mulrC m) divz_mulAC. Qed.",
    "Lemma mulz_divCA d m n :\n  (d %| m)%Z -> (d %| n)%Z -> m * (n %/ d)%Z = n * (m %/ d)%Z.\nProof. by move=> dv_d_m dv_d_n; rewrite mulrC divz_mulAC ?mulz_divA. Qed.",
    "Lemma divzA m n p : (p %| n -> n %| m * p -> m %/ (n %/ p)%Z = m * p %/ n)%Z.\nProof.\nmove/divzK=> p_dv_n; have [->|] := eqVneq n 0; first by rewrite div0z !divz0.\nrewrite -{1 2}p_dv_n mulf_eq0 => /norP[pn_nz p_nz] /divzK; rewrite mulrA p_dv_n.\nby move/mulIf=> {1} <- //; rewrite mulzK.\nQed.",
    "Lemma divzMA m n p : (n * p %| m -> m %/ (n * p) = (m %/ n)%Z %/ p)%Z.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite mulr0 !divz0.\nhave [-> | nz_n] := eqVneq n 0; first by rewrite mul0r !divz0 div0z.\nby move/divzK=> {2} <-; rewrite mulrA mulrAC !mulzK.\nQed.",
    "Lemma divzAC m n p : (n * p %| m -> (m %/ n)%Z %/ p =  (m %/ p)%Z %/ n)%Z.\nProof. by move=> np_dv_mn; rewrite -!divzMA // mulrC. Qed.",
    "Lemma divzMl p m d : p != 0 -> (d %| m -> p * m %/ (p * d) = m %/ d)%Z.\nProof.\nhave [-> | nz_d nz_p] := eqVneq d 0; first by rewrite mulr0 !divz0.\nby move/divzK=> {1}<-; rewrite mulrCA mulzK ?mulf_neq0.\nQed.",
    "Lemma divzMr p m d : p != 0 -> (d %| m -> m * p %/ (d * p) = m %/ d)%Z.\nProof. by rewrite -!(mulrC p); apply: divzMl. Qed.",
    "Lemma dvdz_mul2l p d m : p != 0 -> (p * d %| p * m)%Z = (d %| m)%Z.\nProof. by rewrite !dvdzE -absz_gt0 !abszM; apply: dvdn_pmul2l. Qed.",
    "Lemma dvdz_mul2r p d m : p != 0 -> (d * p %| m * p)%Z = (d %| m)%Z.\nProof. by rewrite !dvdzE -absz_gt0 !abszM; apply: dvdn_pmul2r. Qed.",
    "Lemma dvdz_exp2l p m n : (m <= n)%N -> (p ^+ m %| p ^+ n)%Z.\nProof. by rewrite dvdzE !abszX; apply: dvdn_exp2l. Qed.",
    "Lemma dvdz_Pexp2l p m n : `|p| > 1 -> (p ^+ m %| p ^+ n)%Z = (m <= n)%N.\nProof. by rewrite dvdzE !abszX ltz_nat; apply: dvdn_Pexp2l. Qed.",
    "Lemma dvdz_exp2r m n k : (m %| n -> m ^+ k %| n ^+ k)%Z.\nProof. by rewrite !dvdzE !abszX; apply: dvdn_exp2r. Qed.",
    "Lemma dvdz_exp k d m : (0 < k)%N -> (d %| m -> d %| m ^+ k)%Z.\nProof. by case: k => // k _ d_dv_m; rewrite exprS dvdz_mulr. Qed.",
    "Lemma eqz_mod_dvd d m n : (m == n %[mod d])%Z = (d %| m - n)%Z.\nProof.\napply/eqP/dvdz_mod0P=> eq_mn.\n  by rewrite -modzDml eq_mn modzDml subrr mod0z.\nby rewrite -(subrK n m) -modzDml eq_mn add0r.\nQed.",
    "Lemma divzDl m n d :\n  (d %| m)%Z -> ((m + n) %/ d)%Z = (m %/ d)%Z + (n %/ d)%Z.\nProof.\nhave [-> | d_nz] := eqVneq d 0; first by rewrite !divz0.\nby move/divzK=> {1}<-; rewrite divzMDl.\nQed.",
    "Lemma divzDr m n d :\n  (d %| n)%Z -> ((m + n) %/ d)%Z = (m %/ d)%Z + (n %/ d)%Z.\nProof. by move=> dv_n; rewrite addrC divzDl // addrC. Qed.",
    "Lemma dvdz_pcharf (R : nzRingType) p : p \\in [pchar R] ->\n  forall n : int, (p %| n)%Z = (n%:~R == 0 :> R).\nProof.\nmove=> pcharRp [] n; rewrite [LHS](dvdn_pcharf pcharRp)//.\nby rewrite NegzE abszN rmorphN// oppr_eq0.\nQed.",
    "Lemma gcdzz m : gcdz m m = `|m|%:Z. Proof. by rewrite /gcdz gcdnn. Qed.",
    "Lemma gcdzC : commutative gcdz. Proof. by move=> m n; rewrite /gcdz gcdnC. Qed.",
    "Lemma gcd0z m : gcdz 0 m = `|m|%:Z. Proof. by rewrite /gcdz gcd0n. Qed.",
    "Lemma gcdz0 m : gcdz m 0 = `|m|%:Z. Proof. by rewrite /gcdz gcdn0. Qed.",
    "Lemma gcd1z : left_zero 1 gcdz. Proof. by move=> m; rewrite /gcdz gcd1n. Qed.",
    "Lemma gcdz1 : right_zero 1 gcdz. Proof. by move=> m; rewrite /gcdz gcdn1. Qed.",
    "Lemma dvdz_gcdr m n : (gcdz m n %| n)%Z. Proof. exact: dvdn_gcdr. Qed.",
    "Lemma dvdz_gcdl m n : (gcdz m n %| m)%Z. Proof. exact: dvdn_gcdl. Qed.",
    "Lemma gcdz_eq0 m n : (gcdz m n == 0) = (m == 0) && (n == 0).\nProof. by rewrite -absz_eq0 eqn0Ngt gcdn_gt0 !negb_or -!eqn0Ngt !absz_eq0. Qed.",
    "Lemma gcdNz m n : gcdz (- m) n = gcdz m n. Proof. by rewrite /gcdz abszN. Qed.",
    "Lemma gcdzN m n : gcdz m (- n) = gcdz m n. Proof. by rewrite /gcdz abszN. Qed.",
    "Lemma gcdz_modr m n : gcdz m (n %% m)%Z = gcdz m n.\nProof.\nrewrite -modz_abs /gcdz; move/absz: m => m.\nhave [-> | m_gt0] := posnP m; first by rewrite modz0.\ncase: n => n; first by rewrite modz_nat gcdn_modr.\nrewrite modNz_nat // NegzE abszN {2}(divn_eq n m) -addnS gcdnMDl.\nrewrite -addrA -opprD -intS /=; set m1 := _.+1.\nhave le_m1m: (m1 <= m)%N by apply: ltn_pmod.\nby rewrite subzn // !(gcdnC m) -{2 3}(subnK le_m1m) gcdnDl gcdnDr gcdnC.\nQed.",
    "Lemma gcdz_modl m n : gcdz (m %% n)%Z n = gcdz m n.\nProof. by rewrite -!(gcdzC n) gcdz_modr. Qed.",
    "Lemma gcdzMDl q m n : gcdz m (q * m + n) = gcdz m n.\nProof. by rewrite -gcdz_modr modzMDl gcdz_modr. Qed.",
    "Lemma gcdzDl m n : gcdz m (m + n) = gcdz m n.\nProof. by rewrite -{2}(mul1r m) gcdzMDl. Qed.",
    "Lemma gcdzDr m n : gcdz m (n + m) = gcdz m n.\nProof. by rewrite addrC gcdzDl. Qed.",
    "Lemma gcdzMl n m : gcdz n (m * n) = `|n|%:Z.\nProof. by rewrite -[m * n]addr0 gcdzMDl gcdz0. Qed.",
    "Lemma gcdzMr n m : gcdz n (n * m) = `|n|%:Z.\nProof. by rewrite mulrC gcdzMl. Qed.",
    "Lemma gcdz_idPl {m n} : reflect (gcdz m n = `|m|%:Z) (m %| n)%Z.\nProof. by apply: (iffP gcdn_idPl) => [<- | []]. Qed.",
    "Lemma gcdz_idPr {m n} : reflect (gcdz m n = `|n|%:Z) (n %| m)%Z.\nProof. by rewrite gcdzC; apply: gcdz_idPl. Qed.",
    "Lemma expz_min e m n : e >= 0 -> e ^+ minn m n = gcdz (e ^+ m) (e ^+ n).\nProof.\nby case: e => // e _; rewrite /gcdz !abszX -expn_min -natz -natrX !natz.\nQed.",
    "Lemma dvdz_gcd p m n : (p %| gcdz m n)%Z = (p %| m)%Z && (p %| n)%Z.\nProof. exact: dvdn_gcd. Qed.",
    "Lemma gcdzAC : right_commutative gcdz.\nProof. by move=> m n p; rewrite /gcdz gcdnAC. Qed.",
    "Lemma gcdzA : associative gcdz.\nProof. by move=> m n p; rewrite /gcdz gcdnA. Qed.",
    "Lemma gcdzCA : left_commutative gcdz.\nProof. by move=> m n p; rewrite /gcdz gcdnCA. Qed.",
    "Lemma gcdzACA : interchange gcdz gcdz.\nProof. by move=> m n p q; rewrite /gcdz gcdnACA. Qed.",
    "Lemma mulz_gcdr m n p : `|m|%:Z * gcdz n p = gcdz (m * n) (m * p).\nProof. by rewrite -PoszM muln_gcdr -!abszM. Qed.",
    "Lemma mulz_gcdl m n p : gcdz m n * `|p|%:Z = gcdz (m * p) (n * p).\nProof. by rewrite -PoszM muln_gcdl -!abszM. Qed.",
    "Lemma mulz_divCA_gcd n m : n * (m %/ gcdz n m)%Z  = m * (n %/ gcdz n m)%Z.\nProof. by rewrite mulz_divCA ?dvdz_gcdl ?dvdz_gcdr. Qed.",
    "Lemma dvdz_lcmr m n : (n %| lcmz m n)%Z.\nProof. exact: dvdn_lcmr. Qed.",
    "Lemma dvdz_lcml m n : (m %| lcmz m n)%Z.\nProof. exact: dvdn_lcml. Qed.",
    "Lemma dvdz_lcm d1 d2 m : ((lcmn d1 d2 %| m) = (d1 %| m) && (d2 %| m))%Z.\nProof. exact: dvdn_lcm. Qed.",
    "Lemma lcmzC : commutative lcmz.\nProof. by move=> m n; rewrite /lcmz lcmnC. Qed.",
    "Lemma lcm0z : left_zero 0 lcmz.\nProof. by move=> x; rewrite /lcmz absz0 lcm0n. Qed.",
    "Lemma lcmz0 : right_zero 0 lcmz.\nProof. by move=> x; rewrite /lcmz absz0 lcmn0. Qed.",
    "Lemma lcmz_ge0 m n : 0 <= lcmz m n.\nProof. by []. Qed.",
    "Lemma lcmz_neq0 m n : (lcmz m n != 0) = (m != 0) && (n != 0).\nProof.\nhave [->|m_neq0] := eqVneq m 0; first by rewrite lcm0z.\nhave [->|n_neq0] := eqVneq n 0; first by rewrite lcmz0.\nby rewrite gt_eqF// [0 < _]lcmn_gt0 !absz_gt0 m_neq0 n_neq0.\nQed.",
    "Lemma coprimezE m n : coprimez m n = coprime `|m| `|n|. Proof. by []. Qed.",
    "Lemma coprimez_sym : symmetric coprimez.\nProof. by move=> m n; apply: coprime_sym. Qed.",
    "Lemma coprimeNz m n : coprimez (- m) n = coprimez m n.\nProof. by rewrite coprimezE abszN. Qed.",
    "Lemma coprimezN m n : coprimez m (- n) = coprimez m n.\nProof. by rewrite coprimezE abszN. Qed.",
    "Lemma egcdzP m n : egcdz_spec m n (egcdz m n).\nProof.\nrewrite /egcdz; have [-> | m_nz] := eqVneq.\n  by split; [rewrite -abszEsign gcd0z | rewrite coprimezE absz_sign].\nhave m_gt0 : (`|m| > 0)%N by rewrite absz_gt0.\ncase: egcdnP (coprime_egcdn `|n| m_gt0) => //= u v Duv _ co_uv; split.\n  rewrite !mulNr -!mulrA mulrCA -abszEsg mulrCA -abszEsign.\n  by rewrite -!PoszM Duv addnC PoszD addrK.\nby rewrite coprimezE abszM absz_sg m_nz mul1n mulNr abszN abszMsign.\nQed.",
    "Lemma Bezoutz m n : {u : int & {v : int | u * m + v * n = gcdz m n}}.\nProof. by exists (egcdz m n).1, (egcdz m n).2; case: egcdzP. Qed.",
    "Lemma coprimezP m n :\n  reflect (exists uv, uv.1 * m + uv.2 * n = 1) (coprimez m n).\nProof.\napply: (iffP eqP) => [<-| [[u v] /= Duv]].\n  by exists (egcdz m n); case: egcdzP.\ncongr _%:Z; apply: gcdn_def; rewrite ?dvd1n // => d dv_d_n dv_d_m.\nby rewrite -(dvdzE d 1) -Duv [m]intEsg [n]intEsg rpredD ?dvdz_mull.\nQed.",
    "Lemma Gauss_dvdz m n p :\n  coprimez m n -> (m * n %| p)%Z = (m %| p)%Z && (n %| p)%Z.\nProof. by move/Gauss_dvd <-; rewrite -abszM. Qed.",
    "Lemma Gauss_dvdzr m n p : coprimez m n -> (m %| n * p)%Z = (m %| p)%Z.\nProof. by rewrite dvdzE abszM => /Gauss_dvdr->. Qed.",
    "Lemma Gauss_dvdzl m n p : coprimez m p -> (m %| n * p)%Z = (m %| n)%Z.\nProof. by rewrite mulrC; apply: Gauss_dvdzr. Qed.",
    "Lemma Gauss_gcdzr p m n : coprimez p m -> gcdz p (m * n) = gcdz p n.\nProof. by rewrite /gcdz abszM => /Gauss_gcdr->. Qed.",
    "Lemma Gauss_gcdzl p m n : coprimez p n -> gcdz p (m * n) = gcdz p m.\nProof. by move=> co_pn; rewrite mulrC Gauss_gcdzr. Qed.",
    "Lemma coprimezMr p m n : coprimez p (m * n) = coprimez p m && coprimez p n.\nProof. by rewrite -coprimeMr -abszM. Qed.",
    "Lemma coprimezMl p m n : coprimez (m * n) p = coprimez m p && coprimez n p.\nProof. by rewrite -coprimeMl -abszM. Qed.",
    "Lemma coprimez_pexpl k m n : (0 < k)%N -> coprimez (m ^+ k) n = coprimez m n.\nProof. by rewrite /coprimez /gcdz abszX; apply: coprime_pexpl. Qed.",
    "Lemma coprimez_pexpr k m n : (0 < k)%N -> coprimez m (n ^+ k) = coprimez m n.\nProof. by move=> k_gt0; rewrite !(coprimez_sym m) coprimez_pexpl. Qed.",
    "Lemma coprimezXl k m n : coprimez m n -> coprimez (m ^+ k) n.\nProof. by rewrite /coprimez /gcdz abszX; apply: coprimeXl. Qed.",
    "Lemma coprimezXr k m n : coprimez m n -> coprimez m (n ^+ k).\nProof. by rewrite !(coprimez_sym m); apply: coprimezXl. Qed.",
    "Lemma coprimez_dvdl m n p : (m %| n)%N -> coprimez n p -> coprimez m p.\nProof. exact: coprime_dvdl. Qed.",
    "Lemma coprimez_dvdr m n p : (m %| n)%N -> coprimez p n -> coprimez p m.\nProof. exact: coprime_dvdr. Qed.",
    "Lemma dvdz_pexp2r m n k : (k > 0)%N -> (m ^+ k %| n ^+ k)%Z = (m %| n)%Z.\nProof. by rewrite dvdzE !abszX; apply: dvdn_pexp2r. Qed.",
    "Lemma zchinese_remainder x y :\n  (x == y %[mod m1 * m2])%Z = (x == y %[mod m1])%Z && (x == y %[mod m2])%Z.\nProof. by rewrite !eqz_mod_dvd Gauss_dvdz. Qed.",
    "Lemma zchinese_modl r1 r2 : (zchinese r1 r2 = r1 %[mod m1])%Z.\nProof.\nrewrite /zchinese; have [u v /= Duv _] := egcdzP m1 m2.\nrewrite -{2}[r1]mulr1 -((gcdz _ _ =P 1) co_m12) -Duv.\nby rewrite mulrDr mulrAC addrC (mulrAC r2) !mulrA !modzMDl.\nQed.",
    "Lemma zchinese_modr r1 r2 : (zchinese r1 r2 = r2 %[mod m2])%Z.\nProof.\nrewrite /zchinese; have [u v /= Duv _] := egcdzP m1 m2.\nrewrite -{2}[r2]mulr1 -((gcdz _ _ =P 1) co_m12) -Duv.\nby rewrite mulrAC modzMDl mulrAC addrC mulrDr !mulrA modzMDl.\nQed.",
    "Lemma zchinese_mod x : (x = zchinese (x %% m1)%Z (x %% m2)%Z %[mod m1 * m2])%Z.\nProof.\napply/eqP; rewrite zchinese_remainder //.\nby rewrite zchinese_modl zchinese_modr !modz_mod !eqxx.\nQed.",
    "Lemma sgz_contents p : sgz (zcontents p) = sgz (lead_coef p).\nProof.\nrewrite /zcontents mulrC sgzM sgz_id; set d := _%:Z.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite lead_coef0 mulr0.\nrewrite gtr0_sgz ?mul1r // ltz_nat polySpred ?big_ord_recr //= -lead_coefE.\nby rewrite gcdn_gt0 orbC absz_gt0 lead_coef_eq0 nz_p.\nQed.",
    "Lemma zcontents_eq0 p : (zcontents p == 0) = (p == 0).\nProof. by rewrite -sgz_eq0 sgz_contents sgz_eq0 lead_coef_eq0. Qed.",
    "Lemma zcontents0 : zcontents 0 = 0.\nProof. by apply/eqP; rewrite zcontents_eq0. Qed.",
    "Lemma zcontentsZ a p : zcontents (a *: p) = a * zcontents p.\nProof.\nhave [-> | nz_a] := eqVneq a 0; first by rewrite scale0r mul0r zcontents0.\nrewrite {2}[a]intEsg mulrCA -mulrA -PoszM big_distrr /= mulrCA mulrA -sgzM.\nrewrite -lead_coefZ; congr (_ * _%:Z); rewrite size_scale //.\nby apply: eq_bigr => i _; rewrite coefZ abszM.\nQed.",
    "Lemma zcontents_monic p : p \\is monic -> zcontents p = 1.\nProof.\nmove=> mon_p; rewrite /zcontents polySpred ?monic_neq0 //.\nby rewrite big_ord_recr /= -lead_coefE (monicP mon_p) gcdn1.\nQed.",
    "Lemma dvdz_contents a p : (a %| zcontents p)%Z = (p \\is a polyOver (dvdz a)).\nProof.\nrewrite dvdzE abszM absz_sg lead_coef_eq0.\nhave [-> | nz_p] := eqVneq; first by rewrite mul0n dvdn0 rpred0.\nrewrite mul1n; apply/dvdn_biggcdP/(all_nthP 0)=> a_dv_p i ltip /=.\n  exact: (a_dv_p (Ordinal ltip)).\nexact: a_dv_p.\nQed.",
    "Lemma map_poly_divzK {a} p :\n  p \\is a polyOver (dvdz a) -> a *: map_poly (divz^~ a) p = p.\nProof.\nmove/polyOverP=> a_dv_p; apply/polyP=> i.\nby rewrite coefZ coef_map_id0 ?div0z // mulrC divzK.\nQed.",
    "Lemma polyOver_dvdzP a p :\n  reflect (exists q, p = a *: q) (p \\is a polyOver (dvdz a)).\nProof.\napply: (iffP idP) => [/map_poly_divzK | [q ->]].\n  by exists (map_poly (divz^~ a) p).\nby apply/polyOverP=> i; rewrite coefZ dvdz_mulr.\nQed.",
    "Lemma zpolyEprim p : p = zcontents p *: zprimitive p.\nProof. by rewrite map_poly_divzK // -dvdz_contents. Qed.",
    "Lemma zprimitive0 : zprimitive 0 = 0.\nProof.\nby apply/polyP=> i; rewrite coef0 coef_map_id0 ?div0z // zcontents0 divz0.\nQed.",
    "Lemma zprimitive_eq0 p : (zprimitive p == 0) = (p == 0).\nProof.\napply/idP/idP=> /eqP p0; first by rewrite [p]zpolyEprim p0 scaler0.\nby rewrite p0 zprimitive0.\nQed.",
    "Lemma size_zprimitive p : size (zprimitive p) = size p.\nProof.\nhave [-> | ] := eqVneq p 0; first by rewrite zprimitive0.\nby rewrite {1 3}[p]zpolyEprim scale_poly_eq0 => /norP[/size_scale-> _].\nQed.",
    "Lemma sgz_lead_primitive p : sgz (lead_coef (zprimitive p)) = (p != 0).\nProof.\nhave [-> | nz_p] := eqVneq; first by rewrite zprimitive0 lead_coef0.\napply: (@mulfI _ (sgz (zcontents p))); first by rewrite sgz_eq0 zcontents_eq0.\nby rewrite -sgzM mulr1 -lead_coefZ -zpolyEprim sgz_contents.\nQed.",
    "Lemma zcontents_primitive p : zcontents (zprimitive p) = (p != 0).\nProof.\nhave [-> | nz_p] := eqVneq; first by rewrite zprimitive0 zcontents0.\napply: (@mulfI _ (zcontents p)); first by rewrite zcontents_eq0.\nby rewrite mulr1 -zcontentsZ -zpolyEprim.\nQed.",
    "Lemma zprimitive_id p : zprimitive (zprimitive p) = zprimitive p.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite !zprimitive0.\nby rewrite {2}[zprimitive p]zpolyEprim zcontents_primitive nz_p scale1r.\nQed.",
    "Lemma zprimitive_monic p : p \\in monic -> zprimitive p = p.\nProof. by move=> mon_p; rewrite {2}[p]zpolyEprim zcontents_monic ?scale1r. Qed.",
    "Lemma zprimitiveZ a p : a != 0 -> zprimitive (a *: p) = zprimitive p.\nProof.\nhave [-> | nz_p nz_a] := eqVneq p 0; first by rewrite scaler0.\napply: (@mulfI _ (a * zcontents p)%:P).\n  by rewrite polyC_eq0 mulf_neq0 ?zcontents_eq0.\nby rewrite -{1}zcontentsZ !mul_polyC -zpolyEprim -scalerA -zpolyEprim.\nQed.",
    "Lemma zprimitive_min p a q :\n    p != 0 -> p = a *: q ->\n  {b | sgz b = sgz (lead_coef q) & q = b *: zprimitive p}.\nProof.\nmove=> nz_p Dp; have /dvdzP/sig_eqW[b Db]: (a %| zcontents p)%Z.\n  by rewrite dvdz_contents; apply/polyOver_dvdzP; exists q.\nsuffices ->: q = b *: zprimitive p.\n  by rewrite lead_coefZ sgzM sgz_lead_primitive nz_p mulr1; exists b.\napply: (@mulfI _ a%:P).\n  by apply: contraNneq nz_p; rewrite Dp -mul_polyC => ->; rewrite mul0r.\nby rewrite !mul_polyC -Dp scalerA mulrC -Db -zpolyEprim.\nQed.",
    "Lemma zprimitive_irr p a q :\n  p != 0 -> zprimitive p = a *: q -> a = sgz (lead_coef q).\nProof.\nmove=> nz_p Dp; have: p = (a * zcontents p) *: q.\n  by rewrite mulrC -scalerA -Dp -zpolyEprim.\ncase/zprimitive_min=> // b <- /eqP.\nrewrite Dp -{1}[q]scale1r scalerA -subr_eq0 -scalerBl scale_poly_eq0 subr_eq0.\nhave{Dp} /negPf->: q != 0.\n  by apply: contraNneq nz_p; rewrite -zprimitive_eq0 Dp => ->; rewrite scaler0.\nby case: b a => [[|[|b]] | [|b]] [[|[|a]] | [|a]] //; rewrite mulr0.\nQed.",
    "Lemma zcontentsM p q : zcontents (p * q) = zcontents p * zcontents q.\nProof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite !(mul0r, zcontents0).\nhave [-> | nz_q] := eqVneq q 0; first by rewrite !(mulr0, zcontents0).\nrewrite -[zcontents q]mulr1 {1}[p]zpolyEprim {1}[q]zpolyEprim.\nrewrite -scalerAl -scalerAr !zcontentsZ; congr (_ * (_ * _)).\nrewrite [zcontents _]intEsg sgz_contents lead_coefM sgzM !sgz_lead_primitive.\napply/eqP; rewrite nz_p nz_q !mul1r [_ == _]eqn_leq absz_gt0 zcontents_eq0.\nrewrite mulf_neq0 ?zprimitive_eq0 // andbT leqNgt.\napply/negP=> /pdivP[r r_pr r_dv_d]; pose to_r : int -> 'F_r := intr.\nhave nz_prim_r q1: q1 != 0 -> map_poly to_r (zprimitive q1) != 0.\n  move=> nz_q1; apply: contraTneq (prime_gt1 r_pr) => r_dv_q1.\n  rewrite -leqNgt dvdn_leq // -(dvdzE r true) -nz_q1 -zcontents_primitive.\n  rewrite dvdz_contents; apply/polyOverP=> i /=; rewrite dvdzE /=.\n  have /polyP/(_ i)/eqP := r_dv_q1; rewrite coef_map coef0 /=.\n  rewrite {1}[_`_i]intEsign rmorphM /= rmorph_sign /= mulf_eq0 signr_eq0 /=.\n  by rewrite -val_eqE /= val_Fp_nat.\nsuffices{nz_prim_r} /idPn[]: map_poly to_r (zprimitive p * zprimitive q) == 0.\n  by rewrite rmorphM mulf_neq0 ?nz_prim_r.\nrewrite [_ * _]zpolyEprim [zcontents _]intEsign mulrC -scalerA map_polyZ /=.\nby rewrite scale_poly_eq0 -val_eqE /= val_Fp_nat ?(eqnP r_dv_d).\nQed.",
    "Lemma zprimitiveM p q : zprimitive (p * q) = zprimitive p * zprimitive q.\nProof.\nhave [pq_0|] := eqVneq (p * q) 0.\n  rewrite pq_0; move/eqP: pq_0; rewrite mulf_eq0.\n  by case/pred2P=> ->; rewrite !zprimitive0 (mul0r, mulr0).\nrewrite -zcontents_eq0 -polyC_eq0 => /mulfI; apply; rewrite !mul_polyC.\nby rewrite -zpolyEprim zcontentsM -scalerA scalerAr scalerAl -!zpolyEprim.\nQed.",
    "Lemma dvdpP_int p q : p %| q -> {r | q = zprimitive p * r}.\nProof.\ncase/Pdiv.Idomain.dvdpP/sig2_eqW=> [[c r] /= nz_c Dpr].\nexists (zcontents q *: zprimitive r); rewrite -scalerAr.\nby rewrite -zprimitiveM mulrC -Dpr zprimitiveZ // -zpolyEprim.\nQed.",
    "Lemma int_Smith_normal_form m n (M : 'M[int]_(m, n)) :\n  {L : 'M[int]_m & L \\in unitmx &\n  {R : 'M[int]_n & R \\in unitmx &\n  {d : seq int | sorted dvdz d &\n   M = L *m (\\matrix_(i, j) (d`_i *+ (i == j :> nat))) *m R}}}.\nProof.\nmove: {2}_.+1 (ltnSn (m + n)) => mn.\nelim: mn => // mn IHmn in m n M *; rewrite ltnS => le_mn.\nhave [[i j] nzMij | no_ij] := pickP (fun k => M k.1 k.2 != 0); last first.\n  do 2![exists 1%:M; first exact: unitmx1]; exists nil => //=.\n  apply/matrixP=> i j; apply/eqP; rewrite mulmx1 mul1mx mxE nth_nil mul0rn.\n  exact: negbFE (no_ij (i, j)).\ndo [case: m i => [[]//|m] i; case: n j => [[]//|n] j /=] in M nzMij le_mn *.\nwlog Dj: j M nzMij / j = 0; last rewrite {j}Dj in nzMij.\n  case/(_ 0 (xcol j 0 M)); rewrite ?mxE ?tpermR // => L uL [R uR [d dvD dM]].\n  exists L => //; exists (xcol j 0 R); last exists d => //=.\n     by rewrite xcolE unitmx_mul uR unitmx_perm.\n  by rewrite xcolE !mulmxA -dM xcolE -mulmxA -perm_mxM tperm2 perm_mx1 mulmx1.\nmove Da: (M i 0) nzMij => a nz_a.\nhave [A leA] := ubnP `|a|; elim: A => // A IHa in a leA m n M i Da nz_a le_mn *.\nwlog [j a'Mij]: m n M i Da le_mn / {j | ~~ (a %| M i j)%Z}; last first.\n  have nz_j: j != 0 by apply: contraNneq a'Mij => ->; rewrite Da.\n  case: n => [[[]//]|n] in j le_mn nz_j M a'Mij Da *.\n  wlog{nz_j} Dj: j M a'Mij Da / j = 1; last rewrite {j}Dj in a'Mij.\n    case/(_ 1 (xcol j 1 M)); rewrite ?mxE ?tpermR ?tpermD //.\n    move=> L uL [R uR [d dvD dM]]; exists L => //.\n    exists (xcol j 1 R); first by rewrite xcolE unitmx_mul uR unitmx_perm.\n    exists d; rewrite //= xcolE !mulmxA -dM xcolE -mulmxA -perm_mxM tperm2.\n    by rewrite perm_mx1 mulmx1.\n  have [u [v]] := Bezoutz a (M i 1); set b := gcdz _ _ => Db.\n  have{leA} ltA: (`|b| < A)%N.\n    rewrite -ltnS (leq_trans _ leA) // ltnS ltn_neqAle andbC.\n    rewrite dvdn_leq ?absz_gt0 ? dvdn_gcdl //=.\n    by rewrite (contraNneq _ a'Mij) ?dvdzE // => <-; apply: dvdn_gcdr.\n  pose t2 := [fun j : 'I_2 => [tuple _; _]`_j : int]; pose a1 := M i 1.\n  pose Uul := \\matrix_(k, j) t2 (t2 u (- (a1 %/ b)%Z) j) (t2 v (a %/ b)%Z j) k.\n  pose U : 'M_(2 + n) := block_mx Uul 0 0 1%:M; pose M1 := M *m U.\n  have{nz_a} nz_b: b != 0 by rewrite gcdz_eq0 (negPf nz_a).\n  have uU: U \\in unitmx.\n    rewrite unitmxE det_ublock det1 (expand_det_col _ 0) big_ord_recl big_ord1.\n    do 2!rewrite /cofactor [row' _ _]mx11_scalar !mxE det_scalar1 /=.\n    rewrite mulr1 mul1r mulN1r opprK -[_ + _](mulzK _ nz_b) mulrDl.\n    by rewrite -!mulrA !divzK ?dvdz_gcdl ?dvdz_gcdr // Db divzz nz_b unitr1.\n  have{} Db: M1 i 0 = b.\n    rewrite /M1 -(lshift0 n 1) [U]block_mxEh mul_mx_row row_mxEl.\n    rewrite -[M](@hsubmxK _ _ 2) (@mul_row_col _ _ 2) mulmx0 addr0 !mxE /=.\n    rewrite big_ord_recl big_ord1 !mxE /= [lshift _ _]((_ =P 0) _) // Da.\n    by rewrite [lshift _ _]((_ =P 1) _) // mulrC -(mulrC v).\n  have [L uL [R uR [d dvD dM1]]] := IHa b ltA _ _ M1 i Db nz_b le_mn.\n  exists L => //; exists (R *m invmx U); last exists d => //.\n    by rewrite unitmx_mul uR unitmx_inv.\n  by rewrite mulmxA -dM1 mulmxK.\nmove=> {A leA}IHa; wlog Di: i M Da / i = 0; last rewrite {i}Di in Da.\n  case/(_ 0 (xrow i 0 M)); rewrite ?mxE ?tpermR // => L uL [R uR [d dvD dM]].\n  exists (xrow i 0 L); first by rewrite xrowE unitmx_mul unitmx_perm.\n  exists R => //; exists d; rewrite //= xrowE -!mulmxA (mulmxA L) -dM xrowE.\n  by rewrite mulmxA -perm_mxM tperm2 perm_mx1 mul1mx.\nwithout loss /forallP a_dvM0: / [forall j, a %| M 0%R j]%Z.\n  case: (altP forallP) => [_ IH|/forallPn/sigW/IHa IH _]; exact: IH.\nwithout loss{Da a_dvM0} Da: M / forall j, M 0 j = a.\n  pose Uur := col' 0 (\\row_j (1 - (M 0%R j %/ a)%Z)).\n  pose U : 'M_(1 + n) := block_mx 1 Uur 0 1%:M; pose M1 := M *m U.\n  have uU: U \\in unitmx by rewrite unitmxE det_ublock !det1 mulr1.\n  case/(_ (M *m U)) => [j | L uL [R uR [d dvD dM]]].\n    rewrite -(lshift0 m 0) -[M](@submxK _ 1 _ 1) (@mulmx_block _ 1 m 1).\n    rewrite (@col_mxEu _ 1) !mulmx1 mulmx0 addr0 [ulsubmx _]mx11_scalar.\n    rewrite mul_scalar_mx !mxE !lshift0 Da.\n    case: splitP => [j0 _ | j1 Dj]; rewrite ?ord1 !mxE // lshift0 rshift1.\n    by rewrite mulrBr mulr1 mulrC divzK ?subrK.\n  exists L => //; exists (R * U^-1); first by rewrite unitmx_mul uR unitmx_inv.\n  by exists d; rewrite //= mulmxA -dM mulmxK.\nwithout loss{IHa} /forallP/(_ (_, _))/= a_dvM: / [forall k, a %| M k.1 k.2]%Z.\n  case: (altP forallP) => [_|/forallPn/sigW [[i j] /= a'Mij] _]; first exact.\n  have [|||L uL [R uR [d dvD dM]]] := IHa _ _ M^T j; rewrite ?mxE 1?addnC //.\n    by exists i; rewrite mxE.\n  exists R^T; last exists L^T; rewrite ?unitmx_tr //; exists d => //.\n  rewrite -[M]trmxK dM !trmx_mul mulmxA; congr (_ *m _ *m _).\n  by apply/matrixP=> i1 j1 /[!mxE]; case: eqVneq => // ->.\nwithout loss{nz_a a_dvM} a1: M a Da / a = 1.\n  pose M1 := map_mx (divz^~ a) M; case/(_ M1 1)=> // [k|L uL [R uR [d dvD dM]]].\n    by rewrite !mxE Da divzz nz_a.\n  exists L => //; exists R => //; exists [seq a * x | x <- d].\n    case: d dvD {dM} => //= x d; elim: d x => //= y d IHd x /andP[dv_xy /IHd].\n    by rewrite [dvdz _ _]dvdz_mul2l ?[_ \\in _]dv_xy.\n  have ->: M = a *: M1 by apply/matrixP=> i j; rewrite !mxE mulrC divzK ?a_dvM.\n  rewrite dM scalemxAl scalemxAr; congr (_ *m _ *m _).\n  apply/matrixP=> i j; rewrite !mxE mulrnAr; congr (_ *+ _).\n  have [lt_i_d | le_d_i] := ltnP i (size d); first by rewrite (nth_map 0).\n  by rewrite !nth_default ?size_map ?mulr0.\nrewrite {a}a1 -[m.+1]/(1 + m)%N -[n.+1]/(1 + n)%N in M Da *.\npose Mu := ursubmx M; pose Ml := dlsubmx M.\nhave{} Da: ulsubmx M = 1 by rewrite [_ M]mx11_scalar !mxE !lshift0 Da.\npose M1 := - (Ml *m Mu) + drsubmx M.\nhave [|L uL [R uR [d dvD dM1]]] := IHmn m n M1; first by rewrite -addnS ltnW.\nexists (block_mx 1 0 Ml L).\n  by rewrite unitmxE det_lblock det_scalar1 mul1r.\nexists (block_mx 1 Mu 0 R).\n  by rewrite unitmxE det_ublock det_scalar1 mul1r.\nexists (1 :: d); set D1 := \\matrix_(i, j) _ in dM1.\n  by rewrite /= path_min_sorted //; apply/allP => g _; apply: dvd1n.\nrewrite [D in _ *m D *m _](_ : _ = block_mx 1 0 0 D1); last first.\n  by apply/matrixP=> i j; do 3?[rewrite ?mxE ?ord1 //=; case: splitP => ? ->].\nrewrite !mulmx_block !(mul0mx, mulmx0, addr0) !mulmx1 add0r mul1mx -Da -dM1.\nby rewrite addNKr submxK.\nQed.",
    "Lemma eigenvalue_closed {C : numClosedFieldType} n (A : 'M[C]_n) : (n > 0)%N ->\n  exists a, eigenvalue A a.\nProof.\nmove=> n_gt0; have /closed_rootP [a rAa] : size (char_poly A) != 1%N.\n  by rewrite size_char_poly; case: (n) n_gt0.\nby exists a; rewrite eigenvalue_root_char.\nQed.",
    "Lemma common_eigenvector {C : numClosedFieldType} n (As : seq 'M[C]_n) :\n  (n > 0)%N -> {in As &, forall A B, comm_mx A B} ->\n  exists2 v : 'rV_n, v != 0 & all (fun A => stablemx v A) As.\nProof.\nmove=> n_gt0 /all_comm_mxP; have [k sAsk] := ubnP (size As).\nelim: k n n_gt0 As sAsk => [//|k IHk]  n n_gt0 [|A As].\n  exists (const_mx 1) => //; apply/negP => /eqP/rowP/(_ (Ordinal n_gt0)).\n  by rewrite !mxE => /eqP; rewrite oner_eq0.\nrewrite ltnS all_comm_mx_cons => sAsk /andP[].\nmove=> /allP/(_ _ _)/eqP/= A_comm /all_comm_mxP As_comm.\nhave [a a_eigen] := eigenvalue_closed A n_gt0.\nhave [] := IHk _ _ [seq restrictmx (eigenspace A a) B | B <- As].\n- by rewrite lt0n mxrank_eq0.\n- by rewrite size_map.\n- apply/all_comm_mxP; move=> _ _ /= /mapP /= [B B_in ->] /mapP /= [B' B'_in ->].\n  rewrite -?conjmxM ?inE ?stablemx_row_base ?comm_mx_stable_eigenspace//;\n  by [rewrite As_comm | apply: As_comm | apply: A_comm].\nmove=> v vN0 /allP /= vP; exists (v *m (row_base (eigenspace A a))).\n  by rewrite mulmx_free_eq0 ?row_base_free.\napply/andP; split.\n  by apply/eigenvectorP; exists a; rewrite mulmx_sub // eq_row_base.\napply/allP => B B_in; rewrite -stablemx_restrict ?vP //.\n  by apply/mapP; exists B.\nby rewrite comm_mx_stable_eigenspace //; exact: A_comm.\nQed.",
    "Lemma common_eigenvector2 {C : numClosedFieldType}n  (A B : 'M[C]_n) :\n  (n > 0)%N -> A *m B = B *m A ->\n  exists2 v : 'rV_n, v != 0 & (stablemx v A) && (stablemx v B).\nProof.\nmove=> n_gt0 AB_comm; have [] := @common_eigenvector _ _ [:: A; B] n_gt0.\n  by move=> A' B'; rewrite !inE => /orP [] /eqP-> /orP [] /eqP->.\nby move=> v v_neq0 /allP vP; exists v; rewrite ?vP ?(mem_head, in_cons, orbT).\nQed.",
    "Lemma trmxCK {C : numClosedFieldType} m n (A : 'M[C]_(m, n)) : A ^t* ^t* = A.\nProof. by apply/matrixP=> i j; rewrite !mxE conjCK. Qed.",
    "Lemma realmxC A : A \\is a realmx -> A ^ conjC = A.\nProof.\nby move=> ?; apply/matrixP => x y; rewrite mxE; exact/CrealP/mxOverP.\nQed.",
    "Lemma realmxD A B : A \\is a realmx -> B \\is a realmx -> A + B \\is a realmx.\nProof.\nrewrite !qualifE/= => /'forall_forallP realA /'forall_forallP realB.\nby apply/'forall_forallP => i j; rewrite mxE realD.\nQed.",
    "Lemma Remx_rect : {in realmx &, forall A B, (A + 'i *: B) ^ (@Re _) = A}.\nProof.\nmove=> A B Areal Breal; apply/matrixP=> i j; rewrite !mxE.\nby rewrite Re_rect // (mxOverP _ _).\nQed.",
    "Lemma Immx_rect : {in realmx &, forall A B, (A + 'i *: B) ^ (@Im _) = B}.\nProof.\nmove=> /= A B Areal Breal; apply/matrixP=> i j; rewrite !mxE.\nby rewrite Im_rect // (mxOverP _ _).\nQed.",
    "Lemma eqmx_ReiIm A B A' B' :\n  A \\is a realmx -> B \\is a realmx -> A' \\is a realmx -> B' \\is a realmx ->\n  (A + 'i *: B) = (A' + 'i *: B') -> (A, B) = (A', B').\nProof.\nmove=> ARe BRe A'Im B'Im eqAB.\nhave /(congr1 (fun A => A ^ (@Im _))) := eqAB.\nhave /(congr1 (fun A => A ^ (@Re _))) := eqAB.\nby rewrite !Remx_rect// !Immx_rect// => -> ->.\nQed.",
    "Lemma realsym_hermsym {C : numClosedFieldType} {n} (A : 'M[C]_n) :\n  A \\is symmetricmx -> A \\is a realmx -> A \\is hermsymmx.\nProof.\nmove=> Asym Areal; apply/is_hermitianmxP.\nby rewrite (trmx_hermitian (HermitianMx Asym))/= !scale1r ?realmxC ?map_mx_id.\nQed.",
    "Lemma real_similar {C : numClosedFieldType} {n} (A B : 'M[C]_n) :\n  similar_in unitmx A B ->\n  A \\is a realmx -> B \\is a realmx -> similar_in [predI realmx & unitmx] A B.\nProof.\ncase=> [P /=]; pose Pr := P ^ (@Re _); pose Pi := P ^ (@Im _).\nhave Pr_real : Pr \\is a realmx by apply/mxOverP=> i j; rewrite !mxE Creal_Re.\nhave Pi_real : Pi \\is a realmx by apply/mxOverP=> i j; rewrite !mxE Creal_Im.\npose Q x := P ^ (@Re _) + x *: P ^ (@Im _).\nhave -> : P = Q 'i by apply/matrixP=> i j; rewrite !mxE -Crect.\nmove=> Qi_unit eq_AP_PB Areal Breal.\npose p := \\det (Pr ^ polyC + 'X *: Pi ^ polyC).\nhave horner_evaliC x : horner_eval (x : C) \\o polyC =1 id := fun=> hornerC _ _.\nhave Qunit x : Q x \\in unitmx = (p.[x] != 0).\n  rewrite /p -horner_evalE -det_map_mx map_mxD map_mxZ/= horner_evalE hornerX.\n  by rewrite -![(_ ^ polyC) ^ _]map_mx_comp !map_mx_id// unitmxE unitfE.\nhave p_neq0 : p != 0.\n  by move: Qi_unit; rewrite Qunit; apply: contra_neq => ->; rewrite hornerE.\nhave [a a_real rootNa] : exists2 a, a \\is Num.real &  ~~ root p a.\n  have rs_uniq : uniq [seq (i%:R : C) | i <- iota 0 (size p)].\n    by rewrite map_inj_uniq ?iota_uniq //; apply: mulrIn; rewrite oner_eq0.\n  have := contraNN (fun x => max_poly_roots p_neq0 x rs_uniq).\n  rewrite size_map size_iota ltnn => /(_ isT) /allPn[a a_in rootNpa].\n  by exists a => //; by move: a_in => /mapP [i _ ->]; rewrite realn.\nexists (Q a).\n  rewrite inE Qunit rootNa andbT.\n  rewrite /Q/=.\n  by rewrite realmxD// mxOverZ.\napply/similarP; rewrite ?Qunit//; move: eq_AP_PB => /(similarP Qi_unit).\nrewrite !mulmxDl !mulmxDr -!scalemxAr -!scalemxAl => /eqmx_ReiIm.\nby rewrite !mxOverM// => /(_ isT isT isT isT) [-> ->].\nQed.",
    "Lemma unitarymxP m n {M : 'M[C]_(m, n)} :\n  reflect (M *m M^t* = 1%:M) (M \\is unitarymx).\nProof. by apply: (iffP eqP). Qed.",
    "Lemma mulmxtVK m1 m2 n (A : 'M[C]_(m1, n)) (B : 'M[C]_(n, m2)) :\n  B \\is unitarymx -> A *m B *m B^t* = A.\nProof. by move=> B_unitary; rewrite -mulmxA (unitarymxP _) ?mulmx1. Qed.",
    "Lemma unitarymx_unit n (M : 'M[C]_n) : M \\is unitarymx -> M \\in unitmx.\nProof. by move=> /unitarymxP /mulmx1_unit []. Qed.",
    "Lemma invmx_unitary n (M : 'M[C]_n) : M \\is unitarymx -> invmx M = M^t*.\nProof.\nmove=> Munitary; apply: (@row_full_inj _ _ _ _ M).\n  by rewrite row_full_unit unitarymx_unit.\nby rewrite mulmxV ?unitarymx_unit ?(unitarymxP _).\nQed.",
    "Lemma mulmxKtV m1 m2 n (A : 'M[C]_(m1, n)) (B : 'M[C]_(m2, n)) :\n  B \\is unitarymx -> m2 = n -> A *m B^t* *m B = A.\nProof.\nmove=> B_unitary m2E; case: _ / (esym m2E) in B B_unitary *.\nby rewrite -invmx_unitary // mulmxKV //; exact: unitarymx_unit.\nQed.",
    "Lemma mxrank_unitary m n (M : 'M[C]_(m, n)) : M \\is unitarymx -> \\rank M = m.\nProof.\nrewrite qualifE => /eqP /(congr1 mxrank); rewrite mxrank1 => rkM.\napply/eqP; rewrite eqn_leq rank_leq_row /= -[X in (X <= _)%N]rkM.\nby rewrite mxrankM_maxl.\nQed.",
    "Lemma mul_unitarymx m n p (A : 'M[C]_(m, n)) (B : 'M[C]_(n, p)) :\n  A \\is unitarymx -> B \\is unitarymx -> A *m B \\is unitarymx.\nProof.\nmove=> Aunitary Bunitary; apply/unitarymxP; rewrite trmx_mul map_mxM.\nby rewrite mulmxA -[A *m _ *m _]mulmxA !(unitarymxP _, mulmx1).\nQed.",
    "Lemma pinvmx_unitary n (M : 'M[C]_n) : M \\is unitarymx -> pinvmx M = M^t*.\nProof. by move=> Munitary; rewrite pinvmxE ?unitarymx_unit// invmx_unitary. Qed.",
    "Lemma conjymx n (P M : 'M[C]_n) : P \\is unitarymx -> conjmx P M = P *m M *m P^t*.\nProof. by move=> Munitary; rewrite conjumx ?invmx_unitary ?unitarymx_unit. Qed.",
    "Lemma trmx_unitary n (M : 'M[C]_n) : (M ^T \\is unitarymx) = (M \\is unitarymx).\nProof.\napply/unitarymxP/unitarymxP; rewrite -?map_trmx -trmx_mul.\n  by rewrite -trmx1 => /trmx_inj /mulmx1C->; rewrite trmx1.\nby move=> /mulmx1C->; rewrite trmx1.\nQed.",
    "Lemma conjC_unitary m n (M : 'M[C]_(m, n)) :\n  (M ^ conjC \\is unitarymx) = (M \\is unitarymx).\nProof.\napply/unitarymxP/unitarymxP; rewrite -?map_mxM ?map_trmx; last first.\n  by move=> ->; rewrite map_mx1.\nby rewrite -[1%:M](map_mx1 conjC) => /map_mx_inj ->; rewrite map_mx1.\nQed.",
    "Lemma trmxC_unitary n (M : 'M[C]_n) : (M ^t* \\is unitarymx) = (M \\is unitarymx).\nProof. by rewrite conjC_unitary trmx_unitary. Qed.",
    "Lemma normalmxP {M : 'M[C]_n} :\n  reflect (M *m M ^t* = M ^t* *m M) (M \\is normalmx).\nProof. exact: eqP. Qed.",
    "Lemma hermitian_normalmx (A : 'M[C]_n) : A \\is hermsymmx -> A \\is normalmx.\nProof.\nmove=> Ahermi; apply/normalmxP.\nby rewrite (trmx_hermitian (HermitianMx Ahermi)) scale1r map_mxCK.\nQed.",
    "Lemma symmetric_normalmx (A : 'M[C]_n) : A \\is symmetricmx ->\n  A \\is a realmx -> A \\is normalmx.\nProof. by move=> Asym Areal; rewrite hermitian_normalmx// realsym_hermsym. Qed.",
    "Lemma dotmxE n (u v : 'rV[C]_n) : '[u, v] = ( u *m v ^t* ) 0 0.\nProof. by rewrite /dotmx /form_of_matrix mulmx1 /= trace_mx11. Qed.",
    "Lemma row_unitarymxP m n {M : 'M[C]_(m, n)} :\n  reflect (forall i j, '[row i M, row j M] = (i == j)%:R) (M \\is unitarymx).\nProof.\napply: (iffP eqP) => [Mo i j|Mo].\n  have /matrixP/(_ i j) := Mo; rewrite !mxE => <-.\n  by rewrite dotmxE !mxE; apply: eq_bigr => /= k _; rewrite !mxE.\napply/matrixP=> i j; rewrite !mxE; have := Mo i j; rewrite dotmxE !mxE => <-.\nby apply: eq_bigr => /= k _; rewrite !mxE.\nQed.",
    "Lemma orthomx1E m n p (A : 'M[C]_(m, n)) (B : 'M_(p, n)) :\n  (A '_|_ B)%MS = (A *m B^t* == 0).\nProof. by apply/sub_kermxP/eqP; rewrite !mul1mx. Qed.",
    "Lemma orthomx1P m n p {A : 'M[C]_(m, n)} {B : 'M_(p, n)} :\n  reflect (A *m B^t* = 0) (A '_|_ B).\nProof. by rewrite orthomx1E; exact/eqP. Qed.",
    "Lemma orthomx_disj n p q (A : 'M[C]_(p, n)) (B :'M_(q, n)) :\n  A '_|_ B -> (A :&: B = 0)%MS.\nProof.\nmove=> nAB; apply/eqP/rowV0Pn => [[v]]; rewrite sub_capmx => /andP [vA vB].\napply/negP; rewrite negbK.\nby rewrite -(dnorm_eq0 (@dotmx n)) -orthomxE (orthomxP _ _ _ nAB).\nQed.",
    "Lemma orthomx_ortho_disj n p (A : 'M[C]_(p, n)) : (A :&: A^! = 0)%MS.\nProof. exact/orthomx_disj/ortho_mx_ortho. Qed.",
    "Lemma rank_ortho p n (A : 'M[C]_(p, n)) : \\rank A^! = (n - \\rank A)%N.\nProof. by rewrite mxrank_ker mul1mx mxrank_map mxrank_tr. Qed.",
    "Lemma add_rank_ortho p n (A : 'M[C]_(p, n)) : (\\rank A + \\rank A^!)%N = n.\nProof. by rewrite rank_ortho subnKC ?rank_leq_col. Qed.",
    "Lemma addsmx_ortho p n (A : 'M[C]_(p, n)) : (A + A^! :=: 1%:M)%MS.\nProof.\napply/eqmxP/andP; rewrite submx1; split=> //.\nrewrite -mxrank_leqif_sup ?submx1 ?mxrank1 ?(mxdirectP _) /= ?add_rank_ortho //.\nby rewrite mxdirect_addsE /= ?mxdirectE ?orthomx_ortho_disj !eqxx.\nQed.",
    "Lemma ortho_id p n (A : 'M[C]_(p, n)) : (A^!^! :=: A)%MS.\nProof.\napply/eqmx_sym/eqmxP.\nby rewrite -mxrank_leqif_eq 1?orthomx_sym // !rank_ortho subKn // ?rank_leq_col.\nQed.",
    "Lemma submx_ortho p m n (U : 'M[C]_(p, n)) (V : 'M_(m, n)) :\n  (U^! <= V^!)%MS = (V <= U)%MS.\nProof. by rewrite orthomx_sym ortho_id. Qed.",
    "Lemma sub_adds_genmx_ortho (p m n : nat) (U : 'M[C]_(p, n))  (W : 'M_(m, n)) :\n  (W <= <<U>> + U^!)%MS.\nProof.\nby rewrite !(adds_eqmx (genmxE _) (eqmx_refl _)) addsmx_ortho submx1.\nQed.",
    "Lemma cap_genmx_ortho p n (U : 'M[C]_(p, n)) : (<<U>> :&: U^!)%MS = 0.\nProof.\napply/eqmx0P; rewrite !(cap_eqmx (genmxE _) (eqmx_refl _)).\nby rewrite orthomx_ortho_disj; exact/eqmx0P.\nQed.",
    "Lemma proj_ortho_sub p m n (U : 'M_(p, n)) (W : 'M_(m, n)) :\n  (W *m proj_ortho U <= U)%MS.\nProof. by rewrite (submx_trans (proj_mx_sub _ _ _)) // genmxE. Qed.",
    "Lemma proj_ortho_compl_sub p m n (U : 'M_(p, n)) (W : 'M_(m, n)) :\n  (W - W *m proj_ortho U <= U^!)%MS.\nProof. by rewrite proj_mx_compl_sub // addsmx_ortho submx1. Qed.",
    "Lemma proj_ortho_id p m n (U : 'M_(p, n)) (W : 'M_(m, n)) :\n  (W <= U)%MS -> W *m proj_ortho U = W.\nProof. by move=> WU; rewrite proj_mx_id ?genmxE. Qed.",
    "Lemma proj_ortho_0 p m n (U : 'M_(p, n)) (W : 'M_(m, n)) :\n  (W <= U^!)%MS -> W *m proj_ortho U = 0.\nProof. by move=> WUo; rewrite proj_mx_0. Qed.",
    "Lemma add_proj_ortho p m n (U : 'M_(p, n)) (W : 'M_(m, n)) :\n  W *m proj_ortho U + W *m proj_ortho U^!%MS = W.\nProof.\nrewrite -[W in LHS](@add_proj_mx _ _ _ <<U>>%MS U^!%MS W)//.\nrewrite !mulmxDl proj_ortho_id ?proj_ortho_sub //.\nrewrite proj_ortho_0 ?proj_mx_sub // addr0.\nrewrite proj_ortho_0 ?ortho_id ?proj_ortho_sub // add0r.\nby rewrite proj_ortho_id ?proj_mx_sub// add_proj_mx.\nQed.",
    "Lemma proj_ortho_proj m n (U : 'M_(m, n)) : let P := proj_ortho U in P *m P = P.\nProof. by rewrite /= proj_mx_proj. Qed.",
    "Lemma proj_orthoE p n (U : 'M_(p, n)) : (proj_ortho U :=: U)%MS.\nProof.\napply/eqmxP/andP; split; first by rewrite -proj_ortho_proj proj_ortho_sub.\nby rewrite -[X in (X <= _)%MS](proj_ortho_id (submx_refl U)) mulmx_sub.\nQed.",
    "Lemma orthomx_proj_mx_ortho p p' m m' n\n  (A : 'M_(p, n)) (A' : 'M_(p', n))\n  (W : 'M_(m, n)) (W' : 'M_(m', n)) :\n  A '_|_ A' -> W *m proj_ortho A '_|_ W' *m proj_ortho A'.\nProof.\nrewrite orthomx_sym => An.\nrewrite mulmx_sub // orthomx_sym (eqmx_ortho _ (proj_orthoE _)).\nby rewrite (submx_trans _ An) // proj_ortho_sub.\nQed.",
    "Lemma schmidt_subproof m n (A : 'M[C]_(m, n)) : (m <= n)%N ->\n  exists2 B : 'M_(m, n), B \\is unitarymx & [forall i : 'I_m,\n   (row i A <= (\\sum_(k < m | (k <= i)%N) <<row k B>>))%MS\n   && ('[row i A, row i B] >= 0) ].\nProof.\nelim: m A => [|m IHm].\n  exists (pid_mx n); first by rewrite qualifE !thinmx0.\n  by apply/forallP=> -[].\nrewrite -addn1 => A leq_Sm_n.\nhave lemSm : (m <= m + 1)%N by rewrite addn1.\nhave ltmSm : (m < m + 1)%N by rewrite addn1.\nhave lemn : (m <= n)%N by rewrite ltnW // -addn1.\nhave [B Bortho] := IHm (usubmx A) lemn.\nmove=> /forallP /= subAB.\nhave [v /and4P [vBn v_neq0 dAv_ge0 dAsub]] :\n  exists v, [&& B '_|_ v, v != 0, '[dsubmx A, v] >= 0 & (dsubmx A <= B + v)%MS].\n  have := add_proj_ortho B (dsubmx A).\n  set BoSn := (_ *m proj_ortho _^!%MS) => pBE.\n  have [BoSn_eq0|BoSn_neq0] := eqVneq BoSn 0.\n    rewrite BoSn_eq0 addr0 in pBE.\n    have /rowV0Pn [v vBn v_neq0] : B^!%MS != 0.\n      rewrite -mxrank_eq0 rank_ortho -lt0n subn_gt0.\n      by rewrite mxrank_unitary // -addn1.\n    rewrite orthomx_sym in vBn.\n    exists v; rewrite vBn v_neq0 -pBE.\n      rewrite ['[_, _]](hermmx_eq0P _ _) ?lexx //=.\n      rewrite (submx_trans (proj_ortho_sub _ _)) //.\n      by rewrite -{1}[B]addr0 addmx_sub_adds ?sub0mx.\n    by rewrite (submx_trans _ vBn) // proj_ortho_sub.\n  pose c := (sqrtC '[BoSn])^-1; have c_gt0 : c > 0.\n    by rewrite invr_gt0 sqrtC_gt0 lt_def ?dnorm_eq0 ?dnorm_ge0 BoSn_neq0.\n  exists BoSn; apply/and4P; split => //.\n  - by rewrite orthomx_sym ?proj_ortho_sub // /gtr_eqF.\n  - rewrite -pBE linearDl //.\n    rewrite [X in X + '[_]](hermmx_eq0P _ _) ?add0r ?dnorm_ge0 //.\n    by rewrite orthomx_proj_mx_ortho // orthomx_sym.\n  - by rewrite -pBE addmx_sub_adds // proj_ortho_sub.\nwlog nv_eq1 : v vBn v_neq0 dAv_ge0 dAsub / '[v] = 1.\n  pose c := (sqrtC '[v])^-1.\n  have c_gt0 : c > 0 by rewrite invr_gt0 sqrtC_gt0 ?dnorm_gt0.\n  have [c_ge0 c_eq0F] := (ltW c_gt0, gt_eqF c_gt0).\n  move=> /(_ (c *: v)); apply.\n  - by rewrite orthomxZ ?c_eq0F.\n  - by rewrite scaler_eq0 c_eq0F.\n  - by rewrite linearZr mulr_ge0 // conjC_ge0.\n  - by rewrite (submx_trans dAsub) // addsmxS // eqmx_scale // c_eq0F.\n  - rewrite dnormZ normfV ger0_norm ?sqrtC_ge0 ?dnorm_ge0 //.\n    by rewrite exprVn rootCK ?mulVf // dnorm_eq0.\nexists (col_mx B v).\n  apply/row_unitarymxP => i j.\n  case: (split_ordP i) (split_ordP j) => [] i' -> [] j' ->;\n    rewrite eq_shift ?(rowKu, rowKd, row_id, ord1) -?val_eqE /=\n            ?(row_unitarymxP _) //= ?addn0.\n    by rewrite ['[_, _]](hermmx_eq0P _ _)//= (submx_trans _ vBn)// row_sub.\n  rewrite ['[_, _]](hermmx_eq0P _ _)//= orthomx_sym (submx_trans _ vBn) //.\n  exact: row_sub.\napply/forallP => i; case: (split_ordP i) => j -> /=.\n  have /andP [sABj dot_gt0] := subAB j.\n  rewrite rowKu -row_usubmx (submx_trans sABj) //=.\n  rewrite (eq_rect _ (submx _) (submx_refl _)) //.\n  rewrite [in RHS](reindex (lshift 1)) /=.\n    by apply: eq_bigr=> k k_le; rewrite rowKu.\n  exists (fun k => insubd j k) => k; rewrite inE /= => le_kj;\n  by apply/val_inj; rewrite /= insubdK // -topredE /= (leq_ltn_trans le_kj).\nrewrite rowKd -row_dsubmx !row_id ord1 ?dAv_ge0 ?andbT {j} addn0.\nrewrite (bigD1 (rshift _ ord0)) /= ?addn0 ?rowKd ?row_id // addsmxC.\nrewrite (submx_trans dAsub) // addsmxS ?genmxE //.\napply/row_subP => j; apply/(sumsmx_sup (lshift _ j)) => //=.\n  by rewrite ltnW ?ltn_ord //= -val_eqE /= addn0 ltn_eqF.\nby rewrite rowKu genmxE.\nQed.",
    "Lemma schmidt_unitarymx m n (A : 'M[C]_(m, n)) : (m <= n)%N ->\n  schmidt A \\is unitarymx.\nProof. by rewrite /schmidt; case: eqP => // ?; case: sig2_eqW. Qed.",
    "Lemma row_schmidt_sub m n (A : 'M[C]_(m, n)) i :\n  (row i A <= (\\sum_(k < m | (k <= i)%N) <<row k (schmidt A)>>))%MS.\nProof.\nrewrite /schmidt; case: eqP => // ?.\n   by case: sig2_eqW => ? ? /= /forallP /(_ i) /andP[].\nby apply/(sumsmx_sup i) => //; rewrite genmxE.\nQed.",
    "Lemma form1_row_schmidt m n (A : 'M[C]_(m, n)) i :\n  '[row i A, row i (schmidt A)] >= 0.\nProof.\nrewrite /schmidt; case: eqP => // ?; rewrite ?dnorm_ge0 //.\nby case: sig2_eqW => ? ? /= /forallP /(_ i) /andP[].\nQed.",
    "Lemma schmidt_sub m n (A : 'M[C]_(m, n)) : (A <= schmidt A)%MS.\nProof.\napply/row_subP => i; rewrite (submx_trans (row_schmidt_sub _ _)) //.\nby apply/sumsmx_subP => /= j le_ji; rewrite genmxE row_sub.\nQed.",
    "Lemma eqmx_schmidt_full m n (A : 'M[C]_(m, n)) :\n  row_full A -> (schmidt A :=: A)%MS.\nProof.\nmove=> Afull; apply/eqmx_sym/eqmxP; rewrite -mxrank_leqif_eq //.\nby rewrite eqn_leq mxrankS //= (@leq_trans n) ?rank_leq_col ?col_leq_rank.\nQed.",
    "Lemma eqmx_schmidt_free m n (A : 'M[C]_(m, n)) :\n  row_free A -> (schmidt A :=: A)%MS.\nProof.\nmove=> Afree; apply/eqmx_sym/eqmxP; rewrite -mxrank_leqif_eq //.\nby rewrite eqn_leq mxrankS //= (@leq_trans m) ?rank_leq_row // ?row_leq_rank.\nQed.",
    "Lemma schmidt_complete_unitarymx m n (V : 'M[C]_(m, n)) :\n  schmidt_complete V \\is unitarymx.\nProof.\napply/unitarymxP; rewrite tr_col_mx map_row_mx mul_col_row.\nrewrite !(unitarymxP _) ?schmidt_unitarymx ?rank_leq_col //.\nmove=> [:nsV]; rewrite !(orthomx1P _) -?scalar_mx_block //;\n  [abstract: nsV|]; last by rewrite orthomx_sym.\nby do 2!rewrite eqmx_schmidt_free ?eq_row_base ?row_base_free // orthomx_sym.\nQed.",
    "Lemma cotrigonalization n (As : seq 'M[C]_n) :\n  {in As &, forall A B, comm_mx A B} ->\n  cotrigonalizable_in (@unitarymx C n n) As.\nProof.\nelim: n {-2}n (leqnn n) As => [|N IHN] n.\n  rewrite leqn0 => /eqP n_eq0.\n  exists 1%:M; first by rewrite qualifE mul1mx trmx1 map_mx1.\n  apply/allP => ? ?; apply/is_trig_mxP => i j.\n  by suff: False by []; move: i; rewrite n_eq0 => -[].\nrewrite leq_eqVlt => /predU1P [n_eqSN|/IHN//].\nhave /andP [n_gt0 n_small] : (n > 0)%N && (n - 1 <= N)%N.\n  by rewrite n_eqSN /= subn1.\nmove=> As As_comm;\nhave [v vN0 /allP /= vP] := common_eigenvector n_gt0 As_comm.\nsuff: exists2 P : 'M[C]_(\\rank v + \\rank v^!, n), P \\is unitarymx &\n  all (fun A => is_trig_mx (P *m A *m ( P^t* ))) As.\n  rewrite add_rank_ortho // => -[P P_unitary] /=; rewrite -invmx_unitary//.\n  by under eq_all do rewrite -conjumx ?unitarymx_unit//; exists P.\npose S := schmidt_complete v.\npose r A := S *m A *m S^t*.\nhave vSvo X : stablemx v X ->\n  schmidt (row_base v) *m X *m schmidt (row_base v^!%MS) ^t* = 0.\n  move=> /eigenvectorP [a v_in].\n  rewrite (eigenspaceP (_ : (_ <= _ a))%MS); last first.\n    by rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base.\n  rewrite -scalemxAl (orthomx1P _) ?scaler0 //.\n  by do 2!rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base // orthomx_sym.\nhave drrE X : drsubmx (r X) =\n  schmidt (row_base v^!%MS) *m X *m schmidt (row_base v^!%MS) ^t*.\n  by rewrite /r mul_col_mx tr_col_mx map_row_mx mul_col_row block_mxKdr.\nhave vSv X a : (v <= eigenspace X a)%MS ->\n  schmidt (row_base v) *m X *m schmidt (row_base v) ^t* = a%:M.\n  move=> vXa; rewrite (eigenspaceP (_ : (_ <= _ a)%MS)); last first.\n    by rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base.\n  by rewrite -scalemxAl (unitarymxP _) ?scalemx1 ?schmidt_unitarymx ?rank_leq_col.\nhave [] := IHN _ _ [seq drsubmx (r A) | A <- As].\n- by rewrite rank_ortho rank_rV vN0.\n- move=> _ _ /mapP[/= A A_in ->] /mapP[/= B B_in ->].\n  have : (r A) *m (r B) = (r B) *m (r A).\n    rewrite /r !mulmxA !mulmxKtV // ?schmidt_complete_unitarymx //;\n    by rewrite ?add_rank_ortho // -![S *m _ *m _]mulmxA As_comm.\n  rewrite -[r A in X in X -> _]submxK -[r B  in X in X -> _]submxK.\n  rewrite 2!mulmx_block => /eq_block_mx [_ _ _].\n  suff urr_eq0 X : X \\in As -> ursubmx (r X) = 0.\n    by rewrite !urr_eq0 ?mulmx0 ?add0r.\n  rewrite /r /S ![schmidt_complete _ *m _]mul_col_mx.\n  rewrite !tr_col_mx !map_row_mx !mul_col_row !block_mxKur.\n  by move=> X_in; rewrite vSvo // vP.\nmove=> P' P'_unitary /allP /= P'P.\nexists ((block_mx 1%:M 0 0 P') *m S).\n  rewrite mul_unitarymx ?schmidt_complete_unitarymx //.\n  apply/unitarymxP; rewrite tr_block_mx map_block_mx mulmx_block.\n  rewrite !trmx0 !(@map_mx0 _ _ conjC) !tr_scalar_mx !map_scalar_mx ?conjC1.\n  rewrite !(mulmx1, mul1mx, mulmx0, mul0mx, addr0, add0r).\n  by rewrite (unitarymxP _) -?scalar_mx_block //.\napply/allP => /= A A_in.\nrewrite trmx_mul map_mxM tr_block_mx map_block_mx.\nrewrite !trmx0 !map_mx0 !tr_scalar_mx !map_scalar_mx ?conjC1.\nrewrite mulmxA -[_ *m S *m _]mulmxA -[_ *m _ *m S^t*]mulmxA.\nrewrite /S ![schmidt_complete _ *m _]mul_col_mx.\nrewrite !tr_col_mx !map_row_mx !mul_col_row !mulmx_block.\nrewrite !(mulmx1, mul1mx, mulmx0, mul0mx, addr0, add0r).\napply/is_trig_mxP => /= i j lt_ij; rewrite mxE.\ncase: splitP => //= i' i_eq; rewrite !mxE;\ncase: splitP => //= j' j_eq.\n- have /vP /eigenvectorP [a v_in] := A_in.\n  by rewrite (vSv _ _ v_in) mxE -val_eqE ltn_eqF //= -i_eq -j_eq.\n- by rewrite vSvo ?mul0mx ?mxE // vP //.\n- move: lt_ij; rewrite i_eq j_eq ltnNge -ltnS (leq_trans (ltn_ord j'))//.\n  by rewrite -addnS leq_addr.\n- set A' := _ *m A *m _; rewrite -invmx_unitary // -conjumx ?unitarymx_unit//.\n  have /(_ _) /is_trig_mxP -> // := P'P A'; last first.\n    by move: lt_ij; rewrite i_eq j_eq ltn_add2l.\n  by apply/mapP; exists A; rewrite //= drrE.\nQed.",
    "Lemma cotrigonalization2 n (A B : 'M[C]_n) : A *m B = B *m A ->\n  exists2 P : 'M[C]_n, P \\is unitarymx &\n    similar_trig P A && similar_trig P B.\nProof.\nmove=> AB_comm; have [] := @cotrigonalization _ [:: A; B].\n  by move=> ??; rewrite !inE => /orP[]/eqP->/orP[]/eqP->.\nmove=> P Punitary /allP /= PP; exists P => //.\nby rewrite !PP ?(mem_head, in_cons, orbT).\nQed.",
    "Lemma spectral_unitarymx n (A : 'M[C]_n) : spectralmx A \\is unitarymx.\nProof.\nrewrite /spectralmx; case: orthomx_spectral_subproof; last first.\n  by move=> _; apply/unitarymxP; rewrite trmx1 map_mx1 mulmx1.\nby move=> ?; case: sig2_eqW.\nQed.",
    "Lemma spectral_unit n (A : 'M[C]_n) : spectralmx A \\in unitmx.\nProof. exact/unitarymx_unit/spectral_unitarymx. Qed.",
    "Lemma hermitian_spectral_diag_real n (A : 'M[C]_n) : A \\is hermsymmx ->\n  spectral_diag A \\is a realmx.\nProof.\nmove=> Ahermi; have /hermitian_normalmx /orthomx_spectralP A_eq := Ahermi.\nhave /(congr1 ( fun X => X^t* )) := A_eq.\nrewrite invmx_unitary ?spectral_unitarymx //.\nrewrite !trmx_mul !map_mxM map_trmx trmxK -map_mx_comp.\nrewrite tr_diag_mx map_diag_mx (map_mx_id (@conjCK _)).\nrewrite -[in RHS]invmx_unitary ?spectral_unitarymx //.\nhave := is_hermitianmxP _ _ _ Ahermi; rewrite expr0 scale1r => <-.\nrewrite {1}A_eq mulmxA => /(congr1 (mulmx^~ (invmx (spectralmx A)))).\nrewrite !mulmxK ?spectral_unit//.\nmove=> /(congr1 (mulmx (spectralmx A))); rewrite !mulKVmx ?spectral_unit//.\nmove=> eq_A_conjA; apply/mxOverP => i j; rewrite ord1 {i}.\nhave /matrixP /(_ j j) := eq_A_conjA; rewrite !mxE eqxx !mulr1n.\nby move=> /esym/CrealP.\nQed.",
    "Lemma coef_rVpoly v k : (rVpoly v)`_k = if insub k is Some i then v 0 i else 0.\nProof. by rewrite coef_poly; case: insubP => [i ->|]; rewrite ?if_same. Qed.",
    "Lemma coef_rVpoly_ord v (i : 'I_d) : (rVpoly v)`_i = v 0 i.\nProof. by rewrite coef_rVpoly valK. Qed.",
    "Lemma rVpoly_delta i : rVpoly (delta_mx 0 i) = 'X^i.\nProof.\napply/polyP=> j; rewrite coef_rVpoly coefXn.\ncase: insubP => [k _ <- | j_ge_d]; first by rewrite mxE.\nby case: eqP j_ge_d => // ->; rewrite ltn_ord.\nQed.",
    "Lemma rVpolyK : cancel rVpoly poly_rV.\nProof. by move=> u; apply/rowP=> i; rewrite mxE coef_rVpoly_ord. Qed.",
    "Lemma poly_rV_K p : size p <= d -> rVpoly (poly_rV p) = p.\nProof.\nmove=> le_p_d; apply/polyP=> k; rewrite coef_rVpoly.\ncase: insubP => [i _ <- | ]; first by rewrite mxE.\nby rewrite -ltnNge => le_d_l; rewrite nth_default ?(leq_trans le_p_d).\nQed.",
    "Lemma poly_rV_is_linear : linear poly_rV.\nProof. by move=> a p q; apply/rowP=> i; rewrite !mxE coefD coefZ. Qed.",
    "Lemma rVpoly_is_linear : linear rVpoly.\nProof.\nmove=> a u v; apply/polyP=> k; rewrite coefD coefZ !coef_rVpoly.\nby case: insubP => [i _ _ | _]; rewrite ?mxE // mulr0 addr0.\nQed.",
    "Lemma Sylvester_mxE (i j : 'I_dS) :\n  let S_ r k := r`_(j - k) *+ (k <= j) in\n  Sylvester_mx i j = match split i with inl k => S_ p k | inr k => S_ q k end.\nProof.\nmove=> S_ /[1!mxE]; case: {i}(split i) => i /[!mxE]/=;\n  by rewrite rVpoly_delta coefXnM ltnNge if_neg -mulrb.\nQed.",
    "Lemma resultant_in_ideal (R : comNzRingType) (p q : {poly R}) :\n    size p > 1 -> size q > 1 ->\n  {uv : {poly R} * {poly R} | size uv.1 < size q /\\ size uv.2 < size p\n  & (resultant p q)%:P = uv.1 * p + uv.2 * q}.\nProof.\nmove=> p_nc q_nc; pose dp := (size p).-1; pose dq := (size q).-1.\npose S := Sylvester_mx p q; pose dS := (dq + dp)%N.\nhave dS_gt0: dS > 0 by rewrite /dS /dq -(subnKC q_nc).\npose j0 := Ordinal dS_gt0.\npose Ss0 := col_mx (p *: \\col_(i < dq) 'X^i) (q *: \\col_(i < dp) 'X^i).\npose Ss := \\matrix_(i, j) (if j == j0 then Ss0 i 0 else (S i j)%:P).\npose u ds s := \\sum_(i < ds) cofactor Ss (s i) j0 * 'X^i.\nexists (u _ (lshift dp), u _ ((rshift dq) _)).\n  suffices sz_u ds s: ds > 1 -> size (u ds.-1 s) < ds by rewrite !sz_u.\n  move/ltn_predK=> {2}<-; apply: leq_trans (size_sum _ _ _) _.\n  apply/bigmax_leqP=> i _.\n  have ->: cofactor Ss (s i) j0 = (cofactor S (s i) j0)%:P.\n    rewrite rmorphM /= rmorph_sign -det_map_mx; congr (_ * \\det _).\n    by apply/matrixP=> i' j'; rewrite !mxE.\n  apply: leq_trans (size_polyMleq _ _) (leq_trans _ (valP i)).\n  by rewrite size_polyC size_polyXn addnS /= -add1n leq_add2r leq_b1.\ntransitivity (\\det Ss); last first.\n  rewrite (expand_det_col Ss j0) big_split_ord !big_distrl /=.\n  by congr (_ + _); apply: eq_bigr => i _;\n    rewrite mxE eqxx (col_mxEu, col_mxEd) !mxE mulrC mulrA mulrAC.\npose S_ j1 := map_mx polyC (\\matrix_(i, j) S i (if j == j0 then j1 else j)).\npose Ss0_ i dj := \\poly_(j < dj) S i (insubd j0 j).\npose Ss_ dj := \\matrix_(i, j) (if j == j0 then Ss0_ i dj else (S i j)%:P).\nhave{Ss u} ->: Ss = Ss_ dS.\n  apply/matrixP=> i j; rewrite mxE [in RHS]mxE; case: (j == j0) => {j}//.\n  apply/polyP=> k; rewrite coef_poly Sylvester_mxE mxE.\n  have [k_ge_dS | k_lt_dS] := leqP dS k.\n    case: (split i) => {}i; rewrite !mxE coefMXn;\n    case: ifP => // /negbT; rewrite -ltnNge ltnS => hi.\n      apply: (leq_sizeP _ _ (leqnn (size p))); rewrite -(ltn_predK p_nc).\n      by rewrite ltn_subRL (leq_trans _ k_ge_dS) // ltn_add2r.\n    - apply: (leq_sizeP _ _ (leqnn (size q))); rewrite -(ltn_predK q_nc).\n      by rewrite ltn_subRL (leq_trans _ k_ge_dS) // addnC ltn_add2l.\n  by rewrite insubdK //; case: (split i) => {}i;\n     rewrite !mxE coefMXn; case: leqP.\ncase: (ubnPgeq dS) (dS_gt0); elim=> // dj IHj ltjS _; pose j1 := Ordinal ltjS.\npose rj0T (A : 'M[{poly R}]_dS) := row j0 A^T.\nhave: rj0T (Ss_ dj.+1) = 'X^dj *: rj0T (S_ j1) + 1 *: rj0T (Ss_ dj).\n  apply/rowP=> i; apply/polyP=> k; rewrite scale1r !(Sylvester_mxE, mxE) eqxx.\n  rewrite coefD coefXnM coefC !coef_poly ltnS subn_eq0 ltn_neqAle andbC.\n  have [k_le_dj | k_gt_dj] /= := leqP k dj; last by rewrite addr0.\n  rewrite Sylvester_mxE insubdK; last exact: leq_ltn_trans (ltjS).\n  by have [->|] := eqP; rewrite (addr0, add0r).\nrewrite -det_tr => /determinant_multilinear->;\n  try by apply/matrixP=> i j; rewrite !mxE lift_eqF.\nhave [dj0 | dj_gt0] := posnP dj; rewrite ?dj0 !mul1r.\n  rewrite !det_tr det_map_mx addrC (expand_det_col _ j0) big1 => [|i _].\n    rewrite add0r; congr (\\det _)%:P.\n    apply/matrixP=> i j; rewrite [in RHS]mxE; case: eqP => // ->.\n    by congr (S i _); apply: val_inj.\n  by rewrite mxE /= [Ss0_ _ _]poly_def big_ord0 mul0r.\nhave /determinant_alternate->: j1 != j0 by rewrite -val_eqE -lt0n.\n  by rewrite mulr0 add0r det_tr IHj // ltnW.\nby move=> i; rewrite !mxE if_same.\nQed.",
    "Lemma resultant_eq0 (R : idomainType) (p q : {poly R}) :\n  (resultant p q == 0) = (size (gcdp p q) > 1).\nProof.\nhave dvdpp := dvdpp; set r := gcdp p q.\npose dp := (size p).-1; pose dq := (size q).-1.\nhave /andP[r_p r_q]: (r %| p) && (r %| q) by rewrite -dvdp_gcd.\napply/det0P/idP=> [[uv nz_uv] | r_nonC].\n  have [p0 _ | p_nz] := eqVneq p 0.\n    have: dq + dp > 0.\n      rewrite lt0n; apply: contraNneq nz_uv => dqp0.\n      by rewrite dqp0 in uv *; rewrite [uv]thinmx0.\n    by rewrite /dp /dq /r p0 size_poly0 addn0 gcd0p -subn1 subn_gt0.\n  do [rewrite -[uv]hsubmxK -{1}row_mx0 mul_row_col !mul_rV_lin1 /=] in nz_uv *.\n  set u := rVpoly _; set v := rVpoly _; pose m := gcdp (v * p) (v * q).\n  have lt_vp: size v < size p by rewrite (polySpred p_nz) ltnS size_poly.\n  move/(congr1 rVpoly)/eqP; rewrite -linearD linear0 poly_rV_K; last first.\n    rewrite (leq_trans (size_polyD _ _)) // geq_max.\n    rewrite !(leq_trans (size_polyMleq _ _)) // -subn1 leq_subLR.\n      by rewrite addnC addnA leq_add ?leqSpred ?size_poly.\n    by rewrite addnCA leq_add ?leqSpred ?size_poly.\n  rewrite addrC addr_eq0 => /eqP vq_up.\n  have nz_v: v != 0.\n    apply: contraNneq nz_uv => v0; apply/eqP.\n    congr row_mx; apply: (can_inj rVpolyK); rewrite linear0 // -/u.\n    by apply: contra_eq vq_up; rewrite v0 mul0r -addr_eq0 add0r => /mulf_neq0->.\n  have r_nz: r != 0 := dvdpN0 r_p p_nz.\n  have /dvdpP [[c w] /= nz_c wv]: v %| m by rewrite dvdp_gcd !dvdp_mulr.\n  have m_wd d: m %| v * d -> w %| d.\n    case/dvdpP=> [[k f]] /= nz_k /(congr1 ( *:%R c)).\n    rewrite mulrC scalerA scalerAl scalerAr wv mulrA => /(mulIf nz_v)def_fw.\n    by apply/dvdpP; exists (c * k, f); rewrite //= mulf_neq0.\n  have w_r: w %| r by rewrite dvdp_gcd !m_wd ?dvdp_gcdl ?dvdp_gcdr.\n  have w_nz: w != 0 := dvdpN0 w_r r_nz.\n  have p_m: p %| m  by rewrite dvdp_gcd vq_up -mulNr !dvdp_mull.\n  rewrite (leq_trans _ (dvdp_leq r_nz w_r)) // -(ltn_add2l (size v)).\n  rewrite addnC -ltn_subRL subn1 -size_mul // mulrC -wv size_scale //.\n  rewrite (leq_trans lt_vp) // dvdp_leq // -size_poly_eq0.\n  by rewrite -(size_scale _ nz_c) size_poly_eq0 wv mulf_neq0.\nhave [[c p'] /= nz_c p'r] := dvdpP _ _ r_p.\nhave [[k q'] /= nz_k q'r] := dvdpP _ _ r_q.\nhave def_r := subnKC r_nonC; have r_nz: r != 0 by rewrite -size_poly_eq0 -def_r.\nhave le_p'_dp: size p' <= dp.\n  have [-> | nz_p'] := eqVneq p' 0; first by rewrite size_poly0.\n  by rewrite /dp -(size_scale p nz_c) p'r size_mul // addnC -def_r leq_addl.\nhave le_q'_dq: size q' <= dq.\n  have [-> | nz_q'] := eqVneq q' 0; first by rewrite size_poly0.\n  by rewrite /dq -(size_scale q nz_k) q'r size_mul // addnC -def_r leq_addl.\nexists (row_mx (- c *: poly_rV q') (k *: poly_rV p')); last first.\n  rewrite mul_row_col scaleNr mulNmx !mul_rV_lin1 /= 2!linearZ /= !poly_rV_K //.\n  by rewrite !scalerCA p'r q'r mulrCA addNr.\napply: contraNneq r_nz; rewrite -row_mx0 => /eq_row_mx[/eqP].\nrewrite scaleNr oppr_eq0 gcdp_eq0 -!size_poly_eq0 => /eqP q0 p0.\nrewrite -(size_scale p nz_c) -(size_scale (c *: p) nz_k) p'r.\nrewrite -(size_scale q nz_k) -(size_scale (k *: q) nz_c) q'r !scalerAl.\nrewrite -(poly_rV_K le_p'_dp) -(poly_rV_K le_q'_dq).\nby rewrite -2![_ *: rVpoly _]linearZ p0 q0 !linear0 mul0r size_poly0.\nQed.",
    "Lemma horner_mx_C a : horner_mx a%:P = a%:M.\nProof. exact: horner_morphC. Qed.",
    "Lemma horner_mx_X : horner_mx 'X = A. Proof. exact: horner_morphX. Qed.",
    "Lemma horner_mxZ : scalable horner_mx.\nProof.\nmove=> a p /=; rewrite -mul_polyC rmorphM /=.\nby rewrite horner_mx_C [_ * _]mul_scalar_mx.\nQed.",
    "Lemma horner_rVpoly m (u : 'rV_m) :\n  horner_mx (rVpoly u) = vec_mx (u *m powers_mx m).\nProof.\nrewrite mulmx_sum_row [rVpoly u]poly_def 2!linear_sum; apply: eq_bigr => i _.\nby rewrite valK /= 2!linearZ rmorphXn/= horner_mx_X rowK mxvecK.\nQed.",
    "Lemma horner_mx_diag (d : 'rV[R]_n) (p : {poly R}) :\n  horner_mx (diag_mx d) p = diag_mx (map_mx (horner p) d).\nProof.\napply/matrixP => i j; rewrite !mxE.\nelim/poly_ind: p => [|p c ihp]; first by rewrite rmorph0 horner0 mxE mul0rn.\nrewrite !hornerE mulrnDl rmorphD rmorphM /= horner_mx_X horner_mx_C !mxE.\nrewrite (bigD1 j)//= ihp mxE eqxx mulr1n -mulrnAl big1 ?addr0.\n  by have [->|_] := eqVneq; rewrite /= !(mulr1n, addr0, mul0r).\nby move=> k /negPf nkF; rewrite mxE nkF mulr0.\nQed.",
    "Lemma comm_mx_horner A B p : comm_mx A B -> comm_mx A (horner_mx B p).\nProof.\nmove=> fg; apply: commr_horner => // i.\nby rewrite coef_map; apply/comm_scalar_mx.\nQed.",
    "Lemma comm_horner_mx A B p : comm_mx A B -> comm_mx (horner_mx A p) B.\nProof. by move=> ?; apply/comm_mx_sym/comm_mx_horner/comm_mx_sym. Qed.",
    "Lemma comm_horner_mx2 A p q : GRing.comm (horner_mx A p) (horner_mx A q).\nProof. exact/comm_mx_horner/comm_horner_mx. Qed.",
    "Lemma horner_mx_stable (K : fieldType) m n p\n    (V : 'M[K]_(n.+1, m.+1)) (f : 'M_m.+1) :\n  stablemx V f -> stablemx V (horner_mx f p).\nProof.\nmove=> V_fstab; elim/poly_ind: p => [|p c]; first by rewrite rmorph0 stablemx0.\nmove=> fp_stable; rewrite rmorphD rmorphM/= horner_mx_X horner_mx_C.\nby rewrite stablemxD ?stablemxM ?fp_stable ?stablemxC.\nQed.",
    "Lemma size_char_poly : size char_poly = n.+1.\nProof.\nhave [q <- lt_q_n] := split_diagA; have le_q_n := leq_trans lt_q_n (leq_pred n).\nby rewrite size_polyDl size_prod_XsubC size_diagA.\nQed.",
    "Lemma char_poly_monic : char_poly \\is monic.\nProof.\nrewrite monicE -(monicP (monic_prod_XsubC diagA xpredT id)).\nrewrite !lead_coefE size_char_poly.\nhave [q <- lt_q_n] := split_diagA; have le_q_n := leq_trans lt_q_n (leq_pred n).\nby rewrite size_prod_XsubC size_diagA coefD (nth_default 0 le_q_n) addr0.\nQed.",
    "Lemma char_poly_trace : n > 0 -> char_poly`_n.-1 = - \\tr A.\nProof.\nmove=> n_gt0; have [q <- lt_q_n] := split_diagA; set p := \\prod_(x <- _) _.\nrewrite coefD {q lt_q_n}(nth_default 0 lt_q_n) addr0.\nhave{n_gt0} ->: p`_n.-1 = ('X * p)`_n by rewrite coefXM eqn0Ngt n_gt0.\nhave ->: \\tr A = \\sum_(x <- diagA) x by rewrite big_map big_filter.\nrewrite -size_diagA {}/p; elim: diagA => [|x d IHd].\n  by rewrite !big_nil mulr1 coefX oppr0.\nrewrite !big_cons coefXM mulrBl coefB IHd opprD addrC; congr (- _ + _).\nrewrite mul_polyC coefZ [size _]/= -(size_prod_XsubC _ id) -lead_coefE.\nby rewrite (monicP _) ?monic_prod_XsubC ?mulr1.\nQed.",
    "Lemma char_poly_det : char_poly`_0 = (- 1) ^+ n * \\det A.\nProof.\nrewrite big_distrr coef_sum [0%N]lock /=; apply: eq_bigr => s _.\nrewrite -{1}rmorphN -rmorphXn mul_polyC coefZ /=.\nrewrite mulrA -exprD addnC exprD -mulrA -lock; congr (_ * _).\ntransitivity (\\prod_(i < n) - A i (s i)); last by rewrite prodrN card_ord.\nelim: (index_enum _) => [|i e IHe]; rewrite !(big_nil, big_cons) ?coef1 //.\nby rewrite coefM big_ord1 IHe !mxE coefB coefC coefMn coefX mul0rn sub0r.\nQed.",
    "Lemma mx_poly_ring_isom (R : nzRingType) n' (n := n'.+1) :\n  exists phi : {rmorphism 'M[{poly R}]_n -> {poly 'M[R]_n}},\n  [/\\ bijective phi,\n      forall p, phi p%:M = map_poly scalar_mx p,\n      forall A, phi (map_mx polyC A) = A%:P\n    & forall A i j k, (phi A)`_k i j = (A i j)`_k].\nProof.\nset M_RX := 'M[{poly R}]_n; set MR_X := ({poly 'M[R]_n}).\npose Msize (A : M_RX) := \\max_i \\max_j size (A i j).\npose phi (A : M_RX) := \\poly_(k < Msize A) \\matrix_(i, j) (A i j)`_k.\nhave coef_phi A i j k: (phi A)`_k i j = (A i j)`_k.\n  rewrite coef_poly; case: (ltnP k _) => le_m_k; rewrite mxE // nth_default //.\n  by apply: leq_trans (leq_trans (leq_bigmax i) le_m_k); apply: (leq_bigmax j).\nhave phi_is_additive : additive phi.\n  move=> A B; apply/polyP => k; apply/matrixP => i j.\n  by rewrite !(coef_phi, mxE, coefD, coefN).\nhave phi_is_multiplicative : multiplicative phi.\n  split=> [A B|]; apply/polyP => k; apply/matrixP => i j; last first.\n    by rewrite coef_phi mxE coefMn !coefC; case: (k == _); rewrite ?mxE ?mul0rn.\n  rewrite !coef_phi !mxE !coefM summxE coef_sum.\n  pose F k1 k2 := (A i k1)`_k2 * (B k1 j)`_(k - k2).\n  transitivity (\\sum_k1 \\sum_(k2 < k.+1) F k1 k2); rewrite {}/F.\n    by apply: eq_bigr=> k1 _; rewrite coefM.\n  rewrite exchange_big /=; apply: eq_bigr => k2 _.\n  by rewrite mxE; apply: eq_bigr => k1 _; rewrite !coef_phi.\nhave bij_phi: bijective phi.\n  exists (fun P : MR_X => \\matrix_(i, j) \\poly_(k < size P) P`_k i j) => [A|P].\n    apply/matrixP=> i j; rewrite mxE; apply/polyP=> k.\n    rewrite coef_poly -coef_phi.\n    by case: leqP => // P_le_k; rewrite nth_default ?mxE.\n  apply/polyP=> k; apply/matrixP=> i j; rewrite coef_phi mxE coef_poly.\n  by case: leqP => // P_le_k; rewrite nth_default ?mxE.\npose phiaM := GRing.isAdditive.Build _ _ phi phi_is_additive.\npose phimM := GRing.isMultiplicative.Build _ _ phi phi_is_multiplicative.\npose phiRM : {rmorphism _ -> _} := HB.pack phi phiaM phimM.\nexists phiRM; split=> // [p | A]; apply/polyP=> k; apply/matrixP=> i j.\n  by rewrite coef_phi coef_map !mxE coefMn.\nby rewrite coef_phi !mxE !coefC; case k; last rewrite /= mxE.\nQed.",
    "Lemma eigenvalue_root_char (F : fieldType) n (A : 'M[F]_n) a :\n  eigenvalue A a = root (char_poly A) a.\nProof.\ntransitivity (\\det (a%:M - A) == 0).\n  apply/eigenvalueP/det0P=> [[v Av_av v_nz] | [v v_nz Av_av]]; exists v => //.\n    by rewrite mulmxBr Av_av mul_mx_scalar subrr.\n  by apply/eqP; rewrite -mul_mx_scalar eq_sym -subr_eq0 -mulmxBr Av_av.\ncongr (_ == 0); rewrite horner_sum; apply: eq_bigr => s _.\nrewrite hornerM horner_exp !hornerE; congr (_ * _).\nrewrite (big_morph _ (fun p q => hornerM p q a) (hornerC 1 a)).\nby apply: eq_bigr => i _; rewrite !mxE !(hornerE, hornerMn).\nQed.",
    "Lemma char_poly_trig {R : comNzRingType} n (A : 'M[R]_n) : is_trig_mx A ->\n  char_poly A = \\prod_(i < n) ('X - (A i i)%:P).\nProof.\nmove=> /is_trig_mxP Atrig; rewrite /char_poly det_trig.\n  by apply: eq_bigr => i; rewrite !mxE eqxx.\nby apply/is_trig_mxP => i j lt_ij; rewrite !mxE -val_eqE ltn_eqF ?Atrig ?subrr.\nQed.",
    "Lemma companionmxK {R : comNzRingType} (p : {poly R}) :\n   p \\is monic -> char_poly (companionmx p) = p.\nProof.\npose D n : 'M[{poly R}]_n := \\matrix_(i, j)\n   ('X *+ (i == j.+1 :> nat) - ((i == j)%:R)%:P).\nhave detD n : \\det (D n) = (-1) ^+ n.\n  elim: n => [|n IHn]; first by rewrite det_mx00.\n  rewrite (expand_det_row _ ord0) big_ord_recl !mxE /= sub0r.\n  rewrite big1 ?addr0; last by move=> i _; rewrite !mxE /= subrr mul0r.\n  rewrite /cofactor mul1r [X in \\det X](_ : _ = D _) ?IHn ?exprS//.\n  by apply/matrixP=> i j; rewrite !mxE /= /bump !add1n eqSS.\nelim/poly_ind: p => [|p c IHp].\n  by rewrite monicE lead_coef0 eq_sym oner_eq0.\nhave [->|p_neq0] := eqVneq p 0.\n  rewrite mul0r add0r monicE lead_coefC => /eqP->.\n  by rewrite /companionmx /char_poly size_poly1 det_mx00.\nrewrite monicE lead_coefDl ?lead_coefMX => [p_monic|]; last first.\n  rewrite size_polyC size_mulX ?polyX_eq0// ltnS.\n  by rewrite (leq_trans (leq_b1 _)) ?size_poly_gt0.\nrewrite -[in RHS]IHp // /companionmx size_MXaddC (negPf p_neq0) /=.\nrewrite /char_poly polySpred //.\nhave [->|spV1_gt0] := posnP (size p).-1.\n  rewrite [X in \\det X]mx11_scalar det_scalar1 !mxE ?eqxx det_mx00.\n  by rewrite mul1r -horner_coef0 hornerMXaddC mulr0 add0r rmorphN opprK.\nrewrite (expand_det_col _ ord0) /= -[(size p).-1]prednK //.\nrewrite big_ord_recr big_ord_recl/= big1 ?add0r //=; last first.\n  move=> i _; rewrite !mxE -val_eqE /= /bump leq0n add1n eqSS.\n  by rewrite ltn_eqF ?subrr ?mul0r.\nrewrite !mxE ?subnn -horner_coef0 /= hornerMXaddC.\nrewrite !(eqxx, mulr0, add0r, addr0, subr0, rmorphN, opprK)/=.\nrewrite mulrC /cofactor; congr (_ * 'X + _).\n  rewrite /cofactor -signr_odd oddD addbb mul1r; congr (\\det _).\n  apply/matrixP => i j; rewrite !mxE -val_eqE coefD coefMX coefC.\n  by rewrite /= /bump /= !add1n !eqSS addr0.\nrewrite /cofactor [X in \\det X](_ : _ = D _).\n  by rewrite detD /= addn0 -signr_odd -signr_addb addbb mulr1.\napply/matrixP=> i j; rewrite !mxE -!val_eqE /= /bump /=.\nby rewrite leqNgt ltn_ord add0n add1n [_ == _.-2.+1]ltn_eqF.\nQed.",
    "Lemma mulmx_delta_companion (R : nzRingType) (p : seq R)\n  (i: 'I_(size p).-1) (i_small : i.+1 < (size p).-1):\n  delta_mx 0 i *m companionmx p = delta_mx 0 (Ordinal i_small) :> 'rV__.\nProof.\napply/rowP => j; rewrite !mxE (bigD1 i) //= ?(=^~val_eqE, mxE) /= eqxx mul1r.\nrewrite ltn_eqF ?big1 ?addr0 1?eq_sym //; last first.\n  by rewrite -ltnS prednK // (leq_trans  _ i_small).\nby move=> k /negPf ki_eqF; rewrite !mxE eqxx ki_eqF mul0r.\nQed.",
    "Lemma row'_col'_char_poly_mx {R : nzRingType} m i (M : 'M[R]_m) :\n  row' i (col' i (char_poly_mx M)) = char_poly_mx (row' i (col' i M)).\nProof. by apply/matrixP => k l; rewrite !mxE (inj_eq lift_inj). Qed.",
    "Lemma char_block_diag_mx {R : nzRingType} m n (A : 'M[R]_m) (B : 'M[R]_n) :\n  char_poly_mx (block_mx A 0 0 B) =\n  block_mx (char_poly_mx A) 0 0 (char_poly_mx B).\nProof.\nrewrite /char_poly_mx map_block_mx/= !map_mx0.\nby rewrite scalar_mx_block opp_block_mx add_block_mx !subr0.\nQed.",
    "Lemma mxminpoly_nonconstant : d > 0.\nProof.\nrewrite /d; case: ex_minnP => -[] //; rewrite leqn0 mxrank_eq0; move/eqP.\nby move/row_matrixP/(_ 0)/eqP; rewrite rowK row0 mxvec_eq0 -mxrank_eq0 mxrank1.\nQed.",
    "Lemma minpoly_mx1 : (1%:M \\in Ad)%MS.\nProof.\nby apply: (eq_row_sub (Ordinal mxminpoly_nonconstant)); rewrite rowK.\nQed.",
    "Lemma minpoly_mx_free : row_free Ad.\nProof.\nhave:= mxminpoly_nonconstant; rewrite /d; case: ex_minnP => -[] // d' _ /(_ d').\nby move/implyP; rewrite ltnn implybF -ltnS ltn_neqAle rank_leq_row andbT negbK.\nQed.",
    "Lemma horner_mx_mem p : (horner_mx A p \\in Ad)%MS.\nProof.\nelim/poly_ind: p => [|p a IHp]; first by rewrite rmorph0 // linear0 sub0mx.\nrewrite rmorphD rmorphM /= horner_mx_C horner_mx_X.\nrewrite addrC -scalemx1 linearP /= -(mul_vec_lin (mulmxr A)).\ncase/submxP: IHp => u ->{p}.\nhave: (powers_mx A (1 + d) <= Ad)%MS.\n  rewrite -(geq_leqif (mxrank_leqif_sup _)).\n    by rewrite (eqnP minpoly_mx_free) /d; case: ex_minnP.\n  rewrite addnC; apply/row_subP=> i.\n  by apply: eq_row_sub (lshift 1 i) _; rewrite !rowK.\napply: submx_trans; rewrite addmx_sub ?scalemx_sub //.\n  by apply: (eq_row_sub 0); rewrite rowK.\nrewrite -mulmxA mulmx_sub {u}//; apply/row_subP=> i.\nrewrite row_mul rowK mul_vec_lin /= mulmxE -exprSr.\nby apply: (eq_row_sub (rshift 1 i)); rewrite rowK.\nQed.",
    "Lemma mx_inv_horner0 :  mx_inv_horner 0 = 0.\nProof. by rewrite /mx_inv_horner !(linear0, mul0mx). Qed.",
    "Lemma mx_inv_hornerK B : (B \\in Ad)%MS -> horner_mx A (mx_inv_horner B) = B.\nProof. by move=> sBAd; rewrite horner_rVpoly mulmxKpV ?mxvecK. Qed.",
    "Lemma minpoly_mxM B C : (B \\in Ad -> C \\in Ad -> B * C \\in Ad)%MS.\nProof.\nmove=> AdB AdC; rewrite -(mx_inv_hornerK AdB) -(mx_inv_hornerK AdC).\nby rewrite -rmorphM ?horner_mx_mem.\nQed.",
    "Lemma minpoly_mx_ring : mxring Ad.\nProof.\napply/andP; split; first exact/mulsmx_subP/minpoly_mxM.\napply/mxring_idP; exists 1%:M; split=> *; rewrite ?mulmx1 ?mul1mx //.\n  by rewrite -mxrank_eq0 mxrank1.\nexact: minpoly_mx1.\nQed.",
    "Lemma size_mxminpoly : size p_A = d.+1.\nProof. by rewrite size_polyDl ?size_polyXn // size_polyN ltnS size_poly. Qed.",
    "Lemma mxminpoly_monic : p_A \\is monic.\nProof.\nrewrite monicE /lead_coef size_mxminpoly coefB coefXn eqxx /=.\nby rewrite nth_default ?size_poly // subr0.\nQed.",
    "Lemma size_mod_mxminpoly p : size (p %% p_A) <= d.\nProof.\nby rewrite -ltnS -size_mxminpoly ltn_modp // -size_poly_eq0 size_mxminpoly.\nQed.",
    "Lemma mx_root_minpoly : horner_mx A p_A = 0.\nProof.\nrewrite rmorphB -{3}(horner_mx_X A) -rmorphXn /=.\nby rewrite mx_inv_hornerK ?subrr ?horner_mx_mem.\nQed.",
    "Lemma horner_rVpolyK (u : 'rV_d) :\n  mx_inv_horner (horner_mx A (rVpoly u)) = rVpoly u.\nProof.\ncongr rVpoly; rewrite horner_rVpoly vec_mxK.\nby apply: (row_free_inj minpoly_mx_free); rewrite mulmxKpV ?submxMl.\nQed.",
    "Lemma horner_mxK p : mx_inv_horner (horner_mx A p) = p %% p_A.\nProof.\nrewrite {1}(Pdiv.IdomainMonic.divp_eq mxminpoly_monic p) rmorphD rmorphM /=.\nrewrite mx_root_minpoly mulr0 add0r.\nby rewrite -(poly_rV_K (size_mod_mxminpoly _)) horner_rVpolyK.\nQed.",
    "Lemma mxminpoly_min p : horner_mx A p = 0 -> p_A %| p.\nProof. by move=> pA0; rewrite /dvdp -horner_mxK pA0 mx_inv_horner0. Qed.",
    "Lemma mxminpoly_minP p : reflect (horner_mx A p = 0) (p_A %| p).\nProof.\napply: (iffP idP); last exact: mxminpoly_min.\nby move=> /Pdiv.Field.dvdpP[q ->]; rewrite rmorphM/= mx_root_minpoly mulr0.\nQed.",
    "Lemma dvd_mxminpoly p : (p_A %| p) = (horner_mx A p == 0).\nProof. exact/mxminpoly_minP/eqP. Qed.",
    "Lemma horner_rVpoly_inj : injective (horner_mx A \\o rVpoly : 'rV_d -> 'M_n).\nProof.\napply: can_inj (poly_rV \\o mx_inv_horner) _ => u /=.\nby rewrite horner_rVpolyK rVpolyK.\nQed.",
    "Lemma mxminpoly_linear_is_scalar : (d <= 1) = is_scalar_mx A.\nProof.\nhave scalP := has_non_scalar_mxP minpoly_mx1.\nrewrite leqNgt -(eqnP minpoly_mx_free); apply/scalP/idP=> [|[[B]]].\n  case scalA: (is_scalar_mx A); [by right | left].\n  by exists A; rewrite ?scalA // -{1}(horner_mx_X A) horner_mx_mem.\nmove/mx_inv_hornerK=> <- nsB; case/is_scalar_mxP=> a defA; case/negP: nsB.\nmove: {B}(_ B); apply: poly_ind => [|p c].\n  by rewrite rmorph0 ?mx0_is_scalar.\nrewrite rmorphD ?rmorphM /= horner_mx_X defA; case/is_scalar_mxP=> b ->.\nby rewrite -rmorphM horner_mx_C -rmorphD /= scalar_mx_is_scalar.\nQed.",
    "Lemma mxminpoly_dvd_char : p_A %| char_poly A.\nProof. exact/mxminpoly_min/Cayley_Hamilton. Qed.",
    "Lemma eigenvalue_root_min a : eigenvalue A a = root p_A a.\nProof.\napply/idP/idP=> Aa; last first.\n  rewrite eigenvalue_root_char !root_factor_theorem in Aa *.\n  exact: dvdp_trans Aa mxminpoly_dvd_char.\nhave{Aa} [v Av_av v_nz] := eigenvalueP Aa.\napply: contraR v_nz => pa_nz; rewrite -{pa_nz}(eqmx_eq0 (eqmx_scale _ pa_nz)).\napply/eqP; rewrite -(mulmx0 _ v) -mx_root_minpoly.\nelim/poly_ind: p_A => [|p c IHp].\n  by rewrite rmorph0 horner0 scale0r mulmx0.\nrewrite !hornerE rmorphD rmorphM /= horner_mx_X horner_mx_C scalerDl.\nby rewrite -scalerA mulmxDr mul_mx_scalar mulmxA -IHp -scalemxAl Av_av.\nQed.",
    "Lemma root_mxminpoly a : root p_A a = root (char_poly A) a.\nProof. by rewrite -eigenvalue_root_min eigenvalue_root_char. Qed.",
    "Lemma mxminpoly_diag {F : fieldType} {n} (d : 'rV[F]_n.+1)\n    (u := undup [seq d 0 i | i <- enum 'I_n.+1]) :\n  mxminpoly (diag_mx d) = \\prod_(r <- u) ('X - r%:P).\nProof.\napply/eqP; rewrite -eqp_monic ?mxminpoly_monic ?monic_prod_XsubC// /eqp.\nrewrite mxminpoly_min/=; last first.\n  rewrite horner_mx_diag; apply/matrixP => i j; rewrite !mxE horner_prod.\n  case: (altP (i =P j)) => [->|neq_ij//]; rewrite mulr1n.\n  rewrite (bigD1_seq (d 0 j)) ?undup_uniq ?mem_undup ?map_f// /=.\n  by rewrite hornerD hornerN hornerX hornerC subrr mul0r.\napply: uniq_roots_dvdp; last by rewrite uniq_rootsE undup_uniq.\napply/allP => x; rewrite mem_undup root_mxminpoly char_poly_trig//.\nrewrite -(big_map _ predT (fun x => _ - x%:P)) root_prod_XsubC.\nby move=> /mapP[i _ ->]; apply/mapP; exists i; rewrite ?(mxE, eqxx).\nQed.",
    "Lemma map_rVpoly (u : 'rV_d) : fp (rVpoly u) = rVpoly u^f.\nProof.\napply/polyP=> k; rewrite coef_map !coef_rVpoly.\nby case: (insub k) => [i|]; rewrite /=  ?rmorph0 // mxE.\nQed.",
    "Lemma map_poly_rV p : (poly_rV p)^f = poly_rV (fp p) :> 'rV_d.\nProof. by apply/rowP=> j; rewrite !mxE coef_map. Qed.",
    "Lemma map_char_poly_mx : map_mx fp (char_poly_mx A) = char_poly_mx A^f.\nProof.\nrewrite raddfB /= map_scalar_mx /= map_polyX; congr (_ - _).\nby apply/matrixP=> i j; rewrite !mxE map_polyC.\nQed.",
    "Lemma map_char_poly : fp (char_poly A) = char_poly A^f.\nProof. by rewrite -det_map_mx map_char_poly_mx. Qed.",
    "Lemma map_resultant (aR rR : nzRingType) (f : {rmorphism {poly aR} -> rR}) p q :\n    f (lead_coef p) != 0 -> f (lead_coef q) != 0 ->\n  f (resultant p q)= resultant (map_poly f p) (map_poly f q).\nProof.\nmove=> nz_fp nz_fq; rewrite /resultant /Sylvester_mx !size_map_poly_id0 //.\nrewrite -det_map_mx /= map_col_mx; congr (\\det (col_mx _ _));\n  by apply: map_lin1_mx => v; rewrite map_poly_rV rmorphM /= map_rVpoly.\nQed.",
    "Lemma map_powers_mx e : (powers_mx A e)^f = powers_mx A^f e.\nProof. by apply/row_matrixP=> i; rewrite -map_row !rowK map_mxvec rmorphXn. Qed.",
    "Lemma map_horner_mx p : (horner_mx A p)^f = horner_mx A^f (fp p).\nProof.\nrewrite -[p](poly_rV_K (leqnn _)) map_rVpoly.\nby rewrite !horner_rVpoly map_vec_mx map_mxM map_powers_mx.\nQed.",
    "Lemma map_mx_companion (e := congr1 predn (size_map_poly _ _)) :\n  (companionmx p)^f = castmx (e, e) (companionmx (fp p)).\nProof.\napply/matrixP => i j; rewrite !(castmxE, mxE) /= (fun_if f).\nby rewrite rmorphN coef_map size_map_poly rmorph_nat.\nQed.",
    "Lemma companion_map_poly (e := esym (congr1 predn (size_map_poly _ _))) :\n  companionmx (fp p) = castmx (e, e) (companionmx p)^f.\nProof. by rewrite map_mx_companion castmx_comp castmx_id. Qed.",
    "Lemma degree_mxminpoly_map : degree_mxminpoly A^f = degree_mxminpoly A.\nProof. by apply: eq_ex_minn => e; rewrite -map_powers_mx mxrank_map. Qed.",
    "Lemma mxminpoly_map : mxminpoly A^f = fp (mxminpoly A).\nProof.\nrewrite rmorphB; congr (_ - _).\n  by rewrite /= map_polyXn degree_mxminpoly_map.\nrewrite degree_mxminpoly_map -rmorphXn /=.\napply/polyP=> i; rewrite coef_map //= !coef_rVpoly degree_mxminpoly_map.\ncase/insub: i => [i|]; last by rewrite rmorph0.\nby rewrite -map_powers_mx -map_pinvmx // -map_mxvec -map_mxM // mxE.\nQed.",
    "Lemma map_mx_inv_horner u : fp (mx_inv_horner A u) = mx_inv_horner A^f u^f.\nProof.\nrewrite map_rVpoly map_mxM map_mxvec map_pinvmx map_powers_mx.\nby rewrite /mx_inv_horner degree_mxminpoly_map.\nQed.",
    "Lemma kermxpolyC n (g : 'M_n) c : c != 0 -> kermxpoly g c%:P = 0.\nProof.\nmove=> c_neq0; case: n => [|n] in g *; first by rewrite thinmx0.\napply/eqP; rewrite /kermxpoly horner_mx_C kermx_eq0 row_free_unit.\nby rewrite -scalemx1 scaler_unit ?unitmx1// unitfE.\nQed.",
    "Lemma kermxpoly1 n (g : 'M_n) : kermxpoly g 1 = 0.\nProof. by rewrite kermxpolyC ?oner_eq0. Qed.",
    "Lemma kermxpolyX n (g : 'M_n) : kermxpoly g 'X = kermx g.\nProof.\ncase: n => [|n] in g *; first by rewrite !thinmx0.\nby rewrite /kermxpoly horner_mx_X.\nQed.",
    "Lemma kermxpoly_min n (g : 'M[K]_n.+1) p :\n  mxminpoly g %| p -> (kermxpoly g p :=: 1)%MS.\nProof. by rewrite /kermxpoly => /mxminpoly_minP ->; apply: kermx0. Qed.",
    "Lemma comm_mx_stable_kermxpoly n (f g : 'M_n) (p : {poly K}) : comm_mx f g ->\n  stablemx (kermxpoly f p) g.\nProof.\ncase: n => [|n] in f g *; first by rewrite !thinmx0.\nmove=> fg; rewrite /kermxpoly; apply: comm_mx_stable_ker.\nby apply/comm_mx_sym/comm_mx_horner/comm_mx_sym.\nQed.",
    "Lemma mxdirect_kermxpoly n (g : 'M_n) (p q : {poly K}) :\n  coprimep p q -> (kermxpoly g p :&: kermxpoly g q = 0)%MS.\nProof.\ncase: n => [|n] in g *; first by rewrite thinmx0 ?cap0mx ?submx_refl.\nmove=> /Bezout_eq1_coprimepP [[/= u v]]; rewrite mulrC [v * _]mulrC => cpq.\napply/eqP/rowV0P => x.\nrewrite sub_capmx => /andP[/sub_kermxP xgp0 /sub_kermxP xgq0].\nmove: cpq => /(congr1 (mulmx x \\o horner_mx g))/=.\nrewrite !(rmorphM, rmorphD, rmorph1, mulmx1, mulmxDr, mulmxA).\nby rewrite xgp0 xgq0 !mul0mx add0r.\nQed.",
    "Lemma kermxpolyM n (g : 'M_n) (p q : {poly K}) : coprimep p q ->\n  (kermxpoly g (p * q) :=: kermxpoly g p + kermxpoly g q)%MS.\nProof.\ncase: n => [|n] in g *; first by rewrite !thinmx0.\nmove=> /Bezout_eq1_coprimepP [[/= u v]]; rewrite mulrC [v * _]mulrC => cpq.\napply/eqmxP/andP; split; last first.\n  apply/sub_kermxP/eqmx0P; rewrite !addsmxMr [in X in (_ + X)%MS]mulrC.\n  by rewrite !rmorphM/= !mulmxA !mulmx_ker !mul0mx !addsmx0 submx_refl.\nmove: cpq => /(congr1 (horner_mx g))/=; rewrite rmorph1 rmorphD/=.\nrewrite -[X in (X <= _)%MS]mulr1 => <-; rewrite mulrDr [p * u]mulrC addrC.\nrewrite addmx_sub_adds//; apply/sub_kermxP; rewrite mulmxE -mulrA -rmorphM.\n  by rewrite mulrAC [q * p]mulrC rmorphM/= mulrA -!mulmxE mulmx_ker mul0mx.\nrewrite -[_ * _ * q]mulrA [u * _]mulrC.\nby rewrite rmorphM mulrA -!mulmxE mulmx_ker mul0mx.\nQed.",
    "Lemma kermxpoly_prod n (g : 'M_n)\n    (I : finType) (P : {pred I}) (p_ : I -> {poly K}) :\n  {in P &, forall i j, j != i -> coprimep (p_ i) (p_ j)} ->\n  (kermxpoly g (\\prod_(i | P i) p_ i) :=: \\sum_(i | P i) kermxpoly g (p_ i))%MS.\nProof.\nmove=> p_coprime; elim: index_enum (index_enum_uniq I).\n  by rewrite !big_nil ?kermxpoly1 ?submx_refl//.\nmove=> j js ihjs /= /andP[jNjs js_uniq]; apply/eqmxP.\nrewrite !big_cons; case: ifP => [Pj|PNj]; rewrite ?ihjs ?submx_refl//.\nsuff cjjs: coprimep (p_ j) (\\prod_(i <- js | P i) p_ i).\n  by rewrite !kermxpolyM// !(adds_eqmx (eqmx_refl _) (ihjs _)) ?submx_refl.\nrewrite (@big_morph _ _ _ true andb) ?big_all_cond ?coprimep1//; last first.\n  by move=> p q; rewrite coprimepMr.\napply/allP => i i_js; apply/implyP => Pi; apply: p_coprime => //.\nby apply: contraNneq jNjs => <-.\nQed.",
    "Lemma mxdirect_sum_kermx n (g : 'M_n)\n    (I : finType) (P : {pred I}) (p_ : I -> {poly K}) :\n  {in P &, forall i j, j != i -> coprimep (p_ i) (p_ j)} ->\n  mxdirect (\\sum_(i | P i) kermxpoly g (p_ i))%MS.\nProof.\nmove=> p_coprime; apply/mxdirect_sumsP => i Pi; apply/eqmx0P.\nhave cpNi : {in [pred j | P j && (j != i)] &,\n    forall j k : I, k != j -> coprimep (p_ j) (p_ k)}.\n  by move=> j k /andP[Pj _] /andP[Pk _]; apply: p_coprime.\nrewrite -!(cap_eqmx (eqmx_refl _) (kermxpoly_prod g _))//.\nrewrite mxdirect_kermxpoly ?submx_refl//.\nrewrite (@big_morph _ _ _ true andb) ?big_all_cond ?coprimep1//; last first.\n  by move=> p q; rewrite coprimepMr.\nby apply/allP => j _; apply/implyP => /andP[Pj neq_ji]; apply: p_coprime.\nQed.",
    "Lemma eigenspace_poly n a (f : 'M_n) :\n  eigenspace f a = kermxpoly f ('X - a%:P).\nProof.\ncase: n => [|m] in a f *; first by rewrite !thinmx0.\nby congr (kermx _); rewrite rmorphB /= ?horner_mx_X ?horner_mx_C.\nQed.",
    "Lemma geigenspaceE n' (g : 'M_n'.+1) a :\n  geigenspace g a = kermx ((g - a%:M) ^+ n'.+1).\nProof.\nby rewrite /geigenspace /kermxpoly rmorphXn/= rmorphB/= horner_mx_X horner_mx_C.\nQed.",
    "Lemma eigenspace_sub_geigen n (g : 'M_n) a :\n  (eigenspace g a <= geigenspace g a)%MS.\nProof.\ncase: n => [|n] in g *; rewrite ?thinmx0 ?sub0mx// geigenspaceE.\nby apply/sub_kermxP; rewrite exprS mulmxA mulmx_ker mul0mx.\nQed.",
    "Lemma mxdirect_sum_geigenspace\n    (I : finType) (n : nat) (g : 'M_n) (P : {pred I}) (a_ : I -> K) :\n  {in P &, injective a_} -> mxdirect (\\sum_(i | P i) geigenspace g (a_ i)).\nProof.\nmove=> /inj_in_eq eq_a; apply: mxdirect_sum_kermx => i j Pi Pj Nji.\nby rewrite coprimep_expr ?coprimep_expl// coprimep_XsubC root_XsubC eq_a.\nQed.",
    "Lemma eigenpolyP n (g : 'M_n) (p : {poly K}) :\n  reflect (exists2 v : 'rV_n, (v <= kermxpoly g p)%MS & v != 0) (eigenpoly g p).\nProof. exact: rowV0Pn. Qed.",
    "Lemma eigenvalue_poly n a (f : 'M_n) : eigenvalue f a = eigenpoly f ('X - a%:P).\nProof. by rewrite /eigenpoly /eigenvalue eigenspace_poly. Qed.",
    "Lemma comm_mx_stable_geigenspace n (f g : 'M_n) a : comm_mx f g ->\n  stablemx (geigenspace f a) g.\nProof. exact: comm_mx_stable_kermxpoly. Qed.",
    "Lemma map_kermxpoly (n : nat) (g : 'M_n) (p : {poly aF}) :\n  map_mx f (kermxpoly g p) = kermxpoly (map_mx f g) (map_poly f p).\nProof.\nby case: n => [|n] in g *; rewrite ?thinmx0// map_kermx map_horner_mx.\nQed.",
    "Lemma map_geigenspace (n : nat) (g : 'M_n) (a : aF) :\n  map_mx f (geigenspace g a) = geigenspace (map_mx f g) (f a).\nProof. by rewrite map_kermxpoly rmorphXn/= rmorphB /= map_polyX map_polyC. Qed.",
    "Lemma eigenpoly_map n (g : 'M_n) (p : {poly aF}) :\n  eigenpoly (map_mx f g) (map_poly f p) = eigenpoly g p.\nProof. by rewrite /eigenpoly -map_kermxpoly map_mx_eq0. Qed.",
    "Lemma integral_rmorph x :\n  integralOver BtoR x -> integralOver (RtoK \\o BtoR) (RtoK x).\nProof. by case=> p; exists p; rewrite // map_poly_comp rmorph_root. Qed.",
    "Lemma integral_id x : integralOver RtoK (RtoK x).\nProof. by exists ('X - x%:P); rewrite ?monicXsubC ?rmorph_root ?root_XsubC. Qed.",
    "Lemma integral_nat n : integralOver RtoK n%:R.\nProof. by rewrite -(rmorph_nat RtoK); apply: integral_id. Qed.",
    "Lemma integral0 : integralOver RtoK 0. Proof. exact: (integral_nat 0). Qed.",
    "Lemma integral1 : integralOver RtoK 1. Proof. exact: (integral_nat 1). Qed.",
    "Lemma integral_poly (p : {poly K}) :\n  (forall i, integralOver RtoK p`_i) <-> {in p : seq K, integralRange RtoK}.\nProof.\nsplit=> intRp => [_ /(nthP 0)[i _ <-] // | i]; rewrite -[p]coefK coef_poly.\nby case: ifP => [ltip | _]; [apply/intRp/mem_nth | apply: integral0].\nQed.",
    "Lemma integral_horner_root w (p q : {poly K}) :\n    p \\is monic -> root p w ->\n    {in p : seq K, integralRange RtoK} -> {in q : seq K, integralRange RtoK} ->\n  integralOver RtoK q.[w].\nProof.\nmove=> mon_p pw0 intRp intRq.\npose memR y := exists x, y = RtoK x.\nhave memRid x: memR (RtoK x) by exists x.\nhave memR_nat n: memR n%:R by rewrite -(rmorph_nat RtoK) /=.\nhave [memR0 memR1]: memR 0 * memR 1 := (memR_nat 0, memR_nat 1).\nhave memRN1: memR (- 1) by exists (- 1); rewrite rmorphN1.\npose rVin (E : K -> Prop) n (a : 'rV[K]_n) := forall i, E (a 0 i).\npose pXin (E : K -> Prop) (r : {poly K}) := forall i, E r`_i.\npose memM E n (X : 'rV_n) y := exists a, rVin E n a /\\ y = (a *m X^T) 0 0.\npose finM E S := exists n, exists X, forall y, memM E n X y <-> S y.\nhave tensorM E n1 n2 X Y: finM E (memM (memM E n2 Y) n1 X).\n  exists (n1 * n2)%N, (mxvec (X^T *m Y)) => y.\n  split=> [[a [Ea Dy]] | [a1 [/fin_all_exists[a /all_and2[Ea Da1]] ->]]].\n    exists (Y *m (vec_mx a)^T); split=> [i|].\n      exists (row i (vec_mx a)); split=> [j|]; first by rewrite !mxE; apply: Ea.\n      by rewrite -row_mul -{1}[Y]trmxK -trmx_mul !mxE.\n    by rewrite -[Y]trmxK -!trmx_mul mulmxA -mxvec_dotmul trmx_mul trmxK vec_mxK.\n  exists (mxvec (\\matrix_i a i)); split.\n    by case/mxvec_indexP=> i j; rewrite mxvecE mxE; apply: Ea.\n  rewrite -[mxvec _]trmxK -trmx_mul mxvec_dotmul -mulmxA trmx_mul !mxE.\n  apply: eq_bigr => i _; rewrite Da1 !mxE; congr (_ * _).\n  by apply: eq_bigr => j _; rewrite !mxE.\nsuffices [m [X [[u [_ Du]] idealM]]]: exists m,\n  exists X, let M := memM memR m X in M 1 /\\ forall y, M y -> M (q.[w] * y).\n- do [set M := memM _ m X; move: q.[w] => z] in idealM *.\n  have MX i: M (X 0 i).\n    by exists (delta_mx 0 i); split=> [j|]; rewrite -?rowE !mxE.\n  have /fin_all_exists[a /all_and2[Fa Da1]] i := idealM _ (MX i).\n  have /fin_all_exists[r Dr] i := fin_all_exists (Fa i).\n  pose A := \\matrix_(i, j) r j i; pose B := z%:M - map_mx RtoK A.\n  have XB0: X *m B = 0.\n    apply/eqP; rewrite mulmxBr mul_mx_scalar subr_eq0; apply/eqP/rowP=> i.\n    by rewrite !mxE Da1 mxE; apply: eq_bigr=> j _; rewrite !mxE mulrC Dr.\n  exists (char_poly A); first exact: char_poly_monic.\n  have: (\\det B *: (u *m X^T)) 0 0 == 0.\n    rewrite scalemxAr -linearZ -mul_mx_scalar -mul_mx_adj mulmxA XB0 /=.\n    by rewrite mul0mx trmx0 mulmx0 mxE.\n  rewrite mxE -Du mulr1 rootE -horner_evalE -2!det_map_mx; congr (\\det _ == 0).\n  rewrite raddfB/= map_scalar_mx; apply/matrixP=> i j.\n  by rewrite !mxE raddfB raddfMn/= map_polyX map_polyC /horner_eval !hornerE.\npose gen1 x E y := exists2 r, pXin E r & y = r.[x]; pose gen := foldr gen1 memR.\nhave gen1S (E : K -> Prop) x y: E 0 -> E y -> gen1 x E y.\n  by exists y%:P => [i|]; rewrite ?hornerC ?coefC //; case: ifP.\nhave genR S y: memR y -> gen S y.\n  by elim: S => //= x S IH in y * => /IH; apply/gen1S/IH.\nhave gen0 := genR _ 0 memR0; have gen_1 := genR _ 1 memR1.\nhave{gen1S} genS S y: y \\in S -> gen S y.\n  elim: S => //= x S IH /predU1P[-> | /IH//]; last exact: gen1S.\n  by exists 'X => [i|]; rewrite ?hornerX // coefX; apply: genR.\npose propD (R : K -> Prop) := forall x y, R x -> R y -> R (x + y).\nhave memRD: propD memR.\n  by move=> _ _ [a ->] [b ->]; exists (a + b); rewrite rmorphD.\nhave genD S: propD (gen S).\n  elim: S => //= x S IH _ _ [r1 Sr1 ->] [r2 Sr2 ->]; rewrite -hornerD.\n  by exists (r1 + r2) => // i; rewrite coefD; apply: IH.\nhave gen_sum S := big_ind _ (gen0 S) (genD S).\npose propM (R : K -> Prop) := forall x y, R x -> R y -> R (x * y).\nhave memRM: propM memR.\n  by move=> _ _ [a ->] [b ->]; exists (a * b); rewrite rmorphM.\nhave genM S: propM (gen S).\n  elim: S => //= x S IH _ _ [r1 Sr1 ->] [r2 Sr2 ->]; rewrite -hornerM.\n  by exists (r1 * r2) => // i; rewrite coefM; apply: gen_sum => j _; apply: IH.\nhave gen_horner S r y: pXin (gen S) r -> gen S y -> gen S r.[y].\n  move=> Sq Sy; rewrite horner_coef; apply: gen_sum => [[i _] /= _].\n  by elim: {2}i => [|n IHn]; rewrite ?mulr1 // exprSr mulrA; apply: genM.\npose S := w :: q ++ p; suffices [m [X defX]]: finM memR (gen S).\n  exists m, X => M; split=> [|y /defX Xy]; first exact/defX.\n  apply/defX/genM => //; apply: gen_horner => // [i|]; last exact/genS/mem_head.\n  rewrite -[q]coefK coef_poly; case: ifP => // lt_i_q.\n  by apply: genS; rewrite inE mem_cat mem_nth ?orbT.\npose intR R y := exists r, [/\\ r \\is monic, root r y & pXin R r].\npose fix genI s := if s is y :: s1 then intR (gen s1) y /\\ genI s1 else True.\nhave{mon_p pw0 intRp intRq}: genI S.\n  split; set S1 := _ ++ _; first exists p.\n    split=> // i; rewrite -[p]coefK coef_poly; case: ifP => // lt_i_p.\n    by apply: genS; rewrite mem_cat orbC mem_nth.\n  set S2 := S1; have: all [in S1] S2 by apply/allP.\n  elim: S2 => //= y S2 IH /andP[S1y S12]; split; last exact: IH.\n  have{q S S1 IH S1y S12 intRp intRq} [q mon_q qx0]: integralOver RtoK y.\n    by move: S1y; rewrite mem_cat => /orP[]; [apply: intRq | apply: intRp].\n  exists (map_poly RtoK q); split=> // [|i]; first exact: monic_map.\n  by rewrite coef_map /=; apply: genR.\nelim: {w p q}S => /= [_|x S IH [[p [mon_p px0 Sp]] /IH{IH}[m2 [X2 defS]]]].\n  exists 1, 1 => y; split=> [[a [Fa ->]] | Fy].\n    by rewrite tr_scalar_mx mulmx1; apply: Fa.\n  by exists y%:M; split=> [i|]; rewrite 1?ord1 ?tr_scalar_mx ?mulmx1 mxE.\npose m1 := (size p).-1; pose X1 := \\row_(i < m1) x ^+ i.\nhave [m [X defM]] := tensorM memR m1 m2 X1 X2; set M := memM _ _ _ in defM.\nexists m, X => y; rewrite -/M; split=> [/defM[a [M2a]] | [q Sq]] -> {y}.\n  exists (rVpoly a) => [i|].\n    by rewrite coef_rVpoly; case/insub: i => // i; apply/defS/M2a.\n  rewrite mxE (horner_coef_wide _ (size_poly _ _)) -/(rVpoly a).\n  by apply: eq_bigr => i _; rewrite coef_rVpoly_ord !mxE.\nhave M_0: M 0 by exists 0; split=> [i|]; rewrite ?mul0mx mxE.\nhave M_D: propD M.\n  move=> _ _ [a [Fa ->]] [b [Fb ->]]; exists (a + b).\n  by rewrite mulmxDl !mxE; split=> // i /[1!mxE]; apply: memRD.\nhave{M_0 M_D} Msum := big_ind _ M_0 M_D.\nrewrite horner_coef; apply: (Msum) => i _; case: i q`_i {Sq}(Sq i) => /=.\nelim: {q}(size q) => // n IHn i i_le_n y Sy.\nhave [i_lt_m1 | m1_le_i] := ltnP i m1.\n  apply/defM; exists (y *: delta_mx 0 (Ordinal i_lt_m1)); split=> [j|].\n    by apply/defS; rewrite !mxE /= mulr_natr; case: eqP.\n  by rewrite -scalemxAl -rowE !mxE.\nrewrite -(subnK m1_le_i) exprD -[x ^+ m1]subr0 -(rootP px0) horner_coef.\nrewrite polySpred ?monic_neq0 // -/m1 big_ord_recr /= -lead_coefE.\nrewrite opprD addrC (monicP mon_p) mul1r subrK !mulrN -mulNr !mulr_sumr.\napply: Msum => j _; rewrite mulrA mulrACA -exprD; apply: IHn.\n  by rewrite -addnS addnC addnBA // leq_subLR leq_add.\nby rewrite -mulN1r; do 2!apply: (genM) => //; apply: genR.\nQed.",
    "Lemma integral_root_monic u p :\n    p \\is monic -> root p u -> {in p : seq K, integralRange RtoK} ->\n  integralOver RtoK u.\nProof.\nmove=> mon_p pu0 intRp; rewrite -[u]hornerX.\napply: integral_horner_root mon_p pu0 intRp _.\nby apply/integral_poly => i; rewrite coefX; apply: integral_nat.\nQed.",
    "Lemma integral_opp u : integralOver RtoK u -> integralOver RtoK (- u).\nProof. by rewrite -{1}[u]opprK => /intR_XsubC/integral_root_monic; apply. Qed.",
    "Lemma integral_horner (p : {poly K}) u :\n    {in p : seq K, integralRange RtoK} -> integralOver RtoK u ->\n  integralOver RtoK p.[u].\nProof. by move=> ? /integral_opp/intR_XsubC/integral_horner_root; apply. Qed.",
    "Lemma integral_sub u v :\n  integralOver RtoK u -> integralOver RtoK v -> integralOver RtoK (u - v).\nProof.\nmove=> intRu /integral_opp/intR_XsubC/integral_horner/(_ intRu).\nby rewrite !hornerE.\nQed.",
    "Lemma integral_add u v :\n  integralOver RtoK u -> integralOver RtoK v -> integralOver RtoK (u + v).\nProof. by rewrite -{2}[v]opprK => intRu /integral_opp; apply: integral_sub. Qed.",
    "Lemma integral_mul u v :\n  integralOver RtoK u -> integralOver RtoK v -> integralOver RtoK (u * v).\nProof.\nrewrite -{2}[v]hornerX -hornerZ => intRu; apply: integral_horner.\nby apply/integral_poly=> i; rewrite coefZ coefX mulr_natr mulrb; case: ifP.\nQed.",
    "Lemma integral_algebraic u : algebraicOver FtoE u <-> integralOver FtoE u.\nProof.\nsplit=> [] [p p_nz pu0]; last by exists p; rewrite ?monic_neq0.\nexists (mk_mon p); first by rewrite monicE lead_coefZ mulVf ?lead_coef_eq0.\nby rewrite linearZ rootE hornerZ (rootP pu0) mulr0.\nQed.",
    "Lemma algebraic_id a : algebraicOver FtoE (FtoE a).\nProof. exact/integral_algebraic/integral_id. Qed.",
    "Lemma algebraic0 : algebraicOver FtoE 0.\nProof. exact/integral_algebraic/integral0. Qed.",
    "Lemma algebraic1 : algebraicOver FtoE 1.\nProof. exact/integral_algebraic/integral1. Qed.",
    "Lemma algebraic_opp x : algebraicOver FtoE x -> algebraicOver FtoE (- x).\nProof. by move/integral_algebraic/integral_opp/integral_algebraic. Qed.",
    "Lemma algebraic_add x y :\n  algebraicOver FtoE x -> algebraicOver FtoE y -> algebraicOver FtoE (x + y).\nProof.\nmove/integral_algebraic=> intFx /integral_algebraic intFy.\nexact/integral_algebraic/integral_add.\nQed.",
    "Lemma algebraic_sub x y :\n  algebraicOver FtoE x -> algebraicOver FtoE y -> algebraicOver FtoE (x - y).\nProof. by move=> algFx /algebraic_opp; apply: algebraic_add. Qed.",
    "Lemma algebraic_mul x y :\n  algebraicOver FtoE x -> algebraicOver FtoE y -> algebraicOver FtoE (x * y).\nProof.\nmove/integral_algebraic=> intFx /integral_algebraic intFy.\nexact/integral_algebraic/integral_mul.\nQed.",
    "Lemma algebraic_inv u : algebraicOver FtoE u -> algebraicOver FtoE u^-1.\nProof.\nhave [-> | /expf_neq0 nz_u_n] := eqVneq u 0; first by rewrite invr0.\ncase=> p nz_p pu0; exists (Poly (rev p)).\n  apply/eqP=> /polyP/(_ 0); rewrite coef_Poly coef0 nth_rev ?size_poly_gt0 //.\n  by apply/eqP; rewrite subn1 lead_coef_eq0.\napply/eqP/(mulfI (nz_u_n (size p).-1)); rewrite mulr0 -(rootP pu0).\nrewrite (@horner_coef_wide _ (size p)); last first.\n  by rewrite size_map_poly -(size_rev p) size_Poly.\nrewrite horner_coef mulr_sumr size_map_poly.\nrewrite [rhs in _ = rhs](reindex_inj rev_ord_inj) /=.\napply: eq_bigr => i _; rewrite !coef_map coef_Poly nth_rev // mulrCA.\nby congr (_ * _); rewrite -{1}(subnKC (valP i)) addSn addnC exprD exprVn ?mulfK.\nQed.",
    "Lemma algebraic_div x y :\n  algebraicOver FtoE x -> algebraicOver FtoE y -> algebraicOver FtoE (x / y).\nProof. by move=> algFx /algebraic_inv; apply: algebraic_mul. Qed.",
    "Lemma integral_inv x : integralOver FtoE x -> integralOver FtoE x^-1.\nProof. by move/integral_algebraic/algebraic_inv/integral_algebraic. Qed.",
    "Lemma integral_div x y :\n  integralOver FtoE x -> integralOver FtoE y -> integralOver FtoE (x / y).\nProof. by move=> algFx /integral_inv; apply: integral_mul. Qed.",
    "Lemma integral_root p u :\n    p != 0 -> root p u -> {in p : seq E, integralRange FtoE} ->\n  integralOver FtoE u.\nProof.\nmove=> nz_p pu0 algFp.\nhave mon_p1: mk_mon p \\is monic.\n  by rewrite monicE lead_coefZ mulVf ?lead_coef_eq0.\nhave p1u0: root (mk_mon p) u by rewrite rootE hornerZ (rootP pu0) mulr0.\napply: integral_root_monic mon_p1 p1u0 _ => _ /(nthP 0)[i ltip <-].\nrewrite coefZ mulrC; rewrite size_scale ?invr_eq0 ?lead_coef_eq0 // in ltip.\nby apply: integral_div; apply/algFp/mem_nth; rewrite -?polySpred.\nQed.",
    "Lemma eval_mx_term e m n (A : 'M_(m, n)) : eval_mx e (mx_term A) = A.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma eval_mulmx e m n p (A : 'M[term]_(m, n)) (B : 'M_(n, p)) :\n  eval_mx e (mulmx_term A B) = eval_mx e A *m eval_mx e B.\nProof.\napply/matrixP=> i k; rewrite !mxE /= ((big_morph (eval e)) 0 +%R) //=.\nby apply: eq_bigr => j _; rewrite /= !mxE.\nQed.",
    "Lemma mxrank_form_qf r m n (A : 'M_(m, n)) : qf_form (mxrank_form r A).\nProof.\nby elim: m r n A => [|m IHm] r [|n] A //=; rewrite GRing.Pick_form_qf /=.\nQed.",
    "Lemma eval_mxrank e r m n (A : 'M_(m, n)) :\n  qf_eval e (mxrank_form r A) = (\\rank (eval_mx e A) == r).\nProof.\nelim: m r n A => [|m IHm] r [|n] A /=; try by case r; rewrite unlock.\nrewrite GRing.eval_Pick !unlock /=; set pf := fun _ => _.\nrewrite -(@eq_pick _ pf) => [|k]; rewrite {}/pf ?mxE // eq_sym.\ncase: pick => [[i j]|] //=; set B := _ - _; have:= mxrankE B.\ncase: (Gaussian_elimination_ B) r => [[_ _] _] [|r] //= <-; rewrite {}IHm eqSS.\nby congr (\\rank _ == r); apply/matrixP=> k l; rewrite !(mxE, big_ord1) !tpermR.\nQed.",
    "Lemma eval_vec_mx e m n (u : 'rV_(m * n)) :\n  eval_mx e (vec_mx u) = vec_mx (eval_mx e u).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma eval_mxvec e m n (A : 'M_(m, n)) :\n  eval_mx e (mxvec A) = mxvec (eval_mx e A).\nProof. by rewrite -{2}[A]mxvecK eval_vec_mx vec_mxK. Qed.",
    "Lemma eval_col_mx e :\n  eval_mx e (col_mx A B) = col_mx (eval_mx e A) (eval_mx e B).\nProof. by apply/matrixP=> i j; do 2![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma submx_form_qf : qf_form submx_form.\nProof.\nby rewrite (morphAnd (@qf_form _)) ?big1 //= => r _; rewrite !mxrank_form_qf.\nQed.",
    "Lemma eval_submx e : qf_eval e submx_form = (eval_mx e A <= eval_mx e B)%MS.\nProof.\nrewrite (morphAnd (qf_eval e)) //= big_andE /=.\napply/forallP/idP=> /= [|sAB d]; last first.\n  rewrite !eval_mxrank eval_col_mx -addsmxE; apply/implyP=> /eqP <-.\n  by rewrite mxrank_leqif_sup ?addsmxSr // addsmx_sub sAB /=.\nmove/(_ (inord (\\rank (eval_mx e (col_mx A B))))).\nrewrite inordK ?ltnS ?rank_leq_col // !eval_mxrank eqxx /= eval_col_mx.\nby rewrite -addsmxE mxrank_leqif_sup ?addsmxSr // addsmx_sub; case/andP.\nQed.",
    "Lemma size_seq_of_rV v : size (seq_of_rV v) = d.\nProof. by rewrite tuple.size_tuple card_ord. Qed.",
    "Lemma nth_seq_of_rV x0 v (i : 'I_d) : nth x0 (seq_of_rV v) i = v 0 i.\nProof. by rewrite nth_fgraph_ord ffunE. Qed.",
    "Lemma nth_row_env e k (i : 'I_d) : (row_env e)`_(k * d + i) = e`_k 0 i.\nProof.\nelim: e k => [|v e IHe] k; first by rewrite !nth_nil mxE.\nrewrite /row_env /= nth_cat size_seq_of_rV.\ncase: k => [|k]; first by rewrite (valP i) nth_seq_of_rV.\nby rewrite mulSn -addnA -if_neg -leqNgt leq_addr addKn IHe.\nQed.",
    "Lemma eval_row_var e k : eval_mx (row_env e) (row_var k) = e`_k :> 'rV_d.\nProof. by apply/rowP=> i; rewrite !mxE /= nth_row_env. Qed.",
    "Lemma Exists_rowP e k f :\n  d > 0 ->\n   ((exists v : 'rV[F]_d, holds (row_env (set_nth 0 e k v)) f)\n      <-> holds (row_env e) (Exists_row_form k f)).\nProof.\nmove=> d_gt0; pose i_ j := Ordinal (ltn_pmod j d_gt0).\nhave d_eq j: (j = j %/ d * d + i_ j)%N := divn_eq j d.\nsplit=> [[v f_v] | ]; last case/GRing.foldExistsP=> e' ee' f_e'.\n  apply/GRing.foldExistsP; exists (row_env (set_nth 0 e k v)) => {f f_v}// j.\n  rewrite [j]d_eq !nth_row_env nth_set_nth /=; case: eqP => // ->.\n  by case/imageP; exists (i_ j).\nexists (\\row_i e'`_(k * d + i)); apply: eq_holds f_e' => j /=.\nmove/(_ j): ee'; rewrite [j]d_eq !nth_row_env nth_set_nth /=.\ncase: eqP => [-> | ne_j_k -> //]; first by rewrite mxE.\napply/mapP=> [[r lt_r_d]]; rewrite -d_eq => def_j; case: ne_j_k.\nby rewrite def_j divnMDl // divn_small ?addn0.\nQed.",
    "Lemma stablemx_comp (m n p : nat) (V : 'M[F]_(m, n)) (W : 'M_(n, p)) (f : 'M_p) :\n  stablemx W f -> stablemx V (conjmx W f) -> stablemx (V *m W) f.\nProof. by move=> Wf /(submxMr W); rewrite -mulmxA mulmxKpV// mulmxA. Qed.",
    "Lemma stablemx_restrict m n (A : 'M[F]_n) (V : 'M_n) (W : 'M_(m, \\rank V)):\n  stablemx V A -> stablemx W (restrictmx V A) = stablemx (W *m row_base V) A.\nProof.\nmove=> A_stabV; rewrite mulmxA -[in RHS]mulmxA.\nrewrite -(submxMfree _ W (row_base_free V)) mulmxKpV //.\nby rewrite mulmx_sub ?stablemx_row_base.\nQed.",
    "Lemma conjmxM (m n : nat) (V : 'M[F]_(m, n)) :\n   {in [pred f | stablemx V f] &, {morph conjmx V : f g / f *m g}}.\nProof.\nmove=> f g; rewrite !inE => Vf Vg /=.\nby rewrite /conjmx 2!mulmxA mulmxA mulmxKpV ?stablemx_row_base.\nQed.",
    "Lemma conjMmx (m n p : nat) (V : 'M[F]_(m, n)) (W : 'M_(n, p)) (f : 'M_p) :\n  row_free (V *m W) -> stablemx W f -> stablemx V (conjmx W f) ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> rfVW Wf VWf; apply: (row_free_inj rfVW); rewrite mulmxKpV ?stablemx_comp//.\nby rewrite mulmxA mulmxKpV// -[RHS]mulmxA mulmxKpV ?mulmxA.\nQed.",
    "Lemma conjuMmx (m n : nat) (V : 'M[F]_m) (W : 'M_(m, n)) (f : 'M_n) :\n  V \\in unitmx -> row_free W -> stablemx W f ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> Vu rfW Wf; rewrite conjMmx ?stablemx_unit//.\nby rewrite /row_free mxrankMfree// -/(row_free V) row_free_unit.\nQed.",
    "Lemma conjMumx (m n : nat) (V : 'M[F]_(m, n)) (W f : 'M_n) :\n  W \\in unitmx -> row_free V -> stablemx V (conjmx W f) ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> Wu rfW Wf; rewrite conjMmx ?stablemx_unit//.\nby rewrite /row_free mxrankMfree ?row_free_unit.\nQed.",
    "Lemma conjuMumx (n : nat) (V W f : 'M[F]_n) :\n  V \\in unitmx -> W \\in unitmx ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof. by move=> Vu Wu; rewrite conjuMmx ?stablemx_unit ?row_free_unit. Qed.",
    "Lemma conjmx_scalar (m n : nat) (V : 'M[F]_(m, n)) (a : F) :\n  row_free V -> conjmx V a%:M = a%:M.\nProof. by move=> rfV; rewrite /conjmx scalar_mxC mulmxKp. Qed.",
    "Lemma conj0mx (m n : nat) f : conjmx (0 : 'M[F]_(m, n)) f = 0.\nProof. by rewrite /conjmx !mul0mx. Qed.",
    "Lemma conjmx0 (m n : nat) (V : 'M[F]_(m, n)) : conjmx V 0 = 0.\nProof. by rewrite /conjmx mulmx0 mul0mx. Qed.",
    "Lemma conjumx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx V f = V *m f *m invmx V.\nProof. by move=> uV; rewrite /conjmx pinvmxE. Qed.",
    "Lemma conj1mx (n : nat) (f : 'M[F]_n) : conjmx 1%:M f = f.\nProof. by rewrite conjumx ?unitmx1// invmx1 mulmx1 mul1mx. Qed.",
    "Lemma conjVmx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx (invmx V) f = invmx V *m f *m V.\nProof. by move=> Vunit; rewrite conjumx ?invmxK ?unitmx_inv. Qed.",
    "Lemma conjmxK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx (invmx V) (conjmx V f) = f.\nProof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulVmx ?conj1mx. Qed.",
    "Lemma conjmxVK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx V (conjmx (invmx V) f) = f.\nProof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulmxV ?conj1mx. Qed.",
    "Lemma horner_mx_conj m n p (V : 'M[F]_(n.+1, m.+1)) (f : 'M_m.+1) :\n   row_free V -> stablemx V f ->\n   horner_mx (conjmx V f) p = conjmx V (horner_mx f p).\nProof.\nmove=> V_free V_stab; rewrite/conjmx; elim/poly_ind: p => [|p c].\n  by rewrite !rmorph0 mulmx0 mul0mx.\nrewrite !(rmorphD, rmorphM)/= !(horner_mx_X, horner_mx_C) => ->.\nrewrite [_ * _]mulmxA [_ *m (V *m _)]mulmxA mulmxKpV ?horner_mx_stable//.\napply: (row_free_inj V_free); rewrite [_ *m V]mulmxDl.\npose stablemxE := (stablemxD, stablemxM, stablemxC, horner_mx_stable).\nby rewrite !mulmxKpV -?[V *m _ *m _]mulmxA ?stablemxE// mulmxDr -scalar_mxC.\nQed.",
    "Lemma horner_mx_uconj n p (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n   V \\is a GRing.unit ->\n   horner_mx (V *m f *m invmx V) p = V *m horner_mx f p *m invmx V.\nProof.\nmove=> V_unit; rewrite -!conjumx//.\nby rewrite horner_mx_conj ?row_free_unit ?stablemx_unit.\nQed.",
    "Lemma horner_mx_uconjC n p (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n   V \\is a GRing.unit ->\n   horner_mx (invmx V *m f *m V) p = invmx V *m horner_mx f p *m V.\nProof.\nmove=> V_unit; rewrite -[X in _ *m X](invmxK V).\nby rewrite horner_mx_uconj ?invmxK ?unitmx_inv.\nQed.",
    "Lemma mxminpoly_conj m n (V : 'M[F]_(m.+1, n.+1)) (f : 'M_n.+1) :\n  row_free V -> stablemx V f -> mxminpoly (conjmx V f) %| mxminpoly f.\nProof.\nby move=> *; rewrite mxminpoly_min// horner_mx_conj// mx_root_minpoly conjmx0.\nQed.",
    "Lemma mxminpoly_uconj n (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n  V \\in unitmx -> mxminpoly (conjmx V f) = mxminpoly f.\nProof.\nhave simp := (row_free_unit, stablemx_unit, unitmx_inv, unitmx1).\nmove=> Vu; apply/eqP; rewrite -eqp_monic ?mxminpoly_monic// /eqp.\napply/andP; split; first by rewrite mxminpoly_conj ?simp.\nby rewrite -[f in X in X %| _](conjmxK _ Vu) mxminpoly_conj ?simp.\nQed.",
    "Lemma sub_kermxpoly_conjmx V f p W : stablemx V f -> row_free V ->\n  (W <= kermxpoly (conjmx V f) p)%MS = (W *m V <= kermxpoly f p)%MS.\nProof.\ncase: n m => [|n'] [|m'] in V f W * => fV rfV; rewrite ?thinmx0//.\n  by rewrite /row_free mxrank.unlock in rfV.\n  by rewrite mul0mx !sub0mx.\napply/sub_kermxP/sub_kermxP; rewrite horner_mx_conj//; last first.\n  by move=> /(congr1 (mulmxr (pinvmx V)))/=; rewrite mul0mx !mulmxA.\nmove=> /(congr1 (mulmxr V))/=; rewrite ![W *m _]mulmxA ?mul0mx mulmxKpV//.\nby rewrite -mulmxA mulmx_sub// horner_mx_stable//.\nQed.",
    "Lemma sub_eigenspace_conjmx V f a W : stablemx V f -> row_free V ->\n  (W <= eigenspace (conjmx V f) a)%MS = (W *m V <= eigenspace f a)%MS.\nProof. by move=> fV rfV; rewrite !eigenspace_poly sub_kermxpoly_conjmx. Qed.",
    "Lemma eigenpoly_conjmx V f : stablemx V f -> row_free V ->\n  {subset eigenpoly (conjmx V f) <= eigenpoly f}.\nProof.\nmove=> fV rfV a /eigenpolyP [x]; rewrite sub_kermxpoly_conjmx//.\nmove=> xV_le_fa x_neq0; apply/eigenpolyP.\nby exists (x *m V); rewrite ?mulmx_free_eq0.\nQed.",
    "Lemma eigenvalue_conjmx V f : stablemx V f -> row_free V ->\n  {subset eigenvalue (conjmx V f) <= eigenvalue f}.\nProof.\nby move=> fV rfV a; rewrite ![_ \\in _]eigenvalue_poly; apply: eigenpoly_conjmx.\nQed.",
    "Lemma conjmx_eigenvalue a V f : (V <= eigenspace f a)%MS -> row_free V ->\n  conjmx V f = a%:M.\nProof.\nby move=> /eigenspaceP Vfa rfV; rewrite /conjmx Vfa -mul_scalar_mx mulmxKp.\nQed.",
    "Lemma simmxPp m n {P : 'M[F]_(m, n)} {A B} :\n  stablemx P A -> A ~_P B -> P *m A = B *m P.\nProof. by move=> stablemxPA /eqP <-; rewrite mulmxKpV. Qed.",
    "Lemma simmxW m n {P : 'M[F]_(m, n)} {A B} : row_free P ->\n  P *m A = B *m P -> A ~_P B.\nProof. by rewrite /(_ ~__ _)/= /conjmx => fP ->; rewrite mulmxKp. Qed.",
    "Lemma simmxP {P A B} : P \\in unitmx ->\n  reflect (P *m A = B *m P) (A ~_P B).\nProof.\nmove=> p_unit; apply: (iffP idP); first exact/simmxPp/stablemx_unit.\nby apply: simmxW; rewrite row_free_unit.\nQed.",
    "Lemma simmxRL {P A B} : P \\in unitmx ->\n  reflect (B = P *m A *m invmx P) (A ~_P B).\nProof. by move=> ?; apply: (iffP eqP); rewrite conjumx. Qed.",
    "Lemma simmxLR {P A B} : P \\in unitmx ->\n  reflect (A = conjmx (invmx P) B) (A ~_P B).\nProof.\nby move=> Pu; rewrite conjVmx//; apply: (iffP (simmxRL Pu)) => ->;\n   rewrite !mulmxA ?(mulmxK, mulmxKV, mulVmx, mulmxV, mul1mx, mulmx1).\nQed.",
    "Lemma simmx_minpoly {n} {P A B : 'M[F]_n.+1} : P \\in unitmx ->\n  A ~_P B -> mxminpoly A = mxminpoly B.\nProof. by move=> Pu /eqP<-; rewrite mxminpoly_uconj. Qed.",
    "Lemma diagonalizable_for_row_base m n (P : 'M[F]_(m, n)) (A : 'M_n) :\n  diagonalizable_for (row_base P) A = is_diag_mx (restrictmx P A).\nProof. by []. Qed.",
    "Lemma diagonalizable_forPp m n (P : 'M[F]_(m, n)) A :\n  reflect (forall i j : 'I__, i != j :> nat -> conjmx P A i j = 0)\n          (diagonalizable_for P A).\nProof. exact: @is_diag_mxP. Qed.",
    "Lemma diagonalizable_forP n (P : 'M[F]_n) A : P \\in unitmx ->\n  reflect (forall i j : 'I__, i != j :> nat -> (P *m A *m invmx P) i j = 0)\n          (diagonalizable_for P A).\nProof. by move=> Pu; rewrite -conjumx//; exact: is_diag_mxP. Qed.",
    "Lemma diagonalizable_forPex {m} {n} {P : 'M[F]_(m, n)} {A} :\n  reflect (exists D, A ~_P (diag_mx D)) (diagonalizable_for P A).\nProof. by apply: (iffP (diag_mxP _)) => -[D]/eqP; exists D. Qed.",
    "Lemma diagonalizable_forLR n {P : 'M[F]_n} {A} : P \\in unitmx ->\n  reflect (exists D, A = conjmx (invmx P) (diag_mx D)) (diagonalizable_for P A).\nProof.\nby move=> Punit; apply: (iffP diagonalizable_forPex) => -[D /(simmxLR Punit)]; exists D.\nQed.",
    "Lemma diagonalizable_for_mxminpoly {n} {P A : 'M[F]_n.+1}\n  (rs := undup [seq conjmx P A i i | i <- enum 'I_n.+1]) :\n  P \\in unitmx -> diagonalizable_for P A ->\n  mxminpoly A = \\prod_(r <- rs) ('X - r%:P).\nProof.\nrewrite /rs => pu /(diagonalizable_forLR pu)[d {A rs}->].\nrewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\nby rewrite [in X in _ = X](@eq_map _ _ _ (d 0))// => i; rewrite conjmxVK// mxE eqxx.\nQed.",
    "Lemma diagonalizable_for_sum (F : fieldType) (m n : nat) (p_ : 'I_n -> nat)\n      (V_ : forall i, 'M[F]_(p_ i, m)) (A : 'M[F]_m) :\n    mxdirect (\\sum_i <<V_ i>>) ->\n    (forall i, stablemx (V_ i) A) ->\n    (forall i, row_free (V_ i)) ->\n  diagonalizable_for (\\mxcol_i V_ i) A = [forall i, diagonalizable_for (V_ i) A].\nProof.\nmove=> Vd VA rAV; have aVA : stablemx (\\mxcol_i V_ i) A.\n  rewrite (eqmx_stable _ (eqmx_col _)) stablemx_sums//.\n  by move=> i; rewrite (eqmx_stable _ (genmxE _)).\napply/diagonalizable_forPex/'forall_diagonalizable_forPex => /=\n    [[D /(simmxPp aVA) +] i|/(_ _)/sigW DoA].\n  rewrite mxcol_mul -[D]submxrowK diag_mxrow mul_mxdiag_mxcol.\n  move=> /eq_mxcolP/(_ i); set D0 := (submxrow _ _) => VMeq.\n  by exists D0; apply/simmxW.\nexists (\\mxrow_i tag (DoA i)); apply/simmxW.\n   rewrite -row_leq_rank eqmx_col (mxdirectP Vd)/=.\n   by under [leqRHS]eq_bigr do rewrite genmxE (eqP (rAV _)).\nrewrite mxcol_mul diag_mxrow mul_mxdiag_mxcol; apply: eq_mxcol => i.\nby case: DoA => /= k /(simmxPp); rewrite VA => /(_ isT) ->.\nQed.",
    "Lemma codiagonalizable1 n (A : 'M[F]_n) :\n  codiagonalizable [:: A] <-> diagonalizable A.\nProof. by split=> -[P Punit PA]; exists P; move: PA; rewrite //= andbT. Qed.",
    "Lemma codiagonalizable_on m n (V_ : 'I_n -> 'M[F]_m) (As : seq 'M[F]_m) :\n    (\\sum_i V_ i :=: 1%:M)%MS -> mxdirect (\\sum_i V_ i) ->\n    (forall i, all (fun A => stablemx (V_ i) A) As) ->\n    (forall i, codiagonalizable (map (restrictmx (V_ i)) As)) ->\n  codiagonalizable As.\nProof.\nmove=> V1 Vdirect /(_ _)/allP AV /(_ _) /sig2W/= Pof.\npose P_ i := tag (Pof i).\nhave P_unit i : P_ i \\in unitmx by rewrite /P_; case: {+}Pof.\nhave P_diag i A : A \\in As -> diagonalizable_for (P_ i *m row_base (V_ i)) A.\n  move=> AAs; rewrite /P_; case: {+}Pof => /= P Punit.\n  rewrite all_map => /allP/(_ A AAs); rewrite /= !/(diagonalizable_for _ _).\n  by rewrite conjuMmx ?row_base_free ?stablemx_row_base ?AV.\npose P := \\mxcol_i (P_ i *m row_base (V_ i)).\nhave P_full i : row_full (P_ i) by rewrite row_full_unit.\nhave PrV i : (P_ i *m row_base (V_ i) :=: V_ i)%MS.\n  exact/(eqmx_trans _ (eq_row_base _))/eqmxMfull.\napply/codiagonalizablePfull; eexists _; last exists P; rewrite /=.\n- rewrite -sub1mx eqmx_col.\n  by under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\napply/allP => A AAs /=; rewrite diagonalizable_for_sum.\n- by apply/forallP => i; apply: P_diag.\n- rewrite mxdirectE/=.\n  under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\n  by under eq_bigr do rewrite genmxE PrV; rewrite  -(mxdirectP Vdirect)//= V1.\n- by move=> i; rewrite (eqmx_stable _ (PrV _)) ?AV.\n- by move=> i; rewrite /row_free eqmxMfull ?eq_row_base ?row_full_unit.\nQed.",
    "Lemma diagonalizable_diag {n} (d : 'rV[F]_n) : diagonalizable (diag_mx d).\nProof.\nexists 1%:M; rewrite ?unitmx1// /(diagonalizable_for _ _).\nby rewrite conj1mx diag_mx_is_diag.\nQed.",
    "Lemma diagonalizable_scalar {n} (a : F) : diagonalizable (a%:M : 'M_n).\nProof. by rewrite -diag_const_mx. Qed.",
    "Lemma diagonalizable0 {n} : diagonalizable (0 : 'M[F]_n).\nProof.\nby rewrite (_ : 0 = 0%:M)//; apply/matrixP => i j; rewrite !mxE// mul0rn.\nQed.",
    "Lemma diagonalizablePeigen {n} {A : 'M[F]_n} :\n  diagonalizable A <->\n  exists2 rs, uniq rs & (\\sum_(r <- rs) eigenspace A r :=: 1%:M)%MS.\nProof.\nsplit=> [df|[rs urs rsP]].\n  suff [rs rsP] : exists rs, (\\sum_(r <- rs) eigenspace A r :=: 1%:M)%MS.\n    exists (undup rs); rewrite ?undup_uniq//; apply: eqmx_trans rsP.\n    elim: rs => //= r rs IHrs; rewrite big_cons.\n    case: ifPn => in_rs; rewrite ?big_cons; last exact: adds_eqmx.\n    apply/(eqmx_trans IHrs)/eqmx_sym/addsmx_idPr.\n    have rrs : (index r rs < size rs)%N by rewrite index_mem.\n    rewrite (big_nth 0) big_mkord (sumsmx_sup (Ordinal rrs)) ?nth_index//.\n  move: df => [P Punit /(diagonalizable_forLR Punit)[d ->]].\n  exists [seq d 0 i | i <- enum 'I_n]; rewrite big_image/=.\n  apply: (@eqmx_trans _ _ _ _ _ _ P); apply/eqmxP;\n    rewrite ?sub1mx ?submx1 ?row_full_unit//.\n  rewrite submx_full ?row_full_unit//=.\n  apply/row_subP => i; rewrite rowE (sumsmx_sup i)//.\n  apply/eigenspaceP; rewrite conjVmx// !mulmxA mulmxK//.\n  by rewrite -rowE row_diag_mx scalemxAl.\nhave mxdirect_eigenspaces : mxdirect (\\sum_(i < size rs) eigenspace A rs`_i).\n  apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\nrewrite (big_nth 0) big_mkord in rsP; apply/codiagonalizable1.\napply/(codiagonalizable_on _ mxdirect_eigenspaces) => // i/=.\n  case: n => [|n] in A {mxdirect_eigenspaces} rsP *.\n    by rewrite thinmx0 sub0mx.\n  by rewrite comm_mx_stable_eigenspace.\napply/codiagonalizable1.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i); first exact: diagonalizable_scalar.\n  by rewrite eq_row_base.\nby rewrite row_base_free.\nQed.",
    "Lemma diagonalizableP n' (n := n'.+1) (A : 'M[F]_n) :\n  diagonalizable A <->\n  exists2 rs, uniq rs & mxminpoly A %| \\prod_(x <- rs) ('X - x%:P).\nProof.\nsplit=> [[P Punit /diagonalizable_forPex[d /(simmxLR Punit)->]]|].\n  rewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\n  by eexists; [|by []]; rewrite undup_uniq.\nmove=> + /ltac:(apply/diagonalizablePeigen) => -[rs rsu rsP]; exists rs => //.\nrewrite (big_nth 0) [X in (X :=: _)%MS](big_nth 0) !big_mkord in rsP *.\nrewrite (eq_bigr _ (fun _ _ => eigenspace_poly _ _)).\napply: (eqmx_trans (eqmx_sym (kermxpoly_prod _ _)) (kermxpoly_min _)) => //.\nby move=> i j _ _; rewrite coprimep_XsubC root_XsubC nth_uniq.\nQed.",
    "Lemma diagonalizable_conj_diag m n (V : 'M[F]_(m, n)) (d : 'rV[F]_n) :\n  stablemx V (diag_mx d) -> row_free V -> diagonalizable (conjmx V (diag_mx d)).\nProof.\ncase: m n => [|m] [|n] in V d * => Vd rdV; rewrite ?thinmx0.\n- by [].\n- by [].\n- by exfalso; move: rdV; rewrite /row_free mxrank.unlock eqxx orbT.\napply/diagonalizableP; pose u := undup [seq d 0 i | i <- enum 'I_n.+1].\nexists u; first by rewrite undup_uniq.\nby rewrite (dvdp_trans (mxminpoly_conj (f:=diag_mx d) _ _))// mxminpoly_diag.\nQed.",
    "Lemma codiagonalizableP n (As : seq 'M[F]_n) :\n  {in As &, forall A B, comm_mx A B} /\\ {in As, forall A, diagonalizable A}\n  <-> codiagonalizable As.\nProof.\nsplit => [cdAs|[P Punit /allP/= AsD]]/=; last first.\n  split; last by exists P; rewrite // AsD.\n  move=> A B AAs BAs; move=> /(_ _ _)/diagonalizable_forPex/sigW in AsD.\n  have [[dA /simmxLR->//] [dB /simmxLR->//]] := (AsD _ AAs, AsD _ BAs).\n  by rewrite /comm_mx -!conjmxM 1?diag_mxC// inE stablemx_unit ?unitmx_inv.\nmove: cdAs => -[]; move/(rwP (all_comm_mxP _)) => cdAs cdAs'.\nhave [k] := ubnP (size As); elim: k => [|k IHk]//= in n As cdAs cdAs' *.\ncase: As cdAs cdAs' => [|A As]//=; first by exists 1%:M; rewrite ?unitmx1.\nrewrite ltnS all_comm_mx_cons => /andP[/allP/(_ _ _)/eqP AAsC AsC dAAs] Ask.\nhave /diagonalizablePeigen [rs urs rs1] := dAAs _ (mem_head _ _).\nrewrite (big_nth 0) big_mkord in rs1.\nhave eAB (i : 'I_(size rs)) B : B \\in A :: As -> stablemx (eigenspace A rs`_i) B.\n   case: n => [|n'] in B A As AAsC AsC {dAAs rs1 Ask} * => B_AAs.\n      by rewrite thinmx0 sub0mx.\n  rewrite comm_mx_stable_eigenspace//.\n  by move: B_AAs; rewrite !inE => /predU1P [->//|/AAsC].\napply/(@codiagonalizable_on _ _ _ (_ :: _) rs1) => [|i|i /=].\n- apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\n- by apply/allP => B B_AAs; rewrite eAB.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free//.\nset Bs := map _ _; suff [P Punit /= PBs] : codiagonalizable Bs.\n  exists P; rewrite /= ?PBs ?andbT// /(diagonalizable_for _ _).\n  by rewrite conjmx_scalar ?mx_scalar_is_diag// row_free_unit.\napply: IHk; rewrite ?size_map/= ?ltnS//.\n  apply/all_comm_mxP => _ _ /mapP[/= B BAs ->] /mapP[/= h hAs ->].\n  rewrite -!conjmxM ?inE ?stablemx_row_base ?eAB ?inE ?BAs ?hAs ?orbT//.\n  by rewrite (all_comm_mxP _ AsC).\nmove=> _ /mapP[/= B BAs ->].\nhave: stablemx (row_base (eigenspace A rs`_i)) B.\n  by rewrite stablemx_row_base eAB// inE BAs orbT.\nhave := dAAs B; rewrite inE BAs orbT => /(_ isT) [P Punit].\nmove=> /diagonalizable_forPex[D /(simmxLR Punit)->] sePD.\nhave rAeP : row_free (row_base (eigenspace A rs`_i) *m invmx P).\n  by rewrite /row_free mxrankMfree ?row_free_unit ?unitmx_inv// eq_row_base.\nrewrite -conjMumx ?unitmx_inv ?row_base_free => [|//|//|//].\napply/diagonalizable_conj_diag => //.\nby rewrite stablemx_comp// stablemx_unit ?unitmx_inv.\nQed.",
    "Lemma r2vK : cancel r2v v2r.   Proof. exact: svalP r2v_subproof. Qed.",
    "Lemma r2v_inj : injective r2v. Proof. exact: can_inj r2vK. Qed.",
    "Lemma v2rK : cancel v2r r2v.   Proof. by have/bij_can_sym:= r2vK; apply. Qed.",
    "Lemma v2r_inj : injective v2r. Proof. exact: can_inj v2rK. Qed.",
    "Lemma b2mxK n (X : n.-tuple vT) i : r2v (row i (b2mx X)) = X`_i.\nProof. by rewrite rowK v2rK -tnth_nth. Qed.",
    "Lemma gen_vs2mx (U : {vspace vT}) : <<vs2mx U>>%MS = vs2mx U.\nProof. by apply/eqP; rewrite /vs2mx; case: U. Qed.",
    "Lemma vs2mxK : cancel vs2mx mx2vs.\nProof. by move=> v; apply: val_inj; rewrite /= gen_vs2mx. Qed.",
    "Lemma mx2vsK m (M : 'M_(m, vT)) : (vs2mx (mx2vs M) :=: M)%MS.\nProof. exact: genmxE. Qed.",
    "Lemma memvE v U : (v \\in U) = (<[v]> <= U)%VS. Proof. by []. Qed.",
    "Lemma vlineP v1 v2 : reflect (exists k, v1 = k *: v2) (v1 \\in <[v2]>)%VS.\nProof.\napply: (iffP idP) => [|[k ->]]; rewrite memvK genmxE ?linearZ ?scalemx_sub //.\nby case/sub_rVP=> k; rewrite -linearZ => /v2r_inj->; exists k.\nQed.",
    "Lemma mem0v U : 0 \\in U. Proof. exact: rpred0. Qed.",
    "Lemma memvN U v : (- v \\in U) = (v \\in U). Proof. exact: rpredN. Qed.",
    "Lemma memvD U : {in U &, forall u v, u + v \\in U}. Proof. exact: rpredD. Qed.",
    "Lemma memvB U : {in U &, forall u v, u - v \\in U}. Proof. exact: rpredB. Qed.",
    "Lemma memvZ U k : {in U, forall v, k *: v \\in U}. Proof. exact: rpredZ. Qed.",
    "Lemma memv_suml I r (P : pred I) vs U :\n  (forall i, P i -> vs i \\in U) -> \\sum_(i <- r | P i) vs i \\in U.\nProof. exact: rpred_sum. Qed.",
    "Lemma memv_line u : u \\in <[u]>%VS.\nProof. by apply/vlineP; exists 1; rewrite scale1r. Qed.",
    "Lemma subvP U V : reflect {subset U <= V} (U <= V)%VS.\nProof.\napply: (iffP rV_subP) => sU12 u.\n  by rewrite !memvE /subsetv !genmxE => /sU12.\nby have:= sU12 (r2v u); rewrite !memvE /subsetv !genmxE r2vK.\nQed.",
    "Lemma subvv U : (U <= U)%VS. Proof. exact/subvP. Qed.",
    "Lemma subv_trans : transitive subV.\nProof. by move=> U V W /subvP sUV /subvP sVW; apply/subvP=> u /sUV/sVW. Qed.",
    "Lemma subv_anti : antisymmetric subV.\nProof. by move=> U V; apply/vs2mxP. Qed.",
    "Lemma eqEsubv U V : (U == V) = (U <= V <= U)%VS.\nProof. by apply/eqP/idP=> [-> | /subv_anti//]; rewrite subvv. Qed.",
    "Lemma vspaceP U V : U =i V <-> U = V.\nProof.\nsplit=> [eqUV | -> //]; apply/subv_anti/andP.\nby split; apply/subvP=> v; rewrite eqUV.\nQed.",
    "Lemma subvPn {U V} : reflect (exists2 u, u \\in U & u \\notin V) (~~ (U <= V)%VS).\nProof.\napply: (iffP idP) => [|[u Uu]]; last by apply: contra => /subvP->.\ncase/row_subPn=> i; set vi := row i _ => V'vi.\nby exists (r2v vi); rewrite memvK r2vK ?row_sub.\nQed.",
    "Lemma sub0v U : (0 <= U)%VS.\nProof. exact: mem0v. Qed.",
    "Lemma subv0 U : (U <= 0)%VS = (U == 0%VS).\nProof. by rewrite eqEsubv sub0v andbT. Qed.",
    "Lemma memv0 v : v \\in 0%VS = (v == 0).\nProof. by apply/idP/eqP=> [/vlineP[k ->] | ->]; rewrite (scaler0, mem0v). Qed.",
    "Lemma subvf U : (U <= fullv)%VS. Proof. by rewrite /subsetv vs2mxF submx1. Qed.",
    "Lemma memvf v : v \\in fullv. Proof. exact: subvf. Qed.",
    "Lemma memv_pick U : vpick U \\in U. Proof. by rewrite mem_r2v nz_row_sub. Qed.",
    "Lemma vpick0 U : (vpick U == 0) = (U == 0%VS).\nProof. by  rewrite -memv0 mem_r2v -subv0 /subV vs2mx0 !submx0 nz_row_eq0. Qed.",
    "Lemma subv_add U V W : (U + V <= W)%VS = (U <= W)%VS && (V <= W)%VS.\nProof. by rewrite /subV vs2mxD addsmx_sub. Qed.",
    "Lemma addvS U1 U2 V1 V2 : (U1 <= U2 -> V1 <= V2 -> U1 + V1 <= U2 + V2)%VS.\nProof. by rewrite /subV !vs2mxD; apply: addsmxS. Qed.",
    "Lemma addvSl U V : (U <= U + V)%VS.\nProof. by rewrite /subV vs2mxD addsmxSl. Qed.",
    "Lemma addvSr U V : (V <= U + V)%VS.\nProof. by rewrite /subV vs2mxD addsmxSr. Qed.",
    "Lemma addvC : commutative addV.\nProof. by move=> U V; apply/vs2mxP; rewrite !vs2mxD addsmxC submx_refl. Qed.",
    "Lemma addvA : associative addV.\nProof. by move=> U V W; apply/vs2mxP; rewrite !vs2mxD addsmxA submx_refl. Qed.",
    "Lemma addv_idPl {U V}: reflect (U + V = U)%VS (V <= U)%VS.\nProof. by rewrite /subV (sameP addsmx_idPl eqmxP) -vs2mxD; apply: vs2mxP. Qed.",
    "Lemma addv_idPr {U V} : reflect (U + V = V)%VS (U <= V)%VS.\nProof. by rewrite addvC; apply: addv_idPl. Qed.",
    "Lemma addvv : idempotent_op addV.\nProof. by move=> U; apply/addv_idPl. Qed.",
    "Lemma add0v : left_id 0%VS addV.\nProof. by move=> U; apply/addv_idPr/sub0v. Qed.",
    "Lemma addv0 : right_id 0%VS addV.\nProof. by move=> U; apply/addv_idPl/sub0v. Qed.",
    "Lemma sumfv : left_zero fullv addV.\nProof. by move=> U; apply/addv_idPl/subvf. Qed.",
    "Lemma addvf : right_zero fullv addV.\nProof. by move=> U; apply/addv_idPr/subvf. Qed.",
    "Lemma memv_add u v U V : u \\in U -> v \\in V -> u + v \\in (U + V)%VS.\nProof. by rewrite !memvK genmxE linearD; apply: addmx_sub_adds. Qed.",
    "Lemma memv_addP {w U V} :\n  reflect (exists2 u, u \\in U & exists2 v, v \\in V & w = u + v)\n          (w \\in U + V)%VS.\nProof.\napply: (iffP idP) => [|[u Uu [v Vv ->]]]; last exact: memv_add.\nrewrite memvK genmxE => /sub_addsmxP[r /(canRL v2rK)->].\nrewrite linearD /=; set u := r2v _; set v := r2v _.\nby exists u; last exists v; rewrite // mem_r2v submxMl.\nQed.",
    "Lemma sumv_sup i0 P U Vs :\n  P i0 -> (U <= Vs i0)%VS -> (U <= \\sum_(i | P i) Vs i)%VS.\nProof. by move=> Pi0 /subv_trans-> //; rewrite (bigD1 i0) ?addvSl. Qed.",
    "Lemma subv_sumP {P Us V} :\n  reflect (forall i, P i -> Us i <= V)%VS  (\\sum_(i | P i) Us i <= V)%VS.\nProof.\napply: (iffP idP) => [sUV i Pi | sUV].\n  by apply: subv_trans sUV; apply: sumv_sup Pi _.\nby elim/big_rec: _ => [|i W Pi sWV]; rewrite ?sub0v // subv_add sUV.\nQed.",
    "Lemma memv_sumr P vs (Us : I -> {vspace vT}) :\n    (forall i, P i -> vs i \\in Us i) ->\n  \\sum_(i | P i) vs i \\in (\\sum_(i | P i) Us i)%VS.\nProof. by move=> Uv; apply/rpred_sum=> i Pi; apply/(sumv_sup i Pi)/Uv. Qed.",
    "Lemma memv_sumP {P} {Us : I -> {vspace vT}} {v} :\n  reflect (exists2 vs, forall i, P i ->  vs i \\in Us i\n                     & v = \\sum_(i | P i) vs i)\n          (v \\in \\sum_(i | P i) Us i)%VS.\nProof.\napply: (iffP idP) => [|[vs Uv ->]]; last exact: memv_sumr.\nrewrite memvK vs2mx_sum => /sub_sumsmxP[r /(canRL v2rK)->].\npose f i := r2v (r i *m vs2mx (Us i)); rewrite linear_sum /=.\nby exists f => //= i _; rewrite mem_r2v submxMl.\nQed.",
    "Lemma subv_cap U V W : (U <= V :&: W)%VS = (U <= V)%VS && (U <= W)%VS.\nProof. by rewrite /subV vs2mxI sub_capmx. Qed.",
    "Lemma capvS U1 U2 V1 V2 : (U1 <= U2 -> V1 <= V2 -> U1 :&: V1 <= U2 :&: V2)%VS.\nProof. by rewrite /subV !vs2mxI; apply: capmxS. Qed.",
    "Lemma capvSl U V : (U :&: V <= U)%VS.\nProof. by rewrite /subV vs2mxI capmxSl. Qed.",
    "Lemma capvSr U V : (U :&: V <= V)%VS.\nProof. by rewrite /subV vs2mxI capmxSr. Qed.",
    "Lemma capvC : commutative capV.\nProof. by move=> U V; apply/vs2mxP; rewrite !vs2mxI capmxC submx_refl. Qed.",
    "Lemma capvA : associative capV.\nProof. by move=> U V W; apply/vs2mxP; rewrite !vs2mxI capmxA submx_refl. Qed.",
    "Lemma capv_idPl {U V} : reflect (U :&: V = U)%VS (U <= V)%VS.\nProof. by rewrite /subV(sameP capmx_idPl eqmxP) -vs2mxI; apply: vs2mxP. Qed.",
    "Lemma capv_idPr {U V} : reflect (U :&: V = V)%VS (V <= U)%VS.\nProof. by rewrite capvC; apply: capv_idPl. Qed.",
    "Lemma capvv : idempotent_op capV.\nProof. by move=> U; apply/capv_idPl. Qed.",
    "Lemma cap0v : left_zero 0%VS capV.\nProof. by move=> U; apply/capv_idPl/sub0v. Qed.",
    "Lemma capv0 : right_zero 0%VS capV.\nProof. by move=> U; apply/capv_idPr/sub0v. Qed.",
    "Lemma capfv : left_id fullv capV.\nProof. by move=> U; apply/capv_idPr/subvf. Qed.",
    "Lemma capvf : right_id fullv capV.\nProof. by move=> U; apply/capv_idPl/subvf. Qed.",
    "Lemma memv_cap w U V : (w \\in U :&: V)%VS = (w \\in U) && (w \\in V).\nProof. by rewrite !memvE subv_cap. Qed.",
    "Lemma memv_capP {w U V} : reflect (w \\in U /\\ w \\in V) (w \\in U :&: V)%VS.\nProof. by rewrite memv_cap; apply: andP. Qed.",
    "Lemma vspace_modl U V W : (U <= W -> U + (V :&: W) = (U + V) :&: W)%VS.\nProof.\nby move=> sUV; apply/vs2mxP; rewrite !(vs2mxD, vs2mxI); apply/eqmxP/matrix_modl.\nQed.",
    "Lemma vspace_modr  U V W : (W <= U -> (U :&: V) + W = U :&: (V + W))%VS.\nProof. by rewrite -!(addvC W) !(capvC U); apply: vspace_modl. Qed.",
    "Lemma bigcapv_inf i0 P Us V :\n  P i0 -> (Us i0 <= V -> \\bigcap_(i | P i) Us i <= V)%VS.\nProof. by move=> Pi0; apply: subv_trans; rewrite (bigD1 i0) ?capvSl. Qed.",
    "Lemma subv_bigcapP {P U Vs} :\n  reflect (forall i, P i -> U <= Vs i)%VS (U <= \\bigcap_(i | P i) Vs i)%VS.\nProof.\napply: (iffP idP) => [sUV i Pi | sUV].\n  by rewrite (subv_trans sUV) ?(bigcapv_inf Pi).\nby elim/big_rec: _ => [|i W Pi]; rewrite ?subvf // subv_cap sUV.\nQed.",
    "Lemma addv_complf U : (U + U^C)%VS = fullv.\nProof.\napply/vs2mxP; rewrite vs2mxD -gen_vs2mx -genmx_adds !genmxE submx1 sub1mx.\nexact: addsmx_compl_full.\nQed.",
    "Lemma capv_compl U : (U :&: U^C = 0)%VS.\nProof.\napply/val_inj; rewrite [val]/= vs2mx0 vs2mxI -gen_vs2mx -genmx_cap.\nby rewrite capmx_compl genmx0.\nQed.",
    "Lemma diffvSl U V : (U :\\: V <= U)%VS.\nProof. by rewrite /subV genmxE diffmxSl. Qed.",
    "Lemma capv_diff U V : ((U :\\: V) :&: V = 0)%VS.\nProof.\napply/val_inj; rewrite [val]/= vs2mx0 vs2mxI -(gen_vs2mx V) -genmx_cap.\nby rewrite capmx_diff genmx0.\nQed.",
    "Lemma addv_diff_cap U V : (U :\\: V + U :&: V)%VS = U.\nProof.\napply/vs2mxP; rewrite vs2mxD -genmx_adds !genmxE.\nexact/eqmxP/addsmx_diff_cap_eq.\nQed.",
    "Lemma addv_diff U V : (U :\\: V + V = U + V)%VS.\nProof. by rewrite -{2}(addv_diff_cap U V) -addvA (addv_idPr (capvSr U V)). Qed.",
    "Lemma dimv0 : \\dim (0%VS : {vspace vT}) = 0.\nProof. by rewrite /dimv vs2mx0 mxrank0. Qed.",
    "Lemma dimv_eq0 U :  (\\dim U == 0) = (U == 0%VS).\nProof. by rewrite /dimv /= mxrank_eq0 [in RHS]/eq_op /= linear0 genmx0. Qed.",
    "Lemma dimvf : \\dim {:vT} = dim vT.\nProof. by rewrite /dimv vs2mxF mxrank1. Qed.",
    "Lemma dim_vline v : \\dim <[v]> = (v != 0).\nProof. by rewrite /dimv mxrank_gen rank_rV (can2_eq v2rK r2vK) linear0. Qed.",
    "Lemma dimvS U V : (U <= V)%VS -> \\dim U <= \\dim V.\nProof. exact: mxrankS. Qed.",
    "Lemma dimv_leqif_sup U V : (U <= V)%VS -> \\dim U <= \\dim V ?= iff (V <= U)%VS.\nProof. exact: mxrank_leqif_sup. Qed.",
    "Lemma dimv_leqif_eq U V : (U <= V)%VS -> \\dim U <= \\dim V ?= iff (U == V).\nProof. by rewrite eqEsubv; apply: mxrank_leqif_eq. Qed.",
    "Lemma eqEdim U V : (U == V) = (U <= V)%VS && (\\dim V <= \\dim U).\nProof. by apply/idP/andP=> [/eqP | [/dimv_leqif_eq/geq_leqif]] ->. Qed.",
    "Lemma dimv_compl U : \\dim U^C = (\\dim {:vT} - \\dim U)%N.\nProof. by rewrite dimvf /dimv mxrank_gen mxrank_compl. Qed.",
    "Lemma dimv_cap_compl U V : (\\dim (U :&: V) + \\dim (U :\\: V))%N = \\dim U.\nProof. by rewrite /dimv !mxrank_gen mxrank_cap_compl. Qed.",
    "Lemma dimv_sum_cap U V : (\\dim (U + V) + \\dim (U :&: V) = \\dim U + \\dim V)%N.\nProof. by rewrite /dimv !mxrank_gen mxrank_sum_cap. Qed.",
    "Lemma dimv_disjoint_sum U V :\n  (U :&: V = 0)%VS -> \\dim (U + V) = (\\dim U + \\dim V)%N.\nProof. by move=> dxUV; rewrite -dimv_sum_cap dxUV dimv0 addn0. Qed.",
    "Lemma dimv_add_leqif U V :\n  \\dim (U + V) <= \\dim U + \\dim V ?= iff (U :&: V <= 0)%VS.\nProof.\nby rewrite /dimv /subV !mxrank_gen vs2mx0 genmxE; apply: mxrank_adds_leqif.\nQed.",
    "Lemma diffv_eq0 U V : (U :\\: V == 0)%VS = (U <= V)%VS.\nProof.\nrewrite -dimv_eq0 -(eqn_add2l (\\dim (U :&: V))) addn0 dimv_cap_compl eq_sym.\nby rewrite (dimv_leqif_eq (capvSl _ _)) (sameP capv_idPl eqP).\nQed.",
    "Lemma dimv_leq_sum I r (P : pred I) (Us : I -> {vspace vT}) :\n  \\dim (\\sum_(i <- r | P i) Us i) <= \\sum_(i <- r | P i) \\dim (Us i).\nProof.\nelim/big_rec2: _ => [|i d vs _ le_vs_d]; first by rewrite dim_vline eqxx.\nby apply: (leq_trans (dimv_add_leqif _ _)); rewrite leq_add2l.\nQed.",
    "Lemma directvE (S : addv_expr) :\n  directv (unwrap S) = (\\dim (unwrap S) == unwrap (addv_dim S)).\nProof. by []. Qed.",
    "Lemma directvP {S : proper_addv_expr} : reflect (\\dim S = S :> nat) (directv S).\nProof. exact: eqnP. Qed.",
    "Lemma directv_trivial U : directv (unwrap (@trivial_addv U)).\nProof. exact: eqxx. Qed.",
    "Lemma dimv_sum_leqif (S : addv_expr) :\n  \\dim (unwrap S) <= unwrap (addv_dim S) ?= iff directv (unwrap S).\nProof.\nrewrite directvE; case: S => [[U] [d] /= defUd]; split=> //=.\nrewrite /dimv; elim: {1}_ {U}_ d / defUd => // m1 m2 A1 A2 r1 r2 _ leA1 _ leA2.\nby apply: leq_trans (leq_add leA1 leA2); rewrite mxrank_adds_leqif.\nQed.",
    "Lemma directvEgeq (S : addv_expr) :\n  directv (unwrap S) = (\\dim (unwrap S) >= unwrap (addv_dim S)).\nProof. by rewrite leq_eqVlt ltnNge eq_sym !dimv_sum_leqif orbF. Qed.",
    "Lemma directv_addE (S1 S2 : addv_expr) :\n  directv (unwrap S1 + unwrap S2)\n    = [&& directv (unwrap S1), directv (unwrap S2)\n        & unwrap S1 :&: unwrap S2 == 0]%VS.\nProof.\nby rewrite /directv_def /dimv vs2mxD -mxdirectE mxdirect_addsE -vs2mxI -vs2mx0.\nQed.",
    "Lemma directv_addP {U V} : reflect (U :&: V = 0)%VS (directv (U + V)).\nProof. by rewrite directv_addE !directv_trivial; apply: eqP. Qed.",
    "Lemma directv_add_unique {U V} :\n   reflect (forall u1 u2 v1 v2, u1 \\in U -> u2 \\in U -> v1 \\in V -> v2 \\in V ->\n             (u1 + v1 == u2 + v2) = ((u1, v1) == (u2, v2)))\n           (directv (U + V)).\nProof.\napply: (iffP directv_addP) => [dxUV u1 u2 v1 v2 Uu1 Uu2 Vv1 Vv2 | dxUV].\n  apply/idP/idP=> [| /eqP[-> ->] //]; rewrite -subr_eq0 opprD addrACA addr_eq0.\n  move/eqP=> eq_uv; rewrite xpair_eqE -subr_eq0 eq_uv oppr_eq0 subr_eq0 andbb.\n  by rewrite -subr_eq0 -memv0 -dxUV memv_cap -memvN -eq_uv !memvB.\napply/eqP; rewrite -subv0; apply/subvP=> v /memv_capP[U1v U2v].\nby rewrite memv0 -[v == 0]andbb {1}eq_sym -xpair_eqE -dxUV ?mem0v // addrC.\nQed.",
    "Lemma directv_sumP {Us : I -> {vspace vT}} :\n  reflect (forall i, P i -> Us i :&: (\\sum_(j | P j && (j != i)) Us j) = 0)%VS\n          (directv (\\sum_(i | P i) Us i)).\nProof.\nrewrite directvE /= /dimv vs2mx_sum -mxdirectE; apply: (equivP mxdirect_sumsP).\nby do [split=> dxU i /dxU; rewrite -vs2mx_sum -vs2mxI -vs2mx0] => [/val_inj|->].\nQed.",
    "Lemma directv_sumE {Ss : I -> addv_expr} (xunwrap := unwrap) :\n  reflect [/\\ forall i, P i -> directv (unwrap (Ss i))\n            & directv (\\sum_(i | P i) xunwrap (Ss i))]\n          (directv (\\sum_(i | P i) unwrap (Ss i))).\nProof.\nby rewrite !directvE /= /dimv 2!{1}vs2mx_sum -!mxdirectE; apply: mxdirect_sumsE.\nQed.",
    "Lemma directv_sum_independent {Us : I -> {vspace vT}} :\n   reflect (forall us,\n               (forall i, P i -> us i \\in Us i) -> \\sum_(i | P i) us i = 0 ->\n             (forall i, P i -> us i = 0))\n           (directv (\\sum_(i | P i) Us i)).\nProof.\napply: (iffP directv_sumP) => [dxU us Uu u_0 i Pi | dxU i Pi].\n  apply/eqP; rewrite -memv0 -(dxU i Pi) memv_cap Uu //= -memvN -sub0r -{1}u_0.\n  by rewrite (bigD1 i) //= addrC addKr memv_sumr // => j /andP[/Uu].\napply/eqP; rewrite -subv0; apply/subvP=> v.\nrewrite memv_cap memv0 => /andP[Uiv /memv_sumP[us Uu Dv]].\nhave: \\sum_(j | P j) [eta us with i |-> - v] j = 0.\n  rewrite (bigD1 i) //= eqxx {1}Dv addrC -sumrB big1 // => j /andP[_ i'j].\n  by rewrite (negPf i'j) subrr.\nmove/dxU/(_ i Pi); rewrite /= eqxx -oppr_eq0 => -> // j Pj.\nby have [-> | i'j] := eqVneq; rewrite ?memvN // Uu ?Pj.\nQed.",
    "Lemma directv_sum_unique {Us : I -> {vspace vT}} :\n  reflect (forall us vs,\n              (forall i, P i -> us i \\in Us i) ->\n              (forall i, P i -> vs i \\in Us i) ->\n            (\\sum_(i | P i) us i == \\sum_(i | P i) vs i)\n              = [forall (i | P i), us i == vs i])\n          (directv (\\sum_(i | P i) Us i)).\nProof.\napply: (iffP directv_sum_independent) => [dxU us vs Uu Uv | dxU us Uu u_0 i Pi].\n  apply/idP/forall_inP=> [|eq_uv]; last by apply/eqP/eq_bigr => i /eq_uv/eqP.\n  rewrite -subr_eq0 -sumrB => /eqP/dxU eq_uv i Pi.\n  by rewrite -subr_eq0 eq_uv // => j Pj; apply: memvB; move: j Pj.\napply/eqP; have:= esym (dxU us \\0 Uu _); rewrite u_0 big1_eq eqxx.\nby move/(_ _)/forall_inP=> -> // j _; apply: mem0v.\nQed.",
    "Lemma memv_span X v : v \\in X -> v \\in <<X>>%VS.\nProof.\nby case/seq_tnthP=> i {v}->; rewrite unlock memvK genmxE (eq_row_sub i) // rowK.\nQed.",
    "Lemma memv_span1 v : v \\in <<[:: v]>>%VS.\nProof. by rewrite memv_span ?mem_head. Qed.",
    "Lemma dim_span X : \\dim <<X>> <= size X.\nProof. by rewrite unlock /dimv genmxE rank_leq_row. Qed.",
    "Lemma span_subvP {X U} : reflect {subset X <= U} (<<X>> <= U)%VS.\nProof.\nrewrite /subV [@span _ _]unlock genmxE.\napply: (iffP row_subP) => /= [sXU | sXU i].\n  by move=> _ /seq_tnthP[i ->]; have:= sXU i; rewrite rowK memvK.\nby rewrite rowK -memvK sXU ?mem_tnth.\nQed.",
    "Lemma sub_span X Y : {subset X <= Y} -> (<<X>> <= <<Y>>)%VS.\nProof. by move=> sXY; apply/span_subvP=> v /sXY/memv_span. Qed.",
    "Lemma eq_span X Y : X =i Y -> (<<X>> = <<Y>>)%VS.\nProof.\nby move=> eqXY; apply: subv_anti; rewrite !sub_span // => u; rewrite eqXY.\nQed.",
    "Lemma span_def X : span X = (\\sum_(u <- X) <[u]>)%VS.\nProof.\napply/subv_anti/andP; split.\n  by apply/span_subvP=> v Xv; rewrite (big_rem v) // memvE addvSl.\nby rewrite big_tnth; apply/subv_sumP=> i _; rewrite -memvE memv_span ?mem_tnth.\nQed.",
    "Lemma span_nil : (<<Nil vT>> = 0)%VS.\nProof. by rewrite span_def big_nil. Qed.",
    "Lemma span_seq1 v : (<<[:: v]>> = <[v]>)%VS.\nProof. by rewrite span_def big_seq1. Qed.",
    "Lemma span_cons v X : (<<v :: X>> = <[v]> + <<X>>)%VS.\nProof. by rewrite !span_def big_cons. Qed.",
    "Lemma span_cat X Y : (<<X ++ Y>> = <<X>> + <<Y>>)%VS.\nProof. by rewrite !span_def big_cat. Qed.",
    "Lemma coord_span n (X : n.-tuple vT) v :\n  v \\in span X -> v = \\sum_i coord X i v *: X`_i.\nProof.\nrewrite memvK span_b2mx genmxE => Xv.\nby rewrite unlock_with mul_b2mx mulmxKpV ?v2rK.\nQed.",
    "Lemma coord0 i v : coord [tuple 0] i v = 0.\nProof.\nrewrite unlock /pinvmx rank_rV; case: negP => [[] | _].\n  by apply/eqP/rowP=> j; rewrite !mxE (tnth_nth 0) /= linear0 mxE.\nby rewrite pid_mx_0 !(mulmx0, mul0mx) mxE.\nQed.",
    "Lemma nil_free : free (Nil vT).\nProof. by rewrite /free span_nil dimv0. Qed.",
    "Lemma seq1_free v : free [:: v] = (v != 0).\nProof. by rewrite /free span_seq1 dim_vline; case: (~~ _). Qed.",
    "Lemma perm_free X Y : perm_eq X Y -> free X = free Y.\nProof.\nby move=> eqXY; rewrite /free (perm_size eqXY) (eq_span (perm_mem eqXY)).\nQed.",
    "Lemma free_directv X : free X = (0 \\notin X) && directv (\\sum_(v <- X) <[v]>).\nProof.\nhave leXi i (v := tnth (in_tuple X) i): true -> \\dim <[v]> <= 1 ?= iff (v != 0).\n  by rewrite -seq1_free -span_seq1 => _; apply/leqif_eq/dim_span.\nhave [_ /=] := leqif_trans (dimv_sum_leqif _) (leqif_sum leXi).\nrewrite sum1_card card_ord !directvE /= /free andbC span_def !(big_tnth _ _ X).\nby congr (_ = _ && _); rewrite -has_pred1 -all_predC -big_all big_tnth big_andE.\nQed.",
    "Lemma free_not0 v X : free X -> v \\in X -> v != 0.\nProof. by rewrite free_directv andbC => /andP[_ /memPn]; apply. Qed.",
    "Lemma freeP n (X : n.-tuple vT) :\n  reflect (forall k, \\sum_(i < n) k i *: X`_i = 0 -> (forall i, k i = 0))\n          (free X).\nProof.\nrewrite free_b2mx; apply: (iffP idP) => [t_free k kt0 i | t_free].\n  suffices /rowP/(_ i): \\row_i k i = 0 by rewrite !mxE.\n  by apply/(row_free_inj t_free)/r2v_inj; rewrite mul0mx -lin_b2mx kt0 linear0.\nrewrite -kermx_eq0; apply/rowV0P=> rk /sub_kermxP kt0.\nby apply/rowP=> i; rewrite mxE {}t_free // mul_b2mx kt0 linear0.\nQed.",
    "Lemma coord_free n (X : n.-tuple vT) (i j : 'I_n) :\n  free X -> coord X j (X`_i) = (i == j)%:R.\nProof.\nrewrite unlock free_b2mx => /row_freeP[Ct CtK]; rewrite -row_b2mx.\nby rewrite -row_mul -[pinvmx _]mulmx1 -CtK 3!mulmxA mulmxKpV // CtK !mxE.\nQed.",
    "Lemma coord_sum_free n (X : n.-tuple vT) k j :\n  free X -> coord X j (\\sum_(i < n) k i *: X`_i) = k j.\nProof.\nmove=> Xfree; rewrite linear_sum (bigD1 j) 1?linearZ //= coord_free // eqxx.\nrewrite mulr1 big1 ?addr0 // => i /negPf j'i.\nby rewrite linearZ /= coord_free // j'i mulr0.\nQed.",
    "Lemma cat_free X Y :\n  free (X ++ Y) = [&& free X, free Y & directv (<<X>> + <<Y>>)].\nProof.\nrewrite !free_directv mem_cat directvE /= !big_cat -directvE directv_addE /=.\nrewrite negb_or -!andbA; do !bool_congr; rewrite -!span_def.\nby rewrite (sameP eqP directv_addP).\nQed.",
    "Lemma catl_free Y X : free (X ++ Y) -> free X.\nProof. by rewrite cat_free => /and3P[]. Qed.",
    "Lemma catr_free X Y : free (X ++ Y) -> free Y.\nProof. by rewrite cat_free => /and3P[]. Qed.",
    "Lemma filter_free p X : free X -> free (filter p X).\nProof.\nrewrite -(perm_free (etrans (perm_filterC p X _) (perm_refl X))).\nexact: catl_free.\nQed.",
    "Lemma free_cons v X : free (v :: X) = (v \\notin <<X>>)%VS && free X.\nProof.\nrewrite (cat_free [:: v]) seq1_free directvEgeq /= span_seq1 dim_vline.\ncase: eqP => [-> | _] /=; first by rewrite mem0v.\nrewrite andbC ltnNge (geq_leqif (dimv_leqif_sup _)) ?addvSr //.\nby rewrite subv_add subvv andbT -memvE.\nQed.",
    "Lemma freeE n (X : n.-tuple vT) :\n  free X = [forall i : 'I_n, X`_i \\notin <<drop i.+1 X>>%VS].\nProof.\ncase: X => X /= /eqP <-{n}; rewrite -(big_andE xpredT) /=.\nelim: X => [|v X IH_X] /=; first by rewrite nil_free big_ord0.\nby rewrite free_cons IH_X big_ord_recl drop0.\nQed.",
    "Lemma freeNE n (X : n.-tuple vT) :\n  ~~ free X = [exists i : 'I_n, X`_i \\in <<drop i.+1 X>>%VS].\nProof. by rewrite freeE -negb_exists negbK. Qed.",
    "Lemma free_uniq X : free X -> uniq X.\nProof.\nelim: X => //= v b IH_X; rewrite free_cons => /andP[X'v /IH_X->].\nby rewrite (contra _ X'v) // => /memv_span.\nQed.",
    "Lemma free_span X v (sumX := fun k => \\sum_(x <- X) k x *: x) :\n    free X -> v \\in <<X>>%VS ->\n  {k | v = sumX k & forall k1, v = sumX k1 -> {in X, k1 =1 k}}.\nProof.\nrewrite -{2}[X]in_tupleE => freeX /coord_span def_v.\npose k x := oapp (fun i => coord (in_tuple X) i v) 0 (insub (index x X)).\nexists k => [|k1 {}def_v _ /(nthP 0)[i ltiX <-]].\n  rewrite /sumX (big_nth 0) big_mkord def_v; apply: eq_bigr => i _.\n  by rewrite /k index_uniq ?free_uniq // valK.\nrewrite /k /= index_uniq ?free_uniq // insubT //= def_v.\nby rewrite /sumX (big_nth 0) big_mkord coord_sum_free.\nQed.",
    "Lemma linear_of_free (rT : lmodType K) X (fX : seq rT) :\n  {f : {linear vT -> rT} | free X -> size fX = size X -> map f X = fX}.\nProof.\npose f u := \\sum_i coord (in_tuple X) i u *: fX`_i.\nhave lin_f: linear f.\n  move=> k u v; rewrite scaler_sumr -big_split; apply: eq_bigr => i _.\n  by rewrite /= scalerA -scalerDl linearP.\npose flM := GRing.isLinear.Build _ _ _ _ f lin_f.\npose fL : {linear _ -> _} := HB.pack f flM.\nexists fL => freeX eq_szX.\napply/esym/(@eq_from_nth _ 0); rewrite ?size_map eq_szX // => i ltiX.\nrewrite (nth_map 0) //= /f (bigD1 (Ordinal ltiX)) //=.\nrewrite big1 => [|j /negbTE neqji]; rewrite (coord_free (Ordinal _)) //.\n  by rewrite eqxx scale1r addr0.\nby rewrite eq_sym neqji scale0r.\nQed.",
    "Lemma span_basis U X : basis_of U X -> <<X>>%VS = U.\nProof. by case/andP=> /eqP. Qed.",
    "Lemma basis_free U X : basis_of U X -> free X.\nProof. by case/andP. Qed.",
    "Lemma coord_basis U n (X : n.-tuple vT) v :\n  basis_of U X -> v \\in U -> v = \\sum_i coord X i v *: X`_i.\nProof. by move/span_basis <-; apply: coord_span. Qed.",
    "Lemma nil_basis : basis_of 0 (Nil vT).\nProof. by rewrite /basis_of span_nil eqxx nil_free. Qed.",
    "Lemma seq1_basis v : v != 0 -> basis_of <[v]> [:: v].\nProof. by move=> nz_v; rewrite /basis_of span_seq1 // eqxx seq1_free. Qed.",
    "Lemma basis_not0 x U X : basis_of U X -> x \\in X -> x != 0.\nProof. by move/basis_free/free_not0; apply. Qed.",
    "Lemma basis_mem x U X : basis_of U X -> x \\in X -> x \\in U.\nProof. by move/span_basis=> <- /memv_span. Qed.",
    "Lemma cat_basis U V X Y :\n  directv (U + V) -> basis_of U X -> basis_of V Y -> basis_of (U + V) (X ++ Y).\nProof.\nmove=> dxUV /andP[/eqP defU freeX] /andP[/eqP defV freeY].\nby rewrite /basis_of span_cat cat_free defU defV // eqxx freeX freeY.\nQed.",
    "Lemma size_basis U n (X : n.-tuple vT) : basis_of U X -> \\dim U = n.\nProof. by case/andP=> /eqP <- /eqnP->; apply: size_tuple. Qed.",
    "Lemma basisEdim X U : basis_of U X = (U <= <<X>>)%VS && (size X <= \\dim U).\nProof.\napply/andP/idP=> [[defU /eqnP <-]| ]; first by rewrite -eqEdim eq_sym.\ncase/andP=> sUX leXU; have leXX := dim_span X.\nrewrite /free eq_sym eqEdim sUX eqn_leq !(leq_trans leXX) //.\nby rewrite (leq_trans leXU) ?dimvS.\nQed.",
    "Lemma basisEfree X U :\n  basis_of U X = [&& free X, (<<X>> <= U)%VS & \\dim U <= size X].\nProof.\nby rewrite andbC; apply: andb_id2r => freeX; rewrite eqEdim (eqnP freeX).\nQed.",
    "Lemma perm_basis X Y U : perm_eq X Y -> basis_of U X = basis_of U Y.\nProof.\nmove=> eqXY; congr ((_ == _) && _); last exact: perm_free.\nexact/eq_span/perm_mem.\nQed.",
    "Lemma vbasisP U : basis_of U (vbasis U).\nProof.\nrewrite /basis_of free_b2mx span_b2mx (sameP eqP (vs2mxP _ _)) !genmxE.\nhave ->: b2mx (vbasis U) = row_base (vs2mx U).\n  by apply/row_matrixP=> i; rewrite unlock rowK tnth_mktuple r2vK.\nby rewrite row_base_free !eq_row_base submx_refl.\nQed.",
    "Lemma vbasis_mem v U : v \\in (vbasis U) -> v \\in U.\nProof. exact: basis_mem (vbasisP _). Qed.",
    "Lemma coord_vbasis v U :\n  v \\in U -> v = \\sum_(i < \\dim U) coord (vbasis U) i v *: (vbasis U)`_i.\nProof. exact: coord_basis (vbasisP U). Qed.",
    "Lemma span_bigcat :\n  (<<\\big[cat/[::]]_(i | P i) Xs i>> = \\sum_(i | P i) <<Xs i>>)%VS.\nProof. by rewrite (big_morph _ span_cat span_nil). Qed.",
    "Lemma bigcat_free :\n    directv (\\sum_(i | P i) <<Xs i>>) ->\n  (forall i, P i -> free (Xs i)) -> free (\\big[cat/[::]]_(i | P i) Xs i).\nProof.\nrewrite /free directvE /= span_bigcat => /directvP-> /= freeXs.\nrewrite (big_morph _ (@size_cat _) (erefl _)) /=.\nby apply/eqP/eq_bigr=> i /freeXs/eqP.\nQed.",
    "Lemma bigcat_basis Us (U := (\\sum_(i | P i) Us i)%VS) :\n    directv U -> (forall i, P i -> basis_of (Us i) (Xs i)) ->\n  basis_of U (\\big[cat/[::]]_(i | P i) Xs i).\nProof.\nmove=> dxU XsUs; rewrite /basis_of span_bigcat.\nhave defUs i: P i -> span (Xs i) = Us i by case/XsUs/andP=> /eqP.\nrewrite (eq_bigr _ defUs) eqxx bigcat_free // => [|_ /XsUs/andP[]//].\napply/directvP; rewrite /= (eq_bigr _ defUs) (directvP dxU) /=.\nby apply/eq_bigr=> i /defUs->.\nQed.",
    "Lemma lfunE (ff : {linear aT -> rT}) : linfun ff =1 ff.\nProof. by move=> v; rewrite 2!unlock /= mul_rV_lin1 /= !v2rK. Qed.",
    "Lemma fun_of_lfunK : cancel (@fun_of_lfun R aT rT) linfun.\nProof.\nmove=> f; apply/val_inj/row_matrixP=> i.\nby rewrite 2!unlock /= !rowE mul_rV_lin1 /= !r2vK.\nQed.",
    "Lemma lfunP f g : f =1 g <-> f = g.\nProof.\nsplit=> [eq_fg | -> //]; rewrite -[f]fun_of_lfunK -[g]fun_of_lfunK unlock.\nby apply/val_inj/row_matrixP=> i; rewrite !rowE !mul_rV_lin1 /= eq_fg.\nQed.",
    "Lemma lfun_addN : left_inverse zero_lfun opp_lfun add_lfun.\nProof. by move=> f; apply/lfunP=> v; rewrite !lfunE /= lfunE addNr. Qed.",
    "Lemma zero_lfunE x : (0 : 'Hom(aT, rT)) x = 0. Proof. exact: lfunE. Qed.",
    "Lemma add_lfunE f g x : (f + g) x = f x + g x. Proof. exact: lfunE. Qed.",
    "Lemma opp_lfunE f x : (- f) x = - f x. Proof. exact: lfunE. Qed.",
    "Lemma sum_lfunE I (r : seq I) (P : pred I) (fs : I -> 'Hom(aT, rT)) x :\n  (\\sum_(i <- r | P i) fs i) x = \\sum_(i <- r | P i) fs i x.\nProof. by elim/big_rec2: _ => [|i _ f _ <-]; rewrite lfunE. Qed.",
    "Lemma scale_lfunE k f x : (k *: f) x = k *: f x. Proof. exact: lfunE. Qed.",
    "Lemma id_lfunE u: \\1%VF u = u :> aT. Proof. exact: lfunE. Qed.",
    "Lemma comp_lfunE f g u : (f \\o g)%VF u = f (g u). Proof. exact: lfunE. Qed.",
    "Lemma comp_lfunA f g h : (f \\o (g \\o h) = (f \\o g) \\o h)%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfun1l f : (\\1 \\o f)%VF = f.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfun1r f : (f \\o \\1)%VF = f.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfun0l g : (0 \\o g)%VF = 0 :> 'Hom(aT, rT).\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfun0r f : (f \\o 0)%VF = 0 :> 'Hom(aT, rT).\nProof. by apply/lfunP=> u; do !rewrite lfunE /=; rewrite linear0. Qed.",
    "Lemma comp_lfunDl f1 f2 g : ((f1 + f2) \\o g = (f1 \\o g) + (f2 \\o g))%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfunDr f g1 g2 : (f \\o (g1 + g2) = (f \\o g1) + (f \\o g2))%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=; rewrite linearD. Qed.",
    "Lemma comp_lfunNl f g : ((- f) \\o g = - (f \\o g))%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfunNr f g : (f \\o (- g) = - (f \\o g))%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=; rewrite linearN. Qed.",
    "Lemma comp_lfunZl k f g : (k *: (f \\o g) = (k *: f) \\o g)%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed.",
    "Lemma comp_lfunZr k f g : (k *: (f \\o g) = f \\o (k *: g))%VF.\nProof. by apply/lfunP=> u; do !rewrite lfunE /=; rewrite linearZ. Qed.",
    "Lemma limgS f U V : (U <= V)%VS -> (f @: U <= f @: V)%VS.\nProof. by rewrite unlock /subsetv !genmxE; apply: submxMr. Qed.",
    "Lemma limg_line f v : (f @: <[v]> = <[f v]>)%VS.\nProof.\napply/eqP; rewrite 2!unlock eqEsubv /subsetv /= r2vK !genmxE.\nby rewrite !(eqmxMr _ (genmxE _)) submx_refl.\nQed.",
    "Lemma limg0 f : (f @: 0 = 0)%VS. Proof. by rewrite limg_line linear0. Qed.",
    "Lemma memv_img f v U : v \\in U -> f v \\in (f @: U)%VS.\nProof. by move=> Uv; rewrite memvE -limg_line limgS. Qed.",
    "Lemma memv_imgP f w U :\n  reflect (exists2 u, u \\in U & w = f u) (w \\in f @: U)%VS.\nProof.\napply: (iffP idP) => [|[u Uu ->]]; last exact: memv_img.\nrewrite 2!unlock memvE /subsetv !genmxE => /submxP[ku Drw].\nexists (r2v (ku *m vs2mx U)); last by rewrite /= r2vK -mulmxA -Drw v2rK.\nby rewrite memvE /subsetv !genmxE r2vK submxMl.\nQed.",
    "Lemma lim0g U : (0 @: U = 0 :> {vspace rT})%VS.\nProof.\napply/eqP; rewrite -subv0; apply/subvP=> _ /memv_imgP[u _ ->].\nby rewrite lfunE rpred0.\nQed.",
    "Lemma eq_in_limg V f g : {in V, f =1 g} -> (f @: V = g @: V)%VS.\nProof.\nmove=> eq_fg; apply/vspaceP=> y.\nby apply/memv_imgP/memv_imgP=> [][x Vx ->]; exists x; rewrite ?eq_fg.\nQed.",
    "Lemma limgD f : {morph lfun_img f : U V / U + V}%VS.\nProof.\nmove=> U V; apply/eqP; rewrite unlock eqEsubv /subsetv /= -genmx_adds.\nby rewrite !genmxE !(eqmxMr _ (genmxE _)) !addsmxMr submx_refl.\nQed.",
    "Lemma limg_sum f I r (P : pred I) Us :\n  (f @: (\\sum_(i <- r | P i) Us i) = \\sum_(i <- r | P i) f @: Us i)%VS.\nProof. exact: (big_morph _ (limgD f) (limg0 f)). Qed.",
    "Lemma limg_cap f U V : (f @: (U :&: V) <= f @: U :&: f @: V)%VS.\nProof. by rewrite subv_cap !limgS ?capvSl ?capvSr. Qed.",
    "Lemma limg_bigcap f I r (P : pred I) Us :\n  (f @: (\\bigcap_(i <- r | P i) Us i) <= \\bigcap_(i <- r | P i) f @: Us i)%VS.\nProof.\nelim/big_rec2: _ => [|i V U _ sUV]; first exact: subvf.\nby rewrite (subv_trans (limg_cap f _ U)) ?capvS.\nQed.",
    "Lemma limg_span f X : (f @: <<X>> = <<map f X>>)%VS.\nProof.\nby rewrite !span_def big_map limg_sum; apply: eq_bigr => x _; rewrite limg_line.\nQed.",
    "Lemma subset_limgP f U (r : seq rT) :\n  {subset r <= (f @: U)%VS} <-> (exists2 a, all (mem U) a & r = map f a).\nProof.\nsplit => [|[{}r /allP/= rE ->] _ /mapP[x xr ->]]; last by rewrite memv_img ?rE.\nmove=> /(_ _ _)/memv_imgP/sig2_eqW-/(all_sig_cond (0 : aT))[f' f'P].\nexists (map f' r); first by apply/allP => _ /mapP [x /f'P[? ?] ->].\nby symmetry; rewrite -map_comp; apply: map_id_in => x /f'P[].\nQed.",
    "Lemma lfunPn f g : reflect (exists u, f u != g u) (f != g).\nProof.\napply: (iffP idP) => [f'g|[x]]; last by apply: contraNneq => /lfunP->.\nsuffices /subvPn[_ /memv_imgP[u _ ->]]: ~~ (limg (f - g) <= 0)%VS.\n  by rewrite lfunE /= lfunE /= memv0 subr_eq0; exists u.\napply: contra f'g => /subvP fg0; apply/eqP/lfunP=> u; apply/eqP.\nby rewrite -subr_eq0 -opp_lfunE -add_lfunE -memv0 fg0 ?memv_img ?memvf.\nQed.",
    "Lemma inv_lfun_def f : (f \\o f^-1 \\o f)%VF = f.\nProof.\napply/lfunP=> u; do !rewrite lfunE /=; rewrite unlock /= !r2vK.\nby rewrite mulmxKpV ?submxMl.\nQed.",
    "Lemma limg_lfunVK f : {in limg f, cancel f^-1%VF f}.\nProof. by move=> _ /memv_imgP[u _ ->]; rewrite -!comp_lfunE inv_lfun_def. Qed.",
    "Lemma lkerE f U : (U <= lker f)%VS = (f @: U == 0)%VS.\nProof.\nrewrite unlock -dimv_eq0 /dimv /subsetv !genmxE mxrank_eq0.\nby rewrite (sameP sub_kermxP eqP).\nQed.",
    "Lemma memv_ker f v : (v \\in lker f) = (f v == 0).\nProof. by rewrite -memv0 !memvE subv0 lkerE limg_line. Qed.",
    "Lemma eqlfunP f g v : reflect (f v = g v) (v \\in lker (f - g)).\nProof. by rewrite memv_ker !lfun_simp subr_eq0; apply: eqP. Qed.",
    "Lemma eqlfun_inP V f g : reflect {in V, f =1 g} (V <= lker (f - g))%VS.\nProof. by apply: (iffP subvP) => E x /E/eqlfunP. Qed.",
    "Lemma limg_ker_compl f U : (f @: (U :\\: lker f) = f @: U)%VS.\nProof.\nrewrite -{2}(addv_diff_cap U (lker f)) limgD; apply/esym/addv_idPl.\nby rewrite (subv_trans _ (sub0v _)) // subv0 -lkerE capvSr.\nQed.",
    "Lemma limg_ker_dim f U : (\\dim (U :&: lker f) + \\dim (f @: U) = \\dim U)%N.\nProof.\nrewrite unlock /dimv /= genmx_cap genmx_id -genmx_cap !genmxE.\nby rewrite addnC mxrank_mul_ker.\nQed.",
    "Lemma limg_dim_eq f U : (U :&: lker f = 0)%VS -> \\dim (f @: U) = \\dim U.\nProof. by rewrite -(limg_ker_dim f U) => ->; rewrite dimv0. Qed.",
    "Lemma limg_basis_of f U X :\n  (U :&: lker f = 0)%VS -> basis_of U X -> basis_of (f @: U) (map f X).\nProof.\nmove=> injUf /andP[/eqP defU /eqnP freeX].\nby rewrite /basis_of /free size_map -limg_span -freeX defU limg_dim_eq ?eqxx.\nQed.",
    "Lemma lker0P f : reflect (injective f) (lker f == 0%VS).\nProof.\nrewrite -subv0; apply: (iffP subvP) => [injf u v eq_fuv | injf u].\n  apply/eqP; rewrite -subr_eq0 -memv0 injf //.\n  by rewrite memv_ker linearB /= eq_fuv subrr.\nby rewrite memv_ker memv0 -(inj_eq injf) linear0.\nQed.",
    "Lemma limg_ker0 f U V : lker f == 0%VS -> (f @: U <= f @: V)%VS = (U <= V)%VS.\nProof.\nmove/lker0P=> injf; apply/idP/idP=> [/subvP sfUV | ]; last exact: limgS.\nby apply/subvP=> u Uu; have /memv_imgP[v Vv /injf->] := sfUV _ (memv_img f Uu).\nQed.",
    "Lemma eq_limg_ker0 f U V : lker f == 0%VS -> (f @: U == f @: V)%VS = (U == V).\nProof. by move=> injf; rewrite !eqEsubv !limg_ker0. Qed.",
    "Lemma lker0_lfunK f : lker f == 0%VS -> cancel f f^-1%VF.\nProof.\nby move/lker0P=> injf u; apply: injf; rewrite limg_lfunVK ?memv_img ?memvf.\nQed.",
    "Lemma lker0_compVf f : lker f == 0%VS -> (f^-1 \\o f = \\1)%VF.\nProof. by move/lker0_lfunK=> fK; apply/lfunP=> u; rewrite !lfunE /= fK. Qed.",
    "Lemma lker0_img_cap f U V : lker f == 0%VS ->\n  (f @: (U :&: V) = f @: U :&: f @: V)%VS.\nProof.\nmove=> kf0; apply/eqP; rewrite eqEsubv limg_cap/=; apply/subvP => x.\nrewrite memv_cap => /andP[/memv_imgP[u uU ->]] /memv_imgP[v vV].\nby move=> /(lker0P _ kf0) eq_uv; rewrite memv_img// memv_cap uU eq_uv vV.\nQed.",
    "Lemma fixedSpaceP f a : reflect (f a = a) (a \\in fixedSpace f).\nProof.\nby rewrite memv_ker add_lfunE opp_lfunE id_lfunE subr_eq0; apply: eqP.\nQed.",
    "Lemma fixedSpacesP f U : reflect {in U, f =1 id} (U <= fixedSpace f)%VS.\nProof. by apply: (iffP subvP) => cUf x /cUf/fixedSpaceP. Qed.",
    "Lemma fixedSpace_limg f U : (U <= fixedSpace f -> f @: U = U)%VS.\nProof.\nmove/fixedSpacesP=> cUf; apply/vspaceP=> x.\nby apply/memv_imgP/idP=> [[{}x Ux ->] | Ux]; last exists x; rewrite ?cUf.\nQed.",
    "Lemma fixedSpace_id : fixedSpace \\1 = {:vT}%VS.\nProof.\nby apply/vspaceP=> x; rewrite memvf; apply/fixedSpaceP; rewrite lfunE.\nQed.",
    "Lemma lker0_limgf : limg f = fullv.\nProof.\nby apply/eqP; rewrite eqEdim subvf limg_dim_eq //= (eqP kerf0) capv0.\nQed.",
    "Lemma lker0_lfunVK : cancel f^-1%VF f.\nProof. by move=> u; rewrite limg_lfunVK // lker0_limgf memvf. Qed.",
    "Lemma lker0_compfV : (f \\o f^-1 = \\1)%VF.\nProof. by apply/lfunP=> u; rewrite !lfunE /= lker0_lfunVK. Qed.",
    "Lemma lker0_compVKf aT g : (f \\o (f^-1 \\o g))%VF = g :> 'Hom(aT, vT).\nProof. by rewrite comp_lfunA lker0_compfV comp_lfun1l. Qed.",
    "Lemma lker0_compKf aT g : (f^-1 \\o (f \\o g))%VF = g :> 'Hom(aT, vT).\nProof. by rewrite comp_lfunA lker0_compVf ?comp_lfun1l. Qed.",
    "Lemma lker0_compfK rT h : ((h \\o f) \\o f^-1)%VF = h :> 'Hom(vT, rT).\nProof. by rewrite -comp_lfunA lker0_compfV comp_lfun1r. Qed.",
    "Lemma lker0_compfVK rT h : ((h \\o f^-1) \\o f)%VF = h :> 'Hom(vT, rT).\nProof. by rewrite -comp_lfunA lker0_compVf ?comp_lfun1r. Qed.",
    "Lemma lim1g U : (\\1 @: U)%VS = U.\nProof.\nhave /andP[/eqP <- _] := vbasisP U; rewrite limg_span map_id_in // => u _.\nby rewrite lfunE.\nQed.",
    "Lemma limg_comp f g U : ((g \\o f) @: U = g @: (f @: U))%VS.\nProof.\nhave /andP[/eqP <- _] := vbasisP U; rewrite !limg_span; congr (span _).\nby rewrite -map_comp; apply/eq_map => u; rewrite lfunE.\nQed.",
    "Lemma lpreim_cap_limg f W : (f @^-1: (W :&: limg f))%VS = (f @^-1: W)%VS.\nProof. by rewrite /lfun_preim -capvA capvv. Qed.",
    "Lemma lpreim0 f : (f @^-1: 0)%VS = lker f.\nProof. by rewrite /lfun_preim cap0v limg0 add0v. Qed.",
    "Lemma lpreimS f V W : (V <= W)%VS-> (f @^-1: V <= f @^-1: W)%VS.\nProof. by move=> sVW; rewrite addvS // limgS // capvS. Qed.",
    "Lemma lpreimK f W : (W <= limg f)%VS -> (f @: (f @^-1: W))%VS = W.\nProof.\nmove=> sWf; rewrite limgD (capv_idPl sWf) // -limg_comp.\nhave /eqP->: (f @: lker f == 0)%VS by rewrite -lkerE.\nhave /andP[/eqP defW _] := vbasisP W; rewrite addv0 -defW limg_span.\nrewrite map_id_in // => x Xx; rewrite lfunE /= limg_lfunVK //.\nby apply: span_subvP Xx; rewrite defW.\nQed.",
    "Lemma memv_preim f u W : (f u \\in W) = (u \\in f @^-1: W)%VS.\nProof.\napply/idP/idP=> [Wfu | /(memv_img f)]; last first.\n  by rewrite -lpreim_cap_limg lpreimK ?capvSr // => /memv_capP[].\nrewrite -[u](addNKr (f^-1%VF (f u))) memv_add ?memv_img //.\n  by rewrite memv_cap Wfu memv_img ?memvf.\nby rewrite memv_ker addrC linearB /= subr_eq0 limg_lfunVK ?memv_img ?memvf.\nQed.",
    "Lemma memv_pi U V w : (daddv_pi U V) w \\in U.\nProof. by rewrite unlock memvE /subsetv genmxE /= r2vK proj_mx_sub. Qed.",
    "Lemma memv_proj U w : projv U w \\in U. Proof. exact: memv_pi. Qed.",
    "Lemma memv_pi1 U V w : (addv_pi1 U V) w \\in U.\nProof. by rewrite (subvP (diffvSl U V)) ?memv_pi. Qed.",
    "Lemma memv_pi2 U V w : (addv_pi2 U V) w \\in V. Proof. exact: memv_pi. Qed.",
    "Lemma daddv_pi_id U V u : (U :&: V = 0)%VS -> u \\in U -> daddv_pi U V u = u.\nProof.\nmove/eqP; rewrite -dimv_eq0 memvE /subsetv /dimv !genmxE mxrank_eq0 => /eqP.\nby move=> dxUV Uu; rewrite unlock /= proj_mx_id ?v2rK.\nQed.",
    "Lemma daddv_pi_proj U V w (pi := daddv_pi U V) :\n  (U :&: V = 0)%VS -> pi (pi w) = pi w.\nProof. by move/daddv_pi_id=> -> //; apply: memv_pi. Qed.",
    "Lemma daddv_pi_add U V w :\n  (U :&: V = 0)%VS -> (w \\in U + V)%VS -> daddv_pi U V w + daddv_pi V U w = w.\nProof.\nmove/eqP; rewrite -dimv_eq0 memvE /subsetv /dimv !genmxE mxrank_eq0 => /eqP.\nby move=> dxUW UVw; rewrite unlock /= -linearD /= add_proj_mx ?v2rK.\nQed.",
    "Lemma projv_id U u : u \\in U -> projv U u = u.\nProof. exact: daddv_pi_id (capv_compl _). Qed.",
    "Lemma projv_proj U w : projv U (projv U w) = projv U w.\nProof. exact: daddv_pi_proj (capv_compl _). Qed.",
    "Lemma memv_projC U w : w - projv U w \\in (U^C)%VS.\nProof.\nrewrite -{1}[w](daddv_pi_add (capv_compl U)) ?addv_complf ?memvf //.\nby rewrite addrC addKr memv_pi.\nQed.",
    "Lemma limg_proj U : limg (projv U) = U.\nProof.\napply/vspaceP=> u; apply/memv_imgP/idP=> [[u1 _ ->] | ]; first exact: memv_proj.\nby exists (projv U u); rewrite ?projv_id ?memv_img ?memvf.\nQed.",
    "Lemma lker_proj U : lker (projv U) = (U^C)%VS.\nProof.\napply/eqP; rewrite eqEdim andbC; apply/andP; split.\n  by rewrite dimv_compl -(limg_ker_dim (projv U) fullv) limg_proj addnK capfv.\nby apply/subvP=> v; rewrite memv_ker -{2}[v]subr0 => /eqP <-; apply: memv_projC.\nQed.",
    "Lemma addv_pi1_proj U V w (pi1 := addv_pi1 U V) : pi1 (pi1 w) = pi1 w.\nProof. by rewrite daddv_pi_proj // capv_diff. Qed.",
    "Lemma addv_pi2_id U V v : v \\in V -> addv_pi2 U V v = v.\nProof. by apply: daddv_pi_id; rewrite capvC capv_diff. Qed.",
    "Lemma addv_pi2_proj U V w (pi2 := addv_pi2 U V) : pi2 (pi2 w) = pi2 w.\nProof. by rewrite addv_pi2_id ?memv_pi2. Qed.",
    "Lemma addv_pi1_pi2 U V w :\n  w \\in (U + V)%VS -> addv_pi1 U V w + addv_pi2 U V w = w.\nProof. by rewrite -addv_diff; exact/daddv_pi_add/capv_diff. Qed.",
    "Lemma memv_sum_pi i v : sumv_pi_for defV i v \\in Vs i.\nProof.\nrewrite /sumv_pi_for.\nelim: (filter P r0) v => [|j r IHr] v /=; first by rewrite lfunE mem0v.\nby case: eqP => [->|_]; rewrite ?lfunE ?memv_pi1 /=.\nQed.",
    "Lemma sumv_pi_uniq_sum v :\n    uniq (filter P r0) -> v \\in V ->\n  \\sum_(i <- r0 | P i) sumv_pi_for defV i v = v.\nProof.\nrewrite /sumv_pi_for defV -!(big_filter r0 P).\nelim: (filter P r0) v => [|i r IHr] v /= => [_ | /andP[r'i /IHr{}IHr]].\n  by rewrite !big_nil memv0 => /eqP.\nrewrite !big_cons eqxx => /addv_pi1_pi2; congr (_ + _ = v).\nrewrite -[_ v]IHr ?memv_pi2 //; apply: eq_big_seq => j /=.\nby case: eqP => [<- /idPn | _]; rewrite ?lfunE.\nQed.",
    "Lemma sumv_pi_sum (I : finType) (P : pred I) Vs v (V : {vspace vT})\n                  (defV : V = (\\sum_(i | P i) Vs i)%VS) :\n  v \\in V -> \\sum_(i | P i) sumv_pi_for defV i v = v :> vT.\nProof. by apply: sumv_pi_uniq_sum; have [e _ []] := big_enumP. Qed.",
    "Lemma sumv_pi_nat_sum m n (P : pred nat) Vs v (V : {vspace vT})\n                      (defV : V = (\\sum_(m <= i < n | P i) Vs i)%VS) :\n  v \\in V -> \\sum_(m <= i < n | P i) sumv_pi_for defV i v = v :> vT.\nProof. by apply: sumv_pi_uniq_sum; apply/filter_uniq/iota_uniq. Qed.",
    "Lemma subvsP w : vsval w \\in U. Proof. exact: valP. Qed.",
    "Lemma subvs_inj : injective vsval. Proof. exact: val_inj. Qed.",
    "Lemma congr_subvs u v : u = v -> vsval u = vsval v. Proof. exact: congr1. Qed.",
    "Lemma vsval_is_linear : linear vsval. Proof. by []. Qed.",
    "Lemma vsprojK : {in U, cancel vsproj vsval}.\nProof. by rewrite unlock; apply: projv_id. Qed.",
    "Lemma vsvalK : cancel vsval vsproj.\nProof. by move=> w; apply/val_inj/vsprojK/subvsP. Qed.",
    "Lemma vsproj_is_linear : linear vsproj.\nProof. by move=> k w1 w2; apply: val_inj; rewrite unlock /= linearP. Qed.",
    "Lemma SubvsE x (xU : x \\in U) : Subvs xU = vsproj x.\nProof. by apply/val_inj; rewrite /= vsprojK. Qed.",
    "Lemma dim_matrix : dim 'M[R]_(m, n) = m * n.\nProof. by []. Qed.",
    "Lemma vsolve_eqP (U : {vspace vT}) :\n  reflect (exists2 u, u \\in U & forall i, tnth lhs i u = tnth rhs i)\n          (vsolve_eq U).\nProof.\nhave lhsZ: linear lhsf by move=> a u v; apply/ffunP=> i; rewrite !ffunE linearP.\npose lhslM := GRing.isLinear.Build _ _ _ _ lhsf lhsZ.\npose lhsL : {linear _ -> _} := HB.pack lhsf lhslM.\napply: (iffP memv_imgP) => [] [u Uu sol_u]; exists u => //.\n  by move=> i; rewrite -[tnth rhs i]ffunE sol_u (lfunE lhsL) ffunE.\nby apply/ffunP=> i; rewrite (lfunE lhsL) !ffunE sol_u.\nQed.",
    "Lemma span_lfunP (U : seq uT) (phi psi : 'Hom(uT,vT)) :\n  {in <<U>>%VS, phi =1 psi} <-> {in U, phi =1 psi}.\nProof.\nsplit=> eq_phi_psi u uU; first by rewrite eq_phi_psi ?memv_span.\nrewrite [u](@coord_span _ _ _ (in_tuple U))// !linear_sum/=.\nby apply: eq_bigr=> i _; rewrite 2!linearZ/= eq_phi_psi// ?mem_nth.\nQed.",
    "Lemma fullv_lfunP (U : seq uT) (phi psi : 'Hom(uT,vT)) : <<U>>%VS = fullv ->\n  phi = psi <-> {in U, phi =1 psi}.\nProof.\nby move=> Uf; split=> [->//|/span_lfunP]; rewrite Uf=> /(_ _ (memvf _))-/lfunP.\nQed.",
    "Lemma rVof_linear : linear rVof.\nProof. by move=> x v1 v2; apply/rowP=> i; rewrite !mxE linearP. Qed.",
    "Lemma coord_rVof i v : coord e i v = rVof v 0 i.\nProof. by rewrite !mxE. Qed.",
    "Lemma vecof_delta i : vecof (delta_mx 0 i) = e`_i.\nProof.\nrewrite /vecof (bigD1 i)//= mxE !eqxx scale1r big1 ?addr0// => j neq_ji.\nby rewrite mxE (negPf neq_ji) andbF scale0r.\nQed.",
    "Lemma vecof_linear : linear vecof.\nProof.\nmove=> x v1 v2; rewrite linear_sum -big_split/=.\nby apply: eq_bigr => i _/=; rewrite !mxE scalerDl scalerA.\nQed.",
    "Lemma rVofK : cancel rVof vecof.\nProof.\nmove=> v; rewrite [v in RHS](coord_basis e_basis) ?memvf//.\nby apply: eq_bigr => i; rewrite !mxE.\nQed.",
    "Lemma vecofK : cancel vecof rVof.\nProof.\nmove=> v; apply/rowP=> i; rewrite !(lfunE, mxE).\nby rewrite coord_sum_free ?(basis_free e_basis).\nQed.",
    "Lemma rVofE (i : 'I_n) : rVof e`_i = delta_mx 0 i.\nProof.\napply/rowP=> k; rewrite !mxE.\nby rewrite eqxx coord_free ?(basis_free e_basis)// eq_sym.\nQed.",
    "Lemma coord_vecof i v : coord e i (vecof v) = v 0 i.\nProof. by rewrite coord_rVof vecofK. Qed.",
    "Lemma rVof_eq0 v : (rVof v == 0) = (v == 0).\nProof. by rewrite -(inj_eq (can_inj vecofK)) rVofK linear0. Qed.",
    "Lemma vecof_eq0 v : (vecof v == 0) = (v == 0).\nProof. by rewrite -(inj_eq (can_inj rVofK)) vecofK linear0. Qed.",
    "Lemma mxof_linear : linear mxof.\nProof.\nmove=> x h1 h2; apply/matrixP=> i j; do !rewrite ?lfunE/= ?mxE.\nby rewrite linearP.\nQed.",
    "Lemma funmx_linear M : linear (funmx M).\nProof.\nby rewrite /funmx => x u v; rewrite linearP mulmxDl -scalemxAl linearP.\nQed.",
    "Lemma hommx_linear : linear hommx.\nProof.\nrewrite /hommx; move=> x A B; apply/lfunP=> u; do !rewrite lfunE/=.\nby rewrite /funmx mulmxDr -scalemxAr linearP.\nQed.",
    "Lemma mxofK : cancel mxof hommx.\nProof.\nby move=> h; apply/lfunP=> u; rewrite lfunE/= /funmx mul_rV_lin1/= !rVofK.\nQed.",
    "Lemma hommxK : cancel hommx mxof.\nProof.\nmove=> M; apply/matrixP => i j; rewrite !mxE/= lfunE/=.\nby rewrite /funmx vecofK// -rowE coord_vecof// mxE.\nQed.",
    "Lemma mul_mxof phi u : u *m mxof phi = rVof e' (phi (vecof e u)).\nProof. by rewrite mul_rV_lin1/=. Qed.",
    "Lemma hommxE M u : hommx M u = vecof e' (rVof e u *m M).\nProof. by rewrite -[M in RHS]hommxK mul_mxof !rVofK//. Qed.",
    "Lemma rVof_mul M u : rVof e u *m M = rVof e' (hommx M u).\nProof. by rewrite hommxE vecofK. Qed.",
    "Lemma hom_vecof (phi : 'Hom(uT, vT)) u :\n  phi (vecof e u) = vecof e' (u *m mxof phi).\nProof. by rewrite mul_mxof rVofK. Qed.",
    "Lemma rVof_app (phi : 'Hom(uT, vT)) u :\n  rVof e' (phi u) = rVof e u *m mxof phi.\nProof. by rewrite mul_mxof !rVofK. Qed.",
    "Lemma vecof_mul M u : vecof e' (u *m M) = hommx M (vecof e u).\nProof. by rewrite hommxE vecofK. Qed.",
    "Lemma mxof_eq0 phi : (mxof phi == 0) = (phi == 0).\nProof. by rewrite -(inj_eq (can_inj hommxK)) mxofK linear0. Qed.",
    "Lemma hommx_eq0 M : (hommx M == 0) = (M == 0).\nProof. by rewrite -(inj_eq (can_inj mxofK)) hommxK linear0. Qed.",
    "Lemma mxof_comp (phi : 'Hom(uT, vT)) (psi : 'Hom(vT, wT)) :\n  mxof e g (psi \\o phi)%VF = mxof e f phi *m mxof f g psi.\nProof.\napply/matrixP => i k; rewrite !(mxE, comp_lfunE, lfunE) /=.\nrewrite [phi _](coord_basis f_basis) ?memvf// 2!linear_sum/=.\nby apply: eq_bigr => j _ /=; rewrite !mxE !linearZ/= !vecof_delta.\nQed.",
    "Lemma hommx_mul (A : 'M_(m,n)) (B : 'M_(n, p)) :\n  hommx e g (A *m B) = (hommx f g B \\o hommx e f A)%VF.\nProof.\nby apply: (can_inj (mxofK e_basis g_basis)); rewrite mxof_comp !hommxK.\nQed.",
    "Lemma mxof1 : free e -> mxof e e \\1 = 1%:M.\nProof.\nby move=> eF; apply/matrixP=> i j; rewrite !mxE vecof_delta lfunE coord_free.\nQed.",
    "Lemma hommx1 : hommx e e 1%:M = \\1%VF.\nProof. by rewrite -mxof1 ?(basis_free e_basis)// mxofK. Qed.",
    "Lemma msofK : cancel msof vsof.\nProof. by rewrite /msof /vsof; move=> V; rewrite mxofK// limg_proj. Qed.",
    "Lemma mem_vecof u (V : {vspace vT}) : (vecof e u \\in V) = (u <= msof V)%MS.\nProof.\napply/idP/submxP=> [|[v ->{u}]]; last by rewrite -hom_vecof// memv_proj.\nrewrite -[V in X in X -> _]msofK => /memv_imgP[v _].\nby move=> /(canRL (vecofK _)) ->//; rewrite -rVof_mul//; eexists.\nQed.",
    "Lemma rVof_sub u M : (rVof e u <= M)%MS = (u \\in vsof M).\nProof.\napply/submxP/memv_imgP => [[v /(canRL (rVofK _)) ->//]|[v _ ->]]{u}.\n  by exists (vecof e v); rewrite ?memvf// -vecof_mul.\nby exists (rVof e v); rewrite -rVof_mul.\nQed.",
    "Lemma vsof_sub M V : (vsof M <= V)%VS = (M <= msof V)%MS.\nProof.\napply/subvP/rV_subP => [MsubV _/submxP[u ->]|VsubM _/memv_imgP[u _ ->]].\n  by rewrite -mem_vecof MsubV// -rVof_sub vecofK// submxMl.\nby rewrite -[V]msofK -rVof_sub VsubM// -rVof_mul// submxMl.\nQed.",
    "Lemma msof_sub V M : (msof V <= M)%MS = (V <= vsof M)%VS.\nProof.\napply/rV_subP/subvP => [VsubM v vV|MsubV _/submxP[u ->]].\n  by rewrite -rVof_sub VsubM// -mem_vecof rVofK.\nby rewrite mul_mxof rVof_sub MsubV// memv_proj.\nQed.",
    "Lemma vsofK M : (msof (vsof M) == M)%MS.\nProof. by rewrite msof_sub -vsof_sub subvv. Qed.",
    "Lemma sub_msof : {mono msof : V V' / (V <= V')%VS >-> (V <= V')%MS}.\nProof. by move=> V V'; rewrite msof_sub msofK. Qed.",
    "Lemma sub_vsof : {mono vsof : M M' / (M <= M')%MS >-> (M <= M')%VS}.\nProof. by move=> M M'; rewrite vsof_sub (eqmxP (vsofK _)). Qed.",
    "Lemma msof0 : msof 0 = 0.\nProof.\napply/eqP; rewrite -submx0; apply/rV_subP => v.\nby rewrite -mem_vecof memv0 vecof_eq0// => /eqP->; rewrite sub0mx.\nQed.",
    "Lemma vsof0 : vsof 0 = 0%VS.\nProof. by apply/vspaceP=> v; rewrite memv0 -rVof_sub submx0 rVof_eq0. Qed.",
    "Lemma msof_eq0 V : (msof V == 0) = (V == 0%VS).\nProof. by rewrite -(inj_eq (can_inj msofK)) msof0. Qed.",
    "Lemma vsof_eq0 M : (vsof M == 0%VS) = (M == 0).\nProof.\nrewrite (sameP eqP eqmx0P) -!(eqmxP (vsofK M)) (sameP eqmx0P eqP) -msof0.\nby rewrite (inj_eq (can_inj msofK)).\nQed.",
    "Lemma lker_ker phi : lker phi = vsof e (kermx (mxof e e phi)).\nProof.\napply/vspaceP => v; rewrite memv_ker -rVof_sub// (sameP sub_kermxP eqP).\nby rewrite -rVof_app// rVof_eq0.\nQed.",
    "Lemma limgE phi : limg phi = vsof e (mxof e e phi).\nProof.\napply/vspaceP => v; rewrite -rVof_sub//.\napply/memv_imgP/submxP => [[u _ ->]|[u /(canRL (rVofK _)) ->//]].\n  by exists (rVof e u); rewrite -rVof_app.\nby exists (vecof e u); rewrite ?memvf// -hom_vecof.\nQed.",
    "Lemma leigenspaceE f a : leigenspace f a = vsof e (eigenspace (mxof e e f) a).\nProof. by rewrite [LHS]lker_ker linearB linearZ/= mxof1// scalemx1. Qed.",
    "Lemma denom_ratioP : forall f : ratio, f.2 != 0. Proof. by case. Qed.",
    "Lemma numer_Ratio x y : y != 0 -> (Ratio x y).1 = x.\nProof. by move=> ny0; rewrite /Ratio /insubd insubT. Qed.",
    "Lemma denom_Ratio x y : y != 0 -> (Ratio x y).2 = y.\nProof. by move=> ny0; rewrite /Ratio /insubd insubT. Qed.",
    "Lemma RatioP n d : Ratio_spec n d (Ratio n d) n d.\nProof.\nrewrite /Ratio /insubd; case: insubP=> /= [x /= d_neq0 hx|].\n  have ->: x = @mkRatio (n, d) d_neq0 by apply: val_inj.\n  by constructor.\nby rewrite negbK=> /eqP hx; rewrite {2}hx; constructor.\nQed.",
    "Lemma Ratio0 x : Ratio x 0 = ratio0.\nProof. by rewrite /Ratio /insubd; case: insubP; rewrite //= eqxx. Qed.",
    "Lemma equivfE x y : equivf x y = equivf_notation x y.\nProof. by []. Qed.",
    "Lemma equivf_refl : reflexive equivf.\nProof. by move=> x; rewrite /equivf mulrC. Qed.",
    "Lemma equivf_sym : symmetric equivf.\nProof. by move=> x y; rewrite /equivf eq_sym; congr (_==_); rewrite mulrC. Qed.",
    "Lemma equivf_trans : transitive equivf.\nProof.\nmove=> [x Px] [y Py] [z Pz]; rewrite /equivf /= mulrC => /eqP xy /eqP yz.\nby rewrite -(inj_eq (mulfI Px)) mulrA xy -mulrA yz mulrCA.\nQed.",
    "Lemma equivf_def (x y : ratio R) : x == y %[mod type]\n                                    = (\\n_x * \\d_y == \\d_x * \\n_y).\nProof. by rewrite eqmodE. Qed.",
    "Lemma equivf_r x : \\n_x * \\d_(repr (\\pi_type x)) = \\d_x * \\n_(repr (\\pi_type x)).\nProof. by apply/eqP; rewrite -equivf_def reprK. Qed.",
    "Lemma equivf_l x : \\n_(repr (\\pi_type x)) * \\d_x = \\d_(repr (\\pi_type x)) * \\n_x.\nProof. by apply/eqP; rewrite -equivf_def reprK. Qed.",
    "Lemma numer0 x : (\\n_x == 0) = (x == (ratio0 R) %[mod_eq equivf]).\nProof. by rewrite eqmodE /= !equivfE // mulr1 mulr0. Qed.",
    "Lemma Ratio_numden : forall x, Ratio \\n_x \\d_x = x.\nProof.\ncase=> [[n d] /= nd]; rewrite /Ratio /insubd; apply: val_inj=> /=.\nby case: insubP=> //=; rewrite nd.\nQed.",
    "Lemma pi_add : {morph \\pi : x y / addf x y >-> add x y}.\nProof.\nmove=> x y; unlock add; apply/eqmodP; rewrite /= equivfE /addf /=.\nrewrite !numden_Ratio ?mulf_neq0 ?domP // mulrDr mulrDl; apply/eqP.\nsymmetry; rewrite (AC (2*2) (3*1*2*4)) (AC (2*2) (3*2*1*4))/=.\nby rewrite !equivf_l (ACl ((2*3)*(1*4))) (ACl ((2*3)*(4*1)))/=.\nQed.",
    "Lemma pi_opp : {morph \\pi : x / oppf x >-> opp x}.\nProof.\nmove=> x; unlock opp; apply/eqmodP; rewrite /= /equivf /oppf /=.\nby rewrite !numden_Ratio ?(domP,mulf_neq0) // mulNr mulrN -equivf_r.\nQed.",
    "Lemma pi_mul : {morph \\pi : x y / mulf x y >-> mul x y}.\nProof.\nmove=> x y; unlock mul; apply/eqmodP=> /=.\nrewrite equivfE /= /addf /= !numden_Ratio ?mulf_neq0 ?domP //.\nby rewrite mulrACA !equivf_r mulrACA.\nQed.",
    "Lemma pi_inv : {morph \\pi : x / invf x >-> inv x}.\nProof.\nmove=> x; unlock inv; apply/eqmodP=> /=; rewrite equivfE /invf eq_sym.\ndo 2?case: RatioP=> /= [/eqP|];\n  rewrite ?mul0r ?mul1r -?equivf_def ?numer0 ?reprK //.\n  by move=> hx /eqP hx'; rewrite hx' eqxx in hx.\nby move=> /eqP ->; rewrite eqxx.\nQed.",
    "Lemma addA : associative add.\nProof.\nelim/quotW=> x; elim/quotW=> y; elim/quotW=> z; rewrite !piE.\nrewrite /addf /= !numden_Ratio ?mulf_neq0 ?domP // !mulrDl.\nby rewrite !mulrA !addrA ![_ * _ * \\d_x]mulrAC.\nQed.",
    "Lemma addC : commutative add.\nProof.\nby elim/quotW=> x; elim/quotW=> y; rewrite !piE /addf addrC [\\d__ * _]mulrC.\nQed.",
    "Lemma add0_l : left_id 0%:F add.\nProof.\nelim/quotW=> x; rewrite !piE /addf !numden_Ratio ?oner_eq0 //.\nby rewrite mul0r mul1r mulr1 add0r Ratio_numden.\nQed.",
    "Lemma addN_l : left_inverse 0%:F opp add.\nProof.\nelim/quotW=> x; apply/eqP; rewrite piE /equivf.\nrewrite /addf /oppf !numden_Ratio ?(oner_eq0, mulf_neq0, domP) //.\nby rewrite mulr1 mulr0 mulNr addNr.\nQed.",
    "Lemma mulA : associative mul.\nProof.\nelim/quotW=> x; elim/quotW=> y; elim/quotW=> z; rewrite !piE.\nby rewrite /mulf !numden_Ratio ?mulf_neq0 ?domP // !mulrA.\nQed.",
    "Lemma mulC : commutative mul.\nProof.\nelim/quotW=> x; elim/quotW=> y; rewrite !piE /mulf.\nby rewrite [_ * (\\d_x)]mulrC [_ * (\\n_x)]mulrC.\nQed.",
    "Lemma mul1_l : left_id 1%:F mul.\nProof.\nelim/quotW=> x; rewrite !piE /mulf.\nby rewrite !numden_Ratio ?oner_eq0 // !mul1r Ratio_numden.\nQed.",
    "Lemma mul_addl : left_distributive mul add.\nProof.\nelim/quotW=> x; elim/quotW=> y; elim/quotW=> z; apply/eqP.\nrewrite !piE /equivf /mulf /addf !numden_Ratio ?mulf_neq0 ?domP //; apply/eqP.\nrewrite !(mulrDr, mulrDl) (AC (3*(2*2)) (4*2*7*((1*3)*(6*5))))/=.\nby rewrite [X in _ + X](AC (3*(2*2)) (4*6*7*((1*3)*(2*5))))/=.\nQed.",
    "Lemma nonzero1 : 1%:F != 0%:F :> type.\nProof. by rewrite piE equivfE !numden_Ratio ?mul1r ?oner_eq0. Qed.",
    "Lemma mulV_l : forall a, a != 0%:F -> mul (inv a) a = 1%:F.\nProof.\nelim/quotW=> x /=; rewrite !piE.\nrewrite /equivf !numden_Ratio ?oner_eq0 // mulr1 mulr0=> nx0.\napply/eqmodP; rewrite /= equivfE.\nby rewrite !numden_Ratio ?(oner_eq0, mulf_neq0, domP) // !mulr1 mulrC.\nQed.",
    "Lemma inv0 : inv 0%:F = 0%:F.\nProof.\nrewrite !piE /invf !numden_Ratio ?oner_eq0 // /Ratio /insubd.\ndo 2?case: insubP; rewrite //= ?eqxx ?oner_eq0 // => u _ hu _.\nby congr \\pi; apply: val_inj; rewrite /= hu.\nQed.",
    "Lemma Ratio_numden (x : {ratio R}) : Ratio \\n_x \\d_x = x.\nProof. exact: FracField.Ratio_numden. Qed.",
    "Lemma tofrac_is_additive: additive tofrac.\nProof.\nmove=> p q /=; unlock tofrac.\nrewrite -[X in _ = _ + X]pi_opp -[RHS]pi_add.\nby rewrite /addf /oppf /= !numden_Ratio ?(oner_neq0, mul1r, mulr1).\nQed.",
    "Lemma tofrac_is_multiplicative: multiplicative tofrac.\nProof.\nsplit=> [p q|//]; unlock tofrac; rewrite -[RHS]pi_mul.\nby rewrite /mulf /= !numden_Ratio ?(oner_neq0, mul1r, mulr1).\nQed.",
    "Lemma tofrac0 : 0%:F = 0. Proof. exact: rmorph0. Qed.",
    "Lemma tofracN : {morph tofrac: x / - x}. Proof. exact: rmorphN. Qed.",
    "Lemma tofracD : {morph tofrac: x y / x + y}. Proof. exact: rmorphD. Qed.",
    "Lemma tofracB : {morph tofrac: x y / x - y}. Proof. exact: rmorphB. Qed.",
    "Lemma tofracMn n : {morph tofrac: x / x *+ n}. Proof. exact: rmorphMn. Qed.",
    "Lemma tofracMNn n : {morph tofrac: x / x *- n}. Proof. exact: rmorphMNn. Qed.",
    "Lemma tofrac1 : 1%:F = 1. Proof. exact: rmorph1. Qed.",
    "Lemma tofracM : {morph tofrac: x y  / x * y}. Proof. exact: rmorphM. Qed.",
    "Lemma tofracXn n : {morph tofrac: x / x ^+ n}. Proof. exact: rmorphXn. Qed.",
    "Lemma tofrac_eq (p q : R): (p%:F == q%:F) = (p == q).\nProof.\napply/eqP/eqP=> [|->//]; unlock tofrac=> /eqmodP /eqP /=.\nby rewrite !numden_Ratio ?(oner_eq0, mul1r, mulr1).\nQed.",
    "Lemma tofrac_eq0 (p : R): (p%:F == 0) = (p == 0).\nProof. by rewrite tofrac_eq. Qed.",
    "Lemma stablemx_comp (m n p : nat) (V : 'M[F]_(m, n)) (W : 'M_(n, p)) (f : 'M_p) :\n  stablemx W f -> stablemx V (conjmx W f) -> stablemx (V *m W) f.\nProof. by move=> Wf /(submxMr W); rewrite -mulmxA mulmxKpV// mulmxA. Qed.",
    "Lemma stablemx_restrict m n (A : 'M[F]_n) (V : 'M_n) (W : 'M_(m, \\rank V)):\n  stablemx V A -> stablemx W (restrictmx V A) = stablemx (W *m row_base V) A.\nProof.\nmove=> A_stabV; rewrite mulmxA -[in RHS]mulmxA.\nrewrite -(submxMfree _ W (row_base_free V)) mulmxKpV //.\nby rewrite mulmx_sub ?stablemx_row_base.\nQed.",
    "Lemma conjmxM (m n : nat) (V : 'M[F]_(m, n)) :\n   {in [pred f | stablemx V f] &, {morph conjmx V : f g / f *m g}}.\nProof.\nmove=> f g; rewrite !inE => Vf Vg /=.\nby rewrite /conjmx 2!mulmxA mulmxA mulmxKpV ?stablemx_row_base.\nQed.",
    "Lemma conjMmx (m n p : nat) (V : 'M[F]_(m, n)) (W : 'M_(n, p)) (f : 'M_p) :\n  row_free (V *m W) -> stablemx W f -> stablemx V (conjmx W f) ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> rfVW Wf VWf; apply: (row_free_inj rfVW); rewrite mulmxKpV ?stablemx_comp//.\nby rewrite mulmxA mulmxKpV// -[RHS]mulmxA mulmxKpV ?mulmxA.\nQed.",
    "Lemma conjuMmx (m n : nat) (V : 'M[F]_m) (W : 'M_(m, n)) (f : 'M_n) :\n  V \\in unitmx -> row_free W -> stablemx W f ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> Vu rfW Wf; rewrite conjMmx ?stablemx_unit//.\nby rewrite /row_free mxrankMfree// -/(row_free V) row_free_unit.\nQed.",
    "Lemma conjMumx (m n : nat) (V : 'M[F]_(m, n)) (W f : 'M_n) :\n  W \\in unitmx -> row_free V -> stablemx V (conjmx W f) ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof.\nmove=> Wu rfW Wf; rewrite conjMmx ?stablemx_unit//.\nby rewrite /row_free mxrankMfree ?row_free_unit.\nQed.",
    "Lemma conjuMumx (n : nat) (V W f : 'M[F]_n) :\n  V \\in unitmx -> W \\in unitmx ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\nProof. by move=> Vu Wu; rewrite conjuMmx ?stablemx_unit ?row_free_unit. Qed.",
    "Lemma conjmx_scalar (m n : nat) (V : 'M[F]_(m, n)) (a : F) :\n  row_free V -> conjmx V a%:M = a%:M.\nProof. by move=> rfV; rewrite /conjmx scalar_mxC mulmxKp. Qed.",
    "Lemma conj0mx (m n : nat) f : conjmx (0 : 'M[F]_(m, n)) f = 0.\nProof. by rewrite /conjmx !mul0mx. Qed.",
    "Lemma conjmx0 (m n : nat) (V : 'M[F]_(m, n)) : conjmx V 0 = 0.\nProof. by rewrite /conjmx mulmx0 mul0mx. Qed.",
    "Lemma conjumx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx V f = V *m f *m invmx V.\nProof. by move=> uV; rewrite /conjmx pinvmxE. Qed.",
    "Lemma conj1mx (n : nat) (f : 'M[F]_n) : conjmx 1%:M f = f.\nProof. by rewrite conjumx ?unitmx1// invmx1 mulmx1 mul1mx. Qed.",
    "Lemma conjVmx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx (invmx V) f = invmx V *m f *m V.\nProof. by move=> Vunit; rewrite conjumx ?invmxK ?unitmx_inv. Qed.",
    "Lemma conjmxK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx (invmx V) (conjmx V f) = f.\nProof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulVmx ?conj1mx. Qed.",
    "Lemma conjmxVK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx V (conjmx (invmx V) f) = f.\nProof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulmxV ?conj1mx. Qed.",
    "Lemma horner_mx_conj m n p (B : 'M[F]_(n.+1, m.+1)) (f : 'M_m.+1) :\n   row_free B -> stablemx B f ->\n   horner_mx (conjmx B f) p = conjmx B (horner_mx f p).\nProof.\nmove=> B_free B_stab; rewrite/conjmx; elim/poly_ind: p => [|p c].\n  by rewrite !rmorph0 mulmx0 mul0mx.\nrewrite !(rmorphD, rmorphM)/= !(horner_mx_X, horner_mx_C) => ->.\nrewrite [_ * _]mulmxA [_ *m (B *m _)]mulmxA mulmxKpV ?horner_mx_stable//.\napply: (row_free_inj B_free); rewrite [_ *m B]mulmxDl.\npose stablemxE := (stablemxD, stablemxM, stablemxC, horner_mx_stable).\nby rewrite !mulmxKpV -?[B *m _ *m _]mulmxA ?stablemxE// mulmxDr -scalar_mxC.\nQed.",
    "Lemma horner_mx_uconj n p (B : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n   B \\is a GRing.unit ->\n   horner_mx (B *m f *m invmx B) p = B *m horner_mx f p *m invmx B.\nProof.\nmove=> B_unit; rewrite -!conjumx//.\nby rewrite horner_mx_conj ?row_free_unit ?stablemx_unit.\nQed.",
    "Lemma horner_mx_uconjC n p (B : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n   B \\is a GRing.unit ->\n   horner_mx (invmx B *m f *m B) p = invmx B *m horner_mx f p *m B.\nProof.\nmove=> B_unit; rewrite -[X in _ *m X](invmxK B).\nby rewrite horner_mx_uconj ?invmxK ?unitmx_inv.\nQed.",
    "Lemma mxminpoly_conj m n (V : 'M[F]_(m.+1, n.+1)) (f : 'M_n.+1) :\n  row_free V -> stablemx V f -> mxminpoly (conjmx V f) %| mxminpoly f.\nProof.\nby move=> *; rewrite mxminpoly_min// horner_mx_conj// mx_root_minpoly conjmx0.\nQed.",
    "Lemma mxminpoly_uconj n (V : 'M[F]_(n.+1)) (f : 'M_n.+1) :\n  V \\in unitmx -> mxminpoly (conjmx V f) = mxminpoly f.\nProof.\nhave simp := (row_free_unit, stablemx_unit, unitmx_inv, unitmx1).\nmove=> Vu; apply/eqP; rewrite -eqp_monic ?mxminpoly_monic// /eqp.\napply/andP; split; first by rewrite mxminpoly_conj ?simp.\nby rewrite -[f in X in X %| _](conjmxK _ Vu) mxminpoly_conj ?simp.\nQed.",
    "Lemma sub_kermxpoly_conjmx V f p W : stablemx V f -> row_free V ->\n  (W <= kermxpoly (conjmx V f) p)%MS = (W *m V <= kermxpoly f p)%MS.\nProof.\nmove: n m => [|n'] [|m']// in V f W *; rewrite ?thinmx0// => fV rfV.\n- by rewrite /row_free mxrank0 in rfV.\n- by rewrite mul0mx !sub0mx.\n- apply/sub_kermxP/sub_kermxP; rewrite horner_mx_conj//; last first.\n    by move=> /(congr1 (mulmxr (pinvmx V)))/=; rewrite mul0mx !mulmxA.\n  move=> /(congr1 (mulmxr V))/=; rewrite ![W *m _]mulmxA ?mul0mx mulmxKpV//.\n  by rewrite -mulmxA mulmx_sub// horner_mx_stable//.\nQed.",
    "Lemma sub_eigenspace_conjmx V f a W : stablemx V f -> row_free V ->\n  (W <= eigenspace (conjmx V f) a)%MS = (W *m V <= eigenspace f a)%MS.\nProof. by move=> fV rfV; rewrite !eigenspace_poly sub_kermxpoly_conjmx. Qed.",
    "Lemma eigenpoly_conjmx V f : stablemx V f -> row_free V ->\n  {subset eigenpoly (conjmx V f) <= eigenpoly f}.\nProof.\nmove=> fV rfV a /eigenpolyP [x]; rewrite sub_kermxpoly_conjmx//.\nmove=> xV_le_fa x_neq0; apply/eigenpolyP.\nby exists (x *m V); rewrite ?mulmx_free_eq0.\nQed.",
    "Lemma eigenvalue_conjmx V f : stablemx V f -> row_free V ->\n  {subset eigenvalue (conjmx V f) <= eigenvalue f}.\nProof.\nby move=> fV rfV a; rewrite ![_ \\in _]eigenvalue_poly; apply: eigenpoly_conjmx.\nQed.",
    "Lemma conjmx_eigenvalue a V f : (V <= eigenspace f a)%MS -> row_free V ->\n conjmx V f = a%:M.\nProof.\nby move=> /eigenspaceP Vfa rfV; rewrite /conjmx Vfa -mul_scalar_mx mulmxKp.\nQed.",
    "Lemma similarPp m n {P : 'M[F]_(m, n)} {A B} :\n  stablemx P A -> similar P A B -> P *m A = B *m P.\nProof. by move=> stablemxPA /eqP <-; rewrite mulmxKpV. Qed.",
    "Lemma similarW m n {P : 'M[F]_(m, n)} {A B} : row_free P ->\n  P *m A = B *m P -> similar P A B.\nProof. by rewrite /similar_to/= /conjmx => fP ->; rewrite mulmxKp. Qed.",
    "Lemma similarP {p f g} : p \\in unitmx ->\n  reflect (p *m f = g *m p) (similar p f g).\nProof.\nmove=> p_unit; apply: (iffP idP); first exact/similarPp/stablemx_unit.\nby apply: similarW; rewrite row_free_unit.\nQed.",
    "Lemma similarRL {p f g} : p \\in unitmx ->\n  reflect (g = p *m f *m invmx p) (similar p f g).\nProof. by move=> ?; apply: (iffP eqP); rewrite conjumx. Qed.",
    "Lemma similarLR {p f g} : p \\in unitmx ->\n  reflect (f = conjmx (invmx p) g) (similar p f g).\nProof.\nby move=> pu; rewrite conjVmx//; apply: (iffP (similarRL pu)) => ->;\n   rewrite !mulmxA ?(mulmxK, mulmxKV, mulVmx, mulmxV, mul1mx, mulmx1).\nQed.",
    "Lemma similar_mxminpoly {n} {p f g : 'M[F]_n.+1} : p \\in unitmx ->\n  similar p f g -> mxminpoly f = mxminpoly g.\nProof. by move=> pu /eqP<-; rewrite mxminpoly_uconj. Qed.",
    "Lemma similar_diag_row_base m n (P : 'M[F]_(m, n)) (A : 'M_n) :\n  similar_diag (row_base P) A = is_diag_mx (restrictmx P A).\nProof. by []. Qed.",
    "Lemma similar_diagPp m n (P : 'M[F]_(m, n)) A :\n  reflect (forall i j : 'I__, i != j :> nat -> conjmx P A i j = 0)\n          (similar_diag P A).\nProof. exact: @is_diag_mxP. Qed.",
    "Lemma similar_diagP n (P : 'M[F]_n) A : P \\in unitmx ->\n  reflect (forall i j : 'I__, i != j :> nat -> (P *m A *m invmx P) i j = 0)\n          (similar_diag P A).\nProof. by move=> Pu; rewrite -conjumx//; exact: is_diag_mxP. Qed.",
    "Lemma similar_diagPex {m} {n} {P : 'M[F]_(m, n)} {A} :\n  reflect (exists D, similar P A (diag_mx D)) (similar_diag P A).\nProof. by apply: (iffP (diag_mxP _)) => -[D]/eqP; exists D. Qed.",
    "Lemma similar_diagLR n {P : 'M[F]_n} {A} : P \\in unitmx ->\n  reflect (exists D, A = conjmx (invmx P) (diag_mx D)) (similar_diag P A).\nProof.\nby move=> Punit; apply: (iffP similar_diagPex) => -[D /(similarLR Punit)]; exists D.\nQed.",
    "Lemma similar_diag_mxminpoly {n} {p f : 'M[F]_n.+1}\n  (rs := undup [seq conjmx p f i i | i <- enum 'I_n.+1]) :\n  p \\in unitmx -> similar_diag p f ->\n  mxminpoly f = \\prod_(r <- rs) ('X - r%:P).\nProof.\nrewrite /rs => pu /(similar_diagLR pu)[d {f rs}->].\nrewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\nby rewrite [in RHS](@eq_map _ _ _ (d 0))// => i; rewrite conjmxVK// mxE eqxx.\nQed.",
    "Lemma similar_diag_sum (F : fieldType) (m n : nat) (p_ : 'I_n -> nat)\n      (V_ : forall i, 'M[F]_(p_ i, m)) (f : 'M[F]_m) :\n    mxdirect (\\sum_i <<V_ i>>) ->\n    (forall i, stablemx (V_ i) f) ->\n    (forall i, row_free (V_ i)) ->\n  similar_diag (\\mxcol_i V_ i) f = [forall i, similar_diag (V_ i) f].\nProof.\nmove=> Vd Vf rfV; have aVf : stablemx (\\mxcol_i V_ i) f.\n  rewrite (eqmx_stable _ (eqmx_col _)) stablemx_sums//.\n  by move=> i; rewrite (eqmx_stable _ (genmxE _)).\napply/similar_diagPex/'forall_similar_diagPex => /=\n    [[D /(similarPp aVf) +] i|/(_ _)/sigW Dof].\n  rewrite mxcol_mul -[D]submxrowK diag_mxrow mul_mxdiag_mxcol.\n  move=> /eq_mxcolP/(_ i); set D0 := (submxrow _ _) => VMeq.\n  by exists D0; apply/similarW.\nexists (\\mxrow_i tag (Dof i)); apply/similarW.\n   rewrite -row_leq_rank eqmx_col (mxdirectP Vd)/=.\n   by under [X in (_ <= X)%N]eq_bigr do rewrite genmxE (eqP (rfV _)).\nrewrite mxcol_mul diag_mxrow mul_mxdiag_mxcol; apply: eq_mxcol => i.\nby case: Dof => /= k /(similarPp); rewrite Vf => /(_ isT) ->.\nQed.",
    "Lemma codiagonalizable1 n (A : 'M[F]_n) :\n  codiagonalizable [:: A] <-> diagonalizable A.\nProof. by split=> -[P Punit PA]; exists P; move: PA; rewrite //= andbT. Qed.",
    "Lemma codiagonalizablePfull n (As : seq 'M[F]_n) :\n  codiagonalizable As <-> exists m,\n    exists2 P : 'M_(m, n), row_full P & all [pred A | similar_diag P A] As.\nProof.\nsplit => [[P Punit SPA]|[m [P Pfull SPA]]].\n  by exists n => //; exists P; rewrite ?row_full_unit.\nhave Qfull := fullrowsub_unit Pfull.\nexists (rowsub (fullrankfun Pfull) P) => //; apply/allP => A AAs/=.\nhave /allP /(_ _ AAs)/= /similar_diagPex[d /similarPp] := SPA.\nrewrite submx_full// => /(_ isT) PA_eq.\napply/similar_diagPex; exists (colsub (fullrankfun Pfull) d).\napply/similarP => //; apply/row_matrixP => i.\nrewrite !row_mul row_diag_mx -scalemxAl -rowE !row_rowsub !mxE.\nhave /(congr1 (row (fullrankfun Pfull i))) := PA_eq.\nby rewrite !row_mul row_diag_mx -scalemxAl -rowE => ->.\nQed.",
    "Lemma codiagonalizable_on m n (V_ : 'I_n -> 'M[F]_m) (As : seq 'M[F]_m) :\n  (\\sum_i V_ i :=: 1%:M)%MS -> mxdirect (\\sum_i V_ i) ->\n  (forall i, all (fun A => stablemx (V_ i) A) As) ->\n  (forall i, codiagonalizable (map (restrictmx (V_ i)) As)) -> codiagonalizable As.\nProof.\nmove=> V1 Vdirect /(_ _)/allP AV /(_ _) /sig2W/= Pof.\npose P_ i := tag (Pof i).\nhave P_unit i : P_ i \\in unitmx by rewrite /P_; case: {+}Pof.\nhave P_diag i A : A \\in As -> similar_diag (P_ i *m row_base (V_ i)) A.\n  move=> AAs; rewrite /P_; case: {+}Pof => /= P Punit.\n  rewrite all_map => /allP/(_ A AAs); rewrite /similar_to/=.\n  by rewrite conjuMmx ?row_base_free ?stablemx_row_base ?AV.\npose P := \\mxcol_i (P_ i *m row_base (V_ i)).\nhave P_full i : row_full (P_ i) by rewrite row_full_unit.\nhave PrV i : (P_ i *m row_base (V_ i) :=: V_ i)%MS.\n  exact/(eqmx_trans _ (eq_row_base _))/eqmxMfull.\napply/codiagonalizablePfull; eexists _; last exists P; rewrite /=.\n- rewrite -sub1mx eqmx_col.\n  by under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\napply/allP => A AAs /=; rewrite similar_diag_sum.\n- by apply/forallP => i; apply: P_diag.\n- rewrite mxdirectE/=.\n  under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\n  by under eq_bigr do rewrite genmxE PrV; rewrite  -(mxdirectP Vdirect)//= V1.\n- by move=> i; rewrite (eqmx_stable _ (PrV _)) ?AV.\n- by move=> i; rewrite /row_free eqmxMfull ?eq_row_base ?row_full_unit.\nQed.",
    "Lemma diagonalizable_diag {n} (d : 'rV[F]_n) : diagonalizable (diag_mx d).\nProof.\nby exists 1%:M; rewrite ?unitmx1// /similar_to conj1mx diag_mx_is_diag.\nQed.",
    "Lemma diagonalizable_scalar {n} (a : F) : diagonalizable (a%:M : 'M_n).\nProof. by rewrite -diag_const_mx. Qed.",
    "Lemma diagonalizable0 {n} : diagonalizable (0 : 'M[F]_n).\nProof.\nby rewrite (_ : 0 = 0%:M)//; apply/matrixP => i j; rewrite !mxE// mul0rn.\nQed.",
    "Lemma diagonalizablePeigen {n} {f : 'M[F]_n} :\n  diagonalizable f <->\n  exists2 rs, uniq rs & (\\sum_(r <- rs) eigenspace f r :=: 1%:M)%MS.\nProof.\nsplit=> [df|[rs urs rsP]].\n  suff [rs rsP] : exists rs, (\\sum_(r <- rs) eigenspace f r :=: 1%:M)%MS.\n    exists (undup rs); rewrite ?undup_uniq//; apply: eqmx_trans rsP.\n    elim: rs => //= r rs IHrs; rewrite big_cons.\n    case: ifPn => in_rs; rewrite ?big_cons; last exact: adds_eqmx.\n    apply/(eqmx_trans IHrs)/eqmx_sym/addsmx_idPr.\n    have rrs : (index r rs < size rs)%N by rewrite index_mem.\n    rewrite (big_nth 0) big_mkord (sumsmx_sup (Ordinal rrs)) ?nth_index//.\n  move: df => [P Punit /(similar_diagLR Punit)[d ->]].\n  exists [seq d 0 i | i <- enum 'I_n]; rewrite big_image/=.\n  apply: (@eqmx_trans _ _ _ _ _ _ P); apply/eqmxP;\n    rewrite ?sub1mx ?submx1 ?row_full_unit//.\n  rewrite submx_full ?row_full_unit//=.\n  apply/row_subP => i; rewrite rowE (sumsmx_sup i)//.\n  apply/eigenspaceP; rewrite conjVmx// !mulmxA mulmxK//.\n  by rewrite -rowE row_diag_mx scalemxAl.\nhave mxdirect_eigenspaces : mxdirect (\\sum_(i < size rs) eigenspace f rs`_i).\n  apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\nrewrite (big_nth 0) big_mkord in rsP; apply/codiagonalizable1.\napply/(codiagonalizable_on _ mxdirect_eigenspaces) => // i/=.\n  case: n => [|n] in f {mxdirect_eigenspaces} rsP *.\n    by rewrite thinmx0 sub0mx.\n  by rewrite comm_mx_stable_eigenspace.\napply/codiagonalizable1.\nby rewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free.\nQed.",
    "Lemma diagonalizableP n' (n := n'.+1) (f : 'M[F]_n) :\n  diagonalizable f <->\n  exists2 rs, uniq rs & mxminpoly f %| \\prod_(x <- rs) ('X - x%:P).\nProof.\nsplit=> [[P Punit /similar_diagPex[d /(similarLR Punit)->]]|].\n  rewrite mxminpoly_uconj ?unitmx_inv// mxminpoly_diag.\n  by eexists; [|by []]; rewrite undup_uniq.\nmove=> [rs rsU rsP]; apply: diagonalizablePeigen.2.\nexists rs => //.\nrewrite (big_nth 0) big_mkord (eq_bigr _ (fun _ _ => eigenspace_poly _ _)).\napply: (eqmx_trans (eqmx_sym (kermxpoly_prod _ _)) (kermxpoly_min _)).\n  by move=> i j _ _; rewrite coprimep_XsubC root_XsubC nth_uniq.\nby rewrite (big_nth 0) big_mkord in rsP.\nQed.",
    "Lemma diagonalizable_conj_diag m n (V : 'M[F]_(m, n)) (d : 'rV[F]_n) :\n  stablemx V (diag_mx d) -> row_free V -> diagonalizable (conjmx V (diag_mx d)).\nProof.\nmove: m n => [|m] [|n] in V d *; rewrite ?thinmx0; [by []|by []| |] => Vd rdV.\n- by rewrite /row_free mxrank0 in rdV.\n- apply/diagonalizableP; pose u := undup [seq d 0 i | i <- enum 'I_n.+1].\n  exists u; first by rewrite undup_uniq.\n  by rewrite (dvdp_trans (mxminpoly_conj rdV _))// mxminpoly_diag.\nQed.",
    "Lemma codiagonalizableP n (fs : seq 'M[F]_n) :\n  {in fs &, forall f g, comm_mx f g} /\\ (forall f, f \\in fs -> diagonalizable f)\n  <-> codiagonalizable fs.\nProof.\nsplit => [cdfs|[P Punit /allP/= fsD]]/=; last first.\n  split; last by exists P; rewrite // fsD.\n  move=> f g ffs gfs; move=> /(_ _ _)/similar_diagPex/sigW in fsD.\n  have [[df /similarLR->//] [dg /similarLR->//]] := (fsD _ ffs, fsD _ gfs).\n  by rewrite /comm_mx -!conjmxM 1?diag_mxC// inE stablemx_unit ?unitmx_inv.\nmove: cdfs => [/(rwP (all_comm_mxP _)).1 cdfs1 cdfs2].\nhave [k] := ubnP (size fs); elim: k => [|k IHk]//= in n fs cdfs1 cdfs2 *.\ncase: fs cdfs1 cdfs2 => [|f fs]//=; first by exists 1%:M; rewrite ?unitmx1.\nrewrite ltnS all_comm_mx_cons => /andP[/allP/(_ _ _)/eqP ffsC fsC dffs] fsk.\nhave /diagonalizablePeigen [rs urs rs1] := dffs _ (mem_head _ _).\nrewrite (big_nth 0) big_mkord in rs1.\nhave efg (i : 'I_(size rs)) g : g \\in f :: fs -> stablemx (eigenspace f rs`_i) g.\n   case: n => [|n'] in g f fs ffsC fsC {dffs rs1 fsk} * => g_ffs.\n      by rewrite thinmx0 sub0mx.\n  rewrite comm_mx_stable_eigenspace//.\n  by move: g_ffs; rewrite !inE => /predU1P [->//|/ffsC].\napply/(@codiagonalizable_on _ _ _ (_ :: _) rs1) => [|i|i /=].\n- apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\n- by apply/allP => g g_ffs; rewrite efg.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free//.\nset gs := map _ _; suff [P Punit /= Pgs] : codiagonalizable gs.\n  exists P; rewrite /= ?Pgs ?andbT// /similar_to.\n  by rewrite conjmx_scalar ?mx_scalar_is_diag// row_free_unit.\napply: IHk; rewrite ?size_map/= ?ltnS//.\n  apply/all_comm_mxP => _ _ /mapP[/= g gfs ->] /mapP[/= h hfs ->].\n  rewrite -!conjmxM ?inE ?stablemx_row_base ?efg ?inE ?gfs ?hfs ?orbT//.\n  by rewrite (all_comm_mxP _ fsC).\nmove=> _ /mapP[/= g gfs ->].\nhave: stablemx (row_base (eigenspace f rs`_i)) g.\n  by rewrite stablemx_row_base efg// inE gfs orbT.\nhave := dffs g; rewrite inE gfs orbT => /(_ isT) [P Punit].\nmove=> /similar_diagPex[D /(similarLR Punit)->] sePD.\nhave rfeP : row_free (row_base (eigenspace f rs`_i) *m invmx P).\n  by rewrite /row_free mxrankMfree ?row_free_unit ?unitmx_inv// eq_row_base.\nrewrite -conjMumx ?unitmx_inv ?row_base_free//.\napply/diagonalizable_conj_diag => //.\nby rewrite stablemx_comp// stablemx_unit ?unitmx_inv.\nQed.",
    "Lemma floorP n : if n \\is Rreal then n%:~R <= n < (n + 1)%:~R else n == 0.\nProof. by rewrite num_real !intz ltzD1 lexx. Qed.",
    "Lemma intrP n : reflect (exists m, n = m%:~R) true.\nProof. by apply: ReflectT; exists n; rewrite intz. Qed.",
    "Lemma natrP n : reflect (exists m, n = m%:R) (0 <= n).\nProof.\napply: (iffP idP); last by case=> m ->; rewrite ler0n.\nby case: n => // n _; exists n; rewrite natz.\nQed.",
    "Lemma floorP x :\n  if x \\is Rreal then (floor x)%:~R <= x < (floor x + 1)%:~R else floor x == 0.\nProof. exact: floor_subproof. Qed.",
    "Lemma floorNceil x : floor x = - ceil (- x).\nProof. by rewrite ceil_subproof !opprK. Qed.",
    "Lemma ceilNfloor x : ceil x = - floor (- x).\nProof. exact: ceil_subproof. Qed.",
    "Lemma truncEfloor x : truncn x = if floor x is Posz n then n else 0.\nProof. exact: truncn_subproof. Qed.",
    "Lemma natrP x : reflect (exists n, x = n%:R) (x \\is a nat_num).\nProof. exact: nat_num_subproof. Qed.",
    "Lemma intrP x : reflect (exists m, x = m%:~R) (x \\is a int_num).\nProof. exact: int_num_subproof. Qed.",
    "Lemma intr_int m : m%:~R \\is a int_num. Proof. by apply/intrP; exists m. Qed.",
    "Lemma natr_nat n : n%:R \\is a nat_num. Proof. by apply/natrP; exists n. Qed.",
    "Lemma rpred_int_num (S : subringClosed R) x : x \\is a int_num -> x \\in S.\nProof. by move=> /intrP[n ->]; rewrite rpred_int. Qed.",
    "Lemma rpred_nat_num (S : semiringClosed R) x : x \\is a nat_num -> x \\in S.\nProof. by move=> /natrP[n ->]; apply: rpred_nat. Qed.",
    "Lemma int_num0 : 0 \\is a int_num. Proof. exact: (intr_int 0). Qed.",
    "Lemma int_num1 : 1 \\is a int_num. Proof. exact: (intr_int 1). Qed.",
    "Lemma nat_num0 : 0 \\is a nat_num. Proof. exact: (natr_nat 0). Qed.",
    "Lemma nat_num1 : 1 \\is a nat_num. Proof. exact: (natr_nat 1). Qed.",
    "Lemma Rreal_nat : {subset nat_num <= Rreal}. Proof. exact: rpred_nat_num. Qed.",
    "Lemma intr_nat : {subset nat_num <= int_num}.\nProof. by move=> _ /natrP[n ->]; rewrite pmulrn intr_int. Qed.",
    "Lemma Rreal_int : {subset int_num <= Rreal}. Proof. exact: rpred_int_num. Qed.",
    "Lemma intrE x : (x \\is a int_num) = (x \\is a nat_num) || (- x \\is a nat_num).\nProof.\napply/idP/orP => [/intrP[[n|n] ->]|[]/intr_nat]; rewrite ?rpredN //.\n  by left; apply/natrP; exists n.\nby rewrite NegzE intrN opprK; right; apply/natrP; exists n.+1.\nQed.",
    "Lemma intr_normK x : x \\is a int_num -> `|x| ^+ 2 = x ^+ 2.\nProof. by move/Rreal_int/real_normK. Qed.",
    "Lemma natr_normK x : x \\is a nat_num -> `|x| ^+ 2 = x ^+ 2.\nProof. by move/Rreal_nat/real_normK. Qed.",
    "Lemma natr_norm_int x : x \\is a int_num -> `|x| \\is a nat_num.\nProof. by move=> /intrP[m ->]; rewrite -intr_norm rpred_nat_num ?natr_nat. Qed.",
    "Lemma natr_ge0 x : x \\is a nat_num -> 0 <= x.\nProof. by move=> /natrP[n ->]; apply: ler0n. Qed.",
    "Lemma natr_gt0 x : x \\is a nat_num -> (0 < x) = (x != 0).\nProof. by move/natr_ge0; case: comparableP. Qed.",
    "Lemma natrEint x : (x \\is a nat_num) = (x \\is a int_num) && (0 <= x).\nProof.\napply/idP/andP=> [Nx | [Zx x_ge0]]; first by rewrite intr_nat ?natr_ge0.\nby rewrite -(ger0_norm x_ge0) natr_norm_int.\nQed.",
    "Lemma intrEge0 x : 0 <= x -> (x \\is a int_num) = (x \\is a nat_num).\nProof. by rewrite natrEint andbC => ->. Qed.",
    "Lemma intrEsign x : x \\is a int_num -> x = (-1) ^+ (x < 0)%R * `|x|.\nProof. by move/Rreal_int/realEsign. Qed.",
    "Lemma norm_natr x : x \\is a nat_num -> `|x| = x.\nProof. by move/natr_ge0/ger0_norm. Qed.",
    "Lemma natr_exp_even x n : ~~ odd n -> x \\is a int_num -> x ^+ n \\is a nat_num.\nProof.\nmove=> n_oddF x_intr.\nby rewrite natrEint rpredX //= real_exprn_even_ge0 // Rreal_int.\nQed.",
    "Lemma norm_intr_ge1 x : x \\is a int_num -> x != 0 -> 1 <= `|x|.\nProof.\nrewrite -normr_eq0 => /natr_norm_int/natrP[n ->].\nby rewrite pnatr_eq0 ler1n lt0n.\nQed.",
    "Lemma sqr_intr_ge1 x : x \\is a int_num -> x != 0 -> 1 <= x ^+ 2.\nProof.\nby move=> Zx nz_x; rewrite -intr_normK // expr_ge1 ?normr_ge0 ?norm_intr_ge1.\nQed.",
    "Lemma intr_ler_sqr x : x \\is a int_num -> x <= x ^+ 2.\nProof.\nmove=> Zx; have [-> | nz_x] := eqVneq x 0; first by rewrite expr0n.\napply: le_trans (_ : `|x| <= _); first by rewrite real_ler_norm ?Rreal_int.\nby rewrite -intr_normK // ler_eXnr // norm_intr_ge1.\nQed.",
    "Lemma real_floor_itv x : x \\is Rreal -> (floor x)%:~R <= x < (floor x + 1)%:~R.\nProof. by case: ifP (floorP x). Qed.",
    "Lemma real_floor_le x : x \\is Rreal -> (floor x)%:~R <= x.\nProof. by case/real_floor_itv/andP. Qed.",
    "Lemma real_floorD1_gt x : x \\is Rreal -> x < (floor x + 1)%:~R.\nProof. by case/real_floor_itv/andP. Qed.",
    "Lemma floor_def x m : m%:~R <= x < (m + 1)%:~R -> floor x = m.\nProof.\ncase/andP=> lemx ltxm1; apply/eqP; rewrite eq_le -!ltzD1.\nmove: (ger_real lemx); rewrite realz => /real_floor_itv/andP[lefx ltxf1].\nby rewrite -!(ltr_int R) 2?(@le_lt_trans _ _ x).\nQed.",
    "Lemma real_floor_ge_int_tmp x n : x \\is Rreal -> (n <= floor x) = (n%:~R <= x).\nProof.\nmove=> /real_floor_itv /andP[lefx ltxf1]; apply/idP/idP => lenx.\n  by apply: le_trans lefx; rewrite ler_int.\nby rewrite -ltzD1 -(ltr_int R); apply: le_lt_trans ltxf1.\nQed.",
    "Lemma real_floor_ge_int x n : x \\is Rreal -> (n%:~R <= x) = (n <= floor x).\nProof. by move=> ?; rewrite real_floor_ge_int_tmp. Qed.",
    "Lemma real_floor_lt_int x n : x \\is Rreal -> (floor x < n) = (x < n%:~R).\nProof.\nby move=> ?; rewrite [RHS]real_ltNge ?realz -?real_floor_ge_int_tmp -?ltNge.\nQed.",
    "Lemma real_floor_eq x n : x \\is Rreal ->\n  (floor x == n) = (n%:~R <= x < (n + 1)%:~R).\nProof.\nby move=> xr; apply/eqP/idP => [<-|]; [exact: real_floor_itv|exact: floor_def].\nQed.",
    "Lemma le_floor : {homo floor : x y / x <= y}.\nProof.\nmove=> x y lexy; move: (floorP x) (floorP y); rewrite (ger_real lexy).\ncase: ifP => [_ /andP[lefx _] /andP[_] | _ /eqP-> /eqP-> //].\nby move=> /(le_lt_trans lexy) /(le_lt_trans lefx); rewrite ltr_int ltzD1.\nQed.",
    "Lemma intrKfloor : cancel intr floor.\nProof. by move=> m; apply: floor_def; rewrite lexx rmorphD ltrDl ltr01. Qed.",
    "Lemma natr_int n : n%:R \\is a int_num.\nProof. by rewrite intrE natr_nat. Qed.",
    "Lemma intrEfloor x : x \\is a int_num = ((floor x)%:~R == x).\nProof.\nby apply/intrP/eqP => [[n ->] | <-]; [rewrite intrKfloor | exists (floor x)].\nQed.",
    "Lemma floorK : {in int_num, cancel floor intr}.\nProof. by move=> z; rewrite intrEfloor => /eqP. Qed.",
    "Lemma floor0 : floor 0 = 0. Proof. exact: intrKfloor 0. Qed.",
    "Lemma floor1 : floor 1 = 1. Proof. exact: intrKfloor 1. Qed.",
    "Lemma real_floorDzr : {in int_num & Rreal, {morph floor : x y / x + y}}.\nProof.\nmove=> _ y /intrP[m ->] Ry; apply: floor_def.\nby rewrite -addrA 2!rmorphD /= intrKfloor lerD2l ltrD2l real_floor_itv.\nQed.",
    "Lemma real_floorDrz : {in Rreal & int_num, {morph floor : x y / x + y}}.\nProof. by move=> x y xr yz; rewrite addrC real_floorDzr // addrC. Qed.",
    "Lemma floorN : {in int_num, {morph floor : x / - x}}.\nProof. by move=> _ /intrP[m ->]; rewrite -rmorphN !intrKfloor. Qed.",
    "Lemma floorM : {in int_num &, {morph floor : x y / x * y}}.\nProof.\nby move=> _ _ /intrP[m1 ->] /intrP[m2 ->]; rewrite -rmorphM !intrKfloor.\nQed.",
    "Lemma floorX n : {in int_num, {morph floor : x / x ^+ n}}.\nProof. by move=> _ /intrP[m ->]; rewrite -rmorphXn !intrKfloor. Qed.",
    "Lemma real_floor_ge0 x : x \\is Rreal -> (0 <= floor x) = (0 <= x).\nProof. by move=> ?; rewrite real_floor_ge_int_tmp. Qed.",
    "Lemma floor_lt0 x : (floor x < 0) = (x < 0).\nProof.\ncase: ifP (floorP x) => [xr _ | xr /eqP <-]; first by rewrite real_floor_lt_int.\nby rewrite ltxx; apply/esym/(contraFF _ xr)/ltr0_real.\nQed.",
    "Lemma real_floor_le0 x : x \\is Rreal -> (floor x <= 0) = (x < 1).\nProof. by move=> ?; rewrite -ltzD1 add0r real_floor_lt_int. Qed.",
    "Lemma floor_gt0 x : (floor x > 0) = (x >= 1).\nProof.\ncase: ifP (floorP x) => [xr _ | xr /eqP->].\n  by rewrite gtz0_ge1 real_floor_ge_int_tmp.\nby rewrite ltxx; apply/esym/(contraFF _ xr)/ger1_real.\nQed.",
    "Lemma floor_neq0 x : (floor x != 0) = (x < 0) || (x >= 1).\nProof.\ncase: ifP (floorP x) => [xr _ | xr /eqP->]; rewrite ?eqxx/=.\n  by rewrite neq_lt floor_lt0 floor_gt0.\nby apply/esym/(contraFF _ xr) => /orP[/ltr0_real|/ger1_real].\nQed.",
    "Lemma floorpK : {in polyOver int_num, cancel (map_poly floor) (map_poly intr)}.\nProof.\nmove=> p /(all_nthP 0) Zp; apply/polyP=> i.\nrewrite coef_map coef_map_id0 //= -[p]coefK coef_poly.\nby case: ifP => [/Zp/floorK // | _]; rewrite floor0.\nQed.",
    "Lemma floorpP (p : {poly R}) :\n  p \\is a polyOver int_num -> {q | p = map_poly intr q}.\nProof. by exists (map_poly floor p); rewrite floorpK. Qed.",
    "Lemma real_ceil_itv x : x \\is Rreal -> (ceil x - 1)%:~R < x <= (ceil x)%:~R.\nProof.\nrewrite ceilNfloor -opprD !intrN ltrNl lerNr andbC -realN.\nexact: real_floor_itv.\nQed.",
    "Lemma real_ceilB1_lt x : x \\is Rreal -> (ceil x - 1)%:~R < x.\nProof. by case/real_ceil_itv/andP. Qed.",
    "Lemma real_ceil_ge x : x \\is Rreal -> x <= (ceil x)%:~R.\nProof. by case/real_ceil_itv/andP. Qed.",
    "Lemma ceil_def x m : (m - 1)%:~R < x <= m%:~R -> ceil x = m.\nProof.\nrewrite -ltrN2 -lerN2 andbC -!intrN opprD opprK ceilNfloor.\nby move=> /floor_def ->; rewrite opprK.\nQed.",
    "Lemma real_ceil_le_int_tmp x n : x \\is Rreal -> (ceil x <= n) = (x <= n%:~R).\nProof.\nrewrite ceilNfloor lerNl -realN => /real_floor_ge_int_tmp ->.\nby rewrite intrN lerN2.\nQed.",
    "Lemma real_ceil_le_int x n : x \\is Rreal -> x <= n%:~R = (ceil x <= n).\nProof. by move=> ?; rewrite real_ceil_le_int_tmp. Qed.",
    "Lemma real_ceil_gt_int x n : x \\is Rreal -> (n < ceil x) = (n%:~R < x).\nProof.\nby move=> ?; rewrite [RHS]real_ltNge ?realz -?real_ceil_le_int_tmp ?ltNge.\nQed.",
    "Lemma real_ceil_eq x n : x \\is Rreal ->\n  (ceil x == n) = ((n - 1)%:~R < x <= n%:~R).\nProof.\nby move=> xr; apply/eqP/idP => [<-|]; [exact: real_ceil_itv|exact: ceil_def].\nQed.",
    "Lemma le_ceil_tmp : {homo ceil : x y / x <= y}.\nProof. by move=> x y lexy; rewrite !ceilNfloor lerN2 le_floor ?lerN2. Qed.",
    "Lemma intrKceil : cancel intr ceil.\nProof. by move=> m; rewrite ceilNfloor -intrN intrKfloor opprK. Qed.",
    "Lemma intrEceil x : x \\is a int_num = ((ceil x)%:~R == x).\nProof. by rewrite -rpredN intrEfloor -eqr_oppLR -intrN -ceilNfloor. Qed.",
    "Lemma ceilK : {in int_num, cancel ceil intr}.\nProof. by move=> z; rewrite intrEceil => /eqP. Qed.",
    "Lemma ceil0 : ceil 0 = 0. Proof. exact: intrKceil 0. Qed.",
    "Lemma ceil1 : ceil 1 = 1. Proof. exact: intrKceil 1. Qed.",
    "Lemma real_ceilDzr : {in int_num & Rreal, {morph ceil : x y / x + y}}.\nProof.\nmove=> x y x_int y_real.\nby rewrite ceilNfloor opprD real_floorDzr ?rpredN // opprD -!ceilNfloor.\nQed.",
    "Lemma real_ceilDrz : {in Rreal & int_num, {morph ceil : x y / x + y}}.\nProof. by move=> x y xr yz; rewrite addrC real_ceilDzr // addrC. Qed.",
    "Lemma ceilN : {in int_num, {morph ceil : x / - x}}.\nProof. by move=> ? ?; rewrite !ceilNfloor !opprK floorN. Qed.",
    "Lemma ceilM : {in int_num &, {morph ceil : x y / x * y}}.\nProof.\nby move=> _ _ /intrP[m1 ->] /intrP[m2 ->]; rewrite -rmorphM !intrKceil.\nQed.",
    "Lemma ceilX n : {in int_num, {morph ceil : x / x ^+ n}}.\nProof. by move=> _ /intrP[m ->]; rewrite -rmorphXn !intrKceil. Qed.",
    "Lemma real_ceil_ge0 x : x \\is Rreal -> (0 <= ceil x) = (-1 < x).\nProof.\nby move=> ?; rewrite ceilNfloor oppr_ge0 real_floor_le0 ?realN 1?ltrNl.\nQed.",
    "Lemma ceil_lt0 x : (ceil x < 0) = (x <= -1).\nProof. by rewrite ceilNfloor oppr_lt0 floor_gt0 lerNr. Qed.",
    "Lemma real_ceil_le0 x : x \\is Rreal -> (ceil x <= 0) = (x <= 0).\nProof. by move=> ?; rewrite real_ceil_le_int_tmp. Qed.",
    "Lemma ceil_gt0 x : (ceil x > 0) = (x > 0).\nProof. by rewrite ceilNfloor oppr_gt0 floor_lt0 oppr_lt0. Qed.",
    "Lemma ceil_neq0 x : (ceil x != 0) = (x <= -1) || (x > 0).\nProof. by rewrite ceilNfloor oppr_eq0 floor_neq0 oppr_lt0 lerNr orbC. Qed.",
    "Lemma real_ceil_floor x : x \\is Rreal ->\n  ceil x = floor x + (x \\isn't a int_num).\nProof.\ncase Ix: (x \\is a int_num) => Rx /=.\n  by apply/eqP; rewrite addr0 ceilNfloor eqr_oppLR floorN.\napply/ceil_def; rewrite addrK; move: (real_floor_itv Rx).\nby rewrite le_eqVlt -intrEfloor Ix /= => /andP[-> /ltW].\nQed.",
    "Lemma truncn_floor x : truncn x = if 0 <= x then `|floor x|%N else 0%N.\nProof.\nmove: (floorP x); rewrite truncEfloor realE.\nhave [/le_floor|_]/= := boolP (0 <= x); first by rewrite floor0; case: floor.\nby case: ifP => [/le_floor|_ /eqP->//]; rewrite floor0; case: floor => [[]|].\nQed.",
    "Lemma truncnP x :\n  if 0 <= x then (truncn x)%:R <= x < (truncn x).+1%:R else truncn x == 0%N.\nProof.\nrewrite truncn_floor.\ncase: (boolP (0 <= x)) => //= /[dup] /le_floor + /ger0_real/real_floor_itv.\nby rewrite floor0; case: (floor x) => // n _; rewrite absz_nat addrC -intS.\nQed.",
    "Lemma truncn_itv x : 0 <= x -> (truncn x)%:R <= x < (truncn x).+1%:R.\nProof. by move=> x_ge0; move: (truncnP x); rewrite x_ge0. Qed.",
    "Lemma truncn_le x : (truncn x)%:R <= x = (0 <= x).\nProof. by case: ifP (truncnP x) => [+ /andP[] | + /eqP->//]. Qed.",
    "Lemma real_truncnS_gt x : x \\is Rreal -> x < (truncn x).+1%:R.\nProof. by move/real_ge0P => [/truncn_itv/andP[]|/lt_le_trans->]. Qed.",
    "Lemma truncn_def x n : n%:R <= x < n.+1%:R -> truncn x = n.\nProof.\ncase/andP=> lemx ltxm1; apply/eqP; rewrite eqn_leq -ltnS -[(n <= _)%N]ltnS.\nhave/truncn_itv/andP[lefx ltxf1]: 0 <= x by apply: le_trans lemx; apply: ler0n.\nby rewrite -!(ltr_nat R) 2?(@le_lt_trans _ _ x).\nQed.",
    "Lemma truncn_ge_nat x n : 0 <= x -> (n <= truncn x)%N = (n%:R <= x).\nProof.\nmove=> /truncn_itv /andP[letx ltxt1]; apply/idP/idP => lenx.\n  by apply: le_trans letx; rewrite ler_nat.\nby rewrite -ltnS -(ltr_nat R); apply: le_lt_trans ltxt1.\nQed.",
    "Lemma truncn_gt_nat x n : (n < truncn x)%N = (n.+1%:R <= x).\nProof.\ncase: ifP (truncnP x) => [x0 _ | x0 /eqP->]; first by rewrite truncn_ge_nat.\nby rewrite ltn0; apply/esym/(contraFF _ x0)/le_trans.\nQed.",
    "Lemma truncn_lt_nat x n : 0 <= x -> (truncn x < n)%N = (x < n%:R).\nProof. by move=> ?; rewrite real_ltNge ?ger0_real// ltnNge truncn_ge_nat. Qed.",
    "Lemma real_truncn_le_nat x n : x \\is Rreal -> (truncn x <= n)%N = (x < n.+1%:R).\nProof. by move=> ?; rewrite real_ltNge// leqNgt truncn_gt_nat. Qed.",
    "Lemma truncn_eq x n : 0 <= x -> (truncn x == n) = (n%:R <= x < n.+1%:R).\nProof.\nby move=> xr; apply/eqP/idP => [<-|]; [exact: truncn_itv|exact: truncn_def].\nQed.",
    "Lemma le_truncn : {homo truncn : x y / x <= y >-> (x <= y)%N}.\nProof.\nmove=> x y lexy; move: (truncnP x) (truncnP y).\ncase: ifP => [x0 /andP[letx _] | x0 /eqP->//].\ncase: ifP => [y0 /andP[_] | y0 /eqP->]; [|by rewrite (le_trans x0 lexy) in y0].\nby move=> /(le_lt_trans lexy) /(le_lt_trans letx); rewrite ltr_nat ltnS.\nQed.",
    "Lemma natrK : cancel (GRing.natmul 1) truncn.\nProof. by move=> m; apply: truncn_def; rewrite ler_nat ltr_nat ltnS leqnn. Qed.",
    "Lemma natrEtruncn x : (x \\is a nat_num) = ((truncn x)%:R == x).\nProof.\nby apply/natrP/eqP => [[n ->]|<-]; [rewrite natrK | exists (truncn x)].\nQed.",
    "Lemma archi_boundP x : 0 <= x -> x < (bound x)%:R.\nProof.\nmove=> x_ge0; case/truncn_itv/andP: (normr_ge0 x) => _.\nexact/le_lt_trans/real_ler_norm/ger0_real.\nQed.",
    "Lemma truncnK : {in nat_num, cancel truncn (GRing.natmul 1)}.\nProof. by move=> x; rewrite natrEtruncn => /eqP. Qed.",
    "Lemma truncn0 : truncn 0 = 0%N. Proof. exact: natrK 0%N. Qed.",
    "Lemma truncn1 : truncn 1 = 1%N. Proof. exact: natrK 1%N. Qed.",
    "Lemma truncnD :\n  {in nat_num & Rnneg, {morph truncn : x y / x + y >-> (x + y)%N}}.\nProof.\nmove=> _ y /natrP[n ->] y_ge0; apply: truncn_def.\nby rewrite -addnS !natrD !natrK lerD2l ltrD2l truncn_itv.\nQed.",
    "Lemma truncnM : {in nat_num &, {morph truncn : x y / x * y >-> (x * y)%N}}.\nProof. by move=> _ _ /natrP[n1 ->] /natrP[n2 ->]; rewrite -natrM !natrK. Qed.",
    "Lemma truncnX n : {in nat_num, {morph truncn : x / x ^+ n >-> (x ^ n)%N}}.\nProof. by move=> _ /natrP[n1 ->]; rewrite -natrX !natrK. Qed.",
    "Lemma truncn_gt0 x : (0 < truncn x)%N = (1 <= x).\nProof.\ncase: ifP (truncnP x) => [x0 | x0 /eqP<-]; first by rewrite truncn_ge_nat.\nby rewrite ltnn; apply/esym/(contraFF _ x0)/le_trans.\nQed.",
    "Lemma truncn0Pn x : reflect (truncn x = 0%N) (~~ (1 <= x)).\nProof. by rewrite -truncn_gt0 -eqn0Ngt; apply: eqP. Qed.",
    "Lemma sum_truncnK I r (P : pred I) F : (forall i, P i -> F i \\is a nat_num) ->\n  (\\sum_(i <- r | P i) truncn (F i))%:R = \\sum_(i <- r | P i) F i.\nProof. by rewrite natr_sum => natr; apply: eq_bigr => i /natr /truncnK. Qed.",
    "Lemma prod_truncnK I r (P : pred I) F : (forall i, P i -> F i \\is a nat_num) ->\n  (\\prod_(i <- r | P i) truncn (F i))%:R = \\prod_(i <- r | P i) F i.\nProof. by rewrite natr_prod => natr; apply: eq_bigr => i /natr /truncnK. Qed.",
    "Lemma natr_sum_eq1 (I : finType) (P : pred I) (F : I -> R) :\n     (forall i, P i -> F i \\is a nat_num) -> \\sum_(i | P i) F i = 1 ->\n   {i : I | [/\\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]}.\nProof.\nmove=> natF /eqP; rewrite -sum_truncnK// -[1]/1%:R eqr_nat => /sum_nat_eq1 exi.\nhave [i /and3P[Pi /eqP f1 /forallP a]] : {i : I | [&& P i, truncn (F i) == 1\n    & [forall j : I, ((j != i) ==> P j ==> (truncn (F j) == 0))]]}.\n  apply/sigW; have [i [Pi /eqP f1 a]] := exi; exists i; apply/and3P; split=> //.\n  by apply/forallP => j; apply/implyP => ji; apply/implyP => Pj; apply/eqP/a.\nexists i; split=> [//||j ji Pj]; rewrite -[LHS]truncnK ?natF ?f1//; apply/eqP.\nby rewrite -[0]/0%:R eqr_nat; apply: implyP Pj; apply: implyP ji; apply: a.\nQed.",
    "Lemma natr_mul_eq1 x y :\n  x \\is a nat_num -> y \\is a nat_num -> (x * y == 1) = (x == 1) && (y == 1).\nProof. by do 2!move/truncnK <-; rewrite -natrM !pnatr_eq1 muln_eq1. Qed.",
    "Lemma natr_prod_eq1 (I : finType) (P : pred I) (F : I -> R) :\n    (forall i, P i -> F i \\is a nat_num) -> \\prod_(i | P i) F i = 1 ->\n  forall i, P i -> F i = 1.\nProof.\nmove=> natF /eqP; rewrite -prod_truncnK// -[1]/1%:R eqr_nat prod_nat_seq_eq1.\nmove/allP => a i Pi; apply/eqP; rewrite -[F i]truncnK ?natF// eqr_nat.\nby apply: implyP Pi; apply: a; apply: mem_index_enum.\nQed.",
    "Lemma raddfZ_nat a u : a \\is a nat_num -> f (a *: u) = a *: f u.\nProof. by move=> /natrP[n ->]; apply: raddfZnat. Qed.",
    "Lemma rpredZ_nat (S : addrClosed V) :\n  {in nat_num & S, forall z u, z *: u \\in S}.\nProof. by move=> _ u /natrP[n ->]; apply: rpredZnat. Qed.",
    "Lemma raddfZ_int a u : a \\is a int_num -> f (a *: u) = a *: f u.\nProof. by move=> /intrP[m ->]; rewrite !scaler_int raddfMz. Qed.",
    "Lemma rpredZ_int (S : zmodClosed V) :\n  {in int_num & S, forall z u, z *: u \\in S}.\nProof. by move=> _ u /intrP[m ->] ?; rewrite scaler_int rpredMz. Qed.",
    "Lemma aut_natr nu : {in nat_num, nu =1 id}.\nProof. by move=> _ /natrP[n ->]; apply: rmorph_nat. Qed.",
    "Lemma aut_intr nu : {in int_num, nu =1 id}.\nProof. by move=> _ /intrP[m ->]; apply: rmorph_int. Qed.",
    "Lemma upper_nthrootP x i : (bound x <= i)%N -> x < 2%:R ^+ i.\nProof.\ncase/truncn_itv/andP: (normr_ge0 x) => _ /ltr_normlW xlt le_b_i.\nby rewrite (lt_le_trans xlt) // -natrX ler_nat (ltn_trans le_b_i) // ltn_expl.\nQed.",
    "Lemma truncnS_gt x : x < (truncn x).+1%:R.\nProof. exact: real_truncnS_gt. Qed.",
    "Lemma truncn_le_nat x n : (truncn x <= n)%N = (x < n.+1%:R).\nProof. exact: real_truncn_le_nat. Qed.",
    "Lemma floor_itv x : (floor x)%:~R <= x < (floor x + 1)%:~R.\nProof. exact: real_floor_itv. Qed.",
    "Lemma floor_le_tmp x : (floor x)%:~R <= x. Proof. exact: real_floor_le. Qed.",
    "Lemma floorD1_gt x : x < (floor x + 1)%:~R.\nProof. exact: real_floorD1_gt. Qed.",
    "Lemma floor_ge_int x n : n%:~R <= x = (n <= floor x).\nProof. by rewrite real_floor_ge_int_tmp. Qed.",
    "Lemma floor_ge_int_tmp x n : (n <= floor x) = (n%:~R <= x).\nProof. exact: real_floor_ge_int_tmp. Qed.",
    "Lemma floor_lt_int x n : (floor x < n) = (x < n%:~R).\nProof. exact: real_floor_lt_int. Qed.",
    "Lemma floor_eq x n : (floor x == n) = (n%:~R <= x < (n + 1)%:~R).\nProof. exact: real_floor_eq. Qed.",
    "Lemma floorDzr : {in @int_num R, {morph floor : x y / x + y}}.\nProof. by move=> x xz y; apply/real_floorDzr/num_real. Qed.",
    "Lemma floorDrz x y : y \\is a int_num -> floor (x + y) = floor x + floor y.\nProof. by move=> yz; apply/real_floorDrz/yz/num_real. Qed.",
    "Lemma floor_ge0 x : (0 <= floor x) = (0 <= x).\nProof. exact: real_floor_ge0. Qed.",
    "Lemma floor_le0 x : (floor x <= 0) = (x < 1).\nProof. exact: real_floor_le0. Qed.",
    "Lemma ceil_itv x : (ceil x - 1)%:~R < x <= (ceil x)%:~R.\nProof. exact: real_ceil_itv. Qed.",
    "Lemma ceilB1_lt x : (ceil x - 1)%:~R < x.\nProof. exact: real_ceilB1_lt. Qed.",
    "Lemma ceil_ge x : x <= (ceil x)%:~R. Proof. exact: real_ceil_ge. Qed.",
    "Lemma ceil_le_int x n : x <= n%:~R = (ceil x <= n).\nProof. by rewrite real_ceil_le_int_tmp. Qed.",
    "Lemma ceil_le_int_tmp x n : (ceil x <= n) = (x <= n%:~R).\nProof. exact: real_ceil_le_int_tmp. Qed.",
    "Lemma ceil_gt_int x n : (n < ceil x) = (n%:~R < x).\nProof. exact: real_ceil_gt_int. Qed.",
    "Lemma ceil_eq x n : (ceil x == n) = ((n - 1)%:~R < x <= n%:~R).\nProof. exact: real_ceil_eq. Qed.",
    "Lemma ceilDzr : {in @int_num R, {morph ceil : x y / x + y}}.\nProof. by move=> x xz y; apply/real_ceilDzr/num_real. Qed.",
    "Lemma ceilDrz x y : y \\is a int_num -> ceil (x + y) = ceil x + ceil y.\nProof. by move=> yz; apply/real_ceilDrz/yz/num_real. Qed.",
    "Lemma ceil_ge0 x : (0 <= ceil x) = (-1 < x).\nProof. exact: real_ceil_ge0. Qed.",
    "Lemma ceil_le0 x : (ceil x <= 0) = (x <= 0).\nProof. exact: real_ceil_le0. Qed.",
    "Lemma ceil_floor x : ceil x = floor x + (x \\isn't a int_num).\nProof. exact: real_ceil_floor. Qed.",
    "Lemma natr_aut x : (nu x \\is a nat_num) = (x \\is a nat_num).\nProof. by apply/idP/idP=> /[dup] ? /(aut_natr nu) => [/fmorph_inj <-| ->]. Qed.",
    "Lemma intr_aut x : (nu x \\is a int_num) = (x \\is a int_num).\nProof. by rewrite !intrE -rmorphN !natr_aut. Qed.",
    "Lemma conj_natr x : x \\is a nat_num -> x^* = x.\nProof. by move/Rreal_nat/CrealP. Qed.",
    "Lemma conj_intr x : x \\is a int_num -> x^* = x.\nProof. by move/Rreal_int/CrealP. Qed.",
    "Lemma Znat_def (n : int) : (n \\is a nat_num) = (0 <= n).\nProof. by []. Qed.",
    "Lemma ZnatP (m : int) : reflect (exists n : nat, m = n) (m \\is a nat_num).\nProof. by case: m => m; constructor; [exists m | case]. Qed.",
    "Lemma boundP x : 0 <= x -> x < (bound x)%:R.\n  Proof. by move/ger0_norm=> {1}<-; rewrite /bound; case: (sigW _). Qed.",
    "Lemma truncnP x :\n    if 0 <= x then (truncn x)%:R <= x < (truncn x).+1%:R else truncn x == 0%N.\n  Proof.\n  rewrite /truncn; case: truncn_subproof => // n hn.\n  by case: ifP => x_ge0; rewrite ?(ifT _ _ x_ge0) ?(ifF _ _ x_ge0) // hn.\n  Qed.",
    "Lemma ltmxE : (A < B)%MS = ((A <= B)%MS && ~~ (B <= A)%MS). Proof. by []. Qed.",
    "Lemma ltmxW : (A < B)%MS -> (A <= B)%MS. Proof. by case/andP. Qed.",
    "Lemma ltmxEneq : (A < B)%MS = (A <= B)%MS && ~~ (A == B)%MS.\nProof. by apply: andb_id2l => ->. Qed.",
    "Lemma submxElt : (A <= B)%MS = (A == B)%MS || (A < B)%MS.\nProof. by rewrite -andb_orr orbN andbT. Qed.",
    "Lemma rank_leq_row m n (A : 'M_(m, n)) : \\rank A <= m.\nProof.\nrewrite mxrankE.\nelim: m n A => [|m IHm] [|n] //= A; case: pickP => [[i j] _|] //=.\nby move: (_ - _) => B; case: GaussE (IHm _ B) => [[L U] r] /=.\nQed.",
    "Lemma row_leq_rank m n (A : 'M_(m, n)) : (m <= \\rank A) = row_free A.\nProof. by rewrite /row_free eqn_leq rank_leq_row. Qed.",
    "Lemma rank_leq_col m n (A : 'M_(m, n)) : \\rank A <= n.\nProof.\nrewrite mxrankE.\nelim: m n A => [|m IHm] [|n] //= A; case: pickP => [[i j] _|] //=.\nby move: (_ - _) => B; case: GaussE (IHm _ B) => [[L U] r] /=.\nQed.",
    "Lemma col_leq_rank m n (A : 'M_(m, n)) : (n <= \\rank A) = row_full A.\nProof. by rewrite /row_full eqn_leq rank_leq_col. Qed.",
    "Lemma eq_row_full m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B)%MS -> row_full A = row_full B.\nProof. by rewrite /row_full => ->. Qed.",
    "Lemma row_ebase_unit m n (A : 'M_(m, n)) : row_ebase A \\in unitmx.\nProof.\nrewrite /row_ebase unlock; elim: m n A => [|m IHm] [|n] //= A.\ncase: pickP => [[i j] /= nzAij | //=]; move: (_ - _) => B.\ncase: GaussE (IHm _ B) => [[L U] r] /= uU.\nrewrite unitmxE xcolE det_mulmx (@det_ublock _ 1) det_scalar1 !unitrM.\nby rewrite unitfE nzAij -!unitmxE uU unitmx_perm.\nQed.",
    "Lemma col_ebase_unit m n (A : 'M_(m, n)) : col_ebase A \\in unitmx.\nProof.\nrewrite /col_ebase unlock; elim: m n A => [|m IHm] [|n] //= A.\ncase: pickP => [[i j] _|] //=; move: (_ - _) => B.\ncase: GaussE (IHm _ B) => [[L U] r] /= uL.\nrewrite unitmxE xrowE det_mulmx (@det_lblock _ 1) det1 mul1r unitrM.\nby rewrite -unitmxE unitmx_perm.\nQed.",
    "Lemma mulmx_ebase m n (A : 'M_(m, n)) :\n  col_ebase A *m pid_mx (\\rank A) *m row_ebase A = A.\nProof.\nrewrite mxrankE /col_ebase /row_ebase unlock.\nelim: m n A => [n A | m IHm]; first by rewrite [A]flatmx0 [_ *m _]flatmx0.\ncase=> [A | n]; first by rewrite [_ *m _]thinmx0 [A]thinmx0.\nrewrite -(add1n m) -?(add1n n) => A /=.\ncase: pickP => [[i0 j0] | A0] /=; last first.\n  apply/matrixP=> i j; rewrite pid_mx_0 mulmx0 mul0mx mxE.\n  by move/eqP: (A0 (i, j)).\nset a := A i0 j0 => nz_a; set A1 := xrow _ _ _.\nset u := ursubmx _; set v := _ *: _; set B : 'M_(m, n) := _ - _.\nmove: (rank_leq_col B) (rank_leq_row B) {IHm}(IHm n B); rewrite mxrankE.\ncase: (GaussE B) => [[L U] r] /= r_m r_n defB.\nhave ->: pid_mx (1 + r) = block_mx 1 0 0 (pid_mx r) :> 'M[F]_(1 + m, 1 + n).\n  rewrite -(subnKC r_m) -(subnKC r_n) pid_mx_block -col_mx0 -row_mx0.\n  by rewrite block_mxA castmx_id col_mx0 row_mx0 -scalar_mx_block -pid_mx_block.\nrewrite xcolE xrowE mulmxA -xcolE -!mulmxA.\nrewrite !(addr0, add0r, mulmx0, mul0mx, mulmx_block, mul1mx) mulmxA defB.\nrewrite addrC subrK mul_mx_scalar scalerA divff // scale1r.\nhave ->: a%:M = ulsubmx A1 by rewrite [_ A1]mx11_scalar !mxE !lshift0 !tpermR.\nrewrite submxK /A1 xrowE !xcolE -!mulmxA mulmxA -!perm_mxM !tperm2 !perm_mx1.\nby rewrite mulmx1 mul1mx.\nQed.",
    "Lemma mulmx_base m n (A : 'M_(m, n)) : col_base A *m row_base A = A.\nProof. by rewrite mulmxA -[col_base A *m _]mulmxA pid_mx_id ?mulmx_ebase. Qed.",
    "Lemma mulmx1_min_rank r m n (A : 'M_(m, n)) M N :\n  M *m A *m N = 1%:M :> 'M_r -> r <= \\rank A.\nProof. by rewrite -{1}(mulmx_base A) mulmxA -mulmxA; move/mulmx1_min. Qed.",
    "Lemma mulmx_max_rank r m n (M : 'M_(m, r)) (N : 'M_(r, n)) :\n  \\rank (M *m N) <= r.\nProof.\nset MN := M *m N; set rMN := \\rank _.\npose L : 'M_(rMN, m) := pid_mx rMN *m invmx (col_ebase MN).\npose U : 'M_(n, rMN) := invmx (row_ebase MN) *m pid_mx rMN.\nsuffices: L *m M *m (N *m U) = 1%:M by apply: mulmx1_min.\nrewrite mulmxA -(mulmxA L) -[M *m N]mulmx_ebase -/MN.\nby rewrite !mulmxA mulmxKV // mulmxK // !pid_mx_id /rMN ?pid_mx_1.\nQed.",
    "Lemma mxrank_tr m n (A : 'M_(m, n)) : \\rank A^T = \\rank A.\nProof.\napply/eqP; rewrite eqn_leq -{3}[A]trmxK -{1}(mulmx_base A) -{1}(mulmx_base A^T).\nby rewrite !trmx_mul !mulmx_max_rank.\nQed.",
    "Lemma mxrank_add m n (A B : 'M_(m, n)) : \\rank (A + B)%R <= \\rank A + \\rank B.\nProof.\nby rewrite -{1}(mulmx_base A) -{1}(mulmx_base B) -mul_row_col mulmx_max_rank.\nQed.",
    "Lemma mxrankM_maxl m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  \\rank (A *m B) <= \\rank A.\nProof. by rewrite -{1}(mulmx_base A) -mulmxA mulmx_max_rank. Qed.",
    "Lemma mxrankM_maxr m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  \\rank (A *m B) <= \\rank B.\nProof. by rewrite -mxrank_tr -(mxrank_tr B) trmx_mul mxrankM_maxl. Qed.",
    "Lemma mxrank_scale m n a (A : 'M_(m, n)) : \\rank (a *: A) <= \\rank A.\nProof. by rewrite -mul_scalar_mx mxrankM_maxr. Qed.",
    "Lemma mxrank_scale_nz m n a (A : 'M_(m, n)) :\n   a != 0 -> \\rank (a *: A) = \\rank A.\nProof.\nmove=> nza; apply/eqP; rewrite eqn_leq -{3}[A]scale1r -(mulVf nza).\nby rewrite -scalerA !mxrank_scale.\nQed.",
    "Lemma mxrank_opp m n (A : 'M_(m, n)) : \\rank (- A) = \\rank A.\nProof. by rewrite -scaleN1r mxrank_scale_nz // oppr_eq0 oner_eq0. Qed.",
    "Lemma mxrank0 m n : \\rank (0 : 'M_(m, n)) = 0%N.\nProof. by apply/eqP; rewrite -leqn0 -(@mulmx0 _ m 0 n 0) mulmx_max_rank. Qed.",
    "Lemma mxrank_eq0 m n (A : 'M_(m, n)) : (\\rank A == 0) = (A == 0).\nProof.\napply/eqP/eqP=> [rA0 | ->{A}]; last exact: mxrank0.\nmove: (col_base A) (row_base A) (mulmx_base A); rewrite rA0 => Ac Ar <-.\nby rewrite [Ac]thinmx0 mul0mx.\nQed.",
    "Lemma mulmx_coker m n (A : 'M_(m, n)) : A *m cokermx A = 0.\nProof.\nby rewrite -{1}[A]mulmx_ebase -!mulmxA mulKVmx // mul_pid_mx_copid ?mulmx0.\nQed.",
    "Lemma submxE m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS = (A *m cokermx B == 0).\nProof. by rewrite unlock. Qed.",
    "Lemma mulmxKpV m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS -> A *m pinvmx B *m B = A.\nProof.\nrewrite submxE !mulmxA mulmxBr mulmx1 subr_eq0 => /eqP defA.\nrewrite -{4}[B]mulmx_ebase -!mulmxA mulKmx //.\nby rewrite (mulmxA (pid_mx _)) pid_mx_id // !mulmxA -{}defA mulmxKV.\nQed.",
    "Lemma mulmxVp m n (A : 'M[F]_(m, n)) : row_free A -> A *m pinvmx A = 1%:M.\nProof.\nmove=> fA; rewrite -[X in X *m _]mulmx_ebase !mulmxA mulmxK ?row_ebase_unit//.\nrewrite -[X in X *m _]mulmxA mul_pid_mx !minnn (minn_idPr _) ?rank_leq_col//.\nby rewrite (eqP fA) pid_mx_1 mulmx1 mulmxV ?col_ebase_unit.\nQed.",
    "Lemma mulmxKp p m n (B : 'M[F]_(m, n)) : row_free B ->\n  cancel ((@mulmx _ p _ _)^~ B) (mulmx^~ (pinvmx B)).\nProof. by move=> ? A; rewrite -mulmxA mulmxVp ?mulmx1. Qed.",
    "Lemma submxP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (exists D, A = D *m B) (A <= B)%MS.\nProof.\napply: (iffP idP) => [/mulmxKpV | [D ->]]; first by exists (A *m pinvmx B).\nby rewrite submxE -mulmxA mulmx_coker mulmx0.\nQed.",
    "Lemma submx_refl m n (A : 'M_(m, n)) : (A <= A)%MS.\nProof. by rewrite submxE mulmx_coker. Qed.",
    "Lemma submxMl m n p (D : 'M_(m, n)) (A : 'M_(n, p)) : (D *m A <= A)%MS.\nProof. by rewrite submxE -mulmxA mulmx_coker mulmx0. Qed.",
    "Lemma submxMr m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  (A <= B)%MS -> (A *m C <= B *m C)%MS.\nProof. by case/submxP=> D ->; rewrite -mulmxA submxMl. Qed.",
    "Lemma mulmx_sub m n1 n2 p (C : 'M_(m, n1)) A (B : 'M_(n2, p)) :\n  (A <= B -> C *m A <= B)%MS.\nProof. by case/submxP=> D ->; rewrite mulmxA submxMl. Qed.",
    "Lemma submx_trans m1 m2 m3 n\n                 (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= B -> B <= C -> A <= C)%MS.\nProof. by case/submxP=> D ->{A}; apply: mulmx_sub. Qed.",
    "Lemma ltmx_sub_trans m1 m2 m3 n\n                     (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A < B)%MS -> (B <= C)%MS -> (A < C)%MS.\nProof.\ncase/andP=> sAB ltAB sBC; rewrite ltmxE (submx_trans sAB) //.\nby apply: contra ltAB; apply: submx_trans.\nQed.",
    "Lemma sub_ltmx_trans m1 m2 m3 n\n                     (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= B)%MS -> (B < C)%MS -> (A < C)%MS.\nProof.\nmove=> sAB /andP[sBC ltBC]; rewrite ltmxE (submx_trans sAB) //.\nby apply: contra ltBC => sCA; apply: submx_trans sAB.\nQed.",
    "Lemma ltmx_trans m n : transitive (@ltmx F m m n).\nProof. by move=> A B C; move/ltmxW; apply: sub_ltmx_trans. Qed.",
    "Lemma ltmx_irrefl m n : irreflexive (@ltmx F m m n).\nProof. by move=> A; rewrite /ltmx submx_refl andbF. Qed.",
    "Lemma sub0mx m1 m2 n (A : 'M_(m2, n)) : ((0 : 'M_(m1, n)) <= A)%MS.\nProof. by rewrite submxE mul0mx. Qed.",
    "Lemma submx0null m1 m2 n (A : 'M[F]_(m1, n)) :\n  (A <= (0 : 'M_(m2, n)))%MS -> A = 0.\nProof. by case/submxP=> D; rewrite mulmx0. Qed.",
    "Lemma submx0 m n (A : 'M_(m, n)) : (A <= (0 : 'M_n))%MS = (A == 0).\nProof. by apply/idP/eqP=> [|->]; [apply: submx0null | apply: sub0mx]. Qed.",
    "Lemma lt0mx m n (A : 'M_(m, n)) : ((0 : 'M_n) < A)%MS = (A != 0).\nProof. by rewrite /ltmx sub0mx submx0. Qed.",
    "Lemma ltmx0 m n (A : 'M[F]_(m, n)) : (A < (0 : 'M_n))%MS = false.\nProof. by rewrite /ltmx sub0mx andbF. Qed.",
    "Lemma eqmx0P m n (A : 'M_(m, n)) : reflect (A = 0) (A == (0 : 'M_n))%MS.\nProof. by rewrite submx0 sub0mx andbT; apply: eqP. Qed.",
    "Lemma eqmx_eq0 m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B)%MS -> (A == 0) = (B == 0).\nProof. by move=> eqAB; rewrite -!submx0 eqAB. Qed.",
    "Lemma addmx_sub m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m1, n)) (C : 'M_(m2, n)) :\n  (A <= C)%MS -> (B <= C)%MS -> ((A + B)%R <= C)%MS.\nProof.\nby case/submxP=> A' ->; case/submxP=> B' ->; rewrite -mulmxDl submxMl.\nQed.",
    "Lemma rowsub_sub m1 m2 n (f : 'I_m2 -> 'I_m1) (A : 'M_(m1, n)) :\n  (rowsub f A <= A)%MS.\nProof. by rewrite rowsubE mulmx_sub. Qed.",
    "Lemma summx_sub m1 m2 n (B : 'M_(m2, n))\n                I (r : seq I) (P : pred I) (A_ : I -> 'M_(m1, n)) :\n  (forall i, P i -> A_ i <= B)%MS -> ((\\sum_(i <- r | P i) A_ i)%R <= B)%MS.\nProof.\nby move=> leAB; elim/big_ind: _ => // [|C D]; [apply/sub0mx | apply/addmx_sub].\nQed.",
    "Lemma scalemx_sub m1 m2 n a (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS -> (a *: A <= B)%MS.\nProof. by case/submxP=> A' ->; rewrite scalemxAl submxMl. Qed.",
    "Lemma row_sub m n i (A : 'M_(m, n)) : (row i A <= A)%MS.\nProof. exact: rowsub_sub. Qed.",
    "Lemma eq_row_sub m n v (A : 'M_(m, n)) i : row i A = v -> (v <= A)%MS.\nProof. by move <-; rewrite row_sub. Qed.",
    "Lemma nz_row_sub m n (A : 'M_(m, n)) : (nz_row A <= A)%MS.\nProof. by rewrite /nz_row; case: pickP => [i|] _; rewrite ?row_sub ?sub0mx. Qed.",
    "Lemma row_subP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (forall i, row i A <= B)%MS (A <= B)%MS.\nProof.\napply: (iffP idP) => [sAB i|sAB].\n  by apply: submx_trans sAB; apply: row_sub.\nrewrite submxE; apply/eqP/row_matrixP=> i; apply/eqP.\nby rewrite row_mul row0 -submxE.\nQed.",
    "Lemma rV_subP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (forall v : 'rV_n, v <= A -> v <= B)%MS (A <= B)%MS.\nProof.\napply: (iffP idP) => [sAB v Av | sAB]; first exact: submx_trans sAB.\nby apply/row_subP=> i; rewrite sAB ?row_sub.\nQed.",
    "Lemma row_subPn m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (exists i, ~~ (row i A <= B)%MS) (~~ (A <= B)%MS).\nProof. by rewrite (sameP row_subP forallP); apply: forallPn. Qed.",
    "Lemma sub_rVP n (u v : 'rV[F]_n) : reflect (exists a, u = a *: v) (u <= v)%MS.\nProof.\napply: (iffP submxP) => [[w ->] | [a ->]].\n  by exists (w 0 0); rewrite -mul_scalar_mx -mx11_scalar.\nby exists a%:M; rewrite mul_scalar_mx.\nQed.",
    "Lemma rank_rV n (v : 'rV[F]_n) : \\rank v = (v != 0).\nProof.\ncase: eqP => [-> | nz_v]; first by rewrite mxrank0.\nby apply/eqP; rewrite eqn_leq rank_leq_row lt0n mxrank_eq0; apply/eqP.\nQed.",
    "Lemma rowV0Pn m n (A : 'M_(m, n)) :\n  reflect (exists2 v : 'rV_n, v <= A & v != 0)%MS (A != 0).\nProof.\nrewrite -submx0; apply: (iffP idP) => [| [v svA]]; last first.\n  by rewrite -submx0; apply: contra (submx_trans _).\nby case/row_subPn=> i; rewrite submx0; exists (row i A); rewrite ?row_sub.\nQed.",
    "Lemma rowV0P m n (A : 'M_(m, n)) :\n  reflect (forall v : 'rV_n, v <= A -> v = 0)%MS (A == 0).\nProof.\nrewrite -[A == 0]negbK; case: rowV0Pn => IH.\n  by right; case: IH => v svA nzv IH; case/eqP: nzv; apply: IH.\nby left=> v svA; apply/eqP/idPn=> nzv; case: IH; exists v.\nQed.",
    "Lemma submx_full m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  row_full B -> (A <= B)%MS.\nProof.\nby rewrite submxE /cokermx => /eqnP->; rewrite /copid_mx pid_mx_1 subrr !mulmx0.\nQed.",
    "Lemma row_fullP m n (A : 'M_(m, n)) :\n  reflect (exists B, B *m A = 1%:M) (row_full A).\nProof.\napply: (iffP idP) => [Afull | [B kA]].\n  by exists (1%:M *m pinvmx A); apply: mulmxKpV (submx_full _ Afull).\nby rewrite [_ A]eqn_leq rank_leq_col (mulmx1_min_rank B 1%:M) ?mulmx1.\nQed.",
    "Lemma row_full_inj m n p A : row_full A -> injective (@mulmx F m n p A).\nProof.\ncase/row_fullP=> A' A'K; apply: can_inj (mulmx A') _ => B.\nby rewrite mulmxA A'K mul1mx.\nQed.",
    "Lemma row_freeP m n (A : 'M_(m, n)) :\n  reflect (exists B, A *m B = 1%:M) (row_free A).\nProof.\nrewrite /row_free -mxrank_tr.\napply: (iffP row_fullP) => [] [B kA];\n  by exists B^T; rewrite -trmx1 -kA trmx_mul ?trmxK.\nQed.",
    "Lemma row_free_inj m n p A : row_free A -> injective ((@mulmx F m n p)^~ A).\nProof.\ncase/row_freeP=> A' AK; apply: can_inj (mulmx^~ A') _ => B.\nby rewrite -mulmxA AK mulmx1.\nQed.",
    "Lemma row_free_unit n (A : 'M_n) : row_free A = (A \\in unitmx).\nProof.\napply/row_fullP/idP=> [[A'] | uA]; first by case/mulmx1_unit.\nby exists (invmx A); rewrite mulVmx.\nQed.",
    "Lemma row_full_unit n (A : 'M_n) : row_full A = (A \\in unitmx).\nProof. exact: row_free_unit. Qed.",
    "Lemma mxrank_unit n (A : 'M_n) : A \\in unitmx -> \\rank A = n.\nProof. by rewrite -row_full_unit => /eqnP. Qed.",
    "Lemma mxrank1 n : \\rank (1%:M : 'M_n) = n. Proof. exact: mxrank_unit. Qed.",
    "Lemma mxrank_delta m n i j : \\rank (delta_mx i j : 'M_(m, n)) = 1.\nProof.\napply/eqP; rewrite eqn_leq lt0n mxrank_eq0.\nrewrite -{1}(mul_delta_mx (0 : 'I_1)) mulmx_max_rank.\nby apply/eqP; move/matrixP; move/(_ i j); move/eqP; rewrite !mxE !eqxx oner_eq0.\nQed.",
    "Lemma mxrankS m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS -> \\rank A <= \\rank B.\nProof. by case/submxP=> D ->; rewrite mxrankM_maxr. Qed.",
    "Lemma submx1 m n (A : 'M_(m, n)) : (A <= 1%:M)%MS.\nProof. by rewrite submx_full // row_full_unit unitmx1. Qed.",
    "Lemma sub1mx m n (A : 'M_(m, n)) : (1%:M <= A)%MS = row_full A.\nProof.\napply/idP/idP; last exact: submx_full.\nby move/mxrankS; rewrite mxrank1 col_leq_rank.\nQed.",
    "Lemma ltmx1 m n (A : 'M_(m, n)) : (A < 1%:M)%MS = ~~ row_full A.\nProof. by rewrite /ltmx sub1mx submx1. Qed.",
    "Lemma lt1mx m n (A : 'M_(m, n)) : (1%:M < A)%MS = false.\nProof. by rewrite /ltmx submx1 andbF. Qed.",
    "Lemma pinvmxE n (A : 'M[F]_n) : A \\in unitmx -> pinvmx A = invmx A.\nProof.\nmove=> A_unit; apply: (@row_free_inj _ _ _ A); rewrite ?row_free_unit//.\nby rewrite -[pinvmx _]mul1mx mulmxKpV ?sub1mx ?row_full_unit// mulVmx.\nQed.",
    "Lemma mulVpmx m n (A : 'M[F]_(m, n)) : row_full A -> pinvmx A *m A = 1%:M.\nProof. by move=> fA; rewrite -[pinvmx _]mul1mx mulmxKpV// sub1mx. Qed.",
    "Lemma pinvmx_free m n (A : 'M[F]_(m, n)) : row_full A -> row_free (pinvmx A).\nProof. by move=> /mulVpmx pAA1; apply/row_freeP; exists A. Qed.",
    "Lemma pinvmx_full m n (A : 'M[F]_(m, n)) : row_free A -> row_full (pinvmx A).\nProof. by move=> /mulmxVp ApA1; apply/row_fullP; exists A. Qed.",
    "Lemma eqmxP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (A :=: B)%MS (A == B)%MS.\nProof.\napply: (iffP andP) => [[sAB sBA] | eqAB]; last by rewrite !eqAB.\nsplit=> [|m3 C]; first by apply/eqP; rewrite eqn_leq !mxrankS.\nsplit; first by apply/idP/idP; apply: submx_trans.\nby apply/idP/idP=> sC; apply: submx_trans sC _.\nQed.",
    "Lemma rV_eqP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (forall u : 'rV_n, (u <= A) = (u <= B))%MS (A == B)%MS.\nProof.\napply: (iffP idP) => [eqAB u | eqAB]; first by rewrite (eqmxP eqAB).\nby apply/andP; split; apply/rV_subP=> u; rewrite eqAB.\nQed.",
    "Lemma mulmxP (m n : nat) (A B : 'M[F]_(m, n)) :\n  reflect (forall u : 'rV_m, u *m A = u *m B) (A == B).\nProof.\napply: (iffP eqP) => [-> //|eqAB].\napply: (@row_full_inj _ _ _ 1%:M); first by rewrite row_full_unit unitmx1.\nby apply/row_matrixP => i; rewrite !row_mul eqAB.\nQed.",
    "Lemma eqmx_refl m1 n (A : 'M_(m1, n)) : (A :=: A)%MS.\nProof. by []. Qed.",
    "Lemma eqmx_sym m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B)%MS -> (B :=: A)%MS.\nProof. by move=> eqAB; split=> [|m3 C]; rewrite !eqAB. Qed.",
    "Lemma eqmx_trans m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A :=: B)%MS -> (B :=: C)%MS -> (A :=: C)%MS.\nProof. by move=> eqAB eqBC; split=> [|m4 D]; rewrite !eqAB !eqBC. Qed.",
    "Lemma eqmx_rank m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A == B)%MS -> \\rank A = \\rank B.\nProof. by move/eqmxP->. Qed.",
    "Lemma lt_eqmx m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n    (A :=: B)%MS ->\n  forall C : 'M_(m3, n), (((A < C) = (B < C))%MS * ((C < A) = (C < B))%MS)%type.\nProof. by move=> eqAB C; rewrite /ltmx !eqAB. Qed.",
    "Lemma eqmxMr m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  (A :=: B)%MS -> (A *m C :=: B *m C)%MS.\nProof. by move=> eqAB; apply/eqmxP; rewrite !submxMr ?eqAB. Qed.",
    "Lemma eqmxMfull m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  row_full A -> (A *m B :=: B)%MS.\nProof.\ncase/row_fullP=> A' A'A; apply/eqmxP; rewrite submxMl /=.\nby apply/submxP; exists A'; rewrite mulmxA A'A mul1mx.\nQed.",
    "Lemma eqmx0 m n : ((0 : 'M[F]_(m, n)) :=: (0 : 'M_n))%MS.\nProof. by apply/eqmxP; rewrite !sub0mx. Qed.",
    "Lemma eqmx_scale m n a (A : 'M_(m, n)) : a != 0 -> (a *: A :=: A)%MS.\nProof.\nmove=> nz_a; apply/eqmxP; rewrite scalemx_sub //.\nby rewrite -{1}[A]scale1r -(mulVf nz_a) -scalerA scalemx_sub.\nQed.",
    "Lemma eqmx_opp m n (A : 'M_(m, n)) : (- A :=: A)%MS.\nProof.\nby rewrite -scaleN1r; apply: eqmx_scale => //; rewrite oppr_eq0 oner_eq0.\nQed.",
    "Lemma submxMfree m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  row_free C -> (A *m C <= B *m C)%MS = (A <= B)%MS.\nProof.\ncase/row_freeP=> C' C_C'_1; apply/idP/idP=> sAB; last exact: submxMr.\nby rewrite -[A]mulmx1 -[B]mulmx1 -C_C'_1 !mulmxA submxMr.\nQed.",
    "Lemma eqmxMfree m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  row_free C -> (A *m C :=: B *m C)%MS -> (A :=: B)%MS.\nProof.\nby move=> Cfree eqAB; apply/eqmxP; move/eqmxP: eqAB; rewrite !submxMfree.\nQed.",
    "Lemma mxrankMfree m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  row_free B -> \\rank (A *m B) = \\rank A.\nProof.\nby move=> Bfree; rewrite -mxrank_tr trmx_mul eqmxMfull /row_full mxrank_tr.\nQed.",
    "Lemma eq_row_base m n (A : 'M_(m, n)) : (row_base A :=: A)%MS.\nProof.\napply/eqmxP/andP; split; apply/submxP.\n  exists (pid_mx (\\rank A) *m invmx (col_ebase A)).\n  by rewrite -{8}[A]mulmx_ebase !mulmxA mulmxKV // pid_mx_id.\nexists (col_ebase A *m pid_mx (\\rank A)).\nby rewrite mulmxA -(mulmxA _ _ (pid_mx _)) pid_mx_id // mulmx_ebase.\nQed.",
    "Lemma row_base0 (m n : nat) : row_base (0 : 'M[F]_(m, n)) = 0.\nProof. by apply/eqmx0P; rewrite !eq_row_base !sub0mx. Qed.",
    "Lemma genmxE m n (A : 'M_(m, n)) : (<<A>> :=: A)%MS.\nProof.\nby rewrite unlock; apply/eqmxP; case/andP: (chooseP (genmx_witnessP A)).\nQed.",
    "Lemma eq_genmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :=: B -> <<A>> = <<B>>)%MS.\nProof.\nmove=> eqAB; rewrite unlock.\nhave{} eqAB: equivmx A (row_full A) =1 equivmx B (row_full B).\n  by move=> C; rewrite /row_full /equivmx !eqAB.\nrewrite (eq_choose eqAB) (choose_id _ (genmx_witnessP B)) //.\nby rewrite -eqAB genmx_witnessP.\nQed.",
    "Lemma genmxP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (<<A>> = <<B>>)%MS (A == B)%MS.\nProof.\napply: (iffP idP) => eqAB; first exact: eq_genmx (eqmxP _).\nby rewrite -!(genmxE A) eqAB !genmxE andbb.\nQed.",
    "Lemma genmx0 m n : <<0 : 'M_(m, n)>>%MS = 0.\nProof. by apply/eqP; rewrite -submx0 genmxE sub0mx. Qed.",
    "Lemma genmx1 n : <<1%:M : 'M_n>>%MS = 1%:M.\nProof.\nrewrite unlock; case/andP: (chooseP (@genmx_witnessP n n 1%:M)) => _ /eqP.\nby rewrite qidmx_eq1 row_full_unit unitmx1 => /eqP.\nQed.",
    "Lemma genmx_id m n (A : 'M_(m, n)) : (<<<<A>>>> = <<A>>)%MS.\nProof. exact/eq_genmx/genmxE. Qed.",
    "Lemma row_base_free m n (A : 'M_(m, n)) : row_free (row_base A).\nProof. by apply/eqnP; rewrite eq_row_base. Qed.",
    "Lemma mxrank_gen m n (A : 'M_(m, n)) : \\rank <<A>>%MS = \\rank A.\nProof. by rewrite genmxE. Qed.",
    "Lemma col_base_full m n (A : 'M_(m, n)) : row_full (col_base A).\nProof.\napply/row_fullP; exists (pid_mx (\\rank A) *m invmx (col_ebase A)).\nby rewrite !mulmxA mulmxKV // pid_mx_id // pid_mx_1.\nQed.",
    "Lemma mxrank_leqif_sup m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS -> \\rank A <= \\rank B ?= iff (B <= A)%MS.\nProof.\nmove=> sAB; split; first by rewrite mxrankS.\napply/idP/idP=> [| sBA]; last by rewrite eqn_leq !mxrankS.\ncase/submxP: sAB => D ->; set r := \\rank B; rewrite -(mulmx_base B) mulmxA.\nrewrite mxrankMfree // => /row_fullP[E kE].\nby rewrite -[rB in _ *m rB]mul1mx -kE -(mulmxA E) (mulmxA _ E) submxMl.\nQed.",
    "Lemma mxrank_leqif_eq m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A <= B)%MS -> \\rank A <= \\rank B ?= iff (A == B)%MS.\nProof. by move=> sAB; rewrite sAB; apply: mxrank_leqif_sup. Qed.",
    "Lemma ltmxErank m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A < B)%MS = (A <= B)%MS && (\\rank A < \\rank B).\nProof.\nby apply: andb_id2l => sAB; rewrite (ltn_leqif (mxrank_leqif_sup sAB)).\nQed.",
    "Lemma rank_ltmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A < B)%MS -> \\rank A < \\rank B.\nProof. by rewrite ltmxErank => /andP[]. Qed.",
    "Lemma eqmx_cast m1 m2 n (A : 'M_(m1, n)) e :\n  ((castmx e A : 'M_(m2, n)) :=: A)%MS.\nProof. by case: e A; case: m2 / => A e; rewrite castmx_id. Qed.",
    "Lemma row_full_castmx m1 m2 n (A : 'M_(m1, n)) e :\n  row_full (castmx e A  : 'M_(m2, n)) = row_full A.\nProof. exact/eq_row_full/eqmx_cast. Qed.",
    "Lemma row_free_castmx m1 m2 n (A : 'M_(m1, n)) e :\n  row_free (castmx e A  : 'M_(m2, n)) = row_free A.\nProof. by rewrite /row_free eqmx_cast; congr (_ == _); rewrite e.1. Qed.",
    "Lemma eqmx_conform m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (conform_mx A B :=: A \\/ conform_mx A B :=: B)%MS.\nProof.\ncase: (eqVneq m2 m1) => [-> | neqm12] in B *.\n  by right; rewrite conform_mx_id.\nby left; rewrite nonconform_mx ?neqm12.\nQed.",
    "Lemma rowsub_comp_sub (m n p q : nat) f (g : 'I_n -> 'I_p) (A : 'M_(m, q)) :\n   (rowsub (f \\o g) A <= rowsub f A)%MS.\nProof. by rewrite rowsub_comp rowsubE mulmx_sub. Qed.",
    "Lemma submx_rowsub (m n p q : nat) (h : 'I_n -> 'I_p) f g (A : 'M_(m, q)) :\n  f =1 g \\o h -> (rowsub f A <= rowsub g A)%MS.\nProof. by move=> /eq_rowsub->; rewrite rowsub_comp_sub. Qed.",
    "Lemma eqmx_rowsub_comp_perm (m1 m2 n : nat) (s : 'S_m2) f (A : 'M_(m1, n)) :\n  (rowsub (f \\o s) A :=: rowsub f A)%MS.\nProof.\nrewrite rowsub_comp rowsubE; apply: eqmxMfull.\nby rewrite -perm_mxEsub row_full_unit unitmx_perm.\nQed.",
    "Lemma eqmx_rowsub_comp (m n p q : nat) f (g : 'I_n -> 'I_p) (A : 'M_(m, q)) :\n  p <= n -> injective g -> (rowsub (f \\o g) A :=: rowsub f A)%MS.\nProof.\nmove=> leq_pn g_inj; have eq_np : n == p by rewrite eqn_leq leq_pn (inj_leq g).\nrewrite (eqP eq_np) in g g_inj *.\nrewrite (eq_rowsub (f \\o (perm g_inj))); last by move=> i; rewrite /= permE.\nexact: eqmx_rowsub_comp_perm.\nQed.",
    "Lemma eqmx_rowsub (m n p q : nat) (h : 'I_n -> 'I_p) f g (A : 'M_(m, q)) :\n  injective h -> p <= n -> f =1 g \\o h -> (rowsub f A :=: rowsub g A)%MS.\nProof. by move=> leq_pn h_inj /eq_rowsub->; apply: eqmx_rowsub_comp. Qed.",
    "Lemma col_mx_sub m3 (C : 'M_(m3, n)) :\n  (col_mx A B <= C)%MS = (A <= C)%MS && (B <= C)%MS.\nProof.\nrewrite !submxE mul_col_mx -col_mx0.\nby apply/eqP/andP; [case/eq_col_mx=> -> -> | case; do 2!move/eqP->].\nQed.",
    "Lemma addsmxE : (A + B :=: col_mx A B)%MS.\nProof.\nhave:= submx_refl (col_mx A B); rewrite col_mx_sub; case/andP=> sAS sBS.\nrewrite unlock; do 2?case: eqP => [AB0 | _]; last exact: genmxE.\n  by apply/eqmxP; rewrite !eqmx_sum_nop sBS col_mx_sub AB0 sub0mx /=.\nby apply/eqmxP; rewrite !eqmx_sum_nop sAS col_mx_sub AB0 sub0mx andbT /=.\nQed.",
    "Lemma addsmx_sub m3 (C : 'M_(m3, n)) :\n  (A + B <= C)%MS = (A <= C)%MS && (B <= C)%MS.\nProof. by rewrite addsmxE col_mx_sub. Qed.",
    "Lemma addsmxSl : (A <= A + B)%MS.\nProof. by have:= submx_refl (A + B)%MS; rewrite addsmx_sub; case/andP. Qed.",
    "Lemma addsmxSr : (B <= A + B)%MS.\nProof. by have:= submx_refl (A + B)%MS; rewrite addsmx_sub; case/andP. Qed.",
    "Lemma addsmx_idPr : reflect (A + B :=: B)%MS (A <= B)%MS.\nProof.\nhave:= @eqmxP _ _ _ (A + B)%MS B.\nby rewrite addsmxSr addsmx_sub submx_refl !andbT.\nQed.",
    "Lemma addsmx_idPl : reflect (A + B :=: A)%MS (B <= A)%MS.\nProof.\nhave:= @eqmxP _ _ _ (A + B)%MS A.\nby rewrite addsmxSl addsmx_sub submx_refl !andbT.\nQed.",
    "Lemma adds0mx m1 m2 n (B : 'M_(m2, n)) : ((0 : 'M_(m1, n)) + B :=: B)%MS.\nProof. by apply/eqmxP; rewrite addsmx_sub sub0mx addsmxSr /= andbT. Qed.",
    "Lemma addsmx0 m1 m2 n (A : 'M_(m1, n)) : (A + (0 : 'M_(m2, n)) :=: A)%MS.\nProof. by apply/eqmxP; rewrite addsmx_sub sub0mx addsmxSl /= !andbT. Qed.",
    "Lemma addsmxC m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A + B = B + A)%MS.\nProof.\nhave: (A + B == B + A)%MS.\n  by apply/andP; rewrite !addsmx_sub andbC -addsmx_sub andbC -addsmx_sub.\nmove/genmxP; rewrite [@addsmx]unlock -!submx0 !submx0.\nby do 2!case: eqP => [// -> | _]; rewrite ?genmx_id ?addsmx_nop0.\nQed.",
    "Lemma adds0mx_id m1 n (B : 'M_n) : ((0 : 'M_(m1, n)) + B)%MS = B.\nProof. by rewrite unlock eqxx addsmx_nop_id. Qed.",
    "Lemma addsmx0_id m2 n (A : 'M_n) : (A + (0 : 'M_(m2, n)))%MS = A.\nProof. by rewrite addsmxC adds0mx_id. Qed.",
    "Lemma addsmxA m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A + (B + C) = A + B + C)%MS.\nProof.\nhave: (A + (B + C) :=: A + B + C)%MS.\n  by apply/eqmxP/andP; rewrite !addsmx_sub -andbA andbA -!addsmx_sub.\nrewrite {1 3}[in @addsmx _ m1]unlock [in @addsmx _ n]unlock !addsmx_nop_id -!submx0.\nrewrite !addsmx_sub ![@addsmx]unlock -!submx0; move/eq_genmx.\nby do 3!case: (_ <= 0)%MS; rewrite //= !genmx_id.\nQed.",
    "Lemma addsmxMr m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  ((A + B)%MS *m C :=: A *m C + B *m C)%MS.\nProof. by apply/eqmxP; rewrite !addsmxE -!mul_col_mx !submxMr ?addsmxE. Qed.",
    "Lemma addsmxS m1 m2 m3 m4 n (A : 'M_(m1, n)) (B : 'M_(m2, n))\n                            (C : 'M_(m3, n)) (D : 'M_(m4, n)) :\n  (A <= C -> B <= D -> A + B <= C + D)%MS.\nProof.\nmove=> sAC sBD.\nby rewrite addsmx_sub {1}addsmxC !(submx_trans _ (addsmxSr _ _)).\nQed.",
    "Lemma addmx_sub_adds m m1 m2 n (A : 'M_(m, n)) (B : 'M_(m, n))\n                               (C : 'M_(m1, n)) (D : 'M_(m2, n)) :\n  (A <= C -> B <= D -> (A + B)%R <= C + D)%MS.\nProof.\nmove=> sAC; move/(addsmxS sAC); apply: submx_trans.\nby rewrite addmx_sub ?addsmxSl ?addsmxSr.\nQed.",
    "Lemma addsmx_addKl n m1 m2 (A : 'M_(m1, n)) (B C : 'M_(m2, n)) :\n  (B <= A)%MS -> (A + (B + C)%R :=: A + C)%MS.\nProof.\nmove=> sBA; apply/eqmxP; rewrite !addsmx_sub !addsmxSl.\nby rewrite -{3}[C](addKr B) !addmx_sub_adds ?eqmx_opp.\nQed.",
    "Lemma addsmx_addKr n m1 m2 (A B : 'M_(m1, n)) (C : 'M_(m2, n)) :\n  (B <= C)%MS -> ((A + B)%R + C :=: A + C)%MS.\nProof. by rewrite -!(addsmxC C) addrC; apply: addsmx_addKl. Qed.",
    "Lemma adds_eqmx m1 m2 m3 m4 n (A : 'M_(m1, n)) (B : 'M_(m2, n))\n                              (C : 'M_(m3, n)) (D : 'M_(m4, n)) :\n  (A :=: C -> B :=: D -> A + B :=: C + D)%MS.\nProof. by move=> eqAC eqBD; apply/eqmxP; rewrite !addsmxS ?eqAC ?eqBD. Qed.",
    "Lemma genmx_adds m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (<<(A + B)%MS>> = <<A>> + <<B>>)%MS.\nProof.\nrewrite -(eq_genmx (adds_eqmx (genmxE A) (genmxE B))).\nby rewrite [@addsmx]unlock !addsmx_nop_id !(fun_if (@genmx _ _ _)) !genmx_id.\nQed.",
    "Lemma sub_addsmxP m1 m2 m3 n\n                  (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  reflect (exists u, A = u.1 *m B + u.2 *m C) (A <= B + C)%MS.\nProof.\napply: (iffP idP) => [|[u ->]]; last by rewrite addmx_sub_adds ?submxMl.\nrewrite addsmxE; case/submxP=> u ->; exists (lsubmx u, rsubmx u).\nby rewrite -mul_row_col hsubmxK.\nQed.",
    "Lemma genmx_sums P n (B_ : I -> 'M_n) :\n  <<(\\sum_(i | P i) B_ i)%MS>>%MS = (\\sum_(i | P i) <<B_ i>>)%MS.\nProof. exact: (big_morph _ (@genmx_adds n n n) (@genmx0 n n)). Qed.",
    "Lemma sumsmx_sup i0 P m n (A : 'M_(m, n)) (B_ : I -> 'M_n) :\n  P i0 -> (A <= B_ i0)%MS -> (A <= \\sum_(i | P i) B_ i)%MS.\nProof.\nby move=> Pi0 sAB; apply: submx_trans sAB _; rewrite (bigD1 i0) // addsmxSl.\nQed.",
    "Lemma sumsmx_subP P m n (A_ : I -> 'M_n) (B : 'M_(m, n)) :\n  reflect (forall i, P i -> A_ i <= B)%MS (\\sum_(i | P i) A_ i <= B)%MS.\nProof.\napply: (iffP idP) => [sAB i Pi | sAB].\n  by apply: submx_trans sAB; apply: sumsmx_sup Pi _.\nby elim/big_rec: _ => [|i Ai Pi sAiB]; rewrite ?sub0mx // addsmx_sub sAB.\nQed.",
    "Lemma summx_sub_sums P m n (A : I -> 'M[F]_(m, n)) B :\n    (forall i, P i -> A i <= B i)%MS ->\n  ((\\sum_(i | P i) A i)%R <= \\sum_(i | P i) B i)%MS.\nProof.\nby move=> sAB; apply: summx_sub => i Pi; rewrite (sumsmx_sup i) ?sAB.\nQed.",
    "Lemma sumsmxS P n (A B : I -> 'M[F]_n) :\n    (forall i, P i -> A i <= B i)%MS ->\n  (\\sum_(i | P i) A i <= \\sum_(i | P i) B i)%MS.\nProof.\nby move=> sAB; apply/sumsmx_subP=> i Pi; rewrite (sumsmx_sup i) ?sAB.\nQed.",
    "Lemma eqmx_sums P n (A B : I -> 'M[F]_n) :\n    (forall i, P i -> A i :=: B i)%MS ->\n  (\\sum_(i | P i) A i :=: \\sum_(i | P i) B i)%MS.\nProof. by move=> eqAB; apply/eqmxP; rewrite !sumsmxS // => i; move/eqAB->. Qed.",
    "Lemma sub_sums_genmxP P m n p (A : 'M_(m, p)) (B_ : I -> 'M_(n, p)) :\n  reflect (exists u_ : I -> 'M_(m, n), A = \\sum_(i | P i) u_ i *m B_ i)\n          (A <= \\sum_(i | P i) <<B_ i>>)%MS.\nProof.\napply: (iffP idP) => [| [u_ ->]]; last first.\n  by apply: summx_sub_sums => i _; rewrite genmxE; apply: submxMl.\nhave [b] := ubnP #|P|; elim: b => // b IHb in P A *.\ncase: (pickP P) => [i Pi | P0 _]; last first.\n  rewrite big_pred0 //; move/submx0null->.\n  by exists (fun _ => 0); rewrite big_pred0.\nrewrite (cardD1x Pi) (bigD1 i) //= => /IHb{b IHb} /= IHi.\nrewrite (adds_eqmx (genmxE _) (eqmx_refl _)) => /sub_addsmxP[u ->].\nhave [u_ ->] := IHi _ (submxMl u.2 _).\nexists [eta u_ with i |-> u.1]; rewrite (bigD1 i Pi)/= eqxx; congr (_ + _).\nby apply: eq_bigr => j /andP[_ /negPf->].\nQed.",
    "Lemma sub_sumsmxP P m n (A : 'M_(m, n)) (B_ : I -> 'M_n) :\n  reflect (exists u_, A = \\sum_(i | P i) u_ i *m B_ i)\n          (A <= \\sum_(i | P i) B_ i)%MS.\nProof.\nby rewrite -(eqmx_sums (fun _ _ => genmxE _)); apply/sub_sums_genmxP.\nQed.",
    "Lemma sumsmxMr_gen P m n A (B : 'M[F]_(m, n)) :\n  ((\\sum_(i | P i) A i)%MS *m B :=: \\sum_(i | P i) <<A i *m B>>)%MS.\nProof.\napply/eqmxP/andP; split; last first.\n  by apply/sumsmx_subP=> i Pi; rewrite genmxE submxMr ?(sumsmx_sup i).\nhave [u ->] := sub_sumsmxP _ _ _ (submx_refl (\\sum_(i | P i) A i)%MS).\nby rewrite mulmx_suml summx_sub_sums // => i _; rewrite genmxE -mulmxA submxMl.\nQed.",
    "Lemma sumsmxMr P n (A_ : I -> 'M[F]_n) (B : 'M_n) :\n  ((\\sum_(i | P i) A_ i)%MS *m B :=: \\sum_(i | P i) (A_ i *m B))%MS.\nProof.\nby apply: eqmx_trans (sumsmxMr_gen _ _ _) (eqmx_sums _) => i _; apply: genmxE.\nQed.",
    "Lemma rank_pid_mx m n r : r <= m -> r <= n -> \\rank (pid_mx r : 'M_(m, n)) = r.\nProof.\ndo 2!move/subnKC <-; rewrite pid_mx_block block_mxEv row_mx0 -addsmxE addsmx0.\nby rewrite -mxrank_tr tr_row_mx trmx0 trmx1 -addsmxE addsmx0 mxrank1.\nQed.",
    "Lemma rank_copid_mx n r : r <= n -> \\rank (copid_mx r : 'M_n) = (n - r)%N.\nProof.\nmove/subnKC <-; rewrite /copid_mx pid_mx_block scalar_mx_block.\nrewrite opp_block_mx !oppr0 add_block_mx !addr0 subrr block_mxEv row_mx0.\nrewrite -addsmxE adds0mx -mxrank_tr tr_row_mx trmx0 trmx1.\nby rewrite -addsmxE adds0mx mxrank1 addKn.\nQed.",
    "Lemma mxrank_compl m n (A : 'M_(m, n)) : \\rank A^C = (n - \\rank A)%N.\nProof. by rewrite mxrankMfree ?row_free_unit ?rank_copid_mx. Qed.",
    "Lemma mxrank_ker m n (A : 'M_(m, n)) : \\rank (kermx A) = (m - \\rank A)%N.\nProof. by rewrite mxrankMfree ?row_free_unit ?unitmx_inv ?rank_copid_mx. Qed.",
    "Lemma kermx_eq0 n m (A : 'M_(m, n)) : (kermx A == 0) = row_free A.\nProof. by rewrite -mxrank_eq0 mxrank_ker subn_eq0 row_leq_rank. Qed.",
    "Lemma mxrank_coker m n (A : 'M_(m, n)) : \\rank (cokermx A) = (n - \\rank A)%N.\nProof. by rewrite eqmxMfull ?row_full_unit ?unitmx_inv ?rank_copid_mx. Qed.",
    "Lemma cokermx_eq0 n m (A : 'M_(m, n)) : (cokermx A == 0) = row_full A.\nProof. by rewrite -mxrank_eq0 mxrank_coker subn_eq0 col_leq_rank. Qed.",
    "Lemma mulmx_ker m n (A : 'M_(m, n)) : kermx A *m A = 0.\nProof.\nby rewrite -{2}[A]mulmx_ebase !mulmxA mulmxKV // mul_copid_mx_pid ?mul0mx.\nQed.",
    "Lemma mulmxKV_ker m n p (A : 'M_(n, p)) (B : 'M_(m, n)) :\n  B *m A = 0 -> B *m col_ebase A *m kermx A = B.\nProof.\nrewrite mulmxA mulmxBr mulmx1 mulmxBl mulmxK //.\nrewrite -{1}[A]mulmx_ebase !mulmxA => /(canRL (mulmxK (row_ebase_unit A))).\nrewrite mul0mx // => BA0; apply: (canLR (addrK _)).\nby rewrite -(pid_mx_id _ _ n (rank_leq_col A)) mulmxA BA0 !mul0mx addr0.\nQed.",
    "Lemma sub_kermxP p m n (A : 'M_(m, n)) (B : 'M_(p, m)) :\n  reflect (B *m A = 0) (B <= kermx A)%MS.\nProof.\napply: (iffP submxP) => [[D ->]|]; first by rewrite -mulmxA mulmx_ker mulmx0.\nby move/mulmxKV_ker; exists (B *m col_ebase A).\nQed.",
    "Lemma sub_kermx p m n (A : 'M_(m, n)) (B : 'M_(p, m)) :\n  (B <= kermx A)%MS = (B *m A == 0).\nProof. exact/sub_kermxP/eqP. Qed.",
    "Lemma kermx0 m n : (kermx (0 : 'M_(m, n)) :=: 1%:M)%MS.\nProof. by apply/eqmxP; rewrite submx1/= sub_kermx mulmx0. Qed.",
    "Lemma mulmx_free_eq0 m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  row_free B -> (A *m B == 0) = (A == 0).\nProof. by rewrite -sub_kermx -kermx_eq0 => /eqP->; rewrite submx0. Qed.",
    "Lemma inj_row_free m n (A : 'M_(m, n)) :\n  (forall v : 'rV_m, v *m A = 0 -> v = 0) -> row_free A.\nProof.\nmove=> Ainj; rewrite -kermx_eq0; apply/eqP/row_matrixP => i.\nby rewrite row0; apply/Ainj; rewrite -row_mul mulmx_ker row0.\nQed.",
    "Lemma row_freePn m n (M : 'M[F]_(m, n)) :\n reflect (exists i, (row i M <= row' i M)%MS) (~~ row_free M).\nProof.\nrewrite -kermx_eq0; apply: (iffP (rowV0Pn _)) => [|[i0 /submxP[D rM]]].\n  move=> [v /sub_kermxP vM_eq0 /rV0Pn[i0 vi0_neq0]]; exists i0.\n  have := vM_eq0; rewrite mulmx_sum_row (bigD1_ord i0)//=.\n  move=> /(canRL (addrK _))/(canRL (scalerK _))->//.\n  rewrite sub0r scalerN -scaleNr scalemx_sub// summx_sub// => l _.\n  by rewrite scalemx_sub// -row_rowsub row_sub.\nexists (\\row_j oapp (D 0) (- 1) (unlift i0 j)); last first.\n  by apply/rV0Pn; exists i0; rewrite !mxE unlift_none/= oppr_eq0 oner_eq0.\napply/sub_kermxP; rewrite mulmx_sum_row (bigD1_ord i0)//= !mxE.\nrewrite unlift_none scaleN1r rM mulmx_sum_row addrC -sumrB big1 // => l _.\nby rewrite !mxE liftK row_rowsub subrr.\nQed.",
    "Lemma negb_row_free m n (M : 'M[F]_(m, n)) :\n  ~~ row_free M = [exists i, (row i M <= row' i M)%MS].\nProof. exact/row_freePn/existsP. Qed.",
    "Lemma mulmx0_rank_max m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  A *m B = 0 -> \\rank A + \\rank B <= n.\nProof.\nmove=> AB0; rewrite -{3}(subnK (rank_leq_row B)) leq_add2r.\nby rewrite -mxrank_ker mxrankS // sub_kermx AB0.\nQed.",
    "Lemma mxrank_Frobenius m n p q (A : 'M_(m, n)) B (C : 'M_(p, q)) :\n  \\rank (A *m B) + \\rank (B *m C) <= \\rank B + \\rank (A *m B *m C).\nProof.\nrewrite -{2}(mulmx_base (A *m B)) -mulmxA (eqmxMfull _ (col_base_full _)).\nset C2 := row_base _ *m C.\nrewrite -{1}(subnK (rank_leq_row C2)) -(mxrank_ker C2) addnAC leq_add2r.\nrewrite addnC -{1}(mulmx_base B) -mulmxA eqmxMfull //.\nset C1 := _ *m C; rewrite -{2}(subnKC (rank_leq_row C1)) leq_add2l -mxrank_ker.\nrewrite -(mxrankMfree _ (row_base_free (A *m B))).\nhave: (row_base (A *m B) <= row_base B)%MS by rewrite !eq_row_base submxMl.\ncase/submxP=> D defD; rewrite defD mulmxA mxrankMfree ?mxrankS //.\nby rewrite sub_kermx -mulmxA (mulmxA D) -defD -/C2 mulmx_ker.\nQed.",
    "Lemma mxrank_mul_min m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  \\rank A + \\rank B - n <= \\rank (A *m B).\nProof.\nby have:= mxrank_Frobenius A 1%:M B; rewrite mulmx1 mul1mx mxrank1 leq_subLR.\nQed.",
    "Lemma addsmx_compl_full m n (A : 'M_(m, n)) : row_full (A + A^C)%MS.\nProof.\nrewrite /row_full addsmxE; apply/row_fullP.\nexists (row_mx (pinvmx A) (cokermx A)); rewrite mul_row_col.\nrewrite -{2}[A]mulmx_ebase -!mulmxA mulKmx // -mulmxDr !mulmxA.\nby rewrite pid_mx_id ?copid_mx_id // -mulmxDl addrC subrK mul1mx mulVmx.\nQed.",
    "Lemma sub_capmx_gen m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= capmx_gen B C)%MS = (A <= B)%MS && (A <= C)%MS.\nProof.\napply/idP/andP=> [sAI | [/submxP[B' ->{A}] /submxP[C' eqBC']]].\n  rewrite !(submx_trans sAI) ?submxMl // /capmx_gen.\n   have:= mulmx_ker (col_mx B C); set K := kermx _.\n   rewrite -{1}[K]hsubmxK mul_row_col; move/(canRL (addrK _))->.\n   by rewrite add0r -mulNmx submxMl.\nhave: (row_mx B' (- C') <= kermx (col_mx B C))%MS.\n  by rewrite sub_kermx mul_row_col eqBC' mulNmx subrr.\ncase/submxP=> D; rewrite -[kermx _]hsubmxK mul_mx_row.\nby case/eq_row_mx=> -> _; rewrite -mulmxA submxMl.\nQed.",
    "Lemma capmxE m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :&: B :=: capmx_gen A B)%MS.\nProof.\nrewrite unlock -sub1mx; apply/eqmxP.\nhave:= submx_refl (capmx_gen A B); rewrite !sub_capmx_gen => /andP[sIA sIB].\ncase idA: (qidmx A); first by rewrite !capmx_nopP submx_refl sub_qidmx.\ncase idB: (qidmx B); first by rewrite !capmx_nopP submx_refl sub_qidmx.\ncase s1B: (1%:M <= B)%MS; rewrite !capmx_normP ?sub_capmx_gen sIA ?sIB //=.\nby rewrite submx_refl (submx_trans (submx1 _)).\nQed.",
    "Lemma capmxSl m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :&: B <= A)%MS.\nProof. by rewrite capmxE submxMl. Qed.",
    "Lemma sub_capmx m m1 m2 n (A : 'M_(m, n)) (B : 'M_(m1, n)) (C : 'M_(m2, n)) :\n  (A <= B :&: C)%MS = (A <= B)%MS && (A <= C)%MS.\nProof. by rewrite capmxE sub_capmx_gen. Qed.",
    "Lemma capmxC m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :&: B = B :&: A)%MS.\nProof.\nhave [eqAB|] := eqVneq (qidmx A) (qidmx B).\n  rewrite (capmx_eq_norm eqAB) (capmx_eq_norm (esym eqAB)).\n  apply: capmx_norm_eq; first by rewrite !qidmx_cap andbC.\n  by apply/andP; split; rewrite !sub_capmx andbC -sub_capmx.\nby rewrite negb_eqb !unlock => /addbP <-; case: (qidmx A).\nQed.",
    "Lemma capmxSr m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :&: B <= B)%MS.\nProof. by rewrite capmxC capmxSl. Qed.",
    "Lemma capmx_idPr n m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (A :&: B :=: B)%MS (B <= A)%MS.\nProof.\nhave:= @eqmxP _ _ _ (A :&: B)%MS B.\nby rewrite capmxSr sub_capmx submx_refl !andbT.\nQed.",
    "Lemma capmx_idPl n m1 m2 (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (A :&: B :=: A)%MS (A <= B)%MS.\nProof. by rewrite capmxC; apply: capmx_idPr. Qed.",
    "Lemma capmxS m1 m2 m3 m4 n (A : 'M_(m1, n)) (B : 'M_(m2, n))\n                           (C : 'M_(m3, n)) (D : 'M_(m4, n)) :\n  (A <= C -> B <= D -> A :&: B <= C :&: D)%MS.\nProof.\nby move=> sAC sBD; rewrite sub_capmx {1}capmxC !(submx_trans (capmxSr _ _)).\nQed.",
    "Lemma cap_eqmx m1 m2 m3 m4 n (A : 'M_(m1, n)) (B : 'M_(m2, n))\n                             (C : 'M_(m3, n)) (D : 'M_(m4, n)) :\n  (A :=: C -> B :=: D -> A :&: B :=: C :&: D)%MS.\nProof. by move=> eqAC eqBD; apply/eqmxP; rewrite !capmxS ?eqAC ?eqBD. Qed.",
    "Lemma capmxMr m1 m2 n p (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(n, p)) :\n  ((A :&: B) *m C <= A *m C :&: B *m C)%MS.\nProof. by rewrite sub_capmx !submxMr ?capmxSl ?capmxSr. Qed.",
    "Lemma cap0mx m1 m2 n (A : 'M_(m2, n)) : ((0 : 'M_(m1, n)) :&: A)%MS = 0.\nProof. exact: submx0null (capmxSl _ _). Qed.",
    "Lemma capmx0 m1 m2 n (A : 'M_(m1, n)) : (A :&: (0 : 'M_(m2, n)))%MS = 0.\nProof. exact: submx0null (capmxSr _ _). Qed.",
    "Lemma capmxT m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  row_full B -> (A :&: B :=: A)%MS.\nProof.\nrewrite -sub1mx => s1B; apply/eqmxP.\nby rewrite capmxSl sub_capmx submx_refl (submx_trans (submx1 A)).\nQed.",
    "Lemma capTmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  row_full A -> (A :&: B :=: B)%MS.\nProof. by move=> Afull; apply/eqmxP; rewrite capmxC !capmxT ?andbb. Qed.",
    "Lemma cap1mx n (A : 'M_n) : (1%:M :&: A = A)%MS.\nProof. by rewrite unlock qidmx_eq1 eqxx capmx_nop_id. Qed.",
    "Lemma capmx1 n (A : 'M_n) : (A :&: 1%:M = A)%MS.\nProof. by rewrite capmxC cap1mx. Qed.",
    "Lemma genmx_cap m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  <<A :&: B>>%MS = (<<A>> :&: <<B>>)%MS.\nProof.\nrewrite -(eq_genmx (cap_eqmx (genmxE A) (genmxE B))).\ncase idAB: (qidmx <<A>> || qidmx <<B>>)%MS.\n  rewrite [@capmx]unlock !capmx_nop_id !(fun_if (@genmx _ _ _)) !genmx_id.\n  by case: (qidmx _) idAB => //= ->.\ncase idA: (qidmx _) idAB => //= idB; rewrite {2}capmx_eq_norm ?idA //.\nset C := (_ :&: _)%MS; have eq_idC: row_full C = qidmx C.\n  rewrite qidmx_cap idA -sub1mx sub_capmx genmxE; apply/andP=> [[s1A]].\n  by case/idP: idA; rewrite qidmx_eq1 -genmx1 (sameP eqP genmxP) submx1.\nrewrite unlock /capmx_norm eq_idC.\nby apply: choose_id (capmx_witnessP _); rewrite -eq_idC genmx_witnessP.\nQed.",
    "Lemma capmxA m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A :&: (B :&: C) = A :&: B :&: C)%MS.\nProof.\nrewrite (capmxC A B) capmxC; wlog idA: m1 m3 A C / qidmx A.\n  move=> IH; case idA: (qidmx A); first exact: IH.\n  case idC: (qidmx C); first by rewrite -IH.\n  rewrite (@capmx_eq_norm n m3) ?qidmx_cap ?idA ?idC ?andbF //.\n  rewrite capmx_eq_norm ?qidmx_cap ?idA ?idC ?andbF //.\n  apply: capmx_norm_eq; first by rewrite !qidmx_cap andbAC.\n  by apply/andP; split; rewrite !sub_capmx andbAC -!sub_capmx.\nrewrite -!(capmxC A) [in @capmx _ m1]unlock idA capmx_nop_id.\nhave [eqBC|] := eqVneq (qidmx B) (qidmx C).\n  rewrite (@capmx_eq_norm n) ?capmx_nopP // capmx_eq_norm //.\n  by apply: capmx_norm_eq; rewrite ?qidmx_cap ?capmxS ?capmx_nopP.\nby rewrite !unlock capmx_nopP capmx_nop_id; do 2?case: (qidmx _) => //.\nQed.",
    "Lemma bigcapmx_inf i0 P m n (A_ : I -> 'M_n) (B : 'M_(m, n)) :\n  P i0 -> (A_ i0 <= B -> \\bigcap_(i | P i) A_ i <= B)%MS.\nProof. by move=> Pi0; apply: submx_trans; rewrite (bigD1 i0) // capmxSl. Qed.",
    "Lemma sub_bigcapmxP P m n (A : 'M_(m, n)) (B_ : I -> 'M_n) :\n  reflect (forall i, P i -> A <= B_ i)%MS (A <= \\bigcap_(i | P i) B_ i)%MS.\nProof.\napply: (iffP idP) => [sAB i Pi | sAB].\n  by apply: (submx_trans sAB); rewrite (bigcapmx_inf Pi).\nby elim/big_rec: _ => [|i Pi C sAC]; rewrite ?submx1 // sub_capmx sAB.\nQed.",
    "Lemma genmx_bigcap P n (A_ : I -> 'M_n) :\n  (<<\\bigcap_(i | P i) A_ i>> = \\bigcap_(i | P i) <<A_ i>>)%MS.\nProof. exact: (big_morph _ (@genmx_cap n n n) (@genmx1 n)). Qed.",
    "Lemma matrix_modl m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= C -> A + (B :&: C) :=: (A + B) :&: C)%MS.\nProof.\nmove=> sAC; set D := ((A + B) :&: C)%MS; apply/eqmxP.\nrewrite sub_capmx addsmxS ?capmxSl // addsmx_sub sAC capmxSr /=.\nhave: (D <= B + A)%MS by rewrite addsmxC capmxSl.\ncase/sub_addsmxP=> u defD; rewrite defD addrC addmx_sub_adds ?submxMl //.\nrewrite sub_capmx submxMl -[_ *m B](addrK (u.2 *m A)) -defD.\nby rewrite addmx_sub ?capmxSr // eqmx_opp mulmx_sub.\nQed.",
    "Lemma matrix_modr m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (C <= A -> (A :&: B) + C :=: A :&: (B + C))%MS.\nProof. by rewrite !(capmxC A) -!(addsmxC C); apply: matrix_modl. Qed.",
    "Lemma capmx_compl m n (A : 'M_(m, n)) : (A :&: A^C)%MS = 0.\nProof.\nset D := (A :&: A^C)%MS; have: (D <= D)%MS by [].\nrewrite sub_capmx andbC => /andP[/submxP[B defB]].\nrewrite submxE => /eqP; rewrite defB -!mulmxA mulKVmx ?copid_mx_id //.\nby rewrite mulmxA => ->; rewrite mul0mx.\nQed.",
    "Lemma mxrank_mul_ker m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  (\\rank (A *m B) + \\rank (A :&: kermx B))%N = \\rank A.\nProof.\napply/eqP; set K := kermx B; set C := (A :&: K)%MS.\nrewrite -(eqmxMr B (eq_row_base A)); set K' := _ *m B.\nrewrite -{2}(subnKC (rank_leq_row K')) -mxrank_ker eqn_add2l.\nrewrite -(mxrankMfree _ (row_base_free A)) mxrank_leqif_sup.\n  by rewrite sub_capmx -(eq_row_base A) submxMl sub_kermx -mulmxA mulmx_ker/=.\nhave /submxP[C' defC]: (C <= row_base A)%MS by rewrite eq_row_base capmxSl.\nby rewrite defC submxMr // sub_kermx mulmxA -defC -sub_kermx capmxSr.\nQed.",
    "Lemma mxrank_injP m n p (A : 'M_(m, n)) (f : 'M_(n, p)) :\n  reflect (\\rank (A *m f) = \\rank A) ((A :&: kermx f)%MS == 0).\nProof.\nrewrite -mxrank_eq0 -(eqn_add2l (\\rank (A *m f))).\nby rewrite mxrank_mul_ker addn0 eq_sym; apply: eqP.\nQed.",
    "Lemma mxrank_disjoint_sum m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :&: B)%MS = 0 -> \\rank (A + B)%MS = (\\rank A + \\rank B)%N.\nProof.\nmove=> AB0; pose Ar := row_base A; pose Br := row_base B.\nhave [Afree Bfree]: row_free Ar /\\ row_free Br by rewrite !row_base_free.\nhave: (Ar :&: Br <= A :&: B)%MS by rewrite capmxS ?eq_row_base.\nrewrite {}AB0 submx0 -mxrank_eq0 capmxE mxrankMfree //.\nset Cr := col_mx Ar Br; set Crl := lsubmx _; rewrite mxrank_eq0 => /eqP Crl0.\nrewrite -(adds_eqmx (eq_row_base _) (eq_row_base _)) addsmxE -/Cr.\nsuffices K0: kermx Cr = 0.\n  by apply/eqP; rewrite eqn_leq rank_leq_row -subn_eq0 -mxrank_ker K0 mxrank0.\nmove/eqP: (mulmx_ker Cr); rewrite -[kermx Cr]hsubmxK mul_row_col -/Crl Crl0.\nrewrite mul0mx add0r -mxrank_eq0 mxrankMfree // mxrank_eq0 => /eqP->.\nexact: row_mx0.\nQed.",
    "Lemma diffmxE m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :\\: B :=: A :&: (capmx_gen A B)^C)%MS.\nProof. by rewrite unlock; apply/eqmxP; rewrite !genmxE !capmxE andbb. Qed.",
    "Lemma genmx_diff m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (<<A :\\: B>> = A :\\: B)%MS.\nProof. by rewrite [@diffmx]unlock genmx_id. Qed.",
    "Lemma diffmxSl m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :\\: B <= A)%MS.\nProof. by rewrite diffmxE capmxSl. Qed.",
    "Lemma capmx_diff m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  ((A :\\: B) :&: B)%MS = 0.\nProof.\napply/eqP; pose C := capmx_gen A B; rewrite -submx0 -(capmx_compl C).\nby rewrite sub_capmx -capmxE sub_capmx andbAC -sub_capmx -diffmxE -sub_capmx.\nQed.",
    "Lemma addsmx_diff_cap_eq m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :\\: B + A :&: B :=: A)%MS.\nProof.\napply/eqmxP; rewrite addsmx_sub capmxSl diffmxSl /=.\nset C := (A :\\: B)%MS; set D := capmx_gen A B.\nsuffices sACD: (A <= C + D)%MS.\n  by rewrite (submx_trans sACD) ?addsmxS ?capmxE.\nhave:= addsmx_compl_full D; rewrite /row_full addsmxE.\ncase/row_fullP=> U /(congr1 (mulmx A)); rewrite mulmx1.\nrewrite -[U]hsubmxK mul_row_col mulmxDr addrC 2!mulmxA.\nset V := _ *m _ => defA; rewrite -defA; move/(canRL (addrK _)): defA => defV.\nsuffices /submxP[W ->]: (V <= C)%MS by rewrite -mul_row_col addsmxE submxMl.\nrewrite diffmxE sub_capmx {1}defV -mulNmx addmx_sub 1?mulmx_sub //.\nby rewrite -capmxE capmxSl.\nQed.",
    "Lemma mxrank_cap_compl m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (\\rank (A :&: B) + \\rank (A :\\: B))%N = \\rank A.\nProof.\nrewrite addnC -mxrank_disjoint_sum ?addsmx_diff_cap_eq //.\nby rewrite (capmxC A) capmxA capmx_diff cap0mx.\nQed.",
    "Lemma mxrank_sum_cap m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (\\rank (A + B) + \\rank (A :&: B) = \\rank A + \\rank B)%N.\nProof.\nset C := (A :&: B)%MS; set D := (A :\\: B)%MS.\nhave rDB: \\rank (A + B)%MS = \\rank (D + B)%MS.\n  apply/eqP; rewrite mxrank_leqif_sup; first by rewrite addsmxS ?diffmxSl.\n  by rewrite addsmx_sub addsmxSr -(addsmx_diff_cap_eq A B) addsmxS ?capmxSr.\nrewrite {1}rDB mxrank_disjoint_sum ?capmx_diff //.\nby rewrite addnC addnA mxrank_cap_compl.\nQed.",
    "Lemma mxrank_adds_leqif m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  \\rank (A + B) <= \\rank A + \\rank B ?= iff (A :&: B <= (0 : 'M_n))%MS.\nProof.\nrewrite -mxrank_sum_cap; split; first exact: leq_addr.\nby rewrite addnC (@eqn_add2r _ 0) eq_sym mxrank_eq0 -submx0.\nQed.",
    "Lemma rank_col_mx0 m n p (A : 'M_(m, n)) :\n  \\rank (col_mx A (0 : 'M_(p, n))) = \\rank A.\nProof. by rewrite -addsmxE addsmx0. Qed.",
    "Lemma rank_col_0mx m n p (A : 'M_(m, n)) :\n  \\rank (col_mx (0 : 'M_(p, n)) A) = \\rank A.\nProof. by rewrite -addsmxE adds0mx. Qed.",
    "Lemma rank_row_mx0 m n p (A : 'M_(m, n)) :\n  \\rank (row_mx A (0 : 'M_(m, p))) = \\rank A.\nProof. by rewrite -mxrank_tr -[RHS]mxrank_tr tr_row_mx trmx0 rank_col_mx0. Qed.",
    "Lemma rank_row_0mx m n p (A : 'M_(m, n)) :\n  \\rank (row_mx (0 : 'M_(m, p)) A) = \\rank A.\nProof. by rewrite -mxrank_tr -[RHS]mxrank_tr tr_row_mx trmx0 rank_col_0mx. Qed.",
    "Lemma rank_diag_block_mx m n p q\n    (A : 'M_(m, n)) (B : 'M_(p, q)) :\n  \\rank (block_mx A 0 0 B) = (\\rank A + \\rank B)%N.\nProof.\nrewrite block_mxEv -addsmxE mxrank_disjoint_sum ?rank_row_mx0 ?rank_row_0mx//.\napply/eqP/rowV0P => v; rewrite sub_capmx => /andP[/submxP[x ->]].\nrewrite mul_mx_row mulmx0 => /submxP[y]; rewrite mul_mx_row mulmx0.\nby move=> /eq_row_mx[-> _]; rewrite row_mx0.\nQed.",
    "Lemma proj_mx_sub m n U V (W : 'M_(m, n)) : (W *m proj_mx U V <= U)%MS.\nProof. by rewrite !mulmx_sub // -addsmxE addsmx0. Qed.",
    "Lemma proj_mx_compl_sub m n U V (W : 'M_(m, n)) :\n  (W <= U + V -> W - W *m proj_mx U V <= V)%MS.\nProof.\nrewrite addsmxE => sWUV; rewrite mulmxA -{1}(mulmxKpV sWUV) -mulmxBr.\nby rewrite mulmx_sub // opp_col_mx add_col_mx subrr subr0 -addsmxE adds0mx.\nQed.",
    "Lemma proj_mx_id m n U V (W : 'M_(m, n)) :\n  (U :&: V = 0)%MS -> (W <= U)%MS -> W *m proj_mx U V = W.\nProof.\nmove=> dxUV sWU; apply/eqP; rewrite -subr_eq0 -submx0 -dxUV.\nrewrite sub_capmx addmx_sub ?eqmx_opp ?proj_mx_sub //= -eqmx_opp opprB.\nby rewrite proj_mx_compl_sub // (submx_trans sWU) ?addsmxSl.\nQed.",
    "Lemma proj_mx_0 m n U V (W : 'M_(m, n)) :\n  (U :&: V = 0)%MS -> (W <= V)%MS -> W *m proj_mx U V = 0.\nProof.\nmove=> dxUV sWV; apply/eqP; rewrite -submx0 -dxUV.\nrewrite sub_capmx proj_mx_sub /= -[_ *m _](subrK W) addmx_sub // -eqmx_opp.\nby rewrite opprB proj_mx_compl_sub // (submx_trans sWV) ?addsmxSr.\nQed.",
    "Lemma add_proj_mx m n U V (W : 'M_(m, n)) :\n    (U :&: V = 0)%MS -> (W <= U + V)%MS ->\n  W *m proj_mx U V + W *m proj_mx V U = W.\nProof.\nmove=> dxUV sWUV; apply/eqP; rewrite -subr_eq0 -submx0 -dxUV.\nrewrite -addrA sub_capmx {2}addrCA -!(opprB W).\nby rewrite !{1}addmx_sub ?proj_mx_sub ?eqmx_opp ?proj_mx_compl_sub // addsmxC.\nQed.",
    "Lemma proj_mx_proj n (U V : 'M_n) :\n  let P := proj_mx U V in (U :&: V = 0)%MS -> P *m P = P.\nProof.\nby move=> P dxUV; rewrite -[P in P *m _]mul1mx proj_mx_id ?proj_mx_sub ?mul1mx.\nQed.",
    "Lemma complete_unitmx m n (U : 'M_(m, n)) (f : 'M_n) :\n  \\rank (U *m f) = \\rank U -> {g : 'M_n | g \\in unitmx & U *m f = U *m g}.\nProof.\nmove=> injfU; pose V := <<U>>%MS; pose W := V *m f.\npose g := proj_mx V (V^C)%MS *m f + cokermx V *m row_ebase W.\nhave defW: V *m g = W.\n  rewrite mulmxDr mulmxA proj_mx_id ?genmxE ?capmx_compl //.\n  by rewrite mulmxA mulmx_coker mul0mx addr0.\nexists g; last first.\n  have /submxP[u ->]: (U <= V)%MS by rewrite genmxE.\n  by rewrite -!mulmxA defW.\nrewrite -row_full_unit -sub1mx; apply/submxP.\nhave: (invmx (col_ebase W) *m W <= V *m g)%MS by rewrite defW submxMl.\ncase/submxP=> v def_v; exists (invmx (row_ebase W) *m (v *m V + (V^C)%MS)).\nrewrite -mulmxA mulmxDl -mulmxA -def_v -{3}[W]mulmx_ebase -mulmxA.\nrewrite mulKmx ?col_ebase_unit // [_ *m g]mulmxDr mulmxA.\nrewrite (proj_mx_0 (capmx_compl _)) // mul0mx add0r 2!mulmxA.\nrewrite mulmxK ?row_ebase_unit // copid_mx_id ?rank_leq_row //.\nrewrite (eqmxMr _ (genmxE U)) injfU genmxE addrC -mulmxDl subrK.\nby rewrite mul1mx mulVmx ?row_ebase_unit.\nQed.",
    "Lemma eqmxMunitP m n (U V : 'M_(m, n)) :\n  reflect (exists2 P, P \\in unitmx & U = P *m V) (U == V)%MS.\nProof.\napply: (iffP eqmxP) => [eqUV | [P Punit ->]]; last first.\n  by apply/eqmxMfull; rewrite row_full_unit.\nhave [D defU]: exists D, U = D *m V by apply/submxP; rewrite eqUV.\nhave{eqUV} [Pt Pt_unit defUt]: {Pt | Pt \\in unitmx & V^T *m D^T = V^T *m Pt}.\n  by apply/complete_unitmx; rewrite -trmx_mul -defU !mxrank_tr eqUV.\nby exists Pt^T; last apply/trmx_inj; rewrite ?unitmx_tr // defU !trmx_mul trmxK.\nQed.",
    "Lemma eq_rank_unitmx m1 m2 n (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  \\rank U = \\rank V -> {f : 'M_n | f \\in unitmx & V :=: U *m f}%MS.\nProof.\nmove=> eqrUV; pose f := invmx (row_ebase <<U>>%MS) *m row_ebase <<V>>%MS.\nhave defUf: (<<U>> *m f :=: <<V>>)%MS.\n  rewrite -[<<U>>%MS]mulmx_ebase mulmxA mulmxK ?row_ebase_unit // -mulmxA.\n  rewrite genmxE eqrUV -genmxE -{3}[<<V>>%MS]mulmx_ebase -mulmxA.\n  move: (pid_mx _ *m _) => W; apply/eqmxP.\n  by rewrite !eqmxMfull ?andbb // row_full_unit col_ebase_unit.\nhave{defUf} defV: (V :=: U *m f)%MS.\n  by apply/eqmxP; rewrite -!(eqmxMr f (genmxE U)) !defUf !genmxE andbb.\nhave injfU: \\rank (U *m f) = \\rank U by rewrite -defV eqrUV.\nby have [g injg defUg] := complete_unitmx injfU; exists g; rewrite -?defUg.\nQed.",
    "Lemma maxrowsub_free : row_free (rowsub mxf A).\nProof.\nrewrite /mxf; case: arg_maxnP => //= f _ fM; apply/negP => /negP rfA.\nhave [i NriA] : exists i, ~~ (row i A <= rowsub f A)%MS.\n  by apply/row_subPn; apply: contraNN rfA => /mxrankS; rewrite row_leq_rank.\nhave [j rjfA] : exists j, (row (f j) A <= rowsub (f \\o lift j) A)%MS.\n  case/row_freePn: rfA => j.\n  by rewrite row_rowsub row'Esub -mxsub_comp; exists j.\npose g : 'I_m ^ \\rank A := finfun [eta f with j |-> i].\nsuff: (rowsub f A < rowsub g A)%MS by rewrite ltmxErank andbC ltnNge fM.\nrewrite ltmxE; apply/andP; split; last first.\n  apply: contra NriA; apply: submx_trans.\n  by rewrite (eq_row_sub j)// row_rowsub ffunE/= eqxx.\napply/row_subP => k; rewrite !row_rowsub.\nhave [->|/negPf eq_kjF] := eqVneq k j; last first.\n  by rewrite (eq_row_sub k)// row_rowsub ffunE/= eq_kjF.\nrewrite (submx_trans rjfA)// (submx_rowsub (lift j))// => l /=.\nby rewrite ffunE/= eq_sym (negPf (neq_lift _ _)).\nQed.",
    "Lemma eq_maxrowsub : (rowsub mxf A :=: A)%MS.\nProof.\napply/eqmxP; rewrite -(eq_leqif (mxrank_leqif_eq _))//.\n  exact: maxrowsub_free.\napply/row_subP => i; apply/submxP; exists (delta_mx 0 (mxf i)).\nby rewrite -rowE; apply/rowP => j; rewrite !mxE.\nQed.",
    "Lemma maxrankfun_inj : injective mxf.\nProof.\nmove=> i j eqAij; have /row_free_inj := maxrowsub_free.\nmove=> /(_ 1) /(_ (delta_mx 0 i) (delta_mx 0 j)).\nrewrite -!rowE !row_rowsub eqAij => /(_ erefl) /matrixP /(_ 0 i) /eqP.\nby rewrite !mxE !eqxx/=; case: (i =P j); rewrite // oner_eq0.\nQed.",
    "Lemma maxrowsub_full : row_full (rowsub mxf A).\nProof. by rewrite /row_full eq_maxrowsub. Qed.",
    "Lemma fullrowsub_full : row_full (rowsub frf A).\nProof.\nby rewrite mxsub_ffunl rowsub_comp rowsub_cast esymK row_full_castmx.\nQed.",
    "Lemma fullrowsub_unit : rowsub frf A \\in unitmx.\nProof. by rewrite -row_full_unit fullrowsub_full. Qed.",
    "Lemma fullrowsub_free : row_free (rowsub frf A).\nProof.  by rewrite row_free_unit fullrowsub_unit. Qed.",
    "Lemma mxrank_fullrowsub : \\rank (rowsub frf A) = n.\nProof. exact/eqP/fullrowsub_full. Qed.",
    "Lemma eq_fullrowsub : (rowsub frf A :=: A)%MS.\nProof.\nrewrite mxsub_ffunl rowsub_comp rowsub_cast esymK.\nexact: (eqmx_trans (eqmx_cast _ _) eq_maxrowsub).\nQed.",
    "Lemma fullrankfun_inj : injective frf.\nProof.\nby move=> i j; rewrite !ffunE => /maxrankfun_inj /(congr1 val)/= /val_inj.\nQed.",
    "Lemma mxdirectP n (S : proper_mxsum_expr n) :\n  reflect (\\rank S = proper_mxsum_rank S) (mxdirect S).\nProof. exact: eqnP. Qed.",
    "Lemma mxdirect_trivial m n A : mxdirect (unwrap (@trivial_mxsum m n A)).\nProof. exact: eqxx. Qed.",
    "Lemma mxrank_sum_leqif m n (S : mxsum_expr m n) :\n  \\rank (unwrap S) <= unwrap (mxsum_rank S) ?= iff mxdirect (unwrap S).\nProof.\nrewrite /mxdirect_def; case: S => [[A] [r] /= defAr]; split=> //=.\nelim: m A r / defAr => // m1 m2 A1 A2 r1 r2 _ leAr1 _ leAr2.\nby apply: leq_trans (leq_add leAr1 leAr2); rewrite mxrank_adds_leqif.\nQed.",
    "Lemma mxdirectE m n (S : mxsum_expr m n) :\n  mxdirect (unwrap S) = (\\rank (unwrap S) == unwrap (mxsum_rank S)).\nProof. by []. Qed.",
    "Lemma mxdirectEgeq m n (S : mxsum_expr m n) :\n  mxdirect (unwrap S) = (\\rank (unwrap S) >= unwrap (mxsum_rank S)).\nProof. by rewrite (geq_leqif (mxrank_sum_leqif S)). Qed.",
    "Lemma mxdirect_addsE (S1 : mxsum_expr m1 n) (S2 : mxsum_expr m2 n) :\n   mxdirect (unwrap S1 + unwrap S2)\n    = [&& mxdirect (unwrap S1), mxdirect (unwrap S2)\n        & unwrap S1 :&: unwrap S2 == 0]%MS.\nProof.\nrewrite (@mxdirectE n) /=.\nhave:= leqif_add (mxrank_sum_leqif S1) (mxrank_sum_leqif S2).\nmove/(leqif_trans (mxrank_adds_leqif (unwrap S1) (unwrap S2)))=> ->.\nby rewrite andbC -andbA submx0.\nQed.",
    "Lemma mxdirect_addsP (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (A :&: B = 0)%MS (mxdirect (A + B)).\nProof. by rewrite mxdirect_addsE !mxdirect_trivial; apply: eqP. Qed.",
    "Lemma mxdirect_sumsP (A_ : I -> 'M_n) :\n  reflect (forall i, P i -> A_ i :&: (\\sum_(j | P j && (j != i)) A_ j) = 0)%MS\n          (mxdirect (\\sum_(i | P i) A_ i)).\nProof.\napply: (iffP (mxdirect_sums_recP _)) => dxA i /dxA; first by case.\nby rewrite mxdirect_trivial.\nQed.",
    "Lemma mxdirect_sumsE (S_ : I -> mxsum_expr n n) (xunwrap := unwrap) :\n  reflect (and (forall i, P i -> mxdirect (unwrap (S_ i)))\n               (mxdirect (\\sum_(i | P i) (xunwrap (S_ i)))))\n          (mxdirect (\\sum_(i | P i) (unwrap (S_ i)))).\nProof.\napply: (iffP (mxdirect_sums_recP _)) => [dxS | [dxS_ dxS] i Pi].\n  by do [split; last apply/mxdirect_sumsP] => i; case/dxS.\nby split; [apply: dxS_ | apply: mxdirect_sumsP Pi].\nQed.",
    "Lemma sub_daddsmx : (B1 :&: B2 = 0)%MS -> (A <= B1 + B2)%MS -> sub_daddsmx_spec.\nProof.\nmove=> dxB /sub_addsmxP[u defA].\nexists (u.1 *m B1) (u.2 *m B2); rewrite ?submxMl // => C1 C2 sCB1 sCB2.\nmove/(canLR (addrK _)) => defC1.\nsuffices: (C2 - u.2 *m B2 <= B1 :&: B2)%MS.\n  by rewrite dxB submx0 subr_eq0 -defC1 defA; move/eqP->; rewrite addrK.\nrewrite sub_capmx -opprB -{1}(canLR (addKr _) defA) -addrA defC1.\nby rewrite !(eqmx_opp, addmx_sub) ?submxMl.\nQed.",
    "Lemma sub_dsumsmx :\n    mxdirect (\\sum_(i | P i) B i) -> (A <= \\sum_(i | P i) B i)%MS ->\n  sub_dsumsmx_spec.\nProof.\nmove/mxdirect_sumsP=> dxB /sub_sumsmxP[u defA].\npose A_ i := u i *m B i.\nexists A_ => //= [i _ | C sCB defAC i Pi]; first exact: submxMl.\napply/eqP; rewrite -subr_eq0 -submx0 -{dxB}(dxB i Pi) /=.\nrewrite sub_capmx addmx_sub ?eqmx_opp ?submxMl ?sCB //=.\nrewrite -(subrK A (C i)) -addrA -opprB addmx_sub ?eqmx_opp //.\n  rewrite addrC defAC (bigD1 i) // addKr /= summx_sub // => j Pi'j.\n  by rewrite (sumsmx_sup j) ?sCB //; case/andP: Pi'j.\nrewrite addrC defA (bigD1 i) // addKr /= summx_sub // => j Pi'j.\nby rewrite (sumsmx_sup j) ?submxMl.\nQed.",
    "Lemma eigenspaceP a m (W : 'M_(m, n)) :\n  reflect (W *m g = a *: W) (W <= eigenspace a)%MS.\nProof. by rewrite sub_kermx mulmxBr subr_eq0 mul_mx_scalar; apply/eqP. Qed.",
    "Lemma eigenvalueP a :\n  reflect (exists2 v : 'rV_n, v *m g = a *: v & v != 0) (eigenvalue a).\nProof. by apply: (iffP (rowV0Pn _)) => [] [v]; move/eigenspaceP; exists v. Qed.",
    "Lemma eigenvectorP {v : 'rV_n} :\n  reflect (exists a, (v <= eigenspace a)%MS) (stablemx v g).\nProof. by apply: (iffP (sub_rVP _ _)) => -[a] /eigenspaceP; exists a. Qed.",
    "Lemma mxdirect_sum_eigenspace (P : pred I) a_ :\n  {in P &, injective a_} -> mxdirect (\\sum_(i | P i) eigenspace (a_ i)).\nProof.\nhave [m] := ubnP #|P|; elim: m P => // m IHm P lePm inj_a.\napply/mxdirect_sumsP=> i Pi; apply/eqP/rowV0P => v.\nrewrite sub_capmx => /andP[/eigenspaceP def_vg].\nset Vi' := (\\sum_(i | _) _)%MS => Vi'v.\nhave dxVi': mxdirect Vi'.\n  rewrite (cardD1x Pi) in lePm; apply: IHm => //.\n  by apply: sub_in2 inj_a => j /andP[].\ncase/sub_dsumsmx: Vi'v => // u Vi'u def_v _.\nrewrite def_v big1 // => j Pi'j; apply/eqP.\nhave nz_aij: a_ i - a_ j != 0.\n  by case/andP: Pi'j => Pj ne_ji; rewrite subr_eq0 eq_sym (inj_in_eq inj_a).\ncase: (sub_dsumsmx dxVi' (sub0mx 1 _)) => C _ _ uniqC.\nrewrite -(eqmx_eq0 (eqmx_scale _ nz_aij)).\nrewrite (uniqC (fun k => (a_ i - a_ k) *: u k)) => // [|k Pi'k|].\n- by rewrite -(uniqC (fun _ => 0)) ?big1 // => k Pi'k; apply: sub0mx.\n- by rewrite scalemx_sub ?Vi'u.\nrewrite -{1}(subrr (v *m g)) {1}def_vg def_v scaler_sumr mulmx_suml -sumrB.\nby apply: eq_bigr => k /Vi'u/eigenspaceP->; rewrite scalerBl.\nQed.",
    "Lemma eqmx_stable m m' n (V : 'M[F]_(m, n)) (V' : 'M[F]_(m', n)) (f : 'M[F]_n) :\n  (V :=: V')%MS -> stablemx V f = stablemx V' f.\nProof. by move=> eqVV'; rewrite (eqmxMr _ eqVV') eqVV'. Qed.",
    "Lemma stablemx_row_base : (stablemx (row_base V) f) = (stablemx V f).\nProof. by apply: eqmx_stable; apply: eq_row_base. Qed.",
    "Lemma stablemx_full : row_full V -> stablemx V f. Proof. exact: submx_full. Qed.",
    "Lemma stablemxM : stablemx V f -> stablemx V g -> stablemx V (f *m g).\nProof. by move=> f_stab /(submx_trans _)->//; rewrite mulmxA submxMr. Qed.",
    "Lemma stablemxD : stablemx V f -> stablemx V g -> stablemx V (f + g).\nProof. by move=> f_stab g_stab; rewrite mulmxDr addmx_sub. Qed.",
    "Lemma stablemxN : stablemx V (- f) = stablemx V f.\nProof. by rewrite mulmxN eqmx_opp. Qed.",
    "Lemma stablemxC x : stablemx V x%:M.\nProof. by rewrite mul_mx_scalar scalemx_sub. Qed.",
    "Lemma stablemx0 : stablemx V 0. Proof. by rewrite mulmx0 sub0mx. Qed.",
    "Lemma stableDmx : stablemx V f -> stablemx W f -> stablemx (V + W)%MS f.\nProof. by move=> fV fW; rewrite addsmxMr addsmxS. Qed.",
    "Lemma stableNmx : stablemx (- V) f = stablemx V f.\nProof. by rewrite mulNmx !eqmx_opp. Qed.",
    "Lemma stable0mx : stablemx (0 : 'M_(m, n)) f. Proof. by rewrite mul0mx. Qed.",
    "Lemma stableCmx (m n : nat) x (f : 'M[F]_(m, n)) : stablemx x%:M f.\nProof.\nhave [->|x_neq0] := eqVneq x 0; first by rewrite mul_scalar_mx scale0r sub0mx.\nby rewrite -![x%:M]scalemx1 eqmx_scale// submx_full// -sub1mx.\nQed.",
    "Lemma stablemx_sums (n : nat) (I : finType) (V_ : I -> 'M[F]_n) (f : 'M_n) :\n  (forall i, stablemx (V_ i) f) -> stablemx (\\sum_i V_ i)%MS f.\nProof.\nby move=> fV; rewrite sumsmxMr; apply/sumsmx_subP => i; rewrite (sumsmx_sup i).\nQed.",
    "Lemma stablemx_unit (n : nat) (V f : 'M[F]_n) : V \\in unitmx -> stablemx V f.\nProof. by move=> Vunit; rewrite submx_full ?row_full_unit. Qed.",
    "Lemma comm_mx_stable (f g : 'M[F]_n) : comm_mx f g -> stablemx f g.\nProof. by move=> comm_fg; rewrite [_ *m _]comm_fg mulmx_sub. Qed.",
    "Lemma comm_mx_stable_ker (f g : 'M[F]_n) :\n  comm_mx f g -> stablemx (kermx f) g.\nProof.\nmove=> comm_fg; apply/sub_kermxP.\nby rewrite -mulmxA -[g *m _]comm_fg mulmxA mulmx_ker mul0mx.\nQed.",
    "Lemma comm_mx_stable_eigenspace (f g : 'M[F]_n) a :\n  comm_mx f g -> stablemx (eigenspace f a) g.\nProof.\nmove=> cfg; rewrite comm_mx_stable_ker//.\nby apply/comm_mx_sym/comm_mxB => //; apply:comm_mx_scalar.\nQed.",
    "Lemma mxdirect_delta n f : {in P &, injective f} ->\n  mxdirect (\\sum_(i | P i) <<delta_mx 0 (f i) : 'rV[F]_n>>).\nProof.\npose fP := image f P => Uf; have UfP: uniq fP by apply/dinjectiveP.\nsuffices /mxdirectP : mxdirect (\\sum_i <<delta_mx 0 i : 'rV[F]_n>>).\n  rewrite /= !(bigID [in fP] predT) -!big_uniq //= !big_map !big_enum.\n  by move/mxdirectP; rewrite mxdirect_addsE => /andP[].\napply/mxdirectP=> /=; transitivity (mxrank (1%:M : 'M[F]_n)).\n  apply/eqmx_rank; rewrite submx1 mx1_sum_delta summx_sub_sums // => i _.\n  by rewrite -(mul_delta_mx (0 : 'I_1)) genmxE submxMl.\nrewrite mxrank1 -[LHS]card_ord -sum1_card.\nby apply/eq_bigr=> i _; rewrite /= mxrank_gen mxrank_delta.\nQed.",
    "Lemma card_GL n : n > 0 ->\n  #|'GL_n[F]| = (#|F| ^ 'C(n, 2) * \\prod_(1 <= i < n.+1) (#|F| ^ i - 1))%N.\nProof.\ncase: n => // n' _; set n := n'.+1; set p := #|F|.\nrewrite big_nat_rev big_add1 -bin2_sum expn_sum -big_split /=.\npose fr m := [pred A : 'M[F]_(m, n) | \\rank A == m].\nset m := n; rewrite [in m.+1]/m; transitivity #|fr m|.\n  by rewrite cardsT /= card_sub; apply: eq_card => A; rewrite -row_free_unit.\nhave: m <= n by []; elim: m => [_ | m IHm /ltnW-le_mn].\n  rewrite (@eq_card1 _ (0 : 'M_(0, n))) ?big_geq //= => A.\n  by rewrite flatmx0 !inE mxrank.unlock !eqxx.\nrewrite big_nat_recr // -{}IHm //= !subSS mulnBr muln1 -expnD subnKC //.\nrewrite -sum_nat_const /= -sum1_card -add1n.\nrewrite (partition_big dsubmx (fr m)) /= => [|A]; last first.\n  rewrite !inE -{1}(vsubmxK A); move: {A}(_ A) (_ A) => Ad Au Afull.\n  rewrite eqn_leq rank_leq_row -(leq_add2l (\\rank Au)) -mxrank_sum_cap.\n  rewrite {1 3}[@mxrank]lock addsmxE (eqnP Afull) -lock -addnA.\n  by rewrite leq_add ?rank_leq_row ?leq_addr.\napply: eq_bigr => A rAm; rewrite (reindex (col_mx^~ A)) /=; last first.\n  exists usubmx => [v _ | vA]; first by rewrite col_mxKu.\n  by case/andP=> _ /eqP <-; rewrite vsubmxK.\ntransitivity #|~: [set v *m A | v in 'rV_m]|; last first.\n  rewrite cardsCs setCK card_imset ?card_mx ?card_ord ?mul1n //.\n  have [B AB1] := row_freeP rAm; apply: can_inj (mulmx^~ B) _ => v.\n  by rewrite -mulmxA AB1 mulmx1.\nrewrite -sum1_card; apply: eq_bigl => v; rewrite !inE col_mxKd eqxx.\nrewrite andbT eqn_leq rank_leq_row /= -(leq_add2r (\\rank (v :&: A)%MS)).\nrewrite -addsmxE mxrank_sum_cap (eqnP rAm) addnAC leq_add2r.\nrewrite (ltn_leqif (mxrank_leqif_sup _)) ?capmxSl // sub_capmx submx_refl.\nby congr (~~ _); apply/submxP/imsetP=> [] [u]; exists u.\nQed.",
    "Lemma LUP_card_GL n : n > 0 ->\n  #|'GL_n[F]| = (#|F| ^ 'C(n, 2) * \\prod_(1 <= i < n.+1) (#|F| ^ i - 1))%N.\nProof.\ncase: n => // n' _; set n := n'.+1; set p := #|F|.\nrewrite cardsT /= card_sub /GRing.unit /= big_add1 /= -bin2_sum -/n /=.\nelim: {n'}n => [|n IHn].\n  rewrite !big_geq // mul1n (@eq_card _ _ predT) ?card_mx //= => M.\n  by rewrite {1}[M]flatmx0 -(flatmx0 1%:M) unitmx1.\nrewrite !big_nat_recr //= expnD mulnAC mulnA -{}IHn -mulnA mulnC.\nset LHS := #|_|; rewrite -[n.+1]muln1 -{2}[n]mul1n {}/LHS.\nrewrite -!card_mx subn1 -(cardC1 0) -mulnA; set nzC := predC1 _.\nrewrite -sum1_card (partition_big lsubmx nzC) => [|A]; last first.\n  rewrite unitmxE unitfE; apply: contra; move/eqP=> v0.\n  rewrite -[A]hsubmxK v0 -[n.+1]/(1 + n)%N -col_mx0.\n  rewrite -[rsubmx _]vsubmxK -det_tr tr_row_mx !tr_col_mx !trmx0.\n  by rewrite det_lblock [0]mx11_scalar det_scalar1 mxE mul0r.\nrewrite -sum_nat_const; apply: eq_bigr => /= v /cV0Pn[k nza].\nhave xrkK: involutive (@xrow F _ _ 0 k).\n  by move=> m A /=; rewrite /xrow -row_permM tperm2 row_perm1.\nrewrite (reindex_inj (inv_inj (xrkK (1 + n)%N))) /= -[n.+1]/(1 + n)%N.\nrewrite (partition_big ursubmx xpredT) //= -sum_nat_const.\napply: eq_bigr => u _; set a : F := v _ _ in nza.\nset v1 : 'cV_(1 + n) := xrow 0 k v.\nhave def_a: usubmx v1 = a%:M.\n  by rewrite [_ v1]mx11_scalar mxE lshift0 mxE tpermL.\npose Schur := dsubmx v1 *m (a^-1 *: u).\npose L : 'M_(1 + n) := block_mx a%:M 0 (dsubmx v1) 1%:M.\npose U B : 'M_(1 + n) := block_mx 1 (a^-1 *: u) 0 B.\nrewrite (reindex (fun B => L *m U B)); last first.\n  exists (fun A1 => drsubmx A1 - Schur) => [B _ | A1].\n    by rewrite mulmx_block block_mxKdr mul1mx addrC addKr.\n  rewrite !inE mulmx_block !mulmx0 mul0mx !mulmx1 !addr0 mul1mx addrC subrK.\n  rewrite mul_scalar_mx scalerA divff // scale1r andbC; case/and3P => /eqP <- _.\n  rewrite -{1}(hsubmxK A1) xrowE mul_mx_row row_mxKl -xrowE => /eqP def_v.\n  rewrite -def_a block_mxEh vsubmxK /v1 -def_v xrkK.\n  apply: trmx_inj; rewrite tr_row_mx tr_col_mx trmx_ursub trmx_drsub trmx_lsub.\n  by rewrite hsubmxK vsubmxK.\nrewrite -sum1_card; apply: eq_bigl => B; rewrite xrowE unitmxE.\nrewrite !det_mulmx unitrM -unitmxE unitmx_perm det_lblock det_ublock.\nrewrite !det_scalar1 det1 mulr1 mul1r unitrM unitfE nza -unitmxE.\nrewrite mulmx_block !mulmx0 mul0mx !addr0 !mulmx1 mul1mx block_mxKur.\nrewrite mul_scalar_mx scalerA divff // scale1r eqxx andbT.\nby rewrite block_mxEh mul_mx_row row_mxKl -def_a vsubmxK -xrowE xrkK eqxx andbT.\nQed.",
    "Lemma card_GL_1 : #|'GL_1[F]| = #|F|.-1.\nProof. by rewrite card_GL // mul1n big_nat1 expn1 subn1. Qed.",
    "Lemma card_GL_2 : #|'GL_2[F]| = (#|F| * #|F|.-1 ^ 2 * #|F|.+1)%N.\nProof.\nrewrite card_GL // big_ltn // big_nat1 expn1 -(addn1 #|F|) -subn1 -!mulnA.\nby rewrite -subn_sqr.\nQed.",
    "Lemma logn_card_GL_p n p : prime p -> logn p #|'GL_n(p)| = 'C(n, 2).\nProof.\nmove=> p_pr; have p_gt1 := prime_gt1 p_pr.\nhave p_i_gt0: p ^ _ > 0 by move=> i; rewrite expn_gt0 ltnW.\nhave <- : #|'GL_n.-1.+1(p)| = #|'GL_n(p)| by [].\nrewrite (card_GL _ (ltn0Sn n.-1)) card_ord Fp_cast // big_add1 /=.\npose p'gt0 m := m > 0 /\\ logn p m = 0.\nsuffices [Pgt0 p'P]: p'gt0 (\\prod_(0 <= i < n.-1.+1) (p ^ i.+1 - 1))%N.\n  by rewrite lognM // p'P pfactorK // addn0; case n.\napply: big_ind => [|m1 m2 [m10 p'm1] [m20]|i _]; rewrite {}/p'gt0 ?logn1 //.\n  by rewrite muln_gt0 m10 lognM ?p'm1.\nrewrite lognE -if_neg subn_gt0 p_pr /= -{1 2}(exp1n i.+1) ltn_exp2r // p_gt1.\nby rewrite dvdn_subr ?dvdn_exp // gtnNdvd.\nQed.",
    "Lemma mem0mx m n (R : 'A_(m, n)) : 0 \\in R.\nProof. by rewrite linear0 sub0mx. Qed.",
    "Lemma memmx0 n A : (A \\in (0 : 'A_n)) -> A = 0.\nProof. by rewrite submx0 mxvec_eq0; move/eqP. Qed.",
    "Lemma memmx1 n (A : 'M_n) : (A \\in mxvec 1%:M) = is_scalar_mx A.\nProof.\napply/sub_rVP/is_scalar_mxP=> [[a] | [a ->]].\n  by rewrite -linearZ scale_scalar_mx mulr1 => /(can_inj mxvecK); exists a.\nby exists a; rewrite -linearZ scale_scalar_mx mulr1.\nQed.",
    "Lemma memmx_subP m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (forall A, A \\in R1 -> A \\in R2) (R1 <= R2)%MS.\nProof.\napply: (iffP idP) => [sR12 A R1_A | sR12]; first exact: submx_trans sR12.\nby apply/rV_subP=> vA; rewrite -(vec_mxK vA); apply: sR12.\nQed.",
    "Lemma memmx_eqP m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (forall A, (A \\in R1) = (A \\in R2)) (R1 == R2)%MS.\nProof.\napply: (iffP eqmxP) => [eqR12 A | eqR12]; first by rewrite eqR12.\nby apply/eqmxP/rV_eqP=> vA; rewrite -(vec_mxK vA) eqR12.\nQed.",
    "Lemma memmx_addsP m1 m2 n A (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (exists D, [/\\ D.1 \\in R1, D.2 \\in R2 & A = D.1 + D.2])\n          (A \\in R1 + R2)%MS.\nProof.\napply: (iffP sub_addsmxP) => [[u /(canRL mxvecK)->] | [D []]].\n  exists (vec_mx (u.1 *m R1), vec_mx (u.2 *m R2)).\n  by rewrite /= linearD !vec_mxK !submxMl.\ncase/submxP=> u1 defD1 /submxP[u2 defD2] ->.\nby exists (u1, u2); rewrite linearD /= defD1 defD2.\nQed.",
    "Lemma memmx_sumsP (I : finType) (P : pred I) n (A : 'M_n) R_ :\n  reflect (exists2 A_, A = \\sum_(i | P i) A_ i & forall i, A_ i \\in R_ i)\n          (A \\in \\sum_(i | P i) R_ i)%MS.\nProof.\napply: (iffP sub_sumsmxP) => [[C defA] | [A_ -> R_A] {A}].\n  exists (fun i => vec_mx (C i *m R_ i)) => [|i].\n    by rewrite -linear_sum -defA /= mxvecK.\n  by rewrite vec_mxK submxMl.\nexists (fun i => mxvec (A_ i) *m pinvmx (R_ i)).\nby rewrite linear_sum; apply: eq_bigr => i _; rewrite mulmxKpV.\nQed.",
    "Lemma has_non_scalar_mxP m n (R : 'A_(m, n)) :\n    (1%:M \\in R)%MS ->\n  reflect (exists2 A, A \\in R & ~~ is_scalar_mx A)%MS (1 < \\rank R).\nProof.\ncase: (posnP n) => [-> | n_gt0] in R *; set S := mxvec _ => sSR.\n  by rewrite [R]thinmx0 mxrank0; right; case; rewrite /is_scalar_mx ?insubF.\nhave rankS: \\rank S = 1%N.\n  apply/eqP; rewrite eqn_leq rank_leq_row lt0n mxrank_eq0 mxvec_eq0.\n  by rewrite -mxrank_eq0 mxrank1 -lt0n.\nrewrite -{2}rankS (ltn_leqif (mxrank_leqif_sup sSR)).\napply: (iffP idP) => [/row_subPn[i] | [A sAR]].\n  rewrite -[row i R]vec_mxK memmx1; set A := vec_mx _ => nsA.\n  by exists A; rewrite // vec_mxK row_sub.\nby rewrite -memmx1; apply/contra/submx_trans.\nQed.",
    "Lemma genmx_muls m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  <<(R1 * R2)%MS>>%MS = (R1 * R2)%MS.\nProof. by rewrite genmx_sums; apply: eq_bigr => i; rewrite genmx_id. Qed.",
    "Lemma mem_mulsmx m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) A1 A2 :\n  (A1 \\in R1 -> A2 \\in R2 -> A1 *m A2 \\in R1 * R2)%MS.\nProof.\nmove=> R_A1 R_A2; rewrite -[A2]mxvecK; case/submxP: R_A2 => a ->{A2}.\nrewrite mulmx_sum_row !linear_sum summx_sub // => i _.\nrewrite 3!linearZ scalemx_sub {a}//= (sumsmx_sup i) // genmxE.\nrewrite -[A1]mxvecK; case/submxP: R_A1 => a ->{A1}.\nby apply/submxP; exists a; rewrite mulmxA mul_rV_lin.\nQed.",
    "Lemma mulsmx_subP m1 m2 m n\n                 (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) (R : 'A_(m, n)) :\n  reflect (forall A1 A2, A1 \\in R1 -> A2 \\in R2 -> A1 *m A2 \\in R)\n          (R1 * R2 <= R)%MS.\nProof.\napply: (iffP memmx_subP) => [sR12R A1 A2 R_A1 R_A2 | sR12R A].\n  by rewrite sR12R ?mem_mulsmx.\ncase/memmx_sumsP=> A_ -> R_A; rewrite linear_sum summx_sub //= => j _.\nrewrite (submx_trans (R_A _)) // genmxE; apply/row_subP=> i.\nby rewrite row_mul mul_rV_lin sR12R ?vec_mxK ?row_sub.\nQed.",
    "Lemma mulsmxS m1 m2 m3 m4 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n))\n                            (R3 : 'A_(m3, n)) (R4 : 'A_(m4, n)) :\n  (R1 <= R3 -> R2 <= R4 -> R1 * R2 <= R3 * R4)%MS.\nProof.\nmove=> sR13 sR24; apply/mulsmx_subP=> A1 A2 R_A1 R_A2.\nby apply: mem_mulsmx; [apply: submx_trans sR13 | apply: submx_trans sR24].\nQed.",
    "Lemma muls_eqmx m1 m2 m3 m4 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n))\n                              (R3 : 'A_(m3, n)) (R4 : 'A_(m4, n)) :\n  (R1 :=: R3 -> R2 :=: R4 -> R1 * R2 = R3 * R4)%MS.\nProof.\nmove=> eqR13 eqR24; rewrite -(genmx_muls R1 R2) -(genmx_muls R3 R4).\nby apply/genmxP; rewrite !mulsmxS ?eqR13 ?eqR24.\nQed.",
    "Lemma mulsmxP m1 m2 n A (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (exists2 A1, forall i, A1 i \\in R1\n            & exists2 A2, forall i, A2 i \\in R2\n           & A = \\sum_(i < n ^ 2) A1 i *m A2 i)\n          (A \\in R1 * R2)%MS.\nProof.\napply: (iffP idP) => [R_A|[A1 R_A1 [A2 R_A2 ->{A}]]]; last first.\n  by rewrite linear_sum summx_sub // => i _; rewrite mem_mulsmx.\nhave{R_A}: (A \\in R1 * <<R2>>)%MS.\n  by apply: memmx_subP R_A; rewrite mulsmxS ?genmxE.\ncase/memmx_sumsP=> A_ -> R_A; pose A2_ i := vec_mx (row i <<R2>>%MS).\npose A1_ i := mxvec (A_ i) *m pinvmx (R1 *m lin_mx (mulmxr (A2_ i))) *m R1.\nexists (vec_mx \\o A1_) => [i|]; first by rewrite vec_mxK submxMl.\nexists A2_ => [i|]; first by rewrite vec_mxK -(genmxE R2) row_sub.\napply: eq_bigr => i _; rewrite -[_ *m _](mx_rV_lin (mulmxr (A2_ i))).\nby rewrite -mulmxA mulmxKpV ?mxvecK // -(genmxE (_ *m _)) R_A.\nQed.",
    "Lemma mulsmxA m1 m2 m3 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) (R3 : 'A_(m3, n)) :\n  (R1 * (R2 * R3) = R1 * R2 * R3)%MS.\nProof.\nrewrite -(genmx_muls (_ * _)%MS) -genmx_muls; apply/genmxP/andP; split.\n  apply/mulsmx_subP=> A1 A23 R_A1; case/mulsmxP=> A2 R_A2 [A3 R_A3 ->{A23}].\n  by rewrite !linear_sum summx_sub //= => i _; rewrite mulmxA !mem_mulsmx.\napply/mulsmx_subP=> _ A3 /mulsmxP[A1 R_A1 [A2 R_A2 ->]] R_A3.\nrewrite mulmx_suml linear_sum summx_sub //= => i _.\nby rewrite -mulmxA !mem_mulsmx.\nQed.",
    "Lemma mulsmxDl m1 m2 m3 n\n               (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) (R3 : 'A_(m3, n)) :\n  ((R1 + R2) * R3 = R1 * R3 + R2 * R3)%MS.\nProof.\nrewrite -(genmx_muls R2 R3) -(genmx_muls R1 R3) -genmx_muls -genmx_adds.\napply/genmxP; rewrite andbC addsmx_sub !mulsmxS ?addsmxSl ?addsmxSr //=.\napply/mulsmx_subP=> _ A3 /memmx_addsP[A [R_A1 R_A2 ->]] R_A3.\nby rewrite mulmxDl linearD addmx_sub_adds ?mem_mulsmx.\nQed.",
    "Lemma mulsmxDr m1 m2 m3 n\n               (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) (R3 : 'A_(m3, n)) :\n  (R1 * (R2 + R3) = R1 * R2 + R1 * R3)%MS.\nProof.\nrewrite -(genmx_muls R1 R3) -(genmx_muls R1 R2) -genmx_muls -genmx_adds.\napply/genmxP; rewrite andbC addsmx_sub !mulsmxS ?addsmxSl ?addsmxSr //=.\napply/mulsmx_subP=> A1 _ R_A1 /memmx_addsP[A [R_A2 R_A3 ->]].\nby rewrite mulmxDr linearD addmx_sub_adds ?mem_mulsmx.\nQed.",
    "Lemma mulsmx0 m1 m2 n (R1 : 'A_(m1, n)) : (R1 * (0 : 'A_(m2, n)) = 0)%MS.\nProof.\napply/eqP; rewrite -submx0; apply/mulsmx_subP=> A1 A0 _.\nby rewrite [A0 \\in 0]eqmx0 => /memmx0->; rewrite mulmx0 mem0mx.\nQed.",
    "Lemma muls0mx m1 m2 n (R2 : 'A_(m2, n)) : ((0 : 'A_(m1, n)) * R2 = 0)%MS.\nProof.\napply/eqP; rewrite -submx0; apply/mulsmx_subP=> A0 A2.\nby rewrite [A0 \\in 0]eqmx0 => /memmx0->; rewrite mul0mx mem0mx.\nQed.",
    "Lemma mxring_idP m n (R : 'A_(m, n)) :\n  reflect (exists e, mxring_id R e) (has_mxring_id R).\nProof.\napply: (iffP andP) => [[nzR] | [e [nz_e Re ideR idRe]]].\n  case/submxP=> v; rewrite -[v]vec_mxK; move/vec_mx: v => e.\n  rewrite !mul_mx_row; case/eq_row_mx => /eqP.\n  rewrite eq_sym -submxE => Re.\n  case/eq_row_mx; rewrite !{1}mul_rV_lin1 /= mxvecK.\n  set u := (_ *m _) => /(can_inj mxvecK) idRe /(can_inj mxvecK) ideR.\n  exists e; split=> // [ | A /submxP[a defA] | A /submxP[a defA]].\n  - by apply: contra nzR; rewrite ideR => /eqP->; rewrite !linear0.\n  - by rewrite -{2}[A]mxvecK defA idRe mulmxA mx_rV_lin -defA /= mxvecK.\n  by rewrite -{2}[A]mxvecK defA ideR mulmxA mx_rV_lin -defA /= mxvecK.\nsplit.\n  by apply: contraNneq nz_e => R0; rewrite R0 eqmx0 in Re; rewrite (memmx0 Re).\napply/submxP; exists (mxvec e); rewrite !mul_mx_row !{1}mul_rV_lin1.\nrewrite submxE in Re; rewrite {Re}(eqP Re).\ncongr (row_mx 0 (row_mx (mxvec _) (mxvec _))); apply/row_matrixP=> i.\n  by rewrite !row_mul !mul_rV_lin1 /= mxvecK ideR vec_mxK ?row_sub.\nby rewrite !row_mul !mul_rV_lin1 /= mxvecK idRe vec_mxK ?row_sub.\nQed.",
    "Lemma cent_mx_fun_is_linear : linear cent_mx_fun.\nProof.\nmove=> a A B; apply/row_matrixP=> i; rewrite linearP row_mul mul_rV_lin.\nrewrite /= [row i _ as v in a *: v]row_mul mul_rV_lin row_mul mul_rV_lin.\nby rewrite -linearP -(linearP (mulmx (vec_mx (row i R)) \\- mulmxr _)).\nQed.",
    "Lemma cent_rowP m n B (R : 'A_(m, n)) :\n  reflect (forall i (A := vec_mx (row i R)), A *m B = B *m A) (B \\in 'C(R))%MS.\nProof.\napply: (iffP sub_kermxP); rewrite mul_vec_lin => cBE.\n  move/(canRL mxvecK): cBE => cBE i A /=; move/(congr1 (row i)): cBE.\n  rewrite row_mul mul_rV_lin -/A; move/(canRL mxvecK).\n  by move/(canRL (subrK _)); rewrite !linear0 add0r.\napply: (canLR vec_mxK); apply/row_matrixP=> i.\nby rewrite row_mul mul_rV_lin /= cBE subrr !linear0.\nQed.",
    "Lemma cent_mxP m n B (R : 'A_(m, n)) :\n  reflect (forall A, A \\in R -> A *m B = B *m A) (B \\in 'C(R))%MS.\nProof.\napply: (iffP cent_rowP) => cEB => [A sAE | i A].\n  rewrite -[A]mxvecK -(mulmxKpV sAE); move: (mxvec A *m _) => u.\n  rewrite !mulmx_sum_row !linear_sum mulmx_suml; apply: eq_bigr => i _ /=.\n  by rewrite 2!linearZ -scalemxAl /= cEB.\nby rewrite cEB // vec_mxK row_sub.\nQed.",
    "Lemma scalar_mx_cent m n a (R : 'A_(m, n)) : (a%:M \\in 'C(R))%MS.\nProof. by apply/cent_mxP=> A _; apply: scalar_mxC. Qed.",
    "Lemma center_mx_sub m n (R : 'A_(m, n)) : ('Z(R) <= R)%MS.\nProof. exact: capmxSl. Qed.",
    "Lemma center_mxP m n A (R : 'A_(m, n)) :\n  reflect (A \\in R /\\ forall B, B \\in R -> B *m A = A *m B)\n          (A \\in 'Z(R))%MS.\nProof.\nrewrite sub_capmx; case R_A: (A \\in R); last by right; case.\nby apply: (iffP cent_mxP) => [cAR | [_ cAR]].\nQed.",
    "Lemma mxring_id_uniq m n (R : 'A_(m, n)) e1 e2 :\n  mxring_id R e1 -> mxring_id R e2 -> e1 = e2.\nProof.\nby case=> [_ Re1 idRe1 _] [_ Re2 _ ide2R]; rewrite -(idRe1 _ Re2) ide2R.\nQed.",
    "Lemma cent_mx_ideal m n (R : 'A_(m, n)) : left_mx_ideal 'C(R)%MS 'C(R)%MS.\nProof.\napply/mulsmx_subP=> A1 A2 C_A1 C_A2; apply/cent_mxP=> B R_B.\nby rewrite mulmxA (cent_mxP C_A1) // -!mulmxA (cent_mxP C_A2).\nQed.",
    "Lemma cent_mx_ring m n (R : 'A_(m, n)) : n > 0 -> mxring 'C(R)%MS.\nProof.\nmove=> n_gt0; rewrite /mxring cent_mx_ideal; apply/mxring_idP.\nexists 1%:M; split=> [||A _|A _]; rewrite ?mulmx1 ?mul1mx ?scalar_mx_cent //.\nby rewrite -mxrank_eq0 mxrank1 -lt0n.\nQed.",
    "Lemma mxdirect_adds_center m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n    mx_ideal (R1 + R2)%MS R1 -> mx_ideal (R1 + R2)%MS R2 ->\n    mxdirect (R1 + R2) ->\n  ('Z((R1 + R2)%MS) :=: 'Z(R1) + 'Z(R2))%MS.\nProof.\ncase/andP=> idlR1 idrR1 /andP[idlR2 idrR2] /mxdirect_addsP dxR12.\napply/eqmxP/andP; split.\n  apply/memmx_subP=> z0; rewrite sub_capmx => /andP[].\n  case/memmx_addsP=> z [R1z1 R2z2 ->{z0}] Cz.\n  rewrite linearD addmx_sub_adds //= ?sub_capmx ?R1z1 ?R2z2 /=.\n    apply/cent_mxP=> A R1_A; have R_A := submx_trans R1_A (addsmxSl R1 R2).\n    have Rz2 := submx_trans R2z2 (addsmxSr R1 R2).\n    rewrite -{1}[z.1](addrK z.2) mulmxBr (cent_mxP Cz) // mulmxDl.\n    rewrite [A *m z.2]memmx0 1?[z.2 *m A]memmx0 ?addrK //.\n      by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  apply/cent_mxP=> A R2_A; have R_A := submx_trans R2_A (addsmxSr R1 R2).\n  have Rz1 := submx_trans R1z1 (addsmxSl R1 R2).\n  rewrite -{1}[z.2](addKr z.1) mulmxDr (cent_mxP Cz) // mulmxDl.\n  rewrite mulmxN [A *m z.1]memmx0 1?[z.1 *m A]memmx0 ?addKr //.\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\nrewrite addsmx_sub; apply/andP; split.\n  apply/memmx_subP=> z; rewrite sub_capmx => /andP[R1z cR1z].\n  have Rz := submx_trans R1z (addsmxSl R1 R2).\n  rewrite sub_capmx Rz; apply/cent_mxP=> A0.\n  case/memmx_addsP=> A [R1_A1 R2_A2] ->{A0}.\n  have R_A2 := submx_trans R2_A2 (addsmxSr R1 R2).\n  rewrite mulmxDl mulmxDr (cent_mxP cR1z) //; congr (_ + _).\n  rewrite [A.2 *m z]memmx0 1?[z *m A.2]memmx0 //.\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\napply/memmx_subP=> z; rewrite !sub_capmx => /andP[R2z cR2z].\nhave Rz := submx_trans R2z (addsmxSr R1 R2); rewrite Rz.\napply/cent_mxP=> _ /memmx_addsP[A [R1_A1 R2_A2 ->]].\nrewrite mulmxDl mulmxDr (cent_mxP cR2z _ R2_A2) //; congr (_ + _).\nhave R_A1 := submx_trans R1_A1 (addsmxSl R1 R2).\nrewrite [A.1 *m z]memmx0 1?[z *m A.1]memmx0 //.\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\nby rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\nQed.",
    "Lemma mxdirect_sums_center (I : finType) m n (R : 'A_(m, n)) R_ :\n    (\\sum_i R_ i :=: R)%MS -> mxdirect (\\sum_i R_ i) ->\n    (forall i : I, mx_ideal R (R_ i)) ->\n  ('Z(R) :=: \\sum_i 'Z(R_ i))%MS.\nProof.\nmove=> defR dxR idealR.\nhave sR_R: (R_ _ <= R)%MS by move=> i; rewrite -defR (sumsmx_sup i).\nhave anhR i j A B : i != j -> A \\in R_ i -> B \\in R_ j -> A *m B = 0.\n  move=> ne_ij RiA RjB; apply: memmx0.\n  have [[_ idRiR] [idRRj _]] := (andP (idealR i), andP (idealR j)).\n  rewrite -(mxdirect_sumsP dxR j) // sub_capmx (sumsmx_sup i) //.\n    by rewrite (mulsmx_subP idRRj) // (memmx_subP (sR_R i)).\n  by rewrite (mulsmx_subP idRiR) // (memmx_subP (sR_R j)).\napply/eqmxP/andP; split.\n  apply/memmx_subP=> Z; rewrite sub_capmx => /andP[].\n  rewrite -{1}defR => /memmx_sumsP[z ->{Z} Rz cRz].\n  apply/memmx_sumsP; exists z => // i; rewrite sub_capmx Rz.\n  apply/cent_mxP=> A RiA; have:= cent_mxP cRz A (memmx_subP (sR_R i) A RiA).\n  rewrite (bigD1 i) //= mulmxDl mulmxDr mulmx_suml mulmx_sumr.\n  by rewrite !big1 ?addr0 // => j; last rewrite eq_sym; move/anhR->.\napply/sumsmx_subP => i _; apply/memmx_subP=> z; rewrite sub_capmx.\ncase/andP=> Riz cRiz; rewrite sub_capmx (memmx_subP (sR_R i)) //=.\napply/cent_mxP=> A; rewrite -{1}defR; case/memmx_sumsP=> a -> R_a.\nrewrite (bigD1 i) // mulmxDl mulmxDr mulmx_suml mulmx_sumr.\nrewrite !big1 => [|j|j]; first by rewrite !addr0 (cent_mxP cRiz).\n  by rewrite eq_sym => /anhR->.\nby move/anhR->.\nQed.",
    "Lemma Gaussian_elimination_map m n (A : 'M_(m, n)) :\n  Gaussian_elimination_ A^f = ((col_ebase A)^f, (row_ebase A)^f, \\rank A).\nProof.\nrewrite mxrankE /row_ebase /col_ebase unlock.\nelim: m n A => [|m IHm] [|n] A /=; rewrite ?map_mx1 //.\nset pAnz := [pred k | A k.1 k.2 != 0].\nrewrite (@eq_pick _ _ pAnz) => [|k]; last by rewrite /= mxE fmorph_eq0.\ncase: {+}(pick _) => [[i j]|]; last by rewrite !map_mx1.\nrewrite mxE -fmorphV  -map_xcol -map_xrow -map_dlsubmx -map_drsubmx.\nrewrite -map_ursubmx -map_mxZ -map_mxM -map_mxB {}IHm /=.\ncase: {+}(Gaussian_elimination_ _) => [[L U] r] /=; rewrite map_xrow map_xcol.\nby rewrite !(@map_block_mx _ _ f 1 _ 1) !map_mx0 ?map_mx1 ?map_scalar_mx.\nQed.",
    "Lemma mxrank_map m n (A : 'M_(m, n)) : \\rank A^f = \\rank A.\nProof. by rewrite mxrankE Gaussian_elimination_map. Qed.",
    "Lemma row_free_map m n (A : 'M_(m, n)) : row_free A^f = row_free A.\nProof. by rewrite /row_free mxrank_map. Qed.",
    "Lemma row_full_map m n (A : 'M_(m, n)) : row_full A^f = row_full A.\nProof. by rewrite /row_full mxrank_map. Qed.",
    "Lemma map_row_ebase m n (A : 'M_(m, n)) : (row_ebase A)^f = row_ebase A^f.\nProof. by rewrite {2}/row_ebase unlock Gaussian_elimination_map. Qed.",
    "Lemma map_col_ebase m n (A : 'M_(m, n)) : (col_ebase A)^f = col_ebase A^f.\nProof. by rewrite {2}/col_ebase unlock Gaussian_elimination_map. Qed.",
    "Lemma map_row_base m n (A : 'M_(m, n)) :\n  (row_base A)^f = castmx (mxrank_map A, erefl n) (row_base A^f).\nProof.\nmove: (mxrank_map A); rewrite {2}/row_base mxrank_map => eqrr.\nby rewrite castmx_id map_mxM map_pid_mx map_row_ebase.\nQed.",
    "Lemma map_col_base m n (A : 'M_(m, n)) :\n  (col_base A)^f = castmx (erefl m, mxrank_map A) (col_base A^f).\nProof.\nmove: (mxrank_map A); rewrite {2}/col_base mxrank_map => eqrr.\nby rewrite castmx_id map_mxM map_pid_mx map_col_ebase.\nQed.",
    "Lemma map_pinvmx m n (A : 'M_(m, n)) : (pinvmx A)^f = pinvmx A^f.\nProof.\nrewrite !map_mxM !map_invmx map_row_ebase map_col_ebase.\nby rewrite map_pid_mx -mxrank_map.\nQed.",
    "Lemma map_kermx m n (A : 'M_(m, n)) : (kermx A)^f = kermx A^f.\nProof.\nby rewrite !map_mxM map_invmx map_col_ebase -mxrank_map map_copid_mx.\nQed.",
    "Lemma map_cokermx m n (A : 'M_(m, n)) : (cokermx A)^f = cokermx A^f.\nProof.\nby rewrite !map_mxM map_invmx map_row_ebase -mxrank_map map_copid_mx.\nQed.",
    "Lemma map_submx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A^f <= B^f)%MS = (A <= B)%MS.\nProof. by rewrite !submxE -map_cokermx -map_mxM map_mx_eq0. Qed.",
    "Lemma map_ltmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A^f < B^f)%MS = (A < B)%MS.\nProof. by rewrite /ltmx !map_submx. Qed.",
    "Lemma map_eqmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A^f :=: B^f)%MS <-> (A :=: B)%MS.\nProof.\nsplit=> [/eqmxP|eqAB]; first by rewrite !map_submx => /eqmxP.\nby apply/eqmxP; rewrite !map_submx !eqAB !submx_refl.\nQed.",
    "Lemma map_genmx m n (A : 'M_(m, n)) : (<<A>>^f :=: <<A^f>>)%MS.\nProof. by apply/eqmxP; rewrite !(genmxE, map_submx) andbb. Qed.",
    "Lemma map_addsmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (((A + B)%MS)^f :=: A^f + B^f)%MS.\nProof.\nby apply/eqmxP; rewrite !addsmxE -map_col_mx !map_submx !addsmxE andbb.\nQed.",
    "Lemma map_capmx_gen m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (capmx_gen A B)^f = capmx_gen A^f B^f.\nProof. by rewrite map_mxM map_lsubmx map_kermx map_col_mx. Qed.",
    "Lemma map_capmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  ((A :&: B)^f :=: A^f :&: B^f)%MS.\nProof.\nby apply/eqmxP; rewrite !capmxE -map_capmx_gen !map_submx -!capmxE andbb.\nQed.",
    "Lemma map_complmx m n (A : 'M_(m, n)) : (A^C^f = A^f^C)%MS.\nProof. by rewrite map_mxM map_row_ebase -mxrank_map map_copid_mx. Qed.",
    "Lemma map_diffmx m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  ((A :\\: B)^f :=: A^f :\\: B^f)%MS.\nProof.\napply/eqmxP; rewrite !diffmxE -map_capmx_gen -map_complmx.\nby rewrite -!map_capmx !map_submx -!diffmxE andbb.\nQed.",
    "Lemma map_eigenspace n (g : 'M_n) a : (eigenspace g a)^f = eigenspace g^f (f a).\nProof. by rewrite map_kermx map_mxB ?map_scalar_mx. Qed.",
    "Lemma eigenvalue_map n (g : 'M_n) a : eigenvalue g^f (f a) = eigenvalue g a.\nProof. by rewrite /eigenvalue -map_eigenspace map_mx_eq0. Qed.",
    "Lemma memmx_map m n A (E : 'A_(m, n)) : (A^f \\in E^f)%MS = (A \\in E)%MS.\nProof. by rewrite -map_mxvec map_submx. Qed.",
    "Lemma map_mulsmx m1 m2 n (E1 : 'A_(m1, n)) (E2 : 'A_(m2, n)) :\n  ((E1 * E2)%MS^f :=: E1^f * E2^f)%MS.\nProof.\nrewrite /mulsmx; elim/big_rec2: _ => [|i A Af _ eqA]; first by rewrite map_mx0.\napply: (eqmx_trans (map_addsmx _ _)); apply: adds_eqmx {A Af}eqA.\napply/eqmxP; rewrite !map_genmx !genmxE map_mxM.\napply/rV_eqP=> u; congr (u <= _ *m _)%MS.\nby apply: map_lin_mx => //= A; rewrite map_mxM // map_vec_mx map_row.\nQed.",
    "Lemma map_cent_mx m n (E : 'A_(m, n)) : ('C(E)%MS)^f = 'C(E^f)%MS.\nProof.\nrewrite map_kermx; congr kermx; apply: map_lin_mx => A; rewrite map_mxM.\nby congr (_ *m _); apply: map_lin_mx => B; rewrite map_mxB ?map_mxM.\nQed.",
    "Lemma map_center_mx m n (E : 'A_(m, n)) : (('Z(E))^f :=: 'Z(E^f))%MS.\nProof. by rewrite /center_mx -map_cent_mx; apply: map_capmx. Qed.",
    "Lemma eqmx_col {m} (V_ : forall i, 'M[F]_(p_ i, m)) :\n  (\\mxcol_i V_ i :=: \\sum_i <<V_ i>>)%MS.\nProof.\napply/eqmxP/andP; split.\n  apply/row_subP => i; rewrite row_mxcol.\n  by rewrite (sumsmx_sup (sig1 i))// genmxE row_sub.\napply/sumsmx_subP => i0 _; rewrite genmxE; apply/row_subP => j.\napply: (eq_row_sub (Rank _ j)); apply/rowP => k.\nby rewrite !mxE Rank2K; case: _ / esym; rewrite cast_ord_id.\nQed.",
    "Lemma rank_mxdiag (V_ : forall i, 'M[F]_(p_ i)) :\n  (\\rank (\\mxdiag_i V_ i) = \\sum_i \\rank (V_ i))%N.\nProof.\nelim: {+}n {+}p_ V_ => [|m IHm] q_ V_.\n  by move: (\\mxdiag__ _); rewrite !big_ord0 => M; rewrite flatmx0 mxrank0.\nrewrite mxdiag_recl [RHS]big_ord_recl/= -IHm.\nby case: _ / mxsize_recl; rewrite ?castmx_id rank_diag_block_mx.\nQed.",
    "Lemma itv_bound_can :\n  cancel (fun b : itv_bound T =>\n            match b with BSide b x => (b, Some x) | BInfty b => (b, None) end)\n         (fun b =>\n            match b with (b, Some x) => BSide b x | (b, None) => BInfty _ b end).\nProof. by case. Qed.",
    "Lemma interval_can :\n  @cancel _ (interval T)\n    (fun '(Interval b1 b2) => (b1, b2)) (fun '(b1, b2) => Interval b1 b2).\nProof. by case. Qed.",
    "Lemma lt_bound_def b1 b2 : lt_bound b1 b2 = (b2 != b1) && le_bound b1 b2.\nProof. by case: b1 b2 => [[]?|[]][[]?|[]] //=; rewrite lt_def. Qed.",
    "Lemma le_bound_refl : reflexive le_bound.\nProof. by move=> [[]?|[]] /=. Qed.",
    "Lemma le_bound_anti : antisymmetric le_bound.\nProof. by case=> [[]?|[]] [[]?|[]] //=; case: comparableP => // ->. Qed.",
    "Lemma le_bound_trans : transitive le_bound.\nProof.\nby case=> [[]?|[]] [[]?|[]] [[]?|[]] lexy leyz //;\n  apply: (lteif_imply _ (lteif_trans lexy leyz)).\nQed.",
    "Lemma bound_lexx c1 c2 x : (BSide c1 x <= BSide c2 x) = (c2 ==> c1).\nProof. by rewrite /<=%O /= lteifxx. Qed.",
    "Lemma bound_ltxx c1 c2 x : (BSide c1 x < BSide c2 x) = (c1 && ~~ c2).\nProof. by rewrite /<%O /= lteifxx. Qed.",
    "Lemma ge_pinfty b : (+oo <= b) = (b == +oo). Proof. by case: b => [|] []. Qed.",
    "Lemma le_ninfty b : (b <= -oo) = (b == -oo). Proof. by case: b => // - []. Qed.",
    "Lemma gt_pinfty b : (+oo < b) = false. Proof. by []. Qed.",
    "Lemma lt_ninfty b : (b < -oo) = false. Proof. by case: b => // -[]. Qed.",
    "Lemma ltBSide x y (b b' : bool) :\n  BSide b x < BSide b' y = (x < y ?<= if b && ~~ b').\nProof. by []. Qed.",
    "Lemma leBSide x y (b b' : bool) :\n  BSide b x <= BSide b' y = (x < y ?<= if b' ==> b).\nProof. by []. Qed.",
    "Lemma ltBRight_leBLeft b x : b < BRight x = (b <= BLeft x).\nProof. by move: b => [[] b|[]]. Qed.",
    "Lemma leBRight_ltBLeft b x : BRight x <= b = (BLeft x < b).\nProof. by move: b => [[] b|[]]. Qed.",
    "Lemma comparable_BSide_min s (x y : T) : (x >=< y)%O ->\n  BSide s (Order.min x y) = Order.min (BSide s x) (BSide s y).\nProof. by rewrite !minEle bnd_simp => /comparable_leP[]. Qed.",
    "Lemma comparable_BSide_max s (x y : T) : (x >=< y)%O ->\n  BSide s (Order.max x y) = Order.max (BSide s x) (BSide s y).\nProof. by rewrite !maxEle bnd_simp => /comparable_leP[]. Qed.",
    "Lemma subitv_refl : reflexive subitv.\nProof. by case=> /= ? ?; rewrite !lexx. Qed.",
    "Lemma subitv_anti : antisymmetric subitv.\nProof.\nby case=> [? ?][? ?]; rewrite andbACA => /andP[] /le_anti -> /le_anti ->.\nQed.",
    "Lemma subitv_trans : transitive subitv.\nProof.\ncase=> [yl yr][xl xr][zl zr] /andP [Hl Hr] /andP [Hl' Hr'] /=.\nby rewrite (le_trans Hl' Hl) (le_trans Hr Hr').\nQed.",
    "Lemma subitvE b1l b1r b2l b2r :\n  (Interval b1l b1r <= Interval b2l b2r) = (b2l <= b1l) && (b1r <= b2r).\nProof. by []. Qed.",
    "Lemma in_itv x i :\n  x \\in i =\n  let: Interval l u := i in\n  match l with\n    | BSide b lb => lb < x ?<= if b\n    | BInfty b => b\n  end &&\n  match u with\n    | BSide b ub => x < ub ?<= if ~~ b\n    | BInfty b => ~~ b\n  end.\nProof. by case: i => [[? ?|[]][|[]]]. Qed.",
    "Lemma itv_boundlr bl br x :\n  (x \\in Interval bl br) = (bl <= BLeft x) && (BRight x <= br).\nProof. by []. Qed.",
    "Lemma itv_splitI bl br x :\n  x \\in Interval bl br = (x \\in Interval bl +oo) && (x \\in Interval -oo br).\nProof. by rewrite !itv_boundlr andbT. Qed.",
    "Lemma subitvP i1 i2 : i1 <= i2 -> {subset i1 <= i2}.\nProof. by move=> ? ? /le_trans; exact. Qed.",
    "Lemma subset_itv (x y z u : itv_bound T) : x <= y -> z <= u ->\n  {subset Interval y z <= Interval x u}.\nProof. by move=> xy zu; apply: subitvP; rewrite subitvE xy zu. Qed.",
    "Lemma subset_itv_bound (r s u v : bool) x y : r <= u -> v <= s ->\n  {subset Interval (BSide r x) (BSide s y) <= Interval (BSide u x) (BSide v y)}.\nProof.\nby move: r s u v=> [] [] [] []// *; apply: subset_itv; rewrite bnd_simp.\nQed.",
    "Lemma subset_itv_oo_cc x y : {subset `]x, y[ <= `[x, y]}.\nProof. by apply: subset_itv; rewrite bnd_simp. Qed.",
    "Lemma subset_itv_oo_oc x y : {subset `]x, y[ <= `]x, y]}.\nProof. by apply: subset_itv; rewrite bnd_simp. Qed.",
    "Lemma subset_itv_oo_co x y : {subset `]x, y[ <= `[x, y[}.\nProof. by apply: subset_itv; rewrite bnd_simp. Qed.",
    "Lemma subset_itv_oc_cc x y : {subset `]x, y] <= `[x, y]}.\nProof. by apply: subset_itv; rewrite bnd_simp. Qed.",
    "Lemma subset_itv_co_cc x y : {subset `[x, y[ <= `[x, y]}.\nProof. by apply: subset_itv; rewrite bnd_simp. Qed.",
    "Lemma itvxx x : `[x, x] =i pred1 x.\nProof. by move=> y; rewrite in_itv/= -eq_le eq_sym. Qed.",
    "Lemma itvxxP y x : reflect (y = x) (y \\in `[x, x]).\nProof. by rewrite itvxx; apply/eqP. Qed.",
    "Lemma subitvPl b1l b2l br :\n  b2l <= b1l -> {subset Interval b1l br <= Interval b2l br}.\nProof. by move=> ?; apply: subitvP; rewrite subitvE lexx andbT. Qed.",
    "Lemma subitvPr bl b1r b2r :\n  b1r <= b2r -> {subset Interval bl b1r <= Interval bl b2r}.\nProof. by move=> ?; apply: subitvP; rewrite subitvE lexx. Qed.",
    "Lemma itv_xx x cl cr y :\n  y \\in Interval (BSide cl x) (BSide cr x) = cl && ~~ cr && (y == x).\nProof. by case: cl cr => [] []; rewrite [LHS]lteif_anti // eq_sym. Qed.",
    "Lemma boundl_in_itv c x b : x \\in Interval (BSide c x) b = c && (BRight x <= b).\nProof. by rewrite itv_boundlr bound_lexx. Qed.",
    "Lemma boundr_in_itv c x b :\n  x \\in Interval b (BSide c x) = ~~ c && (b <= BLeft x).\nProof. by rewrite itv_boundlr bound_lexx implybF andbC. Qed.",
    "Lemma lt_in_itv bl br x : x \\in Interval bl br -> bl < br.\nProof. by case/andP; apply/le_lt_trans. Qed.",
    "Lemma lteif_in_itv cl cr yl yr x :\n  x \\in Interval (BSide cl yl) (BSide cr yr) -> yl < yr ?<= if cl && ~~ cr.\nProof. exact: lt_in_itv. Qed.",
    "Lemma itv_ge b1 b2 : ~~ (b1 < b2) -> Interval b1 b2 =i pred0.\nProof. by move=> ltb12 y; apply/contraNF: ltb12; apply/lt_in_itv. Qed.",
    "Lemma itv_dec : forall x i, reflect (itv_decompose i x) (x \\in i).\nProof. by move=> ? [[? ?|[]][? ?|[]]]; apply: (iffP andP); case. Qed.",
    "Lemma itvP x i : x \\in i -> itv_rewrite i x.\nProof.\ncase: i => [[[]a|[]][[]b|[]]] /andP [] ha hb; rewrite /= ?bound_in_itv;\n  do ![split | apply/negbTE; rewrite (le_gtF, lt_geF)];\n  by [|apply: ltW | move: (lteif_trans ha hb) => //=; exact: ltW].\nQed.",
    "Lemma itv_splitU1 b x : b <= BLeft x ->\n  Interval b (BRight x) =i [predU1 x & Interval b (BLeft x)].\nProof.\nmove=> bx z; rewrite !inE/= !subitvE ?bnd_simp//= lt_neqAle.\nby case: (eqVneq z x) => [->|]//=; rewrite lexx bx.\nQed.",
    "Lemma itv_split1U b x : BRight x <= b ->\n  Interval (BLeft x) b =i [predU1 x & Interval (BRight x) b].\nProof.\nmove=> bx z; rewrite !inE/= !subitvE ?bnd_simp//= lt_neqAle.\nby case: (eqVneq z x) => [->|]//=; rewrite lexx bx.\nQed.",
    "Lemma bound_meetC : commutative bound_meet.\nProof.\ncase=> [? ?|[]][? ?|[]] //=; rewrite meetC; congr BSide.\nby case: lcomparableP; rewrite ?orbF // orbC.\nQed.",
    "Lemma bound_joinC : commutative bound_join.\nProof.\ncase=> [? ?|[]][? ?|[]] //=; rewrite joinC; congr BSide.\nby case: lcomparableP; rewrite ?andbT // andbC.\nQed.",
    "Lemma bound_meetA : associative bound_meet.\nProof.\ncase=> [? x|[]][? y|[]][? z|[]] //=; rewrite !lexI meetA; congr BSide.\nby case: (lcomparableP x y) => [|||->]; case: (lcomparableP y z) => [|||->];\n  case: (lcomparableP x z) => [|||//<-]; case: (lcomparableP x y);\n  rewrite //= ?andbF ?orbF ?lexx ?orbA //; case: (lcomparableP y z).\nQed.",
    "Lemma bound_joinA : associative bound_join.\nProof.\ncase=> [? x|[]][? y|[]][? z|[]] //=; rewrite !leUx joinA; congr BSide.\nby case: (lcomparableP x y) => [|||->]; case: (lcomparableP y z) => [|||->];\n  case: (lcomparableP x z) => [|||//<-]; case: (lcomparableP x y);\n  rewrite //= ?orbT ?andbT ?lexx ?andbA //; case: (lcomparableP y z).\nQed.",
    "Lemma bound_meetKU b2 b1 : bound_join b1 (bound_meet b1 b2) = b1.\nProof.\ncase: b1 b2 => [? ?|[]][? ?|[]] //=;\n  rewrite ?meetKU ?joinxx ?leIl ?lexI ?lexx ?andbb //=; congr BSide.\nby case: lcomparableP; rewrite ?orbF /= ?andbb ?orbK.\nQed.",
    "Lemma bound_joinKI b2 b1 : bound_meet b1 (bound_join b1 b2) = b1.\nProof.\ncase: b1 b2 => [? ?|[]][? ?|[]] //=;\n  rewrite ?joinKI ?meetxx ?leUl ?leUx ?lexx ?orbb //=; congr BSide.\nby case: lcomparableP; rewrite ?orbF ?orbb ?andKb.\nQed.",
    "Lemma bound_leEmeet b1 b2 : (b1 <= b2) = (bound_meet b1 b2 == b1).\nProof.\ncase: b1 b2 => [[]t[][]|[][][]] //=; rewrite ?eqxx// => t';\n  rewrite [LHS]/<=%O /eq_op ?andbT ?andbF ?orbF/= /eq_op/= /eq_op/=;\n  case: lcomparableP => //=; rewrite ?eqxx//=; [| | |].\n- by move/lt_eqF.\n- move=> ic; apply: esym; apply: contraNF ic.\n  by move=> /eqP/meet_idPl; apply: le_comparable.\n- by move/lt_eqF.\n- move=> ic; apply: esym; apply: contraNF ic.\n  by move=> /eqP/meet_idPl; apply: le_comparable.\nQed.",
    "Lemma bound_le0x b : -oo <= b. Proof. by []. Qed.",
    "Lemma bound_lex1 b : b <= +oo. Proof. by case: b => [|[]]. Qed.",
    "Lemma itv_meetC : commutative itv_meet.\nProof. by case=> [? ?][? ?] /=; rewrite meetC joinC. Qed.",
    "Lemma itv_joinC : commutative itv_join.\nProof. by case=> [? ?][? ?] /=; rewrite meetC joinC. Qed.",
    "Lemma itv_meetA : associative itv_meet.\nProof. by case=> [? ?][? ?][? ?] /=; rewrite meetA joinA. Qed.",
    "Lemma itv_joinA : associative itv_join.\nProof. by case=> [? ?][? ?][? ?] /=; rewrite meetA joinA. Qed.",
    "Lemma itv_meetKU i2 i1 : itv_join i1 (itv_meet i1 i2) = i1.\nProof. by case: i1 i2 => [? ?][? ?] /=; rewrite meetKU joinKI. Qed.",
    "Lemma itv_joinKI i2 i1 : itv_meet i1 (itv_join i1 i2) = i1.\nProof. by case: i1 i2 => [? ?][? ?] /=; rewrite meetKU joinKI. Qed.",
    "Lemma itv_leEmeet i1 i2 : (i1 <= i2) = (itv_meet i1 i2 == i1).\nProof.\nby case: i1 i2 => [? ?] [? ?]; rewrite /eq_op/=/eq_op/= eq_meetl eq_joinl.\nQed.",
    "Lemma itv_le0x i : Interval +oo -oo <= i. Proof. by case: i => [[|[]]]. Qed.",
    "Lemma itv_lex1 i : i <= `]-oo, +oo[. Proof. by case: i => [?[|[]]]. Qed.",
    "Lemma in_itvI x i1 i2 : x \\in i1 `&` i2 = (x \\in i1) && (x \\in i2).\nProof. exact: lexI. Qed.",
    "Lemma BSide_min s (x y : T) :\n  BSide s (Order.min x y) = Order.min (BSide s x) (BSide s y).\nProof. exact: comparable_BSide_min. Qed.",
    "Lemma BSide_max s (x y : T) :\n  BSide s (Order.max x y) = Order.max (BSide s x) (BSide s y).\nProof. exact: comparable_BSide_max. Qed.",
    "Lemma itv_bound_total : total (<=%O : rel (itv_bound T)).\nProof. by move=> [[]?|[]][[]?|[]]; rewrite /<=%O //=; case: ltgtP. Qed.",
    "Lemma itv_meetUl : @left_distributive (interval T) _ Order.meet Order.join.\nProof.\nby move=> [? ?][? ?][? ?]; rewrite /Order.meet /Order.join /= -meetUl -joinIl.\nQed.",
    "Lemma itv_splitU c a b : a <= c <= b ->\n  forall y, y \\in Interval a b = (y \\in Interval a c) || (y \\in Interval c b).\nProof.\ncase/andP => leac lecb y.\nrewrite !itv_boundlr !(ltNge (BLeft y) _ : (BRight y <= _) = _).\ncase: (leP a) (leP b) (leP c) => leay [] leby [] lecy //=.\n- by case: leP lecy (le_trans lecb leby).\n- by case: leP leay (le_trans leac lecy).\nQed.",
    "Lemma itv_splitUeq x a b : x \\in Interval a b ->\n  forall y, y \\in Interval a b =\n    [|| y \\in Interval a (BLeft x), y == x | y \\in Interval (BRight x) b].\nProof.\ncase/andP => ax xb y; rewrite (@itv_splitU (BLeft x)) ?ax ?ltW //.\nby congr orb; rewrite (@itv_splitU (BRight x)) ?bound_lexx // itv_xx.\nQed.",
    "Lemma itv_total_meet3E i1 i2 i3 :\n  i1 `&` i2 `&` i3 \\in [:: i1 `&` i2; i1 `&` i3; i2 `&` i3].\nProof.\ncase: i1 i2 i3 => [b1l b1r] [b2l b2r] [b3l b3r]; rewrite !inE /eq_op /=.\ncase: (leP b1l b2l); case: (leP b1l b3l); case: (leP b2l b3l);\n  case: (leP b1r b2r); case: (leP b1r b3r); case: (leP b2r b3r);\n  rewrite ?eqxx ?orbT //= => b23r b13r b12r b23l b13l b12l.\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13r (lt_trans b23r b12r).\nQed.",
    "Lemma itv_total_join3E i1 i2 i3 :\n  i1 `|` i2 `|` i3 \\in [:: i1 `|` i2; i1 `|` i3; i2 `|` i3].\nProof.\ncase: i1 i2 i3 => [b1l b1r] [b2l b2r] [b3l b3r]; rewrite !inE /eq_op /=.\ncase: (leP b1l b2l); case: (leP b1l b3l); case: (leP b2l b3l);\n  case: (leP b1r b2r); case: (leP b1r b3r); case: (leP b2r b3r);\n  rewrite ?eqxx ?orbT //= => b23r b13r b12r b23l b13l b12l.\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\nQed.",
    "Lemma predC_itvl a : [predC Interval -oo a] =i Interval a +oo.\nProof.\ncase: a => [b x|[]//] y.\nby rewrite !inE !subitvE/= bnd_simp andbT !lteBSide/= lteifNE negbK.\nQed.",
    "Lemma predC_itvr a : [predC Interval a +oo] =i Interval -oo a.\nProof. by move=> y; rewrite inE/= -predC_itvl negbK. Qed.",
    "Lemma predC_itv i : [predC i] =i [predU Interval -oo i.1 & Interval i.2 +oo].\nProof.\ncase: i => [a a']; move=> x; rewrite inE/= itv_splitI negb_and.\nby symmetry; rewrite inE/= -predC_itvl -predC_itvr.\nQed.",
    "Lemma real_BSide_min b x y : x \\in Num.real -> y \\in Num.real ->\n  BSide b (Order.min x y) = Order.min (BSide b x) (BSide b y).\nProof. by move=> xr yr; apply/comparable_BSide_min/real_comparable. Qed.",
    "Lemma real_BSide_max b x y : x \\in Num.real -> y \\in Num.real ->\n  BSide b (Order.max x y) = Order.max (BSide b x) (BSide b y).\nProof. by move=> xr yr; apply/comparable_BSide_max/real_comparable. Qed.",
    "Lemma mem0_itvcc_xNx x : (0 \\in `[- x, x]) = (0 <= x).\nProof. by rewrite itv_boundlr [in LHS]/<=%O /= oppr_le0 andbb. Qed.",
    "Lemma mem0_itvoo_xNx x : 0 \\in `](- x), x[ = (0 < x).\nProof. by rewrite itv_boundlr [in LHS]/<=%O /= oppr_lt0 andbb. Qed.",
    "Lemma oppr_itv ba bb (xa xb x : R) :\n  (- x \\in Interval (BSide ba xa) (BSide bb xb)) =\n  (x \\in Interval (BSide (~~ bb) (- xb)) (BSide (~~ ba) (- xa))).\nProof.\nby rewrite !itv_boundlr /<=%O /= !implybF negbK andbC lteifNl lteifNr.\nQed.",
    "Lemma oppr_itvoo (a b x : R) : (- x \\in `]a, b[) = (x \\in `](- b), (- a)[).\nProof. exact: oppr_itv. Qed.",
    "Lemma oppr_itvco (a b x : R) : (- x \\in `[a, b[) = (x \\in `](- b), (- a)]).\nProof. exact: oppr_itv. Qed.",
    "Lemma oppr_itvoc (a b x : R) : (- x \\in `]a, b]) = (x \\in `[(- b), (- a)[).\nProof. exact: oppr_itv. Qed.",
    "Lemma oppr_itvcc (a b x : R) : (- x \\in `[a, b]) = (x \\in `[(- b), (- a)]).\nProof. exact: oppr_itv. Qed.",
    "Lemma mid_in_itv : forall ba bb (xa xb : R), xa < xb ?<= if ba && ~~ bb ->\n  mid xa xb \\in Interval (BSide ba xa) (BSide bb xb).\nProof.\nby move=> [] [] xa xb /= ?; apply/itv_dec; rewrite /= ?midf_lte // ?ltW.\nQed.",
    "Lemma mid_in_itvoo : forall (xa xb : R), xa < xb -> mid xa xb \\in `]xa, xb[.\nProof. by move=> xa xb ?; apply: mid_in_itv. Qed.",
    "Lemma mid_in_itvcc : forall (xa xb : R), xa <= xb -> mid xa xb \\in `[xa, xb].\nProof. by move=> xa xb ?; apply: mid_in_itv. Qed.",
    "Lemma mem_miditv i : (i.1 < i.2)%O -> miditv i \\in i.\nProof.\nmove: i => [[ba a|[]] [bb b|[]]] //= ab; first exact: mid_in_itv.\nby rewrite !in_itv -lteifBlDl subrr lteif01.\nby rewrite !in_itv lteifBlDr -lteifBlDl subrr lteif01.\nQed.",
    "Lemma miditv_le_left i b : (i.1 < i.2)%O -> (BSide b (miditv i) <= i.2)%O.\nProof.\ncase: i => [x y] lti; have := mem_miditv lti; rewrite inE => /andP[_ ].\nby apply: le_trans; rewrite !bnd_simp.\nQed.",
    "Lemma miditv_ge_right i b : (i.1 < i.2)%O -> (i.1 <= BSide b (miditv i))%O.\nProof.\ncase: i => [x y] lti; have := mem_miditv lti; rewrite inE => /andP[+ _].\nby move=> /le_trans; apply; rewrite !bnd_simp.\nQed.",
    "Lemma in_segmentDgt0Pr x y z :\n  reflect (forall e, e > 0 -> y \\in `[x - e, z + e]) (y \\in `[x, z]).\nProof.\napply/(iffP idP)=> [xyz e /[dup] e_gt0 /ltW e_ge0 | xyz_e].\n  by rewrite in_itv /= lerBDr !ler_wpDr// (itvP xyz).\nby rewrite in_itv /= ; apply/andP; split; apply/ler_addgt0Pr => ? /xyz_e;\n  rewrite in_itv /= lerBDr => /andP [].\nQed.",
    "Lemma in_segmentDgt0Pl x y z :\n  reflect (forall e, e > 0 -> y \\in `[(- e + x), (e + z)]) (y \\in `[x, z]).\nProof.\napply/(equivP (in_segmentDgt0Pr x y z)).\nby split=> zxy e /zxy; rewrite [z + _]addrC [_ + x]addrC.\nQed.",
    "Lemma denq_gt0 x : 0 < denq x.\nProof. by rewrite /denq; case: x=> [[a b] /= /andP []]. Qed.",
    "Lemma denq_lt0 x : (denq x < 0) = false. Proof. by rewrite lt_gtF. Qed.",
    "Lemma denq_neq0 x : denq x != 0.\nProof. by rewrite /denq gt_eqF ?denq_gt0. Qed.",
    "Lemma denq_eq0 x : (denq x == 0) = false.\nProof. exact: negPf (denq_neq0 _). Qed.",
    "Lemma coprime_num_den x : coprime `|numq x| `|denq x|.\nProof. by rewrite /numq /denq; case: x=> [[a b] /= /andP []]. Qed.",
    "Lemma fracq_opt_subdefE x : fracq_opt_subdef x = fracq_subdef x.\nProof.\nrewrite /fracq_opt_subdef; case: ifP => //; case: x => n d /= /andP[d_gt0 cnd].\nrewrite /fracq_subdef gt_eqF//= lt_gtF//= (eqP cnd) !divn1 abszEsg gtz0_abs//.\nrewrite mulrA sgz_def mulrnAr -signr_addb addbb expr0.\nby have [->|] := eqVneq n 0; rewrite (mulr0, mul1r).\nQed.",
    "Lemma fracq_opt_subdef_id x :\n  fracq_opt_subdef (fracq_opt_subdef x) = fracq_subdef x.\nProof.\nrewrite [fracq_opt_subdef (_ x)]/fracq_opt_subdef.\nby rewrite fracq_subproof fracq_opt_subdefE.\nQed.",
    "Lemma val_fracq x : val (fracq x) = fracq_subdef x.\nProof. by case: x => [[n|n] [[|[|d]]|d]]//=; rewrite !fracq_opt_subdef_id. Qed.",
    "Lemma num_fracq x : numq (fracq x) = if x.2 != 0 then\n  (-1) ^ ((x.2 < 0) (+) (x.1 < 0)) * (`|x.1| %/ gcdn `|x.1| `|x.2|)%:Z else 0.\nProof. by rewrite /numq val_fracq/=; case: ifP. Qed.",
    "Lemma den_fracq x : denq (fracq x) =\n  if x.2 != 0 then (`|x.2| %/ gcdn `|x.1| `|x.2|)%:Z else 1.\nProof. by rewrite /denq val_fracq/=; case: ifP. Qed.",
    "Lemma scalq_def x : scalq x = sgr x.2 * (gcdn `|x.1| `|x.2|)%:Z.\nProof. by case: x. Qed.",
    "Lemma sgr_scalq x : sgr (scalq x) = sgr x.2.\nProof.\nrewrite scalq_def sgrM sgr_id -[(gcdn _ _)%:Z]intz sgr_nat.\nby rewrite -lt0n gcdn_gt0 ?absz_gt0 orbC; case: sgrP; rewrite // mul0r.\nQed.",
    "Lemma signr_scalq x : (scalq x < 0) = (x.2 < 0).\nProof. by rewrite -!sgr_cp0 sgr_scalq. Qed.",
    "Lemma scalqE x :\n  x.2 != 0 -> scalq x = (-1) ^+ (x.2 < 0)%R * (gcdn `|x.1| `|x.2|)%:Z.\nProof. by rewrite scalq_def; case: sgrP. Qed.",
    "Lemma rat_eqE x y : (x == y) = (numq x == numq y) && (denq x == denq y).\nProof.\nrewrite -val_eqE [val x]surjective_pairing [val y]surjective_pairing /=.\nby rewrite xpair_eqE.\nQed.",
    "Lemma sgr_denq x : sgr (denq x) = 1. Proof. by apply/eqP; rewrite sgr_cp0. Qed.",
    "Lemma normr_denq x : `|denq x| = denq x. Proof. by rewrite gtr0_norm. Qed.",
    "Lemma absz_denq x : `|denq x|%N = denq x :> int.\nProof. by rewrite abszE normr_denq. Qed.",
    "Lemma rat_eq x y : (x == y) = (numq x * denq y == numq y * denq x).\nProof.\nsymmetry; rewrite rat_eqE andbC.\nhave [->|] /= := eqVneq (denq _); first by rewrite (inj_eq (mulIf _)).\napply: contraNF => /eqP hxy; rewrite -absz_denq -[eqbRHS]absz_denq.\nrewrite eqz_nat /= eqn_dvd.\nrewrite -(@Gauss_dvdr _ `|numq x|) 1?coprime_sym ?coprime_num_den // andbC.\nrewrite -(@Gauss_dvdr _ `|numq y|) 1?coprime_sym ?coprime_num_den //.\nby rewrite -!abszM hxy -{1}hxy !abszM !dvdn_mull ?dvdnn.\nQed.",
    "Lemma addq_def x y : addq x y = fracq (addq_subdef (valq x) (valq y)).\nProof. by case: x; case: y. Qed.",
    "Lemma addq_subdefE x y : addq_subdef x y = (x.1 * y.2 + y.1 * x.2, x.2 * y.2).\nProof.\ncase: x y => [x1 [[|[|x2]]|x2]] [y1 [[|[|y2]]|y2]]/=; rewrite ?Monoid.simpm//.\nby case: x1 y1 => [[|[|m]]|m] [[|[|n]]|n]; rewrite ?Monoid.simpm// -PoszD addn1.\nQed.",
    "Lemma mulq_def x y : mulq x y = fracq (mulq_subdef (valq x) (valq y)).\nProof. by case: x; case: y. Qed.",
    "Lemma mulq_subdefE x y : mulq_subdef x y = (x.1 * y.1, x.2 * y.2).\nProof.\nby case: x y => [x1 [[|[|x2]]|x2]] [y1 [[|[|y2]]|y2]]/=; rewrite ?Monoid.simpm.\nQed.",
    "Lemma invq_def x : invq x = fracq (invq_subdef (valq x)).\nProof. by case: x. Qed.",
    "Lemma numq_eq0 x : (numq x == 0) = (x == 0).\nProof.\nrewrite -[x]valqK fracq_eq0; case: fracqP=> /= [|k {}x k0].\n  by rewrite eqxx orbT.\nby rewrite !mulf_eq0 (negPf k0) /= denq_eq0 orbF.\nQed.",
    "Lemma ratzE n : ratz n = n%:Q.\nProof.\nelim: n=> [|n ihn|n ihn]; first by rewrite mulr0z ratz_frac.\n  by rewrite intS mulrzDr ratzD ihn.\nby rewrite intS opprD mulrzDr ratzD ihn.\nQed.",
    "Lemma numq_int n : numq n%:Q = n. Proof. by rewrite -ratzE. Qed.",
    "Lemma denq_int n : denq n%:Q = 1. Proof. by rewrite -ratzE. Qed.",
    "Lemma rat0 : 0%:Q = 0. Proof. by []. Qed.",
    "Lemma rat1 : 1%:Q = 1. Proof. by []. Qed.",
    "Lemma numqN x : numq (- x) = - numq x.\nProof.\nrewrite [- _]oppq_def/= num_fracq.\ncase: x => -[a b]; rewrite /numq/= => /andP[b_gt0].\nrewrite /coprime => /eqP cab.\nby rewrite lt_gtF ?gt_eqF // {2}abszN cab divn1 mulz_sign_abs.\nQed.",
    "Lemma denqN x : denq (- x) = denq x.\nProof.\nrewrite [- _]oppq_def den_fracq.\ncase: x => -[a b]; rewrite /denq/= => /andP[b_gt0].\nby rewrite /coprime=> /eqP cab; rewrite gt_eqF // abszN cab divn1 gtz0_abs.\nQed.",
    "Lemma fracqE x : fracq x = x.1%:Q / x.2%:Q.\nProof.\nmove: x => [m n] /=; apply/val_inj; rewrite val_fracq/=.\ncase: eqVneq => //= [->|n_neq0]; first by rewrite rat0 invr0 mulr0.\nrewrite -[m%:Q]valqK -[n%:Q]valqK.\nrewrite [_^-1]invq_frac ?denq_neq0 ?numq_eq0 ?intq_eq0//=.\nrewrite [X in valq X]mulq_frac val_fracq /invq_subdef !mulq_subdefE/=.\nby rewrite -!/(numq _) -!/(denq _) !numq_int !denq_int mul1r mulr1 n_neq0.\nQed.",
    "Lemma divq_num_den x : (numq x)%:Q / (denq x)%:Q = x.\nProof. by rewrite -{3}[x]valqK [valq _]surjective_pairing /= fracqE. Qed.",
    "Lemma divqP n d : divq_spec n d n d (n%:Q / d%:Q).\nProof.\nset x := (n, d); rewrite -[n]/x.1 -[d]/x.2 -fracqE.\nby case: fracqP => [_|k fx k_neq0] /=; constructor.\nQed.",
    "Lemma ratP x : rat_spec x (numq x) (denq x).\nProof.\nrewrite -{1}[x](divq_num_den); case hd: denq => [p|n].\n  have: 0 < p%:Z by rewrite -hd denq_gt0.\n  case: p hd=> //= n hd; constructor; rewrite -?hd ?divq_num_den //.\n  by rewrite -[n.+1]/`|n.+1|%N -hd coprime_num_den.\nby move: (denq_gt0 x); rewrite hd.\nQed.",
    "Lemma coprimeq_num n d : coprime `|n| `|d| -> numq (n%:~R / d%:~R) = sgr d * n.\nProof.\nmove=> cnd /=; have <- := fracqE (n, d).\nrewrite num_fracq/= (eqP (cnd : _ == 1)) divn1.\nhave [|d_gt0|d_lt0] := sgrP d;\nby rewrite (mul0r, mul1r, mulN1r) //= ?[_ ^ _]signrN ?mulNr mulz_sign_abs.\nQed.",
    "Lemma coprimeq_den n d :\n  coprime `|n| `|d| -> denq (n%:~R / d%:~R) = (if d == 0 then 1 else `|d|).\nProof.\nmove=> cnd; have <- := fracqE (n, d).\nby rewrite den_fracq/= (eqP (cnd : _ == 1)) divn1; case: d {cnd}; case.\nQed.",
    "Lemma denqVz (i : int) : i != 0 -> denq (i%:~R^-1) = `|i|.\nProof.\nmove=> h; rewrite -div1r -[1]/(1%:~R).\nby rewrite coprimeq_den /= ?coprime1n // (negPf h).\nQed.",
    "Lemma numqE x : (numq x)%:~R = x * (denq x)%:~R.\nProof. by rewrite -{2}[x]divq_num_den divfK // intq_eq0 denq_eq0. Qed.",
    "Lemma denqP x : {d | denq x = d.+1}.\nProof. by rewrite /denq; case: x => [[_ [[|d]|]] //= _]; exists d. Qed.",
    "Lemma normqE x : normq x = `|numq x|%:~R / (denq x)%:~R.\nProof. by case: x. Qed.",
    "Lemma le_ratE x y : le_rat x y = (numq x * denq y <= numq y * denq x).\nProof. by case: x; case: y. Qed.",
    "Lemma lt_ratE x y : lt_rat x y = (numq x * denq y < numq y * denq x).\nProof. by case: x; case: y. Qed.",
    "Lemma gt_rat0 x : lt_rat 0 x = (0 < numq x).\nProof. by rewrite lt_ratE mul0r mulr1. Qed.",
    "Lemma lt_rat0 x : lt_rat x 0 = (numq x < 0).\nProof. by rewrite lt_ratE mul0r mulr1. Qed.",
    "Lemma ge_rat0 x : le_rat 0 x = (0 <= numq x).\nProof. by rewrite le_ratE mul0r mulr1. Qed.",
    "Lemma le_rat0 x : le_rat x 0 = (numq x <= 0).\nProof. by rewrite le_ratE mul0r mulr1. Qed.",
    "Lemma sgr_numq_div (n d : int) : sgr (numq (n%:Q / d%:Q)) = sgr n * sgr d.\nProof.\nset x := (n, d); rewrite -[n]/x.1 -[d]/x.2 -fracqE.\ncase: fracqP => [|k fx k_neq0] /=; first by rewrite mulr0.\nby rewrite !sgrM  mulrACA -expr2 sqr_sg k_neq0 sgr_denq mulr1 mul1r.\nQed.",
    "Lemma normr_num_div n d : `|numq (n%:~R / d%:~R)| = numq (`|n|%:~R / `|d|%:~R).\nProof.\nrewrite (normrEsg n) (normrEsg d) !rmorphM /= invfM mulrACA !sgr_def.\nhave [->|n_neq0] := eqVneq; first by rewrite mul0r mulr0.\nhave [->|d_neq0] := eqVneq; first by rewrite invr0 !mulr0.\nrewrite !intr_sign invr_sign -signr_addb numq_sign_mul -numq_div_lt0 //.\nby apply: (canRL (signrMK _)); rewrite mulz_sign_abs.\nQed.",
    "Lemma numq_ge0 x : (0 <= numq x) = (0 <= x).\nProof.\nby case: ratP => n d cnd; rewrite ?pmulr_lge0 ?invr_gt0 (ler0z, ltr0z).\nQed.",
    "Lemma numq_le0 x : (numq x <= 0) = (x <= 0).\nProof. by rewrite -oppr_ge0 -numqN numq_ge0 oppr_ge0. Qed.",
    "Lemma numq_gt0 x : (0 < numq x) = (0 < x).\nProof. by rewrite !ltNge numq_le0. Qed.",
    "Lemma numq_lt0 x : (numq x < 0) = (x < 0).\nProof. by rewrite !ltNge numq_ge0. Qed.",
    "Lemma sgr_numq x : sgz (numq x) = sgz x.\nProof.\napply/eqP; case: (sgzP x); rewrite sgz_cp0 ?(numq_gt0, numq_lt0) //.\nby move->.\nQed.",
    "Lemma denq_mulr_sign (b : bool) x : denq ((-1) ^+ b * x) = denq x.\nProof. by case: b; rewrite ?(mul1r, mulN1r) // denqN. Qed.",
    "Lemma denq_norm x : denq `|x| = denq x.\nProof. by rewrite normrEsign denq_mulr_sign. Qed.",
    "Lemma floorErat (x : rat) : Num.floor x = (numq x %/ denq x)%Z.\nProof. by []. Qed.",
    "Lemma ceilErat (x : rat) : Num.ceil x = - (- numq x %/ denq x)%Z.\nProof. by []. Qed.",
    "Lemma Qint_def (x : rat) : (x \\is a Num.int) = (denq x == 1). Proof. by []. Qed.",
    "Lemma numqK : {in Num.int, cancel (fun x => numq x) intr}.\nProof. by move=> _ /intrP [x ->]; rewrite numq_int. Qed.",
    "Lemma natq_div m n : (n %| m)%N -> (m %/ n)%:R = m%:R / n%:R :> rat.\nProof. exact/pchar0_natf_div/pchar_num. Qed.",
    "Lemma ratr_int z : ratr z%:~R = z%:~R.\nProof. by rewrite /ratr numq_int denq_int divr1. Qed.",
    "Lemma ratr_nat n : ratr n%:R = n%:R.\nProof. exact: ratr_int n. Qed.",
    "Lemma rpred_rat (S : divringClosed R) a : ratr a \\in S.\nProof. by rewrite rpred_div ?rpred_int. Qed.",
    "Lemma fmorph_rat (aR : fieldType) rR (f : {rmorphism aR -> rR}) a :\n  f (ratr _ a) = ratr _ a.\nProof. by rewrite fmorph_div !rmorph_int. Qed.",
    "Lemma fmorph_eq_rat rR (f : {rmorphism rat -> rR}) : f =1 ratr _.\nProof. by move=> a; rewrite -{1}[a]divq_num_den fmorph_div !rmorph_int. Qed.",
    "Lemma rat_linear U V (f : U -> V) : additive f -> scalable f.\nProof.\nmove=> fB a u.\npose aM := GRing.isAdditive.Build U V f fB.\npose phi : {additive U -> V} := HB.pack f aM.\nrewrite -[f]/(phi : _ -> _) -{2}[a]divq_num_den mulrC -scalerA.\napply: canRL (scalerK _) _; first by rewrite intr_eq0 denq_neq0.\nrewrite 2!scaler_int -3!raddfMz /=.\nby rewrite -scalerMzr scalerMzl -mulrzr -numqE scaler_int.\nQed.",
    "Lemma ler_rat : {mono (@ratr F) : x y / x <= y}.\nProof.\nmove=> x y /=; case: (ratP x) => nx dx cndx; case: (ratP y) => ny dy cndy.\nrewrite !fmorph_div /= !ratr_int !ler_pdivlMr ?ltr0z //.\nby rewrite ![_ / _ * _]mulrAC !ler_pdivrMr ?ltr0z // -!rmorphM /= !ler_int.\nQed.",
    "Lemma ltr_rat : {mono (@ratr F) : x y / x < y}.\nProof. exact: leW_mono ler_rat. Qed.",
    "Lemma ler0q x : (0 <= ratr F x) = (0 <= x).\nProof. by rewrite (_ : 0 = ratr F 0) ?ler_rat ?rmorph0. Qed.",
    "Lemma lerq0 x : (ratr F x <= 0) = (x <= 0).\nProof. by rewrite (_ : 0 = ratr F 0) ?ler_rat ?rmorph0. Qed.",
    "Lemma ltr0q x : (0 < ratr F x) = (0 < x).\nProof. by rewrite (_ : 0 = ratr F 0) ?ltr_rat ?rmorph0. Qed.",
    "Lemma ltrq0 x : (ratr F x < 0) = (x < 0).\nProof. by rewrite (_ : 0 = ratr F 0) ?ltr_rat ?rmorph0. Qed.",
    "Lemma ratr_sg x : ratr F (sgr x) = sgr (ratr F x).\nProof. by rewrite !sgr_def fmorph_eq0 ltrq0 rmorphMn /= rmorph_sign. Qed.",
    "Lemma ratr_norm x : ratr F `|x| = `|ratr F x|.\nProof.\nby rewrite {2}[x]numEsign rmorphMsign normrMsign [`|ratr F _|]ger0_norm ?ler0q.\nQed.",
    "Lemma minr_rat : {morph ratr F : x y / Num.min x y}.\nProof. by move=> x y; rewrite !minEle ler_rat; case: leP. Qed.",
    "Lemma maxr_rat : {morph ratr F : x y / Num.max x y}.\nProof. by move=> x y; rewrite !maxEle ler_rat; case: leP. Qed.",
    "Lemma floor_rat : {mono (@ratr F) : x / Num.floor x}.\nProof.\nmove=> x; apply: floor_def; apply/andP; split.\n- by rewrite -ratr_int ler_rat floor_le_tmp.\n- by rewrite -ratr_int ltr_rat floorD1_gt.\nQed.",
    "Lemma ceil_rat : {mono (@ratr F) : x / Num.ceil x}.\nProof. by move=> x; rewrite !ceilNfloor -rmorphN floor_rat. Qed.",
    "Lemma Qint_dvdz (m d : int) : (d %| m)%Z -> (m%:~R / d%:~R : rat) \\is a Num.int.\nProof.\ncase/dvdzP=> z ->; rewrite rmorphM /=; have [->|dn0] := eqVneq d 0.\n  by rewrite mulr0 mul0r.\nby rewrite mulfK ?intr_eq0.\nQed.",
    "Lemma Qnat_dvd (m d : nat) : (d %| m)%N -> (m%:R / d%:R : rat) \\is a Num.nat.\nProof. by move=> h; rewrite natrEint divr_ge0 ?ler0n // !pmulrn Qint_dvdz. Qed.",
    "Lemma size_rat_int_poly p : size (pZtoQ p) = size p.\nProof. by apply: size_map_inj_poly; first apply: intr_inj. Qed.",
    "Lemma rat_poly_scale (p : {poly rat}) :\n  {q : {poly int} & {a | a != 0 & p = a%:~R^-1 *: pZtoQ q}}.\nProof.\npose a := \\prod_(i < size p) denq p`_i.\nhave nz_a: a != 0 by apply/prodf_neq0=> i _; apply: denq_neq0.\nexists (map_poly numq (a%:~R *: p)), a => //.\napply: canRL (scalerK _) _; rewrite ?intr_eq0 //.\napply/polyP=> i; rewrite !(coefZ, coef_map_id0) // numqK // Qint_def mulrC.\nhave [ltip | /(nth_default 0)->] := ltnP i (size p); last by rewrite mul0r.\nby rewrite [a](bigD1 (Ordinal ltip)) // rmorphM mulrA -numqE -rmorphM denq_int.\nQed.",
    "Lemma dvdp_rat_int p q : (pZtoQ p %| pZtoQ q) = (p %| q).\nProof.\napply/dvdpP/Pdiv.Idomain.dvdpP=> [[/= r1 Dq] | [[/= a r] nz_a Dq]]; last first.\n  exists (a%:~R^-1 *: pZtoQ r).\n  by rewrite -scalerAl -rmorphM -Dq /= linearZ/= scalerK ?intr_eq0.\nhave [r [a nz_a Dr1]] := rat_poly_scale r1; exists (a, r) => //=.\napply: (map_inj_poly _ _ : injective pZtoQ) => //; first exact: intr_inj.\nby rewrite linearZ /= Dq Dr1 -scalerAl -rmorphM scalerKV ?intr_eq0.\nQed.",
    "Lemma dvdpP_rat_int p q :\n    p %| pZtoQ q ->\n  {p1 : {poly int} & {a | a != 0 & p = a *: pZtoQ p1} & {r | q = p1 * r}}.\nProof.\nhave{p} [p [a nz_a ->]] := rat_poly_scale p.\nrewrite dvdpZl ?invr_eq0 ?intr_eq0 // dvdp_rat_int => dv_p_q.\nexists (zprimitive p); last exact: dvdpP_int.\nhave [-> | nz_p] := eqVneq p 0.\n  by exists 1; rewrite ?oner_eq0 // zprimitive0 map_poly0 !scaler0.\nexists ((zcontents p)%:~R / a%:~R).\n  by rewrite mulf_neq0 ?invr_eq0 ?intr_eq0 ?zcontents_eq0.\nby rewrite mulrC -scalerA -map_polyZ -zpolyEprim.\nQed.",
    "Lemma irreducible_rat_int p :\n  irreducible_poly (pZtoQ p) <-> irreducible_poly p.\nProof.\nrewrite /irreducible_poly size_rat_int_poly; split=> -[] p1 p_irr; split=> //.\n  move=> q q1; rewrite /eqp -!dvdp_rat_int => rq.\n  by apply/p_irr => //; rewrite size_rat_int_poly.\nmove=> q + /dvdpP_rat_int [] r [] c c0 qE [] s sE.\nrewrite qE size_scale// size_rat_int_poly => r1.\napply/(eqp_trans (eqp_scale _ c0)).\nrewrite /eqp !dvdp_rat_int; apply/p_irr => //.\nby rewrite sE dvdp_mulIl.\nQed.",
    "Lemma solve_Qint_span (vT : vectType rat) m (s : m.-tuple vT) v :\n  {b : int ^ m &\n  {p : seq (int ^ m) &\n  forall a : int ^ m,\n  v = \\sum_(i < m) s`_i *~ a i <->\n  exists c : seq int, a = b + \\sum_(i < size p) p`_i *~ c`_i}} +\n  (~ inIntSpan s v).\nProof.\nhave s_s (i : 'I_m): s`_i \\in <<s>>%VS by rewrite memv_span ?memt_nth.\nhave s_Zs a: \\sum_(i < m) s`_i *~ a i \\in <<s>>%VS.\n  by apply/rpred_sum => i _; apply/rpredMz.\ncase s_v: (v \\in <<s>>%VS); last by right=> [[a Dv]]; rewrite Dv s_Zs in s_v.\nmove SE : (\\matrix_(i < m, j < _) coord (vbasis <<s>>) j s`_i) => S.\nmove rE : (\\rank S) => r; move kE : (m - r)%N => k.\nhave Dm: (m = k + r)%N by rewrite -kE -rE subnK ?rank_leq_row.\nrewrite Dm in s s_s s_Zs s_v S SE rE kE *.\nmove=> {Dm m}; pose m := (k + r)%N.\nhave [K kerK]: {K : 'M_(k, m) | map_mx intr K == kermx S}%MS.\n  move: (mxrank_ker S); rewrite rE kE => krk.\n  pose B := row_base (kermx S); pose d := \\prod_ij denq (B ij.1 ij.2).\n  exists (castmx (krk, erefl m) (map_mx numq (intr d *: B))).\n  rewrite map_castmx !eqmx_cast -map_mx_comp map_mx_id_in => [|i j]; last first.\n    rewrite mxE mulrC [d](bigD1 (i, j)) //= rmorphM mulrA.\n    by rewrite -numqE -rmorphM numq_int.\n  suff nz_d: d%:Q != 0 by rewrite !eqmx_scale // !eq_row_base andbb.\n  by rewrite intr_eq0; apply/prodf_neq0 => i _; apply: denq_neq0.\nhave [L _ [G uG [D _ defK]]] := int_Smith_normal_form K.\nhave {K L D defK kerK} [kerGu kerS_sub_Gu]: map_mx intr (usubmx G) *m S = 0 /\\\n    (kermx S <= map_mx intr (usubmx G))%MS.\n  pose Kl : 'M[rat]_k := map_mx intr (lsubmx (K *m invmx G)).\n  have {}defK: map_mx intr K = Kl *m map_mx intr (usubmx G).\n    rewrite /Kl -map_mxM; congr map_mx.\n    rewrite -[LHS](mulmxKV uG) -{2}[G]vsubmxK -{1}[K *m _]hsubmxK.\n    rewrite mul_row_col -[RHS]addr0; congr (_ + _).\n    rewrite defK mulmxK //= -[RHS](mul0mx _ (dsubmx G)); congr (_ *m _).\n    apply/matrixP => i j; rewrite !mxE big1 //= => j1 _.\n    rewrite mxE /= eqn_leq andbC.\n    by rewrite leqNgt (leq_trans (valP j1)) ?mulr0 ?leq_addr.\n  split; last by rewrite -(eqmxP kerK); apply/submxP; exists Kl.\n  suff /row_full_inj: row_full Kl.\n    by apply; rewrite mulmx0 mulmxA (sub_kermxP _) // -(eqmxP kerK) defK.\n  rewrite /row_full eqn_leq rank_leq_row /= -{1}kE -{2}rE -(mxrank_ker S).\n  by rewrite -(eqmxP kerK) defK mxrankM_maxl.\npose T := map_mx intr (dsubmx G) *m S.\nhave defS: map_mx intr (rsubmx (invmx G)) *m T = S.\n  rewrite mulmxA -map_mxM /=; move: (mulVmx uG).\n  rewrite -{2}[G]vsubmxK -{1}[invmx G]hsubmxK mul_row_col.\n  move/(canRL (addKr _)) ->; rewrite -mulNmx raddfD /= map_mx1 map_mxM /=.\n  by rewrite mulmxDl -mulmxA kerGu mulmx0 add0r mul1mx.\npose vv := \\row_j coord (vbasis <<s>>) j v.\nhave uS: row_full S.\n  apply/row_fullP; exists (\\matrix_(i, j) coord s j (vbasis <<s>>)`_i).\n  apply/matrixP => j1 j2; rewrite !mxE.\n  rewrite -(coord_free _ _ (basis_free (vbasisP _))).\n  rewrite -!tnth_nth (coord_span (vbasis_mem (mem_tnth j1 _))) linear_sum.\n  by apply: eq_bigr => /= i _; rewrite -SE !mxE (tnth_nth 0) !linearZ.\nhave eqST: (S :=: T)%MS by apply/eqmxP; rewrite -{1}defS !submxMl.\ncase Zv: (map_mx denq (vv *m pinvmx T) == const_mx 1); last first.\n  right=> [[a Dv]]; case/eqP: Zv; apply/rowP.\n  have ->: vv = map_mx intr (\\row_i a i) *m S.\n    apply/rowP => j; rewrite !mxE Dv linear_sum.\n    by apply: eq_bigr => i _; rewrite -SE -scaler_int linearZ !mxE.\n  rewrite -defS -2!mulmxA; have ->: T *m pinvmx T = 1%:M.\n    have uT: row_free T by rewrite /row_free -eqST rE.\n    by apply: (row_free_inj uT); rewrite mul1mx mulmxKpV.\n  by move=> i; rewrite mulmx1 -map_mxM 2!mxE denq_int mxE.\npose b := map_mx numq (vv *m pinvmx T) *m dsubmx G.\nleft; exists [ffun j => b 0 j], [seq [ffun j => (usubmx G) i j] | i : 'I_k].\nrewrite size_image card_ord => a; rewrite -[a](addNKr [ffun j => b 0 j]).\nmove: (_ + a) => h; under eq_bigr => i _ do rewrite !ffunE mulrzDr.\nrewrite big_split /=.\nhave <-: v = \\sum_(i < m) s`_i *~ b 0 i.\n  transitivity (\\sum_j (map_mx intr b *m S) 0 j *: (vbasis <<s>>)`_j).\n    rewrite {1}(coord_vbasis s_v); apply: eq_bigr => j _; congr (_ *: _).\n    suff ->: map_mx intr b = vv *m pinvmx T *m map_mx intr (dsubmx G).\n      by rewrite -(mulmxA _ _ S) mulmxKpV ?mxE // -eqST submx_full.\n    rewrite map_mxM /=; congr (_ *m _); apply/rowP => i; rewrite 2!mxE numqE.\n    by have /eqP/rowP/(_ i)/[!mxE] -> := Zv; rewrite mulr1.\n  rewrite (coord_vbasis (s_Zs _)); apply: eq_bigr => j _; congr (_ *: _).\n  rewrite linear_sum mxE; apply: eq_bigr => i _.\n  by rewrite -SE -scaler_int linearZ [b]lock !mxE.\nsplit.\n  rewrite -[LHS]addr0 => /addrI hP; pose c := \\row_i h i *m lsubmx (invmx G).\n  exists [seq c 0 i | i : 'I_k]; congr (_ + _).\n  have/sub_kermxP: map_mx intr (\\row_i h i) *m S = 0.\n    transitivity (\\row_j coord (vbasis <<s>>) j (\\sum_(i < m) s`_i *~ h i)).\n      apply/rowP => j; rewrite !mxE linear_sum; apply: eq_bigr => i _.\n      by rewrite -SE !mxE -scaler_int linearZ.\n    by apply/rowP => j; rewrite !mxE -hP linear0.\n  case/submx_trans/(_ kerS_sub_Gu)/submxP => c' /[dup].\n  move/(congr1 (mulmx^~ (map_mx intr (lsubmx (invmx G))))).\n  rewrite -mulmxA -!map_mxM [in RHS]mulmx_lsub mul_usub_mx -/c mulmxV //=.\n  rewrite scalar_mx_block -/(ulsubmx _) block_mxKul map_scalar_mx mulmx1.\n  move=> <- {c'}; rewrite -map_mxM /= => defh; apply/ffunP => j.\n  move/rowP/(_ j): defh; rewrite sum_ffunE !mxE => /intr_inj ->.\n  apply: eq_bigr => i _; rewrite ffunMzE mulrzz mulrC.\n  rewrite (nth_map i) ?size_enum_ord // nth_ord_enum ffunE.\n  by rewrite (nth_map i) ?size_enum_ord // nth_ord_enum.\ncase=> c /addrI -> {h}; rewrite -[LHS]addr0; congr (_ + _).\npose h := \\row_(j < k) c`_j *m usubmx G.\ntransitivity (\\sum_j (map_mx intr h *m S) 0 j *: (vbasis <<s>>)`_j).\n  by rewrite map_mxM -mulmxA kerGu mulmx0 big1 // => j _; rewrite mxE scale0r.\nrewrite (coord_vbasis (s_Zs _)); apply: eq_bigr => i _; congr (_ *: _).\nrewrite linear_sum -SE mxE; apply: eq_bigr => j _.\nrewrite -scaler_int linearZ !mxE sum_ffunE; congr (_%:~R * _).\napply: {i} eq_bigr => i _; rewrite mxE ffunMzE mulrzz mulrC.\nby rewrite (nth_map i) ?size_enum_ord // ffunE nth_ord_enum.\nQed.",
    "Lemma dec_Qint_span (vT : vectType rat) m (s : m.-tuple vT) v :\n  decidable (inIntSpan s v).\nProof.\nhave [[b [p aP]]|] := solve_Qint_span s v; last by right.\nleft; exists b; apply/(aP b); exists [::]; rewrite big1 ?addr0 // => i _.\nby rewrite nth_nil mulr0z.\nQed.",
    "Lemma eisenstein_crit (p : nat) (q : {poly int}) : prime p -> (size q != 1)%N ->\n  ~~ (p %| lead_coef q)%Z -> ~~ (p ^+ 2 %| q`_0)%Z ->\n  (forall i, (i < (size q).-1)%N -> p %| q`_i)%Z ->\n  irreducible_poly q.\nProof.\nmove=> p_prime qN1 Ndvd_pql Ndvd_pq0 dvd_pq.\napply/irreducible_rat_int.\nhave qN0 : q != 0 by rewrite -lead_coef_eq0; apply: contraNneq Ndvd_pql => ->.\nsplit.\n  rewrite size_map_poly_id0 ?intr_eq0 ?lead_coef_eq0//.\n  by rewrite ltn_neqAle eq_sym qN1 size_poly_gt0.\nmove=> f' +/dvdpP_rat_int[f [d dN0 feq]]; rewrite {f'}feq size_scale// => fN1.\nmove=> /= [g q_eq]; rewrite q_eq (eqp_trans (eqp_scale _ _))//.\nhave fN0 : f != 0 by apply: contra_neq qN0; rewrite q_eq => ->; rewrite mul0r.\nhave gN0 : g != 0 by apply: contra_neq qN0; rewrite q_eq => ->; rewrite mulr0.\nrewrite size_map_poly_id0 ?intr_eq0 ?lead_coef_eq0// in fN1.\nhave [/eqP/size_poly1P[c cN0 ->]|gN1] := eqVneq (size g) 1%N.\n  by rewrite mulrC mul_polyC map_polyZ/= eqp_sym eqp_scale// intr_eq0.\nhave c_neq0 : (lead_coef q)%:~R != 0 :> 'F_p\n   by rewrite -(dvdz_pcharf (pchar_Fp _)).\nhave : map_poly (intr : int -> 'F_p) q = (lead_coef q)%:~R *: 'X^(size q).-1.\n  apply/val_inj/(@eq_from_nth _ 0) => [|i]; rewrite size_map_poly_id0//.\n    by rewrite size_scale// size_polyXn -polySpred.\n  move=> i_small; rewrite coef_poly i_small coefZ coefXn lead_coefE.\n  move: i_small; rewrite polySpred// ltnS/=.\n  case: ltngtP => // [i_lt|->]; rewrite (mulr1, mulr0)//= => _.\n  by apply/eqP; rewrite -(dvdz_pcharf (pchar_Fp _))// dvd_pq.\nrewrite [in LHS]q_eq rmorphM/=.\nset c := (X in X *: _); set n := (_.-1).\nset pf := map_poly _ f; set pg := map_poly _ g => pfMpg.\nhave dvdXn (r : {poly _}) : size r != 1%N -> r %| c *: 'X^n -> r`_0 = 0.\n  move=> rN1; rewrite (eqp_dvdr _ (eqp_scale _ _))//.\n  rewrite -['X]subr0; move=> /dvdp_exp_XsubCP[k lekn]; rewrite subr0.\n  move=> /eqpP[u /andP[u1N0 u2N0]]; have [->|k_gt0] := posnP k.\n    move=> /(congr1 (size \\o val))/eqP.\n    by rewrite /= !size_scale// size_polyXn (negPf rN1).\n  move=> /(congr1 (fun p : {poly _} => p`_0))/eqP.\n  by rewrite !coefZ coefXn ltn_eqF// mulr0 mulf_eq0 (negPf u1N0) => /eqP.\nsuff : ((p : int) ^+ 2 %| q`_0)%Z by rewrite (negPf Ndvd_pq0).\nhave := c_neq0; rewrite q_eq coefM big_ord1.\nrewrite lead_coefM rmorphM mulf_eq0 negb_or => /andP[lpfN0 qfN0].\nhave pfN1 : size pf != 1%N by rewrite size_map_poly_id0.\nhave pgN1 : size pg != 1%N by rewrite size_map_poly_id0.\nhave /(dvdXn _ pgN1) /eqP : pg %| c *: 'X^n by rewrite -pfMpg dvdp_mull.\nhave /(dvdXn _ pfN1) /eqP : pf %| c *: 'X^n by rewrite -pfMpg dvdp_mulr.\nby rewrite !coef_map// -!(dvdz_pcharf (pchar_Fp _))//; apply: dvdz_mul.\nQed.",
    "Lemma rat_vm_compute n (x : rat) : vm_compute_eq n%:Q x -> n%:Q = x.\nProof. exact. Qed.",
    "Lemma redivp_def p q : redivp p q = (rscalp p q, rdivp p q, rmodp p q).\nProof. by rewrite /rscalp /rdivp /rmodp; case: (redivp p q) => [[]] /=. Qed.",
    "Lemma rdiv0p p : rdivp 0 p = 0.\nProof.\nrewrite /rdivp unlock; case: ifP => // Hp; rewrite /redivp_rec !size_poly0.\nby rewrite polySpred ?Hp.\nQed.",
    "Lemma rdivp0 p : rdivp p 0 = 0. Proof. by rewrite /rdivp unlock eqxx. Qed.",
    "Lemma rdivp_small p q : size p < size q -> rdivp p q = 0.\nProof.\nrewrite /rdivp unlock; have [-> | _ ltpq] := eqP; first by rewrite size_poly0.\nby case: (size p) => [|s]; rewrite /= ltpq.\nQed.",
    "Lemma leq_rdivp p q : size (rdivp p q) <= size p.\nProof.\nhave [/rdivp_small->|] := ltnP (size p) (size q); first by rewrite size_poly0.\nrewrite /rdivp /rmodp /rscalp unlock.\nhave [->|q0] //= := eqVneq q 0.\nhave: size (0 : {poly R}) <= size p by rewrite size_poly0.\nmove: {2 3 4 6}(size p) (leqnn (size p)) => A.\nelim: (size p) 0%N (0 : {poly R}) {1 3 4}p (leqnn (size p)) => [|n ihn] k q1 r.\n  by move/size_poly_leq0P->; rewrite /= size_poly0 size_poly_gt0 q0.\nmove=> /= hrn hr hq1 hq; case: ltnP => //= hqr.\nhave sq: 0 < size q by rewrite size_poly_gt0.\nhave sr: 0 < size r by apply: leq_trans sq hqr.\napply: ihn => //.\n- apply/leq_sizeP => j hnj.\n  rewrite coefB -scalerAl coefZ coefXnM ltn_subRL ltnNge.\n  have hj : (size r).-1 <= j by apply: leq_trans hnj; rewrite -ltnS prednK.\n  rewrite [leqLHS]polySpred -?size_poly_gt0 // coefMC.\n  rewrite (leq_ltn_trans hj) /=; last by rewrite -add1n leq_add2r.\n  move: hj; rewrite leq_eqVlt prednK // => /predU1P [<- | hj].\n    by rewrite -subn1 subnAC subKn // !subn1 !lead_coefE subrr.\n  have/leq_sizeP-> //: size q <= j - (size r - size q).\n    by rewrite subnBA // leq_psubRL // leq_add2r.\n  by move/leq_sizeP: (hj) => -> //; rewrite mul0r mulr0 subr0.\n- apply: leq_trans (size_polyD _ _) _; rewrite geq_max; apply/andP; split.\n    apply: leq_trans (size_polyMleq _ _) _.\n    by rewrite size_polyC lead_coef_eq0 q0 /= addn1.\n  rewrite size_polyN; apply: leq_trans (size_polyMleq _ _) _.\n  apply: leq_trans hr; rewrite -subn1 leq_subLR -[in (1 + _)%N](subnK hqr).\n  by rewrite addnA leq_add2r add1n -(@size_polyXn R) size_scale_leq.\napply: leq_trans (size_polyD _ _) _; rewrite geq_max; apply/andP; split.\n  apply: leq_trans (size_polyMleq _ _) _.\n  by rewrite size_polyC lead_coef_eq0 q0 /= addnS addn0.\napply: leq_trans (size_scale_leq _ _) _.\nby rewrite size_polyXn -subSn // leq_subLR -add1n leq_add.\nQed.",
    "Lemma rmod0p p : rmodp 0 p = 0.\nProof.\nrewrite /rmodp unlock; case: ifP => // Hp; rewrite /redivp_rec !size_poly0.\nby rewrite polySpred ?Hp.\nQed.",
    "Lemma rmodp0 p : rmodp p 0 = p. Proof. by rewrite /rmodp unlock eqxx. Qed.",
    "Lemma rscalp_small p q : size p < size q -> rscalp p q = 0.\nProof.\nrewrite /rscalp unlock; case: eqP => _ // spq.\nby case sp: (size p) => [| s] /=; rewrite spq.\nQed.",
    "Lemma ltn_rmodp p q : (size (rmodp p q) < size q) = (q != 0).\nProof.\nrewrite /rdivp /rmodp /rscalp unlock; have [->|q0] := eqVneq q 0.\n  by rewrite /= size_poly0 ltn0.\nelim: (size p) 0%N 0 {1 3}p (leqnn (size p)) => [|n ihn] k q1 r.\n  move/size_poly_leq0P->.\n  by rewrite /= size_poly0 size_poly_gt0 q0 size_poly0 size_poly_gt0.\nmove=> hr /=; case: (ltnP (size r)) => // hsrq; apply/ihn/leq_sizeP => j hnj.\nrewrite coefB -scalerAl !coefZ coefXnM coefMC ltn_subRL ltnNge.\nhave sq: 0 < size q by rewrite size_poly_gt0.\nhave sr: 0 < size r by apply: leq_trans hsrq.\nhave hj: (size r).-1 <= j by apply: leq_trans hnj; rewrite -ltnS prednK.\nmove: (leq_add sq hj); rewrite add1n prednK // => -> /=.\nmove: hj; rewrite leq_eqVlt prednK // => /predU1P [<- | hj].\n  by rewrite -predn_sub subKn // !lead_coefE subrr.\nhave/leq_sizeP -> //: size q <= j - (size r - size q).\n  by rewrite subnBA // leq_subRL ?leq_add2r // (leq_trans hj) // leq_addr.\nby move/leq_sizeP: hj => -> //; rewrite mul0r mulr0 subr0.\nQed.",
    "Lemma ltn_rmodpN0 p q : q != 0 -> size (rmodp p q) < size q.\nProof. by rewrite ltn_rmodp. Qed.",
    "Lemma rmodp1 p : rmodp p 1 = 0.\nProof.\napply/eqP; have := ltn_rmodp p 1.\nby rewrite !oner_neq0 -size_poly_eq0 size_poly1 ltnS leqn0.\nQed.",
    "Lemma rmodp_small p q : size p < size q -> rmodp p q = p.\nProof.\nrewrite /rmodp unlock; have [->|_] := eqP; first by rewrite size_poly0.\nby case sp: (size p) => [| s] Hs /=; rewrite sp Hs /=.\nQed.",
    "Lemma leq_rmodp m d : size (rmodp m d) <= size m.\nProof.\nhave [/rmodp_small -> //|h] := ltnP (size m) (size d).\nhave [->|d0] := eqVneq d 0; first by rewrite rmodp0.\nby apply: leq_trans h; apply: ltnW; rewrite ltn_rmodp.\nQed.",
    "Lemma rmodpC p c : c != 0 -> rmodp p c%:P = 0.\nProof.\nmove=> Hc; apply/eqP; rewrite -size_poly_leq0 -ltnS.\nhave -> : 1%N = nat_of_bool (c != 0) by rewrite Hc.\nby rewrite -size_polyC ltn_rmodp polyC_eq0.\nQed.",
    "Lemma rdvdp0 d : rdvdp d 0. Proof. by rewrite /rdvdp rmod0p. Qed.",
    "Lemma rdvd0p n : rdvdp 0 n = (n == 0). Proof. by rewrite /rdvdp rmodp0. Qed.",
    "Lemma rdvd0pP n : reflect (n = 0) (rdvdp 0 n).\nProof. by apply: (iffP idP); rewrite rdvd0p; move/eqP. Qed.",
    "Lemma rdvdpN0 p q : rdvdp p q -> q != 0 -> p != 0.\nProof. by move=> pq hq; apply: contraTneq pq => ->; rewrite rdvd0p. Qed.",
    "Lemma rdvdp1 d : rdvdp d 1 = (size d == 1).\nProof.\nrewrite /rdvdp; have [->|] := eqVneq d 0.\n  by rewrite rmodp0 size_poly0 (negPf (oner_neq0 _)).\nrewrite -size_poly_leq0 -ltnS; case: ltngtP => // [|/eqP] hd _.\n  by rewrite rmodp_small ?size_poly1 // oner_eq0.\nhave [c cn0 ->] := size_poly1P _ hd.\nrewrite /rmodp unlock -size_poly_eq0 size_poly1 /= size_poly1 size_polyC cn0 /=.\nby rewrite polyC_eq0 (negPf cn0) !lead_coefC !scale1r subrr !size_poly0.\nQed.",
    "Lemma rdvd1p m : rdvdp 1 m. Proof. by rewrite /rdvdp rmodp1. Qed.",
    "Lemma Nrdvdp_small (n d : {poly R}) :\n  n != 0 -> size n < size d -> rdvdp d n = false.\nProof. by move=> nn0 hs; rewrite /rdvdp (rmodp_small hs); apply: negPf. Qed.",
    "Lemma rmodp_eq0P p q : reflect (rmodp p q = 0) (rdvdp q p).\nProof. exact: (iffP eqP). Qed.",
    "Lemma rmodp_eq0 p q : rdvdp q p -> rmodp p q = 0. Proof. exact: rmodp_eq0P. Qed.",
    "Lemma rdvdp_leq p q : rdvdp p q -> q != 0 -> size p <= size q.\nProof. by move=> dvd_pq; rewrite leqNgt; apply: contra => /rmodp_small <-. Qed.",
    "Lemma rgcd0p : left_id 0 rgcdp.\nProof.\nmove=> p; rewrite /rgcdp size_poly0 size_poly_gt0 if_neg.\ncase: ifP => /= [_ | nzp]; first by rewrite eqxx.\nby rewrite polySpred !(rmodp0, nzp) //; case: _.-1 => [|m]; rewrite rmod0p eqxx.\nQed.",
    "Lemma rgcdp0 : right_id 0 rgcdp.\nProof.\nmove=> p; have:= rgcd0p p; rewrite /rgcdp size_poly0 size_poly_gt0.\nby case: eqVneq => p0; rewrite ?(eqxx, p0) //= eqxx.\nQed.",
    "Lemma rgcdpE p q :\n  rgcdp p q = if size p < size q\n    then rgcdp (rmodp q p) p else rgcdp (rmodp p q) q.\nProof.\npose rgcdp_rec := fix rgcdp_rec (n : nat) (pp qq : {poly R}) {struct n} :=\n   let rr := rmodp pp qq in\n   if rr == 0 then qq else\n   if n is n1.+1 then rgcdp_rec n1 qq rr else rr.\nhave Irec: forall m n p q, size q <= m -> size q <= n\n      -> size q < size p -> rgcdp_rec m p q = rgcdp_rec n p q.\n  + elim=> [|m Hrec] [|n] //= p1 q1.\n    - move/size_poly_leq0P=> -> _; rewrite size_poly0 size_poly_gt0 rmodp0.\n      by move/negPf->; case: n => [|n] /=; rewrite rmod0p eqxx.\n    - move=> _ /size_poly_leq0P ->; rewrite size_poly0 size_poly_gt0 rmodp0.\n      by move/negPf->; case: m {Hrec} => [|m] /=; rewrite rmod0p eqxx.\n  case: eqVneq => Epq Sm Sn Sq //; have [->|nzq] := eqVneq q1 0.\n    by case: n m {Sm Sn Hrec} => [|m] [|n] //=; rewrite rmod0p eqxx.\n  apply: Hrec; last by rewrite ltn_rmodp.\n    by rewrite -ltnS (leq_trans _ Sm) // ltn_rmodp.\n  by rewrite -ltnS (leq_trans _ Sn) // ltn_rmodp.\nhave [->|nzp] := eqVneq p 0.\n  by rewrite rmod0p rmodp0 rgcd0p rgcdp0 if_same.\nhave [->|nzq] := eqVneq q 0.\n  by rewrite rmod0p rmodp0 rgcd0p rgcdp0 if_same.\nrewrite /rgcdp -/rgcdp_rec !ltn_rmodp (negPf nzp) (negPf nzq) /=.\nhave [ltpq|leqp] := ltnP; rewrite !(negPf nzp, negPf nzq) //= polySpred //=.\n  have [->|nzqp] := eqVneq.\n    by case: (size p) => [|[|s]]; rewrite /= rmodp0 (negPf nzp) // rmod0p eqxx.\n  apply: Irec => //; last by rewrite ltn_rmodp.\n    by rewrite -ltnS -polySpred // (leq_trans _ ltpq) ?leqW // ltn_rmodp.\n  by rewrite ltnW // ltn_rmodp.\nhave [->|nzpq] := eqVneq.\n  by case: (size q) => [|[|s]]; rewrite /= rmodp0 (negPf nzq) // rmod0p eqxx.\napply: Irec => //; last by rewrite ltn_rmodp.\n  by rewrite -ltnS -polySpred // (leq_trans _ leqp) // ltn_rmodp.\nby rewrite ltnW // ltn_rmodp.\nQed.",
    "Lemma comm_redivpP m d : comm_redivp_spec m d (redivp m d).\nProof.\nrewrite unlock; have [->|Hd] := eqVneq d 0.\n  by constructor; rewrite !(simp, eqxx).\nhave: GRing.comm d (lead_coef d)%:P -> m * (lead_coef d ^+ 0)%:P = 0 * d + m.\n  by rewrite !simp.\nelim: (size m) 0%N 0 {1 4 6}m (leqnn (size m)) => [|n IHn] k q r Hr /=.\n  move/size_poly_leq0P: Hr ->.\n  suff hsd: size (0: {poly R}) < size d by rewrite hsd => /= ?; constructor.\n  by rewrite size_poly0 size_poly_gt0.\ncase: ltnP => Hlt Heq; first by constructor.\napply/IHn=> [|Cda]; last first.\n  rewrite mulrDl addrAC -addrA subrK exprSr polyCM mulrA Heq //.\n  by rewrite mulrDl -mulrA Cda mulrA.\napply/leq_sizeP => j Hj; rewrite coefB coefMC -scalerAl coefZ coefXnM.\nrewrite ltn_subRL ltnNge (leq_trans Hr) /=; last first.\n  by apply: leq_ltn_trans Hj _; rewrite -add1n leq_add2r size_poly_gt0.\nmove: Hj; rewrite leq_eqVlt; case/predU1P => [<-{j} | Hj]; last first.\n  rewrite !nth_default ?simp ?oppr0 ?(leq_trans Hr) //.\n  by rewrite -{1}(subKn Hlt) leq_sub2r // (leq_trans Hr).\nmove: Hr; rewrite leq_eqVlt ltnS; case/predU1P=> Hqq; last first.\n  by rewrite !nth_default ?simp ?oppr0 // -{1}(subKn Hlt) leq_sub2r.\nrewrite /lead_coef Hqq polySpred // subSS subKn ?addrN //.\nby rewrite -subn1 leq_subLR add1n -Hqq.\nQed.",
    "Lemma rmodpp p : GRing.comm p (lead_coef p)%:P -> rmodp p p = 0.\nProof.\nmove=> hC; rewrite /rmodp unlock; have [-> //|] := eqVneq.\nrewrite -size_poly_eq0 /redivp_rec; case sp: (size p)=> [|n] // _.\nrewrite sp ltnn subnn expr0 hC alg_polyC !simp subrr.\nby case: n sp => [|n] sp; rewrite size_polyC /= eqxx.\nQed.",
    "Lemma rgdcop0 q : rgdcop q 0 = (q == 0)%:R.\nProof. by rewrite /rgdcop size_poly0. Qed.",
    "Lemma redivp_eq q r :\n    size r < size d ->\n    let k := (redivp (q * d + r) d).1.1 in\n    let c := (lead_coef d ^+ k)%:P in\n  redivp (q * d + r) d = (k, q * c, r * c).\nProof.\nmove=> lt_rd; case: comm_redivpP=> k q1 r1 /(_ Cdl) Heq.\nhave dn0: d != 0 by case: (size d) lt_rd (size_poly_eq0 d) => // n _ <-.\nmove=> /(_ dn0) Hs.\nhave eC : q * d * (lead_coef d ^+ k)%:P = q * (lead_coef d ^+ k)%:P * d.\n  by rewrite -mulrA polyC_exp (commrX k Cdl) mulrA.\nsuff e1 : q1 = q * (lead_coef d ^+ k)%:P.\n  congr (_, _, _) => //=; move/eqP: Heq.\n  by rewrite [_ + r1]addrC -subr_eq e1 mulrDl addrAC eC subrr add0r; move/eqP.\nhave : (q1 - q * (lead_coef d ^+ k)%:P) * d = r * (lead_coef d ^+ k)%:P - r1.\n  apply: (@addIr _ r1); rewrite subrK.\n  apply: (@addrI _ ((q * (lead_coef d ^+ k)%:P) * d)).\n  by rewrite mulrDl mulNr !addrA [_ + (q1 * d)]addrC addrK -eC -mulrDl.\nmove/eqP; rewrite -[_ == _ - _]subr_eq0 rreg_div0 //.\n  by case/andP; rewrite subr_eq0; move/eqP.\nrewrite size_polyN; apply: (leq_ltn_trans (size_polyD _ _)); rewrite size_polyN.\nrewrite gtn_max Hs (leq_ltn_trans (size_polyMleq _ _)) //.\nrewrite size_polyC; case: (_ == _); last by rewrite addnS addn0.\nby rewrite addn0; apply: leq_ltn_trans lt_rd; case: size.\nQed.",
    "Lemma rdivp_eq p :\n  p * (lead_coef d ^+ (rscalp p d))%:P = (rdivp p d) * d + (rmodp p d).\nProof.\nby rewrite /rdivp /rmodp /rscalp; case: comm_redivpP=> k q1 r1 Hc _; apply: Hc.\nQed.",
    "Lemma eq_rdvdp k q1 p:\n  p * ((lead_coef d)^+ k)%:P = q1 * d -> rdvdp d p.\nProof.\nmove=> he.\nhave Hnq0 := rreg_lead0 Rreg; set lq := lead_coef d.\npose v := rscalp p d; pose m := maxn v k.\nrewrite /rdvdp -(rreg_polyMC_eq0 _ (@rregX _ _ (m - v) Rreg)).\nsuff:\n ((rdivp p d) * (lq ^+ (m - v))%:P - q1 * (lq ^+ (m - k))%:P) * d +\n  (rmodp p d) * (lq ^+ (m - v))%:P == 0.\n  rewrite rreg_div0 //; first by case/andP.\n  by rewrite rreg_size ?ltn_rmodp //; exact: rregX.\nrewrite mulrDl addrAC mulNr -!mulrA polyC_exp -(commrX (m-v) Cdl).\nrewrite -polyC_exp mulrA -mulrDl -rdivp_eq // [(_ ^+ (m - k))%:P]polyC_exp.\nrewrite -(commrX (m-k) Cdl) -polyC_exp mulrA -he -!mulrA -!polyCM -/v.\nby rewrite -!exprD addnC subnK ?leq_maxl // addnC subnK ?subrr ?leq_maxr.\nQed.",
    "Lemma rdvdp_eqP p : rdvdp_spec p d (rmodp p d) (rdvdp d p).\nProof.\ncase hdvd: (rdvdp d p); last by apply: RdvdpN; move/rmodp_eq0P/eqP: hdvd.\nmove/rmodp_eq0P: (hdvd)->; apply: (@Rdvdp _ _ (rscalp p d) (rdivp p d)).\nby rewrite rdivp_eq //; move/rmodp_eq0P: (hdvd)->; rewrite addr0.\nQed.",
    "Lemma rdvdp_mull p : rdvdp d (p * d).\nProof. by apply: (@eq_rdvdp 0 p); rewrite expr0 mulr1. Qed.",
    "Lemma rmodp_mull p : rmodp (p * d) d = 0. Proof. exact/eqP/rdvdp_mull. Qed.",
    "Lemma rmodpp : rmodp d d = 0.\nProof. by rewrite -[d in rmodp d _]mul1r rmodp_mull. Qed.",
    "Lemma rdivpp : rdivp d d = (lead_coef d ^+ rscalp d d)%:P.\nProof.\nhave dn0 : d != 0 by rewrite -lead_coef_eq0 rreg_neq0.\nmove: (rdivp_eq d); rewrite rmodpp addr0.\nsuff ->: GRing.comm d (lead_coef d ^+ rscalp d d)%:P by move/(rreg_lead Rreg)->.\nby rewrite polyC_exp; apply: commrX.\nQed.",
    "Lemma rdvdpp : rdvdp d d. Proof. exact/eqP/rmodpp. Qed.",
    "Lemma rdivpK p : rdvdp d p ->\n  rdivp p d * d = p * (lead_coef d ^+ rscalp p d)%:P.\nProof. by rewrite rdivp_eq /rdvdp; move/eqP->; rewrite addr0. Qed.",
    "Lemma redivp_eq q r : size r < size d ->\n  let k := (redivp (q * d + r) d).1.1 in\n  redivp (q * d + r) d = (k, q, r).\nProof.\ncase: (monic_comreg mond)=> Hc Hr /(redivp_eq Hc Hr q).\nby rewrite (eqP mond) => -> /=; rewrite expr1n !mulr1.\nQed.",
    "Lemma rdivp_eq p : p = rdivp p d * d + rmodp p d.\nProof.\nrewrite -rdivp_eq (eqP mond); last exact: commr1.\nby rewrite expr1n mulr1.\nQed.",
    "Lemma rdivpp : rdivp d d = 1.\nProof.\nby case: (monic_comreg mond) => hc hr; rewrite rdivpp // (eqP mond) expr1n.\nQed.",
    "Lemma rdivp_addl_mul_small q r : size r < size d -> rdivp (q * d + r) d = q.\nProof.\nby move=> Hd; case: (monic_comreg mond)=> Hc Hr; rewrite /rdivp redivp_eq.\nQed.",
    "Lemma rdivp_addl_mul q r : rdivp (q * d + r) d = q + rdivp r d.\nProof.\ncase: (monic_comreg mond)=> Hc Hr; rewrite [r in _ * _ + r]rdivp_eq addrA.\nby rewrite -mulrDl rdivp_addl_mul_small // ltn_rmodp monic_neq0.\nQed.",
    "Lemma rdivpDl q r : rdvdp d q -> rdivp (q + r) d = rdivp q d + rdivp r d.\nProof.\ncase: (monic_comreg mond)=> Hc Hr; rewrite [r in q + r]rdivp_eq addrA.\nrewrite [q in q + _ + _]rdivp_eq; move/rmodp_eq0P->.\nby rewrite addr0 -mulrDl rdivp_addl_mul_small // ltn_rmodp monic_neq0.\nQed.",
    "Lemma rdivpDr q r : rdvdp d r -> rdivp (q + r) d = rdivp q d + rdivp r d.\nProof. by rewrite addrC; move/rdivpDl->; rewrite addrC. Qed.",
    "Lemma rdivp_mull p : rdivp (p * d) d = p.\nProof. by rewrite -[p * d]addr0 rdivp_addl_mul rdiv0p addr0. Qed.",
    "Lemma rmodp_mull p : rmodp (p * d) d = 0.\nProof.\nby apply: rmodp_mull; rewrite (eqP mond); [apply: commr1 | apply: rreg1].\nQed.",
    "Lemma rmodpp : rmodp d d = 0.\nProof.\nby apply: rmodpp; rewrite (eqP mond); [apply: commr1 | apply: rreg1].\nQed.",
    "Lemma rmodp_addl_mul_small q r : size r < size d -> rmodp (q * d + r) d = r.\nProof.\nby move=> Hd; case: (monic_comreg mond)=> Hc Hr; rewrite /rmodp redivp_eq.\nQed.",
    "Lemma rmodp_id (p : {poly R}) : rmodp (rmodp p d) d = rmodp p d.\nProof.\nby rewrite rmodp_small // ltn_rmodpN0 // monic_neq0.\nQed.",
    "Lemma rmodpD p q : rmodp (p + q) d = rmodp p d + rmodp q d.\nProof.\nrewrite [p in LHS]rdivp_eq [q in LHS]rdivp_eq addrACA -mulrDl.\nrewrite rmodp_addl_mul_small //; apply: (leq_ltn_trans (size_polyD _ _)).\nby rewrite gtn_max !ltn_rmodp // monic_neq0.\nQed.",
    "Lemma rmodpN p : rmodp (- p) d = - (rmodp p d).\nProof.\nrewrite {1}(rdivp_eq p) opprD // -mulNr rmodp_addl_mul_small //.\nby rewrite size_polyN ltn_rmodp // monic_neq0.\nQed.",
    "Lemma rmodpB p q : rmodp (p - q) d = rmodp p d - rmodp q d.\nProof. by rewrite rmodpD rmodpN. Qed.",
    "Lemma rmodpZ a p : rmodp (a *: p) d = a *: (rmodp p d).\nProof.\ncase: (altP (a =P 0%R)) => [-> | cn0]; first by rewrite !scale0r rmod0p.\nhave -> : ((a *: p) = (a *: (rdivp p d)) * d + a *: (rmodp p d))%R.\n  by rewrite -scalerAl -scalerDr -rdivp_eq.\nrewrite  rmodp_addl_mul_small //.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\n  rewrite size_polyC cn0 addSn add0n /= ltn_rmodp.\nexact: monic_neq0.\nQed.",
    "Lemma rmodp_sum (I : Type) (r : seq I) (P : pred I) (F : I -> {poly R}) :\n   rmodp (\\sum_(i <- r | P i) F i) d = (\\sum_(i <- r | P i) (rmodp (F i) d)).\nProof.\nby elim/big_rec2: _ => [|i p q _ <-]; rewrite ?(rmod0p, rmodpD).\nQed.",
    "Lemma rmodp_mulmr p q : rmodp (p * (rmodp q d)) d = rmodp (p * q) d.\nProof.\nby rewrite [q in RHS]rdivp_eq mulrDr rmodpD mulrA rmodp_mull add0r.\nQed.",
    "Lemma rdvdpp : rdvdp d d.\nProof.\nby apply: rdvdpp; rewrite (eqP mond); [apply: commr1 | apply: rreg1].\nQed.",
    "Lemma eq_rdvdp q1 p : p = q1 * d -> rdvdp d p.\nProof.\n\nmove=> h; apply: (@eq_rdvdp _ _ _ _ 1 q1); rewrite (eqP mond).\n- exact: commr1.\n- exact: rreg1.\nby rewrite expr1n mulr1.\nQed.",
    "Lemma rdvdp_mull p : rdvdp d (p * d).\nProof.\nby apply: rdvdp_mull; rewrite (eqP mond) //; [apply: commr1 | apply: rreg1].\nQed.",
    "Lemma rdvdpP p : reflect (exists qq, p = qq * d) (rdvdp d p).\nProof.\ncase: (monic_comreg mond)=> Hc Hr; apply: (iffP idP) => [|[qq] /eq_rdvdp //].\nby case: rdvdp_eqP=> // k qq; rewrite (eqP mond) expr1n mulr1 => ->; exists qq.\nQed.",
    "Lemma rdivpK p : rdvdp d p -> (rdivp p d) * d = p.\nProof. by move=> dvddp; rewrite [RHS]rdivp_eq rmodp_eq0 ?addr0. Qed.",
    "Lemma drop_poly_rdivp n p : drop_poly n p = rdivp p 'X^n.\nProof.\nrewrite -[p in RHS](poly_take_drop n) addrC rdivp_addl_mul ?monicXn//.\nby rewrite rdivp_small ?addr0// size_polyXn ltnS size_take_poly.\nQed.",
    "Lemma take_poly_rmodp n p : take_poly n p = rmodp p 'X^n.\nProof.\nhave mX := monicXn R n; rewrite -[p in RHS](poly_take_drop n) rmodpD//.\nby rewrite rmodp_small ?rmodp_mull ?addr0// size_polyXn ltnS size_take_poly.\nQed.",
    "Lemma rmodp_mulml p q : rmodp (rmodp p d * q) d = rmodp (p * q) d.\nProof. by rewrite [in LHS]mulrC [in RHS]mulrC rmodp_mulmr. Qed.",
    "Lemma rmodpX p n : rmodp ((rmodp p d) ^+ n) d = rmodp (p ^+ n) d.\nProof.\nelim: n => [|n IH]; first by rewrite !expr0.\nrewrite !exprS -rmodp_mulmr // IH rmodp_mulmr //.\nby rewrite mulrC rmodp_mulmr // mulrC.\nQed.",
    "Lemma rmodp_compr p q : rmodp (p \\Po (rmodp q d)) d = (rmodp (p \\Po q) d).\nProof.\nelim/poly_ind: p => [|p c IH]; first by rewrite !comp_polyC !rmod0p.\nrewrite !comp_polyD !comp_polyM addrC rmodpD //.\n  rewrite mulrC -rmodp_mulmr // IH rmodp_mulmr //.\n  rewrite !comp_polyX !comp_polyC.\nby rewrite mulrC rmodp_mulmr // -rmodpD // addrC.\nQed.",
    "Lemma rdivp1 p : rdivp p 1 = p.\nProof. by rewrite -[p in LHS]mulr1 rdivp_mull // monic1. Qed.",
    "Lemma rdvdp_XsubCl p x : rdvdp ('X - x%:P) p = root p x.\nProof.\nhave [HcX Hr] := monic_comreg (monicXsubC x).\napply/rmodp_eq0P/factor_theorem => [|[p1 ->]]; last exact/rmodp_mull/monicXsubC.\nmove=> e0; exists (rdivp p ('X - x%:P)).\nby rewrite [LHS](rdivp_eq (monicXsubC x)) e0 addr0.\nQed.",
    "Lemma polyXsubCP p x : reflect (p.[x] = 0) (rdvdp ('X - x%:P) p).\nProof. by apply: (iffP idP); rewrite rdvdp_XsubCl; move/rootP. Qed.",
    "Lemma root_factor_theorem p x : root p x = (rdvdp ('X - x%:P) p).\nProof. by rewrite rdvdp_XsubCl. Qed.",
    "Lemma redivpP m d : redivp_spec m d (redivp m d).\nProof.\nrewrite redivp_def; constructor; last by move=> dn0; rewrite ltn_rmodp.\nby rewrite -mul_polyC mulrC rdivp_eq //= /GRing.comm mulrC.\nQed.",
    "Lemma rdivp_eq d p :\n  (lead_coef d ^+ rscalp p d) *: p = rdivp p d * d + rmodp p d.\nProof.\nby rewrite /rdivp /rmodp /rscalp; case: redivpP=> k q1 r1 Hc _; apply: Hc.\nQed.",
    "Lemma rdvdp_eqP d p : rdvdp_spec p d (rmodp p d) (rdvdp d p).\nProof.\ncase hdvd: (rdvdp d p); last by move/rmodp_eq0P/eqP/RdvdpN: hdvd.\nmove/rmodp_eq0P: (hdvd)->; apply: (@Rdvdp _ _ _ (rscalp p d) (rdivp p d)).\nby rewrite mulrC mul_polyC rdivp_eq; move/rmodp_eq0P: (hdvd)->; rewrite addr0.\nQed.",
    "Lemma rdvdp_eq q p :\n  rdvdp q p = (lead_coef q ^+ rscalp p q *: p == rdivp p q * q).\nProof.\nrewrite rdivp_eq; apply/rmodp_eq0P/eqP => [->|/eqP]; first by rewrite addr0.\nby rewrite eq_sym addrC -subr_eq subrr; move/eqP<-.\nQed.",
    "Lemma uniq_roots_rdvdp p rs :\n  all (root p) rs -> uniq_roots rs -> rdvdp (\\prod_(z <- rs) ('X - z%:P)) p.\nProof.\nmove=> rrs /(uniq_roots_prod_XsubC rrs) [q ->].\nexact/RingMonic.rdvdp_mull/monic_prod_XsubC.\nQed.",
    "Lemma edivp_def p q : edivp p q = (scalp p q, divp p q, modp p q).\nProof. by rewrite /scalp /divp /modp; case: (edivp p q) => [[]] /=. Qed.",
    "Lemma edivp_redivp p q : lead_coef q \\in GRing.unit = false ->\n  edivp p q = redivp p q.\nProof. by move=> hu; rewrite unlock hu; case: (redivp p q) => [[? ?] ?]. Qed.",
    "Lemma divpE p q :\n  p %/ q = if lead_coef q \\in GRing.unit\n    then lead_coef q ^- rscalp p q *: rdivp p q\n    else rdivp p q.\nProof. by case: ifP; rewrite /divp unlock redivp_def => ->. Qed.",
    "Lemma modpE p q :\n  p %% q = if lead_coef q \\in GRing.unit\n    then lead_coef q ^- rscalp p q *: (rmodp p q)\n    else rmodp p q.\nProof. by case: ifP; rewrite /modp unlock redivp_def => ->. Qed.",
    "Lemma scalpE p q :\n  scalp p q = if lead_coef q \\in GRing.unit then 0 else rscalp p q.\nProof. by case: ifP; rewrite /scalp unlock redivp_def => ->. Qed.",
    "Lemma dvdpE p q : p %| q = rdvdp p q.\nProof.\nrewrite /dvdp modpE /rdvdp; case ulcq: (lead_coef p \\in GRing.unit)=> //.\nrewrite -[in LHS]size_poly_eq0 size_scale ?size_poly_eq0 //.\nby rewrite invr_eq0 expf_neq0 //; apply: contraTneq ulcq => ->; rewrite unitr0.\nQed.",
    "Lemma lc_expn_scalp_neq0 p q : lead_coef q ^+ scalp p q != 0.\nProof.\nhave [->|nzq] := eqVneq q 0; last by rewrite expf_neq0 ?lead_coef_eq0.\nby rewrite /scalp 2!unlock /= eqxx lead_coef0 unitr0 /= oner_neq0.\nQed.",
    "Lemma edivpP m d : edivp_spec m d (edivp m d) (lead_coef d \\in GRing.unit).\nProof.\nhave hC : GRing.comm d (lead_coef d)%:P by rewrite /GRing.comm mulrC.\ncase ud: (lead_coef d \\in GRing.unit); last first.\n  rewrite edivp_redivp // redivp_def; constructor; rewrite ?ltn_rmodp // ?ud //.\n  by rewrite rdivp_eq.\nhave cdn0: lead_coef d != 0 by apply: contraTneq ud => ->; rewrite unitr0.\nrewrite unlock ud redivp_def; constructor => //.\n  rewrite -scalerAl -scalerDr -mul_polyC.\n  have hn0 : (lead_coef d ^+ rscalp m d)%:P != 0.\n    by rewrite polyC_eq0; apply: expf_neq0.\n  apply: (mulfI hn0); rewrite !mulrA -exprVn !polyC_exp -exprMn -polyCM.\n  by rewrite divrr // expr1n mul1r -polyC_exp mul_polyC rdivp_eq.\nmove=> dn0; rewrite size_scale ?ltn_rmodp // -exprVn expf_eq0 negb_and.\nby rewrite invr_eq0 cdn0 orbT.\nQed.",
    "Lemma edivp_eq d q r : size r < size d -> lead_coef d \\in GRing.unit ->\n  edivp (q * d + r) d = (0, q, r).\nProof.\nhave hC : GRing.comm d (lead_coef d)%:P by apply: mulrC.\nmove=> hsrd hu; rewrite unlock hu; case et: (redivp _ _) => [[s qq] rr].\nhave cdn0 : lead_coef d != 0 by case: eqP hu => //= ->; rewrite unitr0.\nmove: (et); rewrite RingComRreg.redivp_eq //; last exact/rregP.\nrewrite et /= mulrC (mulrC r) !mul_polyC; case=> <- <-.\nby rewrite !scalerA mulVr ?scale1r // unitrX.\nQed.",
    "Lemma divp_eq p q : (lead_coef q ^+ scalp p q) *: p = (p %/ q) * q + (p %% q).\nProof.\nrewrite divpE modpE scalpE.\ncase uq: (lead_coef q \\in GRing.unit); last by rewrite rdivp_eq.\nrewrite expr0 scale1r; have [->|qn0] := eqVneq q 0.\n  by rewrite lead_coef0 expr0n /rscalp unlock eqxx invr1 !scale1r rmodp0 !simp.\nby rewrite -scalerAl -scalerDr -rdivp_eq scalerA mulVr (scale1r, unitrX).\nQed.",
    "Lemma dvdp_eq q p : (q %| p) = (lead_coef q ^+ scalp p q *: p == (p %/ q) * q).\nProof.\nrewrite dvdpE rdvdp_eq scalpE divpE; case: ifP => ulcq //.\nrewrite expr0 scale1r -scalerAl; apply/eqP/eqP => [<- | {2}->].\n  by rewrite scalerA mulVr ?scale1r // unitrX.\nby rewrite scalerA mulrV ?scale1r // unitrX.\nQed.",
    "Lemma divpK d p : d %| p -> p %/ d * d = (lead_coef d ^+ scalp p d) *: p.\nProof. by rewrite dvdp_eq; move/eqP->. Qed.",
    "Lemma divpKC d p : d %| p -> d * (p %/ d) = (lead_coef d ^+ scalp p d) *: p.\nProof. by move=> ?; rewrite mulrC divpK. Qed.",
    "Lemma dvdpP q p :\n  reflect (exists2 cqq, cqq.1 != 0 & cqq.1 *: p = cqq.2 * q) (q %| p).\nProof.\nrewrite dvdp_eq; apply: (iffP eqP) => [e | [[c qq] cn0 e]].\n  by exists (lead_coef q ^+ scalp p q, p %/ q) => //=.\napply/eqP; rewrite -dvdp_eq dvdpE.\nhave Ecc: c%:P != 0 by rewrite polyC_eq0.\nhave [->|nz_p] := eqVneq p 0; first by rewrite rdvdp0.\npose p1 : {poly R} := lead_coef q ^+ rscalp p q *: qq - c *: (rdivp p q).\nhave E1: c *: rmodp p q = p1 * q.\n  rewrite mulrDl mulNr -scalerAl -e scalerA mulrC -scalerA -scalerAl.\n  by rewrite -scalerBr rdivp_eq addrC addKr.\nsuff: p1 * q == 0 by rewrite -E1 -mul_polyC mulf_eq0 (negPf Ecc).\nrewrite mulf_eq0; apply/norP; case=> p1_nz q_nz; have:= ltn_rmodp p q.\nby rewrite q_nz -(size_scale _ cn0) E1 size_mul // polySpred // ltnNge leq_addl.\nQed.",
    "Lemma mulpK p q : q != 0 -> p * q %/ q = lead_coef q ^+ scalp (p * q) q *: p.\nProof.\nmove=> qn0; apply: (rregP qn0); rewrite -scalerAl divp_eq.\nsuff -> : (p * q) %% q = 0 by rewrite addr0.\nrewrite modpE RingComRreg.rmodp_mull ?scaler0 ?if_same //.\n  by red; rewrite mulrC.\nby apply/rregP; rewrite lead_coef_eq0.\nQed.",
    "Lemma mulKp p q : q != 0 -> q * p %/ q = lead_coef q ^+ scalp (p * q) q *: p.\nProof. by move=> nzq; rewrite mulrC; apply: mulpK. Qed.",
    "Lemma divpp p : p != 0 -> p %/ p = (lead_coef p ^+ scalp p p)%:P.\nProof.\nmove=> np0; have := divp_eq p p.\nsuff -> : p %% p = 0 by rewrite addr0 -mul_polyC; move/(mulIf np0).\nrewrite modpE Ring.rmodpp; last by red; rewrite mulrC.\nby rewrite scaler0 if_same.\nQed.",
    "Lemma scalp0 p : scalp p 0 = 0.\nProof. by rewrite /scalp unlock lead_coef0 unitr0 unlock eqxx. Qed.",
    "Lemma divp_small p q : size p < size q -> p %/ q = 0.\nProof.\nmove=> spq; rewrite /divp unlock redivp_def /=.\nby case: ifP; rewrite rdivp_small // scaler0.\nQed.",
    "Lemma leq_divp p q : (size (p %/ q) <= size p).\nProof.\nrewrite /divp unlock redivp_def /=; case: ifP => ulcq; rewrite ?leq_rdivp //=.\nrewrite size_scale ?leq_rdivp // -exprVn expf_neq0 // invr_eq0.\nby case: eqP ulcq => // ->; rewrite unitr0.\nQed.",
    "Lemma div0p p : 0 %/ p = 0.\nProof.\nby rewrite /divp unlock redivp_def /=; case: ifP; rewrite rdiv0p // scaler0.\nQed.",
    "Lemma divp0 p : p %/ 0 = 0.\nProof.\nby rewrite /divp unlock redivp_def /=; case: ifP; rewrite rdivp0 // scaler0.\nQed.",
    "Lemma divp1 m : m %/ 1 = m.\nProof.\nby rewrite divpE lead_coefC unitr1 Ring.rdivp1 expr1n invr1 scale1r.\nQed.",
    "Lemma modp0 p : p %% 0 = p.\nProof.\nrewrite /modp unlock redivp_def; case: ifP; rewrite rmodp0 //= lead_coef0.\nby rewrite unitr0.\nQed.",
    "Lemma mod0p p : 0 %% p = 0.\nProof.\nby rewrite /modp unlock redivp_def /=; case: ifP; rewrite rmod0p // scaler0.\nQed.",
    "Lemma modp1 p : p %% 1 = 0.\nProof.\nby rewrite /modp unlock redivp_def /=; case: ifP; rewrite rmodp1 // scaler0.\nQed.",
    "Lemma modp_small p q : size p < size q -> p %% q = p.\nProof.\nmove=> spq; rewrite /modp unlock redivp_def; case: ifP; rewrite rmodp_small //.\nby rewrite /= rscalp_small // expr0 /= invr1 scale1r.\nQed.",
    "Lemma modpC p c : c != 0 -> p %% c%:P = 0.\nProof.\nmove=> cn0; rewrite /modp unlock redivp_def /=; case: ifP; rewrite ?rmodpC //.\nby rewrite scaler0.\nQed.",
    "Lemma modp_mull p q : (p * q) %% q = 0.\nProof.\nhave [-> | nq0] := eqVneq q 0; first by rewrite modp0 mulr0.\nhave rlcq : GRing.rreg (lead_coef q) by apply/rregP; rewrite lead_coef_eq0.\nhave hC : GRing.comm q (lead_coef q)%:P by red; rewrite mulrC.\nrewrite modpE; case: ifP => ulcq; rewrite RingComRreg.rmodp_mull //.\nexact: scaler0.\nQed.",
    "Lemma modp_mulr d p : (d * p) %% d = 0. Proof. by rewrite mulrC modp_mull. Qed.",
    "Lemma modpp d : d %% d = 0.\nProof. by rewrite -[d in d %% _]mul1r modp_mull. Qed.",
    "Lemma ltn_modp p q : (size (p %% q) < size q) = (q != 0).\nProof.\nrewrite /modp unlock redivp_def /=; case: ifP=> ulcq; rewrite ?ltn_rmodp //=.\nrewrite size_scale ?ltn_rmodp // -exprVn expf_neq0 // invr_eq0.\nby case: eqP ulcq => // ->; rewrite unitr0.\nQed.",
    "Lemma ltn_divpl d q p : d != 0 ->\n   (size (q %/ d) < size p) = (size q < size (p * d)).\nProof.\nmove=> dn0.\nhave: (lead_coef d) ^+ (scalp q d) != 0 by apply: lc_expn_scalp_neq0.\nmove/(size_scale q)<-; rewrite divp_eq; have [->|quo0] := eqVneq (q %/ d) 0.\n  rewrite mul0r add0r size_poly0 size_poly_gt0.\n  have [->|pn0] := eqVneq p 0; first by rewrite mul0r size_poly0 ltn0.\n  by rewrite size_mul // (polySpred pn0) addSn ltn_addl // ltn_modp.\nrewrite size_polyDl; last first.\n  by rewrite size_mul // (polySpred quo0) addSn /= ltn_addl // ltn_modp.\nhave [->|pn0] := eqVneq p 0; first by rewrite mul0r size_poly0 !ltn0.\nby rewrite !size_mul ?quo0 // (polySpred dn0) !addnS ltn_add2r.\nQed.",
    "Lemma leq_divpr d p q : d != 0 ->\n   (size p <= size (q %/ d)) = (size (p * d) <= size q).\nProof. by move=> dn0; rewrite leqNgt ltn_divpl // -leqNgt. Qed.",
    "Lemma divpN0 d p : d != 0 -> (p %/ d != 0) = (size d <= size p).\nProof.\nmove=> dn0.\nby rewrite -[d in RHS]mul1r -leq_divpr // size_polyC oner_eq0 size_poly_gt0.\nQed.",
    "Lemma size_divp p q : q != 0 -> size (p %/ q) = (size p - (size q).-1)%N.\nProof.\nmove=> nq0; case: (leqP (size q) (size p)) => sqp; last first.\n  move: (sqp); rewrite -{1}(ltn_predK sqp) ltnS -subn_eq0 divp_small //.\n  by move/eqP->; rewrite size_poly0.\nhave np0 : p != 0.\n  by rewrite -size_poly_gt0; apply: leq_trans sqp; rewrite size_poly_gt0.\nhave /= := congr1 (size \\o @polyseq R) (divp_eq p q).\nrewrite size_scale; last by rewrite expf_eq0 lead_coef_eq0 (negPf nq0) andbF.\nhave [->|qq0] := eqVneq (p %/ q) 0.\n  by rewrite mul0r add0r=> es; move: nq0; rewrite -(ltn_modp p) -es ltnNge sqp.\nrewrite size_polyDl.\n  by move->; apply/eqP; rewrite size_mul // (polySpred nq0) addnS /= addnK.\nrewrite size_mul ?qq0 //.\nmove: nq0; rewrite -(ltn_modp p); move/leq_trans; apply.\nby rewrite (polySpred qq0) addSn /= leq_addl.\nQed.",
    "Lemma ltn_modpN0 p q : q != 0 -> size (p %% q) < size q.\nProof. by rewrite ltn_modp. Qed.",
    "Lemma modp_id p q : (p %% q) %% q = p %% q.\nProof.\nby have [->|qn0] := eqVneq q 0; rewrite ?modp0 // modp_small ?ltn_modp.\nQed.",
    "Lemma leq_modp m d : size (m %% d) <= size m.\nProof.\nrewrite /modp unlock redivp_def /=; case: ifP; rewrite ?leq_rmodp //.\nmove=> ud; rewrite size_scale ?leq_rmodp // invr_eq0 expf_neq0 //.\nby apply: contraTneq ud => ->; rewrite unitr0.\nQed.",
    "Lemma dvdp0 d : d %| 0. Proof. by rewrite /dvdp mod0p. Qed.",
    "Lemma dvd0p p : (0 %| p) = (p == 0). Proof. by rewrite /dvdp modp0. Qed.",
    "Lemma dvd0pP p : reflect (p = 0) (0 %| p).\nProof. by apply: (iffP idP); rewrite dvd0p; move/eqP. Qed.",
    "Lemma dvdpN0 p q : p %| q -> q != 0 -> p != 0.\nProof. by move=> pq hq; apply: contraTneq pq => ->; rewrite dvd0p. Qed.",
    "Lemma dvdp1 d : (d %| 1) = (size d == 1).\nProof.\nrewrite /dvdp modpE; case ud: (lead_coef d \\in GRing.unit); last exact: rdvdp1.\nrewrite -size_poly_eq0 size_scale; first by rewrite size_poly_eq0 -rdvdp1.\nby rewrite invr_eq0 expf_neq0 //; apply: contraTneq ud => ->; rewrite unitr0.\nQed.",
    "Lemma dvd1p m : 1 %| m. Proof. by rewrite /dvdp modp1. Qed.",
    "Lemma gtNdvdp p q : p != 0 -> size p < size q -> (q %| p) = false.\nProof.\nby move=> nn0 hs; rewrite /dvdp; rewrite (modp_small hs); apply: negPf.\nQed.",
    "Lemma modp_eq0P p q : reflect (p %% q = 0) (q %| p).\nProof. exact: (iffP eqP). Qed.",
    "Lemma modp_eq0 p q : (q %| p) -> p %% q = 0. Proof. exact: modp_eq0P. Qed.",
    "Lemma leq_divpl d p q :\n  d %| p -> (size (p %/ d) <= size q) = (size p <= size (q * d)).\nProof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | nd0 hd].\n  by rewrite divp0 size_poly0 !leq0n.\nrewrite leq_eqVlt ltn_divpl // (leq_eqVlt (size p)).\ncase lhs: (size p < size (q * d)); rewrite ?orbT ?orbF //.\nhave: (lead_coef d) ^+ (scalp p d) != 0 by rewrite expf_neq0 // lead_coef_eq0.\nmove/(size_scale p)<-; rewrite divp_eq; move/modp_eq0P: hd->; rewrite addr0.\nhave [-> | quon0] := eqVneq (p %/ d) 0.\n  rewrite mul0r size_poly0 2!(eq_sym 0) !size_poly_eq0.\n  by rewrite mulf_eq0 (negPf nd0) orbF.\nhave [-> | nq0] := eqVneq q 0.\n  by rewrite mul0r size_poly0 !size_poly_eq0 mulf_eq0 (negPf nd0) orbF.\nby rewrite !size_mul // (polySpred nd0) !addnS /= eqn_add2r.\nQed.",
    "Lemma dvdp_leq p q : q != 0 -> p %| q -> size p <= size q.\nProof.\nmove=> nq0 /modp_eq0P.\nby case: leqP => // /modp_small -> /eqP; rewrite (negPf nq0).\nQed.",
    "Lemma eq_dvdp c quo q p : c != 0 -> c *: p = quo * q -> q %| p.\nProof.\nmove=> cn0; case: (eqVneq p 0) => [->|nz_quo def_quo] //.\npose p1 : {poly R} := lead_coef q ^+ scalp p q *: quo - c *: (p %/ q).\nhave E1: c *: (p %% q) = p1 * q.\n  rewrite mulrDl mulNr -scalerAl -def_quo scalerA mulrC -scalerA.\n  by rewrite -scalerAl -scalerBr divp_eq addrAC subrr add0r.\nrewrite /dvdp; apply/idPn=> m_nz.\nhave: p1 * q != 0 by rewrite -E1 -mul_polyC mulf_neq0 // polyC_eq0.\nrewrite mulf_eq0; case/norP=> p1_nz q_nz.\nhave := ltn_modp p q; rewrite q_nz -(size_scale (p %% q) cn0) E1.\nby rewrite size_mul // polySpred // ltnNge leq_addl.\nQed.",
    "Lemma dvdpp d : d %| d. Proof. by rewrite /dvdp modpp. Qed.",
    "Lemma divp_dvd p q : p %| q -> (q %/ p) %| q.\nProof.\nhave [-> | np0] := eqVneq p 0; first by rewrite divp0.\nrewrite dvdp_eq => /eqP h.\napply: (@eq_dvdp ((lead_coef p)^+ (scalp q p)) p); last by rewrite mulrC.\nby rewrite expf_neq0 // lead_coef_eq0.\nQed.",
    "Lemma dvdp_mull m d n : d %| n -> d %| m * n.\nProof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite mulr0 dvdpp.\nrewrite dvdp_eq => /eqP e.\napply: (@eq_dvdp (lead_coef d ^+ scalp n d) (m * (n %/ d))).\n  by rewrite expf_neq0 // lead_coef_eq0.\nby rewrite scalerAr e mulrA.\nQed.",
    "Lemma dvdp_mulr n d m : d %| m -> d %| m * n.\nProof. by move=> hdm; rewrite mulrC dvdp_mull. Qed.",
    "Lemma dvdp_mul d1 d2 m1 m2 : d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2.\nProof.\ncase: (eqVneq d1 0) => [-> /dvd0pP -> | d1n0]; first by rewrite !mul0r dvdpp.\ncase: (eqVneq d2 0) => [-> _ /dvd0pP -> | d2n0]; first by rewrite !mulr0.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Hq1.\nrewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> Hq2.\napply: (@eq_dvdp (c1 * c2) (q1 * q2)).\n  by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\nrewrite -scalerA scalerAr scalerAl Hq1 Hq2 -!mulrA.\nby rewrite [d1 * (q2 * _)]mulrCA.\nQed.",
    "Lemma dvdp_addr m d n : d %| m -> (d %| m + n) = (d %| n).\nProof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite add0r.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Eq1.\napply/idP/idP; rewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _.\n  have sn0 : c1 * c2 != 0.\n    by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\n  move/eqP=> Eq2; apply: (@eq_dvdp _ (c1 *: q2 - c2 *: q1) _ _ sn0).\n  rewrite mulrDl -scaleNr -!scalerAl -Eq1 -Eq2 !scalerA.\n  by rewrite mulNr mulrC scaleNr -scalerBr addrC addKr.\nhave sn0 : c1 * c2 != 0.\n  by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\nmove/eqP=> Eq2; apply: (@eq_dvdp _ (c1 *: q2 + c2 *: q1) _ _ sn0).\nby rewrite mulrDl -!scalerAl -Eq1 -Eq2 !scalerA mulrC addrC scalerDr.\nQed.",
    "Lemma dvdp_addl n d m : d %| n -> (d %| m + n) = (d %| m).\nProof. by rewrite addrC; apply: dvdp_addr. Qed.",
    "Lemma dvdp_add d m n : d %| m -> d %| n -> d %| m + n.\nProof. by move/dvdp_addr->. Qed.",
    "Lemma dvdp_add_eq d m n : d %| m + n -> (d %| m) = (d %| n).\nProof. by move=> ?; apply/idP/idP; [move/dvdp_addr <-| move/dvdp_addl <-]. Qed.",
    "Lemma dvdp_subr d m n : d %| m -> (d %| m - n) = (d %| n).\nProof. by move=> ?; apply: dvdp_add_eq; rewrite -addrA addNr simp. Qed.",
    "Lemma dvdp_subl d m n : d %| n -> (d %| m - n) = (d %| m).\nProof. by move/dvdp_addl<-; rewrite subrK. Qed.",
    "Lemma dvdp_sub d m n : d %| m -> d %| n -> d %| m - n.\nProof. by move=> *; rewrite dvdp_subl. Qed.",
    "Lemma dvdp_mod d n m : d %| n -> (d %| m) = (d %| m %% n).\nProof.\nhave [-> | nn0] := eqVneq n 0; first by rewrite modp0.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite modp0.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Eq1.\napply/idP/idP; rewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _.\n  have sn0 : c1 * c2 != 0.\n   by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\n  pose quo := (c1 * lead_coef n ^+ scalp m n) *: q2 - c2 *: (m %/ n) * q1.\n  move/eqP=> Eq2; apply: (@eq_dvdp _ quo _ _ sn0).\n  rewrite mulrDl mulNr -!scalerAl -!mulrA -Eq1 -Eq2 -scalerAr !scalerA.\n  rewrite mulrC [_ * c2]mulrC mulrA -[((_ * _) * _) *: _]scalerA -scalerBr.\n  by rewrite divp_eq addrC addKr.\nhave sn0 : c1 * c2 * lead_coef n ^+ scalp m n != 0.\n  rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 ?(negPf dn0) ?andbF //.\n  by rewrite (negPf nn0) andbF.\nmove/eqP=> Eq2; apply: (@eq_dvdp _ (c2 *: (m %/ n) * q1 + c1 *: q2) _ _ sn0).\nrewrite -scalerA divp_eq scalerDr -!scalerA Eq2 scalerAl scalerAr Eq1.\nby rewrite scalerAl mulrDl mulrA.\nQed.",
    "Lemma dvdp_trans : transitive (@dvdp R).\nProof.\nmove=> n d m.\ncase: (eqVneq d 0) => [-> /dvd0pP -> // | dn0].\ncase: (eqVneq n 0) => [-> _ /dvd0pP -> // | nn0].\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Hq1.\nrewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> Hq2.\nhave sn0 : c1 * c2 != 0 by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\napply: (@eq_dvdp _ (q2 * q1) _ _ sn0).\nby rewrite -scalerA Hq2 scalerAr Hq1 mulrA.\nQed.",
    "Lemma dvdp_mulIl p q : p %| p * q. Proof. exact/dvdp_mulr/dvdpp. Qed.",
    "Lemma dvdp_mulIr p q : q %| p * q. Proof. exact/dvdp_mull/dvdpp. Qed.",
    "Lemma dvdp_mul2r r p q : r != 0 -> (p * r %| q * r) = (p %| q).\nProof.\nmove=> nzr.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite mul0r !dvd0p mulf_eq0 (negPf nzr) orbF.\nhave [-> | qn0] := eqVneq q 0; first by rewrite mul0r !dvdp0.\napply/idP/idP; last by move=> ?; rewrite dvdp_mul ?dvdpp.\nrewrite dvdp_eq; set c := _ ^+ _; set x := _ %/ _; move/eqP=> Hx.\napply: (@eq_dvdp c x); first by rewrite expf_neq0 // lead_coef_eq0 mulf_neq0.\nby apply: (mulIf nzr); rewrite -mulrA -scalerAl.\nQed.",
    "Lemma dvdp_mul2l r p q: r != 0 -> (r * p %| r * q) = (p %| q).\nProof. by rewrite ![r * _]mulrC; apply: dvdp_mul2r. Qed.",
    "Lemma ltn_divpr d p q :\n  d %| q -> (size p < size (q %/ d)) = (size (p * d) < size q).\nProof. by move=> dv_d_q; rewrite !ltnNge leq_divpl. Qed.",
    "Lemma dvdp_exp d k p : 0 < k -> d %| p -> d %| (p ^+ k).\nProof. by case: k => // k _ d_dv_m; rewrite exprS dvdp_mulr. Qed.",
    "Lemma dvdp_exp2l d k l : k <= l -> d ^+ k %| d ^+ l.\nProof. by move/subnK <-; rewrite exprD dvdp_mull // ?lead_coef_exp ?unitrX. Qed.",
    "Lemma dvdp_Pexp2l d k l : 1 < size d -> (d ^+ k %| d ^+ l) = (k <= l).\nProof.\nmove=> sd; case: leqP => [|gt_n_m]; first exact: dvdp_exp2l.\nhave dn0 : d != 0 by rewrite -size_poly_gt0; apply: ltn_trans sd.\nrewrite gtNdvdp ?expf_neq0 // polySpred ?expf_neq0 // size_exp /=.\nrewrite [size (d ^+ k)]polySpred ?expf_neq0 // size_exp ltnS ltn_mul2l.\nby move: sd; rewrite -subn_gt0 subn1; move->.\nQed.",
    "Lemma dvdp_exp2r p q k : p %| q -> p ^+ k %| q ^+ k.\nProof.\ncase: (eqVneq p 0) => [-> /dvd0pP -> // | pn0].\nrewrite dvdp_eq; set c := _ ^+ _; set t := _ %/ _; move/eqP=> e.\napply: (@eq_dvdp (c ^+ k) (t ^+ k)); first by rewrite !expf_neq0 ?lead_coef_eq0.\nby rewrite -exprMn -exprZn; congr (_ ^+ k).\nQed.",
    "Lemma dvdp_exp_sub p q k l: p != 0 ->\n  (p ^+ k %| q * p ^+ l) = (p ^+ (k - l) %| q).\nProof.\nmove=> pn0; case: (leqP k l)=> [|/ltnW] hkl.\n  move: (hkl); rewrite -subn_eq0; move/eqP->; rewrite expr0 dvd1p.\n  exact/dvdp_mull/dvdp_exp2l.\nby rewrite -[in LHS](subnK hkl) exprD dvdp_mul2r // expf_eq0 (negPf pn0) andbF.\nQed.",
    "Lemma dvdp_XsubCl p x : ('X - x%:P) %| p = root p x.\nProof. by rewrite dvdpE; apply: Ring.rdvdp_XsubCl. Qed.",
    "Lemma root_dvdp p q x : p %| q -> root p x -> root q x.\nProof. by rewrite -!dvdp_XsubCl => /[swap]; exact: dvdp_trans. Qed.",
    "Lemma polyXsubCP p x : reflect (p.[x] = 0) (('X - x%:P) %| p).\nProof. by rewrite dvdpE; apply: Ring.polyXsubCP. Qed.",
    "Lemma eqp_div_XsubC p c :\n  (p == (p %/ ('X - c%:P)) * ('X - c%:P)) = ('X - c%:P %| p).\nProof. by rewrite dvdp_eq lead_coefXsubC expr1n scale1r. Qed.",
    "Lemma root_factor_theorem p x : root p x = (('X - x%:P) %| p).\nProof. by rewrite dvdp_XsubCl. Qed.",
    "Lemma uniq_roots_dvdp p rs : all (root p) rs -> uniq_roots rs ->\n  (\\prod_(z <- rs) ('X - z%:P)) %| p.\nProof.\nmove=> rrs; case/(uniq_roots_prod_XsubC rrs)=> q ->.\nby apply: dvdp_mull; rewrite // (eqP (monic_prod_XsubC _)) unitr1.\nQed.",
    "Lemma root_bigmul x (ps : seq {poly R}) :\n  ~~root (\\big[*%R/1]_(p <- ps) p) x = all (fun p => ~~ root p x) ps.\nProof.\nelim: ps => [|p ps ihp]; first by rewrite big_nil root1.\nby rewrite big_cons /= rootM negb_or ihp.\nQed.",
    "Lemma eqpP m n :\n  reflect (exists2 c12, (c12.1 != 0) && (c12.2 != 0) & c12.1 *: m = c12.2 *: n)\n          (m %= n).\nProof.\napply: (iffP idP) => [| [[c1 c2]/andP[nz_c1 nz_c2 eq_cmn]]]; last first.\n  rewrite /eqp (@eq_dvdp c2 c1%:P) -?eq_cmn ?mul_polyC // (@eq_dvdp c1 c2%:P)//.\n  by rewrite eq_cmn mul_polyC.\ncase: (eqVneq m 0) => [-> /andP [/dvd0pP -> _] | m_nz].\n  by exists (1, 1); rewrite ?scaler0 // oner_eq0.\ncase: (eqVneq n 0) => [-> /andP [_ /dvd0pP ->] | n_nz /andP []].\n  by exists (1, 1); rewrite ?scaler0 // oner_eq0.\nrewrite !dvdp_eq; set c1 := _ ^+ _; set c2 := _ ^+ _.\nset q1 := _ %/ _; set q2 := _ %/ _; move/eqP => Hq1 /eqP Hq2;\nhave Hc1 : c1 != 0 by rewrite expf_eq0 lead_coef_eq0 negb_and m_nz orbT.\nhave Hc2 : c2 != 0 by rewrite expf_eq0 lead_coef_eq0 negb_and n_nz orbT.\nhave def_q12: q1 * q2 = (c1 * c2)%:P.\n  apply: (mulIf m_nz); rewrite mulrAC mulrC -Hq1 -scalerAr -Hq2 scalerA.\n  by rewrite -mul_polyC.\nhave: q1 * q2 != 0 by rewrite def_q12 -size_poly_eq0 size_polyC mulf_neq0.\nrewrite mulf_eq0; case/norP=> nz_q1 nz_q2.\nhave: size q2 <= 1.\n  have:= size_mul nz_q1 nz_q2; rewrite def_q12 size_polyC mulf_neq0 //=.\n  by rewrite polySpred // => ->; rewrite leq_addl.\nrewrite leq_eqVlt ltnS size_poly_leq0 (negPf nz_q2) orbF.\ncase/size_poly1P=> c cn0 cqe; exists (c2, c); first by rewrite Hc2.\nby rewrite Hq2 -mul_polyC -cqe.\nQed.",
    "Lemma eqp_eq p q: p %= q -> (lead_coef q) *: p = (lead_coef p) *: q.\nProof.\nmove=> /eqpP [[c1 c2] /= /andP [nz_c1 nz_c2]] eq.\nhave/(congr1 lead_coef) := eq; rewrite !lead_coefZ.\nmove=> eqC; apply/(@mulfI _ c2%:P); rewrite ?polyC_eq0 //.\nby rewrite !mul_polyC scalerA -eqC mulrC -scalerA eq !scalerA mulrC.\nQed.",
    "Lemma eqpxx : reflexive (@eqp R). Proof. by move=> p; rewrite /eqp dvdpp. Qed.",
    "Lemma eqpW p q : p = q -> p %= q. Proof. by move->; rewrite eqpxx. Qed.",
    "Lemma eqp_sym : symmetric (@eqp R).\nProof. by move=> p q; rewrite /eqp andbC. Qed.",
    "Lemma eqp_trans : transitive (@eqp R).\nProof.\nmove=> p q r; case/andP=> Dp pD; case/andP=> Dq qD.\nby rewrite /eqp (dvdp_trans Dp) // (dvdp_trans qD).\nQed.",
    "Lemma eqp_ltrans : left_transitive (@eqp R).\nProof. exact: sym_left_transitive eqp_sym eqp_trans. Qed.",
    "Lemma eqp_rtrans : right_transitive (@eqp R).\nProof. exact: sym_right_transitive eqp_sym eqp_trans. Qed.",
    "Lemma eqp0 p : (p %= 0) = (p == 0).\nProof. by apply/idP/eqP => [/andP [_ /dvd0pP] | -> //]. Qed.",
    "Lemma eqp01 : 0 %= (1 : {poly R}) = false.\nProof. by rewrite eqp_sym eqp0 oner_eq0. Qed.",
    "Lemma eqp_scale p c : c != 0 -> c *: p %= p.\nProof.\nmove=> c0; apply/eqpP; exists (1, c); first by rewrite c0 oner_eq0.\nby rewrite scale1r.\nQed.",
    "Lemma eqp_size p q : p %= q -> size p = size q.\nProof.\nhave [->|Eq] := eqVneq q 0; first by rewrite eqp0; move/eqP->.\nrewrite eqp_sym; have [->|Ep] := eqVneq p 0; first by rewrite eqp0; move/eqP->.\nby case/andP => Dp Dq; apply: anti_leq; rewrite !dvdp_leq.\nQed.",
    "Lemma size_poly_eq1 p : (size p == 1) = (p %= 1).\nProof.\napply/size_poly1P/idP=> [[c cn0 ep] |].\n  by apply/eqpP; exists (1, c); rewrite ?oner_eq0 // alg_polyC scale1r.\nby move/eqp_size; rewrite size_poly1; move/eqP/size_poly1P.\nQed.",
    "Lemma polyXsubC_eqp1 (x : R) : ('X - x%:P %= 1) = false.\nProof. by rewrite -size_poly_eq1 size_XsubC. Qed.",
    "Lemma dvdp_eqp1 p q : p %| q -> q %= 1 -> p %= 1.\nProof.\nmove=> dpq hq.\nhave sizeq : size q == 1 by rewrite size_poly_eq1.\nhave n0q : q != 0 by case: eqP hq => // ->; rewrite eqp01.\nrewrite -size_poly_eq1 eqn_leq -{1}(eqP sizeq) dvdp_leq //= size_poly_gt0.\nby apply/eqP => p0; move: dpq n0q; rewrite p0 dvd0p => ->.\nQed.",
    "Lemma eqp_dvdr q p d: p %= q -> d %| p = (d %| q).\nProof.\nsuff Hmn m n: m %= n -> (d %| m) -> (d %| n).\n  by move=> mn; apply/idP/idP; apply: Hmn=> //; rewrite eqp_sym.\nby rewrite /eqp; case/andP=> pq qp dp; apply: (dvdp_trans dp).\nQed.",
    "Lemma eqp_dvdl d2 d1 p : d1 %= d2 -> d1 %| p = (d2 %| p).\nProof.\nsuff Hmn m n: m %= n -> (m %| p) -> (n %| p).\n  by move=> ?; apply/idP/idP; apply: Hmn; rewrite // eqp_sym.\nby rewrite /eqp; case/andP=> dd' d'd dp; apply: (dvdp_trans d'd).\nQed.",
    "Lemma dvdpZr c m n : c != 0 -> m %| c *: n = (m %| n).\nProof. by move=> cn0; exact/eqp_dvdr/eqp_scale. Qed.",
    "Lemma dvdpZl c m n : c != 0 -> (c *: m %| n) = (m %| n).\nProof. by move=> cn0; exact/eqp_dvdl/eqp_scale. Qed.",
    "Lemma dvdpNl d p : (- d) %| p = (d %| p).\nProof.\nby rewrite -scaleN1r; apply/eqp_dvdl/eqp_scale; rewrite oppr_eq0 oner_neq0.\nQed.",
    "Lemma dvdpNr d p : d %| (- p) = (d %| p).\nProof. by apply: eqp_dvdr; rewrite -scaleN1r eqp_scale ?oppr_eq0 ?oner_eq0. Qed.",
    "Lemma eqp_mul2r r p q : r != 0 -> (p * r %= q * r) = (p %= q).\nProof. by move=> nz_r; rewrite /eqp !dvdp_mul2r. Qed.",
    "Lemma eqp_mul2l r p q: r != 0 -> (r * p %= r * q) = (p %= q).\nProof. by move=> nz_r; rewrite /eqp !dvdp_mul2l. Qed.",
    "Lemma eqp_mull r p q: q %= r -> p * q %= p * r.\nProof.\ncase/eqpP=> [[c d]] /andP [c0 d0 e]; apply/eqpP; exists (c, d); rewrite ?c0 //.\nby rewrite scalerAr e -scalerAr.\nQed.",
    "Lemma eqp_mulr q p r : p %= q -> p * r %= q * r.\nProof. by move=> epq; rewrite ![_ * r]mulrC eqp_mull. Qed.",
    "Lemma eqp_exp p q k : p %= q -> p ^+ k %= q ^+ k.\nProof.\nmove=> pq; elim: k=> [|k ihk]; first by rewrite !expr0 eqpxx.\nby rewrite !exprS (@eqp_trans (q * p ^+ k)) // (eqp_mulr, eqp_mull).\nQed.",
    "Lemma polyC_eqp1 (c : R) : (c%:P %= 1) = (c != 0).\nProof.\napply/eqpP/idP => [[[x y]] |nc0] /=.\n  case: (eqVneq c) => [->|] //= /andP [_] /negPf <- /eqP.\n  by rewrite alg_polyC scaler0 eq_sym polyC_eq0.\nexists (1, c); first by rewrite nc0 /= oner_neq0.\nby rewrite alg_polyC scale1r.\nQed.",
    "Lemma dvdUp d p: d %= 1 -> d %| p.\nProof. by move/eqp_dvdl->; rewrite dvd1p. Qed.",
    "Lemma dvdp_size_eqp p q : p %| q -> size p == size q = (p %= q).\nProof.\nmove=> pq; apply/idP/idP; last by move/eqp_size->.\nhave [->|Hq] := eqVneq q 0; first by rewrite size_poly0 size_poly_eq0 eqp0.\nhave [->|Hp] := eqVneq p 0.\n  by rewrite size_poly0 eq_sym size_poly_eq0 eqp_sym eqp0.\nmove: pq; rewrite dvdp_eq; set c := _ ^+ _; set x := _ %/ _; move/eqP=> eqpq.\nhave /= := congr1 (size \\o @polyseq R) eqpq.\nhave cn0 : c != 0 by rewrite expf_neq0 // lead_coef_eq0.\nrewrite (@eqp_size _ q); last exact: eqp_scale.\nrewrite size_mul ?p0 // => [-> HH|]; last first.\n  apply/eqP=> HH; move: eqpq; rewrite HH mul0r.\n  by move/eqP; rewrite scale_poly_eq0 (negPf Hq) (negPf cn0).\nsuff: size x == 1%N.\n  case/size_poly1P=> y H1y H2y.\n  by apply/eqpP; exists (y, c); rewrite ?H1y // eqpq H2y mul_polyC.\ncase: (size p) HH (size_poly_eq0 p)=> [|n]; first by case: eqP Hp.\nby rewrite addnS -add1n eqn_add2r; move/eqP->.\nQed.",
    "Lemma eqp_root p q : p %= q -> root p =1 root q.\nProof.\nmove/eqpP=> [[c d]] /andP [c0 d0 e] x; move/negPf:c0=>c0; move/negPf:d0=>d0.\nby rewrite rootE -[_==_]orFb -c0 -mulf_eq0 -hornerZ e hornerZ mulf_eq0 d0.\nQed.",
    "Lemma eqp_rmod_mod p q : rmodp p q %= modp p q.\nProof.\nrewrite modpE eqp_sym; case: ifP => ulcq //.\napply: eqp_scale; rewrite invr_eq0 //.\nby apply: expf_neq0; apply: contraTneq ulcq => ->; rewrite unitr0.\nQed.",
    "Lemma eqp_rdiv_div p q : rdivp p q %= divp p q.\nProof.\nrewrite divpE eqp_sym; case: ifP=> ulcq//; apply: eqp_scale; rewrite invr_eq0//.\nby apply: expf_neq0; apply: contraTneq ulcq => ->; rewrite unitr0.\nQed.",
    "Lemma dvd_eqp_divl d p q (dvd_dp : d %| q) (eq_pq : p %= q) :\n  p %/ d %= q %/ d.\nProof.\ncase: (eqVneq q 0) eq_pq=> [->|q_neq0]; first by rewrite eqp0=> /eqP->.\nhave d_neq0: d != 0 by apply: contraTneq dvd_dp=> ->; rewrite dvd0p.\nmove=> eq_pq; rewrite -(@eqp_mul2r d) // !divpK // ?(eqp_dvdr _ eq_pq) //.\nrewrite (eqp_ltrans (eqp_scale _ _)) ?lc_expn_scalp_neq0 //.\nby rewrite (eqp_rtrans (eqp_scale _ _)) ?lc_expn_scalp_neq0.\nQed.",
    "Lemma gcd0p : left_id 0 gcdp.\nProof.\nmove=> p; rewrite /gcdp size_poly0 size_poly_gt0 if_neg.\ncase: ifP => /= [_ | nzp]; first by rewrite eqxx.\nby rewrite polySpred !(modp0, nzp) //; case: _.-1 => [|m]; rewrite mod0p eqxx.\nQed.",
    "Lemma gcdp0 : right_id 0 gcdp.\nProof.\nmove=> p; have:= gcd0p p; rewrite /gcdp size_poly0 size_poly_gt0.\nby case: eqVneq => //= ->; rewrite eqxx.\nQed.",
    "Lemma gcdpE p q :\n  gcdp p q = if size p < size q\n    then gcdp (modp q p) p else gcdp (modp p q) q.\nProof.\npose gcdpE_rec := fix gcdpE_rec (n : nat) (pp qq : {poly R}) {struct n} :=\n   let rr := modp pp qq in\n   if rr == 0 then qq else\n   if n is n1.+1 then gcdpE_rec n1 qq rr else rr.\nhave Irec: forall k l p q, size q <= k -> size q <= l\n      -> size q < size p -> gcdpE_rec k p q = gcdpE_rec l p q.\n+ elim=> [|m Hrec] [|n] //= p1 q1.\n  - move/size_poly_leq0P=> -> _; rewrite size_poly0 size_poly_gt0 modp0.\n    by move/negPf ->; case: n => [|n] /=; rewrite mod0p eqxx.\n  - move=> _ /size_poly_leq0P ->; rewrite size_poly0 size_poly_gt0 modp0.\n    by move/negPf ->; case: m {Hrec} => [|m] /=; rewrite mod0p eqxx.\n  case: eqP => Epq Sm Sn Sq //; have [->|nzq] := eqVneq q1 0.\n    by case: n m {Sm Sn Hrec} => [|m] [|n] //=; rewrite mod0p eqxx.\n  apply: Hrec; last by rewrite ltn_modp.\n    by rewrite -ltnS (leq_trans _ Sm) // ltn_modp.\n  by rewrite -ltnS (leq_trans _ Sn) // ltn_modp.\nhave [->|nzp] := eqVneq p 0; first by rewrite mod0p modp0 gcd0p gcdp0 if_same.\nhave [->|nzq] := eqVneq q 0; first by rewrite mod0p modp0 gcd0p gcdp0 if_same.\nrewrite /gcdp !ltn_modp !(negPf nzp, negPf nzq) /=.\nhave [ltpq|leqp] := ltnP; rewrite !(negPf nzp, negPf nzq) /= polySpred //.\n  have [->|nzqp] := eqVneq.\n    by case: (size p) => [|[|s]]; rewrite /= modp0 (negPf nzp) // mod0p eqxx.\n  apply: Irec => //; last by rewrite ltn_modp.\n    by rewrite -ltnS -polySpred // (leq_trans _ ltpq) ?leqW // ltn_modp.\n  by rewrite ltnW // ltn_modp.\ncase: eqVneq => [->|nzpq].\n  by case: (size q) => [|[|s]]; rewrite /= modp0 (negPf nzq) // mod0p eqxx.\napply: Irec => //; rewrite ?ltn_modp //.\n  by rewrite -ltnS -polySpred // (leq_trans _ leqp) // ltn_modp.\nby rewrite ltnW // ltn_modp.\nQed.",
    "Lemma size_gcd1p p : size (gcdp 1 p) = 1.\nProof.\nrewrite gcdpE size_polyC oner_eq0 /= modp1; have [|/size1_polyC ->] := ltnP.\n  by rewrite gcd0p size_polyC oner_eq0.\nhave [->|p00] := eqVneq p`_0 0; first by rewrite modp0 gcdp0 size_poly1.\nby rewrite modpC // gcd0p size_polyC p00.\nQed.",
    "Lemma size_gcdp1 p : size (gcdp p 1) = 1.\nProof.\nrewrite gcdpE size_polyC oner_eq0 /= modp1 ltnS; case: leqP.\n  by move/size_poly_leq0P->; rewrite gcdp0 modp0 size_polyC oner_eq0.\nby rewrite gcd0p size_polyC oner_eq0.\nQed.",
    "Lemma gcdpp : idempotent_op gcdp.\nProof. by move=> p; rewrite gcdpE ltnn modpp gcd0p. Qed.",
    "Lemma dvdp_gcdlr p q : (gcdp p q %| p) && (gcdp p q %| q).\nProof.\nhave [r] := ubnP (minn (size q) (size p)); elim: r => // r IHr in p q *.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite gcd0p dvdpp andbT.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite gcdp0 dvdpp /=.\nrewrite ltnS gcdpE; case: leqP => [le_pq | lt_pq] le_qr.\n  suffices /IHr/andP[E1 E2]: minn (size q) (size (p %% q)) < r.\n    by rewrite E2 andbT (dvdp_mod _ E2).\n  by rewrite gtn_min orbC (leq_trans _ le_qr) ?ltn_modp.\nsuffices /IHr/andP[E1 E2]: minn (size p) (size (q %% p)) < r.\n  by rewrite E2 (dvdp_mod _ E2).\nby rewrite gtn_min orbC (leq_trans _ le_qr) ?ltn_modp.\nQed.",
    "Lemma dvdp_gcdl p q : gcdp p q %| p. Proof. by case/andP: (dvdp_gcdlr p q). Qed.",
    "Lemma dvdp_gcdr p q :gcdp p q %| q. Proof. by case/andP: (dvdp_gcdlr p q). Qed.",
    "Lemma leq_gcdpl p q : p != 0 -> size (gcdp p q) <= size p.\nProof. by move=> pn0; move: (dvdp_gcdl p q); apply: dvdp_leq. Qed.",
    "Lemma leq_gcdpr p q : q != 0 -> size (gcdp p q) <= size q.\nProof. by move=> qn0; move: (dvdp_gcdr p q); apply: dvdp_leq. Qed.",
    "Lemma dvdp_gcd p m n : p %| gcdp m n = (p %| m) && (p %| n).\nProof.\napply/idP/andP=> [dv_pmn | []].\n  by rewrite ?(dvdp_trans dv_pmn) ?dvdp_gcdl ?dvdp_gcdr.\nhave [r] := ubnP (minn (size n) (size m)); elim: r => // r IHr in m n *.\nhave [-> | nz_m] := eqVneq m 0; first by rewrite gcd0p.\nhave [-> | nz_n] := eqVneq n 0; first by rewrite gcdp0.\nrewrite gcdpE ltnS; case: leqP => [le_nm | lt_mn] le_r dv_m dv_n.\n  apply: IHr => //; last by rewrite -(dvdp_mod _ dv_n).\n  by rewrite gtn_min orbC (leq_trans _ le_r) ?ltn_modp.\napply: IHr => //; last by rewrite -(dvdp_mod _ dv_m).\nby rewrite gtn_min orbC (leq_trans _ le_r) ?ltn_modp.\nQed.",
    "Lemma gcdpC p q : gcdp p q %= gcdp q p.\nProof. by rewrite /eqp !dvdp_gcd !dvdp_gcdl !dvdp_gcdr. Qed.",
    "Lemma gcd1p p : gcdp 1 p %= 1.\nProof.\nrewrite -size_poly_eq1 gcdpE size_poly1; case: ltnP.\n  by rewrite modp1 gcd0p size_poly1 eqxx.\nmove/size1_polyC=> e; rewrite e.\nhave [->|p00] := eqVneq p`_0 0; first by rewrite modp0 gcdp0 size_poly1.\nby rewrite modpC // gcd0p size_polyC p00.\nQed.",
    "Lemma gcdp1 p : gcdp p 1 %= 1.\nProof. by rewrite (eqp_ltrans (gcdpC _ _)) gcd1p. Qed.",
    "Lemma gcdp_addl_mul p q r: gcdp r (p * r + q) %= gcdp r q.\nProof.\nsuff h m n d : gcdp d n %| gcdp d (m * d + n).\n  apply/andP; split => //.\n  by rewrite {2}(_: q = (-p) * r + (p * r + q)) ?H // mulNr addKr.\nby rewrite dvdp_gcd dvdp_gcdl /= dvdp_addr ?dvdp_gcdr ?dvdp_mull ?dvdp_gcdl.\nQed.",
    "Lemma gcdp_addl m n : gcdp m (m + n) %= gcdp m n.\nProof. by rewrite -[m in m + _]mul1r gcdp_addl_mul. Qed.",
    "Lemma gcdp_addr m n : gcdp m (n + m) %= gcdp m n.\nProof. by rewrite addrC gcdp_addl. Qed.",
    "Lemma gcdp_mull m n : gcdp n (m * n) %= n.\nProof.\nhave [-> | nn0] := eqVneq n 0; first by rewrite gcd0p mulr0 eqpxx.\nhave [-> | mn0] := eqVneq m 0; first by rewrite mul0r gcdp0 eqpxx.\nrewrite gcdpE modp_mull gcd0p size_mul //; case: leqP; last by rewrite eqpxx.\nrewrite (polySpred mn0) addSn /= -[leqRHS]add0n leq_add2r -ltnS.\nrewrite -polySpred //= leq_eqVlt ltnS size_poly_leq0 (negPf mn0) orbF.\ncase/size_poly1P=> c cn0 -> {mn0 m}; rewrite mul_polyC.\nsuff -> : n %% (c *: n) = 0 by rewrite gcd0p; apply: eqp_scale.\nby apply/modp_eq0P; rewrite dvdpZl.\nQed.",
    "Lemma gcdp_mulr m n : gcdp n (n * m) %= n.\nProof. by rewrite mulrC gcdp_mull. Qed.",
    "Lemma gcdp_scalel c m n : c != 0 -> gcdp (c *: m) n %= gcdp m n.\nProof.\nmove=> cn0; rewrite /eqp dvdp_gcd [gcdp m n %| _]dvdp_gcd !dvdp_gcdr !andbT.\napply/andP; split; last first.\n  by apply: dvdp_trans (dvdp_gcdl _ _) _; rewrite dvdpZr.\nby apply: dvdp_trans (dvdp_gcdl _ _) _; rewrite dvdpZl.\nQed.",
    "Lemma gcdp_scaler c m n : c != 0 -> gcdp m (c *: n) %= gcdp m n.\nProof.\nmove=> cn0; apply: eqp_trans (gcdpC _ _) _.\nby apply: eqp_trans (gcdp_scalel _ _ _) _ => //; apply: gcdpC.\nQed.",
    "Lemma dvdp_gcd_idl m n : m %| n -> gcdp m n %= m.\nProof.\nhave [-> | mn0] := eqVneq m 0.\n  by rewrite dvd0p => /eqP ->; rewrite gcdp0 eqpxx.\nrewrite dvdp_eq; move/eqP/(f_equal (gcdp m)) => h.\napply: eqp_trans (gcdp_mull (n %/ m) _).\nby rewrite -h eqp_sym gcdp_scaler // expf_neq0 // lead_coef_eq0.\nQed.",
    "Lemma dvdp_gcd_idr m n : n %| m -> gcdp m n %= n.\nProof. by move/dvdp_gcd_idl; exact/eqp_trans/gcdpC. Qed.",
    "Lemma gcdp_exp p k l : gcdp (p ^+ k) (p ^+ l) %= p ^+ minn k l.\nProof.\ncase: leqP => [|/ltnW] /subnK <-; rewrite exprD; first exact: gcdp_mull.\nexact/(eqp_trans (gcdpC _ _))/gcdp_mull.\nQed.",
    "Lemma gcdp_eq0 p q : gcdp p q == 0 = (p == 0) && (q == 0).\nProof.\napply/idP/idP; last by case/andP => /eqP -> /eqP ->; rewrite gcdp0.\nhave h m n: gcdp m n == 0 -> (m == 0).\n  by rewrite -(dvd0p m); move/eqP<-; rewrite dvdp_gcdl.\nby move=> ?; rewrite (h _ q) // (h _ p) // -eqp0 (eqp_ltrans (gcdpC _ _)) eqp0.\nQed.",
    "Lemma eqp_gcdr p q r : q %= r -> gcdp p q %= gcdp p r.\nProof.\nmove=> eqr; rewrite /eqp !(dvdp_gcd, dvdp_gcdl, andbT) /=.\nby rewrite -(eqp_dvdr _ eqr) dvdp_gcdr (eqp_dvdr _ eqr) dvdp_gcdr.\nQed.",
    "Lemma eqp_gcdl r p q : p %= q -> gcdp p r %= gcdp q r.\nProof.\nmove=> eqr; rewrite /eqp !(dvdp_gcd, dvdp_gcdr, andbT) /=.\nby rewrite -(eqp_dvdr _ eqr) dvdp_gcdl (eqp_dvdr _ eqr) dvdp_gcdl.\nQed.",
    "Lemma eqp_gcd p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> gcdp p1 q1 %= gcdp p2 q2.\nProof. move=> e1 e2; exact: eqp_trans (eqp_gcdr _ e2) (eqp_gcdl _ e1). Qed.",
    "Lemma eqp_rgcd_gcd p q : rgcdp p q %= gcdp p q.\nProof.\nmove: {2}(minn (size p) (size q)) (leqnn (minn (size p) (size q))) => n.\nelim: n p q => [p q|n ihn p q hs].\n  rewrite leqn0; case: ltnP => _; rewrite size_poly_eq0; move/eqP->.\n    by rewrite gcd0p rgcd0p eqpxx.\n  by rewrite gcdp0 rgcdp0 eqpxx.\nhave [-> | pn0] := eqVneq p 0; first by rewrite gcd0p rgcd0p eqpxx.\nhave [-> | qn0] := eqVneq q 0; first by rewrite gcdp0 rgcdp0 eqpxx.\nrewrite gcdpE rgcdpE; case: ltnP hs => sp hs.\n  have e := eqp_rmod_mod q p; apply/eqp_trans/ihn: (eqp_gcdl p e).\n  by rewrite (eqp_size e) geq_min -ltnS (leq_trans _ hs) ?ltn_modp.\nhave e := eqp_rmod_mod p q; apply/eqp_trans/ihn: (eqp_gcdl q e).\nby rewrite (eqp_size e) geq_min -ltnS (leq_trans _ hs) ?ltn_modp.\nQed.",
    "Lemma gcdp_modl m n : gcdp (m %% n) n %= gcdp m n.\nProof.\nhave [/modp_small -> // | lenm] := ltnP (size m) (size n).\nby rewrite (gcdpE m n) ltnNge lenm.\nQed.",
    "Lemma gcdp_modr m n : gcdp m (n %% m) %= gcdp m n.\nProof.\napply: eqp_trans (gcdpC _ _); apply: eqp_trans (gcdp_modl _ _); exact: gcdpC.\nQed.",
    "Lemma gcdp_def d m n :\n    d %| m -> d %| n -> (forall d', d' %| m -> d' %| n -> d' %| d) ->\n  gcdp m n %= d.\nProof.\nmove=> dm dn h; rewrite /eqp dvdp_gcd dm dn !andbT.\nby apply: h; [apply: dvdp_gcdl | apply: dvdp_gcdr].\nQed.",
    "Lemma coprimep_size_gcd p q : coprimep p q -> size (gcdp p q) = 1.\nProof. by rewrite /coprimep=> /eqP. Qed.",
    "Lemma coprimep_def p q : coprimep p q = (size (gcdp p q) == 1).\nProof. done. Qed.",
    "Lemma coprimepZl c m n : c != 0 -> coprimep (c *: m) n = coprimep m n.\nProof. by move=> ?; rewrite !coprimep_def (eqp_size (gcdp_scalel _ _ _)). Qed.",
    "Lemma coprimepZr c m n: c != 0 -> coprimep m (c *: n) = coprimep m n.\nProof. by move=> ?; rewrite !coprimep_def (eqp_size (gcdp_scaler _ _ _)). Qed.",
    "Lemma coprimepp p : coprimep p p = (size p == 1).\nProof. by rewrite coprimep_def gcdpp. Qed.",
    "Lemma gcdp_eqp1 p q : gcdp p q %= 1 = coprimep p q.\nProof. by rewrite coprimep_def size_poly_eq1. Qed.",
    "Lemma coprimep_sym p q : coprimep p q = coprimep q p.\nProof. by rewrite -!gcdp_eqp1; apply: eqp_ltrans; rewrite gcdpC. Qed.",
    "Lemma coprime1p p : coprimep 1 p.\nProof. by rewrite /coprimep -[1%N](size_poly1 R); exact/eqP/eqp_size/gcd1p. Qed.",
    "Lemma coprimep1 p : coprimep p 1.\nProof. by rewrite coprimep_sym; apply: coprime1p. Qed.",
    "Lemma coprimep0 p : coprimep p 0 = (p %= 1).\nProof. by rewrite /coprimep gcdp0 size_poly_eq1. Qed.",
    "Lemma coprime0p p : coprimep 0 p = (p %= 1).\nProof. by rewrite coprimep_sym coprimep0. Qed.",
    "Lemma coprimepP p q :\n reflect (forall d, d %| p -> d %| q -> d %= 1) (coprimep p q).\nProof.\nrewrite /coprimep; apply: (iffP idP) => [/eqP hs d dvddp dvddq | h].\n  have/dvdp_eqp1: d %| gcdp p q by rewrite dvdp_gcd dvddp dvddq.\n  by rewrite -size_poly_eq1 hs; exact.\nby rewrite size_poly_eq1; case/andP: (dvdp_gcdlr p q); apply: h.\nQed.",
    "Lemma coprimepPn p q : p != 0 ->\n  reflect (exists d, (d %| gcdp p q) && ~~ (d %= 1)) (~~ coprimep p q).\nProof.\nmove=> p0; apply: (iffP idP).\n  by rewrite -gcdp_eqp1=> ng1; exists (gcdp p q); rewrite dvdpp /=.\ncase=> d /andP [dg]; apply: contra; rewrite -gcdp_eqp1=> g1.\nby move: dg; rewrite (eqp_dvdr _ g1) dvdp1 size_poly_eq1.\nQed.",
    "Lemma coprimep_dvdl q p r : r %| q -> coprimep p q -> coprimep p r.\nProof.\nmove=> rp /coprimepP cpq'; apply/coprimepP => d dp dr.\nexact/cpq'/(dvdp_trans dr).\nQed.",
    "Lemma coprimep_dvdr p q r : r %| p -> coprimep p q -> coprimep r q.\nProof.\nby move=> rp; rewrite ![coprimep _ q]coprimep_sym; apply/coprimep_dvdl.\nQed.",
    "Lemma coprimep_modl p q : coprimep (p %% q) q = coprimep p q.\nProof.\nrewrite !coprimep_def [in RHS]gcdpE.\nby case: ltnP => // hpq; rewrite modp_small // gcdpE hpq.\nQed.",
    "Lemma coprimep_modr q p : coprimep q (p %% q) = coprimep q p.\nProof. by rewrite ![coprimep q _]coprimep_sym coprimep_modl. Qed.",
    "Lemma rcoprimep_coprimep q p : rcoprimep q p = coprimep q p.\nProof. by rewrite /coprimep /rcoprimep (eqp_size (eqp_rgcd_gcd _ _)). Qed.",
    "Lemma eqp_coprimepr p q r : q %= r -> coprimep p q = coprimep p r.\nProof. by rewrite -!gcdp_eqp1; move/(eqp_gcdr p)/eqp_ltrans. Qed.",
    "Lemma eqp_coprimepl p q r : q %= r -> coprimep q p = coprimep r p.\nProof. by rewrite !(coprimep_sym _ p); apply: eqp_coprimepr. Qed.",
    "Lemma egcdp0 p : egcdp p 0 = (1, 0). Proof. by rewrite /egcdp size_poly0. Qed.",
    "Lemma egcdp_recP : forall k p q, q != 0 -> size q <= k -> size q <= size p ->\n  let e := (egcdp_rec p q k) in\n    [/\\ size e.1 <= size q, size e.2 <= size p & gcdp p q %= e.1 * p + e.2 * q].\nProof.\nelim=> [|k ihk] p q /= qn0; first by rewrite size_poly_leq0 (negPf qn0).\nmove=> sqSn qsp; rewrite (negPf qn0).\nhave sp : size p > 0 by apply: leq_trans qsp; rewrite size_poly_gt0.\nhave [r0 | rn0] /= := eqVneq (p %%q) 0.\n  rewrite r0 /egcdp_rec; case: k ihk sqSn => [|n] ihn sqSn /=.\n    rewrite !scaler0 !mul0r subr0 add0r mul1r size_poly0 size_poly1.\n    by rewrite dvdp_gcd_idr /dvdp ?r0.\n  rewrite !eqxx mul0r scaler0 /= mul0r add0r subr0 mul1r size_poly0 size_poly1.\n  by rewrite dvdp_gcd_idr /dvdp ?r0 //.\nhave h1 : size (p %% q) <= k.\n  by rewrite -ltnS; apply: leq_trans sqSn; rewrite ltn_modp.\nhave h2 : size (p %% q) <= size q by rewrite ltnW // ltn_modp.\nhave := ihk q (p %% q) rn0 h1 h2.\ncase: (egcdp_rec _ _)=> u v /= => [[ihn'1 ihn'2 ihn'3]].\nrewrite gcdpE ltnNge qsp //= (eqp_ltrans (gcdpC _ _)); split; last first.\n- apply: (eqp_trans ihn'3).\n  rewrite mulrBl addrCA -scalerAl scalerAr -mulrA -mulrBr.\n  by rewrite divp_eq addrAC subrr add0r eqpxx.\n- apply: (leq_trans (size_polyD _ _)).\n  have [-> | vn0] := eqVneq v 0.\n    rewrite mul0r size_polyN size_poly0 maxn0; apply: leq_trans ihn'1 _.\n    exact: leq_modp.\n  have [-> | qqn0] := eqVneq (p %/ q) 0.\n    rewrite mulr0 size_polyN size_poly0 maxn0; apply: leq_trans ihn'1 _.\n    exact: leq_modp.\n  rewrite geq_max (leq_trans ihn'1) ?leq_modp //= size_polyN size_mul //.\n  move: (ihn'2); rewrite (polySpred vn0) (polySpred qn0).\n  rewrite -(ltn_add2r (size (p %/ q))) !addSn /= ltnS; move/leq_trans; apply.\n  rewrite size_divp // addnBA ?addKn //.\n  by apply: leq_trans qsp; apply: leq_pred.\n- by rewrite size_scale // lc_expn_scalp_neq0.\nQed.",
    "Lemma egcdpP p q : p != 0 -> q != 0 -> forall (e := egcdp p q),\n  [/\\ size e.1 <= size q, size e.2 <= size p & gcdp p q %= e.1 * p + e.2 * q].\nProof.\nrewrite /egcdp => pn0 qn0; case: (leqP (size q) (size p)) => /= [|/ltnW] hp.\n  exact: egcdp_recP.\ncase: (egcdp_recP pn0 (leqnn (size p)) hp) => h1 h2 h3; split => //.\nby rewrite (eqp_ltrans (gcdpC _ _)) addrC.\nQed.",
    "Lemma egcdpE p q (e := egcdp p q) : gcdp p q %= e.1 * p + e.2 * q.\nProof.\nrewrite {}/e; have [-> /= | qn0] := eqVneq q 0.\n  by rewrite gcdp0 egcdp0 mul1r mulr0 addr0.\nhave [-> | pn0] := eqVneq p 0; last by case: (egcdpP pn0 qn0).\nby rewrite gcd0p /egcdp size_poly0 size_poly_leq0 (negPf qn0) /= !simp.\nQed.",
    "Lemma Bezoutp p q : exists u, u.1 * p + u.2 * q %= (gcdp p q).\nProof.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite gcd0p; exists (0, 1); rewrite mul0r mul1r add0r.\nhave [-> | qn0] := eqVneq q 0.\n  by rewrite gcdp0; exists (1, 0); rewrite mul0r mul1r addr0.\npose e := egcdp p q; exists e; rewrite eqp_sym.\nby case: (egcdpP pn0 qn0).\nQed.",
    "Lemma Bezout_coprimepP p q :\n  reflect (exists u, u.1 * p + u.2 * q %= 1) (coprimep p q).\nProof.\nrewrite -gcdp_eqp1; apply: (iffP idP)=> [g1|].\n  by case: (Bezoutp p q) => [[u v] Puv]; exists (u, v); apply: eqp_trans g1.\ncase=> [[u v]]; rewrite eqp_sym=> Puv; rewrite /eqp (eqp_dvdr _ Puv).\nby rewrite dvdp_addr dvdp_mull ?dvdp_gcdl ?dvdp_gcdr //= dvd1p.\nQed.",
    "Lemma coprimep_root p q x : coprimep p q -> root p x -> q.[x] != 0.\nProof.\ncase/Bezout_coprimepP=> [[u v] euv] px0.\nmove/eqpP: euv => [[c1 c2]] /andP /= [c1n0 c2n0 e].\nsuffices: c1 * (v.[x] * q.[x]) != 0.\n  by rewrite !mulf_eq0 !negb_or c1n0 /=; case/andP.\nhave := f_equal (horner^~ x) e; rewrite /= !hornerZ hornerD.\nby rewrite !hornerM (eqP px0) mulr0 add0r hornerC mulr1; move->.\nQed.",
    "Lemma Gauss_dvdpl p q d: coprimep d q -> (d %| p * q) = (d %| p).\nProof.\nmove/Bezout_coprimepP=>[[u v] Puv]; apply/idP/idP; last exact: dvdp_mulr.\nmove/(eqp_mull p): Puv; rewrite mulr1 mulrDr eqp_sym=> peq dpq.\nrewrite (eqp_dvdr _ peq) dvdp_addr; first by rewrite mulrA mulrAC dvdp_mulr.\nby rewrite mulrA dvdp_mull ?dvdpp.\nQed.",
    "Lemma Gauss_dvdpr p q d: coprimep d q -> (d %| q * p) = (d %| p).\nProof. by rewrite mulrC; apply: Gauss_dvdpl. Qed.",
    "Lemma Gauss_dvdp m n p : coprimep m n -> (m * n %| p) = (m %| p) && (n %| p).\nProof.\nhave [-> | mn0] := eqVneq m 0.\n  by rewrite coprime0p => /eqp_dvdl->; rewrite !mul0r dvd0p dvd1p andbT.\nhave [-> | nn0] := eqVneq n 0.\n  by rewrite coprimep0 => /eqp_dvdl->; rewrite !mulr0 dvd1p.\nmove=> hc; apply/idP/idP => [mnmp | /andP [dmp dnp]].\n  move/Gauss_dvdpl: hc => <-; move: (dvdp_mull m mnmp); rewrite dvdp_mul2l //.\n  move->; move: (dvdp_mulr n mnmp); rewrite dvdp_mul2r // andbT.\n  exact: dvdp_mulr.\nmove: (dnp); rewrite dvdp_eq.\nset c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> e2.\nhave/esym := Gauss_dvdpl q2 hc; rewrite -e2.\nhave -> : m %| c2 *: p by rewrite -mul_polyC dvdp_mull.\nrewrite dvdp_eq; set c3 := _ ^+ _; set q3 := _ %/ _; move/eqP=> e3.\napply: (@eq_dvdp (c3 * c2) q3).\n  by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\nby rewrite mulrA -e3 -scalerAl -e2 scalerA.\nQed.",
    "Lemma Gauss_gcdpr p m n : coprimep p m -> gcdp p (m * n) %= gcdp p n.\nProof.\nmove=> co_pm; apply/eqP; rewrite /eqp !dvdp_gcd !dvdp_gcdl /= andbC.\nrewrite dvdp_mull ?dvdp_gcdr // -(@Gauss_dvdpl _ m).\n  by rewrite mulrC dvdp_gcdr.\napply/coprimepP=> d; rewrite dvdp_gcd; case/andP=> hdp _ hdm.\nby move/coprimepP: co_pm; apply.\nQed.",
    "Lemma Gauss_gcdpl p m n : coprimep p n -> gcdp p (m * n) %= gcdp p m.\nProof. by move=> co_pn; rewrite mulrC Gauss_gcdpr. Qed.",
    "Lemma coprimepMr p q r : coprimep p (q * r) = (coprimep p q && coprimep p r).\nProof.\napply/coprimepP/andP=> [hp | [/coprimepP-hq hr]].\n  by split; apply/coprimepP=> d dp dq; rewrite hp //;\n     [apply/dvdp_mulr | apply/dvdp_mull].\nmove=> d dp dqr; move/(_ _ dp) in hq.\nrewrite Gauss_dvdpl in dqr; first exact: hq.\nby move/coprimep_dvdr: hr; apply.\nQed.",
    "Lemma coprimepMl p q r: coprimep (q * r) p = (coprimep q p && coprimep r p).\nProof. by rewrite ![coprimep _ p]coprimep_sym coprimepMr. Qed.",
    "Lemma modp_coprime k u n : k != 0 -> (k * u) %% n %= 1 -> coprimep k n.\nProof.\nmove=> kn0 hmod; apply/Bezout_coprimepP.\nexists (((lead_coef n)^+(scalp (k * u) n) *: u), (- (k * u %/ n))).\nrewrite -scalerAl mulrC (divp_eq (u * k) n) mulNr -addrAC subrr add0r.\nby rewrite mulrC.\nQed.",
    "Lemma coprimep_pexpl k m n : 0 < k -> coprimep (m ^+ k) n = coprimep m n.\nProof.\ncase: k => // k _; elim: k => [|k IHk]; first by rewrite expr1.\nby rewrite exprS coprimepMl -IHk andbb.\nQed.",
    "Lemma coprimep_pexpr k m n : 0 < k -> coprimep m (n ^+ k) = coprimep m n.\nProof. by move=> k_gt0; rewrite !(coprimep_sym m) coprimep_pexpl. Qed.",
    "Lemma coprimep_expl k m n : coprimep m n -> coprimep (m ^+ k) n.\nProof. by case: k => [|k] co_pm; rewrite ?coprime1p // coprimep_pexpl. Qed.",
    "Lemma coprimep_expr k m n : coprimep m n -> coprimep m (n ^+ k).\nProof. by rewrite !(coprimep_sym m); apply: coprimep_expl. Qed.",
    "Lemma gcdp_mul2l p q r : gcdp (p * q) (p * r) %= (p * gcdp q r).\nProof.\nhave [->|hp] := eqVneq p 0; first by rewrite !mul0r gcdp0 eqpxx.\nrewrite /eqp !dvdp_gcd !dvdp_mul2l // dvdp_gcdr dvdp_gcdl !andbT.\nmove: (Bezoutp q r) => [[u v]] huv.\nrewrite eqp_sym in huv; rewrite (eqp_dvdr _ (eqp_mull _ huv)).\nrewrite mulrDr ![p * (_ * _)]mulrCA.\nby apply: dvdp_add; rewrite dvdp_mull// (dvdp_gcdr, dvdp_gcdl).\nQed.",
    "Lemma gcdp_mul2r q r p : gcdp (q * p) (r * p) %= gcdp q r * p.\nProof. by rewrite ![_ * p]mulrC gcdp_mul2l. Qed.",
    "Lemma mulp_gcdr p q r : r * (gcdp p q) %= gcdp (r * p) (r * q).\nProof. by rewrite eqp_sym gcdp_mul2l. Qed.",
    "Lemma mulp_gcdl p q r : (gcdp p q) * r %= gcdp (p * r) (q * r).\nProof. by rewrite eqp_sym gcdp_mul2r. Qed.",
    "Lemma coprimep_div_gcd p q : (p != 0) || (q != 0) ->\n  coprimep (p %/ (gcdp p q)) (q %/ gcdp p q).\nProof.\nrewrite -negb_and -gcdp_eq0 -gcdp_eqp1 => gpq0.\nrewrite -(@eqp_mul2r (gcdp p q)) // mul1r (eqp_ltrans (mulp_gcdl _ _ _)).\nhave: gcdp p q %| p by rewrite dvdp_gcdl.\nhave: gcdp p q %| q by rewrite dvdp_gcdr.\nrewrite !dvdp_eq => /eqP <- /eqP <-.\nhave lcn0 k : (lead_coef (gcdp p q)) ^+ k != 0.\n  by rewrite expf_neq0 ?lead_coef_eq0.\nby apply: eqp_gcd; rewrite ?eqp_scale.\nQed.",
    "Lemma divp_eq0 p q : (p %/ q == 0) = [|| p == 0, q ==0 | size p < size q].\nProof.\napply/eqP/idP=> [d0|]; last first.\n  case/or3P; [by move/eqP->; rewrite div0p| by move/eqP->; rewrite divp0|].\n  by move/divp_small.\ncase: eqVneq => // _; case: eqVneq => // qn0.\nmove: (divp_eq p q); rewrite d0 mul0r add0r.\nmove/(f_equal (fun x : {poly R} => size x)).\nby rewrite size_scale ?lc_expn_scalp_neq0 // => ->; rewrite ltn_modp qn0 !orbT.\nQed.",
    "Lemma dvdp_div_eq0 p q : q %| p -> (p %/ q == 0) = (p == 0).\nProof.\nmove=> dvdp_qp; have [->|p_neq0] := eqVneq p 0; first by rewrite div0p eqxx.\nrewrite divp_eq0 ltnNge dvdp_leq // (negPf p_neq0) orbF /=.\nby apply: contraTF dvdp_qp=> /eqP ->; rewrite dvd0p.\nQed.",
    "Lemma Bezout_coprimepPn p q : p != 0 -> q != 0 ->\n  reflect (exists2 uv : {poly R} * {poly R},\n    (0 < size uv.1 < size q) && (0 < size uv.2 < size p) &\n      uv.1 * p = uv.2 * q)\n    (~~ (coprimep p q)).\nProof.\nmove=> pn0 qn0; apply: (iffP idP); last first.\n  case=> [[u v] /= /andP [/andP [ps1 s1] /andP [ps2 s2]] e].\n  have: ~~(size (q * p) <= size (u * p)).\n    rewrite -ltnNge !size_mul // -?size_poly_gt0 // (polySpred pn0) !addnS.\n    by rewrite ltn_add2r.\n  apply: contra => ?; apply: dvdp_leq; rewrite ?mulf_neq0 // -?size_poly_gt0 //.\n  by rewrite mulrC Gauss_dvdp // dvdp_mull // e dvdp_mull.\nrewrite coprimep_def neq_ltn ltnS size_poly_leq0 gcdp_eq0.\nrewrite (negPf pn0) (negPf qn0) /=.\ncase sg: (size (gcdp p q)) => [|n] //; case: n sg=> [|n] // sg _.\nmove: (dvdp_gcdl p q); rewrite dvdp_eq; set c1 := _ ^+ _; move/eqP=> hu1.\nmove: (dvdp_gcdr p q); rewrite dvdp_eq; set c2 := _ ^+ _; move/eqP=> hv1.\nexists (c1 *: (q %/ gcdp p q), c2 *: (p %/ gcdp p q)); last first.\n  by rewrite -!scalerAl !scalerAr hu1 hv1 mulrCA.\nrewrite !size_scale ?lc_expn_scalp_neq0 //= !size_poly_gt0 !divp_eq0.\nrewrite gcdp_eq0 !(negPf pn0) !(negPf qn0) /= -!leqNgt leq_gcdpl //.\nrewrite leq_gcdpr //= !ltn_divpl -?size_poly_eq0 ?sg //.\nrewrite !size_mul // -?size_poly_eq0 ?sg // ![(_ + n.+2)%N]addnS /=.\nby rewrite -!(addn1 (size _)) !leq_add2l.\nQed.",
    "Lemma dvdp_pexp2r m n k : k > 0 -> (m ^+ k %| n ^+ k) = (m %| n).\nProof.\nmove=> k_gt0; apply/idP/idP; last exact: dvdp_exp2r.\nhave [-> // | nn0] := eqVneq n 0; have [-> | mn0] := eqVneq m 0.\n  move/prednK: k_gt0=> {1}<-; rewrite exprS mul0r //= !dvd0p expf_eq0.\n  by case/andP=> _ ->.\nset d := gcdp m n; have := dvdp_gcdr m n; rewrite -/d dvdp_eq.\nset c1 := _ ^+ _; set n' := _ %/ _; move/eqP=> def_n.\nhave := dvdp_gcdl m n; rewrite -/d dvdp_eq.\nset c2 := _ ^+ _; set m' := _ %/ _; move/eqP=> def_m.\nhave dn0 : d != 0 by rewrite gcdp_eq0 negb_and nn0 orbT.\nhave c1n0 : c1 != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nhave c2n0 : c2 != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nhave c2k_n0 : c2 ^+ k != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nrewrite -(@dvdpZr (c1 ^+ k)) ?expf_neq0 ?lead_coef_eq0 //.\nrewrite -(@dvdpZl (c2 ^+ k)) // -!exprZn def_m def_n !exprMn.\nrewrite dvdp_mul2r ?expf_neq0 //.\nhave: coprimep (m' ^+ k) (n' ^+ k).\n  by rewrite coprimep_pexpl // coprimep_pexpr // coprimep_div_gcd ?mn0.\nmove/coprimepP=> hc hd.\nhave /size_poly1P [c cn0 em'] : size m' == 1.\n  case: (eqVneq m' 0) def_m => [-> /eqP | m'_n0 def_m].\n    by rewrite mul0r scale_poly_eq0 (negPf mn0) (negPf c2n0).\n  have := hc _ (dvdpp _) hd; rewrite -size_poly_eq1.\n  rewrite polySpred; last by rewrite expf_eq0 negb_and m'_n0 orbT.\n  by rewrite size_exp eqSS muln_eq0 orbC eqn0Ngt k_gt0 /= -eqSS -polySpred.\nrewrite -(@dvdpZl c2) // def_m em' mul_polyC dvdpZl //.\nby rewrite -(@dvdpZr c1) // def_n dvdp_mull.\nQed.",
    "Lemma root_gcd p q x : root (gcdp p q) x = root p x && root q x.\nProof.\nrewrite /= !root_factor_theorem; apply/idP/andP=> [dg| [dp dq]].\n  by split; apply: dvdp_trans dg _; rewrite ?(dvdp_gcdl, dvdp_gcdr).\nhave:= Bezoutp p q => [[[u v]]]; rewrite eqp_sym=> e.\nby rewrite (eqp_dvdr _ e) dvdp_addl dvdp_mull.\nQed.",
    "Lemma root_biggcd x (ps : seq {poly R}) :\n  root (\\big[gcdp/0]_(p <- ps) p) x = all (fun p => root p x) ps.\nProof.\nelim: ps => [|p ps ihp]; first by rewrite big_nil root0.\nby rewrite big_cons /= root_gcd ihp.\nQed.",
    "Lemma gdcop0 q : gdcop q 0 = (q == 0)%:R.\nProof. by rewrite /gdcop size_poly0. Qed.",
    "Lemma gdcop_recP q p k : size p <= k -> gdcop_spec q p (gdcop_rec q p k).\nProof.\nelim: k p => [p | k ihk p] /=.\n  move/size_poly_leq0P->.\n  have [->|q0] := eqVneq; split; rewrite ?coprime1p // ?eqxx ?orbT //.\n  by move=> d _; rewrite coprimep0 dvdp1 size_poly_eq1.\nmove=> hs; case cop : (coprimep _ _); first by split; rewrite ?dvdpp ?cop.\nhave [-> | p0] := eqVneq p 0.\n  by rewrite div0p; apply: ihk; rewrite size_poly0 leq0n.\nhave [-> | q0] := eqVneq q 0.\n  rewrite gcdp0 divpp ?p0 //= => {hs ihk}; case: k=> /=.\n    rewrite eqxx; split; rewrite ?dvd1p ?coprimep0 ?eqpxx //=.\n    by move=> d _; rewrite coprimep0 dvdp1 size_poly_eq1.\n  move=> n; rewrite coprimep0 polyC_eqp1 //; rewrite lc_expn_scalp_neq0.\n  split; first by rewrite (@eqp_dvdl 1) ?dvd1p // polyC_eqp1 lc_expn_scalp_neq0.\n    by rewrite coprimep0 polyC_eqp1 // ?lc_expn_scalp_neq0.\n  by move=> d _; rewrite coprimep0; move/eqp_dvdl->; rewrite dvd1p.\nmove: (dvdp_gcdl p q); rewrite dvdp_eq; move/eqP=> e.\nhave sgp : size (gcdp p q) <= size p.\n  by apply: dvdp_leq; rewrite ?gcdp_eq0 ?p0 ?q0 // dvdp_gcdl.\nhave : p %/ gcdp p q != 0; last move/negPf=>p'n0.\n  apply: dvdpN0 (dvdp_mulIl (p %/ gcdp p q) (gcdp p q)) _.\n  by rewrite -e scale_poly_eq0 negb_or lc_expn_scalp_neq0.\nhave gn0 : gcdp p q != 0.\n  apply: dvdpN0 (dvdp_mulIr (p %/ gcdp p q) (gcdp p q)) _.\n  by rewrite -e scale_poly_eq0 negb_or lc_expn_scalp_neq0.\nhave sp' : size (p %/ (gcdp p q)) <= k.\n  rewrite size_divp ?sgp // leq_subLR (leq_trans hs) // -add1n leq_add2r -subn1.\n  by rewrite ltn_subRL add1n ltn_neqAle eq_sym [_ == _]cop size_poly_gt0 gn0.\ncase (ihk _ sp')=> r' dr'p'; first rewrite p'n0 orbF=> cr'q maxr'.\nconstructor=> //=; rewrite ?(negPf p0) ?orbF //.\n  exact/(dvdp_trans dr'p')/divp_dvd/dvdp_gcdl.\nmove=> d dp cdq; apply: maxr'; last by rewrite cdq.\ncase dpq: (d %| gcdp p q).\n  move: (dpq); rewrite dvdp_gcd dp /= => dq; apply: dvdUp.\n  apply: contraLR cdq => nd1; apply/coprimepPn; last first.\n    by exists d; rewrite dvdp_gcd dvdpp dq nd1.\n  by apply: contraNneq p0 => d0; move: dp; rewrite d0 dvd0p.\napply: contraLR dp => ndp'.\nrewrite (@eqp_dvdr ((lead_coef (gcdp p q) ^+ scalp p (gcdp p q))*:p)).\n  by rewrite e; rewrite Gauss_dvdpl //; apply: (coprimep_dvdl (dvdp_gcdr _ _)).\nby rewrite eqp_sym eqp_scale // lc_expn_scalp_neq0.\nQed.",
    "Lemma gdcopP q p : gdcop_spec q p (gdcop q p).\nProof. by rewrite /gdcop; apply: gdcop_recP. Qed.",
    "Lemma coprimep_gdco p q : (q != 0)%B -> coprimep (gdcop p q) p.\nProof. by move=> q_neq0; case: gdcopP=> d; rewrite (negPf q_neq0) orbF. Qed.",
    "Lemma size2_dvdp_gdco p q d : p != 0 -> size d = 2 ->\n  (d %| (gdcop q p)) = (d %| p) && ~~(d %| q).\nProof.\nhave [-> | dn0] := eqVneq d 0; first by rewrite size_poly0.\nmove=> p0 sd; apply/idP/idP.\n  case: gdcopP=> r rp crq maxr dr; move/negPf: (p0)=> p0f.\n  rewrite (dvdp_trans dr) //=.\n  apply: contraL crq => dq; rewrite p0f orbF; apply/coprimepPn.\n    by apply: contraNneq p0 => r0; move: rp; rewrite r0 dvd0p.\n  by exists d; rewrite dvdp_gcd dr dq -size_poly_eq1 sd.\ncase/andP=> dp dq; case: gdcopP=> r rp crq maxr; apply: maxr=> //.\napply/coprimepP=> x xd xq.\nmove: (dvdp_leq dn0 xd); rewrite leq_eqVlt sd; case/orP; last first.\n  rewrite ltnS leq_eqVlt ltnS size_poly_leq0 orbC.\n  case/predU1P => [x0|]; last by rewrite -size_poly_eq1.\n  by move: xd; rewrite x0 dvd0p (negPf dn0).\nby rewrite -sd dvdp_size_eqp //; move/(eqp_dvdl q); rewrite xq (negPf dq).\nQed.",
    "Lemma dvdp_gdco p q : (gdcop p q) %| q. Proof. by case: gdcopP. Qed.",
    "Lemma root_gdco p q x : p != 0 -> root (gdcop q p) x = root p x && ~~(root q x).\nProof.\nmove=> p0 /=; rewrite !root_factor_theorem.\napply: size2_dvdp_gdco; rewrite ?p0 //.\nby rewrite size_polyDl size_polyX // size_polyN size_polyC ltnS; case: (x != 0).\nQed.",
    "Lemma dvdp_comp_poly r p q : (p %| q) -> (p \\Po r) %| (q \\Po r).\nProof.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite comp_poly0 !dvd0p; move/eqP->; rewrite comp_poly0.\nrewrite dvdp_eq; set c := _ ^+ _; set s := _ %/ _; move/eqP=> Hq.\napply: (@eq_dvdp c (s \\Po r)); first by rewrite expf_neq0 // lead_coef_eq0.\nby rewrite -comp_polyZ Hq comp_polyM.\nQed.",
    "Lemma gcdp_comp_poly r p q : gcdp p q \\Po r %= gcdp (p \\Po r) (q \\Po r).\nProof.\napply/andP; split.\n  by rewrite dvdp_gcd !dvdp_comp_poly ?dvdp_gcdl ?dvdp_gcdr.\ncase: (Bezoutp p q) => [[u v]] /andP [].\nmove/(dvdp_comp_poly r) => Huv _.\nrewrite (dvdp_trans _ Huv) // comp_polyD !comp_polyM.\nby rewrite dvdp_add // dvdp_mull // (dvdp_gcdl,dvdp_gcdr).\nQed.",
    "Lemma coprimep_comp_poly r p q : coprimep p q -> coprimep (p \\Po r) (q \\Po r).\nProof.\nrewrite -!gcdp_eqp1 -!size_poly_eq1 -!dvdp1; move/(dvdp_comp_poly r).\nrewrite comp_polyC => Hgcd.\nby apply: dvdp_trans Hgcd; case/andP: (gcdp_comp_poly r p q).\nQed.",
    "Lemma coprimep_addl_mul p q r : coprimep r (p * r + q) = coprimep r q.\nProof. by rewrite !coprimep_def (eqp_size (gcdp_addl_mul _ _ _)). Qed.",
    "Lemma irredp_neq0 p : irreducible_poly p -> p != 0.\nProof. by rewrite -size_poly_gt0 => [[/ltnW]]. Qed.",
    "Lemma modp_XsubC p c : p %% ('X - c%:P) = p.[c]%:P.\nProof.\nhave/factor_theorem [q /(canRL (subrK _)) Dp]: root (p - p.[c]%:P) c.\n  by rewrite /root !hornerE subrr.\nrewrite modpE /= lead_coefXsubC unitr1 expr1n invr1 scale1r [in LHS]Dp.\nrewrite RingMonic.rmodp_addl_mul_small // ?monicXsubC// size_XsubC size_polyC.\nby case: (p.[c] == 0).\nQed.",
    "Lemma coprimep_XsubC p c : coprimep p ('X - c%:P) = ~~ root p c.\nProof.\nrewrite -coprimep_modl modp_XsubC /root -alg_polyC.\nhave [-> | /coprimepZl->] := eqVneq; last exact: coprime1p.\nby rewrite scale0r /coprimep gcd0p size_XsubC.\nQed.",
    "Lemma coprimep_XsubC2 (a b : R) : b - a != 0 ->\n  coprimep ('X - a%:P) ('X - b%:P).\nProof. by move=> bBa_neq0; rewrite coprimep_XsubC rootE hornerXsubC. Qed.",
    "Lemma coprimepX p : coprimep p 'X = ~~ root p 0.\nProof. by rewrite -['X]subr0 coprimep_XsubC. Qed.",
    "Lemma eqp_monic : {in monic &, forall p q, (p %= q) = (p == q)}.\nProof.\nmove=> p q monic_p monic_q; apply/idP/eqP=> [|-> //].\ncase/eqpP=> [[a b] /= /andP[a_neq0 _] eq_pq].\napply: (@mulfI _ a%:P); first by rewrite polyC_eq0.\nrewrite !mul_polyC eq_pq; congr (_ *: q); apply: (mulIf (oner_neq0 _)).\nby rewrite -[in LHS](monicP monic_q) -(monicP monic_p) -!lead_coefZ eq_pq.\nQed.",
    "Lemma dvdp_mul_XsubC p q c :\n  (p %| ('X - c%:P) * q) = ((if root p c then p %/ ('X - c%:P) else p) %| q).\nProof.\ncase: ifPn => [| not_pc0]; last by rewrite Gauss_dvdpr ?coprimep_XsubC.\nrewrite root_factor_theorem -eqp_div_XsubC mulrC => /eqP{1}->.\nby rewrite dvdp_mul2l ?polyXsubC_eq0.\nQed.",
    "Lemma dvdp_prod_XsubC (I : Type) (r : seq I) (F : I -> R) p :\n    p %| \\prod_(i <- r) ('X - (F i)%:P) ->\n  {m | p %= \\prod_(i <- mask m r) ('X - (F i)%:P)}.\nProof.\nelim: r => [|i r IHr] in p *.\n  by rewrite big_nil dvdp1; exists nil; rewrite // big_nil -size_poly_eq1.\nrewrite big_cons dvdp_mul_XsubC root_factor_theorem -eqp_div_XsubC.\ncase: eqP => [{2}-> | _] /IHr[m Dp]; last by exists (false :: m).\nby exists (true :: m); rewrite /= mulrC big_cons eqp_mul2l ?polyXsubC_eq0.\nQed.",
    "Lemma irredp_XsubC (x : R) : irreducible_poly ('X - x%:P).\nProof.\nsplit=> [|d size_d d_dv_Xx]; first by rewrite size_XsubC.\nhave: ~ d %= 1 by apply/negP; rewrite -size_poly_eq1.\nhave [|m /=] := @dvdp_prod_XsubC _ [:: x] id d; first by rewrite big_seq1.\nby case: m => [|[] [|_ _] /=]; rewrite (big_nil, big_seq1).\nQed.",
    "Lemma irredp_XaddC (x : R) : irreducible_poly ('X + x%:P).\nProof. by rewrite -[x]opprK rmorphN; apply: irredp_XsubC. Qed.",
    "Lemma irredp_XsubCP d p :\n  irreducible_poly p -> d %| p -> {d %= 1} + {d %= p}.\nProof.\nmove=> irred_p dvd_dp; have [] := boolP (_ %= 1); first by left.\nby rewrite -size_poly_eq1=> /irred_p /(_ dvd_dp); right.\nQed.",
    "Lemma dvdp_exp_XsubCP (p : {poly R}) (c : R) (n : nat) :\n  reflect (exists2 k, (k <= n)%N & p %= ('X - c%:P) ^+ k)\n          (p %| ('X - c%:P) ^+ n).\nProof.\napply: (iffP idP) => [|[k lkn /eqp_dvdl->]]; last by rewrite dvdp_exp2l.\nmove=> /Pdiv.WeakIdomain.dvdpP[[/= a q] a_neq0].\nhave [m [r]] := multiplicity_XsubC p c; have [->|pN0]/= := eqVneq p 0.\n  rewrite mulr0 => _ _ /eqP;  rewrite scale_poly_eq0 (negPf a_neq0)/=.\n  by rewrite expf_eq0/= andbC polyXsubC_eq0.\nmove=> rNc ->; rewrite mulrA => eq_qrm; exists m.\n  have: ('X - c%:P) ^+ m %| a *: ('X - c%:P) ^+ n by rewrite eq_qrm dvdp_mull.\n  by rewrite (eqp_dvdr _ (eqp_scale _ _))// dvdp_Pexp2l// size_XsubC.\nsuff /eqP : size r = 1%N.\n  by rewrite size_poly_eq1 => /eqp_mulr/eqp_trans->//; rewrite mul1r eqpxx.\nhave : r %| a *: ('X - c%:P) ^+ n by rewrite eq_qrm mulrAC dvdp_mull.\nrewrite (eqp_dvdr _ (eqp_scale _ _))//.\nmove: rNc; rewrite -coprimep_XsubC => /(coprimep_expr n) /coprimepP.\nby move=> /(_ _ (dvdpp _)); rewrite -size_poly_eq1 => /(_ _)/eqP.\nQed.",
    "Lemma divpE p : p %/ q = rdivp p q.\nProof. by rewrite divpE (eqP monq) unitr1 expr1n invr1 scale1r. Qed.",
    "Lemma modpE p : p %% q = rmodp p q.\nProof. by rewrite modpE (eqP monq) unitr1 expr1n invr1 scale1r. Qed.",
    "Lemma scalpE p : scalp p q = 0.\nProof. by rewrite scalpE (eqP monq) unitr1. Qed.",
    "Lemma divp_eq p : p = (p %/ q) * q + (p %% q).\nProof. by rewrite -divp_eq (eqP monq) expr1n scale1r. Qed.",
    "Lemma divpp p : q %/ q = 1.\nProof. by rewrite divpp ?monic_neq0 // (eqP monq) expr1n. Qed.",
    "Lemma dvdp_eq p : (q %| p) = (p == (p %/ q) * q).\nProof. by rewrite dvdp_eq (eqP monq) expr1n scale1r. Qed.",
    "Lemma dvdpP p : reflect (exists qq, p = qq * q) (q %| p).\nProof.\napply: (iffP idP); first by rewrite dvdp_eq; move/eqP=> e; exists (p %/ q).\nby case=> qq ->; rewrite dvdp_mull // dvdpp.\nQed.",
    "Lemma mulpK p : p * q %/ q = p.\nProof. by rewrite mulpK ?monic_neq0 // (eqP monq) expr1n scale1r. Qed.",
    "Lemma mulKp p : q * p %/ q = p. Proof. by rewrite mulrC mulpK. Qed.",
    "Lemma drop_poly_divp n p : drop_poly n p = p %/ 'X^n.\nProof. by rewrite RingMonic.drop_poly_rdivp divpE // monicXn. Qed.",
    "Lemma take_poly_modp n p : take_poly n p = p %% 'X^n.\nProof. by rewrite RingMonic.take_poly_rmodp modpE // monicXn. Qed.",
    "Lemma divp_eq p : p = (p %/ d) * d + (p %% d).\nProof. by have := divp_eq p d; rewrite scalpE ulcd expr0 scale1r. Qed.",
    "Lemma edivpP p q r : p = q * d + r -> size r < size d ->\n  q = (p %/ d) /\\ r = p %% d.\nProof.\nmove=> ep srd; have := divp_eq p; rewrite [LHS]ep.\nmove/eqP; rewrite -subr_eq -addrA addrC eq_sym -subr_eq -mulrBl; move/eqP.\nhave lcdn0 : lead_coef d != 0 by apply: contraTneq ulcd => ->; rewrite unitr0.\nhave [-> /esym /eqP|abs] := eqVneq (p %/ d) q.\n  by rewrite subrr mul0r subr_eq0 => /eqP<-.\nhave hleq : size d <= size ((p %/ d - q) * d).\n  rewrite size_proper_mul; last first.\n    by rewrite mulf_eq0 (negPf lcdn0) orbF lead_coef_eq0 subr_eq0.\n  by move: abs; rewrite -subr_eq0; move/polySpred->; rewrite addSn /= leq_addl.\nhave hlt : size (r - p %% d) < size d.\n  apply: leq_ltn_trans (size_polyD _ _) _.\n  by rewrite gtn_max srd size_polyN ltn_modp -lead_coef_eq0.\nby move=> e; have:= leq_trans hlt hleq; rewrite e ltnn.\nQed.",
    "Lemma divpP p q r : p = q * d + r -> size r < size d -> q = (p %/ d).\nProof. by move/edivpP=> h; case/h. Qed.",
    "Lemma modpP p q r : p = q * d + r -> size r < size d -> r = (p %% d).\nProof. by move/edivpP=> h; case/h. Qed.",
    "Lemma ulc_eqpP p q : lead_coef q \\is a GRing.unit ->\n  reflect (exists2 c : R, c != 0 & p = c *: q) (p %= q).\nProof.\nhave [->|] := eqVneq (lead_coef q) 0; first by rewrite unitr0.\nrewrite lead_coef_eq0 => nz_q ulcq; apply: (iffP idP).\n  have [->|nz_p] := eqVneq p 0; first by rewrite eqp_sym eqp0 (negPf nz_q).\n  move/eqp_eq=> eq; exists (lead_coef p / lead_coef q).\n    by rewrite mulf_neq0 // ?invr_eq0 lead_coef_eq0.\n  by apply/(scaler_injl ulcq); rewrite scalerA mulrCA divrr // mulr1.\nby case=> c nz_c ->; apply/eqpP; exists (1, c); rewrite ?scale1r ?oner_eq0.\nQed.",
    "Lemma dvdp_eq p : (d %| p) = (p == p %/ d * d).\nProof.\napply/eqP/eqP=> [modp0 | ->]; last exact: modp_mull.\nby rewrite [p in LHS]divp_eq modp0 addr0.\nQed.",
    "Lemma ucl_eqp_eq p q : lead_coef q \\is a GRing.unit ->\n  p %= q -> p = (lead_coef p / lead_coef q) *: q.\nProof.\nmove=> ulcq /eqp_eq; move/(congr1 ( *:%R (lead_coef q)^-1 )).\nby rewrite !scalerA mulrC divrr // scale1r mulrC.\nQed.",
    "Lemma modpZl c p : (c *: p) %% d = c *: (p %% d).\nProof.\nhave [-> | cn0] := eqVneq c 0; first by rewrite !scale0r mod0p.\nhave e : (c *: p) = (c *: (p %/ d)) * d + c *: (p %% d).\n  by rewrite -scalerAl -scalerDr -divp_eq.\nsuff s: size (c *: (p %% d)) < size d by case: (edivpP e s) => _ ->.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\nrewrite size_polyC cn0 addSn add0n /= ltn_modp -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed.",
    "Lemma divpZl c p : (c *: p) %/ d = c *: (p %/ d).\nProof.\nhave [-> | cn0] := eqVneq c 0; first by rewrite !scale0r div0p.\nhave e : (c *: p) = (c *: (p %/ d)) * d + c *: (p %% d).\n  by rewrite -scalerAl -scalerDr -divp_eq.\nsuff s: size (c *: (p %% d)) < size d by case: (edivpP e s) => ->.\nrewrite -mul_polyC; apply: leq_ltn_trans (size_polyMleq _ _) _.\nrewrite size_polyC cn0 addSn add0n /= ltn_modp -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed.",
    "Lemma eqp_modpl p q : p %= q -> (p %% d) %= (q %% d).\nProof.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0 e].\nby apply/eqpP; exists (c1, c2); rewrite ?c1n0 //= -!modpZl e.\nQed.",
    "Lemma eqp_divl p q : p %= q -> (p %/ d) %= (q %/ d).\nProof.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0 e].\nby apply/eqpP; exists (c1, c2); rewrite ?c1n0 // -!divpZl e.\nQed.",
    "Lemma modpN p : (- p) %% d = - (p %% d).\nProof. by rewrite -mulN1r -[RHS]mulN1r -polyCN !mul_polyC modpZl. Qed.",
    "Lemma divpN p : (- p) %/ d = - (p %/ d).\nProof. by rewrite -mulN1r -[RHS]mulN1r -polyCN !mul_polyC divpZl. Qed.",
    "Lemma modpD p q : (p + q) %% d = p %% d + q %% d.\nProof.\nhave/edivpP [] // : (p + q) = (p %/ d + q %/ d) * d + (p %% d + q %% d).\n  by rewrite mulrDl addrACA -!divp_eq.\napply: leq_ltn_trans (size_polyD _ _) _.\nrewrite gtn_max !ltn_modp andbb -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed.",
    "Lemma divpD p q : (p + q) %/ d = p %/ d + q %/ d.\nProof.\nhave/edivpP [] // : (p + q) = (p %/ d + q %/ d) * d + (p %% d + q %% d).\n  by rewrite mulrDl addrACA -!divp_eq.\napply: leq_ltn_trans (size_polyD _ _) _.\nrewrite gtn_max !ltn_modp andbb -lead_coef_eq0.\nby apply: contraTneq ulcd => ->; rewrite unitr0.\nQed.",
    "Lemma mulpK q : (q * d) %/ d = q.\nProof.\ncase/esym/edivpP: (addr0 (q * d)); rewrite // size_poly0 size_poly_gt0.\nby rewrite -lead_coef_eq0; apply: contraTneq ulcd => ->; rewrite unitr0.\nQed.",
    "Lemma mulKp q : (d * q) %/ d = q. Proof. by rewrite mulrC; apply: mulpK. Qed.",
    "Lemma divp_addl_mul_small q r : size r < size d -> (q * d + r) %/ d = q.\nProof. by move=> srd; rewrite divpD (divp_small srd) addr0 mulpK. Qed.",
    "Lemma modp_addl_mul_small q r : size r < size d -> (q * d + r) %% d = r.\nProof. by move=> srd; rewrite modpD modp_mull add0r modp_small. Qed.",
    "Lemma divp_addl_mul q r : (q * d + r) %/ d = q + r %/ d.\nProof. by rewrite divpD mulpK. Qed.",
    "Lemma divpp : d %/ d = 1. Proof. by rewrite -[d in d %/ _]mul1r mulpK. Qed.",
    "Lemma leq_divMp m : size (m %/ d * d) <= size m.\nProof.\ncase: (eqVneq d 0) ulcd => [->|dn0 _]; first by rewrite lead_coef0 unitr0.\nhave [->|q0] := eqVneq (m %/ d) 0; first by rewrite mul0r size_poly0 leq0n.\nrewrite {2}(divp_eq m) size_polyDl // size_mul // (polySpred q0) addSn /=.\nby rewrite ltn_addl // ltn_modp.\nQed.",
    "Lemma dvdpP p : reflect (exists q, p = q * d) (d %| p).\nProof.\napply: (iffP idP) => [| [k ->]]; last by apply/eqP; rewrite modp_mull.\nby rewrite dvdp_eq; move/eqP->; exists (p %/ d).\nQed.",
    "Lemma divpK p : d %| p -> p %/ d * d = p.\nProof. by rewrite dvdp_eq; move/eqP. Qed.",
    "Lemma divpKC p : d %| p -> d * (p %/ d) = p.\nProof. by move=> ?; rewrite mulrC divpK. Qed.",
    "Lemma dvdp_eq_div p q : d %| p -> (q == p %/ d) = (q * d == p).\nProof.\nmove/divpK=> {2}<-; apply/eqP/eqP; first by move->.\napply/mulIf; rewrite -lead_coef_eq0; apply: contraTneq ulcd => ->.\nby rewrite unitr0.\nQed.",
    "Lemma dvdp_eq_mul p q : d %| p -> (p == q * d) = (p %/ d == q).\nProof. by move=> dv_d_p; rewrite eq_sym -dvdp_eq_div // eq_sym. Qed.",
    "Lemma divp_mulA p q : d %| q -> p * (q %/ d) = p * q %/ d.\nProof.\nmove=> hdm; apply/eqP; rewrite eq_sym -dvdp_eq_mul.\n  by rewrite -mulrA divpK.\nby move/divpK: hdm<-; rewrite mulrA dvdp_mull // dvdpp.\nQed.",
    "Lemma divp_mulAC m n : d %| m -> m %/ d * n = m * n %/ d.\nProof. by move=> hdm; rewrite mulrC (mulrC m); apply: divp_mulA. Qed.",
    "Lemma divp_mulCA p q : d %| p -> d %| q -> p * (q %/ d) = q * (p %/ d).\nProof. by move=> hdp hdq; rewrite mulrC divp_mulAC // divp_mulA. Qed.",
    "Lemma modp_mul p q : (p * (q %% d)) %% d = (p * q) %% d.\nProof. by rewrite [q in RHS]divp_eq mulrDr modpD mulrA modp_mull add0r. Qed.",
    "Lemma expp_sub m n : n <= m -> (d ^+ (m - n))%N = d ^+ m %/ d ^+ n.\nProof. by move/subnK=> {2}<-; rewrite exprD mulpK // lead_coef_exp unitrX. Qed.",
    "Lemma divp_pmul2l p q : lead_coef q \\in GRing.unit -> d * p %/ (d * q) = p %/ q.\nProof.\nmove=> uq; rewrite {1}(divp_eq uq p) mulrDr mulrCA divp_addl_mul //; last first.\n  by rewrite lead_coefM unitrM_comm ?ulcd //; red; rewrite mulrC.\nhave dn0 : d != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcd => ->; rewrite unitr0.\nhave qn0 : q != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq uq => ->; rewrite unitr0.\nhave dqn0 : d * q != 0 by rewrite mulf_eq0 negb_or dn0.\nsuff : size (d * (p %% q)) < size (d * q).\n  by rewrite ltnNge -divpN0 // negbK => /eqP ->; rewrite addr0.\nhave [-> | rn0] := eqVneq (p %% q) 0.\n  by rewrite mulr0 size_poly0 size_poly_gt0.\nby rewrite !size_mul // (polySpred dn0) !addSn /= ltn_add2l ltn_modp.\nQed.",
    "Lemma divp_pmul2r p q : lead_coef p \\in GRing.unit -> q * d %/ (p * d) = q %/ p.\nProof. by move=> uq; rewrite -!(mulrC d) divp_pmul2l. Qed.",
    "Lemma divp_divl r p q :\n    lead_coef r \\in GRing.unit -> lead_coef p \\in GRing.unit ->\n  q %/ p %/ r = q %/ (p * r).\nProof.\nmove=> ulcr ulcp.\nhave e : q = (q %/ p %/ r) * (p * r) + ((q %/ p) %% r * p + q %% p).\n  by rewrite addrA (mulrC p) mulrA -mulrDl; rewrite -divp_eq //; apply: divp_eq.\nhave pn0 : p != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcp => ->; rewrite unitr0.\nhave rn0 : r != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcr => ->; rewrite unitr0.\nhave s : size ((q %/ p) %% r * p + q %% p) < size (p * r).\n  have [-> | qn0] := eqVneq ((q %/ p) %% r) 0.\n    rewrite mul0r add0r size_mul // (polySpred rn0) addnS /=.\n    by apply: leq_trans (leq_addr _ _); rewrite ltn_modp.\n  rewrite size_polyDl mulrC.\n    by rewrite !size_mul // (polySpred pn0) !addSn /= ltn_add2l ltn_modp.\n  rewrite size_mul // (polySpred qn0) addnS /=.\n  by apply: leq_trans (leq_addr _ _); rewrite ltn_modp.\ncase: (edivpP _ e s) => //; rewrite lead_coefM unitrM_comm ?ulcp //.\nby red; rewrite mulrC.\nQed.",
    "Lemma divpAC p q : lead_coef p \\in GRing.unit -> q %/ d %/ p = q %/ p %/ d.\nProof. by move=> ulcp; rewrite !divp_divl // mulrC. Qed.",
    "Lemma modpZr c p : c \\in GRing.unit -> p %% (c *: d) = (p %% d).\nProof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !modp0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVr // scale1r -(divp_eq ulcd).\nsuff s : size (p %% d) < size (c *: d).\n  by rewrite (modpP _ e s) // -mul_polyC lead_coefM lead_coefC unitrM cn0.\nby rewrite size_scale ?ltn_modp //; apply: contraTneq cn0 => ->; rewrite unitr0.\nQed.",
    "Lemma divpZr c p : c \\in GRing.unit -> p %/ (c *: d) = c^-1 *: (p %/ d).\nProof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !divp0 scaler0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVr // scale1r -(divp_eq ulcd).\nsuff s : size (p %% d) < size (c *: d).\n  by rewrite (divpP _ e s) // -mul_polyC lead_coefM lead_coefC unitrM cn0.\nby rewrite size_scale ?ltn_modp //; apply: contraTneq cn0 => ->; rewrite unitr0.\nQed.",
    "Lemma divp_eq p q : p = (p %/ q) * q + (p %% q).\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite modp0 mulr0 add0r.\nby apply: IdomainUnit.divp_eq; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divp_modpP p q d r : p = q * d + r -> size r < size d ->\n  q = (p %/ d) /\\ r = p %% d.\nProof.\nmove=> he hs; apply: IdomainUnit.edivpP => //; rewrite unitfE lead_coef_eq0.\nby rewrite -size_poly_gt0; apply: leq_trans hs.\nQed.",
    "Lemma divpP p q d r : p = q * d + r -> size r < size d ->\n  q = (p %/ d).\nProof. by move/divp_modpP=> h; case/h. Qed.",
    "Lemma modpP p q d r : p = q * d + r -> size r < size d -> r = (p %% d).\nProof. by move/divp_modpP=> h; case/h. Qed.",
    "Lemma eqpfP p q : p %= q -> p = (lead_coef p / lead_coef q) *: q.\nProof.\nhave [->|nz_q] := eqVneq q 0; first by rewrite eqp0 scaler0 => /eqP ->.\nby apply/IdomainUnit.ucl_eqp_eq; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma dvdp_eq q p : (q %| p) = (p == p %/ q * q).\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite dvd0p mulr0 eq_sym.\nby apply: IdomainUnit.dvdp_eq; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma eqpf_eq p q : reflect (exists2 c, c != 0 & p = c *: q) (p %= q).\nProof.\napply: (iffP idP); last first.\n  case=> c nz_c ->; apply/eqpP.\n  by exists (1, c); rewrite ?scale1r ?oner_eq0.\nhave [->|nz_q] := eqVneq q 0.\n  by rewrite eqp0=> /eqP ->; exists 1; rewrite ?scale1r ?oner_eq0.\ncase/IdomainUnit.ulc_eqpP; first by rewrite unitfE lead_coef_eq0.\nby move=> c nz_c ->; exists c.\nQed.",
    "Lemma modpZl c p q : (c *: p) %% q = c *: (p %% q).\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite !modp0.\nby apply: IdomainUnit.modpZl; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma mulpK p q : q != 0 -> p * q %/ q = p.\nProof. by move=> qn0; rewrite IdomainUnit.mulpK // unitfE lead_coef_eq0. Qed.",
    "Lemma mulKp p q : q != 0 -> q * p %/ q = p.\nProof. by rewrite mulrC; apply: mulpK. Qed.",
    "Lemma divpZl c p q : (c *: p) %/ q = c *: (p %/ q).\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite !divp0 scaler0.\nby apply: IdomainUnit.divpZl; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma modpZr c p d : c != 0 -> p %% (c *: d) = (p %% d).\nProof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !modp0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVf // scale1r -divp_eq.\nsuff s : size (p %% d) < size (c *: d) by rewrite (modpP e s).\nby rewrite size_scale ?ltn_modp.\nQed.",
    "Lemma divpZr c p d : c != 0 -> p %/ (c *: d) = c^-1 *: (p %/ d).\nProof.\ncase: (eqVneq d 0) => [-> | dn0 cn0]; first by rewrite scaler0 !divp0 scaler0.\nhave e : p = (c^-1 *: (p %/ d)) * (c *: d) + (p %% d).\n  by rewrite scalerCA scalerA mulVf // scale1r -divp_eq.\nsuff s : size (p %% d) < size (c *: d) by rewrite (divpP e s).\nby rewrite size_scale ?ltn_modp.\nQed.",
    "Lemma eqp_modpl d p q : p %= q -> (p %% d) %= (q %% d).\nProof.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0 e].\nby apply/eqpP; exists (c1, c2); rewrite ?c1n0 // -!modpZl e.\nQed.",
    "Lemma eqp_divl d p q : p %= q -> (p %/ d) %= (q %/ d).\nProof.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0 e].\nby apply/eqpP; exists (c1, c2); rewrite ?c1n0 // -!divpZl e.\nQed.",
    "Lemma eqp_modpr d p q : p %= q -> (d %% p) %= (d %% q).\nProof.\ncase/eqpP=> [[c1 c2]] /andP [c1n0 c2n0 e].\nhave -> : p = (c1^-1 * c2) *: q by rewrite -scalerA -e scalerA mulVf // scale1r.\nby rewrite modpZr ?eqpxx // mulf_eq0 negb_or invr_eq0 c1n0.\nQed.",
    "Lemma eqp_mod p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> p1 %% q1 %= p2 %% q2.\nProof. move=> e1 e2; exact: eqp_trans (eqp_modpl _ e1) (eqp_modpr _ e2). Qed.",
    "Lemma eqp_divr (d m n : {poly F}) : m %= n -> (d %/ m) %= (d %/ n).\nProof.\ncase/eqpP=> [[c1 c2]] /andP [c1n0 c2n0 e].\nhave -> : m = (c1^-1 * c2) *: n by rewrite -scalerA -e scalerA mulVf // scale1r.\nby rewrite divpZr ?eqp_scale // ?invr_eq0 mulf_eq0 negb_or invr_eq0 c1n0.\nQed.",
    "Lemma eqp_div p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> p1 %/ q1 %= p2 %/ q2.\nProof. move=> e1 e2; exact: eqp_trans (eqp_divl _ e1) (eqp_divr _ e2). Qed.",
    "Lemma eqp_gdcor p q r : q %= r -> gdcop p q %= gdcop p r.\nProof.\nmove=> eqr; rewrite /gdcop (eqp_size eqr).\nmove: (size r)=> n; elim: n p q r eqr => [|n ihn] p q r; first by rewrite eqpxx.\nmove=> eqr /=; rewrite (eqp_coprimepl p eqr); case: ifP => _ //.\nexact/ihn/eqp_div/eqp_gcdl.\nQed.",
    "Lemma eqp_gdcol p q r : q %= r -> gdcop q p %= gdcop r p.\nProof.\nmove=> eqr; rewrite /gdcop; move: (size p)=> n.\nelim: n p q r eqr {1 3}p (eqpxx p) => [|n ihn] p q r eqr s esp /=.\n  case: (eqVneq q 0) eqr => [-> | nq0 eqr] /=.\n    by rewrite eqp_sym eqp0 => ->; rewrite eqpxx.\n  by case: (eqVneq r 0) eqr nq0 => [->|]; rewrite ?eqpxx // eqp0 => ->.\nrewrite (eqp_coprimepr _ eqr) (eqp_coprimepl _ esp); case: ifP=> _ //.\nexact/ihn/eqp_div/eqp_gcd.\nQed.",
    "Lemma eqp_rgdco_gdco q p : rgdcop q p %= gdcop q p.\nProof.\nrewrite /rgdcop /gdcop; move: (size p)=> n.\nelim: n p q {1 3}p {1 3}q (eqpxx p) (eqpxx q) => [|n ihn] p q s t /= sp tq.\n  case: (eqVneq t 0) tq => [-> | nt0 etq].\n    by rewrite eqp_sym eqp0 => ->; rewrite eqpxx.\n  by case: (eqVneq q 0) etq nt0 => [->|]; rewrite ?eqpxx // eqp0 => ->.\nrewrite rcoprimep_coprimep (eqp_coprimepl t sp) (eqp_coprimepr p tq).\ncase: ifP=> // _; apply: ihn => //; apply: eqp_trans (eqp_rdiv_div _ _) _.\nby apply: eqp_div => //; apply: eqp_trans (eqp_rgcd_gcd _ _) _; apply: eqp_gcd.\nQed.",
    "Lemma modpD d p q : (p + q) %% d = p %% d + q %% d.\nProof.\nhave [-> | dn0] := eqVneq d 0; first by rewrite !modp0.\nby apply: IdomainUnit.modpD; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma modpN p q : (- p) %% q = - (p %% q).\nProof. by apply/eqP; rewrite -addr_eq0 -modpD addNr mod0p. Qed.",
    "Lemma modNp p q : (- p) %% q = - (p %% q). Proof. exact: modpN. Qed.",
    "Lemma divpD d p q : (p + q) %/ d = p %/ d + q %/ d.\nProof.\nhave [-> | dn0] := eqVneq d 0; first by rewrite !divp0 addr0.\nby apply: IdomainUnit.divpD; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divpN p q : (- p) %/ q = - (p %/ q).\nProof. by apply/eqP; rewrite -addr_eq0 -divpD addNr div0p. Qed.",
    "Lemma divp_addl_mul_small d q r : size r < size d -> (q * d + r) %/ d = q.\nProof.\nmove=> srd; rewrite divpD (divp_small srd) addr0 mulpK // -size_poly_gt0.\nexact: leq_trans srd.\nQed.",
    "Lemma modp_addl_mul_small d q r : size r < size d -> (q * d + r) %% d = r.\nProof. by move=> srd; rewrite modpD modp_mull add0r modp_small. Qed.",
    "Lemma divp_addl_mul d q r : d != 0 -> (q * d + r) %/ d = q + r %/ d.\nProof. by move=> dn0; rewrite divpD mulpK. Qed.",
    "Lemma divpp d : d != 0 -> d %/ d = 1.\nProof.\nby move=> dn0; apply: IdomainUnit.divpp; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma leq_divMp d m : size (m %/ d * d) <= size m.\nProof.\nhave [-> | dn0] := eqVneq d 0; first by rewrite mulr0 size_poly0.\nby apply: IdomainUnit.leq_divMp; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divpK d p : d %| p -> p %/ d * d = p.\nProof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite mulr0.\nby apply: IdomainUnit.divpK; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divpKC d p : d %| p -> d * (p %/ d) = p.\nProof. by move=> ?; rewrite mulrC divpK. Qed.",
    "Lemma dvdp_eq_div d p q : d != 0 -> d %| p -> (q == p %/ d) = (q * d == p).\nProof.\nby move=> dn0; apply: IdomainUnit.dvdp_eq_div; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma dvdp_eq_mul d p q : d != 0 -> d %| p -> (p == q * d) = (p %/ d == q).\nProof. by move=> dn0 dv_d_p; rewrite eq_sym -dvdp_eq_div // eq_sym. Qed.",
    "Lemma divp_mulA d p q : d %| q -> p * (q %/ d) = p * q %/ d.\nProof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite !divp0 mulr0.\nby apply: IdomainUnit.divp_mulA; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divp_mulAC d m n : d %| m -> m %/ d * n = m * n %/ d.\nProof. by move=> hdm; rewrite mulrC (mulrC m); apply: divp_mulA. Qed.",
    "Lemma divp_mulCA d p q : d %| p -> d %| q -> p * (q %/ d) = q * (p %/ d).\nProof. by move=> hdp hdq; rewrite mulrC divp_mulAC // divp_mulA. Qed.",
    "Lemma expp_sub d m n : d != 0 -> m >= n -> (d ^+ (m - n))%N = d ^+ m %/ d ^+ n.\nProof. by move=> dn0 /subnK=> {2}<-; rewrite exprD mulpK // expf_neq0. Qed.",
    "Lemma divp_pmul2l d q p : d != 0 -> q != 0 -> d * p %/ (d * q) = p %/ q.\nProof.\nby move=> dn0 qn0; apply: IdomainUnit.divp_pmul2l; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divp_pmul2r d p q : d != 0 -> p != 0 -> q * d %/ (p * d) = q %/ p.\nProof. by move=> dn0 qn0; rewrite -!(mulrC d) divp_pmul2l. Qed.",
    "Lemma divp_divl r p q : q %/ p %/ r = q %/ (p * r).\nProof.\nhave [-> | rn0] := eqVneq r 0; first by rewrite mulr0 !divp0.\nhave [-> | pn0] := eqVneq p 0; first by rewrite mul0r !divp0 div0p.\nby apply: IdomainUnit.divp_divl; rewrite unitfE lead_coef_eq0.\nQed.",
    "Lemma divpAC d p q : q %/ d %/ p = q %/ p %/ d.\nProof. by rewrite !divp_divl // mulrC. Qed.",
    "Lemma edivp_def p q : edivp p q = (0, p %/ q, p %% q).\nProof.\nrewrite Idomain.edivp_def; congr (_, _, _); rewrite /scalp 2!unlock /=.\nhave [-> | qn0] := eqVneq; first by rewrite lead_coef0 unitr0.\nby rewrite unitfE lead_coef_eq0 qn0 /=; case: (redivp_rec _ _ _ _) => [[]].\nQed.",
    "Lemma divpE p q : p %/ q = (lead_coef q)^-(rscalp p q) *: (rdivp p q).\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite rdivp0 divp0 scaler0.\nby rewrite Idomain.divpE unitfE lead_coef_eq0 qn0.\nQed.",
    "Lemma modpE p q : p %% q = (lead_coef q)^-(rscalp p q) *: (rmodp p q).\nProof.\nhave [-> | qn0] := eqVneq q 0.\n  by rewrite rmodp0 modp0 /rscalp unlock eqxx lead_coef0 expr0 invr1 scale1r.\nby rewrite Idomain.modpE unitfE lead_coef_eq0 qn0.\nQed.",
    "Lemma scalpE p q : scalp p q = 0.\nProof.\nhave [-> | qn0] := eqVneq q 0; first by rewrite scalp0.\nby rewrite Idomain.scalpE unitfE lead_coef_eq0 qn0.\nQed.",
    "Lemma dvdpE p q : p %| q = rdvdp p q. Proof. exact: Idomain.dvdpE. Qed.",
    "Lemma edivpP m d : edivp_spec m d (edivp m d).\nProof.\nrewrite edivp_def; constructor; first exact: divp_eq.\nby apply/implyP=> dn0; rewrite ltn_modp.\nQed.",
    "Lemma edivp_eq d q r : size r < size d -> edivp (q * d + r) d = (0, q, r).\nProof.\nmove=> srd; apply: Idomain.edivp_eq; rewrite // unitfE lead_coef_eq0.\nby rewrite -size_poly_gt0; apply: leq_trans srd.\nQed.",
    "Lemma modp_mul p q m : (p * (q %% m)) %% m = (p * q) %% m.\nProof. by rewrite [in RHS](divp_eq q m) mulrDr modpD mulrA modp_mull add0r. Qed.",
    "Lemma horner_mod p q x : root q x -> (p %% q).[x] = p.[x].\nProof.\nby rewrite [in RHS](divp_eq p q) !hornerE => /eqP->; rewrite mulr0 add0r.\nQed.",
    "Lemma dvdpP p q : reflect (exists qq, p = qq * q) (q %| p).\nProof.\nhave [-> | qn0] := eqVneq q 0; last first.\n  by apply: IdomainUnit.dvdpP; rewrite unitfE lead_coef_eq0.\nby rewrite dvd0p; apply: (iffP eqP) => [->| [? ->]]; [exists 1|]; rewrite mulr0.\nQed.",
    "Lemma Bezout_eq1_coprimepP p q :\n  reflect (exists u, u.1 * p + u.2 * q = 1) (coprimep p q).\nProof.\napply: (iffP idP)=> [hpq|]; last first.\n  by case=> -[u v] /= e; apply/Bezout_coprimepP; exists (u, v); rewrite e eqpxx.\ncase/Bezout_coprimepP: hpq => [[u v]] /=.\ncase/eqpP=> [[c1 c2]] /andP /= [c1n0 c2n0] e.\nexists (c2^-1 *: (c1 *: u), c2^-1 *: (c1 *: v)); rewrite /= -!scalerAl.\nby rewrite -!scalerDr e scalerA mulVf // scale1r.\nQed.",
    "Lemma dvdp_gdcor p q : q != 0 -> p %| (gdcop q p) * (q ^+ size p).\nProof.\nrewrite /gdcop => nz_q; have [n hsp] := ubnPleq (size p).\nelim: n => [|n IHn] /= in p hsp *; first by rewrite (negPf nz_q) mul0r dvdp0.\nhave [_ | ncop_pq] := ifPn; first by rewrite dvdp_mulr.\nhave g_gt1: 1 < size (gcdp p q).\n  rewrite ltn_neqAle eq_sym ncop_pq size_poly_gt0 gcdp_eq0.\n  by rewrite negb_and nz_q orbT.\nhave [-> | nz_p] := eqVneq p 0.\n  by rewrite div0p exprSr mulrA dvdp_mulr // IHn // size_poly0.\nhave le_d_p: size (p %/ gcdp p q) < size p.\n  rewrite size_divp -?size_poly_eq0 -(subnKC g_gt1) // add2n /=.\n  by rewrite polySpred // ltnS subSS leq_subr.\nrewrite -[p in p %| _](divpK (dvdp_gcdl p q)) exprSr mulrA.\nby rewrite dvdp_mul ?IHn ?dvdp_gcdr // -ltnS (leq_trans le_d_p).\nQed.",
    "Lemma reducible_cubic_root p q :\n  size p <= 4 -> 1 < size q < size p -> q %| p -> {r | root p r}.\nProof.\nmove=> p_le4 /andP[]; rewrite leq_eqVlt eq_sym.\nhave [/poly2_root[x qx0] _ _ | _ /= q_gt2 p_gt_q] := size q =P 2.\n  by exists x; rewrite -!dvdp_XsubCl in qx0 *; apply: (dvdp_trans qx0).\ncase/dvdpP/sig_eqW=> r def_p; rewrite def_p.\nsuffices /poly2_root[x rx0]: size r = 2 by exists x; rewrite rootM rx0.\nhave /norP[nz_r nz_q]: ~~ [|| r == 0 | q == 0].\n  by rewrite -mulf_eq0 -def_p -size_poly_gt0 (leq_ltn_trans _ p_gt_q).\nrewrite def_p size_mul // -subn1 leq_subLR ltn_subRL in p_gt_q p_le4.\nby apply/eqP; rewrite -(eqn_add2r (size q)) eqn_leq (leq_trans p_le4).\nQed.",
    "Lemma cubic_irreducible p :\n  1 < size p <= 4 -> (forall x, ~~ root p x) -> irreducible_poly p.\nProof.\nmove=> /andP[p_gt1 p_le4] root'p; split=> // q sz_q_neq1 q_dv_p.\nhave nz_p: p != 0 by rewrite -size_poly_gt0 ltnW.\nhave nz_q: q != 0 by apply: contraTneq q_dv_p => ->; rewrite dvd0p.\nhave q_gt1: size q > 1 by rewrite ltn_neqAle eq_sym sz_q_neq1 size_poly_gt0.\nrewrite -dvdp_size_eqp // eqn_leq dvdp_leq //= leqNgt; apply/negP=> p_gt_q.\nby have [|x /idPn//] := reducible_cubic_root p_le4 _ q_dv_p; rewrite q_gt1.\nQed.",
    "Lemma mup_geq x q n : q != 0 -> (n <= mup x q)%N = (('X - x%:P) ^+ n %| q).\nProof.\nmove=> q_neq0; rewrite /mup; symmetry.\ncase: arg_maxnP; rewrite ?expr0 ?dvd1p//= => i i_dvd gti.\ncase: ltnP => [|/dvdp_exp2l/dvdp_trans]; last exact.\napply: contraTF => dvdq; rewrite -leqNgt.\nsuff n_small : (n < (size q).+1)%N by exact: (gti (Ordinal n_small)).\nby rewrite ltnS ltnW// -(size_exp_XsubC _ x) dvdp_leq.\nQed.",
    "Lemma mup_leq x q n : q != 0 ->\n  (mup x q <= n)%N = ~~ (('X - x%:P) ^+ n.+1 %| q).\nProof. by move=> qN0; rewrite leqNgt mup_geq. Qed.",
    "Lemma mup_ltn x q n : q != 0 -> (mup x q < n)%N = ~~ (('X - x%:P) ^+ n %| q).\nProof. by move=> qN0; rewrite ltnNge mup_geq. Qed.",
    "Lemma XsubC_dvd x q : q != 0 -> ('X - x%:P %| q) = (0 < mup x q)%N.\nProof. by move=> /mup_geq-/(_ _ 1%N)/esym; apply. Qed.",
    "Lemma mup_XsubCX n x y :\n  mup x (('X - y%:P) ^+ n) = (if (y == x) then n else 0)%N.\nProof.\nhave Xxn0 : ('X - y%:P) ^+ n != 0 by rewrite ?expf_neq0 ?polyXsubC_eq0.\napply/eqP; rewrite eqn_leq mup_leq ?mup_geq//.\nhave [->|Nxy] := eqVneq x y.\n  by rewrite /= dvdpp ?dvdp_Pexp2l ?size_XsubC ?ltnn.\nby rewrite dvd1p dvdp_XsubCl /root horner_exp !hornerE expf_neq0// subr_eq0.\nQed.",
    "Lemma mupNroot x q : ~~ root q x -> mup x q = 0%N.\nProof.\nmove=> qNx; have qN0 : q != 0 by apply: contraNneq qNx => ->; rewrite root0.\nby move: qNx; rewrite -dvdp_XsubCl XsubC_dvd// lt0n negbK => /eqP.\nQed.",
    "Lemma mupMr x q1 q2 : ~~ root q1 x -> mup x (q1 * q2) = mup x q2.\nProof.\nmove=> q1Nx; have q1N0 : q1 != 0 by apply: contraNneq q1Nx => ->; rewrite root0.\nhave [->|q2N0] := eqVneq q2 0; first by rewrite mulr0.\napply/esym/eqP; rewrite eqn_leq mup_geq ?mulf_neq0// dvdp_mull -?mup_geq//=.\nrewrite mup_leq ?mulf_neq0// Gauss_dvdpr -?mup_ltn//.\nby rewrite coprimep_expl// coprimep_sym coprimep_XsubC.\nQed.",
    "Lemma mupMl x q1 q2 : ~~ root q2 x -> mup x (q1 * q2) = mup x q1.\nProof. by rewrite mulrC; apply/mupMr. Qed.",
    "Lemma mupM x q1 q2 : q1 != 0 -> q2 != 0 ->\n  mup x (q1 * q2) = (mup x q1 + mup x q2)%N.\nProof.\nmove=> q1N0 q2N0; apply/eqP; rewrite eqn_leq mup_leq ?mulf_neq0//.\nrewrite mup_geq ?mulf_neq0// exprD ?dvdp_mul; do ?by rewrite -mup_geq.\nhave [m1 [r1]] := multiplicity_XsubC q1 x; rewrite q1N0 /= => r1Nx ->.\nhave [m2 [r2]] := multiplicity_XsubC q2 x; rewrite q2N0 /= => r2Nx ->.\nrewrite !mupMr// ?mup_XsubCX eqxx/= mulrACA exprS exprD.\nrewrite dvdp_mul2r ?mulf_neq0 ?expf_neq0 ?polyXsubC_eq0//.\nby rewrite dvdp_XsubCl rootM negb_or r1Nx r2Nx.\nQed.",
    "Lemma mu_prod_XsubC x (s : seq F) :\n  mup x (\\prod_(y <- s) ('X - y%:P)) = count_mem x s.\nProof.\nelim: s => [|y s IHs]; rewrite (big_cons, big_nil)/=.\n  by rewrite mupNroot// root1.\nrewrite mupM ?polyXsubC_eq0// ?monic_neq0 ?monic_prod_XsubC//.\nby rewrite IHs (@mup_XsubCX 1).\nQed.",
    "Lemma prod_XsubC_eq (s t : seq F) :\n  \\prod_(x <- s) ('X - x%:P) = \\prod_(x <- t) ('X - x%:P) -> perm_eq s t.\nProof.\nmove=> eq_prod; apply/allP => x _ /=; apply/eqP.\nby have /(congr1 (mup x)) := eq_prod; rewrite !mu_prod_XsubC.\nQed.",
    "Lemma redivp_map a b :\n  redivp a^f b^f = (rscalp a b, (rdivp a b)^f, (rmodp a b)^f).\nProof.\nrewrite /rdivp /rscalp /rmodp !unlock map_poly_eq0 size_map_poly.\nhave [// | q_nz] := ifPn; rewrite -(rmorph0 (map_poly f)) //.\nhave [m _] := ubnPeq (size a); elim: m 0%N 0 a => [|m IHm] qq r a /=.\n  rewrite -!mul_polyC !size_map_poly !lead_coef_map // -(map_polyXn f).\n  by rewrite -!(map_polyC f) -!rmorphM -rmorphB -rmorphD; case: (_ < _).\nrewrite -!mul_polyC !size_map_poly !lead_coef_map // -(map_polyXn f).\nby rewrite -!(map_polyC f) -!rmorphM -rmorphB -rmorphD /= IHm; case: (_ < _).\nQed.",
    "Lemma edivp_map a b :\n  edivp a^f b^f = (0, (a %/ b)^f, (a %% b)^f).\nProof.\nhave [-> | bn0] := eqVneq b 0.\n  rewrite (rmorph0 (map_poly f)) WeakIdomain.edivp_def !modp0 !divp0.\n  by rewrite (rmorph0 (map_poly f)) scalp0.\nrewrite unlock redivp_map lead_coef_map rmorph_unit; last first.\n  by rewrite unitfE lead_coef_eq0.\nrewrite modpE divpE !map_polyZ [in RHS]rmorphV ?rmorphXn // unitfE.\nby rewrite expf_neq0 // lead_coef_eq0.\nQed.",
    "Lemma scalp_map p q : scalp p^f q^f = scalp p q.\nProof. by rewrite /scalp edivp_map edivp_def. Qed.",
    "Lemma map_divp p q : (p %/ q)^f = p^f %/ q^f.\nProof. by rewrite /divp edivp_map edivp_def. Qed.",
    "Lemma map_modp p q : (p %% q)^f = p^f %% q^f.\nProof. by rewrite /modp edivp_map edivp_def. Qed.",
    "Lemma egcdp_map p q :\n  egcdp (map_poly f p) (map_poly f q)\n     = (map_poly f (egcdp p q).1, map_poly f (egcdp p q).2).\nProof.\nwlog le_qp: p q / size q <= size p.\n  move=> IH; have [/IH// | lt_qp] := leqP (size q) (size p).\n  have /IH := ltnW lt_qp; rewrite /egcdp !size_map_poly ltnW // leqNgt lt_qp /=.\n  by case: (egcdp_rec _ _ _) => u v [-> ->].\nrewrite /egcdp !size_map_poly {}le_qp; move: (size q) => n.\nelim: n => /= [|n IHn] in p q *; first by rewrite rmorph1 rmorph0.\nrewrite map_poly_eq0; have [_ | nz_q] := ifPn; first by rewrite rmorph1 rmorph0.\nrewrite -map_modp (IHn q (p %% q)); case: (egcdp_rec _ _ n) => u v /=.\nrewrite map_polyZ lead_coef_map -rmorphXn scalp_map rmorphB rmorphM.\nby rewrite -map_divp.\nQed.",
    "Lemma dvdp_map p q : (p^f %| q^f) = (p %| q).\nProof. by rewrite /dvdp -map_modp map_poly_eq0. Qed.",
    "Lemma eqp_map p q : (p^f %= q^f) = (p %= q).\nProof. by rewrite /eqp !dvdp_map. Qed.",
    "Lemma gcdp_map p q : (gcdp p q)^f = gcdp p^f q^f.\nProof.\nwlog lt_p_q: p q / size p < size q.\n  move=> IHpq; case: (ltnP (size p) (size q)) => [|le_q_p]; first exact: IHpq.\n  rewrite gcdpE (gcdpE p^f) !size_map_poly ltnNge le_q_p /= -map_modp.\n  have [-> | q_nz] := eqVneq q 0; first by rewrite rmorph0 !gcdp0.\n  by rewrite IHpq ?ltn_modp.\nhave [m le_q_m] := ubnP (size q); elim: m => // m IHm in p q lt_p_q le_q_m *.\nrewrite gcdpE (gcdpE p^f) !size_map_poly lt_p_q -map_modp.\nhave [-> | q_nz] := eqVneq p 0; first by rewrite rmorph0 !gcdp0.\nby rewrite IHm ?(leq_trans lt_p_q) ?ltn_modp.\nQed.",
    "Lemma coprimep_map p q : coprimep p^f q^f = coprimep p q.\nProof. by rewrite -!gcdp_eqp1 -eqp_map rmorph1 gcdp_map. Qed.",
    "Lemma gdcop_rec_map p q n : (gdcop_rec p q n)^f = gdcop_rec p^f q^f n.\nProof.\nelim: n p q => [|n IH] => /= p q.\n  by rewrite map_poly_eq0; case: eqP; rewrite ?rmorph1 ?rmorph0.\nrewrite /coprimep -gcdp_map size_map_poly.\nby case: eqP => Hq0 //; rewrite -map_divp -IH.\nQed.",
    "Lemma gdcop_map p q : (gdcop p q)^f = gdcop p^f q^f.\nProof. by rewrite /gdcop gdcop_rec_map !size_map_poly. Qed.",
    "Lemma root_coprimep (p q : {poly F}) :\n  (forall x, root p x -> q.[x] != 0) -> coprimep p q.\nProof.\nmove=> Ncmn; rewrite -gcdp_eqp1 -size_poly_eq1; apply/closed_rootP.\nby case=> r; rewrite root_gcd !rootE=> /andP [/Ncmn/negPf->].\nQed.",
    "Lemma coprimepP (p q : {poly F}) :\n  reflect (forall x, root p x -> q.[x] != 0) (coprimep p q).\nProof. by apply: (iffP idP)=> [/coprimep_root|/root_coprimep]. Qed.",
    "Lemma zmod1gE : 1%g = 0 :> U.            Proof. by []. Qed.",
    "Lemma zmodVgE x : x^-1%g = - x.          Proof. by []. Qed.",
    "Lemma zmodMgE x y : (x * y)%g = x + y.   Proof. by []. Qed.",
    "Lemma zmodXgE n x : (x ^+ n)%g = x *+ n. Proof. by []. Qed.",
    "Lemma zmod_mulgC x y : commute x y.      Proof. exact: addrC. Qed.",
    "Lemma zmod_abelian (A : {set U}) : abelian A.\nProof. by apply/centsP=> x _ y _; apply: zmod_mulgC. Qed.",
    "Lemma mulVr : {in unit, left_inverse 1 inv *%R}.\n  Proof.\n  rewrite /inv => x Ux; case: pickP => [y | no_y]; last by case/pred0P: Ux.\n  by case/andP=> _; move/eqP.\n  Qed.",
    "Lemma mulrV : {in unit, right_inverse 1 inv *%R}.\n  Proof.\n  rewrite /inv => x Ux; case: pickP => [y | no_y]; last by case/pred0P: Ux.\n  by case/andP; move/eqP.\n  Qed.",
    "Lemma intro_unit x y : y * x = 1 /\\ x * y = 1 -> x \\is a unit.\n  Proof.\n  by case=> yx1 xy1; apply/existsP; exists y; rewrite /is_inv xy1 yx1 !eqxx.\n  Qed.",
    "Lemma invr_out : {in [predC unit], inv =1 id}.\n  Proof.\n  rewrite /inv => x nUx; case: pickP => // y invxy.\n  by case/existsP: nUx; exists y.\n  Qed.",
    "Lemma unit_inv_proof u : (val u)^-1 \\is a GRing.unit.\nProof. by rewrite unitrV ?(valP u). Qed.",
    "Lemma unit_mul_proof u v : val u * val v \\is a GRing.unit.\nProof. by rewrite (unitrMr _ (valP u)) ?(valP v). Qed.",
    "Lemma unit_muluA : associative unit_mul.\nProof. by move=> u v w; apply/val_inj/mulrA. Qed.",
    "Lemma unit_mul1u : left_id unit1 unit_mul.\nProof. by move=> u; apply/val_inj/mul1r. Qed.",
    "Lemma unit_mulVu : left_inverse unit1 unit_inv unit_mul.\nProof. by move=> u; apply/val_inj/(mulVr (valP u)). Qed.",
    "Lemma val_unit1 : val (1%g : unit_of) = 1. Proof. by []. Qed.",
    "Lemma val_unitM x y : val (x * y : unit_of)%g = val x * val y.\nProof. by []. Qed.",
    "Lemma val_unitV x : val (x^-1 : unit_of)%g = (val x)^-1. Proof. by []. Qed.",
    "Lemma val_unitX n x : val (x ^+ n : unit_of)%g = val x ^+ n.\nProof. by case: n; last by elim=> //= n ->. Qed.",
    "Lemma unit_actE x u : unit_act x u = x * val u. Proof. by []. Qed.",
    "Lemma unit_is_groupAction : @is_groupAction _ R setT setT unit_action.\nProof.\nmove=> u _ /[1!inE]; apply/andP; split; first by apply/subsetP=> x /[1!inE].\nby apply/morphicP=> x y _ _; rewrite !actpermE /= [_ u]mulrDl.\nQed.",
    "Lemma decidable : GRing.decidable_field_axiom sat.\n  Proof.\n  move=> e f; elim: f e;\n  try by move=> f1 IH1 f2 IH2 e /=; case IH1; case IH2; constructor; tauto.\n  - by move=> b e; apply: idP.\n  - by move=> t1 t2 e; apply: eqP.\n  - by move=> t e; apply: idP.\n  - by move=> f IH e /=; case: IH; constructor.\n  - by move=> i f IH e; apply: (iffP existsP) => [] [x fx]; exists x; apply/IH.\n    by move=> i f IH e; apply: (iffP forallP) => f_ x; apply/IH.\n  Qed.",
    "Lemma card_finNzRing_gt1 (R : finNzRingType) : 1 < #|R|.\nProof. by rewrite (cardD1 0) (cardD1 1) !inE GRing.oner_neq0. Qed.",
    "Lemma card_finField_unit (F : finFieldType) : #|[set: {unit F}]| = #|F|.-1.\nProof.\nrewrite -(cardC1 0) cardsT card_sub; apply: eq_card => x.\nby rewrite GRing.unitfE.\nQed.",
    "Lemma swapXY_polyC p : swapXY p%:P = p^:P.\nProof. by rewrite unlock map_polyC hornerC. Qed.",
    "Lemma swapXY_X : swapXY 'X = 'Y.\nProof. by rewrite unlock map_polyX hornerX. Qed.",
    "Lemma swapXY_Y : swapXY 'Y = 'X.\nProof. by rewrite swapXY_polyC map_polyX. Qed.",
    "Lemma swapXY_is_additive : additive swapXY.\nProof. by move=> u v; rewrite unlock rmorphB !hornerE. Qed.",
    "Lemma coef_swapXY u i j : (swapXY u)`_i`_j = u`_j`_i.\nProof.\nelim/poly_ind: u => [|u p IHu] in i j *; first by rewrite raddf0 !coef0.\nrewrite raddfD !coefD /= swapXY_polyC coef_map /= !coefC coefMX.\nrewrite !(fun_if (fun q : {poly R} => q`_i)) coef0 -IHu; congr (_ + _).\nby rewrite unlock rmorphM /= map_polyX hornerMX coefMC coefMX.\nQed.",
    "Lemma swapXYK : involutive swapXY.\nProof. by move=> u; apply/polyP=> i; apply/polyP=> j; rewrite !coef_swapXY. Qed.",
    "Lemma swapXY_map_polyC p : swapXY p^:P = p%:P.\nProof. by rewrite -swapXY_polyC swapXYK. Qed.",
    "Lemma swapXY_eq0 u : (swapXY u == 0) = (u == 0).\nProof. by rewrite (inv_eq swapXYK) raddf0. Qed.",
    "Lemma swapXY_is_multiplicative : multiplicative swapXY.\nProof.\nsplit=> [u v|]; last by rewrite swapXY_polyC map_polyC.\napply/polyP=> i; apply/polyP=> j; rewrite coef_swapXY !coefM !coef_sum.\nrewrite (eq_bigr _ (fun _ _ => coefM _ _ _)) exchange_big /=.\napply: eq_bigr => j1 _; rewrite coefM; apply: eq_bigr=> i1 _.\nby rewrite !coef_swapXY.\nQed.",
    "Lemma swapXY_is_scalable : scalable_for (map_poly polyC \\; *%R) swapXY.\nProof. by move=> p u /=; rewrite -mul_polyC rmorphM /= swapXY_polyC. Qed.",
    "Lemma swapXY_comp_poly p u : swapXY (p^:P \\Po u) = p^:P \\Po swapXY u.\nProof.\nrewrite -horner_map; congr _.[_]; rewrite -!map_poly_comp /=.\nby apply: eq_map_poly => x; rewrite /= swapXY_polyC map_polyC.\nQed.",
    "Lemma max_size_coefXY u i : size u`_i <= sizeY u.\nProof.\nhave [ltiu | /(nth_default 0)->] := ltnP i (size u); last by rewrite size_poly0.\nexact: (bigmax_sup (Ordinal ltiu)).\nQed.",
    "Lemma max_size_lead_coefXY u : size (lead_coef u) <= sizeY u.\nProof. by rewrite lead_coefE max_size_coefXY. Qed.",
    "Lemma max_size_evalX u : size u.['X] <= sizeY u + (size u).-1.\nProof.\nrewrite horner_coef (leq_trans (size_sum _ _ _)) //; apply/bigmax_leqP=> i _.\nrewrite (leq_trans (size_polyMleq _ _)) // size_polyXn addnS.\nby rewrite leq_add ?max_size_coefXY //= -ltnS (leq_trans _ (leqSpred _)).\nQed.",
    "Lemma max_size_evalC u x : size u.[x%:P] <= sizeY u.\nProof.\nrewrite horner_coef (leq_trans (size_sum _ _ _)) //; apply/bigmax_leqP=> i _.\nrewrite (leq_trans (size_polyMleq _ _)) // -polyC_exp size_polyC addnC -subn1.\nby rewrite (leq_trans _ (max_size_coefXY _ i)) // leq_subLR leq_add2r leq_b1.\nQed.",
    "Lemma sizeYE u : sizeY u = size (swapXY u).\nProof.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  apply/bigmax_leqP=> /= i _; apply/leq_sizeP => j /(nth_default 0) u_j_0.\n  by rewrite -coef_swapXY u_j_0 coef0.\napply/leq_sizeP=> j le_uY_j; apply/polyP=> i; rewrite coef_swapXY coef0.\nby rewrite nth_default // (leq_trans _ le_uY_j) ?max_size_coefXY.\nQed.",
    "Lemma sizeY_eq0 u : (sizeY u == 0) = (u == 0).\nProof. by rewrite sizeYE size_poly_eq0 swapXY_eq0. Qed.",
    "Lemma sizeY_mulX u : sizeY (u * 'X) = sizeY u.\nProof.\nrewrite !sizeYE rmorphM /= swapXY_X rreg_size //.\nby have /monic_comreg[_ /rreg_lead] := monicX R.\nQed.",
    "Lemma swapXY_poly_XaY p : swapXY (poly_XaY p) = poly_XaY p.\nProof. by rewrite swapXY_comp_poly rmorphD /= swapXY_X swapXY_Y addrC. Qed.",
    "Lemma swapXY_poly_XmY p : swapXY (poly_XmY p) = poly_XmY p.\nProof.\nby rewrite swapXY_comp_poly rmorphM /= swapXY_X swapXY_Y commr_polyX.\nQed.",
    "Lemma poly_XaY0 : poly_XaY 0 = 0.\nProof. by rewrite /poly_XaY rmorph0 comp_poly0. Qed.",
    "Lemma poly_XmY0 : poly_XmY 0 = 0.\nProof. by rewrite /poly_XmY rmorph0 comp_poly0. Qed.",
    "Lemma swapXY_map (R S : nzRingType) (f : {additive R -> S}) u :\n  swapXY (u ^ map_poly f) = swapXY u ^ map_poly f.\nProof.\nby apply/polyP=> i; apply/polyP=> j; rewrite !(coef_map, coef_swapXY).\nQed.",
    "Lemma horner_swapXY u x : (swapXY u).[x%:P] = u ^ eval x.\nProof.\napply/polyP=> i /=; rewrite coef_map /= /eval horner_coef coef_sum -sizeYE.\nrewrite (horner_coef_wide _ (max_size_coefXY u i)); apply: eq_bigr=> j _.\nby rewrite -polyC_exp coefMC coef_swapXY.\nQed.",
    "Lemma horner_polyC u x : u.[x%:P] = swapXY u ^ eval x.\nProof. by rewrite -horner_swapXY swapXYK. Qed.",
    "Lemma horner2_swapXY u x y : (swapXY u).[x, y] = u.[y, x].\nProof. by rewrite horner_swapXY -{1}(hornerC y x) horner_map. Qed.",
    "Lemma horner_poly_XaY p v : (poly_XaY p).[v] = p \\Po (v + 'X).\nProof. by rewrite horner_comp !hornerE. Qed.",
    "Lemma horner_poly_XmY p v : (poly_XmY p).[v] = p \\Po (v * 'X).\nProof. by rewrite horner_comp !hornerE. Qed.",
    "Lemma size_poly_XaY p : size (poly_XaY p) = size p.\nProof. by rewrite size_comp_poly2 ?size_XaddC // size_map_polyC. Qed.",
    "Lemma poly_XaY_eq0 p : (poly_XaY p == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 size_poly_XaY. Qed.",
    "Lemma size_poly_XmY p : size (poly_XmY p) = size p.\nProof. by rewrite size_comp_poly2 ?size_XmulC ?polyX_eq0 ?size_map_polyC. Qed.",
    "Lemma poly_XmY_eq0 p : (poly_XmY p == 0) = (p == 0).\nProof. by rewrite -!size_poly_eq0 size_poly_XmY. Qed.",
    "Lemma lead_coef_poly_XaY p : lead_coef (poly_XaY p) = (lead_coef p)%:P.\nProof.\nrewrite lead_coef_comp ?size_XaddC // -['Y]opprK -polyCN lead_coefXsubC.\nby rewrite expr1n mulr1 lead_coef_map_inj //; apply: polyC_inj.\nQed.",
    "Lemma sub_annihilant_in_ideal p q :\n    1 < size p -> 1 < size q ->\n  {uv : {poly {poly R}} * {poly {poly R}}\n   | size uv.1 < size q /\\ size uv.2 < size p\n   & forall x y,\n     (sub_annihilant p q).[y] = uv.1.[x, y] * p.[x + y] + uv.2.[x, y] * q.[x]}.\nProof.\nrewrite -size_poly_XaY -(size_map_polyC q) => p1_gt1 q1_gt1.\nhave [uv /= [ub_u ub_v Dr]] := resultant_in_ideal p1_gt1 q1_gt1.\nexists uv => // x y; rewrite -[r in r.[y]](hornerC _ x%:P) Dr.\nby rewrite !(hornerE, horner_comp).\nQed.",
    "Lemma sub_annihilantP p q x y :\n    p != 0 -> q != 0 -> p.[x] = 0 -> q.[y] = 0 ->\n  (sub_annihilant p q).[x - y] = 0.\nProof.\nmove=> nz_p nz_q px0 qy0.\nhave p_gt1: size p > 1 by have /rootP/root_size_gt1-> := px0.\nhave q_gt1: size q > 1 by have /rootP/root_size_gt1-> := qy0.\nhave [uv /= _ /(_ y)->] := sub_annihilant_in_ideal p_gt1 q_gt1.\nby rewrite (addrC y) subrK px0 qy0 !mulr0 addr0.\nQed.",
    "Lemma sub_annihilant_neq0 p q : p != 0 -> q != 0 -> sub_annihilant p q != 0.\nProof.\nrewrite resultant_eq0; set p1 := poly_XaY p => nz_p nz_q.\nhave [nz_p1 nz_q1]: p1 != 0 /\\ q^:P != 0 by rewrite poly_XaY_eq0 map_polyC_eq0.\nrewrite -leqNgt eq_leq //; apply/eqP/Bezout_coprimepPn=> // [[[u v]]] /=.\nrewrite !size_poly_gt0 -andbA => /and4P[nz_u ltuq nz_v _] Duv.\nhave /eqP/= := congr1 (size \\o (lead_coef \\o swapXY)) Duv.\nrewrite ltn_eqF // !rmorphM !lead_coefM (leq_trans (leq_ltn_trans _ ltuq)) //=.\n  rewrite -{2}[u]swapXYK -sizeYE swapXY_poly_XaY lead_coef_poly_XaY.\n  by rewrite mulrC mul_polyC size_scale ?max_size_lead_coefXY ?lead_coef_eq0.\nrewrite swapXY_map_polyC lead_coefC size_map_polyC.\nset v1 := lead_coef _; have nz_v1: v1 != 0 by rewrite lead_coef_eq0 swapXY_eq0.\nrewrite [leqRHS]polySpred ?mulf_neq0 // size_mul //.\nby rewrite (polySpred nz_v1) addnC addnS polySpred // ltnS leq_addr.\nQed.",
    "Lemma div_annihilant_in_ideal p q :\n    1 < size p -> 1 < size q ->\n  {uv : {poly {poly R}} * {poly {poly R}}\n   | size uv.1 < size q /\\ size uv.2 < size p\n   & forall x y,\n     (div_annihilant p q).[y] = uv.1.[x, y] * p.[x * y] + uv.2.[x, y] * q.[x]}.\nProof.\nrewrite -size_poly_XmY -(size_map_polyC q) => p1_gt1 q1_gt1.\nhave [uv /= [ub_u ub_v Dr]] := resultant_in_ideal p1_gt1 q1_gt1.\nexists uv => // x y; rewrite -[r in r.[y]](hornerC _ x%:P) Dr.\nby rewrite !(hornerE, horner_comp).\nQed.",
    "Lemma div_annihilant_neq0 p q : p != 0 -> q.[0] != 0 -> div_annihilant p q != 0.\nProof.\nhave factorX u: u != 0 -> root u 0 -> exists2 v, v != 0 & u = v * 'X.\n  move=> nz_u /factor_theorem[v]; rewrite subr0 => Du; exists v => //.\n  by apply: contraNneq nz_u => v0; rewrite Du v0 mul0r.\nhave nzX: 'X != 0 := monic_neq0 (monicX _); have rootC0 := root_polyC _ 0.\nrewrite resultant_eq0 -leqNgt -rootE // => nz_p nz_q0; apply/eq_leq/eqP.\nhave nz_q: q != 0 by apply: contraNneq nz_q0 => ->; rewrite root0.\napply/Bezout_coprimepPn; rewrite ?map_polyC_eq0 ?poly_XmY_eq0 // => [[uv]].\nrewrite !size_poly_gt0 -andbA ltnNge => /and4P[nz_u /negP ltuq nz_v _] Duv.\npose u := swapXY uv.1; pose v := swapXY uv.2.\nsuffices{ltuq}: size q <= sizeY u by rewrite sizeYE swapXYK -size_map_polyC.\nhave{nz_u nz_v} [nz_u nz_v Dvu]: [/\\ u != 0, v != 0 & q *: v = u * poly_XmY p].\n  rewrite !swapXY_eq0; split=> //; apply: (can_inj swapXYK).\n  by rewrite linearZ rmorphM /= !swapXYK swapXY_poly_XmY Duv mulrC.\nhave{Duv} [n ltvn]: {n | size v < n} by exists (size v).+1.\nelim: n {uv} => // n IHn in p (v) (u) nz_u nz_v Dvu nz_p ltvn *.\nhave Dp0: root (poly_XmY p) 0 = root p 0 by rewrite root_comp !hornerE rootC0.\nhave Dv0: root u 0 || root p 0 = root v 0 by rewrite -Dp0 -rootM -Dvu rootZ.\nhave [v0_0 | nz_v0] := boolP (root v 0); last first.\n  have nz_p0: ~~ root p 0 by apply: contra nz_v0; rewrite -Dv0 orbC => ->.\n  apply: (@leq_trans (size (q * v.[0]))).\n    by rewrite size_mul // (polySpred nz_v0) addnS leq_addr.\n  rewrite -hornerZ Dvu !(horner_comp, hornerE) horner_map mulrC size_Cmul //.\n  by rewrite horner_coef0 max_size_coefXY.\nhave [v1 nz_v1 Dv] := factorX _ _ nz_v v0_0; rewrite Dv size_mulX // in ltvn.\nhave /orP[/factorX[//|u1 nz_u1 Du] | p0_0]: root u 0 || root p 0 by rewrite Dv0.\n  rewrite Du sizeY_mulX; apply: IHn nz_u1 nz_v1 _ nz_p ltvn.\n  by apply: (mulIf (nzX _)); rewrite mulrAC -scalerAl -Du -Dv.\nhave /factorX[|v2 nz_v2 Dv1]: root (swapXY v1) 0; rewrite ?swapXY_eq0 //.\n  suffices: root (swapXY v1 * 'Y) 0 by rewrite mulrC mul_polyC rootZ ?polyX_eq0.\n  have: root (swapXY (q *: v)) 0.\n    by rewrite Dvu rmorphM rootM /= swapXY_poly_XmY Dp0 p0_0 orbT.\n  by rewrite linearZ rootM rootC0 (negPf nz_q0) /= Dv rmorphM /= swapXY_X.\nrewrite ltnS (canRL swapXYK Dv1) -sizeYE sizeY_mulX sizeYE in ltvn.\nhave [p1 nz_p1 Dp] := factorX _ _ nz_p p0_0.\napply: IHn nz_u _ _ nz_p1 ltvn; first by rewrite swapXY_eq0.\nhave: 'X * 'Y != 0 :> {poly {poly R}} by rewrite mulf_neq0 ?polyC_eq0 ?nzX.\nmove/mulIf; apply.\nrewrite -scalerAl mulrA mulrAC -{1}swapXY_X -rmorphM /= -Dv1 swapXYK -Dv Dvu.\nby rewrite /poly_XmY Dp rmorphM /= map_polyX comp_polyM comp_polyX mulrA.\nQed.",
    "Lemma div_annihilantP (p q : {poly E}) (x y : E) :\n    p != 0 -> q != 0 -> y != 0 -> p.[x] = 0 -> q.[y] = 0 ->\n  (div_annihilant p q).[x / y] = 0.\nProof.\nmove=> nz_p nz_q nz_y px0 qy0.\nhave p_gt1: size p > 1 by have /rootP/root_size_gt1-> := px0.\nhave q_gt1: size q > 1 by have /rootP/root_size_gt1-> := qy0.\nhave [uv /= _ /(_ y)->] := div_annihilant_in_ideal p_gt1 q_gt1.\nby rewrite (mulrC y) divfK // px0 qy0 !mulr0 addr0.\nQed.",
    "Lemma map_sub_annihilantP (p q : {poly F}) (x y : E) :\n     p != 0 -> q != 0 ->(p ^ FtoE).[x] = 0 -> (q ^ FtoE).[y] = 0 ->\n  (sub_annihilant p q ^ FtoE).[x - y] = 0.\nProof.\nmove=> nz_p nz_q px0 qy0; have pFto0 := map_poly_eq0 FtoE.\nrewrite map_resultant ?pFto0 ?lead_coef_eq0 ?map_poly_eq0 ?poly_XaY_eq0 //.\nrewrite map_comp_poly rmorphD /= map_polyC /= !map_polyX -!map_poly_comp /=.\nby rewrite !(eq_map_poly (map_polyC _)) !map_poly_comp sub_annihilantP ?pFto0.\nQed.",
    "Lemma map_div_annihilantP (p q : {poly F}) (x y : E) :\n     p != 0 -> q != 0 -> y != 0 -> (p ^ FtoE).[x] = 0 -> (q ^ FtoE).[y] = 0 ->\n  (div_annihilant p q ^ FtoE).[x / y] = 0.\nProof.\nmove=> nz_p nz_q nz_y px0 qy0; have pFto0 := map_poly_eq0 FtoE.\nrewrite map_resultant ?pFto0 ?lead_coef_eq0 ?map_poly_eq0 ?poly_XmY_eq0 //.\nrewrite map_comp_poly rmorphM /= map_polyC /= !map_polyX -!map_poly_comp /=.\nby rewrite !(eq_map_poly (map_polyC _)) !map_poly_comp div_annihilantP ?pFto0.\nQed.",
    "Lemma root_annihilant x p (pEx := (p ^ pFtoE).[x%:P]) :\n    pEx != 0 -> algebraicOver FtoE x ->\n  exists2 r : {poly F}, r != 0 & forall y, root pEx y -> root (r ^ FtoE) y.\nProof.\nmove=> nz_px [q nz_q qx0].\nhave [/size1_polyC Dp | p_gt1] := leqP (size p) 1.\n  by rewrite {}/pEx Dp map_polyC hornerC map_poly_eq0 in nz_px *; exists p`_0.\nhave nz_p: p != 0 by rewrite -size_poly_gt0 ltnW.\nhave [m le_qm] := ubnP (size q); elim: m => // m IHm in q le_qm nz_q qx0 *.\nhave nz_q1: q^:P != 0 by rewrite map_poly_eq0.\nhave sz_q1: size q^:P = size q by rewrite size_map_polyC.\nhave q1_gt1: size q^:P > 1.\n  by rewrite sz_q1 -(size_map_poly FtoE) (root_size_gt1 _ qx0) ?map_poly_eq0.\nhave [uv _ Dr] := resultant_in_ideal p_gt1 q1_gt1; set r := resultant p _ in Dr.\nhave /eqP q1x0: (q^:P ^ pFtoE).[x%:P] == 0.\n  by rewrite -swapXY_polyC -swapXY_map horner_swapXY !map_polyC polyC_eq0.\nhave [|r_nz] := boolP (r == 0); last first.\n  exists r => // y pxy0; rewrite -[r ^ _](hornerC _ x%:P) -map_polyC Dr.\n  by rewrite rmorphD !rmorphM !hornerE q1x0 mulr0 addr0 rootM pxy0 orbT.\nrewrite resultant_eq0 => /gtn_eqF/Bezout_coprimepPn[]// [q2 p1] /=.\nrewrite size_poly_gt0 sz_q1 => /andP[/andP[nz_q2 ltq2] _] Dq.\npose n := (size (lead_coef q2)).-1; pose q3 := map_poly (coefp n) q2.\nhave nz_q3: q3 != 0 by rewrite map_poly_eq0_id0 ?lead_coef_eq0.\napply: (IHm q3); rewrite ?(leq_ltn_trans (size_poly _ _)) ?(leq_trans ltq2) //.\nhave /polyP/(_ n)/eqP: (q2 ^ pFtoE).[x%:P] = 0.\napply: (mulIf nz_px); rewrite -hornerM -rmorphM Dq rmorphM hornerM /= q1x0.\n  by rewrite mul0r mulr0.\nrewrite coef0; congr (_ == 0); rewrite !horner_coef coef_sum.\nrewrite size_map_poly !size_map_poly_id0 ?map_poly_eq0 ?lead_coef_eq0 //.\nby apply: eq_bigr => i _; rewrite -rmorphXn coefMC !coef_map.\nQed.",
    "Lemma algebraic_root_polyXY x y :\n    (let pEx p := (p ^ map_poly FtoE).[x%:P] in\n    exists2 p, pEx p != 0 & root (pEx p) y) ->\n  algebraicOver FtoE x -> algebraicOver FtoE y.\nProof. by case=> p nz_px pxy0 /(root_annihilant nz_px)[r]; exists r; auto. Qed.",
    "Lemma map_itv_bound_comp S T U (f : T -> S) (g : U -> T) (b : itv_bound U) :\n  map_itv_bound (f \\o g) b = map_itv_bound f (map_itv_bound g b).\nProof. by case: b. Qed.",
    "Lemma map_itv_comp S T U (f : T -> S) (g : U -> T) (i : interval U) :\n  map_itv (f \\o g) i = map_itv f (map_itv g i).\nProof. by case: i => l u /=; rewrite -!map_itv_bound_comp. Qed.",
    "Lemma opp_bound_ge0 b : (BLeft 0%R <= opp_bound b)%O = (b <= BRight 0%R)%O.\nProof. by case: b => [[] b | []//]; rewrite /= !bnd_simp oppr_ge0. Qed.",
    "Lemma opp_bound_gt0 b : (BRight 0%R <= opp_bound b)%O = (b <= BLeft 0%R)%O.\nProof.\nby case: b => [[] b | []//]; rewrite /= !bnd_simp ?oppr_ge0 ?oppr_gt0.\nQed.",
    "Lemma mul_boundrC b1 b2 : mul_boundr b1 b2 = mul_boundr b2 b1.\nProof.\nby move: b1 b2 => [[] [[|?]|?] | []] [[] [[|?]|?] | []] //=; rewrite mulnC.\nQed.",
    "Lemma mul_boundr_gt0 b1 b2 :\n  (BRight 0%Z <= b1 -> BRight 0%Z <= b2 -> BRight 0%Z <= mul_boundr b1 b2)%O.\nProof.\ncase: b1 b2 => [b1b b1 | []] [b2b b2 | []]//=.\n- by case: b1b b2b => -[]; case: b1 b2 => [[|b1] | b1] [[|b2] | b2].\n- by case: b1b b1 => -[[] |].\n- by case: b2b b2 => -[[] |].\nQed.",
    "Lemma spec_real1 T f (op1 : T -> T) (op1i : interval int -> interval int) :\n    forall (x : T), (forall xi, f xi x = true -> f (op1i xi) (op1 x) = true) ->\n  forall xi, spec f xi x -> spec f (real1 op1i xi) (op1 x).\nProof. by move=> x + [//| xi]; apply. Qed.",
    "Lemma spec_real2 T f (op2 : T -> T -> T)\n    (op2i : interval int -> interval int -> interval int) (x y : T) :\n    (forall xi yi, f xi x = true -> f yi y = true ->\n     f (op2i xi yi) (op2 x y) = true) ->\n  forall xi yi, spec f xi x -> spec f yi y ->\n    spec f (real2 op2i xi yi) (op2 x y).\nProof. by move=> + [//| xi] [//| yi]; apply. Qed.",
    "Lemma itv_le_total_subproof : total (<=%O : rel nR).\nProof.\nmove=> x y; apply: real_comparable.\n- by case: x => [x /=/andP[]].\n- by case: y => [y /=/andP[]].\nQed.",
    "Lemma top_typ_spec T f (x : T) : Itv.spec f Itv.Top x.\nProof. by []. Qed.",
    "Lemma real_domain_typ_spec (R : realDomainType) (x : R) :\n  num_spec (Itv.Real `]-oo, +oo[) x.\nProof. by rewrite /Itv.num_sem/= num_real. Qed.",
    "Lemma real_field_typ_spec (R : realFieldType) (x : R) :\n  num_spec (Itv.Real `]-oo, +oo[) x.\nProof. exact: real_domain_typ_spec. Qed.",
    "Lemma nat_typ_spec (x : nat) : nat_spec (Itv.Real `[0, +oo[) x.\nProof. by []. Qed.",
    "Lemma typ_inum_spec (i : Itv.t) (xt : Itv.typ i) (x : Itv.sort xt) :\n  Itv.spec (@Itv.sort_sem _ xt) i x.\nProof. by move: xt x => []. Qed.",
    "Lemma le_num_itv_bound (x y : itv_bound int) :\n  (num_itv_bound R x <= num_itv_bound R y)%O = (x <= y)%O.\nProof.\nby case: x y => [[] x | x] [[] y | y]//=; rewrite !bnd_simp ?ler_int ?ltr_int.\nQed.",
    "Lemma num_itv_bound_le_BLeft (x : itv_bound int) (y : int) :\n  (num_itv_bound R x <= BLeft (y%:~R : R))%O = (x <= BLeft y)%O.\nProof.\nrewrite -[BLeft y%:~R]/(map_itv_bound intr (BLeft y)).\nby rewrite le_num_itv_bound.\nQed.",
    "Lemma BRight_le_num_itv_bound (x : int) (y : itv_bound int) :\n  (BRight (x%:~R : R) <= num_itv_bound R y)%O = (BRight x <= y)%O.\nProof.\nrewrite -[BRight x%:~R]/(map_itv_bound intr (BRight x)).\nby rewrite le_num_itv_bound.\nQed.",
    "Lemma num_spec_sub (x y : Itv.t) : Itv.sub x y ->\n  forall z : R, num_spec x z -> num_spec y z.\nProof.\ncase: x y => [| x] [| y] //= x_sub_y z /andP[rz]; rewrite /Itv.num_sem rz/=.\nmove: x y x_sub_y => [lx ux] [ly uy] /andP[lel leu] /=.\nmove=> /andP[lxz zux]; apply/andP; split.\n- by apply: le_trans lxz; rewrite le_num_itv_bound.\n- by apply: le_trans zux _; rewrite le_num_itv_bound.\nQed.",
    "Lemma bottom x : ~ unify_itv i empty_itv.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= => /andP[] /le_trans /[apply]; rewrite ler10.\nQed.",
    "Lemma gt0 x : unify_itv i (Itv.Real `]0%Z, +oo[) -> 0 < x%:num :> R.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_].\nby rewrite /= in_itv/= andbT.\nQed.",
    "Lemma le0F x : unify_itv i (Itv.Real `]0%Z, +oo[) -> x%:num <= 0 :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= andbT => /lt_geF.\nQed.",
    "Lemma lt0 x : unify_itv i (Itv.Real `]-oo, 0%Z[) -> x%:num < 0 :> R.\nProof.\nby case: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=; rewrite in_itv.\nQed.",
    "Lemma ge0F x : unify_itv i (Itv.Real `]-oo, 0%Z[) -> 0 <= x%:num :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= => /lt_geF.\nQed.",
    "Lemma ge0 x : unify_itv i (Itv.Real `[0%Z, +oo[) -> 0 <= x%:num :> R.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= andbT.\nQed.",
    "Lemma lt0F x : unify_itv i (Itv.Real `[0%Z, +oo[) -> x%:num < 0 :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= andbT => /le_gtF.\nQed.",
    "Lemma le0 x : unify_itv i (Itv.Real `]-oo, 0%Z]) -> x%:num <= 0 :> R.\nProof.\nby case: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=; rewrite in_itv.\nQed.",
    "Lemma gt0F x : unify_itv i (Itv.Real `]-oo, 0%Z]) -> 0 < x%:num :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= => /le_gtF.\nQed.",
    "Lemma cmp0 x : unify_itv i (Itv.Real `]-oo, +oo[) -> 0 >=< x%:num.\nProof. by case: i x => [//| i' [x /=/andP[]]]. Qed.",
    "Lemma neq0 x :\n  unify (fun ix iy => ~~ Itv.sub ix iy) (Itv.Real `[0%Z, 0%Z]) i ->\n  x%:num != 0 :> R.\nProof.\ncase: i x => [//| [l u] [x /= Px]]; apply: contra => /eqP x0 /=.\nmove: Px; rewrite x0 => /and3P[_ /= l0 u0]; apply/andP; split.\n- by case: l l0 => [[] l /= |//]; rewrite !bnd_simp ?lerz0 ?ltrz0.\n- by case: u u0 => [[] u /= |//]; rewrite !bnd_simp ?ler0z ?ltr0z.\nQed.",
    "Lemma eq0F x :\n  unify (fun ix iy => ~~ Itv.sub ix iy) (Itv.Real `[0%Z, 0%Z]) i ->\n  x%:num == 0 :> R = false.\nProof. by move=> u; apply/negbTE/neq0. Qed.",
    "Lemma lt1 x : unify_itv i (Itv.Real `]-oo, 1%Z[) -> x%:num < 1 :> R.\nProof.\nby case: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=; rewrite in_itv.\nQed.",
    "Lemma ge1F x : unify_itv i (Itv.Real `]-oo, 1%Z[) -> 1 <= x%:num :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= => /lt_geF.\nQed.",
    "Lemma le1 x : unify_itv i (Itv.Real `]-oo, 1%Z]) -> x%:num <= 1 :> R.\nProof.\nby case: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=; rewrite in_itv.\nQed.",
    "Lemma gt1F x : unify_itv i (Itv.Real `]-oo, 1%Z]) -> 1 < x%:num :> R = false.\nProof.\ncase: x => x /= /[swap] /num_spec_sub /[apply] /andP[_] /=.\nby rewrite in_itv/= => /le_gtF.\nQed.",
    "Lemma widen_itv_subproof x i' : Itv.sub i i' -> num_spec i' x%:num.\nProof. by case: x => x /= /[swap] /num_spec_sub; apply. Qed.",
    "Lemma widen_itvE x (uni : unify_itv i i) : @widen_itv x i uni = x.\nProof. exact/val_inj. Qed.",
    "Lemma posE x (uni : unify_itv i (Itv.Real `]0%Z, +oo[)) :\n  (widen_itv x%:num%:itv uni)%:num = x%:num.\nProof. by []. Qed.",
    "Lemma nngE x (uni : unify_itv i (Itv.Real `[0%Z, +oo[)) :\n  (widen_itv x%:num%:itv uni)%:num = x%:num.\nProof. by []. Qed.",
    "Lemma num_spec_zero : num_spec (Itv.Real `[0, 0]) (0 : R).\nProof. by apply/andP; split; [exact: real0 | rewrite /= in_itv/= lexx]. Qed.",
    "Lemma num_spec_one : num_spec (Itv.Real `[1, 1]) (1 : R).\nProof. by apply/andP; split; [exact: real1 | rewrite /= in_itv/= lexx]. Qed.",
    "Lemma opp_boundr (x : R) b :\n  (BRight (- x)%R <= num_itv_bound R (opp_bound b))%O\n  = (num_itv_bound R b <= BLeft x)%O.\nProof.\nby case: b => [[] b | []//]; rewrite /= !bnd_simp mulrNz ?lerN2 // ltrN2.\nQed.",
    "Lemma opp_boundl (x : R) b :\n  (num_itv_bound R (opp_bound b) <= BLeft (- x)%R)%O\n  = (BRight x <= num_itv_bound R b)%O.\nProof.\nby case: b => [[] b | []//]; rewrite /= !bnd_simp mulrNz ?lerN2 // ltrN2.\nQed.",
    "Lemma num_spec_opp (i : Itv.t) (x : num_def R i) (r := Itv.real1 opp i) :\n  num_spec r (- x%:num).\nProof.\napply: Itv.spec_real1 (Itv.P x).\ncase: x => x /= _ [l u] /and3P[xr lx xu].\nrewrite /Itv.num_sem/= realN xr/=; apply/andP.\nby rewrite opp_boundl opp_boundr.\nQed.",
    "Lemma num_itv_add_boundl (x1 x2 : R) b1 b2 :\n  (num_itv_bound R b1 <= BLeft x1)%O -> (num_itv_bound R b2 <= BLeft x2)%O ->\n  (num_itv_bound R (add_boundl b1 b2) <= BLeft (x1 + x2)%R)%O.\nProof.\ncase: b1 b2 => [bb1 b1 |//] [bb2 b2 |//].\ncase: bb1; case: bb2; rewrite /= !bnd_simp mulrzDr.\n- exact: lerD.\n- exact: ler_ltD.\n- exact: ltr_leD.\n- exact: ltrD.\nQed.",
    "Lemma num_itv_add_boundr (x1 x2 : R) b1 b2 :\n  (BRight x1 <= num_itv_bound R b1)%O -> (BRight x2 <= num_itv_bound R b2)%O ->\n  (BRight (x1 + x2)%R <= num_itv_bound R (add_boundr b1 b2))%O.\nProof.\ncase: b1 b2 => [bb1 b1 |//] [bb2 b2 |//].\ncase: bb1; case: bb2; rewrite /= !bnd_simp mulrzDr.\n- exact: ltrD.\n- exact: ltr_leD.\n- exact: ler_ltD.\n- exact: lerD.\nQed.",
    "Lemma num_spec_add (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 add xi yi) :\n  num_spec r (x%:num + y%:num).\nProof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\nrewrite /Itv.num_sem realD//=; apply/andP.\nby rewrite num_itv_add_boundl ?num_itv_add_boundr.\nQed.",
    "Lemma signP (l u : itv_bound int) (x : R) :\n    (num_itv_bound R l <= BLeft x)%O -> (BRight x <= num_itv_bound R u)%O ->\n    x \\in Num.real ->\n  sign_spec l u x (sign (Interval l u)).\nProof.\nmove=> + + xr; rewrite /sign/sign_boundl/sign_boundr.\nhave [lneg|lpos|->] := ltgtP l; have [uneg|upos|->] := ltgtP u => lx xu.\n- apply: ISignNonPos => //; first exact: ltW.\n  have:= le_trans xu (eqbRL (le_num_itv_bound _ _) (ltW uneg)).\n  by rewrite bnd_simp.\n- exact: ISignBoth.\n- exact: ISignNonPos.\n- have:= @ltxx _ _ (num_itv_bound R l).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound (le_trans (ltW uneg)).\n- apply: ISignNonNeg => //; first exact: ltW.\n  have:= le_trans (eqbRL (le_num_itv_bound _ _) (ltW lpos)) lx.\n  by rewrite bnd_simp.\n- have:= @ltxx _ _ (num_itv_bound R l).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound ?leBRight_ltBLeft.\n- have:= @ltxx _ _ (num_itv_bound R (BLeft 0%Z)).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound -?ltBRight_leBLeft.\n- exact: ISignNonNeg.\n- apply: ISignEqZero => //.\n  by apply/le_anti/andP; move: lx xu; rewrite !bnd_simp.\nQed.",
    "Lemma num_itv_mul_boundl b1 b2 (x1 x2 : R) :\n  (BLeft 0%:Z <= b1 -> BLeft 0%:Z <= b2 ->\n   num_itv_bound R b1 <= BLeft x1 ->\n   num_itv_bound R b2 <= BLeft x2 ->\n   num_itv_bound R (mul_boundl b1 b2) <= BLeft (x1 * x2))%O.\nProof.\nmove: b1 b2 => [[] b1 | []//] [[] b2 | []//] /=; rewrite 4!bnd_simp.\n- set bl := match b1 with 0%Z => _ | _ => _ end.\n  have -> : bl = BLeft (b1 * b2).\n    rewrite {}/bl; move: b1 b2 => [[|p1]|p1] [[|p2]|p2]; congr BLeft.\n    by rewrite mulr0.\n  by rewrite bnd_simp intrM -2!(ler0z R); apply: ler_pM.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp// => b1p b2p sx1 sx2.\n  + by rewrite mulr_ge0 ?(le_trans _ (ltW sx2)) ?ler0z.\n  + rewrite intrM (@lt_le_trans _ _ (b1.+1%:~R * x2)) ?ltr_pM2l//.\n    by rewrite ler_pM2r// (le_lt_trans _ sx2) ?ler0z.\n- case: b2 => [[|b2] | b2]; rewrite !bnd_simp// => b1p b2p sx1 sx2.\n  + by rewrite mulr_ge0 ?(le_trans _ (ltW sx1)) ?ler0z.\n  + rewrite intrM (@le_lt_trans _ _ (b1%:~R * x2)) ?ler_wpM2l ?ler0z//.\n    by rewrite ltr_pM2r ?(lt_le_trans _ sx2).\n- by rewrite -2!(ler0z R) bnd_simp intrM; apply: ltr_pM.\nQed.",
    "Lemma num_itv_mul_boundr b1 b2 (x1 x2 : R) :\n  (0 <= x1 -> 0 <= x2 ->\n   BRight x1 <= num_itv_bound R b1 ->\n   BRight x2 <= num_itv_bound R b2 ->\n   BRight (x1 * x2) <= num_itv_bound R (mul_boundr b1 b2))%O.\nProof.\ncase: b1 b2 => [b1b b1 | []] [b2b b2 | []] //= x1p x2p; last first.\n- case: b2b b2 => -[[|//] | //] _ x20.\n  + have:= @ltxx _ (itv_bound R) (BLeft 0%:~R).\n    by rewrite (lt_le_trans _ x20).\n  + have -> : x2 = 0 by apply/le_anti/andP.\n    by rewrite mulr0.\n- case: b1b b1 => -[[|//] |//] x10 _.\n  + have:= @ltxx _ (itv_bound R) (BLeft 0%Z%:~R).\n    by rewrite (lt_le_trans _ x10).\n  + by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\ncase: b1b b2b => -[]; rewrite -[intRing.mulz]/GRing.mul.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have:= @ltxx _ R 0; rewrite (le_lt_trans x1p x1b).\n  + case: b2 x2b => [[| b2] | b2] => x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ R 0; rewrite (le_lt_trans x2p x2b).\n    * by rewrite intrM ltr_pM.\n    * have:= @ltxx _ R 0; rewrite (le_lt_trans x2p)//.\n      by rewrite (lt_le_trans x2b) ?lerz0.\n  + have:= @ltxx _ R 0; rewrite (le_lt_trans x1p)//.\n    by rewrite (lt_le_trans x1b) ?lerz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have:= @ltxx _ R 0; rewrite (le_lt_trans x1p x1b).\n  + case: b2 x2b => [[| b2] | b2] x2b; rewrite bnd_simp.\n    * exact: mulr_ge0_le0.\n    * by rewrite intrM (le_lt_trans (ler_wpM2l x1p x2b)) ?ltr_pM2r.\n    * have:= @ltxx _ _ x2.\n      by rewrite (le_lt_trans x2b) ?(lt_le_trans _ x2p) ?ltrz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (lt_le_trans x1b) ?(le_trans _ x1p) ?lerz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + case: b2 x2b => [[|b2] | b2] x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ _ x2; rewrite (lt_le_trans x2b).\n    * by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\n    * have:= @ltxx _ _ x2.\n      by rewrite (lt_le_trans x2b) ?(le_trans _ x2p) ?lerz0.\n  + case: b2 x2b => [[|b2] | b2] x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ _ x2; rewrite (lt_le_trans x2b).\n    * by rewrite intrM (le_lt_trans (ler_wpM2r x2p x1b)) ?ltr_pM2l.\n    * have:= @ltxx _ _ x2.\n      by rewrite (lt_le_trans x2b) ?(le_trans _ x2p) ?lerz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (le_lt_trans x1b) ?(lt_le_trans _ x1p) ?ltrz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\n  + case: b2 x2b => [[| b2] | b2] x2b; rewrite bnd_simp.\n    * by have -> : x2 = 0; [apply/le_anti/andP | rewrite mulr0].\n    * by rewrite intrM ler_pM.\n    * have:= @ltxx _ _ x2.\n      by rewrite (le_lt_trans x2b) ?(lt_le_trans _ x2p) ?ltrz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (le_lt_trans x1b) ?(lt_le_trans _ x1p) ?ltrz0.\nQed.",
    "Lemma BRight_le_mul_boundr b1 b2 (x1 x2 : R) :\n  (0 <= x1 -> x2 \\in Num.real -> BRight 0%Z <= b2 ->\n   BRight x1 <= num_itv_bound R b1 ->\n   BRight x2 <= num_itv_bound R b2 ->\n   BRight (x1 * x2) <= num_itv_bound R (mul_boundr b1 b2))%O.\nProof.\nmove=> x1ge0 x2r b2ge0 lex1b1 lex2b2.\nhave /orP[x2ge0 | x2le0] := x2r; first exact: num_itv_mul_boundr.\nhave lem0 : (BRight (x1 * x2) <= BRight 0%R)%O.\n  by rewrite bnd_simp mulr_ge0_le0 // ltW.\napply: le_trans lem0 _.\nrewrite -(mulr0z 1) BRight_le_num_itv_bound.\napply: mul_boundr_gt0 => //.\nby rewrite -(@BRight_le_num_itv_bound R) (le_trans _ lex1b1).\nQed.",
    "Lemma comparable_num_itv_bound (x y : itv_bound int) :\n  (num_itv_bound R x >=< num_itv_bound R y)%O.\nProof.\nby case: x y => [[] x | []] [[] y | []]//; apply/orP;\n  rewrite !bnd_simp ?ler_int ?ltr_int;\n  case: leP => xy; apply/orP => //; rewrite ltW ?orbT.\nQed.",
    "Lemma num_itv_bound_min (x y : itv_bound int) :\n  num_itv_bound R (Order.min x y)\n  = Order.min (num_itv_bound R x) (num_itv_bound R y).\nProof.\nhave [lexy | ltyx] := leP x y; [by rewrite !minEle le_num_itv_bound lexy|].\nrewrite minElt -if_neg -comparable_leNgt ?le_num_itv_bound ?ltW//.\nexact: comparable_num_itv_bound.\nQed.",
    "Lemma num_itv_bound_max (x y : itv_bound int) :\n  num_itv_bound R (Order.max x y)\n  = Order.max (num_itv_bound R x) (num_itv_bound R y).\nProof.\nhave [lexy | ltyx] := leP x y; [by rewrite !maxEle le_num_itv_bound lexy|].\nrewrite maxElt -if_neg -comparable_leNgt ?le_num_itv_bound ?ltW//.\nexact: comparable_num_itv_bound.\nQed.",
    "Lemma num_spec_mul (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 mul xi yi) :\n  num_spec r (x%:num * y%:num).\nProof.\nrewrite {}/r; case: xi yi x y => [//| [xl xu]] [//| [yl yu]].\ncase=> [x /=/and3P[xr /= xlx xxu]] [y /=/and3P[yr /= yly yyu]].\nrewrite -/(sign (Interval xl xu)) -/(sign (Interval yl yu)).\nhave ns000 : @Itv.num_sem R `[0, 0] 0 by apply/and3P.\nhave xyr : x * y \\in Num.real by exact: realM.\ncase: (signP xlx xxu xr) => xlb xub xs.\n- by rewrite xs mul0r; case: (signP yly yyu yr).\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=.\n    * exact: num_itv_mul_boundl xlx yly.\n    * exact: num_itv_mul_boundr xxu yyu.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK -mulrN.\n    * by rewrite opp_boundl num_itv_mul_boundr ?oppr_ge0// opp_boundr.\n    * by rewrite opp_boundr num_itv_mul_boundl ?opp_boundl// opp_bound_ge0.\n  + apply/and3P; split=> //=.\n    * rewrite  -[x * y]opprK -mulrN opp_boundl.\n      by rewrite BRight_le_mul_boundr ?realN ?opp_boundr// opp_bound_gt0 ltW.\n    * by rewrite BRight_le_mul_boundr// ltW.\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK -mulNr.\n    * rewrite opp_boundl.\n      by rewrite num_itv_mul_boundr ?oppr_ge0 ?opp_boundr.\n    * by rewrite opp_boundr num_itv_mul_boundl ?opp_boundl// opp_bound_ge0.\n  + apply/and3P; split=> //=; rewrite -mulrNN.\n    * by rewrite num_itv_mul_boundl ?opp_bound_ge0 ?opp_boundl.\n    * by rewrite num_itv_mul_boundr ?oppr_ge0 ?opp_boundr.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK.\n    * rewrite -mulNr opp_boundl BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr//.\n      exact: ltW.\n    * rewrite opprK -mulrNN.\n      by rewrite BRight_le_mul_boundr ?opp_boundr\n              ?oppr_ge0 ?realN ?opp_bound_gt0// ltW.\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=; rewrite mulrC mul_boundrC.\n    * rewrite -[y * x]opprK -mulrN opp_boundl.\n      rewrite BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n      by rewrite opp_bound_gt0 ltW.\n    * by rewrite BRight_le_mul_boundr// ltW.\n  + apply/and3P; split=> //=; rewrite mulrC mul_boundrC.\n    * rewrite -[y * x]opprK -mulNr opp_boundl.\n      by rewrite BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr// ltW.\n    * rewrite -mulrNN BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n      by rewrite opp_bound_gt0 ltW.\napply/and3P; rewrite xyr/= num_itv_bound_min num_itv_bound_max.\nrewrite (comparable_ge_min _ (comparable_num_itv_bound _ _)).\nrewrite (comparable_le_max _ (comparable_num_itv_bound _ _)).\ncase: (comparable_leP xr) => [x0 | /ltW x0]; split=> //.\n- apply/orP; right; rewrite -[x * y]opprK -mulrN opp_boundl.\n  by rewrite BRight_le_mul_boundr ?realN ?opp_boundr// opp_bound_gt0 ltW.\n- by apply/orP; right; rewrite BRight_le_mul_boundr// ltW.\n- apply/orP; left; rewrite -[x * y]opprK -mulNr opp_boundl.\n  by rewrite BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr// ltW.\n- apply/orP; left; rewrite -mulrNN.\n  rewrite BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n  by rewrite opp_bound_gt0 ltW.\nQed.",
    "Lemma num_spec_min (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 min xi yi) :\n  num_spec r (Order.min x%:num y%:num).\nProof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\napply/and3P; split; rewrite ?min_real//= num_itv_bound_min real_BSide_min//.\n- apply: (comparable_le_min2 (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\n- apply: (comparable_le_min2 _ (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\nQed.",
    "Lemma num_spec_max (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 max xi yi) :\n  num_spec r (Order.max x%:num y%:num).\nProof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\napply/and3P; split; rewrite ?max_real//= num_itv_bound_max real_BSide_max//.\n- apply: (comparable_le_max2 (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\n- apply: (comparable_le_max2 _ (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\nQed.",
    "Lemma nat_num_spec (i : Itv.t) (n : nat) : nat_spec i n = num_spec i (n%:R : R).\nProof.\ncase: i => [//| [l u]]; rewrite /= /Itv.num_sem realn/=; congr (_ && _).\n- by case: l => [[] l |//]; rewrite !bnd_simp ?pmulrn ?ler_int ?ltr_int.\n- by case: u => [[] u |//]; rewrite !bnd_simp ?pmulrn ?ler_int ?ltr_int.\nQed.",
    "Lemma num_spec_natmul (xi ni : Itv.t) (x : num_def R xi) (n : nat_def ni)\n    (r := natmul_itv xi ni) :\n  num_spec r (x%:num *+ n%:num).\nProof.\nrewrite {}/r; case: xi x ni n => [//| xi] x [| ni] n.\n  by apply/and3P; case: n%:num => [|?]; rewrite ?mulr0n ?realrMn.\nhave Pn : num_spec (Itv.Real ni) (n%:num%:R : R).\n  by case: n => /= n; rewrite [Itv.nat_sem ni n](nat_num_spec (Itv.Real ni)).\nrewrite -mulr_natr -[n%:num%:R]/((Itv.Def Pn)%:num).\nby rewrite (@num_spec_mul (Itv.Real xi) (Itv.Real ni)).\nQed.",
    "Lemma num_spec_int (i : Itv.t) (n : int) :\n  num_spec i n = num_spec i (n%:~R : R).\nProof.\ncase: i => [//| [l u]]; rewrite /= /Itv.num_sem num_real realz/=.\ncongr (andb _ _).\n- by case: l => [[] l |//]; rewrite !bnd_simp intz ?ler_int ?ltr_int.\n- by case: u => [[] u |//]; rewrite !bnd_simp intz ?ler_int ?ltr_int.\nQed.",
    "Lemma num_spec_intmul (xi ii : Itv.t) (x : num_def R xi) (i : num_def int ii)\n    (r := natmul_itv xi ii) :\n  num_spec r (x%:num *~ i%:num).\nProof.\nrewrite {}/r; case: xi x ii i => [//| xi] x [| ii] i.\n  by apply/and3P; case: i%:inum => [[|n] | n]; rewrite ?mulr0z ?realN ?realrMn.\nhave Pi : num_spec (Itv.Real ii) (i%:num%:~R : R).\n  by case: i => /= i; rewrite [Itv.num_sem ii i](num_spec_int (Itv.Real ii)).\nrewrite -mulrzr -[i%:num%:~R]/((Itv.Def Pi)%:num).\nby rewrite (@num_spec_mul (Itv.Real xi) (Itv.Real ii)).\nQed.",
    "Lemma num_itv_bound_keep_pos (op : R -> R) (x : R) b :\n  {homo op : x / 0 <= x} -> {homo op : x / 0 < x} ->\n  (num_itv_bound R b <= BLeft x)%O ->\n  (num_itv_bound R (keep_pos_bound b) <= BLeft (op x))%O.\nProof.\ncase: b => [[] [] [| b] // | []//] hle hlt; rewrite !bnd_simp.\n- exact: hle.\n- by move=> blex; apply: le_lt_trans (hlt _ _) => //; apply: lt_le_trans blex.\n- exact: hlt.\n- by move=> bltx; apply: le_lt_trans (hlt _ _) => //; apply: le_lt_trans bltx.\nQed.",
    "Lemma num_itv_bound_keep_neg (op : R -> R) (x : R) b :\n  {homo op : x / x <= 0} -> {homo op : x / x < 0} ->\n  (BRight x <= num_itv_bound R b)%O ->\n  (BRight (op x) <= num_itv_bound R (keep_neg_bound b))%O.\nProof.\ncase: b => [[] [[|//] | b] | []//] hge hgt; rewrite !bnd_simp.\n- exact: hgt.\n- by move=> xltb; apply: hgt; apply: lt_le_trans xltb _; rewrite lerz0.\n- exact: hge.\n- by move=> xleb; apply: hgt; apply: le_lt_trans xleb _; rewrite ltrz0.\nQed.",
    "Lemma num_spec_inv (i : Itv.t) (x : num_def R i) (r := Itv.real1 inv i) :\n  num_spec r (x%:num^-1).\nProof.\napply: Itv.spec_real1 (Itv.P x).\ncase: x => x /= _ [l u] /and3P[xr /= lx xu].\nrewrite /Itv.num_sem/= realV xr/=; apply/andP; split.\n- apply: num_itv_bound_keep_pos lx.\n  + by move=> ?; rewrite invr_ge0.\n  + by move=> ?; rewrite invr_gt0.\n- apply: num_itv_bound_keep_neg xu.\n  + by move=> ?; rewrite invr_le0.\n  + by move=> ?; rewrite invr_lt0.\nQed.",
    "Lemma num_itv_bound_exprn_le1 (x : R) n l u :\n  (num_itv_bound R l <= BLeft x)%O ->\n  (BRight x <= num_itv_bound R u)%O ->\n  (BRight (x ^+ n) <= num_itv_bound R (exprn_le1_bound l u))%O.\nProof.\ncase: u => [bu [[//|[|//]] |//] | []//].\nrewrite /exprn_le1_bound; case: (leP _ l) => [lge1 /= |//] lx xu.\nrewrite bnd_simp; case: n => [| n]; rewrite ?expr0//.\nhave xN1 : -1 <= x.\n  case: l lge1 lx => [[] l | []//]; rewrite !bnd_simp -(@ler_int R).\n  - exact: le_trans.\n  - by move=> + /ltW; apply: le_trans.\nhave x1 : x <= 1 by case: bu xu; rewrite bnd_simp// => /ltW.\nhave xr : x \\is Num.real by exact: ler1_real.\ncase: (real_ge0P xr) => x0; first by rewrite expr_le1.\nrewrite -[x]opprK exprNn; apply: le_trans (ler_piMl _ _) _.\n- by rewrite exprn_ge0 ?oppr_ge0 1?ltW.\n- suff: -1 <= (-1) ^+ n.+1 :> R /\\ (-1) ^+ n.+1 <= 1 :> R => [[]//|].\n  elim: n => [|n [IHn1 IHn2]]; rewrite ?expr1// ![_ ^+ n.+2]exprS !mulN1r.\n  by rewrite lerNl opprK lerNl.\n- by rewrite expr_le1 ?oppr_ge0 1?lerNl// ltW.\nQed.",
    "Lemma num_spec_exprn (i : Itv.t) (x : num_def R i) n (r := Itv.real1 exprn i) :\n  num_spec r (x%:num ^+ n).\nProof.\napply: (@Itv.spec_real1 _ _ (fun x => x^+n) _ _ _ _ (Itv.P x)).\ncase: x => x /= _ [l u] /and3P[xr /= lx xu].\nrewrite /Itv.num_sem realX//=; apply/andP; split.\n- apply: (@num_itv_bound_keep_pos (fun x => x^+n)) lx.\n  + exact: exprn_ge0.\n  + exact: exprn_gt0.\n- exact: num_itv_bound_exprn_le1 lx xu.\nQed.",
    "Lemma num_spec_exprz (xi ki : Itv.t) (x : num_def R xi) (k : num_def int ki)\n    (r := Itv.real2 exprz xi ki) :\n  num_spec r (x%:num ^ k%:num).\nProof.\nrewrite {}/r; case: ki k => [|[lk uk]] k; first by case: xi x.\ncase: xi x => [//|xi x]; rewrite /Itv.real2.\nhave P : Itv.num_sem\n    (let 'Interval l _ := xi in Interval (keep_pos_bound l) +oo)\n    (x%:num ^ k%:num).\n  case: xi x => lx ux x; apply/and3P; split=> [||//].\n    have xr : x%:num \\is Num.real by case: x => x /=/andP[].\n    by case: k%:num => n; rewrite ?realV realX.\n  apply: (@num_itv_bound_keep_pos (fun x => x ^ k%:num));\n    [exact: exprz_ge0 | exact: exprz_gt0 |].\n  by case: x => x /=/and3P[].\ncase: lk k P => [slk [lk | lk] | slk] k P; [|exact: P..].\ncase: k P => -[k | k] /= => [_ _|]; rewrite -/(exprn xi); last first.\n  by move=> /and3P[_ /=]; case: slk; rewrite bnd_simp -pmulrn natz.\nexact: (@num_spec_exprn (Itv.Real xi)).\nQed.",
    "Lemma num_spec_norm {V : normedZmodType R} (x : V) :\n  num_spec (Itv.Real `[0, +oo[) `|x|.\nProof. by apply/and3P; split; rewrite //= ?normr_real ?bnd_simp ?normr_ge0. Qed.",
    "Lemma num_spec_sqrt (i : Itv.t) (x : num_def R i) (r := sqrt_itv i) :\n  num_spec r (Num.sqrt x%:num).\nProof.\nhave: Itv.num_sem `[0%Z, +oo[ (Num.sqrt x%:num).\n  by apply/and3P; rewrite /= num_real !bnd_simp sqrtr_ge0.\nrewrite {}/r; case: i x => [//| [[bl [l |//] |//] u]] [x /= +] _.\ncase: bl l => -[| l] /and3P[xr /= bx _]; apply/and3P; split=> //=;\n  move: bx; rewrite !bnd_simp ?sqrtr_ge0// sqrtr_gt0;\n  [exact: lt_le_trans | exact: le_lt_trans..].\nQed.",
    "Lemma num_spec_sqrtC (i : Itv.t) (x : num_def R i) (r := sqrtC_itv i) :\n  num_spec r (sqrtC x%:num).\nProof.\nrewrite {}/r; case: i x => [//| [l u] [x /=/and3P[xr /= lx xu]]].\ncase: l lx => [bl [l |//] |[]//] lx; apply/and3P; split=> //=.\n  by apply: sqrtC_real; case: bl lx => /[!bnd_simp] [|/ltW]; apply: le_trans.\ncase: bl lx => /[!bnd_simp] lx.\n- by rewrite sqrtC_ge0; apply: le_trans lx.\n- by rewrite sqrtC_gt0; apply: le_lt_trans lx.\nQed.",
    "Lemma nat_spec_zero : nat_spec (Itv.Real `[0, 0]%Z) 0. Proof. by []. Qed.",
    "Lemma nat_spec_add (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 add xi yi) :\n  nat_spec r (x%:num + y%:num).\nProof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) natrD.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_add.\nQed.",
    "Lemma nat_spec_succ (i : Itv.t) (n : nat_def i)\n    (r := Itv.real2 add i (Itv.Real `[1, 1]%Z)) :\n  nat_spec r (S n%:num).\nProof.\npose i1 := Itv.Real `[1, 1]%Z; have P1 : nat_spec i1 1 by [].\nby rewrite -addn1 -[1%N]/((Itv.Def P1)%:num); apply: nat_spec_add.\nQed.",
    "Lemma nat_spec_double (i : Itv.t) (n : nat_def i) (r := Itv.real2 add i i) :\n  nat_spec r (n%:num.*2).\nProof. by rewrite -addnn nat_spec_add. Qed.",
    "Lemma nat_spec_mul (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 mul xi yi) :\n  nat_spec r (x%:num * y%:num).\nProof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) natrM.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_mul.\nQed.",
    "Lemma nat_spec_exp (i : Itv.t) (x : nat_def i) n (r := Itv.real1 exprn i) :\n  nat_spec r (x%:num ^ n).\nProof.\nhave Px : num_spec i (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) natrX -[x%:num%:R]/((Itv.Def Px)%:num).\nexact: num_spec_exprn.\nQed.",
    "Lemma nat_spec_min (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 min xi yi) :\n  nat_spec r (minn x%:num y%:num).\nProof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) -minEnat natr_min.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_min.\nQed.",
    "Lemma nat_spec_max (xi yi : Itv.t) (x : nat_def xi) (y : nat_def yi)\n    (r := Itv.real2 max xi yi) :\n  nat_spec r (maxn x%:num y%:num).\nProof.\nhave Px : num_spec xi (x%:num%:R : int).\n  by case: x => /= x; rewrite (@nat_num_spec int).\nhave Py : num_spec yi (y%:num%:R : int).\n  by case: y => /= y; rewrite (@nat_num_spec int).\nrewrite (@nat_num_spec int) -maxEnat natr_max.\nrewrite -[x%:num%:R]/((Itv.Def Px)%:num) -[y%:num%:R]/((Itv.Def Py)%:num).\nexact: num_spec_max.\nQed.",
    "Lemma nat_spec_factorial (n : nat) : nat_spec (Itv.Real `[1%Z, +oo[) n`!.\nProof. by apply/andP; rewrite bnd_simp lez_nat fact_gt0. Qed.",
    "Lemma num_spec_Posz n : num_spec (Itv.Real `[0, +oo[) (Posz n).\nProof. by apply/and3P; rewrite /= num_real !bnd_simp. Qed.",
    "Lemma num_spec_Negz n : num_spec (Itv.Real `]-oo, -1]) (Negz n).\nProof. by apply/and3P; rewrite /= num_real !bnd_simp. Qed.",
    "Lemma num_eq : {mono num : x y / x == y}. Proof. by []. Qed.",
    "Lemma num_le : {mono num : x y / (x <= y)%O}. Proof. by []. Qed.",
    "Lemma num_lt : {mono num : x y / (x < y)%O}. Proof. by []. Qed.",
    "Lemma num_min : {morph num : x y / Order.min x y}.\nProof. by move=> x y; rewrite !minEle num_le -fun_if. Qed.",
    "Lemma num_max : {morph num : x y / Order.max x y}.\nProof. by move=> x y; rewrite !maxEle num_le -fun_if. Qed.",
    "Lemma num_abs_eq0 (a : R) : (`|a|%:nng == 0%:nng) = (a == 0).\nProof. by rewrite -normr_eq0. Qed.",
    "Lemma num_le_max a x y :\n  a <= Num.max x%:num y%:num = (a <= x%:num) || (a <= y%:num).\nProof. by rewrite -comparable_le_max// real_comparable. Qed.",
    "Lemma num_ge_max a x y :\n  Num.max x%:num y%:num <= a = (x%:num <= a) && (y%:num <= a).\nProof. by rewrite -comparable_ge_max// real_comparable. Qed.",
    "Lemma num_le_min a x y :\n  a <= Num.min x%:num y%:num = (a <= x%:num) && (a <= y%:num).\nProof. by rewrite -comparable_le_min// real_comparable. Qed.",
    "Lemma num_ge_min a x y :\n  Num.min x%:num y%:num <= a = (x%:num <= a) || (y%:num <= a).\nProof. by rewrite -comparable_ge_min// real_comparable. Qed.",
    "Lemma num_lt_max a x y :\n  a < Num.max x%:num y%:num = (a < x%:num) || (a < y%:num).\nProof. by rewrite -comparable_lt_max// real_comparable. Qed.",
    "Lemma num_gt_max a x y :\n  Num.max x%:num  y%:num < a = (x%:num < a) && (y%:num < a).\nProof. by rewrite -comparable_gt_max// real_comparable. Qed.",
    "Lemma num_lt_min a x y :\n  a < Num.min x%:num y%:num = (a < x%:num) && (a < y%:num).\nProof. by rewrite -comparable_lt_min// real_comparable. Qed.",
    "Lemma num_gt_min a x y :\n  Num.min x%:num y%:num < a = (x%:num < a) || (y%:num < a).\nProof. by rewrite -comparable_gt_min// real_comparable. Qed.",
    "Lemma num_abs_le a x : 0 <= a -> (`|a|%:nng <= x) = (a <= x%:num).\nProof. by move=> a0; rewrite -num_le//= ger0_norm. Qed.",
    "Lemma num_abs_lt a x : 0 <= a -> (`|a|%:nng < x) = (a < x%:num).\nProof. by move=> a0; rewrite -num_lt/= ger0_norm. Qed.",
    "Lemma itvnum_subdef : num_spec (Itv.Real (Interval l u)) x.\nProof. by apply/and3P. Qed.",
    "Lemma itvreal_subdef : num_spec (Itv.Real (Interval l u)) x.\nProof. by apply/and3P; split; first exact: num_real. Qed.",
    "Lemma itv01_subdef : num_spec (Itv.Real `[0%Z, 1%Z]) x.\nProof. by apply/and3P; split; rewrite ?bnd_simp// ger0_real. Qed.",
    "Lemma posnum_subdef : num_spec (Itv.Real `]0, +oo[) x.\nProof. by apply/and3P; rewrite /= gtr0_real. Qed.",
    "Lemma nngnum_subdef : num_spec (Itv.Real `[0, +oo[) x.\nProof. by apply/and3P; rewrite /= ger0_real. Qed.",
    "Lemma posnumP (R : numDomainType) (x : R) : 0 < x ->\n  posnum_spec x x (x == 0) (0 <= x) (0 < x).\nProof.\nmove=> x_gt0; case: real_ltgt0P (x_gt0) => []; rewrite ?gtr0_real // => _ _.\nby rewrite -[x]/(PosNum x_gt0)%:num; constructor.\nQed.",
    "Lemma nonnegP (R : numDomainType) (x : R) : 0 <= x -> nonneg_spec x x (0 <= x).\nProof. by move=> xge0; rewrite xge0 -[x]/(NngNum xge0)%:num; constructor. Qed.",
    "Lemma s_of_p0 (p : {i01 R}) : s_of_pq p 0%:i01 = p.\nProof. by apply/val_inj; rewrite /= subr0 mulr1 subKr. Qed.",
    "Lemma Zp_opp_subproof i : (p - i) %% p < p.\nProof. by case: p i => [[]//|k] i; apply/ltn_pmod. Qed.",
    "Lemma Zp_add_subproof i j : (i + j) %% p < p.\nProof. by case: p i j => [[]//|k] i j; apply/ltn_pmod. Qed.",
    "Lemma Zp_mul_subproof i j : (i * j) %% p < p.\nProof. by case: p i j => [[]//|k] i j; apply/ltn_pmod. Qed.",
    "Lemma Zp_inv_subproof i : (egcdn i p).1 %% p < p.\nProof. by case: p i => [[]//|k] i; apply/ltn_pmod. Qed.",
    "Lemma Zp_addA : associative Zp_add.\nProof.\nby move=> x y z; apply: val_inj; rewrite /= modnDml modnDmr addnA.\nQed.",
    "Lemma Zp_addC : commutative Zp_add.\nProof. by move=> x y; apply: val_inj; rewrite /= addnC. Qed.",
    "Lemma Zp_mulC : commutative Zp_mul.\nProof. by move=> x y; apply: val_inj; rewrite /= mulnC. Qed.",
    "Lemma Zp_mulA : associative Zp_mul.\nProof.\nby move=> x y z; apply: val_inj; rewrite /= modnMml modnMmr mulnA.\nQed.",
    "Lemma Zp_mul_addr : right_distributive Zp_mul Zp_add.\nProof.\nby move=> x y z; apply: val_inj; rewrite /= modnMmr modnDm mulnDr.\nQed.",
    "Lemma Zp_mul_addl : left_distributive Zp_mul Zp_add.\nProof. by move=> x y z; rewrite -!(Zp_mulC z) Zp_mul_addr. Qed.",
    "Lemma Zp_inv_out i : ~~ coprime p i -> Zp_inv i = i.\nProof. by rewrite /Zp_inv => /negPf->. Qed.",
    "Lemma modZp x : x %% p = x.\nProof. by rewrite modn_small ?ltn_ord. Qed.",
    "Lemma valZpK x : inZp x = x.\nProof. by apply: val_inj; rewrite /= modZp. Qed.",
    "Lemma Zp_add0z : left_id Zp0 Zp_add.\nProof. by move=> x; apply: val_inj; rewrite /= modZp. Qed.",
    "Lemma Zp_addNz : left_inverse Zp0 Zp_opp Zp_add.\nProof.\nby move=> x; apply: val_inj; rewrite /= modnDml subnK ?modnn // ltnW.\nQed.",
    "Lemma Zp_mul1z : left_id Zp1 Zp_mul.\nProof. by move=> x; apply: val_inj; rewrite /= modnMml mul1n modZp. Qed.",
    "Lemma Zp_mulz1 : right_id Zp1 Zp_mul.\nProof. by move=> x; rewrite Zp_mulC Zp_mul1z. Qed.",
    "Lemma Zp_mulVz x : coprime p x -> Zp_mul (Zp_inv x) x = Zp1.\nProof.\nmove=> co_p_x; apply: val_inj; rewrite /Zp_inv co_p_x /= modnMml.\nby rewrite -(chinese_modl co_p_x 1 0) /chinese addn0 mul1n mulnC.\nQed.",
    "Lemma Zp_mulzV x : coprime p x -> Zp_mul x (Zp_inv x) = Zp1.\nProof. by move=> Ux; rewrite /= Zp_mulC Zp_mulVz. Qed.",
    "Lemma Zp_intro_unit x y : Zp_mul y x = Zp1 -> coprime p x.\nProof.\ncase=> yx1; have:= coprimen1 p.\nby rewrite -coprime_modr -yx1 coprime_modr coprimeMr; case/andP.\nQed.",
    "Lemma Zp_mulrn x n : x *+ n = inZp (x * n).\nProof.\napply: val_inj => /=; elim: n => [|n IHn]; first by rewrite muln0 modn_small.\nby rewrite !GRing.mulrS /= IHn modnDmr mulnS.\nQed.",
    "Lemma Zp_mulgC : @commutative 'I_p _ mulg.\nProof. exact: Zp_addC. Qed.",
    "Lemma Zp_abelian : abelian [set: 'I_p].\nProof. exact: FinRing.zmod_abelian. Qed.",
    "Lemma Zp_expg x n : x ^+ n = inZp (x * n).\nProof. exact: Zp_mulrn. Qed.",
    "Lemma Zp1_expgz x : Zp1 ^+ x = x.\nProof.\nrewrite Zp_expg; apply/val_inj.\nby move: (Zp_mul1z x) => /(congr1 val).\nQed.",
    "Lemma Zp_cycle : setT = <[Zp1]>.\nProof. by apply/setP=> x; rewrite -[x]Zp1_expgz inE groupX ?mem_gen ?set11. Qed.",
    "Lemma order_Zp1 : #[Zp1] = p.\nProof. by rewrite orderE -Zp_cycle cardsT card_ord. Qed.",
    "Lemma ord1 : all_equal_to (0 : 'I_1).\nProof. exact: ord1. Qed.",
    "Lemma lshift0 m n : lshift m (0 : 'I_n.+1) = (0 : 'I_(n + m).+1).\nProof. exact: val_inj. Qed.",
    "Lemma rshift1 n : @rshift 1 n =1 lift (0 : 'I_n.+1).\nProof. by move=> i; apply: val_inj. Qed.",
    "Lemma split1 n i :\n  split (i : 'I_(1 + n)) = oapp (@inr _ _) (inl _ 0) (unlift 0 i).\nProof.\ncase: unliftP => [i'|] -> /=.\n  by rewrite -rshift1 (unsplitK (inr _ _)).\nby rewrite -(lshift0 n 0) (unsplitK (inl _ _)).\nQed.",
    "Lemma Zp_nontrivial : Zp1 != 0 :> 'I_p. Proof. by []. Qed.",
    "Lemma Zp_nat n : n%:R = inZp n :> 'I_p.\nProof. by apply: val_inj; rewrite [n%:R]Zp_mulrn /= modnMml mul1n. Qed.",
    "Lemma natr_Zp (x : 'I_p) : x%:R = x.\nProof. by rewrite Zp_nat valZpK. Qed.",
    "Lemma natr_negZp (x : 'I_p) : (- x)%:R = - x.\nProof. by apply: val_inj; rewrite /= Zp_nat /= modn_mod. Qed.",
    "Lemma unit_Zp_mulgC : @commutative {unit 'I_p} _ mulg.\nProof. by move=> u v; apply: val_inj; rewrite /= GRing.mulrC. Qed.",
    "Lemma unit_Zp_expg (u : {unit 'I_p}) n :\n  val (u ^+ n) = inZp (val u ^ n) :> 'I_p.\nProof.\napply: val_inj => /=; elim: n => [|n IHn] //.\nby rewrite expgS /= IHn expnS modnMmr.\nQed.",
    "Lemma add_1_Zp p (x : 'Z_p) : 1 + x = ordS x.\nProof. by case: p => [|[|p]] in x *; apply/val_inj. Qed.",
    "Lemma add_Zp_1 p (x : 'Z_p) : x + 1 = ordS x.\nProof. by rewrite addrC add_1_Zp. Qed.",
    "Lemma sub_Zp_1 p (x : 'Z_p) : x - 1 = ord_pred x.\nProof. by apply: (addIr 1); rewrite addrNK add_Zp_1 ord_predK. Qed.",
    "Lemma add_N1_Zp p (x : 'Z_p) : -1 + x = ord_pred x.\nProof. by rewrite addrC sub_Zp_1. Qed.",
    "Lemma Zp_cast : p > 1 -> (Zp_trunc p).+2 = p.\nProof. by case: p => [|[]]. Qed.",
    "Lemma val_Zp_nat (p_gt1 : p > 1) n : (n%:R : 'Z_p) = (n %% p)%N :> nat.\nProof. by rewrite Zp_nat /= Zp_cast. Qed.",
    "Lemma Zp_nat_mod (p_gt1 : p > 1)m : (m %% p)%:R = m%:R :> 'Z_p.\nProof. by apply: ord_inj; rewrite !val_Zp_nat // modn_mod. Qed.",
    "Lemma pchar_Zp : p > 1 -> p%:R = 0 :> 'Z_p.\nProof. by move=> p_gt1; rewrite -Zp_nat_mod ?modnn. Qed.",
    "Lemma unitZpE x : p > 1 -> ((x%:R : 'Z_p) \\is a GRing.unit) = coprime p x.\nProof.\nmove=> p_gt1; rewrite qualifE /=.\nby rewrite val_Zp_nat ?Zp_cast ?coprime_modr.\nQed.",
    "Lemma Zp_group_set : group_set Zp.\nProof. by rewrite /Zp; case: (p > 1); apply: groupP. Qed.",
    "Lemma card_Zp : p > 0 -> #|Zp| = p.\nProof.\nrewrite /Zp; case: p => [|[|p']] //= _; first by rewrite cards1.\nby rewrite cardsT card_ord.\nQed.",
    "Lemma mem_Zp x : p > 1 -> x \\in Zp. Proof. by rewrite /Zp => ->. Qed.",
    "Lemma card_units_Zp : p > 0 -> #|units_Zp| = totient p.\nProof.\nmove=> p_gt0; transitivity (totient p.-2.+2); last by case: p p_gt0 => [|[|p']].\nrewrite cardsT card_sub -sum1_card big_mkcond /=.\nby rewrite totient_count_coprime big_mkord.\nQed.",
    "Lemma units_Zp_abelian : abelian units_Zp.\nProof. by apply/centsP=> u _ v _; apply: unit_Zp_mulgC. Qed.",
    "Lemma Fp_Zcast : Zp_trunc (pdiv p) = Zp_trunc p.\nProof. by rewrite /pdiv primes_prime. Qed.",
    "Lemma Fp_cast : (Zp_trunc (pdiv p)).+2 = p.\nProof. by rewrite Fp_Zcast ?Zp_cast ?prime_gt1. Qed.",
    "Lemma card_Fp : #|'F_p| = p.\nProof. by rewrite card_ord Fp_cast. Qed.",
    "Lemma val_Fp_nat n : (n%:R : 'F_p) = (n %% p)%N :> nat.\nProof. by rewrite Zp_nat /= Fp_cast. Qed.",
    "Lemma Fp_nat_mod m : (m %% p)%:R = m%:R :> 'F_p.\nProof. by apply: ord_inj; rewrite !val_Fp_nat // modn_mod. Qed.",
    "Lemma pchar_Fp : p \\in [pchar 'F_p].\nProof. by rewrite !inE -Fp_nat_mod p_pr ?modnn. Qed.",
    "Lemma pchar_Fp_0 : p%:R = 0 :> 'F_p.\nProof. exact: GRing.pcharf0 pchar_Fp. Qed.",
    "Lemma unitFpE x : ((x%:R : 'F_p) \\is a GRing.unit) = coprime p x.\nProof. by rewrite pdiv_id // unitZpE // prime_gt1. Qed.",
    "Lemma Fp_fieldMixin : GRing.ComUnitRing_isField 'F_p.\nProof.\nconstructor => x nzx.\nrewrite qualifE /= prime_coprime ?gtnNdvd ?lt0n //.\ncase: (ltnP 1 p) => [lt1p | ]; last by case: p => [|[|p']].\nby rewrite Zp_cast ?prime_gt1 ?pdiv_prime.\nQed.",
    "Lemma gen_tperm_step n (k : 'I_n.+1) : coprime n.+1 k ->\n  <<[set tperm i (i + k) | i : 'I_n.+1]>>%g = [set: 'S_n.+1].\nProof.\ncase: n k => [|n] k.\n  move=> _; apply/eqP; rewrite eqEsubset subsetT/= -(gen_tperm 0)/= gen_subG.\n  apply/subsetP => s /imsetP[/= [][|//] lt01 _ ->].\n  have ->: (Ordinal lt01) = 0 by apply/val_inj.\n  by rewrite tperm1 group1.\nrewrite -unitZpE// natr_Zp => k_unit.\napply/eqP; rewrite eqEsubset subsetT/= -(gen_tperm 0)/= gen_subG.\napply/subsetP => s /imsetP[/= i _ ->].\nrewrite -[i](mulVKr k_unit) -[_ * i]natr_Zp mulr_natr.\nelim: (val _) => //= {i} [|[|i] IHi]; first by rewrite tperm1 group1.\n  by rewrite mulrSr mem_gen//; apply/imsetP; exists 0.\nhave [->|kS2N0] := eqVneq (k *+ i.+2) 0; first by rewrite tperm1 group1.\nhave kSSneqkS : k *+ i.+2 != k *+ i.+1.\n  rewrite -subr_eq0 -mulrnBr// subSnn mulr1n.\n  by apply: contraTneq k_unit => ->; rewrite unitr0.\nrewrite -(@tpermJ_tperm _ (k *+ i.+1)) 1?eq_sym//.\nrewrite groupJ// 1?tpermC// mulrSr 1?tpermC.\nby rewrite mem_gen//; apply/imsetP; exists (k *+ i.+1).\nQed.",
    "Lemma perm_addr1X n m (j k : 'I_n.+1) : (perm (addrI m%R) ^+ j)%g k = m *+ j + k.\nProof. by rewrite permX (eq_iter (permE _)) iter_addr. Qed.",
    "Lemma gen_tpermn_circular_shift n (i j : 'I_n.+2)\n    (c := perm (addrI 1)) : coprime n.+2 (j - i)%R ->\n  <<[set tperm i j ; c]>>%g = [set: 'S_n.+2].\nProof.\nmove=> jBi_coprime; apply/eqP; rewrite eqEsubset subsetT/=.\nrewrite -(gen_tperm_step jBi_coprime) gen_subG.\napply/subsetP => s /imsetP[/= k _ ->].\nsuff -> : tperm k (k + (j - i)) = (tperm i j ^ c ^+ (k - i)%R)%g.\n  by rewrite groupJ ?groupX ?mem_gen ?inE ?eqxx ?orbT.\nby rewrite tpermJ !perm_addr1X natr_Zp addrNK addrAC addrA.\nQed.",
    "Lemma ger0_def x : (0 <= x) = (`|x| == x).\nProof. by rewrite ler_def subr0. Qed.",
    "Lemma subr_ge0 x y : (0 <= x - y) = (y <= x).\nProof. by rewrite ger0_def -ler_def. Qed.",
    "Lemma oppr_ge0 x : (0 <= - x) = (x <= 0).\nProof. by rewrite -sub0r subr_ge0. Qed.",
    "Lemma ler01 : 0 <= 1 :> R.\nProof.\nhave n1_nz: `|1 : R| != 0 by apply: contraNneq (@oner_neq0 R) => /normr0_eq0->.\nby rewrite ger0_def -(inj_eq (mulfI n1_nz)) -normrM !mulr1.\nQed.",
    "Lemma ltr01 : 0 < 1 :> R. Proof. by rewrite lt_def oner_neq0 ler01. Qed.",
    "Lemma le0r x : (0 <= x) = (x == 0) || (0 < x).\nProof. by rewrite le_eqVlt eq_sym. Qed.",
    "Lemma addr_ge0 x y : 0 <= x -> 0 <= y -> 0 <= x + y.\nProof.\nrewrite le0r; case/predU1P=> [-> | x_pos]; rewrite ?add0r // le0r.\nby case/predU1P=> [-> | y_pos]; rewrite ltW ?addr0 ?addr_gt0.\nQed.",
    "Lemma pmulr_rgt0 x y : 0 < x -> (0 < x * y) = (0 < y).\nProof.\nrewrite !lt_def !ger0_def normrM mulf_eq0 negb_or => /andP[x_neq0 /eqP->].\nby rewrite x_neq0 (inj_eq (mulfI x_neq0)).\nQed.",
    "Lemma posrE x : (x \\is pos) = (0 < x). Proof. by []. Qed.",
    "Lemma nnegrE x : (x \\is nneg) = (0 <= x). Proof. by []. Qed.",
    "Lemma realE x : (x \\is real) = (0 <= x) || (x <= 0). Proof. by []. Qed.",
    "Lemma num_real (R : realDomainType) (x : R) : x \\is real.\nProof. exact: le_total. Qed.",
    "Lemma poly_ivt : real_closed_axiom R. Proof. exact: poly_ivt_subproof. Qed.",
    "Lemma posrE x : (x \\is pos) = (0 < x). Proof. by []. Qed.",
    "Lemma negrE x : (x \\is neg) = (x < 0). Proof. by []. Qed.",
    "Lemma nnegrE x : (x \\is nneg) = (0 <= x). Proof. by []. Qed.",
    "Lemma nposrE x : (x \\is npos) = (x <= 0). Proof. by []. Qed.",
    "Lemma realE x : (x \\is real) = (0 <= x) || (x <= 0). Proof. by []. Qed.",
    "Lemma lt0r x : (0 < x) = (x != 0) && (0 <= x). Proof. exact: lt_def. Qed.",
    "Lemma le0r x : (0 <= x) = (x == 0) || (0 < x). Proof. exact: le0r. Qed.",
    "Lemma lt0r_neq0 (x : R) : 0 < x -> x != 0. Proof. by move=> /gt_eqF ->. Qed.",
    "Lemma ltr0_neq0 (x : R) : x < 0 -> x != 0. Proof. by move=> /lt_eqF ->. Qed.",
    "Lemma pmulr_rgt0 x y : 0 < x -> (0 < x * y) = (0 < y).\nProof. exact: pmulr_rgt0. Qed.",
    "Lemma pmulr_rge0 x y : 0 < x -> (0 <= x * y) = (0 <= y).\nProof. by move=> x_gt0; rewrite !le0r mulf_eq0 pmulr_rgt0 // gt_eqF. Qed.",
    "Lemma ler01 : 0 <= 1 :> R. Proof. exact: ler01. Qed.",
    "Lemma ltr01 : 0 < 1 :> R. Proof. exact: ltr01. Qed.",
    "Lemma ler0n n : 0 <= n%:R :> R. Proof. by rewrite -nnegrE rpred_nat. Qed.",
    "Lemma ltr0Sn n : 0 < n.+1%:R :> R.\nProof. by elim: n => // n; apply: addr_gt0. Qed.",
    "Lemma ltr0n n : (0 < n%:R :> R) = (0 < n)%N.\nProof. by case: n => //= n; apply: ltr0Sn. Qed.",
    "Lemma pnatr_eq0 n : (n%:R == 0 :> R) = (n == 0)%N.\nProof. by case: n => [|n]; rewrite ?mulr0n ?eqxx // gt_eqF. Qed.",
    "Lemma pchar_num : [pchar R] =i pred0.\nProof. by case=> // p /=; rewrite !inE pnatr_eq0 andbF. Qed.",
    "Lemma ger0_def x : (0 <= x) = (`|x| == x). Proof. exact: ger0_def. Qed.",
    "Lemma normr_idP {x} : reflect (`|x| = x) (0 <= x).\nProof. by rewrite ger0_def; apply: eqP. Qed.",
    "Lemma ger0_norm x : 0 <= x -> `|x| = x. Proof. exact: normr_idP. Qed.",
    "Lemma normr1 : `|1 : R| = 1. Proof. exact: ger0_norm. Qed.",
    "Lemma normr_nat n : `|n%:R : R| = n%:R. Proof. exact: ger0_norm. Qed.",
    "Lemma normr_prod I r (P : pred I) (F : I -> R) :\n  `|\\prod_(i <- r | P i) F i| = \\prod_(i <- r | P i) `|F i|.\nProof. exact: (big_morph norm normrM normr1). Qed.",
    "Lemma normrX n x : `|x ^+ n| = `|x| ^+ n.\nProof. by rewrite -(card_ord n) -!prodr_const normr_prod. Qed.",
    "Lemma normr_unit : {homo (@norm _  R) : x / x \\is a GRing.unit}.\nProof.\nmove=> x /= /unitrP [y [yx xy]]; apply/unitrP; exists `|y|.\nby rewrite -!normrM xy yx normr1.\nQed.",
    "Lemma normrV : {in GRing.unit, {morph (@norm _  R) : x / x ^-1}}.\nProof.\nmove=> x ux; apply: (mulrI (normr_unit ux)).\nby rewrite -normrM !divrr ?normr1 ?normr_unit.\nQed.",
    "Lemma normrN1 : `|-1 : R| = 1.\nProof.\nhave: `|-1 : R| ^+ 2 == 1 by rewrite -normrX -signr_odd normr1.\nrewrite sqrf_eq1 => /orP[/eqP //|]; rewrite -ger0_def le0r oppr_eq0 oner_eq0.\nby move/(addr_gt0 ltr01); rewrite subrr ltxx.\nQed.",
    "Lemma big_real x0 op I (P : pred I) F (s : seq I) :\n  {in real &, forall x y, op x y \\is real} -> x0 \\is real ->\n  {in P, forall i, F i \\is real} -> \\big[op/x0]_(i <- s | P i) F i \\is real.\nProof. exact: comparable_bigr. Qed.",
    "Lemma sum_real I (P : pred I) (F : I -> R) (s : seq I) :\n  {in P, forall i, F i \\is real} -> \\sum_(i <- s | P i) F i \\is real.\nProof. by apply/big_real; [apply: rpredD | apply: rpred0]. Qed.",
    "Lemma prod_real I (P : pred I) (F : I -> R) (s : seq I) :\n  {in P, forall i, F i \\is real} -> \\prod_(i <- s | P i) F i \\is real.\nProof. by apply/big_real; [apply: rpredM | apply: rpred1]. Qed.",
    "Lemma normr0 : `|0 : V| = 0.\nProof. by rewrite -(mulr0n 0) normrMn mulr0n. Qed.",
    "Lemma distrC v w : `|v - w| = `|w - v|.\nProof. by rewrite -opprB normrN. Qed.",
    "Lemma normr_id v : `| `|v| | = `|v|.\nProof.\nhave nz2: 2 != 0 :> R by rewrite pnatr_eq0.\napply: (mulfI nz2); rewrite -{1}normr_nat -normrM mulr_natl mulr2n ger0_norm //.\nby rewrite -{2}normrN -normr0 -(subrr v) ler_normD.\nQed.",
    "Lemma normr_ge0 v : 0 <= `|v|. Proof. by rewrite ger0_def normr_id. Qed.",
    "Lemma normr_lt0 v : `|v| < 0 = false.\nProof. by rewrite le_gtF// normr_ge0. Qed.",
    "Lemma gtr0_norm_neq0 v : `|v| > 0 -> (v != 0).\nProof. by apply: contra_ltN => /eqP->; rewrite normr0. Qed.",
    "Lemma gtr0_norm_eq0F v : `|v| > 0 -> (v == 0) = false.\nProof. by move=> /gtr0_norm_neq0/negPf->. Qed.",
    "Lemma normr0P v : reflect (`|v| = 0) (v == 0).\nProof. by apply: (iffP eqP)=> [->|/normr0_eq0 //]; apply: normr0. Qed.",
    "Lemma normr_le0 v : `|v| <= 0 = (v == 0).\nProof. by rewrite -normr_eq0 eq_le normr_ge0 andbT. Qed.",
    "Lemma normr_gt0 v : `|v| > 0 = (v != 0).\nProof. by rewrite lt_def normr_eq0 normr_ge0 andbT. Qed.",
    "Lemma ler0_def x : (x <= 0) = (`|x| == - x).\nProof. by rewrite ler_def sub0r normrN. Qed.",
    "Lemma ler0_norm x : x <= 0 -> `|x| = - x.\nProof. by move=> x_le0; rewrite -[r in _ = r]ger0_norm ?normrN ?oppr_ge0. Qed.",
    "Lemma ger0_le_norm :\n  {in nneg &, {mono (@normr _ R) : x y / x <= y}}.\nProof. by move=> x y; rewrite !nnegrE => x0 y0; rewrite !ger0_norm. Qed.",
    "Lemma gtr0_le_norm :\n  {in pos &, {mono (@normr _ R) : x y / x <= y}}.\nProof. by move=> x y; rewrite !posrE => /ltW x0 /ltW y0; exact: ger0_le_norm. Qed.",
    "Lemma ler0_ge_norm :\n  {in npos &, {mono (@normr _ R) : x y / x <= y >-> x >= y}}.\nProof.\nmove=> x y; rewrite !nposrE => x0 y0.\nby rewrite !ler0_norm// -[LHS]subr_ge0 opprK addrC subr_ge0.\nQed.",
    "Lemma ltr0_ge_norm :\n  {in neg &, {mono (@normr _ R) : x y / x <= y >-> x >= y}}.\nProof. by move=> x y; rewrite !negrE => /ltW x0 /ltW y0; exact: ler0_ge_norm. Qed.",
    "Lemma subr_ge0 x y : (0 <= y - x) = (x <= y). Proof. exact: subr_ge0. Qed.",
    "Lemma subr_gt0 x y : (0 < y - x) = (x < y).\nProof. by rewrite !lt_def subr_eq0 subr_ge0. Qed.",
    "Lemma subr_le0  x y : (y - x <= 0) = (y <= x).\nProof. by rewrite -[LHS]subr_ge0 opprB add0r subr_ge0. Qed.",
    "Lemma subr_lt0  x y : (y - x < 0) = (y < x).\nProof. by rewrite -[LHS]subr_gt0 opprB add0r subr_gt0. Qed.",
    "Lemma comparable0r x : (0 >=< x)%R = (x \\is Num.real). Proof. by []. Qed.",
    "Lemma comparabler0 x : (x >=< 0)%R = (x \\is Num.real).\nProof. by rewrite comparable_sym. Qed.",
    "Lemma subr_comparable0 x y : (x - y >=< 0)%R = (x >=< y)%R.\nProof. by rewrite /comparable subr_ge0 subr_le0. Qed.",
    "Lemma comparablerE x y : (x >=< y)%R = (x - y \\is Num.real).\nProof. by rewrite -comparabler0 subr_comparable0. Qed.",
    "Lemma  comparabler_trans : transitive (comparable : rel R).\nProof.\nmove=> y x z; rewrite !comparablerE => xBy_real yBz_real.\nby have := rpredD xBy_real yBz_real; rewrite addrA addrNK.\nQed.",
    "Lemma addr_ge0 x y : 0 <= x -> 0 <= y -> 0 <= x + y.\nProof. exact: addr_ge0. Qed.",
    "Lemma normr_nneg (R : numDomainType) (x : R) : `|x| \\is Num.nneg.\nProof. by rewrite qualifE /=. Qed.",
    "Lemma lerN2 : {mono -%R : x y /~ x <= y :> R}.\nProof. by move=> x y /=; rewrite -subr_ge0 opprK addrC subr_ge0. Qed.",
    "Lemma ltrN2 : {mono -%R : x y /~ x < y :> R}.\nProof. by move=> x y /=; rewrite leW_nmono. Qed.",
    "Lemma lerNr x y : (x <= - y) = (y <= - x).\nProof. by rewrite (monoRL opprK lerN2). Qed.",
    "Lemma ltrNr x y : (x < - y) = (y < - x).\nProof. by rewrite (monoRL opprK (leW_nmono _)). Qed.",
    "Lemma lerNl x y : (- x <= y) = (- y <= x).\nProof. by rewrite (monoLR opprK lerN2). Qed.",
    "Lemma ltrNl x y : (- x < y) = (- y < x).\nProof. by rewrite (monoLR opprK (leW_nmono _)). Qed.",
    "Lemma oppr_ge0 x : (0 <= - x) = (x <= 0). Proof. by rewrite lerNr oppr0. Qed.",
    "Lemma oppr_gt0 x : (0 < - x) = (x < 0). Proof. by rewrite ltrNr oppr0. Qed.",
    "Lemma oppr_le0 x : (- x <= 0) = (0 <= x). Proof. by rewrite lerNl oppr0. Qed.",
    "Lemma oppr_lt0 x : (- x < 0) = (0 < x). Proof. by rewrite ltrNl oppr0. Qed.",
    "Lemma gtrN x : 0 < x -> - x < x.\nProof. by move=> n0; rewrite -subr_lt0 -opprD oppr_lt0 addr_gt0. Qed.",
    "Lemma ge0_cp x : 0 <= x -> (- x <= 0) * (- x <= x).\nProof. by move=> hx; rewrite oppr_cp0 hx (@le_trans _ _ 0) ?oppr_cp0. Qed.",
    "Lemma gt0_cp x : 0 < x ->\n  (0 <= x) * (- x <= 0) * (- x <= x) * (- x < 0) * (- x < x).\nProof.\nmove=> hx; move: (ltW hx) => hx'; rewrite !ge0_cp hx' //.\nby rewrite oppr_cp0 hx // (@lt_trans _ _ 0) ?oppr_cp0.\nQed.",
    "Lemma le0_cp x : x <= 0 -> (0 <= - x) * (x <= - x).\nProof. by move=> hx; rewrite oppr_cp0 hx (@le_trans _ _ 0) ?oppr_cp0. Qed.",
    "Lemma lt0_cp x :\n  x < 0 -> (x <= 0) * (0 <= - x) * (x <= - x) * (0 < - x) * (x < - x).\nProof.\nmove=> hx; move: (ltW hx) => hx'; rewrite !le0_cp // hx'.\nby rewrite oppr_cp0 hx // (@lt_trans _ _ 0) ?oppr_cp0.\nQed.",
    "Lemma ger0_real x : 0 <= x -> x \\is real.\nProof. by rewrite realE => ->. Qed.",
    "Lemma ler0_real x : x <= 0 -> x \\is real.\nProof. by rewrite realE orbC => ->. Qed.",
    "Lemma gtr0_real x : 0 < x -> x \\is real. Proof. by move=> /ltW/ger0_real. Qed.",
    "Lemma ltr0_real x : x < 0 -> x \\is real. Proof. by move=> /ltW/ler0_real. Qed.",
    "Lemma real0 : 0 \\is @real R. Proof. exact: rpred0. Qed.",
    "Lemma real1 : 1 \\is @real R. Proof. exact: rpred1. Qed.",
    "Lemma realn n : n%:R \\is @real R. Proof. exact: rpred_nat. Qed.",
    "Lemma ler_leVge x y : x <= 0 -> y <= 0 -> (x <= y) || (y <= x).\nProof. by rewrite -!oppr_ge0 => /(ger_leVge _) /[apply]; rewrite !lerN2. Qed.",
    "Lemma real_leVge x y : x \\is real -> y \\is real -> (x <= y) || (y <= x).\nProof. by rewrite -comparabler0 -comparable0r => /comparabler_trans P/P. Qed.",
    "Lemma real_comparable x y : x \\is real -> y \\is real -> x >=< y.\nProof. exact: real_leVge. Qed.",
    "Lemma realB : {in real &, forall x y, x - y \\is real}.\nProof. exact: rpredB. Qed.",
    "Lemma realN : {mono (@GRing.opp R) : x / x \\is real}.\nProof. exact: rpredN. Qed.",
    "Lemma realBC x y : (x - y \\is real) = (y - x \\is real).\nProof. exact: rpredBC. Qed.",
    "Lemma realD : {in real &, forall x y, x + y \\is real}.\nProof. exact: rpredD. Qed.",
    "Lemma real_leP x y : x \\is real -> y \\is real ->\n  ler_xor_gt x y (min y x) (min x y) (max y x) (max x y)\n                 `|x - y| `|y - x| (x <= y) (y < x).\nProof.\nmove=> xR yR; case: (comparable_leP (real_leVge xR yR)) => xy.\n- by rewrite [`|x - y|]distrC !ger0_norm ?subr_cp0 //; constructor.\n- by rewrite [`|y - x|]distrC !gtr0_norm ?subr_cp0 //; constructor.\nQed.",
    "Lemma real_ltP x y : x \\is real -> y \\is real ->\n  ltr_xor_ge x y (min y x) (min x y) (max y x) (max x y)\n             `|x - y| `|y - x| (y <= x) (x < y).\nProof. by move=> xR yR; case: real_leP=> //; constructor. Qed.",
    "Lemma real_ltNge : {in real &, forall x y, (x < y) = ~~ (y <= x)}.\nProof. by move=> x y xR yR /=; case: real_leP. Qed.",
    "Lemma real_leNgt : {in real &, forall x y, (x <= y) = ~~ (y < x)}.\nProof. by move=> x y xR yR /=; case: real_leP. Qed.",
    "Lemma real_ltgtP x y : x \\is real -> y \\is real ->\n  comparer x y (min y x) (min x y) (max y x) (max x y) `|x - y| `|y - x|\n               (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y).\nProof.\nmove=> xR yR; case: (comparable_ltgtP (real_leVge yR xR)) => [?|?|->].\n- by rewrite [`|y - x|]distrC !gtr0_norm ?subr_gt0//; constructor.\n- by rewrite [`|x - y|]distrC !gtr0_norm ?subr_gt0//; constructor.\n- by rewrite subrr normr0; constructor.\nQed.",
    "Lemma real_ge0P x : x \\is real -> ger0_xor_lt0 x\n   (min 0 x) (min x 0) (max 0 x) (max x 0)\n  `|x| (x < 0) (0 <= x).\nProof.\nmove=> hx; rewrite -[X in `|X|]subr0; case: real_leP;\nby rewrite ?subr0 ?sub0r //; constructor.\nQed.",
    "Lemma real_le0P x : x \\is real -> ler0_xor_gt0 x\n  (min 0 x) (min x 0) (max 0 x) (max x 0)\n  `|x| (0 < x) (x <= 0).\nProof.\nmove=> hx; rewrite -[X in `|X|]subr0; case: real_ltP;\nby rewrite ?subr0 ?sub0r //; constructor.\nQed.",
    "Lemma real_ltgt0P x : x \\is real ->\n  comparer0 x (min 0 x) (min x 0) (max 0 x) (max x 0)\n            `|x| (0 == x) (x == 0) (x <= 0) (0 <= x) (x < 0) (x > 0).\nProof.\nmove=> hx; rewrite -[X in `|X|]subr0; case: (@real_ltgtP 0 x);\nby rewrite ?subr0 ?sub0r //; constructor.\nQed.",
    "Lemma max_real : {in real &, forall x y, max x y \\is real}.\nProof. exact: comparable_maxr. Qed.",
    "Lemma min_real : {in real &, forall x y, min x y \\is real}.\nProof. exact: comparable_minr. Qed.",
    "Lemma bigmax_real I x0 (r : seq I) (P : pred I) (f : I -> R):\n  x0 \\is real -> {in P, forall i : I, f i \\is real} ->\n  \\big[max/x0]_(i <- r | P i) f i \\is real.\nProof. exact/big_real/max_real. Qed.",
    "Lemma bigmin_real I x0 (r : seq I) (P : pred I) (f : I -> R):\n  x0 \\is real -> {in P, forall i : I, f i \\is real} ->\n  \\big[min/x0]_(i <- r | P i) f i \\is real.\nProof. exact/big_real/min_real. Qed.",
    "Lemma real_neqr_lt : {in real &, forall x y, (x != y) = (x < y) || (y < x)}.\nProof. by move=> * /=; case: real_ltgtP. Qed.",
    "Lemma lerB_real x y : x <= y -> y - x \\is real.\nProof. by move=> le_xy; rewrite ger0_real // subr_ge0. Qed.",
    "Lemma gerB_real x y : x <= y -> x - y \\is real.\nProof. by move=> le_xy; rewrite ler0_real // subr_le0. Qed.",
    "Lemma ler_real y x : x <= y -> (x \\is real) = (y \\is real).\nProof. by move=> le_xy; rewrite -(addrNK x y) rpredDl ?lerB_real. Qed.",
    "Lemma ger_real x y : y <= x -> (x \\is real) = (y \\is real).\nProof. by move=> le_yx; rewrite -(ler_real le_yx). Qed.",
    "Lemma ger1_real x : 1 <= x -> x \\is real. Proof. by move=> /ger_real->. Qed.",
    "Lemma ler1_real x : x <= 1 -> x \\is real. Proof. by move=> /ler_real->. Qed.",
    "Lemma Nreal_leF x y : y \\is real -> x \\notin real -> (x <= y) = false.\nProof. by move=> yR; apply: contraNF=> /ler_real->. Qed.",
    "Lemma Nreal_geF x y : y \\is real -> x \\notin real -> (y <= x) = false.\nProof. by move=> yR; apply: contraNF=> /ger_real->. Qed.",
    "Lemma Nreal_ltF x y : y \\is real -> x \\notin real -> (x < y) = false.\nProof. by move=> yR xNR; rewrite lt_def Nreal_leF ?andbF. Qed.",
    "Lemma Nreal_gtF x y : y \\is real -> x \\notin real -> (y < x) = false.\nProof. by move=> yR xNR; rewrite lt_def Nreal_geF ?andbF. Qed.",
    "Lemma real_wlog_ler P :\n    (forall a b, P b a -> P a b) -> (forall a b, a <= b -> P a b) ->\n  forall a b : R, a \\is real -> b \\is real -> P a b.\nProof.\nmove=> sP hP a b ha hb; wlog: a b ha hb / a <= b => [hwlog|]; last exact: hP.\nby case: (real_leP ha hb)=> [/hP //|/ltW hba]; apply/sP/hP.\nQed.",
    "Lemma real_wlog_ltr P :\n    (forall a, P a a) -> (forall a b, (P b a -> P a b)) ->\n    (forall a b, a < b -> P a b) ->\n  forall a b : R, a \\is real -> b \\is real -> P a b.\nProof.\nmove=> rP sP hP; apply: real_wlog_ler=> // a b.\nby rewrite le_eqVlt; case: eqVneq => [->|] //= _ /hP.\nQed.",
    "Lemma lerD2l x : {mono +%R x : y z / y <= z}.\nProof. by move=> y z; rewrite -subr_ge0 opprD addrAC addNKr addrC subr_ge0. Qed.",
    "Lemma lerD2r x : {mono +%R^~ x : y z / y <= z}.\nProof. by move=> y z; rewrite ![_ + x]addrC lerD2l. Qed.",
    "Lemma ltrD2l x : {mono +%R x : y z / y < z}.\nProof. by move=> y z; rewrite (leW_mono (lerD2l _)). Qed.",
    "Lemma ltrD2r x : {mono +%R^~ x : y z / y < z}.\nProof. by move=> y z /=; rewrite (leW_mono (lerD2r _)). Qed.",
    "Lemma lerD x y z t : x <= y -> z <= t -> x + z <= y + t.\nProof. by move=> lxy lzt; rewrite (@le_trans _ _ (y + z)) ?lterD2. Qed.",
    "Lemma ler_ltD x y z t : x <= y -> z < t -> x + z < y + t.\nProof. by move=> lxy lzt; rewrite (@le_lt_trans _ _ (y + z)) ?lterD2. Qed.",
    "Lemma ltr_leD x y z t : x < y -> z <= t -> x + z < y + t.\nProof. by move=> lxy lzt; rewrite (@lt_le_trans _ _ (y + z)) ?lterD2. Qed.",
    "Lemma ltrD x y z t : x < y -> z < t -> x + z < y + t.\nProof. by move=> lxy lzt; rewrite ltr_leD // ltW. Qed.",
    "Lemma lerB x y z t : x <= y -> t <= z -> x - z <= y - t.\nProof. by move=> lxy ltz; rewrite lerD // lterN2. Qed.",
    "Lemma ler_ltB x y z t : x <= y -> t < z -> x - z < y - t.\nProof. by move=> lxy lzt; rewrite ler_ltD // lterN2. Qed.",
    "Lemma ltr_leB x y z t : x < y -> t <= z -> x - z < y - t.\nProof. by move=> lxy lzt; rewrite ltr_leD // lterN2. Qed.",
    "Lemma ltrB x y z t : x < y -> t < z -> x - z < y - t.\nProof. by move=> lxy lzt; rewrite ltrD // lterN2. Qed.",
    "Lemma lerBlDr x y z : (x - y <= z) = (x <= z + y).\nProof. by rewrite (monoLR (addrK _) (lerD2r _)). Qed.",
    "Lemma ltrBlDr x y z : (x - y < z) = (x < z + y).\nProof. by rewrite (monoLR (addrK _) (ltrD2r _)). Qed.",
    "Lemma lerBrDr x y z : (x <= y - z) = (x + z <= y).\nProof. by rewrite (monoLR (addrNK _) (lerD2r _)). Qed.",
    "Lemma ltrBrDr x y z : (x < y - z) = (x + z < y).\nProof. by rewrite (monoLR (addrNK _) (ltrD2r _)). Qed.",
    "Lemma lerBlDl x y z : (x - y <= z) = (x <= y + z).\nProof. by rewrite lterBDr addrC. Qed.",
    "Lemma ltrBlDl x y z : (x - y < z) = (x < y + z).\nProof. by rewrite lterBDr addrC. Qed.",
    "Lemma lerBrDl x y z : (x <= y - z) = (z + x <= y).\nProof. by rewrite lerBrDr addrC. Qed.",
    "Lemma ltrBrDl x y z : (x < y - z) = (z + x < y).\nProof. by rewrite lterBDr addrC. Qed.",
    "Lemma lerDl x y : (x <= x + y) = (0 <= y).\nProof. by rewrite -{1}[x]addr0 lterD2. Qed.",
    "Lemma ltrDl x y : (x < x + y) = (0 < y).\nProof. by rewrite -{1}[x]addr0 lterD2. Qed.",
    "Lemma lerDr x y : (x <= y + x) = (0 <= y).\nProof. by rewrite -{1}[x]add0r lterD2. Qed.",
    "Lemma ltrDr x y : (x < y + x) = (0 < y).\nProof. by rewrite -{1}[x]add0r lterD2. Qed.",
    "Lemma gerDl x y : (x + y <= x) = (y <= 0).\nProof. by rewrite -{2}[x]addr0 lterD2. Qed.",
    "Lemma gerBl x y : (x - y <= x) = (0 <= y).\nProof. by rewrite lerBlDl lerDr. Qed.",
    "Lemma gtrDl x y : (x + y < x) = (y < 0).\nProof. by rewrite -{2}[x]addr0 lterD2. Qed.",
    "Lemma gtrBl x y : (x - y < x) = (0 < y).\nProof. by rewrite ltrBlDl ltrDr. Qed.",
    "Lemma gerDr x y : (y + x <= x) = (y <= 0).\nProof. by rewrite -{2}[x]add0r lterD2. Qed.",
    "Lemma gtrDr x y : (y + x < x) = (y < 0).\nProof. by rewrite -{2}[x]add0r lterD2. Qed.",
    "Lemma ler_wpDl y x z : 0 <= x -> y <= z -> y <= x + z.\nProof. by move=> *; rewrite -[y]add0r lerD. Qed.",
    "Lemma ltr_wpDl y x z : 0 <= x -> y < z -> y < x + z.\nProof. by move=> *; rewrite -[y]add0r ler_ltD. Qed.",
    "Lemma ltr_pwDl y x z : 0 < x -> y <= z -> y < x + z.\nProof. by move=> *; rewrite -[y]add0r ltr_leD. Qed.",
    "Lemma ltr_pDl y x z : 0 < x -> y < z -> y < x + z.\nProof. by move=> *; rewrite -[y]add0r ltrD. Qed.",
    "Lemma ler_wnDl y x z : x <= 0 -> y <= z -> x + y <= z.\nProof. by move=> *; rewrite -[z]add0r lerD. Qed.",
    "Lemma ltr_wnDl y x z : x <= 0 -> y < z -> x + y < z.\nProof. by move=> *; rewrite -[z]add0r ler_ltD. Qed.",
    "Lemma ltr_nwDl y x z : x < 0 -> y <= z -> x + y < z.\nProof. by move=> *; rewrite -[z]add0r ltr_leD. Qed.",
    "Lemma ltr_nDl y x z : x < 0 -> y < z -> x + y < z.\nProof. by move=> *; rewrite -[z]add0r ltrD. Qed.",
    "Lemma ler_wpDr y x z : 0 <= x -> y <= z -> y <= z + x.\nProof. by move=> *; rewrite addrC ler_wpDl. Qed.",
    "Lemma ltr_wpDr y x z : 0 <= x -> y < z -> y < z + x.\nProof. by move=> *; rewrite addrC ltr_wpDl. Qed.",
    "Lemma ltr_pwDr y x z : 0 < x -> y <= z -> y < z + x.\nProof. by move=> *; rewrite addrC ltr_pwDl. Qed.",
    "Lemma ltr_pDr y x z : 0 < x -> y < z -> y < z + x.\nProof. by move=> *; rewrite addrC ltr_pDl. Qed.",
    "Lemma ler_wnDr y x z : x <= 0 -> y <= z -> y + x <= z.\nProof. by move=> *; rewrite addrC ler_wnDl. Qed.",
    "Lemma ltr_wnDr y x z : x <= 0 -> y < z -> y + x < z.\nProof. by move=> *; rewrite addrC ltr_wnDl. Qed.",
    "Lemma ltr_nwDr y x z : x < 0 -> y <= z -> y + x < z.\nProof. by move=> *; rewrite addrC ltr_nwDl. Qed.",
    "Lemma ltr_nDr y x z : x < 0 -> y < z -> y + x < z.\nProof. by move=> *; rewrite addrC ltr_nDl. Qed.",
    "Lemma paddr_eq0 (x y : R) :\n  0 <= x -> 0 <= y -> (x + y == 0) = (x == 0) && (y == 0).\nProof.\nrewrite le0r; case/orP=> [/eqP->|hx]; first by rewrite add0r eqxx.\nby rewrite (gt_eqF hx) /= => hy; rewrite gt_eqF // ltr_pwDl.\nQed.",
    "Lemma naddr_eq0 (x y : R) :\n  x <= 0 -> y <= 0 -> (x + y == 0) = (x == 0) && (y == 0).\nProof.\nby move=> lex0 ley0; rewrite -oppr_eq0 opprD paddr_eq0 ?oppr_cp0 // !oppr_eq0.\nQed.",
    "Lemma addr_ss_eq0 (x y : R) :\n    (0 <= x) && (0 <= y) || (x <= 0) && (y <= 0) ->\n  (x + y == 0) = (x == 0) && (y == 0).\nProof. by case/orP=> /andP []; [apply: paddr_eq0 | apply: naddr_eq0]. Qed.",
    "Lemma sumr_ge0 I (r : seq I) (P : pred I) (F : I -> R) :\n  (forall i, P i -> (0 <= F i)) -> 0 <= \\sum_(i <- r | P i) (F i).\nProof. exact: (big_ind _ _ (@ler_wpDl 0)). Qed.",
    "Lemma ler_sum I (r : seq I) (P : pred I) (F G : I -> R) :\n    (forall i, P i -> F i <= G i) ->\n  \\sum_(i <- r | P i) F i <= \\sum_(i <- r | P i) G i.\nProof. exact: (big_ind2 _ (lexx _) lerD). Qed.",
    "Lemma ler_sum_nat (m n : nat) (F G : nat -> R) :\n  (forall i, (m <= i < n)%N -> F i <= G i) ->\n  \\sum_(m <= i < n) F i <= \\sum_(m <= i < n) G i.\nProof. by move=> le_FG; rewrite !big_nat ler_sum. Qed.",
    "Lemma psumr_eq0 (I : eqType) (r : seq I) (P : pred I) (F : I -> R) :\n    (forall i, P i -> 0 <= F i) ->\n  (\\sum_(i <- r | P i) (F i) == 0) = (all (fun i => (P i) ==> (F i == 0)) r).\nProof.\nelim: r=> [|a r ihr hr] /=; rewrite (big_nil, big_cons); first by rewrite eqxx.\nby case: ifP=> pa /=; rewrite ?paddr_eq0 ?ihr ?hr // sumr_ge0.\nQed.",
    "Lemma psumr_eq0P (I : finType) (P : pred I) (F : I -> R) :\n     (forall i, P i -> 0 <= F i) -> \\sum_(i | P i) F i = 0 ->\n  (forall i, P i -> F i = 0).\nProof.\nmove=> F_ge0 /eqP; rewrite psumr_eq0 // -big_all big_andE => /forallP hF i Pi.\nby move: (hF i); rewrite implyTb Pi /= => /eqP.\nQed.",
    "Lemma psumr_neq0 (I : eqType) (r : seq I) (P : pred I) (F : I -> R) :\n    (forall i, P i -> 0 <= F i) ->\n  (\\sum_(i <- r | P i) (F i) != 0) = (has (fun i => P i && (0 < F i)) r).\nProof.\nmove=> F_ge0; rewrite psumr_eq0// -has_predC; apply: eq_has => x /=.\nby case Px: (P x); rewrite //= lt_def F_ge0 ?andbT.\nQed.",
    "Lemma psumr_neq0P (I : finType) (P : pred I) (F : I -> R) :\n     (forall i, P i -> 0 <= F i) -> \\sum_(i | P i) F i <> 0 ->\n  (exists i, P i && (0 < F i)).\nProof. by move=> ? /eqP; rewrite psumr_neq0// => /hasP[x _ ?]; exists x. Qed.",
    "Lemma ler_pM2l x : 0 < x -> {mono *%R x : x y / x <= y}.\nProof.\nby move=> x_gt0 y z /=; rewrite -subr_ge0 -mulrBr pmulr_rge0 // subr_ge0.\nQed.",
    "Lemma ltr_pM2l x : 0 < x -> {mono *%R x : x y / x < y}.\nProof. by move=> x_gt0; apply: leW_mono (ler_pM2l _). Qed.",
    "Lemma ler_pM2r x : 0 < x -> {mono *%R^~ x : x y / x <= y}.\nProof. by move=> x_gt0 y z /=; rewrite ![_ * x]mulrC ler_pM2l. Qed.",
    "Lemma ltr_pM2r x : 0 < x -> {mono *%R^~ x : x y / x < y}.\nProof. by move=> x_gt0; apply: leW_mono (ler_pM2r _). Qed.",
    "Lemma ler_nM2l x : x < 0 -> {mono *%R x : x y /~ x <= y}.\nProof. by move=> x_lt0 y z /=; rewrite -lerN2 -!mulNr ler_pM2l ?oppr_gt0. Qed.",
    "Lemma ltr_nM2l x : x < 0 -> {mono *%R x : x y /~ x < y}.\nProof. by move=> x_lt0; apply: leW_nmono (ler_nM2l _). Qed.",
    "Lemma ler_nM2r x : x < 0 -> {mono *%R^~ x : x y /~ x <= y}.\nProof. by move=> x_lt0 y z /=; rewrite ![_ * x]mulrC ler_nM2l. Qed.",
    "Lemma ltr_nM2r x : x < 0 -> {mono *%R^~ x : x y /~ x < y}.\nProof. by move=> x_lt0; apply: leW_nmono (ler_nM2r _). Qed.",
    "Lemma ler_wpM2l x : 0 <= x -> {homo *%R x : y z / y <= z}.\nProof.\nby rewrite le0r => /orP[/eqP-> y z | /ler_pM2l/mono2W//]; rewrite !mul0r.\nQed.",
    "Lemma ler_wpM2r x : 0 <= x -> {homo *%R^~ x : y z / y <= z}.\nProof. by move=> x_ge0 y z leyz; rewrite ![_ * x]mulrC ler_wpM2l. Qed.",
    "Lemma ler_wnM2l x : x <= 0 -> {homo *%R x : y z /~ y <= z}.\nProof. by move=> x_le0 y z leyz; rewrite -![x * _]mulrNN ler_wpM2l ?lterNE. Qed.",
    "Lemma ler_wnM2r x : x <= 0 -> {homo *%R^~ x : y z /~ y <= z}.\nProof. by move=> x_le0 y z leyz; rewrite -![_ * x]mulrNN ler_wpM2r ?lterNE. Qed.",
    "Lemma ler_pM x1 y1 x2 y2 :\n  0 <= x1 -> 0 <= x2 -> x1 <= y1 -> x2 <= y2 -> x1 * x2 <= y1 * y2.\nProof.\nmove=> x1ge0 x2ge0 le_xy1 le_xy2; have y1ge0 := le_trans x1ge0 le_xy1.\nexact: le_trans (ler_wpM2r x2ge0 le_xy1) (ler_wpM2l y1ge0 le_xy2).\nQed.",
    "Lemma ltr_pM x1 y1 x2 y2 :\n  0 <= x1 -> 0 <= x2 -> x1 < y1 -> x2 < y2 -> x1 * x2 < y1 * y2.\nProof.\nmove=> x1ge0 x2ge0 lt_xy1 lt_xy2; have y1gt0 := le_lt_trans x1ge0 lt_xy1.\nby rewrite (le_lt_trans (ler_wpM2r x2ge0 (ltW lt_xy1))) ?ltr_pM2l.\nQed.",
    "Lemma ler_pMn2r n : (0 < n)%N -> {mono (@GRing.natmul R)^~ n : x y / x <= y}.\nProof.\nby case: n => // n _ x y /=; rewrite -mulr_natl -[y *+ _]mulr_natl ler_pM2l.\nQed.",
    "Lemma ltr_pMn2r n : (0 < n)%N -> {mono (@GRing.natmul R)^~ n : x y / x < y}.\nProof. by move/ler_pMn2r/leW_mono. Qed.",
    "Lemma pmulrnI n : (0 < n)%N -> injective ((@GRing.natmul R)^~ n).\nProof. by move/ler_pMn2r/inc_inj. Qed.",
    "Lemma eqr_pMn2r n : (0 < n)%N -> {mono (@GRing.natmul R)^~ n : x y / x == y}.\nProof. by move/pmulrnI/inj_eq. Qed.",
    "Lemma pmulrn_lgt0 x n : (0 < n)%N -> (0 < x *+ n) = (0 < x).\nProof. by move=> n_gt0; rewrite -(mul0rn _ n) ltr_pMn2r // mul0rn. Qed.",
    "Lemma pmulrn_llt0 x n : (0 < n)%N -> (x *+ n < 0) = (x < 0).\nProof. by move=> n_gt0; rewrite -(mul0rn _ n) ltr_pMn2r // mul0rn. Qed.",
    "Lemma pmulrn_lge0 x n : (0 < n)%N -> (0 <= x *+ n) = (0 <= x).\nProof. by move=> n_gt0; rewrite -(mul0rn _ n) ler_pMn2r // mul0rn. Qed.",
    "Lemma pmulrn_lle0 x n : (0 < n)%N -> (x *+ n <= 0) = (x <= 0).\nProof. by move=> n_gt0; rewrite -(mul0rn _ n) ler_pMn2r // mul0rn. Qed.",
    "Lemma ltr_wMn2r x y n : x < y -> (x *+ n < y *+ n) = (0 < n)%N.\nProof. by move=> ltxy; case: n=> // n; rewrite ltr_pMn2r. Qed.",
    "Lemma ltr_wpMn2r n : (0 < n)%N -> {homo (@GRing.natmul R)^~ n : x y / x < y}.\nProof. by move=> n_gt0 x y /= / ltr_wMn2r ->. Qed.",
    "Lemma ler_wMn2r n : {homo (@GRing.natmul R)^~ n : x y / x <= y}.\nProof. by move=> x y hxy /=; case: n=> // n; rewrite ler_pMn2r. Qed.",
    "Lemma mulrn_wge0 x n : 0 <= x -> 0 <= x *+ n.\nProof. by move=> /(ler_wMn2r n); rewrite mul0rn. Qed.",
    "Lemma mulrn_wle0 x n : x <= 0 -> x *+ n <= 0.\nProof. by move=> /(ler_wMn2r n); rewrite mul0rn. Qed.",
    "Lemma lerMn2r n x y : (x *+ n <= y *+ n) = ((n == 0) || (x <= y)).\nProof. by case: n => [|n]; rewrite ?lexx ?eqxx // ler_pMn2r. Qed.",
    "Lemma ltrMn2r n x y : (x *+ n < y *+ n) = ((0 < n)%N && (x < y)).\nProof. by case: n => [|n]; rewrite ?lexx ?eqxx // ltr_pMn2r. Qed.",
    "Lemma eqrMn2r n x y : (x *+ n == y *+ n) = (n == 0)%N || (x == y).\nProof. by rewrite !(@eq_le _ R) !lerMn2r -orb_andr. Qed.",
    "Lemma mulrn_eq0 x n : (x *+ n == 0) = ((n == 0)%N || (x == 0)).\nProof. by rewrite -mulr_natl mulf_eq0 pnatr_eq0. Qed.",
    "Lemma eqNr x : (- x == x) = (x == 0).\nProof. by rewrite eq_sym -addr_eq0 -mulr2n mulrn_eq0. Qed.",
    "Lemma mulrIn x : x != 0 -> injective (GRing.natmul x).\nProof.\nmove=> x_neq0 m n; without loss /subnK <-: m n / (n <= m)%N.\n  by move=> IH eq_xmn; case/orP: (leq_total m n) => /IH->.\nby move/eqP; rewrite mulrnDr -subr_eq0 addrK mulrn_eq0 => /predU1P[-> | /idPn].\nQed.",
    "Lemma ler_wpMn2l x :\n  0 <= x -> {homo (@GRing.natmul R x) : m n / (m <= n)%N >-> m <= n}.\nProof. by move=> xge0 m n /subnK <-; rewrite mulrnDr ler_wpDl ?mulrn_wge0. Qed.",
    "Lemma ler_wnMn2l x :\n  x <= 0 -> {homo (@GRing.natmul R x) : m n / (n <= m)%N >-> m <= n}.\nProof.\nby move=> xle0 m n hmn /=; rewrite -lerN2 -!mulNrn ler_wpMn2l // oppr_cp0.\nQed.",
    "Lemma mulrn_wgt0 x n : 0 < x -> 0 < x *+ n = (0 < n)%N.\nProof. by case: n => // n hx; rewrite pmulrn_lgt0. Qed.",
    "Lemma mulrn_wlt0 x n : x < 0 -> x *+ n < 0 = (0 < n)%N.\nProof. by case: n => // n hx; rewrite pmulrn_llt0. Qed.",
    "Lemma ler_pMn2l x :\n  0 < x -> {mono (@GRing.natmul R x) : m n / (m <= n)%N >-> m <= n}.\nProof.\nmove=> x_gt0 m n /=; case: leqP => hmn; first by rewrite ler_wpMn2l // ltW.\nby rewrite -(subnK (ltnW hmn)) mulrnDr gerDr lt_geF // mulrn_wgt0 // subn_gt0.\nQed.",
    "Lemma ltr_pMn2l x :\n  0 < x -> {mono (@GRing.natmul R x) : m n / (m < n)%N >-> m < n}.\nProof. by move=> x_gt0; apply: leW_mono (ler_pMn2l _). Qed.",
    "Lemma ler_nMn2l x :\n  x < 0 -> {mono (@GRing.natmul R x) : m n / (n <= m)%N >-> m <= n}.\nProof. by move=> xlt0 m n /=; rewrite -lerN2 -!mulNrn ler_pMn2l// oppr_gt0. Qed.",
    "Lemma ltr_nMn2l x :\n  x < 0 -> {mono (@GRing.natmul R x) : m n / (n < m)%N >-> m < n}.\nProof. by move=> x_lt0; apply: leW_nmono (ler_nMn2l _). Qed.",
    "Lemma ler_nat m n : (m%:R <= n%:R :> R) = (m <= n)%N.\nProof. by rewrite ler_pMn2l. Qed.",
    "Lemma ltr_nat m n : (m%:R < n%:R :> R) = (m < n)%N.\nProof. by rewrite ltr_pMn2l. Qed.",
    "Lemma eqr_nat m n : (m%:R == n%:R :> R) = (m == n)%N.\nProof. by rewrite (inj_eq (mulrIn _)) ?oner_eq0. Qed.",
    "Lemma pnatr_eq1 n : (n%:R == 1 :> R) = (n == 1)%N.\nProof. exact: eqr_nat 1. Qed.",
    "Lemma lern0 n : (n%:R <= 0 :> R) = (n == 0).\nProof. by rewrite -[0]/0%:R ler_nat leqn0. Qed.",
    "Lemma ltrn0 n : (n%:R < 0 :> R) = false.\nProof. by rewrite -[0]/0%:R ltr_nat ltn0. Qed.",
    "Lemma ler1n n : 1 <= n%:R :> R = (1 <= n)%N. Proof. by rewrite -ler_nat. Qed.",
    "Lemma ltr1n n : 1 < n%:R :> R = (1 < n)%N. Proof. by rewrite -ltr_nat. Qed.",
    "Lemma lern1 n : n%:R <= 1 :> R = (n <= 1)%N. Proof. by rewrite -ler_nat. Qed.",
    "Lemma ltrn1 n : n%:R < 1 :> R = (n < 1)%N. Proof. by rewrite -ltr_nat. Qed.",
    "Lemma ltrN10 : -1 < 0 :> R. Proof. by rewrite oppr_lt0. Qed.",
    "Lemma lerN10 : -1 <= 0 :> R. Proof. by rewrite oppr_le0. Qed.",
    "Lemma ltr10 : 1 < 0 :> R = false. Proof. by rewrite le_gtF. Qed.",
    "Lemma ler10 : 1 <= 0 :> R = false. Proof. by rewrite lt_geF. Qed.",
    "Lemma ltr0N1 : 0 < -1 :> R = false. Proof. by rewrite le_gtF // lerN10. Qed.",
    "Lemma ler0N1 : 0 <= -1 :> R = false. Proof. by rewrite lt_geF // ltrN10. Qed.",
    "Lemma pmulrn_rgt0 x n : 0 < x -> 0 < x *+ n = (0 < n)%N.\nProof. exact: mulrn_wgt0. Qed.",
    "Lemma pmulrn_rlt0 x n : 0 < x -> x *+ n < 0 = false.\nProof. by move=> x_gt0; rewrite -(mulr0n x) ltr_pMn2l. Qed.",
    "Lemma pmulrn_rge0 x n : 0 < x -> 0 <= x *+ n.\nProof. by move=> x_gt0; rewrite -(mulr0n x) ler_pMn2l. Qed.",
    "Lemma pmulrn_rle0 x n : 0 < x -> x *+ n <= 0 = (n == 0)%N.\nProof. by move=> x_gt0; rewrite -(mulr0n x) ler_pMn2l ?leqn0. Qed.",
    "Lemma nmulrn_rgt0 x n : x < 0 -> 0 < x *+ n = false.\nProof. by move=> x_lt0; rewrite -(mulr0n x) ltr_nMn2l. Qed.",
    "Lemma nmulrn_rge0 x n : x < 0 -> 0 <= x *+ n = (n == 0)%N.\nProof. by move=> x_lt0; rewrite -(mulr0n x) ler_nMn2l ?leqn0. Qed.",
    "Lemma nmulrn_rle0 x n : x < 0 -> x *+ n <= 0.\nProof. by move=> x_lt0; rewrite -(mulr0n x) ler_nMn2l. Qed.",
    "Lemma pmulr_rlt0 x y : 0 < x -> (x * y < 0) = (y < 0).\nProof.\nby move=> x_gt0; rewrite -[LHS]oppr_gt0 -mulrN pmulr_rgt0 // oppr_gt0.\nQed.",
    "Lemma pmulr_rle0 x y : 0 < x -> (x * y <= 0) = (y <= 0).\nProof.\nby move=> x_gt0; rewrite -[LHS]oppr_ge0 -mulrN pmulr_rge0 // oppr_ge0.\nQed.",
    "Lemma pmulr_lgt0 x y : 0 < x -> (0 < y * x) = (0 < y).\nProof. by move=> x_gt0; rewrite mulrC pmulr_rgt0. Qed.",
    "Lemma pmulr_lge0 x y : 0 < x -> (0 <= y * x) = (0 <= y).\nProof. by move=> x_gt0; rewrite mulrC pmulr_rge0. Qed.",
    "Lemma pmulr_llt0 x y : 0 < x -> (y * x < 0) = (y < 0).\nProof. by move=> x_gt0; rewrite mulrC pmulr_rlt0. Qed.",
    "Lemma pmulr_lle0 x y : 0 < x -> (y * x <= 0) = (y <= 0).\nProof. by move=> x_gt0; rewrite mulrC pmulr_rle0. Qed.",
    "Lemma nmulr_rgt0 x y : x < 0 -> (0 < x * y) = (y < 0).\nProof. by move=> x_lt0; rewrite -mulrNN pmulr_rgt0 lterNE. Qed.",
    "Lemma nmulr_rge0 x y : x < 0 -> (0 <= x * y) = (y <= 0).\nProof. by move=> x_lt0; rewrite -mulrNN pmulr_rge0 lterNE. Qed.",
    "Lemma nmulr_rlt0 x y : x < 0 -> (x * y < 0) = (0 < y).\nProof. by move=> x_lt0; rewrite -mulrNN pmulr_rlt0 lterNE. Qed.",
    "Lemma nmulr_rle0 x y : x < 0 -> (x * y <= 0) = (0 <= y).\nProof. by move=> x_lt0; rewrite -mulrNN pmulr_rle0 lterNE. Qed.",
    "Lemma nmulr_lgt0 x y : x < 0 -> (0 < y * x) = (y < 0).\nProof. by move=> x_lt0; rewrite mulrC nmulr_rgt0. Qed.",
    "Lemma nmulr_lge0 x y : x < 0 -> (0 <= y * x) = (y <= 0).\nProof. by move=> x_lt0; rewrite mulrC nmulr_rge0. Qed.",
    "Lemma nmulr_llt0 x y : x < 0 -> (y * x < 0) = (0 < y).\nProof. by move=> x_lt0; rewrite mulrC nmulr_rlt0. Qed.",
    "Lemma nmulr_lle0 x y : x < 0 -> (y * x <= 0) = (0 <= y).\nProof. by move=> x_lt0; rewrite mulrC nmulr_rle0. Qed.",
    "Lemma mulr_ge0 x y : 0 <= x -> 0 <= y -> 0 <= x * y.\nProof. by move=> x_ge0 y_ge0; rewrite -(mulr0 x) ler_wpM2l. Qed.",
    "Lemma mulr_le0 x y : x <= 0 -> y <= 0 -> 0 <= x * y.\nProof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wnM2l. Qed.",
    "Lemma mulr_ge0_le0 x y : 0 <= x -> y <= 0 -> x * y <= 0.\nProof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wpM2l. Qed.",
    "Lemma mulr_le0_ge0 x y : x <= 0 -> 0 <= y -> x * y <= 0.\nProof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wnM2l. Qed.",
    "Lemma mulr_gt0 x y : 0 < x -> 0 < y -> 0 < x * y.\nProof. by move=> x_gt0 y_gt0; rewrite pmulr_rgt0. Qed.",
    "Lemma mulr_ge0_gt0 x y : 0 <= x -> 0 <= y -> (0 < x * y) = (0 < x) && (0 < y).\nProof.\nrewrite le_eqVlt => /predU1P[<-|x0]; first by rewrite mul0r ltxx.\nrewrite le_eqVlt => /predU1P[<-|y0]; first by rewrite mulr0 ltxx andbC.\nby apply/idP/andP=> [|_]; rewrite pmulr_rgt0.\nQed.",
    "Lemma prodr_ge0 I r (P : pred I) (E : I -> R) :\n  (forall i, P i -> 0 <= E i) -> 0 <= \\prod_(i <- r | P i) E i.\nProof. by move=> Ege0; rewrite -nnegrE rpred_prod. Qed.",
    "Lemma prodr_gt0 I r (P : pred I) (E : I -> R) :\n  (forall i, P i -> 0 < E i) -> 0 < \\prod_(i <- r | P i) E i.\nProof. by move=> Ege0; rewrite -posrE rpred_prod. Qed.",
    "Lemma ler_prod I r (P : pred I) (E1 E2 : I -> R) :\n    (forall i, P i -> 0 <= E1 i <= E2 i) ->\n  \\prod_(i <- r | P i) E1 i <= \\prod_(i <- r | P i) E2 i.\nProof.\nmove=> leE12; elim/(big_load (fun x => 0 <= x)): _.\nelim/big_rec2: _ => // i x2 x1 /leE12/andP[le0Ei leEi12] [x1ge0 le_x12].\nby rewrite mulr_ge0 // ler_pM.\nQed.",
    "Lemma ltr_prod I r (P : pred I) (E1 E2 : I -> R) :\n    has P r -> (forall i, P i -> 0 <= E1 i < E2 i) ->\n  \\prod_(i <- r | P i) E1 i < \\prod_(i <- r | P i) E2 i.\nProof.\nelim: r => //= i r IHr; rewrite !big_cons; case: ifP => {IHr}// Pi _ ltE12.\nhave /andP[le0E1i ltE12i] := ltE12 i Pi; set E2r := \\prod_(j <- r | P j) E2 j.\napply: le_lt_trans (_ : E1 i * E2r < E2 i * E2r).\n  by rewrite ler_wpM2l ?ler_prod // => j /ltE12/andP[-> /ltW].\nby rewrite ltr_pM2r ?prodr_gt0 // => j /ltE12/andP[le0E1j /le_lt_trans->].\nQed.",
    "Lemma ltr_prod_nat (E1 E2 : nat -> R) (n m : nat) :\n   (m < n)%N -> (forall i, (m <= i < n)%N -> 0 <= E1 i < E2 i) ->\n  \\prod_(m <= i < n) E1 i < \\prod_(m <= i < n) E2 i.\nProof.\nmove=> lt_mn ltE12; rewrite !big_nat ltr_prod {ltE12}//.\nby apply/hasP; exists m; rewrite ?mem_index_iota leqnn.\nQed.",
    "Lemma realMr x y : x != 0 -> x \\is real -> (x * y \\is real) = (y \\is real).\nProof.\nmove=> x_neq0 xR; case: real_ltgtP x_neq0 => // hx _; rewrite !realE.\n  by rewrite nmulr_rge0 // nmulr_rle0 // orbC.\nby rewrite pmulr_rge0 // pmulr_rle0 // orbC.\nQed.",
    "Lemma realrM x y : y != 0 -> y \\is real -> (x * y \\is real) = (x \\is real).\nProof. by move=> y_neq0 yR; rewrite mulrC realMr. Qed.",
    "Lemma realM : {in real &, forall x y, x * y \\is real}.\nProof. exact: rpredM. Qed.",
    "Lemma realrMn x n : (n != 0)%N -> (x *+ n \\is real) = (x \\is real).\nProof. by move=> n_neq0; rewrite -mulr_natl realMr ?realn ?pnatr_eq0. Qed.",
    "Lemma ger_pMl x y : 0 < y -> (x * y <= y) = (x <= 1).\nProof. by move=> hy; rewrite -{2}[y]mul1r ler_pM2r. Qed.",
    "Lemma gtr_pMl x y : 0 < y -> (x * y < y) = (x < 1).\nProof. by move=> hy; rewrite -{2}[y]mul1r ltr_pM2r. Qed.",
    "Lemma ger_pMr x y : 0 < y -> (y * x <= y) = (x <= 1).\nProof. by move=> hy; rewrite -{2}[y]mulr1 ler_pM2l. Qed.",
    "Lemma gtr_pMr x y : 0 < y -> (y * x < y) = (x < 1).\nProof. by move=> hy; rewrite -{2}[y]mulr1 ltr_pM2l. Qed.",
    "Lemma ler_pMl x y : 0 < y -> (y <= x * y) = (1 <= x).\nProof. by move=> hy; rewrite -{1}[y]mul1r ler_pM2r. Qed.",
    "Lemma ltr_pMl x y : 0 < y -> (y < x * y) = (1 < x).\nProof. by move=> hy; rewrite -{1}[y]mul1r ltr_pM2r. Qed.",
    "Lemma ler_pMr x y : 0 < y -> (y <= y * x) = (1 <= x).\nProof. by move=> hy; rewrite -{1}[y]mulr1 ler_pM2l. Qed.",
    "Lemma ltr_pMr x y : 0 < y -> (y < y * x) = (1 < x).\nProof. by move=> hy; rewrite -{1}[y]mulr1 ltr_pM2l. Qed.",
    "Lemma ger_nMl x y : y < 0 -> (x * y <= y) = (1 <= x).\nProof. by move=> hy; rewrite -{2}[y]mul1r ler_nM2r. Qed.",
    "Lemma gtr_nMl x y : y < 0 -> (x * y < y) = (1 < x).\nProof. by move=> hy; rewrite -{2}[y]mul1r ltr_nM2r. Qed.",
    "Lemma ger_nMr x y : y < 0 -> (y * x <= y) = (1 <= x).\nProof. by move=> hy; rewrite -{2}[y]mulr1 ler_nM2l. Qed.",
    "Lemma gtr_nMr x y : y < 0 -> (y * x < y) = (1 < x).\nProof. by move=> hy; rewrite -{2}[y]mulr1 ltr_nM2l. Qed.",
    "Lemma ler_nMl x y : y < 0 -> (y <= x * y) = (x <= 1).\nProof. by move=> hy; rewrite -{1}[y]mul1r ler_nM2r. Qed.",
    "Lemma ltr_nMl x y : y < 0 -> (y < x * y) = (x < 1).\nProof. by move=> hy; rewrite -{1}[y]mul1r ltr_nM2r. Qed.",
    "Lemma ler_nMr x y : y < 0 -> (y <= y * x) = (x <= 1).\nProof. by move=> hy; rewrite -{1}[y]mulr1 ler_nM2l. Qed.",
    "Lemma ltr_nMr x y : y < 0 -> (y < y * x) = (x < 1).\nProof. by move=> hy; rewrite -{1}[y]mulr1 ltr_nM2l. Qed.",
    "Lemma ler_peMl x y : 0 <= y -> 1 <= x -> y <= x * y.\nProof. by move=> hy hx; rewrite -{1}[y]mul1r ler_wpM2r. Qed.",
    "Lemma ler_neMl x y : y <= 0 -> 1 <= x -> x * y <= y.\nProof. by move=> hy hx; rewrite -{2}[y]mul1r ler_wnM2r. Qed.",
    "Lemma ler_peMr x y : 0 <= y -> 1 <= x -> y <= y * x.\nProof. by move=> hy hx; rewrite -{1}[y]mulr1 ler_wpM2l. Qed.",
    "Lemma ler_neMr x y : y <= 0 -> 1 <= x -> y * x <= y.\nProof. by move=> hy hx; rewrite -{2}[y]mulr1 ler_wnM2l. Qed.",
    "Lemma ler_piMl x y : 0 <= y -> x <= 1 -> x * y <= y.\nProof. by move=> hy hx; rewrite -{2}[y]mul1r ler_wpM2r. Qed.",
    "Lemma ler_niMl x y : y <= 0 -> x <= 1 -> y <= x * y.\nProof. by move=> hy hx; rewrite -{1}[y]mul1r ler_wnM2r. Qed.",
    "Lemma ler_piMr x y : 0 <= y -> x <= 1 -> y * x <= y.\nProof. by move=> hy hx; rewrite -{2}[y]mulr1 ler_wpM2l. Qed.",
    "Lemma ler_niMr x y : y <= 0 -> x <= 1 -> y <= y * x.\nProof. by move=> hx hy; rewrite -{1}[y]mulr1 ler_wnM2l. Qed.",
    "Lemma mulr_ile1 x y : 0 <= x -> 0 <= y -> x <= 1 -> y <= 1 -> x * y <= 1.\nProof. by move=> *; rewrite (@le_trans _ _ y) ?ler_piMl. Qed.",
    "Lemma mulr_ilt1 x y : 0 <= x -> 0 <= y -> x < 1 -> y < 1 -> x * y < 1.\nProof. by move=> *; rewrite (@le_lt_trans _ _ y) ?ler_piMl // ltW. Qed.",
    "Lemma mulr_ege1 x y : 1 <= x -> 1 <= y -> 1 <= x * y.\nProof.\nby move=> le1x le1y; rewrite (@le_trans _ _ y) ?ler_peMl // (le_trans ler01).\nQed.",
    "Lemma mulr_egt1 x y : 1 < x -> 1 < y -> 1 < x * y.\nProof.\nby move=> le1x lt1y; rewrite (@lt_trans _ _ y) // ltr_pMl // (lt_trans ltr01).\nQed.",
    "Lemma invr_gt0 x : (0 < x^-1) = (0 < x).\nProof.\nhave [ux | nux] := boolP (x \\is a GRing.unit); last by rewrite invr_out.\nby apply/idP/idP=> /ltr_pM2r <-; rewrite mul0r (mulrV, mulVr) ?ltr01.\nQed.",
    "Lemma invr_ge0 x : (0 <= x^-1) = (0 <= x).\nProof. by rewrite !le0r invr_gt0 invr_eq0. Qed.",
    "Lemma invr_lt0 x : (x^-1 < 0) = (x < 0).\nProof. by rewrite -oppr_cp0 -invrN invr_gt0 oppr_cp0. Qed.",
    "Lemma invr_le0 x : (x^-1 <= 0) = (x <= 0).\nProof. by rewrite -oppr_cp0 -invrN invr_ge0 oppr_cp0. Qed.",
    "Lemma divr_ge0 x y : 0 <= x -> 0 <= y -> 0 <= x / y.\nProof. by move=> x_ge0 y_ge0; rewrite mulr_ge0 ?invr_ge0. Qed.",
    "Lemma divr_gt0 x y : 0 < x -> 0 < y -> 0 < x / y.\nProof. by move=> x_gt0 y_gt0; rewrite pmulr_rgt0 ?invr_gt0. Qed.",
    "Lemma realV : {mono (@GRing.inv R) : x / x \\is real}.\nProof. exact: rpredV. Qed.",
    "Lemma exprn_ge0 n x : 0 <= x -> 0 <= x ^+ n.\nProof. by move=> xge0; rewrite -nnegrE rpredX. Qed.",
    "Lemma realX n : {in real, forall x, x ^+ n \\is real}.\nProof. exact: rpredX. Qed.",
    "Lemma exprn_gt0 n x : 0 < x -> 0 < x ^+ n.\nProof.\nby rewrite !lt0r expf_eq0 => /andP[/negPf-> /exprn_ge0->]; rewrite andbF.\nQed.",
    "Lemma exprn_ile1 n x : 0 <= x -> x <= 1 -> x ^+ n <= 1.\nProof.\nmove=> xge0 xle1; elim: n=> [|*]; rewrite ?expr0 // exprS.\nby rewrite mulr_ile1 ?exprn_ge0.\nQed.",
    "Lemma exprn_ilt1 n x : 0 <= x -> x < 1 -> x ^+ n < 1 = (n != 0).\nProof.\nmove=> xge0 xlt1.\ncase: n; [by rewrite eqxx ltxx | elim=> [|n ihn]; first by rewrite expr1].\nby rewrite exprS mulr_ilt1 // exprn_ge0.\nQed.",
    "Lemma exprn_ege1 n x : 1 <= x -> 1 <= x ^+ n.\nProof.\nby move=> x_ge1; elim: n=> [|n ihn]; rewrite ?expr0 // exprS mulr_ege1.\nQed.",
    "Lemma exprn_egt1 n x : 1 < x -> 1 < x ^+ n = (n != 0).\nProof.\nmove=> xgt1; case: n; first by rewrite eqxx ltxx.\nby elim=> [|n ihn]; rewrite ?expr1// exprS mulr_egt1 // exprn_ge0.\nQed.",
    "Lemma ler_iXnr x n : (0 < n)%N -> 0 <= x -> x <= 1 -> x ^+ n <= x.\nProof. by case: n => n // *; rewrite exprS ler_piMr // exprn_ile1. Qed.",
    "Lemma ltr_iXnr x n : 0 < x -> x < 1 -> (x ^+ n < x) = (1 < n)%N.\nProof.\ncase: n=> [|[|n]] //; first by rewrite expr0 => _ /lt_gtF ->.\nby move=> x0 x1; rewrite exprS gtr_pMr // ?exprn_ilt1 // ltW.\nQed.",
    "Lemma ler_eXnr x n : (0 < n)%N -> 1 <= x -> x <= x ^+ n.\nProof.\ncase: n => // n _ x_ge1.\nby rewrite exprS ler_peMr ?(le_trans _ x_ge1) // exprn_ege1.\nQed.",
    "Lemma ltr_eXnr x n : 1 < x -> (x < x ^+ n) = (1 < n)%N.\nProof.\nmove=> x_ge1; case: n=> [|[|n]] //; first by rewrite expr0 lt_gtF.\nby rewrite exprS ltr_pMr ?(lt_trans _ x_ge1) ?exprn_egt1.\nQed.",
    "Lemma ler_wiXn2l x :\n  0 <= x -> x <= 1 -> {homo GRing.exp x : m n / (n <= m)%N >-> m <= n}.\nProof.\nmove=> xge0 xle1 m n /= hmn.\nby rewrite -(subnK hmn) exprD ler_piMl ?(exprn_ge0, exprn_ile1).\nQed.",
    "Lemma ler_weXn2l x : 1 <= x -> {homo GRing.exp x : m n / (m <= n)%N >-> m <= n}.\nProof.\nmove=> xge1 m n /= hmn; rewrite -(subnK hmn) exprD.\nby rewrite ler_peMl ?(exprn_ge0, exprn_ege1) // (le_trans _ xge1) ?ler01.\nQed.",
    "Lemma ieexprn_weq1 x n : 0 <= x -> (x ^+ n == 1) = ((n == 0) || (x == 1)).\nProof.\nmove=> xle0; case: n => [|n]; first by rewrite expr0 eqxx.\ncase: (@real_ltgtP x 1); do ?by rewrite ?ger0_real.\n+ by move=> x_lt1; rewrite 1?lt_eqF // exprn_ilt1.\n+ by move=> x_lt1; rewrite 1?gt_eqF // exprn_egt1.\nby move->; rewrite expr1n eqxx.\nQed.",
    "Lemma ieexprIn x : 0 < x -> x != 1 -> injective (GRing.exp x).\nProof.\nmove=> x_gt0 x_neq1 m n; without loss /subnK <-: m n / (n <= m)%N.\n  by move=> IH eq_xmn; case/orP: (leq_total m n) => /IH->.\ncase: {m}(m - n)%N => // m /eqP/idPn[]; rewrite -[x ^+ n]mul1r exprD.\nby rewrite (inj_eq (mulIf _)) ?ieexprn_weq1 ?ltW // expf_neq0 ?gt_eqF.\nQed.",
    "Lemma ler_iXn2l x :\n  0 < x -> x < 1 -> {mono GRing.exp x : m n / (n <= m)%N >-> m <= n}.\nProof.\nmove=> xgt0 xlt1; apply: (le_nmono (inj_nhomo_lt _ _)); last first.\n  by apply/ler_wiXn2l; exact/ltW.\nby apply: ieexprIn; rewrite ?lt_eqF ?ltr_cpable.\nQed.",
    "Lemma ltr_iXn2l x :\n  0 < x -> x < 1 -> {mono GRing.exp x : m n / (n < m)%N >-> m < n}.\nProof. by move=> xgt0 xlt1; apply: (leW_nmono (ler_iXn2l _ _)). Qed.",
    "Lemma ler_eXn2l x :\n  1 < x -> {mono GRing.exp x : m n / (m <= n)%N >-> m <= n}.\nProof.\nmove=> xgt1; apply: (le_mono (inj_homo_lt _ _)); last first.\n  by apply: ler_weXn2l; rewrite ltW.\nby apply: ieexprIn; rewrite ?gt_eqF ?gtr_cpable //; apply: lt_trans xgt1.\nQed.",
    "Lemma ltr_eXn2l x :\n  1 < x -> {mono (GRing.exp x) : m n / (m < n)%N >-> m < n}.\nProof. by move=> xgt1; apply: (leW_mono (ler_eXn2l _)). Qed.",
    "Lemma ltrXn2r n x y : 0 <= x -> x < y -> x ^+ n < y ^+ n = (n != 0).\nProof.\nmove=> xge0 xlty; case: n; first by rewrite ltxx.\nelim=> [|n IHn]; rewrite ?[_ ^+ _.+2]exprS //.\nrewrite (@le_lt_trans _ _ (x * y ^+ n.+1)) ?ler_wpM2l ?ltr_pM2r ?IHn //.\n  by rewrite ltW.\nby rewrite exprn_gt0 // (le_lt_trans xge0).\nQed.",
    "Lemma lerXn2r n : {in nneg & , {homo (@GRing.exp R)^~ n : x y / x <= y}}.\nProof.\nmove=> x y /= x0 y0 xy; elim: n => [|n IHn]; rewrite !(expr0, exprS) //.\nby rewrite (@le_trans _ _ (x * y ^+ n)) ?ler_wpM2l ?ler_wpM2r ?exprn_ge0.\nQed.",
    "Lemma ltr_wpXn2r n :\n  (0 < n)%N -> {in nneg & , {homo (@GRing.exp R)^~ n : x y / x < y}}.\nProof. by move=> ngt0 x y /= x0 y0 hxy; rewrite ltrXn2r // -lt0n. Qed.",
    "Lemma ler_pXn2r n :\n  (0 < n)%N -> {in nneg & , {mono (@GRing.exp R)^~ n : x y / x <= y}}.\nProof.\ncase: n => // n _ x y; rewrite !qualifE /= =>  x_ge0 y_ge0.\nhave [-> | nzx] := eqVneq x 0; first by rewrite exprS mul0r exprn_ge0.\nrewrite -subr_ge0 subrXX pmulr_lge0 ?subr_ge0 //= big_ord_recr /=.\nrewrite subnn expr0 mul1r /= ltr_pwDr // ?exprn_gt0 ?lt0r ?nzx //.\nby rewrite sumr_ge0 // => i _; rewrite mulr_ge0 ?exprn_ge0.\nQed.",
    "Lemma ltr_pXn2r n :\n  (0 < n)%N -> {in nneg & , {mono (@GRing.exp R)^~ n : x y / x < y}}.\nProof.\nby move=> n_gt0 x y x_ge0 y_ge0; rewrite !lt_neqAle !eq_le !ler_pXn2r.\nQed.",
    "Lemma pexpIrn n : (0 < n)%N -> {in nneg &, injective ((@GRing.exp R)^~ n)}.\nProof. by move=> n_gt0; apply: inc_inj_in (ler_pXn2r _). Qed.",
    "Lemma expr_le1 n x : (0 < n)%N -> 0 <= x -> (x ^+ n <= 1) = (x <= 1).\nProof.\nby move=> ngt0 xge0; rewrite -{1}[1](expr1n _ n) ler_pXn2r // [_ \\in _]ler01.\nQed.",
    "Lemma expr_lt1 n x : (0 < n)%N -> 0 <= x -> (x ^+ n < 1) = (x < 1).\nProof.\nby move=> ngt0 xge0; rewrite -{1}[1](expr1n _ n) ltr_pXn2r // [_ \\in _]ler01.\nQed.",
    "Lemma expr_ge1 n x : (0 < n)%N -> 0 <= x -> (1 <= x ^+ n) = (1 <= x).\nProof.\nby move=> ngt0 xge0; rewrite -{1}[1](expr1n _ n) ler_pXn2r // [_ \\in _]ler01.\nQed.",
    "Lemma expr_gt1 n x : (0 < n)%N -> 0 <= x -> (1 < x ^+ n) = (1 < x).\nProof.\nby move=> ngt0 xge0; rewrite -{1}[1](expr1n _ n) ltr_pXn2r // [_ \\in _]ler01.\nQed.",
    "Lemma pexpr_eq1 x n : (0 < n)%N -> 0 <= x -> (x ^+ n == 1) = (x == 1).\nProof. by move=> ngt0 xge0; rewrite !eq_le expr_le1 // expr_ge1. Qed.",
    "Lemma pexprn_eq1 x n : 0 <= x -> (x ^+ n == 1) = (n == 0) || (x == 1).\nProof. by case: n => [|n] xge0; rewrite ?eqxx // pexpr_eq1 ?gtn_eqF. Qed.",
    "Lemma eqrXn2 n x y :\n  (0 < n)%N -> 0 <= x -> 0 <= y -> (x ^+ n == y ^+ n) = (x == y).\nProof. by move=> ngt0 xge0 yge0; rewrite (inj_in_eq (pexpIrn _)). Qed.",
    "Lemma sqrp_eq1 x : 0 <= x -> (x ^+ 2 == 1) = (x == 1).\nProof. by move/pexpr_eq1->. Qed.",
    "Lemma sqrn_eq1 x : x <= 0 -> (x ^+ 2 == 1) = (x == -1).\nProof. by rewrite -sqrrN -oppr_ge0 -eqr_oppLR => /sqrp_eq1. Qed.",
    "Lemma ler_sqr : {in nneg &, {mono (fun x => x ^+ 2) : x y / x <= y}}.\nProof. exact: ler_pXn2r. Qed.",
    "Lemma ltr_sqr : {in nneg &, {mono (fun x => x ^+ 2) : x y / x < y}}.\nProof. exact: ltr_pXn2r. Qed.",
    "Lemma ler_pV2 :\n  {in [pred x in GRing.unit | 0 < x] &, {mono (@GRing.inv R) : x y /~ x <= y}}.\nProof.\nmove=> x y /andP [ux hx] /andP [uy hy] /=.\nby rewrite -(ler_pM2l hx) -(ler_pM2r hy) !(divrr, mulrVK) ?unitf_gt0 // mul1r.\nQed.",
    "Lemma ler_nV2 :\n  {in [pred x in GRing.unit | x < 0] &, {mono (@GRing.inv R) : x y /~ x <= y}}.\nProof.\nmove=> x y /andP [ux hx] /andP [uy hy] /=.\nby rewrite -(ler_nM2l hx) -(ler_nM2r hy) !(divrr, mulrVK) ?unitf_lt0 // mul1r.\nQed.",
    "Lemma ltr_pV2 :\n  {in [pred x in GRing.unit | 0 < x] &, {mono (@GRing.inv R) : x y /~ x < y}}.\nProof. exact: leW_nmono_in ler_pV2. Qed.",
    "Lemma ltr_nV2 :\n  {in [pred x in GRing.unit | x < 0] &, {mono (@GRing.inv R) : x y /~ x < y}}.\nProof. exact: leW_nmono_in ler_nV2. Qed.",
    "Lemma invr_gt1 x : x \\is a GRing.unit -> 0 < x -> (1 < x^-1) = (x < 1).\nProof.\nby move=> Ux xgt0; rewrite -{1}[1]invr1 ltr_pV2 ?inE ?unitr1 ?ltr01 ?Ux.\nQed.",
    "Lemma invr_ge1 x : x \\is a GRing.unit -> 0 < x -> (1 <= x^-1) = (x <= 1).\nProof.\nby move=> Ux xgt0; rewrite -{1}[1]invr1 ler_pV2 ?inE ?unitr1 ?ltr01 // Ux.\nQed.",
    "Lemma invr_le1 x (ux : x \\is a GRing.unit) (hx : 0 < x) :\n  (x^-1 <= 1) = (1 <= x).\nProof. by rewrite -invr_ge1 ?invr_gt0 ?unitrV // invrK. Qed.",
    "Lemma invr_lt1 x (ux : x \\is a GRing.unit) (hx : 0 < x) : (x^-1 < 1) = (1 < x).\nProof. by rewrite -invr_gt1 ?invr_gt0 ?unitrV // invrK. Qed.",
    "Lemma natr_min (m n : nat) : (Order.min m n)%:R = Order.min m%:R n%:R :> R.\nProof. by rewrite !minElt ltr_nat /Order.lt/= -fun_if. Qed.",
    "Lemma natr_max (m n : nat) : (Order.max m n)%:R = Order.max m%:R n%:R :> R.\nProof. by rewrite !maxElt ltr_nat /Order.lt/= -fun_if. Qed.",
    "Lemma addr_min_max x y : min x y + max x y = x + y.\nProof. by rewrite /min /max; case: ifP => //; rewrite addrC. Qed.",
    "Lemma addr_max_min x y : max x y + min x y = x + y.\nProof. by rewrite addrC addr_min_max. Qed.",
    "Lemma minr_to_max x y : min x y = x + y - max x y.\nProof. by rewrite -[x + y]addr_min_max addrK. Qed.",
    "Lemma maxr_to_min x y : max x y = x + y - min x y.\nProof. by rewrite -[x + y]addr_max_min addrK. Qed.",
    "Lemma real_oppr_max : {in real &, {morph -%R : x y / max x y >-> min x y : R}}.\nProof.\nby move=> x y xr yr; rewrite !(fun_if, if_arg) ltrN2; case: real_ltgtP => // ->.\nQed.",
    "Lemma real_oppr_min : {in real &, {morph -%R : x y / min x y >-> max x y : R}}.\nProof.\nby move=> x y xr yr; rewrite -[RHS]opprK real_oppr_max ?realN// !opprK.\nQed.",
    "Lemma real_addr_minl : {in real & real & real, @left_distributive R R +%R min}.\nProof.\nby move=> x y z xr yr zr; case: (@real_leP (_ + _)); rewrite ?realD//;\n   rewrite lterD2; case: real_leP.\nQed.",
    "Lemma real_addr_minr : {in real & real & real, @right_distributive R R +%R min}.\nProof. by move=> x y z xr yr zr; rewrite !(addrC x) real_addr_minl. Qed.",
    "Lemma real_addr_maxl : {in real & real & real, @left_distributive R R +%R max}.\nProof.\nby move=> x y z xr yr zr; case: (@real_leP (_ + _)); rewrite ?realD//;\n   rewrite lterD2; case: real_leP.\nQed.",
    "Lemma real_addr_maxr : {in real & real & real, @right_distributive R R +%R max}.\nProof. by move=> x y z xr yr zr; rewrite !(addrC x) real_addr_maxl. Qed.",
    "Lemma minr_pMr x y z : 0 <= x -> x * min y z = min (x * y) (x * z).\nProof.\nhave [|x_gt0||->]// := comparableP x; last by rewrite !mul0r minxx.\nby rewrite !(fun_if, if_arg) lter_pM2l//; case: (y < z).\nQed.",
    "Lemma maxr_pMr x y z : 0 <= x -> x * max y z = max (x * y) (x * z).\nProof.\nhave [|x_gt0||->]// := comparableP x; last by rewrite !mul0r maxxx.\nby rewrite !(fun_if, if_arg) lter_pM2l//; case: (y < z).\nQed.",
    "Lemma real_maxr_nMr x y z : x <= 0 -> y \\is real -> z \\is real ->\n  x * max y z = min (x * y) (x * z).\nProof.\nmove=> x0 yr zr; rewrite -[_ * _]opprK -mulrN real_oppr_max// -mulNr.\nby rewrite minr_pMr ?oppr_ge0// !(mulNr, mulrN, opprK).\nQed.",
    "Lemma real_minr_nMr x y z :  x <= 0 -> y \\is real -> z \\is real ->\n  x * min y z = max (x * y) (x * z).\nProof.\nmove=> x0 yr zr; rewrite -[_ * _]opprK -mulrN real_oppr_min// -mulNr.\nby rewrite maxr_pMr ?oppr_ge0// !(mulNr, mulrN, opprK).\nQed.",
    "Lemma minr_pMl x y z : 0 <= x -> min y z * x = min (y * x) (z * x).\nProof. by move=> *; rewrite mulrC minr_pMr // ![_ * x]mulrC. Qed.",
    "Lemma maxr_pMl x y z : 0 <= x -> max y z * x = max (y * x) (z * x).\nProof. by move=> *; rewrite mulrC maxr_pMr // ![_ * x]mulrC. Qed.",
    "Lemma real_minr_nMl x y z : x <= 0 -> y \\is real -> z \\is real ->\n  min y z * x = max (y * x) (z * x).\nProof. by move=> *; rewrite mulrC real_minr_nMr // ![_ * x]mulrC. Qed.",
    "Lemma real_maxr_nMl x y z : x <= 0 -> y \\is real -> z \\is real ->\n  max y z * x = min (y * x) (z * x).\nProof. by move=> *; rewrite mulrC real_maxr_nMr // ![_ * x]mulrC. Qed.",
    "Lemma real_maxrN x : x \\is real -> max x (- x) = `|x|.\nProof.\nmove=> x_real; rewrite /max.\nby case: real_ge0P => // [/ge0_cp [] | /lt0_cp []];\n   case: (@real_leP (- x) x); rewrite ?realN.\nQed.",
    "Lemma real_maxNr x : x \\is real -> max (- x) x = `|x|.\nProof.\nby move=> x_real; rewrite comparable_maxC ?real_maxrN ?real_comparable ?realN.\nQed.",
    "Lemma real_minrN x : x \\is real -> min x (- x) = - `|x|.\nProof.\nby move=> x_real; rewrite -[LHS]opprK real_oppr_min ?opprK ?real_maxNr ?realN.\nQed.",
    "Lemma real_minNr x : x \\is real ->  min (- x) x = - `|x|.\nProof.\nby move=> x_real; rewrite -[LHS]opprK real_oppr_min ?opprK ?real_maxrN ?realN.\nQed.",
    "Lemma real_arg_minP : extremum_spec <=%R P F [arg min_(i < i0 | P i) F i].\nProof.\nby apply: comparable_arg_minP => // i j iP jP; rewrite real_comparable ?F_real.\nQed.",
    "Lemma real_arg_maxP : extremum_spec >=%R P F [arg max_(i > i0 | P i) F i].\nProof.\nby apply: comparable_arg_maxP => // i j iP jP; rewrite real_comparable ?F_real.\nQed.",
    "Lemma real_ler_norm x : x \\is real -> x <= `|x|.\nProof.\nby case/real_ge0P=> hx //; rewrite (le_trans (ltW hx)) // oppr_ge0 ltW.\nQed.",
    "Lemma normr_real v : `|v| \\is real. Proof. by apply/ger0_real. Qed.",
    "Lemma ler_norm_sum I r (G : I -> V) (P : pred I):\n  `|\\sum_(i <- r | P i) G i| <= \\sum_(i <- r | P i) `|G i|.\nProof.\nelim/big_rec2: _ => [|i y x _]; first by rewrite normr0.\nby rewrite -(lerD2l `|G i|); apply: le_trans; apply: ler_normD.\nQed.",
    "Lemma ler_normB v w : `|v - w| <= `|v| + `|w|.\nProof. by rewrite (le_trans (ler_normD _ _)) ?normrN. Qed.",
    "Lemma ler_distD u v w : `|v - w| <= `|v - u| + `|u - w|.\nProof. by rewrite (le_trans _ (ler_normD _ _)) // addrA addrNK. Qed.",
    "Lemma lerB_normD v w : `|v| - `|w| <= `|v + w|.\nProof.\nby rewrite -{1}[v](addrK w) lterBDl (le_trans (ler_normD _ _))// addrC normrN.\nQed.",
    "Lemma lerB_dist v w : `|v| - `|w| <= `|v - w|.\nProof. by rewrite -[`|w|]normrN lerB_normD. Qed.",
    "Lemma ler_dist_dist v w : `| `|v| - `|w| | <= `|v - w|.\nProof.\nhave [||_|_] // := @real_leP `|v| `|w|; last by rewrite lerB_dist.\nby rewrite distrC lerB_dist.\nQed.",
    "Lemma ler_dist_normD v w : `| `|v| - `|w| | <= `|v + w|.\nProof. by rewrite -[w]opprK normrN ler_dist_dist. Qed.",
    "Lemma ler_nnorml v x : x < 0 -> `|v| <= x = false.\nProof. by move=> h; rewrite lt_geF //; apply/(lt_le_trans h). Qed.",
    "Lemma ltr_nnorml v x : x <= 0 -> `|v| < x = false.\nProof. by move=> h; rewrite le_gtF //; apply/(le_trans h). Qed.",
    "Lemma real_ler_norml x y : x \\is real -> (`|x| <= y) = (- y <= x <= y).\nProof.\nmove=> xR; wlog x_ge0 : x xR / 0 <= x => [hwlog|].\n  move: (xR) => /(@real_leVge 0) /orP [|/hwlog->|hx] //.\n  by rewrite -[x]opprK normrN lerN2 andbC lerNl hwlog ?realN ?oppr_ge0.\nrewrite ger0_norm //; have [le_xy|] := boolP (x <= y); last by rewrite andbF.\nby rewrite (le_trans _ x_ge0) // oppr_le0 (le_trans x_ge0).\nQed.",
    "Lemma real_ler_normlP x y :\n  x \\is real -> reflect ((-x <= y) * (x <= y)) (`|x| <= y).\nProof.\nby move=> Rx; rewrite real_ler_norml // lerNl; apply: (iffP andP) => [] [].\nQed.",
    "Lemma real_eqr_norml x y :\n  x \\is real -> (`|x| == y) = ((x == y) || (x == -y)) && (0 <= y).\nProof.\nmove=> Rx.\napply/idP/idP=> [|/andP[/pred2P[]-> /ger0_norm/eqP]]; rewrite ?normrE //.\ncase: real_le0P => // hx; rewrite 1?eqr_oppLR => /eqP exy.\n  by move: hx; rewrite exy ?oppr_le0 eqxx orbT //.\nby move: hx=> /ltW; rewrite exy eqxx.\nQed.",
    "Lemma real_eqr_norm2 x y :\n  x \\is real -> y \\is real -> (`|x| == `|y|) = (x == y) || (x == -y).\nProof.\nmove=> Rx Ry; rewrite real_eqr_norml // normrE andbT.\nby case: real_le0P; rewrite // opprK orbC.\nQed.",
    "Lemma real_ltr_norml x y : x \\is real -> (`|x| < y) = (- y < x < y).\nProof.\nmove=> Rx; wlog x_ge0 : x Rx / 0 <= x => [hwlog|].\n  move: (Rx) => /(@real_leVge 0) /orP [|/hwlog->|hx] //.\n  by rewrite -[x]opprK normrN ltrN2 andbC ltrNl hwlog ?realN ?oppr_ge0.\nrewrite ger0_norm //; have [le_xy|] := boolP (x < y); last by rewrite andbF.\nby rewrite (lt_le_trans _ x_ge0) // oppr_lt0 (le_lt_trans x_ge0).\nQed.",
    "Lemma real_ltr_normlP x y :\n  x \\is real -> reflect ((-x < y) * (x < y)) (`|x| < y).\nProof.\nby move=> Rx; rewrite real_ltr_norml // ltrNl; apply: (iffP (@andP _ _)); case.\nQed.",
    "Lemma real_ler_normr x y : y \\is real -> (x <= `|y|) = (x <= y) || (x <= - y).\nProof.\nmove=> Ry.\nhave [xR|xNR] := boolP (x \\is real); last by rewrite ?Nreal_leF ?realN.\nrewrite real_leNgt ?real_ltr_norml // negb_and -?real_leNgt ?realN //.\nby rewrite orbC lerNr.\nQed.",
    "Lemma real_ltr_normr x y : y \\is real -> (x < `|y|) = (x < y) || (x < - y).\nProof.\nmove=> Ry.\nhave [xR|xNR] := boolP (x \\is real); last by rewrite ?Nreal_ltF ?realN.\nrewrite real_ltNge ?real_ler_norml // negb_and -?real_ltNge ?realN //.\nby rewrite orbC ltrNr.\nQed.",
    "Lemma real_ltr_normlW x y : x \\is real -> `|x| < y -> x < y.\nProof. by move=> ?; case/real_ltr_normlP. Qed.",
    "Lemma real_ltrNnormlW x y : x \\is real -> `|x| < y -> - y < x.\nProof. by move=> ?; case/real_ltr_normlP => //; rewrite ltrNl. Qed.",
    "Lemma real_ler_normlW x y : x \\is real -> `|x| <= y -> x <= y.\nProof. by move=> ?; case/real_ler_normlP. Qed.",
    "Lemma real_lerNnormlW x y : x \\is real -> `|x| <= y -> - y <= x.\nProof. by move=> ?; case/real_ler_normlP => //; rewrite lerNl. Qed.",
    "Lemma real_ler_distl x y e :\n  x - y \\is real -> (`|x - y| <= e) = (y - e <= x <= y + e).\nProof. by move=> Rxy; rewrite real_lter_norml // !lterBDl. Qed.",
    "Lemma real_ltr_distl x y e :\n  x - y \\is real -> (`|x - y| < e) = (y - e < x < y + e).\nProof. by move=> Rxy; rewrite real_lter_norml // !lterBDl. Qed.",
    "Lemma real_ltr_distlDr x y e : x - y \\is real -> `|x - y| < e -> x < y + e.\nProof. by move=> ?; rewrite real_ltr_distl // => /andP[]. Qed.",
    "Lemma real_ler_distlDr x y e : x - y \\is real -> `|x - y| <= e -> x <= y + e.\nProof. by move=> ?; rewrite real_ler_distl // => /andP[]. Qed.",
    "Lemma real_ltr_distlCDr x y e : x - y \\is real -> `|x - y| < e -> y < x + e.\nProof. by rewrite realBC (distrC x) => ? /real_ltr_distlDr; apply. Qed.",
    "Lemma real_ler_distlCDr x y e : x - y \\is real -> `|x - y| <= e -> y <= x + e.\nProof. by rewrite realBC distrC => ? /real_ler_distlDr; apply. Qed.",
    "Lemma real_ltr_distlBl x y e : x - y \\is real -> `|x - y| < e -> x - e < y.\nProof. by move/real_ltr_distlDr; rewrite ltrBlDr; apply. Qed.",
    "Lemma real_ler_distlBl x y e : x - y \\is real -> `|x - y| <= e -> x - e <= y.\nProof. by move/real_ler_distlDr; rewrite lerBlDr; apply. Qed.",
    "Lemma real_ltr_distlCBl x y e : x - y \\is real -> `|x - y| < e -> y - e < x.\nProof. by rewrite realBC distrC => ? /real_ltr_distlBl; apply. Qed.",
    "Lemma real_ler_distlCBl x y e : x - y \\is real -> `|x - y| <= e -> y - e <= x.\nProof. by rewrite realBC distrC => ? /real_ler_distlBl; apply. Qed.",
    "Lemma eqr_norm_id x : (`|x| == x) = (0 <= x). Proof. by rewrite ger0_def. Qed.",
    "Lemma eqr_normN x : (`|x| == - x) = (x <= 0). Proof. by rewrite ler0_def. Qed.",
    "Lemma real_exprn_even_ge0 n x : x \\is real -> ~~ odd n -> 0 <= x ^+ n.\nProof.\nmove=> xR even_n; have [/exprn_ge0 -> //|x_lt0] := real_ge0P xR.\nrewrite -[x]opprK -mulN1r exprMn -signr_odd (negPf even_n) expr0 mul1r.\nby rewrite exprn_ge0 ?oppr_ge0 ?ltW.\nQed.",
    "Lemma real_exprn_even_gt0 n x :\n  x \\is real -> ~~ odd n -> (0 < x ^+ n) = (n == 0)%N || (x != 0).\nProof.\nmove=> xR n_even; rewrite lt0r real_exprn_even_ge0 ?expf_eq0 //.\nby rewrite andbT negb_and lt0n negbK.\nQed.",
    "Lemma real_exprn_even_le0 n x :\n  x \\is real -> ~~ odd n -> (x ^+ n <= 0) = (n != 0) && (x == 0).\nProof.\nmove=> xR n_even; rewrite !real_leNgt ?rpred0 ?rpredX //.\nby rewrite real_exprn_even_gt0 // negb_or negbK.\nQed.",
    "Lemma real_exprn_even_lt0 n x :\n  x \\is real -> ~~ odd n -> (x ^+ n < 0) = false.\nProof. by move=> xR n_even; rewrite le_gtF // real_exprn_even_ge0. Qed.",
    "Lemma real_exprn_odd_ge0 n x :\n  x \\is real -> odd n -> (0 <= x ^+ n) = (0 <= x).\nProof.\ncase/real_ge0P => [x_ge0|x_lt0] n_odd; first by rewrite exprn_ge0.\napply: negbTE; rewrite lt_geF //.\ncase: n n_odd => // n /= n_even; rewrite exprS pmulr_llt0 //.\nby rewrite real_exprn_even_gt0 ?ler0_real ?ltW // (lt_eqF x_lt0) ?orbT.\nQed.",
    "Lemma real_exprn_odd_gt0 n x : x \\is real -> odd n -> (0 < x ^+ n) = (0 < x).\nProof.\nby move=> xR n_odd; rewrite !lt0r expf_eq0 real_exprn_odd_ge0; case: n n_odd.\nQed.",
    "Lemma real_exprn_odd_le0 n x : x \\is real -> odd n -> (x ^+ n <= 0) = (x <= 0).\nProof.\nby move=> xR n_odd; rewrite !real_leNgt ?rpred0 ?rpredX // real_exprn_odd_gt0.\nQed.",
    "Lemma real_exprn_odd_lt0 n x : x \\is real -> odd n -> (x ^+ n < 0) = (x < 0).\nProof.\nby move=> xR n_odd; rewrite !real_ltNge ?rpred0 ?rpredX // real_exprn_odd_ge0.\nQed.",
    "Lemma realEsqr x : (x \\is real) = (0 <= x ^+ 2).\nProof. by rewrite ger0_def normrX eqf_sqr -ger0_def -ler0_def. Qed.",
    "Lemma real_normK x : x \\is real -> `|x| ^+ 2 = x ^+ 2.\nProof. by move=> Rx; rewrite -normrX ger0_norm -?realEsqr. Qed.",
    "Lemma normr_sign s : `|(-1) ^+ s : R| = 1.\nProof. by rewrite normrX normrN1 expr1n. Qed.",
    "Lemma normrMsign s x : `|(-1) ^+ s * x| = `|x|.\nProof. by rewrite normrM normr_sign mul1r. Qed.",
    "Lemma signr_gt0 (b : bool) : (0 < (-1) ^+ b :> R) = ~~ b.\nProof. by case: b; rewrite (ltr01, ltr0N1). Qed.",
    "Lemma signr_lt0 (b : bool) : ((-1) ^+ b < 0 :> R) = b.\nProof. by case: b; rewrite // ?(ltrN10, ltr10). Qed.",
    "Lemma signr_ge0 (b : bool) : (0 <= (-1) ^+ b :> R) = ~~ b.\nProof. by rewrite le0r signr_eq0 signr_gt0. Qed.",
    "Lemma signr_le0 (b : bool) : ((-1) ^+ b <= 0 :> R) = b.\nProof. by rewrite le_eqVlt signr_eq0 signr_lt0. Qed.",
    "Lemma signr_inj : injective (fun b : bool => (-1) ^+ b : R).\nProof. exact: can_inj (fun x => 0 >= x) signr_le0. Qed.",
    "Lemma sgr_def x : sg x = (-1) ^+ (x < 0)%R *+ (x != 0).\nProof. by rewrite /sg; do 2!case: ifP => //. Qed.",
    "Lemma neqr0_sign x : x != 0 -> (-1) ^+ (x < 0)%R = sgr x.\nProof. by rewrite sgr_def  => ->. Qed.",
    "Lemma gtr0_sg x : 0 < x -> sg x = 1.\nProof. by move=> x_gt0; rewrite /sg gt_eqF // lt_gtF. Qed.",
    "Lemma ltr0_sg x : x < 0 -> sg x = -1.\nProof. by move=> x_lt0; rewrite /sg x_lt0 lt_eqF. Qed.",
    "Lemma sgr0 : sg 0 = 0 :> R. Proof. by rewrite /sgr eqxx. Qed.",
    "Lemma sgr1 : sg 1 = 1 :> R. Proof. by rewrite gtr0_sg // ltr01. Qed.",
    "Lemma sgrN1 : sg (-1) = -1 :> R. Proof. by rewrite ltr0_sg // ltrN10. Qed.",
    "Lemma sqr_sg x : sg x ^+ 2 = (x != 0)%:R.\nProof. by rewrite sgr_def exprMn_n sqrr_sign -mulnn mulnb andbb. Qed.",
    "Lemma mulr_sg_eq1 x y : (sg x * y == 1) = (x != 0) && (sg x == y).\nProof.\nrewrite /sg eq_sym; case: ifP => _; first by rewrite mul0r oner_eq0.\nby case: ifP => _; rewrite ?mul1r // mulN1r eqr_oppLR.\nQed.",
    "Lemma mulr_sg_eqN1 x y : (sg x * sg y == -1) = (x != 0) && (sg x == - sg y).\nProof.\nmove/sg: y => y; rewrite /sg eq_sym eqr_oppLR.\ncase: ifP => _; first by rewrite mul0r oppr0 oner_eq0.\nby case: ifP => _; rewrite ?mul1r // mulN1r eqr_oppLR.\nQed.",
    "Lemma sgr_eq0 x : (sg x == 0) = (x == 0).\nProof. by rewrite -sqrf_eq0 sqr_sg pnatr_eq0; case: (x == 0). Qed.",
    "Lemma sgr_odd n x : x != 0 -> (sg x) ^+ n = (sg x) ^+ (odd n).\nProof. by rewrite /sg; do 2!case: ifP => // _; rewrite ?expr1n ?signr_odd. Qed.",
    "Lemma sgrMn x n : sg (x *+ n) = (n != 0)%:R * sg x.\nProof.\ncase: n => [|n]; first by rewrite mulr0n sgr0 mul0r.\nby rewrite !sgr_def mulrn_eq0 mul1r pmulrn_llt0.\nQed.",
    "Lemma sgr_nat n : sg n%:R = (n != 0)%:R :> R.\nProof. by rewrite sgrMn sgr1 mulr1. Qed.",
    "Lemma sgr_id x : sg (sg x) = sg x.\nProof. by rewrite !(fun_if sg) !sgrE. Qed.",
    "Lemma sgr_lt0 x : (sg x < 0) = (x < 0).\nProof.\nrewrite /sg; case: eqP => [-> // | _].\nby case: ifP => _; rewrite ?ltrN10 // lt_gtF.\nQed.",
    "Lemma sgr_le0 x : (sgr x <= 0) = (x <= 0).\nProof. by rewrite !le_eqVlt sgr_eq0 sgr_lt0. Qed.",
    "Lemma realEsign x : x \\is real -> x = (-1) ^+ (x < 0)%R * `|x|.\nProof. by case/real_ge0P; rewrite (mul1r, mulN1r) ?opprK. Qed.",
    "Lemma realNEsign x : x \\is real -> - x = (-1) ^+ (0 < x)%R * `|x|.\nProof. by move=> Rx; rewrite -normrN -oppr_lt0 -realEsign ?rpredN. Qed.",
    "Lemma real_normrEsign (x : R) (xR : x \\is real) : `|x| = (-1) ^+ (x < 0)%R * x.\nProof. by rewrite {3}[x]realEsign // signrMK. Qed.",
    "Lemma real_mulr_sign_norm x : x \\is real -> (-1) ^+ (x < 0)%R * `|x| = x.\nProof. by move/realEsign. Qed.",
    "Lemma real_mulr_Nsign_norm x : x \\is real -> (-1) ^+ (0 < x)%R * `|x| = - x.\nProof. by move/realNEsign. Qed.",
    "Lemma realEsg x : x \\is real -> x = sgr x * `|x|.\nProof.\nmove=> xR; have [-> | ] := eqVneq x 0; first by rewrite normr0 mulr0.\nby move=> /neqr0_sign <-; rewrite -realEsign.\nQed.",
    "Lemma normr_sg x : `|sg x| = (x != 0)%:R.\nProof. by rewrite sgr_def -mulr_natr normrMsign normr_nat. Qed.",
    "Lemma sgr_norm x : sg `|x| = (x != 0)%:R.\nProof. by rewrite /sg le_gtF // normr_eq0 mulrb if_neg. Qed.",
    "Lemma leif_nat_r m n C : (m%:R <= n%:R ?= iff C :> R) = (m <= n ?= iff C)%N.\nProof. by rewrite /leif !ler_nat eqr_nat. Qed.",
    "Lemma leifBLR x y z C : (x - y <= z ?= iff C) = (x <= z + y ?= iff C).\nProof. by rewrite /leif !eq_le lerBlDr lerBrDr. Qed.",
    "Lemma leifBRL x y z C : (x <= y - z ?= iff C) = (x + z <= y ?= iff C).\nProof. by rewrite -leifBLR opprK. Qed.",
    "Lemma leifD x1 y1 C1 x2 y2 C2 :\n    x1 <= y1 ?= iff C1 -> x2 <= y2 ?= iff C2 ->\n  x1 + x2 <= y1 + y2 ?= iff C1 && C2.\nProof.\nrewrite -(mono_leif (C := C1) (lerD2r x2)).\nrewrite -(mono_leif (C := C2) (lerD2l y1)).\nexact: leif_trans.\nQed.",
    "Lemma leif_sum (I : finType) (P C : pred I) (E1 E2 : I -> R) :\n    (forall i, P i -> E1 i <= E2 i ?= iff C i) ->\n  \\sum_(i | P i) E1 i <= \\sum_(i | P i) E2 i ?= iff [forall (i | P i), C i].\nProof.\nmove=> leE12; rewrite -big_andE.\nelim/big_rec3: _ => [|i Ci m2 m1 /leE12]; first by rewrite /leif lexx eqxx.\nexact: leifD.\nQed.",
    "Lemma leif_0_sum (I : finType) (P C : pred I) (E : I -> R) :\n    (forall i, P i -> 0 <= E i ?= iff C i) ->\n  0 <= \\sum_(i | P i) E i ?= iff [forall (i | P i), C i].\nProof. by move/leif_sum; rewrite big1_eq. Qed.",
    "Lemma real_leif_norm x : x \\is real -> x <= `|x| ?= iff (0 <= x).\nProof.\nby move=> xR; rewrite ger0_def eq_sym; apply: leif_eq; rewrite real_ler_norm.\nQed.",
    "Lemma leif_pM x1 x2 y1 y2 C1 C2 :\n    0 <= x1 -> 0 <= x2 -> x1 <= y1 ?= iff C1 -> x2 <= y2 ?= iff C2 ->\n  x1 * x2 <= y1 * y2 ?= iff (y1 * y2 == 0) || C1 && C2.\nProof.\nmove=> x1_ge0 x2_ge0 le_xy1 le_xy2; have [y_0 | ] := eqVneq _ 0.\n  apply/leifP; rewrite y_0 /= mulf_eq0 !eq_le x1_ge0 x2_ge0 !andbT.\n  move/eqP: y_0; rewrite mulf_eq0.\n  by case/pred2P=> <-; rewrite (le_xy1, le_xy2) ?orbT.\nrewrite /= mulf_eq0 => /norP[y1nz y2nz].\nhave y1_gt0: 0 < y1 by rewrite lt_def y1nz (le_trans _ le_xy1).\nhave [x2_0 | x2nz] := eqVneq x2 0.\n  apply/leifP; rewrite -le_xy2 x2_0 eq_sym (negPf y2nz) andbF mulr0.\n  by rewrite mulr_gt0 // lt_def y2nz -x2_0 le_xy2.\nhave:= le_xy2; rewrite -[X in X -> _](mono_leif (ler_pM2l y1_gt0)).\nby apply: leif_trans; rewrite (mono_leif (ler_pM2r _)) // lt_def x2nz.\nQed.",
    "Lemma leif_nM x1 x2 y1 y2 C1 C2 :\n    y1 <= 0 -> y2 <= 0 -> x1 <= y1 ?= iff C1 -> x2 <= y2 ?= iff C2 ->\n  y1 * y2 <= x1 * x2 ?= iff (x1 * x2 == 0) || C1 && C2.\nProof.\nrewrite -!oppr_ge0 -mulrNN -[x1 * x2]mulrNN => y1le0 y2le0 le_xy1 le_xy2.\nby apply: leif_pM => //; rewrite (nmono_leif lerN2).\nQed.",
    "Lemma leif_pprod (I : finType) (P C : pred I) (E1 E2 : I -> R) :\n    (forall i, P i -> 0 <= E1 i) ->\n    (forall i, P i -> E1 i <= E2 i ?= iff C i) ->\n  let pi E := \\prod_(i | P i) E i in\n  pi E1 <= pi E2 ?= iff (pi E2 == 0) || [forall (i | P i), C i].\nProof.\nmove=> E1_ge0 leE12 /=; rewrite -big_andE; elim/(big_load (fun x => 0 <= x)): _.\nelim/big_rec3: _ => [|i Ci m2 m1 Pi [m1ge0 le_m12]].\n  by split=> //; apply/leifP; rewrite orbT.\nhave Ei_ge0 := E1_ge0 i Pi; split; first by rewrite mulr_ge0.\ncongr (leif _ _ _): (leif_pM Ei_ge0 m1ge0 (leE12 i Pi) le_m12).\nby rewrite mulf_eq0 -!orbA; congr (_ || _); rewrite !orb_andr orbA orbb.\nQed.",
    "Lemma subr_lteifr0 C x y : (y - x < 0 ?<= if C) = (y < x ?<= if C).\nProof. by case: C => /=; rewrite subr_lte0. Qed.",
    "Lemma subr_lteif0r C x y : (0 < y - x ?<= if C) = (x < y ?<= if C).\nProof. by case: C => /=; rewrite subr_gte0. Qed.",
    "Lemma lteif01 C : 0 < 1 ?<= if C :> R.\nProof. by case: C; rewrite /= lter01. Qed.",
    "Lemma lteifNl C x y : - x < y ?<= if C = (- y < x ?<= if C).\nProof. by case: C; rewrite /= lterNl. Qed.",
    "Lemma lteifNr C x y : x < - y ?<= if C = (y < - x ?<= if C).\nProof. by case: C; rewrite /= lterNr. Qed.",
    "Lemma lteif0Nr C x : 0 < - x ?<= if C = (x < 0 ?<= if C).\nProof. by case: C; rewrite /= (oppr_ge0, oppr_gt0). Qed.",
    "Lemma lteifNr0 C x : - x < 0 ?<= if C = (0 < x ?<= if C).\nProof. by case: C; rewrite /= (oppr_le0, oppr_lt0). Qed.",
    "Lemma lteifN2 C : {mono -%R : x y /~ x < y ?<= if C :> R}.\nProof. by case: C => ? ?; rewrite /= lterN2. Qed.",
    "Lemma lteifD2l C x : {mono +%R x : y z / y < z ?<= if C}.\nProof. by case: C => ? ?; rewrite /= lterD2. Qed.",
    "Lemma lteifD2r C x : {mono +%R^~ x : y z / y < z ?<= if C}.\nProof. by case: C => ? ?; rewrite /= lterD2. Qed.",
    "Lemma lteifBlDr C x y z : (x - y < z ?<= if C) = (x < z + y ?<= if C).\nProof. by case: C; rewrite /= lterBDr. Qed.",
    "Lemma lteifBrDr C x y z : (x < y - z ?<= if C) = (x + z < y ?<= if C).\nProof. by case: C; rewrite /= lterBDr. Qed.",
    "Lemma lteifBlDl C x y z : (x - y < z ?<= if C) = (x < y + z ?<= if C).\nProof. by case: C; rewrite /= lterBDl. Qed.",
    "Lemma lteifBrDl C x y z : (x < y - z ?<= if C) = (z + x < y ?<= if C).\nProof. by case: C; rewrite /= lterBDl. Qed.",
    "Lemma lteif_pM2l C x : 0 < x -> {mono *%R x : y z / y < z ?<= if C}.\nProof. by case: C => ? ? ?; rewrite /= lter_pM2l. Qed.",
    "Lemma lteif_pM2r C x : 0 < x -> {mono *%R^~ x : y z / y < z ?<= if C}.\nProof. by case: C => ? ? ?; rewrite /= lter_pM2r. Qed.",
    "Lemma lteif_nM2l C x : x < 0 -> {mono *%R x : y z /~ y < z ?<= if C}.\nProof. by case: C => ? ? ?; rewrite /= lter_nM2l. Qed.",
    "Lemma lteif_nM2r C x : x < 0 -> {mono *%R^~ x : y z /~ y < z ?<= if C}.\nProof. by case: C => ? ? ?; rewrite /= lter_nM2r. Qed.",
    "Lemma lteif_nnormr C x y : y < 0 ?<= if ~~ C -> (`|x| < y ?<= if C) = false.\nProof. by case: C => ?; rewrite /= lter_nnormr. Qed.",
    "Lemma real_lteifNE x y C : x \\is Num.real -> y \\is Num.real ->\n  x < y ?<= if ~~ C = ~~ (y < x ?<= if C).\nProof. by move=> ? ?; rewrite comparable_lteifNE ?real_comparable. Qed.",
    "Lemma real_lteif_norml C x y :\n  x \\is Num.real ->\n  (`|x| < y ?<= if C) = ((- y < x ?<= if C) && (x < y ?<= if C)).\nProof. by case: C => ?; rewrite /= real_lter_norml. Qed.",
    "Lemma real_lteif_normr C x y :\n  y \\is Num.real ->\n  (x < `|y| ?<= if C) = ((x < y ?<= if C) || (x < - y ?<= if C)).\nProof. by case: C => ?; rewrite /= real_lter_normr. Qed.",
    "Lemma real_lteif_distl C x y e :\n  x - y \\is real ->\n  (`|x - y| < e ?<= if C) = (y - e < x ?<= if C) && (x < y + e ?<= if C).\nProof. by case: C => /= ?; rewrite real_lter_distl. Qed.",
    "Lemma real_leif_mean_square_scaled x y :\n  x \\is real -> y \\is real -> x * y *+ 2 <= x ^+ 2 + y ^+ 2 ?= iff (x == y).\nProof.\nmove=> Rx Ry; rewrite -[_ *+ 2]add0r -leifBRL addrAC -sqrrB -subr_eq0.\nby rewrite -sqrf_eq0 eq_sym; apply: leif_eq; rewrite -realEsqr rpredB.\nQed.",
    "Lemma real_leif_AGM2_scaled x y :\n  x \\is real -> y \\is real -> x * y *+ 4 <= (x + y) ^+ 2 ?= iff (x == y).\nProof.\nmove=> Rx Ry; rewrite sqrrD addrAC (mulrnDr _ 2) -leifBLR addrK.\nexact: real_leif_mean_square_scaled.\nQed.",
    "Lemma leif_AGM_scaled (I : finType) (A : {pred I}) (E : I -> R) (n := #|A|) :\n    {in A, forall i, 0 <= E i *+ n} ->\n  \\prod_(i in A) (E i *+ n) <= (\\sum_(i in A) E i) ^+ n\n                            ?= iff [forall i in A, forall j in A, E i == E j].\nProof.\nhave [m leAm] := ubnP #|A|; elim: m => // m IHm in A leAm E n * => Ege0.\napply/leifP; case: ifPn => [/forall_inP-Econstant | Enonconstant].\n  have [i /= Ai | A0] := pickP [in A]; last by rewrite [n]eq_card0 ?big_pred0.\n  have /eqfun_inP-E_i := Econstant i Ai; rewrite -(eq_bigr _ E_i) sumr_const.\n  by rewrite exprMn_n prodrMn_const -(eq_bigr _ E_i) prodr_const.\nset mu := \\sum_(i in A) E i; pose En i := E i *+ n.\npose cmp_mu s := [pred i | s * mu < s * En i].\nhave{Enonconstant} has_cmp_mu e (s := (-1) ^+ e): {i | i \\in A & cmp_mu s i}.\n  apply/sig2W/exists_inP; apply: contraR Enonconstant => /exists_inPn-mu_s_A.\n  have n_gt0 i: i \\in A -> (0 < n)%N by rewrite [n](cardD1 i) => ->.\n  have{} mu_s_A i: i \\in A -> s * En i <= s * mu.\n    move=> Ai; rewrite real_leNgt ?mu_s_A ?rpredMsign ?ger0_real ?Ege0 //.\n    by rewrite -(pmulrn_lge0 _ (n_gt0 i Ai)) -sumrMnl sumr_ge0.\n  have [_ /esym/eqfun_inP] := leif_sum (fun i Ai => leif_eq (mu_s_A i Ai)).\n  rewrite sumr_const -/n -mulr_sumr sumrMnl -/mu mulrnAr eqxx => A_mu.\n  apply/forall_inP=> i Ai; apply/eqfun_inP=> j Aj.\n  by apply: (pmulrnI (n_gt0 i Ai)); apply: (can_inj (signrMK e)); rewrite !A_mu.\nhave [[i Ai Ei_lt_mu] [j Aj Ej_gt_mu]] := (has_cmp_mu 1, has_cmp_mu 0)%N.\nrewrite {cmp_mu has_cmp_mu}/= !mul1r !mulN1r ltrN2 in Ei_lt_mu Ej_gt_mu.\npose A' := [predD1 A & i]; pose n' := #|A'|.\nhave [Dn n_gt0]: n = n'.+1 /\\ (n > 0)%N  by rewrite [n](cardD1 i) Ai.\nhave i'j: j != i by apply: contraTneq Ej_gt_mu => ->; rewrite lt_gtF.\nhave{i'j} A'j: j \\in A' by rewrite !inE Aj i'j.\nhave mu_gt0: 0 < mu := le_lt_trans (Ege0 i Ai) Ei_lt_mu.\nrewrite (bigD1 i) // big_andbC (bigD1 j) //= mulrA; set pi := \\prod_(k | _) _.\nhave [-> | nz_pi] := eqVneq pi 0; first by rewrite !mulr0 exprn_gt0.\nhave{nz_pi} pi_gt0: 0 < pi.\n  by rewrite lt_def nz_pi prodr_ge0 // => k /andP[/andP[_ /Ege0]].\nrewrite -/(En i) -/(En j); pose E' := [eta En with j |-> En i + En j - mu].\nhave E'ge0 k: k \\in A' -> E' k *+ n' >= 0.\n  case/andP=> /= _ Ak; apply: mulrn_wge0; case: ifP => _; last exact: Ege0.\n  by rewrite subr_ge0 ler_wpDl ?Ege0 // ltW.\nrewrite -/n Dn in leAm; have{leAm IHm E'ge0}: _ <= _ := IHm _ leAm _ E'ge0.\nhave ->: \\sum_(k in A') E' k = mu *+ n'.\n  apply: (addrI mu); rewrite -mulrS -Dn -sumrMnl (bigD1 i Ai) big_andbC /=.\n  rewrite !(bigD1 j A'j) /= addrCA eqxx !addrA subrK; congr (_ + _).\n  by apply: eq_bigr => k /andP[_ /negPf->].\nrewrite prodrMn_const exprMn_n -/n' ler_pMn2r ?expn_gt0; last by case: (n').\nhave ->: \\prod_(k in A') E' k = E' j * pi.\n  by rewrite (bigD1 j) //=; congr *%R; apply: eq_bigr => k /andP[_ /negPf->].\nrewrite -(ler_pM2l mu_gt0) -exprS -Dn mulrA; apply: lt_le_trans.\nrewrite ltr_pM2r //= eqxx -addrA mulrDr mulrC -ltrBlDl -mulrBl.\nby rewrite mulrC ltr_pM2r ?subr_gt0.\nQed.",
    "Lemma poly_disk_bound p b : {ub | forall x, `|x| <= b -> `|p.[x]| <= ub}.\nProof.\nexists (\\sum_(j < size p) `|p`_j| * b ^+ j) => x le_x_b.\nrewrite horner_coef (le_trans (ler_norm_sum _ _ _)) ?ler_sum // => j _.\nrewrite normrM normrX ler_wpM2l ?lerXn2r ?unfold_in //=.\nexact: le_trans (normr_ge0 x) le_x_b.\nQed.",
    "Lemma real_mono :\n  {homo f : x y / x < y} -> {in real &, {mono f : x y / x <= y}}.\nProof.\nmove=> mf x y xR yR /=; have [lt_xy | le_yx] := real_leP xR yR.\n  by rewrite ltW_homo.\nby rewrite lt_geF ?mf.\nQed.",
    "Lemma real_nmono :\n  {homo f : x y /~ x < y} -> {in real &, {mono f : x y /~ x <= y}}.\nProof.\nmove=> mf x y xR yR /=; have [lt_xy|le_yx] := real_ltP xR yR.\n  by rewrite lt_geF ?mf.\nby rewrite ltW_nhomo.\nQed.",
    "Lemma real_mono_in :\n    {in D &, {homo f : x y / x < y}} ->\n  {in [pred x in D | x \\is real] &, {mono f : x y / x <= y}}.\nProof.\nmove=> Dmf x y /andP[hx xR] /andP[hy yR] /=.\nhave [lt_xy|le_yx] := real_leP xR yR; first by rewrite (ltW_homo_in Dmf).\nby rewrite lt_geF ?Dmf.\nQed.",
    "Lemma real_nmono_in :\n    {in D &, {homo f : x y /~ x < y}} ->\n  {in [pred x in D | x \\is real] &, {mono f : x y /~ x <= y}}.\nProof.\nmove=> Dmf x y /andP[hx xR] /andP[hy yR] /=.\nhave [lt_xy|le_yx] := real_ltP xR yR; last by rewrite (ltW_nhomo_in Dmf).\nby rewrite lt_geF ?Dmf.\nQed.",
    "Lemma realn_mono : {homo f' : x y / x < y >-> (x < y)} ->\n  {in real &, {mono f' : x y / x <= y >-> (x <= y)}}.\nProof.\nmove=> mf x y xR yR /=; have [lt_xy | le_yx] := real_leP xR yR.\n  by rewrite ltW_homo.\nby rewrite lt_geF ?mf.\nQed.",
    "Lemma realn_nmono : {homo f' : x y / y < x >-> (x < y)} ->\n  {in real &, {mono f' : x y / y <= x >-> (x <= y)}}.\nProof.\nmove=> mf x y xR yR /=; have [lt_xy|le_yx] := real_ltP xR yR.\n  by rewrite lt_geF ?mf.\nby rewrite ltW_nhomo.\nQed.",
    "Lemma realn_mono_in : {in D &, {homo f' : x y / x < y >-> (x < y)}} ->\n  {in [pred x in D | x \\is real] &, {mono f' : x y / x <= y >-> (x <= y)}}.\nProof.\nmove=> Dmf x y /andP[hx xR] /andP[hy yR] /=.\nhave [lt_xy|le_yx] := real_leP xR yR; first by rewrite (ltW_homo_in Dmf).\nby rewrite lt_geF ?Dmf.\nQed.",
    "Lemma realn_nmono_in : {in D &, {homo f' : x y / y < x >-> (x < y)}} ->\n  {in [pred x in D | x \\is real] &, {mono f' : x y / y <= x >-> (x <= y)}}.\nProof.\nmove=> Dmf x y /andP[hx xR] /andP[hy yR] /=.\nhave [lt_xy|le_yx] := real_ltP xR yR; last by rewrite (ltW_nhomo_in Dmf).\nby rewrite lt_geF ?Dmf.\nQed.",
    "Lemma natrG_gt0 G : #|G|%:R > 0 :> R.\nProof. by rewrite ltr0n cardG_gt0. Qed.",
    "Lemma natrG_neq0 G : #|G|%:R != 0 :> R.\nProof. by rewrite gt_eqF // natrG_gt0. Qed.",
    "Lemma natr_indexg_gt0 G B : #|G : B|%:R > 0 :> R.\nProof. by rewrite ltr0n indexg_gt0. Qed.",
    "Lemma natr_indexg_neq0 G B : #|G : B|%:R != 0 :> R.\nProof. by rewrite gt_eqF // natr_indexg_gt0. Qed.",
    "Lemma unitf_gt0 x : 0 < x -> x \\is a GRing.unit.\nProof. by move=> hx; rewrite unitfE eq_sym lt_eqF. Qed.",
    "Lemma unitf_lt0 x : x < 0 -> x \\is a GRing.unit.\nProof. by move=> hx; rewrite unitfE lt_eqF. Qed.",
    "Lemma lef_pV2 : {in pos &, {mono (@GRing.inv F) : x y /~ x <= y}}.\nProof. by move=> x y hx hy /=; rewrite ler_pV2 ?inE ?unitf_gt0. Qed.",
    "Lemma lef_nV2 : {in neg &, {mono (@GRing.inv F) : x y /~ x <= y}}.\nProof. by move=> x y hx hy /=; rewrite ler_nV2 ?inE ?unitf_lt0. Qed.",
    "Lemma ltf_pV2 : {in pos &, {mono (@GRing.inv F) : x y /~ x < y}}.\nProof. exact: leW_nmono_in lef_pV2. Qed.",
    "Lemma ltf_nV2 : {in neg &, {mono (@GRing.inv F) : x y /~ x < y}}.\nProof. exact: leW_nmono_in lef_nV2. Qed.",
    "Lemma invf_pgt : {in pos &, forall x y, (x < y^-1) = (y < x^-1)}.\nProof. by move=> x y *; rewrite -[x in LHS]invrK ltf_pV2// posrE invr_gt0. Qed.",
    "Lemma invf_pge : {in pos &, forall x y, (x <= y^-1) = (y <= x^-1)}.\nProof. by move=> x y *; rewrite -[x in LHS]invrK lef_pV2// posrE invr_gt0. Qed.",
    "Lemma invf_ngt : {in neg &, forall x y, (x < y^-1) = (y < x^-1)}.\nProof. by move=> x y *; rewrite -[x in LHS]invrK ltf_nV2// negrE invr_lt0. Qed.",
    "Lemma invf_nge : {in neg &, forall x y, (x <= y^-1) = (y <= x^-1)}.\nProof. by move=> x y *; rewrite -[x in LHS]invrK lef_nV2// negrE invr_lt0. Qed.",
    "Lemma invf_gt1 x : 0 < x -> (1 < x^-1) = (x < 1).\nProof. by move=> x0; rewrite invf_pgt ?invr1 ?posrE. Qed.",
    "Lemma invf_ge1 x : 0 < x -> (1 <= x^-1) = (x <= 1).\nProof. by move=> x0; rewrite invf_pge ?invr1 ?posrE. Qed.",
    "Lemma invf_plt : {in pos &, forall x y, (x^-1 < y) = (y^-1 < x)}.\nProof. by move=> x y *; rewrite -[y in LHS]invrK ltf_pV2// posrE invr_gt0. Qed.",
    "Lemma invf_ple : {in pos &, forall x y, (x^-1 <= y) = (y^-1 <= x)}.\nProof. by move=> x y *; rewrite -[y in LHS]invrK lef_pV2// posrE invr_gt0. Qed.",
    "Lemma invf_nlt : {in neg &, forall x y, (x^-1 < y) = (y^-1 < x)}.\nProof. by move=> x y *; rewrite -[y in LHS]invrK ltf_nV2// negrE invr_lt0. Qed.",
    "Lemma invf_nle : {in neg &, forall x y, (x^-1 <= y) = (y^-1 <= x)}.\nProof. by move=> x y *; rewrite -[y in LHS]invrK lef_nV2// negrE invr_lt0. Qed.",
    "Lemma invf_le1 x : 0 < x -> (x^-1 <= 1) = (1 <= x).\nProof. by move=> x0; rewrite -invf_ple ?invr1 ?posrE. Qed.",
    "Lemma invf_lt1 x : 0 < x -> (x^-1 < 1) = (1 < x).\nProof. by move=> x0; rewrite invf_plt ?invr1 ?posrE. Qed.",
    "Lemma ler_pdivlMr z x y : 0 < z -> (x <= y / z) = (x * z <= y).\nProof. by move=> z_gt0; rewrite -(@ler_pM2r _ z _ x) ?mulfVK ?gt_eqF. Qed.",
    "Lemma ltr_pdivlMr z x y : 0 < z -> (x < y / z) = (x * z < y).\nProof. by move=> z_gt0; rewrite -(@ltr_pM2r _ z _ x) ?mulfVK ?gt_eqF. Qed.",
    "Lemma ler_pdivrMr z x y : 0 < z -> (y / z <= x) = (y <= x * z).\nProof. by move=> z_gt0; rewrite -(@ler_pM2r _ z) ?mulfVK ?gt_eqF. Qed.",
    "Lemma ltr_pdivrMr z x y : 0 < z -> (y / z < x) = (y < x * z).\nProof. by move=> z_gt0; rewrite -(@ltr_pM2r _ z) ?mulfVK ?gt_eqF. Qed.",
    "Lemma ler_pdivlMl z x y : 0 < z -> (x <= z^-1 * y) = (z * x <= y).\nProof. by move=> z_gt0; rewrite mulrC ler_pdivlMr ?[z * _]mulrC. Qed.",
    "Lemma ltr_pdivlMl z x y : 0 < z -> (x < z^-1 * y) = (z * x < y).\nProof. by move=> z_gt0; rewrite mulrC ltr_pdivlMr ?[z * _]mulrC. Qed.",
    "Lemma ler_pdivrMl z x y : 0 < z -> (z^-1 * y <= x) = (y <= z * x).\nProof. by move=> z_gt0; rewrite mulrC ler_pdivrMr ?[z * _]mulrC. Qed.",
    "Lemma ltr_pdivrMl z x y : 0 < z -> (z^-1 * y < x) = (y < z * x).\nProof. by move=> z_gt0; rewrite mulrC ltr_pdivrMr ?[z * _]mulrC. Qed.",
    "Lemma ler_ndivlMr z x y : z < 0 -> (x <= y / z) = (y <= x * z).\nProof. by move=> z_lt0; rewrite -(@ler_nM2r _ z) ?mulfVK  ?lt_eqF. Qed.",
    "Lemma ltr_ndivlMr z x y : z < 0 -> (x < y / z) = (y < x * z).\nProof. by move=> z_lt0; rewrite -(@ltr_nM2r _ z) ?mulfVK ?lt_eqF. Qed.",
    "Lemma ler_ndivrMr z x y : z < 0 -> (y / z <= x) = (x * z <= y).\nProof. by move=> z_lt0; rewrite -(@ler_nM2r _ z) ?mulfVK ?lt_eqF. Qed.",
    "Lemma ltr_ndivrMr z x y : z < 0 -> (y / z < x) = (x * z < y).\nProof. by move=> z_lt0; rewrite -(@ltr_nM2r _ z) ?mulfVK ?lt_eqF. Qed.",
    "Lemma ler_ndivlMl z x y : z < 0 -> (x <= z^-1 * y) = (y <= z * x).\nProof. by move=> z_lt0; rewrite mulrC ler_ndivlMr ?[z * _]mulrC. Qed.",
    "Lemma ltr_ndivlMl z x y : z < 0 -> (x < z^-1 * y) = (y < z * x).\nProof. by move=> z_lt0; rewrite mulrC ltr_ndivlMr ?[z * _]mulrC. Qed.",
    "Lemma ler_ndivrMl z x y : z < 0 -> (z^-1 * y <= x) = (z * x <= y).\nProof. by move=> z_lt0; rewrite mulrC ler_ndivrMr ?[z * _]mulrC. Qed.",
    "Lemma ltr_ndivrMl z x y : z < 0 -> (z^-1 * y < x) = (z * x < y).\nProof. by move=> z_lt0; rewrite mulrC ltr_ndivrMr ?[z * _]mulrC. Qed.",
    "Lemma natf_div m d : (d %| m)%N -> (m %/ d)%:R = m%:R / d%:R :> F.\nProof. by apply: pchar0_natf_div; apply: (@pchar_num F). Qed.",
    "Lemma normfV : {morph (norm : F -> F) : x / x ^-1}.\nProof.\nmove=> x /=; have [/normrV //|Nux] := boolP (x \\is a GRing.unit).\nby rewrite !invr_out // unitfE normr_eq0 -unitfE.\nQed.",
    "Lemma normf_div : {morph (norm : F -> F) : x y / x / y}.\nProof. by move=> x y /=; rewrite normrM normfV. Qed.",
    "Lemma invr_sg x : (sg x)^-1 = sgr x.\nProof. by rewrite !(fun_if GRing.inv) !(invr0, invrN, invr1). Qed.",
    "Lemma sgrV x : sgr x^-1 = sgr x.\nProof. by rewrite /sgr invr_eq0 invr_lt0. Qed.",
    "Lemma splitr x : x = x / 2%:R + x / 2%:R.\nProof. by rewrite -mulr2n -mulr_natr mulfVK //= pnatr_eq0. Qed.",
    "Lemma lteif_pdivlMr C z x y :\n  0 < z -> x < y / z ?<= if C = (x * z < y ?<= if C).\nProof. by case: C => ? /=; rewrite lter_pdivlMr. Qed.",
    "Lemma lteif_pdivrMr C z x y :\n  0 < z -> y / z < x ?<= if C = (y < x * z ?<= if C).\nProof. by case: C => ? /=; rewrite lter_pdivrMr. Qed.",
    "Lemma lteif_pdivlMl C z x y :\n  0 < z -> x < z^-1 * y ?<= if C = (z * x < y ?<= if C).\nProof. by case: C => ? /=; rewrite lter_pdivlMl. Qed.",
    "Lemma lteif_pdivrMl C z x y :\n  0 < z -> z^-1 * y < x ?<= if C = (y < z * x ?<= if C).\nProof. by case: C => ? /=; rewrite lter_pdivrMl. Qed.",
    "Lemma lteif_ndivlMr C z x y :\n  z < 0 -> x < y / z ?<= if C = (y < x * z ?<= if C).\nProof. by case: C => ? /=; rewrite lter_ndivlMr. Qed.",
    "Lemma lteif_ndivrMr C z x y :\n  z < 0 -> y / z < x ?<= if C = (x * z < y ?<= if C).\nProof. by case: C => ? /=; rewrite lter_ndivrMr. Qed.",
    "Lemma lteif_ndivlMl C z x y :\n  z < 0 -> x < z^-1 * y ?<= if C = (y < z * x ?<= if C).\nProof. by case: C => ? /=; rewrite lter_ndivlMl. Qed.",
    "Lemma lteif_ndivrMl C z x y :\n  z < 0 -> z^-1 * y < x ?<= if C = (z * x < y ?<= if C).\nProof. by case: C => ? /=; rewrite lter_ndivrMl. Qed.",
    "Lemma midf_le x y : x <= y -> (x <= mid x y) * (mid x y <= y).\nProof.\nmove=> lexy; rewrite ler_pdivlMr ?ler_pdivrMr ?ltr0Sn //.\nby rewrite !mulrDr !mulr1 !lerD2.\nQed.",
    "Lemma midf_lt x y : x < y -> (x < mid x y) * (mid x y < y).\nProof.\nmove=> ltxy; rewrite ltr_pdivlMr ?ltr_pdivrMr ?ltr0Sn //.\nby rewrite !mulrDr !mulr1 !ltrD2.\nQed.",
    "Lemma ler_addgt0Pr x y : reflect (forall e, e > 0 -> x <= y + e) (x <= y).\nProof.\napply/(iffP idP)=> [lexy e e_gt0 | lexye]; first by rewrite ler_wpDr// ltW.\nhave [||ltyx]// := comparable_leP.\n  rewrite (@comparabler_trans _ (y + 1))// /Order.comparable ?lexye ?ltr01//.\n  by rewrite lerDl ler01 orbT.\nhave /midf_lt [_] := ltyx; rewrite le_gtF//.\nrewrite -(@addrK _ y y) (addrAC _ _ x) -addrA 2!mulrDl -splitr lexye//.\nby rewrite divr_gt0// ?ltr0n// subr_gt0.\nQed.",
    "Lemma ler_addgt0Pl x y : reflect (forall e, e > 0 -> x <= e + y) (x <= y).\nProof.\nby apply/(equivP (ler_addgt0Pr x y)); split=> lexy e /lexy; rewrite addrC.\nQed.",
    "Lemma lt_le a b : (forall x, x < a -> x < b) -> a <= b.\nProof.\nmove=> ab; apply/ler_addgt0Pr => e e_gt0; rewrite -lerBDr ltW//.\nby rewrite ab// ltrBlDr ltrDl.\nQed.",
    "Lemma gt_ge a b : (forall x, b < x -> a < x) -> a <= b.\nProof.\nby move=> ab; apply/ler_addgt0Pr => e e_gt0; rewrite ltW// ab// ltrDl.\nQed.",
    "Lemma real_leif_mean_square x y :\n  x \\is real -> y \\is real -> x * y <= mid (x ^+ 2) (y ^+ 2) ?= iff (x == y).\nProof.\nmove=> Rx Ry; rewrite -(mono_leif (ler_pM2r (ltr_nat F 0 2))).\nby rewrite divfK ?pnatr_eq0 // mulr_natr; apply: real_leif_mean_square_scaled.\nQed.",
    "Lemma real_leif_AGM2 x y :\n  x \\is real -> y \\is real -> x * y <= mid x y ^+ 2 ?= iff (x == y).\nProof.\nmove=> Rx Ry; rewrite -(mono_leif (ler_pM2r (ltr_nat F 0 4))).\nrewrite mulr_natr (natrX F 2 2) -exprMn divfK ?pnatr_eq0 //.\nexact: real_leif_AGM2_scaled.\nQed.",
    "Lemma leif_AGM (I : finType) (A : {pred I}) (E : I -> F) :\n    let n := #|A| in let mu := (\\sum_(i in A) E i) / n%:R in\n    {in A, forall i, 0 <= E i} ->\n  \\prod_(i in A) E i <= mu ^+ n\n                     ?= iff [forall i in A, forall j in A, E i == E j].\nProof.\nmove=> n mu Ege0; have [n0 | n_gt0] := posnP n.\n  by rewrite n0 -big_andE !(big_pred0 _ _ _ _ (card0_eq n0)); apply/leifP.\npose E' i := E i / n%:R.\nhave defE' i: E' i *+ n = E i by rewrite -mulr_natr divfK ?pnatr_eq0 -?lt0n.\nhave /leif_AGM_scaled (i): i \\in A -> 0 <= E' i *+ n by rewrite defE' => /Ege0.\nrewrite -/n -mulr_suml (eq_bigr _ (in1W defE')); congr (_ <= _ ?= iff _).\nby do 2![apply: eq_forallb_in => ? _]; rewrite -(eqr_pMn2r n_gt0) !defE'.\nQed.",
    "Lemma Cauchy_root_bound p : p != 0 -> {b | forall x, root p x -> `|x| <= b}.\nProof.\nmove=> nz_p; set a := lead_coef p; set n := (size p).-1.\nhave [q Dp]: {q | forall x, x != 0 -> p.[x] = (a - q.[x^-1] / x) * x ^+ n}.\n  exists (- \\poly_(i < n) p`_(n - i.+1)) => x nz_x.\n  rewrite hornerN mulNr opprK horner_poly mulrDl !mulr_suml addrC.\n  rewrite horner_coef polySpred // big_ord_recr (reindex_inj rev_ord_inj) /=.\n  rewrite -/n -lead_coefE; congr (_ + _); apply: eq_bigr=> i _.\n  by rewrite exprB ?unitfE // -exprVn mulrA mulrAC exprSr mulrA.\nhave [b ub_q] := poly_disk_bound q 1; exists (b / `|a| + 1) => x px0.\nhave b_ge0: 0 <= b by rewrite (le_trans (normr_ge0 q.[1])) ?ub_q ?normr1.\nhave{b_ge0} ba_ge0: 0 <= b / `|a| by rewrite divr_ge0.\nrewrite real_leNgt ?rpredD ?rpred1 ?ger0_real //.\napply: contraL px0 => lb_x; rewrite rootE.\nhave x_ge1: 1 <= `|x| by rewrite (le_trans _ (ltW lb_x)) // ler_wpDl.\nhave nz_x: x != 0 by rewrite -normr_gt0 (lt_le_trans ltr01).\nrewrite {}Dp // mulf_neq0 ?expf_neq0 // subr_eq0 eq_sym.\nhave: (b / `|a|) < `|x| by rewrite (lt_trans _ lb_x) // ltr_pwDr ?ltr01.\napply: contraTneq => /(canRL (divfK nz_x))Dax.\nrewrite ltr_pdivrMr ?normr_gt0 ?lead_coef_eq0 // mulrC -normrM -{}Dax.\nby rewrite le_gtF // ub_q // normfV invf_le1 ?normr_gt0.\nQed.",
    "Lemma natf_indexg (gT : finGroupType) (G H : {group gT}) :\n  H \\subset G -> #|G : H|%:R = (#|G|%:R / #|H|%:R)%R :> F.\nProof. by move=> sHG; rewrite -divgS // natf_div ?cardSg. Qed.",
    "Lemma num_real x : x \\is real. Proof. exact: num_real. Qed.",
    "Lemma lerP x y : ler_xor_gt x y (min y x) (min x y) (max y x) (max x y)\n                                `|x - y| `|y - x| (x <= y) (y < x).\nProof. exact: real_leP. Qed.",
    "Lemma ltrP x y : ltr_xor_ge x y (min y x) (min x y) (max y x) (max x y)\n                                `|x - y| `|y - x| (y <= x) (x < y).\nProof. exact: real_ltP. Qed.",
    "Lemma ltrgtP x y :\n   comparer x y  (min y x) (min x y) (max y x) (max x y)\n                 `|x - y| `|y - x| (y == x) (x == y)\n                 (x >= y) (x <= y) (x > y) (x < y) .\nProof. exact: real_ltgtP. Qed.",
    "Lemma ger0P x : ger0_xor_lt0 x (min 0 x) (min x 0) (max 0 x) (max x 0)\n                                `|x| (x < 0) (0 <= x).\nProof. exact: real_ge0P. Qed.",
    "Lemma ler0P x : ler0_xor_gt0 x (min 0 x) (min x 0) (max 0 x) (max x 0)\n                                `|x| (0 < x) (x <= 0).\nProof. exact: real_le0P. Qed.",
    "Lemma ltrgt0P x : comparer0 x (min 0 x) (min x 0) (max 0 x) (max x 0)\n  `|x| (0 == x) (x == 0) (x <= 0) (0 <= x) (x < 0) (x > 0).\nProof. exact: real_ltgt0P. Qed.",
    "Lemma mulr_lt0 x y :\n  (x * y < 0) = [&& x != 0, y != 0 & (x < 0) (+) (y < 0)].\nProof.\nhave [x_gt0|x_lt0|->] /= := ltrgt0P x; last by rewrite mul0r.\n  by rewrite pmulr_rlt0 //; case: ltrgt0P.\nby rewrite nmulr_rlt0 //; case: ltrgt0P.\nQed.",
    "Lemma neq0_mulr_lt0 x y :\n  x != 0 -> y != 0 -> (x * y < 0) = (x < 0) (+) (y < 0).\nProof. by move=> x_neq0 y_neq0; rewrite mulr_lt0 x_neq0 y_neq0. Qed.",
    "Lemma mulr_sign_lt0 (b : bool) x :\n  ((-1) ^+ b * x < 0) = (x != 0) && (b (+) (x < 0)%R).\nProof. by rewrite mulr_lt0 signr_lt0 signr_eq0. Qed.",
    "Lemma mulr_sign_norm x : (-1) ^+ (x < 0)%R * `|x| = x.\nProof. by rewrite -realEsign. Qed.",
    "Lemma mulr_Nsign_norm x : (-1) ^+ (0 < x)%R * `|x| = - x.\nProof. by rewrite real_mulr_Nsign_norm. Qed.",
    "Lemma numEsign x : x = (-1) ^+ (x < 0)%R * `|x|.\nProof. by rewrite -realEsign. Qed.",
    "Lemma numNEsign x : -x = (-1) ^+ (0 < x)%R * `|x|.\nProof. by rewrite -realNEsign. Qed.",
    "Lemma normrEsign x : `|x| = (-1) ^+ (x < 0)%R * x.\nProof. by rewrite -real_normrEsign. Qed.",
    "Lemma sgr_cp0 x :\n  ((sg x == 1) = (0 < x)) *\n  ((sg x == -1) = (x < 0)) *\n  ((sg x == 0) = (x == 0)).\nProof.\nrewrite -[1]/((-1) ^+ false) -signrN lt0r leNgt sgr_def.\ncase: (x =P 0) => [-> | _]; first by rewrite !(eq_sym 0) !signr_eq0 ltxx eqxx.\nby rewrite !(inj_eq signr_inj) eqb_id eqbF_neg signr_eq0 //.\nQed.",
    "Lemma sgrP x :\n  sgr_val x `|x| (0 == x) (x <= 0) (0 <= x) (x == 0) (x < 0) (0 < x)\n                 (0 == sg x) (-1 == sg x) (1 == sg x)\n                 (sg x == 0)  (sg x == -1) (sg x == 1) (sg x).\nProof.\nby rewrite ![_ == sg _]eq_sym !sgr_cp0 /sg; case: ltrgt0P; constructor.\nQed.",
    "Lemma normrEsg x : `|x| = sg x * x.\nProof. by case: sgrP; rewrite ?(mul0r, mul1r, mulN1r). Qed.",
    "Lemma numEsg x : x = sg x * `|x|.\nProof. by case: sgrP; rewrite !(mul1r, mul0r, mulrNN). Qed.",
    "Lemma mulr_sg_norm x : sg x * `|x| = x. Proof. by rewrite -numEsg. Qed.",
    "Lemma sgrM x y : sg (x * y) = sg x * sg y.\nProof.\nrewrite !sgr_def mulr_lt0 andbA mulrnAr mulrnAl -mulrnA mulnb -negb_or mulf_eq0.\nby case: (~~ _) => //; rewrite signr_addb.\nQed.",
    "Lemma sgrN x : sg (- x) = - sg x.\nProof. by rewrite -mulrN1 sgrM sgrN1 mulrN1. Qed.",
    "Lemma sgrX n x : sg (x ^+ n) = (sg x) ^+ n.\nProof. by elim: n => [|n IHn]; rewrite ?sgr1 // !exprS sgrM IHn. Qed.",
    "Lemma sgr_smul x y : sg (sg x * y) = sg x * sg y.\nProof. by rewrite sgrM sgr_id. Qed.",
    "Lemma sgr_gt0 x : (sg x > 0) = (x > 0).\nProof. by rewrite -[LHS]sgr_cp0 sgr_id sgr_cp0. Qed.",
    "Lemma sgr_ge0 x : (sgr x >= 0) = (x >= 0).\nProof. by rewrite !leNgt sgr_lt0. Qed.",
    "Lemma ler_norm x : (x <= `|x|).\nProof. exact: real_ler_norm. Qed.",
    "Lemma ler_norml x y : (`|x| <= y) = (- y <= x <= y).\nProof. exact: real_ler_norml. Qed.",
    "Lemma ler_normlP x y : reflect ((- x <= y) * (x <= y)) (`|x| <= y).\nProof. exact: real_ler_normlP. Qed.",
    "Lemma eqr_norml x y : (`|x| == y) = ((x == y) || (x == -y)) && (0 <= y).\nProof. exact: real_eqr_norml. Qed.",
    "Lemma eqr_norm2 x y : (`|x| == `|y|) = (x == y) || (x == -y).\nProof. exact: real_eqr_norm2. Qed.",
    "Lemma ltr_norml x y : (`|x| < y) = (- y < x < y).\nProof. exact: real_ltr_norml. Qed.",
    "Lemma ltr_normlP x y : reflect ((-x < y) * (x < y)) (`|x| < y).\nProof. exact: real_ltr_normlP. Qed.",
    "Lemma ltr_normlW x y : `|x| < y -> x < y. Proof. exact: real_ltr_normlW. Qed.",
    "Lemma ltrNnormlW x y : `|x| < y -> - y < x. Proof. exact: real_ltrNnormlW. Qed.",
    "Lemma ler_normlW x y : `|x| <= y -> x <= y. Proof. exact: real_ler_normlW. Qed.",
    "Lemma lerNnormlW x y : `|x| <= y -> - y <= x. Proof. exact: real_lerNnormlW. Qed.",
    "Lemma ler_normr x y : (x <= `|y|) = (x <= y) || (x <= - y).\nProof. exact: real_ler_normr. Qed.",
    "Lemma ltr_normr x y : (x < `|y|) = (x < y) || (x < - y).\nProof. exact: real_ltr_normr. Qed.",
    "Lemma ler_distl x y e : (`|x - y| <= e) = (y - e <= x <= y + e).\nProof. exact: real_ler_distl. Qed.",
    "Lemma ltr_distl x y e : (`|x - y| < e) = (y - e < x < y + e).\nProof. exact: real_ltr_distl. Qed.",
    "Lemma ltr_distlC x y e : (`|x - y| < e) = (x - e < y < x + e).\nProof. by rewrite distrC ltr_distl. Qed.",
    "Lemma ler_distlC x y e : (`|x - y| <= e) = (x - e <= y <= x + e).\nProof. by rewrite distrC ler_distl. Qed.",
    "Lemma ltr_distlDr x y e : `|x - y| < e -> x < y + e.\nProof. exact: real_ltr_distlDr. Qed.",
    "Lemma ler_distlDr x y e : `|x - y| <= e -> x <= y + e.\nProof. exact: real_ler_distlDr. Qed.",
    "Lemma ltr_distlCDr x y e : `|x - y| < e -> y < x + e.\nProof. exact: real_ltr_distlCDr. Qed.",
    "Lemma ler_distlCDr x y e : `|x - y| <= e -> y <= x + e.\nProof. exact: real_ler_distlCDr. Qed.",
    "Lemma ltr_distlBl x y e : `|x - y| < e -> x - e < y.\nProof. exact: real_ltr_distlBl. Qed.",
    "Lemma ler_distlBl x y e : `|x - y| <= e -> x - e <= y.\nProof. exact: real_ler_distlBl. Qed.",
    "Lemma ltr_distlCBl x y e : `|x - y| < e -> y - e < x.\nProof. exact: real_ltr_distlCBl. Qed.",
    "Lemma ler_distlCBl x y e : `|x - y| <= e -> y - e <= x.\nProof. exact: real_ler_distlCBl. Qed.",
    "Lemma exprn_even_ge0 n x : ~~ odd n -> 0 <= x ^+ n.\nProof. by move=> even_n; rewrite real_exprn_even_ge0 ?num_real. Qed.",
    "Lemma exprn_even_gt0 n x : ~~ odd n -> (0 < x ^+ n) = (n == 0)%N || (x != 0).\nProof. by move=> even_n; rewrite real_exprn_even_gt0 ?num_real. Qed.",
    "Lemma exprn_even_le0 n x : ~~ odd n -> (x ^+ n <= 0) = (n != 0) && (x == 0).\nProof. by move=> even_n; rewrite real_exprn_even_le0 ?num_real. Qed.",
    "Lemma exprn_even_lt0 n x : ~~ odd n -> (x ^+ n < 0) = false.\nProof. by move=> even_n; rewrite real_exprn_even_lt0 ?num_real. Qed.",
    "Lemma exprn_odd_ge0 n x : odd n -> (0 <= x ^+ n) = (0 <= x).\nProof. by move=> even_n; rewrite real_exprn_odd_ge0 ?num_real. Qed.",
    "Lemma exprn_odd_gt0 n x : odd n -> (0 < x ^+ n) = (0 < x).\nProof. by move=> even_n; rewrite real_exprn_odd_gt0 ?num_real. Qed.",
    "Lemma exprn_odd_le0 n x : odd n -> (x ^+ n <= 0) = (x <= 0).\nProof. by move=> even_n; rewrite real_exprn_odd_le0 ?num_real. Qed.",
    "Lemma exprn_odd_lt0 n x : odd n -> (x ^+ n < 0) = (x < 0).\nProof. by move=> even_n; rewrite real_exprn_odd_lt0 ?num_real. Qed.",
    "Lemma lteif_norml C x y :\n  (`|x| < y ?<= if C) = (- y < x ?<= if C) && (x < y ?<= if C).\nProof. by case: C; rewrite /= lter_norml. Qed.",
    "Lemma lteif_normr C x y :\n  (x < `|y| ?<= if C) = (x < y ?<= if C) || (x < - y ?<= if C).\nProof. by case: C; rewrite /= lter_normr. Qed.",
    "Lemma lteif_distl C x y e :\n  (`|x - y| < e ?<= if C) = (y - e < x ?<= if C) && (x < y + e ?<= if C).\nProof. by case: C; rewrite /= lter_distl. Qed.",
    "Lemma sqr_ge0 x : 0 <= x ^+ 2. Proof. by rewrite exprn_even_ge0. Qed.",
    "Lemma sqr_norm_eq1 x : (x ^+ 2 == 1) = (`|x| == 1).\nProof. by rewrite sqrf_eq1 eqr_norml ler01 andbT. Qed.",
    "Lemma leif_mean_square_scaled x y :\n  x * y *+ 2 <= x ^+ 2 + y ^+ 2 ?= iff (x == y).\nProof. exact: real_leif_mean_square_scaled. Qed.",
    "Lemma leif_AGM2_scaled x y : x * y *+ 4 <= (x + y) ^+ 2 ?= iff (x == y).\nProof. exact: real_leif_AGM2_scaled. Qed.",
    "Lemma oppr_max : {morph -%R : x y / max x y >-> min x y : R}.\nProof. by move=> x y; apply: real_oppr_max. Qed.",
    "Lemma oppr_min : {morph -%R : x y / min x y >-> max x y : R}.\nProof. by move=> x y; apply: real_oppr_min. Qed.",
    "Lemma addr_minl : @left_distributive R R +%R min.\nProof. by move=> x y z; apply: real_addr_minl. Qed.",
    "Lemma addr_minr : @right_distributive R R +%R min.\nProof. by move=> x y z; apply: real_addr_minr. Qed.",
    "Lemma addr_maxl : @left_distributive R R +%R max.\nProof. by move=> x y z; apply: real_addr_maxl. Qed.",
    "Lemma addr_maxr : @right_distributive R R +%R max.\nProof. by move=> x y z; apply: real_addr_maxr. Qed.",
    "Lemma minr_nMr x y z : x <= 0 -> x * min y z = max (x * y) (x * z).\nProof. by move=> x_le0; apply: real_minr_nMr. Qed.",
    "Lemma maxr_nMr x y z : x <= 0 -> x * max y z = min (x * y) (x * z).\nProof. by move=> x_le0; apply: real_maxr_nMr. Qed.",
    "Lemma minr_nMl x y z : x <= 0 -> min y z * x = max (y * x) (z * x).\nProof. by move=> x_le0; apply: real_minr_nMl. Qed.",
    "Lemma maxr_nMl x y z : x <= 0 -> max y z * x = min (y * x) (z * x).\nProof. by move=> x_le0; apply: real_maxr_nMl. Qed.",
    "Lemma maxrN x : max x (- x) = `|x|.   Proof. exact: real_maxrN. Qed.",
    "Lemma maxNr x : max (- x) x = `|x|.   Proof. exact: real_maxNr. Qed.",
    "Lemma minrN x : min x (- x) = - `|x|. Proof. exact: real_minrN. Qed.",
    "Lemma minNr x : min (- x) x = - `|x|. Proof. exact: real_minNr. Qed.",
    "Lemma poly_itv_bound a b : {ub | forall x, a <= x <= b -> `|p.[x]| <= ub}.\nProof.\nhave [ub le_p_ub] := poly_disk_bound p (Num.max `|a| `|b|).\nexists ub => x /andP[le_a_x le_x_b]; rewrite le_p_ub // le_max !ler_normr.\nby have [_|_] := ler0P x; rewrite ?lerN2 ?le_a_x ?le_x_b orbT.\nQed.",
    "Lemma monic_Cauchy_bound : p \\is monic -> {b | forall x, x >= b -> p.[x] > 0}.\nProof.\nmove/monicP=> mon_p; pose n := (size p - 2)%N.\nhave [p_le1 | p_gt1] := leqP (size p) 1.\n  exists 0 => x _; rewrite (size1_polyC p_le1) hornerC.\n  by rewrite -[p`_0]lead_coefC -size1_polyC // mon_p ltr01.\npose lb := \\sum_(j < n.+1) `|p`_j|; exists (lb + 1) => x le_ub_x.\nhave x_ge1: 1 <= x; last have x_gt0 := lt_le_trans ltr01 x_ge1.\n  by rewrite -(lerD2l lb) ler_wpDl ?sumr_ge0 // => j _.\nrewrite horner_coef -(subnK p_gt1) -/n addnS big_ord_recr /= addn1.\nrewrite [in p`__]subnSK // subn1 -lead_coefE mon_p mul1r -ltrBlDl sub0r.\napply: le_lt_trans (_ : lb * x ^+ n < _); last first.\n  by rewrite exprS ltr_pM2r ?exprn_gt0// -(ltrD2r 1) ltr_pwDr.\nrewrite -sumrN mulr_suml ler_sum // => j _; apply: le_trans (ler_norm _) _.\nrewrite normrN normrM ler_wpM2l // normrX.\nby rewrite ger0_norm ?(ltW x_gt0) // ler_weXn2l ?leq_ord.\nQed.",
    "Lemma leif_mean_square : x * y <= (x ^+ 2 + y ^+ 2) / 2 ?= iff (x == y).\nProof. by apply: real_leif_mean_square; apply: num_real. Qed.",
    "Lemma leif_AGM2 : x * y <= ((x + y) / 2)^+ 2 ?= iff (x == y).\nProof. by apply: real_leif_AGM2; apply: num_real. Qed.",
    "Lemma poly_ivt : real_closed_axiom R. Proof. exact: poly_ivt. Qed.",
    "Lemma sqrtr_ge0 a : 0 <= sqrt a.\nProof. by rewrite /sqrt; case: (sig2W _). Qed.",
    "Lemma sqr_sqrtr a : 0 <= a -> sqrt a ^+ 2 = a.\nProof.\nby rewrite /sqrt => a_ge0; case: (sig2W _) => /= x _; rewrite a_ge0 => /eqP.\nQed.",
    "Lemma ler0_sqrtr a : a <= 0 -> sqrt a = 0.\nProof.\nrewrite /sqrtr; case: (sig2W _) => x /= _.\nby have [//|_ /eqP//|->] := ltrgt0P a; rewrite mulf_eq0 orbb => /eqP.\nQed.",
    "Lemma ltr0_sqrtr a : a < 0 -> sqrt a = 0.\nProof. by move=> /ltW; apply: ler0_sqrtr. Qed.",
    "Lemma sqrtrP a : sqrtr_spec a a (0 <= a) (a < 0) (sqrt a).\nProof.\nhave [a_ge0|a_lt0] := ger0P a.\n  by rewrite -{1 2}[a]sqr_sqrtr //; constructor.\nby rewrite ltr0_sqrtr //; constructor.\nQed.",
    "Lemma sqrtr_sqr a : sqrt (a ^+ 2) = `|a|.\nProof.\nhave /eqP : sqrt (a ^+ 2) ^+ 2 = `|a| ^+ 2.\n  by rewrite -normrX ger0_norm ?sqr_sqrtr ?sqr_ge0.\nrewrite eqf_sqr => /predU1P[-> //|ha].\nhave := sqrtr_ge0 (a ^+ 2); rewrite (eqP ha) oppr_ge0 normr_le0 => /eqP ->.\nby rewrite normr0 oppr0.\nQed.",
    "Lemma sqrtrM a b : 0 <= a -> sqrt (a * b) = sqrt a * sqrt b.\nProof.\ncase: (sqrtrP a) => // {}a a_ge0 _; case: (sqrtrP b) => [b_lt0 | {}b b_ge0].\n  by rewrite mulr0 ler0_sqrtr // nmulr_lle0 ?mulr_ge0.\nby rewrite mulrACA sqrtr_sqr ger0_norm ?mulr_ge0.\nQed.",
    "Lemma sqrtr0 : sqrt 0 = 0 :> R.\nProof. by move: (sqrtr_sqr 0); rewrite exprS mul0r => ->; rewrite normr0. Qed.",
    "Lemma sqrtr1 : sqrt 1 = 1 :> R.\nProof. by move: (sqrtr_sqr 1); rewrite expr1n => ->; rewrite normr1. Qed.",
    "Lemma sqrtr_eq0 a : (sqrt a == 0) = (a <= 0).\nProof.\ncase: sqrtrP => [/ltW ->|b]; first by rewrite eqxx.\ncase: ltrgt0P => [b_gt0|//|->]; last by rewrite exprS mul0r lexx.\nby rewrite lt_geF ?pmulr_rgt0.\nQed.",
    "Lemma sqrtr_gt0 a : (0 < sqrt a) = (0 < a).\nProof. by rewrite lt0r sqrtr_ge0 sqrtr_eq0 -ltNge andbT. Qed.",
    "Lemma eqr_sqrt a b : 0 <= a -> 0 <= b -> (sqrt a == sqrt b) = (a == b).\nProof.\nmove=> a_ge0 b_ge0; apply/eqP/eqP=> [HS|->] //.\nby move: (sqr_sqrtr a_ge0); rewrite HS (sqr_sqrtr b_ge0).\nQed.",
    "Lemma ler_wsqrtr : {homo @sqrt R : a b / a <= b}.\nProof.\nmove=> a b /= le_ab; case: (boolP (0 <= a))=> [pa|]; last first.\n  by rewrite -ltNge; move/ltW; rewrite -sqrtr_eq0; move/eqP->.\nrewrite -(@ler_pXn2r R 2) ?nnegrE ?sqrtr_ge0 //.\nby rewrite !sqr_sqrtr // (le_trans pa).\nQed.",
    "Lemma ler_psqrt : {in @nneg R &, {mono sqrt : a b / a <= b}}.\nProof.\napply: le_mono_in => x y x_gt0 y_gt0.\nrewrite !lt_neqAle => /andP[neq_xy le_xy].\nby rewrite ler_wsqrtr // eqr_sqrt // neq_xy.\nQed.",
    "Lemma ler_sqrt a b : 0 <= b -> (sqrt a <= sqrt b) = (a <= b).\nProof.\nmove=> b_ge0; have [a_le0|a_gt0] := ler0P a; last first.\n  by rewrite ler_psqrt // nnegrE ltW.\nby rewrite ler0_sqrtr // sqrtr_ge0 (le_trans a_le0).\nQed.",
    "Lemma ltr_sqrt a b : 0 < b -> (sqrt a < sqrt b) = (a < b).\nProof.\nmove=> b_gt0; have [a_le0|a_gt0] := ler0P a; last first.\n  by rewrite (leW_mono_in ler_psqrt)//; apply: ltW.\nby rewrite ler0_sqrtr // sqrtr_gt0 b_gt0 (le_lt_trans a_le0).\nQed.",
    "Lemma sqrtrV x : 0 <= x -> sqrt (x^-1) = (sqrt x)^-1.\nProof.\ncase: ltrgt0P => // [x_gt0 _|->]; last by rewrite !(invr0, sqrtr0).\nhave sx_neq0 : sqrt x != 0 by rewrite sqrtr_eq0 -ltNge.\napply: (mulfI sx_neq0).\nby rewrite -sqrtrM !(divff, ltW, sqrtr1) // lt0r_neq0.\nQed.",
    "Lemma mulCii : 'i * 'i = -1 :> C. Proof. exact: sqrCi. Qed.",
    "Lemma conjCK : involutive (@conj_op C).\nProof.\nhave JE x : x^* = `|x|^+2 / x.\n  have [->|x_neq0] := eqVneq x 0; first by rewrite rmorph0 invr0 mulr0.\n  by apply: (canRL (mulfK _)) => //; rewrite mulrC -normCK.\nmove=> x; have [->|x_neq0] := eqVneq x 0; first by rewrite !rmorph0.\nrewrite !JE normrM normfV exprMn normrX normr_id.\nrewrite invfM exprVn (AC (2*2) (1*(2*3)*4))/= -invfM -exprMn.\nby rewrite divff ?mul1r ?invrK // !expf_eq0 normr_eq0 //.\nQed.",
    "Lemma ReE z : 'Re z = (z + z^*) / 2%:R. Proof. by rewrite ['Re _]unlock. Qed.",
    "Lemma ImE z : 'Im z = 'i * (z^* - z) / 2%:R.\nProof. by rewrite ['Im _]unlock. Qed.",
    "Lemma normCKC x : `|x| ^+ 2 = x^* * x. Proof. by rewrite normCK mulrC. Qed.",
    "Lemma mul_conjC_ge0 x : 0 <= x * x^*.\nProof. by rewrite -normCK exprn_ge0. Qed.",
    "Lemma mul_conjC_gt0 x : (0 < x * x^* ) = (x != 0).\nProof.\nhave [->|x_neq0] := eqVneq; first by rewrite rmorph0 mulr0.\nby rewrite -normCK exprn_gt0 ?normr_gt0.\nQed.",
    "Lemma mul_conjC_eq0 x : (x * x^* == 0) = (x == 0).\nProof. by rewrite -normCK expf_eq0 normr_eq0. Qed.",
    "Lemma conjC_ge0 x : (0 <= x^* ) = (0 <= x).\nProof.\nwlog suffices: x / 0 <= x -> 0 <= x^*.\n  by move=> IH; apply/idP/idP=> /IH; rewrite ?conjCK.\nrewrite [in X in X -> _]le0r => /predU1P[-> | x_gt0]; first by rewrite rmorph0.\nby rewrite -(pmulr_rge0 _ x_gt0) mul_conjC_ge0.\nQed.",
    "Lemma conjC_nat n : (n%:R)^* = n%:R :> C. Proof. exact: rmorph_nat. Qed.",
    "Lemma conjC0 : 0^* = 0 :> C. Proof. exact: rmorph0. Qed.",
    "Lemma conjC1 : 1^* = 1 :> C. Proof. exact: rmorph1. Qed.",
    "Lemma conjCN1 : (- 1)^* = - 1 :> C. Proof. exact: rmorphN1. Qed.",
    "Lemma conjC_eq0 x : (x^* == 0) = (x == 0). Proof. exact: fmorph_eq0. Qed.",
    "Lemma invC_norm x : x^-1 = `|x| ^- 2 * x^*.\nProof.\nhave [-> | nx_x] := eqVneq x 0; first by rewrite conjC0 mulr0 invr0.\nby rewrite normCK invfM divfK ?conjC_eq0.\nQed.",
    "Lemma CrealE x : (x \\is real) = (x^* == x).\nProof.\nrewrite realEsqr ger0_def normrX normCK.\nby have [-> | /mulfI/inj_eq-> //] := eqVneq x 0; rewrite rmorph0 !eqxx.\nQed.",
    "Lemma CrealP {x} : reflect (x^* = x) (x \\is real).\nProof. by rewrite CrealE; apply: eqP. Qed.",
    "Lemma conj_Creal x : x \\is real -> x^* = x.\nProof. by move/CrealP. Qed.",
    "Lemma conj_normC z : `|z|^* = `|z|.\nProof. by rewrite conj_Creal ?normr_real. Qed.",
    "Lemma CrealJ : {mono (@conj_op C) : x / x \\is Num.real}.\nProof. by apply: (homo_mono1 conjCK) => x xreal; rewrite conj_Creal. Qed.",
    "Lemma geC0_conj x : 0 <= x -> x^* = x.\nProof. by move=> /ger0_real/CrealP. Qed.",
    "Lemma geC0_unit_exp x n : 0 <= x -> (x ^+ n.+1 == 1) = (x == 1).\nProof. by move=> x_ge0; rewrite pexpr_eq1. Qed.",
    "Lemma root0C x : 0.-root x = 0. Proof. by case_rootC. Qed.",
    "Lemma rootCK n : (n > 0)%N -> cancel n.-root (fun x => x ^+ n).\nProof. by case: n => //= n _ x; case_rootC. Qed.",
    "Lemma root1C x : 1.-root x = x. Proof. exact: (@rootCK 1). Qed.",
    "Lemma rootC0 n : n.-root 0 = 0.\nProof.\nhave [-> | n_gt0] := posnP n; first by rewrite root0C.\nby have /eqP := rootCK n_gt0 0; rewrite expf_eq0 n_gt0 /= => /eqP.\nQed.",
    "Lemma rootC_inj n : (n > 0)%N -> injective n.-root.\nProof. by move/rootCK/can_inj. Qed.",
    "Lemma eqr_rootC n : (n > 0)%N -> {mono n.-root : x y / x == y}.\nProof. by move/rootC_inj/inj_eq. Qed.",
    "Lemma rootC_eq0 n x : (n > 0)%N -> (n.-root x == 0) = (x == 0).\nProof. by move=> n_gt0; rewrite -{1}(rootC0 n) eqr_rootC. Qed.",
    "Lemma nonRealCi : ('i : C) \\isn't real.\nProof. by rewrite realEsqr sqrCi oppr_ge0 lt_geF ?ltr01. Qed.",
    "Lemma neq0Ci : 'i != 0 :> C. Proof. by apply: contraNneq nonRealCi => ->. Qed.",
    "Lemma normCi : `|'i| = 1 :> C.\nProof. by apply/eqP; rewrite -(@pexpr_eq1 _ _ 2) // -normrX sqrCi normrN1. Qed.",
    "Lemma invCi : 'i^-1 = - 'i :> C.\nProof. by rewrite -div1r -[1]opprK -sqrCi mulNr mulfK ?neq0Ci. Qed.",
    "Lemma conjCi : 'i^* = - 'i :> C.\nProof. by rewrite -invCi invC_norm normCi expr1n invr1 mul1r. Qed.",
    "Lemma Crect x : x = 'Re x + 'i * 'Im x.\nProof.\nrewrite !(ReE, ImE) 2!mulrA mulCii mulN1r opprB -mulrDl.\nby rewrite addrACA subrr addr0 mulrDl -splitr.\nQed.",
    "Lemma eqCP x y : x = y <-> ('Re x = 'Re y) /\\ ('Im x = 'Im y).\nProof. by split=> [->//|[eqRe eqIm]]; rewrite [x]Crect [y]Crect eqRe eqIm. Qed.",
    "Lemma eqC x y : (x == y) = ('Re x == 'Re y) && ('Im x == 'Im y).\nProof. by apply/eqP/(andPP eqP eqP) => /eqCP. Qed.",
    "Lemma Creal_Re x : 'Re x \\is real.\nProof. by rewrite ReE CrealE fmorph_div rmorph_nat rmorphD /= conjCK addrC. Qed.",
    "Lemma Creal_Im x : 'Im x \\is real.\nProof.\nrewrite ImE CrealE fmorph_div rmorph_nat rmorphM /= rmorphB conjCK.\nby rewrite conjCi -opprB mulrNN.\nQed.",
    "Lemma Creal_ImP z : reflect ('Im z = 0) (z \\is real).\nProof.\nrewrite ImE CrealE -subr_eq0 -(can_eq (mulKf neq0Ci)) mulr0.\nby rewrite -(can_eq (divfK nz2)) mul0r; apply: eqP.\nQed.",
    "Lemma Creal_ReP z : reflect ('Re z = z) (z \\in real).\nProof.\nrewrite (sameP (Creal_ImP z) eqP) -(can_eq (mulKf neq0Ci)) mulr0.\nby rewrite -(inj_eq (addrI ('Re z))) addr0 -Crect eq_sym; apply: eqP.\nQed.",
    "Lemma ReMl : {in real, forall x, {morph Re : z / x * z}}.\nProof.\nby move=> x Rx z /=; rewrite !ReE rmorphM /= (conj_Creal Rx) -mulrDr -mulrA.\nQed.",
    "Lemma ReMr : {in real, forall x, {morph Re : z / z * x}}.\nProof. by move=> x Rx z /=; rewrite mulrC ReMl // mulrC. Qed.",
    "Lemma ImMl : {in real, forall x, {morph Im : z / x * z}}.\nProof.\nby move=> x Rx z; rewrite !ImE rmorphM /= (conj_Creal Rx) -mulrBr mulrCA !mulrA.\nQed.",
    "Lemma ImMr : {in real, forall x, {morph Im : z / z * x}}.\nProof. by move=> x Rx z /=; rewrite mulrC ImMl // mulrC. Qed.",
    "Lemma Re_i : 'Re 'i = 0. Proof. by rewrite ReE conjCi subrr mul0r. Qed.",
    "Lemma Im_i : 'Im 'i = 1.\nProof.\nrewrite ImE conjCi -opprD mulrN -mulr2n mulrnAr mulCii.\nby rewrite mulNrn opprK divff.\nQed.",
    "Lemma Re_conj z : 'Re z^* = 'Re z.\nProof. by rewrite !ReE addrC conjCK. Qed.",
    "Lemma Im_conj z : 'Im z^* = - 'Im z.\nProof. by rewrite !ImE -mulNr -mulrN opprB conjCK. Qed.",
    "Lemma Re_rect : {in real &, forall x y, 'Re (x + 'i * y) = x}.\nProof.\nmove=> x y Rx Ry; rewrite /= raddfD /= (Creal_ReP x Rx).\nby rewrite ReMr // Re_i mul0r addr0.\nQed.",
    "Lemma Im_rect : {in real &, forall x y, 'Im (x + 'i * y) = y}.\nProof.\nmove=> x y Rx Ry; rewrite /= raddfD /= (Creal_ImP x Rx) add0r.\nby rewrite ImMr // Im_i mul1r.\nQed.",
    "Lemma conjC_rect : {in real &, forall x y, (x + 'i * y)^* = x - 'i * y}.\nProof.\nby move=> x y Rx Ry; rewrite /= rmorphD rmorphM /= conjCi mulNr !conj_Creal.\nQed.",
    "Lemma addC_rect x1 y1 x2 y2 :\n  (x1 + 'i * y1) + (x2 + 'i * y2) = x1 + x2 + 'i * (y1 + y2).\nProof. by rewrite addrACA -mulrDr. Qed.",
    "Lemma oppC_rect x y : - (x + 'i * y)  = - x + 'i * (- y).\nProof. by rewrite mulrN -opprD. Qed.",
    "Lemma subC_rect x1 y1 x2 y2 :\n  (x1 + 'i * y1) - (x2 + 'i * y2) = x1 - x2 + 'i * (y1 - y2).\nProof. by rewrite oppC_rect addC_rect. Qed.",
    "Lemma mulC_rect x1 y1 x2 y2 : (x1 + 'i * y1) * (x2 + 'i * y2) =\n                              x1 * x2 - y1 * y2 + 'i * (x1 * y2 + x2 * y1).\nProof.\nrewrite mulrDl !mulrDr (AC (2*2) (1*4*(2*3)))/= mulrACA.\nby rewrite -expr2 sqrCi mulN1r -!mulrA [_ * ('i * _)]mulrCA [_ * y1]mulrC.\nQed.",
    "Lemma ImM x y : 'Im (x * y) = 'Re x * 'Im y + 'Re y * 'Im x.\nProof.\nrewrite [x in LHS]Crect [y in LHS]Crect mulC_rect.\nby rewrite !(Im_rect, rpredB, rpredD, rpredM).\nQed.",
    "Lemma ImMil x : 'Im ('i * x) = 'Re x.\nProof. by rewrite ImM Re_i Im_i mul0r mulr1 add0r. Qed.",
    "Lemma ReMil x : 'Re ('i * x) = - 'Im x.\nProof. by rewrite -ImMil mulrA mulCii mulN1r raddfN. Qed.",
    "Lemma ReMir x : 'Re (x * 'i) = - 'Im x. Proof. by rewrite mulrC ReMil. Qed.",
    "Lemma ImMir x : 'Im (x * 'i) = 'Re x. Proof. by rewrite mulrC ImMil. Qed.",
    "Lemma ReM x y : 'Re (x * y) = 'Re x * 'Re y - 'Im x * 'Im y.\nProof. by rewrite -ImMil mulrCA ImM ImMil ReMil mulNr ['Im _ * _]mulrC. Qed.",
    "Lemma normC2_rect :\n  {in real &, forall x y, `|x + 'i * y| ^+ 2 = x ^+ 2 + y ^+ 2}.\nProof.\nmove=> x y Rx Ry; rewrite /= normCK rmorphD rmorphM /= conjCi !conj_Creal //.\nby rewrite mulrC mulNr -subr_sqr exprMn sqrCi mulN1r opprK.\nQed.",
    "Lemma normC2_Re_Im z : `|z| ^+ 2 = 'Re z ^+ 2 + 'Im z ^+ 2.\nProof. by rewrite -normC2_rect -?Crect. Qed.",
    "Lemma invC_Crect x y : (x + 'i * y)^-1  = (x^* - 'i * y^*) / `|x + 'i * y| ^+ 2.\nProof. by rewrite /= invC_norm mulrC !rmorphE rmorphM /= conjCi mulNr. Qed.",
    "Lemma invC_rect :\n  {in real &, forall x y, (x + 'i * y)^-1  = (x - 'i * y) / (x ^+ 2 + y ^+ 2)}.\nProof. by move=> x y Rx Ry; rewrite invC_Crect normC2_rect ?conj_Creal. Qed.",
    "Lemma ImV x : 'Im x^-1 = - 'Im x / `|x| ^+ 2.\nProof.\nrewrite [x in LHS]Crect invC_rect// ImMr ?(rpredV, rpredD, rpredX)//.\nby rewrite -mulrN Im_rect ?rpredN// -normC2_rect// -Crect.\nQed.",
    "Lemma ReV x : 'Re x^-1 = 'Re x / `|x| ^+ 2.\nProof.\nrewrite [x in LHS]Crect invC_rect// ReMr ?(rpredV, rpredD, rpredX)//.\nby rewrite -mulrN Re_rect ?rpredN// -normC2_rect// -Crect.\nQed.",
    "Lemma rectC_mulr x y z : (x + 'i * y) * z = x * z + 'i * (y * z).\nProof. by rewrite mulrDl mulrA. Qed.",
    "Lemma rectC_mull x y z : z * (x + 'i * y) = z * x + 'i * (z * y).\nProof. by rewrite mulrDr mulrCA. Qed.",
    "Lemma divC_Crect x1 y1 x2 y2 :\n  (x1 + 'i * y1) / (x2 + 'i * y2) =\n  (x1 * x2^* + y1 * y2^* + 'i * (x2^* * y1 - x1 * y2^*)) /\n    `|x2 + 'i * y2| ^+ 2.\nProof.\nrewrite invC_Crect// -mulrN [_ / _]rectC_mulr mulC_rect !mulrA -mulrBl.\nrewrite [_ * _ * y1]mulrAC -mulrDl mulrA -mulrDl !(mulrN, mulNr) opprK.\nby rewrite [- _ + _]addrC.\nQed.",
    "Lemma divC_rect x1 y1 x2 y2 :\n     x1 \\is real -> y1 \\is real -> x2 \\is real -> y2 \\is real ->\n  (x1 + 'i * y1) / (x2 + 'i * y2) =\n  (x1 * x2 + y1 * y2 + 'i * (x2 * y1 - x1 * y2)) /\n    (x2 ^+ 2 + y2 ^+ 2).\nProof. by move=> *; rewrite divC_Crect normC2_rect ?conj_Creal. Qed.",
    "Lemma Im_div x y : 'Im (x / y) = ('Re y * 'Im x - 'Re x * 'Im y) / `|y| ^+ 2.\nProof. by rewrite ImM ImV ReV mulrA [X in _ + X]mulrAC -mulrDl mulrN addrC. Qed.",
    "Lemma Re_div x y : 'Re (x / y) = ('Re x * 'Re y + 'Im x * 'Im y) / `|y| ^+ 2.\nProof. by rewrite ReM ImV ReV !mulrA -mulrBl mulrN opprK. Qed.",
    "Lemma leif_normC_Re_Creal z : `|'Re z| <= `|z| ?= iff (z \\is real).\nProof.\nrewrite -(mono_in_leif ler_sqr); try by rewrite qualifE /=.\nrewrite [`|'Re _| ^+ 2]normCK conj_Creal // normC2_Re_Im -expr2.\nrewrite addrC -leifBLR subrr (sameP (Creal_ImP _) eqP) -sqrf_eq0 eq_sym.\nby apply: leif_eq; rewrite -realEsqr.\nQed.",
    "Lemma leif_Re_Creal z : 'Re z <= `|z| ?= iff (0 <= z).\nProof.\nhave ubRe: 'Re z <= `|'Re z| ?= iff (0 <= 'Re z).\n  by rewrite ger0_def eq_sym; apply/leif_eq/real_ler_norm.\ncongr (_ <= _ ?= iff _): (leif_trans ubRe (leif_normC_Re_Creal z)).\napply/andP/idP=> [[zRge0 /Creal_ReP <- //] | z_ge0].\nby have Rz := ger0_real z_ge0; rewrite (Creal_ReP _ _).\nQed.",
    "Lemma eqC_semipolar x y :\n  `|x| = `|y| -> 'Re x = 'Re y -> 0 <= 'Im x * 'Im y -> x = y.\nProof.\nmove=> eq_norm eq_Re sign_Im.\nrewrite [x]Crect [y]Crect eq_Re; congr (_ + 'i * _).\nhave /eqP := congr1 (fun z => z ^+ 2) eq_norm.\nrewrite !normC2_Re_Im eq_Re (can_eq (addKr _)) eqf_sqr => /pred2P[] // eq_Im.\nrewrite eq_Im mulNr -expr2 oppr_ge0 real_exprn_even_le0 //= in sign_Im.\nby rewrite eq_Im (eqP sign_Im) oppr0.\nQed.",
    "Lemma rootC_Re_max n x y :\n  (n > 0)%N -> y ^+ n = x -> 0 <= 'Im y -> 'Re y <= 'Re (n.-root x).\nProof.\nby move=> n_gt0 yn_x leI0y; case_rootC=> z /= _ /(_ y n_gt0 yn_x)/argCleP[].\nQed.",
    "Lemma Im_rootC_ge0 n x : (n > 1)%N -> 0 <= 'Im (n.-root x).\nProof.\nset y := n.-root x => n_gt1; have n_gt0 := ltnW n_gt1.\napply: wlog_neg; rewrite -real_ltNge ?rpred0 // => ltIy0.\nsuffices [z zn_x leI0z]: exists2 z, z ^+ n = x & 'Im z >= 0.\n  by rewrite /y; case_rootC => /= y1 _ /(_ z n_gt0 zn_x)/argCleP[].\nhave [w wn1 ltRw0] := neg_unity_root n_gt1.\nwlog leRI0yw: w wn1 ltRw0 / 0 <= 'Re y * 'Im w.\n  move=> IHw; have: 'Re y * 'Im w \\is real by rewrite rpredM.\n  case/real_ge0P=> [|/ltW leRIyw0]; first exact: IHw.\n  apply: (IHw w^* ); rewrite ?Re_conj ?Im_conj ?mulrN ?oppr_ge0 //.\n  by rewrite -rmorphXn wn1 rmorph1.\nexists (w * y); first by rewrite exprMn wn1 mul1r rootCK.\nrewrite [w]Crect [y]Crect mulC_rect.\nby rewrite Im_rect ?rpredD ?rpredN 1?rpredM // addr_ge0 // ltW ?nmulr_rgt0.\nQed.",
    "Lemma rootC_lt0 n x : (1 < n)%N -> (n.-root x < 0) = false.\nProof.\nset y := n.-root x => n_gt1; have n_gt0 := ltnW n_gt1.\napply: negbTE; apply: wlog_neg => /negbNE lt0y; rewrite le_gtF //.\nhave Rx: x \\is real by rewrite -[x](rootCK n_gt0) rpredX // ltr0_real.\nhave Re_y: 'Re y = y by apply/Creal_ReP; rewrite ltr0_real.\nhave [z zn_x leR0z]: exists2 z, z ^+ n = x & 'Re z >= 0.\n  have [w wn1 ltRw0] := neg_unity_root n_gt1.\n  exists (w * y); first by rewrite exprMn wn1 mul1r rootCK.\n  by rewrite ReMr ?ltr0_real // ltW // nmulr_lgt0.\nwithout loss leI0z: z zn_x leR0z / 'Im z >= 0.\n  move=> IHz; have: 'Im z \\is real by [].\n  case/real_ge0P=> [|/ltW leIz0]; first exact: IHz.\n  apply: (IHz z^* ); rewrite ?Re_conj ?Im_conj ?oppr_ge0 //.\n  by rewrite -rmorphXn /= zn_x conj_Creal.\nby apply: le_trans leR0z _; rewrite -Re_y ?rootC_Re_max ?ltr0_real.\nQed.",
    "Lemma rootC_ge0 n x : (n > 0)%N -> (0 <= n.-root x) = (0 <= x).\nProof.\nset y := n.-root x => n_gt0.\napply/idP/idP=> [/(exprn_ge0 n) | x_ge0]; first by rewrite rootCK.\nrewrite -(ge_leif (leif_Re_Creal y)).\nhave Ray: `|y| \\is real by apply: normr_real.\nrewrite -(Creal_ReP _ Ray) rootC_Re_max ?(Creal_ImP _ Ray) //.\nby rewrite -normrX rootCK // ger0_norm.\nQed.",
    "Lemma rootC_gt0 n x : (n > 0)%N -> (n.-root x > 0) = (x > 0).\nProof. by move=> n_gt0; rewrite !lt0r rootC_ge0 ?rootC_eq0. Qed.",
    "Lemma rootC_le0 n x : (1 < n)%N -> (n.-root x <= 0) = (x == 0).\nProof.\nby move=> n_gt1; rewrite le_eqVlt rootC_lt0 // orbF rootC_eq0 1?ltnW.\nQed.",
    "Lemma ler_rootCl n : (n > 0)%N -> {in Num.nneg, {mono n.-root : x y / x <= y}}.\nProof.\nmove=> n_gt0 x x_ge0 y; have [y_ge0 | not_y_ge0] := boolP (0 <= y).\n  by rewrite -(ler_pXn2r n_gt0) ?qualifE /= ?rootC_ge0 ?rootCK.\nrewrite (contraNF (@le_trans _ _ _ 0 _ _)) ?rootC_ge0 //.\nby rewrite (contraNF (le_trans x_ge0)).\nQed.",
    "Lemma ler_rootC n : (n > 0)%N -> {in Num.nneg &, {mono n.-root : x y / x <= y}}.\nProof. by move=> n_gt0 x y x_ge0 _; apply: ler_rootCl. Qed.",
    "Lemma ltr_rootCl n : (n > 0)%N -> {in Num.nneg, {mono n.-root : x y / x < y}}.\nProof. by move=> n_gt0 x x_ge0 y; rewrite !lt_def ler_rootCl ?eqr_rootC. Qed.",
    "Lemma ltr_rootC n : (n > 0)%N -> {in Num.nneg &, {mono n.-root : x y / x < y}}.\nProof. by move/ler_rootC/leW_mono_in. Qed.",
    "Lemma exprCK n x : (0 < n)%N -> 0 <= x -> n.-root (x ^+ n) = x.\nProof.\nmove=> n_gt0 x_ge0; apply/eqP.\nby rewrite -(eqrXn2 n_gt0) ?rootC_ge0 ?exprn_ge0 ?rootCK.\nQed.",
    "Lemma norm_rootC n x : `|n.-root x| = n.-root `|x|.\nProof.\nhave [-> | n_gt0] := posnP n; first by rewrite !root0C normr0.\nby apply/eqP; rewrite -(eqrXn2 n_gt0) ?rootC_ge0 // -normrX !rootCK.\nQed.",
    "Lemma rootCX n x k : (n > 0)%N -> 0 <= x -> n.-root (x ^+ k) = n.-root x ^+ k.\nProof.\nmove=> n_gt0 x_ge0; apply/eqP.\nby rewrite -(eqrXn2 n_gt0) ?(exprn_ge0, rootC_ge0) // 1?exprAC !rootCK.\nQed.",
    "Lemma rootC1 n : (n > 0)%N -> n.-root 1 = 1.\nProof. by move/(rootCX 0)/(_ ler01). Qed.",
    "Lemma rootCpX n x k : (k > 0)%N -> 0 <= x -> n.-root (x ^+ k) = n.-root x ^+ k.\nProof.\nby case: n => [|n] k_gt0; [rewrite !root0C expr0n gtn_eqF | apply: rootCX].\nQed.",
    "Lemma rootCV n x : 0 <= x -> n.-root x^-1 = (n.-root x)^-1.\nProof.\nmove=> x_ge0; have [->|n_gt0] := posnP n; first by rewrite !root0C invr0.\napply/eqP.\nby rewrite -(eqrXn2 n_gt0) ?(invr_ge0, rootC_ge0) // !exprVn !rootCK.\nQed.",
    "Lemma rootC_eq1 n x : (n > 0)%N -> (n.-root x == 1) = (x == 1).\nProof. by move=> n_gt0; rewrite -{1}(rootC1 n_gt0) eqr_rootC. Qed.",
    "Lemma rootC_ge1 n x : (n > 0)%N -> (n.-root x >= 1) = (x >= 1).\nProof.\nby move=> n_gt0; rewrite -{1}(rootC1 n_gt0) ler_rootCl // qualifE /= ler01.\nQed.",
    "Lemma rootC_gt1 n x : (n > 0)%N -> (n.-root x > 1) = (x > 1).\nProof. by move=> n_gt0; rewrite !lt_def rootC_eq1 ?rootC_ge1. Qed.",
    "Lemma rootC_le1 n x : (n > 0)%N -> 0 <= x -> (n.-root x <= 1) = (x <= 1).\nProof. by move=> n_gt0 x_ge0; rewrite -{1}(rootC1 n_gt0) ler_rootCl. Qed.",
    "Lemma rootC_lt1 n x : (n > 0)%N -> 0 <= x -> (n.-root x < 1) = (x < 1).\nProof. by move=> n_gt0 x_ge0; rewrite !lt_neqAle rootC_eq1 ?rootC_le1. Qed.",
    "Lemma rootCMl n x z : 0 <= x -> n.-root (x * z) = n.-root x * n.-root z.\nProof.\nrewrite le0r => /predU1P[-> | x_gt0]; first by rewrite !(mul0r, rootC0).\nhave [| n_gt1 | ->] := ltngtP n 1; last by rewrite !root1C.\n  by case: n => //; rewrite !root0C mul0r.\nhave [x_ge0 n_gt0] := (ltW x_gt0, ltnW n_gt1).\nhave nx_gt0: 0 < n.-root x by rewrite rootC_gt0.\nhave Rnx: n.-root x \\is real by rewrite ger0_real ?ltW.\napply: eqC_semipolar; last 1 first; try apply/eqP.\n- by rewrite ImMl // !(Im_rootC_ge0, mulr_ge0, rootC_ge0).\n- by rewrite -(eqrXn2 n_gt0) // -!normrX exprMn !rootCK.\nrewrite eq_le; apply/andP; split; last first.\n  rewrite rootC_Re_max ?exprMn ?rootCK ?ImMl //.\n  by rewrite mulr_ge0 ?Im_rootC_ge0 ?ltW.\nrewrite -[n.-root _](mulVKf (negbT (gt_eqF nx_gt0))) !(ReMl Rnx) //.\nrewrite ler_pM2l // rootC_Re_max ?exprMn ?exprVn ?rootCK ?mulKf ?gt_eqF //.\nby rewrite ImMl ?rpredV // mulr_ge0 ?invr_ge0 ?Im_rootC_ge0 ?ltW.\nQed.",
    "Lemma rootCMr n x z : 0 <= x -> n.-root (z * x) = n.-root z * n.-root x.\nProof. by move=> x_ge0; rewrite mulrC rootCMl // mulrC. Qed.",
    "Lemma imaginaryCE : 'i = sqrtC (-1).\nProof.\nhave : sqrtC (-1) ^+ 2 - 'i ^+ 2 == 0 by rewrite sqrCi rootCK // subrr.\nrewrite subr_sqr mulf_eq0 subr_eq0 addr_eq0; have [//|_/= /eqP sCN1E] := eqP.\nby have := @Im_rootC_ge0 2 (-1) isT; rewrite sCN1E raddfN /= Im_i ler0N1.\nQed.",
    "Lemma leif_rootC_AGM (I : finType) (A : {pred I}) (n := #|A|) E :\n    {in A, forall i, 0 <= E i} ->\n  n.-root (\\prod_(i in A) E i) <= (\\sum_(i in A) E i) / n%:R\n                             ?= iff [forall i in A, forall j in A, E i == E j].\nProof.\nmove=> Ege0; have [n0 | n_gt0] := posnP n.\n  rewrite n0 root0C invr0 mulr0; apply/leif_refl/forall_inP=> i.\n  by rewrite (card0_eq n0).\nrewrite -(mono_in_leif (ler_pXn2r n_gt0)) ?rootCK //=; first 1 last.\n- by rewrite qualifE /= rootC_ge0 // prodr_ge0.\n- by rewrite rpred_div ?rpred_nat ?rpred_sum.\nexact: leif_AGM.\nQed.",
    "Lemma sqrtC0 : sqrtC 0 = 0. Proof. exact: rootC0. Qed.",
    "Lemma sqrtC1 : sqrtC 1 = 1. Proof. exact: rootC1. Qed.",
    "Lemma sqrtCK x : sqrtC x ^+ 2 = x. Proof. exact: rootCK. Qed.",
    "Lemma sqrCK x : 0 <= x -> sqrtC (x ^+ 2) = x. Proof. exact: exprCK. Qed.",
    "Lemma sqrtC_ge0 x : (0 <= sqrtC x) = (0 <= x). Proof. exact: rootC_ge0. Qed.",
    "Lemma sqrtC_eq0 x : (sqrtC x == 0) = (x == 0). Proof. exact: rootC_eq0. Qed.",
    "Lemma sqrtC_gt0 x : (sqrtC x > 0) = (x > 0). Proof. exact: rootC_gt0. Qed.",
    "Lemma sqrtC_lt0 x : (sqrtC x < 0) = false. Proof. exact: rootC_lt0. Qed.",
    "Lemma sqrtC_le0 x : (sqrtC x <= 0) = (x == 0). Proof. exact: rootC_le0. Qed.",
    "Lemma ler_sqrtC : {in Num.nneg &, {mono sqrtC : x y / x <= y}}.\nProof. exact: ler_rootC. Qed.",
    "Lemma ltr_sqrtC : {in Num.nneg &, {mono sqrtC : x y / x < y}}.\nProof. exact: ltr_rootC. Qed.",
    "Lemma eqr_sqrtC : {mono sqrtC : x y / x == y}.\nProof. exact: eqr_rootC. Qed.",
    "Lemma sqrtC_inj : injective sqrtC.\nProof. exact: rootC_inj. Qed.",
    "Lemma sqrtCM : {in Num.nneg &, {morph sqrtC : x y / x * y}}.\nProof. by move=> x y _; apply: rootCMr. Qed.",
    "Lemma sqrtC_real x : 0 <= x -> sqrtC x \\in Num.real.\nProof. by rewrite -sqrtC_ge0; apply: ger0_real. Qed.",
    "Lemma sqrCK_P x : reflect (sqrtC (x ^+ 2) = x) ((0 <= 'Im x) && ~~ (x < 0)).\nProof.\napply: (iffP andP) => [[leI0x not_gt0x] | <-]; last first.\n  by rewrite sqrtC_lt0 Im_rootC_ge0.\nhave /eqP := sqrtCK (x ^+ 2); rewrite eqf_sqr => /pred2P[] // defNx.\napply: sqrCK; rewrite -real_leNgt ?rpred0 // in not_gt0x;\napply/Creal_ImP/le_anti;\nby rewrite leI0x -oppr_ge0 -raddfN -defNx Im_rootC_ge0.\nQed.",
    "Lemma normC_def x : `|x| = sqrtC (x * x^* ).\nProof. by rewrite -normCK sqrCK. Qed.",
    "Lemma norm_conjC x : `|x^*| = `|x|.\nProof. by rewrite !normC_def conjCK mulrC. Qed.",
    "Lemma normC_rect :\n  {in real &, forall x y, `|x + 'i * y| = sqrtC (x ^+ 2 + y ^+ 2)}.\nProof. by move=> x y Rx Ry; rewrite /= normC_def -normCK normC2_rect. Qed.",
    "Lemma normC_Re_Im z : `|z| = sqrtC ('Re z ^+ 2 + 'Im z ^+ 2).\nProof. by rewrite normC_def -normCK normC2_Re_Im. Qed.",
    "Lemma normCDeq x y :\n    `|x + y| = `|x| + `|y| ->\n  {t : C | `|t| == 1 & (x, y) = (`|x| * t, `|y| * t)}.\nProof.\nmove=> lin_xy; apply: sig2_eqW; pose u z := if z == 0 then 1 else z / `|z|.\nhave uE z: (`|u z| = 1) * (`|z| * u z = z).\n  rewrite /u; have [->|nz_z] := eqVneq; first by rewrite normr0 normr1 mul0r.\n  by rewrite normf_div normr_id mulrCA divff ?mulr1 ?normr_eq0.\nhave [->|nz_x] := eqVneq x 0; first by exists (u y); rewrite uE ?normr0 ?mul0r.\nexists (u x); rewrite uE // /u (negPf nz_x); congr (_ , _).\nhave{lin_xy} def2xy: `|x| * `|y| *+ 2 = x * y ^* + y * x ^*.\n  apply/(addrI (x * x^* ))/(addIr (y * y^* )); rewrite -2!{1}normCK -sqrrD.\n  by rewrite addrA -addrA -!mulrDr -mulrDl -rmorphD -normCK lin_xy.\nhave def_xy: x * y^* = y * x^*.\n  apply/eqP; rewrite -subr_eq0 -[_ == 0](@expf_eq0 _ _ 2).\n  rewrite (canRL (subrK _) (subr_sqrDB _ _)) opprK -def2xy exprMn_n exprMn.\n  by rewrite mulrN (@GRing.mul C).[AC (2*2) (1*4*(3*2))] -!normCK mulNrn addNr.\nhave{def_xy def2xy} def_yx: `|y * x| = y * x^*.\n  by apply: (mulIf nz2); rewrite !mulr_natr mulrC normrM def2xy def_xy.\nrewrite -{1}(divfK nz_x y) invC_norm mulrCA -{}def_yx !normrM invfM.\nby rewrite mulrCA divfK ?normr_eq0 // mulrAC mulrA.\nQed.",
    "Lemma normC_sum_eq (I : finType) (P : pred I) (F : I -> C) :\n     `|\\sum_(i | P i) F i| = \\sum_(i | P i) `|F i| ->\n   {t : C | `|t| == 1 & forall i, P i -> F i = `|F i| * t}.\nProof.\nhave [i /andP[Pi nzFi] | F0] := pickP [pred i | P i & F i != 0]; last first.\n  exists 1 => [|i Pi]; first by rewrite normr1.\n  by case/nandP: (F0 i) => [/negP[]// | /negbNE/eqP->]; rewrite normr0 mul0r.\nrewrite !(bigD1 i Pi) /= => norm_sumF; pose Q j := P j && (j != i).\nrewrite -normr_eq0 in nzFi; set c := F i / `|F i|; exists c => [|j Pj].\n  by rewrite normrM normfV normr_id divff.\nhave [Qj | /nandP[/negP[]// | /negbNE/eqP->]] := boolP (Q j); last first.\n  by rewrite mulrC divfK.\nhave: `|F i + F j| = `|F i| + `|F j|.\n  do [rewrite !(bigD1 j Qj) /=; set z := \\sum_(k | _) `|_|] in norm_sumF.\n  apply/eqP; rewrite eq_le ler_normD -(lerD2r z) -addrA -norm_sumF addrA.\n  by rewrite (le_trans (ler_normD _ _)) // lerD2l ler_norm_sum.\nby case/normCDeq=> k _ [/(canLR (mulKf nzFi)) <-]; rewrite -(mulrC (F i)).\nQed.",
    "Lemma normC_sum_eq1 (I : finType) (P : pred I) (F : I -> C) :\n    `|\\sum_(i | P i) F i| = (\\sum_(i | P i) `|F i|) ->\n     (forall i, P i -> `|F i| = 1) ->\n   {t : C | `|t| == 1 & forall i, P i -> F i = t}.\nProof.\ncase/normC_sum_eq=> t t1 defF normF.\nby exists t => // i Pi; rewrite defF // normF // mul1r.\nQed.",
    "Lemma normC_sum_upper (I : finType) (P : pred I) (F G : I -> C) :\n     (forall i, P i -> `|F i| <= G i) ->\n     \\sum_(i | P i) F i = \\sum_(i | P i) G i ->\n   forall i, P i -> F i = G i.\nProof.\nset sumF := \\sum_(i | _) _; set sumG := \\sum_(i | _) _ => leFG eq_sumFG.\nhave posG i: P i -> 0 <= G i by move/leFG; apply: le_trans.\nhave norm_sumG: `|sumG| = sumG by rewrite ger0_norm ?sumr_ge0.\nhave norm_sumF: `|sumF| = \\sum_(i | P i) `|F i|.\n  apply/eqP; rewrite eq_le ler_norm_sum eq_sumFG norm_sumG -subr_ge0 -sumrB.\n  by rewrite sumr_ge0 // => i Pi; rewrite subr_ge0 ?leFG.\nhave [t _ defF] := normC_sum_eq norm_sumF.\nhave [/(psumr_eq0P posG) G0 i Pi | nz_sumG] := eqVneq sumG 0.\n  by apply/eqP; rewrite G0 // -normr_eq0 eq_le normr_ge0 -(G0 i Pi) leFG.\nhave t1: t = 1.\n  apply: (mulfI nz_sumG); rewrite mulr1 -{1}norm_sumG -eq_sumFG norm_sumF.\n  by rewrite mulr_suml -(eq_bigr _ defF).\nhave /psumr_eq0P eqFG i: P i -> 0 <= G i - F i.\n  by move=> Pi; rewrite subr_ge0 defF // t1 mulr1 leFG.\nmove=> i /eqFG/(canRL (subrK _))->; rewrite ?add0r //.\nby rewrite sumrB -/sumF eq_sumFG subrr.\nQed.",
    "Lemma normCBeq x y :\n  `|x - y| = `|x| - `|y| -> {t | `|t| == 1 & (x, y) = (`|x| * t, `|y| * t)}.\nProof.\nset z := x - y; rewrite -(subrK y x) -/z => /(canLR (subrK _))/esym-Dx.\nhave [t t_1 [Dz Dy]] := normCDeq Dx.\nby exists t; rewrite // Dx mulrDl -Dz -Dy.\nQed.",
    "Lemma deg2_poly_factor : p = a *: ('X - r1%:P) * ('X - r2%:P).\nProof. by apply: deg2_poly_factor; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_root1 : root p r1.\nProof. by apply: deg2_poly_root1; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_root2 : root p r2.\nProof. by apply: deg2_poly_root2; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_factor : p = ('X - r1%:P) * ('X - r2%:P).\nProof. by apply: deg2_poly_factor; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_root1 : root p r1.\nProof. by apply: deg2_poly_root1; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_root2 : root p r2.\nProof. by apply: deg2_poly_root2; rewrite ?pnatr_eq0// sqrtCK. Qed.",
    "Lemma deg2_poly_min x : p.[- b / (2 * a)] <= p.[x].\nProof.\nrewrite [p]deg2_poly_canonical ?pnatr_eq0// -/a -/b -/c /delta !hornerE/=.\nby rewrite ler_pM2l// lerD2r addrC mulNr subrr expr0n sqr_ge0.\nQed.",
    "Lemma deg2_poly_minE : p.[- b / (2 * a)] = - delta / (4 * a).\nProof.\nrewrite [p]deg2_poly_canonical ?pnatr_eq0// -/a -/b -/c -/delta !hornerE/=.\nrewrite [X in X^+2]addrC [in LHS]mulNr subrr expr0n add0r mulNr.\nby rewrite mulrC mulNr invfM mulrA mulfVK.\nQed.",
    "Lemma deg2_poly_gt0 : reflect (forall x, 0 < p.[x]) (delta < 0).\nProof.\napply/(iffP idP) => [dlt0 x | /(_ (- b / (2 * a)))]; last first.\n  by rewrite deg2_poly_minE ltr_pdivlMr// mul0r oppr_gt0.\napply: lt_le_trans (deg2_poly_min _).\nby rewrite deg2_poly_minE ltr_pdivlMr// mul0r oppr_gt0.\nQed.",
    "Lemma deg2_poly_ge0 : reflect (forall x, 0 <= p.[x]) (delta <= 0).\nProof.\napply/(iffP idP) => [dlt0 x | /(_ (- b / (2 * a)))]; last first.\n  by rewrite deg2_poly_minE ler_pdivlMr// mul0r oppr_ge0.\napply: le_trans (deg2_poly_min _).\nby rewrite deg2_poly_minE ler_pdivlMr// mul0r oppr_ge0.\nQed.",
    "Lemma deg2_poly_max x : p.[x] <= p.[- b / (2 * a)].\nProof. by rewrite -lerN2 -!hornerN -b2a deg2_poly_min// coefN oppr_ge0. Qed.",
    "Lemma deg2_poly_maxE : p.[- b / (2 * a)] = - delta / (4 * a).\nProof.\napply/eqP; rewrite [eqbRHS]mulNr -eqr_oppLR -hornerN -b2a.\nby rewrite deg2_poly_minE// deltaN coefN mulrN divrNN.\nQed.",
    "Lemma deg2_poly_lt0 : reflect (forall x, p.[x] < 0) (delta < 0).\nProof.\nrewrite -deltaN; apply/(iffP (deg2_poly_gt0 _ _)); rewrite ?coefN ?oppr_ge0//.\n- by move=> gt0 x; rewrite -oppr_gt0 -hornerN gt0.\n- by move=> lt0 x; rewrite hornerN oppr_gt0 lt0.\nQed.",
    "Lemma deg2_poly_le0 : reflect (forall x, p.[x] <= 0) (delta <= 0).\nProof.\nrewrite -deltaN; apply/(iffP (deg2_poly_ge0 _ _)); rewrite ?coefN ?oppr_ge0//.\n- by move=> ge0 x; rewrite -oppr_ge0 -hornerN ge0.\n- by move=> le0 x; rewrite hornerN oppr_ge0 le0.\nQed.",
    "Lemma deg2_poly_factor : 0 <= delta -> p = a *: ('X - r1%:P) * ('X - r2%:P).\nProof. by move=> dge0; apply: deg2_poly_factor; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_root1 : 0 <= delta -> root p r1.\nProof. by move=> dge0; apply: deg2_poly_root1; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_root2 : 0 <= delta -> root p r2.\nProof. by move=> dge0; apply: deg2_poly_root2; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_noroot : reflect (forall x, ~~ root p x) (delta < 0).\nProof.\napply/(iffP idP) => [dlt0 x | /(_ r1)].\n  case: ltgtP aneq0 => [agt0 _|alt0 _|//]; rewrite rootE; last first.\n    exact/lt0r_neq0/(deg2_poly_gt0 degp (ltW alt0)).\n  rewrite -oppr_eq0 -hornerN.\n  apply/lt0r_neq0/deg2_poly_gt0; rewrite ?size_polyN ?coefN ?oppr_ge0 ?ltW//.\n  by rewrite sqrrN -mulrA mulrNN mulrA.\nby rewrite ltNge; apply: contraNN => ?; apply: deg2_poly_root1.\nQed.",
    "Lemma deg2_poly_gt0l x : x < r1 -> 0 < p.[x].\nProof.\nmove=> xltr1; have [? | dge0] := ltP delta 0; first exact: deg2_poly_gt0.\nhave {}xltr1 : sqrt delta < - (x * (2 * a) + b).\n  by rewrite ltrNr -ltrBrDr addrC -ltr_pdivlMr.\nrewrite [p]deg2_poly_canonical// -/a -/b -/c -/delta !hornerE/=.\nrewrite mulr_gt0// subr_gt0 ltr_pdivrMr// xb4 -sqrrN.\nrewrite -ltr_sqrt ?sqrtr_sqr ?(lt_le_trans xltr1) ?ler_norm//.\nby rewrite exprn_gt0 ?(le_lt_trans _ xltr1) ?sqrtr_ge0.\nQed.",
    "Lemma deg2_poly_gt0r x : r2 < x -> 0 < p.[x].\nProof.\nmove=> xgtr2; have [? | dge0] := ltP delta 0; first exact: deg2_poly_gt0.\nhave {}xgtr2 : sqrt delta < x * (2 * a) + b.\n  by rewrite -ltrBlDr addrC -ltr_pdivrMr.\nrewrite [p]deg2_poly_canonical// -/a -/b -/c -/delta !hornerE/=.\nrewrite mulr_gt0// subr_gt0 ltr_pdivrMr// xb4.\nrewrite -ltr_sqrt ?sqrtr_sqr ?(lt_le_trans xgtr2) ?ler_norm//.\nby rewrite exprn_gt0 ?(le_lt_trans _ xgtr2) ?sqrtr_ge0.\nQed.",
    "Lemma deg2_poly_lt0m x : r1 < x < r2 -> p.[x] < 0.\nProof.\nmove=> /andP[r1ltx xltr2].\nhave [dle0 | dgt0] := leP delta 0.\n  by move: (lt_trans r1ltx xltr2); rewrite /r1 /r2 ler0_sqrtr// oppr0 ltxx.\nrewrite [p]deg2_poly_canonical// !hornerE/= -/a -/b -/c -/delta.\nrewrite pmulr_rlt0// subr_lt0 ltr_pdivlMr// xb4 -ltr_sqrt// sqrtr_sqr ltr_norml.\nby rewrite -ltrBlDr addrC -ltr_pdivrMr// r1ltx -ltrBrDr addrC -ltr_pdivlMr.\nQed.",
    "Lemma deg2_poly_ge0l x : x <= r1 -> 0 <= p.[x].\nProof.\nrewrite le_eqVlt => /orP[/eqP->|xltr1]; last exact/ltW/deg2_poly_gt0l.\nhave [dge0|dlt0] := leP 0 delta; last by apply: deg2_poly_ge0 => //; apply: ltW.\nby rewrite le_eqVlt (rootP (deg2_poly_root1 dge0)) eqxx.\nQed.",
    "Lemma deg2_poly_ge0r x : r2 <= x -> 0 <= p.[x].\nProof.\nrewrite le_eqVlt => /orP[/eqP<-|xgtr2]; last exact/ltW/deg2_poly_gt0r.\nhave [dge0|dlt0] := leP 0 delta; last by apply: deg2_poly_ge0 => //; apply: ltW.\nby rewrite le_eqVlt (rootP (deg2_poly_root2 dge0)) eqxx.\nQed.",
    "Lemma deg2_poly_le0m x : 0 <= delta -> r1 <= x <= r2 -> p.[x] <= 0.\nProof.\nmove=> dge0; rewrite le_eqVlt andb_orl => /orP[/andP[/eqP<- _]|].\n  by rewrite le_eqVlt (rootP (deg2_poly_root1 dge0)) eqxx.\nrewrite le_eqVlt andb_orr => /orP[/andP[_ /eqP->]|].\n  by rewrite le_eqVlt (rootP (deg2_poly_root2 dge0)) eqxx.\nby move=> ?; apply/ltW/deg2_poly_lt0m.\nQed.",
    "Lemma deg2_poly_lt0l x : x < r1 -> p.[x] < 0.\nProof. by move=> ?; rewrite -oppr_gt0 -hornerN deg2_poly_gt0l// deltaN r1N. Qed.",
    "Lemma deg2_poly_lt0r x : r2 < x -> p.[x] < 0.\nProof. by move=> ?; rewrite -oppr_gt0 -hornerN deg2_poly_gt0r// deltaN r2N. Qed.",
    "Lemma deg2_poly_gt0m x : r1 < x < r2 -> 0 < p.[x].\nProof.\nby move=> ?; rewrite -oppr_lt0 -hornerN deg2_poly_lt0m// deltaN r1N r2N.\nQed.",
    "Lemma deg2_poly_le0l x : x <= r1 -> p.[x] <= 0.\nProof. by move=> ?; rewrite -oppr_ge0 -hornerN deg2_poly_ge0l// deltaN r1N. Qed.",
    "Lemma deg2_poly_le0r x : r2 <= x -> p.[x] <= 0.\nProof. by move=> ?; rewrite -oppr_ge0 -hornerN deg2_poly_ge0r// deltaN r2N. Qed.",
    "Lemma deg2_poly_ge0m x : 0 <= delta -> r1 <= x <= r2 -> 0 <= p.[x].\nProof.\nby move=> ? ?; rewrite -oppr_le0 -hornerN deg2_poly_le0m ?deltaN// r1N r2N.\nQed.",
    "Lemma deg2_poly_min x : p.[- b / 2] <= p.[x].\nProof. by rewrite -a2 deg2_poly_min -/a ?a1 ?ler01. Qed.",
    "Lemma deg2_poly_minE : p.[- b / 2] = - delta / 4.\nProof. by rewrite -a2 -a4 deltam deg2_poly_minE. Qed.",
    "Lemma deg2_poly_gt0 : reflect (forall x, 0 < p.[x]) (delta < 0).\nProof. by rewrite deltam; apply: deg2_poly_gt0; rewrite // -/a a1 ler01. Qed.",
    "Lemma deg2_poly_ge0 : reflect (forall x, 0 <= p.[x]) (delta <= 0).\nProof. by rewrite deltam; apply: deg2_poly_ge0; rewrite // -/a a1 ler01. Qed.",
    "Lemma deg2_poly_factor : 0 <= delta -> p = ('X - r1%:P) * ('X - r2%:P).\nProof. by move=> dge0; apply: deg2_poly_factor; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_root1 : 0 <= delta -> root p r1.\nProof. by move=> dge0; apply: deg2_poly_root1; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_root2 : 0 <= delta -> root p r2.\nProof. by move=> dge0; apply: deg2_poly_root2; rewrite ?sqr_sqrtr. Qed.",
    "Lemma deg2_poly_noroot : reflect (forall x, ~~ root p x) (delta < 0).\nProof. by rewrite deltam; apply: deg2_poly_noroot. Qed.",
    "Lemma deg2_poly_gt0l x : x < r1 -> 0 < p.[x].\nProof.\nby move=> ?; apply: deg2_poly_gt0l; rewrite // -/a ?a1 ?ler01 ?mulr1.\nQed.",
    "Lemma deg2_poly_gt0r x : r2 < x -> 0 < p.[x].\nProof.\nby move=> ?; apply: deg2_poly_gt0r; rewrite // -/a ?a1 ?ler01 ?mulr1.\nQed.",
    "Lemma deg2_poly_lt0m x : r1 < x < r2 -> p.[x] < 0.\nProof.\nby move=> ?; apply: deg2_poly_lt0m; rewrite // -/a ?a1 ?ler01 ?mulr1.\nQed.",
    "Lemma deg2_poly_ge0l x : x <= r1 -> 0 <= p.[x].\nProof.\nby move=> ?; apply: deg2_poly_ge0l; rewrite // -/a ?a1 ?ler01 ?mulr1.\nQed.",
    "Lemma deg2_poly_ge0r x : r2 <= x -> 0 <= p.[x].\nProof.\nby move=> ?; apply: deg2_poly_ge0r; rewrite // -/a ?a1 ?ler01 ?mulr1.\nQed.",
    "Lemma deg2_poly_le0m x : 0 <= delta -> r1 <= x <= r2 -> p.[x] <= 0.\nProof.\nmove=> dge0 xm.\nby apply: deg2_poly_le0m; rewrite -/a -/b -/c ?a1 ?mulr1 -/delta ?ler01.\nQed.",
    "Lemma deg_le2_poly_delta_ge0 : 0 <= a -> (forall x, 0 <= p.[x]) -> delta <= 0.\nProof.\nmove=> age0 pge0; move: degp; rewrite leq_eqVlt => /orP[/eqP|] degp'.\n  exact/(Real.deg2_poly_ge0 degp' age0).\nhave a0 : a = 0 by rewrite /a nth_default.\nrewrite /delta a0 mulr0 mul0r subr0 exprn_even_le0//=.\nhave [//|/eqP nzb] := eqP; move: (pge0 ((- 1 - c) / b)).\nhave -> : p = b *: 'X + c%:P.\n  apply/polyP => + /[!coefE] => -[|[|i]] /=; rewrite !Monoid.simpm//.\n  by rewrite nth_default// -ltnS (leq_trans degp').\nby rewrite !hornerE/= mulrAC mulfV// mul1r subrK ler0N1.\nQed.",
    "Lemma deg_le2_poly_delta_le0 : a <= 0 -> (forall x, p.[x] <= 0) -> delta <= 0.\nProof.\nmove=> ale0 ple0; rewrite /delta -sqrrN -[c]opprK mulrN -mulNr -[-(4 * a)]mulrN.\nrewrite -!coefN deg_le2_poly_delta_ge0 ?size_polyN ?coefN ?oppr_ge0// => x.\nby rewrite hornerN oppr_ge0.\nQed.",
    "Lemma deg_le2_poly_ge0 : (forall x, 0 <= p.[x]) -> delta <= 0.\nProof.\nhave [age0|alt0] := leP 0 a; first exact: deg_le2_poly_delta_ge0.\nmove=> pge0; move: degp; rewrite leq_eqVlt => /orP[/eqP|] degp'; last first.\n  by move: alt0; rewrite /a nth_default ?ltxx.\nhave [//|dge0] := leP delta 0.\npose r1 := (- b - sqrt delta) / (2 * a).\npose r2 := (- b + sqrt delta) / (2 * a).\npose x0 := Num.max (r1 + 1) (r2 + 1).\nmove: (pge0 x0); rewrite (Real.deg2_poly_factor degp' (ltW dge0)).\nrewrite !hornerE/= -mulrA nmulr_rge0// leNgt => /negbTE<-.\nby apply: mulr_gt0; rewrite subr_gt0 lt_max ltrDl ltr01 ?orbT.\nQed.",
    "Lemma deg_le2_poly_le0 : (forall x, p.[x] <= 0) -> delta <= 0.\nProof.\nmove=> ple0; rewrite /delta -sqrrN -[c]opprK mulrN -mulNr -[-(4 * a)]mulrN.\nby rewrite -!coefN deg_le2_poly_ge0 ?size_polyN// => x; rewrite hornerN oppr_ge0.\nQed.",
    "Lemma ltrr x : x < x = false. Proof. by rewrite lt_def eqxx. Qed.",
    "Lemma ge0_def x : (0 <= x) = (`|x| == x).\n  Proof. by rewrite le_def subr0. Qed.",
    "Lemma subr_ge0 x y : (0 <= x - y) = (y <= x).\n  Proof. by rewrite ge0_def -le_def. Qed.",
    "Lemma subr_gt0 x y : (0 < y - x) = (x < y).\n  Proof. by rewrite !lt_def subr_eq0 subr_ge0. Qed.",
    "Lemma lt_trans : transitive Rlt.\n  Proof.\n  move=> y x z le_xy le_yz.\n  by rewrite -subr_gt0 -(subrK y z) -addrA addr_gt0 // subr_gt0.\n  Qed.",
    "Lemma le01 : 0 <= 1.\n  Proof.\n  have n1_nz: `|1| != 0 :> R by apply: contraNneq (@oner_neq0 R) => /norm_eq0->.\n  by rewrite ge0_def -(inj_eq (mulfI n1_nz)) -normM !mulr1.\n  Qed.",
    "Lemma lt01 : 0 < 1.\n  Proof. by rewrite lt_def oner_neq0 le01. Qed.",
    "Lemma ltW x y : x < y -> x <= y. Proof. by rewrite lt_def => /andP[]. Qed.",
    "Lemma lerr x : x <= x.\n  Proof.\n  have n2: `|2| == 2 :> R by rewrite -ge0_def ltW ?addr_gt0 ?lt01.\n  rewrite le_def subrr -(inj_eq (addrI `|0|)) addr0 -mulr2n -mulr_natr.\n  by rewrite -(eqP n2) -normM mul0r.\n  Qed.",
    "Lemma le_def' x y : (x <= y) = (x == y) || (x < y).\n  Proof. by rewrite lt_def; case: eqVneq => //= ->; rewrite lerr. Qed.",
    "Lemma le_trans : transitive Rle.\nProof.  by move=> y x z; rewrite !le_def' => /predU1P [->|hxy] // /predU1P [<-|hyz];\n    rewrite ?hxy ?(lt_trans hxy hyz) orbT.\n  Qed.",
    "Lemma normrMn x n : `|x *+ n| = `|x| *+ n.\n  Proof.\n  rewrite -mulr_natr -[RHS]mulr_natr normM.\n  congr (_ * _); apply/eqP; rewrite -ge0_def.\n  elim: n => [|n ih]; [exact: lerr | apply: (le_trans ih)].\n  by rewrite le_def -natrB // subSnn -[_%:R]subr0 -le_def mulr1n le01.\n  Qed.",
    "Lemma normrN1 : `|-1| = 1 :> R.\n  Proof.\n  have: `|-1| ^+ 2 == 1 :> R\n    by rewrite expr2 /= -normM mulrNN mul1r -[1]subr0 -le_def le01.\n  rewrite sqrf_eq1 => /predU1P [] //; rewrite -[-1]subr0 -le_def.\n  have ->: 0 <= -1 = (-1 == 0 :> R) || (0 < -1)\n    by rewrite lt_def; case: eqP => // ->; rewrite lerr.\n  by rewrite oppr_eq0 oner_eq0 => /(addr_gt0 lt01); rewrite subrr ltrr.\n  Qed.",
    "Lemma normrN x : `|- x| = `|x|.\n  Proof. by rewrite -mulN1r normM -[RHS]mul1r normrN1. Qed.",
    "Lemma le_total : Order.POrder_isTotal ring_display R.\n  Proof.\n  constructor=> x y; move: (real (x - y)).\n  by rewrite unfold_in /= !ler_def subr0 add0r opprB orbC.\n  Qed.",
    "Lemma natsum_of_intK : cancel natsum_of_int int_of_natsum.\nProof. by case. Qed.",
    "Lemma eqz_nat (m n : nat) : (m%:Z == n%:Z) = (m == n). Proof. by []. Qed.",
    "Lemma PoszD : {morph Posz : m n / (m + n)%N >-> m + n}. Proof. by []. Qed.",
    "Lemma NegzE (n : nat) : Negz n = - n.+1. Proof. by []. Qed.",
    "Lemma int_rect (P : int -> Type) :\n  P 0 -> (forall n : nat, P n -> P (n.+1))\n  -> (forall n : nat, P (- n) -> P (- (n.+1)))\n  -> forall n : int, P n.\nProof.\nby move=> P0 hPp hPn []; elim=> [|n ihn]//; do ?[apply: hPn | apply: hPp].\nQed.",
    "Lemma intP x : int_spec x x. Proof. by move: x=> [] []; constructor. Qed.",
    "Lemma addzC : commutative addz.\nProof. by move=> [] m [] n //=; rewrite addnC. Qed.",
    "Lemma add0z : left_id 0 addz. Proof. by do 2?case. Qed.",
    "Lemma oppzK : involutive oppz. Proof. by do 2?case. Qed.",
    "Lemma oppzD : {morph oppz : m n / m + n}.\nProof.\nby move=> [[|n]|n] [[|m]|m] /=; rewrite ?addn0 ?subn0 ?addnS //;\n  rewrite !NegzE !ltnS !subSS; case: ltngtP => [?|?|->];\n  rewrite ?subnn // ?oppzK ?subnS ?prednK // subn_gt0.\nQed.",
    "Lemma add1Pz (n : int) : 1 + (n - 1) = n.\nProof. by case: (intP n)=> // n' /= _; rewrite ?(subn1, addn0). Qed.",
    "Lemma subSz1 (n : int) : 1 + n - 1 = n.\nProof.\nby apply: (inv_inj oppzK); rewrite addzC !oppzD oppzK [_ - n]addzC add1Pz.\nQed.",
    "Lemma addSnz (m : nat) (n : int) : m.+1%N + n = 1 + (m + n).\nProof.\nmove: m n=> [|m] [] [|n] //=; rewrite ?add1n ?subn1 // !(ltnS, subSS).\ncase: ltngtP=> hnm /=; rewrite ?hnm ?subnn //.\n  by rewrite subnS add1n prednK ?subn_gt0.\nby rewrite ltnS leqn0 subn_eq0 leqNgt hnm /= subnS subn1.\nQed.",
    "Lemma addSz (m n : int) : (1 + m) + n = 1 + (m + n).\nProof.\ncase: m => [] m; first by rewrite -PoszD add1n addSnz.\nrewrite !NegzE; apply: (inv_inj oppzK).\nrewrite !oppzD !oppzK addSnz [-1%:Z + _]addzC addSnz add1Pz.\nby rewrite [-1%:Z + _]addzC subSz1.\nQed.",
    "Lemma addPz (m n : int) : (m - 1) + n = (m + n) - 1.\nProof.\nby apply: (inv_inj oppzK); rewrite !oppzD oppzK [_ + 1]addzC addSz addzC.\nQed.",
    "Lemma addzA : associative addz.\nProof.\nelim=> [|m ihm|m ihm] n p; first by rewrite !add0z.\n  by rewrite -add1n PoszD !addSz ihm.\nby rewrite -add1n addnC PoszD oppzD !addPz ihm.\nQed.",
    "Lemma addNz : left_inverse (0:int) oppz addz. Proof. by do 3?elim. Qed.",
    "Lemma predn_int (n : nat) : 0 < n -> n.-1%:Z = n - 1.\nProof. by case: n => //= n _; rewrite subn1. Qed.",
    "Lemma PoszD : {morph Posz : n m / (n + m)%N >-> n + m}. Proof. by []. Qed.",
    "Lemma NegzE (n : nat) : Negz n = -(n.+1)%:Z. Proof. by []. Qed.",
    "Lemma int_rect (P : int -> Type) :\n  P 0 -> (forall n : nat, P n -> P (n.+1)%N)\n  -> (forall n : nat, P (- (n%:Z)) -> P (- (n.+1%N%:Z)))\n  -> forall n : int, P n.\nProof.\nby move=> P0 hPp hPn []; elim=> [|n ihn]//; do ?[apply: hPn | apply: hPp].\nQed.",
    "Lemma intP x : int_spec x x.\nProof. by move: x=> [] [] *; rewrite ?NegzE; constructor. Qed.",
    "Lemma subzn (m n : nat) : (n <= m)%N -> m%:Z - n%:Z = (m - n)%N.\nProof.\nelim: n=> //= [|n ihn] hmn; first by rewrite subr0 subn0.\nrewrite subnS -addn1 !PoszD opprD addrA ihn 1?ltnW //.\nby rewrite intZmod.predn_int // subn_gt0.\nQed.",
    "Lemma subzSS (m n : nat) : m.+1%:Z - n.+1%:Z = m%:Z - n%:Z.\nProof. by elim: n m=> [|n ihn] m //; rewrite !subzn. Qed.",
    "Lemma mul0z : left_zero 0 *%Z.\nProof. by case=> [n|[|n]] //=; rewrite muln0. Qed.",
    "Lemma mulzC : commutative mulz.\nProof. by move=> [] m [] n //=; rewrite mulnC. Qed.",
    "Lemma mulz0 : right_zero 0 *%Z.\nProof. by move=> x; rewrite mulzC mul0z. Qed.",
    "Lemma mulzN (m n : int) : (m * (- n))%Z = - (m * n)%Z.\nProof.\nby case: (intP m)=> {m} [|m|m]; rewrite ?mul0z //;\ncase: (intP n)=> {n} [|n|n]; rewrite ?mulz0 //= mulnC.\nQed.",
    "Lemma mulNz (m n : int) : ((- m) * n)%Z = - (m * n)%Z.\nProof. by rewrite mulzC mulzN mulzC. Qed.",
    "Lemma mulzA : associative mulz.\nProof.\nby move=> [] m [] n [] p; rewrite ?NegzE ?(mulnA,mulNz,mulzN,opprK) //= ?mulnA.\nQed.",
    "Lemma mul1z : left_id 1%Z mulz.\nProof. by case=> [[|n]|n] //=; rewrite ?mul1n// plusE addn0. Qed.",
    "Lemma mulzS (x : int) (n : nat) : (x * n.+1%:Z)%Z = x + (x * n)%Z.\nProof.\nby case: (intP x)=> [|m'|m'] //=; [rewrite mulnS|rewrite mulSn -opprD].\nQed.",
    "Lemma mulz_addl : left_distributive mulz (+%R).\nProof.\nmove=> x y z; elim: z=> [|n|n]; first by rewrite !(mul0z,mulzC).\n  by rewrite !mulzS=> ->; rewrite !addrA [X in X + _]addrAC.\nrewrite !mulzN !mulzS -!opprD=> /oppr_inj->.\nby rewrite !addrA [X in X + _]addrAC.\nQed.",
    "Lemma nonzero1z : 1%Z != 0. Proof. by []. Qed.",
    "Lemma PoszM : {morph Posz : n m / (n * m)%N >-> n * m}. Proof. by []. Qed.",
    "Lemma intS (n : nat) : n.+1%:Z = 1 + n%:Z. Proof. by rewrite -PoszD. Qed.",
    "Lemma predn_int (n : nat) : (0 < n)%N -> n.-1%:Z = n%:Z - 1.\nProof. exact: intZmod.predn_int. Qed.",
    "Lemma mulVz : {in unitz, left_inverse 1%R invz *%R}.\nProof. by move=> n /pred2P[] ->. Qed.",
    "Lemma mulzn_eq1 m (n : nat) : (m * n == 1) = (m == 1) && (n == 1).\nProof. by case: m => m /=; [rewrite -PoszM [_==_]muln_eq1 | case: n]. Qed.",
    "Lemma unitzPl m n : n * m = 1 -> m \\is a unitz.\nProof.\nrewrite qualifE => /eqP.\nby case: m => m; rewrite ?NegzE ?mulrN -?mulNr mulzn_eq1 => /andP[_ /eqP->].\nQed.",
    "Lemma invz_out : {in [predC unitz], invz =1 id}.\nProof. exact. Qed.",
    "Lemma idomain_axiomz m n : m * n = 0 -> (m == 0) || (n == 0).\nProof. by case: m n => [[|m]|m] [[|n]|n]. Qed.",
    "Lemma subz_ge0 m n : lez 0 (n - m) = lez m n.\nProof.\ncase: (intP m); case: (intP n)=> // {}m {}n /=;\nrewrite ?ltnS -?opprD ?opprB ?subzSS; case: leqP=> // hmn;\nby [ rewrite subzn //\n   | rewrite -opprB subzn ?(ltnW hmn) //;\n      move: hmn; rewrite -subn_gt0; case: (_ - _)%N].\nQed.",
    "Lemma lez_nat m n : (m <= n :> int) = (m <= n)%N. Proof. by []. Qed.",
    "Lemma ltz_nat  m n : (m < n :> int) = (m < n)%N.\nProof. by rewrite ltnNge ltNge lez_nat. Qed.",
    "Lemma leNz_nat m n : (- m%:Z <= n). Proof. by case: m. Qed.",
    "Lemma ltNz_nat m n : (- m%:Z < n) = (m != 0) || (n != 0).\nProof. by move: m n=> [|?] []. Qed.",
    "Lemma lezN_nat m n : (m%:Z <= - n%:Z) = (m == 0) && (n == 0).\nProof. by move: m n=> [|?] []. Qed.",
    "Lemma ltzN_nat m n : (m%:Z < - n%:Z) = false.\nProof. by move: m n=> [|?] []. Qed.",
    "Lemma le0z_nat n : 0 <= n :> int. Proof. by []. Qed.",
    "Lemma lez0_nat n : n <= 0 :> int = (n == 0 :> nat). Proof. by elim: n. Qed.",
    "Lemma gtz0_ge1 x : (0 < x) = (1 <= x). Proof. by case: (intP x). Qed.",
    "Lemma lez1D x y : (1 + x <= y) = (x < y).\nProof. by rewrite -subr_gt0 gtz0_ge1 lterBDr. Qed.",
    "Lemma lezD1 x y : (x + 1 <= y) = (x < y).\nProof. by rewrite addrC lez1D. Qed.",
    "Lemma ltz1D x y : (x < 1 + y) = (x <= y).\nProof. by rewrite -lez1D lerD2l. Qed.",
    "Lemma ltzD1 x y : (x < y + 1) = (x <= y).\nProof. by rewrite -lezD1 lerD2r. Qed.",
    "Lemma pmulrn (R : zmodType) (x : R) (n : nat) : x *+ n = x *~ n%:Z.\nProof. by []. Qed.",
    "Lemma nmulrn (R : zmodType) (x : R) (n : nat) : x *- n = x *~ - n%:Z.\nProof. by case: n; rewrite // oppr0. Qed.",
    "Lemma mulrzBl_nat (m n : nat) x : x *~ (m%:Z - n%:Z) = x *~ m - x *~ n.\nProof.\nwlog/subnK <-: m n / (n <= m)%N; last by rewrite -!pmulrn PoszD mulrnDr !addrK.\nhave [hmn|/ltnW hmn] := leqP n m; first exact.\nby rewrite -[in LHS]opprB -[RHS]opprB subzn // -nmulrn pmulrn -subzn // => ->.\nQed.",
    "Lemma scalezrE n x : n *: (x : M^z) = x *~ n. Proof. by []. Qed.",
    "Lemma mulrzA x m n :  x *~ (m * n) = x *~ m *~ n.\nProof. by rewrite -!scalezrE scalerA mulrC. Qed.",
    "Lemma mulr0z x : x *~ 0 = 0. Proof. by []. Qed.",
    "Lemma mul0rz n : 0 *~ n = 0 :> M.\nProof. by rewrite -scalezrE scaler0. Qed.",
    "Lemma mulrNz x n : x *~ (- n) = - (x *~ n).\nProof. by rewrite -scalezrE scaleNr. Qed.",
    "Lemma mulrN1z x : x *~ (- 1) = - x. Proof. by rewrite -scalezrE scaleN1r. Qed.",
    "Lemma mulNrz x n : (- x) *~ n = - (x *~ n).\nProof. by rewrite -scalezrE scalerN. Qed.",
    "Lemma mulrzBr x m n : x *~ (m - n) = x *~ m - x *~ n.\nProof. by rewrite -scalezrE scalerBl. Qed.",
    "Lemma mulrzBl x y n : (x - y) *~ n = x *~ n - y *~ n.\nProof. by rewrite -scalezrE scalerBr. Qed.",
    "Lemma mulrz_nat (n : nat) x : x *~ n%:R = x *+ n.\nProof. by rewrite -scalezrE scaler_nat. Qed.",
    "Lemma mulrz_sumr : forall x I r (P : pred I) F,\n  x *~ (\\sum_(i <- r | P i) F i) = \\sum_(i <- r | P i) x *~ F i.\nProof. by rewrite -/M^z; apply: scaler_suml. Qed.",
    "Lemma mulrz_suml : forall n I r (P : pred I) (F : I -> M),\n  (\\sum_(i <- r | P i) F i) *~ n= \\sum_(i <- r | P i) F i *~ n.\nProof. by rewrite -/M^z; apply: scaler_sumr. Qed.",
    "Lemma ffunMzE (I : finType) (M : zmodType) (f : {ffun I -> M}) z x :\n  (f *~ z) x = f x *~ z.\nProof. by case: z => n; rewrite ?ffunE ffunMnE. Qed.",
    "Lemma intz (n : int) : n%:~R = n.\nProof. by case: n => n; rewrite ?NegzE /intmul/= -(rmorphMn Posz)/= natn. Qed.",
    "Lemma natz (n : nat) : n%:R = n%:Z :> int.\nProof. by rewrite pmulrn intz. Qed.",
    "Lemma mulrzAl n x y : (x *~ n) * y = (x * y) *~ n.\nProof. by case: n => n; rewrite ?mulNr mulrnAl. Qed.",
    "Lemma mulrzAr n x y : x * (y *~ n) = (x * y) *~ n.\nProof. by case: n => n; rewrite ?mulrN mulrnAr. Qed.",
    "Lemma mulrzl x n : n%:~R * x = x *~ n. Proof. by rewrite mulrzAl mul1r. Qed.",
    "Lemma mulrzr x n : x * n%:~R = x *~ n. Proof. by rewrite mulrzAr mulr1. Qed.",
    "Lemma mulNrNz n x : (- x) *~ (- n) = x *~ n.\nProof. by rewrite mulNrz mulrNz opprK. Qed.",
    "Lemma mulrbz x (b : bool) : x *~ b = (if b then x else 0).\nProof. by case: b. Qed.",
    "Lemma intrN n : (- n)%:~R = - n%:~R :> R. Proof. exact: mulrNz. Qed.",
    "Lemma intrD m n : (m + n)%:~R = m%:~R + n%:~R :> R. Proof. exact: mulrzDr. Qed.",
    "Lemma intrB m n : (m - n)%:~R = m%:~R - n%:~R :> R. Proof. exact: mulrzBr. Qed.",
    "Lemma intrM m n : (m * n)%:~R = m%:~R * n%:~R :> R.\nProof. by rewrite mulrzA -mulrzr. Qed.",
    "Lemma intmul1_is_multiplicative : multiplicative ( *~%R (1 : R)).\nProof. by split; move=> // x y /=; rewrite ?intrD ?mulrNz ?intrM. Qed.",
    "Lemma mulr2z n : n *~ 2 = n + n. Proof. exact: mulr2n. Qed.",
    "Lemma mulrzz m n : m *~ n = m * n. Proof. by rewrite -mulrzr intz. Qed.",
    "Lemma mulz2 n : n * 2%:Z = n + n. Proof. by rewrite -mulrzz. Qed.",
    "Lemma mul2z n : 2%:Z * n = n + n. Proof. by rewrite mulrC -mulrzz. Qed.",
    "Lemma scaler_int n v : n%:~R *: v = v *~ n.\nProof. by case: n => n; rewrite /intmul ?scaleNr scaler_nat. Qed.",
    "Lemma scalerMzl a v n : (a *: v) *~ n = (a *~ n) *: v.\nProof. by rewrite -mulrzl -scaler_int scalerA. Qed.",
    "Lemma scalerMzr a v n : (a *: v) *~ n = a *: (v *~ n).\nProof. by rewrite -!scaler_int !scalerA mulrzr mulrzl. Qed.",
    "Lemma mulrz_int (M : zmodType) (n : int) (x : M) : x *~ n%:~R = x *~ n.\nProof. by rewrite -scalezrE scaler_int. Qed.",
    "Lemma raddfMz n : {morph f : x / x *~ n}.\nProof. by case: n=> n x; rewrite 1?raddfN raddfMn. Qed.",
    "Lemma rmorphMz : forall n, {morph f : x / x *~ n}. Proof. exact: raddfMz. Qed.",
    "Lemma rmorph_int : forall n, f n%:~R = n%:~R.\nProof. by move=> n; rewrite rmorphMz rmorph1. Qed.",
    "Lemma linearMn : forall n, {morph f : x / x *~ n}. Proof. exact: raddfMz. Qed.",
    "Lemma raddf_int_scalable (aV rV : lmodType int) (f : {additive aV -> rV}) :\n  scalable f.\nProof. by move=> z u; rewrite -[z]intz !scaler_int raddfMz. Qed.",
    "Lemma commrMz (x y : R) n : GRing.comm x y -> GRing.comm x (y *~ n).\nProof. by rewrite /GRing.comm=> com_xy; rewrite mulrzAr mulrzAl com_xy. Qed.",
    "Lemma commr_int (x : R) n : GRing.comm x n%:~R.\nProof. exact/commrMz/commr1. Qed.",
    "Lemma sumMz : forall I r (P : pred I) F,\n (\\sum_(i <- r | P i) F i)%N%:~R = \\sum_(i <- r | P i) ((F i)%:~R) :> R.\nProof. exact: rmorph_sum. Qed.",
    "Lemma prodMz : forall I r (P : pred I) F,\n (\\prod_(i <- r | P i) F i)%N%:~R = \\prod_(i <- r | P i) ((F i)%:~R) :> R.\nProof. exact: rmorph_prod. Qed.",
    "Lemma pFrobenius_autMz x n : (x *~ n)^f = x^f *~ n.\nProof.\ncase: n=> n /=; first exact: pFrobenius_autMn.\nby rewrite !NegzE !mulrNz pFrobenius_autN pFrobenius_autMn.\nQed.",
    "Lemma pFrobenius_aut_int n : (n%:~R)^f = n%:~R.\nProof. by rewrite pFrobenius_autMz pFrobenius_aut1. Qed.",
    "Lemma rmorphzP (f : {rmorphism int -> R}) : f =1 ( *~%R 1).\nProof. by move=> n; rewrite -[n in LHS]intz rmorph_int. Qed.",
    "Lemma ler_pMz2r n (hn : 0 < n) : {mono *~%R^~ n :x y / x <= y :> R}.\nProof. by move=> x y; case: n hn=> [[]|] // n _; rewrite ler_pMn2r. Qed.",
    "Lemma ltr_pMz2r n (hn : 0 < n) : {mono *~%R^~ n : x y / x < y :> R}.\nProof. exact: leW_mono (ler_pMz2r _). Qed.",
    "Lemma ler_nMz2r n (hn : n < 0) : {mono *~%R^~ n : x y /~ x <= y :> R}.\nProof.\nby move=> x y /=; rewrite -![_ *~ n]mulNrNz ler_pMz2r (oppr_cp0, lerN2).\nQed.",
    "Lemma ltr_nMz2r n (hn : n < 0) : {mono *~%R^~ n : x y /~ x < y :> R}.\nProof. exact: leW_nmono (ler_nMz2r _). Qed.",
    "Lemma ler_wpMz2r n (hn : 0 <= n) : {homo *~%R^~ n : x y / x <= y :> R}.\nProof. by move=> x y xy; case: n hn=> [] // n _; rewrite ler_wMn2r. Qed.",
    "Lemma ler_wnMz2r n (hn : n <= 0) : {homo *~%R^~ n : x y /~ x <= y :> R}.\nProof. by move=> x y xy /=; rewrite -lerN2 -!mulrNz ler_wpMz2r // oppr_ge0. Qed.",
    "Lemma mulrz_ge0 x n (x0 : 0 <= x) (n0 : 0 <= n) : 0 <= x *~ n.\nProof. by rewrite -(mul0rz _ n) ler_wpMz2r. Qed.",
    "Lemma mulrz_le0 x n (x0 : x <= 0) (n0 : n <= 0) : 0 <= x *~ n.\nProof. by rewrite -(mul0rz _ n) ler_wnMz2r. Qed.",
    "Lemma mulrz_ge0_le0 x n (x0 : 0 <= x) (n0 : n <= 0) : x *~ n <= 0.\nProof. by rewrite -(mul0rz _ n) ler_wnMz2r. Qed.",
    "Lemma mulrz_le0_ge0 x n (x0 : x <= 0) (n0 : 0 <= n) : x *~ n <= 0.\nProof. by rewrite -(mul0rz _ n) ler_wpMz2r. Qed.",
    "Lemma pmulrz_lgt0 x n (n0 : 0 < n) : 0 < x *~ n = (0 < x).\nProof. by rewrite -(mul0rz _ n) ltr_pMz2r // mul0rz. Qed.",
    "Lemma nmulrz_lgt0 x n (n0 : n < 0) : 0 < x *~ n = (x < 0).\nProof. by rewrite -(mul0rz _ n) ltr_nMz2r // mul0rz. Qed.",
    "Lemma pmulrz_llt0 x n (n0 : 0 < n) : x *~ n < 0 = (x < 0).\nProof. by rewrite -(mul0rz _ n) ltr_pMz2r // mul0rz. Qed.",
    "Lemma nmulrz_llt0 x n (n0 : n < 0) : x *~ n < 0 = (0 < x).\nProof. by rewrite -(mul0rz _ n) ltr_nMz2r // mul0rz. Qed.",
    "Lemma pmulrz_lge0 x n (n0 : 0 < n) : 0 <= x *~ n = (0 <= x).\nProof. by rewrite -(mul0rz _ n) ler_pMz2r // mul0rz. Qed.",
    "Lemma nmulrz_lge0 x n (n0 : n < 0) : 0 <= x *~ n = (x <= 0).\nProof. by rewrite -(mul0rz _ n) ler_nMz2r // mul0rz. Qed.",
    "Lemma pmulrz_lle0 x n (n0 : 0 < n) : x *~ n <= 0 = (x <= 0).\nProof. by rewrite -(mul0rz _ n) ler_pMz2r // mul0rz. Qed.",
    "Lemma nmulrz_lle0 x n (n0 : n < 0) : x *~ n <= 0 = (0 <= x).\nProof. by rewrite -(mul0rz _ n) ler_nMz2r // mul0rz. Qed.",
    "Lemma ler_wpMz2l x (hx : 0 <= x) : {homo *~%R x : x y / x <= y}.\nProof.\nby move=> m n /= hmn; rewrite -subr_ge0 -mulrzBr mulrz_ge0 // subr_ge0.\nQed.",
    "Lemma ler_wnMz2l x (hx : x <= 0) : {homo *~%R x : x y /~ x <= y}.\nProof.\nby move=> m n /= hmn; rewrite -subr_ge0 -mulrzBr mulrz_le0 // subr_le0.\nQed.",
    "Lemma ler_pMz2l x (hx : 0 < x) : {mono *~%R x : x y / x <= y}.\nProof.\nmove=> m n /=; rewrite real_mono ?num_real // => {m n}.\nby move=> m n /= hmn; rewrite -subr_gt0 -mulrzBr pmulrz_lgt0 // subr_gt0.\nQed.",
    "Lemma ler_nMz2l x (hx : x < 0) : {mono *~%R x : x y /~ x <= y}.\nProof.\nmove=> m n /=; rewrite real_nmono ?num_real // => {m n}.\nby move=> m n /= hmn; rewrite -subr_gt0 -mulrzBr nmulrz_lgt0 // subr_lt0.\nQed.",
    "Lemma ltr_pMz2l x (hx : 0 < x) : {mono *~%R x : x y / x < y}.\nProof. exact: leW_mono (ler_pMz2l _). Qed.",
    "Lemma ltr_nMz2l x (hx : x < 0) : {mono *~%R x : x y /~ x < y}.\nProof. exact: leW_nmono (ler_nMz2l _). Qed.",
    "Lemma pmulrz_rgt0 x n (x0 : 0 < x) : 0 < x *~ n = (0 < n).\nProof. by rewrite -(mulr0z x) ltr_pMz2l. Qed.",
    "Lemma nmulrz_rgt0 x n (x0 : x < 0) : 0 < x *~ n = (n < 0).\nProof. by rewrite -(mulr0z x) ltr_nMz2l. Qed.",
    "Lemma pmulrz_rlt0 x n (x0 : 0 < x) : x *~ n < 0 = (n < 0).\nProof. by rewrite -(mulr0z x) ltr_pMz2l. Qed.",
    "Lemma nmulrz_rlt0 x n (x0 : x < 0) : x *~ n < 0 = (0 < n).\nProof. by rewrite -(mulr0z x) ltr_nMz2l. Qed.",
    "Lemma pmulrz_rge0 x n (x0 : 0 < x) : 0 <= x *~ n = (0 <= n).\nProof. by rewrite -(mulr0z x) ler_pMz2l. Qed.",
    "Lemma nmulrz_rge0 x n (x0 : x < 0) : 0 <= x *~ n = (n <= 0).\nProof. by rewrite -(mulr0z x) ler_nMz2l. Qed.",
    "Lemma pmulrz_rle0 x n (x0 : 0 < x) : x *~ n <= 0 = (n <= 0).\nProof. by rewrite -(mulr0z x) ler_pMz2l. Qed.",
    "Lemma nmulrz_rle0 x n (x0 : x < 0) : x *~ n <= 0 = (0 <= n).\nProof. by rewrite -(mulr0z x) ler_nMz2l. Qed.",
    "Lemma mulrIz x (hx : x != 0) : injective ( *~%R x).\nProof.\nmove=> y z; rewrite -![x *~ _]mulrzr => /(mulfI hx).\nby apply: inc_inj y z; exact: ler_pMz2l.\nQed.",
    "Lemma ler_int m n : (m%:~R <= n%:~R :> R) = (m <= n).\nProof. by rewrite ler_pMz2l. Qed.",
    "Lemma ltr_int m n : (m%:~R < n%:~R :> R) = (m < n).\nProof. by rewrite ltr_pMz2l. Qed.",
    "Lemma eqr_int m n : (m%:~R == n%:~R :> R) = (m == n).\nProof. by rewrite (inj_eq (mulrIz _)) ?oner_eq0. Qed.",
    "Lemma ler0z n : (0 <= n%:~R :> R) = (0 <= n).\nProof. by rewrite pmulrz_rge0. Qed.",
    "Lemma ltr0z n : (0 < n%:~R :> R) = (0 < n).\nProof. by rewrite pmulrz_rgt0. Qed.",
    "Lemma lerz0 n : (n%:~R <= 0 :> R) = (n <= 0).\nProof. by rewrite pmulrz_rle0. Qed.",
    "Lemma ltrz0 n : (n%:~R < 0 :> R) = (n < 0).\nProof. by rewrite pmulrz_rlt0. Qed.",
    "Lemma ler1z (n : int) : (1 <= n%:~R :> R) = (1 <= n).\nProof. by rewrite -[1]/(1%:~R) ler_int. Qed.",
    "Lemma ltr1z (n : int) : (1 < n%:~R :> R) = (1 < n).\nProof. by rewrite -[1]/(1%:~R) ltr_int. Qed.",
    "Lemma lerz1 n : (n%:~R <= 1 :> R) = (n <= 1).\nProof. by rewrite -[1]/(1%:~R) ler_int. Qed.",
    "Lemma ltrz1 n : (n%:~R < 1 :> R) = (n < 1).\nProof. by rewrite -[1]/(1%:~R) ltr_int. Qed.",
    "Lemma intr_eq0 n : (n%:~R == 0 :> R) = (n == 0).\nProof. by rewrite -(mulr0z 1) (inj_eq (mulrIz _)) // oner_eq0. Qed.",
    "Lemma mulrz_eq0 x n : (x *~ n == 0) = ((n == 0) || (x == 0)).\nProof. by rewrite -mulrzl mulf_eq0 intr_eq0. Qed.",
    "Lemma mulrz_neq0 x n : x *~ n != 0 = ((n != 0) && (x != 0)).\nProof. by rewrite mulrz_eq0 negb_or. Qed.",
    "Lemma realz n : (n%:~R : R) \\in Num.real.\nProof. by rewrite -topredE /Num.real /= ler0z lerz0 le_total. Qed.",
    "Lemma exprnP x (n : nat) : x ^+ n = x ^ n. Proof. by []. Qed.",
    "Lemma exprnN x (n : nat) : x ^- n = x ^ -n%:Z.\nProof. by case: n=> //; rewrite oppr0 expr0 invr1. Qed.",
    "Lemma expr0z x : x ^ 0 = 1. Proof. by []. Qed.",
    "Lemma expr1z x : x ^ 1 = x. Proof. by []. Qed.",
    "Lemma exprN1 x : x ^ (-1) = x^-1. Proof. by []. Qed.",
    "Lemma invr_expz x n : (x ^ n)^-1 = x ^ (- n).\nProof. by case: (intP n)=> // [|m]; rewrite ?opprK ?expr0z ?invr1 // invrK. Qed.",
    "Lemma exprz_inv x n : (x^-1) ^ n = x ^ (- n).\nProof. by case: (intP n)=> // m; rewrite -[_ ^ (- _)]exprVn ?opprK ?invrK. Qed.",
    "Lemma exp1rz n : 1 ^ n = 1 :> R.\nProof. by case: (intP n)=> // m; rewrite -?exprz_inv ?invr1; apply: expr1n. Qed.",
    "Lemma exprSz x (n : nat) : x ^ n.+1 = x * x ^ n. Proof. exact: exprS. Qed.",
    "Lemma exprSzr x (n : nat) : x ^ n.+1 = x ^ n * x. Proof. exact: exprSr. Qed.",
    "Lemma exprzD_ss x m n : (0 <= m) && (0 <= n) || (m <= 0) && (n <= 0)\n  ->  x ^ (m + n) = x ^ m * x ^ n.\nProof.\ncase: (intP m)=> {m} [|m|m]; case: (intP n)=> {n} [|n|n] //= _;\nby rewrite ?expr0z ?mul1r ?exprzD_nat ?exprzD_Nnat ?sub0r ?addr0 ?mulr1.\nQed.",
    "Lemma exp0rz n : 0 ^ n = (n == 0)%:~R :> R.\nProof. by case: (intP n)=> // m; rewrite -?exprz_inv ?invr0 exprSz mul0r. Qed.",
    "Lemma commrXz x y n : GRing.comm x y -> GRing.comm x (y ^ n).\nProof.\nrewrite /GRing.comm; elim: n x y=> [|n ihn|n ihn] x y com_xy //=.\n* by rewrite expr0z mul1r mulr1.\n* by rewrite -exprnP commrX //.\nrewrite -exprz_inv -exprnP commrX //.\ncase: (boolP (y \\is a GRing.unit))=> uy; last by rewrite invr_out.\nby apply/eqP; rewrite (can2_eq (mulrVK _) (mulrK _)) // -mulrA com_xy mulKr.\nQed.",
    "Lemma exprMz_comm x y n : x \\is a GRing.unit -> y \\is a GRing.unit ->\n  GRing.comm x y -> (x * y) ^ n = x ^ n * y ^ n.\nProof.\nmove=> ux uy com_xy; elim: n => [|n _|n _]; first by rewrite expr0z mulr1.\n  by rewrite -!exprnP exprMn_comm.\nrewrite -!exprnN -!exprVn com_xy -exprMn_comm ?invrM//.\nexact/commrV/commr_sym/commrV.\nQed.",
    "Lemma commrXz_wmulls x y n :\n  0 <= n -> GRing.comm x y -> (x * y) ^ n = x ^ n * y ^ n.\nProof.\nmove=> n0 com_xy; elim: n n0 => [|n _|n _] //; first by rewrite expr0z mulr1.\nby rewrite -!exprnP exprMn_comm.\nQed.",
    "Lemma unitrXz x n (ux : x \\is a GRing.unit) : x ^ n \\is a GRing.unit.\nProof.\ncase: (intP n)=> {n} [|n|n]; rewrite ?expr0z ?unitr1 ?unitrX //.\nby rewrite -invr_expz unitrV unitrX.\nQed.",
    "Lemma exprzDr x (ux : x \\is a GRing.unit) m n : x ^ (m + n) = x ^ m * x ^ n.\nProof.\nmove: n m; apply: wlog_le=> n m hnm.\n  by rewrite addrC hnm commrXz //; exact/commr_sym/commrXz.\ncase: (intP m) hnm=> {m} [|m|m]; rewrite ?mul1r ?add0r //;\n case: (intP n)=> {n} [|n|n _]; rewrite ?mulr1 ?addr0 //;\n   do ?by rewrite exprzD_ss.\nrewrite -invr_expz subzSS !exprSzr invrM ?unitrX // -mulrA mulVKr //.\ncase: (leqP n m)=> [|/ltnW] hmn; rewrite -{2}(subnK hmn) exprzD_nat -subzn //.\n  by rewrite mulrK ?unitrX.\nby rewrite invrM ?unitrXz // mulVKr ?unitrXz // -opprB -invr_expz.\nQed.",
    "Lemma exprz_exp x m n : (x ^ m) ^ n = (x ^ (m * n)).\nProof.\nwlog: n / 0 <= n.\n  by case: n=> [n -> //|n]; rewrite ?NegzE mulrN -?invr_expz=> -> /=.\nelim: n x m=> [|n ihn|n ihn] x m // _; first by rewrite mulr0 !expr0z.\nrewrite exprSz ihn // intS mulrDr mulr1 exprzD_ss //.\nby case: (intP m)=> // m'; rewrite ?oppr_le0 //.\nQed.",
    "Lemma exprzAC x m n : (x ^ m) ^ n = (x ^ n) ^ m.\nProof. by rewrite !exprz_exp mulrC. Qed.",
    "Lemma exprz_out x n (nux : x \\isn't a GRing.unit) (hn : 0 <= n) :\n  x ^ (- n) = x ^ n.\nProof. by case: (intP n) hn=> //= m; rewrite -exprnN -exprVn invr_out. Qed.",
    "Lemma exprz_pMzl x m n : 0 <= n -> (x *~ m) ^ n = x ^ n *~ (m ^ n).\nProof.\nby elim: n=> [|n ihn|n _] // _; rewrite !exprSz ihn // mulrzAr mulrzAl -mulrzA.\nQed.",
    "Lemma exprz_pintl m n (hn : 0 <= n) : m%:~R ^ n = (m ^ n)%:~R :> R.\nProof. by rewrite exprz_pMzl // exp1rz. Qed.",
    "Lemma exprzMzl x m n (ux : x \\is a GRing.unit) (um : m%:~R \\is a @GRing.unit R):\n   (x *~ m) ^ n = (m%:~R ^ n) * x ^ n :> R.\nProof. rewrite -[x *~ _]mulrzl exprMz_comm //; exact/commr_sym/commr_int. Qed.",
    "Lemma expNrz x n : (- x) ^ n = (-1) ^ n * x ^ n :> R.\nProof.\ncase: n=> [] n; rewrite ?NegzE; first exact: exprNn.\nby rewrite -!exprz_inv !invrN invr1; apply: exprNn.\nQed.",
    "Lemma unitr_n0expz x n :\n  n != 0 -> (x ^ n \\is a GRing.unit) = (x \\is a GRing.unit).\nProof.\nby case: n => *; rewrite ?NegzE -?exprz_inv ?unitrX_pos ?unitrV ?lt0n.\nQed.",
    "Lemma intrV (n : int) :\n  n \\in [:: 0; 1; -1] -> n%:~R ^-1 = n%:~R :> R.\nProof.\nby case: (intP n)=> // [|[]|[]] //; rewrite ?rmorphN ?invrN (invr0, invr1).\nQed.",
    "Lemma rmorphXz (R' : unitRingType) (f : {rmorphism R -> R'}) n :\n  {in GRing.unit, {morph f : x / x ^ n}}.\nProof. by case: n => n x Ux; rewrite ?rmorphV ?rpredX ?rmorphXn. Qed.",
    "Lemma expfz_eq0 x n : (x ^ n == 0) = (n != 0) && (x == 0).\nProof.\nby case: n=> n; rewrite ?NegzE -?exprz_inv ?expf_eq0 ?lt0n ?invr_eq0.\nQed.",
    "Lemma expfz_neq0 x n : x != 0 -> x ^ n != 0.\nProof. by move=> x_nz; rewrite expfz_eq0; apply/nandP; right. Qed.",
    "Lemma exprzMl x y n (ux : x \\is a GRing.unit) (uy : y \\is a GRing.unit) :\n  (x * y) ^ n = x ^ n * y ^ n.\nProof. by rewrite exprMz_comm //; apply: mulrC. Qed.",
    "Lemma expfV (x : R) (i : int) : (x ^ i) ^-1 = (x ^-1) ^ i.\nProof. by rewrite invr_expz exprz_inv. Qed.",
    "Lemma expfzDr x m n : x != 0 -> x ^ (m + n) = x ^ m * x ^ n.\nProof. by move=> hx; rewrite exprzDr ?unitfE. Qed.",
    "Lemma expfz_n0addr x m n : m + n != 0 -> x ^ (m + n) = x ^ m * x ^ n.\nProof.\nhave [-> hmn|nx0 _] := eqVneq x 0; last exact: expfzDr.\nrewrite !exp0rz (negPf hmn).\ncase: (eqVneq m 0) hmn => [->|]; rewrite (mul0r, mul1r) //.\nby rewrite add0r=> /negPf->.\nQed.",
    "Lemma expfzMl x y n : (x * y) ^ n = x ^ n * y ^ n.\nProof.\nhave [->|/negPf n0] := eqVneq n 0; first by rewrite !expr0z mulr1.\ncase: (boolP ((x * y) == 0)); rewrite ?mulf_eq0.\n  by case/pred2P=> ->; rewrite ?(mul0r, mulr0, exp0rz, n0).\nby case/norP=> x0 y0; rewrite exprzMl ?unitfE.\nQed.",
    "Lemma fmorphXz (R : unitRingType) (f : {rmorphism F -> R}) n :\n  {morph f : x / x ^ n}.\nProof. by case: n => n x; rewrite ?fmorphV rmorphXn. Qed.",
    "Lemma exprz_ge0 n x (hx : 0 <= x) : (0 <= x ^ n).\nProof. by case: n => n; rewrite ?invr_ge0 ?exprn_ge0. Qed.",
    "Lemma exprz_gt0 n x (hx : 0 < x) : (0 < x ^ n).\nProof. by case: n => n; rewrite ?invr_gt0 ?exprn_gt0. Qed.",
    "Lemma ler_wpiXz2l x (x0 : 0 <= x) (x1 : x <= 1) :\n  {in >= 0 &, {homo exprz x : x y /~ x <= y}}.\nProof.\nmove=> [] m [] n; rewrite -!topredE /= ?oppr_cp0 ?ltz_nat // => _ _.\nby rewrite lez_nat -?exprnP => /ler_wiXn2l; apply.\nQed.",
    "Lemma pexprz_eq1 x n (x0 : 0 <= x) : (x ^ n == 1) = ((n == 0) || (x == 1)).\nProof.\ncase: n=> n; rewrite ?NegzE -?exprz_inv ?oppr_eq0 pexprn_eq1 // ?invr_eq1 //.\nby rewrite invr_ge0.\nQed.",
    "Lemma ler_wpXz2r n (hn : 0 <= n) :\n  {in >= 0 & , {homo (@exprz R)^~ n : x y / x <= y}}.\nProof. by case: n hn=> // n _; exact: lerXn2r. Qed.",
    "Lemma ler_wniXz2l x (x0 : 0 <= x) (x1 : x <= 1) :\n  {in < 0 &, {homo exprz x : x y /~ x <= y}}.\nProof.\nmove=> [] m [] n; rewrite ?NegzE -!topredE /= ?oppr_cp0 ?ltz_nat // => _ _.\nrewrite lerN2 lez_nat -?invr_expz=> hmn; have := x0.\nrewrite le0r=> /predU1P [->|lx0]; first by rewrite !exp0rz invr0.\nby rewrite lef_pV2 -?topredE /= ?exprz_gt0 // ler_wiXn2l.\nQed.",
    "Lemma ler_weXz2l x (x1 : 1 <= x) : {homo exprz x : x y / x <= y}.\nProof.\nmove=> m n /= hmn; case: (lerP 0 m)=> [|/ltW] hm.\n  by rewrite ler_wpeXz2l // [_ \\in _](le_trans hm).\ncase: (lerP n 0)=> [|/ltW] hn.\n  by rewrite ler_wneXz2l // [_ \\in _](le_trans hmn).\napply: (@le_trans _ _ (x ^ 0)); first by rewrite ler_wneXz2l.\nby rewrite ler_wpeXz2l.\nQed.",
    "Lemma ieexprIz x (x0 : 0 < x) (nx1 : x != 1) : injective (exprz x).\nProof.\napply: wlog_lt=> // m n hmn; first by move=> hmn'; rewrite hmn.\nmove=> /(f_equal ( *%R^~ (x ^ (- n)))).\nrewrite -!expfzDr ?gt_eqF // subrr expr0z=> /eqP.\nby rewrite pexprz_eq1 ?(ltW x0) // (negPf nx1) subr_eq0 orbF=> /eqP.\nQed.",
    "Lemma ler_piXz2l x (x0 : 0 < x) (x1 : x < 1) :\n  {in >= 0 &, {mono exprz x : x y /~ x <= y}}.\nProof.\napply: (le_nmono_in (inj_nhomo_lt_in _ _)).\n  by move=> n m hn hm /=; apply: ieexprIz; rewrite // lt_eqF.\nby apply: ler_wpiXz2l; rewrite ?ltW.\nQed.",
    "Lemma ltr_piXz2l x (x0 : 0 < x) (x1 : x < 1) :\n  {in >= 0 &, {mono exprz x : x y /~ x < y}}.\nProof. exact: (leW_nmono_in (ler_piXz2l _ _)). Qed.",
    "Lemma ler_niXz2l x (x0 : 0 < x) (x1 : x < 1) :\n  {in < 0 &, {mono exprz x : x y /~ x <= y}}.\nProof.\napply: (le_nmono_in (inj_nhomo_lt_in _ _)).\n  by move=> n m hn hm /=; apply: ieexprIz; rewrite // lt_eqF.\nby apply: ler_wniXz2l; rewrite ?ltW.\nQed.",
    "Lemma ltr_niXz2l x (x0 : 0 < x) (x1 : x < 1) :\n  {in < 0 &, {mono (exprz x) : x y /~ x < y}}.\nProof. exact: (leW_nmono_in (ler_niXz2l _ _)). Qed.",
    "Lemma ler_eXz2l x (x1 : 1 < x) : {mono exprz x : x y / x <= y}.\nProof.\napply: (le_mono (inj_homo_lt _ _)).\n  by apply: ieexprIz; rewrite ?(lt_trans ltr01) // gt_eqF.\nby apply: ler_weXz2l; rewrite ?ltW.\nQed.",
    "Lemma ltr_eXz2l x (x1 : 1 < x) : {mono exprz x : x y / x < y}.\nProof. exact: (leW_mono (ler_eXz2l _)). Qed.",
    "Lemma ler_wnXz2r n (hn : n <= 0) :\n  {in > 0 & , {homo (@exprz R)^~ n : x y /~ x <= y}}.\nProof.\nmove=> x y /= hx hy hxy; rewrite -lef_pV2 ?[_ \\in _]exprz_gt0 //.\nby rewrite !invr_expz ler_wpXz2r ?[_ \\in _]ltW // oppr_cp0.\nQed.",
    "Lemma pexpIrz n (n0 : n != 0) : {in >= 0 &, injective ((@exprz R)^~ n)}.\nProof.\nmove=> x y; rewrite ![_ \\in _]le0r=> /predU1P [-> _ /eqP|hx].\n  by rewrite exp0rz ?(negPf n0) eq_sym expfz_eq0=> /andP [_ /eqP->].\ncase/predU1P=> [-> /eqP|hy].\n  by rewrite exp0rz ?(negPf n0) expfz_eq0=> /andP [_ /eqP].\nmove=> /(f_equal ( *%R^~ (y ^ (- n)))) /eqP.\nrewrite -expfzDr ?(gt_eqF hy) // subrr expr0z -exprz_inv -expfzMl.\nrewrite pexprz_eq1 ?(negPf n0) /= ?mulr_ge0 ?invr_ge0 ?ltW //.\nby rewrite (can2_eq (mulrVK _) (mulrK _)) ?unitfE ?(gt_eqF hy) // mul1r=> /eqP.\nQed.",
    "Lemma nexpIrz n (n0 : n != 0) : {in <= 0 &, injective ((@exprz R)^~ n)}.\nProof.\nmove=> x y; rewrite ![_ \\in _]le_eqVlt => /predU1P [-> _ /eqP|hx].\n  by rewrite exp0rz ?(negPf n0) eq_sym expfz_eq0=> /andP [_ /eqP->].\ncase/predU1P=> [-> /eqP|hy].\n  by rewrite exp0rz ?(negPf n0) expfz_eq0=> /andP [_ /eqP].\nmove=> /(f_equal ( *%R^~ (y ^ (- n)))) /eqP.\nrewrite -expfzDr ?(lt_eqF hy) // subrr expr0z -exprz_inv -expfzMl.\nrewrite pexprz_eq1 ?(negPf n0) /= ?mulr_le0 ?invr_le0 ?ltW //.\nby rewrite (can2_eq (mulrVK _) (mulrK _)) ?unitfE ?(lt_eqF hy) // mul1r=> /eqP.\nQed.",
    "Lemma ler_pXz2r n (hn : 0 < n) :\n  {in >= 0 & , {mono ((@exprz R)^~ n) : x y / x <= y}}.\nProof.\napply: le_mono_in (inj_homo_lt_in _ _).\n  by move=> x y hx hy /=; apply: pexpIrz; rewrite // gt_eqF.\nby apply: ler_wpXz2r; rewrite ltW.\nQed.",
    "Lemma ltr_pXz2r n (hn : 0 < n) :\n  {in >= 0 & , {mono ((@exprz R)^~ n) : x y / x < y}}.\nProof. exact: leW_mono_in (ler_pXz2r _). Qed.",
    "Lemma ler_nXz2r n (hn : n < 0) :\n  {in > 0 & , {mono ((@exprz R)^~ n) : x y /~ x <= y}}.\nProof.\napply: le_nmono_in (inj_nhomo_lt_in _ _); last first.\n  by apply: ler_wnXz2r; rewrite ltW.\nby move=> x y hx hy /=; apply: pexpIrz; rewrite ?[_ \\in _]ltW ?lt_eqF.\nQed.",
    "Lemma ltr_nXz2r n (hn : n < 0) :\n  {in > 0 & , {mono ((@exprz R)^~ n) : x y /~ x < y}}.\nProof. exact: leW_nmono_in (ler_nXz2r _). Qed.",
    "Lemma eqrXz2 n x y : n != 0 -> 0 <= x -> 0 <= y -> (x ^ n == y ^ n) = (x == y).\nProof. by  move=> *; rewrite (inj_in_eq (pexpIrz _)). Qed.",
    "Lemma sgz_def x : sgz x = (-1) ^+ (x < 0)%R *+ (x != 0).\nProof. by rewrite /sgz; case: (_ == _); case: (_ < _). Qed.",
    "Lemma sgrEz x : sgr x = (sgz x)%:~R. Proof. by rewrite !(fun_if intr). Qed.",
    "Lemma gtr0_sgz x : 0 < x -> sgz x = 1.\nProof. by move=> x_gt0; rewrite /sgz lt_neqAle andbC eq_le lt_geF. Qed.",
    "Lemma ltr0_sgz x : x < 0 -> sgz x = -1.\nProof. by move=> x_lt0; rewrite /sgz eq_sym eq_le x_lt0 lt_geF. Qed.",
    "Lemma sgz0 : sgz (0 : R) = 0. Proof. by rewrite /sgz eqxx. Qed.",
    "Lemma sgz1 : sgz (1 : R) = 1. Proof. by rewrite gtr0_sgz // ltr01. Qed.",
    "Lemma sgzN1 : sgz (-1 : R) = -1. Proof. by rewrite ltr0_sgz // ltrN10. Qed.",
    "Lemma sgz_sgr x : sgz (sgr x) = sgz x.\nProof. by rewrite !(fun_if sgz) !sgzE. Qed.",
    "Lemma normr_sgz x : `|sgz x| = (x != 0).\nProof. by rewrite sgz_def -mulr_natr normrMsign normr_nat natz. Qed.",
    "Lemma normr_sg x : `|sgr x| = (x != 0)%:~R.\nProof. by rewrite sgr_def -mulr_natr normrMsign normr_nat. Qed.",
    "Lemma sgz_int m : sgz (m%:~R : R) = sgz m.\nProof. by rewrite /sgz intr_eq0 ltrz0. Qed.",
    "Lemma sgrz (n : int) : sgr n = sgz n. Proof. by rewrite sgrEz intz. Qed.",
    "Lemma intr_sg m : (sgr m)%:~R = sgr (m%:~R) :> R.\nProof. by rewrite sgrz -sgz_int -sgrEz. Qed.",
    "Lemma sgz_id (x : R) : sgz (sgz x) = sgz x.\nProof. by rewrite !(fun_if (@sgz _)). Qed.",
    "Lemma sgz_cp0 x :\n  ((sgz x == 1) = (0 < x)) *\n  ((sgz x == -1) = (x < 0)) *\n  ((sgz x == 0) = (x == 0)).\nProof. by rewrite /sgz; case: ltrgtP. Qed.",
    "Lemma sgzP x :\n  sgz_val x (0 == x) (x <= 0) (0 <= x) (x == 0) (x < 0) (0 < x)\n  (0 == sgr x) (-1 == sgr x) (1 == sgr x)\n  (sgr x == 0)  (sgr x == -1) (sgr x == 1)\n  (0 == sgz x) (-1 == sgz x) (1 == sgz x)\n  (sgz x == 0)  (sgz x == -1) (sgz x == 1) `|x| (sgr x) (sgz x).\nProof.\nrewrite ![_ == sgz _]eq_sym ![_ == sgr _]eq_sym !sgr_cp0 !sgz_cp0.\nby rewrite /sgz; case: sgrP; constructor.\nQed.",
    "Lemma sgzN x : sgz (- x) = - sgz x.\nProof. by rewrite /sgz oppr_eq0 oppr_lt0; case: ltrgtP. Qed.",
    "Lemma mulz_sg x : sgz x * sgz x = (x != 0)%:~R.\nProof. by case: sgzP; rewrite ?(mulr0, mulr1, mulrNN). Qed.",
    "Lemma mulz_sg_eq1 x y : (sgz x * sgz y == 1) = (x != 0) && (sgz x == sgz y).\nProof.\ndo 2?case: sgzP=> _; rewrite ?(mulr0, mulr1, mulrN1, opprK, oppr0, eqxx);\n  by rewrite ?[0 == 1]eq_sym ?oner_eq0 //= eqr_oppLR oppr0 oner_eq0.\nQed.",
    "Lemma mulz_sg_eqN1 x y : (sgz x * sgz y == -1) = (x != 0) && (sgz x == - sgz y).\nProof. by rewrite -eqr_oppLR -mulrN -sgzN mulz_sg_eq1. Qed.",
    "Lemma sgzM x y : sgz (x * y) = sgz x * sgz y.\nProof.\nrewrite -sgz_sgr -(sgz_sgr x) -(sgz_sgr y) sgrM.\nby case: sgrP; case: sgrP; rewrite /sgz ?(mulNr, mul0r, mul1r);\n  rewrite ?(oppr_eq0, oppr_cp0, eqxx, ltxx, ltr01, ltr10, oner_eq0).\nQed.",
    "Lemma sgzX (n : nat) x : sgz (x ^+ n) = (sgz x) ^+ n.\nProof. by elim: n => [|n IHn]; rewrite ?sgz1 // !exprS sgzM IHn. Qed.",
    "Lemma sgz_eq0 x : (sgz x == 0) = (x == 0).\nProof. by rewrite sgz_cp0. Qed.",
    "Lemma sgz_odd (n : nat) x : x != 0 -> (sgz x) ^+ n = (sgz x) ^+ (odd n).\nProof. by case: sgzP => //=; rewrite ?expr1n // signr_odd. Qed.",
    "Lemma sgz_gt0 x : (sgz x > 0) = (x > 0).\nProof. by case: sgzP. Qed.",
    "Lemma sgz_lt0 x : (sgz x < 0) = (x < 0).\nProof. by case: sgzP. Qed.",
    "Lemma sgz_ge0 x : (sgz x >= 0) = (x >= 0).\nProof. by case: sgzP. Qed.",
    "Lemma sgz_le0 x : (sgz x <= 0) = (x <= 0).\nProof. by case: sgzP. Qed.",
    "Lemma sgz_smul x y : sgz (y *~ (sgz x)) = (sgz x) * (sgz y).\nProof. by rewrite -mulrzl sgzM -sgrEz sgz_sgr. Qed.",
    "Lemma sgrMz m x : sgr (x *~ m) = sgr x *~ sgr m.\nProof. by rewrite -mulrzr sgrM -intr_sg mulrzr. Qed.",
    "Lemma sgz_eq (R R' : realDomainType) (x : R) (y : R') :\n  (sgz x == sgz y) = ((x == 0) == (y == 0)) && ((0 < x) == (0 < y)).\nProof. by do 2!case: sgzP. Qed.",
    "Lemma intr_sign (R : pzRingType) s : ((-1) ^+ s)%:~R = (-1) ^+ s :> R.\nProof. exact: rmorph_sign. Qed.",
    "Lemma absz_nat (n : nat) : `|n| = n. Proof. by []. Qed.",
    "Lemma abszE (m : int) : `|m| = `|m|%R :> int. Proof. by []. Qed.",
    "Lemma absz0 : `|0%R| = 0. Proof. by []. Qed.",
    "Lemma abszN m : `|- m| = `|m|. Proof. by case: (normrN m). Qed.",
    "Lemma absz_eq0 m : (`|m| == 0) = (m == 0%R). Proof. by case: (intP m). Qed.",
    "Lemma absz_gt0 m : (`|m| > 0) = (m != 0%R). Proof. by case: (intP m). Qed.",
    "Lemma absz1 : `|1%R| = 1. Proof. by []. Qed.",
    "Lemma abszN1 : `|-1%R| = 1. Proof. by []. Qed.",
    "Lemma absz_id m : `|(`|m|)| = `|m|. Proof. by []. Qed.",
    "Lemma abszM m1 m2 : `|(m1 * m2)%R| = `|m1| * `|m2|.\nProof. by case: m1 m2 => [[|m1]|m1] [[|m2]|m2] //=; rewrite ?mulnS mulnC. Qed.",
    "Lemma abszX (n : nat) m : `|m ^+ n| = `|m| ^ n.\nProof. by elim: n => // n ihn; rewrite exprS expnS abszM ihn. Qed.",
    "Lemma absz_sg m : `|sgr m| = (m != 0%R). Proof. by case: (intP m). Qed.",
    "Lemma gez0_abs m : (0 <= m)%R -> `|m| = m :> int.\nProof. by case: (intP m). Qed.",
    "Lemma gtz0_abs m : (0 < m)%R -> `|m| = m :> int.\nProof. by case: (intP m). Qed.",
    "Lemma lez0_abs m : (m <= 0)%R -> `|m| = - m :> int.\nProof. by case: (intP m). Qed.",
    "Lemma ltz0_abs m : (m < 0)%R -> `|m| = - m :> int.\nProof. by case: (intP m). Qed.",
    "Lemma lez_abs m : m <= `|m|%N :> int.\nProof. by case: (intP m). Qed.",
    "Lemma absz_sign s : `|(-1) ^+ s| = 1.\nProof. by rewrite abszX exp1n. Qed.",
    "Lemma abszMsign s m : `|((-1) ^+ s * m)%R| = `|m|.\nProof. by rewrite abszM absz_sign mul1n. Qed.",
    "Lemma mulz_sign_abs m : ((-1) ^+ (m < 0)%R * `|m|%:Z)%R = m.\nProof. by rewrite abszE mulr_sign_norm. Qed.",
    "Lemma mulz_Nsign_abs m : ((-1) ^+ (0 < m)%R * `|m|%:Z)%R = - m.\nProof. by rewrite abszE mulr_Nsign_norm. Qed.",
    "Lemma intEsign  m : m = ((-1) ^+ (m < 0)%R * `|m|%:Z)%R.\nProof. exact: numEsign. Qed.",
    "Lemma abszEsign m : `|m|%:Z = ((-1) ^+ (m < 0)%R * m)%R.\nProof. exact: normrEsign. Qed.",
    "Lemma intEsg m : m = (sgz m * `|m|%:Z)%R.\nProof. by rewrite -sgrz -numEsg. Qed.",
    "Lemma abszEsg m : (`|m|%:Z = sgz m * m)%R.\nProof. by rewrite -sgrz -normrEsg. Qed.",
    "Lemma mulr_absz (x : R) i : x *+ `|i| = x *~ `|i|.\nProof. by rewrite -abszE. Qed.",
    "Lemma natr_absz i : `|i|%:R = `|i|%:~R :> R.\nProof. by rewrite -abszE. Qed.",
    "Lemma distnC m1 m2 : `|m1 - m2| = `|m2 - m1|.\nProof. by rewrite -opprB abszN. Qed.",
    "Lemma distnDl d n1 n2 : `|d + n1 - (d + n2)| = `|n1 - n2|.\nProof. by rewrite !PoszD opprD addrCA -addrA addKr. Qed.",
    "Lemma distnDr d n1 n2 : `|n1 + d - (n2 + d)| = `|n1 - n2|.\nProof. by rewrite -!(addnC d) distnDl. Qed.",
    "Lemma distnEr n1 n2 : n1 <= n2 -> `|n1 - n2| = n2 - n1.\nProof. by move/subnK=> {1}<-; rewrite distnC PoszD addrK absz_nat. Qed.",
    "Lemma distnEl n1 n2 : n2 <= n1 -> `|n1 - n2| = n1 - n2.\nProof. by move/distnEr <-; rewrite distnC. Qed.",
    "Lemma distn0 n : `|n - 0| = n.\nProof. by rewrite subr0 absz_nat. Qed.",
    "Lemma dist0n n : `|0 - n| = n.\nProof. by rewrite distnC distn0. Qed.",
    "Lemma distnn m : `|m - m| = 0.\nProof. by rewrite subrr. Qed.",
    "Lemma distn_eq0 n1 n2 : (`|n1 - n2| == 0) = (n1 == n2).\nProof. by rewrite absz_eq0 subr_eq0. Qed.",
    "Lemma distnS n : `|n - n.+1| = 1.\nProof. exact: distnDr n 0 1. Qed.",
    "Lemma distSn n : `|n.+1 - n| = 1.\nProof. exact: distnDr n 1 0. Qed.",
    "Lemma distn_eq1 n1 n2 :\n  (`|n1 - n2| == 1) = (if n1 < n2 then n1.+1 == n2 else n1 == n2.+1).\nProof.\ncase: ltnP => [lt_n12 | le_n21].\n  by rewrite eq_sym -(eqn_add2r n1) distnEr ?subnK // ltnW.\nby rewrite -(eqn_add2r n2) distnEl ?subnK.\nQed.",
    "Lemma leqD_dist  m1 m2 m3 : `|m1 - m3| <= `|m1 - m2| + `|m2 - m3|.\nProof. by rewrite -lez_nat PoszD !abszE ler_distD. Qed.",
    "Lemma leqifD_distz m1 m2 m3 :\n  `|m1 - m3| <= `|m1 - m2| + `|m2 - m3|\n             ?= iff (m1 <= m2 <= m3)%R || (m3 <= m2 <= m1)%R.\nProof.\napply/leqifP; rewrite -ltz_nat -eqz_nat PoszD !abszE; apply/leifP.\nwlog le_m31 : m1 m3 / (m3 <= m1)%R.\n  move=> IH; case/orP: (le_total m1 m3) => /IH //.\n  by rewrite (addrC `|_|)%R orbC !(distrC m1) !(distrC m3).\nrewrite ger0_norm ?subr_ge0 // orb_idl => [|/andP[le_m12 le_m23]]; last first.\n  by have /eqP->: m2 == m3; rewrite ?lexx // eq_le le_m23 (le_trans le_m31).\nrewrite -{1}(subrK m2 m1) -(addrA _ m2) -subr_ge0 andbC -[X in X && _]subr_ge0.\nby apply: leifD; apply/real_leif_norm/num_real.\nQed.",
    "Lemma leqifD_dist n1 n2 n3 :\n  `|n1 - n3| <= `|n1 - n2| + `|n2 - n3|\n             ?= iff (n1 <= n2 <= n3) || (n3 <= n2 <= n1).\nProof. exact: leqifD_distz. Qed.",
    "Lemma sqrn_dist n1 n2 : `|n1 - n2| ^ 2 + 2 * (n1 * n2) = n1 ^ 2 + n2 ^ 2.\nProof.\nwlog le_n21: n1 n2 / n2 <= n1.\n  move=> IH; case/orP: (leq_total n2 n1) => /IH //.\n  by rewrite (addnC (n2 ^ 2)) (mulnC n2) distnC.\nby rewrite distnEl ?sqrnB ?subnK ?nat_Cauchy.\nQed.",
    "Lemma intr_norm m : `|m|%:~R = `|m%:~R : R|.\nProof. by rewrite {2}[m]intEsign rmorphMsign normrMsign abszE normr_nat. Qed.",
    "Lemma normrMz m (x : R) : `|x *~ m| = `|x| *~ `|m|.\nProof. by rewrite -mulrzl normrM -intr_norm mulrzl. Qed.",
    "Lemma expN1r (i : int) : (-1 : R) ^ i = (-1) ^+ `|i|.\nProof.\ncase: i => n; first by rewrite exprnP absz_nat.\nby rewrite NegzE abszN  absz_nat -invr_expz expfV invrN1.\nQed.",
    "Lemma coefMrz p n i : (p *~ n)`_i = (p`_i *~ n).\nProof. by case: n => n; rewrite ?NegzE (coefMNn, coefMn). Qed.",
    "Lemma polyCMz n : {morph (@polyC R) : c / c *~ n}.\nProof. by case: (intP n) => // n' c; rewrite ?mulrNz ?polyCN polyCMn. Qed.",
    "Lemma hornerMz n p x : (p *~ n).[x] = p.[x] *~ n.\nProof. by case: n => n; rewrite ?NegzE ?mulNzr ?(hornerN, hornerMn). Qed.",
    "Lemma horner_int n x : (n%:~R : {poly R}).[x] = n%:~R.\nProof. by rewrite hornerMz hornerC. Qed.",
    "Lemma derivMz n p : (p *~ n)^`() = p^`() *~ n.\nProof. by case: n => n; rewrite ?NegzE -?pmulrn (derivMn, derivMNn). Qed.",
    "Lemma mulpz p n : p *~ n = n%:~R *: p.\nProof. by rewrite -mul_polyC polyCMz polyC1 mulrzl. Qed.",
    "Lemma rpredMz (M : zmodType) (S : zmodClosed M) m :\n  {in S, forall u, u *~ m \\in S}.\nProof. by case: m => n u Su; rewrite ?rpredN ?rpredMn. Qed.",
    "Lemma rpred_int (R : pzRingType) (S : subringClosed R) m : m%:~R \\in S.\nProof. by rewrite rpredMz ?rpred1. Qed.",
    "Lemma rpredZint (R : pzRingType) (M : lmodType R) (S : zmodClosed M) m :\n  {in S, forall u, m%:~R *: u \\in S}.\nProof. by move=> u Su; rewrite /= scaler_int rpredMz. Qed.",
    "Lemma rpredXz (R : unitRingType) (S : divClosed R) m :\n  {in S, forall x, x ^ m \\in S}.\nProof. by case: m => n x Sx; rewrite ?rpredV rpredX. Qed.",
    "Lemma rpredXsign (R : unitRingType) (S : divClosed R) n x :\n  (x ^ ((-1) ^+ n) \\in S) = (x \\in S).\nProof. by rewrite -signr_odd; case: (odd n); rewrite ?rpredV. Qed.",
    "Lemma mxE k F : matrix_of_fun k F =2 F.\nProof. by move=> i j; rewrite unlock /fun_of_matrix /= ffunE. Qed.",
    "Lemma matrixP (A B : matrix R m n) : A =2 B <-> A = B.\nProof.\nrewrite /fun_of_matrix; split=> [/= eqAB | -> //].\nby apply/val_inj/ffunP=> [[i j]]; apply: eqAB.\nQed.",
    "Lemma eq_mx k F1 F2 : (F1 =2 F2) -> matrix_of_fun k F1 = matrix_of_fun k F2.\nProof. by move=> eq_F; apply/matrixP => i j; rewrite !mxE eq_F. Qed.",
    "Lemma card_mx (F : finType) m n : (#|{: 'M[F]_(m, n)}| = #|F| ^ (m * n))%N.\nProof. by rewrite card_sub card_ffun card_prod !card_ord. Qed.",
    "Lemma castmx_const m' n' (eq_mn : (m = m') * (n = n')) a :\n  castmx eq_mn (const_mx a) = const_mx a.\nProof. by case: eq_mn; case: m' /; case: n' /. Qed.",
    "Lemma trmx_const a : trmx (const_mx a) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma row_perm_const s a : row_perm s (const_mx a) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma col_perm_const s a : col_perm s (const_mx a) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma xrow_const i1 i2 a : xrow i1 i2 (const_mx a) = const_mx a.\nProof. exact: row_perm_const. Qed.",
    "Lemma xcol_const j1 j2 a : xcol j1 j2 (const_mx a) = const_mx a.\nProof. exact: col_perm_const. Qed.",
    "Lemma rowP (u v : 'rV[R]_n) : u 0 =1 v 0 <-> u = v.\nProof. by split=> [eq_uv | -> //]; apply/matrixP=> i; rewrite ord1. Qed.",
    "Lemma rowK u_ i0 : row i0 (\\matrix_i u_ i) = u_ i0.\nProof. by apply/rowP=> i'; rewrite !mxE. Qed.",
    "Lemma row_matrixP A B : (forall i, row i A = row i B) <-> A = B.\nProof.\nsplit=> [eqAB | -> //]; apply/matrixP=> i j.\nby move/rowP/(_ j): (eqAB i); rewrite !mxE.\nQed.",
    "Lemma colP (u v : 'cV[R]_m) : u^~ 0 =1 v^~ 0 <-> u = v.\nProof. by split=> [eq_uv | -> //]; apply/matrixP=> i j; rewrite ord1. Qed.",
    "Lemma row_const i0 a : row i0 (const_mx a) = const_mx a.\nProof. by apply/rowP=> j; rewrite !mxE. Qed.",
    "Lemma col_const j0 a : col j0 (const_mx a) = const_mx a.\nProof. by apply/colP=> i; rewrite !mxE. Qed.",
    "Lemma row'_const i0 a : row' i0 (const_mx a) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma col'_const j0 a : col' j0 (const_mx a) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma col_perm1 A : col_perm 1 A = A.\nProof. by apply/matrixP=> i j; rewrite mxE perm1. Qed.",
    "Lemma row_perm1 A : row_perm 1 A = A.\nProof. by apply/matrixP=> i j; rewrite mxE perm1. Qed.",
    "Lemma col_permM s t A : col_perm (s * t) A = col_perm s (col_perm t A).\nProof. by apply/matrixP=> i j; rewrite !mxE permM. Qed.",
    "Lemma row_permM s t A : row_perm (s * t) A = row_perm s (row_perm t A).\nProof. by apply/matrixP=> i j; rewrite !mxE permM. Qed.",
    "Lemma col_row_permC s t A :\n  col_perm s (row_perm t A) = row_perm t (col_perm s A).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma rowEsub i : row i = rowsub (fun=> i). Proof. by []. Qed.",
    "Lemma colEsub j : col j = colsub (fun=> j). Proof. by []. Qed.",
    "Lemma row'Esub i : row' i = rowsub (lift i). Proof. by []. Qed.",
    "Lemma col'Esub j : col' j = colsub (lift j). Proof. by []. Qed.",
    "Lemma row_permEsub s : row_perm s = rowsub s.\nProof. by rewrite /row_perm /mxsub !unlock. Qed.",
    "Lemma col_permEsub s : col_perm s = colsub s.\nProof. by rewrite /col_perm /mxsub !unlock. Qed.",
    "Lemma xrowEsub i1 i2 : xrow i1 i2 = rowsub (tperm i1 i2).\nProof. exact: row_permEsub. Qed.",
    "Lemma xcolEsub j1 j2 : xcol j1 j2 = colsub (tperm j1 j2).\nProof. exact: col_permEsub. Qed.",
    "Lemma mxsub_id : mxsub id id =1 id.\nProof. by move=> A; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma eq_mxsub m' n' f f' g g' : f =1 f' -> g =1 g' ->\n  @mxsub m' n' f g =1 mxsub f' g'.\nProof. by move=> eq_f eq_g A; apply/matrixP => i j; rewrite !mxE eq_f eq_g. Qed.",
    "Lemma eq_rowsub m' (f f' : 'I_m' -> 'I_m) : f =1 f' -> rowsub f =1 rowsub f'.\nProof. by move=> /eq_mxsub; apply. Qed.",
    "Lemma eq_colsub n' (g g' : 'I_n' -> 'I_n) : g =1 g' -> colsub g =1 colsub g'.\nProof. by move=> /eq_mxsub; apply. Qed.",
    "Lemma mxsub_eq_id f g : f =1 id -> g =1 id -> mxsub f g =1 id.\nProof. by move=> fid gid A; rewrite (eq_mxsub fid gid) mxsub_id. Qed.",
    "Lemma mxsub_eq_colsub n' f g : f =1 id -> @mxsub _ n' f g =1 colsub g.\nProof. by move=> f_id; apply: eq_mxsub. Qed.",
    "Lemma mxsub_eq_rowsub m' f g : g =1 id -> @mxsub m' _ f g =1 rowsub f.\nProof. exact: eq_mxsub. Qed.",
    "Lemma mxsub_ffunl m' n' f g : @mxsub m' n' (finfun f) g =1 mxsub f g.\nProof. by apply: eq_mxsub => // i; rewrite ffunE. Qed.",
    "Lemma mxsub_ffunr m' n' f g : @mxsub m' n' f (finfun g) =1 mxsub f g.\nProof. by apply: eq_mxsub => // i; rewrite ffunE. Qed.",
    "Lemma mxsub_ffun m' n' f g : @mxsub m' n' (finfun f) (finfun g) =1 mxsub f g.\nProof. by move=> A; rewrite mxsub_ffunl mxsub_ffunr. Qed.",
    "Lemma mxsub_const m' n' f g a : @mxsub m' n' f g (const_mx a) = const_mx a.\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma castmx_id m n erefl_mn (A : 'M_(m, n)) : castmx erefl_mn A = A.\nProof. by case: erefl_mn => e_m e_n; rewrite [e_m]eq_axiomK [e_n]eq_axiomK. Qed.",
    "Lemma castmx_comp m1 n1 m2 n2 m3 n3 (eq_m1 : m1 = m2) (eq_n1 : n1 = n2)\n                                    (eq_m2 : m2 = m3) (eq_n2 : n2 = n3) A :\n  castmx (eq_m2, eq_n2) (castmx (eq_m1, eq_n1) A)\n    = castmx (etrans eq_m1 eq_m2, etrans eq_n1 eq_n2) A.\nProof.\nby case: m2 / eq_m1 eq_m2; case: m3 /; case: n2 / eq_n1 eq_n2; case: n3 /.\nQed.",
    "Lemma castmxK m1 n1 m2 n2 (eq_m : m1 = m2) (eq_n : n1 = n2) :\n  cancel (castmx (eq_m, eq_n)) (castmx (esym eq_m, esym eq_n)).\nProof. by case: m2 / eq_m; case: n2 / eq_n. Qed.",
    "Lemma castmxKV m1 n1 m2 n2 (eq_m : m1 = m2) (eq_n : n1 = n2) :\n  cancel (castmx (esym eq_m, esym eq_n)) (castmx (eq_m, eq_n)).\nProof. by case: m2 / eq_m; case: n2 / eq_n. Qed.",
    "Lemma castmx_sym m1 n1 m2 n2 (eq_m : m1 = m2) (eq_n : n1 = n2) A1 A2 :\n  A1 = castmx (eq_m, eq_n) A2 -> A2 = castmx (esym eq_m, esym eq_n) A1.\nProof. by move/(canLR (castmxK _ _)). Qed.",
    "Lemma eq_castmx m1 n1 m2 n2 (eq_mn eq_mn' : (m1 = m2) * (n1 = n2)) :\n  castmx eq_mn =1 castmx eq_mn'.\nProof.\ncase: eq_mn eq_mn' => [em en] [em' en'] A.\nby apply: (canRL (castmxKV _ _)); rewrite castmx_comp castmx_id.\nQed.",
    "Lemma castmxE m1 n1 m2 n2 (eq_mn : (m1 = m2) * (n1 = n2)) A i j :\n  castmx eq_mn A i j =\n     A (cast_ord (esym eq_mn.1) i) (cast_ord (esym eq_mn.2) j).\nProof.\nby do [case: eq_mn; case: m2 /; case: n2 /] in A i j *; rewrite !cast_ord_id.\nQed.",
    "Lemma conform_mx_id m n (B A : 'M_(m, n)) : conform_mx B A = A.\nProof. by rewrite /conform_mx; do 2!case: eqP => // *; rewrite castmx_id. Qed.",
    "Lemma nonconform_mx m m' n n' (B : 'M_(m', n')) (A : 'M_(m, n)) :\n  (m != m') || (n != n') -> conform_mx B A = B.\nProof. by rewrite /conform_mx; do 2!case: eqP. Qed.",
    "Lemma conform_castmx m1 n1 m2 n2 m3 n3\n                     (e_mn : (m2 = m3) * (n2 = n3)) (B : 'M_(m1, n1)) A :\n  conform_mx B (castmx e_mn A) = conform_mx B A.\nProof. by do [case: e_mn; case: m3 /; case: n3 /] in A *. Qed.",
    "Lemma trmxK m n : cancel (@trmx m n) (@trmx n m).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma trmx_inj m n : injective (@trmx m n).\nProof. exact: can_inj (@trmxK m n). Qed.",
    "Lemma trmx_cast m1 n1 m2 n2 (eq_mn : (m1 = m2) * (n1 = n2)) A :\n  (castmx eq_mn A)^T = castmx (eq_mn.2, eq_mn.1) A^T.\nProof.\nby case: eq_mn => eq_m eq_n; apply/matrixP=> i j; rewrite !(mxE, castmxE).\nQed.",
    "Lemma trmx_conform m' n' m n (B : 'M_(m', n')) (A : 'M_(m, n)) :\n  (conform_mx B A)^T = conform_mx B^T A^T.\nProof.\nrewrite /conform_mx; do !case: eqP; rewrite ?mxE// => en em.\nby rewrite trmx_cast.\nQed.",
    "Lemma tr_row_perm m n s (A : 'M_(m, n)) : (row_perm s A)^T = col_perm s A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_col_perm m n s (A : 'M_(m, n)) : (col_perm s A)^T = row_perm s A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_xrow m n i1 i2 (A : 'M_(m, n)) : (xrow i1 i2 A)^T = xcol i1 i2 A^T.\nProof. exact: tr_row_perm. Qed.",
    "Lemma tr_xcol m n j1 j2 (A : 'M_(m, n)) : (xcol j1 j2 A)^T = xrow j1 j2 A^T.\nProof. exact: tr_col_perm. Qed.",
    "Lemma row_id n i (V : 'rV_n) : row i V = V.\nProof. by apply/rowP=> j; rewrite mxE [i]ord1. Qed.",
    "Lemma col_id n j (V : 'cV_n) : col j V = V.\nProof. by apply/colP=> i; rewrite mxE [j]ord1. Qed.",
    "Lemma row_eq m1 m2 n i1 i2 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  row i1 A1 = row i2 A2 -> A1 i1 =1 A2 i2.\nProof. by move/rowP=> eqA12 j; have /[!mxE] := eqA12 j. Qed.",
    "Lemma col_eq m n1 n2 j1 j2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  col j1 A1 = col j2 A2 -> A1^~ j1 =1 A2^~ j2.\nProof. by move/colP=> eqA12 i; have /[!mxE] := eqA12 i. Qed.",
    "Lemma row'_eq m n i0 (A B : 'M_(m, n)) :\n  row' i0 A = row' i0 B -> {in predC1 i0, A =2 B}.\nProof.\nmove=> /matrixP eqAB' i /[!inE]/[1!eq_sym]/unlift_some[i' -> _] j.\nby have /[!mxE] := eqAB' i' j.\nQed.",
    "Lemma col'_eq m n j0 (A B : 'M_(m, n)) :\n  col' j0 A = col' j0 B -> forall i, {in predC1 j0, A i =1 B i}.\nProof.\nmove=> /matrixP eqAB' i j /[!inE]/[1!eq_sym]/unlift_some[j' -> _].\nby have  /[!mxE] := eqAB' i j'.\nQed.",
    "Lemma tr_row m n i0 (A : 'M_(m, n)) : (row i0 A)^T = col i0 A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_row' m n i0 (A : 'M_(m, n)) : (row' i0 A)^T = col' i0 A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_col m n j0 (A : 'M_(m, n)) : (col j0 A)^T = row j0 A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_col' m n j0 (A : 'M_(m, n)) : (col' j0 A)^T = row' j0 A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxsub_comp m1 m2 m3 n1 n2 n3\n  (f : 'I_m2 -> 'I_m1) (f' : 'I_m3 -> 'I_m2)\n  (g : 'I_n2 -> 'I_n1) (g' : 'I_n3 -> 'I_n2) (A : 'M_(m1, n1)) :\n  mxsub (f \\o f') (g \\o g') A = mxsub f' g' (mxsub f g A).\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma rowsub_comp m1 m2 m3 n\n  (f : 'I_m2 -> 'I_m1) (f' : 'I_m3 -> 'I_m2) (A : 'M_(m1, n)) :\n  rowsub (f \\o f') A = rowsub f' (rowsub f A).\nProof. exact: mxsub_comp. Qed.",
    "Lemma colsub_comp m n n2 n3\n  (g : 'I_n2 -> 'I_n) (g' : 'I_n3 -> 'I_n2) (A : 'M_(m, n)) :\n  colsub (g \\o g') A = colsub g' (colsub g A).\nProof. exact: mxsub_comp. Qed.",
    "Lemma mxsubrc m1 m2 n n2 f g (A : 'M_(m1, n)) :\n  mxsub f g A = rowsub f (colsub g A) :> 'M_(m2, n2).\nProof. exact: mxsub_comp. Qed.",
    "Lemma mxsubcr m1 m2 n n2 f g (A : 'M_(m1, n)) :\n  mxsub f g A = colsub g (rowsub f A) :> 'M_(m2, n2).\nProof. exact: mxsub_comp. Qed.",
    "Lemma rowsub_cast m1 m2 n (eq_m : m1 = m2) (A : 'M_(m2, n)) :\n  rowsub (cast_ord eq_m) A = castmx (esym eq_m, erefl) A.\nProof. by case: _ / eq_m in A *; apply: (mxsub_eq_id (cast_ord_id _)). Qed.",
    "Lemma colsub_cast m n1 n2 (eq_n : n1 = n2) (A : 'M_(m, n2)) :\n  colsub (cast_ord eq_n) A = castmx (erefl, esym eq_n) A.\nProof. by case: _ / eq_n in A *; apply: (mxsub_eq_id _ (cast_ord_id _)). Qed.",
    "Lemma mxsub_cast m1 m2 n1 n2 (eq_m : m1 = m2) (eq_n : n1 = n2) A :\n  mxsub (cast_ord eq_m) (cast_ord eq_n) A = castmx (esym eq_m, esym eq_n) A.\nProof. by rewrite mxsubrc rowsub_cast colsub_cast castmx_comp/= etrans_id. Qed.",
    "Lemma castmxEsub m1 m2 n1 n2 (eq_mn : (m1 = m2) * (n1 = n2)) A :\n  castmx eq_mn A = mxsub (cast_ord (esym eq_mn.1)) (cast_ord (esym eq_mn.2)) A.\nProof. by rewrite mxsub_cast !esymK; case: eq_mn. Qed.",
    "Lemma trmx_mxsub m1 m2 n1 n2 f g (A : 'M_(m1, n1)) :\n  (mxsub f g A)^T = mxsub g f A^T :> 'M_(n2, m2).\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma row_mxsub m1 m2 n1 n2\n    (f : 'I_m2 -> 'I_m1) (g : 'I_n2 -> 'I_n1) (A : 'M_(m1, n1)) i :\n  row i (mxsub f g A) = row (f i) (colsub g A).\nProof. by rewrite !rowEsub -!mxsub_comp. Qed.",
    "Lemma col_mxsub m1 m2 n1 n2\n    (f : 'I_m2 -> 'I_m1) (g : 'I_n2 -> 'I_n1) (A : 'M_(m1, n1)) i :\n col i (mxsub f g A) = col (g i) (rowsub f A).\nProof. by rewrite !colEsub -!mxsub_comp. Qed.",
    "Lemma row_rowsub m1 m2 n (f : 'I_m2 -> 'I_m1) (A : 'M_(m1, n)) i :\n  row i (rowsub f A) = row (f i) A.\nProof. by rewrite row_mxsub mxsub_id. Qed.",
    "Lemma col_colsub m n1 n2 (g : 'I_n2 -> 'I_n1) (A : 'M_(m, n1)) i :\n  col i (colsub g A) = col (g i) A.\nProof. by rewrite col_mxsub mxsub_id. Qed.",
    "Lemma row_mxEl A1 A2 i j : row_mx A1 A2 i (lshift n2 j) = A1 i j.\nProof. by rewrite mxE (unsplitK (inl _ _)). Qed.",
    "Lemma row_mxKl A1 A2 : lsubmx (row_mx A1 A2) = A1.\nProof. by apply/matrixP=> i j; rewrite mxE row_mxEl. Qed.",
    "Lemma row_mxEr A1 A2 i j : row_mx A1 A2 i (rshift n1 j) = A2 i j.\nProof. by rewrite mxE (unsplitK (inr _ _)). Qed.",
    "Lemma row_mxKr A1 A2 : rsubmx (row_mx A1 A2) = A2.\nProof. by apply/matrixP=> i j; rewrite mxE row_mxEr. Qed.",
    "Lemma hsubmxK A : row_mx (lsubmx A) (rsubmx A) = A.\nProof. by apply/matrixP=> i j /[!mxE]; case: split_ordP => k -> /[!mxE]. Qed.",
    "Lemma col_mxEu A1 A2 i j : col_mx A1 A2 (lshift m2 i) j = A1 i j.\nProof. by rewrite mxE (unsplitK (inl _ _)). Qed.",
    "Lemma col_mxKu A1 A2 : usubmx (col_mx A1 A2) = A1.\nProof. by apply/matrixP=> i j; rewrite mxE col_mxEu. Qed.",
    "Lemma col_mxEd A1 A2 i j : col_mx A1 A2 (rshift m1 i) j = A2 i j.\nProof. by rewrite mxE (unsplitK (inr _ _)). Qed.",
    "Lemma col_mxKd A1 A2 : dsubmx (col_mx A1 A2) = A2.\nProof. by apply/matrixP=> i j; rewrite mxE col_mxEd. Qed.",
    "Lemma lsubmxEsub : lsubmx = colsub (lshift _).\nProof. by rewrite /lsubmx /mxsub !unlock. Qed.",
    "Lemma rsubmxEsub : rsubmx = colsub (@rshift _ _).\nProof. by rewrite /rsubmx /mxsub !unlock. Qed.",
    "Lemma usubmxEsub : usubmx = rowsub (lshift _).\nProof. by rewrite /usubmx /mxsub !unlock. Qed.",
    "Lemma dsubmxEsub  : dsubmx = rowsub (@rshift _ _).\nProof. by rewrite /dsubmx /mxsub !unlock. Qed.",
    "Lemma eq_row_mx A1 A2 B1 B2 : row_mx A1 A2 = row_mx B1 B2 -> A1 = B1 /\\ A2 = B2.\nProof.\nmove=> eqAB; move: (congr1 lsubmx eqAB) (congr1 rsubmx eqAB).\nby rewrite !(row_mxKl, row_mxKr).\nQed.",
    "Lemma eq_col_mx A1 A2 B1 B2 : col_mx A1 A2 = col_mx B1 B2 -> A1 = B1 /\\ A2 = B2.\nProof.\nmove=> eqAB; move: (congr1 usubmx eqAB) (congr1 dsubmx eqAB).\nby rewrite !(col_mxKu, col_mxKd).\nQed.",
    "Lemma row_mx_const a : row_mx (const_mx a) (const_mx a) = const_mx a.\nProof. by split_mxE. Qed.",
    "Lemma col_mx_const a : col_mx (const_mx a) (const_mx a) = const_mx a.\nProof. by split_mxE. Qed.",
    "Lemma row_usubmx A i : row i (usubmx A) = row (lshift m2 i) A.\nProof. by apply/rowP=> j; rewrite !mxE; congr (A _ _); apply/val_inj. Qed.",
    "Lemma row_dsubmx A i : row i (dsubmx A) = row (rshift m1 i) A.\nProof. by apply/rowP=> j; rewrite !mxE; congr (A _ _); apply/val_inj. Qed.",
    "Lemma col_lsubmx A i : col i (lsubmx A) = col (lshift n2 i) A.\nProof. by apply/colP=> j; rewrite !mxE; congr (A _ _); apply/val_inj. Qed.",
    "Lemma col_rsubmx A i : col i (rsubmx A) = col (rshift n1 i) A.\nProof. by apply/colP=> j; rewrite !mxE; congr (A _ _); apply/val_inj. Qed.",
    "Lemma row_thin_mx m n (A : 'M_(m,0)) (B : 'M_(m,n)) : row_mx A B = B.\nProof.\napply/matrixP=> i j; rewrite mxE; case: splitP=> [|k H]; first by case.\nby congr fun_of_matrix; exact: val_inj.\nQed.",
    "Lemma col_flat_mx m n (A : 'M_(0,n)) (B : 'M_(m,n)) : col_mx A B = B.\nProof.\napply/matrixP=> i j; rewrite mxE; case: splitP => [|k H]; first by case.\nby congr fun_of_matrix; exact: val_inj.\nQed.",
    "Lemma trmx_lsub m n1 n2 (A : 'M_(m, n1 + n2)) : (lsubmx A)^T = usubmx A^T.\nProof. by split_mxE. Qed.",
    "Lemma trmx_rsub m n1 n2 (A : 'M_(m, n1 + n2)) : (rsubmx A)^T = dsubmx A^T.\nProof. by split_mxE. Qed.",
    "Lemma tr_row_mx m n1 n2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  (row_mx A1 A2)^T = col_mx A1^T A2^T.\nProof. by split_mxE. Qed.",
    "Lemma tr_col_mx m1 m2 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  (col_mx A1 A2)^T = row_mx A1^T A2^T.\nProof. by split_mxE. Qed.",
    "Lemma trmx_usub m1 m2 n (A : 'M_(m1 + m2, n)) : (usubmx A)^T = lsubmx A^T.\nProof. by split_mxE. Qed.",
    "Lemma trmx_dsub m1 m2 n (A : 'M_(m1 + m2, n)) : (dsubmx A)^T = rsubmx A^T.\nProof. by split_mxE. Qed.",
    "Lemma vsubmxK m1 m2 n (A : 'M_(m1 + m2, n)) : col_mx (usubmx A) (dsubmx A) = A.\nProof. by apply: trmx_inj; rewrite tr_col_mx trmx_usub trmx_dsub hsubmxK. Qed.",
    "Lemma cast_row_mx m m' n1 n2 (eq_m : m = m') A1 A2 :\n  castmx (eq_m, erefl _) (row_mx A1 A2)\n    = row_mx (castmx (eq_m, erefl n1) A1) (castmx (eq_m, erefl n2) A2).\nProof. by case: m' / eq_m. Qed.",
    "Lemma cast_col_mx m1 m2 n n' (eq_n : n = n') A1 A2 :\n  castmx (erefl _, eq_n) (col_mx A1 A2)\n    = col_mx (castmx (erefl m1, eq_n) A1) (castmx (erefl m2, eq_n) A2).\nProof. by case: n' / eq_n. Qed.",
    "Lemma row_mxA m n1 n2 n3 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) (A3 : 'M_(m, n3)) :\n  let cast := (erefl m, esym (addnA n1 n2 n3)) in\n  row_mx A1 (row_mx A2 A3) = castmx cast (row_mx (row_mx A1 A2) A3).\nProof.\napply: (canRL (castmxKV _ _)); apply/matrixP=> i j.\nrewrite castmxE !mxE cast_ord_id; case: splitP => j1 /= def_j.\n  have: (j < n1 + n2) && (j < n1) by rewrite def_j lshift_subproof /=.\n  by move: def_j; do 2![case: splitP => // ? ->; rewrite ?mxE] => /ord_inj->.\ncase: splitP def_j => j2 ->{j} def_j /[!mxE].\n  have: ~~ (j2 < n1) by rewrite -leqNgt def_j leq_addr.\n  have: j1 < n2 by rewrite -(ltn_add2l n1) -def_j.\n  by move: def_j; do 2![case: splitP => // ? ->] => /addnI/val_inj->.\nhave: ~~ (j1 < n2) by rewrite -leqNgt -(leq_add2l n1) -def_j leq_addr.\nby case: splitP def_j => // ? ->; rewrite addnA => /addnI/val_inj->.\nQed.",
    "Lemma col_mxA m1 m2 m3 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) (A3 : 'M_(m3, n)) :\n  let cast := (esym (addnA m1 m2 m3), erefl n) in\n  col_mx A1 (col_mx A2 A3) = castmx cast (col_mx (col_mx A1 A2) A3).\nProof. by apply: trmx_inj; rewrite trmx_cast !tr_col_mx -row_mxA. Qed.",
    "Lemma row_row_mx m n1 n2 i0 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  row i0 (row_mx A1 A2) = row_mx (row i0 A1) (row i0 A2).\nProof.\nby apply/matrixP=> i j /[!mxE]; case: (split j) => j' /[1!mxE].\nQed.",
    "Lemma col_col_mx m1 m2 n j0 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  col j0 (col_mx A1 A2) = col_mx (col j0 A1) (col j0 A2).\nProof. by apply: trmx_inj; rewrite !(tr_col, tr_col_mx, row_row_mx). Qed.",
    "Lemma row'_row_mx m n1 n2 i0 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  row' i0 (row_mx A1 A2) = row_mx (row' i0 A1) (row' i0 A2).\nProof.\nby apply/matrixP=> i j /[!mxE]; case: (split j) => j' /[1!mxE].\nQed.",
    "Lemma col'_col_mx m1 m2 n j0 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  col' j0 (col_mx A1 A2) = col_mx (col' j0 A1) (col' j0 A2).\nProof. by apply: trmx_inj; rewrite !(tr_col', tr_col_mx, row'_row_mx). Qed.",
    "Lemma colKl m n1 n2 j1 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  col (lshift n2 j1) (row_mx A1 A2) = col j1 A1.\nProof. by apply/matrixP=> i j; rewrite !(row_mxEl, mxE). Qed.",
    "Lemma colKr m n1 n2 j2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  col (rshift n1 j2) (row_mx A1 A2) = col j2 A2.\nProof. by apply/matrixP=> i j; rewrite !(row_mxEr, mxE). Qed.",
    "Lemma rowKu m1 m2 n i1 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  row (lshift m2 i1) (col_mx A1 A2) = row i1 A1.\nProof. by apply/matrixP=> i j; rewrite !(col_mxEu, mxE). Qed.",
    "Lemma rowKd m1 m2 n i2 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  row (rshift m1 i2) (col_mx A1 A2) = row i2 A2.\nProof. by apply/matrixP=> i j; rewrite !(col_mxEd, mxE). Qed.",
    "Lemma col'Kl m n1 n2 j1 (A1 : 'M_(m, n1.+1)) (A2 : 'M_(m, n2)) :\n  col' (lshift n2 j1) (row_mx A1 A2) = row_mx (col' j1 A1) A2.\nProof.\napply/matrixP=> i /= j; symmetry; rewrite 2!mxE; case: split_ordP => j' ->.\n  by rewrite mxE -(row_mxEl _ A2); congr (row_mx _ _ _); apply: ord_inj.\nrewrite -(row_mxEr A1); congr (row_mx _ _ _); apply: ord_inj => /=.\nby rewrite /bump -ltnS -addSn ltn_addr.\nQed.",
    "Lemma row'Ku m1 m2 n i1 (A1 : 'M_(m1.+1, n)) (A2 : 'M_(m2, n)) :\n  row' (lshift m2 i1) (@col_mx m1.+1 m2 n A1 A2) = col_mx (row' i1 A1) A2.\nProof.\nby apply: trmx_inj; rewrite tr_col_mx !(@tr_row' _.+1) (@tr_col_mx _.+1) col'Kl.\nQed.",
    "Lemma mx'_cast m n : 'I_n -> (m + n.-1)%N = (m + n).-1.\nProof. by case=> j /ltn_predK <-; rewrite addnS. Qed.",
    "Lemma col'Kr m n1 n2 j2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  col' (rshift n1 j2) (@row_mx m n1 n2 A1 A2)\n    = castmx (erefl m, mx'_cast n1 j2) (row_mx A1 (col' j2 A2)).\nProof.\napply/matrixP=> i j; symmetry; rewrite castmxE mxE cast_ord_id.\ncase: splitP => j' /= def_j.\n  rewrite mxE -(row_mxEl _ A2); congr (row_mx _ _ _); apply: ord_inj.\n  by rewrite /= def_j /bump leqNgt ltn_addr.\nrewrite 2!mxE -(row_mxEr A1); congr (row_mx _ _ _ _); apply: ord_inj.\nby rewrite /= def_j /bump leq_add2l addnCA.\nQed.",
    "Lemma row'Kd m1 m2 n i2 (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  row' (rshift m1 i2) (col_mx A1 A2)\n    = castmx (mx'_cast m1 i2, erefl n) (col_mx A1 (row' i2 A2)).\nProof. by apply: trmx_inj; rewrite trmx_cast !(tr_row', tr_col_mx) col'Kr. Qed.",
    "Lemma eq_block_mx Aul Aur Adl Adr Bul Bur Bdl Bdr :\n block_mx Aul Aur Adl Adr = block_mx Bul Bur Bdl Bdr ->\n  [/\\ Aul = Bul, Aur = Bur, Adl = Bdl & Adr = Bdr].\nProof. by case/eq_col_mx; do 2!case/eq_row_mx=> -> ->. Qed.",
    "Lemma block_mx_const a :\n  block_mx (const_mx a) (const_mx a) (const_mx a) (const_mx a) = const_mx a.\nProof. by split_mxE. Qed.",
    "Lemma submxK : block_mx ulsubmx ursubmx dlsubmx drsubmx = A.\nProof. by rewrite /block_mx !hsubmxK vsubmxK. Qed.",
    "Lemma ulsubmxEsub : ulsubmx = mxsub (lshift _) (lshift _) A.\nProof. by rewrite /ulsubmx lsubmxEsub usubmxEsub -mxsub_comp. Qed.",
    "Lemma dlsubmxEsub : dlsubmx = mxsub (@rshift _ _) (lshift _) A.\nProof. by rewrite /dlsubmx lsubmxEsub dsubmxEsub -mxsub_comp. Qed.",
    "Lemma ursubmxEsub : ursubmx = mxsub (lshift _) (@rshift _ _) A.\nProof. by rewrite /ursubmx rsubmxEsub usubmxEsub -mxsub_comp. Qed.",
    "Lemma drsubmxEsub : drsubmx = mxsub (@rshift _ _) (@rshift _ _) A.\nProof. by rewrite /drsubmx rsubmxEsub dsubmxEsub -mxsub_comp. Qed.",
    "Lemma block_mxEul i j : A (lshift m2 i) (lshift n2 j) = Aul i j.\nProof. by rewrite col_mxEu row_mxEl. Qed.",
    "Lemma block_mxKul : ulsubmx A = Aul.\nProof. by rewrite /ulsubmx col_mxKu row_mxKl. Qed.",
    "Lemma block_mxEur i j : A (lshift m2 i) (rshift n1 j) = Aur i j.\nProof. by rewrite col_mxEu row_mxEr. Qed.",
    "Lemma block_mxKur : ursubmx A = Aur.\nProof. by rewrite /ursubmx col_mxKu row_mxKr. Qed.",
    "Lemma block_mxEdl i j : A (rshift m1 i) (lshift n2 j) = Adl i j.\nProof. by rewrite col_mxEd row_mxEl. Qed.",
    "Lemma block_mxKdl : dlsubmx A = Adl.\nProof. by rewrite /dlsubmx col_mxKd row_mxKl. Qed.",
    "Lemma block_mxEdr i j : A (rshift m1 i) (rshift n1 j) = Adr i j.\nProof. by rewrite col_mxEd row_mxEr. Qed.",
    "Lemma block_mxKdr : drsubmx A = Adr.\nProof. by rewrite /drsubmx col_mxKd row_mxKr. Qed.",
    "Lemma block_mxEv : A = col_mx (row_mx Aul Aur) (row_mx Adl Adr).\nProof. by []. Qed.",
    "Lemma trmx_ulsub : (ulsubmx A)^T = ulsubmx A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma trmx_ursub : (ursubmx A)^T = dlsubmx A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma trmx_dlsub : (dlsubmx A)^T = ursubmx A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma trmx_drsub : (drsubmx A)^T = drsubmx A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_block_mx :\n (block_mx Aul Aur Adl Adr)^T = block_mx Aul^T Adl^T Aur^T Adr^T.\nProof.\nrewrite -[_^T]submxK -trmx_ulsub -trmx_ursub -trmx_dlsub -trmx_drsub.\nby rewrite block_mxKul block_mxKur block_mxKdl block_mxKdr.\nQed.",
    "Lemma block_mxEh :\n  block_mx Aul Aur Adl Adr = row_mx (col_mx Aul Adl) (col_mx Aur Adr).\nProof. by apply: trmx_inj; rewrite tr_block_mx tr_row_mx 2!tr_col_mx. Qed.",
    "Lemma block_mxA m1 m2 m3 n1 n2 n3\n   (A11 : 'M_(m1, n1)) (A12 : 'M_(m1, n2)) (A13 : 'M_(m1, n3))\n   (A21 : 'M_(m2, n1)) (A22 : 'M_(m2, n2)) (A23 : 'M_(m2, n3))\n   (A31 : 'M_(m3, n1)) (A32 : 'M_(m3, n2)) (A33 : 'M_(m3, n3)) :\n  let cast := (esym (addnA m1 m2 m3), esym (addnA n1 n2 n3)) in\n  let row1 := row_mx A12 A13 in let col1 := col_mx A21 A31 in\n  let row3 := row_mx A31 A32 in let col3 := col_mx A13 A23 in\n  block_mx A11 row1 col1 (block_mx A22 A23 A32 A33)\n    = castmx cast (block_mx (block_mx A11 A12 A21 A22) col3 row3 A33).\nProof.\nrewrite /= block_mxEh !col_mxA -cast_row_mx -block_mxEv -block_mxEh.\nrewrite block_mxEv block_mxEh !row_mxA -cast_col_mx -block_mxEh -block_mxEv.\nby rewrite castmx_comp etrans_id.\nQed.",
    "Lemma row_ind m (P : forall n, 'M[R]_(m, n) -> Type) :\n    (forall A, P 0 A) ->\n    (forall n c A, P n A -> P (1 + n)%N (row_mx c A)) ->\n  forall n A, P n A.\nProof.\nmove=> P0 PS; elim=> [//|n IHn] A.\nby rewrite -[n.+1]/(1 + n)%N in A *; rewrite -[A]hsubmxK; apply: PS.\nQed.",
    "Lemma col_ind n (P : forall m, 'M[R]_(m, n) -> Type) :\n    (forall A, P 0 A) ->\n    (forall m r A, P m A -> P (1 + m)%N (col_mx r A)) ->\n  forall m A, P m A.\nProof.\nmove=> P0 PS; elim=> [//|m IHm] A.\nby rewrite -[m.+1]/(1 + m)%N in A *; rewrite -[A]vsubmxK; apply: PS.\nQed.",
    "Lemma mx_ind (P : forall m n, 'M[R]_(m, n) -> Type) :\n    (forall m A, P m 0 A) ->\n    (forall n A, P 0 n A) ->\n    (forall m n x r c A, P m n A -> P (1 + m)%N (1 + n)%N (block_mx x r c A)) ->\n  forall m n A, P m n A.\nProof.\nmove=> P0l P0r PS; elim=> [|m IHm] [|n] A; do ?by [apply: P0l|apply: P0r].\nby rewrite -[A](@submxK 1 _ 1); apply: PS.\nQed.",
    "Lemma sqmx_ind (P : forall n, 'M[R]_n -> Type) :\n    (forall A, P 0 A) ->\n    (forall n x r c A, P n A -> P (1 + n)%N (block_mx x r c A)) ->\n  forall n A, P n A.\nProof.\nby move=> P0 PS; elim=> [//|n IHn] A; rewrite -[A](@submxK 1 _ 1); apply: PS.\nQed.",
    "Lemma ringmx_ind (P : forall n, 'M[R]_n.+1 -> Type) :\n    (forall x, P 0 x) ->\n    (forall n x (r : 'rV_n.+1) (c : 'cV_n.+1) A,\n       P n A -> P (1 + n)%N (block_mx x r c A)) ->\n  forall n A, P n A.\nProof.\nby move=> P0 PS; elim=> [//|n IHn] A; rewrite -[A](@submxK 1 _ 1); apply: PS.\nQed.",
    "Lemma mxsub_ind\n    (weight : forall m n, 'M[R]_(m, n) -> nat)\n    (sub : forall m n m' n', ('I_m' -> 'I_m) -> ('I_n' -> 'I_n) -> Prop)\n    (P : forall m n, 'M[R]_(m, n) -> Type) :\n    (forall m n (A : 'M[R]_(m, n)),\n      (forall m' n' f g, weight m' n' (mxsub f g A) < weight m n A ->\n                         sub m n m' n' f g ->\n                         P m' n' (mxsub f g A)) -> P m n A) ->\n  forall m n A, P m n A.\nProof.\nmove=> Psub m n A; have [k] := ubnP (weight m n A).\nelim: k => [//|k IHk] in m n A *.\nrewrite ltnS => lt_A_k; apply: Psub => m' n' f g lt_A'_A ?.\nby apply: IHk; apply: leq_trans lt_A_k.\nQed.",
    "Lemma mxvec_cast : #|{:'I_m * 'I_n}| = (m * n)%N.\nProof. by rewrite card_prod !card_ord. Qed.",
    "Lemma mxvec_indexP k : is_mxvec_index k.\nProof.\nrewrite -[k](cast_ordK (esym mxvec_cast)) esymK.\nby rewrite -[_ k]enum_valK; case: (enum_val _).\nQed.",
    "Lemma mxvecE A i j : mxvec A 0 (mxvec_index i j) = A i j.\nProof. by rewrite castmxE mxE cast_ordK enum_rankK. Qed.",
    "Lemma mxvecK : cancel mxvec vec_mx.\nProof. by move=> A; apply/matrixP=> i j; rewrite mxE mxvecE. Qed.",
    "Lemma vec_mxK : cancel vec_mx mxvec.\nProof.\nby move=> u; apply/rowP=> k; case/mxvec_indexP: k => i j; rewrite mxvecE mxE.\nQed.",
    "Lemma curry_mxvec_bij : {on 'I_(m * n), bijective (uncurry mxvec_index)}.\nProof.\nexists (enum_val \\o cast_ord (esym mxvec_cast)) => [[i j] _ | k _] /=.\n  by rewrite cast_ordK enum_rankK.\nby case/mxvec_indexP: k => i j /=; rewrite cast_ordK enum_rankK.\nQed.",
    "Lemma map_trmx : A^f^T = A^T^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_const_mx a : (const_mx a)^f = const_mx (f a) :> 'M_(m, n).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_row i : (row i A)^f = row i A^f.\nProof. by apply/rowP=> j; rewrite !mxE. Qed.",
    "Lemma map_col j : (col j A)^f = col j A^f.\nProof. by apply/colP=> i; rewrite !mxE. Qed.",
    "Lemma map_row' i0 : (row' i0 A)^f = row' i0 A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_col' j0 : (col' j0 A)^f = col' j0 A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_mxsub m' n' g h : (@mxsub _ _ _  m' n' g h A)^f = mxsub g h A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_row_perm s : (row_perm s A)^f = row_perm s A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_col_perm s : (col_perm s A)^f = col_perm s A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_xrow i1 i2 : (xrow i1 i2 A)^f = xrow i1 i2 A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_xcol j1 j2 : (xcol j1 j2 A)^f = xcol j1 j2 A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_castmx m' n' c : (castmx c A)^f = castmx c A^f :> 'M_(m', n').\nProof. by apply/matrixP=> i j; rewrite !(castmxE, mxE). Qed.",
    "Lemma map_conform_mx m' n' (B : 'M_(m', n')) :\n  (conform_mx B A)^f = conform_mx B^f A^f.\nProof.\nmove: B; have [[<- <-] B|] := eqVneq (m, n) (m', n').\n  by rewrite !conform_mx_id.\nby rewrite negb_and => neq_mn B; rewrite !nonconform_mx.\nQed.",
    "Lemma map_mxvec : (mxvec A)^f = mxvec A^f.\nProof. by apply/rowP=> i; rewrite !(castmxE, mxE). Qed.",
    "Lemma map_vec_mx (v : 'rV_(m * n)) : (vec_mx v)^f = vec_mx v^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_row_mx : (row_mx Aul Aur)^f = row_mx Aul^f Aur^f.\nProof. by apply/matrixP=> i j; do 2![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map_col_mx : (col_mx Aul Adl)^f = col_mx Aul^f Adl^f.\nProof. by apply/matrixP=> i j; do 2![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map_block_mx :\n  (block_mx Aul Aur Adl Adr)^f = block_mx Aul^f Aur^f Adl^f Adr^f.\nProof. by apply/matrixP=> i j; do 3![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map_lsubmx : (lsubmx Bh)^f = lsubmx Bh^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_rsubmx : (rsubmx Bh)^f = rsubmx Bh^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_usubmx : (usubmx Bv)^f = usubmx Bv^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_dsubmx : (dsubmx Bv)^f = dsubmx Bv^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_ulsubmx : (ulsubmx B)^f = ulsubmx B^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_ursubmx : (ursubmx B)^f = ursubmx B^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_dlsubmx : (dlsubmx B)^f = dlsubmx B^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_drsubmx : (drsubmx B)^f = drsubmx B^f.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map_mx_comp (f : R -> S) (g : S -> T)\n  (M : 'M_(m, n)) : M ^ (g \\o f) = (M ^ f) ^ g.\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma eq_in_map_mx (g f : R -> S) (M : 'M_(m, n)) :\n  (forall i j, f (M i j) = g (M i j)) -> M ^ f = M ^ g.\nProof. by move=> fg; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma eq_map_mx (g f : R -> S) : f =1 g ->\n  forall (M : 'M_(m, n)), M ^ f = M ^ g.\nProof. by move=> eq_fg M; apply/eq_in_map_mx. Qed.",
    "Lemma map_mx_id_in (f : R -> R) (M : 'M_(m, n)) :\n  (forall i j, f (M i j) = M i j) -> M ^ f = M.\nProof. by move=> fM; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma map_mx_id (f : R -> R) : f =1 id -> forall M : 'M_(m, n), M ^ f = M.\nProof. by move=> fid M; rewrite map_mx_id_in. Qed.",
    "Lemma map2_trmx : (map2_mx A B)^T = map2_mx A^T B^T.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_const_mx a b :\n  map2_mx (const_mx a) (const_mx b) = const_mx (f a b) :> 'M_(m, n).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_row i : map2_mx (row i A) (row i B) = row i (map2_mx A B).\nProof. by apply/rowP=> j; rewrite !mxE. Qed.",
    "Lemma map2_col j : map2_mx (col j A) (col j B) = col j (map2_mx A B).\nProof. by apply/colP=> i; rewrite !mxE. Qed.",
    "Lemma map2_row' i0 : map2_mx (row' i0 A) (row' i0 B) = row' i0 (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_col' j0 : map2_mx (col' j0 A) (col' j0 B) = col' j0 (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_mxsub m' n' g h :\n  map2_mx (@mxsub _ _ _  m' n' g h A) (@mxsub _ _ _  m' n' g h B) =\n  mxsub g h (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_row_perm s :\n  map2_mx (row_perm s A) (row_perm s B) = row_perm s (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_col_perm s :\n  map2_mx (col_perm s A) (col_perm s B) = col_perm s (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_xrow i1 i2 :\n  map2_mx (xrow i1 i2 A) (xrow i1 i2 B) = xrow i1 i2 (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_xcol j1 j2 :\n  map2_mx (xcol j1 j2 A) (xcol j1 j2 B) = xcol j1 j2 (map2_mx A B).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_castmx m' n' c :\n  map2_mx (castmx c A) (castmx c B) = castmx c (map2_mx A B) :> 'M_(m', n').\nProof. by apply/matrixP=> i j; rewrite !(castmxE, mxE). Qed.",
    "Lemma map2_conform_mx m' n' (A' : 'M_(m', n')) (B' : 'M_(m', n')) :\n  map2_mx (conform_mx A' A) (conform_mx B' B) =\n  conform_mx (map2_mx A' B') (map2_mx A B).\nProof.\nmove: A' B'; have [[<- <-] A' B'|] := eqVneq (m, n) (m', n').\n  by rewrite !conform_mx_id.\nby rewrite negb_and => neq_mn A' B'; rewrite !nonconform_mx.\nQed.",
    "Lemma map2_mxvec : map2_mx (mxvec A) (mxvec B) = mxvec (map2_mx A B).\nProof. by apply/rowP=> i; rewrite !(castmxE, mxE). Qed.",
    "Lemma map2_vec_mx (v : 'rV_(m * n)) (w : 'rV_(m * n)) :\n  map2_mx (vec_mx v) (vec_mx w) = vec_mx (map2_mx v w).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_row_mx :\n  map2_mx (row_mx Aul Aur) (row_mx A'ul A'ur) =\n  row_mx (map2_mx Aul A'ul) (map2_mx Aur A'ur).\nProof. by apply/matrixP=> i j; do 2![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map2_col_mx :\n  map2_mx (col_mx Aul Adl) (col_mx A'ul A'dl) =\n  col_mx (map2_mx Aul A'ul) (map2_mx Adl A'dl).\nProof. by apply/matrixP=> i j; do 2![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map2_block_mx :\n  map2_mx (block_mx Aul Aur Adl Adr) (block_mx A'ul A'ur A'dl A'dr) =\n  block_mx\n   (map2_mx Aul A'ul) (map2_mx Aur A'ur) (map2_mx Adl A'dl) (map2_mx Adr A'dr).\nProof. by apply/matrixP=> i j; do 3![rewrite !mxE //; case: split => ?]. Qed.",
    "Lemma map2_lsubmx : map2_mx (lsubmx Bh) (lsubmx B'h) = lsubmx (map2_mx Bh B'h).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_rsubmx : map2_mx (rsubmx Bh) (rsubmx B'h) = rsubmx (map2_mx Bh B'h).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_usubmx : map2_mx (usubmx Bv) (usubmx B'v) = usubmx (map2_mx Bv B'v).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_dsubmx : map2_mx (dsubmx Bv) (dsubmx B'v) = dsubmx (map2_mx Bv B'v).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_ulsubmx : map2_mx (ulsubmx B) (ulsubmx B') = ulsubmx (map2_mx B B').\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_ursubmx : map2_mx (ursubmx B) (ursubmx B') = ursubmx (map2_mx B B').\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_dlsubmx : map2_mx (dlsubmx B) (dlsubmx B') = dlsubmx (map2_mx B B').\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma map2_drsubmx : map2_mx (drsubmx B) (drsubmx B') = drsubmx (map2_mx B B').\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma eq_in_map2_mx (f g : R -> S -> T) (M : 'M[R]_(m, n)) (M' : 'M[S]_(m, n)) :\n  (forall i j, f (M i j) (M' i j) = g (M i j) (M' i j)) ->\n  map2_mx f M M' = map2_mx g M M'.\nProof. by move=> fg; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma eq_map2_mx (f g : R -> S -> T) : f =2 g ->\n  @map2_mx _ _ _ f m n =2 @map2_mx _ _ _ g m n.\nProof. by move=> eq_fg M M'; apply/eq_in_map2_mx. Qed.",
    "Lemma map2_mx_left_in (f : R -> R -> R) (M : 'M_(m, n)) (M' : 'M_(m, n)) :\n  (forall i j, f (M i j) (M' i j) = M i j) -> map2_mx f M M' = M.\nProof. by move=> fM; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma map2_mx_left (f : R -> R -> R) : f =2 (fun x _ => x) ->\n  forall (M : 'M_(m, n)) (M' : 'M_(m, n)), map2_mx f M M' = M.\nProof. by move=> fl M M'; rewrite map2_mx_left_in// =>i j; rewrite fl. Qed.",
    "Lemma map2_mx_right_in (f : R -> R -> R) (M : 'M_(m, n)) (M' : 'M_(m, n)) :\n  (forall i j, f (M i j) (M' i j) = M' i j) -> map2_mx f M M' = M'.\nProof. by move=> fM; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma map2_mx_right (f : R -> R -> R) : f =2 (fun _ x => x) ->\n  forall (M : 'M_(m, n)) (M' : 'M_(m, n)), map2_mx f M M' = M'.\nProof. by move=> fr M M'; rewrite map2_mx_right_in// =>i j; rewrite fr. Qed.",
    "Lemma map2_mxA {opm : Monoid.law idm} : associative (@map2_mx _ _ _ opm m n).\nProof. by move=> A B C; apply/matrixP=> i j; rewrite !mxE Monoid.mulmA. Qed.",
    "Lemma map2_1mx {opm : Monoid.law idm} :\n  left_id (const_mx idm) (@map2_mx _ _ _ opm m n).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE Monoid.mul1m. Qed.",
    "Lemma map2_mx1 {opm : Monoid.law idm} :\n  right_id (const_mx idm) (@map2_mx _ _ _ opm m n).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE Monoid.mulm1. Qed.",
    "Lemma map2_mxC {opm : Monoid.com_law idm} :\n  commutative (@map2_mx _ _ _ opm m n).\nProof. by move=> A B; apply/matrixP=> i j; rewrite !mxE Monoid.mulmC. Qed.",
    "Lemma map2_0mx {opm : Monoid.mul_law idm} :\n  left_zero (const_mx idm) (@map2_mx _ _ _ opm m n).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE Monoid.mul0m. Qed.",
    "Lemma map2_mx0 {opm : Monoid.mul_law idm} :\n  right_zero (const_mx idm) (@map2_mx _ _ _ opm m n).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE Monoid.mulm0. Qed.",
    "Lemma map2_mxDl {mul : T -> T -> T} {add : Monoid.add_law idm mul} :\n  left_distributive (@map2_mx _ _ _ mul m n) (@map2_mx _ _ _ add m n).\nProof. by move=> A B C; apply/matrixP=> i j; rewrite !mxE Monoid.mulmDl. Qed.",
    "Lemma map2_mxDr {mul : T -> T -> T} {add : Monoid.add_law idm mul} :\n  right_distributive (@map2_mx _ _ _ mul m n) (@map2_mx _ _ _ add m n).\nProof. by move=> A B C; apply/matrixP=> i j; rewrite !mxE Monoid.mulmDr. Qed.",
    "Lemma mulmxnE A d i j : (A *+ d) i j = A i j *+ d.\nProof. by elim: d => [|d IHd]; rewrite ?mulrS mxE ?IHd. Qed.",
    "Lemma summxE I r (P : pred I) (E : I -> 'M_(m, n)) i j :\n  (\\sum_(k <- r | P k) E k) i j = \\sum_(k <- r | P k) E k i j.\nProof. by apply: (big_morph (fun A => A i j)) => [A B|]; rewrite mxE. Qed.",
    "Lemma const_mx_is_semi_additive : semi_additive const_mx.\nProof. by split=> [|a b]; apply/matrixP => // i j; rewrite !mxE. Qed.",
    "Lemma swizzle_mx_is_semi_additive k : semi_additive (swizzle_mx k).\nProof. by split=> [|A B]; apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma flatmx0 n : all_equal_to (0 : 'M_(0, n)).\nProof. by move=> A; apply/matrixP=> [] []. Qed.",
    "Lemma thinmx0 n : all_equal_to (0 : 'M_(n, 0)).\nProof. by move=> A; apply/matrixP=> i []. Qed.",
    "Lemma trmx0 m n : (0 : 'M_(m, n))^T = 0.\nProof. exact: trmx_const. Qed.",
    "Lemma row0 m n i0 : row i0 (0 : 'M_(m, n)) = 0.\nProof. exact: row_const. Qed.",
    "Lemma col0 m n j0 : col j0 (0 : 'M_(m, n)) = 0.\nProof. exact: col_const. Qed.",
    "Lemma mxvec_eq0 m n (A : 'M_(m, n)) : (mxvec A == 0) = (A == 0).\nProof. by rewrite (can2_eq mxvecK vec_mxK) raddf0. Qed.",
    "Lemma vec_mx_eq0 m n (v : 'rV_(m * n)) : (vec_mx v == 0) = (v == 0).\nProof. by rewrite (can2_eq vec_mxK mxvecK) raddf0. Qed.",
    "Lemma row_mx0 m n1 n2 : row_mx 0 0 = 0 :> 'M_(m, n1 + n2).\nProof. exact: row_mx_const. Qed.",
    "Lemma col_mx0 m1 m2 n : col_mx 0 0 = 0 :> 'M_(m1 + m2, n).\nProof. exact: col_mx_const. Qed.",
    "Lemma block_mx0 m1 m2 n1 n2 : block_mx 0 0 0 0 = 0 :> 'M_(m1 + m2, n1 + n2).\nProof. exact: block_mx_const. Qed.",
    "Lemma add_row_mx m n1 n2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) B1 B2 :\n  row_mx A1 A2 + row_mx B1 B2 = row_mx (A1 + B1) (A2 + B2).\nProof. by split_mxE. Qed.",
    "Lemma add_col_mx m1 m2 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) B1 B2 :\n  col_mx A1 A2 + col_mx B1 B2 = col_mx (A1 + B1) (A2 + B2).\nProof. by split_mxE. Qed.",
    "Lemma add_block_mx m1 m2 n1 n2 (Aul : 'M_(m1, n1)) Aur Adl (Adr : 'M_(m2, n2))\n                   Bul Bur Bdl Bdr :\n  let A := block_mx Aul Aur Adl Adr in let B := block_mx Bul Bur Bdl Bdr in\n  A + B = block_mx (Aul + Bul) (Aur + Bur) (Adl + Bdl) (Adr + Bdr).\nProof. by rewrite /= add_col_mx !add_row_mx. Qed.",
    "Lemma row_mx_eq0 (m n1 n2 : nat) (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)):\n  (row_mx A1 A2 == 0) = (A1 == 0) && (A2 == 0).\nProof.\napply/eqP/andP; last by case=> /eqP-> /eqP->; rewrite row_mx0.\nby rewrite -row_mx0 => /eq_row_mx [-> ->].\nQed.",
    "Lemma col_mx_eq0 (m1 m2 n : nat) (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)):\n  (col_mx A1 A2 == 0) = (A1 == 0) && (A2 == 0).\nProof. by rewrite -![_ == 0](inj_eq trmx_inj) !trmx0 tr_col_mx row_mx_eq0. Qed.",
    "Lemma block_mx_eq0 m1 m2 n1 n2 (Aul : 'M_(m1, n1)) Aur Adl (Adr : 'M_(m2, n2)) :\n  (block_mx Aul Aur Adl Adr == 0) =\n  [&& Aul == 0, Aur == 0, Adl == 0 & Adr == 0].\nProof. by rewrite col_mx_eq0 !row_mx_eq0 !andbA. Qed.",
    "Lemma trmx_eq0  m n (A : 'M_(m, n)) : (A^T == 0) = (A == 0).\nProof. by rewrite -trmx0 (inj_eq trmx_inj). Qed.",
    "Lemma matrix_eq0 m n (A : 'M_(m, n)) :\n  (A == 0) = [forall i, forall j, A i j == 0].\nProof.\napply/eqP/'forall_'forall_eqP => [-> i j|A_eq0]; first by rewrite !mxE.\nby apply/matrixP => i j; rewrite A_eq0 !mxE.\nQed.",
    "Lemma matrix0Pn m n (A : 'M_(m, n)) : reflect (exists i j, A i j != 0) (A != 0).\nProof.\nby rewrite matrix_eq0; apply/(iffP forallPn) => -[i /forallPn]; exists i.\nQed.",
    "Lemma rV0Pn n (v : 'rV_n) : reflect (exists i, v 0 i != 0) (v != 0).\nProof.\napply: (iffP (matrix0Pn _)) => [[i [j]]|[j]]; last by exists 0, j.\nby rewrite ord1; exists j.\nQed.",
    "Lemma cV0Pn n (v : 'cV_n) : reflect (exists i, v i 0 != 0) (v != 0).\nProof.\napply: (iffP (matrix0Pn _)) => [[i] [j]|[i]]; last by exists i, 0.\nby rewrite ord1; exists i.\nQed.",
    "Lemma nz_row_eq0 m n (A : 'M_(m, n)) : (nz_row A == 0) = (A == 0).\nProof.\nrewrite /nz_row; symmetry; case: pickP => [i /= nzAi | Ai0].\n  by rewrite (negPf nzAi); apply: contraTF nzAi => /eqP->; rewrite row0 eqxx.\nby rewrite eqxx; apply/eqP/row_matrixP=> i; move/eqP: (Ai0 i) ->; rewrite row0.\nQed.",
    "Lemma is_diag_mxP m n (A : 'M[V]_(m, n)) :\n  reflect (forall i j : 'I__, i != j :> nat -> A i j = 0) (is_diag_mx A).\nProof. by apply: (iffP 'forall_'forall_implyP) => /(_ _ _ _)/eqP. Qed.",
    "Lemma mx0_is_diag m n : is_diag_mx (0 : 'M[V]_(m, n)).\nProof. by apply/is_diag_mxP => i j _; rewrite mxE. Qed.",
    "Lemma mx11_is_diag (M : 'M_1) : is_diag_mx M.\nProof. by apply/is_diag_mxP => i j; rewrite !ord1 eqxx. Qed.",
    "Lemma is_trig_mxP m n (A : 'M[V]_(m, n)) :\n  reflect (forall i j : 'I__, (i < j)%N -> A i j = 0) (is_trig_mx A).\nProof. by apply: (iffP 'forall_'forall_implyP) => /(_ _ _ _)/eqP. Qed.",
    "Lemma is_diag_mx_is_trig m n (A : 'M[V]_(m, n)) : is_diag_mx A -> is_trig_mx A.\nProof.\nby move=> /is_diag_mxP A_eq0; apply/is_trig_mxP=> i j lt_ij;\n   rewrite A_eq0// ltn_eqF.\nQed.",
    "Lemma mx0_is_trig m n : is_trig_mx (0 : 'M[V]_(m, n)).\nProof. by apply/is_trig_mxP => i j _; rewrite mxE. Qed.",
    "Lemma mx11_is_trig (M : 'M_1) : is_trig_mx M.\nProof. by apply/is_trig_mxP => i j; rewrite !ord1 ltnn. Qed.",
    "Lemma is_diag_mxEtrig m n (A : 'M[V]_(m, n)) :\n  is_diag_mx A = is_trig_mx A && is_trig_mx A^T.\nProof.\napply/is_diag_mxP/andP => [Adiag|[/is_trig_mxP Atrig /is_trig_mxP ATtrig]].\n  by split; apply/is_trig_mxP => i j lt_ij; rewrite ?mxE ?Adiag//;\n     [rewrite ltn_eqF|rewrite gtn_eqF].\nby move=> i j; case: ltngtP => // [/Atrig|/ATtrig]; rewrite ?mxE.\nQed.",
    "Lemma is_diag_trmx  m n (A : 'M[V]_(m, n)) : is_diag_mx A^T = is_diag_mx A.\nProof. by rewrite !is_diag_mxEtrig trmxK andbC. Qed.",
    "Lemma ursubmx_trig m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  m1 <= n1 -> is_trig_mx A -> ursubmx A = 0.\nProof.\nmove=> leq_m1_n1 /is_trig_mxP Atrig; apply/matrixP => i j.\nby rewrite !mxE Atrig//= ltn_addr// (@leq_trans m1).\nQed.",
    "Lemma dlsubmx_diag m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  n1 <= m1 -> is_diag_mx A -> dlsubmx A = 0.\nProof.\nmove=> leq_m2_n2 /is_diag_mxP Adiag; apply/matrixP => i j.\nby rewrite !mxE Adiag// gtn_eqF//= ltn_addr// (@leq_trans n1).\nQed.",
    "Lemma ulsubmx_trig m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  is_trig_mx A -> is_trig_mx (ulsubmx A).\nProof.\nmove=> /is_trig_mxP Atrig; apply/is_trig_mxP => i j lt_ij.\nby rewrite !mxE Atrig.\nQed.",
    "Lemma drsubmx_trig m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  m1 <= n1 -> is_trig_mx A -> is_trig_mx (drsubmx A).\nProof.\nmove=> leq_m1_n1 /is_trig_mxP Atrig; apply/is_trig_mxP => i j lt_ij.\nby rewrite !mxE Atrig//= -addnS leq_add.\nQed.",
    "Lemma ulsubmx_diag m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  is_diag_mx A -> is_diag_mx (ulsubmx A).\nProof.\nrewrite !is_diag_mxEtrig trmx_ulsub.\nby move=> /andP[/ulsubmx_trig-> /ulsubmx_trig->].\nQed.",
    "Lemma drsubmx_diag m1 m2 n1 n2 (A : 'M[V]_(m1 + m2, n1 + n2)) :\n  m1 = n1 -> is_diag_mx A -> is_diag_mx (drsubmx A).\nProof.\nmove=> eq_m1_n1 /is_diag_mxP Adiag; apply/is_diag_mxP => i j neq_ij.\nby rewrite !mxE Adiag//= eq_m1_n1 eqn_add2l.\nQed.",
    "Lemma is_trig_block_mx m1 m2 n1 n2 ul ur dl dr : m1 = n1 ->\n  @is_trig_mx (m1 + m2) (n1 + n2) (block_mx ul ur dl dr) =\n  [&& ur == 0, is_trig_mx ul & is_trig_mx dr].\nProof.\nmove=> eq_m1_n1; rewrite {}eq_m1_n1 in ul ur dl dr *.\napply/is_trig_mxP/and3P => [Atrig|]; last first.\n  move=> [/eqP-> /is_trig_mxP ul_trig /is_trig_mxP dr_trig] i j; rewrite !mxE.\n  do 2![case: split_ordP => ? ->; rewrite ?mxE//=] => lt_ij; rewrite ?ul_trig//.\n    move: lt_ij; rewrite ltnNge -ltnS.\n    by rewrite (leq_trans (ltn_ord _))// -addnS leq_addr.\n  by rewrite dr_trig//; move: lt_ij; rewrite ltn_add2l.\nsplit.\n- apply/eqP/matrixP => i j; have := Atrig (lshift _ i) (rshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP-> /eqP<- <- //.\n  by rewrite /= (leq_trans (ltn_ord _)) ?leq_addr.\n- apply/is_trig_mxP => i j lt_ij; have := Atrig (lshift _ i) (lshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  by case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP<- /eqP<- ->.\n- apply/is_trig_mxP => i j lt_ij; have := Atrig (rshift _ i) (rshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP<- /eqP<- -> //.\n  by rewrite /= ltn_add2l.\nQed.",
    "Lemma trigmx_ind (P : forall m n, 'M_(m, n) -> Type) :\n  (forall m, P m 0 0) ->\n  (forall n, P 0 n 0) ->\n  (forall m n x c A, is_trig_mx A ->\n    P m n A -> P (1 + m)%N (1 + n)%N (block_mx x 0 c A)) ->\n  forall m n A, is_trig_mx A -> P m n A.\nProof.\nmove=> P0l P0r PS m n A; elim: A => {m n} [m|n|m n xx r c] A PA;\n  do ?by rewrite (flatmx0, thinmx0); by [apply: P0l|apply: P0r].\nby rewrite is_trig_block_mx => // /and3P[/eqP-> _ Atrig]; apply: PS (PA _).\nQed.",
    "Lemma trigsqmx_ind (P : forall n, 'M[V]_n -> Type) : (P 0 0) ->\n  (forall n x c A, is_trig_mx A -> P n A -> P (1 + n)%N (block_mx x 0 c A)) ->\n  forall n A, is_trig_mx A -> P n A.\nProof.\nmove=> P0 PS n A; elim/sqmx_ind: A => {n} [|n x r c] A PA.\n  by rewrite thinmx0; apply: P0.\nby rewrite is_trig_block_mx => // /and3P[/eqP-> _ Atrig]; apply: PS (PA _).\nQed.",
    "Lemma is_diag_block_mx m1 m2 n1 n2 ul ur dl dr : m1 = n1 ->\n  @is_diag_mx (m1 + m2) (n1 + n2) (block_mx ul ur dl dr) =\n  [&& ur == 0, dl == 0, is_diag_mx ul & is_diag_mx dr].\nProof.\nmove=> eq_m1_n1.\nrewrite !is_diag_mxEtrig tr_block_mx !is_trig_block_mx// trmx_eq0.\nby rewrite andbACA -!andbA; congr [&& _, _, _ & _]; rewrite andbCA.\nQed.",
    "Lemma diagmx_ind (P : forall m n, 'M_(m, n) -> Type) :\n  (forall m, P m 0 0) ->\n  (forall n, P 0 n 0) ->\n  (forall m n x c A, is_diag_mx A ->\n    P m n A -> P (1 + m)%N (1 + n)%N (block_mx x 0 c A)) ->\n  forall m n A, is_diag_mx A -> P m n A.\nProof.\nmove=> P0l P0r PS m n A Adiag; have Atrig := is_diag_mx_is_trig Adiag.\nelim/trigmx_ind: Atrig Adiag => // {}m {}n r c {}A _ PA.\nrewrite is_diag_block_mx => // /and4P[_ /eqP-> _ Adiag].\nexact: PS (PA _).\nQed.",
    "Lemma diagsqmx_ind (P : forall n, 'M[V]_n -> Type) :\n    (P 0 0) ->\n  (forall n x c A, is_diag_mx A -> P n A -> P (1 + n)%N (block_mx x 0 c A)) ->\n  forall n A, is_diag_mx A -> P n A.\nProof.\nmove=> P0 PS n A; elim/sqmx_ind: A => [|{}n x r c] A PA.\n  by rewrite thinmx0; apply: P0.\nrewrite is_diag_block_mx => // /and4P[/eqP-> /eqP-> _ Adiag].\nexact: PS (PA _).\nQed.",
    "Lemma tr_diag_mx n (d : 'rV_n) : (diag_mx d)^T = diag_mx d.\nProof. by apply/matrixP=> i j /[!mxE]; case: eqVneq => // ->. Qed.",
    "Lemma diag_mx_is_semi_additive n : semi_additive (@diag_mx n).\nProof.\nby split=> [|A B]; apply/matrixP => i j; rewrite !mxE ?mul0rn// mulrnDl.\nQed.",
    "Lemma diag_mx_row m n (l : 'rV_n) (r : 'rV_m) :\n  diag_mx (row_mx l r) = block_mx (diag_mx l) 0 0 (diag_mx r).\nProof.\napply/matrixP => i j.\nby do ?[rewrite !mxE; case: split_ordP => ? ->]; rewrite mxE eq_shift.\nQed.",
    "Lemma diag_mxP n (A : 'M[V]_n) :\n  reflect (exists d : 'rV_n, A = diag_mx d) (is_diag_mx A).\nProof.\napply: (iffP (is_diag_mxP A)) => [Adiag|[d ->] i j neq_ij]; last first.\n  by rewrite !mxE -val_eqE (negPf neq_ij).\nexists (\\row_i A i i); apply/matrixP => i j; rewrite !mxE.\nby case: (altP (i =P j)) => [->|/Adiag->].\nQed.",
    "Lemma diag_mx_is_diag n (r : 'rV[V]_n) : is_diag_mx (diag_mx r).\nProof. by apply/diag_mxP; exists r. Qed.",
    "Lemma diag_mx_is_trig n (r : 'rV[V]_n) : is_trig_mx (diag_mx r).\nProof. exact/is_diag_mx_is_trig/diag_mx_is_diag. Qed.",
    "Lemma diag_const_mx a : diag_mx (const_mx a) = a%:M :> 'M_n.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma tr_scalar_mx a : (a%:M)^T = a%:M.\nProof. by apply/matrixP=> i j; rewrite !mxE eq_sym. Qed.",
    "Lemma scalar_mx_is_semi_additive : semi_additive scalar_mx.\nProof. by split=> [|a b]; rewrite -!diag_const_mx ?raddf0// !raddfD. Qed.",
    "Lemma is_scalar_mxP A : reflect (exists a, A = a%:M) (is_scalar_mx A).\nProof.\nrewrite /is_scalar_mx; case: insubP => [i _ _ | ].\n  by apply: (iffP eqP) => [|[a ->]]; [exists (A i i) | rewrite mxE eqxx].\nrewrite -eqn0Ngt => /eqP n0; left; exists 0.\nby rewrite raddf0; rewrite n0 in A *; rewrite [A]flatmx0.\nQed.",
    "Lemma scalar_mx_is_scalar a : is_scalar_mx a%:M.\nProof. by apply/is_scalar_mxP; exists a. Qed.",
    "Lemma mx0_is_scalar : is_scalar_mx 0.\nProof. by apply/is_scalar_mxP; exists 0; rewrite raddf0. Qed.",
    "Lemma scalar_mx_is_diag a : is_diag_mx (a%:M).\nProof. by rewrite -diag_const_mx diag_mx_is_diag. Qed.",
    "Lemma is_scalar_mx_is_diag A : is_scalar_mx A -> is_diag_mx A.\nProof. by move=> /is_scalar_mxP[a ->]; apply: scalar_mx_is_diag. Qed.",
    "Lemma scalar_mx_is_trig a : is_trig_mx (a%:M).\nProof. by rewrite is_diag_mx_is_trig// scalar_mx_is_diag. Qed.",
    "Lemma is_scalar_mx_is_trig A : is_scalar_mx A -> is_trig_mx A.\nProof. by move=> /is_scalar_mx_is_diag /is_diag_mx_is_trig. Qed.",
    "Lemma mx11_scalar (A : 'M_1) : A = (A 0 0)%:M.\nProof. by apply/rowP=> j; rewrite ord1 mxE. Qed.",
    "Lemma scalar_mx_block n1 n2 a : a%:M = block_mx a%:M 0 0 a%:M :> 'M_(n1 + n2).\nProof.\napply/matrixP=> i j; rewrite !mxE.\nby do 2![case: split_ordP => ? ->; rewrite !mxE]; rewrite ?eq_shift.\nQed.",
    "Lemma mxtrace_tr A : \\tr A^T = \\tr A.\nProof. by apply: eq_bigr=> i _; rewrite mxE. Qed.",
    "Lemma mxtrace_is_semi_additive : semi_additive mxtrace.\nProof.\nsplit=> [|A B].\n- rewrite /mxtrace; under eq_bigr => i _ do rewrite mxE.\n  by rewrite big_const_idem //= addr0.\n- by rewrite -big_split /=; apply: eq_bigr => i _; rewrite mxE.\nQed.",
    "Lemma mxtrace0 : \\tr 0 = 0. Proof. exact: raddf0. Qed.",
    "Lemma mxtraceD A B : \\tr (A + B) = \\tr A + \\tr B. Proof. exact: raddfD. Qed.",
    "Lemma mxtrace_diag D : \\tr (diag_mx D) = \\sum_j D 0 j.\nProof. by apply: eq_bigr => j _; rewrite mxE eqxx. Qed.",
    "Lemma mxtrace_scalar a : \\tr a%:M = a *+ n.\nProof.\nrewrite -diag_const_mx mxtrace_diag; under eq_bigr do rewrite mxE.\nby rewrite sumr_const card_ord.\nQed.",
    "Lemma trace_mx11 (A : 'M_1) : \\tr A = A 0 0.\nProof. by rewrite {1}[A]mx11_scalar mxtrace_scalar. Qed.",
    "Lemma mxtrace_block n1 n2 (Aul : 'M_n1) Aur Adl (Adr : 'M_n2) :\n  \\tr (block_mx Aul Aur Adl Adr) = \\tr Aul + \\tr Adr.\nProof.\nrewrite /(\\tr _) big_split_ord /=.\nby congr (_ + _); under eq_bigr do rewrite (block_mxEul, block_mxEdr).\nQed.",
    "Lemma map_mx0 : 0^f = 0 :> 'M_(m, n).\nProof. by rewrite map_const_mx raddf0. Qed.",
    "Lemma map_mxD A B : (A + B)^f = A^f + B^f.\nProof. by apply/matrixP=> i j; rewrite !mxE raddfD. Qed.",
    "Lemma addNmx : left_inverse (const_mx 0) oppmx (@addmx V m n).\nProof. by move=> A; apply/matrixP=> i j; rewrite !mxE addNr. Qed.",
    "Lemma const_mx_is_additive : additive const_mx.\nProof. by move=> a b; apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma swizzle_mx_is_additive k : additive (swizzle_mx f g k).\nProof. by move=> A B; apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma opp_row_mx m n1 n2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  - row_mx A1 A2 = row_mx (- A1) (- A2).\nProof. by split_mxE. Qed.",
    "Lemma opp_col_mx m1 m2 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  - col_mx A1 A2 = col_mx (- A1) (- A2).\nProof. by split_mxE. Qed.",
    "Lemma opp_block_mx m1 m2 n1 n2 (Aul : 'M_(m1, n1)) Aur Adl (Adr : 'M_(m2, n2)) :\n  - block_mx Aul Aur Adl Adr = block_mx (- Aul) (- Aur) (- Adl) (- Adr).\nProof. by rewrite opp_col_mx !opp_row_mx. Qed.",
    "Lemma diag_mx_is_additive n : additive (@diag_mx V n).\nProof.\nby move=>A B; apply/matrixP=>i j; rewrite !mxE mulrnBl.\nQed.",
    "Lemma scalar_mx_is_additive : additive (@scalar_mx V n).\nProof. by move=> a b; rewrite -!diag_const_mx !raddfB. Qed.",
    "Lemma mxtrace_is_additive : additive (@mxtrace V n).\nProof.\nmove=>A B; rewrite -sumrN -big_split /=.\nby apply: eq_bigr=> i _; rewrite !mxE.\nQed.",
    "Lemma map_mxN A : (- A)^f = - A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE raddfN. Qed.",
    "Lemma map_mxB A B : (A - B)^f = A^f - B^f.\nProof. by rewrite map_mxD map_mxN. Qed.",
    "Lemma scale1mx A : 1 *m: A = A.\nProof. by apply/matrixP=> i j; rewrite !mxE mul1r. Qed.",
    "Lemma scalemxDl A x y : (x + y) *m: A = x *m: A + y *m: A.\nProof. by apply/matrixP=> i j; rewrite !mxE mulrDl. Qed.",
    "Lemma scalemxDr x A B : x *m: (A + B) = x *m: A + x *m: B.\nProof. by apply/matrixP=> i j; rewrite !mxE mulrDr. Qed.",
    "Lemma scalemxA x y A : x *m: (y *m: A) = (x * y) *m: A.\nProof. by apply/matrixP=> i j; rewrite !mxE mulrA. Qed.",
    "Lemma trmx_delta m n i j : (delta_mx i j)^T = delta_mx j i :> 'M[R]_(n, m).\nProof. by apply/matrixP=> i' j'; rewrite !mxE andbC. Qed.",
    "Lemma delta_mx_lshift m n1 n2 i j :\n  delta_mx i (lshift n2 j) = row_mx (delta_mx i j) 0 :> 'M_(m, n1 + n2).\nProof.\napply/matrixP=> i' j'; rewrite !mxE -(can_eq splitK) (unsplitK (inl _ _)).\nby case: split => ?; rewrite mxE ?andbF.\nQed.",
    "Lemma delta_mx_rshift m n1 n2 i j :\n  delta_mx i (rshift n1 j) = row_mx 0 (delta_mx i j) :> 'M_(m, n1 + n2).\nProof.\napply/matrixP=> i' j'; rewrite !mxE -(can_eq splitK) (unsplitK (inr _ _)).\nby case: split => ?; rewrite mxE ?andbF.\nQed.",
    "Lemma delta_mx_ushift m1 m2 n i j :\n  delta_mx (lshift m2 i) j = col_mx (delta_mx i j) 0 :> 'M_(m1 + m2, n).\nProof.\napply/matrixP=> i' j'; rewrite !mxE -(can_eq splitK) (unsplitK (inl _ _)).\nby  case: split => ?; rewrite mxE.\nQed.",
    "Lemma delta_mx_dshift m1 m2 n i j :\n  delta_mx (rshift m1 i) j = col_mx 0 (delta_mx i j) :> 'M_(m1 + m2, n).\nProof.\napply/matrixP=> i' j'; rewrite !mxE -(can_eq splitK) (unsplitK (inr _ _)).\nby case: split => ?; rewrite mxE.\nQed.",
    "Lemma vec_mx_delta m n i j :\n  vec_mx (delta_mx 0 (mxvec_index i j)) = delta_mx i j :> 'M_(m, n).\nProof.\nby apply/matrixP=> i' j'; rewrite !mxE /= [_ == _](inj_eq enum_rank_inj).\nQed.",
    "Lemma mxvec_delta m n i j :\n  mxvec (delta_mx i j) = delta_mx 0 (mxvec_index i j) :> 'rV_(m * n).\nProof. by rewrite -vec_mx_delta vec_mxK. Qed.",
    "Lemma trmx1 n : (1%:M)^T = 1%:M :> 'M[R]_n. Proof. exact: tr_scalar_mx. Qed.",
    "Lemma row1 n i : row i (1%:M : 'M_n) = delta_mx 0 i.\nProof. by apply/rowP=> j; rewrite !mxE eq_sym. Qed.",
    "Lemma col1 n i : col i (1%:M : 'M_n) = delta_mx i 0.\nProof. by apply/colP => j; rewrite !mxE eqxx andbT. Qed.",
    "Lemma mulmxA m n p q (A : 'M_(m, n)) (B : 'M_(n, p)) (C : 'M_(p, q)) :\n  A *m (B *m C) = A *m B *m C.\nProof.\napply/matrixP=> i l /[!mxE]; under eq_bigr do rewrite mxE big_distrr/=.\nrewrite exchange_big; apply: eq_bigr => j _; rewrite mxE big_distrl /=.\nby under eq_bigr do rewrite mulrA.\nQed.",
    "Lemma mul0mx m n p (A : 'M_(n, p)) : 0 *m A = 0 :> 'M_(m, p).\nProof.\nby apply/matrixP=> i k; rewrite !mxE big1 //= => j _; rewrite mxE mul0r.\nQed.",
    "Lemma mulmx0 m n p (A : 'M_(m, n)) : A *m 0 = 0 :> 'M_(m, p).\nProof.\nby apply/matrixP=> i k; rewrite !mxE big1 // => j _; rewrite mxE mulr0.\nQed.",
    "Lemma mulmxDl m n p (A1 A2 : 'M_(m, n)) (B : 'M_(n, p)) :\n  (A1 + A2) *m B = A1 *m B + A2 *m B.\nProof.\napply/matrixP=> i k; rewrite !mxE -big_split /=.\nby apply: eq_bigr => j _; rewrite !mxE -mulrDl.\nQed.",
    "Lemma mulmxDr m n p (A : 'M_(m, n)) (B1 B2 : 'M_(n, p)) :\n  A *m (B1 + B2) = A *m B1 + A *m B2.\nProof.\napply/matrixP=> i k; rewrite !mxE -big_split /=.\nby apply: eq_bigr => j _; rewrite mxE mulrDr.\nQed.",
    "Lemma mulmx_suml m n p (A : 'M_(n, p)) I r P (B_ : I -> 'M_(m, n)) :\n   (\\sum_(i <- r | P i) B_ i) *m A = \\sum_(i <- r | P i) B_ i *m A.\nProof.\nby apply: (big_morph (mulmx^~ A)) => [B C|]; rewrite ?mul0mx ?mulmxDl.\nQed.",
    "Lemma mulmx_sumr m n p (A : 'M_(m, n)) I r P (B_ : I -> 'M_(n, p)) :\n   A *m (\\sum_(i <- r | P i) B_ i) = \\sum_(i <- r | P i) A *m B_ i.\nProof.\nby apply: (big_morph (mulmx A)) => [B C|]; rewrite ?mulmx0 ?mulmxDr.\nQed.",
    "Lemma rowE m n i (A : 'M_(m, n)) : row i A = delta_mx 0 i *m A.\nProof.\napply/rowP=> j; rewrite !mxE (bigD1_ord i) //= mxE !eqxx mul1r.\nby rewrite big1 ?addr0 // => i'; rewrite mxE /= lift_eqF mul0r.\nQed.",
    "Lemma colE m n i (A : 'M_(m, n)) : col i A = A *m delta_mx i 0.\nProof.\napply/colP=> j; rewrite !mxE (bigD1_ord i) //= mxE !eqxx mulr1.\nby rewrite big1 ?addr0 // => i'; rewrite mxE /= lift_eqF mulr0.\nQed.",
    "Lemma mul_rVP m n A B :((@mulmx 1 m n)^~ A =1 mulmx^~ B) <-> (A = B).\nProof. by split=> [eqAB|->//]; apply/row_matrixP => i; rewrite !rowE eqAB. Qed.",
    "Lemma row_mul m n p (i : 'I_m) A (B : 'M_(n, p)) :\n  row i (A *m B) = row i A *m B.\nProof. by rewrite !rowE mulmxA. Qed.",
    "Lemma mxsub_mul m n m' n' p f g (A : 'M_(m, p)) (B : 'M_(p, n)) :\n  mxsub f g (A *m B) = rowsub f A *m colsub g B :> 'M_(m', n').\nProof. by split_mxE; under [RHS]eq_bigr do rewrite !mxE. Qed.",
    "Lemma mul_rowsub_mx m n m' p f (A : 'M_(m, p)) (B : 'M_(p, n)) :\n  rowsub f A *m B = rowsub f (A *m B) :> 'M_(m', n).\nProof. by rewrite mxsub_mul mxsub_id. Qed.",
    "Lemma mulmx_colsub m n n' p g (A : 'M_(m, p)) (B : 'M_(p, n)) :\n  A *m colsub g B = colsub g (A *m B) :> 'M_(m, n').\nProof. by rewrite mxsub_mul mxsub_id. Qed.",
    "Lemma mul_delta_mx_cond m n p (j1 j2 : 'I_n) (i1 : 'I_m) (k2 : 'I_p) :\n  delta_mx i1 j1 *m delta_mx j2 k2 = delta_mx i1 k2 *+ (j1 == j2).\nProof.\napply/matrixP => i k; rewrite !mxE (bigD1_ord j1) //=.\nrewrite mulmxnE !mxE !eqxx andbT -natrM -mulrnA !mulnb !andbA andbAC.\nby rewrite big1 ?addr0 // => j; rewrite !mxE andbC -natrM lift_eqF.\nQed.",
    "Lemma mul_delta_mx m n p (j : 'I_n) (i : 'I_m) (k : 'I_p) :\n  delta_mx i j *m delta_mx j k = delta_mx i k.\nProof. by rewrite mul_delta_mx_cond eqxx. Qed.",
    "Lemma mul_delta_mx_0 m n p (j1 j2 : 'I_n) (i1 : 'I_m) (k2 : 'I_p) :\n  j1 != j2 -> delta_mx i1 j1 *m delta_mx j2 k2 = 0.\nProof. by rewrite mul_delta_mx_cond => /negPf->. Qed.",
    "Lemma mul_diag_mx m n d (A : 'M_(m, n)) :\n  diag_mx d *m A = \\matrix_(i, j) (d 0 i * A i j).\nProof.\napply/matrixP=> i j; rewrite !mxE (bigD1 i) //= mxE eqxx big1 ?addr0 // => i'.\nby rewrite mxE eq_sym mulrnAl => /negPf->.\nQed.",
    "Lemma mul_mx_diag m n (A : 'M_(m, n)) d :\n  A *m diag_mx d = \\matrix_(i, j) (A i j * d 0 j).\nProof.\napply/matrixP=> i j; rewrite !mxE (bigD1 j) //= mxE eqxx big1 ?addr0 // => i'.\nby rewrite mxE eq_sym mulrnAr; move/negPf->.\nQed.",
    "Lemma mulmx_diag n (d e : 'rV_n) :\n  diag_mx d *m diag_mx e = diag_mx (\\row_j (d 0 j * e 0 j)).\nProof. by apply/matrixP=> i j; rewrite mul_diag_mx !mxE mulrnAr. Qed.",
    "Lemma scalar_mxM n a b : (a * b)%:M = a%:M *m b%:M :> 'M_n.\nProof.\nrewrite -[in RHS]diag_const_mx mul_diag_mx.\nby apply/matrixP => i j; rewrite !mxE mulrnAr.\nQed.",
    "Lemma mul1mx m n (A : 'M_(m, n)) : 1%:M *m A = A.\nProof.\nby rewrite -diag_const_mx mul_diag_mx; apply/matrixP => i j; rewrite !mxE mul1r.\nQed.",
    "Lemma mulmx1 m n (A : 'M_(m, n)) : A *m 1%:M = A.\nProof.\nby rewrite -diag_const_mx mul_mx_diag; apply/matrixP=> i j; rewrite !mxE mulr1.\nQed.",
    "Lemma rowsubE m m' n f (A : 'M_(m, n)) :\n   rowsub f A = rowsub f 1%:M *m A :> 'M_(m', n).\nProof. by rewrite mul_rowsub_mx mul1mx. Qed.",
    "Lemma mul_col_perm m n p s (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  col_perm s A *m B = A *m row_perm s^-1 B.\nProof.\napply/matrixP=> i k; rewrite !mxE (reindex_perm s^-1).\nby apply: eq_bigr => j _ /=; rewrite !mxE permKV.\nQed.",
    "Lemma mul_row_perm m n p s (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  A *m row_perm s B = col_perm s^-1 A *m B.\nProof. by rewrite mul_col_perm invgK. Qed.",
    "Lemma mul_xcol m n p j1 j2 (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  xcol j1 j2 A *m B = A *m xrow j1 j2 B.\nProof. by rewrite mul_col_perm tpermV. Qed.",
    "Lemma col_permE m n s (A : 'M_(m, n)) : col_perm s A = A *m perm_mx s^-1.\nProof. by rewrite mul_row_perm mulmx1 invgK. Qed.",
    "Lemma row_permE m n s (A : 'M_(m, n)) : row_perm s A = perm_mx s *m A.\nProof.\nby rewrite -[perm_mx _]mul1mx mul_row_perm mulmx1 -mul_row_perm mul1mx.\nQed.",
    "Lemma xcolE m n j1 j2 (A : 'M_(m, n)) : xcol j1 j2 A = A *m tperm_mx j1 j2.\nProof. by rewrite /xcol col_permE tpermV. Qed.",
    "Lemma xrowE m n i1 i2 (A : 'M_(m, n)) : xrow i1 i2 A = tperm_mx i1 i2 *m A.\nProof. exact: row_permE. Qed.",
    "Lemma perm_mxEsub n s : @perm_mx n s = rowsub s 1%:M.\nProof. by rewrite /perm_mx row_permEsub. Qed.",
    "Lemma tperm_mxEsub n i1 i2 : @tperm_mx n i1 i2 = rowsub (tperm i1 i2) 1%:M.\nProof. by rewrite /tperm_mx perm_mxEsub. Qed.",
    "Lemma tr_perm_mx n (s : 'S_n) : (perm_mx s)^T = perm_mx s^-1.\nProof. by rewrite -[_^T]mulmx1 tr_row_perm mul_col_perm trmx1 mul1mx. Qed.",
    "Lemma tr_tperm_mx n i1 i2 : (tperm_mx i1 i2)^T = tperm_mx i1 i2 :> 'M_n.\nProof. by rewrite tr_perm_mx tpermV. Qed.",
    "Lemma perm_mx1 n : perm_mx 1 = 1%:M :> 'M_n.\nProof. exact: row_perm1. Qed.",
    "Lemma perm_mxM n (s t : 'S_n) : perm_mx (s * t) = perm_mx s *m perm_mx t.\nProof. by rewrite -row_permE -row_permM. Qed.",
    "Lemma is_perm_mxP n (A : 'M_n) :\n  reflect (exists s, A = perm_mx s) (is_perm_mx A).\nProof. by apply: (iffP existsP) => [] [s /eqP]; exists s. Qed.",
    "Lemma perm_mx_is_perm n (s : 'S_n) : is_perm_mx (perm_mx s).\nProof. by apply/is_perm_mxP; exists s. Qed.",
    "Lemma is_perm_mx1 n : is_perm_mx (1%:M : 'M_n).\nProof. by rewrite -perm_mx1 perm_mx_is_perm. Qed.",
    "Lemma is_perm_mxMl n (A B : 'M_n) :\n  is_perm_mx A -> is_perm_mx (A *m B) = is_perm_mx B.\nProof.\ncase/is_perm_mxP=> s ->.\napply/is_perm_mxP/is_perm_mxP=> [[t def_t] | [t ->]]; last first.\n  by exists (s * t)%g; rewrite perm_mxM.\nexists (s^-1 * t)%g.\nby rewrite perm_mxM -def_t -!row_permE -row_permM mulVg row_perm1.\nQed.",
    "Lemma is_perm_mx_tr n (A : 'M_n) : is_perm_mx A^T = is_perm_mx A.\nProof.\napply/is_perm_mxP/is_perm_mxP=> [[t def_t] | [t ->]]; exists t^-1%g.\n  by rewrite -tr_perm_mx -def_t trmxK.\nby rewrite tr_perm_mx.\nQed.",
    "Lemma is_perm_mxMr n (A B : 'M_n) :\n  is_perm_mx B -> is_perm_mx (A *m B) = is_perm_mx A.\nProof.\ncase/is_perm_mxP=> s ->.\nrewrite -[s]invgK -col_permE -is_perm_mx_tr tr_col_perm row_permE.\nby rewrite is_perm_mxMl (perm_mx_is_perm, is_perm_mx_tr).\nQed.",
    "Lemma pid_mx_0 m n : pid_mx 0 = 0 :> 'M_(m, n).\nProof. by apply/matrixP=> i j; rewrite !mxE andbF. Qed.",
    "Lemma pid_mx_1 r : pid_mx r = 1%:M :> 'M_r.\nProof. by apply/matrixP=> i j; rewrite !mxE ltn_ord andbT. Qed.",
    "Lemma pid_mx_row n r : pid_mx r = row_mx 1%:M 0 :> 'M_(r, r + n).\nProof.\napply/matrixP=> i j; rewrite !mxE ltn_ord andbT.\nby case: split_ordP => j' ->; rewrite !mxE// (val_eqE (lshift n i)) eq_shift.\nQed.",
    "Lemma pid_mx_col m r : pid_mx r = col_mx 1%:M 0 :> 'M_(r + m, r).\nProof.\napply/matrixP=> i j; rewrite !mxE andbC.\nby case: split_ordP => ? ->; rewrite !mxE//.\nQed.",
    "Lemma pid_mx_block m n r : pid_mx r = block_mx 1%:M 0 0 0 :> 'M_(r + m, r + n).\nProof.\napply/matrixP=> i j; rewrite !mxE row_mx0 andbC.\ndo ![case: split_ordP => ? -> /[!mxE]//].\nby rewrite (val_eqE (lshift n _)) eq_shift.\nQed.",
    "Lemma tr_pid_mx m n r : (pid_mx r)^T = pid_mx r :> 'M_(n, m).\nProof. by apply/matrixP=> i j /[!mxE]; case: eqVneq => // ->. Qed.",
    "Lemma pid_mx_minv m n r : pid_mx (minn m r) = pid_mx r :> 'M_(m, n).\nProof. by apply/matrixP=> i j; rewrite !mxE leq_min ltn_ord. Qed.",
    "Lemma pid_mx_minh m n r : pid_mx (minn n r) = pid_mx r :> 'M_(m, n).\nProof. by apply: trmx_inj; rewrite !tr_pid_mx pid_mx_minv. Qed.",
    "Lemma mul_pid_mx m n p q r :\n  (pid_mx q : 'M_(m, n)) *m (pid_mx r : 'M_(n, p)) = pid_mx (minn n (minn q r)).\nProof.\napply/matrixP=> i k; rewrite !mxE !leq_min.\nhave [le_n_i | lt_i_n] := leqP n i.\n  rewrite andbF big1 // => j _.\n  by rewrite -pid_mx_minh !mxE leq_min ltnNge le_n_i andbF mul0r.\nrewrite (bigD1 (Ordinal lt_i_n)) //= big1 ?addr0 => [|j].\n  by rewrite !mxE eqxx /= -natrM mulnb andbCA.\nby rewrite -val_eqE /= !mxE eq_sym -natrM => /negPf->.\nQed.",
    "Lemma pid_mx_id m n p r :\n  r <= n -> (pid_mx r : 'M_(m, n)) *m (pid_mx r : 'M_(n, p)) = pid_mx r.\nProof. by move=> le_r_n; rewrite mul_pid_mx minnn (minn_idPr _). Qed.",
    "Lemma pid_mxErow m n (le_mn : m <= n) :\n  pid_mx m = rowsub (widen_ord le_mn) 1%:M.\nProof. by apply/matrixP=> i j; rewrite !mxE -!val_eqE/= ltn_ord andbT. Qed.",
    "Lemma pid_mxEcol m n (le_mn : m <= n) :\n  pid_mx n = colsub (widen_ord le_mn) 1%:M.\nProof. by apply/matrixP=> i j; rewrite !mxE -!val_eqE/= ltn_ord andbT. Qed.",
    "Lemma mul_mx_row m n p1 p2 (A : 'M_(m, n)) (Bl : 'M_(n, p1)) (Br : 'M_(n, p2)) :\n  A *m row_mx Bl Br = row_mx (A *m Bl) (A *m Br).\nProof.\napply/matrixP=> i k; rewrite !mxE.\nby case defk: (split k) => /[!mxE]; under eq_bigr do rewrite mxE defk.\nQed.",
    "Lemma mul_col_mx m1 m2 n p (Au : 'M_(m1, n)) (Ad : 'M_(m2, n)) (B : 'M_(n, p)) :\n  col_mx Au Ad *m B = col_mx (Au *m B) (Ad *m B).\nProof.\napply/matrixP=> i k; rewrite !mxE.\nby case defi: (split i) => /[!mxE]; under eq_bigr do rewrite mxE defi.\nQed.",
    "Lemma mul_row_col m n1 n2 p (Al : 'M_(m, n1)) (Ar : 'M_(m, n2))\n                            (Bu : 'M_(n1, p)) (Bd : 'M_(n2, p)) :\n  row_mx Al Ar *m col_mx Bu Bd = Al *m Bu + Ar *m Bd.\nProof.\napply/matrixP=> i k; rewrite !mxE big_split_ord /=.\ncongr (_ + _); apply: eq_bigr => j _; first by rewrite row_mxEl col_mxEu.\nby rewrite row_mxEr col_mxEd.\nQed.",
    "Lemma mul_col_row m1 m2 n p1 p2 (Au : 'M_(m1, n)) (Ad : 'M_(m2, n))\n                                (Bl : 'M_(n, p1)) (Br : 'M_(n, p2)) :\n  col_mx Au Ad *m row_mx Bl Br\n     = block_mx (Au *m Bl) (Au *m Br) (Ad *m Bl) (Ad *m Br).\nProof. by rewrite mul_col_mx !mul_mx_row. Qed.",
    "Lemma mul_row_block m n1 n2 p1 p2 (Al : 'M_(m, n1)) (Ar : 'M_(m, n2))\n                                  (Bul : 'M_(n1, p1)) (Bur : 'M_(n1, p2))\n                                  (Bdl : 'M_(n2, p1)) (Bdr : 'M_(n2, p2)) :\n  row_mx Al Ar *m block_mx Bul Bur Bdl Bdr\n   = row_mx (Al *m Bul + Ar *m Bdl) (Al *m Bur + Ar *m Bdr).\nProof. by rewrite block_mxEh mul_mx_row !mul_row_col. Qed.",
    "Lemma mul_block_col m1 m2 n1 n2 p (Aul : 'M_(m1, n1)) (Aur : 'M_(m1, n2))\n                                  (Adl : 'M_(m2, n1)) (Adr : 'M_(m2, n2))\n                                  (Bu : 'M_(n1, p)) (Bd : 'M_(n2, p)) :\n  block_mx Aul Aur Adl Adr *m col_mx Bu Bd\n   = col_mx (Aul *m Bu + Aur *m Bd) (Adl *m Bu + Adr *m Bd).\nProof. by rewrite mul_col_mx !mul_row_col. Qed.",
    "Lemma mulmx_block m1 m2 n1 n2 p1 p2 (Aul : 'M_(m1, n1)) (Aur : 'M_(m1, n2))\n                                    (Adl : 'M_(m2, n1)) (Adr : 'M_(m2, n2))\n                                    (Bul : 'M_(n1, p1)) (Bur : 'M_(n1, p2))\n                                    (Bdl : 'M_(n2, p1)) (Bdr : 'M_(n2, p2)) :\n  block_mx Aul Aur Adl Adr *m block_mx Bul Bur Bdl Bdr\n    = block_mx (Aul *m Bul + Aur *m Bdl) (Aul *m Bur + Aur *m Bdr)\n               (Adl *m Bul + Adr *m Bdl) (Adl *m Bur + Adr *m Bdr).\nProof. by rewrite mul_col_mx !mul_row_block. Qed.",
    "Lemma mulmx_lsub m n p k (A : 'M_(m, n)) (B : 'M_(n, p + k)) :\n  A *m lsubmx B = lsubmx (A *m B).\nProof. by rewrite !lsubmxEsub mulmx_colsub. Qed.",
    "Lemma mulmx_rsub m n p k (A : 'M_(m, n)) (B : 'M_(n, p + k)) :\n  A *m rsubmx B = rsubmx (A *m B).\nProof. by rewrite !rsubmxEsub mulmx_colsub. Qed.",
    "Lemma mul_usub_mx m k n p (A : 'M_(m + k, n)) (B : 'M_(n, p)) :\n  usubmx A *m B = usubmx (A *m B).\nProof. by rewrite !usubmxEsub mul_rowsub_mx. Qed.",
    "Lemma mul_dsub_mx m k n p (A : 'M_(m + k, n)) (B : 'M_(n, p)) :\n  dsubmx A *m B = dsubmx (A *m B).\nProof. by rewrite !dsubmxEsub mul_rowsub_mx. Qed.",
    "Lemma mxtrace1 : \\tr (1%:M : 'M[R]_n) = n%:R. Proof. exact: mxtrace_scalar. Qed.",
    "Lemma mulmxE : mulmx = *%R. Proof. by []. Qed.",
    "Lemma idmxE : 1%:M = 1 :> 'M_n. Proof. by []. Qed.",
    "Lemma scalar_mx_is_multiplicative : multiplicative (@scalar_mx R n).\nProof. by split=> //; apply: scalar_mxM. Qed.",
    "Lemma lift0_perm0 s : lift0_perm s 0 = 0.\nProof. exact: lift_perm_id. Qed.",
    "Lemma lift0_perm_lift s k' :\n  lift0_perm s (lift 0 k') = lift (0 : 'I_n.+1) (s k').\nProof. exact: lift_perm_lift. Qed.",
    "Lemma lift0_permK s : cancel (lift0_perm s) (lift0_perm s^-1).\nProof. by move=> i; rewrite /lift0_perm -lift_permV permK. Qed.",
    "Lemma lift0_perm_eq0 s i : (lift0_perm s i == 0) = (i == 0).\nProof. by rewrite (canF_eq (lift0_permK s)) lift0_perm0. Qed.",
    "Lemma lift0_mx_perm s : lift0_mx (perm_mx s) = perm_mx (lift0_perm s).\nProof.\napply/matrixP=> /= i j; rewrite !mxE split1 /=; case: unliftP => [i'|] -> /=.\n  rewrite lift0_perm_lift !mxE split1 /=.\n  by case: unliftP => [j'|] ->; rewrite ?(inj_eq (lift_inj _)) /= !mxE.\nrewrite lift0_perm0 !mxE split1 /=.\nby case: unliftP => [j'|] ->; rewrite /= mxE.\nQed.",
    "Lemma lift0_mx_is_perm s : is_perm_mx (lift0_mx (perm_mx s)).\nProof. by rewrite lift0_mx_perm perm_mx_is_perm. Qed.",
    "Lemma exp_block_diag_mx m n (A: 'M_m.+1) (B : 'M_n.+1) k :\n  (block_mx A 0 0 B) ^+ k = block_mx (A ^+ k) 0 0 (B ^+ k).\nProof.\nelim: k=> [|k IHk]; first by rewrite !expr0 -scalar_mx_block.\nrewrite !exprS IHk [LHS](mulmx_block A _ _ _ (A ^+ k)).\nby rewrite !mulmx0 !mul0mx !add0r !addr0.\nQed.",
    "Lemma trmx_mul_rev (R : pzSemiRingType) m n p\n    (A : 'M[R]_(m, n)) (B : 'M[R]_(n, p)) :\n  (A *m B)^T = (B : 'M[R^c]_(n, p))^T *m (A : 'M[R^c]_(m, n))^T.\nProof. by apply/matrixP=> k i /[!mxE]; apply: eq_bigr => j _ /[!mxE]. Qed.",
    "Lemma matrix_nonzero1 : 1%:M != 0 :> 'M[R]_n.\nProof. by apply/eqP=> /matrixP/(_ 0 0)/eqP; rewrite !mxE oner_eq0. Qed.",
    "Lemma map_mxM A B : (A *m B)^f = A^f *m B^f :> 'M_(m, p).\nProof.\napply/matrixP=> i k; rewrite !mxE rmorph_sum //.\nby apply: eq_bigr => j; rewrite !mxE rmorphM.\nQed.",
    "Lemma map_delta_mx i j : (delta_mx i j)^f = delta_mx i j :> 'M_(m, n).\nProof. by apply/matrixP=> i' j'; rewrite !mxE rmorph_nat. Qed.",
    "Lemma map_diag_mx d : (diag_mx d)^f = diag_mx d^f :> 'M_n.\nProof. by apply/matrixP=> i j; rewrite !mxE rmorphMn. Qed.",
    "Lemma map_scalar_mx a : a%:M^f = (f a)%:M :> 'M_n.\nProof. by apply/matrixP=> i j; rewrite !mxE rmorphMn. Qed.",
    "Lemma map_mx1 : 1%:M^f = 1%:M :> 'M_n.\nProof. by rewrite map_scalar_mx rmorph1. Qed.",
    "Lemma map_perm_mx (s : 'S_n) : (perm_mx s)^f = perm_mx s.\nProof. by apply/matrixP=> i j; rewrite !mxE rmorph_nat. Qed.",
    "Lemma map_tperm_mx (i1 i2 : 'I_n) : (tperm_mx i1 i2)^f = tperm_mx i1 i2.\nProof. exact: map_perm_mx. Qed.",
    "Lemma map_pid_mx r : (pid_mx r)^f = pid_mx r :> 'M_(m, n).\nProof. by apply/matrixP=> i j; rewrite !mxE rmorph_nat. Qed.",
    "Lemma trace_map_mx (A : 'M_n) : \\tr A^f = f (\\tr A).\nProof. by rewrite rmorph_sum; apply: eq_bigr => i _; rewrite mxE. Qed.",
    "Lemma map_mx_is_multiplicative n : multiplicative (map_mx f : 'M_n -> 'M_n).\nProof. by split; [apply: map_mxM | apply: map_mx1]. Qed.",
    "Lemma comm_mx_sym f g : comm_mx f g -> comm_mx g f.\nProof. by rewrite /comm_mx. Qed.",
    "Lemma comm_mx_refl f : comm_mx f f. Proof. by []. Qed.",
    "Lemma comm_mx0 f : comm_mx f 0. Proof. by rewrite /comm_mx mulmx0 mul0mx. Qed.",
    "Lemma comm0mx f : comm_mx 0 f. Proof. by rewrite /comm_mx mulmx0 mul0mx. Qed.",
    "Lemma comm_mx1 f : comm_mx f 1%:M.\nProof. by rewrite /comm_mx mulmx1 mul1mx. Qed.",
    "Lemma comm1mx f : comm_mx 1%:M f.\nProof. by rewrite /comm_mx mulmx1 mul1mx. Qed.",
    "Lemma comm_mxD f g g' : comm_mx f g -> comm_mx f g' -> comm_mx f (g + g').\nProof. by rewrite /comm_mx mulmxDl mulmxDr => -> ->. Qed.",
    "Lemma comm_mxM f g g' : comm_mx f g -> comm_mx f g' -> comm_mx f (g *m g').\nProof. by rewrite /comm_mx mulmxA => ->; rewrite -!mulmxA => ->. Qed.",
    "Lemma comm_mx_sum I (s : seq I) (P : pred I) (F : I -> 'M[R]_n) (f : 'M[R]_n) :\n  (forall i : I, P i -> comm_mx f (F i)) -> comm_mx f (\\sum_(i <- s | P i) F i).\nProof. by move=> comm_mxfF; elim/big_ind: _ => // g h; apply: comm_mxD. Qed.",
    "Lemma comm_mxP f g : reflect (comm_mx f g) (comm_mxb f g).\nProof. exact: eqP. Qed.",
    "Lemma all_comm_mxP fs :\n  reflect {in fs &, forall f g, f *m g = g *m f} (all_comm_mx fs).\nProof. by apply: (iffP allrelP) => fsP ? ? ? ?; apply/eqP/fsP. Qed.",
    "Lemma all_comm_mx1 f : all_comm_mx [:: f].\nProof. by rewrite /comm_mxb all2rel1. Qed.",
    "Lemma all_comm_mx2P f g : reflect (f *m g = g *m f) (all_comm_mx [:: f; g]).\nProof. by rewrite /comm_mxb /= all2rel2 ?eqxx //; exact: eqP. Qed.",
    "Lemma all_comm_mx_cons f fs :\n  all_comm_mx (f :: fs) = all (comm_mxb f) fs && all_comm_mx fs.\nProof. by rewrite /comm_mxb /= all2rel_cons //= eqxx. Qed.",
    "Lemma comm_mxE : comm_mx = @GRing.comm _. Proof. by []. Qed.",
    "Lemma trmx_mul A B : (A *m B)^T = B^T *m A^T.\nProof.\nrewrite trmx_mul_rev; apply/matrixP=> k i; rewrite !mxE.\nby apply: eq_bigr => j _; rewrite mulrC.\nQed.",
    "Lemma diag_mxC n (d e : 'rV[R]_n) :\n  diag_mx d *m diag_mx e = diag_mx e *m diag_mx d.\nProof.\nby rewrite !mulmx_diag; congr (diag_mx _); apply/rowP=> i; rewrite !mxE mulrC.\nQed.",
    "Lemma diag_mx_comm n (d e : 'rV[R]_n) : comm_mx (diag_mx d) (diag_mx e).\nProof. exact: diag_mxC. Qed.",
    "Lemma scalar_mxC m n a (A : 'M[R]_(m, n)) : A *m a%:M = a%:M *m A.\nProof.\nrewrite -!diag_const_mx mul_mx_diag mul_diag_mx.\nby apply/matrixP => i j; rewrite !mxE mulrC.\nQed.",
    "Lemma comm_mx_scalar n a (A : 'M[R]_n) : comm_mx A a%:M.\nProof. exact: scalar_mxC. Qed.",
    "Lemma comm_scalar_mx n a (A : 'M[R]_n) : comm_mx a%:M A.\nProof. exact/comm_mx_sym/comm_mx_scalar. Qed.",
    "Lemma mxtrace_mulC m n (A : 'M[R]_(m, n)) B : \\tr (A *m B) = \\tr (B *m A).\nProof.\nhave expand_trM C D: \\tr (C *m D) = \\sum_i \\sum_j C i j * D j i.\n  by apply: eq_bigr => i _; rewrite mxE.\nrewrite !{}expand_trM exchange_big /=.\nby do 2!apply: eq_bigr => ? _; apply: mulrC.\nQed.",
    "Lemma scalemx_const a b : a *: const_mx b = const_mx (a * b).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma matrix_sum_delta A :\n  A = \\sum_(i < m) \\sum_(j < n) A i j *: delta_mx i j.\nProof.\napply/matrixP=> i j.\nrewrite summxE (bigD1_ord i) // summxE (bigD1_ord j) //= !mxE !eqxx mulr1.\nrewrite !big1 ?addr0 //= => [i' | j'] _.\n  by rewrite summxE big1// => j' _; rewrite !mxE eq_liftF mulr0.\nby rewrite !mxE eqxx eq_liftF mulr0.\nQed.",
    "Lemma swizzle_mx_is_scalable m n p q f g k :\n  scalable (@swizzle_mx R m n p q f g k).\nProof. by move=> a A; apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma row_sum_delta n (u : 'rV_n) : u = \\sum_(j < n) u 0 j *: delta_mx 0 j.\nProof. by rewrite {1}[u]matrix_sum_delta big_ord1. Qed.",
    "Lemma scale_row_mx m n1 n2 a (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  a *: row_mx A1 A2 = row_mx (a *: A1) (a *: A2).\nProof. by split_mxE. Qed.",
    "Lemma scale_col_mx m1 m2 n a (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  a *: col_mx A1 A2 = col_mx (a *: A1) (a *: A2).\nProof. by split_mxE. Qed.",
    "Lemma scale_block_mx m1 m2 n1 n2 a (Aul : 'M_(m1, n1)) (Aur : 'M_(m1, n2))\n                                   (Adl : 'M_(m2, n1)) (Adr : 'M_(m2, n2)) :\n  a *: block_mx Aul Aur Adl Adr\n     = block_mx (a *: Aul) (a *: Aur) (a *: Adl) (a *: Adr).\nProof. by rewrite scale_col_mx !scale_row_mx. Qed.",
    "Lemma diag_mx_is_linear n : linear (@diag_mx R n).\nProof. by move=> a A B; apply/matrixP=> i j; rewrite !mxE mulrnAr mulrnDl. Qed.",
    "Lemma diag_mx_sum_delta n (d : 'rV_n) :\n  diag_mx d = \\sum_i d 0 i *: delta_mx i i.\nProof.\napply/matrixP=> i j; rewrite summxE (bigD1_ord i) //= !mxE eqxx /=.\nby rewrite eq_sym mulr_natr big1 ?addr0 // => i'; rewrite !mxE eq_liftF mulr0.\nQed.",
    "Lemma row_diag_mx n (d : 'rV_n) i : row i (diag_mx d) = d 0 i *: delta_mx 0 i.\nProof. by apply/rowP => j; rewrite !mxE eqxx eq_sym mulr_natr. Qed.",
    "Lemma scale_scalar_mx n a1 a2 : a1 *: a2%:M = (a1 * a2)%:M :> 'M_n.\nProof. by apply/matrixP=> i j; rewrite !mxE mulrnAr. Qed.",
    "Lemma scalemx1 n a : a *: 1%:M = a%:M :> 'M_n.\nProof. by rewrite scale_scalar_mx mulr1. Qed.",
    "Lemma scalar_mx_sum_delta n a : a%:M = \\sum_i a *: delta_mx i i :> 'M_n.\nProof.\nby rewrite -diag_const_mx diag_mx_sum_delta; under eq_bigr do rewrite mxE.\nQed.",
    "Lemma mx1_sum_delta n : 1%:M = \\sum_i delta_mx i i :> 'M[R]_n.\nProof. by rewrite [1%:M]scalar_mx_sum_delta -scaler_sumr scale1r. Qed.",
    "Lemma mulmxN m n p (A : 'M[R]_(m, n)) (B : 'M_(n, p)) : A *m (- B) = - (A *m B).\nProof.\nby apply/matrixP=> i k; rewrite !mxE -sumrN; under eq_bigr do rewrite mxE mulrN.\nQed.",
    "Lemma mulNmx m n p (A : 'M[R]_(m, n)) (B : 'M_(n, p)) : - A *m B = - (A *m B).\nProof.\nby apply/matrixP=> i k; rewrite !mxE -sumrN; under eq_bigr do rewrite mxE mulNr.\nQed.",
    "Lemma mulmxBl m n p (A1 A2 : 'M[R]_(m, n)) (B : 'M_(n, p)) :\n  (A1 - A2) *m B = A1 *m B - A2 *m B.\nProof. by rewrite mulmxDl mulNmx. Qed.",
    "Lemma mulmxBr m n p (A : 'M[R]_(m, n)) (B1 B2 : 'M_(n, p)) :\n  A *m (B1 - B2) = A *m B1 - A *m B2.\nProof. by rewrite mulmxDr mulmxN. Qed.",
    "Lemma scalemxAl m n p a (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  a *: (A *m B) = (a *: A) *m B.\nProof.\napply/matrixP=> i k; rewrite !mxE big_distrr /=.\nby apply: eq_bigr => j _; rewrite mulrA mxE.\nQed.",
    "Lemma mulmx_sum_row m n (u : 'rV_m) (A : 'M_(m, n)) :\n  u *m A = \\sum_i u 0 i *: row i A.\nProof. by apply/rowP => j /[!(mxE, summxE)]; apply: eq_bigr => i _ /[!mxE]. Qed.",
    "Lemma mul_scalar_mx m n a (A : 'M_(m, n)) : a%:M *m A = a *: A.\nProof.\nby rewrite -diag_const_mx mul_diag_mx; apply/matrixP=> i j; rewrite !mxE.\nQed.",
    "Lemma mul_copid_mx_pid m n r :\n  r <= m -> copid_mx r *m pid_mx r = 0 :> 'M_(m, n).\nProof. by move=> le_r_m; rewrite mulmxBl mul1mx pid_mx_id ?subrr. Qed.",
    "Lemma mul_pid_mx_copid m n r :\n  r <= n -> pid_mx r *m copid_mx r = 0 :> 'M_(m, n).\nProof. by move=> le_r_n; rewrite mulmxBr mulmx1 pid_mx_id ?subrr. Qed.",
    "Lemma copid_mx_id n r : r <= n -> copid_mx r *m copid_mx r = copid_mx r :> 'M_n.\nProof.\nby move=> le_r_n; rewrite mulmxBl mul1mx mul_pid_mx_copid // oppr0 addr0.\nQed.",
    "Lemma mul_rV_lin1 u : u *m lin1_mx f = f u.\nProof.\nrewrite [u in RHS]matrix_sum_delta big_ord1 linear_sum; apply/rowP=> i.\nby rewrite mxE summxE; apply: eq_bigr => j _; rewrite linearZ !mxE.\nQed.",
    "Lemma mul_rV_lin u : u *m lin_mx f = mxvec (f (vec_mx u)).\nProof. exact: mul_rV_lin1. Qed.",
    "Lemma mul_vec_lin A : mxvec A *m lin_mx f = mxvec (f A).\nProof. by rewrite mul_rV_lin mxvecK. Qed.",
    "Lemma mx_rV_lin u : vec_mx (u *m lin_mx f) = f (vec_mx u).\nProof. by rewrite mul_rV_lin mxvecK. Qed.",
    "Lemma mx_vec_lin A : vec_mx (mxvec A *m lin_mx f) = f A.\nProof. by rewrite mul_rV_lin !mxvecK. Qed.",
    "Lemma mulmxr_is_linear B : linear (mulmxr B).\nProof. by move=> a A1 A2; rewrite /= mulmxDl scalemxAl. Qed.",
    "Lemma lin_mulmxr_is_linear : linear lin_mulmxr.\nProof.\nmove=> a A B; apply/row_matrixP; case/mxvec_indexP=> i j.\nrewrite linearP /= !rowE !mul_rV_lin /= vec_mx_delta -linearP mulmxDr.\ncongr (mxvec (_ + _)); apply/row_matrixP=> k.\nrewrite linearZ /= !row_mul rowE mul_delta_mx_cond.\nby case: (k == i); [rewrite -!rowE linearZ | rewrite !mul0mx raddf0].\nQed.",
    "Lemma mxtrace_is_scalar : scalar (@mxtrace R n).\nProof.\nmove=> a A B; rewrite mulr_sumr -big_split /=.\nby apply: eq_bigr=> i _; rewrite !mxE.\nQed.",
    "Lemma mxtraceZ a (A : 'M_n) : \\tr (a *: A) = a * \\tr A.\nProof. exact: scalarZ. Qed.",
    "Lemma map_mxZ a A : (a *: A)^f = f a *: A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE rmorphM. Qed.",
    "Lemma det_map_mx n' (A : 'M_n') : \\det A^f = f (\\det A).\nProof.\nrewrite rmorph_sum //; apply: eq_bigr => s _.\nrewrite rmorphM /= rmorph_sign rmorph_prod; congr (_ * _).\nby apply: eq_bigr => i _; rewrite mxE.\nQed.",
    "Lemma cofactor_map_mx (A : 'M_n) i j : cofactor A^f i j = f (cofactor A i j).\nProof. by rewrite rmorphM /= rmorph_sign -det_map_mx map_row' map_col'. Qed.",
    "Lemma map_mx_adj (A : 'M_n) : (\\adj A)^f = \\adj A^f.\nProof. by apply/matrixP=> i j; rewrite !mxE cofactor_map_mx. Qed.",
    "Lemma map_copid_mx n r : (copid_mx r)^f = copid_mx r :> 'M_n.\nProof. by rewrite map_mxB map_mx1 map_pid_mx. Qed.",
    "Lemma map_lin1_mx m n (g : 'rV_m -> 'rV_n) gf :\n  (forall v, (g v)^f = gf v^f) -> (lin1_mx g)^f = lin1_mx gf.\nProof.\nmove=> def_gf; apply/matrixP => i j; rewrite !mxE.\nby rewrite -(map_delta_mx f) -def_gf mxE.\nQed.",
    "Lemma map_lin_mx m1 n1 m2 n2 (g : 'M_(m1, n1) -> 'M_(m2, n2)) gf :\n  (forall A, (g A)^f = gf A^f) -> (lin_mx g)^f = lin_mx gf.\nProof.\nmove=> def_gf; apply: map_lin1_mx => A /=.\nby rewrite map_mxvec def_gf map_vec_mx.\nQed.",
    "Lemma comm_mxN f g : comm_mx f g -> comm_mx f (- g).\nProof. by rewrite /comm_mx mulmxN mulNmx => ->. Qed.",
    "Lemma comm_mxN1 f : comm_mx f (- 1%:M). Proof. exact/comm_mxN/comm_mx1. Qed.",
    "Lemma comm_mxB f g g' : comm_mx f g -> comm_mx f g' -> comm_mx f (g - g').\nProof. by move=> fg fg'; apply/comm_mxD => //; apply/comm_mxN. Qed.",
    "Lemma scalemxAr a A B : a *: (A *m B) = A *m (a *: B).\nProof. by apply: trmx_inj; rewrite trmx_mul !linearZ /= trmx_mul scalemxAl. Qed.",
    "Lemma mulmx_is_scalable A : scalable (@mulmx _ m n p A).\nProof. by move=> a B; rewrite scalemxAr. Qed.",
    "Lemma lin_mulmx_is_linear : linear lin_mulmx.\nProof.\nmove=> a A B; apply/row_matrixP=> i; rewrite linearP /= !rowE !mul_rV_lin /=.\nby rewrite -linearP /= scalemxAl mulmxDl.\nQed.",
    "Lemma lin_mul_row_is_linear : linear lin_mul_row.\nProof.\nmove=> a u v; apply/row_matrixP=> i; rewrite linearP /= !rowE !mul_rV_lin1 /=.\nby rewrite mulmxDl scalemxAl.\nQed.",
    "Lemma mul_vec_lin_row A u : mxvec A *m lin_mul_row u = u *m A.\nProof. by rewrite mul_rV_lin1 /= mxvecK. Qed.",
    "Lemma mxvec_dotmul m n (A : 'M[R]_(m, n)) u v :\n  mxvec (u^T *m v) *m (mxvec A)^T = u *m A *m v^T.\nProof.\ntransitivity (\\sum_i \\sum_j (u 0 i * A i j *: row j v^T)).\n  apply/rowP=> i; rewrite {i}ord1 mxE (reindex _ (curry_mxvec_bij _ _)) /=.\n  rewrite pair_bigA summxE; apply: eq_bigr => [[i j]] /= _.\n  by rewrite !mxE !mxvecE mxE big_ord1 mxE mulrAC.\nrewrite mulmx_sum_row exchange_big; apply: eq_bigr => j _ /=.\nby rewrite mxE -scaler_suml.\nQed.",
    "Lemma mul_mx_scalar m n a (A : 'M[R]_(m, n)) : A *m a%:M = a *: A.\nProof. by rewrite scalar_mxC mul_scalar_mx. Qed.",
    "Lemma determinant_multilinear n (A B C : 'M[R]_n) i0 b c :\n    row i0 A = b *: row i0 B + c *: row i0 C ->\n    row' i0 B = row' i0 A ->\n    row' i0 C = row' i0 A ->\n  \\det A = b * \\det B + c * \\det C.\nProof.\nrewrite -[_ + _](row_id 0); move/row_eq=> ABC.\nmove/row'_eq=> BA; move/row'_eq=> CA.\nrewrite !big_distrr -big_split; apply: eq_bigr => s _ /=.\nrewrite -!(mulrCA (_ ^+s)) -mulrDr; congr (_ * _).\nrewrite !(bigD1 i0 (_ : predT i0)) //= {}ABC !mxE mulrDl !mulrA.\nby congr (_ * _ + _ * _); apply: eq_bigr => i i0i; rewrite ?BA ?CA.\nQed.",
    "Lemma determinant_alternate n (A : 'M[R]_n) i1 i2 :\n  i1 != i2 -> A i1 =1 A i2 -> \\det A = 0.\nProof.\nmove=> neq_i12 eqA12; pose t := tperm i1 i2.\nhave oddMt s: (t * s)%g = ~~ s :> bool by rewrite odd_permM odd_tperm neq_i12.\nrewrite [\\det A](bigID (@odd_perm _)) /=.\napply: canLR (subrK _) _; rewrite add0r -sumrN.\nrewrite (reindex_inj (mulgI t)); apply: eq_big => //= s.\nrewrite oddMt => /negPf->; rewrite mulN1r mul1r; congr (- _).\nrewrite (reindex_perm t); apply: eq_bigr => /= i _.\nby rewrite permM tpermK /t; case: tpermP => // ->; rewrite eqA12.\nQed.",
    "Lemma det_tr n (A : 'M[R]_n) : \\det A^T = \\det A.\nProof.\nrewrite [\\det A^T](reindex_inj invg_inj) /=.\napply: eq_bigr => s _ /=; rewrite !odd_permV (reindex_perm s) /=.\nby congr (_ * _); apply: eq_bigr => i _; rewrite mxE permK.\nQed.",
    "Lemma det_perm n (s : 'S_n) : \\det (perm_mx s) = (-1) ^+ s :> R.\nProof.\nrewrite [\\det _](bigD1 s) //= big1 => [|i _]; last by rewrite /= !mxE eqxx.\nrewrite mulr1 big1 ?addr0 => //= t Dst.\ncase: (pickP (fun i => s i != t i)) => [i ist | Est].\n  by rewrite (bigD1 i) // mulrCA /= !mxE (negPf ist) mul0r.\nby case/eqP: Dst; apply/permP => i; move/eqP: (Est i).\nQed.",
    "Lemma det1 n : \\det (1%:M : 'M[R]_n) = 1.\nProof. by rewrite -perm_mx1 det_perm odd_perm1. Qed.",
    "Lemma det_mx00 (A : 'M[R]_0) : \\det A = 1.\nProof. by rewrite flatmx0 -(flatmx0 1%:M) det1. Qed.",
    "Lemma detZ n a (A : 'M[R]_n) : \\det (a *: A) = a ^+ n * \\det A.\nProof.\nrewrite big_distrr /=; apply: eq_bigr => s _; rewrite mulrCA; congr (_ * _).\nrewrite -[n in a ^+ n]card_ord -prodr_const -big_split /=.\nby apply: eq_bigr=> i _; rewrite mxE.\nQed.",
    "Lemma det0 n' : \\det (0 : 'M[R]_n'.+1) = 0.\nProof. by rewrite -(scale0r 0) detZ exprS !mul0r. Qed.",
    "Lemma det_scalar n a : \\det (a%:M : 'M[R]_n) = a ^+ n.\nProof. by rewrite -{1}(mulr1 a) -scale_scalar_mx detZ det1 mulr1. Qed.",
    "Lemma det_scalar1 a : \\det (a%:M : 'M[R]_1) = a.\nProof. exact: det_scalar. Qed.",
    "Lemma det_mx11  (M : 'M[R]_1) : \\det M = M 0 0.\nProof. by rewrite {1}[M]mx11_scalar det_scalar. Qed.",
    "Lemma det_mulmx n (A B : 'M[R]_n) : \\det (A *m B) = \\det A * \\det B.\nProof.\nrewrite big_distrl /=.\npose F := ('I_n ^ n)%type; pose AB s i j := A i j * B j (s i).\ntransitivity (\\sum_(f : F) \\sum_(s : 'S_n) (-1) ^+ s * \\prod_i AB s i (f i)).\n  rewrite exchange_big; apply: eq_bigr => /= s _; rewrite -big_distrr /=.\n  congr (_ * _); rewrite -(bigA_distr_bigA (AB s)) /=.\n  by apply: eq_bigr => x _; rewrite mxE.\nrewrite (bigID (fun f : F => injectiveb f)) /= addrC big1 ?add0r => [|f Uf].\n  rewrite (reindex (@pval _)) /=; last first.\n    pose in_Sn := insubd (1%g : 'S_n).\n    by exists in_Sn => /= f Uf; first apply: val_inj; apply: insubdK.\n  apply: eq_big => /= [s | s _]; rewrite ?(valP s) // big_distrr /=.\n  rewrite (reindex_inj (mulgI s)); apply: eq_bigr => t _ /=.\n  rewrite big_split /= [in LHS]mulrA mulrCA mulrA mulrCA mulrA.\n  rewrite -signr_addb odd_permM !pvalE; congr (_ * _); symmetry.\n  by rewrite (reindex_perm s); apply: eq_bigr => i; rewrite permM.\ntransitivity (\\det (\\matrix_(i, j) B (f i) j) * \\prod_i A i (f i)).\n  rewrite mulrC big_distrr /=; apply: eq_bigr => s _.\n  rewrite mulrCA big_split //=; congr (_ * (_ * _)).\n  by apply: eq_bigr => x _; rewrite mxE.\ncase/injectivePn: Uf => i1 [i2 Di12 Ef12].\nby rewrite (determinant_alternate Di12) ?simp //= => j; rewrite !mxE Ef12.\nQed.",
    "Lemma detM n' (A B : 'M[R]_n'.+1) : \\det (A * B) = \\det A * \\det B.\nProof. exact: det_mulmx. Qed.",
    "Lemma expand_cofactor n (A : 'M[R]_n) i j :\n  cofactor A i j =\n    \\sum_(s : 'S_n | s i == j) (-1) ^+ s * \\prod_(k | i != k) A k (s k).\nProof.\ncase: n A i j => [|n] A i0 j0; first by case: i0.\nrewrite (reindex (lift_perm i0 j0)); last first.\n  pose ulsf i (s : 'S_n.+1) k := odflt k (unlift (s i) (s (lift i k))).\n  have ulsfK i (s : 'S_n.+1) k: lift (s i) (ulsf i s k) = s (lift i k).\n    rewrite /ulsf; have:= neq_lift i k.\n    by rewrite -(can_eq (permK s)) => /unlift_some[] ? ? ->.\n  have inj_ulsf: injective (ulsf i0 _).\n    move=> s; apply: can_inj (ulsf (s i0) s^-1%g) _ => k'.\n    by rewrite {1}/ulsf ulsfK !permK liftK.\n  exists (fun s => perm (inj_ulsf s)) => [s _ | s].\n    by apply/permP=> k'; rewrite permE /ulsf lift_perm_lift lift_perm_id liftK.\n  move/(s _ =P _) => si0; apply/permP=> k.\n  case: (unliftP i0 k) => [k'|] ->; rewrite ?lift_perm_id //.\n  by rewrite lift_perm_lift -si0 permE ulsfK.\nrewrite /cofactor big_distrr /=.\napply: eq_big => [s | s _]; first by rewrite lift_perm_id eqxx.\nrewrite -signr_odd mulrA -signr_addb oddD -odd_lift_perm; congr (_ * _).\ncase: (pickP 'I_n) => [k0 _ | n0]; last first.\n  by rewrite !big1 // => [j /unlift_some[i] | i _]; have:= n0 i.\nrewrite (reindex (lift i0)).\n  by apply: eq_big => [k | k _] /=; rewrite ?neq_lift // !mxE lift_perm_lift.\nexists (fun k => odflt k0 (unlift i0 k)) => k; first by rewrite liftK.\nby case/unlift_some=> k' -> ->.\nQed.",
    "Lemma expand_det_row n (A : 'M[R]_n) i0 :\n  \\det A = \\sum_j A i0 j * cofactor A i0 j.\nProof.\nrewrite /(\\det A) (partition_big (fun s : 'S_n => s i0) predT) //=.\napply: eq_bigr => j0 _; rewrite expand_cofactor big_distrr /=.\napply: eq_bigr => s /eqP Dsi0.\nrewrite mulrCA (bigID (pred1 i0)) /= big_pred1_eq Dsi0; congr (_ * (_ * _)).\nby apply: eq_bigl => i; rewrite eq_sym.\nQed.",
    "Lemma cofactor_tr n (A : 'M[R]_n) i j : cofactor A^T i j = cofactor A j i.\nProof.\nrewrite /cofactor addnC; congr (_ * _).\nrewrite -tr_row' -tr_col' det_tr; congr (\\det _).\nby apply/matrixP=> ? ?; rewrite !mxE.\nQed.",
    "Lemma cofactorZ n a (A : 'M[R]_n) i j :\n  cofactor (a *: A) i j = a ^+ n.-1 * cofactor A i j.\nProof. by rewrite {1}/cofactor !linearZ detZ mulrCA mulrA. Qed.",
    "Lemma expand_det_col n (A : 'M[R]_n) j0 :\n  \\det A = \\sum_i (A i j0 * cofactor A i j0).\nProof.\nrewrite -det_tr (expand_det_row _ j0).\nby under eq_bigr do rewrite cofactor_tr mxE.\nQed.",
    "Lemma trmx_adj n (A : 'M[R]_n) : (\\adj A)^T = \\adj A^T.\nProof. by apply/matrixP=> i j; rewrite !mxE cofactor_tr. Qed.",
    "Lemma adjZ n a (A : 'M[R]_n) : \\adj (a *: A) = a^+n.-1 *: \\adj A.\nProof. by apply/matrixP=> i j; rewrite !mxE cofactorZ. Qed.",
    "Lemma mul_mx_adj n (A : 'M[R]_n) : A *m \\adj A = (\\det A)%:M.\nProof.\napply/matrixP=> i1 i2 /[!mxE]; have [->|Di] := eqVneq.\n  rewrite (expand_det_row _ i2) //=.\n  by apply: eq_bigr => j _; congr (_ * _); rewrite mxE.\npose B := \\matrix_(i, j) (if i == i2 then A i1 j else A i j).\nhave EBi12: B i1 =1 B i2 by move=> j; rewrite /= !mxE eqxx (negPf Di).\nrewrite -[_ *+ _](determinant_alternate Di EBi12) (expand_det_row _ i2).\napply: eq_bigr => j _; rewrite !mxE eqxx; congr (_ * (_ * _)).\napply: eq_bigr => s _; congr (_ * _); apply: eq_bigr => i _.\nby rewrite !mxE eq_sym -if_neg neq_lift.\nQed.",
    "Lemma mul_adj_mx n (A : 'M[R]_n) : \\adj A *m A = (\\det A)%:M.\nProof.\nby apply: trmx_inj; rewrite trmx_mul trmx_adj mul_mx_adj det_tr tr_scalar_mx.\nQed.",
    "Lemma adj1 n : \\adj (1%:M) = 1%:M :> 'M[R]_n.\nProof. by rewrite -{2}(det1 n) -mul_adj_mx mulmx1. Qed.",
    "Lemma mulmx1C n (A B : 'M[R]_n) : A *m B = 1%:M -> B *m A = 1%:M.\nProof.\nmove=> AB1; pose A' := \\det B *: \\adj A.\nsuffices kA: A' *m A = 1%:M by rewrite -[B]mul1mx -kA -(mulmxA A') AB1 mulmx1.\nby rewrite -scalemxAl mul_adj_mx scale_scalar_mx mulrC -det_mulmx AB1 det1.\nQed.",
    "Lemma det_ublock n1 n2 Aul (Aur : 'M[R]_(n1, n2)) Adr :\n  \\det (block_mx Aul Aur 0 Adr) = \\det Aul * \\det Adr.\nProof.\nelim: n1 => [|n1 IHn1] in Aul Aur *.\n  have ->: Aul = 1%:M by apply/matrixP=> i [].\n  rewrite det1 mul1r; congr (\\det _); apply/matrixP=> i j.\n  by do 2![rewrite !mxE; case: splitP => [[]|k] //=; move/val_inj=> <- {k}].\nrewrite (expand_det_col _ (lshift n2 0)) big_split_ord /=.\nrewrite addrC big1 1?simp => [|i _]; last by rewrite block_mxEdl mxE simp.\nrewrite (expand_det_col _ 0) big_distrl /=; apply: eq_bigr=> i _.\nrewrite block_mxEul -!mulrA; do 2!congr (_ * _).\nby rewrite col'_col_mx !col'Kl raddf0 row'Ku row'_row_mx IHn1.\nQed.",
    "Lemma det_lblock n1 n2 Aul (Adl : 'M[R]_(n2, n1)) Adr :\n  \\det (block_mx Aul 0 Adl Adr) = \\det Aul * \\det Adr.\nProof. by rewrite -det_tr tr_block_mx trmx0 det_ublock !det_tr. Qed.",
    "Lemma det_trig n (A : 'M[R]_n) : is_trig_mx A -> \\det A = \\prod_(i < n) A i i.\nProof.\nelim/trigsqmx_ind => [|k x c B Bt IHB]; first by rewrite ?big_ord0 ?det_mx00.\nrewrite det_lblock big_ord_recl det_mx11 IHB//; congr (_ * _).\n  by rewrite -[ord0](lshift0 _ 0) block_mxEul.\nby apply: eq_bigr => i; rewrite -!rshift1 block_mxEdr.\nQed.",
    "Lemma det_diag n (d : 'rV[R]_n) : \\det (diag_mx d) = \\prod_i d 0 i.\nProof. by rewrite det_trig//; apply: eq_bigr => i; rewrite !mxE eqxx. Qed.",
    "Lemma mulmx1_min m n (A : 'M[R]_(m, n)) B : A *m B = 1%:M -> m <= n.\nProof.\nmove=> AB1; rewrite leqNgt; apply/negP=> /subnKC; rewrite addSnnS.\nmove: (_ - _)%N => m' def_m; move: AB1; rewrite -{m}def_m in A B *.\nrewrite -(vsubmxK A) -(hsubmxK B) mul_col_row scalar_mx_block.\ncase/eq_block_mx=> /mulmx1C BlAu1 AuBr0 _ => /eqP/idPn[].\nby rewrite -[_ B]mul1mx -BlAu1 -mulmxA AuBr0 !mulmx0 eq_sym oner_neq0.\nQed.",
    "Lemma unitmxE A : (A \\in unitmx) = (\\det A \\is a GRing.unit).\nProof. by []. Qed.",
    "Lemma unitmx1 : 1%:M \\in unitmx. Proof. by rewrite unitmxE det1 unitr1. Qed.",
    "Lemma unitmx_perm s : perm_mx s \\in unitmx.\nProof. by rewrite unitmxE det_perm unitrX ?unitrN ?unitr1. Qed.",
    "Lemma unitmx_tr A : (A^T \\in unitmx) = (A \\in unitmx).\nProof. by rewrite unitmxE det_tr. Qed.",
    "Lemma unitmxZ a A : a \\is a GRing.unit -> (a *: A \\in unitmx) = (A \\in unitmx).\nProof. by move=> Ua; rewrite !unitmxE detZ unitrM unitrX. Qed.",
    "Lemma invmx1 : invmx 1%:M = 1%:M.\nProof. by rewrite /invmx det1 invr1 scale1r adj1 if_same. Qed.",
    "Lemma invmxZ a A : a *: A \\in unitmx -> invmx (a *: A) = a^-1 *: invmx A.\nProof.\nrewrite /invmx !unitmxE detZ unitrM => /andP[Ua U_A].\nrewrite Ua U_A adjZ !scalerA invrM {U_A}//=.\ncase: (posnP n) A => [-> | n_gt0] A; first by rewrite flatmx0 [_ *: _]flatmx0.\nrewrite unitrX_pos // in Ua; rewrite -[_ * _](mulrK Ua) mulrC -!mulrA.\nby rewrite -exprSr prednK // !mulrA divrK ?unitrX.\nQed.",
    "Lemma invmx_scalar a : invmx (a%:M) = a^-1%:M.\nProof.\ncase Ua: (a%:M \\in unitmx).\n  by rewrite -scalemx1 in Ua *; rewrite invmxZ // invmx1 scalemx1.\nrewrite /invmx Ua; have [->|n_gt0] := posnP n; first by rewrite ![_%:M]flatmx0.\nby rewrite unitmxE det_scalar unitrX_pos // in Ua; rewrite invr_out ?Ua.\nQed.",
    "Lemma mulVmx : {in unitmx, left_inverse 1%:M invmx mulmx}.\nProof.\nby move=> A nsA; rewrite /invmx nsA -scalemxAl mul_adj_mx scale_scalar_mx mulVr.\nQed.",
    "Lemma mulmxV : {in unitmx, right_inverse 1%:M invmx mulmx}.\nProof.\nby move=> A nsA; rewrite /invmx nsA -scalemxAr mul_mx_adj scale_scalar_mx mulVr.\nQed.",
    "Lemma mulKmx m : {in unitmx, @left_loop _ 'M_(n, m) invmx mulmx}.\nProof. by move=> A uA /= B; rewrite mulmxA mulVmx ?mul1mx. Qed.",
    "Lemma mulKVmx m : {in unitmx, @rev_left_loop _ 'M_(n, m) invmx mulmx}.\nProof. by move=> A uA /= B; rewrite mulmxA mulmxV ?mul1mx. Qed.",
    "Lemma mulmxK m : {in unitmx, @right_loop 'M_(m, n) _ invmx mulmx}.\nProof. by move=> A uA /= B; rewrite -mulmxA mulmxV ?mulmx1. Qed.",
    "Lemma mulmxKV m : {in unitmx, @rev_right_loop 'M_(m, n) _ invmx mulmx}.\nProof. by move=> A uA /= B; rewrite -mulmxA mulVmx ?mulmx1. Qed.",
    "Lemma det_inv A : \\det (invmx A) = (\\det A)^-1.\nProof.\ncase uA: (A \\in unitmx); last by rewrite /invmx uA invr_out ?negbT.\nby apply: (mulrI uA); rewrite -det_mulmx mulmxV ?divrr ?det1.\nQed.",
    "Lemma unitmx_inv A : (invmx A \\in unitmx) = (A \\in unitmx).\nProof. by rewrite !unitmxE det_inv unitrV. Qed.",
    "Lemma unitmx_mul A B : (A *m B \\in unitmx) = (A \\in unitmx) && (B \\in unitmx).\nProof. by rewrite -unitrM -det_mulmx. Qed.",
    "Lemma trmx_inv (A : 'M_n) : (invmx A)^T = invmx (A^T).\nProof. by rewrite (fun_if trmx) linearZ /= trmx_adj -unitmx_tr -det_tr. Qed.",
    "Lemma invmxK : involutive invmx.\nProof.\nmove=> A; case uA : (A \\in unitmx); last by rewrite /invmx !uA.\nby apply: (can_inj (mulKVmx uA)); rewrite mulVmx // mulmxV ?unitmx_inv.\nQed.",
    "Lemma mulmx1_unit A B : A *m B = 1%:M -> A \\in unitmx /\\ B \\in unitmx.\nProof. by move=> AB1; apply/andP; rewrite -unitmx_mul AB1 unitmx1. Qed.",
    "Lemma intro_unitmx A B : B *m A = 1%:M /\\ A *m B = 1%:M -> unitmx A.\nProof. by case=> _ /mulmx1_unit[]. Qed.",
    "Lemma invmx_out : {in [predC unitmx], invmx =1 id}.\nProof. by move=> A; rewrite inE /= /invmx -if_neg => ->. Qed.",
    "Lemma detV (A : 'M_n) : \\det A^-1 = (\\det A)^-1.\nProof. exact: det_inv. Qed.",
    "Lemma unitr_trmx (A : 'M_n) : (A^T  \\is a GRing.unit) = (A \\is a GRing.unit).\nProof. exact: unitmx_tr. Qed.",
    "Lemma trmxV (A : 'M_n) : A^-1^T = (A^T)^-1.\nProof. exact: trmx_inv. Qed.",
    "Lemma perm_mxV (s : 'S_n) : perm_mx s^-1 = (perm_mx s)^-1.\nProof.\nrewrite -[_^-1]mul1r; apply: (canRL (mulmxK (unitmx_perm s))).\nby rewrite -perm_mxM mulVg perm_mx1.\nQed.",
    "Lemma is_perm_mxV (A : 'M_n) : is_perm_mx A^-1 = is_perm_mx A.\nProof.\napply/is_perm_mxP/is_perm_mxP=> [] [s defA]; exists s^-1%g.\n  by rewrite -(invrK A) defA perm_mxV.\nby rewrite defA perm_mxV.\nQed.",
    "Lemma block_diag_mx_unit (R : comUnitRingType) n1 n2\n      (Aul : 'M[R]_n1) (Adr : 'M[R]_n2) :\n  (block_mx Aul 0 0 Adr \\in unitmx) = (Aul \\in unitmx) && (Adr \\in unitmx).\nProof. by rewrite !unitmxE det_ublock unitrM. Qed.",
    "Lemma invmx_block_diag (R : comUnitRingType) n1 n2\n     (Aul : 'M[R]_n1) (Adr : 'M[R]_n2) :\n  block_mx Aul 0 0 Adr \\in unitmx ->\n  invmx (block_mx Aul 0 0 Adr) = block_mx (invmx Aul) 0 0 (invmx Adr).\nProof.\nmove=> /[dup] Aunit; rewrite block_diag_mx_unit => /andP[Aul_unit Adr_unit].\nrewrite -[LHS]mul1mx; apply: (canLR (mulmxK _)) => //.\nrewrite [RHS](mulmx_block (invmx Aul)) !(mulmx0, mul0mx, add0r, addr0).\nby rewrite !mulVmx// -?scalar_mx_block.\nQed.",
    "Lemma GL_1E : GLval 1 = 1. Proof. by []. Qed.",
    "Lemma GL_VE u : GLval u^-1 = (GLval u)^-1. Proof. by []. Qed.",
    "Lemma GL_VxE u : GLval u^-1 = invmx u. Proof. by []. Qed.",
    "Lemma GL_ME u v : GLval (u * v) = GLval u * GLval v. Proof. by []. Qed.",
    "Lemma GL_MxE u v : GLval (u * v) = u *m v. Proof. by []. Qed.",
    "Lemma GL_unit u : GLval u \\is a GRing.unit. Proof. exact: valP. Qed.",
    "Lemma GL_unitmx u : val u \\in unitmx. Proof. exact: GL_unit. Qed.",
    "Lemma GL_det u : \\det u != 0.\nProof.\nby apply: contraL (GL_unitmx u); rewrite unitmxE => /eqP->; rewrite unitr0.\nQed.",
    "Lemma scalemx_eq0 m n a (A : 'M[R]_(m, n)) :\n  (a *: A == 0) = (a == 0) || (A == 0).\nProof.\ncase nz_a: (a == 0) / eqP => [-> | _]; first by rewrite scale0r eqxx.\napply/eqP/eqP=> [aA0 | ->]; last exact: scaler0.\napply/matrixP=> i j; apply/eqP; move/matrixP/(_ i j)/eqP: aA0.\nby rewrite !mxE mulf_eq0 nz_a.\nQed.",
    "Lemma scalemx_inj m n a :\n  a != 0 -> injective ( *:%R a : 'M[R]_(m, n) -> 'M[R]_(m, n)).\nProof.\nmove=> nz_a A B eq_aAB; apply: contraNeq nz_a.\nrewrite -[A == B]subr_eq0 -[a == 0]orbF => /negPf<-.\nby rewrite -scalemx_eq0 linearB subr_eq0 /= eq_aAB.\nQed.",
    "Lemma det0P n (A : 'M[R]_n) :\n  reflect (exists2 v : 'rV[R]_n, v != 0 & v *m A = 0) (\\det A == 0).\nProof.\napply: (iffP eqP) => [detA0 | [v n0v vA0]]; last first.\n  apply: contraNeq n0v => nz_detA; rewrite -(inj_eq (scalemx_inj nz_detA)).\n  by rewrite scaler0 -mul_mx_scalar -mul_mx_adj mulmxA vA0 mul0mx.\nelim: n => [|n IHn] in A detA0 *.\n  by case/idP: (oner_eq0 R); rewrite -detA0 [A]thinmx0 -(thinmx0 1%:M) det1.\nhave [{detA0}A'0 | nzA'] := eqVneq (row 0 (\\adj A)) 0; last first.\n  exists (row 0 (\\adj A)) => //; rewrite rowE -mulmxA mul_adj_mx detA0.\n  by rewrite mul_mx_scalar scale0r.\npose A' := col' 0 A; pose vA := col 0 A.\nhave defA: A = row_mx vA A'.\n  apply/matrixP=> i j /[!mxE].\n  by case: split_ordP => j' -> /[!(mxE, ord1)]; congr (A i _); apply: val_inj.\nhave{IHn} w_ j : exists w : 'rV_n.+1, [/\\ w != 0, w 0 j = 0 & w *m A' = 0].\n  have [|wj nzwj wjA'0] := IHn (row' j A').\n    by apply/eqP; move/rowP/(_ j)/eqP: A'0; rewrite !mxE mulf_eq0 signr_eq0.\n  exists (\\row_k oapp (wj 0) 0 (unlift j k)).\n  rewrite !mxE unlift_none -wjA'0; split=> //.\n    apply: contraNneq nzwj => w0; apply/eqP/rowP=> k'.\n    by move/rowP/(_ (lift j k')): w0; rewrite !mxE liftK.\n  apply/rowP=> k; rewrite !mxE (bigD1_ord j) //= mxE unlift_none mul0r add0r.\n  by apply: eq_big => //= k'; rewrite !mxE/= liftK.\nhave [w0 [/rV0Pn[j nz_w0j] w00_0 w0A']] := w_ 0; pose a0 := (w0 *m vA) 0 0.\nhave{w_} [wj [nz_wj wj0_0 wjA']] := w_ j; pose aj := (wj *m vA) 0 0.\nhave [aj0 | nz_aj] := eqVneq aj 0.\n  exists wj => //; rewrite defA (@mul_mx_row _ _ _ 1) [_ *m _]mx11_scalar -/aj.\n  by rewrite aj0 raddf0 wjA' row_mx0.\nexists (aj *: w0 - a0 *: wj).\n  apply: contraNneq nz_aj; move/rowP/(_ j)/eqP; rewrite !mxE wj0_0 mulr0 subr0.\n  by rewrite mulf_eq0 (negPf nz_w0j) orbF.\nrewrite defA (@mul_mx_row _ _ _ 1) !mulmxBl -!scalemxAl w0A' wjA' !linear0.\nby rewrite -mul_mx_scalar -mul_scalar_mx -!mx11_scalar subrr addr0 row_mx0.\nQed.",
    "Lemma map_mx_inj {m n} : injective (map_mx f : 'M_(m, n) -> 'M_(m, n)).\nProof.\nmove=> A B eq_AB; apply/matrixP=> i j.\nby move/matrixP/(_ i j): eq_AB => /[!mxE]; apply: fmorph_inj.\nQed.",
    "Lemma map_mx_is_scalar n (A : 'M_n) : is_scalar_mx A^f = is_scalar_mx A.\nProof.\nrewrite /is_scalar_mx; case: (insub _) => // i.\nby rewrite mxE -map_scalar_mx inj_eq //; apply: map_mx_inj.\nQed.",
    "Lemma map_unitmx n (A : 'M_n) : (A^f \\in unitmx) = (A \\in unitmx).\nProof. by rewrite unitmxE det_map_mx // fmorph_unit // -unitfE. Qed.",
    "Lemma map_mx_unit n' (A : 'M_n'.+1) :\n  (A^f \\is a GRing.unit) = (A \\is a GRing.unit).\nProof. exact: map_unitmx. Qed.",
    "Lemma map_invmx n (A : 'M_n) : (invmx A)^f = invmx A^f.\nProof.\nrewrite /invmx map_unitmx (fun_if (map_mx f)).\nby rewrite map_mxZ map_mx_adj det_map_mx fmorphV.\nQed.",
    "Lemma map_mx_inv n' (A : 'M_n'.+1) : A^-1^f = A^f^-1.\nProof. exact: map_invmx. Qed.",
    "Lemma map_mx_eq0 m n (A : 'M_(m, n)) : (A^f == 0) = (A == 0).\nProof. by rewrite -(inj_eq map_mx_inj) raddf0. Qed.",
    "Lemma cormen_lup_perm n (A : 'M_n.+1) : is_perm_mx (cormen_lup A).1.1.\nProof.\nelim: n => [|n IHn] /= in A *; first exact: is_perm_mx1.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/=.\nrewrite (is_perm_mxMr _ (perm_mx_is_perm _ _)).\nby case/is_perm_mxP => s ->; apply: lift0_mx_is_perm.\nQed.",
    "Lemma cormen_lup_correct n (A : 'M_n.+1) :\n  let: (P, L, U) := cormen_lup A in P * A = L * U.\nProof.\nelim: n => [|n IHn] /= in A *; first by rewrite !mul1r.\nset k := odflt _ _; set A1 : 'M_(1 + _) := xrow _ _ _.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P' L' U']] /= IHn.\nrewrite -mulrA -!mulmxE -xrowE -/A1 /= -[n.+2]/(1 + n.+1)%N -{1}(submxK A1).\nrewrite !mulmx_block !mul0mx !mulmx0 !add0r !addr0 !mul1mx -{L' U'}[L' *m _]IHn.\nrewrite -scalemxAl !scalemxAr -!mulmxA addrC -mulrDr {A'}subrK.\ncongr (block_mx _ _ (_ *m _) _).\nrewrite [_ *: _]mx11_scalar !mxE lshift0 tpermL {}/A1 {}/k.\ncase: pickP => /= [k nzAk0 | no_k]; first by rewrite mulVf ?mulmx1.\nrewrite (_ : dlsubmx _ = 0) ?mul0mx //; apply/colP=> i.\nby rewrite !mxE lshift0 (elimNf eqP (no_k _)).\nQed.",
    "Lemma cormen_lup_detL n (A : 'M_n.+1) : \\det (cormen_lup A).1.2 = 1.\nProof.\nelim: n => [|n IHn] /= in A *; first by rewrite det1.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/= detL.\nby rewrite (@det_lblock _ 1) det1 mul1r.\nQed.",
    "Lemma cormen_lup_lower n A (i j : 'I_n.+1) :\n  i <= j -> (cormen_lup A).1.2 i j = (i == j)%:R.\nProof.\nelim: n => [|n IHn] /= in A i j *; first by rewrite [i]ord1 [j]ord1 mxE.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/= Ll.\nrewrite !mxE split1; case: unliftP => [i'|] -> /=; rewrite !mxE split1.\n  by case: unliftP => [j'|] -> //; apply: Ll.\nby case: unliftP => [j'|] ->; rewrite /= mxE.\nQed.",
    "Lemma cormen_lup_upper n A (i j : 'I_n.+1) :\n  j < i -> (cormen_lup A).2 i j = 0 :> F.\nProof.\nelim: n => [|n IHn] /= in A i j *; first by rewrite [i]ord1.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P L U]] {A'}/= Uu.\nrewrite !mxE split1; case: unliftP => [i'|] -> //=; rewrite !mxE split1.\nby case: unliftP => [j'|] ->; [apply: Uu | rewrite /= mxE].\nQed.",
    "Lemma mxOverP {S : {pred T}} {M : 'M[T]__} :\n  reflect (forall i j, M i j \\in S) (M \\is a mxOver S).\nProof. exact/'forall_forallP. Qed.",
    "Lemma mxOverS (S1 S2 : {pred T}) :\n  {subset S1 <= S2} -> {subset mxOver S1 <= mxOver S2}.\nProof. by move=> sS12 M /mxOverP S1M; apply/mxOverP=> i j; apply/sS12/S1M. Qed.",
    "Lemma mxOver_const c S : c \\in S -> const_mx c \\is a mxOver S.\nProof. by move=> cS; apply/mxOverP => i j; rewrite !mxE. Qed.",
    "Lemma mxOver_constE c S : (m > 0)%N -> (n > 0)%N ->\n  (const_mx c \\is a mxOver S) = (c \\in S).\nProof.\nmove=> m_gt0 n_gt0; apply/idP/idP; last exact: mxOver_const.\nby move=> /mxOverP /(_ (Ordinal m_gt0) (Ordinal n_gt0)); rewrite mxE.\nQed.",
    "Lemma thinmxOver {n : nat} {T : Type} (M : 'M[T]_(n, 0)) S : M \\is a mxOver S.\nProof. by apply/mxOverP => ? []. Qed.",
    "Lemma flatmxOver {n : nat} {T : Type} (M : 'M[T]_(0, n)) S : M \\is a mxOver S.\nProof. by apply/mxOverP => - []. Qed.",
    "Lemma mxOver0 S : 0 \\in S -> 0 \\is a @mxOver m n _ S.\nProof. exact: mxOver_const. Qed.",
    "Lemma mxOver_scalar S c : 0 \\in S -> c \\in S -> c%:M \\is a @mxOver n n R S.\nProof. by move=> S0 cS; apply/mxOverP => i j; rewrite !mxE; case: eqP. Qed.",
    "Lemma mxOver_scalarE S c : (n > 0)%N ->\n  (c%:M \\is a @mxOver n n R S) = ((n > 1) ==> (0 \\in S)) && (c \\in S).\nProof.\ncase: n => [|[|k]]//= _.\n   by apply/mxOverP/idP => [/(_ ord0 ord0)|cij i j]; rewrite ?mxE ?ord1.\napply/mxOverP/andP => [cij|[S0 cij] i j]; last by rewrite !mxE; case: eqP.\nby split; [have := cij 0 1|have := cij 0 0]; rewrite !mxE.\nQed.",
    "Lemma mxOverZ (S : mulrClosed R) :\n  {in S & mxOver S, forall a : R, forall v : 'M[R]_(m, n),\n     a *: v \\is a mxOver S}.\nProof.\nby move=> a v aS /mxOverP vS; apply/mxOverP => i j; rewrite !mxE rpredM.\nQed.",
    "Lemma mxOver_diag (S : {pred R}) k (D : 'rV[R]_k) :\n   0 \\in S -> D \\is a mxOver S -> diag_mx D \\is a mxOver S.\nProof.\nmove=> S0 DS; apply/mxOverP => i j; rewrite !mxE.\nby case: eqP => //; rewrite (mxOverP DS).\nQed.",
    "Lemma mxOver_diagE (S : {pred R}) k (D : 'rV[R]_k) : k > 0 ->\n  (diag_mx D \\is a mxOver S) = ((k > 1) ==> (0 \\in S)) && (D \\is a mxOver S).\nProof.\ncase: k => [|[|k]]//= in D * => _.\n  by rewrite [diag_mx _]mx11_scalar [D in RHS]mx11_scalar !mxE.\napply/idP/andP => [/mxOverP DS|[S0 DS]]; last exact: mxOver_diag.\nsplit; first by have /[!mxE] := DS 0 1.\nby apply/mxOverP => i j; have := DS j j; rewrite ord1 !mxE eqxx.\nQed.",
    "Lemma mxOverM (S : semiringClosed R) p q r : {in mxOver S & mxOver S,\n  forall u : 'M[R]_(p, q), forall v : 'M[R]_(q, r), u *m v \\is a mxOver S}.\nProof.\nmove=> M N /mxOverP MS /mxOverP NS; apply/mxOverP => i j.\nby rewrite !mxE rpred_sum // => k _; rewrite rpredM.\nQed.",
    "Lemma mxblockEh B_ : \\mxblock_(i, j) B_ i j = \\mxrow_j \\mxcol_i B_ i j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma mxblockEv B_ : \\mxblock_(i, j) B_ i j = \\mxcol_i \\mxrow_j B_ i j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma submxblockEh A i j : submxblock A i j = submxcol (submxrow A j) i.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma submxblockEv A i j : submxblock A i j = submxrow (submxcol A i) j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma mxblockK B_ i j : submxblock (\\mxblock_(i, j) B_ i j) i j = B_ i j.\nProof.\napply/matrixP => k l; rewrite !mxE !Rank2K.\nby do !case: _ / esym; rewrite !cast_ord_id.\nQed.",
    "Lemma mxrowK m B_ j : @submxrow m (\\mxrow_j B_ j) j = B_ j.\nProof.\napply/matrixP => k l; rewrite !mxE !Rank2K.\nby do !case: _ / esym; rewrite !cast_ord_id.\nQed.",
    "Lemma mxcolK n B_ i : @submxcol n (\\mxcol_i B_ i) i = B_ i.\nProof.\napply/matrixP => k l; rewrite !mxE !Rank2K.\nby do !case: _ / esym; rewrite !cast_ord_id.\nQed.",
    "Lemma submxrow_matrix B_ j :\n  submxrow (\\mxblock_(i, j) B_ i j) j = \\mxcol_i B_ i j.\nProof. by rewrite mxblockEh mxrowK. Qed.",
    "Lemma submxcol_matrix B_ i :\n  submxcol (\\mxblock_(i, j) B_ i j) i = \\mxrow_j B_ i j.\nProof. by rewrite mxblockEv mxcolK. Qed.",
    "Lemma submxblockK A : \\mxblock_(i, j) (submxblock A i j) = A.\nProof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed.",
    "Lemma submxrowK m (A : 'M[T]_(m, sq)) : \\mxrow_j (submxrow A j) = A.\nProof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed.",
    "Lemma submxcolK n (A : 'M[T]_(sp, n)) : \\mxcol_i (submxcol A i) = A.\nProof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed.",
    "Lemma mxblockP A B :\n  (forall i j, submxblock A i j = submxblock B i j) <-> A = B.\nProof.\nsplit=> [eqAB|->//]; apply/matrixP=> s t;\nhave /matrixP := eqAB (sig1 s) (sig1 t).\nby move=> /(_ (sig2 s) (sig2 t)); rewrite !mxE !sig2K.\nQed.",
    "Lemma mxrowP m (A B : 'M_(m, sq)) :\n  (forall j, submxrow A j = submxrow B j) <-> A = B.\nProof.\nsplit=> [eqAB|->//]; apply/matrixP=> i t; have /matrixP := eqAB (sig1 t).\nby move=> /(_ i (sig2 t)); rewrite !mxE !sig2K.\nQed.",
    "Lemma mxcolP n (A B : 'M_(sp, n)) :\n  (forall i, submxcol A i = submxcol B i) <-> A = B.\nProof.\nsplit=> [eqAB|->//]; apply/matrixP=> s j; have /matrixP := eqAB (sig1 s).\nby move=> /(_ (sig2 s) j); rewrite !mxE !sig2K.\nQed.",
    "Lemma eq_mxblockP A_ B_ :\n  (forall i j, A_ i j = B_ i j) <->\n  (\\mxblock_(i, j) A_ i j = \\mxblock_(i, j) B_ i j).\nProof.\nsplit; first by move=> e; apply/mxblockP => i j; rewrite !mxblockK.\nby move=> + i j => /mxblockP/(_ i j); rewrite !mxblockK.\nQed.",
    "Lemma eq_mxblock A_ B_ :\n  (forall i j, A_ i j = B_ i j) ->\n  (\\mxblock_(i, j) A_ i j = \\mxblock_(i, j) B_ i j).\nProof. by move=> /eq_mxblockP. Qed.",
    "Lemma eq_mxrowP m (A_ B_ : forall j, 'M[T]_(m, q_ j)) :\n  (forall j, A_ j = B_ j) <-> (\\mxrow_j A_ j = \\mxrow_j B_ j).\nProof.\nsplit; first by move=> e; apply/mxrowP => j; rewrite !mxrowK.\nby move=> + j => /mxrowP/(_ j); rewrite !mxrowK.\nQed.",
    "Lemma eq_mxrow m (A_ B_ : forall j, 'M[T]_(m, q_ j)) :\n  (forall j, A_ j = B_ j) -> (\\mxrow_j A_ j = \\mxrow_j B_ j).\nProof. by move=> /eq_mxrowP. Qed.",
    "Lemma eq_mxcolP n (A_ B_ : forall i, 'M[T]_(p_ i, n)) :\n  (forall i, A_ i = B_ i) <-> (\\mxcol_i A_ i = \\mxcol_i B_ i).\nProof.\nsplit; first by move=> e; apply/mxcolP => i; rewrite !mxcolK.\nby move=> + i => /mxcolP/(_ i); rewrite !mxcolK.\nQed.",
    "Lemma eq_mxcol n (A_ B_ : forall i, 'M[T]_(p_ i, n)) :\n  (forall i, A_ i = B_ i) -> (\\mxcol_i A_ i = \\mxcol_i B_ i).\nProof. by move=> /eq_mxcolP. Qed.",
    "Lemma row_mxrow m (B_ : forall j, 'M[T]_(m, q_ j)) i :\n  row i (\\mxrow_j B_ j) = \\mxrow_j (row i (B_ j)).\nProof. by apply/rowP => l; rewrite !mxE. Qed.",
    "Lemma col_mxrow m (B_ : forall j, 'M[T]_(m, q_ j)) j :\n  col j (\\mxrow_j B_ j) = col (sig2 j) (B_ (sig1 j)).\nProof. by apply/colP => l; rewrite !mxE. Qed.",
    "Lemma row_mxcol n (B_ : forall i, 'M[T]_(p_ i, n)) i :\n  row i (\\mxcol_i B_ i) = row (sig2 i) (B_ (sig1 i)).\nProof. by apply/rowP => l; rewrite !mxE. Qed.",
    "Lemma col_mxcol n (B_ : forall i, 'M[T]_(p_ i, n)) j :\n  col j (\\mxcol_i B_ i) = \\mxcol_i (col j (B_ i)).\nProof. by apply/colP => l; rewrite !mxE. Qed.",
    "Lemma row_mxblock B_ i :\n  row i (\\mxblock_(i, j) B_ i j) = \\mxrow_j row (sig2 i) (B_ (sig1 i) j).\nProof. by apply/rowP => l; rewrite !mxE. Qed.",
    "Lemma col_mxblock B_ j :\n  col j (\\mxblock_(i, j) B_ i j) = \\mxcol_i col (sig2 j) (B_ i (sig1 j)).\nProof. by apply/colP => l; rewrite !mxE. Qed.",
    "Lemma tr_mxblock {T : Type} {p q : nat} {p_ : 'I_p -> nat} {q_ : 'I_q -> nat}\n  (B_ : forall i j, 'M[T]_(p_ i, q_ j)) :\n  (\\mxblock_(i, j) B_ i j)^T = \\mxblock_(i, j) (B_ j i)^T.\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma tr_mxrow n (B_ : forall j, 'M[T]_(n, p_ j)) :\n  (\\mxrow_j B_ j)^T = \\mxcol_i (B_ i)^T.\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma tr_mxcol n (B_ : forall i, 'M[T]_(p_ i, n)) :\n  (\\mxcol_i B_ i)^T = \\mxrow_i (B_ i)^T.\nProof. by apply/matrixP => i j; rewrite !mxE. Qed.",
    "Lemma tr_submxblock (A : 'M[T]_sp) i j :\n  (submxblock A i j)^T = (submxblock A^T j i).\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma tr_submxrow n (A : 'M[T]_(n, sp)) j :\n  (submxrow A j)^T = (submxcol A^T j).\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma tr_submxcol n (A : 'M[T]_(sp, n)) i :\n  (submxcol A i)^T = (submxrow A^T i).\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma mxsize_recl : (p_ ord0 + \\sum_i p_ (lift ord0 i) = (\\sum_i p_ i))%N.\nProof. by rewrite big_ord_recl. Qed.",
    "Lemma mxrow_recl n (B_ : forall j, 'M[T]_(n, p_ j)) :\n  \\mxrow_j B_ j = castmx (erefl, mxsize_recl)\n    (row_mx (B_ 0) (\\mxrow_j B_ (lift ord0 j))).\nProof.\napply/mxrowP => i; rewrite mxrowK.\napply/matrixP => j k; rewrite !(castmxE, mxE)/=.\ncase: splitP => l /=; do [\n    rewrite [LHS]RankEsum big_mkcond big_ord_recl -big_mkcond/=;\n    rewrite /bump/= -addnA cast_ord_id;\n    under eq_bigl do rewrite add1n -ltn_predRL/=].\n  case: posnP => i0; last first.\n    by move=> lE; have := ltn_ord l; rewrite /= -lE -ltn_subRL subnn.\n  by rewrite (@val_inj _ _ _ i 0 i0) big_pred0_eq in k * => /val_inj->.\ncase: posnP => i0.\n  rewrite (@val_inj _ _ _ i 0 i0) big_pred0_eq in k l * => kE.\n  by have := ltn_ord k; rewrite /= [val k]kE -ltn_subRL subnn.\nhave i_lt : i.-1 < m by rewrite -subn1 ltn_subLR.\nset i' := lift ord0 (Ordinal i_lt).\nhave ii' : i = i' by apply/val_inj; rewrite /=/bump/= add1n prednK.\nhave k_lt : k < p_ i' by rewrite -ii'.\nmove=> /addnI; rewrite eqRank => /val_inj/= /[dup] kl<-; rewrite mxE.\nrewrite Rank2K//; case: _ / esym; rewrite cast_ord_id/=.\nrewrite -/i'; set j' := Ordinal _; have : k = j' :> nat by [].\nby move: j'; rewrite -ii' => j' /val_inj->.\nQed.",
    "Lemma mxcol_recu {T : Type} {p : nat} {p_ : 'I_p.+1 -> nat} m\n    (B_ : forall j, 'M[T]_(p_ j, m)) :\n  \\mxcol_j B_ j = castmx (mxsize_recl, erefl)\n    (col_mx (B_ 0) (\\mxcol_j B_ (lift ord0 j))).\nProof.\nby apply: trmx_inj; rewrite trmx_cast tr_col_mx !tr_mxcol mxrow_recl.\nQed.",
    "Lemma mxblock_recu {p q : nat} {p_ : 'I_p.+1 -> nat} {q_ : 'I_q -> nat}\n    (B_ : forall i j, 'M[T]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) B_ i j = castmx (mxsize_recl, erefl) (col_mx\n     (\\mxrow_j B_ ord0 j)\n     (\\mxblock_(i, j) B_ (l0 i) j)).\nProof. by rewrite !mxblockEv mxcol_recu. Qed.",
    "Lemma mxblock_recl {p q : nat} {p_ : 'I_p -> nat} {q_ : 'I_q.+1 -> nat}\n    (B_ : forall i j, 'M[T]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) B_ i j = castmx (erefl, mxsize_recl)\n  (row_mx (\\mxcol_i B_ i ord0) (\\mxblock_(i, j) B_ i (l0 j))).\nProof. by rewrite !mxblockEh mxrow_recl. Qed.",
    "Lemma mxblock_recul {p q : nat} {p_ : 'I_p.+1 -> nat} {q_ : 'I_q.+1 -> nat}\n    (B_ : forall i j, 'M[T]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) B_ i j = castmx e (block_mx\n     (B_ 0 0)                  (\\mxrow_j B_ ord0 (l0 j))\n     (\\mxcol_i B_ (l0 i) ord0) (\\mxblock_(i, j) B_ (l0 i) (l0 j))).\nProof.\nrewrite mxblock_recl mxcol_recu mxblock_recu -cast_row_mx -block_mxEh.\nby rewrite castmx_comp; apply: eq_castmx.\nQed.",
    "Lemma mxrowEblock {q : nat} {q_ : 'I_q -> nat} m\n    (R_ : forall j, 'M[T]_(m, q_ j)) :\n  (\\mxrow_j R_ j) =\n  castmx (big_ord1 _ (fun=> m), erefl) (\\mxblock_(i < 1, j < q) R_ j).\nProof.\nrewrite mxblock_recu castmx_comp.\napply/matrixP => i j; rewrite !castmxE !mxE/=; case: splitP => //=.\n  by move=> k /val_inj->; rewrite ?cast_ord_id ?mxE//=.\nby move=> [k klt]; suff: false by []; rewrite big_ord0 in klt.\nQed.",
    "Lemma mxcolEblock {p : nat} {p_ : 'I_p -> nat} n\n    (C_ : forall i, 'M[T]_(p_ i, n)) :\n  (\\mxcol_i C_ i) =\n  castmx (erefl, big_ord1 _ (fun=> n)) (\\mxblock_(i < p, j < 1) C_ i).\nProof.\nby apply: trmx_inj; rewrite tr_mxcol mxrowEblock trmx_cast tr_mxblock.\nQed.",
    "Lemma mxEmxrow m n (A : 'M[T]_(m, n)) :\n  A = castmx (erefl, big_ord1 _ (fun=> n)) (\\mxrow__ A).\nProof.\napply/matrixP => i j; rewrite castmxE !mxE/= cast_ord_id.\ncongr (A i); set j' := cast_ord _ _.\nsuff -> : j' = (tagnat.Rank 0 j) by apply/val_inj; rewrite tagnat.Rank2K.\nby apply/val_inj; rewrite [RHS]tagnat.RankEsum/= big_pred0_eq add0n.\nQed.",
    "Lemma mxEmxcol m n (A : 'M[T]_(m, n)) :\n  A = castmx (big_ord1 _ (fun=> m), erefl) (\\mxcol__ A).\nProof. by apply: trmx_inj; rewrite trmx_cast tr_mxcol [LHS]mxEmxrow. Qed.",
    "Lemma mxEmxblock m n (A : 'M[T]_(m, n)) :\n  A = castmx (big_ord1 _ (fun=> m), big_ord1 _ (fun=> n))\n             (\\mxblock_(i < 1, j < 1) A).\nProof. by rewrite [LHS]mxEmxrow mxrowEblock castmx_comp; apply: eq_castmx. Qed.",
    "Lemma mxrowD m (R_ R'_ : forall j, 'M[V]_(m, q_ j)) :\n  \\mxrow_j (R_ j + R'_ j) = \\mxrow_j (R_ j) + \\mxrow_j (R'_ j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxrowN m (R_ : forall j, 'M[V]_(m, q_ j)) :\n  \\mxrow_j (- R_ j) = - \\mxrow_j (R_ j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxrowB m (R_ R'_ : forall j, 'M[V]_(m, q_ j)) :\n  \\mxrow_j (R_ j - R'_ j) = \\mxrow_j (R_ j) - \\mxrow_j (R'_ j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxrow0 m : \\mxrow_j (0 : 'M[V]_(m, q_ j)) = 0.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxrow_const m a : \\mxrow_j (const_mx a : 'M[V]_(m, q_ j)) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxrow_sum (J : finType) m\n    (R_ : forall i j, 'M[V]_(m, q_ j)) (P : {pred J}) :\n  \\mxrow_j (\\sum_(i | P i) R_ i j) = \\sum_(i | P i) \\mxrow_j (R_ i j).\nProof.\napply/matrixP => i j; rewrite !(mxE, summxE).\nby apply: eq_bigr => l; rewrite !mxE.\nQed.",
    "Lemma submxrowD m (B B' : 'M[V]_(m, sq)) j :\n submxrow (B + B') j = submxrow B j + submxrow B' j.\nProof. by apply/matrixP => i i'; rewrite !mxE. Qed.",
    "Lemma submxrowN m (B : 'M[V]_(m, sq)) j :\n submxrow (- B) j = - submxrow B j.\nProof. by apply/matrixP => i i'; rewrite !mxE. Qed.",
    "Lemma submxrowB m (B B' : 'M[V]_(m, sq)) j :\n submxrow (B - B') j = submxrow B j - submxrow B' j.\nProof. by apply/matrixP => i i'; rewrite !mxE. Qed.",
    "Lemma submxrow0 m j : submxrow (0 : 'M[V]_(m, sq)) j = 0.\nProof. by apply/matrixP=> i i'; rewrite !mxE. Qed.",
    "Lemma submxrow_sum (J : finType) m\n   (R_ : forall i, 'M[V]_(m, sq)) (P : {pred J}) j:\n  submxrow (\\sum_(i | P i) R_ i) j = \\sum_(i | P i) submxrow (R_ i) j.\nProof.\napply/matrixP => i i'; rewrite !(mxE, summxE).\nby apply: eq_bigr => l; rewrite !mxE.\nQed.",
    "Lemma mul_mxrow m n' (A : 'M[R]_(m, n')) (R_ : forall j, 'M[R]_(n', q_ j)) :\n  A *m \\mxrow_j R_ j= \\mxrow_j (A *m R_ j).\nProof. by apply/matrixP=> i s; rewrite !mxE; under eq_bigr do rewrite !mxE. Qed.",
    "Lemma mul_submxrow m n' (A : 'M[R]_(m, n')) (B : 'M[R]_(n', sq)) j :\n  A *m submxrow B j= submxrow (A *m B) j.\nProof. by apply/matrixP=> i s; rewrite !mxE; under eq_bigr do rewrite !mxE. Qed.",
    "Lemma mxcolD m (C_ C'_ : forall i, 'M[V]_(p_ i, m)) :\n  \\mxcol_i (C_ i + C'_ i) = \\mxcol_i (C_ i) + \\mxcol_i (C'_ i).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxcolN m (C_ : forall i, 'M[V]_(p_ i, m)) :\n  \\mxcol_i (- C_ i) = - \\mxcol_i (C_ i).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxcolB m (C_ C'_ : forall i, 'M[V]_(p_ i, m)) :\n  \\mxcol_i (C_ i - C'_ i) = \\mxcol_i (C_ i) - \\mxcol_i (C'_ i).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxcol0 m : \\mxcol_i (0 : 'M[V]_(p_ i, m)) = 0.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxcol_const m a : \\mxcol_j (const_mx a : 'M[V]_(p_ j, m)) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxcol_sum\n  (I : finType) m (C_ : forall j i, 'M[V]_(p_ i, m)) (P : {pred I}):\n  \\mxcol_i (\\sum_(j | P j) C_ j i) = \\sum_(j | P j) \\mxcol_i (C_ j i).\nProof.\napply/matrixP => i j; rewrite !(mxE, summxE).\nby apply: eq_bigr => l; rewrite !mxE.\nQed.",
    "Lemma submxcolD m (B B' : 'M[V]_(sp, m)) i :\n submxcol (B + B') i = submxcol B i + submxcol B' i.\nProof. by apply/matrixP => j j'; rewrite !mxE. Qed.",
    "Lemma submxcolN m (B : 'M[V]_(sp, m)) i :\n submxcol (- B) i = - submxcol B i.\nProof. by apply/matrixP => j j'; rewrite !mxE. Qed.",
    "Lemma submxcolB m (B B' : 'M[V]_(sp, m)) i :\n submxcol (B - B') i = submxcol B i - submxcol B' i.\nProof. by apply/matrixP => j j'; rewrite !mxE. Qed.",
    "Lemma submxcol0 m i : submxcol (0 : 'M[V]_(sp, m)) i = 0.\nProof. by apply/matrixP=> j j'; rewrite !mxE. Qed.",
    "Lemma submxcol_sum (I : finType) m\n   (C_ : forall j, 'M[V]_(sp, m)) (P : {pred I}) i :\n  submxcol (\\sum_(j | P j) C_ j) i = \\sum_(j | P j) submxcol (C_ j) i.\nProof.\napply/matrixP => j j'; rewrite !(mxE, summxE).\nby apply: eq_bigr => l; rewrite !mxE.\nQed.",
    "Lemma mxcol_mul n' m (C_ : forall i, 'M[R]_(p_ i, n')) (A : 'M[R]_(n', m)) :\n  \\mxcol_i C_ i *m A = \\mxcol_i (C_ i *m A).\nProof. by apply/matrixP=> i s; rewrite !mxE; under eq_bigr do rewrite !mxE. Qed.",
    "Lemma submxcol_mul n' m (B : 'M[R]_(sp, n')) (A : 'M[R]_(n', m)) i :\n  submxcol B i *m A = submxcol (B *m A) i.\nProof. by apply/matrixP=> j s; rewrite !mxE; under eq_bigr do rewrite !mxE. Qed.",
    "Lemma mxblockD (B_ B'_ : forall i j, 'M[V]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) (B_ i j + B'_ i j) =\n  \\mxblock_(i, j) (B_ i j) + \\mxblock_(i, j) (B'_ i j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxblockN (B_ : forall i j, 'M[V]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) (- B_ i j) = - \\mxblock_(i, j) (B_ i j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxblockB (B_ B'_ : forall i j, 'M[V]_(p_ i, q_ j)) :\n  \\mxblock_(i, j) (B_ i j - B'_ i j) =\n  \\mxblock_(i, j) (B_ i j) - \\mxblock_(i, j) (B'_ i j).\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxblock0 : \\mxblock_(i, j) (0 : 'M[V]_(p_ i, q_ j)) = 0.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxblock_const a :\n  \\mxblock_(i, j) (const_mx a : 'M[V]_(p_ i, q_ j)) = const_mx a.\nProof. by apply/matrixP=> i j; rewrite !mxE. Qed.",
    "Lemma mxblock_sum (I : finType)\n    (B_ : forall k i j, 'M[V]_(p_ i, q_ j)) (P : {pred I}):\n  \\mxblock_(i, j) (\\sum_(k | P k) B_ k i j) =\n  \\sum_(k | P k) \\mxblock_(i, j) (B_ k i j).\nProof.\napply/matrixP => i j; rewrite !(mxE, summxE).\nby apply: eq_bigr => l; rewrite !mxE.\nQed.",
    "Lemma submxblockD (B B' : 'M[V]_(sp, sq)) i j :\n submxblock (B + B') i j = submxblock B i j + submxblock B' i j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma submxblockN (B : 'M[V]_(sp, sq)) i j :\n submxblock (- B) i j = - submxblock B i j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma submxblockB (B B' : 'M[V]_(sp, sq)) i j :\n submxblock (B - B') i j = submxblock B i j - submxblock B' i j.\nProof. by apply/matrixP => k l; rewrite !mxE. Qed.",
    "Lemma submxblock0 i j : submxblock (0 : 'M[V]_(sp, sq)) i j = 0.\nProof. by apply/matrixP=> k l; rewrite !mxE. Qed.",
    "Lemma submxblock_sum (I : finType)\n   (B_ : forall k, 'M[V]_(sp, sq)) (P : {pred I}) i j :\n  submxblock (\\sum_(k | P k) B_ k) i j = \\sum_(k | P k) submxblock (B_ k) i j.\nProof.\napply/matrixP => k l; rewrite !(mxE, summxE).\nby apply: eq_bigr => p; rewrite !mxE.\nQed.",
    "Lemma mul_mxrow_mxcol m n\n    (R_ : forall j, 'M[R]_(m, p_ j)) (C_ : forall i, 'M[R]_(p_ i, n)) :\n  \\mxrow_j R_ j *m \\mxcol_i C_ i = \\sum_i (R_ i *m C_ i).\nProof.\napply/matrixP => i j; rewrite !mxE summxE; under [RHS]eq_bigr do rewrite !mxE.\nrewrite sig_big_dep/= (reindex _ tagnat.sig_bij_on)/=.\nby apply: eq_bigr=> l _; rewrite !mxE.\nQed.",
    "Lemma mul_mxcol_mxrow m\n    (C_ : forall i, 'M[R]_(p_ i, m)) (R_ : forall j, 'M[R]_(m, q_ j)) :\n  \\mxcol_i C_ i*m \\mxrow_j R_ j  = \\mxblock_(i, j) (C_ i *m R_ j).\nProof.\napply/mxblockP => i j; rewrite mxblockK.\nby rewrite submxblockEh -mul_submxrow -submxcol_mul mxcolK mxrowK.\nQed.",
    "Lemma mul_mxrow_mxblock m\n    (R_ : forall i, 'M[R]_(m, p_ i)) (B_ : forall i j, 'M[R]_(p_ i, q_ j)) :\n  \\mxrow_i R_ i *m \\mxblock_(i, j) B_ i j = \\mxrow_j (\\sum_i (R_ i *m B_ i j)).\nProof.\nrewrite mxblockEv mul_mxrow_mxcol mxrow_sum.\nby apply: eq_bigr => i _; rewrite mul_mxrow.\nQed.",
    "Lemma mul_mxblock_mxrow m\n    (B_ : forall i j, 'M[R]_(q_ i, p_ j)) (C_ : forall i, 'M[R]_(p_ i, m)) :\n  \\mxblock_(i, j) B_ i j *m \\mxcol_j C_ j = \\mxcol_i (\\sum_j (B_ i j *m C_ j)).\nProof.\nrewrite mxblockEh mul_mxrow_mxcol mxcol_sum.\nby apply: eq_bigr => i _; rewrite mxcol_mul.\nQed.",
    "Lemma mul_mxblock {R : pzRingType} {p q r : nat}\n    {p_ : 'I_p -> nat} {q_ : 'I_q -> nat} {r_ : 'I_r -> nat}\n    (A_ : forall i j, 'M[R]_(p_ i, q_ j)) (B_ : forall j k, 'M_(q_ j, r_ k)) :\n  \\mxblock_(i, j) A_ i j *m \\mxblock_(j, k) B_ j k =\n  \\mxblock_(i, k) \\sum_j (A_ i j *m B_ j k).\nProof.\nrewrite mxblockEh mul_mxrow_mxblock mxblockEh; apply: eq_mxrow => i.\nby under [LHS]eq_bigr do rewrite mxcol_mul; rewrite -mxcol_sum.\nQed.",
    "Lemma is_trig_mxblockP (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  reflect [/\\ forall (i j : 'I_p), (i < j)%N -> B_ i j = 0 &\n              forall i, is_trig_mx (B_ i i)]\n          (is_trig_mx (\\mxblock_(i, j) B_ i j)).\nProof.\napply: (iffP is_trig_mxP); last first.\n  move=> [Blt1 /(_ _)/is_trig_mxP Blt2]/= s s'; rewrite !mxE.\n  rewrite -[_ < _]lt_sig ltEsig/= /sig1 /sig2 leEord.\n  case: ltngtP => //= ii'; first by rewrite (Blt1 _ _ ii') mxE.\n  move: (sig s) (sig s') ii' => -[/= i j] [/= i' +] /val_inj ii'.\n  by case: _ / ii' => j'; rewrite tagged_asE => /Blt2->.\nmove=> Btrig; split=> [i i' lti|i].\n  apply/matrixP => j j'; have := Btrig (Rank _ j) (Rank _ j').\n  rewrite !mxE !Rank2K; do !case: _ / esym; rewrite !cast_ord_id.\n  rewrite /Rank [_ <= _]lt_rank.\n  by rewrite ltEsig/= leEord ltnW//= (ltn_geF lti)//= => /(_ isT).\napply/is_trig_mxP => j j' ltj; have := Btrig (Rank _ j) (Rank _ j').\nrewrite !mxE !Rank2K; do! case: _ / esym; rewrite !cast_ord_id.\nby rewrite [_ <= _]lt_rank ltEsig/= !leEord leqnn/= tagged_asE; apply.\nQed.",
    "Lemma is_trig_mxblock (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  is_trig_mx (\\mxblock_(i, j) B_ i j) =\n  ([forall i : 'I_p, forall j : 'I_p, (i < j)%N ==> (B_ i j == 0)] &&\n   [forall i, is_trig_mx (B_ i i)]).\nProof.\nby apply/is_trig_mxblockP/andP => -[] => [/(_ _ _ _)/eqP|]\n  => /'forall_'forall_implyP => [|/(_ _ _ _)/eqP] Blt /forallP.\nQed.",
    "Lemma is_diag_mxblockP (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  reflect [/\\ forall (i j : 'I_p), i != j -> B_ i j = 0 &\n              forall i, is_diag_mx (B_ i i)]\n          (is_diag_mx (\\mxblock_(i, j) B_ i j)).\nProof.\napply: (iffP is_diag_mxP); last first.\n  move=> [Bneq1 /(_ _)/is_diag_mxP Bneq2]/= s s'; rewrite !mxE.\n  rewrite val_eqE -(can_eq sigK) /sig1 /sig2.\n  move: (sig s) (sig s') => -[/= i j] [/= i' j'].\n  rewrite -tag_eqE/= /tag_eq/= negb_and.\n  case: eqVneq => /= [ii'|/Bneq1->]; last by rewrite !mxE.\n  by rewrite -ii' in j' *; rewrite tagged_asE => /Bneq2.\nmove=> Bdiag; split=> [i i' Ni|i].\n  apply/matrixP => j j'; have := Bdiag (Rank _ j) (Rank _ j').\n  rewrite !mxE !Rank2K; do !case: _ / esym; rewrite !cast_ord_id.\n  by rewrite eq_Rank negb_and Ni; apply.\napply/is_diag_mxP => j j' Nj; have := Bdiag (Rank _ j) (Rank _ j').\nrewrite !mxE !Rank2K; do! case: _ / esym; rewrite !cast_ord_id.\nby rewrite eq_Rank negb_and val_eqE Nj orbT; apply.\nQed.",
    "Lemma is_diag_mxblock (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  is_diag_mx (\\mxblock_(i, j) B_ i j) =\n  ([forall i : 'I_p, forall j : 'I_p, (i != j) ==> (B_ i j == 0)] &&\n   [forall i, is_diag_mx (B_ i i)]).\nProof.\nby apply/is_diag_mxblockP/andP => -[] => [/(_ _ _ _)/eqP|]\n  => /'forall_'forall_implyP => [|/(_ _ _ _)/eqP] Blt /forallP.\nQed.",
    "Lemma submxblock_diag (B_  : forall i, 'M[V]_(p_ i)) i :\n  submxblock (\\mxdiag_i B_ i) i i = B_ i.\nProof. by rewrite mxblockK conform_mx_id eqxx. Qed.",
    "Lemma eq_mxdiagP (B_ B'_ : forall i, 'M[V]_(p_ i)) :\n  (forall i, B_ i = B'_ i) <-> (\\mxdiag_i B_ i = \\mxdiag_i B'_ i).\nProof.\nrewrite /mxdiag; split; first by move=> e; apply/eq_mxblockP => i j; rewrite e.\nby move=> + i => /eq_mxblockP/(_ i i); rewrite eqxx !conform_mx_id.\nQed.",
    "Lemma eq_mxdiag (B_ B'_ : forall i, 'M[V]_(p_ i)) :\n  (forall i, B_ i = B'_ i) -> (\\mxdiag_i B_ i = \\mxdiag_i B'_ i).\nProof. by move=> /eq_mxdiagP. Qed.",
    "Lemma mxdiagD (B_ B'_ : forall i, 'M[V]_(p_ i)) :\n  \\mxdiag_i (B_ i + B'_ i) = \\mxdiag_i (B_ i) + \\mxdiag_i (B'_ i).\nProof.\nrewrite /mxdiag -mxblockD; apply/eq_mxblock => i j.\nby case: eqVneq => [->|]; rewrite ?conform_mx_id ?addr0.\nQed.",
    "Lemma mxdiagN (B_ : forall i, 'M[V]_(p_ i)) :\n  \\mxdiag_i (- B_ i) = - \\mxdiag_i (B_ i).\nProof.\nrewrite /mxdiag -mxblockN; apply/eq_mxblock => i j.\nby case: eqVneq => [->|]; rewrite ?conform_mx_id ?oppr0.\nQed.",
    "Lemma mxdiagB (B_ B'_ : forall i, 'M[V]_(p_ i)) :\n  \\mxdiag_i (B_ i - B'_ i) = \\mxdiag_i (B_ i) - \\mxdiag_i (B'_ i).\nProof. by rewrite mxdiagD mxdiagN. Qed.",
    "Lemma mxdiag0 : \\mxdiag_i (0 : 'M[V]_(p_ i)) = 0.\nProof. by under [LHS]eq_mxdiag do rewrite -[0]subr0; rewrite mxdiagB subrr. Qed.",
    "Lemma mxdiag_sum (I : finType) (B_ : forall k i, 'M[V]_(p_ i)) (P : {pred I}) :\n  \\mxdiag_i (\\sum_(k | P k) B_ k i) = \\sum_(k | P k) \\mxdiag_i (B_ k i).\nProof.\nrewrite /mxdiag -mxblock_sum; apply/eq_mxblock => i j.\ncase: eqVneq => [->|]; rewrite ?conform_mx_id//; last by rewrite big1.\nby apply: eq_bigr => k; rewrite conform_mx_id.\nQed.",
    "Lemma tr_mxdiag (B_ : forall i, 'M[V]_(p_ i)) :\n  (\\mxdiag_i B_ i)^T = \\mxdiag_i (B_ i)^T.\nProof.\nrewrite tr_mxblock; apply/eq_mxblock => i j.\nby case: eqVneq => [->|]; rewrite ?trmx_conform ?trmx0.\nQed.",
    "Lemma row_mxdiag (B_ : forall i, 'M[V]_(p_ i)) k :\n  let B'_ i := if sig1 k == i then conform_mx 0 (B_ i) else 0 in\n  row k (\\mxdiag_ i B_ i) = row (sig2 k) (\\mxrow_i B'_ i).\nProof.\nrewrite /= row_mxblock row_mxrow; apply/eq_mxrow => i.\nby case: eqVneq => // e; congr row; rewrite e.\nQed.",
    "Lemma col_mxdiag (B_ : forall i, 'M[V]_(p_ i)) k :\n  let B'_ i := if sig1 k == i then conform_mx 0 (B_ i) else 0 in\n  col k (\\mxdiag_ i B_ i) = col (sig2 k) (\\mxcol_i B'_ i).\nProof.\nby rewrite /= col_mxblock col_mxcol; apply/eq_mxcol => i; rewrite eq_sym.\nQed.",
    "Lemma mxdiag_recl {V : zmodType} {m : nat} {p_ : 'I_m.+1 -> nat}\n    (B_ : forall i, 'M[V]_(p_ i)) :\n  \\mxdiag_i B_ i = castmx (mxsize_recl, mxsize_recl)\n    (block_mx (B_ 0) 0 0 (\\mxdiag_i B_ (lift ord0 i))).\nProof.\nrewrite /mxdiag mxblock_recul/= !conform_mx_id.\nby congr (castmx _ (block_mx _ _ _ _)); rewrite ?mxrow0 ?mxcol0.\nQed.",
    "Lemma mxtrace_mxblock (B_ : forall i j, 'M[R]_(p_ i, p_ j)) :\n  \\tr (\\mxblock_(i, j) B_ i j) = \\sum_i \\tr (B_ i i).\nProof.\nrewrite /mxtrace sig_big_dep (reindex _ sig_bij_on)/=.\nby apply: eq_bigr => i _; rewrite !mxE.\nQed.",
    "Lemma mxdiagZ a : \\mxdiag_i (a%:M : 'M[R]_(p_ i)) = a%:M.\nProof.\napply/matrixP => s t; rewrite !mxE -(can_eq sigK) /sig1 /sig2.\ncase: (sig s) (sig t) => [/= i j] [/= i' j'].\ncase: eqP => [<-|ni] in j' *; last by rewrite !mxE; case: eqVneq => // -[].\nby rewrite conform_mx_id eq_Tagged/= mxE.\nQed.",
    "Lemma diag_mxrow (B_ : forall j, 'rV[R]_(p_ j)) :\n  diag_mx (\\mxrow_j B_ j) = \\mxdiag_j (diag_mx (B_ j)).\nProof.\napply/matrixP => s s'; rewrite !mxE/= -(can_eq sigK) /sig1 /sig2.\ncase: (sig s) (sig s') => [/= i j] [/= i' j'].\nrewrite -tag_eqE /tag_eq/=; case: (eqVneq i i') => ii'; rewrite ?mxE//=.\nby case: _ / ii' in j' *; rewrite tagged_asE/= conform_mx_id mxE.\nQed.",
    "Lemma mxtrace_mxdiag (B_ : forall i, 'M[R]_(p_ i)) :\n  \\tr (\\mxdiag_i B_ i) = \\sum_i \\tr (B_ i).\nProof.\nby rewrite mxtrace_mxblock; apply: eq_bigr => i _; rewrite eqxx/= conform_mx_id.\nQed.",
    "Lemma mul_mxdiag_mxcol m\n    (D_ : forall i, 'M[R]_(p_ i)) (C_ : forall i, 'M[R]_(p_ i, m)):\n  \\mxdiag_i D_ i *m \\mxcol_i C_ i = \\mxcol_i (D_ i *m C_ i).\nProof.\nrewrite /mxdiag mxblockEh mul_mxrow_mxcol.\nunder [LHS]eq_bigr do rewrite mxcol_mul; rewrite -mxcol_sum.\napply/eq_mxcol => i; rewrite (bigD1 i)//= eqxx conform_mx_id big1 ?addr0//.\nby move=> j; case: eqVneq => //=; rewrite mul0mx.\nQed.",
    "Lemma mul_mxrow_mxdiag {R : pzRingType} {p : nat} {p_ : 'I_p -> nat} m\n    (R_ : forall i, 'M[R]_(m, p_ i)) (D_ : forall i, 'M[R]_(p_ i)) :\n  \\mxrow_i R_ i *m \\mxdiag_i D_ i = \\mxrow_i (R_ i *m D_ i).\nProof.\napply: trmx_inj; rewrite trmx_mul_rev !tr_mxrow tr_mxdiag mul_mxdiag_mxcol.\nby apply/ eq_mxcol => i; rewrite trmx_mul_rev.\nQed.",
    "Lemma mul_mxblock_mxdiag {R : pzRingType} {p q : nat}\n  {p_ : 'I_p -> nat} {q_ : 'I_q -> nat}\n    (B_ : forall i j, 'M[R]_(p_ i, q_ j)) (D_ : forall j, 'M[R]_(q_ j)) :\n  \\mxblock_(i, j) B_ i j *m \\mxdiag_j D_ j = \\mxblock_(i, j) (B_ i j *m D_ j).\nProof.\nby rewrite !mxblockEh mul_mxrow_mxdiag; under eq_mxrow do rewrite mxcol_mul.\nQed.",
    "Lemma mul_mxdiag_mxblock {R : pzRingType} {p q : nat}\n  {p_ : 'I_p -> nat} {q_ : 'I_q -> nat}\n    (D_ : forall j, 'M[R]_(p_ j)) (B_ : forall i j, 'M[R]_(p_ i, q_ j)):\n  \\mxdiag_j D_ j *m \\mxblock_(i, j) B_ i j = \\mxblock_(i, j) (D_ i *m B_ i j).\nProof.\nby rewrite !mxblockEv mul_mxdiag_mxcol; under eq_mxcol do rewrite mul_mxrow.\nQed.",
    "Lemma det_Vandermonde (R : comPzRingType) (n : nat) (a : 'rV[R]_n) :\n  \\det (Vandermonde n a) = \\prod_(i < n) \\prod_(j < n | i < j) (a 0 j - a 0 i).\nProof.\nset V := @Vandermonde R.\nelim: n => [|n IHn] in a *; first by rewrite det_mx00 big1// => -[] [].\npose b : 'rV_n := \\row_i a 0 (lift 0 i).\npose C : 'M_n := diag_mx (\\row_(i < n) (b 0 i - a 0 0)).\npose D : 'M_n.+1 := 1 - a 0 0 *: \\matrix_(i, j) (i == j.+1 :> nat)%:R. \nhave detD : \\det D = 1.\n  rewrite det_trig ?big_ord_recl ?mxE ?mulr0 ?subr0 ?eqxx.\n    by rewrite ?big1 ?mulr1// => i; rewrite !mxE eqxx ltn_eqF// mulr0 subr0.\n  by apply/is_trig_mxP => *; rewrite !mxE ![_ == _]ltn_eqF ?mulr0 ?subr0 ?leqW.\nsuff: D * V _ _ a = block_mx 1 (const_mx 1) 0 (V _ _ b *m C) :> 'M_(1 + n).\n  move=> /(congr1 determinant); rewrite detM detD mul1r => ->.\n  rewrite det_ublock det1 mul1r det_mulmx IHn big_ord_recl mulrC; congr (_ * _).\n    rewrite big_mkcond big_ord_recl/= mul1r det_diag.\n    by under eq_bigr do rewrite !mxE.\n  apply: eq_bigr => i _; under eq_bigr do rewrite !mxE.\n  by rewrite big_mkcond [RHS]big_mkcond big_ord_recl/= mul1r.\nrewrite mulrBl mul1r -[_ * _]scalemxAl; apply/matrixP => i j; rewrite !mxE.\nunder eq_bigr do rewrite !mxE; case: splitP => [{i}_ -> /[!ord1]|{}i ->].\n  rewrite !expr0 big1; last by move=> ?; rewrite mul0r.\n  by rewrite ?mulr0 ?subr0 ?mxE; case: splitP => k; rewrite ?ord1 mxE//.\nunder eq_bigr do rewrite eqSS mulr_natl mulrb eq_sym.\nrewrite -big_mkcond/= big_ord1_eq exprS ifT// ?leqW// -mulrBl !mxE/=.\ncase: split_ordP => [{j}_ -> /[!ord1]|{}j ->]; rewrite ?lshift0 ?rshift1 ?mxE.\n   by rewrite ?subrr ?mul0r//.\nunder eq_bigr do rewrite !mxE mulrnAr mulrb.\nby rewrite -big_mkcond big_pred1_eq /= mulrC.\nQed.",
    "Theorem Lagrange G H : H \\subset G -> (#|H| * #|G : H|)%N = #|G|.\nProof. by move/setIidPr=> sHG; rewrite -{1}sHG LagrangeI. Qed.",
    "Theorem third_isom : {f : {morphism (G / H) / (K / H) >-> coset_of K} | 'injm f\n   & forall A : {set gT}, A \\subset G -> f @* (A / H / (K / H)) = A / K}.\nProof.\nhave [[sKG nKG] [sHG nHG]] := (andP snKG, andP snHG).\nhave sHker: 'ker (coset H) \\subset 'ker (restrm nKG (coset K)).\n  by rewrite ker_restrm !ker_coset subsetI sHG.\nhave:= first_isom_loc (factm_morphism sHker nHG) (subxx _) => /=.\nrewrite ker_factm_loc ker_restrm ker_coset !(setIidPr sKG) /= -!quotientE.\ncase=> f injf im_f; exists f => // A sAG; rewrite im_f ?morphimS //.\nby rewrite morphim_factm morphim_restrm (setIidPr sAG).\nQed.",
    "Theorem third_isog : (G / H / (K / H)) \\isog (G / K).\nProof.\nby case: third_isom => f inj_f im_f; apply/isogP; exists f; rewrite ?im_f.\nQed.",
    "Theorem Frobenius_Cauchy G S : [acts G, on S | to] ->\n  \\sum_(a in G) #|'Fix_(S | to)[a]| = (#|orbit to G @: S| * #|G|)%N.\nProof.\nmove=> GactS; have sGD := acts_dom GactS.\ntransitivity (\\sum_(a in G) \\sum_(x in 'Fix_(S | to)[a]) 1%N).\n  by apply: eq_bigr => a _; rewrite -sum1_card.\nrewrite (exchange_big_dep [in S]) /= => [|a x _]; last by case/setIP.\nrewrite (set_partition_big _ (orbit_partition GactS)) -sum_nat_const /=.\napply: eq_bigr => _ /imsetP[x Sx ->].\nrewrite -(card_orbit_in_stab x sGD) -sum_nat_const.\napply: eq_bigr => y; rewrite orbit_in_sym // => /imsetP[a Ga defx].\nrewrite defx astab1_act_in ?(subsetP sGD) //.\nrewrite -{2}(conjGid Ga) -conjIg cardJg -sum1_card setIA (setIidPl sGD).\nby apply: eq_bigl => b; rewrite !(sub1set, inE) -(acts_act GactS Ga) -defx Sx.\nQed.",
    "Theorem subgroup_transitiveP G H S x :\n     x \\in S -> H \\subset G -> [transitive G, on S | to] ->\n  reflect ('C_G[x | to] * H = G) [transitive H, on S | to].\nProof. by move=> Sx sHG; apply: subgroup_transitivePin (subsetT G). Qed.",
    "Theorem Cayley_isom G : isom G (Cayley_repr G @* G) (Cayley_repr G).\nProof. exact: faithful_isom (faithfulR G). Qed.",
    "Theorem Cayley_isog G : G \\isog Cayley_repr G @* G.\nProof. exact: isom_isog (Cayley_isom G). Qed.",
    "Theorem constt_Inertia_bijection :\n [/\\  {in calA, forall s, 'Ind[G] 'chi_s \\in irr G},\n      {in calA &, injective (Ind_Iirr G)},\n           Ind_Iirr G @: calA =i calB,\n      {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi),\n             [predI irr_constt ('Res chi) & calA] =i pred1 s}\n   &  {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi),\n             '['Res psi, theta] = '['Res chi, theta]}].\nProof.\nhave [sHG sTG]: H \\subset G /\\ T \\subset G by rewrite subsetIl normal_sub.\nhave nsHT : H <| T := normal_Inertia theta sHG; have sHT := normal_sub nsHT.\nhave AtoB_P s (psi := 'chi_s) (chi := 'Ind[G] psi): s \\in calA ->\n  [/\\ chi \\in irr G, AtoB s \\in calB & '['Res psi, theta] = '['Res chi, theta]].\n- rewrite constt_Ind_Res => sHt; have [r sGr] := constt_cfInd_irr s sTG.\n  rewrite constt_Ind_Res.\n  have rTs: s \\in irr_constt ('Res[T] 'chi_r) by rewrite -constt_Ind_Res.\n  have NrT: 'Res[T] 'chi_r \\is a character by rewrite cfRes_char ?irr_char.\n  have rHt: t \\in irr_constt ('Res[H] 'chi_r).\n    by have:= constt_Res_trans NrT rTs sHt; rewrite cfResRes.\n  pose e := '['Res[H] 'chi_r, theta]; set f := '['Res[H] psi, theta].\n  have DrH: 'Res[H] 'chi_r = e *: \\sum_(xi <- (theta ^: G)%CF) xi.\n    exact: Clifford_Res_sum_cfclass.\n  have DpsiH: 'Res[H] psi = f *: theta.\n    rewrite (Clifford_Res_sum_cfclass nsHT sHt).\n    by rewrite cfclass_invariant ?subsetIr ?big_seq1.\n  have ub_chi_r: 'chi_r 1%g <= chi 1%g ?= iff ('chi_r == chi).\n    have Nchi: chi \\is a character by rewrite cfInd_char ?irr_char.\n    have [chi1 Nchi1->] := constt_charP _ Nchi sGr.\n    rewrite addrC cfunE -leifBLR subrr eq_sym -subr_eq0 addrK.\n    by split; rewrite ?char1_ge0 // eq_sym char1_eq0.\n  have lb_chi_r: chi 1%g <= 'chi_r 1%g ?= iff (f == e).\n    rewrite cfInd1 // -(cfRes1 H) DpsiH -(cfRes1 H 'chi_r) DrH !cfunE sum_cfunE.\n    rewrite (eq_big_seq (fun _ => theta 1%g)) => [|i]; last first.\n      by case/cfclassP=> y _ ->; rewrite cfConjg1.\n    rewrite reindex_cfclass //= sumr_const -(eq_card (cfclass_IirrE _ _)).\n    rewrite mulr_natl mulrnAr card_cfclass_Iirr //.\n    rewrite (mono_leif (ler_pMn2r (indexg_gt0 G T))).\n    rewrite (mono_leif (ler_pM2r (irr1_gt0 t))); apply: leif_eq.\n    by rewrite /e -(cfResRes _ sHT) ?cfdot_Res_ge_constt.\n  have [_ /esym] := leif_trans ub_chi_r lb_chi_r; rewrite eqxx.\n  by case/andP=> /eqP Dchi /eqP->; rewrite cfIirrE -/chi -?Dchi ?mem_irr.\nhave part_c: {in calA, forall s (chi := 'Ind[G] 'chi_s),\n  [predI irr_constt ('Res[T] chi) & calA] =i pred1 s}.\n- move=> s As chi s1; have [irr_chi _ /eqP Dchi_theta] := AtoB_P s As.\n  have chiTs: s \\in irr_constt ('Res[T] chi).\n    by rewrite irr_consttE cfdot_Res_l irrWnorm ?oner_eq0.\n  apply/andP/eqP=> [[/= chiTs1 As1] | -> //].\n  apply: contraTeq Dchi_theta => s's1; rewrite lt_eqF // -/chi.\n  have [|phi Nphi DchiT] := constt_charP _ _ chiTs.\n    by rewrite cfRes_char ?cfInd_char ?irr_char.\n  have [|phi1 Nphi1 Dphi] := constt_charP s1 Nphi _.\n    rewrite irr_consttE -(canLR (addKr _) DchiT) addrC cfdotBl cfdot_irr.\n    by rewrite mulrb ifN_eqC ?subr0.\n  rewrite -(cfResRes chi sHT sTG) DchiT Dphi !rmorphD !cfdotDl /=.\n  rewrite -ltrBDl subrr ltr_wpDr ?lt_def //;\n    rewrite natr_ge0 ?Cnat_cfdot_char ?cfRes_char ?irr_char //.\n  by rewrite andbT -irr_consttE -constt_Ind_Res.\ndo [split=> //; try by move=> s /AtoB_P[]] => [s1 s2 As1 As2 | r].\n  have [[irr_s1G _ _] [irr_s2G _ _]] := (AtoB_P _ As1, AtoB_P _ As2).\n  move/(congr1 (tnth (irr G))); rewrite !cfIirrE // => eq_s12_G.\n  apply/eqP; rewrite -[_ == _]part_c // inE /= As1 -eq_s12_G.\n  by rewrite -As1 [_ && _]part_c // inE /=.\napply/imsetP/idP=> [[s /AtoB_P[_ BsG _] -> //] | Br].\nhave /exists_inP[s rTs As]: [exists s in irr_constt ('Res 'chi_r), s \\in calA].\n  rewrite -negb_forall_in; apply: contra Br => /eqfun_inP => o_tT_rT.\n  rewrite -(cfIndInd _ sTG sHT) -cfdot_Res_r ['Res _]cfun_sum_constt.\n  by rewrite cfdot_sumr big1 // => i rTi; rewrite cfdotZr o_tT_rT ?mulr0.\nexists s => //; have [/irrP[r1 DsG] _ _] := AtoB_P s As.\nby apply/eqP; rewrite /AtoB -constt_Ind_Res DsG irrK constt_irr in rTs *.\nQed.",
    "Theorem constt_Ind_mul_ext f (phi := 'chi_f) (psi := phi * theta) :\n  G \\subset 'I[phi] -> psi \\in irr N ->\n  let calS := irr_constt ('Ind phi) in\n  [/\\ {in calS, forall b, 'chi_b * chi \\in irr G},\n      {in calS &, injective mul_Iirr},\n      irr_constt ('Ind psi) =i [seq mul_Iirr b | b in calS]\n    & 'Ind psi = \\sum_(b in calS) '['Ind phi, 'chi_b] *: 'chi_(mul_Iirr b)].\nProof.\nmove=> IGphi irr_psi calS.\nhave IGpsi: G \\subset 'I[psi].\n  by rewrite (subset_trans _ (inertia_mul _ _)) // subsetI IGphi.\npose e b := '['Ind[G] phi, 'chi_b]; pose d b g := '['chi_b * chi, 'chi_g * chi].\nhave Ne b: e b \\in Num.nat by rewrite Cnat_cfdot_char ?cfInd_char ?irr_char.\nhave egt0 b: b \\in calS -> e b > 0 by rewrite natr_gt0.\nhave DphiG: 'Ind phi = \\sum_(b in calS) e b *: 'chi_b := cfun_sum_constt _.\nhave DpsiG: 'Ind psi = \\sum_(b in calS) e b *: 'chi_b * chi.\n  by rewrite /psi -cNt cfIndM // DphiG mulr_suml.\npose d_delta := [forall b in calS, forall g in calS, d b g == (b == g)%:R].\nhave charMchi b: 'chi_b * chi \\is a character by rewrite rpredM ?irr_char.\nhave [_]: '['Ind[G] phi] <= '['Ind[G] psi] ?= iff d_delta.\n  pose sum_delta := \\sum_(b in calS) e b * \\sum_(g in calS) e g * (b == g)%:R.\n  pose sum_d := \\sum_(b in calS) e b * \\sum_(g in calS) e g * d b g.\n  have ->: '['Ind[G] phi] = sum_delta.\n    rewrite DphiG cfdot_suml; apply: eq_bigr => b _; rewrite cfdotZl cfdot_sumr.\n    by congr (_ * _); apply: eq_bigr => g; rewrite cfdotZr cfdot_irr conj_natr.\n  have ->: '['Ind[G] psi] = sum_d.\n    rewrite DpsiG cfdot_suml; apply: eq_bigr => b _.\n    rewrite -scalerAl cfdotZl cfdot_sumr; congr (_ * _).\n    by apply: eq_bigr => g _; rewrite -scalerAl cfdotZr conj_natr.\n  have eMmono := mono_leif (ler_pM2l (egt0 _ _)).\n  apply: leif_sum => b /eMmono->; apply: leif_sum => g /eMmono->.\n  split; last exact: eq_sym.\n  have /natrP[n Dd]: d b g \\in Num.nat by rewrite Cnat_cfdot_char.\n  have [Db | _] := eqP; rewrite Dd leC_nat // -ltC_nat -Dd Db cfnorm_gt0.\n  by rewrite -char1_eq0 // cfunE mulf_neq0 ?irr1_neq0.\nrewrite -!cfdot_Res_l ?cfRes_Ind_invariant // !cfdotZl cfnorm_irr irrWnorm //.\nrewrite eqxx => /esym/forall_inP/(_ _ _)/eqfun_inP; rewrite /d /= => Dd.\nhave irrMchi: {in calS, forall b, 'chi_b * chi \\in irr G}.\n  by move=> b Sb; rewrite /= irrEchar charMchi Dd ?eqxx.\nhave injMchi: {in calS &, injective mul_Iirr}.\n  move=> b g Sb Sg /(congr1 (fun s => '['chi_s, 'chi_(mul_Iirr g)]))/eqP.\n  by rewrite cfnorm_irr !cfIirrE ?irrMchi ?Dd // pnatr_eq1; case: (b =P g).\nhave{DpsiG} ->: 'Ind psi = \\sum_(b in calS) e b *: 'chi_(mul_Iirr b).\n  by rewrite DpsiG; apply: eq_bigr => b Sb; rewrite -scalerAl cfIirrE ?irrMchi.\nsplit=> // i; rewrite irr_consttE cfdot_suml;\napply/idP/idP=> [|/imageP[b Sb ->]].\n  apply: contraR => N'i; rewrite big1 // => b Sb.\n  rewrite cfdotZl cfdot_irr mulrb ifN_eqC ?mulr0 //.\n  by apply: contraNneq N'i => ->; apply: image_f.\nrewrite gt_eqF // (bigD1 b) //= cfdotZl cfnorm_irr mulr1 ltr_wpDr ?egt0 //.\napply: sumr_ge0 => g /andP[Sg _]; rewrite cfdotZl cfdot_irr.\nby rewrite mulr_ge0 ?ler0n ?natr_ge0.\nQed.",
    "Theorem invariant_chief_irr_cases G K L s (theta := 'chi[K]_s) :\n    chief_factor G L K -> abelian (K / L) -> G \\subset 'I[theta] ->\n  let t := #|K : L| in\n  [\\/ 'Res[L] theta \\in irr L,\n      exists2 e, exists p, 'Res[L] theta = e%:R *: 'chi_p & (e ^ 2)%N = t\n   |  exists2 p, injective p & 'Res[L] theta = \\sum_(i < t) 'chi_(p i)].\nProof.\ncase/andP=> /maxgroupP[/andP[ltLK nLG] maxL] nsKG abKbar IGtheta t.\nhave [sKG nKG] := andP nsKG; have sLG := subset_trans (proper_sub ltLK) sKG.\nhave nsLG: L <| G by apply/andP.\nhave nsLK := normalS (proper_sub ltLK) sKG nsLG; have [sLK nLK] := andP nsLK.\nhave [p0 sLp0] := constt_cfRes_irr L s; rewrite -/theta in sLp0.\npose phi := 'chi_p0; pose T := 'I_G[phi].\nhave sTG: T \\subset G := subsetIl G _.\nhave /eqP mulKT: (K * T)%g == G.\n  rewrite eqEcard mulG_subG sKG sTG -LagrangeMr -indexgI -(Lagrange sTG) /= -/T.\n  rewrite mulnC leq_mul // setIA (setIidPl sKG) -!size_cfclass // -/phi.\n  rewrite uniq_leq_size ?cfclass_uniq // => _ /cfclassP[x Gx ->].\n  have: conjg_Iirr p0 x \\in irr_constt ('Res theta).\n    have /inertiaJ <-: x \\in 'I[theta] := subsetP IGtheta x Gx.\n    by rewrite -(cfConjgRes _ nsKG) // irr_consttE conjg_IirrE // cfConjg_iso.\n  apply: contraR; rewrite -conjg_IirrE // => not_sLp0x.\n  rewrite (Clifford_Res_sum_cfclass nsLK sLp0) cfdotZl cfdot_suml.\n  rewrite big1_seq ?mulr0 // => _ /cfclassP[y Ky ->]; rewrite -conjg_IirrE //.\n  rewrite cfdot_irr mulrb ifN_eq ?(contraNneq _ not_sLp0x) // => <-.\n  by rewrite conjg_IirrE //; apply/cfclassP; exists y.\nhave nsKT_G: K :&: T <| G.\n  rewrite /normal subIset ?sKG // -mulKT setIA (setIidPl sKG) mulG_subG.\n  rewrite normsIG // sub_der1_norm ?subsetIl //.\n  exact: subset_trans (der1_min nLK abKbar) (sub_Inertia _ sLK).\nhave [e DthL]: exists e, 'Res theta = e%:R *: \\sum_(xi <- (phi ^: K)%CF) xi.\n  rewrite (Clifford_Res_sum_cfclass nsLK sLp0) -/phi; set e := '[_, _].\n  exists (Num.truncn e).\n  by rewrite truncnK ?Cnat_cfdot_char ?cfRes_char ?irr_char.\nhave [defKT | ltKT_K] := eqVneq (K :&: T) K; last first.\n  have defKT: K :&: T = L.\n    apply: maxL; last by rewrite subsetI sLK sub_Inertia.\n    by rewrite normal_norm // properEneq ltKT_K subsetIl.\n  have t_cast: size (phi ^: K)%CF = t.\n    by rewrite size_cfclass //= -{2}(setIidPl sKG) -setIA defKT.\n  pose phiKt := Tuple (introT eqP t_cast); pose p i := cfIirr (tnth phiKt i).\n  have pK i: 'chi_(p i) = (phi ^: K)%CF`_i.\n    rewrite cfIirrE; first by rewrite (tnth_nth 0).\n    by have /cfclassP[y _ ->] := mem_tnth i phiKt; rewrite cfConjg_irr ?mem_irr.\n  constructor 3; exists p => [i j /(congr1 (tnth (irr L)))/eqP| ].\n    by apply: contraTeq; rewrite !pK !nth_uniq ?t_cast ?cfclass_uniq.\n  have{} DthL: 'Res theta = e%:R *: \\sum_(i < t) (phi ^: K)%CF`_i.\n    by rewrite DthL (big_nth 0) big_mkord t_cast.\n  suffices /eqP e1: e == 1 by rewrite DthL e1 scale1r; apply: eq_bigr.\n  have Dth1: theta 1%g = e%:R * t%:R * phi 1%g.\n    rewrite -[t]card_ord -mulrA -(cfRes1 L) DthL cfunE; congr (_ * _).\n    rewrite mulr_natl -sumr_const sum_cfunE -t_cast; apply: eq_bigr => i _.\n    by have /cfclassP[y _ ->] := mem_nth 0 (valP i); rewrite cfConjg1.\n  rewrite eqn_leq lt0n (contraNneq _ (irr1_neq0 s)); last first.\n    by rewrite Dth1 => ->; rewrite !mul0r.\n  rewrite -leC_nat -(ler_pM2r (gt0CiG K L)) -/t -(ler_pM2r (irr1_gt0 p0)).\n  rewrite mul1r -Dth1 -cfInd1 //.\n  by rewrite char1_ge_constt ?cfInd_char ?irr_char ?constt_Ind_Res.\nhave IKphi: 'I_K[phi] = K by rewrite -{1}(setIidPl sKG) -setIA.\nhave{} DthL: 'Res[L] theta = e%:R *: phi.\n  by rewrite DthL -[rhs in (_ ^: rhs)%CF]IKphi cfclass_inertia big_seq1.\npose mmLth := @mul_mod_Iirr K L s.\nhave linKbar := char_abelianP _ abKbar.\nhave LmodL i: ('chi_i %% L)%CF \\is a linear_char := cfMod_lin_char (linKbar i).\nhave mmLthE i: 'chi_(mmLth i) = ('chi_i %% L)%CF * theta.\n  by rewrite cfIirrE ?mod_IirrE // mul_lin_irr ?mem_irr.\nhave mmLthL i: 'Res[L] 'chi_(mmLth i) = 'Res[L] theta.\n  rewrite mmLthE rmorphM /= cfRes_sub_ker ?cfker_mod ?lin_char1 //.\n  by rewrite scale1r mul1r.\nhave [inj_Mphi | /injectivePn[i [j i'j eq_mm_ij]]] := boolP (injectiveb mmLth).\n  suffices /eqP e1: e == 1 by constructor 1; rewrite DthL e1 scale1r mem_irr.\n  rewrite eqn_leq lt0n (contraNneq _ (irr1_neq0 s)); last first.\n    by rewrite -(cfRes1 L) DthL cfunE => ->; rewrite !mul0r.\n  rewrite -leq_sqr -leC_nat natrX -(ler_pM2r (irr1_gt0 p0)) -mulrA mul1r.\n  have ->: e%:R * 'chi_p0 1%g = 'Res[L] theta 1%g by rewrite DthL cfunE.\n  rewrite cfRes1 -(ler_pM2l (gt0CiG K L)) -cfInd1 // -/phi.\n  rewrite -card_quotient // -card_Iirr_abelian // mulr_natl.\n  rewrite ['Ind phi]cfun_sum_cfdot sum_cfunE (bigID [in codom mmLth]) /=.\n  rewrite ler_wpDr ?sumr_ge0 // => [i _|].\n    by rewrite char1_ge0 ?rpredZ_nat ?Cnat_cfdot_char ?cfInd_char ?irr_char.\n  rewrite -big_uniq //= big_image -sumr_const ler_sum // => i _.\n  rewrite cfunE -[in leRHS](cfRes1 L) -cfdot_Res_r mmLthL cfRes1.\n  by rewrite DthL cfdotZr rmorph_nat cfnorm_irr mulr1.\nconstructor 2; exists e; first by exists p0.\npose mu := (('chi_i / 'chi_j)%R %% L)%CF; pose U := cfker mu.\nhave lin_mu: mu \\is a linear_char by rewrite cfMod_lin_char ?rpred_div.\nhave Uj := lin_char_unitr (linKbar j).\nhave ltUK: U \\proper K.\n  rewrite /proper cfker_sub /U; have /irrP[k Dmu] := lin_char_irr lin_mu.\n  rewrite Dmu subGcfker -irr_eq1 -Dmu cfMod_eq1 //.\n  by rewrite (can2_eq (divrK Uj) (mulrK Uj)) mul1r (inj_eq irr_inj).\nsuffices: theta \\in 'CF(K, L).\n  rewrite -cfnorm_Res_leif // DthL cfnormZ !cfnorm_irr !mulr1 normr_nat.\n  by rewrite -natrX eqC_nat => /eqP.\nhave <-: gcore U G = L.\n  apply: maxL; last by rewrite sub_gcore ?cfker_mod.\n  by rewrite gcore_norm (sub_proper_trans (gcore_sub _ _)).\napply/cfun_onP=> x; apply: contraNeq => nz_th_x.\napply/bigcapP=> y /(subsetP IGtheta)/setIdP[nKy /eqP th_y].\napply: contraR nz_th_x; rewrite mem_conjg -{}th_y cfConjgE {nKy}//.\nmove: {x y}(x ^ _) => x U'x; have [Kx | /cfun0-> //] := boolP (x \\in K).\nhave /eqP := congr1 (fun k => (('chi_j %% L)%CF^-1 * 'chi_k) x) eq_mm_ij.\nrewrite -rmorphV // !mmLthE !mulrA -!rmorphM mulVr // rmorph1 !cfunE.\nrewrite (mulrC _^-1) -/mu -subr_eq0 -mulrBl cfun1E Kx mulf_eq0 => /orP[]//.\nrewrite mulrb subr_eq0 -(lin_char1 lin_mu) [_ == _](contraNF _ U'x) //.\nby rewrite /U cfkerEchar ?lin_charW // inE Kx.\nQed.",
    "Theorem solvable_irr_extendible_from_det G N s (theta := 'chi[N]_s) :\n    N <| G -> solvable (G / N) ->\n    G \\subset 'I[theta] -> coprime #|G : N| (Num.truncn (theta 1%g)) ->\n  [exists c, 'Res 'chi[G]_c == theta]\n    = [exists u, 'Res 'chi[G]_u == cfDet theta].\nProof.\nset e := #|G : N|; set f := Num.truncn _ => nsNG solG IGtheta co_e_f.\napply/exists_eqP/exists_eqP=> [[c cNth] | [u uNdth]].\n  have /lin_char_irr/irrP[u Du] := cfDet_lin_char 'chi_c.\n  by exists u; rewrite -Du -cfDetRes ?irr_char ?cNth.\nmove: {2}e.+1 (ltnSn e) => m.\nelim: m => // m IHm in G u e nsNG solG IGtheta co_e_f uNdth *.\nrewrite ltnS => le_e; have [sNG nNG] := andP nsNG.\nhave [<- | ltNG] := eqsVneq N G; first by exists s; rewrite cfRes_id.\nhave [G0 maxG0 sNG0]: {G0 | maxnormal (gval G0) G G & N \\subset G0}.\n  by apply: maxgroup_exists; rewrite properEneq ltNG sNG.\nhave [/andP[ltG0G nG0G] maxG0_P] := maxgroupP maxG0.\nset mu := 'chi_u in uNdth; have lin_mu: mu \\is a linear_char.\n  by rewrite qualifE/= irr_char -(cfRes1 N) uNdth /= lin_char1 ?cfDet_lin_char.\nhave sG0G := proper_sub ltG0G; have nsNG0 := normalS sNG0 sG0G nsNG.\nhave nsG0G: G0 <| G by apply/andP.\nhave /lin_char_irr/irrP[u0 Du0] := cfRes_lin_char G0 lin_mu.\nhave u0Ndth: 'Res 'chi_u0 = cfDet theta by rewrite -Du0 cfResRes.\nhave IG0theta: G0 \\subset 'I[theta].\n  by rewrite (subset_trans sG0G) // -IGtheta subsetIr.\nhave coG0f: coprime #|G0 : N| f by rewrite (coprime_dvdl _ co_e_f) ?indexSg.\nhave{m IHm le_e} [c0 c0Ns]: exists c0, 'Res 'chi[G0]_c0 = theta.\n  have solG0: solvable (G0 / N) := solvableS (quotientS N sG0G) solG.\n  apply: IHm nsNG0 solG0 IG0theta coG0f u0Ndth (leq_trans _ le_e).\n  by rewrite -(ltn_pmul2l (cardG_gt0 N)) !Lagrange ?proper_card.\nhave{c0 c0Ns} [c0 [c0Ns dc0_u0] Uc0] := extend_to_cfdet nsNG0 coG0f c0Ns u0Ndth.\nhave IGc0: G \\subset 'I['chi_c0].\n  apply/subsetP=> x Gx; rewrite inE (subsetP nG0G) //= -conjg_IirrE.\n  apply/eqP; congr 'chi__; apply: Uc0; rewrite conjg_IirrE.\n    by rewrite -(cfConjgRes _ nsG0G nsNG) // c0Ns inertiaJ ?(subsetP IGtheta).\n  by rewrite cfDetConjg dc0_u0 -Du0 (cfConjgRes _ _ nsG0G) // cfConjg_id.\nhave prG0G: prime #|G : G0|.\n  have [h injh im_h] := third_isom sNG0 nsNG nsG0G.\n  rewrite -card_quotient // -im_h // card_injm //.\n  rewrite simple_sol_prime 1?quotient_sol //.\n  by rewrite /simple -(injm_minnormal injh) // im_h // maxnormal_minnormal.\nhave [t tG0c0] := prime_invariant_irr_extendible nsG0G (erefl _) prG0G IGc0.\nby exists t; rewrite /theta -c0Ns -tG0c0 cfResRes.\nQed.",
    "Theorem extend_linear_char_from_Sylow G N (lambda : 'CF(N)) :\n    N <| G -> lambda \\is a linear_char -> G \\subset 'I[lambda] ->\n    (forall p, p \\in \\pi('o(lambda)%CF) ->\n       exists2 Hp : {group gT},\n         [/\\ N \\subset Hp, Hp \\subset G & p.-Sylow(G / N) (Hp / N)%g]\n       & exists u, 'Res 'chi[Hp]_u = lambda) ->\n  exists u, 'Res[N, G] 'chi_u = lambda.\nProof.\nset m := 'o(lambda)%CF => nsNG lam_lin IGlam p_ext_lam.\nhave [sNG nNG] := andP nsNG; have linN := @cfRes_lin_lin _ _ N.\nwlog [p p_lam]: lambda @m lam_lin IGlam p_ext_lam /\n  exists p : nat, \\pi(m) =i (p : nat_pred).\n- move=> IHp; have [linG [cf [inj_cf _ lin_cf onto_cf]]] := lin_char_group N.\n  case=> cf1 cfM cfX _ cf_order; have [lam cf_lam] := onto_cf _ lam_lin.\n  pose mu p := cf lam.`_p; pose pi_m p := p \\in \\pi(m).\n  have Dm: m = #[lam] by rewrite /m cfDet_order_lin // cf_lam cf_order.\n  have Dlambda: lambda = \\prod_(p < m.+1 | pi_m p) mu p.\n    rewrite -(big_morph cf cfM cf1) big_mkcond cf_lam /pi_m Dm; congr (cf _).\n    rewrite -{1}[lam]prod_constt big_mkord; apply: eq_bigr => p _.\n    by case: ifPn => // p'lam; apply/constt1P; rewrite /p_elt p'natEpi.\n  have lin_mu p: mu p \\is a linear_char by rewrite /mu cfX -cf_lam rpredX.\n  suffices /fin_all_exists [u uNlam] (p : 'I_m.+1):\n    exists u, pi_m p -> 'Res[N, G] 'chi_u = mu p.\n  - pose nu := \\prod_(p < m.+1 | pi_m p) 'chi_(u p).\n    have lin_nu: nu \\is a linear_char.\n      by apply: rpred_prod => p m_p; rewrite linN ?irr_char ?uNlam.\n    have /irrP[u1 Dnu] := lin_char_irr lin_nu.\n    by exists u1; rewrite Dlambda -Dnu rmorph_prod; apply: eq_bigr.\n  have [m_p | _] := boolP (pi_m p); last by exists 0.\n  have o_mu: \\pi('o(mu p)%CF) =i (p : nat_pred).\n    rewrite cfDet_order_lin // cf_order orderE /=.\n    have [|pr_p _ [k ->]] := pgroup_pdiv (p_elt_constt p lam).\n      by rewrite cycle_eq1 (sameP eqP constt1P) /p_elt p'natEpi // negbK -Dm.\n    by move=> q; rewrite pi_of_exp // pi_of_prime.\n  have IGmu: G \\subset 'I[mu p].\n    rewrite (subset_trans IGlam) // /mu cfX -cf_lam.\n    elim: (chinese _ _ _ _) => [|k IHk]; first by rewrite inertia1 norm_inertia.\n    by rewrite exprS (subset_trans _ (inertia_mul _ _)) // subsetIidl.\n  have [q||u] := IHp _ (lin_mu p) IGmu; [ | by exists p | by exists u].\n  rewrite o_mu => /eqnP-> {q}.\n  have [Hp sylHp [u uNlam]] := p_ext_lam p m_p; exists Hp => //.\n  rewrite /mu cfX -cf_lam -uNlam -rmorphXn /=; set nu := _ ^+ _.\n  have /lin_char_irr/irrP[v ->]: nu \\is a linear_char; last by exists v.\n  by rewrite rpredX // linN ?irr_char ?uNlam.\nhave pi_m_p: p \\in \\pi(m) by rewrite p_lam !inE.\nhave [pr_p mgt0]: prime p /\\ (m > 0)%N.\n  by have:= pi_m_p; rewrite mem_primes => /and3P[].\nhave p_m: p.-nat m by rewrite -(eq_pnat _ p_lam) pnat_pi.\nhave{p_ext_lam} [H [sNH sHG sylHbar] [v vNlam]] := p_ext_lam p pi_m_p.\nhave co_p_GH: coprime p #|G : H|.\n  rewrite -(index_quotient_eq _ sHG nNG) ?subIset ?sNH ?orbT //.\n  by rewrite (pnat_coprime (pnat_id pr_p)) //; have [] := and3P sylHbar.\nhave lin_v: 'chi_v \\is a linear_char by rewrite linN ?irr_char ?vNlam.\npose nuG := 'Ind[G] 'chi_v.\nhave [c vGc co_p_f]: exists2 c, c \\in irr_constt nuG & ~~ (p %| 'chi_c 1%g)%C.\n  apply/exists_inP; rewrite -negb_forall_in.\n  apply: contraL co_p_GH => /forall_inP p_dv_v1.\n  rewrite prime_coprime // negbK -dvdC_nat -[rhs in (_ %| rhs)%C]mulr1.\n  rewrite -(lin_char1 lin_v) -cfInd1 // ['Ind _]cfun_sum_constt /=.\n  rewrite sum_cfunE rpred_sum // => i /p_dv_v1 p_dv_chi1i.\n  rewrite cfunE dvdC_mull // intr_nat //.\n  by rewrite Cnat_cfdot_char ?cfInd_char ?irr_char.\npose f := Num.truncn ('chi_c 1%g); pose b := (egcdn f m).1.\nhave fK: f%:R = 'chi_c 1%g by rewrite truncnK ?Cnat_irr1.\nhave fb_mod_m: f * b = 1 %[mod m].\n  have co_m_f: coprime m f.\n    by rewrite (pnat_coprime p_m) ?p'natE // -dvdC_nat CdivE fK.\n  by rewrite -(chinese_modl co_m_f 1 0) /chinese !mul0n addn0 mul1n.\nhave /irrP[s Dlam] := lin_char_irr lam_lin.\nhave cHv: v \\in irr_constt ('Res[H] 'chi_c) by rewrite -constt_Ind_Res.\nhave{cHv} cNs: s \\in irr_constt ('Res[N] 'chi_c).\n  rewrite -(cfResRes _ sNH) ?(constt_Res_trans _ cHv) ?cfRes_char ?irr_char //.\n  by rewrite vNlam Dlam constt_irr !inE.\nhave DcN: 'Res[N] 'chi_c = lambda *+ f.\n  have:= Clifford_Res_sum_cfclass nsNG cNs.\n  rewrite cfclass_invariant -Dlam // big_seq1 Dlam => DcN.\n  have:= cfRes1 N 'chi_c; rewrite DcN cfunE -Dlam lin_char1 // mulr1 => ->.\n  by rewrite -scaler_nat fK.\nhave /lin_char_irr/irrP[d Dd]: cfDet 'chi_c ^+ b \\is a linear_char.\n  by rewrite rpredX // cfDet_lin_char.\nexists d; rewrite -{}Dd rmorphXn /= -cfDetRes ?irr_char // DcN.\nrewrite cfDetMn ?lin_charW // -exprM cfDet_id //.\nrewrite -(expr_mod _ (exp_cforder _)) -cfDet_order_lin // -/m.\nby rewrite fb_mod_m /m cfDet_order_lin // expr_mod ?exp_cforder.\nQed.",
    "Theorem inertia_Frobenius_ker i : i != 0 -> 'I_G['chi[K]_i] = K.\nProof.\nhave [_ _ nsKG regK] := Frobenius_kerP frobGK; have [sKG nKG] := andP nsKG.\nmove=> nzi; apply/eqP; rewrite eqEsubset sub_Inertia // andbT.\napply/subsetP=> x /setIP[Gx /setIdP[nKx /eqP x_stab_i]].\nhave actIirrK: is_action G (@conjg_Iirr _ K).\n  split=> [y j k eq_jk | j y z Gy Gz].\n    by apply/irr_inj/(can_inj (cfConjgK y)); rewrite -!conjg_IirrE eq_jk.\n  by apply: irr_inj; rewrite !conjg_IirrE (cfConjgM _ nsKG).\npose ito := Action actIirrK; pose cto := ('Js \\ (subsetT G))%act.\nhave acts_Js : [acts G, on classes K | 'Js].\n  apply/subsetP=> y Gy; have nKy := subsetP nKG y Gy.\n  rewrite !inE; apply/subsetP=> _ /imsetP[z Gz ->] /[!inE]/=.\n  rewrite -class_rcoset norm_rlcoset // class_lcoset.\n  by apply: imset_f; rewrite memJ_norm.\nhave acts_cto : [acts G, on classes K | cto] by rewrite astabs_ract subsetIidl.\npose m := #|'Fix_(classes K | cto)[x]|.\nhave def_m: #|'Fix_ito[x]| = m.\n  apply: card_afix_irr_classes => // j y _ Ky /imsetP[_ /imsetP[z Kz ->] ->].\n  by rewrite conjg_IirrE cfConjgEJ // cfunJ.\nhave: (m != 1)%N.\n  rewrite -def_m (cardD1 (0 : Iirr K)) (cardD1 i) !(inE, sub1set) /=.\n  by rewrite conjg_Iirr0 nzi eqxx -(inj_eq irr_inj) conjg_IirrE x_stab_i eqxx.\napply: contraR => notKx; apply/cards1P; exists 1%g; apply/esym/eqP.\nrewrite eqEsubset !(sub1set, inE) classes1 /= conjs1g eqxx /=.\napply/subsetP=> _ /setIP[/imsetP[y Ky ->] /afix1P /= cyKx].\nhave /imsetP[z Kz def_yx]: y ^ x \\in y ^: K.\n  by rewrite -cyKx; apply: imset_f; apply: class_refl.\nrewrite inE classG_eq1; apply: contraR notKx => nty.\nrewrite -(groupMr x (groupVr Kz)).\napply: (subsetP (regK y _)); first exact/setD1P.\nrewrite !inE groupMl // groupV (subsetP sKG) //=.\nby rewrite conjg_set1 conjgM def_yx conjgK.\nQed.",
    "Theorem irr_induced_Frobenius_ker i : i != 0 -> 'Ind[G, K] 'chi_i \\in irr G.\nProof.\nmove/inertia_Frobenius_ker/group_inj=> defK.\nhave [_ _ nsKG _] := Frobenius_kerP frobGK.\nhave [] := constt_Inertia_bijection i nsKG; rewrite defK cfInd_id => -> //.\nby rewrite constt_irr !inE.\nQed.",
    "Theorem Frobenius_Ind_irrP j :\n  reflect (exists2 i, i != 0 & 'chi_j = 'Ind[G, K] 'chi_i)\n          (~~ (K \\subset cfker 'chi_j)).\nProof.\nhave [_ _ nsKG _] := Frobenius_kerP frobGK; have [sKG nKG] := andP nsKG.\napply: (iffP idP) => [not_chijK1 | [i nzi ->]]; last first.\n  by rewrite cfker_Ind_irr ?sub_gcore // subGcfker.\nhave /neq0_has_constt[i chijKi]: 'Res[K] 'chi_j != 0 by apply: Res_irr_neq0.\nhave nz_i: i != 0.\n  by apply: contraNneq not_chijK1 => i0; rewrite constt0_Res_cfker // -i0.\nhave /irrP[k def_chik] := irr_induced_Frobenius_ker nz_i.\nhave: '['chi_j, 'chi_k] != 0 by rewrite -def_chik -cfdot_Res_l.\nby rewrite cfdot_irr pnatr_eq0; case: (j =P k) => // ->; exists i.\nQed.",
    "Theorem gring_classM_expansion i j : 'K_i *m 'K_j = \\sum_k (a i j k)%:R *: 'K_k.\nProof.\nhave [/imsetP[zi Gzi dKi] /imsetP[zj Gzj dKj]] := (enum_valP i, enum_valP j).\npose aG := regular_repr F G; have sKG := subsetP (class_subG _ (subxx G)).\ntransitivity (\\sum_(x in zi ^: G) \\sum_(y in zj ^: G) aG (x * y)%g).\n  rewrite mulmx_suml -/aG dKi; apply: eq_bigr => x /sKG Gx.\n  rewrite mulmx_sumr -/aG dKj; apply: eq_bigr => y /sKG Gy.\n  by rewrite repr_mxM ?Gx ?Gy.\npose h2 xy : gT := (xy.1 * xy.2)%g.\npose h1 xy := enum_rank_in (classes1 G) (h2 xy ^: G).\nrewrite pair_big (partition_big h1 xpredT) //=; apply: eq_bigr => k _.\nrewrite (partition_big h2 [in enum_val k]) /= => [|[x y]]; last first.\n  case/andP=> /andP[/= /sKG Gx /sKG Gy] /eqP <-.\n  by rewrite enum_rankK_in ?class_refl ?mem_classes ?groupM ?Gx ?Gy.\nrewrite scaler_sumr; apply: eq_bigr => g Kk_g; rewrite scaler_nat.\nrewrite (set_gring_classM_coef _ _ Kk_g) -sumr_const; apply: eq_big => [] [x y].\n  rewrite !inE /= dKi dKj /h1 /h2 /=; apply: andb_id2r => /eqP ->.\n  have /imsetP[zk Gzk dKk] := enum_valP k; rewrite dKk in Kk_g.\n  by rewrite (class_eqP Kk_g) -dKk enum_valK_in eqxx andbT.\nby rewrite /h2 /= => /andP[_ /eqP->].\nQed.",
    "Theorem coprime_degree_support_cfcenter g :\n    coprime (Num.truncn ('chi_i 1%g)) #|g ^: G| -> g \\notin ('Z('chi_i))%CF ->\n  'chi_i g = 0.\nProof.\nset m := Num.truncn _ => co_m_gG notZg.\nhave [Gg | /cfun0-> //] := boolP (g \\in G).\nhave Dm: 'chi_i 1%g = m%:R by rewrite truncnK ?Cnat_irr1.\nhave m_gt0: (0 < m)%N by rewrite -ltC_nat -Dm irr1_gt0.\nhave nz_m: m%:R != 0 :> algC by rewrite pnatr_eq0 -lt0n.\npose alpha := 'chi_i g / m%:R.\nhave a_lt1: `|alpha| < 1.\n  rewrite normrM normfV normr_nat -{2}(divff nz_m).\n  rewrite lt_def (can_eq (mulfVK nz_m)) eq_sym -{1}Dm -irr_cfcenterE // notZg.\n  by rewrite ler_pM2r ?invr_gt0 ?ltr0n // -Dm char1_ge_norm ?irr_char.\nhave Za: alpha \\in Aint.\n  have [u _ /dvdnP[v eq_uv]] := Bezoutl #|g ^: G| m_gt0.\n  suffices ->: alpha = v%:R * 'chi_i g - u%:R * (alpha * #|g ^: G|%:R).\n    rewrite rpredB // rpredM ?rpred_nat ?Aint_irr //.\n    by rewrite mulrC mulrA -Dm Aint_class_div_irr1.\n  rewrite -mulrCA -[v%:R](mulfK nz_m) -!natrM -eq_uv (eqnP co_m_gG).\n  by rewrite mulrAC -mulrA -/alpha mulr_natl mulr_natr mulrS addrK.\nhave [Qn galQn [QnC gQnC [_ _ Qn_g]]] := group_num_field_exists <[g]>.\nhave{Qn_g} [a Da]: exists a, QnC a = alpha.\n  rewrite /alpha; have [a <-] := Qn_g _ G _ (irr_char i) g (dvdnn _).\n  by exists (a / m%:R); rewrite fmorph_div rmorph_nat.\nhave Za_nu nu: sval (gQnC nu) alpha \\in Aint by rewrite Aint_aut.\nhave norm_a_nu nu: `|sval (gQnC nu) alpha| <= 1.\n  move: {nu}(sval _) => nu; rewrite fmorph_div rmorph_nat normrM normfV.\n  rewrite normr_nat -Dm -(ler_pM2r (irr1_gt0 (aut_Iirr nu i))) mul1r.\n  congr (_ <= _): (char1_ge_norm g (irr_char (aut_Iirr nu i))).\n  by rewrite !aut_IirrE !cfunE Dm rmorph_nat divfK.\npose beta := QnC (galNorm 1 {:Qn} a).\nhave Dbeta: beta = \\prod_(nu in 'Gal({:Qn} / 1)) sval (gQnC nu) alpha.\n  rewrite /beta rmorph_prod. apply: eq_bigr => nu _.\n  by case: (gQnC nu) => f /= ->; rewrite Da.\nhave Zbeta: beta \\in Num.int.\n  apply: Cint_rat_Aint; last by rewrite Dbeta rpred_prod.\n  rewrite /beta; have /vlineP[/= c ->] := mem_galNorm galQn (memvf a).\n  by rewrite alg_num_field fmorph_rat rpred_rat.\nhave [|nz_a] := boolP (alpha == 0).\n  by rewrite (can2_eq (divfK _) (mulfK _)) // mul0r => /eqP.\nhave: beta != 0 by rewrite Dbeta; apply/prodf_neq0 => nu _; rewrite fmorph_eq0.\nmove/(norm_intr_ge1 Zbeta); rewrite lt_geF //; apply: le_lt_trans a_lt1.\nrewrite -[`|alpha|]mulr1 Dbeta (bigD1 1%g) ?group1 //= -Da.\ncase: (gQnC _) => /= _ <-.\nrewrite gal_id normrM -subr_ge0 -mulrBr mulr_ge0 // Da subr_ge0.\nelim/big_rec: _ => [|nu c _]; first by rewrite normr1 lexx.\napply: le_trans; rewrite -subr_ge0 -{1}[`|c|]mul1r normrM -mulrBl.\nby rewrite mulr_ge0 // subr_ge0 norm_a_nu.\nQed.",
    "Theorem primes_class_simple_gt1 C :\n  simple G -> ~~ abelian G -> C \\in (classes G)^# -> (size (primes #|C|) > 1)%N.\nProof.\nmove=> simpleG not_cGG /setD1P[ntC /imsetP[g Gg defC]].\nhave{ntC} nt_g: g != 1%g by rewrite defC classG_eq1 in ntC.\nrewrite ltnNge {C}defC; set m := #|_|; apply/negP=> p_natC.\nhave{p_natC} [p p_pr [a Dm]]: {p : nat & prime p & {a | m = p ^ a}%N}.\n  have /prod_prime_decomp->: (0 < m)%N by rewrite /m -index_cent1.\n  rewrite prime_decompE; case Dpr: (primes _) p_natC => [|p []] // _.\n    by exists 2%N => //; rewrite big_nil; exists 0.\n  rewrite big_seq1; exists p; last by exists (logn p m).\n  by have:= mem_primes p m; rewrite Dpr mem_head => /esym/and3P[].\nhave{simpleG} [ntG minG] := simpleP _ simpleG.\npose p_dv1 i := (p %| 'chi[G]_i 1%g)%C.\nhave p_dvd_supp_g i: ~~ p_dv1 i && (i != 0) -> 'chi_i g = 0.\n  rewrite /p_dv1 irr1_degree dvdC_nat -prime_coprime // => /andP[co_p_i1 nz_i].\n  have fful_i: cfker 'chi_i = [1].\n    have /minG[//|/eqP] := cfker_normal 'chi_i.\n    by rewrite eqEsubset subGcfker (negPf nz_i) andbF.\n  have trivZ: 'Z(G) = [1] by have /minG[|/center_idP/idPn] := center_normal G.\n  have trivZi: ('Z('chi_i))%CF = [1].\n    apply/trivgP; rewrite -quotient_sub1 ?norms1 //= -fful_i cfcenter_eq_center.\n    rewrite fful_i subG1 -(isog_eq1 (isog_center (quotient1_isog G))) /=.\n    by rewrite trivZ.\n  rewrite coprime_degree_support_cfcenter ?trivZi ?inE //.\n  by rewrite -/m Dm irr1_degree natrK coprime_sym coprimeXl.\npose alpha := \\sum_(i | p_dv1 i && (i != 0)) 'chi_i 1%g / p%:R * 'chi_i g.\nhave nz_p: p%:R != 0 :> algC by rewrite pnatr_eq0 -lt0n prime_gt0.\nhave Dalpha: alpha = - 1 / p%:R.\n  apply/(canRL (mulfK nz_p))/eqP; rewrite -addr_eq0 addrC; apply/eqP/esym.\n  transitivity (cfReg G g); first by rewrite cfRegE (negPf nt_g).\n  rewrite cfReg_sum sum_cfunE (bigD1 0) //= irr0 !cfunE cfun11 cfun1E Gg.\n  rewrite mulr1; congr (1 + _); rewrite (bigID p_dv1) /= addrC big_andbC.\n  rewrite big1 => [|i /p_dvd_supp_g chig0]; last by rewrite cfunE chig0 mulr0.\n  rewrite add0r big_andbC mulr_suml; apply: eq_bigr => i _.\n  by rewrite mulrAC divfK // cfunE.\nsuffices: (p %| 1)%C by rewrite (dvdC_nat p 1) dvdn1 -(subnKC (prime_gt1 p_pr)).\nrewrite unfold_in (negPf nz_p).\nrewrite Cint_rat_Aint ?rpred_div ?rpred1 ?rpred_nat //.\nrewrite -rpredN // -mulNr -Dalpha rpred_sum // => i /andP[/dvdCP[c Zc ->] _].\nby rewrite mulfK // rpredM ?Aint_irr ?Aint_Cint.\nQed.",
    "Theorem Burnside_p_a_q_b gT (G : {group gT}) :\n  (size (primes #|G|) <= 2)%N -> solvable G.\nProof.\nmove: {2}_.+1 (ltnSn #|G|) => n; elim: n => // n IHn in gT G *.\nrewrite ltnS => leGn piGle2; have [simpleG | ] := boolP (simple G); last first.\n  rewrite negb_forall_in => /exists_inP[N sNG]; rewrite eq_sym.\n  have [->|] := eqVneq N G.\n    rewrite groupP /= genGid normG andbT eqb_id negbK => /eqP->.\n    exact: solvable1.\n  rewrite [N == G]eqEproper sNG eqbF_neg !negbK => ltNG /and3P[grN].\n  case/isgroupP: grN => {}N -> in sNG ltNG *; rewrite /= genGid => ntN nNG.\n  have nsNG: N <| G by apply/andP.\n  have dv_le_pi m: (m %| #|G| -> size (primes m) <= 2)%N.\n    move=> m_dv_G; apply: leq_trans piGle2.\n    by rewrite uniq_leq_size ?primes_uniq //; apply: pi_of_dvd.\n  rewrite (series_sol nsNG) !IHn ?dv_le_pi ?cardSg ?dvdn_quotient //.\n    by apply: leq_trans leGn; apply: ltn_quotient.\n  by apply: leq_trans leGn; apply: proper_card.\nhave [->|[p p_pr p_dv_G]] := trivgVpdiv G; first exact: solvable1.\nhave piGp: p \\in \\pi(G) by rewrite mem_primes p_pr cardG_gt0.\nhave [P sylP] := Sylow_exists p G; have [sPG pP p'GP] := and3P sylP.\nhave ntP: P :!=: 1%g by rewrite -rank_gt0 (rank_Sylow sylP) p_rank_gt0.\nhave /trivgPn[g /setIP[Pg cPg] nt_g]: 'Z(P) != 1%g.\n  by rewrite center_nil_eq1 // (pgroup_nil pP).\napply: abelian_sol; have: (size (primes #|g ^: G|) <= 1)%N.\n  rewrite -ltnS -[_.+1]/(size (p :: _)) (leq_trans _ piGle2) //.\n  rewrite -index_cent1 uniq_leq_size // => [/= | q].\n    rewrite primes_uniq -p'natEpi ?(pnat_dvd _ p'GP) ?indexgS //.\n    by rewrite subsetI sPG sub_cent1.\n  by rewrite inE => /predU1P[-> // |]; apply: pi_of_dvd; rewrite ?dvdn_indexg.\nrewrite leqNgt; apply: contraR => /primes_class_simple_gt1-> //.\nby rewrite !inE classG_eq1 nt_g mem_classes // (subsetP sPG).\nQed.",
    "Theorem dvd_irr1_cardG gT (G : {group gT}) i : ('chi[G]_i 1%g %| #|G|)%C.\nProof.\nrewrite unfold_in -if_neg irr1_neq0 Cint_rat_Aint //=.\n  by rewrite rpred_div ?rpred_nat // rpred_nat_num ?Cnat_irr1.\nrewrite -[n in n / _]/(_ *+ true) -(eqxx i) -mulr_natr.\nrewrite -first_orthogonality_relation mulVKf ?neq0CG //.\nrewrite sum_by_classes => [|x y Gx Gy]; rewrite -?conjVg ?cfunJ //.\nrewrite mulr_suml rpred_sum // => K /repr_classesP[Gx {1}->].\nby rewrite !mulrA mulrAC rpredM ?Aint_irr ?Aint_class_div_irr1.\nQed.",
    "Theorem dvd_irr1_index_center gT (G : {group gT}) i :\n  ('chi[G]_i 1%g %| #|G : 'Z('chi_i)%CF|)%C.\nProof.\nwithout loss fful: gT G i / cfaithful 'chi_i.\n  rewrite -{2}[i](quo_IirrK _ (subxx _)) 1?mod_IirrE ?cfModE ?cfker_normal //.\n  rewrite morph1; set i1 := quo_Iirr _ i => /(_ _ _ i1) IH.\n  have fful_i1: cfaithful 'chi_i1.\n    by rewrite quo_IirrE ?cfker_normal ?cfaithful_quo.\n  have:= IH fful_i1; rewrite cfcenter_fful_irr // -cfcenter_eq_center.\n  rewrite index_quotient_eq ?cfcenter_sub ?cfker_norm //.\n  by rewrite setIC subIset // normal_sub ?cfker_center_normal.\nhave [lambda lin_lambda Dlambda] := cfcenter_Res 'chi_i.\nhave DchiZ: {in G & 'Z(G), forall x y, 'chi_i (x * y)%g = 'chi_i x * lambda y}.\n  rewrite -(cfcenter_fful_irr fful) => x y Gx Zy.\n  apply: (mulfI (irr1_neq0 i)); rewrite mulrCA.\n  transitivity ('chi_i x * ('chi_i 1%g *: lambda) y); last by rewrite !cfunE.\n  rewrite -Dlambda cfResE ?cfcenter_sub //.\n  rewrite -irrRepr cfcenter_repr !cfunE in Zy *.\n  case/setIdP: Zy => Gy /is_scalar_mxP[e De].\n  rewrite repr_mx1 group1 (groupM Gx Gy) (repr_mxM _ Gx Gy) Gx Gy De.\n  by rewrite mul_mx_scalar mxtraceZ mulrCA mulrA mulrC -mxtraceZ scalemx1.\nhave inj_lambda: {in 'Z(G) &, injective lambda}.\n  rewrite -(cfcenter_fful_irr fful) => x y Zx Zy eq_xy.\n  apply/eqP; rewrite eq_mulVg1 -in_set1 (subsetP fful) // cfkerEirr inE.\n  apply/eqP; transitivity ('Res['Z('chi_i)%CF] 'chi_i (x^-1 * y)%g).\n    by rewrite cfResE ?cfcenter_sub // groupM ?groupV.\n  rewrite Dlambda !cfunE lin_charM ?groupV // -eq_xy -lin_charM ?groupV //.\n  by rewrite mulrC mulVg lin_char1 ?mul1r.\nrewrite unfold_in -if_neg irr1_neq0 Cint_rat_Aint //.\n  by rewrite rpred_div ?rpred_nat // rpred_nat_num ?Cnat_irr1.\nrewrite (cfcenter_fful_irr fful) nCdivE natf_indexg ?center_sub //=.\nhave ->: #|G|%:R = \\sum_(x in G) 'chi_i x * 'chi_i (x^-1)%g.\n  rewrite -[_%:R]mulr1; apply: canLR (mulVKf (neq0CG G)) _.\n  by rewrite first_orthogonality_relation eqxx.\nrewrite (big_setID [set x | 'chi_i x == 0]) /= -setIdE.\nrewrite big1 ?add0r => [| x /setIdP[_ /eqP->]]; last by rewrite mul0r.\npose h x := (x ^: G * 'Z(G))%g; rewrite (partition_big_imset h).\nrewrite !mulr_suml rpred_sum //= => _ /imsetP[x /setDP[Gx nz_chi_x] ->].\nhave: #|x ^: G|%:R * ('chi_i x * 'chi_i x^-1%g) / 'chi_i 1%g \\in Aint.\n  by rewrite !mulrA mulrAC rpredM ?Aint_irr ?Aint_class_div_irr1.\ncongr 2 (_ * _ \\in Aint); apply: canRL (mulfK (neq0CG _)) _.\nrewrite inE in nz_chi_x.\ntransitivity ('chi_i x * 'chi_i (x^-1)%g *+ #|h x|); last first.\n  rewrite -sumr_const.\n  apply: eq_big => [y | _ /mulsgP[_ z /imsetP[u Gu ->] Zz] ->].\n    rewrite !inE -andbA; apply/idP/and3P=> [|[_ _ /eqP <-]]; last first.\n      by rewrite -{1}[y]mulg1 mem_mulg ?class_refl.\n    case/mulsgP=> _ z /imsetP[u Gu ->] Zz ->; have /centerP[Gz cGz] := Zz.\n    rewrite groupM 1?DchiZ ?groupJ ?cfunJ //; split=> //.\n      by rewrite mulf_neq0 // lin_char_neq0 /= ?cfcenter_fful_irr.\n    rewrite -[z](mulKg u) -cGz // -conjMg /h classGidl {u Gu}//.\n    apply/eqP/setP=> w; apply/mulsgP/mulsgP=> [][_ z1 /imsetP[v Gv ->] Zz1 ->].\n      exists (x ^ v)%g (z * z1)%g; rewrite ?imset_f ?groupM //.\n      by rewrite conjMg -mulgA /(z ^ v)%g cGz // mulKg.\n    exists ((x * z) ^ v)%g (z^-1 * z1)%g; rewrite ?imset_f ?groupM ?groupV //.\n    by rewrite conjMg -mulgA /(z ^ v)%g cGz // mulKg mulKVg.\n  rewrite !irr_inv DchiZ ?groupJ ?cfunJ // rmorphM mulrACA -!normCK -exprMn.\n  by rewrite (normC_lin_char lin_lambda) ?mulr1 //= cfcenter_fful_irr.\nrewrite mulrAC -natrM mulr_natl; congr (_ *+ _).\nsymmetry; rewrite /h /mulg /= /set_mulg [in _ @2: (_, _)]unlock cardsE.\nrewrite -cardX card_in_image // => [] [y1 z1] [y2 z2] /=.\nmove=> /andP[/=/imsetP[u1 Gu1 ->] Zz1] /andP[/=/imsetP[u2 Gu2 ->] Zz2] {y1 y2}.\nmove=> eq12; have /eqP := congr1 'chi_i eq12.\nrewrite !(cfunJ, DchiZ) ?groupJ // (can_eq (mulKf nz_chi_x)).\nrewrite (inj_in_eq inj_lambda) // => /eqP eq_z12; rewrite eq_z12 in eq12 *.\nby rewrite (mulIg _ _ _ eq12).\nQed.",
    "Theorem faithful_degree_p_part gT (p : nat) (G P : {group gT}) i :\n    cfaithful 'chi[G]_i -> p.-nat (Num.truncn ('chi_i 1%g)) ->\n    p.-Sylow(G) P -> abelian P ->\n  'chi_i 1%g = (#|G : 'Z(G)|`_p)%:R.\nProof.\nhave [p_pr | pr'p] := boolP (prime p); last first.\n  have p'n n: (n > 0)%N -> p^'.-nat n.\n    by move/p'natEpi->; rewrite mem_primes (negPf pr'p).\n  rewrite irr1_degree natrK => _ /pnat_1-> => [_ _|].\n    by rewrite part_p'nat ?p'n.\n  by rewrite p'n ?irr_degree_gt0.\nmove=> fful_i /p_natP[a Dchi1] sylP cPP.\nhave Dchi1C: 'chi_i 1%g = (p ^ a)%:R by rewrite -Dchi1 irr1_degree natrK.\nhave pa_dv_ZiG: (p ^ a %| #|G : 'Z(G)|)%N.\n  rewrite -dvdC_nat -[pa in (pa %| _)%C]Dchi1C -(cfcenter_fful_irr fful_i).\n  exact: dvd_irr1_index_center.\nhave [sPG pP p'PiG] := and3P sylP.\nhave ZchiP: 'Res[P] 'chi_i \\in 'CF(P, P :&: 'Z(G)).\n  apply/cfun_onP=> x /[1!inE]; have [Px | /cfun0->//] := boolP (x \\in P).\n  rewrite /= -(cfcenter_fful_irr fful_i) cfResE //.\n  apply: coprime_degree_support_cfcenter.\n  rewrite Dchi1 coprimeXl // prime_coprime // -p'natE //.\n  apply: pnat_dvd p'PiG; rewrite -index_cent1 indexgS // subsetI sPG.\n  by rewrite sub_cent1 (subsetP cPP).\nhave /andP[_ nZG] := center_normal G; have nZP := subset_trans sPG nZG.\napply/eqP; rewrite Dchi1C eqr_nat eqn_dvd -{1}(pfactorK a p_pr) -p_part.\nrewrite partn_dvd //= -dvdC_nat -[pa in (_ %| pa)%C]Dchi1C -card_quotient //=.\nrewrite -(card_Hall (quotient_pHall nZP sylP)) card_quotient // -indexgI.\nrewrite -(cfResE _ sPG) // index_support_dvd_degree ?subsetIl ?cPP ?orbT //.\nby rewrite cfRes_char ?irr_char.\nQed.",
    "Theorem nonlinear_irr_vanish gT (G : {group gT}) i :\n  'chi[G]_i 1%g > 1 -> exists2 x, x \\in G & 'chi_i x = 0.\nProof.\nmove=> chi1gt1; apply/exists_eq_inP; apply: contraFT (lt_geF chi1gt1).\nmove=> /exists_inPn-nz_chi.\nrewrite -(norm_natr (Cnat_irr1 i)) -(@expr_le1 _ 2)//.\nrewrite -(lerD2r (#|G|%:R * '['chi_i])) {1}cfnorm_irr mulr1.\nrewrite (cfnormE (cfun_onG _)) mulVKf ?neq0CG // (big_setD1 1%g) //=.\nrewrite addrCA lerD2l (cardsD1 1%g) group1 mulrS lerD2l.\nrewrite -sumr_const !(partition_big_imset (fun s => <[s]>)) /=.\napply: ler_sum => _ /imsetP[g /setD1P[ntg Gg] ->].\nhave sgG: <[g]> \\subset G by rewrite cycle_subG.\npose S := [pred s | generator <[g]> s]; pose chi := 'Res[<[g]>] 'chi_i.\nhave defS: [pred s in G^# | <[s]> == <[g]>] =i S.\n  move=> s; rewrite inE /= eq_sym andb_idl // !inE -cycle_eq1 -cycle_subG.\n  by move/eqP <-; rewrite cycle_eq1 ntg.\nhave resS: {in S, 'chi_i =1 chi}.\n  by move=> s /cycle_generator=> g_s; rewrite cfResE ?cycle_subG.\nrewrite !(eq_bigl _ _ defS) sumr_const.\nrewrite (eq_bigr (fun s => `|chi s| ^+ 2)) => [|s /resS-> //].\napply: sum_norm2_char_generators => [|s Ss].\n  by rewrite cfRes_char ?irr_char.\nby rewrite -resS // nz_chi ?(subsetP sgG) ?cycle_generator.\nQed.",
    "Theorem Clifford_component_basis M : mxsimple rH M ->\n  {t : nat & {x_ : sH -> 'I_t -> gT |\n    forall W, let sW := (\\sum_j M *m rG (x_ W j))%MS in\n      [/\\ forall j, x_ W j \\in G, (sW :=: W)%MS & mxdirect sW]}}.\nProof.\nmove=> simM; pose t := (n %/ #|sH| %/ \\rank M)%N; exists t.\nhave [X /subsetP sXG [defX1 dxX1]] := Clifford_basis simM.\npose sMv (W : sH) x := (M *m rG x <= W)%MS; pose Xv := [pred x in X | sMv _ x].\nhave sXvG W: {subset Xv W <= G} by move=> x /andP[/sXG].\nhave defW W: (\\sum_(x in Xv W) M *m rG x :=: W)%MS.\n  apply/eqmxP; rewrite -(geq_leqif (mxrank_leqif_eq _)); last first.\n    by apply/sumsmx_subP=> x /andP[].\n  rewrite -(leq_add2r (\\sum_(W' | W' != W) \\rank W')) -((bigD1 W) predT) //=.\n  rewrite -(mxdirectP (Socle_direct sH)) /= -/(Socle _) Clifford_Socle1 -defX1.\n  apply: leq_trans (mxrankS _) (mxrank_sum_leqif _).1 => /=.\n  rewrite (bigID (sMv W))%MS addsmxS //=.\n  apply/sumsmx_subP=> x /andP[Xx notW_Mx]; have Gx := sXG x Xx.\n  have simMx := Clifford_simple simM Gx.\n  pose Wx := PackSocle (component_socle sH simMx).\n  have sMxWx: (M *m rG x <= Wx)%MS by rewrite PackSocleK component_mx_id.\n  by rewrite (sumsmx_sup Wx) //; apply: contra notW_Mx => /eqP <-.\nhave dxXv W: mxdirect (\\sum_(x in Xv W) M *m rG x).\n  move: dxX1; rewrite !mxdirectE /= !(bigID (sMv W) [in X]) /=.\n  by rewrite -mxdirectE mxdirect_addsE /= => /andP[].\nhave def_t W: #|Xv W| = t.\n  rewrite /t -{1}(Clifford_rank_components W) mulKn 1?(cardD1 W) //.\n  rewrite -defW (mxdirectP (dxXv W)) /= (eq_bigr (fun _ => \\rank M)) => [|x].\n    rewrite sum_nat_const mulnK //; last by rewrite lt0n mxrank_eq0; case simM.\n  by move/sXvG=> Gx; rewrite mxrankMfree // row_free_unit repr_mx_unit.\nexists (fun W i => enum_val (cast_ord (esym (def_t W)) i)) => W.\ncase: {def_t}t / (def_t W) => sW.\ncase: (pickP (Xv W)) => [x0 XvWx0 | XvW0]; last first.\n  by case/negP: (nz_socle W); rewrite -submx0 -defW big_pred0.\nhave{x0 XvWx0} reXv := reindex _ (enum_val_bij_in XvWx0).\nhave def_sW: (sW :=: W)%MS.\n  apply: eqmx_trans (defW W); apply/eqmxP; apply/genmxP; congr <<_>>%MS.\n  rewrite reXv /=; apply: eq_big => [j | j _]; first by have:= enum_valP j.\n  by rewrite cast_ord_id.\nsplit=> // [j|]; first by rewrite (sXvG W) ?enum_valP.\napply/mxdirectP; rewrite def_sW -(defW W) /= (mxdirectP (dxXv W)) /= reXv /=.\nby apply: eq_big => [j | j _]; [move: (enum_valP j) | rewrite cast_ord_id].\nQed.",
    "Theorem mx_Schreier U :\n    mx_subseries U -> path ltmx 0 U ->\n  classically (exists V, [/\\ mx_series V, last 0 V :=: 1%:M & subseq U V])%MS.\nProof.\nmove: U => U0; set U := {1 2}U0; have: subseq U0 U := subseq_refl U.\npose n' := n.+1; have: n < size U + n' by rewrite leq_addl.\nelim: n' U => [|n' IH_U] U ltUn' sU0U modU incU [] // noV.\n  rewrite addn0 ltnNge in ltUn'; case/negP: ltUn'.\n  by rewrite (leq_trans (max_size_mx_series incU)) ?rank_leq_row.\napply: (noV); exists U; split => //; first split=> // i lt_iU; last first.\n  apply/eqmxP; apply: contraT => neU1.\n  apply: {IH_U}(IH_U (rcons U 1%:M)) noV.\n  - by rewrite size_rcons addSnnS.\n  - by rewrite (subseq_trans sU0U) ?subseq_rcons.\n  - by rewrite /mx_subseries all_rcons mxmodule1.\n  by rewrite rcons_path ltmxEneq neU1 submx1 !andbT.\nset U'i := _`_i; set Ui := _`_i; have defU := cat_take_drop i U.\nhave defU'i: U'i = last 0 (take i U).\n  rewrite (last_nth 0) /U'i -{1}defU -cat_cons nth_cat /=.\n  by rewrite size_take lt_iU leqnn.\nmove: incU; rewrite -defU cat_path (drop_nth 0) //= -/Ui -defU'i.\nset U' := take i U; set U'' := drop _ U; case/and3P=> incU' ltUi incU''.\nsplit=> // W [modW ltUW ltWV]; case: notF.\napply: {IH_U}(IH_U (U' ++ W :: Ui :: U'')) noV; last 2 first.\n- by rewrite /mx_subseries -drop_nth // all_cat /= modW -all_cat defU.\n- by rewrite cat_path /= -defU'i; apply/and4P.\n- by rewrite -drop_nth // size_cat /= addnS -size_cat defU addSnnS.\nby rewrite (subseq_trans sU0U) // -defU cat_subseq // -drop_nth ?subseq_cons.\nQed.",
    "Theorem cfun_irr_sum phi : {a | phi = \\sum_i a i *: 'chi[G]_i}.\nProof.\nrewrite (coord_basis irr_basis (memvf phi)) -eq_sum_nth_irr.\nby exists ((coord (irr G))^~ phi).\nQed.",
    "Theorem generalized_orthogonality_relation y (i j : Iirr G) :\n  #|G|%:R^-1 * (\\sum_(x in G) 'chi_i (x * y)%g * 'chi_j x^-1%g)\n    = (i == j)%:R * ('chi_i y / 'chi_i 1%g).\nProof.\npose W := @socle_of_Iirr _ G; pose e k := Wedderburn_id (W k).\npose aG := regular_repr algC G.\nhave [Gy | notGy] := boolP (y \\in G); last first.\n  rewrite cfun0 // mul0r big1 ?mulr0 // => x Gx.\n  by rewrite cfun0 ?groupMl ?mul0r.\ntransitivity (('chi_i).[e j *m aG y]%CF / 'chi_j 1%g).\n  rewrite [e j]Wedderburn_id_expansion -scalemxAl xcfunZr -mulrA; congr (_ * _).\n  rewrite mulmx_suml raddf_sum big_distrl; apply: eq_bigr => x Gx /=.\n  rewrite -scalemxAl xcfunZr -repr_mxM // xcfunG ?groupM // mulrAC mulrC.\n  by congr (_ * _); rewrite mulrC mulKf ?irr1_neq0.\nrewrite mulr_natl mulrb; have [<-{j} | neq_ij] := eqVneq.\n  by congr (_ / _); rewrite xcfun_mul_id ?envelop_mx_id ?xcfunG.\nrewrite (xcfun_annihilate neq_ij) ?mul0r //.\ncase/andP: (Wedderburn_ideal (W j)) => _; apply: submx_trans.\nby rewrite mem_mulsmx ?Wedderburn_id_mem ?envelop_mx_id.\nQed.",
    "Theorem second_orthogonality_relation x y :\n    y \\in G ->\n  \\sum_i 'chi[G]_i x * ('chi_i y)^* = #|'C_G[x]|%:R *+ (x \\in y ^: G).\nProof.\nmove=> Gy; pose i_x := iC (x ^: G); pose i_y := iC (y ^: G).\nhave [Gx | notGx] := boolP (x \\in G); last first.\n  rewrite (contraNF (subsetP _ x) notGx) ?class_subG ?big1 // => i _.\n  by rewrite cfun0 ?mul0r.\ntransitivity ((#|'C_G[repr (y ^: G)]|%:R *: (X' *m X)) i_y i_x).\n  rewrite scalemxAl !mxE; apply: eq_bigr => k _; rewrite !mxE mulrC -!mulrA.\n  by rewrite !class_IirrK ?mem_classes // !cfun_repr mulVKf ?neq0CG.\nrewrite mulmx1C // !mxE -!divg_index !(index_cent1, =^~ indexgI).\nrewrite (class_eqP (mem_repr y _)) ?class_refl // mulr_natr.\nrewrite (can_in_eq class_IirrK) ?mem_classes //.\nhave [-> | not_yGx] := eqVneq; first by rewrite class_refl.\nby rewrite [x \\in _](contraNF _ not_yGx) // => /class_eqP->.\nQed.",
    "Theorem extraspecial_repr_structure_pchar (sS : irrType F S) :\n  [/\\ #|linear_irr sS| = (p ^ n.*2)%N,\n      exists iphi : 'I_p.-1 -> sS, let phi i := irr_repr (iphi i) in\n        [/\\ injective iphi,\n            codom iphi =i ~: linear_irr sS,\n            forall i, mx_faithful (phi i),\n            forall z, z \\in 'Z(S)^# ->\n              exists2 w, primitive_root_of_unity p w\n                       & forall i, phi i z = (w ^+ i.+1)%:M\n          & forall i, irr_degree (iphi i) = (p ^ n)%N]\n    & #|sS| = (p ^ n.*2 + p.-1)%N].\nProof.\nhave [[defPhiS defS'] prZ] := esS; set linS := linear_irr sS.\nhave nb_lin: #|linS| = (p ^ n.*2)%N.\n  rewrite card_linear_irr // -divgS ?der_sub //=.\n  by rewrite oSpn defS' oZp expnS mulKn.\nhave nb_irr: #|sS| = (p ^ n.*2 + p.-1)%N.\n  pose Zcl := classes S ::&: 'Z(S).\n  have cardZcl: #|Zcl| = p.\n    transitivity #|[set [set z] | z in 'Z(S)]|; last first.\n      by rewrite card_imset //; apply: set1_inj.\n    apply: eq_card => zS; apply/setIdP/imsetP=> [[] | [z]].\n      case/imsetP=> z Sz ->{zS} szSZ.\n      have Zz: z \\in 'Z(S) by rewrite (subsetP szSZ) ?class_refl.\n      exists z => //; rewrite inE Sz in Zz.\n      apply/eqP; rewrite eq_sym eqEcard sub1set class_refl cards1.\n      by rewrite -index_cent1 (setIidPl _) ?indexgg // sub_cent1.\n    case/setIP=> Sz cSz ->{zS}; rewrite sub1set inE Sz; split=> //.\n    apply/imsetP; exists z; rewrite //.\n    apply/eqP; rewrite eqEcard sub1set class_refl cards1.\n    by rewrite -index_cent1 (setIidPl _) ?indexgg // sub_cent1.\n  move/eqP: (class_formula S); rewrite (bigID [in Zcl]) /=.\n  rewrite (eq_bigr (fun _ => 1)) => [|zS]; last first.\n    case/andP=> _ /setIdP[/imsetP[z Sz ->{zS}] /subsetIP[_ cSzS]].\n    rewrite (setIidPl _) ?indexgg // sub_cent1 (subsetP cSzS) //.\n    exact: mem_repr (class_refl S z).\n  rewrite sum1dep_card setIdE (setIidPr _) 1?cardsE ?cardZcl; last first.\n    by apply/subsetP=> zS /[!inE] /andP[].\n  have pn_gt0: p ^ n.*2 > 0 by rewrite expn_gt0 p_gt0.\n  rewrite card_irr_pchar // oSpn expnS -(prednK pn_gt0) mulnS eqn_add2l.\n  rewrite (eq_bigr (fun _ => p)) => [|xS]; last first.\n    case/andP=> SxS; rewrite inE SxS; case/imsetP: SxS => x Sx ->{xS} notZxS.\n    have [y Sy ->] := repr_class S x; apply: p_maximal_index => //.\n    apply: cent1_extraspecial_maximal => //; first exact: groupJ.\n    apply: contra notZxS => Zxy; rewrite -{1}(lcoset_id Sy) class_lcoset.\n    rewrite ((_ ^: _ =P [set x ^ y])%g _) ?sub1set // eq_sym eqEcard.\n    rewrite sub1set class_refl cards1 -index_cent1 (setIidPl _) ?indexgg //.\n    by rewrite sub_cent1; apply: subsetP Zxy; apply: subsetIr.\n  rewrite sum_nat_cond_const mulnC eqn_pmul2l //; move/eqP <-.\n  rewrite addSnnS prednK // -cardZcl -[card _](cardsID Zcl) /= addnC.\n  by congr (_ + _)%N; apply: eq_card => t; rewrite !inE andbC // andbAC andbb.\nhave fful_nlin i: i \\in ~: linS -> mx_faithful (irr_repr i).\n  rewrite !inE => nlin_phi.\n  apply/trivgP; apply: (TI_center_nil (pgroup_nil pS) (rker_normal _)).\n  rewrite setIC; apply: (prime_TIg prZ); rewrite /= -defS' der1_sub_rker //.\n  exact: socle_irr.\nhave [i0 nlin_i0]: exists i0, i0 \\in ~: linS.\n  by apply/card_gt0P; rewrite cardsCs setCK nb_irr nb_lin addKn -subn1 subn_gt0.\nhave [z defZ]: exists z, 'Z(S) = <[z]> by apply/cyclicP; rewrite prime_cyclic.\nhave Zz: z \\in 'Z(S) by [rewrite defZ cycle_id]; have [Sz cSz] := setIP Zz.\nhave ozp: #[z] = p by rewrite -oZp defZ.\nhave ntz: z != 1%g by rewrite -order_gt1 ozp.\npose phi := irr_repr i0; have irr_phi: mx_irreducible phi := socle_irr i0.\npose w := irr_mode i0 z.\nhave phi_z: phi z = w%:M by rewrite /phi irr_center_scalar.\nhave phi_ze e: phi (z ^+ e)%g = (w ^+ e)%:M.\n  by rewrite /phi irr_center_scalar ?groupX ?irr_modeX.\nhave wp1: w ^+ p = 1 by rewrite -irr_modeX // -ozp expg_order irr_mode1.\nhave injw: {in 'Z(S) &, injective (irr_mode i0)}.\n  move=> x y Zx Zy /= eq_xy; have [[Sx _] [Sy _]] := (setIP Zx, setIP Zy).\n  apply: mx_faithful_inj (fful_nlin _ nlin_i0) _ _ Sx Sy _.\n  by rewrite !{1}irr_center_scalar ?eq_xy; first by split.\nhave prim_w e: 0 < e < p -> p.-primitive_root (w ^+ e).\n  case/andP=> e_gt0 lt_e_p; apply/andP; split=> //.\n  apply/eqfunP=> -[d ltdp] /=; rewrite unity_rootE -exprM.\n  rewrite -(irr_mode1 i0) -irr_modeX // (inj_in_eq injw) ?groupX ?group1 //.\n  rewrite -order_dvdn ozp Euclid_dvdM // gtnNdvd //=.\n  move: ltdp; rewrite leq_eqVlt.\n  by case: eqP => [-> _ | _ ltd1p]; rewrite (dvdnn, gtnNdvd).\nhave /cyclicP[a defAutZ]: cyclic (Aut 'Z(S)) by rewrite Aut_prime_cyclic ?ozp.\nhave phi_unitP (i : 'I_p.-1): (i.+1%:R : 'Z_#[z]) \\in GRing.unit.\n  by rewrite unitZpE ?order_gt1 // ozp prime_coprime // -lt0n !modIp'.\npose ephi i := invm (injm_Zpm a) (Zp_unitm (FinRing.Unit (phi_unitP i))).\npose j : 'Z_#[z] := val (invm (injm_Zp_unitm z) a).\nhave co_j_p: coprime j p.\n  rewrite coprime_sym /j; case: (invm _ a) => /=.\n  by rewrite ozp /GRing.unit /= Zp_cast.\nhave [alpha Aut_alpha alphaZ] := center_aut_extraspecial pS esS co_j_p.\nhave alpha_i_z i: ((alpha ^+ ephi i) z = z ^+ i.+1)%g.\n  transitivity ((a ^+ ephi i) z)%g.\n    elim: (ephi i : nat) => // e IHe; rewrite !expgS !permM alphaZ //.\n    have Aut_a: a \\in Aut 'Z(S) by rewrite defAutZ cycle_id.\n    rewrite -{2}[a](invmK (injm_Zp_unitm z)); last by rewrite im_Zp_unitm -defZ.\n    rewrite /= autE ?cycle_id // -/j /= /cyclem.\n    rewrite -(autmE (groupX _ Aut_a)) -(autmE (groupX _ Aut_alpha)).\n    by rewrite !morphX //= !autmE IHe.\n  rewrite [(a ^+ _)%g](invmK (injm_Zpm a)) /=; last first.\n    by rewrite im_Zpm -defAutZ defZ Aut_aut.\n  by rewrite autE ?cycle_id //= val_Zp_nat ozp ?modIp'.\nhave rphiP i: S :==: autm (groupX (ephi i) Aut_alpha) @* S by rewrite im_autm.\npose rphi i := morphim_repr (eqg_repr phi (rphiP i)) (subxx S).\nhave rphi_irr i: mx_irreducible (rphi i) by apply/morphim_mx_irr/eqg_mx_irr.\nhave rphi_fful i: mx_faithful (rphi i).\n  rewrite /mx_faithful rker_morphim rker_eqg.\n  by rewrite (trivgP (fful_nlin _ nlin_i0)) morphpreIdom; apply: injm_autm.\nhave rphi_z i: rphi i z = (w ^+ i.+1)%:M.\n  by rewrite /rphi [phi]lock /= /morphim_mx autmE alpha_i_z -lock phi_ze.\npose iphi i := irr_comp sS (rphi i); pose phi_ i := irr_repr (iphi i).\nhave{} phi_ze i e: phi_ i (z ^+ e)%g = (w ^+ (e * i.+1)%N)%:M.\n  rewrite /phi_ !{1}irr_center_scalar ?groupX ?irr_modeX //.\n  suffices ->: irr_mode (iphi i) z = w ^+ i.+1 by rewrite mulnC exprM.\n  have:= mx_rsim_sym (rsim_irr_comp_pchar sS F'S (rphi_irr i)).\n  case/mx_rsim_def=> B [B' _ homB]; rewrite /irr_mode homB // rphi_z.\n  rewrite -{1}scalemx1 -scalemxAr -scalemxAl -{1}(repr_mx1 (rphi i)).\n  by rewrite -homB // repr_mx1 scalemx1 mxE.\nhave inj_iphi: injective iphi.\n  move=> i1 i2 eqi12; apply/eqP.\n  move/eqP: (congr1 (fun i => irr_mode i (z ^+ 1)) eqi12).\n  rewrite /irr_mode !{1}[irr_repr _ _]phi_ze !{1}mxE !mul1n.\n  by rewrite (eq_prim_root_expr (prim_w 1 p_gt1)) !modIp'.\nhave deg_phi i: irr_degree (iphi i) = irr_degree i0.\n  by case: (rsim_irr_comp_pchar sS F'S (rphi_irr i)).\nhave im_iphi: codom iphi =i ~: linS.\n  apply/subset_cardP; last apply/subsetP=> _ /codomP[i ->].\n    by rewrite card_image // card_ord cardsCs setCK nb_irr nb_lin addKn.\n  by rewrite !inE /= (deg_phi i) in nlin_i0 *.\nsplit=> //; exists iphi; rewrite -/phi_.\nsplit=> // [i | ze | i].\n- have sim_i := rsim_irr_comp_pchar sS F'S (rphi_irr i).\n  by rewrite -(mx_rsim_faithful sim_i) rphi_fful.\n- rewrite {1}defZ 2!inE andbC; case/andP.\n  case/cyclePmin=> e; rewrite ozp => lt_e_p ->{ze}.\n  case: (posnP e) => [-> | e_gt0 _]; first by rewrite eqxx.\n  exists (w ^+ e) => [|i]; first by rewrite prim_w ?e_gt0.\n  by rewrite phi_ze exprM.\nrewrite deg_phi {i}; set d := irr_degree i0.\napply/eqP; move/eqP: (sum_irr_degree_pchar sS F'S splitF).\nrewrite (bigID [in linS]) /= -/irr_degree.\nrewrite (eq_bigr (fun=> 1)) => [|i]; last by rewrite !inE; move/eqP->.\nrewrite sum1_card nb_lin.\nrewrite (eq_bigl [in codom iphi]) // => [|i]; last first.\n  by rewrite -in_setC -im_iphi.\nrewrite (eq_bigr (fun=> d ^ 2))%N => [|_ /codomP[i ->]]; last first.\n  by rewrite deg_phi.\nrewrite sum_nat_const card_image // card_ord oSpn (expnS p) -{3}[p]prednK //.\nrewrite mulSn eqn_add2l eqn_pmul2l; last by rewrite -ltnS prednK.\nby rewrite -muln2 expnM eqn_sqr.\nQed.",
    "Theorem finDomain_mulrC : @commutative R R *%R.\nProof.\nhave fieldR := finDomain_field.\nhave [p p_pr pcharRp]: exists2 p, prime p & p \\in [pchar R].\n  have [e /prod_prime_decomp->]: {e | (e > 0)%N & e%:R == 0 :> R}.\n    by exists #|[set: R]%G|; rewrite // -order_dvdn order_dvdG ?inE.\n  rewrite big_seq; elim/big_rec: _ => [|[p m] /= n]; first by rewrite oner_eq0.\n  case/mem_prime_decomp=> p_pr _ _ IHn.\n  elim: m => [|m IHm]; rewrite ?mul1n {IHn}// expnS -mulnA natrM.\n  by case/eqP/domR/orP=> //; exists p; last apply/andP.\npose Rp := pPrimeCharType pcharRp; pose L : {vspace Rp} := fullv.\npose G := [set: {unit R}]; pose ofG : {unit R} -> Rp := val.\npose projG (E : {vspace Rp}) := [preim ofG of E].\nhave inG t nzt: Sub t (finDomain_field nzt) \\in G by rewrite inE.\nhave card_projG E: #|projG E| = (p ^ \\dim E - 1)%N.\n  transitivity #|E|.-1; last by rewrite subn1 card_vspace card_Fp.\n  rewrite (cardD1 0) mem0v (card_preim val_inj) /=.\n  apply: eq_card => x; congr (_ && _); rewrite [LHS]codom_val.\n  by apply/idP/idP=> [/(memPn _ _)-> | /fieldR]; rewrite ?unitr0.\npose C u := 'C[ofG u]%AS; pose Q := 'C(L)%AS; pose q := (p ^ \\dim Q)%N.\nhave defC u: 'C[u] =i projG (C u).\n  by move=> v; rewrite cent1E !inE (sameP cent1vP eqP).\nhave defQ: 'Z(G) =i projG Q.\n  move=> u /[!inE].\n  apply/centP/centvP=> cGu v _; last exact/val_inj/cGu/memvf.\n  by have [-> | /inG/cGu[]] := eqVneq v 0; first by rewrite commr0.\nhave q_gt1: (1 < q)%N by rewrite (ltn_exp2l 0) ?prime_gt1 ?adim_gt0.\npose n := \\dim_Q L; have oG: #|G| = (q ^ n - 1)%N.\n  rewrite -expnM mulnC divnK ?skew_field_dimS ?subvf // -card_projG.\n  by apply: eq_card => u; rewrite !inE memvf.\nhave oZ: #|'Z(G)| = (q - 1)%N by rewrite -card_projG; apply: eq_card.\nsuffices n_le1: (n <= 1)%N.\n  move=> u v; apply/centvsP: (memvf (u : Rp)) (memvf (v : Rp)) => {u v}.\n  rewrite -(geq_leqif (dimv_leqif_sup (subvf Q))) -/L.\n  by rewrite leq_divLR ?mul1n ?skew_field_dimS ?subvf in n_le1.\nwithout loss n_gt1: / (1 < n)%N by rewrite ltnNge; apply: wlog_neg.\nhave [q_gt0 n_gt0] := (ltnW q_gt1, ltnW n_gt1).\nhave [z z_prim] := C_prim_root_exists n_gt0.\nhave zn1: z ^+ n = 1 by apply: prim_expr_order.\nhave /eqP-n1z: `|z| == 1 by rewrite -(pexpr_eq1 n_gt0) // -normrX zn1 normr1.\nsuffices /eqP/normCBeq[t n1t [Dq Dz]]:\n  `|q%:R - z : algC| == `|q%:R : algC| - `|z|.\n  suffices z1: z == 1 by rewrite leq_eqVlt -dvdn1 (prim_order_dvd z_prim) z1.\n  by rewrite Dz n1z mul1r -(eqr_pMn2r q_gt0) Dq normr_nat mulr_natl.\npose aq d : algC := (cyclotomic (z ^+ (n %/ d)) d).[q%:R].\nsuffices: `|aq n| <= (q - 1)%:R.\n  rewrite eq_le lerB_dist andbT n1z normr_nat natrB //; apply: le_trans.\n  rewrite {}/aq horner_prod divnn n_gt0 expr1 normr_prod.\n  rewrite (bigD1 (Ordinal n_gt1)) ?coprime1n //= !hornerE ler_peMr //.\n  elim/big_ind: _ => // [|d _]; first exact: mulr_ege1.\n  rewrite !hornerE; apply: le_trans (lerB_dist _ _).\n  by rewrite normr_nat normrX n1z expr1n lerBDl (leC_nat 2).\nhave Zaq d: d %| n -> aq d \\in Num.int.\n  move/(dvdn_prim_root z_prim)=> zd_prim.\n  rewrite rpred_horner ?rpred_nat //= -Cintr_Cyclotomic //.\n  by apply/polyOverP=> i; rewrite coef_map ?rpred_int.\nsuffices: (aq n %| (q - 1)%:R)%C.\n  rewrite {1}[aq n]intrEsign ?Zaq // -(rpredMsign _ (aq n < 0)%R).\n  rewrite dvdC_mul2l ?signr_eq0 //.\n  have /natrP[m ->]: `|aq n| \\in Num.nat by rewrite natr_norm_int ?Zaq.\n  by rewrite leC_nat dvdC_nat; apply: dvdn_leq; rewrite subn_gt0.\nhave prod_aq m: m %| n -> \\prod_(d < n.+1 | d %| m) aq d = (q ^ m - 1)%:R.\n  move=> m_dv_n; transitivity ('X^m - 1).[q%:R : algC]; last first.\n    by rewrite !hornerE -natrX natrB ?expn_gt0 ?prime_gt0.\n  rewrite (prod_cyclotomic (dvdn_prim_root z_prim m_dv_n)).\n  have def_divm: perm_eq (divisors m) [seq d <- index_iota 0 n.+1 | d %| m].\n    rewrite uniq_perm ?divisors_uniq ?filter_uniq ?iota_uniq // => d.\n    rewrite -dvdn_divisors ?(dvdn_gt0 n_gt0) // mem_filter mem_iota ltnS /=.\n    by apply/esym/andb_idr=> d_dv_m; rewrite dvdn_leq ?(dvdn_trans d_dv_m).\n  rewrite (perm_big _ def_divm) big_filter big_mkord horner_prod.\n  by apply: eq_bigr => d d_dv_m; rewrite -exprM muln_divA ?divnK.\nhave /rpredBl<-: (aq n %| #|G|%:R)%C.\n  rewrite oG -prod_aq // (bigD1 ord_max) //= dvdC_mulr //.\n  by apply: rpred_prod => d /andP[/Zaq].\nrewrite center_class_formula addrC oZ natrD addKr natr_sum /=.\napply: rpred_sum => _ /imsetP[u /setDP[_ Z'u] ->]; rewrite -/G /=.\nhave sQC: (Q <= C u)%VS by apply/subvP=> v /centvP-cLv; apply/cent1vP/cLv/memvf.\nhave{sQC} /dvdnP[m Dm]: \\dim Q %| \\dim (C u) by apply: skew_field_dimS.\nhave m_dv_n: m %| n by rewrite dvdn_divRL // -?Dm ?skew_field_dimS ?subvf.\nhave m_gt0: (0 < m)%N := dvdn_gt0 n_gt0 m_dv_n.\nhave{Dm} oCu: #|'C[u]| = (q ^ m - 1)%N.\n  by rewrite -expnM mulnC -Dm (eq_card (defC u)) card_projG.\nhave ->: #|u ^: G|%:R = \\prod_(d < n.+1 | d %| n) (aq d / aq d ^+ (d %| m)).\n  rewrite -index_cent1 natf_indexg ?subsetT //= setTI prodf_div prod_aq // -oG.\n  congr (_ / _); rewrite big_mkcond oCu -prod_aq //= big_mkcond /=.\n  by apply: eq_bigr => d _; case: ifP => [/dvdn_trans->| _]; rewrite ?if_same.\nrewrite (bigD1 ord_max) //= [n %| m](contraNF _ Z'u) => [|n_dv_m]; last first.\n  rewrite -sub_cent1 subEproper eq_sym eqEcard subsetT oG oCu leq_sub2r //.\n  by rewrite leq_exp2l // dvdn_leq.\nrewrite divr1 dvdC_mulr //; apply/rpred_prod => d /andP[/Zaq-Zaqd _].\nhave [-> | nz_aqd] := eqVneq (aq d) 0; first by rewrite mul0r /=.\nby rewrite -[aq d]expr1 -exprB ?leq_b1 ?unitfE ?rpredX.\nQed.",
    "Theorem Fundamental_Theorem_of_Algebraics :\n  {L : closedFieldType &\n     {conj : {rmorphism L -> L} | involutive conj & ~ conj =1 id}}.\nProof.\nhave maxn3 n1 n2 n3: {m | [/\\ n1 <= m, n2 <= m & n3 <= m]%N}.\n  by exists (maxn n1 (maxn n2 n3)); apply/and3P; rewrite -!geq_max.\nhave [C [/= QtoC algC]] := countable_algebraic_closure rat.\nexists C; have [i Di2] := GRing.imaginary_exists C.\npose Qfield := fieldExtType rat.\npose Cmorph (L : Qfield) := {rmorphism L -> C}.\nhave pcharQ (L : Qfield): [pchar L] =i pred0 := ftrans (pchar_lalg L) (pchar_num _).\nhave sepQ  (L : Qfield) (K E : {subfield L}): separable K E.\n  by apply/separableP=> u _; apply: pcharf0_separable.\npose genQfield z L := {LtoC : Cmorph L & {u | LtoC u = z & <<1; u>> = fullv}}.\nhave /all_tag[Q /all_tag[ofQ genQz]] z: {Qz : Qfield & genQfield z Qz}.\n  have [|p [/monic_neq0 nzp pz0 irr_p]] := minPoly_decidable_closure _ (algC z).\n    exact: rat_algebraic_decidable.\n  pose Qz := SubFieldExtType pz0 irr_p.\n  pose QzC : {rmorphism _ -> _} := @subfx_inj _ _ QtoC z p.\n  exists Qz, QzC, (subfx_root QtoC z p); first exact: subfx_inj_root.\n  apply/vspaceP=> u; rewrite memvf; apply/Fadjoin1_polyP.\n  by have [q] := subfxEroot pz0 nzp u; exists q.\nhave pQof z p: p^@ ^ ofQ z = p ^ QtoC.\n  by rewrite -map_poly_comp; apply: eq_map_poly => x; rewrite !fmorph_eq_rat.\nhave pQof2 z p u: ofQ z p^@.[u] = (p ^ QtoC).[ofQ z u].\n  by rewrite -horner_map pQof.\nhave PET_Qz z (E : {subfield Q z}): {u | <<1; u>> = E}.\n  exists (separable_generator 1 E).\n  by rewrite -eq_adjoin_separable_generator ?sub1v.\npose gen z x := exists q, x = (q ^ QtoC).[z].\nhave PET2 x y: {z | gen z x & gen z y}.\n  pose Gxy := (x, y) = let: (p, q, z) := _ in ((p ^ QtoC).[z], (q ^ QtoC).[z]).\n  suffices [[[p q] z] []]: {w | Gxy w} by exists z; [exists p | exists q].\n  apply/sig_eqW; have /integral_algebraic[px nz_px pxx0] := algC x.\n  have /integral_algebraic[py nz_py pyy0] := algC y.\n  have [n [[p Dx] [q Dy]]] := pchar0_PET nz_px pxx0 nz_py pyy0 (pchar_num _).\n  by exists (p, q, y *+ n - x); congr (_, _).\nhave gen_inQ z x: gen z x -> {u | ofQ z u = x}.\n  have [u Dz _] := genQz z => /sig_eqW[q ->].\n  by exists q^@.[u]; rewrite pQof2 Dz.\nhave gen_ofP z u v: reflect (gen (ofQ z u) (ofQ z v)) (v \\in <<1; u>>).\n  apply: (iffP Fadjoin1_polyP) => [[q ->]|]; first by rewrite pQof2; exists q.\n  by case=> q; rewrite -pQof2 => /fmorph_inj->; exists q.\nhave /all_tag[sQ genP] z: {s : pred C & forall x, reflect (gen z x) (x \\in s)}.\n  apply: all_tag (fun x => reflect (gen z x)) _ => x.\n  have [w /gen_inQ[u <-] /gen_inQ[v <-]] := PET2 z x.\n  by exists (v \\in <<1; u>>)%VS; apply: gen_ofP.\nhave sQtrans: transitive (fun x z => x \\in sQ z).\n  move=> x y z /genP[p ->] /genP[q ->]; apply/genP; exists (p \\Po q).\n  by rewrite map_comp_poly horner_comp.\nhave sQid z: z \\in sQ z by apply/genP; exists 'X; rewrite map_polyX hornerX.\nhave{gen_ofP} sQof2 z u v: (ofQ z u \\in sQ (ofQ z v)) = (u \\in <<1; v>>%VS).\n  exact/genP/(gen_ofP z).\nhave sQof z v: ofQ z v \\in sQ z.\n  by have [u Dz defQz] := genQz z; rewrite -[in sQ z]Dz sQof2 defQz memvf.\nhave{gen_inQ} sQ_inQ z x z_x := gen_inQ z x (genP z x z_x).\nhave /all_sig[inQ inQ_K] z: {inQ | {in sQ z, cancel inQ (ofQ z)}}.\n  by apply: all_sig_cond (fun x u => ofQ z u = x) 0 _ => x /sQ_inQ.\nhave ofQ_K z: cancel (ofQ z) (inQ z).\n  by move=> x; have /inQ_K/fmorph_inj := sQof z x.\nhave sQring z: divring_closed (sQ z).\n  have sQ_1: 1 \\in sQ z by rewrite -(rmorph1 (ofQ z)) sQof.\n  by split=> // x y /inQ_K<- /inQ_K<- /=; rewrite -(rmorphB, fmorph_div) sQof.\npose sQoM z := GRing.isOppClosed.Build _ _ (sQring z).\npose sQaM z := GRing.isAddClosed.Build _ _ (sQring z).\npose sQmM z := GRing.isMulClosed.Build _ _ (sQring z).\npose sQiM z := GRing.isInvClosed.Build _ _ (sQring z).\npose sQC z : divringClosed _ := HB.pack (sQ z)\n  (sQaM z) (sQoM z) (sQmM z) (sQiM z).\npose morph_ofQ x z Qxz := forall u, ofQ z (Qxz u) = ofQ x u.\nhave QtoQ z x: x \\in sQ z -> {Qxz : 'AHom(Q x, Q z) | morph_ofQ x z Qxz}.\n  move=> z_x; pose Qxz u := inQ z (ofQ x u).\n  have QxzE u: ofQ z (Qxz u) = ofQ x u by apply/inQ_K/(sQtrans x).\n  have Qxza : additive Qxz.\n    by move=> u v; apply: (canLR (ofQ_K z)); rewrite !rmorphB !QxzE.\n  have Qxzm : multiplicative Qxz.\n    by split=> [u v|]; apply: (canLR (ofQ_K z));\n      rewrite ?rmorph1 ?rmorphM /= ?QxzE.\n  have QxzaM := GRing.isAdditive.Build _ _ _ Qxza.\n  have QxzmM := GRing.isMultiplicative.Build _ _ _ Qxzm.\n  have QxzlM := GRing.isScalable.Build _ _ _ _ _ (rat_linear Qxza).\n  pose QxzLRM : {lrmorphism _ -> _} := HB.pack Qxz QxzaM QxzmM QxzlM.\n  by exists (linfun_ahom QxzLRM) => u; rewrite lfunE QxzE.\npose sQs z s := all (mem (sQ z)) s.\nhave inQsK z s: sQs z s -> map (ofQ z) (map (inQ z) s) = s.\n  by rewrite -map_comp => /allP/(_ _ _)/inQ_K; apply: map_id_in.\nhave inQpK z p: p \\is a polyOver (sQ z) -> (p ^ inQ z) ^ ofQ z = p.\n  by move=> /allP/(_ _ _)/inQ_K/=/map_poly_id; rewrite -map_poly_comp.\nhave{gen PET2 genP} PET s: {z | sQs z s & <<1 & map (inQ z) s>>%VS = fullv}.\n  have [y /inQsK Ds]: {y | sQs y s}.\n    elim: s => [|x s /= [y IHs]]; first by exists 0.\n    have [z /genP z_x /genP z_y] := PET2 x y.\n    by exists z; rewrite /= {x}z_x; apply: sub_all IHs => x /sQtrans/= ->.\n  have [w defQs] := PET_Qz _ <<1 & map (inQ y) s>>%AS; pose z := ofQ y w.\n  have z_s: sQs z s.\n    rewrite -Ds /sQs all_map; apply/allP=> u s_u /=.\n    by rewrite sQof2 defQs seqv_sub_adjoin.\n  have [[u Dz defQz] [Qzy QzyE]] := (genQz z, QtoQ y z (sQof y w)).\n  exists z => //; apply/eqP; rewrite eqEsubv subvf /= -defQz.\n  rewrite -(limg_ker0 _ _ (AHom_lker0 Qzy)) aimg_adjoin_seq aimg_adjoin aimg1.\n  rewrite -[map _ _](mapK (ofQ_K y)) -(map_comp (ofQ y)) (eq_map QzyE) inQsK //.\n  by rewrite -defQs -(canLR (ofQ_K y) Dz) -QzyE ofQ_K.\npose rp s := \\prod_(z <- s) ('X - z%:P).\nhave map_rp (f : {rmorphism _ -> _}) s: rp _ s ^ f = rp _ (map f s).\n  rewrite rmorph_prod /rp big_map; apply: eq_bigr => x _ /=.\n  by rewrite rmorphB /= map_polyX map_polyC.\npose is_Gal z := SplittingField.axiom (Q z).\nhave galQ x: {z | x \\in sQ z & is_Gal z}.\n  have /sig2W[p mon_p pz0] := algC x.\n  have [s Dp] := closed_field_poly_normal (p ^ QtoC).\n  rewrite (monicP _) ?monic_map // scale1r in Dp; have [z z_s defQz] := PET s.\n  exists z; first by apply/(allP z_s); rewrite -root_prod_XsubC -Dp.\n  exists p^@; first exact: alg_polyOver.\n  exists (map (inQ z) s); last by apply/vspaceP=> u; rewrite defQz memvf.\n  by rewrite -(eqp_map (ofQ z)) pQof Dp map_rp inQsK ?eqpxx.\npose is_realC x := {R : archiRealFieldType & {rmorphism Q x -> R}}.\npose realC := {x : C & is_realC x}.\npose has_Rroot (xR : realC) p c (Rx := sQ (tag xR)) :=\n  [&& p \\is a polyOver Rx, p \\is monic, c \\in Rx & p.[0] == - c ^+ 2].\npose root_in (xR : realC) p := exists2 w, w \\in sQ (tag xR) & root p w.\npose extendsR (xR yR : realC) := tag xR \\in sQ (tag yR).\nhave add_Rroot xR p c: {yR | extendsR xR yR & has_Rroot xR p c -> root_in yR p}.\n  rewrite {}/extendsR; case: (has_Rroot xR p c) / and4P; last by exists xR.\n  case: xR => x [R QxR] /= [/inQpK <-]; move: (p ^ _) => {}p mon_p /inQ_K<- Dc.\n  have{c Dc} p0_le0: (p ^ QxR).[0] <= 0.\n    rewrite horner_coef0 coef_map -[p`_0]ofQ_K -coef_map -horner_coef0 (eqP Dc).\n    by rewrite -rmorphXn -rmorphN ofQ_K /= rmorphN rmorphXn oppr_le0 sqr_ge0.\n  have [s Dp] := closed_field_poly_normal (p ^ ofQ x).\n  have{Dp} /all_and2[s_p p_s] y: root (p ^ ofQ x) y <-> (y \\in s).\n    by rewrite Dp (monicP mon_p) scale1r root_prod_XsubC.\n  rewrite map_monic in mon_p; have [z /andP[z_x /allP/=z_s] _] := PET (x :: s).\n  have{z_x} [[Qxz QxzE] Dx] := (QtoQ z x z_x, inQ_K z x z_x).\n  pose Qx := <<1; inQ z x>>%AS.\n  have pQwx q1: q1 \\is a polyOver Qx -> {q | q1 = q ^ Qxz}.\n    move/polyOverP=> Qx_q1; exists ((q1 ^ ofQ z) ^ inQ x).\n    apply: (map_poly_inj (ofQ z)); rewrite -map_poly_comp (eq_map_poly QxzE).\n    by rewrite inQpK ?polyOver_poly // => j _; rewrite -Dx sQof2 Qx_q1.\n  have /all_sig[t_ Dt] u: {t | <<1; t>> = <<Qx; u>>} by apply: PET_Qz.\n  suffices{p_s}[u Ry px0]: {u : Q z & is_realC (ofQ z (t_ u)) & ofQ z u \\in s}.\n    exists (Tagged is_realC Ry) => [|_] /=.\n      by rewrite -Dx sQof2 Dt subvP_adjoin ?memv_adjoin.\n    by exists (ofQ z u); rewrite ?p_s // sQof2 Dt memv_adjoin.\n  without loss{z_s s_p} [u Dp s_y]: p mon_p p0_le0 /\n    {u | minPoly Qx u = p ^ Qxz & ofQ z u \\in s}.\n  - move=> IHp; move: {2}_.+1 (ltnSn (size p)) => d.\n    elim: d => // d IHd in p mon_p s_p p0_le0 *; rewrite ltnS => le_p_d.\n    have /closed_rootP/sig_eqW[y py0]: size (p ^ ofQ x) != 1.\n      rewrite size_map_poly size_poly_eq1 eqp_monic ?rpred1 //.\n      by apply: contraTneq p0_le0 => ->; rewrite rmorph1 hornerC lt_geF ?ltr01.\n    have /s_p s_y := py0; have /z_s/sQ_inQ[u Dy] := s_y.\n    have /pQwx[q Dq] := minPolyOver Qx u.\n    have mon_q: q \\is monic by have:= monic_minPoly Qx u; rewrite Dq map_monic.\n    have /dvdpP/sig_eqW[r Dp]: q %| p.\n      rewrite -(dvdp_map Qxz) -Dq minPoly_dvdp //.\n        by apply: polyOver_poly => j _; rewrite -sQof2 QxzE Dx.\n      by rewrite -(fmorph_root (ofQ z)) Dy -map_poly_comp (eq_map_poly QxzE).\n    have mon_r: r \\is monic by rewrite Dp monicMr in mon_p.\n    have [q0_le0 | q0_gt0] := lerP ((q ^ QxR).[0]) 0.\n      by apply: (IHp q) => //; exists u; rewrite ?Dy.\n    have r0_le0: (r ^ QxR).[0] <= 0.\n      by rewrite -(ler_pM2r q0_gt0) mul0r -hornerM -rmorphM -Dp.\n    apply: (IHd r mon_r) => // [w rw0|].\n      by rewrite s_p // Dp rmorphM rootM rw0.\n    apply: leq_trans le_p_d; rewrite Dp size_Mmonic ?monic_neq0 // addnC.\n    by rewrite -(size_map_poly Qxz q) -Dq size_minPoly !ltnS leq_addl.\n  exists u => {s s_y}//; set y := ofQ z (t_ u); set p1 := minPoly Qx u in Dp.\n  have /QtoQ[Qyz QyzE]: y \\in sQ z := sQof z (t_ u).\n  pose q1_ v := Fadjoin_poly Qx u (Qyz v).\n  have{} QyzE v: Qyz v = (q1_ v).[u].\n    by rewrite Fadjoin_poly_eq // -Dt -sQof2 QyzE sQof.\n  have /all_sig2[q_ coqp Dq] v: {q | v != 0 -> coprimep p q & q ^ Qxz = q1_ v}.\n    have /pQwx[q Dq]: q1_ v \\is a polyOver Qx by apply: Fadjoin_polyOver.\n    exists q => // nz_v; rewrite -(coprimep_map Qxz) -Dp -Dq -gcdp_eqp1.\n    have /minPoly_irr/orP[] // := dvdp_gcdl p1 (q1_ v).\n      by rewrite gcdp_polyOver ?minPolyOver ?Fadjoin_polyOver.\n    rewrite -/p1 {1}/eqp dvdp_gcd => /and3P[_ _ /dvdp_leq/=/implyP].\n    rewrite size_minPoly ltnNge size_poly (contraNneq _ nz_v) // => q1v0.\n    by rewrite -(fmorph_eq0 Qyz) /= QyzE q1v0 horner0.\n  pose h2 : R := 2^-1; have nz2: 2 != 0 :> R by rewrite pnatr_eq0.\n  pose itv ab := [pred c : R | ab.1 <= c <= ab.2].\n  pose wid ab : R := ab.2 - ab.1; pose mid ab := (ab.1 + ab.2) * h2.\n  pose sub_itv ab cd := cd.1 <= ab.1 :> R /\\ ab.2 <= cd.2 :> R.\n  pose xup q ab := [/\\ q.[ab.1] <= 0, q.[ab.2] >= 0 & ab.1 <= ab.2 :> R].\n  pose narrow q ab (c := mid ab) := if q.[c] >= 0 then (ab.1, c) else (c, ab.2).\n  pose find k q := iter k (narrow q).\n  have findP k q ab (cd := find k q ab):\n    xup q ab -> [/\\ xup q cd, sub_itv cd ab & wid cd = wid ab / (2 ^ k)%:R].\n  - rewrite {}/cd; case: ab => a b xq_ab.\n    elim: k => /= [|k]; first by rewrite divr1.\n    case: (find k q _) => c d [[/= qc_le0 qd_ge0 le_cd] [/= le_ac le_db] Dcd].\n    have [/= le_ce le_ed] := midf_le le_cd; set e := _ / _ in le_ce le_ed.\n    rewrite expnSr natrM invfM mulrA -{}Dcd /narrow /= -[mid _]/e.\n    have [qe_ge0 // | /ltW qe_le0] := lerP 0 q.[e].\n      do ?split=> //=; [exact: (le_trans le_ed) | apply: canRL (mulfK nz2) _].\n      by rewrite mulrBl divfK // mulr_natr opprD addrACA subrr add0r.\n    do ?split=> //=; [exact: (le_trans le_ac) | apply: canRL (mulfK nz2) _].\n    by rewrite mulrBl divfK // mulr_natr opprD addrACA subrr addr0.\n  have find_root r q ab:\n    xup q ab -> {n | forall x, x \\in itv (find n q ab) ->`|(r * q).[x]| < h2}.\n  - move=> xab; have ub_ab := poly_itv_bound _ ab.1 ab.2.\n    have [Mu MuP] := ub_ab r; have /all_sig[Mq MqP] j := ub_ab q^`N(j).\n    pose d := wid ab; pose dq := \\poly_(i < (size q).-1) Mq i.+1.\n    have d_ge0: 0 <= d by rewrite subr_ge0; case: xab.\n    have [Mdq MdqP] := poly_disk_bound dq d.\n    pose n := Num.bound (Mu * Mdq * d); exists n => c /andP[].\n    have{xab} [[]] := findP n _ _ xab; case: (find n q ab) => a1 b1 /=.\n    rewrite -/d => qa1_le0 qb1_ge0 le_ab1 [/= le_aa1 le_b1b] Dab1 le_a1c le_cb1.\n    have /MuP lbMu: c \\in itv ab.\n      by rewrite inE (le_trans le_aa1) ?(le_trans le_cb1).\n    have Mu_ge0: 0 <= Mu by rewrite (le_trans _ lbMu).\n    have Mdq_ge0: 0 <= Mdq.\n      by rewrite (le_trans _ (MdqP 0 _)) ?normr0.\n    suffices lb1 a2 b2 (ab1 := (a1, b1)) (ab2 := (a2, b2)) :\n      xup q ab2 /\\ sub_itv ab2 ab1 -> q.[b2] - q.[a2] <= Mdq * wid ab1.\n    + apply: le_lt_trans (_ : Mu * Mdq * wid (a1, b1) < h2); last first.\n        rewrite {}Dab1 mulrA ltr_pdivrMr ?ltr0n ?expn_gt0 //.\n        rewrite (lt_le_trans (archi_boundP _)) ?mulr_ge0 ?ltr_nat // -/n.\n        rewrite ler_pdivlMl ?ltr0n // -natrM ler_nat.\n        by case: n => // n; rewrite expnS leq_pmul2l // ltn_expl.\n      rewrite -mulrA hornerM normrM ler_pM //.\n      have [/ltW qc_le0 | qc_ge0] := ltrP q.[c] 0.\n        by apply: le_trans (lb1 c b1 _); rewrite ?ler0_norm ?ler_wpDl.\n      by apply: le_trans (lb1 a1 c _); rewrite ?ger0_norm ?ler_wpDr ?oppr_ge0.\n    case{c le_a1c le_cb1 lbMu}=> [[/=qa2_le0 qb2_ge0 le_ab2] [/=le_a12 le_b21]].\n    pose h := b2 - a2; have h_ge0: 0 <= h by rewrite subr_ge0.\n    have [-> | nz_q] := eqVneq q 0.\n      by rewrite !horner0 subrr mulr_ge0 ?subr_ge0.\n    rewrite -(subrK a2 b2) (addrC h) (nderiv_taylor q (mulrC a2 h)).\n    rewrite (polySpred nz_q) big_ord_recl /= mulr1 nderivn0 addrC addKr.\n    have [le_aa2 le_b2b] := (le_trans le_aa1 le_a12, le_trans le_b21 le_b1b).\n    have /MqP MqPx1: a2 \\in itv ab by rewrite inE le_aa2 (le_trans le_ab2).\n    apply: le_trans (le_trans (ler_norm _) (ler_norm_sum _ _ _)) _.\n    apply: le_trans (_ : `|dq.[h] * h| <= _); last first.\n      by rewrite normrM ler_pM ?normr_ge0 ?MdqP // ?ger0_norm ?lerB ?h_ge0.\n    rewrite horner_poly ger0_norm ?mulr_ge0 ?sumr_ge0 // => [|j _]; last first.\n      by rewrite mulr_ge0 ?exprn_ge0 // (le_trans _ (MqPx1 _)).\n    rewrite mulr_suml ler_sum // => j _; rewrite normrM -mulrA -exprSr.\n    by rewrite ler_pM // normrX ger0_norm.\n  have [ab0 xab0]: {ab | xup (p ^ QxR) ab}.\n    have /monic_Cauchy_bound[b pb_gt0]: p ^ QxR \\is monic by apply: monic_map.\n    by exists (0, `|b|); rewrite /xup normr_ge0 p0_le0 ltW ?pb_gt0 ?ler_norm.\n  pose ab_ n := find n (p ^ QxR) ab0; pose Iab_ n := itv (ab_ n).\n  pose lim v a := (q_ v ^ QxR).[a]; pose nlim v n := lim v (ab_ n).2.\n  have lim0 a: lim 0 a = 0.\n    rewrite /lim; suffices /eqP ->: q_ 0 == 0 by rewrite rmorph0 horner0.\n    by rewrite -(map_poly_eq0 Qxz) Dq /q1_ !raddf0.\n  have limN v a: lim (- v) a = - lim v a.\n    rewrite /lim; suffices ->: q_ (- v) = - q_ v by rewrite rmorphN hornerN.\n    apply: (map_poly_inj Qxz).\n    by rewrite Dq /q1_ (raddfN _ v) (raddfN _ (Qyz v)) [RHS]raddfN /= Dq.\n  pose lim_nz n v := exists2 e, e > 0 & {in Iab_ n, forall a, e < `|lim v a| }.\n  have /(all_sig_cond 0)[n_ nzP] v: v != 0 -> {n | lim_nz n v}.\n    move=> nz_v; do [move/(_ v nz_v); rewrite -(coprimep_map QxR)] in coqp.\n    have /sig_eqW[r r_pq_1] := Bezout_eq1_coprimepP _ _ coqp.\n    have /(find_root r.1)[n ub_rp] := xab0; exists n.\n    have [M Mgt0 ubM]: {M | 0 < M & {in Iab_ n, forall a, `|r.2.[a]| <= M}}.\n      have [M ubM] := poly_itv_bound r.2 (ab_ n).1 (ab_ n).2.\n      exists (Num.max 1 M) => [|s /ubM vM]; first by rewrite lt_max ltr01.\n      by rewrite le_max orbC vM.\n    exists (h2 / M) => [|a xn_a]; first by rewrite divr_gt0 ?invr_gt0 ?ltr0n.\n    rewrite ltr_pdivrMr // -(ltrD2l h2) -mulr2n -mulr_natl divff //.\n    rewrite -normr1 -(hornerC 1 a) -[1%:P]r_pq_1 hornerD.\n    rewrite ?(le_lt_trans (ler_normD _ _)) ?ltr_leD ?ub_rp //.\n    by rewrite mulrC hornerM normrM ler_wpM2l ?ubM.\n  have ab_le m n: (m <= n)%N -> (ab_ n).2 \\in Iab_ m.\n    move/subnKC=> <-; move: {n}(n - m)%N => n; rewrite /ab_.\n    have /(findP m)[/(findP n)[[_ _]]] := xab0.\n    rewrite /find -iterD -!/(find _ _) -!/(ab_ _) addnC !inE.\n    by move: (ab_ _) => /= ab_mn le_ab_mn [/le_trans->].\n  pose lt v w := 0 < nlim (w - v) (n_ (w - v)).\n  have posN v: lt 0 (- v) = lt v 0 by rewrite /lt subr0 add0r.\n  have posB v w: lt 0 (w - v) = lt v w by rewrite /lt subr0.\n  have posE n v: (n_ v <= n)%N -> lt 0 v = (0 < nlim v n).\n    rewrite /lt subr0 /nlim => /ab_le; set a := _.2; set b := _.2 => Iv_a.\n    have [-> | /nzP[e e_gt0]] := eqVneq v 0; first by rewrite !lim0 ltxx.\n    move: (n_ v) => m in Iv_a b * => v_gte.\n    without loss lt0v: v v_gte / 0 < lim v b.\n      move=> IHv; apply/idP/idP => [v_gt0 | /ltW]; first by rewrite -IHv.\n      rewrite lt_def -normr_gt0 ?(lt_trans _ (v_gte _ _)) ?ab_le //=.\n      rewrite !leNgt -!oppr_gt0 -!limN; apply: contra => v_lt0.\n      by rewrite -IHv // => c /v_gte; rewrite limN normrN.\n    rewrite lt0v (lt_trans e_gt0) ?(lt_le_trans (v_gte a Iv_a)) //.\n    rewrite ger0_norm // leNgt; apply/negP=> /ltW lev0.\n    have [le_a le_ab] : _ /\\ a <= b := andP Iv_a.\n    have xab: xup (q_ v ^ QxR) (a, b) by move/ltW in lt0v.\n    have /(find_root (h2 / e)%:P)[n1] := xab; have /(findP n1)[[_ _]] := xab.\n    case: (find _ _ _) => c d /= le_cd [/= le_ac le_db] _ /(_ c)/implyP.\n    rewrite inE lexx le_cd hornerM hornerC normrM le_gtF //.\n    rewrite ger0_norm ?divr_ge0 ?invr_ge0 ?ler0n ?(ltW e_gt0) // mulrAC.\n    rewrite ler_pdivlMr // ler_wpM2l ?invr_ge0 ?ler0n // ltW // v_gte //=.\n    by rewrite inE -/b (le_trans le_a) //= (le_trans le_cd).\n  pose lim_pos m v := exists2 e, e > 0 & forall n, (m <= n)%N -> e < nlim v n.\n  have posP v: reflect (exists m, lim_pos m v) (lt 0 v).\n    apply: (iffP idP) => [v_gt0|[m [e e_gt0 v_gte]]]; last first.\n      by rewrite (posE _ _ (leq_maxl _ m)) (lt_trans e_gt0) ?v_gte ?leq_maxr.\n    have [|e e_gt0 v_gte] := nzP v.\n      by apply: contraTneq v_gt0 => ->; rewrite /lt subr0 /nlim lim0 ltxx.\n    exists (n_ v), e => // n le_vn; rewrite (posE n) // in v_gt0.\n    by rewrite -(ger0_norm (ltW v_gt0)) v_gte ?ab_le.\n  have posNneg v: lt 0 v -> ~~ lt v 0.\n    case/posP=> m [d d_gt0 v_gtd]; rewrite -posN.\n    apply: contraL d_gt0 => /posP[n [e e_gt0 nv_gte]].\n    rewrite lt_gtF // (lt_trans (v_gtd _ (leq_maxl m n))) // -oppr_gt0.\n    by rewrite /nlim -limN (lt_trans e_gt0) ?nv_gte ?leq_maxr.\n  have posVneg v: v != 0 -> lt 0 v || lt v 0.\n    case/nzP=> e e_gt0 v_gte; rewrite -posN; set w := - v.\n    have [m [le_vm le_wm _]] := maxn3 (n_ v) (n_ w) 0; rewrite !(posE m) //.\n    by rewrite /nlim limN -ltr_normr (lt_trans e_gt0) ?v_gte ?ab_le.\n  have posD v w: lt 0 v -> lt 0 w -> lt 0 (v + w).\n    move=> /posP[m [d d_gt0 v_gtd]] /posP[n [e e_gt0 w_gte]].\n    apply/posP; exists (maxn m n), (d + e) => [|k]; first exact: addr_gt0.\n    rewrite geq_max => /andP[le_mk le_nk]; rewrite /nlim /lim.\n    have ->: q_ (v + w) = q_ v + q_ w.\n      by apply: (map_poly_inj Qxz); rewrite rmorphD /= !{1}Dq /q1_ !raddfD.\n    by rewrite rmorphD hornerD ltrD ?v_gtd ?w_gte.\n  have posM v w: lt 0 v -> lt 0 w -> lt 0 (v * w).\n    move=> /posP[m [d d_gt0 v_gtd]] /posP[n [e e_gt0 w_gte]].\n    have /dvdpP[r /(canRL (subrK _))Dqvw]: p %| q_ (v * w) - q_ v * q_ w.\n      rewrite -(dvdp_map Qxz) rmorphB rmorphM /= !Dq -Dp minPoly_dvdp //.\n        by rewrite rpredB 1?rpredM ?Fadjoin_polyOver.\n      by rewrite rootE !hornerE -!QyzE rmorphM subrr.\n    have /(find_root ((d * e)^-1 *: r ^ QxR))[N ub_rp] := xab0.\n    pose f := d * e * h2; apply/posP; exists (maxn N (maxn m n)), f => [|k].\n      by rewrite !mulr_gt0 ?invr_gt0 ?ltr0n.\n   rewrite !geq_max => /and3P[/ab_le/ub_rp{}ub_rp le_mk le_nk].\n    rewrite -(ltrD2r f) -mulr2n -mulr_natr divfK // /nlim /lim Dqvw.\n    rewrite rmorphD hornerD /= -addrA -ltrBlDl ler_ltD //.\n      by rewrite rmorphM hornerM ler_pM ?ltW ?v_gtd ?w_gte.\n    rewrite -ltr_pdivrMl ?mulr_gt0 // (le_lt_trans _ ub_rp) //.\n    by rewrite -scalerAl hornerZ -rmorphM mulrN -normrN ler_norm.\n  pose le v w := (v == w) || lt v w.\n  pose abs v := if le 0 v then v else - v.\n  have absN v: abs (- v) = abs v.\n    rewrite /abs /le !(eq_sym 0) oppr_eq0 opprK posN.\n    have [-> | /posVneg/orP[v_gt0 | v_lt0]] := eqVneq; first by rewrite oppr0.\n      by rewrite v_gt0 /= -if_neg posNneg.\n    by rewrite v_lt0 /= -if_neg -(opprK v) posN posNneg ?posN.\n  have absE v: le 0 v -> abs v = v by rewrite /abs => ->.\n  pose RyM := Num.IntegralDomain_isLtReal.Build (Q y) posD\n                posM posNneg posB posVneg absN absE (rrefl _).\n  pose Ry : realFieldType := HB.pack (Q y) RyM.\n  have QisArchi : Num.NumDomain_bounded_isArchimedean Ry.\n    by constructor; apply: (@rat_algebraic_archimedean Ry _ alg_integral).\n  exists (HB.pack_for archiRealFieldType _ QisArchi); apply: idfun.\nhave some_realC: realC.\n  suffices /all_sig[f QfK] x: {a | in_alg (Q 0) a = x}.\n    have fA : additive f.\n      exact: can2_additive (inj_can_sym QfK (fmorph_inj _)) QfK.\n    have fM : multiplicative f.\n      exact: can2_rmorphism (inj_can_sym QfK (fmorph_inj _)) QfK.\n    pose faM := GRing.isAdditive.Build _ _ _ fA.\n    pose fmM := GRing.isMultiplicative.Build _ _ _ fM.\n    pose fRM : {rmorphism _ -> _} := HB.pack f faM fmM.\n    by exists 0, rat; exact: fRM.\n  have /Fadjoin1_polyP/sig_eqW[q]: x \\in <<1; 0>>%VS by rewrite -sQof2 rmorph0.\n  by exists q.[0]; rewrite -horner_map rmorph0.\npose fix xR n : realC :=\n  if n isn't n'.+1 then some_realC else\n  if unpickle (nth 0 (CodeSeq.decode n') 1) isn't Some (p, c) then xR n' else\n  tag (add_Rroot (xR n') p c).\npose x_ n := tag (xR n).\nhave sRle m n: (m <= n)%N -> {subset sQ (x_ m) <= sQ (x_ n)}.\n  move/subnK <-; elim: {n}(n - m)%N => // n IHn x /IHn{IHn}Rx.\n  rewrite addSn /x_ /=; case: (unpickle _) => [[p c]|] //=.\n  by case: (add_Rroot _ _ _) => yR /= /(sQtrans _ x)->.\nhave xRroot n p c: has_Rroot (xR n) p c -> {m | n <= m & root_in (xR m) p}%N.\n  case/and4P=> Rp mon_p Rc Dc; pose m := CodeSeq.code [:: n; pickle (p, c)].\n  have le_n_m: (n <= m)%N by apply/ltnW/(allP (CodeSeq.ltn_code _))/mem_head.\n  exists m.+1; rewrite ?leqW /x_ //= CodeSeq.codeK pickleK.\n  case: (add_Rroot _ _ _) => yR /= _; apply; apply/and4P.\n  by split=> //; first apply: polyOverS Rp; apply: (sRle n).\nhave /all_sig[z_ /all_and3[Ri_R Ri_i defRi]] n (x := x_ n):\n  {z | [/\\ x \\in sQ z, i \\in sQ z & <<<<1; inQ z x>>; inQ z i>> = fullv]}.\n- have [z /and3P[z_x z_i _] Dzi] := PET [:: x; i].\n  by exists z; rewrite -adjoin_seq1 -adjoin_cons.\npose i_ n := inQ (z_ n) i; pose R_ n := <<1; inQ (z_ n) (x_ n)>>%AS.\nhave memRi n: <<R_ n; i_ n>> =i predT by move=> u; rewrite defRi memvf.\nhave sCle m n: (m <= n)%N -> {subset sQ (z_ m) <= sQ (z_ n)}.\n  move/sRle=> Rmn _ /sQ_inQ[u <-].\n  have /Fadjoin_polyP[p /polyOverP Rp ->] := memRi m u.\n  rewrite -horner_map inQ_K ?(@rpred_horner _ (sQC _)) //=.\n  apply/polyOver_poly=> j _.\n  by apply: sQtrans (Ri_R n); rewrite Rmn // -(inQ_K _ _ (Ri_R m)) sQof2.\nhave R'i n: i \\notin sQ (x_ n).\n  rewrite /x_; case: (xR n) => x [Rn QxR] /=.\n  apply: contraL (@ltr01 Rn) => /sQ_inQ[v Di].\n  suffices /eqP <-: - QxR v ^+ 2 == 1 by rewrite oppr_gt0 -leNgt sqr_ge0.\n  rewrite -rmorphXn -rmorphN fmorph_eq1 -(fmorph_eq1 (ofQ x)) rmorphN eqr_oppLR.\n  by rewrite rmorphXn /= Di Di2.\nhave szX2_1: size ('X^2 + 1) = 3%N.\n  by move=> R; rewrite size_polyDl ?size_polyXn ?size_poly1.\nhave minp_i n (p_i := minPoly (R_ n) (i_ n)): p_i = 'X^2 + 1.\n  have p_dv_X2_1: p_i %| 'X^2 + 1.\n    rewrite minPoly_dvdp ?rpredD ?rpredX ?rpred1 ?polyOverX //.\n    rewrite -(fmorph_root (ofQ _)) inQ_K // rmorphD rmorph1 /= map_polyXn.\n    by rewrite rootE hornerD hornerXn hornerC Di2 addNr.\n  apply/eqP; rewrite -eqp_monic ?monic_minPoly //; last first.\n    by rewrite monicE lead_coefE szX2_1 coefD coefXn coefC addr0.\n  rewrite -dvdp_size_eqp // eqn_leq dvdp_leq -?size_poly_eq0 ?szX2_1 //= ltnNge.\n  by rewrite size_minPoly ltnS leq_eqVlt orbF adjoin_deg_eq1 -sQof2 !inQ_K.\nhave /all_sig[n_ FTA] z: {n | z \\in sQ (z_ n)}.\n  without loss [z_i gal_z]: z / i \\in sQ z /\\ is_Gal z.\n    have [y /and3P[/sQtrans y_z /sQtrans y_i _] _] := PET [:: z; i].\n    have [t /sQtrans t_y gal_t] := galQ y.\n    by case/(_ t)=> [|n]; last exists n; rewrite ?y_z ?y_i ?t_y.\n  apply/sig_eqW; have n := 0%N.\n  have [p]: exists p, [&& p \\is monic, root p z & p \\is a polyOver (sQ (z_ n))].\n    have [p mon_p pz0] := algC z; exists (p ^ QtoC).\n    by rewrite map_monic mon_p pz0 -(pQof (z_ n)); apply/polyOver_poly.\n  have [d lepd] := ubnP (size p); elim: d => // d IHd in p n lepd * => pz0.\n  have [t [t_C t_z gal_t]]: exists t, [/\\ z_ n \\in sQ t, z \\in sQ t & is_Gal t].\n    have [y /and3P[y_C y_z _]] := PET [:: z_ n; z].\n    by have [t /(sQtrans y)t_y] := galQ y; exists t; rewrite !t_y.\n  pose QtMixin := FieldExt_isSplittingField.Build _ (Q t) gal_t.\n  pose Qt : splittingFieldType rat := HB.pack (Q t) QtMixin.\n  have /QtoQ[CnQt CnQtE] := t_C.\n  pose Rn : {subfield Qt} := (CnQt @: R_ n)%AS; pose i_t : Qt := CnQt (i_ n).\n  pose Cn : {subfield Qt} := <<Rn; i_t>>%AS.\n  have defCn: Cn = limg CnQt :> {vspace Q t} by rewrite /= -aimg_adjoin defRi.\n  have memRn u: (u \\in Rn) = (ofQ t u \\in sQ (x_ n)).\n    by rewrite /= aimg_adjoin aimg1 -sQof2 CnQtE inQ_K.\n  have memCn u: (u \\in Cn) = (ofQ t u \\in sQ (z_ n)).\n    have [v Dv genCn] := genQz (z_ n).\n    by rewrite -Dv -CnQtE sQof2 defCn -genCn aimg_adjoin aimg1.\n  have Dit: ofQ t i_t = i by rewrite CnQtE inQ_K.\n  have Dit2: i_t ^+ 2 = -1.\n    by apply: (fmorph_inj (ofQ t)); rewrite rmorphXn rmorphN1 /= Dit.\n  have dimCn: \\dim_Rn Cn = 2%N.\n    rewrite -adjoin_degreeE adjoin_degree_aimg.\n    by apply: succn_inj; rewrite -size_minPoly minp_i szX2_1.\n  have /sQ_inQ[u_z Dz] := t_z; pose Rz := <<Cn; u_z>>%AS.\n  have{p lepd pz0} le_Rz_d: (\\dim_Cn Rz < d)%N.\n    rewrite -ltnS -adjoin_degreeE -size_minPoly (leq_trans _ lepd) // !ltnS.\n    have{pz0} [mon_p pz0 Cp] := and3P pz0.\n    have{Cp} Dp: ((p ^ inQ (z_ n)) ^ CnQt) ^ ofQ t = p.\n      by rewrite -map_poly_comp (eq_map_poly CnQtE) inQpK.\n    rewrite -Dp size_map_poly dvdp_leq ?monic_neq0 -?(map_monic (ofQ _)) ?Dp //.\n    rewrite defCn minPoly_dvdp //; try by rewrite -(fmorph_root (ofQ t)) Dz Dp.\n    by apply/polyOver_poly=> j _; rewrite memv_img ?memvf.\n  have [sRCn sCnRz]: (Rn <= Cn)%VS /\\ (Cn <= Rz)%VS by rewrite !subv_adjoin.\n  have sRnRz := subv_trans sRCn sCnRz.\n  have{gal_z} galRz: galois Rn Rz.\n    apply/and3P; split; [by []|by apply: sepQ|].\n    apply/splitting_normalField=> //.\n    pose QzMixin := FieldExt_isSplittingField.Build _ (Q z) gal_z.\n    pose Qz : splittingFieldType _ := HB.pack (Q z) QzMixin.\n    pose u : Qz := inQ z z.\n    have /QtoQ[Qzt QztE] := t_z; exists (minPoly 1 u ^ Qzt).\n      have /polyOver1P[q ->] := minPolyOver 1 u; apply/polyOver_poly=> j _.\n      by rewrite coef_map linearZZ rmorph1 rpredZ ?rpred1.\n    have [s /eqP Ds] := splitting_field_normal 1 u.\n    rewrite Ds; exists (map Qzt s); first by rewrite map_rp eqpxx.\n    apply/eqP; rewrite eqEsubv; apply/andP; split.\n      apply/Fadjoin_seqP; split=> // _ /mapP[w s_w ->].\n      by rewrite (subvP (adjoinSl u_z (sub1v _))) // -sQof2 Dz QztE.\n    rewrite /= adjoinC (Fadjoin_idP _) -/Rz; last first.\n      by rewrite (subvP (adjoinSl _ (sub1v _))) // -sQof2 Dz Dit.\n    rewrite /= -adjoin_seq1 adjoin_seqSr //; apply/allP=> /=; rewrite andbT.\n    rewrite -(mem_map (fmorph_inj (ofQ _))) -map_comp (eq_map QztE); apply/mapP.\n    by exists u; rewrite ?inQ_K // -root_prod_XsubC -Ds root_minPoly.\n  have galCz: galois Cn Rz by rewrite (galoisS _ galRz) ?sRCn.\n  have [Cz | C'z]:= boolP (u_z \\in Cn); first by exists n; rewrite -Dz -memCn.\n  pose G := 'Gal(Rz / Cn)%G; have{C'z} ntG: G :!=: 1%g.\n    rewrite trivg_card1 -galois_dim 1?(galoisS _ galCz) ?subvv //=.\n    by rewrite -adjoin_degreeE adjoin_deg_eq1.\n  pose extRz m := exists2 w, ofQ t w \\in sQ (z_ m) & w \\in [predD Rz & Cn].\n  suffices [m le_n_m [w Cw /andP[C'w Rz_w]]]: exists2 m, (n <= m)%N & extRz m.\n    pose p := minPoly <<Cn; w>> u_z; apply: (IHd (p ^ ofQ t) m).\n      apply: leq_trans le_Rz_d; rewrite size_map_poly size_minPoly ltnS.\n      rewrite adjoin_degreeE adjoinC (addv_idPl Rz_w) agenv_id.\n      rewrite ltn_divLR ?adim_gt0 // mulnC.\n      rewrite muln_divCA ?field_dimS ?subv_adjoin // ltn_Pmulr ?adim_gt0 //.\n      by rewrite -adjoin_degreeE ltnNge leq_eqVlt orbF adjoin_deg_eq1.\n    rewrite map_monic monic_minPoly -Dz fmorph_root root_minPoly /=.\n    have /polyOverP Cw_p: p \\is a polyOver <<Cn; w>>%VS by apply: minPolyOver.\n    apply/polyOver_poly=> j _; have /Fadjoin_polyP[q Cq {j}->] := Cw_p j.\n    rewrite -horner_map (@rpred_horner _ (sQC _)) //.\n    apply/polyOver_poly=> j _.\n    by rewrite (sCle n) // -memCn (polyOverP Cq).\n  have [evenG | oddG] := boolP (2.-group G); last first.\n    have [P /and3P[sPG evenP oddPG]] := Sylow_exists 2 'Gal(Rz / Rn).\n    have [w defQw] := PET_Qz t [aspace of fixedField P].\n    pose pw := minPoly Rn w; pose p := (- pw * (pw \\Po - 'X)) ^ ofQ t.\n    have sz_pw: (size pw).-1 = #|'Gal(Rz / Rn) : P|.\n      rewrite size_minPoly adjoin_degreeE -dim_fixed_galois //= -defQw.\n      congr (\\dim_Rn _); apply/esym/eqP; rewrite eqEsubv adjoinSl ?sub1v //=.\n      by apply/FadjoinP; rewrite memv_adjoin /= defQw -galois_connection.\n    have mon_p: p \\is monic.\n      have mon_pw: pw \\is monic := monic_minPoly _ _.\n      rewrite map_monic mulNr -mulrN monicMl // monicE.\n      rewrite !(lead_coefN, lead_coef_comp) ?size_polyN ?size_polyX //.\n      by rewrite lead_coefX sz_pw -signr_odd odd_2'nat oddPG mulrN1 opprK.\n    have Dp0: p.[0] = - ofQ t pw.[0] ^+ 2.\n      rewrite -(rmorph0 (ofQ t)) horner_map hornerM rmorphM.\n      by rewrite horner_comp !hornerN hornerX oppr0 /= rmorphN mulNr.\n    have Rpw: pw \\is a polyOver Rn by apply: minPolyOver.\n    have Rp: p \\is a polyOver (sQ (x_ n)).\n      apply/polyOver_poly=> j _; rewrite -memRn; apply: polyOverP j => /=.\n      by rewrite rpredM 1?polyOver_comp ?rpredN ?polyOverX.\n    have Rp0: ofQ t pw.[0] \\in sQ (x_ n) by rewrite -memRn rpred_horner ?rpred0.\n    have [|{mon_p Rp Rp0 Dp0}m lenm p_Rm_0] := xRroot n p (ofQ t pw.[0]).\n      by rewrite /has_Rroot mon_p Rp Rp0 -Dp0 /=.\n    have{p_Rm_0} [y Ry pw_y]: {y | y \\in sQ (x_ m) & root (pw ^ ofQ t) y}.\n      apply/sig2W; have [y Ry] := p_Rm_0.\n      rewrite [p]rmorphM /= map_comp_poly !rmorphN /= map_polyX.\n      rewrite rootM rootN root_comp hornerN hornerX.\n      by case/orP; [exists y | exists (- y)]; rewrite ?(rpredN (sQC _)).\n    have [u Rz_u Dy]: exists2 u, u \\in Rz & y = ofQ t u.\n      have Rz_w: w \\in Rz by rewrite -sub_adjoin1v defQw capvSl.\n      have [sg [Gsg _ Dpw]] := galois_factors sRnRz galRz w Rz_w.\n      set s := map _ sg in Dpw.\n      have /mapP[u /mapP[g Gg Du] ->]: y \\in map (ofQ t) s.\n        by rewrite -root_prod_XsubC -/(rp C _) -map_rp -[rp _ _]Dpw.\n      by exists u; rewrite // Du memv_gal.\n    have{pw_y} pw_u: root pw u by rewrite -(fmorph_root (ofQ t)) -Dy.\n    exists m => //; exists u; first by rewrite -Dy; apply: sQtrans Ry _.\n    rewrite inE /= Rz_u andbT; apply: contra oddG => Cu.\n    suffices: 2.-group 'Gal(Rz / Rn).\n      apply: pnat_dvd; rewrite -!galois_dim // ?(galoisS _ galQr) ?sRCz //.\n      rewrite dvdn_divLR ?field_dimS ?adim_gt0 //.\n      by rewrite mulnC muln_divCA ?field_dimS ?dvdn_mulr.\n    congr (2.-group _): evenP; apply/eqP.\n    rewrite eqEsubset sPG -indexg_eq1 (pnat_1 _ oddPG) // -sz_pw.\n    have (pu := minPoly Rn u): (pu %= pw) || (pu %= 1).\n      by rewrite minPoly_irr ?minPoly_dvdp ?minPolyOver.\n    rewrite /= -size_poly_eq1 {1}size_minPoly orbF => /eqp_size <-.\n    rewrite size_minPoly /= adjoin_degreeE (@pnat_dvd _ 2) // -dimCn.\n    rewrite dvdn_divLR ?divnK ?adim_gt0 ?field_dimS ?subv_adjoin //.\n    exact/FadjoinP.\n  have [w Rz_w deg_w]: exists2 w, w \\in Rz & adjoin_degree Cn w = 2%N.\n    have [P sPG iPG]: exists2 P : {group gal_of Rz}, P \\subset G & #|G : P| = 2%N.\n      have [_ _ [k oG]] := pgroup_pdiv evenG ntG.\n      have [P [sPG _ oP]] := normal_pgroup evenG (normal_refl G) (leq_pred _).\n      by exists P => //; rewrite -divgS // oP oG pfactorK // -expnB ?subSnn.\n    have [w defQw] := PET_Qz _ [aspace of fixedField P].\n    exists w; first by rewrite -sub_adjoin1v defQw capvSl.\n    rewrite adjoin_degreeE -iPG -dim_fixed_galois // -defQw; congr (\\dim_Cn _).\n    apply/esym/eqP; rewrite eqEsubv adjoinSl ?sub1v //=; apply/FadjoinP.\n    by rewrite memv_adjoin /= defQw -galois_connection.\n  have nz2: 2 != 0 :> Qt by move/pcharf0P: (pcharQ (Q t)) => ->.\n  without loss{deg_w} [C'w Cw2]: w Rz_w / w \\notin Cn /\\ w ^+ 2 \\in Cn.\n    pose p := minPoly Cn w; pose v := p`_1 / 2.\n    have /polyOverP Cp: p \\is a polyOver Cn := minPolyOver Cn w.\n    have Cv: v \\in Cn by rewrite rpred_div ?rpred_nat ?Cp.\n    move/(_ (v + w)); apply; first by rewrite rpredD // subvP_adjoin.\n    split; first by rewrite rpredDl // -adjoin_deg_eq1 deg_w.\n    rewrite addrC -[_ ^+ 2]subr0 -(rootP (root_minPoly Cn w)) -/p.\n    rewrite sqrrD [_ - _]addrAC rpredD ?rpredX // -mulr_natr -mulrA divfK //.\n    rewrite [w ^+ 2 + _]addrC mulrC -rpredN opprB horner_coef.\n    have /monicP := monic_minPoly Cn w; rewrite lead_coefE size_minPoly deg_w.\n    by rewrite 2!big_ord_recl big_ord1 => ->; rewrite mulr1 mul1r addrK Cp.\n  without loss R'w2: w Rz_w C'w Cw2 / w ^+ 2 \\notin Rn.\n    move=> IHw; have [Rw2 | /IHw] := boolP (w ^+ 2 \\in Rn); last exact.\n    have R'it: i_t \\notin Rn by rewrite memRn Dit.\n    pose v := 1 + i_t; have R'v: v \\notin Rn by rewrite rpredDl ?rpred1.\n    have Cv: v \\in Cn by rewrite rpredD ?rpred1 ?memv_adjoin.\n    have nz_v: v != 0 by rewrite (memPnC R'v) ?rpred0.\n    apply: (IHw (v * w)); last 1 [|] || by rewrite fpredMl // subvP_adjoin.\n      by rewrite exprMn rpredM // rpredX.\n    rewrite exprMn fpredMr //=; last by rewrite expf_eq0 (memPnC C'w) ?rpred0.\n    by rewrite sqrrD Dit2 expr1n addrC addKr -mulrnAl fpredMl ?rpred_nat.\n  pose rect_w2 u v := [/\\ u \\in Rn, v \\in Rn & u + i_t * (v * 2) = w ^+ 2].\n  have{Cw2} [u [v [Ru Rv Dw2]]]: {u : Qt & {v | rect_w2 u v}}.\n    rewrite /rect_w2 -(Fadjoin_poly_eq Cw2); set p := Fadjoin_poly Rn i_t _.\n    have /polyOverP Rp: p \\is a polyOver Rn by apply: Fadjoin_polyOver.\n    exists p`_0, (p`_1 / 2); split; rewrite ?rpred_div ?rpred_nat //.\n    rewrite divfK // (horner_coef_wide _ (size_Fadjoin_poly _ _ _)) -/p.\n    by rewrite adjoin_degreeE dimCn big_ord_recl big_ord1 mulr1 mulrC.\n  pose p := Poly [:: - (ofQ t v ^+ 2); 0; - ofQ t u; 0; 1].\n  have [|m lenm [x Rx px0]] := xRroot n p (ofQ t v).\n    rewrite /has_Rroot 2!unfold_in/= lead_coefE horner_coef0 -memRn Rv.\n    rewrite (@PolyK _ 1) ?oner_eq0 //= !eqxx.\n    rewrite !(rpred0 (sQC _)) ?(rpred1 (sQC _)) ?(rpredN (sQC _)) //=.\n    by rewrite !andbT (@rpredX _ (sQC _)) -memRn.\n  suffices [y Cy Dy2]: {y | y \\in sQ (z_ m) & ofQ t w ^+ 2 == y ^+ 2}.\n    exists m => //; exists w; last by rewrite inE C'w.\n    by move: Dy2; rewrite eqf_sqr => /pred2P[]->; rewrite ?(rpredN (sQC _)).\n  exists (x + i * (ofQ t v / x)).\n    rewrite (@rpredD _ (sQC _)) 1?(@rpredM _ (sQC _)) //=.\n      exact: (sQtrans (x_ m)).\n    by rewrite (@rpred_div _ (sQC _)) // (sQtrans (x_ m)) // (sRle n) // -memRn.\n  rewrite rootE /horner (@PolyK _ 1) ?oner_eq0 //= ?addr0 ?mul0r in px0.\n  rewrite add0r mul1r -mulrA -expr2 subr_eq0 in px0.\n  have nz_x2: x ^+ 2 != 0.\n    apply: contraNneq R'w2 => y2_0; rewrite -Dw2 mulrCA.\n    suffices /eqP->: v == 0 by rewrite mul0r addr0.\n    by rewrite y2_0 mulr0 eq_sym sqrf_eq0 fmorph_eq0 in px0.\n  apply/eqP/esym/(mulIf nz_x2); rewrite -exprMn -rmorphXn -Dw2 rmorphD rmorphM.\n  rewrite /= Dit mulrDl -expr2 mulrA divfK; last by rewrite expf_eq0 in nz_x2.\n  rewrite mulr_natr addrC sqrrD exprMn Di2 mulN1r -(eqP px0) -mulNr opprB.\n  by rewrite -mulrnAl -mulrnAr -rmorphMn -!mulrDl addrAC subrK.\nhave inFTA n z: (n_ z <= n)%N -> z = ofQ (z_ n) (inQ (z_ n) z).\n  by move/sCle=> le_zn; rewrite inQ_K ?le_zn.\npose is_cj n cj := {in R_ n, cj =1 id} /\\ cj (i_ n) = - i_ n.\nhave /all_sig[cj_ /all_and2[cj_R cj_i]] n: {cj : 'AEnd(Q (z_ n)) | is_cj n cj}.\n  have cj_P: root (minPoly (R_ n) (i_ n) ^ \\1%VF) (- i_ n).\n    rewrite minp_i -(fmorph_root (ofQ _)) !rmorphD !rmorph1 /= !map_polyXn.\n    by rewrite rmorphN inQ_K // rootE hornerD hornerXn hornerC sqrrN Di2 addNr.\n  have cj_M: ahom_in fullv (kHomExtend (R_ n) \\1 (i_ n) (- i_ n)).\n    by rewrite -defRi -k1HomE kHomExtendP ?sub1v ?kHom1.\n  exists (AHom cj_M); split=> [y /kHomExtend_id->|]; first by rewrite ?id_lfunE.\n  by rewrite (kHomExtend_val (kHom1 1 _)).\npose conj_ n z := ofQ _ (cj_ n (inQ _ z)); pose conj z := conj_ (n_ z) z.\nhave conjK n m z: (n_ z <= n)%N -> (n <= m)%N -> conj_ m (conj_ n z) = z.\n  move/sCle=> le_z_n le_n_m; have /le_z_n/sQ_inQ[u <-] := FTA z.\n  have /QtoQ[Qmn QmnE]: z_ n \\in sQ (z_ m) by rewrite (sCle n).\n  rewrite /conj_ ofQ_K -!QmnE !ofQ_K -!comp_lfunE; congr (ofQ _ _).\n  move: u (memRi n u); apply/eqlfun_inP/FadjoinP; split=> /=.\n    apply/eqlfun_inP=> y Ry; rewrite !comp_lfunE !cj_R //.\n    by move: Ry; rewrite -!sQof2 QmnE !inQ_K //; apply: sRle.\n  apply/eqlfunP; rewrite !comp_lfunE cj_i !linearN /=.\n  suffices ->: Qmn (i_ n) = i_ m by rewrite cj_i ?opprK.\n  by apply: (fmorph_inj (ofQ _)); rewrite QmnE !inQ_K.\nhave conjE n z: (n_ z <= n)%N -> conj z = conj_ n z.\n  move/leq_trans=> le_zn; set x := conj z; set y := conj_ n z.\n  have [m [le_xm le_ym le_nm]] := maxn3 (n_ x) (n_ y) n.\n  by have /conjK/=/can_in_inj := leqnn m; apply; rewrite ?conjK // le_zn.\n  have conjA : additive conj.\n  move=> x y.\n  have [m [le_xm le_ym le_xym]] := maxn3 (n_ x) (n_ y) (n_ (x - y)).\n  by rewrite !(conjE m) // (inFTA m x) // (inFTA m y) -?rmorphB /conj_ ?ofQ_K.\nhave conjM : multiplicative conj.\n  split=> [x y|]; last pose n1 := n_ 1.\n    have [m [le_xm le_ym le_xym]] := maxn3 (n_ x) (n_ y) (n_ (x * y)).\n    by rewrite !(conjE m) // (inFTA m x) // (inFTA m y) -?rmorphM /conj_ ?ofQ_K.\n  by rewrite /conj -/n1 -(rmorph1 (ofQ (z_ n1))) /conj_ ofQ_K !rmorph1.\nhave conjaM := GRing.isAdditive.Build _ _ _ conjA.\nhave conjmM := GRing.isMultiplicative.Build _ _ _ conjM.\npose conjRM : {rmorphism _ -> _} := HB.pack conj conjaM conjmM.\nexists conjRM => [z | /(_ i)/eqP/idPn[]] /=.\n  by have [n [/conjE-> /(conjK (n_ z))->]] := maxn3 (n_ (conj z)) (n_ z) 0.\nrewrite /conj/conj_ cj_i rmorphN inQ_K // eq_sym -addr_eq0 -mulr2n -mulr_natl.\nrewrite mulf_neq0 ?(memPnC (R'i 0)) ?(rpred0 (sQC _)) //.\nby have /pcharf0P-> := ftrans (fmorph_pchar QtoC) (pchar_num _).\nQed.",
    "Theorem fin_Csubring_Aint S n (Y : n.-tuple algC) :\n     mulr_closed S -> (forall x, reflect (inIntSpan Y x) (x \\in S)) ->\n  {subset S <= Aint}.\nProof.\nmove=> mulS.\npose Sm := GRing.isMulClosed.Build _ _ mulS.\npose SC : mulrClosed _ := HB.pack S Sm.\nhave ZP_C c: (ZtoC c)%:P \\is a polyOver Num.int_num_subdef.\n  by rewrite raddfMz rpred_int.\nmove=> S_P x Sx; pose v := \\row_(i < n) Y`_i.\nhave [v0 | nz_v] := eqVneq v 0.\n  case/S_P: Sx => {}x ->; rewrite big1 ?isAlgInt0 // => i _.\n  by have /rowP/(_ i)/[!mxE] -> := v0; rewrite mul0rz.\nhave sYS (i : 'I_n): x * Y`_i \\in SC.\n  by rewrite rpredM //; apply/S_P/Cint_spanP/mem_Cint_span/memt_nth.\npose A := \\matrix_(i, j < n) sval (sig_eqW (S_P _ (sYS j))) i.\npose p := char_poly (map_mx ZtoC A).\nhave: p \\is a polyOver Num.int_num_subdef.\n  rewrite rpred_sum // => s _; rewrite rpredMsign rpred_prod // => j _.\n  by rewrite !mxE /= rpredB ?rpredMn ?polyOverX.\napply: root_monic_Aint (char_poly_monic _).\nrewrite -eigenvalue_root_char; apply/eigenvalueP; exists v => //.\napply/rowP=> j; case dAj: (sig_eqW (S_P _ (sYS j))) => [a DxY].\nby rewrite !mxE DxY; apply: eq_bigr => i _; rewrite !mxE dAj /= mulrzr.\nQed.",
    "Theorem Sylow's_theorem :\n  [/\\ forall P, [max P | p.-subgroup(G) P] = p.-Sylow(G) P,\n      [transitive G, on 'Syl_p(G) | 'JG],\n      forall P, p.-Sylow(G) P -> #|'Syl_p(G)| = #|G : 'N_G(P)|\n   &  prime p -> #|'Syl_p(G)| %% p = 1%N].\nProof.\npose maxp A P := [max P | p.-subgroup(A) P]; pose S := [set P | maxp G P].\npose oG := orbit 'JG%act G.\nhave actS: [acts G, on S | 'JG].\n  apply/subsetP=> x Gx; rewrite 3!inE; apply/subsetP=> P; rewrite 3!inE.\n  exact: max_pgroupJ.\nhave S_pG P: P \\in S -> P \\subset G /\\ p.-group P.\n  by rewrite inE => /maxgroupp/andP[].\nhave SmaxN P Q: Q \\in S -> Q \\subset 'N(P) -> maxp 'N_G(P) Q.\n  rewrite inE => /maxgroupP[/andP[sQG pQ] maxQ] nPQ.\n  apply/maxgroupP; rewrite /psubgroup subsetI sQG nPQ.\n  by split=> // R; rewrite subsetI -andbA andbCA => /andP[_]; apply: maxQ.\nhave nrmG P: P \\subset G -> P <| 'N_G(P).\n  by move=> sPG; rewrite /normal subsetIr subsetI sPG normG.\nhave sylS P: P \\in S -> p.-Sylow('N_G(P)) P.\n  move=> S_P; have [sPG pP] := S_pG P S_P.\n  by rewrite normal_max_pgroup_Hall ?nrmG //; apply: SmaxN; rewrite ?normG.\nhave{SmaxN} defCS P: P \\in S -> 'Fix_(S |'JG)(P) = [set P].\n  move=> S_P; apply/setP=> Q; rewrite {1}in_setI {1}afixJG.\n  apply/andP/set1P=> [[S_Q nQP]|->{Q}]; last by rewrite normG.\n  apply/esym/val_inj; case: (S_pG Q) => //= sQG _.\n  by apply: uniq_normal_Hall (SmaxN Q _ _ _) => //=; rewrite ?sylS ?nrmG.\nhave{defCS} oG_mod: {in S &, forall P Q, #|oG P| = (Q \\in oG P) %[mod p]}.\n  move=> P Q S_P S_Q; have [sQG pQ] := S_pG _ S_Q.\n  have soP_S: oG P \\subset S by rewrite acts_sub_orbit.\n  have /pgroup_fix_mod-> //: [acts Q, on oG P | 'JG].\n    apply/actsP=> x /(subsetP sQG) Gx R; apply: orbit_transl.\n    exact: mem_orbit.\n  rewrite -{1}(setIidPl soP_S) -setIA defCS // (cardsD1 Q) setDE.\n  by rewrite -setIA setICr setI0 cards0 addn0 inE set11 andbT.\nhave [P S_P]: exists P, P \\in S.\n  have: p.-subgroup(G) 1 by rewrite /psubgroup sub1G pgroup1.\n  by case/(@maxgroup_exists _ (p.-subgroup(G))) => P; exists P; rewrite inE.\nhave trS: [transitive G, on S | 'JG].\n  apply/imsetP; exists P => //; apply/eqP.\n  rewrite eqEsubset andbC acts_sub_orbit // S_P; apply/subsetP=> Q S_Q.\n  have /[1!inE] /maxgroupP[/andP[_ pP]] := S_P.\n  have [-> max1 | ntP _] := eqVneq P 1%G.\n    move/andP/max1: (S_pG _ S_Q) => Q1.\n    by rewrite (group_inj (Q1 (sub1G Q))) orbit_refl.\n  have:= oG_mod _ _ S_P S_P; rewrite (oG_mod _ Q) // orbit_refl.\n  have p_gt1: p > 1 by apply: prime_gt1; case/pgroup_pdiv: pP.\n  by case: (Q \\in oG P) => //; rewrite mod0n modn_small.\nhave oS1: prime p -> #|S| %% p = 1%N.\n  move/prime_gt1 => p_gt1.\n  by rewrite -(atransP trS P S_P) (oG_mod P P) // orbit_refl modn_small.\nhave oSiN Q: Q \\in S -> #|S| = #|G : 'N_G(Q)|.\n  by move=> S_Q; rewrite -(atransP trS Q S_Q) card_orbit astab1JG.\nhave sylP: p.-Sylow(G) P.\n  rewrite pHallE; case: (S_pG P) => // -> /= pP.\n  case p_pr: (prime p); last first.\n    rewrite p_part lognE p_pr /= -trivg_card1; apply/idPn=> ntP.\n    by case/pgroup_pdiv: pP p_pr => // ->.\n  rewrite -(LagrangeI G 'N(P)) /= mulnC partnM ?cardG_gt0 // part_p'nat.\n    by rewrite mul1n (card_Hall (sylS P S_P)).\n  by rewrite p'natE // -indexgI -oSiN // /dvdn oS1.\nhave eqS Q: maxp G Q = p.-Sylow(G) Q.\n  apply/idP/idP=> [S_Q|]; last exact: Hall_max.\n  have{} S_Q: Q \\in S by rewrite inE.\n  rewrite pHallE -(card_Hall sylP); case: (S_pG Q) => // -> _ /=.\n  by case: (atransP2 trS S_P S_Q) => x _ ->; rewrite cardJg.\nhave ->: 'Syl_p(G) = S by apply/setP=> Q; rewrite 2!inE.\nby split=> // Q sylQ; rewrite -oSiN ?inE ?eqS.\nQed.",
    "Theorem Baer_Suzuki x G :\n    x \\in G -> (forall y, y \\in G -> p.-group <<[set x; x ^ y]>>) ->\n  x \\in 'O_p(G).\nProof.\nhave [n] := ubnP #|G|; elim: n G x => // n IHn G x /ltnSE-leGn Gx pE.\nset E := x ^: G; have{} pE: {in E &, forall x1 x2, p.-group <<[set x1; x2]>>}.\n  move=> _ _ /imsetP[y1 Gy1 ->] /imsetP[y2 Gy2 ->].\n  rewrite -(mulgKV y1 y2) conjgM -2!conjg_set1 -conjUg genJ pgroupJ.\n  by rewrite pE // groupMl ?groupV.\nhave sEG: <<E>> \\subset G by rewrite gen_subG class_subG.\nhave nEG: G \\subset 'N(E) by apply: class_norm.\nhave Ex: x \\in E by apply: class_refl.\nhave [P Px sylP]: exists2 P : {group gT}, x \\in P & p.-Sylow(<<E>>) P.\n  have sxxE: <<[set x; x]>> \\subset <<E>> by rewrite genS // setUid sub1set.\n  have{sxxE} [P sylP sxxP] := Sylow_superset sxxE (pE _ _ Ex Ex).\n  by exists P => //; rewrite (subsetP sxxP) ?mem_gen ?setU11.\ncase sEP: (E \\subset P).\n  apply: subsetP Ex; rewrite -gen_subG; apply: pcore_max.\n    by apply: pgroupS (pHall_pgroup sylP); rewrite gen_subG.\n  by rewrite /normal gen_subG class_subG // norms_gen.\npose P_yD D := [pred y in E :\\: P | p.-group <<y |: D>>].\npose P_D := [pred D : {set gT} | D \\subset P :&: E & [exists y, P_yD D y]].\nhave{Ex Px}: P_D [set x].\n  rewrite /= sub1set inE Px Ex; apply/existsP=> /=.\n  by case/subsetPn: sEP => y Ey Py; exists y; rewrite inE Ey Py pE.\ncase/(@maxset_exists _ P_D)=> D /maxsetP[]; rewrite {P_yD P_D}/=.\nrewrite subsetI sub1set -andbA => /and3P[sDP sDE /existsP[y0]].\nset B := _ |: D; rewrite inE -andbA => /and3P[Py0 Ey0 pB] maxD Dx.\nhave sDgE: D \\subset <<E>> by apply: sub_gen.\nhave sDG: D \\subset G by apply: subset_trans sEG.\nhave sBE: B \\subset E by rewrite subUset sub1set Ey0.\nhave sBG: <<B>> \\subset G by apply: subset_trans (genS _) sEG.\nhave sDB: D \\subset B by rewrite subsetUr.\nhave defD: D :=: P :&: <<B>> :&: E.\n  apply/eqP; rewrite eqEsubset ?subsetI sDP sDE sub_gen //=.\n  apply/setUidPl; apply: maxD; last apply: subsetUl.\n  rewrite subUset subsetI sDP sDE setIAC subsetIl.\n  apply/existsP; exists y0; rewrite inE Py0 Ey0 /= setUA -/B.\n  by rewrite -[<<_>>]joing_idl joingE setKI genGid.\nhave nDD: D \\subset 'N(D).\n  apply/subsetP=> z Dz; rewrite inE defD.\n  apply/subsetP=> _ /imsetP[y /setIP[PBy Ey] ->].\n  rewrite inE groupJ // ?inE ?(subsetP sDP) ?mem_gen ?setU1r //= memJ_norm //.\n  exact: (subsetP (subset_trans sDG nEG)).\ncase nDG: (G \\subset 'N(D)).\n  apply: subsetP Dx; rewrite -gen_subG pcore_max ?(pgroupS (genS _) pB) //.\n  by rewrite /normal gen_subG sDG norms_gen.\nhave{n leGn IHn nDG} pN: p.-group <<'N_E(D)>>.\n  apply: pgroupS (pcore_pgroup p 'N_G(D)); rewrite gen_subG /=.\n  apply/subsetP=> x1 /setIP[Ex1 Nx1]; apply: IHn => [||y Ny].\n  - apply: leq_trans leGn; rewrite proper_card // /proper subsetIl.\n    by rewrite subsetI nDG andbF.\n  - by rewrite inE Nx1 (subsetP sEG) ?mem_gen.\n  have Ex1y: x1 ^ y \\in E.\n    by rewrite -mem_conjgV (normsP nEG) // groupV; case/setIP: Ny.\n  by apply: pgroupS (genS _) (pE _ _ Ex1 Ex1y); apply/subsetP => u /[!inE].\nhave [y1 Ny1 Py1]: exists2 y1, y1 \\in 'N_E(D) & y1 \\notin P.\n  case sNN: ('N_<<B>>('N_<<B>>(D)) \\subset 'N_<<B>>(D)).\n    exists y0 => //; have By0: y0 \\in <<B>> by rewrite mem_gen ?setU11.\n    rewrite inE Ey0 -By0 -in_setI.\n    by rewrite -['N__(D)](nilpotent_sub_norm (pgroup_nil pB)) ?subsetIl.\n  case/subsetPn: sNN => z /setIP[Bz NNz]; rewrite inE Bz inE.\n  case/subsetPn=> y; rewrite mem_conjg => Dzy Dy.\n  have:= Dzy; rewrite {1}defD; do 2![case/setIP]=> _ Bzy Ezy.\n  have Ey: y \\in E by rewrite -(normsP nEG _ (subsetP sBG z Bz)) mem_conjg.\n  have /setIP[By Ny]: y \\in 'N_<<B>>(D).\n    by rewrite -(normP NNz) mem_conjg inE Bzy ?(subsetP nDD).\n  exists y; first by rewrite inE Ey.\n  by rewrite defD 2!inE Ey By !andbT in Dy.\nhave [y2 Ny2 Dy2]: exists2 y2, y2 \\in 'N_(P :&: E)(D) & y2 \\notin D.\n  case sNN: ('N_P('N_P(D)) \\subset 'N_P(D)).\n    have [z /= Ez sEzP] := Sylow_Jsub sylP (genS sBE) pB.\n    have Gz: z \\in G by apply: subsetP Ez.\n    have /subsetPn[y Bzy Dy]: ~~ (B :^ z \\subset D).\n      apply/negP; move/subset_leq_card; rewrite cardJg cardsU1.\n      by rewrite {1}defD 2!inE (negPf Py0) ltnn.\n    exists y => //; apply: subsetP Bzy.\n    rewrite -setIA setICA subsetI sub_conjg (normsP nEG) ?groupV // sBE.\n    have nilP := pgroup_nil (pHall_pgroup sylP).\n    by rewrite -['N__(_)](nilpotent_sub_norm nilP) ?subsetIl // -gen_subG genJ.\n  case/subsetPn: sNN => z /setIP[Pz NNz]; rewrite 2!inE Pz.\n  case/subsetPn=> y Dzy Dy; exists y => //; apply: subsetP Dzy.\n  rewrite -setIA setICA subsetI sub_conjg (normsP nEG) ?groupV //.\n    by rewrite sDE -(normP NNz); rewrite conjSg subsetI sDP.\n  by apply: subsetP Pz; apply: (subset_trans (pHall_sub sylP)).\nsuff{Dy2} Dy2D: y2 |: D = D by rewrite -Dy2D setU11 in Dy2.\napply: maxD; last by rewrite subsetUr.\ncase/setIP: Ny2 => PEy2 Ny2; case/setIP: Ny1 => Ey1 Ny1.\nrewrite subUset sub1set PEy2 subsetI sDP sDE.\napply/existsP; exists y1; rewrite inE Ey1 Py1; apply: pgroupS pN.\nrewrite genS // !subUset !sub1set !in_setI Ey1 Ny1.\nby case/setIP: PEy2 => _ ->; rewrite Ny2 subsetI sDE.\nQed.",
    "Theorem dihedral2_structure :\n    n > 1 -> extremal_generators G 2 n (x, y) -> G \\isog 'D_m ->\n  [/\\ [/\\ X ><| Y = G, {in G :\\: X, forall t, #[t] = 2}\n        & {in X & G :\\: X, forall z t, z ^ t = z^-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      'Ohm_1(G) = G /\\ (forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>),\n      [/\\ yG :|: xyG = G :\\: X, [disjoint yG & xyG]\n        & forall M, maximal M G = pred3 X My Mxy M]\n    & if n == 2 then (2.-abelem G : Prop) else\n  [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n       My \\isog 'D_q, Mxy \\isog 'D_q\n     & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\nProof.\nmove=> n_gt1 genG isoG; have [def2q def2r ltqm ltrq] := def2qr n_gt1.\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave [[u v] [_ Gu ou U'v] [ov uv]] := generators_2dihedral n_gt1 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z^-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> z'; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv expgVn.\nhave oU': {in <[u]> :* v, forall t, #[t] = 2}.\n  move=> t Uvt; apply: nt_prime_order => //; last first.\n    by case: eqP Uvt => // ->; rewrite defUv !inE group1.\n  case/rcosetP: Uvt => z Uz ->{t}; rewrite expgS {1}(conjgC z) -mulgA.\n  by rewrite invUV ?rcoset_refl // mulKg -(expgS v 1) -ov expg_order.\nhave defU: n > 2 -> {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> n_gt2 z Gz oz; apply/eqP; rewrite eqEcard -!orderE oz cycle_subG.\n  apply: contraLR n_gt2; rewrite ou leqnn andbT -(ltn_predK n_gt1) => notUz.\n  by rewrite ltnS -(@ltn_exp2l 2) // -/q -oz oU' // defUv inE notUz.\nhave n2_abelG: (n > 2) || 2.-abelem G.\n  rewrite ltn_neqAle eq_sym n_gt1; case: eqP => //= n2.\n  apply/abelemP=> //; split=> [|z Gz].\n    by apply: (p2group_abelian pG); rewrite oG pfactorK ?n2.\n  case Uz: (z \\in <[u]>); last by rewrite -expg_mod_order oU' // defUv inE Uz.\n  apply/eqP; rewrite -order_dvdn (dvdn_trans (order_dvdG Uz)) // -orderE.\n  by rewrite ou /q n2.\nhave{oU'} oX': {in G :\\: X, forall t, #[t] = 2}.\n  have [n_gt2 | abelG] := orP n2_abelG; first by rewrite [X]defU // -defUv.\n  move=> t /setDP[Gt notXt]; apply: nt_prime_order (group1_contra notXt) => //.\n  by case/abelemP: abelG => // _ ->.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z^-1}.\n  have [n_gt2 | abelG] := orP n2_abelG; first by rewrite [X]defU // -defUv.\n  have [//|cGG oG2] := abelemP _ abelG.\n  move=> t z Xt /setDP[Gz _]; apply/eqP; rewrite eq_sym eq_invg_mul.\n  by rewrite /conjg -(centsP cGG z) // ?mulKg ?[t * t]oG2 ?(subsetP sXG).\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -groupV expnSr expgM invMg.\n  by rewrite -{2}(invXX' _ y) ?mem_cycle ?cycle_id ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X); last by rewrite -{1}(oX' z) ?expg_order ?group1 // inE Xz.\n  by case/cycleP: Xz => i ->; rewrite expgAC mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^- 2 * t}.\n    move=> z Xz; rewrite /= invMg -mulgA (conjgC _ t).\n    by rewrite (invXX' _ t) ?groupV ?invgK.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> _ z /cycleP[j ->] Xz -> -> {tz t'z}.\n    exists (z ^- 2); last by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite groupV -expgM mulnC expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}; exists (x ^- i); first by rewrite groupV groupX.\n  by rewrite defJt ?groupV ?mem_cycle // expgVn invgK expgAC.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> ><| <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite sdprodEY ?cycle_subG ?(subsetP (nXiG 2)) //; first 1 last.\n    rewrite setIC prime_TIg -?orderE ?oX' // cycle_subG.\n    by apply: contra notXt; apply: subsetP; rewrite cycleX.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't /=; rewrite -(sdprod_card (defMt t X't)) -!orderE ox2 oX' //.\n  by rewrite mulnC.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't /=; rewrite p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nsplit.\n- by rewrite ?sdprodE // setIC // prime_TIg ?cycle_subG // -orderE ?oX'.\n- rewrite defG'; split=> //.\n  apply/eqP; rewrite eqn_leq (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // geq_max leqnn -(subnKC n_gt1).\n  rewrite -(subnKC n_gt1) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- split; last exact: extend_cyclic_Mho.\n  have sX'G1: {subset G :\\: X <= 'Ohm_1(G)}.\n    move=> t X't; have [Gt _] := setDP X't.\n    by rewrite (OhmE 1 pG) mem_gen // !inE Gt -(oX' t) //= expg_order.\n  apply/eqP; rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n  by rewrite -(groupMr _ (sX'G1 y X'y)) !sX'G1.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => t Ht notXt.\n  have: t \\in yG :|: xyG by rewrite defX' inE notXt (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP; move/class_eqP <-; rewrite !class_sub_norm ?Ht ?orbT.\nrewrite eqn_leq n_gt1; case: leqP n2_abelG => //= n_gt2 _.\nhave ->: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> t; case/setIP=> Gt cGt.\n  case X't: (t \\in G :\\: X).\n    move/eqP: (invXX' _ _ (cycle_id x) X't).\n    rewrite /conjg -(centP cGt) // mulKg eq_sym eq_invg_mul -order_eq1 ox2.\n    by rewrite (eqn_exp2l _ 0) // -(subnKC n_gt2).\n  move/idPn: X't; rewrite inE Gt andbT negbK => Xt.\n  have:= Ohm_p_cycle 1 (mem_p_elt pG Gx); rewrite ox pfactorK // subn1 => <-.\n  rewrite (OhmE _ (pgroupS sXG pG)) mem_gen // !inE Xt /=.\n  by rewrite -eq_invg_mul -(invXX' _ y) // /conjg (centP cGt) // mulKg.\nhave isoMt: {in G :\\: X, forall t, <<t ^: G>> \\isog 'D_q}.\n  have n1_gt1: n.-1 > 1 by rewrite -(subnKC n_gt2).\n  move=> t X't /=; rewrite isogEcard card_2dihedral ?oMt // leqnn andbT.\n  rewrite Grp_2dihedral //; apply/existsP; exists (x ^+ 2, t) => /=.\n  have [_ <- nX2T _] := sdprodP (defMt t X't); rewrite norm_joinEr //.\n  rewrite -/q -/r !xpair_eqE eqxx -expgM def2r -ox -{1}(oX' t X't).\n  by rewrite !expg_order !eqxx /= invXX' ?mem_cycle.\nrewrite !isoMt //; split=> // C; case/cyclicP=> z ->{C} sCG iCG.\nrewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed.",
    "Theorem quaternion_structure :\n    n > 2 -> extremal_generators G 2 n (x, y) -> G \\isog 'Q_m ->\n  [/\\ [/\\ pprod X Y = G, {in G :\\: X, forall t, #[t] = 4}\n        & {in X & G :\\: X, forall z t, z ^ t = z^-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n          forall u, u \\in G -> #[u] = 2 -> u = x ^+ r,\n          'Ohm_1(G) = <[x ^+ r]> /\\ 'Ohm_2(G) = G\n         & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n      [/\\ yG :|: xyG = G :\\: X /\\ [disjoint yG & xyG]\n        & forall M, maximal M G = pred3 X My Mxy M]\n    & n > 3 ->\n     [/\\ My \\isog 'Q_q, Mxy \\isog 'Q_q\n       & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\nProof.\nmove=> n_gt2 genG isoG; have [def2q def2r ltqm ltrq] := def2qr (ltnW n_gt2).\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave [[u v] [_ Gu ou U'v] [ov v2 uv]] := generators_quaternion n_gt2 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z^-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> ?; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv expgVn.\nhave U'2: {in <[u]> :* v, forall t, t ^+ 2 = u ^+ r}.\n  move=> t; case/rcosetP=> z Uz ->; rewrite expgS {1}(conjgC z) -mulgA.\n  by rewrite invUV ?rcoset_refl // mulKg -(expgS v 1) v2.\nhave our: #[u ^+ r] = 2 by rewrite orderXdiv ou -/q -def2r ?dvdn_mull ?mulnK.\nhave def_ur: {in G, forall t, #[t] = 2 -> t = u ^+ r}.\n  move=> t Gt /= ot; case Ut: (t \\in <[u]>); last first.\n    move/eqP: ot; rewrite eqn_dvd order_dvdn -order_eq1 U'2 ?our //.\n    by rewrite defUv inE Ut.\n  have p2u: 2.-elt u by rewrite /p_elt ou pnatX.\n  have: t \\in 'Ohm_1(<[u]>).\n    by rewrite (OhmE _ p2u) mem_gen // !inE Ut -order_dvdn ot.\n  rewrite (Ohm_p_cycle _ p2u) ou pfactorK // subn1 -/r cycle_traject our !inE.\n  by rewrite -order_eq1 ot /= mulg1; move/eqP.\nhave defU: n > 3 -> {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> n_gt3 z Gz oz; apply/eqP; rewrite eqEcard -!orderE oz cycle_subG.\n  rewrite ou leqnn andbT; apply: contraLR n_gt3 => notUz.\n  rewrite -(ltn_predK n_gt2) ltnS -(@ltn_exp2l 2) // -/q -oz.\n  by rewrite (@orderXprime _ 2 2) // U'2 // defUv inE notUz.\nhave def_xr: x ^+ r = u ^+ r by apply: def_ur; rewrite ?groupX.\nhave X'2: {in G :\\: X, forall t, t ^+ 2 = u ^+ r}.\n  case: (ltngtP n 3) => [|n_gt3|n3 t]; first by rewrite ltnNge n_gt2.\n    by rewrite /X defU // -defUv.\n  case/setDP=> Gt notXt.\n  case Ut: (t \\in <[u]>); last by rewrite U'2 // defUv inE Ut.\n  rewrite [t ^+ 2]def_ur ?groupX //.\n  have:= order_dvdG Ut; rewrite -orderE ou /q n3 dvdn_divisors ?inE //=.\n  rewrite order_eq1 (negbTE (group1_contra notXt)) /=.\n  case/pred2P=> oz; last by rewrite orderXdiv oz.\n  by rewrite [t]def_ur // -def_xr mem_cycle in notXt.\nhave oX': {in G :\\: X, forall z, #[z] = 4}.\n  by move=> t X't /=; rewrite (@orderXprime _ 2 2) // X'2.\nhave defZ: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> z; case/setIP=> Gz cGz; have [Gv _]:= setDP U'v.\n  case Uvz: (z \\in <[u]> :* v).\n    move/eqP: (invUV _ _ (cycle_id u) Uvz).\n    rewrite /conjg -(centP cGz) // mulKg eq_sym eq_invg_mul -(order_dvdn _ 2).\n    by rewrite ou pfactor_dvdn // -(subnKC n_gt2).\n  move/idPn: Uvz; rewrite defUv inE Gz andbT negbK def_xr => Uz.\n  have p_u: 2.-elt u := mem_p_elt pG Gu.\n  suff: z \\in 'Ohm_1(<[u]>) by rewrite (Ohm_p_cycle 1 p_u) ou pfactorK // subn1.\n  rewrite (OhmE _ p_u) mem_gen // !inE Uz /= -eq_invg_mul.\n  by rewrite -(invUV _ v) ?rcoset_refl // /conjg (centP cGz) ?mulKg.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z^-1}.\n  case: (ltngtP n 3) => [|n_gt3|n3 t z Xt]; first by rewrite ltnNge n_gt2.\n    by rewrite /X defU // -defUv.\n  case/setDP=> Gz notXz; rewrite /q /r n3 /= in oxr ox.\n  suff xz: x ^ z = x^-1 by case/cycleP: Xt => i ->; rewrite conjXg xz expgVn.\n  have: x ^ z \\in X by rewrite memJ_norm ?cycle_id ?(subsetP nXG).\n  rewrite invg_expg /X cycle_traject ox !inE /= !mulg1 -order_eq1 orderJ ox /=.\n  case/or3P; move/eqP=> //; last by move/(congr1 order); rewrite orderJ ox oxr.\n  move/conjg_fixP; rewrite (sameP commgP cent1P) cent1C -cent_cycle -/X => cXz.\n  have defXz: X * <[z]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  have: z \\in 'Z(G) by rewrite inE Gz -defXz centM inE cXz cent_cycle cent1id.\n  by rewrite defZ => Xr_z; rewrite (subsetP (cycleX x r)) in notXz.\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -groupV expnSr expgM invMg.\n  by rewrite -{2}(invXX' _ y) ?mem_cycle ?cycle_id ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X).\n    by case/cycleP: Xz => i ->; rewrite -expgM mulnC expgM mem_cycle.\n  rewrite (X'2 z) ?inE ?Xz // -def_xr.\n  by rewrite /r -(subnKC n_gt2) expnS expgM mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^- 2 * t}.\n    move=> z Xz; rewrite /= invMg -mulgA (conjgC _ t).\n    by rewrite (invXX' _ t) ?groupV ?invgK.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> t' z; case/cycleP=> j -> Xz -> -> {tz t'z t'}.\n    exists (z ^- 2); last by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite groupV -expgM mulnC expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}; exists (x ^- i); first by rewrite groupV groupX.\n  by rewrite defJt ?groupV ?mem_cycle // expgVn invgK -!expgM mulnC.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> <*> <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite -defMt // -(Lagrange (joing_subl _ _)) -orderE ox2 -def2r mulnC.\n  congr (_ * r)%N; rewrite -card_quotient /=; last first.\n    by rewrite defMt // (subset_trans _ (nXiG 2)) ?sMtG.\n  rewrite joingC quotientYidr ?(subset_trans _ (nXiG 2)) ?cycle_subG //.\n  rewrite quotient_cycle ?(subsetP (nXiG 2)) //= -defPhi.\n  rewrite -orderE (abelem_order_p (Phi_quotient_abelem pG)) ?mem_quotient //.\n  apply: contraNneq notXt; move/coset_idr; move/implyP=> /=.\n  by rewrite defPhi ?(subsetP (nXiG 2)) //; apply: subsetP; apply: cycleX.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't; rewrite /= p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nrewrite pprodE //; split=> // [|||n_gt3].\n- rewrite defG'; split=> //; apply/eqP; rewrite eqn_leq.\n  rewrite (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // -(subnKC n_gt2).\n  rewrite -(subnKC (ltnW n_gt2)) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- rewrite {2}def_xr defZ; split=> //; last exact: extend_cyclic_Mho.\n  split; apply/eqP; last first.\n    have sX'G2: {subset G :\\: X <= 'Ohm_2(G)}.\n      move=> z X'z; have [Gz _] := setDP X'z.\n      by rewrite (OhmE 2 pG) mem_gen // !inE Gz -order_dvdn oX'.\n    rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n    by rewrite -(groupMr _ (sX'G2 y X'y)) !sX'G2.\n  rewrite eqEsubset (OhmE 1 pG) cycle_subG gen_subG andbC.\n  rewrite mem_gen ?inE ?groupX -?order_dvdn ?oxr //=.\n  apply/subsetP=> t; case/setIP=> Gt; rewrite inE -order_dvdn /=.\n  rewrite dvdn_divisors ?inE //= order_eq1.\n  case/pred2P=> [->|]; first exact: group1.\n  by move/def_ur=> -> //; rewrite def_xr cycle_id.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => z Hz notXz.\n  have: z \\in yG :|: xyG by rewrite defX' inE notXz (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP=> /class_eqP <-; rewrite !class_sub_norm ?Hz ?orbT.\nhave isoMt: {in G :\\: X, forall z, <<z ^: G>> \\isog 'Q_q}.\n  have n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\n  move=> z X'z /=; rewrite isogEcard card_quaternion ?oMt // leqnn andbT.\n  rewrite Grp_quaternion //; apply/existsP; exists (x ^+ 2, z) => /=.\n  rewrite defMt // -/q -/r !xpair_eqE -!expgM def2r -order_dvdn ox dvdnn.\n  rewrite -expnS prednK; last by rewrite -subn2 subn_gt0.\n  by rewrite X'2 // def_xr !eqxx /= invXX' ?mem_cycle.\nrewrite !isoMt //; split=> // C; case/cyclicP=> z ->{C} sCG iCG.\nrewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed.",
    "Theorem semidihedral_structure :\n    n > 3 -> extremal_generators G 2 n (x, y) -> G \\isog 'SD_m -> #[y] = 2 ->\n  [/\\ [/\\ X ><| Y = G, #[x * y] = 4\n        & {in X & G :\\: X, forall z t, z ^ t = z ^+ r.-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n          'Ohm_1(G) = My /\\ 'Ohm_2(G) = G\n         & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n      [/\\ yG :|: xyG = G :\\: X /\\ [disjoint yG & xyG]\n        & forall H, maximal H G = pred3 X My Mxy H]\n    & [/\\ My \\isog 'D_q, Mxy \\isog 'Q_q\n       & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\nProof.\nmove=> n_gt3 genG isoG oy.\nhave [def2q def2r ltqm ltrq] := def2qr (ltnW (ltnW n_gt3)).\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave [[u v] [_ Gu ou U'v] [ov uv]] := generators_semidihedral n_gt3 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z ^+ r.-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> ?; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv -!expgM mulnC.\nhave [vV yV]: v^-1 = v /\\ y^-1 = y by rewrite !invg_expg ov oy.\nhave defU: {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> z Gz /= oz; apply/eqP; rewrite eqEcard -!orderE oz ou leqnn andbT.\n  apply: contraLR (n_gt3) => notUz; rewrite -leqNgt -(ltn_predK n_gt3) ltnS.\n  rewrite -(@dvdn_Pexp2l 2) // -/q -{}oz order_dvdn expgM (expgS z).\n  have{Gz notUz} [z' Uz' ->{z}]: exists2 z', z' \\in <[u]> & z = z' * v.\n    by apply/rcosetP; rewrite defUv inE -cycle_subG notUz Gz.\n  rewrite {2}(conjgC z') invUV ?rcoset_refl // mulgA -{2}vV mulgK -expgS.\n  by rewrite prednK // -expgM mulnC def2r -order_dvdn /q -ou order_dvdG.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z ^+ r.-1}.\n  by rewrite /X defU -?defUv.\nhave xy2: (x * y) ^+ 2 = x ^+ r.\n  rewrite expgS {2}(conjgC x) invXX' ?cycle_id // mulgA -{2}yV mulgK -expgS.\n  by rewrite prednK.\nhave oxy: #[x * y] = 4 by rewrite (@orderXprime _ 2 2) ?xy2.\nhave r_gt2: r > 2 by rewrite (ltn_exp2l 1) // -(subnKC n_gt3).\nhave coXr1: coprime #[x] (2 ^ (n - 3)).-1.\n  rewrite ox coprimeXl // -(@coprime_pexpl (n - 3)) ?coprimenP ?subn_gt0 //.\n  by rewrite expn_gt0.\nhave def2r1: (2 * (2 ^ (n - 3)).-1).+1 = r.-1.\n  rewrite -!subn1 mulnBr -expnS [_.+1]subnSK ?(ltn_exp2l 0) //.\n  by rewrite /r -(subnKC n_gt3).\nhave defZ: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> z /setIP[Gz cGz].\n  case X'z: (z \\in G :\\: X).\n    move/eqP: (invXX' _ _ (cycle_id x) X'z).\n    rewrite /conjg -(centP cGz) // mulKg -def2r1 eq_mulVg1 expgS mulKg mulnC.\n    rewrite -order_dvdn Gauss_dvdr // order_dvdn -order_eq1.\n    by rewrite ox2 -(subnKC r_gt2).\n  move/idPn: X'z; rewrite inE Gz andbT negbK => Xz.\n  have:= Ohm_p_cycle 1 (mem_p_elt pG Gx); rewrite ox pfactorK // subn1 => <-.\n  rewrite (OhmE _ (mem_p_elt pG Gx)) mem_gen // !inE Xz /=.\n  rewrite -(expgK coXr1 Xz) -!expgM mulnCA -order_dvdn dvdn_mull //.\n  rewrite mulnC order_dvdn -(inj_eq (mulgI z)) -expgS mulg1 def2r1.\n  by rewrite -(invXX' z y) // /conjg (centP cGz) ?mulKg.\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -(expgK coXr1 (mem_cycle _ _)) groupX //.\n  rewrite -expgM expnSr -mulnA expgM -(mulKg (x ^+ (2 ^ i)) (_ ^+ _)).\n  by rewrite -expgS def2r1 -(invXX' _ y) ?mem_cycle ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X).\n    by case/cycleP: Xz => i ->; rewrite -expgM mulnC expgM mem_cycle.\n  have{Xz Gz} [xi Xxi ->{z}]: exists2 xi, xi \\in X & z = xi * y.\n    have Uvy: y \\in <[u]> :* v by rewrite defUv -(defU x).\n    apply/rcosetP; rewrite /X defU // (rcoset_eqP Uvy) defUv.\n    by rewrite inE -(defU x) ?Xz.\n  rewrite expn1 expgS {2}(conjgC xi) -{2}[y]/(y ^+ 2.-1) -{1}oy -invg_expg.\n  rewrite mulgA mulgK invXX' // -expgS prednK // /r -(subnKC n_gt3) expnS.\n  by case/cycleP: Xxi => i ->; rewrite -expgM mulnCA expgM mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^+ r.-2 * t}.\n    move=> z Xz /=; rewrite -(mulKg z (z ^+ _)) -expgS -subn2.\n    have X'tV: t^-1 \\in G :\\: X by rewrite inE !groupV notXt.\n    by rewrite subnSK 1?ltnW // subn1 -(invXX' _ t^-1) // -mulgA -conjgCV.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> t' z; case/cycleP=> j -> Xz -> -> {t' t'z tz}.\n    exists (z ^+ r.-2); last first.\n      by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite -def2r1 -expgM mulnCA expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}.\n  exists (x ^+ (i * expg_invn X (2 ^ (n - 3)).-1)); first by rewrite groupX.\n  rewrite defJt ?mem_cycle // -def2r1 -!expgM.\n  by rewrite mulnAC mulnA mulnC muln2 !expgM expgK ?mem_cycle.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> <*> <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite -defMt // -(Lagrange (joing_subl _ _)) -orderE ox2 -def2r mulnC.\n  congr (_ * r)%N; rewrite -card_quotient /=; last first.\n    by rewrite defMt // (subset_trans _ (nXiG 2)) ?sMtG.\n  rewrite joingC quotientYidr ?(subset_trans _ (nXiG 2)) ?cycle_subG //.\n  rewrite quotient_cycle ?(subsetP (nXiG 2)) //= -defPhi -orderE.\n  rewrite (abelem_order_p (Phi_quotient_abelem pG)) ?mem_quotient //.\n  apply: contraNneq notXt; move/coset_idr; move/implyP=> /=.\n  by rewrite /= defPhi (subsetP (nXiG 2)) //; apply: subsetP; apply: cycleX.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't /=; rewrite p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nsplit.\n- by rewrite sdprodE // setIC prime_TIg ?cycle_subG // -orderE oy.\n- rewrite defG'; split=> //.\n  apply/eqP; rewrite eqn_leq (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // -(subnKC n_gt3).\n  rewrite -(subnKC (ltnW (ltnW n_gt3))) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- rewrite defZ; split=> //; last exact: extend_cyclic_Mho.\n  split; apply/eqP; last first.\n    have sX'G2: {subset G :\\: X <= 'Ohm_2(G)}.\n      move=> t X't; have [Gt _] := setDP X't; rewrite -defX' in X't.\n      rewrite (OhmE 2 pG) mem_gen // !inE Gt -order_dvdn.\n      by case/setUP: X't; case/imsetP=> z _ ->; rewrite orderJ ?oy ?oxy.\n    rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n    by rewrite -(groupMr _ (sX'G2 y X'y)) !sX'G2.\n  rewrite eqEsubset andbC gen_subG class_sub_norm ?gFnorm //.\n  rewrite (OhmE 1 pG) mem_gen ?inE ?Gy -?order_dvdn ?oy // gen_subG /= -/My.\n  apply/subsetP=> t /[!inE]; case/andP=> Gt t2.\n  have pX := pgroupS sXG pG.\n  case Xt: (t \\in X).\n    have: t \\in 'Ohm_1(X) by rewrite (OhmE 1 pX) mem_gen // !inE Xt.\n    apply: subsetP; rewrite (Ohm_p_cycle 1 pX) ox pfactorK //.\n    rewrite -(subnKC n_gt3) expgM (subset_trans (cycleX _ _)) //.\n    by rewrite /My -defMt ?joing_subl.\n  have{Xt}: t \\in yG :|: xyG by rewrite defX' inE Xt.\n  case/setUP; first exact: mem_gen.\n  by case/imsetP=> z _ def_t; rewrite -order_dvdn def_t orderJ oxy in t2.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => t Ht notXt.\n  have: t \\in yG :|: xyG by rewrite defX' inE notXt (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP=> /class_eqP <-; rewrite !class_sub_norm ?Ht ?orbT.\nhave n1_gt2: n.-1 > 2 by [rewrite -(subnKC n_gt3)]; have n1_gt1 := ltnW n1_gt2.\nrewrite !isogEcard card_2dihedral ?card_quaternion ?oMt // leqnn !andbT.\nhave invX2X': {in G :\\: X, forall t, x ^+ 2 ^ t == x ^- 2}.\n  move=> t X't; rewrite /= invXX' ?mem_cycle // eq_sym eq_invg_mul -expgS.\n  by rewrite prednK // -order_dvdn ox2.\n  rewrite Grp_2dihedral ?Grp_quaternion //; split=> [||C].\n- apply/existsP; exists (x ^+ 2, y); rewrite /= defMt // !xpair_eqE.\n  by rewrite -!expgM def2r -!order_dvdn ox oy dvdnn eqxx /= invX2X'.\n- apply/existsP; exists (x ^+ 2, x * y); rewrite /= defMt // !xpair_eqE.\n  rewrite -!expgM def2r -order_dvdn ox xy2 dvdnn eqxx invX2X' //=.\n  by rewrite andbT /r -(subnKC n_gt3).\ncase/cyclicP=> z ->{C} sCG iCG; rewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed.",
    "Theorem extremal2_structure (gT : finGroupType) (G : {group gT}) n x y :\n  let cG := extremal_class G in\n  let m := (2 ^ n)%N in let q := (2 ^ n.-1)%N in let r := (2 ^ n.-2)%N in\n  let X := <[x]> in let yG := y ^: G in let xyG := (x * y) ^: G in\n  let My := <<yG>> in let Mxy := <<xyG>> in\n     extremal_generators G 2 n (x, y) ->\n     extremal2 G -> (cG == SemiDihedral) ==> (#[y] == 2) ->\n [/\\ [/\\ (if cG == Quaternion then pprod X <[y]> else X ><| <[y]>) = G,\n         if cG == SemiDihedral then #[x * y] = 4 else\n           {in G :\\: X, forall z, #[z] = (if cG == Dihedral then 2 else 4)},\n         if cG != Quaternion then True else\n         {in G, forall z, #[z] = 2 -> z = x ^+ r}\n       & {in X & G :\\: X, forall t z,\n            t ^ z = (if cG == SemiDihedral then t ^+ r.-1 else t^-1)}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ if n > 2 then 'Z(G) = <[x ^+ r]> /\\ #|'Z(G)| = 2 else 2.-abelem G,\n          'Ohm_1(G) = (if cG == Quaternion then <[x ^+ r]> else\n                       if cG == SemiDihedral then My else G),\n          'Ohm_2(G) = G\n        & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n     [/\\ yG :|: xyG = G :\\: X, [disjoint yG & xyG]\n       & forall H : {group gT}, maximal H G = (gval H \\in pred3 X My Mxy)]\n   & if n <= (cG == Quaternion) + 2 then True else\n     [/\\ forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X,\n         if cG == Quaternion then My \\isog 'Q_q else My \\isog 'D_q,\n         extremal_class My = (if cG == Quaternion then cG else Dihedral),\n         if cG == Dihedral then Mxy \\isog 'D_q else Mxy \\isog 'Q_q\n       & extremal_class Mxy = (if cG == Dihedral then cG else Quaternion)]].\nProof.\nmove=> cG m q r X yG xyG My Mxy genG; have [oG _ _ _] := genG.\nhave logG: logn (pdiv #|G|) #|G| = n by rewrite oG pfactorKpdiv.\nrewrite /extremal2 -/cG; do [rewrite {1}/extremal_class /= {}logG] in cG *.\ncase: ifP => [isoG | _] in cG * => [_ _ /=|].\n  case/andP: isoG => n_gt1 isoG.\n  have:= dihedral2_structure n_gt1 genG isoG; rewrite -/X -/q -/r -/yG -/xyG.\n  case=> [[defG oX' invXX'] nilG [defOhm defMho] maxG defZ].\n  rewrite eqn_leq n_gt1 andbT add0n in defZ *; split=> //.\n    split=> //; first by case: leqP defZ => // _ [].\n    by apply/eqP; rewrite eqEsubset Ohm_sub -{1}defOhm Ohm_leq.\n  case: leqP defZ => // n_gt2 [_ _ isoMy isoMxy defX].\n  have n1_gt1: n.-1 > 1 by rewrite -(subnKC n_gt2).\n  by split=> //; apply/dihedral_classP; exists n.-1.\ncase: ifP => [isoG | _] in cG * => [_ _ /=|].\n  case/andP: isoG => n_gt2 isoG; rewrite n_gt2 add1n.\n  have:= quaternion_structure n_gt2 genG isoG; rewrite -/X -/q -/r -/yG -/xyG.\n  case=> [[defG oX' invXX'] nilG [defZ oZ def2 [-> ->] defMho]].\n  case=> [[-> ->] maxG] isoM; split=> //.\n  case: leqP isoM => // n_gt3 [//|isoMy isoMxy defX].\n  have n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\n  by split=> //; apply/quaternion_classP; exists n.-1.\ndo [case: ifP => [isoG | _]; last by case: ifP] in cG * => /= _; move/eqnP=> oy.\ncase/andP: isoG => n_gt3 isoG; rewrite (leqNgt n) (ltnW n_gt3) /=.\nhave n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\nhave:= semidihedral_structure n_gt3 genG isoG oy.\nrewrite -/X -/q -/r -/yG -/xyG -/My -/Mxy.\ncase=> [[defG oxy invXX'] nilG [defZ oZ [-> ->] defMho] [[defX' tiX'] maxG]].\ncase=> isoMy isoMxy defX; do 2!split=> //.\n  by apply/dihedral_classP; exists n.-1; first apply: ltnW.\nby apply/quaternion_classP; exists n.-1.\nQed.",
    "Theorem symplectic_type_group_structure gT p (G : {group gT}) :\n    p.-group G -> (forall X : {group gT}, X \\char G -> abelian X -> cyclic X) ->\n  exists2 E : {group gT}, E :=: 1 \\/ extraspecial E\n  & exists R : {group gT},\n    [/\\ cyclic R \\/ [/\\ p = 2, extremal2 R & #|R| >= 16],\n        E \\* R = G\n      & E :&: R = 'Z(E)].\nProof.\nmove=> pG sympG; have [H [charH]] := Thompson_critical pG.\nhave sHG := char_sub charH; have pH := pgroupS sHG pG.\nset U := 'Z(H) => sPhiH_U sHG_U defU; set Z := 'Ohm_1(U).\nhave sZU: Z \\subset U by rewrite Ohm_sub.\nhave charU: U \\char G := gFchar_trans _ charH.\nhave cUU: abelian U := center_abelian H.\nhave cycU: cyclic U by apply: sympG.\nhave pU: p.-group U := pgroupS (char_sub charU) pG.\nhave cHU: U \\subset 'C(H) by rewrite subsetIr.\nhave cHsHs: abelian (H / Z).\n  rewrite sub_der1_abelian //= (OhmE _ pU) genS //= -/U.\n  apply/subsetP=> _ /imset2P[h k Hh Hk ->].\n  have Uhk: [~ h, k] \\in U by rewrite (subsetP sHG_U) ?mem_commg ?(subsetP sHG).\n  rewrite inE Uhk inE -commXg; last by red; rewrite -(centsP cHU).\n  apply/commgP; red; rewrite (centsP cHU) // (subsetP sPhiH_U) //.\n  by rewrite (Phi_joing pH) mem_gen // inE orbC (Mho_p_elt 1) ?(mem_p_elt pH).\nhave nsZH: Z <| H by rewrite sub_center_normal.\nhave [K /=] := inv_quotientS nsZH (Ohm_sub 1 (H / Z)); fold Z => defKs sZK sKH.\nhave nsZK: Z <| K := normalS sZK sKH nsZH; have [_ nZK] := andP nsZK.\nhave abelKs: p.-abelem (K / Z) by rewrite -defKs Ohm1_abelem ?quotient_pgroup.\nhave charK: K \\char G.\n  have charZ: Z \\char H := gFchar_trans _ (center_char H).\n  rewrite (char_trans _ charH) // (char_from_quotient nsZK) //.\n  by rewrite -defKs Ohm_char.\nhave cycZK: cyclic 'Z(K) by rewrite sympG ?center_abelian ?gFchar_trans.\nhave [cKK | not_cKK] := orP (orbN (abelian K)).\n  have defH: U = H.\n    apply: center_idP; apply: cyclic_factor_abelian (Ohm_sub 1 _) _.\n    rewrite /= -/Z abelian_rank1_cyclic //.\n    have cKsKs: abelian (K / Z) by rewrite -defKs (abelianS (Ohm_sub 1 _)).\n    have cycK: cyclic K by rewrite -(center_idP cKK).\n    by rewrite -rank_Ohm1 defKs -abelian_rank1_cyclic ?quotient_cyclic.\n  have scH: H \\in 'SCN(G) by apply/SCN_P; rewrite defU char_normal.\n  have [cGG | not_cGG] := orP (orbN (abelian G)).\n    exists 1%G; [by left | exists G; rewrite cprod1g (setIidPl _) ?sub1G //].\n    by split; first left; rewrite ?center1 // sympG ?char_refl.\n  have cycH: cyclic H by rewrite -{}defH.\n  have [[p2 _ cG2]|[M [_ _ _]]] := cyclic_SCN pG scH not_cGG cycH; last first.\n    do 2![case/setIdP] => _ abelE dimE_2 charE.\n    have:= sympG _ charE (abelem_abelian abelE).\n    by rewrite (abelem_cyclic abelE) (eqP dimE_2).\n  have [n oG] := p_natP pG; rewrite p2 in oG.\n  have [n_gt3 | n_le3] := ltnP 3 n.\n    exists 1%G; [by left | exists G; rewrite cprod1g (setIidPl _) ?sub1G //].\n    by split; first right; rewrite ?center1 // oG (@leq_exp2l 2 4).\n  have esG: extraspecial G.\n    by apply: (p3group_extraspecial pG); rewrite // p2 oG pfactorK.\n  exists G; [by right | exists ('Z(G))%G; rewrite cprod_center_id setIA setIid].\n  by split=> //; left; rewrite prime_cyclic; case: esG.\nhave ntK: K :!=: 1 by apply: contra not_cKK => /eqP->; apply: abelian1.\nhave [p_pr _ _] := pgroup_pdiv (pgroupS sKH pH) ntK.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave oZ: #|Z| = p.\n  apply: Ohm1_cyclic_pgroup_prime => //=; apply: contra ntK; move/eqP.\n  by move/(trivg_center_pgroup pH)=> GH; rewrite -subG1 -GH.\nhave sZ_ZK: Z \\subset 'Z(K).\n  by rewrite subsetI sZK gFsub_trans // subIset ?centS ?orbT.\nhave sZsKs: 'Z(K) / Z \\subset K / Z by rewrite quotientS ?center_sub.\nhave [Es /= splitKs] := abelem_split_dprod abelKs sZsKs.\nhave [_ /= defEsZs cEsZs tiEsZs] := dprodP splitKs.\nhave sEsKs: Es \\subset K / Z by rewrite -defEsZs mulG_subr.\nhave [E defEs sZE sEK] := inv_quotientS nsZK sEsKs; rewrite /= -/Z in defEs sZE.\nhave [nZE nZ_ZK] := (subset_trans sEK nZK, subset_trans (center_sub K) nZK).\nhave defK: 'Z(K) * E = K.\n  rewrite -(mulSGid sZ_ZK) -mulgA -quotientK ?mul_subG ?quotientMl //.\n  by rewrite -defEs defEsZs quotientGK.\nhave defZE: 'Z(E) = Z.\n  have cEZK: 'Z(K) \\subset 'C(E) by rewrite subIset // orbC centS.\n  have cE_Z: E \\subset 'C(Z) by rewrite centsC (subset_trans sZ_ZK).\n  apply/eqP; rewrite eqEsubset andbC subsetI sZE centsC cE_Z /=.\n  rewrite -quotient_sub1 ?subIset ?nZE //= -/Z -tiEsZs subsetI defEs.\n  rewrite !quotientS ?center_sub //= subsetI subIset ?sEK //=.\n  by rewrite -defK centM setSI // centsC.\nhave sEH := subset_trans sEK sKH; have pE := pgroupS sEH pH.\nhave esE: extraspecial E.\n  split; last by rewrite defZE oZ.\n  have sPhiZ: 'Phi(E) \\subset Z.\n    rewrite -quotient_sub1 ?gFsub_trans ?(quotient_Phi pE) //.\n    rewrite subG1 (trivg_Phi (quotient_pgroup _ pE)) /= -defEs.\n    by rewrite (abelemS sEsKs) //= -defKs Ohm1_abelem ?quotient_pgroup.\n  have sE'Phi: E^`(1) \\subset 'Phi(E) by rewrite (Phi_joing pE) joing_subl.\n  have ntE': E^`(1) != 1.\n    rewrite (sameP eqP commG1P) -abelianE; apply: contra not_cKK => cEE.\n    by rewrite -defK mulGSid ?center_abelian // -(center_idP cEE) defZE.\n  have defE': E^`(1) = Z.\n    apply/eqP; rewrite eqEcard (subset_trans sE'Phi) //= oZ.\n    have [_ _ [n ->]] := pgroup_pdiv (pgroupS (der_sub _ _) pE) ntE'.\n    by rewrite (leq_exp2l 1) ?prime_gt1.\n  by split; rewrite defZE //; apply/eqP; rewrite eqEsubset sPhiZ -defE'.\nhave [spE _] := esE; have [defPhiE defE'] := spE.\nhave{defE'} sEG_E': [~: E, G] \\subset E^`(1).\n  rewrite defE' defZE /Z (OhmE _ pU) commGC genS //.\n  apply/subsetP=> _ /imset2P[g e Gg Ee ->].\n  have He: e \\in H by rewrite (subsetP sKH) ?(subsetP sEK).\n  have Uge: [~ g, e] \\in U by rewrite (subsetP sHG_U) ?mem_commg.\n  rewrite inE Uge inE -commgX; last by red; rewrite -(centsP cHU).\n  have sZ_ZG: Z \\subset 'Z(G).\n    have charZ: Z \\char G := gFchar_trans _ charU.\n    have/implyP:= meet_center_nil (pgroup_nil pG) (char_normal charZ).\n    rewrite -cardG_gt1 oZ prime_gt1 //=; apply: contraR => not_sZ_ZG.\n    by rewrite prime_TIg ?oZ.\n  have: e ^+ p \\in 'Z(G).\n    rewrite (subsetP sZ_ZG) // -defZE -defPhiE (Phi_joing pE) mem_gen //.\n    by rewrite inE orbC (Mho_p_elt 1) ?(mem_p_elt pE).\n  by case/setIP=> _ /centP cGep; apply/commgP; red; rewrite cGep.\nhave sEG: E \\subset G := subset_trans sEK (char_sub charK).\nset R := 'C_G(E).\nhave{sEG_E'} defG: E \\* R = G by apply: (critical_extraspecial pG).\nhave [_ defER cRE] := cprodP defG.\nhave defH: E \\* 'C_H(E) = H by rewrite -(setIidPr sHG) setIAC (cprod_modl defG).\nhave{defH} [_ defH cRH_E] := cprodP defH.\nhave cRH_RH: abelian 'C_H(E).\n  have sZ_ZRH: Z \\subset 'Z('C_H(E)).\n    rewrite subsetI -{1}defZE setSI //= (subset_trans sZU) // centsC.\n    by rewrite subIset // centsC cHU.\n  rewrite (cyclic_factor_abelian sZ_ZRH) //= -/Z.\n  have defHs: Es \\x ('C_H(E) / Z) = H / Z.\n    rewrite defEs dprodE ?quotient_cents // -?quotientMl ?defH -?quotientGI //=.\n    by rewrite setIA (setIidPl sEH) ['C_E(E)]defZE trivg_quotient.\n  have:= Ohm_dprod 1 defHs; rewrite /= defKs (Ohm1_id (abelemS sEsKs abelKs)).\n  rewrite dprodC; case/dprodP=> _ defEsRHs1 cRHs1Es tiRHs1Es.\n  have sRHsHs: 'C_H(E) / Z \\subset H / Z by rewrite quotientS ?subsetIl.\n  have cRHsRHs: abelian ('C_H(E) / Z) by apply: abelianS cHsHs.\n  have pHs: p.-group (H / Z) by rewrite quotient_pgroup.\n  rewrite abelian_rank1_cyclic // (rank_pgroup (pgroupS sRHsHs pHs)).\n  rewrite p_rank_abelian // -(leq_add2r (logn p #|Es|)) -lognM ?cardG_gt0 //.\n  rewrite -TI_cardMg // defEsRHs1 /= -defEsZs TI_cardMg ?lognM ?cardG_gt0 //.\n  by rewrite leq_add2r -abelem_cyclic ?(abelemS sZsKs) // quotient_cyclic.\nhave{cRH_RH} defRH: 'C_H(E) = U.\n  apply/eqP; rewrite eqEsubset andbC setIS ?centS // subsetI subsetIl /=.\n  by rewrite -{2}defH centM subsetI subsetIr.\nhave scUR: 'C_R(U) = U by rewrite -setIA -{1}defRH -centM defH.\nhave sUR: U \\subset R by rewrite -defRH setSI.\nhave tiER: E :&: R = 'Z(E) by rewrite setIA (setIidPl (subset_trans sEH sHG)).\nhave [cRR | not_cRR] := boolP (abelian R).\n  exists E; [by right | exists [group of R]; split=> //; left].\n  by rewrite /= -(setIidPl (sub_abelian_cent cRR sUR)) scUR.\nhave{} scUR: [group of U] \\in 'SCN(R).\n  by apply/SCN_P; rewrite (normalS sUR (subsetIl _ _)) // char_normal.\nhave pR: p.-group R := pgroupS (subsetIl _ _) pG.\nhave [R_le_3 | R_gt_3] := leqP (logn p #|R|) 3.\n  have esR: extraspecial R := p3group_extraspecial pR not_cRR R_le_3.\n  have esG: extraspecial G := cprod_extraspecial pG defG tiER esE esR.\n  exists G; [by right | exists ('Z(G))%G; rewrite cprod_center_id setIA setIid].\n  by split=> //; left; rewrite prime_cyclic; case: esG.\nhave [[p2 _ ext2R] | [M []]] := cyclic_SCN pR scUR not_cRR cycU.\n  exists E; [by right | exists [group of R]; split=> //; right].\n  by rewrite dvdn_leq ?(@pfactor_dvdn 2 4) ?cardG_gt0 // -{2}p2.\nrewrite /= -/R => defM iUM modM _ _; pose N := 'C_G('Mho^1(U)).\nhave charZN2: 'Z('Ohm_2(N)) \\char G by rewrite !(gFchar_trans, subcent_char).\nhave:= sympG _ charZN2 (center_abelian _).\nrewrite abelian_rank1_cyclic ?center_abelian // leqNgt; case/negP.\nhave defN: E \\* M = N.\n  rewrite defM (cprod_modl defG) // centsC gFsub_trans //= -/U.\n  by rewrite -defRH subsetIr.\ncase/modular_group_classP: modM => q q_pr [n n_gt23 isoM].\nhave{n_gt23} n_gt2 := leq_trans (leq_addl _ _) n_gt23.\nhave n_gt1 := ltnW n_gt2; have n_gt0 := ltnW n_gt1.\nhave [[x y] genM modM] := generators_modular_group q_pr n_gt2 isoM.\nhave{q_pr} defq: q = p; last rewrite {q}defq in genM modM isoM.\n  have: p %| #|M| by rewrite -iUM dvdn_indexg.\n  by have [-> _ _ _] := genM; rewrite Euclid_dvdX // dvdn_prime2 //; case: eqP.\nhave [oM Mx ox X'y] := genM; have [My _] := setDP X'y; have [oy _] := modM.\nhave [sUM sMR]: U \\subset M /\\ M \\subset R.\n  by rewrite defM subsetI sUR subsetIl centsC gFsub_trans.\nhave oU1: #|'Mho^1(U)| = (p ^ n.-2)%N.\n  have oU: #|U| = (p ^ n.-1)%N.\n    by rewrite -(divg_indexS sUM) iUM oM -subn1 expnB.\n  case/cyclicP: cycU pU oU => u -> p_u ou.\n  by rewrite (Mho_p_cycle 1 p_u) -orderE (orderXexp 1 ou) subn1.\nhave sZU1: Z \\subset 'Mho^1(U).\n  rewrite -(cardSg_cyclic cycU) ?gFsub // oZ oU1.\n  by rewrite -(subnKC n_gt2) expnS dvdn_mulr.\ncase/modular_group_structure: genM => // _ [defZM _ oZM] _ _.\nhave:= n_gt2; rewrite leq_eqVlt eq_sym !xpair_eqE andbC.\ncase: eqP => [n3 _ _ | _ /= n_gt3 defOhmM].\n  have eqZU1: Z = 'Mho^1(U) by apply/eqP; rewrite eqEcard sZU1 oZ oU1 n3 /=.\n  rewrite (setIidPl _) in defM; first by rewrite -defM oM n3 pfactorK in R_gt_3.\n  by rewrite -eqZU1 subIset ?centS ?orbT.\nhave{defOhmM} [|defM2 _] := defOhmM 2; first by rewrite -subn1 ltn_subRL.\ndo [set xpn3 := x ^+ _; set X2 := <[_]>] in defM2.\nhave oX2: #|X2| = (p ^ 2)%N.\n  by rewrite -orderE (orderXexp _ ox) -{1}(subnKC n_gt2) addSn addnK.\nhave sZX2: Z \\subset X2.\n  have cycXp: cyclic <[x ^+ p]> := cycle_cyclic _.\n  rewrite -(cardSg_cyclic cycXp) /=; first by rewrite oZ oX2 dvdn_mull.\n    rewrite -defZM subsetI (subset_trans (Ohm_sub _ _)) //=.\n    by rewrite (subset_trans sZU1) // centsC defM subsetIr.\n  by rewrite /xpn3 -subnSK //expnS expgM cycleX.\nhave{defM2} [_ /= defM2 cYX2 tiX2Y] := dprodP defM2.\nhave{defN} [_ defN cME] := cprodP defN.\nhave cEM2: E \\subset 'C('Ohm_2(M)).\n  by rewrite centsC (subset_trans _ cME) ?centS ?Ohm_sub.\nhave [cEX2 cYE]: X2 \\subset 'C(E) /\\ E \\subset 'C(<[y]>).\n by apply/andP; rewrite centsC -subsetI -centM defM2.\nhave pN: p.-group N := pgroupS (subsetIl _ _) pG.\nhave defN2: (E <*> X2) \\x <[y]> = 'Ohm_2(N).\n  rewrite dprodE ?centY ?subsetI 1?centsC ?cYE //=; last first.\n    rewrite -cycle_subG in My; rewrite joingC cent_joinEl //= -/X2.\n    rewrite -(setIidPr My) setIA -group_modl ?cycle_subG ?groupX //.\n    by rewrite mulGSid // (subset_trans _ sZX2) // -defZE -tiER setIS.\n  apply/eqP; rewrite cent_joinEr // -mulgA defM2 eqEsubset mulG_subG.\n  rewrite OhmS ?andbT; last by rewrite -defN mulG_subr.\n  have expE: exponent E %| p ^ 2 by rewrite exponent_special ?(pgroupS sEG).\n  rewrite /= (OhmE 2 pN) sub_gen /=; last 1 first.\n    by rewrite subsetI -defN mulG_subl sub_LdivT expE.\n  rewrite -cent_joinEl // -genM_join genS // -defN.\n  apply/subsetP=> _ /setIP[/imset2P[e z Ee Mz ->]].\n  rewrite inE expgMn; last by red; rewrite -(centsP cME).\n  rewrite (exponentP expE) // mul1g => zp2; rewrite mem_mulg //=.\n  by rewrite (OhmE 2 (pgroupS sMR pR)) mem_gen // !inE Mz.\nhave{defN2} defZN2: X2 \\x <[y]> = 'Z('Ohm_2(N)).\n  rewrite -[X2](mulSGid sZX2) /= -/Z -defZE -(center_dprod defN2).\n  do 2!rewrite -{1}(center_idP (cycle_abelian _)) -/X2; congr (_ \\x _).\n  by case/cprodP: (center_cprod (cprodEY cEX2)).\nhave{defZN2} strZN2: \\big[dprod/1]_(z <- [:: xpn3; y]) <[z]> = 'Z('Ohm_2(N)).\n  by rewrite unlock /= dprodg1.\nrewrite -size_abelian_type ?center_abelian //.\nhave pZN2: p.-group 'Z('Ohm_2(N)) by rewrite (pgroupS _ pN) // subIset ?Ohm_sub.\nrewrite (perm_size (abelian_type_pgroup pZN2 strZN2 _)) //= !inE.\nrewrite !(eq_sym 1) -!order_eq1 oy orderE oX2.\nby rewrite (eqn_exp2l 2 0) // (eqn_exp2l 1 0).\nQed.",
    "Theorem abelian_charsimple_special :\n    p.-group G -> coprime #|G| #|A| -> [~: G, A] = G ->\n    \\bigcup_(H : {group gT} | (H \\char G) && abelian H) H \\subset 'C(A) ->\n  special G /\\ 'C_G(A) = 'Z(G).\nProof.\nmove=> pG coGA defG /bigcupsP cChaA.\nhave cZA: 'Z(G) \\subset 'C_G(A).\n  by rewrite subsetI center_sub cChaA // center_char center_abelian.\nhave cChaG (H : {group gT}): H \\char G -> abelian H -> H \\subset 'Z(G).\n  move=> chH abH; rewrite subsetI char_sub //= centsC -defG.\n  rewrite comm_norm_cent_cent ?(char_norm chH) -?commg_subl ?defG //.\n  by rewrite centsC cChaA ?chH.\nhave cZ2GG: [~: 'Z_2(G), G, G] = 1.\n  by apply/commG1P; rewrite (subset_trans (ucn_comm 1 G)) // ucn1 subsetIr.\nhave{cZ2GG} cG'Z: 'Z_2(G) \\subset 'C(G^`(1)).\n  by rewrite centsC; apply/commG1P; rewrite three_subgroup // (commGC G).\nhave{cG'Z} sZ2G'_Z: 'Z_2(G) :&: G^`(1) \\subset 'Z(G).\n  apply: cChaG; first by rewrite charI ?ucn_char ?der_char.\n  by rewrite /abelian subIset // (subset_trans cG'Z) // centS ?subsetIr.\nhave{sZ2G'_Z} sG'Z: G^`(1) \\subset 'Z(G).\n  rewrite der1_min ?gFnorm //; apply/derG1P.\n  have /TI_center_nil: nilpotent (G / 'Z(G)) := quotient_nil _ (pgroup_nil pG).\n  apply; first exact: gFnormal; rewrite /= setIC -ucn1 -ucn_central.\n  rewrite -quotient_der ?gFnorm // -quotientGI ?ucn_subS ?quotientS1 //=.\n  by rewrite ucn1.\nhave sCG': 'C_G(A) \\subset G^`(1).\n  rewrite -quotient_sub1 //; last by rewrite subIset ?gFnorm.\n  rewrite (subset_trans (quotient_subcent _ G A)) //= -[G in G / _]defG.\n  have nGA: A \\subset 'N(G) by rewrite -commg_subl defG.\n  rewrite quotientR ?gFnorm_trans ?normG //.\n  rewrite coprime_abel_cent_TI ?quotient_norms ?coprime_morph //.\n  exact: sub_der1_abelian.\nhave defZ: 'Z(G) = G^`(1) by apply/eqP; rewrite eqEsubset (subset_trans cZA).\nsplit; last by apply/eqP; rewrite eqEsubset cZA defZ sCG'.\nsplit=> //; apply/eqP; rewrite eqEsubset defZ (Phi_joing pG) joing_subl.\nhave:= pG; rewrite -pnat_exponent => /p_natP[n expGpn].\nrewrite join_subG subxx andbT /= -defZ -(subnn n.-1).\nelim: {2}n.-1 => [|m IHm].\n  rewrite (MhoE _ pG) gen_subG; apply/subsetP=> _ /imsetP[x Gx ->].\n  rewrite subn0 -subn1 -add1n -maxnE maxnC maxnE expnD.\n  by rewrite expgM -expGpn expg_exponent ?groupX ?group1.\nrewrite cChaG ?Mho_char //= (MhoE _ pG) /abelian cent_gen gen_subG.\napply/centsP=> _ /imsetP[x Gx ->] _ /imsetP[y Gy ->].\nmove: sG'Z; rewrite subsetI centsC => /andP[_ /centsP cGG'].\napply/commgP; rewrite {1}expnSr expgM.\nrewrite commXg -?commgX; try by apply: cGG'; rewrite ?mem_commg ?groupX.\napply/commgP; rewrite subsetI Mho_sub centsC in IHm.\napply: (centsP IHm); first by rewrite groupX.\nrewrite -add1n -(addn1 m) subnDA -maxnE maxnC maxnE.\nrewrite -expgM -expnSr -addSn expnD expgM groupX //=.\nby rewrite Mho_p_elt ?(mem_p_elt pG).\nQed.",
    "Theorem extraspecial_structure S : p.-group S -> extraspecial S ->\n  {Es | all (fun E => (#|E| == p ^ 3)%N && ('Z(E) == 'Z(S))) Es\n      & \\big[cprod/1%g]_(E <- Es) E \\* 'Z(S) = S}.\nProof.\nhave [m] := ubnP #|S|; elim: m S => // m IHm S leSm pS esS.\nhave [x Z'x]: {x | x \\in S :\\: 'Z(S)}.\n  apply/sigW/set0Pn; rewrite -subset0 subDset setU0.\n  apply: contra (extraspecial_nonabelian esS) => sSZ.\n  exact: abelianS sSZ (center_abelian S).\nhave [E [R [[oE oR]]]]:= split1_extraspecial pS esS Z'x.\ncase=> defS _ [defZE defZR] _; case: ifP => [_ defR | _ esR].\n  by exists [:: E]; rewrite /= ?oE ?defZE ?eqxx // big_seq1 -defR.\nhave sRS: R \\subset S by case/cprodP: defS => _ <- _; rewrite mulG_subr.\nhave [|Es esEs defR] := IHm _ _ (pgroupS sRS pS) esR.\n  rewrite oR (leq_trans (ltn_Pdiv _ _)) ?cardG_gt0 // (ltn_exp2l 0) //.\n  exact: prime_gt1 (extraspecial_prime pS esS).\nexists (E :: Es); first by rewrite /= oE defZE !eqxx -defZR.\nby rewrite -defZR big_cons -cprodA defR.\nQed.",
    "Theorem stab_ntransitive m x :\n    0 < m -> x \\in S -> [transitive^m.+1 G, on S | to] ->\n  [transitive^m 'C_G[x | to], on S :\\ x | to].\nProof.\nmove=> m_gt0 Sx Gtr; have sSxS: S :\\ x \\subset S by rewrite subsetDl.\ncase: (imsetP Gtr); case/tupleP=> x1 t1; rewrite dtuple_on_add.\ncase/and3P=> Sx1 nt1x1 dt1 trt1; have Gtr1 := ntransitive1 (ltn0Sn _) Gtr.\ncase: (atransP2 Gtr1 Sx1 Sx) => // a Ga x1ax.\npose t := n_act to t1 a.\nhave dxt: [tuple of x :: t] \\in m.+1.-dtuple(S).\n  by rewrite trt1 x1ax; apply/imsetP; exists a => //; apply: val_inj.\napply/imsetP; exists t; first by rewrite dtuple_on_add_D1 Sx in dxt.\napply/setP=> t2; apply/idP/imsetP => [dt2|[b]].\n  have: [tuple of x :: t2] \\in dtuple_on _ S by rewrite dtuple_on_add_D1 Sx.\n  case/(atransP2 Gtr dxt)=> b Gb [xbx tbt2].\n  by exists b; [rewrite inE Gb; apply/astab1P | apply: val_inj].\ncase/setIP=> Gb /astab1P xbx ->{t2}.\nrewrite n_act_dtuple //; last by rewrite dtuple_on_add_D1 Sx in dxt.\napply/astabsP=> y; rewrite !inE -{1}xbx (inj_eq (act_inj _ _)).\nby rewrite (actsP (atrans_acts Gtr1)).\nQed.",
    "Theorem stab_ntransitiveI m x :\n     x \\in S -> [transitive G, on S | to] ->\n     [transitive^m 'C_G[x | to], on S :\\ x | to] ->\n  [transitive^m.+1 G, on S | to].\nProof.\nmove=> Sx Gtr Gntr.\nhave t_to_x t: t \\in m.+1.-dtuple(S) ->\n  exists2 a, a \\in G & exists2 t', t' \\in m.-dtuple(S :\\ x)\n                                 & t = n_act to [tuple of x :: t'] a.\n- case/tupleP: t => y t St.\n  have Sy: y \\in S by rewrite dtuple_on_add_D1 in St; case/andP: St.\n  rewrite -(atransP Gtr _ Sy) in Sx; case/imsetP: Sx => a Ga toya.\n  exists a^-1; first exact: groupVr.\n  exists (n_act to t a); last by rewrite n_act_add toya !actK.\n  move/(n_act_dtuple (subsetP (atrans_acts Gtr) a Ga)): St.\n  by rewrite n_act_add -toya dtuple_on_add_D1 => /andP[].\ncase: (imsetP Gntr) => t dt S_tG; pose xt := [tuple of x :: t].\nhave dxt: xt \\in m.+1.-dtuple(S) by rewrite dtuple_on_add_D1 Sx.\napply/imsetP; exists xt => //; apply/setP=> t2.\napply/esym; apply/imsetP/idP=> [[a Ga ->] | ].\n  by apply: n_act_dtuple; rewrite // (subsetP (atrans_acts Gtr)).\ncase/t_to_x=> a2 Ga2 [t2']; rewrite S_tG.\ncase/imsetP=> a /setIP[Ga /astab1P toxa] -> -> {t2 t2'}.\nby exists (a * a2); rewrite (groupM, actM) //= !n_act_add toxa.\nQed.",
    "Theorem SchurZassenhaus_split gT (G H : {group gT}) :\n  Hall G H -> H <| G -> [splits G, over H].\nProof.\nhave [n] := ubnP #|G|; elim: n => // n IHn in gT G H * => /ltnSE-Gn hallH nsHG.\nhave [sHG nHG] := andP nsHG.\nhave [-> | [p pr_p pH]] := trivgVpdiv H.\n  by apply/splitsP; exists G; rewrite inE -subG1 subsetIl mul1g eqxx.\nhave [P sylP] := Sylow_exists p H.\ncase nPG: (P <| G); last first.\n  pose N := ('N_G(P))%G; have sNG: N \\subset G by rewrite subsetIl.\n  have eqHN_G: H * N = G by apply: Frattini_arg sylP.\n  pose H' := (H :&: N)%G.\n  have nsH'N: H' <| N.\n    by rewrite /normal subsetIr normsI ?normG ?(subset_trans sNG).\n  have eq_iH: #|G : H| = #|N| %/ #|H'|.\n    rewrite -divgS // -(divnMl (cardG_gt0 H')) mulnC -eqHN_G.\n    by rewrite -mul_cardG (mulnC #|H'|) divnMl // cardG_gt0.\n  have hallH': Hall N H'.\n    rewrite /Hall -divgS subsetIr //= -eq_iH.\n    by case/andP: hallH => _; apply: coprimeSg; apply: subsetIl.\n  have: [splits N, over H'].\n    apply: IHn hallH' nsH'N; apply: {n}leq_trans Gn.\n    rewrite proper_card // properEneq sNG andbT; apply/eqP=> eqNG.\n    by rewrite -eqNG normal_subnorm (subset_trans (pHall_sub sylP)) in nPG.\n  case/splitsP=> K /complP[tiKN eqH'K].\n  have sKN: K \\subset N by rewrite -(mul1g K) -eqH'K mulSg ?sub1set.\n  apply/splitsP; exists K; rewrite inE -subG1; apply/andP; split.\n    by rewrite /= -(setIidPr sKN) setIA tiKN.\n  by rewrite eqEsubset -eqHN_G mulgS // -eqH'K mulGS mulSg ?subsetIl.\npose Z := 'Z(P); pose Gbar := G / Z; pose Hbar := H / Z.\nhave sZP: Z \\subset P by apply: center_sub.\nhave sZH: Z \\subset H by apply: subset_trans (pHall_sub sylP).\nhave sZG: Z \\subset G by apply: subset_trans sHG.\nhave nZG: Z <| G by apply: gFnormal_trans nPG.\nhave nZH: Z <| H by apply: normalS nZG.\nhave nHGbar: Hbar <| Gbar by apply: morphim_normal.\nhave hallHbar: Hall Gbar Hbar by apply: morphim_Hall (normal_norm _) _.\nhave: [splits Gbar, over Hbar].\n  apply: IHn => //; apply: {n}leq_trans Gn; rewrite ltn_quotient //.\n  apply/eqP=> /(trivg_center_pgroup (pHall_pgroup sylP))/eqP.\n  rewrite trivg_card1 (card_Hall sylP) p_part -(expn0 p).\n  by rewrite eqn_exp2l ?prime_gt1 // lognE pH pr_p cardG_gt0.\ncase/splitsP=> Kbar /complP[tiHKbar eqHKbar].\nhave: Kbar \\subset Gbar by rewrite -eqHKbar mulG_subr.\ncase/inv_quotientS=> //= ZK quoZK sZZK sZKG.\nhave nZZK: Z <| ZK by apply: normalS nZG.\nhave cardZK: #|ZK| = (#|Z| * #|G : H|)%N.\n  rewrite -(Lagrange sZZK); congr (_ * _)%N.\n  rewrite -card_quotient -?quoZK; last by case/andP: nZZK.\n  rewrite -(divgS sHG) -(Lagrange sZG) -(Lagrange sZH) divnMl //.\n  rewrite -!card_quotient ?normal_norm //= -/Gbar -/Hbar.\n  by rewrite -eqHKbar (TI_cardMg tiHKbar) mulKn.\nhave: [splits ZK, over Z].\n  rewrite (Gaschutz_split nZZK _ sZZK) ?center_abelian //; last first.\n    rewrite -divgS // cardZK mulKn ?cardG_gt0 //.\n    by case/andP: hallH => _; apply: coprimeSg.\n  by apply/splitsP; exists 1%G; rewrite inE -subG1 subsetIr mulg1 eqxx.\ncase/splitsP=> K /complP[tiZK eqZK].\nhave sKZK: K \\subset ZK by rewrite -(mul1g K) -eqZK mulSg ?sub1G.\nhave tiHK: H :&: K = 1.\n  apply/trivgP; rewrite /= -(setIidPr sKZK) setIA -tiZK setSI //.\n  rewrite -quotient_sub1; last by rewrite subIset 1?normal_norm.\n  by rewrite /= quotientGI //= -quoZK tiHKbar.\napply/splitsP; exists K; rewrite inE tiHK ?eqEcard subxx leqnn /=.\nrewrite mul_subG ?(subset_trans sKZK) //= TI_cardMg //.\nrewrite -(@mulKn #|K| #|Z|) ?cardG_gt0 // -TI_cardMg // eqZK.\nby rewrite cardZK mulKn ?cardG_gt0 // Lagrange.\nQed.",
    "Theorem SchurZassenhaus_trans_sol gT (H K K1 : {group gT}) :\n    solvable H -> K \\subset 'N(H) -> K1 \\subset H * K ->\n    coprime #|H| #|K| -> #|K1| = #|K| ->\n  exists2 x, x \\in H & K1 :=: K :^ x.\nProof.\nhave [n] := ubnP #|H|.\nelim: n => // n IHn in gT H K K1 * => /ltnSE-leHn solH nHK.\nhave [-> | ] := eqsVneq H 1.\n  rewrite mul1g => sK1K _ eqK1K; exists 1; first exact: set11.\n  by apply/eqP; rewrite conjsg1 eqEcard sK1K eqK1K /=.\npose G := (H <*> K)%G.\nhave defG: G :=: H * K by rewrite -normC // -norm_joinEl // joingC.\nhave sHG: H \\subset G by apply: joing_subl.\nhave sKG: K \\subset G by apply: joing_subr.\nhave nsHG: H <| G by rewrite /(H <| G) sHG join_subG normG.\ncase/(solvable_norm_abelem solH nsHG)=> M [sMH nsMG ntM] /and3P[_ abelM _].\nhave [sMG nMG] := andP nsMG; rewrite -defG => sK1G coHK oK1K.\nhave nMsG (L : {set gT}): L \\subset G -> L \\subset 'N(M).\n  by move/subset_trans->.\nhave [coKM coHMK]: coprime #|M| #|K| /\\ coprime #|H / M| #|K|.\n  by apply/andP; rewrite -coprimeMl card_quotient ?nMsG ?Lagrange.\nhave oKM (K' : {group gT}): K' \\subset G -> #|K'| = #|K| -> #|K' / M| = #|K|.\n  move=> sK'G oK'.\n  rewrite -quotientMidr -?norm_joinEl ?card_quotient ?nMsG //; last first.\n    by rewrite gen_subG subUset sK'G.\n  rewrite -divgS /=; last by rewrite -gen_subG genS ?subsetUr.\n  by rewrite norm_joinEl ?nMsG // coprime_cardMg ?mulnK // oK' coprime_sym.\nhave [xb]: exists2 xb, xb \\in H / M & K1 / M = (K / M) :^ xb.\n  apply: IHn; try by rewrite (quotient_sol, morphim_norms, oKM K) ?(oKM K1).\n    by apply: leq_trans leHn; rewrite ltn_quotient.\n  by rewrite -morphimMl ?nMsG // -defG morphimS.\ncase/morphimP=> x nMx Hx ->{xb} eqK1Kx; pose K2 := (K :^ x)%G.\nhave{eqK1Kx} eqK12: K1 / M = K2 / M by rewrite quotientJ.\nsuff [y My ->]: exists2 y, y \\in M & K1 :=: K2 :^ y.\n  by exists (x * y); [rewrite groupMl // (subsetP sMH) | rewrite conjsgM].\nhave nMK1: K1 \\subset 'N(M) by apply: nMsG.\nhave defMK: M * K1 = M <*> K1 by rewrite -normC // -norm_joinEl // joingC.\nhave sMKM: M \\subset M <*> K1 by rewrite joing_subl.\nhave nMKM: M <| M <*> K1 by rewrite normalYl.\nhave trMK1: M :&: K1 = 1 by rewrite coprime_TIg ?oK1K.\nhave trMK2: M :&: K2 = 1 by rewrite coprime_TIg ?cardJg ?oK1K.\napply: (Gaschutz_transitive nMKM _ sMKM) => //=; last 2 first.\n- by rewrite inE trMK1 defMK !eqxx.\n- by rewrite -!(setIC M) trMK1.\n- by rewrite -divgS //= -defMK coprime_cardMg oK1K // mulKn.\nrewrite inE trMK2 eqxx eq_sym eqEcard /= -defMK andbC.\nby rewrite !coprime_cardMg ?cardJg ?oK1K ?leqnn //= mulGS -quotientSK -?eqK12.\nQed.",
    "Theorem Frobenius_Ldiv (gT : finGroupType) (G : {group gT}) n :\n  n %| #|G| -> n %| #|'Ldiv_n(G)|.\nProof.\nmove=> nG; move: {2}_.+1 (ltnSn (#|G| %/ n)) => mq.\nelim: mq => // mq IHm in gT G n nG *; case/dvdnP: nG => q oG.\nhave [q_gt0 n_gt0] : 0 < q /\\ 0 < n by apply/andP; rewrite -muln_gt0 -oG.\nrewrite ltnS oG mulnK // => leqm.\nhave:= q_gt0; rewrite leq_eqVlt => /predU1P[q1 | lt1q].\n  rewrite -(mul1n n) q1 -oG (setIidPl _) //.\n  by apply/subsetP=> x Gx; rewrite inE -order_dvdn order_dvdG.\npose p := pdiv q; have pr_p: prime p by apply: pdiv_prime.\nhave lt1p: 1 < p := prime_gt1 pr_p; have p_gt0 := ltnW lt1p.\nhave{leqm} lt_qp_mq: q %/ p < mq by apply: leq_trans leqm; rewrite ltn_Pdiv.\nhave: n %| #|'Ldiv_(p * n)(G)|.\n  have: p * n %| #|G| by rewrite oG dvdn_pmul2r ?pdiv_dvd.\n  move/IHm=> IH; apply: dvdn_trans (IH _); first exact: dvdn_mull.\n  by rewrite oG divnMr.\nrewrite -(cardsID 'Ldiv_n()) dvdn_addl.\n  rewrite -setIA ['Ldiv_n(_)](setIidPr _) //.\n  by apply/subsetP=> x; rewrite !inE -!order_dvdn; apply: dvdn_mull.\nrewrite -setIDA; set A := _ :\\: _.\nhave pA x: x \\in A -> #[x]`_p = (n`_p * p)%N.\n  rewrite !inE -!order_dvdn => /andP[xn xnp].\n  rewrite !p_part // -expnSr; congr (p ^ _)%N; apply/eqP.\n  rewrite eqn_leq -{1}addn1 -(pfactorK 1 pr_p) -lognM ?expn1 // mulnC.\n  rewrite dvdn_leq_log ?muln_gt0 ?p_gt0 //= ltnNge; apply: contra xn => xn.\n  move: xnp; rewrite -[#[x]](partnC p) //.\n  rewrite !Gauss_dvd ?coprime_partC //; case/andP=> _.\n  rewrite p_part ?pfactor_dvdn // xn Gauss_dvdr // coprime_sym.\n  exact: pnat_coprime (pnat_id _) (part_pnat _ _).\nrewrite -(partnC p n_gt0) Gauss_dvd ?coprime_partC //; apply/andP; split.\n  rewrite -sum1_card (partition_big_imset (@cycle _)) /=.\n  apply: dvdn_sum => _ /imsetP[x /setIP[Gx Ax] ->].\n  rewrite (eq_bigl (generator <[x]>)) => [|y].\n    rewrite sum1dep_card -totient_gen -[#[x]](partnC p) //.\n    rewrite totient_coprime ?coprime_partC // dvdn_mulr // .\n    by rewrite (pA x Ax) p_part // -expnSr totient_pfactor // dvdn_mull.\n  rewrite /generator eq_sym andbC; case xy: {+}(_ == _) => //.\n  rewrite !inE -!order_dvdn in Ax *.\n  by rewrite -cycle_subG /order -(eqP xy) cycle_subG Gx.\nrewrite -sum1_card (partition_big_imset (fun x => x.`_p ^: G)) /=.\napply: dvdn_sum => _ /imsetP[x /setIP[Gx Ax] ->].\nset y := x.`_p; have oy: #[y] = (n`_p * p)%N by rewrite order_constt pA.\nrewrite (partition_big (fun x => x.`_p) [in y ^: G]) /= => [|z]; last first.\n  by case/andP=> _ /eqP <-; rewrite /= class_refl.\npose G' := ('C_G[y] / <[y]>)%G; pose n' := gcdn #|G'| n`_p^'.\nhave n'_gt0: 0 < n' by rewrite gcdn_gt0 cardG_gt0.\nrewrite (eq_bigr (fun _ => #|'Ldiv_n'(G')|)) => [|_ /imsetP[a Ga ->]].\n  rewrite sum_nat_const -index_cent1 indexgI.\n  rewrite -(dvdn_pmul2l (cardG_gt0 'C_G[y])) mulnA LagrangeI.\n  have oCy: #|'C_G[y]| = (#[y] * #|G'|)%N.\n    rewrite card_quotient ?subcent1_cycle_norm // Lagrange //.\n    by rewrite subcent1_cycle_sub ?groupX.\n  rewrite oCy -mulnA -(muln_lcm_gcd #|G'|) -/n' mulnA dvdn_mul //.\n    rewrite muln_lcmr -oCy order_constt pA // mulnAC partnC // dvdn_lcm.\n    by rewrite cardSg ?subsetIl // mulnC oG dvdn_pmul2r ?pdiv_dvd.\n  apply: IHm; [exact: dvdn_gcdl | apply: leq_ltn_trans lt_qp_mq].\n  rewrite -(@divnMr n`_p^') // -muln_lcm_gcd mulnC divnMl //.\n  rewrite leq_divRL // divn_mulAC ?leq_divLR ?dvdn_mulr ?dvdn_lcmr //.\n  rewrite dvdn_leq ?muln_gt0 ?q_gt0 //= mulnC muln_lcmr dvdn_lcm.\n  rewrite -(@dvdn_pmul2l n`_p) // mulnA -oy -oCy mulnCA partnC // -oG.\n  by rewrite cardSg ?subsetIl // dvdn_mul ?pdiv_dvd.\npose h := [fun z => coset <[y]> (z ^ a^-1)].\npose h' := [fun Z : coset_of <[y]> => (y * (repr Z).`_p^') ^ a].\nrewrite -sum1_card (reindex_onto h h') /= => [|Z]; last first.\n  rewrite conjgK coset_kerl ?cycle_id ?morph_constt ?repr_coset_norm //.\n  rewrite /= coset_reprK 2!inE -order_dvdn dvdn_gcd => /and3P[_ _ p'Z].\n  by apply: constt_p_elt (pnat_dvd p'Z _); apply: part_pnat.\napply: eq_bigl => z; apply/andP/andP=> [[]|[]].\n  rewrite inE -andbA => /and3P[Gz Az _] /eqP zp_ya.\n  have czy: z ^ a^-1 \\in 'C[y].\n    rewrite -mem_conjg -normJ conjg_set1 -zp_ya.\n    by apply/cent1P; apply: commuteX.\n  have Nz:  z ^ a^-1 \\in 'N(<[y]>) by apply: subsetP czy; apply: norm_gen.\n  have G'z: h z \\in G' by rewrite mem_morphim //= inE groupJ // groupV.\n  rewrite inE G'z inE -order_dvdn dvdn_gcd order_dvdG //=.\n  rewrite /order -morphim_cycle // -quotientE card_quotient ?cycle_subG //.\n  rewrite -(@dvdn_pmul2l #[y]) // Lagrange; last first.\n    by rewrite /= cycleJ cycle_subG mem_conjgV -zp_ya mem_cycle.\n  rewrite oy mulnAC partnC // [#|_|]orderJ; split.\n    by rewrite !inE -!order_dvdn mulnC in Az; case/andP: Az.\n  set Z := coset _ _; have NZ := repr_coset_norm Z; have:= coset_reprK Z.\n  case/kercoset_rcoset=> {NZ}// _ /cycleP[i ->] ->{Z}.\n  rewrite consttM; last exact/commute_sym/commuteX/cent1P.\n  rewrite (constt1P _) ?p_eltNK 1?p_eltX ?p_elt_constt // mul1g.\n  by rewrite conjMg consttJ conjgKV -zp_ya consttC.\nrewrite 2!inE -order_dvdn; set Z := coset _ _ => /andP[Cz n'Z] /eqP def_z.\nhave Nz: z ^ a^-1 \\in 'N(<[y]>).\n  rewrite -def_z conjgK groupMr; first by rewrite -(cycle_subG y) normG.\n  by rewrite groupX ?repr_coset_norm.\nhave{Cz} /setIP[Gz Cz]: z ^ a^-1 \\in 'C_G[y].\n  case/morphimP: Cz => u Nu Cu /kercoset_rcoset[] // _ /cycleP[i ->] ->.\n  by rewrite groupMr // groupX // inE groupX //; apply/cent1P.\nhave{def_z} zp_ya: z.`_p = y ^ a.\n  rewrite -def_z consttJ consttM.\n    rewrite constt_p_elt ?p_elt_constt //.\n    by rewrite (constt1P _) ?p_eltNK ?p_elt_constt ?mulg1.\n  apply: commute_sym; apply/cent1P.\n  by rewrite -def_z conjgK groupMl // in Cz; apply/cent1P.\nhave ozp: #[z ^ a^-1]`_p = #[y] by rewrite -order_constt consttJ zp_ya conjgK.\nsplit; rewrite zp_ya // -class_lcoset lcoset_id // eqxx andbT.\nrewrite -(conjgKV a z) !inE groupJ //= -!order_dvdn orderJ; apply/andP; split.\n  apply: contra (partn_dvd p n_gt0) _.\n  by rewrite ozp -(muln1 n`_p) oy dvdn_pmul2l // dvdn1 neq_ltn lt1p orbT.\nrewrite -(partnC p n_gt0) mulnCA mulnA -oy -(@partnC p #[_]) // ozp.\napply dvdn_mul => //; apply: dvdn_trans (dvdn_trans n'Z (dvdn_gcdr _ _)).\nrewrite {2}/order -morphim_cycle // -quotientE card_quotient ?cycle_subG //.\nrewrite -(@dvdn_pmul2l #|<[z ^ a^-1]> :&: <[y]>|) ?cardG_gt0 // LagrangeI.\nrewrite -[#|<[_]>|](partnC p) ?order_gt0 // dvdn_pmul2r // ozp.\nby rewrite cardSg ?subsetIr.\nQed.",
    "Theorem Gaschutz_split : [splits G, over H] = [splits P, over H].\nProof.\napply/splitsP/splitsP=> [[K /complP[tiHK eqHK]] | [Q /complP[tiHQ eqHQ]]].\n  exists (K :&: P)%G; rewrite inE setICA (setIidPl sHP) setIC tiHK eqxx.\n  by rewrite group_modl // eqHK (sameP eqP setIidPr).\nhave sQP: Q \\subset P by rewrite -eqHQ mulG_subr.\npose rP x := repr (P :* x); pose pP x := x * (rP x)^-1.\nhave PpP x: pP x \\in P by rewrite -mem_rcoset rcoset_repr rcoset_refl.\nhave rPmul x y: x \\in P -> rP (x * y) = rP y.\n  by move=> Px; rewrite /rP rcosetM rcoset_id.\npose pQ x := remgr H Q x; pose rH x := pQ (pP x) * rP x.\nhave pQhq: {in H & Q, forall h q, pQ (h * q) = q} by apply: remgrMid.\nhave pQmul: {in P &, {morph pQ : x y / x * y}}.\n  by apply: remgrM; [apply/complP | apply: normalS (nsHG)].\nhave HrH x: rH x \\in H :* x.\n  by rewrite rcoset_sym mem_rcoset invMg mulgA mem_divgr // eqHQ PpP.\nhave GrH x: x \\in G -> rH x \\in G.\n  move=> Gx; case/rcosetP: (HrH x) => y Hy ->.\n  by rewrite groupM // (subsetP sHG).\nhave rH_Pmul x y: x \\in P -> rH (x * y) = pQ x * rH y.\n  by move=> Px; rewrite /rH mulgA -pQmul; first by rewrite /pP rPmul ?mulgA.\nhave rH_Hmul h y: h \\in H -> rH (h * y) = rH y.\n  by move=> Hh; rewrite rH_Pmul ?(subsetP sHP) // -(mulg1 h) pQhq ?mul1g.\npose mu x y := fmod ((rH x * rH y)^-1 * rH (x * y)).\npose nu y := (\\sum_(Px in rcosets P G) mu (repr Px) y)%R.\nhave rHmul: {in G &, forall x y, rH (x * y) = rH x * rH y * val (mu x y)}.\n  move=> x y Gx Gy; rewrite /= fmodK ?mulKVg // -mem_lcoset lcoset_sym.\n  rewrite -norm_rlcoset; last by rewrite nHG ?GrH ?groupM.\n  by rewrite (rcoset_eqP (HrH _)) -rcoset_mul ?nHG ?GrH // mem_mulg.\nhave actrH a x: x \\in G -> (a ^@ rH x = a ^@ x)%R.\n  move=> Gx; apply: val_inj; rewrite /= !fmvalJ ?nHG ?GrH //.\n  case/rcosetP: (HrH x) => b /(fmodK abelH) <- ->; rewrite conjgM.\n  by congr (_ ^ _); rewrite conjgE -fmvalN -!fmvalA (addrC a) addKr.\nhave mu_Pmul x y z: x \\in P -> mu (x * y) z = mu y z.\n  move=> Px; congr fmod; rewrite -mulgA !(rH_Pmul x) ?rPmul //.\n  by rewrite -mulgA invMg -mulgA mulKg.\nhave mu_Hmul x y z: x \\in G -> y \\in H -> mu x (y * z) = mu x z.\n  move=> Gx Hy; congr fmod; rewrite (mulgA x) (conjgCV x) -mulgA 2?rH_Hmul //.\n  by rewrite -mem_conjg (normP _) ?nHG.\nhave{mu_Hmul} nu_Hmul y z: y \\in H -> nu (y * z) = nu z.\n  move=> Hy; apply: eq_bigr => _ /rcosetsP[x Gx ->]; apply: mu_Hmul y z _ Hy.\n  by rewrite -(groupMl _ (subsetP sPG _ (PpP x))) mulgKV.\nhave cocycle_mu: {in G & &, forall x y z,\n  mu (x * y)%g z + mu x y ^@ z = mu y z + mu x (y * z)%g}%R.\n- move=> x y z Gx Gy Gz; apply: val_inj.\n  apply: (mulgI (rH x * rH y * rH z)).\n  rewrite -(actrH _ _ Gz) addrC fmvalA fmvalJ ?nHG ?GrH //.\n  rewrite mulgA -(mulgA _ (rH z)) -conjgC mulgA -!rHmul ?groupM //.\n  by rewrite mulgA -mulgA -2!(mulgA (rH x)) -!rHmul ?groupM.\nmove: mu => mu in rHmul mu_Pmul cocycle_mu nu nu_Hmul.\nhave{cocycle_mu} cocycle_nu: {in G &, forall y z,\n  nu z + nu y ^@ z = mu y z *+ #|G : P| + nu (y * z)%g}%R.\n- move=> y z Gy Gz; rewrite /= (actr_sum z) /=.\n  have ->: (nu z = \\sum_(Px in rcosets P G) mu (repr Px * y)%g z)%R.\n    rewrite /nu (reindex_acts _ (actsRs_rcosets P G) Gy) /=.\n    apply: eq_bigr => _ /rcosetsP[x Gx /= ->].\n    rewrite rcosetE -rcosetM.\n    case: repr_rcosetP=> p1 Pp1; case: repr_rcosetP=> p2 Pp2.\n    by rewrite -mulgA [x * y]lock !mu_Pmul.\n  rewrite -sumr_const -!big_split /=; apply: eq_bigr => _ /rcosetsP[x Gx ->].\n  rewrite -cocycle_mu //; case: repr_rcosetP => p1 Pp1.\n  by rewrite groupMr // (subsetP sPG).\nmove: nu => nu in nu_Hmul cocycle_nu.\npose f x := rH x * val (nu x *+ m)%R.\nhave{cocycle_nu} fM: {in G &, {morph f : x y / x * y}}.\n  move=> x y Gx Gy; rewrite /f ?rHmul // -3!mulgA; congr (_ * _).\n  rewrite (mulgA _ (rH y)) (conjgC _ (rH y)) -mulgA; congr (_ * _).\n  rewrite -fmvalJ ?actrH ?nHG ?GrH // -!fmvalA actZr -mulrnDl.\n  rewrite -(addrC (nu y)) cocycle_nu // mulrnDl !fmvalA; congr (_ * _).\n  by rewrite !fmvalZ expgK ?fmodP.\nexists (Morphism fM @* G)%G; apply/complP; split.\n  apply/trivgP/subsetP=> x /setIP[Hx /morphimP[y _ Gy eq_x]].\n  apply/set1P; move: Hx; rewrite {x}eq_x /= groupMr ?subgP //.\n  rewrite -{1}(mulgKV y (rH y)) groupMl -?mem_rcoset // => Hy.\n  by rewrite -(mulg1 y) /f nu_Hmul // rH_Hmul //; apply: (morph1 (Morphism fM)).\napply/setP=> x; apply/mulsgP/idP=> [[h y Hh fy ->{x}] | Gx].\n  rewrite groupMl; last exact: (subsetP sHG).\n  case/morphimP: fy => z _ Gz ->{h Hh y}.\n  by rewrite /= /f groupMl ?GrH // (subsetP sHG) ?fmodP.\nexists (x * (f x)^-1) (f x); last first; first by rewrite mulgKV.\n  by apply/morphimP; exists x.\nrewrite -groupV invMg invgK -mulgA (conjgC (val _)) mulgA.\nby rewrite groupMl -(mem_rcoset, mem_conjg) // (normP _) ?nHG ?fmodP.\nQed.",
    "Theorem Gaschutz_transitive : {in [complements to H in G] &,\n  forall K L,  K :&: P = L :&: P -> exists2 x, x \\in H & L :=: K :^ x}.\nProof.\nmove=> K L /=; set Q := K :&: P => /complP[tiHK eqHK] cpHL QeqLP.\nhave [trHL eqHL] := complP cpHL.\npose nu x := fmod (divgr H L x^-1).\nhave sKG: {subset K <= G} by apply/subsetP; rewrite -eqHK mulG_subr.\nhave sLG: {subset L <= G} by apply/subsetP; rewrite -eqHL mulG_subr.\nhave val_nu x: x \\in G -> val (nu x) = divgr H L x^-1.\n  by move=> Gx; rewrite fmodK // mem_divgr // eqHL groupV.\nhave nu_cocycle: {in G &, forall x y, nu (x * y)%g = nu x ^@ y + nu y}%R.\n  move=> x y Gx Gy; apply: val_inj; rewrite fmvalA fmvalJ ?nHG //.\n  rewrite !val_nu ?groupM // /divgr conjgE !mulgA mulgK.\n  by rewrite !(invMg, remgrM cpHL) ?groupV ?mulgA.\nhave nuL x: x \\in L -> nu x = 0%R.\n  move=> Lx; apply: val_inj; rewrite val_nu ?sLG //.\n  by rewrite /divgr remgr_id ?groupV ?mulgV.\nexists (fmval ((\\sum_(X in rcosets Q K) nu (repr X)) *+ m)).\n  exact: fmodP.\napply/eqP; rewrite eq_sym eqEcard; apply/andP; split; last first.\n  by rewrite cardJg -(leq_pmul2l (cardG_gt0 H)) -!TI_cardMg // eqHL eqHK.\napply/subsetP=> _ /imsetP[x Kx ->]; rewrite conjgE mulgA (conjgC _ x).\nhave Gx: x \\in G by rewrite sKG.\nrewrite conjVg -mulgA -fmvalJ ?nHG // -fmvalN -fmvalA (_ : _ + _ = nu x)%R.\n  by rewrite val_nu // mulKVg groupV mem_remgr // eqHL groupV.\nrewrite actZr -!mulNrn -mulrnDl actr_sum.\nrewrite addrC (reindex_acts _ (actsRs_rcosets _ K) Kx) -sumrB /= -/Q.\nrewrite (eq_bigr (fun _ => nu x)) => [|_ /imsetP[y Ky ->]]; last first.\n  rewrite !rcosetE -rcosetM QeqLP.\n  case: repr_rcosetP => z /setIP[Lz _]; case: repr_rcosetP => t /setIP[Lt _].\n  rewrite !nu_cocycle ?groupM ?(sKG y) // ?sLG //.\n  by rewrite (nuL z) ?(nuL t) // !act0r !add0r addrC addKr.\napply: val_inj; rewrite sumr_const !fmvalZ.\nrewrite -{2}(expgK coHiPG (fmodP (nu x))); congr (_ ^+ _ ^+ _).\nrewrite -[#|_|]divgS ?subsetIl // -(divnMl (cardG_gt0 H)).\nrewrite -!TI_cardMg //; last by rewrite setIA setIAC (setIidPl sHP).\nby rewrite group_modl // eqHK (setIidPr sPG) divgS.\nQed.",
    "Theorem Euler_exp_totient a n : coprime a n -> a ^ totient n  = 1 %[mod n].\nProof.\ncase: n => [|[|n']] //; [by rewrite !modn1 | set n := n'.+2] => co_a_n.\nhave{co_a_n} Ua: coprime n (inZp a : 'I_n) by rewrite coprime_sym coprime_modl.\nhave: FinRing.unit 'Z_n Ua ^+ totient n == 1.\n  by rewrite -card_units_Zp // -order_dvdn order_dvdG ?inE.\nby rewrite -2!val_eqE unit_Zp_expg /= -/n modnXm => /eqP.\nQed.",
    "Theorem abelian_structure G :\n    abelian G ->\n  {b | \\big[dprod/1]_(x <- b) <[x]> = G & map order b = abelian_type G}.\nProof.\nrewrite /abelian_type genGidG; have [n] := ubnPleq #|G|.\nelim: n G => /= [|n IHn] G leGn cGG; first by rewrite leqNgt cardG_gt0 in leGn.\nrewrite [in _ && _]cGG /=; case: ifP => [ntG|/eqP->]; last first.\n  by exists [::]; rewrite ?big_nil.\ncase: (abelian_type_subproof G) => H /= [//|x ox xdefG]; rewrite -ox.\nhave [_ defG cxH tixH] := dprodP xdefG.\nhave sHG: H \\subset G by rewrite -defG mulG_subr.\ncase/IHn: (abelianS sHG cGG) => [|b defH <-].\n  rewrite -ltnS (leq_trans _ leGn) // -defG TI_cardMg // -orderE.\n  rewrite ltn_Pmull ?cardG_gt0 // ltn_neqAle order_gt0 eq_sym -dvdn1.\n  by rewrite ox -trivg_exponent ntG.\nby exists (x :: b); rewrite // big_cons defH xdefG.\nQed.",
    "Theorem eq_irrelevance (T : eqType) x y : forall e1 e2 : x = y :> T, e1 = e2.\nProof.\npose proj z e := if x =P z is ReflectT e0 then e0 else e.\nsuff: injective (proj y) by rewrite /proj => injp e e'; apply: injp; case: eqP.\npose join (e : x = _) := etrans (esym e).\napply: can_inj (join x y (proj x (erefl x))) _.\nby case: y /; case: _ / (proj x _).\nQed.",
    "Theorem eqb_eq p q : Pos.eqb p q = true <-> p=q.\nProof.\nby elim: p q => [p IHp|p IHp|] [q|q|] //=; split=> [/IHp->//|]; case=> /IHp.\nQed.",
    "Theorem Wilson p : p > 1 -> prime p = (p %| ((p.-1)`!).+1).\nProof.\nhave dFact n: 0 < n -> (n.-1)`! = \\prod_(0 <= i < n | i != 0) i.\n  move=> n_gt0; rewrite -big_filter fact_prod; symmetry; apply: congr_big => //.\n  rewrite /index_iota subn1 -[n]prednK //=; apply/all_filterP.\n  by rewrite all_predC has_pred1 mem_iota.\nmove=> lt1p; have p_gt0 := ltnW lt1p.\napply/idP/idP=> [pr_p | dv_pF]; last first.\n  apply/primeP; split=> // d dv_dp; have: d <= p by apply: dvdn_leq.\n  rewrite orbC leq_eqVlt => /orP[-> // | ltdp].\n  have:= dvdn_trans dv_dp dv_pF; rewrite dFact // big_mkord.\n  rewrite (bigD1 (Ordinal ltdp)) /=; last by rewrite -lt0n (dvdn_gt0 p_gt0).\n  by rewrite orbC -addn1 dvdn_addr ?dvdn_mulr // dvdn1 => ->.\npose Fp1 := Ordinal lt1p; pose Fp0 := Ordinal p_gt0.\nhave ltp1p: p.-1 < p by [rewrite prednK]; pose Fpn1 := Ordinal ltp1p.\ncase eqF1n1: (Fp1 == Fpn1); first by rewrite -{1}[p]prednK -1?((1 =P p.-1) _).\nhave toFpP m: m %% p < p by rewrite ltn_mod.\npose toFp := Ordinal (toFpP _); pose mFp (i j : 'I_p) := toFp (i * j).\nhave Fp_mod (i : 'I_p) : i %% p = i by apply: modn_small.\nhave mFpA: associative mFp.\n  by move=> i j k; apply: val_inj; rewrite /= modnMml modnMmr mulnA.\nhave mFpC: commutative mFp by move=> i j; apply: val_inj; rewrite /= mulnC.\nhave mFp1: left_id Fp1 mFp by move=> i; apply: val_inj; rewrite /= mul1n.\nhave mFp1r: right_id Fp1 mFp by move=> i; apply: val_inj; rewrite /= muln1.\npose mFpcM := Monoid.isComLaw.Build 'I_p Fp1 mFp mFpA mFpC mFp1.\npose mFpCL : Monoid.com_law _ := HB.pack mFp mFpcM.\npose mFpM := Monoid.Law.sort mFpCL.\npose vFp (i : 'I_p) := toFp (egcdn i p).1.\nhave vFpV i: i != Fp0 -> mFp (vFp i) i = Fp1.\n  rewrite -val_eqE /= -lt0n => i_gt0; apply: val_inj => /=.\n  rewrite modnMml; case: egcdnP => //= _ km -> _; rewrite {km}modnMDl.\n  suffices: coprime i p by move/eqnP->; rewrite modn_small.\n  rewrite coprime_sym prime_coprime //; apply/negP=> /(dvdn_leq i_gt0).\n  by rewrite leqNgt ltn_ord.\nhave vFp0 i: i != Fp0 -> vFp i != Fp0.\n  by move/vFpV; apply/contra_eq_neq => ->; rewrite -val_eqE /= mul0n mod0n.\nhave vFpK: {in predC1 Fp0, involutive vFp}.\n  move=> i n0i; rewrite /= -[vFp _]mFp1r -(vFpV _ n0i) mFpA.\n  by rewrite vFpV (vFp0, mFp1).\nhave le_pmFp (i : 'I_p) m: i <= p + m.\n  by apply: leq_trans (ltnW _) (leq_addr _ _).\nhave eqFp (i j : 'I_p): (i == j) = (p %| p + i - j).\n  by rewrite -eqn_mod_dvd ?(modnDl, Fp_mod).\nhave vFpId i: (vFp i == i :> nat) = xpred2 Fp1 Fpn1 i.\n  have [->{i} | ni0] := eqVneq i Fp0.\n    by rewrite -!val_eqE /= egcd0n modn_small //= -(subnKC lt1p).\n  rewrite 2!eqFp -Euclid_dvdM // -[_ - p.-1]subSS prednK //.\n  have lt0i: 0 < i by rewrite lt0n.\n  rewrite -addnS addKn -addnBA // mulnDl -{2}(addn1 i) -subn_sqr.\n  rewrite addnBA ?leq_sqr // mulnS -addnA -mulnn -mulnDl.\n  rewrite -(subnK (le_pmFp (vFp i) i)) mulnDl addnCA.\n  rewrite -[1 ^ 2]/(Fp1 : nat) -addnBA // dvdn_addl.\n    by rewrite Euclid_dvdM // -eqFp eq_sym orbC /dvdn Fp_mod eqn0Ngt lt0i.\n  by rewrite -eqn_mod_dvd // Fp_mod modnDl -(vFpV _ ni0).\nsuffices [mod_fact]: toFp (p.-1)`! = Fpn1.\n  by rewrite /dvdn -addn1 -modnDml mod_fact addn1 prednK // modnn.\nrewrite dFact //; rewrite ((big_morph toFp) Fp1 mFpM) //; first last.\n- by apply: val_inj; rewrite /= modn_small.\n- by move=> i j; apply: val_inj; rewrite /= modnMm.\nrewrite big_mkord (eq_bigr id) => [|i _]; last by apply: val_inj => /=.\npose ltv i := vFp i < i; rewrite (bigID ltv) -/mFpM [mFpM _ _]mFpC.\nrewrite (bigD1 Fp1) -/mFpM; last by rewrite [ltv _]ltn_neqAle vFpId.\nrewrite [mFpM _ _]mFp1 (bigD1 Fpn1) -?mFpA -/mFpM; last first.\n  rewrite -lt0n -ltnS prednK // lt1p.\n  by rewrite [ltv _]ltn_neqAle vFpId eqxx orbT eq_sym eqF1n1.\nrewrite (reindex_onto vFp vFp) -/mFpM => [|i]; last by do 3!case/andP; auto.\nrewrite (eq_bigl (xpredD1 ltv Fp0)) => [|i]; last first.\n  rewrite andbC -!andbA -2!negb_or -vFpId orbC -leq_eqVlt -ltnNge.\n  have [->|ni0] := eqVneq i; last by rewrite vFpK // eqxx vFp0.\n  by case: eqP => // ->; rewrite !andbF.\nrewrite -{2}[mFp]/mFpM -[mFpM _ _]big_split -/mFpM.\nby rewrite big1 ?mFp1r //= => i /andP [/vFpV].\nQed.",
    "Theorem expnDn a b n :\n  (a + b) ^ n = \\sum_(i < n.+1) 'C(n, i) * (a ^ (n - i) * b ^ i).\nProof.\nelim: n => [|n IHn]; rewrite big_ord_recl muln1 ?big_ord0 //.\nrewrite expnS {}IHn /= mulnDl !big_distrr /= big_ord_recl muln1 subn0.\nrewrite !big_ord_recr /= !binn !subnn bin0 !subn0 !mul1n -!expnS -addnA.\ncongr (_ + _); rewrite addnA -big_split /=; congr (_ + _).\napply: eq_bigr => i _; rewrite mulnCA (mulnA a) -expnS subnSK //=.\nby rewrite (mulnC b) -2!mulnA -expnSr -mulnDl.\nQed.",
    "Theorem factor_theorem p a : reflect (exists q, p = q * ('X - a%:P)) (root p a).\nProof.\napply: (iffP eqP) => [pa0 | [q ->]]; last first.\n  by rewrite hornerM_comm /comm_poly hornerXsubC subrr ?simp.\nexists (\\poly_(i < size p) horner_rec (drop i.+1 p) a).\napply/polyP=> i; rewrite mulrBr coefB coefMX coefMC !coef_poly.\napply: canRL (addrK _) _; rewrite addrC; have [le_p_i | lt_i_p] := leqP.\n  rewrite nth_default // !simp drop_oversize ?if_same //.\n  exact: leq_trans (leqSpred _).\ncase: i => [|i] in lt_i_p *; last by rewrite ltnW // (drop_nth 0 lt_i_p).\nby rewrite drop1 /= -{}pa0 /horner; case: (p : seq R) lt_i_p.\nQed.",
    "Theorem max_poly_roots p rs :\n  p != 0 -> all (root p) rs -> uniq rs -> size rs < size p.\nProof.\nelim: rs p => [p pn0 _ _ | r rs ihrs p pn0] /=; first by rewrite size_poly_gt0.\ncase/andP => rpr arrs /andP [rnrs urs]; case/factor_theorem: rpr => q epq.\nhave [q0 | ?] := eqVneq q 0; first by move: pn0; rewrite epq q0 mul0r eqxx.\nhave -> : size p = (size q).+1.\n   by rewrite epq size_Mmonic ?monicXsubC // size_XsubC addnC.\nsuff /eq_in_all h : {in rs, root q =1 root p} by apply: ihrs => //; rewrite h.\nmove=> x xrs; rewrite epq rootM root_XsubC orbC; case: (eqVneq x r) => // exr.\nby move: rnrs; rewrite -exr xrs.\nQed.",
    "Theorem max_ring_poly_roots p rs :\n  p != 0 -> all (root p) rs -> uniq_roots rs -> size rs < size p.\nProof.\nmove=> nz_p _ /(@uniq_roots_prod_XsubC p)[// | q def_p]; rewrite def_p in nz_p *.\nhave nz_q: q != 0 by apply: contraNneq nz_p => ->; rewrite mul0r.\nrewrite size_Mmonic ?monic_prod_XsubC // (polySpred nz_q) addSn /=.\nby rewrite size_prod_XsubC leq_addl.\nQed.",
    "Theorem formDd u v : u '_|_ v -> '[u + v] = '[u] + '[v].\nProof.\nmove=> uNv; rewrite formDl !formDr ['[v, u]]formC.\nby rewrite ['[u, v]](form_eq0P _) // rmorph0 mulr0 addr0 add0r.\nQed.",
    "Theorem CauchySchwarz (u v : U) :\n  `|'[u, v]| ^+ 2 <= '[u] * '[v] ?= iff ~~ free [:: u; v].\nProof.\nrewrite free_cons span_seq1 seq1_free -negb_or negbK orbC.\nhave [-> | nz_v] /= := altP (v =P 0).\n  by apply/leifP; rewrite /= !linear0r normCK mul0r mulr0.\nwithout loss ou: u / '[u, v] = 0.\n  move=> IHo; pose a := '[u, v] / '[v]; pose u1 := u - a *: v.\n  have ou: '[u1, v] = 0.\n    rewrite linearBl/=.\n    rewrite linearZl_LR.\n    by rewrite divfK ?dnorm_eq0 ?subrr.\n  rewrite (canRL (subrK _) (erefl u1)) rpredDr ?rpredZ ?memv_line //.\n  rewrite linearDl /= ou add0r.\n  rewrite linearZl_LR/= normrM (ger0_norm (dnorm_ge0 _ _)).\n  rewrite exprMn mulrA -dnormZ hnormDd/=; last by rewrite linearZr_LR/= ou mulr0.\n  have:= IHo _ ou.\n  by rewrite mulrDl -leifBLR subrr ou normCK mul0r.\nrewrite ou normCK mul0r; split; first by rewrite mulr_ge0.\nrewrite eq_sym mulf_eq0 orbC dnorm_eq0 (negPf nz_v) /=.\napply/idP/idP=> [|/vlineP[a {2}->]]; last by rewrite linearZr_LR/= ou mulr0.\nby rewrite dnorm_eq0 => /eqP->; apply: rpred0.\nQed.",
    "Theorem Schur n (A : 'M[C]_n) : (n > 0)%N ->\n  trigonalizable_in (@unitarymx C n n) A.\nProof.\ncase: n => [//|n] in A * => _; have [] := @cotrigonalization _ [:: A].\n  by move=> ? ? /=; rewrite !in_cons !orbF => /eqP-> /eqP->.\nby move=> P P_unitary /=; rewrite andbT=> A_trigo; exists P.\nQed.",
    "Theorem orthomx_spectral_subproof n {A : 'M[C]_n} : reflect\n  (exists2 sp : 'M_n * 'rV_n,\n                sp.1 \\is unitarymx &\n                A = invmx sp.1 *m diag_mx sp.2 *m sp.1)\n  (A \\is normalmx).\nProof.\napply: (iffP normalmxP); last first.\n  move=> [[/= P D] P_unitary ->].\n  rewrite !trmx_mul !map_mxM !mulmxA invmx_unitary //.\n  rewrite !trmxCK ![_ *m P *m _]mulmxtVK //.\n  by rewrite -[X in X *m P]mulmxA tr_diag_mx map_diag_mx diag_mxC mulmxA.\nmove=> /cotrigonalization2 [P Punitary /andP[]] PA PATC.\nhave Punit := unitarymx_unit Punitary.\nsuff: similar_diag P A.\n  move=> /similar_diagPex[D] PAD; exists (P, D) => //=.\n  by rewrite -conjVmx//; exact/similarLR.\napply/similar_diagPp => // i j; case: ltngtP => // [lt_ij|lt_ji] _.\n  by have /is_trig_mxP-> := PA.\nhave /is_trig_mxP -/(_ j i lt_ji)/eqP := PATC.\nrewrite !conjumx// invmx_unitary// -[P as X in X *m _]trmxCK.\nby rewrite -!map_mxM -!trmx_mul mulmxA 2!mxE conjC_eq0 => /eqP.\nQed.",
    "Theorem orthomx_spectralP {n} {A : 'M[C]_n}\n  (P := spectralmx A) (sp := spectral_diag A) :\n  reflect (A = invmx P *m diag_mx sp *m P) (A \\is normalmx).\nProof.\nrewrite /P /sp /spectralmx /spectral_diag.\ncase: orthomx_spectral_subproof.\n  by move=> Psp; case: sig2_eqW => //=; constructor.\nmove=> /orthomx_spectral_subproof Ann; constructor; apply/eqP.\napply: contra Ann; rewrite invmx1 mul1mx mulmx1 => /eqP->.\nsuff -> : diag_mx 0 = 0 by rewrite qualifE trmx0 (map_mx0 conjC).\nby move=> ? ?; apply/matrixP=> i j; rewrite !mxE mul0rn.\nQed.",
    "Theorem Cayley_Hamilton (R : comNzRingType) n' (A : 'M[R]_n'.+1) :\n  horner_mx A (char_poly A) = 0.\nProof.\nhave [phi [_ phiZ phiC _]] := mx_poly_ring_isom R n'.\napply/rootP/factor_theorem; rewrite -phiZ -mul_adj_mx rmorphM /=.\nby move: (phi _) => q; exists q; rewrite rmorphB phiC phiZ map_polyX.\nQed."
  ],
  "scores": [
    6944.6455078125,
    14377.90625,
    148210.140625,
    12683.9326171875,
    10390.0546875,
    16437.775390625,
    8448.58984375,
    11237.1474609375,
    2390.05029296875,
    2374.57666015625,
    2352.6083984375,
    2128.265380859375,
    2985.554931640625,
    2821.27783203125,
    5032.212890625,
    1814.0791015625,
    7375.65283203125,
    90.66942596435547,
    41.209049224853516,
    57.24836730957031,
    4158.69921875,
    3593.2412109375,
    4249.1533203125,
    1921.3321533203125,
    6282.6171875,
    2042.643798828125,
    124.23335266113281,
    228.61936950683594,
    2278.6123046875,
    4989.7099609375,
    11170.0615234375,
    5331.15771484375,
    4037.299560546875,
    9975.552734375,
    2308.894775390625,
    4545.3212890625,
    4750.052734375,
    4698.8115234375,
    5411.5810546875,
    4719.1083984375,
    4734.08349609375,
    5401.51416015625,
    2446.90185546875,
    2041.8448486328125,
    1935.9227294921875,
    7350.2470703125,
    72.59229278564453,
    1818.6976318359375,
    2151.29296875,
    1891.3082275390625,
    2107.882568359375,
    2082.4443359375,
    2142.864990234375,
    2242.33984375,
    1826.198974609375,
    3962.369384765625,
    4431.41650390625,
    4448.72265625,
    5369.15625,
    1869.44580078125,
    5992.115234375,
    51.802825927734375,
    1965.81787109375,
    2017.7943115234375,
    2145.57177734375,
    1827.4307861328125,
    2057.3017578125,
    7393.43701171875,
    6987.6181640625,
    2008.583984375,
    3533.616943359375,
    1866.298095703125,
    3514.084716796875,
    3545.15869140625,
    3523.218505859375,
    3554.517578125,
    8545.40234375,
    4748.8017578125,
    5392.41162109375,
    5538.31201171875,
    15666.37109375,
    27418.3515625,
    8537.9345703125,
    21962.13671875,
    3491.744384765625,
    6444.78466796875,
    67465.875,
    10064.287109375,
    4976.2958984375,
    4984.2412109375,
    6437.0361328125,
    6163.84716796875,
    6348.4443359375,
    2041.929931640625,
    2038.7191162109375,
    2047.969482421875,
    2059.574462890625,
    2041.7255859375,
    2047.47265625,
    6685.17724609375,
    2857.769287109375,
    3012.4931640625,
    2095.024169921875,
    2012.7974853515625,
    3455.579833984375,
    3291.887939453125,
    10189.9541015625,
    1803.2933349609375,
    1853.012451171875,
    2976.8525390625,
    5723.49853515625,
    7462.69873046875,
    1974.780029296875,
    2202.496337890625,
    4842.1025390625,
    4801.10009765625,
    5645.96923828125,
    11784.1376953125,
    4705.2607421875,
    4807.50244140625,
    1836.8394775390625,
    1893.1517333984375,
    3028.19580078125,
    5769.498046875,
    7597.46044921875,
    1996.953125,
    2195.1474609375,
    4848.5361328125,
    4857.60888671875,
    5661.35888671875,
    11815.8154296875,
    4746.4208984375,
    4810.5712890625,
    6891.2021484375,
    2146.7265625,
    2941.352294921875,
    1971.0755615234375,
    1870.8936767578125,
    5176.99072265625,
    2185.79638671875,
    2115.57080078125,
    4898.20849609375,
    4923.12744140625,
    5854.150390625,
    1861.0435791015625,
    4837.35400390625,
    2335.787109375,
    4794.373046875,
    4780.16650390625,
    3271.095703125,
    1851.37451171875,
    1842.63818359375,
    2004.48828125,
    1852.3677978515625,
    2458.988525390625,
    4287.43408203125,
    6054.59375,
    1816.3765869140625,
    9068.7265625,
    1806.142333984375,
    1919.795166015625,
    1810.25048828125,
    2166.886962890625,
    4980.31494140625,
    3535.0859375,
    12532.80859375,
    15549.3115234375,
    2256.81494140625,
    5372.21533203125,
    16761.98046875,
    2861.82666015625,
    2856.0341796875,
    1856.975830078125,
    1790.62646484375,
    1788.59375,
    4980.31494140625,
    3529.8505859375,
    6191.4775390625,
    2180.435302734375,
    2201.60986328125,
    21688.171875,
    2950.599609375,
    2396.814453125,
    2186.655517578125,
    7724.8857421875,
    2306.310302734375,
    6835.63916015625,
    322.6299133300781,
    2540.97412109375,
    2938.36083984375,
    4081.083984375,
    4100.86083984375,
    2340.057373046875,
    2373.050537109375,
    8392.091796875,
    2136.02294921875,
    6333.31201171875,
    10413.6015625,
    8273.861328125,
    8273.861328125,
    2899.509521484375,
    3580.95458984375,
    11136.01171875,
    2498.8720703125,
    2502.911376953125,
    2066.1337890625,
    5603.275390625,
    4286.87451171875,
    3739.575439453125,
    5035.40234375,
    11124.8310546875,
    14804.421875,
    14764.0634765625,
    8718.1064453125,
    15549.4912109375,
    2549.870849609375,
    6711.14013671875,
    7135.6376953125,
    4279.0205078125,
    9525.625,
    11978.1142578125,
    5285.79248046875,
    4955.44580078125,
    4644.427734375,
    4931.74267578125,
    8475.1396484375,
    6190.16650390625,
    4739.9375,
    1928.308837890625,
    1926.58837890625,
    1793.59521484375,
    1789.933349609375,
    18680.775390625,
    8491.0048828125,
    2025.4541015625,
    2228.01806640625,
    7357.29052734375,
    4151.716796875,
    2391.69873046875,
    4872.5,
    2054.998291015625,
    1799.654052734375,
    7395.38427734375,
    4182.029296875,
    2391.69873046875,
    4901.162109375,
    2204.66455078125,
    4476.267578125,
    2187.903564453125,
    10303.90234375,
    4286.0830078125,
    2310.570068359375,
    1943.633544921875,
    8103.78173828125,
    8390.6259765625,
    2221.395263671875,
    1876.977783203125,
    4360.06689453125,
    4386.08740234375,
    5843.12939453125,
    6887.25048828125,
    4090.20751953125,
    1788.3460693359375,
    2392.114013671875,
    21423.9375,
    11691.8984375,
    12260.3896484375,
    10932.4833984375,
    5210.99560546875,
    1869.1083984375,
    18310.4921875,
    4480.8359375,
    4857.173828125,
    4830.0634765625,
    13075.9326171875,
    3350.441650390625,
    6137.76171875,
    6940.568359375,
    2191.838134765625,
    2955.653076171875,
    2247.921630859375,
    8354.3056640625,
    8216.2548828125,
    8364.84765625,
    710.9717407226562,
    958.6912231445312,
    5095.142578125,
    9008.48046875,
    6007.0390625,
    8666.2841796875,
    4262.7275390625,
    1992.8609619140625,
    3682.838134765625,
    3666.964599609375,
    11471.9140625,
    11457.412109375,
    14101.40625,
    1848.8148193359375,
    19913.658203125,
    10368.1591796875,
    12354.462890625,
    3253.455322265625,
    3594.125,
    2683.07763671875,
    16784.6875,
    1983.65966796875,
    1872.267578125,
    1893.3372802734375,
    5786.04150390625,
    6038.291015625,
    11348.3447265625,
    5751.3857421875,
    5713.8740234375,
    7728.3984375,
    7724.37353515625,
    1877.5579833984375,
    1946.55078125,
    14545.2685546875,
    14144.142578125,
    2088.925537109375,
    7903.4638671875,
    9595.7724609375,
    7931.81591796875,
    4071.582275390625,
    10584.91796875,
    2094.35546875,
    12164.9736328125,
    43593.7109375,
    7628.2119140625,
    6490.615234375,
    2153.640625,
    2184.132080078125,
    1866.6123046875,
    1967.556884765625,
    1938.829345703125,
    4379.65380859375,
    14485.20703125,
    10825.05078125,
    10419.6337890625,
    9101.6689453125,
    4432.07080078125,
    20443.34375,
    5788.396484375,
    8353.013671875,
    2847.2197265625,
    7555.228515625,
    16589.76171875,
    6772.7998046875,
    5817.78271484375,
    5916.89208984375,
    7464.9736328125,
    7854.490234375,
    58941.17578125,
    37822.125,
    10305.7119140625,
    8206.4521484375,
    6404.58203125,
    1800.603515625,
    25184.86328125,
    1926.923095703125,
    50.246517181396484,
    50.246517181396484,
    4348.28271484375,
    8422.6611328125,
    1837.8289794921875,
    3298.134521484375,
    3308.05859375,
    6366.9443359375,
    11258.8828125,
    6652.83935546875,
    10594.3857421875,
    7910.10498046875,
    12366.2607421875,
    4357.21875,
    1948.0162353515625,
    1806.50634765625,
    12582.0771484375,
    6364.5751953125,
    10576.14453125,
    7151.64794921875,
    2661.1015625,
    7493.65869140625,
    8243.8408203125,
    8204.4892578125,
    8207.5400390625,
    8161.96484375,
    8164.392578125,
    11346.2333984375,
    4499.34521484375,
    7171.814453125,
    7143.99072265625,
    8770.0791015625,
    10187.2119140625,
    12510.05859375,
    16812.732421875,
    19411.84765625,
    2682.9326171875,
    2593.459716796875,
    1946.6656494140625,
    1925.8463134765625,
    3682.745361328125,
    3838.495361328125,
    83.71851348876953,
    1827.8746337890625,
    2093.554443359375,
    40125.75390625,
    9323.2744140625,
    9309.84375,
    9583.3134765625,
    25192.08984375,
    4805.1484375,
    1808.363037109375,
    6051.32080078125,
    4252.40185546875,
    6006.2822265625,
    7027.482421875,
    1960.5616455078125,
    1814.7677001953125,
    2027.9227294921875,
    8612.1826171875,
    8331.51171875,
    15510.166015625,
    4520.8671875,
    4592.01806640625,
    7490.466796875,
    3384.862060546875,
    6239.92041015625,
    6928.1630859375,
    8418.0654296875,
    8488.42578125,
    17122.923828125,
    3912.943603515625,
    6555.2958984375,
    2001.4075927734375,
    4941.908203125,
    6179.47265625,
    7477.18603515625,
    6268.3828125,
    6806.8134765625,
    4820.271484375,
    18055.46484375,
    6869.7568359375,
    13325.953125,
    3903.867431640625,
    6331.52099609375,
    6608.23583984375,
    6547.96044921875,
    12603.8515625,
    6545.12841796875,
    6547.6484375,
    6577.89404296875,
    6535.39404296875,
    15153.7265625,
    7133.40966796875,
    7210.7861328125,
    12018.0009765625,
    12450.0654296875,
    7061.53662109375,
    22062.498046875,
    9137.1923828125,
    4742.51953125,
    4748.65478515625,
    9288.8291015625,
    2273.97607421875,
    1967.4490966796875,
    1957.555908203125,
    6900.703125,
    1959.8349609375,
    6354.8115234375,
    6409.509765625,
    3497.34130859375,
    3255.2099609375,
    6493.50146484375,
    6084.35009765625,
    8624.146484375,
    4240.87109375,
    2063.987548828125,
    3281.832763671875,
    13303.08203125,
    6171.140625,
    11798.9130859375,
    16022.9833984375,
    22648.66796875,
    23456.435546875,
    8761.7998046875,
    2074.18603515625,
    3405.32177734375,
    2133.321533203125,
    6238.736328125,
    1808.1707763671875,
    4116.505859375,
    6364.69189453125,
    7681.87353515625,
    3465.88916015625,
    7257.9736328125,
    3224.6953125,
    13288.697265625,
    8389.78515625,
    6747.08984375,
    6591.869140625,
    6657.24072265625,
    16571.56640625,
    5996.0546875,
    8368.158203125,
    1795.4267578125,
    7971.5537109375,
    10171.4765625,
    11371.9619140625,
    3848.845458984375,
    8788.6669921875,
    5371.123046875,
    1838.2060546875,
    3467.732177734375,
    8535.5810546875,
    2252.972900390625,
    1796.1043701171875,
    1835.4224853515625,
    27004.35546875,
    27559.572265625,
    1673.857177734375,
    2912.13916015625,
    7070.865234375,
    2396.56982421875,
    2493.10009765625,
    7139.45556640625,
    3820.9873046875,
    7488.64404296875,
    12140.0732421875,
    7095.97265625,
    9037.7392578125,
    21447.732421875,
    21451.357421875,
    22090.10546875,
    22128.462890625,
    2482.7861328125,
    2379.53466796875,
    16186.400390625,
    16180.55859375,
    4886.69775390625,
    8461.208984375,
    6043.419921875,
    14635.33984375,
    14633.0302734375,
    24983.81640625,
    12008.91015625,
    5759.33642578125,
    2299.354248046875,
    2337.816162109375,
    2347.165283203125,
    7604.203125,
    4321.95654296875,
    16573.837890625,
    4319.5732421875,
    1864.04345703125,
    4718.83935546875,
    4489.72021484375,
    1959.265869140625,
    4002.520751953125,
    19688.93359375,
    4457.7470703125,
    4534.1142578125,
    29890.916015625,
    11061.4833984375,
    3990.7783203125,
    11414.81640625,
    13481.2607421875,
    18225.265625,
    4541.7109375,
    4411.4541015625,
    11790.7333984375,
    5942.71875,
    5776.6884765625,
    2383.96923828125,
    2426.703369140625,
    2417.49853515625,
    2417.57080078125,
    7024.76806640625,
    7418.84033203125,
    5029.9677734375,
    16276.76953125,
    2338.260009765625,
    7229.4140625,
    5172.6591796875,
    10680.7470703125,
    4237.828125,
    14512.345703125,
    53719.6171875,
    8166.12890625,
    7884.88720703125,
    7841.63671875,
    7759.46875,
    24544.58203125,
    27716.48046875,
    13035.4931640625,
    4413.0966796875,
    4522.82470703125,
    5936.64013671875,
    5821.79931640625,
    5699.48388671875,
    2451.83837890625,
    2411.315673828125,
    2411.177978515625,
    2411.177978515625,
    7036.3505859375,
    5996.720703125,
    5287.1904296875,
    10130.3046875,
    14860.9384765625,
    13736.96875,
    3185.877685546875,
    4160.61669921875,
    2477.5380859375,
    12500.3330078125,
    59094.38671875,
    9802.7099609375,
    5975.2578125,
    43625.49609375,
    19847.232421875,
    49569.69140625,
    40496.2578125,
    4661.291015625,
    4528.39599609375,
    14121.18359375,
    5921.6484375,
    5819.046875,
    4331.87353515625,
    3380.1083984375,
    4709.98046875,
    4720.4111328125,
    2422.636962890625,
    2411.53564453125,
    2411.60791015625,
    4981.71533203125,
    7074.21630859375,
    2400.886962890625,
    10063.9931640625,
    4561.0576171875,
    1787.75244140625,
    110312.2421875,
    5912.033203125,
    6718.05859375,
    6489.4619140625,
    53677.0078125,
    13458.6611328125,
    5977.77685546875,
    13591.7890625,
    4712.82080078125,
    10888.9462890625,
    19643.1953125,
    42054.37109375,
    12310.9873046875,
    59185.27734375,
    23972.40625,
    7123.890625,
    9536.349609375,
    7417.66796875,
    6414.3876953125,
    7518.65966796875,
    9593.1171875,
    26082.126953125,
    29236.654296875,
    14982.224609375,
    2163.1083984375,
    2270.80859375,
    2046.96337890625,
    2269.170166015625,
    6119.32177734375,
    5613.88232421875,
    5767.56884765625,
    15254.2685546875,
    4815.88232421875,
    4815.88232421875,
    2905.830810546875,
    2902.178955078125,
    6339.40673828125,
    6339.40673828125,
    3057.958984375,
    3001.085205078125,
    29941.537109375,
    30257.8515625,
    29940.9296875,
    33846.10546875,
    8969.765625,
    8881.5556640625,
    18019.482421875,
    7373.36572265625,
    7235.34716796875,
    7338.55126953125,
    2001.6868896484375,
    2001.6868896484375,
    1997.0758056640625,
    4144.24462890625,
    9889.15625,
    2532.802490234375,
    4919.8955078125,
    11550.46875,
    5132.98046875,
    8373.869140625,
    10832.595703125,
    8527.1357421875,
    4648.748046875,
    35747.36328125,
    9141.6787109375,
    33739.37109375,
    4933.0908203125,
    28369.314453125,
    16176.158203125,
    93478.5078125,
    9096.939453125,
    29809.126953125,
    11223.0498046875,
    5884.431640625,
    5798.89453125,
    12047.30078125,
    11916.408203125,
    19027.955078125,
    9771.978515625,
    9753.939453125,
    11416.3740234375,
    11481.630859375,
    9402.68359375,
    12736.810546875,
    32083.81640625,
    13683.564453125,
    20642.515625,
    15552.34375,
    2049.3037109375,
    32838.03125,
    39495.40234375,
    38909.296875,
    3498.10009765625,
    24237.4765625,
    5011.33935546875,
    4813.18505859375,
    16226.67578125,
    31233.5,
    6303.12890625,
    6374.69677734375,
    23812.859375,
    58501.8046875,
    3788.356689453125,
    5583.03369140625,
    4575.2763671875,
    2405.705078125,
    2202.657958984375,
    2267.6533203125,
    12620.5009765625,
    4417.35595703125,
    6319.064453125,
    6405.6123046875,
    10314.3251953125,
    6993.70947265625,
    5580.8056640625,
    5632.2783203125,
    5092.42578125,
    2410.132568359375,
    2207.6953125,
    2272.361328125,
    12640.509765625,
    3826.04296875,
    6331.650390625,
    6418.20068359375,
    10368.685546875,
    3086.651123046875,
    6032.6708984375,
    4597.826171875,
    2409.66552734375,
    2206.26611328125,
    2271.613525390625,
    5312.126953125,
    2388.00390625,
    3654.9189453125,
    3719.1533203125,
    3298.998046875,
    7276.30810546875,
    19803.58203125,
    3335.1533203125,
    3332.22607421875,
    2189.14892578125,
    2263.641845703125,
    9741.9033203125,
    2290.30419921875,
    6842.8564453125,
    3072.412841796875,
    62908.10546875,
    6378.79052734375,
    8261.029296875,
    9935.9169921875,
    7475.4189453125,
    9916.91796875,
    12091.5859375,
    4818.650390625,
    8269.17578125,
    17827.76171875,
    10476.462890625,
    5188.6611328125,
    2200.969970703125,
    6348.3662109375,
    18452.115234375,
    8234.67578125,
    8911.3115234375,
    4430.267578125,
    2685.104248046875,
    349.27056884765625,
    4666.45849609375,
    8381.2431640625,
    6188.0205078125,
    2679.473388671875,
    4761.02685546875,
    2933.316650390625,
    15433.248046875,
    22829.8203125,
    2264.124755859375,
    2045.21630859375,
    6222.53271484375,
    5859.37744140625,
    5567.89208984375,
    2227.552734375,
    2156.91064453125,
    2235.96435546875,
    4730.57080078125,
    2046.66162109375,
    2312.55908203125,
    5118.09423828125,
    5095.71044921875,
    2429.399658203125,
    3798.70166015625,
    2124.23828125,
    2040.747314453125,
    3511.625732421875,
    3499.687255859375,
    2601.685791015625,
    2320.56982421875,
    2056.253173828125,
    3511.850830078125,
    4947.02392578125,
    3565.18798828125,
    10929.0771484375,
    10871.357421875,
    5826.96923828125,
    7798.5712890625,
    5960.55712890625,
    5961.46435546875,
    3498.966552734375,
    3494.100830078125,
    5951.25927734375,
    6247.21337890625,
    6058.4296875,
    8020.1201171875,
    3759.45654296875,
    4537.8974609375,
    5752.943359375,
    5286.35986328125,
    2174.55224609375,
    1957.2398681640625,
    8469.9501953125,
    6226.39111328125,
    4681.92822265625,
    4759.74755859375,
    5272.783203125,
    6749.27294921875,
    7505.76171875,
    9037.4384765625,
    8661.599609375,
    10334.392578125,
    7180.41650390625,
    5021.50439453125,
    7751.7353515625,
    3524.773193359375,
    4793.015625,
    4969.8603515625,
    3507.208740234375,
    4960.85986328125,
    3578.934814453125,
    2064.778564453125,
    9005.26953125,
    8660.2587890625,
    4452.08935546875,
    3503.256591796875,
    4961.3642578125,
    2418.874267578125,
    3716.439453125,
    10020.1943359375,
    2337.513427734375,
    5668.30126953125,
    5681.73046875,
    9283.576171875,
    12717.6474609375,
    4569.9921875,
    3942.684326171875,
    7585.97705078125,
    4217.181640625,
    5585.24658203125,
    20301.947265625,
    10222.9443359375,
    2121.520751953125,
    2139.8974609375,
    7779.0126953125,
    5761.85302734375,
    5337.84375,
    2363.786865234375,
    2836.474609375,
    4795.22412109375,
    5619.81640625,
    3448.653564453125,
    4138.10205078125,
    2599.255859375,
    1989.4140625,
    10449.6181640625,
    2249.995361328125,
    4729.94970703125,
    3256.4111328125,
    4143.828125,
    3443.287841796875,
    7851.169921875,
    7654.27197265625,
    1916.248291015625,
    3853.535400390625,
    2172.458984375,
    2212.15625,
    4942.06201171875,
    3883.860595703125,
    8385.0927734375,
    9656.3349609375,
    16817.84375,
    8246.650390625,
    11445.5400390625,
    8089.0615234375,
    9910.5,
    4903.451171875,
    4646.7265625,
    23208.509765625,
    44455.44140625,
    10734.0361328125,
    3840.439697265625,
    2139.156005859375,
    2542.52392578125,
    2549.746337890625,
    4603.3740234375,
    19885.4609375,
    13299.8935546875,
    13179.6240234375,
    7872.90966796875,
    14671.3916015625,
    5951.64013671875,
    2059.93994140625,
    7405.9521484375,
    3494.43798828125,
    10741.0615234375,
    2192.28369140625,
    2329.665771484375,
    2491.529052734375,
    5415.72509765625,
    9937.482421875,
    187.5601348876953,
    24822.673828125,
    8228.703125,
    2731.244873046875,
    11521.1748046875,
    7427.1669921875,
    11208.9296875,
    24143.296875,
    12457.18359375,
    4835.38134765625,
    22938.447265625,
    5897.12939453125,
    2189.37548828125,
    5641.30078125,
    3134.727294921875,
    14732.375,
    19008.869140625,
    27053.34375,
    4114.05712890625,
    5170.68505859375,
    12933.4892578125,
    10899.90625,
    26772.458984375,
    9443.748046875,
    2373.3974609375,
    94.62042999267578,
    121.45523071289062,
    8287.51953125,
    4784.3388671875,
    2359.577880859375,
    4543.5185546875,
    2569.7978515625,
    5479.416015625,
    7129.95947265625,
    14479.357421875,
    33308.32421875,
    7882.24755859375,
    21463.06640625,
    5432.97412109375,
    2198.245849609375,
    24185.634765625,
    14982.609375,
    4832.33984375,
    8425.576171875,
    6291.76220703125,
    10609.84765625,
    4843.1142578125,
    16943.65234375,
    14527.66015625,
    6974.18896484375,
    46011.55078125,
    28911.708984375,
    17603.494140625,
    10122.7138671875,
    6158.0703125,
    2272.634033203125,
    5135.35009765625,
    4989.94921875,
    4579.36767578125,
    4977.923828125,
    7366.95703125,
    7351.78466796875,
    7636.82373046875,
    2051.48388671875,
    2018.6002197265625,
    4793.30078125,
    3920.40380859375,
    1889.2733154296875,
    3196.97998046875,
    8798.4990234375,
    2121.1796875,
    1905.1517333984375,
    8103.736328125,
    6782.9130859375,
    12219.71875,
    17858.041015625,
    6195.87939453125,
    10225.5390625,
    39664.15625,
    37985.04296875,
    6177.45751953125,
    20394.095703125,
    6282.97802734375,
    2326.607666015625,
    2324.646240234375,
    4568.369140625,
    5618.32666015625,
    6870.13916015625,
    4488.4990234375,
    7194.95166015625,
    2992.28955078125,
    2033.1004638671875,
    9884.23046875,
    97921.25,
    6035.54931640625,
    7363.41943359375,
    4472.47509765625,
    64735.77734375,
    78.72515106201172,
    2571.76416015625,
    1907.9287109375,
    7696.60009765625,
    15231.2958984375,
    12387.31640625,
    15415.4794921875,
    28519.212890625,
    2255.439208984375,
    5957.31494140625,
    4045.015869140625,
    9755.640625,
    12851.859375,
    10919.44140625,
    4995.91455078125,
    192198.859375,
    12710.3720703125,
    3736.888916015625,
    2068.533203125,
    55488.28515625,
    11113.0693359375,
    18571.857421875,
    1900.897216796875,
    5802.30224609375,
    26114.083984375,
    8616.3701171875,
    1843.2032470703125,
    15434.3349609375,
    6222.3388671875,
    1992.804931640625,
    2420.216796875,
    9308.0712890625,
    4624.04443359375,
    5965.02001953125,
    77244.421875,
    7368.82177734375,
    6973.087890625,
    4020.072021484375,
    4759.05712890625,
    2160.012939453125,
    2584.531982421875,
    2489.4716796875,
    921.0784912109375,
    912.2615356445312,
    2940.014892578125,
    2917.47509765625,
    637.0858154296875,
    19369.767578125,
    13819.32421875,
    7334.44921875,
    2777.95361328125,
    4765.1572265625,
    13230.7275390625,
    7955.59912109375,
    5139.6484375,
    4847.23388671875,
    5019.97705078125,
    47.02851867675781,
    44.49938201904297,
    226.06907653808594,
    6184.966796875,
    2141.353759765625,
    2139.07568359375,
    2086.858642578125,
    10236.9853515625,
    4959.06884765625,
    6832.46630859375,
    5270.78125,
    7485.1142578125,
    3621.221923828125,
    4883.57568359375,
    7180.49169921875,
    3726.44970703125,
    16916.81640625,
    2213.924560546875,
    3778.570556640625,
    6323.92236328125,
    1982.0455322265625,
    21584.515625,
    10302.2763671875,
    27553.5390625,
    8572.82421875,
    37283.64453125,
    6821.14697265625,
    14003.6494140625,
    11397.7666015625,
    12447.5380859375,
    2062.93212890625,
    1814.9619140625,
    3936.94189453125,
    2175.675537109375,
    2002.9693603515625,
    1799.4471435546875,
    1828.29150390625,
    6385.884765625,
    9317.7685546875,
    4091.48193359375,
    7945.85302734375,
    4879.69775390625,
    4905.8388671875,
    12838.8369140625,
    8339.365234375,
    12944.0859375,
    2200.837646484375,
    25929.38671875,
    6169.5048828125,
    5301.85009765625,
    15128.4482421875,
    3319.343017578125,
    13080.31640625,
    10234.861328125,
    1986.1435546875,
    8641.3369140625,
    28909.638671875,
    7581.18017578125,
    5490.03564453125,
    23415.48046875,
    2167.587646484375,
    3600.215576171875,
    2165.48193359375,
    21900.171875,
    24242.927734375,
    7653.67041015625,
    9341.9697265625,
    13305.0283203125,
    13940.1650390625,
    10329.4443359375,
    17809.591796875,
    6220.244140625,
    15135.0029296875,
    8569.791015625,
    15495.9306640625,
    4614.7041015625,
    7530.248046875,
    19693.79296875,
    43163.56640625,
    10660.17578125,
    11066.2587890625,
    4083.57080078125,
    5343.16943359375,
    6050.73095703125,
    11460.0966796875,
    6250.57080078125,
    15682.2470703125,
    11033.0068359375,
    4218.79345703125,
    2434.69384765625,
    8903.1826171875,
    10931.2080078125,
    19205.125,
    3415.49755859375,
    16436.71875,
    9305.185546875,
    11275.470703125,
    11329.115234375,
    8328.744140625,
    6124.2412109375,
    10939.390625,
    6385.01708984375,
    20055.802734375,
    2233.008056640625,
    2377.25048828125,
    5968.09765625,
    7749.314453125,
    9109.279296875,
    4594.43896484375,
    9360.6416015625,
    4943.53466796875,
    8884.7158203125,
    10174.2109375,
    7540.97265625,
    6002.57421875,
    4160.89501953125,
    3645.085693359375,
    14500.935546875,
    14261.7236328125,
    10536.3642578125,
    7398.58740234375,
    5942.296875,
    4749.2998046875,
    4773.98193359375,
    24481.623046875,
    10522.638671875,
    6084.65771484375,
    6389.6455078125,
    9347.216796875,
    7436.06005859375,
    579.6461181640625,
    2982.226806640625,
    5684.73681640625,
    12269.6455078125,
    6021.3154296875,
    2144.93994140625,
    2394.258544921875,
    3503.936767578125,
    2102.782958984375,
    2269.981689453125,
    2318.5693359375,
    5296.841796875,
    18210.830078125,
    7317.1640625,
    5474.67431640625,
    20333.984375,
    6993.65283203125,
    9571.0927734375,
    6498.48681640625,
    7417.03955078125,
    24866.19140625,
    7210.3544921875,
    20665.40234375,
    6667.7880859375,
    18697.98828125,
    26854.626953125,
    2480.846923828125,
    4123.15771484375,
    11356.2109375,
    2356.697998046875,
    3656.5615234375,
    2550.11767578125,
    7606.98779296875,
    1938.9583740234375,
    5807.3095703125,
    4349.12451171875,
    9451.578125,
    2745.3935546875,
    2785.126220703125,
    2149.9228515625,
    7057.16650390625,
    8727.66796875,
    3536.314453125,
    5792.47021484375,
    2427.52783203125,
    4078.8349609375,
    19948.935546875,
    362.3910827636719,
    6796.57666015625,
    22142.384765625,
    16424.970703125,
    4527.89892578125,
    28879.626953125,
    13796.8779296875,
    1884.07275390625,
    1730.7757568359375,
    1851.416015625,
    3235.006103515625,
    9211.25,
    12503.16015625,
    10798.291015625,
    8691.8271484375,
    5307.0595703125,
    2258.59814453125,
    2363.341552734375,
    8168.93310546875,
    4918.05224609375,
    13346.9208984375,
    4489.7275390625,
    4118.298828125,
    2831.1484375,
    17250.96875,
    4689.90234375,
    7242.7919921875,
    11589.4130859375,
    13940.7607421875,
    24623.625,
    11456.4052734375,
    6875.06494140625,
    6304.74609375,
    10625.0869140625,
    17787.318359375,
    7027.08837890625,
    10105.85546875,
    13120.1376953125,
    13131.939453125,
    2399.424072265625,
    2399.79443359375,
    2404.86669921875,
    2414.91748046875,
    11166.1123046875,
    9952.9384765625,
    13715.8037109375,
    18942.76953125,
    1868.0255126953125,
    4661.90283203125,
    4645.94775390625,
    2409.751953125,
    8059.57080078125,
    2286.75439453125,
    2268.594970703125,
    1857.4197998046875,
    4378.64111328125,
    760.91015625,
    2176.674072265625,
    5338.76806640625,
    21219.279296875,
    274.7578430175781,
    5866.88134765625,
    2441.654052734375,
    15898.2861328125,
    13059.810546875,
    6307.6845703125,
    9106.5361328125,
    2014.6552734375,
    4015.3955078125,
    11593.333984375,
    18458.685546875,
    2024.941650390625,
    4005.83349609375,
    10333.1982421875,
    14007.0400390625,
    26045.09375,
    9679.634765625,
    14397.2763671875,
    26095.712890625,
    13487.8564453125,
    6446.90625,
    5245.40087890625,
    28337.0546875,
    8177.8212890625,
    3282.903564453125,
    3332.865478515625,
    5086.12109375,
    5077.7001953125,
    5075.7314453125,
    6019.689453125,
    9717.625,
    12048.4658203125,
    8978.8349609375,
    4675.98974609375,
    4809.80029296875,
    4801.21875,
    10478.50390625,
    8493.68359375,
    8066.89453125,
    2200.656005859375,
    2108.17919921875,
    5805.08544921875,
    12506.197265625,
    7807.97998046875,
    21058.35546875,
    6840.96533203125,
    4544.7314453125,
    4530.98828125,
    14817.9130859375,
    17977.818359375,
    8746.5029296875,
    8642.8330078125,
    25222.31640625,
    11850.0419921875,
    20524.39453125,
    33745.921875,
    22197.03125,
    12206.1904296875,
    4708.927734375,
    7808.55712890625,
    7670.09326171875,
    7505.1611328125,
    22227.8203125,
    24533.740234375,
    1883.3616943359375,
    18673.884765625,
    18463.748046875,
    22114.8984375,
    5817.896484375,
    15225.8310546875,
    18573.955078125,
    14150.7421875,
    13654.1357421875,
    11314.1943359375,
    8168.94873046875,
    6655.90625,
    3256.305908203125,
    19389.232421875,
    4348.16748046875,
    8555.865234375,
    9107.5771484375,
    8425.0615234375,
    5991.8935546875,
    17850.013671875,
    63671.8984375,
    2959.1630859375,
    7962.947265625,
    7950.47412109375,
    3123.572998046875,
    1822.9814453125,
    1789.6190185546875,
    2638.4375,
    2861.0166015625,
    3674.328857421875,
    2867.852783203125,
    2631.8388671875,
    5508.392578125,
    4337.90283203125,
    2356.2978515625,
    3454.392822265625,
    3451.650146484375,
    3453.18603515625,
    18000.02734375,
    9012.5458984375,
    3450.13818359375,
    4922.07080078125,
    3056.611572265625,
    2105.85498046875,
    2189.71728515625,
    17992.724609375,
    2271.658935546875,
    2040.9739990234375,
    2679.844482421875,
    18870.578125,
    11947.7626953125,
    18074.3515625,
    1815.174560546875,
    6617.361328125,
    4190.52392578125,
    15182.974609375,
    24431.451171875,
    53288.0703125,
    5310.4541015625,
    9760.810546875,
    22092.50390625,
    27731.669921875,
    97768.21875,
    8680.1162109375,
    32.85203170776367,
    28443.3359375,
    1831.84423828125,
    31852.328125,
    27448.462890625,
    27694.15625,
    4428.771484375,
    6358.33251953125,
    7139.67138671875,
    19429.28515625,
    29266.328125,
    30163.609375,
    22171.734375,
    3240.54833984375,
    25144.4609375,
    26114.9921875,
    4866.57568359375,
    24638.34765625,
    36505.71484375,
    16059.1572265625,
    6213.111328125,
    37277.70703125,
    35833.33984375,
    33872.140625,
    24442.41015625,
    4143.314453125,
    7923.55322265625,
    2016.770751953125,
    2152.828369140625,
    26279.189453125,
    7798.43115234375,
    7306.6533203125,
    353.4560546875,
    2408.712158203125,
    2414.493408203125,
    4579.8857421875,
    5921.78466796875,
    1068.0025634765625,
    16650.80078125,
    5767.46484375,
    8320.515625,
    45.45830154418945,
    28529.333984375,
    6117.1044921875,
    6117.1044921875,
    5139.865234375,
    2530.1396484375,
    14803.6181640625,
    12282.01171875,
    4742.93212890625,
    11650.2314453125,
    4811.44970703125,
    8214.2412109375,
    7676.1923828125,
    5391.99267578125,
    2214.986328125,
    2078.224609375,
    18227.640625,
    20851.5703125,
    16764.943359375,
    10067.4873046875,
    4784.125,
    74788.34375,
    28014.1953125,
    23318.259765625,
    28795.33984375,
    4656.37353515625,
    3172.393310546875,
    2253.379150390625,
    7938.0390625,
    4861.73095703125,
    10270.9697265625,
    7411.70947265625,
    8197.7890625,
    2401.484375,
    2372.213134765625,
    7699.009765625,
    2370.131103515625,
    2351.776123046875,
    2377.011474609375,
    2310.5419921875,
    2292.392578125,
    5493.51416015625,
    8394.23828125,
    6041.07275390625,
    6092.4697265625,
    6068.82958984375,
    20339.19921875,
    25915.15234375,
    2352.423095703125,
    6480.837890625,
    4551.57421875,
    4864.80126953125,
    8043.2021484375,
    7851.80712890625,
    8533.1884765625,
    26648.423828125,
    10907.875,
    15348.60546875,
    8949.6923828125,
    1770.4656982421875,
    15399.1572265625,
    17705.84375,
    7042.39404296875,
    8424.09375,
    11350.2255859375,
    37767.40234375,
    7536.62158203125,
    9624.5517578125,
    16343.578125,
    22055.296875,
    7195.44140625,
    5296.70361328125,
    2630.112548828125,
    34756.69140625,
    6288.7958984375,
    31276.796875,
    41646.19140625,
    87357.3671875,
    40272.42578125,
    24972.427734375,
    20266.65234375,
    26477.779296875,
    25337.5390625,
    13390.5478515625,
    10258.0341796875,
    4343.17626953125,
    34686.3359375,
    32623.32421875,
    32347.552734375,
    16108.8388671875,
    16105.0185546875,
    14693.9404296875,
    50077.15625,
    19592.359375,
    5369.1884765625,
    10239.6953125,
    2017.7371826171875,
    5570.025390625,
    5596.8857421875,
    9450.904296875,
    2224.82958984375,
    1975.7076416015625,
    263.1875305175781,
    9738.3271484375,
    12439.697265625,
    1803.6243896484375,
    6232.3564453125,
    54.992855072021484,
    2144.057373046875,
    478.0576171875,
    14839.412109375,
    3284.26318359375,
    17919.9921875,
    10282.14453125,
    2243.03076171875,
    2143.040771484375,
    3559.343994140625,
    280.7352600097656,
    5838.80419921875,
    1844.3212890625,
    12718.078125,
    5865.36181640625,
    1965.270263671875,
    9903.1767578125,
    7560.87255859375,
    4282.34521484375,
    24766.845703125,
    10884.7978515625,
    14307.7001953125,
    17086.716796875,
    1826.623779296875,
    15202.87109375,
    1916.01318359375,
    8650.5224609375,
    9048.451171875,
    14388.7978515625,
    14599.3125,
    23493.505859375,
    37072.71875,
    4744.466796875,
    4253.466796875,
    33667.50390625,
    6240.40771484375,
    6496.2861328125,
    10424.15625,
    7688.62646484375,
    7750.1435546875,
    5894.33544921875,
    6106.8603515625,
    7663.771484375,
    6388.4150390625,
    11351.267578125,
    5598.0849609375,
    4169.1767578125,
    8702.2119140625,
    19947.224609375,
    7248.19677734375,
    15640.87109375,
    10360.9599609375,
    23550.380859375,
    9093.927734375,
    23080.40625,
    14664.2509765625,
    5320.4736328125,
    14648.3984375,
    11343.30078125,
    8175.60546875,
    8134.0361328125,
    2997.536865234375,
    2027.1549072265625,
    38050.32421875,
    7596.1572265625,
    8095.37109375,
    8176.5986328125,
    14773.7119140625,
    12029.576171875,
    9340.3095703125,
    17625.99609375,
    36421.9609375,
    23809.080078125,
    11894.185546875,
    9367.0556640625,
    10149.16796875,
    24380.1796875,
    7637.8818359375,
    10008.423828125,
    11324.6845703125,
    8987.7861328125,
    4048.62158203125,
    15919.576171875,
    4027.045654296875,
    133673.90625,
    24031.421875,
    93322.09375,
    53892.4921875,
    19096.619140625,
    20099.35546875,
    8487.07421875,
    14405.9697265625,
    8180.78515625,
    6806.48583984375,
    9904.681640625,
    5931.3076171875,
    8828.369140625,
    16210.01953125,
    7762.9140625,
    17118.841796875,
    7851.6064453125,
    13153.1669921875,
    209149.03125,
    2199.2392578125,
    2134.068359375,
    3193.27490234375,
    19822.875,
    14052.830078125,
    11858.4287109375,
    6087.75732421875,
    9727.888671875,
    2254.886474609375,
    4371.70654296875,
    2543.338623046875,
    2086.672119140625,
    4962.22802734375,
    12731.388671875,
    4213.634765625,
    15447.3642578125,
    4202.419921875,
    4032.625244140625,
    9938.7041015625,
    12081.1474609375,
    7738.89453125,
    6533.65380859375,
    14337.759765625,
    5496.00537109375,
    19295.080078125,
    5957.0869140625,
    11930.5830078125,
    3011.88818359375,
    12479.048828125,
    7532.396484375,
    23554.345703125,
    28420.818359375,
    61589.98828125,
    55881.42578125,
    15168.951171875,
    26353.28125,
    2164.639892578125,
    2137.403076171875,
    2140.035400390625,
    2138.626953125,
    6280.30322265625,
    24734.26171875,
    4905.9423828125,
    2545.55029296875,
    5531.11083984375,
    11478.271484375,
    12769.4140625,
    13942.658203125,
    1924.77685546875,
    7128.40234375,
    8311.9091796875,
    7047.4501953125,
    4791.33251953125,
    8084.5966796875,
    8638.642578125,
    7101.69775390625,
    2259.41650390625,
    8367.3291015625,
    5172.8916015625,
    9558.7138671875,
    5997.27294921875,
    7612.7119140625,
    6222.81396484375,
    7946.1748046875,
    5538.07373046875,
    8313.455078125,
    5246.8447265625,
    1884.850341796875,
    2326.1103515625,
    2460.825439453125,
    12018.984375,
    7627.19091796875,
    7421.873046875,
    7355.19189453125,
    11098.13671875,
    62580.94140625,
    8781.55859375,
    34501.74609375,
    35907.3671875,
    2837.90771484375,
    2762.61328125,
    24003.375,
    10818.0478515625,
    7554.68505859375,
    7311.5048828125,
    5579.28125,
    8200.6923828125,
    4339.40771484375,
    5345.2421875,
    7130.78125,
    7695.2568359375,
    34637.6484375,
    5498.94970703125,
    11068.5048828125,
    3153.696533203125,
    5975.98974609375,
    24683.482421875,
    4181.994140625,
    6682.8583984375,
    10350.673828125,
    8708.4609375,
    11396.0166015625,
    20133.1171875,
    16736.892578125,
    18604.32421875,
    13063.384765625,
    5516.0625,
    11330.10546875,
    20133.1171875,
    16580.04296875,
    4787.03173828125,
    4746.873046875,
    28312.85546875,
    10860.16015625,
    10803.849609375,
    12320.64453125,
    10028.2490234375,
    11884.4951171875,
    12958.591796875,
    2096.15234375,
    4300.71923828125,
    14552.9375,
    2380.5478515625,
    5624.36181640625,
    7074.43310546875,
    7050.19970703125,
    5609.943359375,
    7891.2177734375,
    5774.51806640625,
    12277.166015625,
    8892.48046875,
    7329.36328125,
    2652.9443359375,
    5927.0234375,
    7348.81103515625,
    5885.3466796875,
    8078.7080078125,
    6156.85009765625,
    16400.486328125,
    6016.11181640625,
    6022.98974609375,
    6022.98974609375,
    6554.615234375,
    27485.703125,
    5375.0771484375,
    3944.708984375,
    4959.34130859375,
    4946.00244140625,
    5303.3515625,
    5128.4189453125,
    9047.529296875,
    8033.57373046875,
    7939.60107421875,
    10150.1435546875,
    9885.71484375,
    4871.1025390625,
    61976.75390625,
    14053.2412109375,
    42288.265625,
    5649.2265625,
    11451.1884765625,
    14459.6005859375,
    12880.697265625,
    8838.6083984375,
    12986.35546875,
    16133.33984375,
    3647.998046875,
    6825.48828125,
    17546.712890625,
    46521.296875,
    22356.041015625,
    17446.525390625,
    2351.47119140625,
    58208.19140625,
    7920.03515625,
    5405.28271484375,
    18728.76171875,
    28265.140625,
    9434.501953125,
    7681.29248046875,
    5131.1953125,
    2961.96826171875,
    2833.211181640625,
    6306.39794921875,
    2595.187255859375,
    37501.12890625,
    16620.689453125,
    16694.630859375,
    15049.6201171875,
    7077.2041015625,
    32582.861328125,
    17516.763671875,
    15218.1953125,
    8361.69140625,
    6059.376953125,
    14718.9794921875,
    9484.38671875,
    25936.927734375,
    45021.14453125,
    13314.1650390625,
    4405.31640625,
    9407.560546875,
    5204.28271484375,
    8504.5478515625,
    10208.630859375,
    8968.4921875,
    12274.19140625,
    16907.80078125,
    6466.8505859375,
    28312.810546875,
    13532.087890625,
    19847.08203125,
    6228.2802734375,
    6477.7314453125,
    5347.873046875,
    13781.765625,
    11055.2705078125,
    8426.1953125,
    5209.92578125,
    33734.625,
    5556.44384765625,
    15710.0419921875,
    12972.0224609375,
    6172.7998046875,
    22586.373046875,
    10896.6708984375,
    5030.1357421875,
    4448.87353515625,
    4746.095703125,
    4409.818359375,
    2252.44091796875,
    8001.73388671875,
    11733.4501953125,
    13013.3544921875,
    2876.746337890625,
    5268.849609375,
    6231.96484375,
    8948.9677734375,
    5606.8857421875,
    2668.344970703125,
    16065.37890625,
    16459.693359375,
    12737.033203125,
    6159.65966796875,
    15909.3466796875,
    18258.263671875,
    9244.677734375,
    15963.9189453125,
    6003.9931640625,
    10420.8701171875,
    10266.330078125,
    6552.6015625,
    11899.2890625,
    13907.3232421875,
    10424.810546875,
    5136.1806640625,
    23123.9765625,
    13948.6708984375,
    5296.52734375,
    11001.9462890625,
    17607.259765625,
    9963.1708984375,
    4440.384765625,
    4737.6083984375,
    4401.330078125,
    5399.2060546875,
    5565.78662109375,
    9004.4130859375,
    9336.3544921875,
    8885.3984375,
    2825.85986328125,
    5216.34619140625,
    14263.919921875,
    14017.640625,
    6176.1474609375,
    18518.751953125,
    5181.84130859375,
    3267.38330078125,
    6272.01708984375,
    5177.74560546875,
    3268.010986328125,
    5519.0625,
    3596.873779296875,
    2002.7320556640625,
    6243.64501953125,
    2684.24658203125,
    2677.100341796875,
    5488.13916015625,
    3804.45654296875,
    8484.27734375,
    4325.62646484375,
    9755.9609375,
    9864.1416015625,
    9554.3056640625,
    7642.19091796875,
    8961.9580078125,
    33353.64453125,
    15978.8427734375,
    4658.78662109375,
    4594.3447265625,
    6141.83447265625,
    4232.21533203125,
    9996.8193359375,
    5386.43115234375,
    9176.3388671875,
    11022.3212890625,
    5742.640625,
    31368.96875,
    7076.017578125,
    17501.48046875,
    10854.9111328125,
    48354.109375,
    97733.6875,
    42382.85546875,
    15820.302734375,
    5921.24658203125,
    10331.7939453125,
    10927.2412109375,
    9378.9423828125,
    26191.814453125,
    8105.677734375,
    15033.3681640625,
    44080.62890625,
    20810.330078125,
    12413.6396484375,
    11004.8125,
    16593.40625,
    20718.32421875,
    6700.65576171875,
    38005.27734375,
    58954.65625,
    6297.91357421875,
    30342.86328125,
    59962.59765625,
    20232.935546875,
    32055.9765625,
    5113.86474609375,
    5951.7421875,
    5622.787109375,
    9135.626953125,
    9130.1171875,
    3346.176025390625,
    7555.85400390625,
    8582.986328125,
    22378.212890625,
    6887.76318359375,
    17725.974609375,
    5199.0927734375,
    6109.7080078125,
    7968.45166015625,
    6998.6513671875,
    10558.97265625,
    8488.8935546875,
    6746.935546875,
    24137.748046875,
    8939.1142578125,
    7024.96533203125,
    7543.04541015625,
    5559.962890625,
    7741.6171875,
    10894.09375,
    9099.0400390625,
    11823.7578125,
    13414.28515625,
    12239.33984375,
    8300.9140625,
    13798.2392578125,
    6709.7666015625,
    5558.3212890625,
    10153.400390625,
    2843.672119140625,
    4436.69580078125,
    9113.033203125,
    8268.6611328125,
    6080.4716796875,
    9608.2177734375,
    9596.3017578125,
    8362.1923828125,
    9667.3349609375,
    5833.16552734375,
    5539.6298828125,
    10658.548828125,
    3942.21630859375,
    7404.5673828125,
    5562.8427734375,
    8471.8583984375,
    19524.69921875,
    20454.701171875,
    6863.35302734375,
    10352.4736328125,
    18044.37109375,
    7454.48974609375,
    15975.9384765625,
    16307.9599609375,
    12449.30078125,
    12658.7861328125,
    5111.6728515625,
    7512.5986328125,
    2526.0712890625,
    16145.4111328125,
    16178.0263671875,
    26190.396484375,
    5901.89599609375,
    2264.005615234375,
    16061.1240234375,
    19753.97265625,
    6009.05615234375,
    7474.00634765625,
    4793.33740234375,
    2696.163330078125,
    7314.341796875,
    4991.31884765625,
    2768.368408203125,
    1846.9515380859375,
    5834.54736328125,
    7776.98046875,
    4407.5908203125,
    38696.640625,
    21029.564453125,
    9069.4609375,
    30183.50390625,
    11898.9765625,
    23241.421875,
    12166.349609375,
    5325.396484375,
    11304.4189453125,
    15263.33984375,
    20713.615234375,
    6679.38671875,
    15624.5029296875,
    18224.2578125,
    59660.859375,
    18268.3984375,
    31234.474609375,
    23869.94921875,
    18435.220703125,
    12549.0615234375,
    17796.033203125,
    16955.4296875,
    12414.6220703125,
    17900.234375,
    2261.6806640625,
    5041.66455078125,
    24073.58203125,
    39991.62109375,
    11557.8974609375,
    24385.35546875,
    30708.392578125,
    6834.8408203125,
    13004.5380859375,
    39535.96875,
    13001.8603515625,
    10115.029296875,
    9850.9248046875,
    14064.1025390625,
    15860.9130859375,
    29658.04296875,
    8948.7353515625,
    7033.33251953125,
    9489.572265625,
    11246.306640625,
    9333.0927734375,
    25461.138671875,
    7983.72802734375,
    27693.05859375,
    12096.2822265625,
    13296.11328125,
    50628.18359375,
    11157.0771484375,
    18488.716796875,
    126451.25,
    99153.03125,
    2645.294921875,
    46242.19921875,
    14101.4130859375,
    2849.779052734375,
    13837.4072265625,
    26552.177734375,
    3160.930419921875,
    18655.919921875,
    15587.580078125,
    45430.625,
    79710.1328125,
    177533.40625,
    201305.8125,
    3305.567138671875,
    3795.74560546875,
    7230.31005859375,
    6341.2421875,
    6462.27978515625,
    7306.55615234375,
    7179.91357421875,
    18795.89453125,
    7129.74169921875,
    23648.08984375,
    12628.00390625,
    10407.4189453125,
    19624.822265625,
    1976.9998779296875,
    16098.908203125,
    28487.1796875,
    16841.21484375,
    3108.11669921875,
    3019.701171875,
    3247.63134765625,
    7000.79345703125,
    4698.63916015625,
    7308.23046875,
    7407.39111328125,
    2826.358154296875,
    5605.857421875,
    4690.85302734375,
    4077.6904296875,
    4186.68359375,
    2818.86083984375,
    2555.34033203125,
    10820.189453125,
    6863.60302734375,
    2821.78173828125,
    310.7351379394531,
    2404.307861328125,
    2582.3330078125,
    2817.91455078125,
    5765.2734375,
    737.3811645507812,
    3535.35546875,
    11225.6708984375,
    9780.451171875,
    9819.0185546875,
    2489.958740234375,
    12895.3359375,
    12554.5830078125,
    2870.031005859375,
    23481.27734375,
    24401.244140625,
    2748.718017578125,
    1266.7828369140625,
    3442.126953125,
    1952.506591796875,
    2635.9521484375,
    2669.0625,
    10536.8876953125,
    2195.056640625,
    11392.359375,
    17534.515625,
    17174.173828125,
    12274.2529296875,
    701.65576171875,
    7794.57763671875,
    2057.206787109375,
    9695.3955078125,
    2825.540771484375,
    3620.119140625,
    5972.3076171875,
    2722.528076171875,
    2699.19580078125,
    6806.57080078125,
    646.0206909179688,
    3576.73046875,
    5272.88134765625,
    2579.4306640625,
    2484.151611328125,
    2283.83642578125,
    6523.34033203125,
    5455.8173828125,
    5000.2900390625,
    15841.1767578125,
    9774.1787109375,
    11883.2490234375,
    13557.681640625,
    20350.2734375,
    14402.3310546875,
    13258.8056640625,
    9417.267578125,
    5573.3798828125,
    4692.06689453125,
    14722.7138671875,
    21829.580078125,
    11755.4716796875,
    12315.5400390625,
    11279.818359375,
    11922.0947265625,
    2384.90576171875,
    2344.964111328125,
    5421.39111328125,
    2657.79248046875,
    7067.59716796875,
    2813.995361328125,
    14923.861328125,
    10090.3896484375,
    2172.57080078125,
    17060.779296875,
    10658.8740234375,
    2355.889404296875,
    2361.074951171875,
    3075.60400390625,
    18748.81640625,
    2807.409423828125,
    14308.630859375,
    2155.16943359375,
    5706.49853515625,
    11131.498046875,
    9493.7275390625,
    13195.140625,
    3522.199951171875,
    14487.1904296875,
    18689.833984375,
    9272.375,
    8691.4541015625,
    11972.9765625,
    22689.5703125,
    6674.6298828125,
    5731.52001953125,
    7355.48681640625,
    6834.81689453125,
    3137.8564453125,
    35043.75,
    11770.2431640625,
    11794.4677734375,
    43745.21875,
    11410.677734375,
    17378.177734375,
    11403.482421875,
    9796.9482421875,
    17046.50390625,
    6995.9814453125,
    17596.892578125,
    47884.25390625,
    3995.006591796875,
    12667.671875,
    40341.7109375,
    29323.791015625,
    6215.65869140625,
    2288.96337890625,
    17867.703125,
    17225.224609375,
    6406.2958984375,
    20291.16015625,
    17616.416015625,
    11631.9609375,
    18897.2890625,
    15486.5986328125,
    61044.859375,
    6239.568359375,
    2093.73046875,
    13342.767578125,
    17190.171875,
    4998.533203125,
    7154.29736328125,
    19883.349609375,
    2487.88134765625,
    41528.90234375,
    27138.96484375,
    13477.8564453125,
    14801.07421875,
    16715.078125,
    25109.75,
    14994.5263671875,
    4089.587158203125,
    87951.515625,
    7967.6943359375,
    72560.3046875,
    19692.64453125,
    7370.86181640625,
    69449.6640625,
    8189.37353515625,
    15335.1982421875,
    11975.7490234375,
    7135.92724609375,
    22832.494140625,
    6560.87890625,
    19542.529296875,
    82118.421875,
    21463.66796875,
    36951.51171875,
    21771.955078125,
    61940.52734375,
    4214.2529296875,
    7909.1396484375,
    58948.34765625,
    6410.9951171875,
    42406.30859375,
    2839.60595703125,
    9009.078125,
    7292.240234375,
    17145.134765625,
    34202.10546875,
    21384.3359375,
    66446.2578125,
    18911.931640625,
    10927.197265625,
    11062.572265625,
    2549.56640625,
    5812.80712890625,
    7711.0986328125,
    4585.9052734375,
    7376.330078125,
    46605.23828125,
    39035.81640625,
    17394.541015625,
    6879.228515625,
    8341.2626953125,
    8241.591796875,
    7356.3701171875,
    8646.5302734375,
    2262.837646484375,
    2122.30029296875,
    2143.395751953125,
    6105.27587890625,
    7078.2265625,
    10748.767578125,
    11692.3603515625,
    6782.771484375,
    9656.728515625,
    8366.0517578125,
    62492.359375,
    31963.76171875,
    24410.216796875,
    12603.5205078125,
    41176.3984375,
    21490.728515625,
    192630.75,
    32168.505859375,
    778.6817016601562,
    7409.3720703125,
    6174.21923828125,
    7254.86962890625,
    6035.02294921875,
    11052.40234375,
    777.9790649414062,
    4184.607421875,
    4379.2763671875,
    8655.953125,
    2788.695556640625,
    4360.95947265625,
    6864.76953125,
    6738.05419921875,
    21015.41015625,
    13671.02734375,
    29205.0,
    2583.3271484375,
    3280.279052734375,
    5692.2666015625,
    8659.2587890625,
    2796.36669921875,
    9881.759765625,
    27497.828125,
    12733.28515625,
    11375.2177734375,
    11182.587890625,
    4068.13232421875,
    6692.33740234375,
    11949.7158203125,
    26030.958984375,
    4814.6572265625,
    6135.5966796875,
    5217.404296875,
    3826.234619140625,
    2361.412109375,
    5567.0869140625,
    9868.8701171875,
    3075.820068359375,
    26259.0703125,
    28627.3828125,
    9798.138671875,
    3683.783447265625,
    19318.587890625,
    27030.546875,
    28789.662109375,
    22224.783203125,
    12971.6796875,
    11947.63671875,
    11386.9130859375,
    19505.1875,
    41889.45703125,
    8731.212890625,
    10192.3603515625,
    8255.029296875,
    11863.720703125,
    8920.3828125,
    26854.427734375,
    5479.5673828125,
    7696.99853515625,
    16957.38671875,
    11609.10546875,
    14370.1162109375,
    60928.328125,
    28877.21484375,
    32317.708984375,
    21120.091796875,
    6800.41650390625,
    45797.99609375,
    8774.625,
    9912.4384765625,
    5602.974609375,
    11018.5712890625,
    38377.80078125,
    12652.943359375,
    8035.2431640625,
    43531.234375,
    35604.3359375,
    50313.4921875,
    13329.0986328125,
    39455.84375,
    15533.70703125,
    8799.6005859375,
    30940.177734375,
    40990.90234375,
    82118.890625,
    8676.158203125,
    66584.7265625,
    16199.5673828125,
    17956.060546875,
    71276.671875,
    18150.69140625,
    61898.3671875,
    3586.125732421875,
    13543.55078125,
    77816.3359375,
    7033.2685546875,
    5087.75146484375,
    14103.0302734375,
    10793.6494140625,
    31568.8203125,
    80129.03125,
    70668.4296875,
    7634.099609375,
    52880.95703125,
    68161.6015625,
    215647.875,
    52536.08984375,
    11084.3837890625,
    10466.306640625,
    2990.5478515625,
    4375.79248046875,
    9568.9248046875,
    3721.074462890625,
    6618.93359375,
    93556.171875,
    15290.3408203125,
    14198.0458984375,
    46758.5234375,
    116864.8359375,
    23942.5546875,
    388.4637145996094,
    4254.419921875,
    85.8593521118164,
    62966.3671875,
    31780.37109375,
    19229.12890625,
    8913.880859375,
    10450.240234375,
    39818.78125,
    12397.185546875,
    10932.0791015625,
    31109.48828125,
    8303.09375,
    6647.53515625,
    5541.8212890625,
    21949.447265625,
    2678.88623046875,
    33634.5390625,
    22929.46875,
    8282.71875,
    73121.5703125,
    67724.203125,
    6097.18896484375,
    26561.736328125,
    80551.140625,
    16868.8359375,
    6995.9853515625,
    28885.994140625,
    13889.8076171875,
    10032.693359375,
    6644.57763671875,
    10992.58984375,
    16415.796875,
    12709.70703125,
    9545.134765625,
    3874.527587890625,
    15333.0458984375,
    6439.0146484375,
    13785.8232421875,
    75709.984375,
    27682.294921875,
    39770.41796875,
    3198.824951171875,
    18052.712890625,
    8593.150390625,
    7708.04833984375,
    11091.724609375,
    5359.51416015625,
    9842.85546875,
    5534.41943359375,
    116162.7734375,
    89311.171875,
    106968.5078125,
    14679.5263671875,
    3723.33203125,
    9678.5986328125,
    52252.6484375,
    29118.4609375,
    60137.765625,
    195640.296875,
    18885.744140625,
    9512.87109375,
    10456.0126953125,
    7658.5556640625,
    2442.279296875,
    3753.727783203125,
    9539.9990234375,
    7521.09716796875,
    2668.44091796875,
    2558.66357421875,
    2484.74951171875,
    8207.599609375,
    84142.1640625,
    24270.7890625,
    75451.1953125,
    7459.54833984375,
    7577.216796875,
    7564.10107421875,
    7323.6337890625,
    4294.87158203125,
    3033.459228515625,
    2183.126220703125,
    4952.740234375,
    4921.75146484375,
    2061.67724609375,
    6824.859375,
    30402.66796875,
    7253.482421875,
    4687.771484375,
    7104.20751953125,
    6956.88671875,
    2195.944091796875,
    2128.642578125,
    2605.901123046875,
    4276.3427734375,
    6094.56396484375,
    12159.962890625,
    8913.26171875,
    4491.58984375,
    2732.474365234375,
    6967.7451171875,
    5430.8564453125,
    3801.77490234375,
    1930.7403564453125,
    14476.5791015625,
    57526.953125,
    9699.7568359375,
    5893.94677734375,
    10506.75,
    134108.1875,
    2052.967529296875,
    2398.47216796875,
    22077.666015625,
    18825.80859375,
    5959.6123046875,
    4545.81103515625,
    8679.8544921875,
    7392.33056640625,
    7661.30078125,
    7388.2255859375,
    13336.263671875,
    3958.97021484375,
    6824.53076171875,
    5063.7255859375,
    57397.33984375,
    15276.8603515625,
    17677.810546875,
    35510.4375,
    10252.896484375,
    4142.62060546875,
    9050.4990234375,
    27909.634765625,
    50328.70703125,
    8122.5673828125,
    5278.82177734375,
    10765.80859375,
    11419.8076171875,
    10377.37109375,
    3750.667236328125,
    20171.34375,
    27167.791015625,
    2488.3896484375,
    6888.67431640625,
    9936.2822265625,
    9438.373046875,
    59990.3671875,
    131908.0625,
    7646.5068359375,
    2006.4007568359375,
    149582.671875,
    52156.72265625,
    44558.19140625,
    2662.6279296875,
    20944.431640625,
    3030.1396484375,
    15752.072265625,
    22073.29296875,
    13850.01953125,
    12122.677734375,
    58725.32421875,
    60444.3671875,
    14043.75390625,
    3887.375244140625,
    7398.900390625,
    78607.34375,
    48809.828125,
    55678.66796875,
    5912.876953125,
    23918.908203125,
    3309.699951171875,
    10879.09765625,
    5909.74755859375,
    6507.87353515625,
    5837.80029296875,
    3634.031982421875,
    124000.078125,
    3194.52197265625,
    19466.990234375,
    7169.3779296875,
    5889.76025390625,
    1153.4371337890625,
    11565.224609375,
    13056.921875,
    1916.550537109375,
    2439.567626953125,
    4727.826171875,
    4726.14013671875,
    4685.54833984375,
    4804.142578125,
    2948.697509765625,
    1993.81591796875,
    3591.33935546875,
    4970.310546875,
    8153.4345703125,
    2049.787841796875,
    2554.1484375,
    14704.5380859375,
    2118.40234375,
    2912.59521484375,
    2070.707275390625,
    2205.631591796875,
    4937.7001953125,
    8452.638671875,
    8650.7158203125,
    14084.494140625,
    9726.8974609375,
    9570.359375,
    8334.048828125,
    7750.412109375,
    13099.0693359375,
    5310.13623046875,
    7684.60498046875,
    2369.524658203125,
    2590.072509765625,
    5729.8427734375,
    6269.0419921875,
    8795.9326171875,
    24620.90625,
    7992.3125,
    19018.79296875,
    54336.3046875,
    5119.861328125,
    2558.93115234375,
    5316.10888671875,
    28705.623046875,
    22139.36328125,
    8218.8076171875,
    3710.984130859375,
    21684.38671875,
    5854.30859375,
    25202.111328125,
    5645.4404296875,
    1971.6851806640625,
    8466.5859375,
    9842.142578125,
    7722.369140625,
    22097.4609375,
    3955.05029296875,
    6549.4189453125,
    3120.383544921875,
    4640.6201171875,
    3446.833740234375,
    4965.9208984375,
    3664.6484375,
    2476.177490234375,
    19932.712890625,
    15256.1982421875,
    4868.9736328125,
    6126.94921875,
    10605.20703125,
    5014.42529296875,
    10801.544921875,
    7490.9228515625,
    14789.220703125,
    7044.859375,
    8030.93505859375,
    3103.807373046875,
    23468.890625,
    6114.6083984375,
    3963.8896484375,
    3599.67822265625,
    2612.83837890625,
    23603.13671875,
    14018.2490234375,
    3348.5810546875,
    3433.967041015625,
    154909.484375,
    13699.3779296875,
    3040.23486328125,
    2183.202392578125,
    2227.62158203125,
    4629.37060546875,
    4753.09814453125,
    21871.564453125,
    2458.620361328125,
    42152.95703125,
    80556.9765625,
    7950.6083984375,
    3011.119384765625,
    11090.900390625,
    15536.6142578125,
    11503.1083984375,
    12560.29296875,
    8643.56640625,
    14778.9755859375,
    9151.3955078125,
    7060.63330078125,
    22889.51171875,
    4270.26611328125,
    5538.3896484375,
    23445.1484375,
    22161.49609375,
    2939.242431640625,
    2675.292724609375,
    65025.31640625,
    8974.826171875,
    14635.6640625,
    27609.130859375,
    27078.529296875,
    3446.91259765625,
    46414.78125,
    15812.0126953125,
    15404.677734375,
    8676.6328125,
    7561.4013671875,
    20219.1796875,
    35549.2734375,
    32523.98828125,
    16482.3359375,
    3961.7138671875,
    2470.78515625,
    14810.1962890625,
    41758.46875,
    17261.1953125,
    8675.7763671875,
    12832.2177734375,
    30471.65625,
    2631.16162109375,
    2515.644775390625,
    10523.341796875,
    14693.44921875,
    8663.607421875,
    6660.81201171875,
    2252.421875,
    5491.8896484375,
    35819.65234375,
    2171.234375,
    7280.79541015625,
    2461.353759765625,
    9890.7001953125,
    14204.357421875,
    9830.7978515625,
    14279.765625,
    6549.05224609375,
    51148.3359375,
    4730.40283203125,
    7345.775390625,
    2089.935791015625,
    2251.440185546875,
    7288.11572265625,
    1820.084228515625,
    5224.45068359375,
    3322.209716796875,
    3408.87451171875,
    2325.57470703125,
    7344.96142578125,
    1839.2506103515625,
    5833.060546875,
    7417.62841796875,
    7412.52783203125,
    4094.4580078125,
    3616.890869140625,
    3690.157958984375,
    2422.012451171875,
    4681.6796875,
    2769.0400390625,
    1856.9342041015625,
    5849.30419921875,
    12690.0810546875,
    7042.955078125,
    6146.26025390625,
    8692.3623046875,
    8854.8935546875,
    5616.37939453125,
    3699.5849609375,
    9175.642578125,
    33122.203125,
    5494.37158203125,
    3580.5810546875,
    9000.0634765625,
    3663.074951171875,
    3659.80810546875,
    2536.515869140625,
    2515.149169921875,
    2065.4130859375,
    2061.16845703125,
    2351.442626953125,
    2515.149169921875,
    2065.4130859375,
    2061.16845703125,
    5165.03759765625,
    2424.382080078125,
    2907.4873046875,
    2705.718017578125,
    11792.3076171875,
    4586.54931640625,
    4610.28076171875,
    4606.0380859375,
    2046.1561279296875,
    3468.019287109375,
    33207.25390625,
    5512.1875,
    5521.9013671875,
    4494.3134765625,
    8946.26171875,
    8464.001953125,
    9846.9453125,
    12557.818359375,
    8291.09765625,
    9093.974609375,
    12386.625,
    6706.89501953125,
    9155.1240234375,
    51351.38671875,
    21811.962890625,
    15861.6298828125,
    9695.1474609375,
    19846.439453125,
    3040.281494140625,
    10525.373046875,
    6260.73046875,
    8091.2109375,
    2739.576416015625,
    4684.568359375,
    2273.457275390625,
    3173.7197265625,
    6930.7626953125,
    4608.35302734375,
    2115.739013671875,
    1829.6373291015625,
    2116.113525390625,
    7300.12548828125,
    53999.85546875,
    7435.26953125,
    4440.89990234375,
    4324.54052734375,
    8266.7119140625,
    8144.0322265625,
    8717.6279296875,
    8606.49609375,
    7816.4306640625,
    2125.729248046875,
    5598.25146484375,
    3329.775390625,
    8278.369140625,
    2019.3636474609375,
    7520.599609375,
    6664.10107421875,
    7459.33642578125,
    9391.9794921875,
    15255.2685546875,
    9173.7919921875,
    13790.068359375,
    29153.1015625,
    27282.599609375,
    18004.486328125,
    19879.3984375,
    26868.474609375,
    7549.17236328125,
    24242.361328125,
    15235.0947265625,
    131061.2578125,
    32390.85546875,
    30878.548828125,
    2454.813720703125,
    11757.076171875,
    15987.84765625,
    4145.4189453125,
    12156.7197265625,
    61880.74609375,
    19547.458984375,
    30953.279296875,
    31186.826171875,
    20137.03515625,
    44691.66796875,
    28945.484375,
    8997.9990234375,
    5847.4072265625,
    6396.0439453125,
    23139.173828125,
    9310.0517578125,
    63138.4765625,
    60753.8828125,
    27353.169921875,
    42339.6015625,
    33224.12890625,
    43756.91015625,
    14573.4296875,
    68487.796875,
    6849.12451171875,
    18750.03515625,
    35301.88671875,
    10299.4326171875,
    9549.6533203125,
    5995.8984375,
    3137.084716796875,
    7237.640625,
    20859.75,
    34233.3203125,
    6673.751953125,
    5248.5966796875,
    326.5075378417969,
    14370.1572265625,
    3658.27978515625,
    7021.1220703125,
    20508.365234375,
    13650.4326171875,
    7382.79443359375,
    6271.8974609375,
    4598.57568359375,
    28084.619140625,
    17386.39453125,
    10692.66015625,
    32445.072265625,
    6043.14111328125,
    11642.66796875,
    10957.830078125,
    22260.7578125,
    15184.4287109375,
    6944.080078125,
    9898.544921875,
    10301.8740234375,
    19222.28125,
    6367.10302734375,
    6088.21533203125,
    2601.444091796875,
    8699.322265625,
    11980.7890625,
    33536.15234375,
    29383.666015625,
    3463.82373046875,
    3077.81982421875,
    3636.2373046875,
    25152.40234375,
    8623.2734375,
    34181.90625,
    50027.35546875,
    16150.66796875,
    9308.6337890625,
    3129.270751953125,
    11818.001953125,
    5932.66796875,
    15110.8955078125,
    5669.2548828125,
    5461.28173828125,
    2038.76416015625,
    2880.775634765625,
    5403.51318359375,
    2599.557373046875,
    2566.6982421875,
    5874.09716796875,
    2563.1787109375,
    2942.177734375,
    8255.6865234375,
    1929.3154296875,
    4413.21142578125,
    4360.68603515625,
    2207.635986328125,
    4756.5712890625,
    4701.62939453125,
    4846.931640625,
    2645.9462890625,
    4712.841796875,
    2822.0078125,
    2334.235107421875,
    2053.20947265625,
    1945.6129150390625,
    3578.20947265625,
    1897.3115234375,
    4960.24853515625,
    1999.6177978515625,
    2868.41552734375,
    4877.68212890625,
    9939.6123046875,
    6183.17236328125,
    11110.6171875,
    2708.156494140625,
    6178.90869140625,
    20911.451171875,
    13140.4619140625,
    30630.53515625,
    10919.595703125,
    7438.591796875,
    4165.8505859375,
    8880.7724609375,
    41951.34765625,
    10170.287109375,
    5834.083984375,
    37681.9609375,
    2592.6005859375,
    2519.315185546875,
    10180.0966796875,
    6542.123046875,
    12938.85546875,
    8291.1787109375,
    145442.71875,
    25263.685546875,
    4710.98974609375,
    11412.2958984375,
    137800.484375,
    4995.5869140625,
    12381.494140625,
    81259.1015625,
    2787.321044921875,
    11193.37890625,
    4010.173095703125,
    6063.916015625,
    17965.943359375,
    7406.38232421875,
    7170.955078125,
    8740.158203125,
    72777.6328125,
    3015.757568359375,
    137646.828125,
    75227.1015625,
    22090.986328125,
    15825.0107421875,
    11976.9619140625,
    7373.7587890625,
    4845.6357421875,
    20484.7734375,
    28084.34375,
    11385.5302734375,
    8534.2421875,
    24394.646484375,
    84897.75,
    6085.94140625,
    15367.056640625,
    6747.255859375,
    18152.671875,
    24695.763671875,
    98260.875,
    8982.29296875,
    73067.2109375,
    55896.96484375,
    9778.0478515625,
    86648.1640625,
    10939.939453125,
    38027.8203125,
    10128.62109375,
    2825.0546875,
    7123.40185546875,
    109080.4921875,
    66344.7265625,
    20049.66015625,
    37293.4921875,
    15268.6591796875,
    11358.5595703125,
    13791.171875,
    11283.6201171875,
    26047.197265625,
    26847.912109375,
    2999.181396484375,
    98212.5625,
    3994.58154296875,
    4056.018798828125,
    4007.515380859375,
    10987.673828125,
    15212.431640625,
    2136.845703125,
    10196.9951171875,
    7407.771484375,
    5770.9853515625,
    2807.449951171875,
    9369.623046875,
    5287.50244140625,
    11349.841796875,
    1938.896240234375,
    20080.376953125,
    5319.1376953125,
    8599.015625,
    3105.157470703125,
    2237.69384765625,
    17407.79296875,
    6516.0693359375,
    3554.26220703125,
    29523.74609375,
    2299.35400390625,
    19498.208984375,
    3028.123779296875,
    8341.8427734375,
    2710.603759765625,
    26732.005859375,
    82581.1328125,
    37648.62890625,
    4172.1435546875,
    26353.7421875,
    8974.423828125,
    8968.6025390625,
    6398.91357421875,
    14809.6337890625,
    24408.7578125,
    2178.66162109375,
    35428.76953125,
    5628.32666015625,
    10992.6259765625,
    17028.072265625,
    13935.1650390625,
    56028.046875,
    9477.404296875,
    21973.359375,
    16284.984375,
    12384.9287109375,
    74288.53125,
    6666.94580078125,
    6834.0986328125,
    16753.44140625,
    1923.2379150390625,
    72252.8203125,
    2001.4029541015625,
    4338.15283203125,
    7397.875,
    6575.9833984375,
    2710.604736328125,
    2377.811279296875,
    2231.31689453125,
    13590.6201171875,
    4712.9658203125,
    6961.54931640625,
    38133.65234375,
    6198.85302734375,
    82060.203125,
    6883.439453125,
    13427.3359375,
    590.5576171875,
    255.00706481933594,
    2310.185791015625,
    1931.5615234375,
    1916.002685546875,
    23323.326171875,
    19406.900390625,
    5750.82958984375,
    2315.084228515625,
    8772.9853515625,
    5306.8681640625,
    6380.05029296875,
    4786.30615234375,
    5055.0361328125,
    5795.7724609375,
    5685.5615234375,
    19656.166015625,
    7962.77880859375,
    2279.4189453125,
    2166.119140625,
    2171.217041015625,
    2485.5341796875,
    5286.4677734375,
    3208.864013671875,
    3208.864013671875,
    2813.953369140625,
    2732.075439453125,
    2571.1298828125,
    8077.47900390625,
    10272.890625,
    2590.523681640625,
    6319.0078125,
    6696.39208984375,
    6259.33251953125,
    6420.7392578125,
    6258.40576171875,
    10495.3271484375,
    4403.10595703125,
    4329.25830078125,
    1934.527099609375,
    9460.03515625,
    5661.7919921875,
    5682.5380859375,
    6632.3212890625,
    4216.1015625,
    3956.088623046875,
    16511.84765625,
    6957.98876953125,
    3523.80712890625,
    2563.00341796875,
    1941.8001708984375,
    5387.27685546875,
    5410.30908203125,
    11407.30078125,
    18830.470703125,
    7056.23828125,
    3043.57958984375,
    18372.595703125,
    5459.81689453125,
    123.64473724365234,
    116.12135314941406,
    2126.67724609375,
    5882.16064453125,
    4901.66162109375,
    5779.79150390625,
    2071.562255859375,
    2052.93310546875,
    8571.68359375,
    2702.5078125,
    8409.9462890625,
    4448.966796875,
    7348.11669921875,
    19913.15234375,
    3883.786865234375,
    7567.25927734375,
    4398.0419921875,
    2253.23291015625,
    2243.5166015625,
    16435.482421875,
    18765.14453125,
    2114.36474609375,
    3453.181396484375,
    89624.1796875,
    16657.98828125,
    14295.02734375,
    2291.788818359375,
    2286.164794921875,
    2112.024169921875,
    1802.0863037109375,
    2724.112548828125,
    6054.80078125,
    6857.220703125,
    2802.3447265625,
    10476.0830078125,
    2449.72509765625,
    2447.389404296875,
    12577.9091796875,
    18891.03125,
    4239.90576171875,
    4271.9833984375,
    9652.3203125,
    4625.13134765625,
    19813.205078125,
    9248.55859375,
    9254.6015625,
    9572.2646484375,
    7597.30322265625,
    2466.06298828125,
    2409.9912109375,
    9585.84765625,
    12638.927734375,
    3085.43212890625,
    3085.467529296875,
    3499.534423828125,
    3509.02880859375,
    35020.29296875,
    3083.158447265625,
    17669.18359375,
    3223.26904296875,
    4876.15087890625,
    1984.20751953125,
    2210.915283203125,
    1880.2054443359375,
    15963.03515625,
    64415.03515625,
    20131.1015625,
    9651.9326171875,
    7113.56591796875,
    11438.3671875,
    30653.173828125,
    9002.08984375,
    9628.8896484375,
    2249.572509765625,
    2192.88720703125,
    2525.880615234375,
    12681.943359375,
    21671.779296875,
    16940.828125,
    52203.890625,
    14499.4833984375,
    13134.9580078125,
    11916.3544921875,
    2058.617431640625,
    2058.617431640625,
    5000.53564453125,
    41222.1328125,
    84.55140686035156,
    11864.205078125,
    24220.216796875,
    4832.2568359375,
    47892.86328125,
    5260.15966796875,
    39442.11328125,
    23298.982421875,
    50.0777702331543,
    29503.875,
    46056.0859375,
    2298.385986328125,
    10159.9638671875,
    2642.727294921875,
    6123.45068359375,
    41204.38671875,
    16878.19921875,
    4831.38671875,
    4965.85009765625,
    5095.85107421875,
    8428.1181640625,
    10741.72265625,
    11024.5751953125,
    2135.98291015625,
    1900.912841796875,
    2264.0390625,
    2342.15234375,
    9128.361328125,
    42280.4296875,
    50272.109375,
    176330.5625,
    7386.89794921875,
    1858.1539306640625,
    7552.27490234375,
    16626.916015625,
    24492.935546875,
    15167.2109375,
    9498.072265625,
    14615.703125,
    34030.40625,
    5468.50537109375,
    2468.7578125,
    12153.501953125,
    2108.464599609375,
    4584.63037109375,
    4323.75341796875,
    4767.47900390625,
    2995.326171875,
    1951.0067138671875,
    2904.88720703125,
    3723.53857421875,
    5491.13232421875,
    1845.49853515625,
    21678.20703125,
    2050.3837890625,
    13430.53125,
    25552.884765625,
    20887.732421875,
    141925.234375,
    86837.4140625,
    13489.2744140625,
    19819.373046875,
    17761.177734375,
    6474.89013671875,
    4675.68017578125,
    5633.5869140625,
    5382.60693359375,
    1899.9625244140625,
    7452.91796875,
    4201.57421875,
    6617.77587890625,
    4535.27978515625,
    21373.328125,
    21848.41015625,
    20968.134765625,
    5259.79736328125,
    8616.1728515625,
    5173.677734375,
    5887.36328125,
    6201.69921875,
    2131.01171875,
    4298.1796875,
    15738.6904296875,
    14233.9345703125,
    22468.416015625,
    8796.4853515625,
    8243.46484375,
    3371.6982421875,
    5178.462890625,
    2403.78173828125,
    2505.76220703125,
    9928.923828125,
    18864.669921875,
    3765.26416015625,
    10365.900390625,
    5357.2734375,
    58309.2421875,
    70074.4609375,
    2130.841064453125,
    15423.7294921875,
    139282.34375,
    338091.4375,
    13237.6640625,
    14817.6162109375,
    24519.890625,
    8035.13916015625,
    19555.54296875,
    4603.60107421875,
    2758.03564453125,
    13262.9765625,
    7909.96337890625,
    8634.4013671875,
    11308.134765625,
    7606.22021484375,
    4236.4814453125,
    1876.7943115234375,
    8077.67041015625,
    7213.82958984375,
    1980.6549072265625,
    23716.81640625,
    5952.32568359375,
    18930.599609375,
    3177.172119140625,
    8340.1103515625,
    12406.3193359375,
    13310.3818359375,
    14409.6435546875,
    50901.5078125,
    7693.91943359375,
    7515.845703125,
    3530.1435546875,
    15108.21484375,
    13886.076171875,
    10890.564453125,
    14631.5361328125,
    4717.11865234375,
    9699.359375,
    9422.4931640625,
    9865.998046875,
    4369.69677734375,
    2510.6181640625,
    10547.1884765625,
    19118.72265625,
    9081.796875,
    19132.203125,
    9167.9248046875,
    17884.958984375,
    57445.41796875,
    11330.3251953125,
    22255.912109375,
    99588.1484375,
    18607.556640625,
    23271.67578125,
    70727.3203125,
    6099.8876953125,
    66454.359375,
    31636.740234375,
    66505.078125,
    142101.671875,
    2447.869384765625,
    2477.0048828125,
    52329.5625,
    13112.47265625,
    95548.1640625,
    249967.859375,
    13254.572265625,
    14513.4931640625,
    16245.255859375,
    8957.7158203125,
    11298.37109375,
    4813.42236328125,
    9060.4453125,
    15097.9345703125,
    27384.623046875,
    1975.3035888671875,
    31765.466796875,
    23967.8203125,
    2333.02685546875,
    36494.453125,
    2217.07470703125,
    11926.9736328125,
    9910.44140625,
    18313.248046875,
    81260.5390625,
    26640.55078125,
    7812.330078125,
    109181.46875,
    16146.9912109375,
    5829.751953125,
    11436.8359375,
    261628.5625,
    2592.687255859375,
    4440.73779296875,
    10480.00390625,
    6832.33544921875,
    18218.296875,
    20934.92578125,
    4394.9755859375,
    13317.3857421875,
    41891.578125,
    36977.79296875,
    16407.623046875,
    10678.15234375,
    8182.10205078125,
    17315.984375,
    17271.02734375,
    11540.6748046875,
    7719.8681640625,
    14564.947265625,
    5987.2431640625,
    9130.1865234375,
    54552.40234375,
    37224.7265625,
    6029.072265625,
    29516.732421875,
    31416.1640625,
    14804.9853515625,
    27467.865234375,
    16672.96484375,
    16005.2587890625,
    13919.056640625,
    15173.935546875,
    25728.263671875,
    16856.63671875,
    7039.2451171875,
    6363.689453125,
    8615.6123046875,
    11743.650390625,
    38553.1796875,
    46276.20703125,
    1075.9324951171875,
    605.9358520507812,
    4661.96923828125,
    2320.48046875,
    8788.7890625,
    25746.751953125,
    31851.072265625,
    31130.66015625,
    119470.8515625,
    5366.291015625,
    184939.6875,
    482480.8125,
    62053.94140625,
    140323.84375,
    128271.609375,
    8950.2607421875,
    1943.506591796875,
    2473.838134765625,
    4337.0322265625,
    55428.265625,
    77595.125,
    2870.890380859375,
    15827.185546875,
    15225.3310546875,
    6157.48828125,
    31666.822265625,
    33559.625,
    15524.3857421875,
    27977.78515625,
    137266.890625,
    37273.06640625,
    14839.541015625,
    21028.455078125,
    320077.0,
    97621.890625,
    44059.3515625,
    15754.28125,
    10563.2021484375,
    1836.4102783203125,
    2101.760498046875,
    2101.760498046875,
    10402.115234375,
    7140.28564453125,
    4765.138671875,
    168388.546875,
    2369.064208984375,
    2273.07958984375,
    2476.377685546875,
    5280.26904296875,
    3206.17236328125,
    3206.17236328125,
    2159.775390625,
    2804.80517578125,
    2725.842529296875,
    2571.2275390625,
    8077.69970703125,
    4459.81005859375,
    11286.8896484375,
    6246.4560546875,
    5810.12841796875,
    5971.30810546875,
    5808.94775390625,
    9536.56640625,
    14022.0654296875,
    5672.9697265625,
    2873.06298828125,
    2623.2333984375,
    20002.953125,
    96449.859375,
    1964.1044921875,
    4470.720703125,
    8021.54638671875,
    8681.0703125,
    2725.7587890625,
    7127.00439453125,
    15242.919921875,
    2211.922607421875,
    151.85044860839844,
    2883.7470703125,
    2883.233154296875,
    2709.9326171875,
    2600.04638671875,
    5157.24267578125,
    5145.8046875,
    5095.41650390625,
    5089.662109375,
    7604.76904296875,
    11393.7490234375,
    11069.560546875,
    11069.3642578125,
    5847.76025390625,
    21287.673828125,
    15172.4384765625,
    10218.005859375,
    2757.9716796875,
    3253.225341796875,
    2496.49169921875,
    20610.34765625,
    11047.6640625,
    11125.86328125,
    16995.490234375,
    16973.177734375,
    8651.7236328125,
    3461.507568359375,
    3068.808837890625,
    13795.2119140625,
    13796.232421875,
    21072.619140625,
    685.42724609375,
    667.9035034179688,
    667.9035034179688,
    4624.63916015625,
    4933.65576171875,
    4481.80419921875,
    3961.656982421875,
    2493.29443359375,
    4588.68212890625,
    9225.7451171875,
    7034.89404296875,
    9052.232421875,
    5084.1923828125,
    2694.678466796875,
    2979.439208984375,
    3360.013671875,
    15339.0732421875,
    7588.37255859375,
    8562.6328125,
    5077.92431640625,
    6604.3896484375,
    3969.068115234375,
    2706.509765625,
    2422.169921875,
    3960.84521484375,
    11109.3134765625,
    1977.8843994140625,
    18997.490234375,
    17888.798828125,
    4050.42138671875,
    12723.4970703125,
    12693.7041015625,
    7828.52978515625,
    6914.87890625,
    7602.21484375,
    2035.082275390625,
    2082.619140625,
    2604.8447265625,
    7814.5205078125,
    3346.925048828125,
    3142.827880859375,
    11131.052734375,
    4801.72998046875,
    4066.474853515625,
    7614.02294921875,
    9724.3193359375,
    6841.50927734375,
    21507.453125,
    5131.46630859375,
    3813.878662109375,
    39201.64453125,
    1853.349609375,
    63778.91015625,
    7091.75390625,
    5349.56884765625,
    50980.46484375,
    9077.7509765625,
    13448.7138671875,
    13506.86328125,
    97.66676330566406,
    2888.44189453125,
    2806.67919921875,
    2514.014404296875,
    2594.2431640625,
    4698.31005859375,
    8394.6201171875,
    8391.642578125,
    8271.369140625,
    8826.98828125,
    13346.107421875,
    2599.876220703125,
    3035.087646484375,
    2642.024658203125,
    7355.19921875,
    2853.8740234375,
    2503.626708984375,
    3506.166015625,
    4496.47314453125,
    3048.709228515625,
    3712.467529296875,
    4863.39501953125,
    5297.80859375,
    6280.75341796875,
    2570.2587890625,
    2538.755859375,
    16324.5810546875,
    11537.7353515625,
    37220.984375,
    13310.0185546875,
    9414.201171875,
    5158.1767578125,
    9153.9951171875,
    27247.4140625,
    2952.110595703125,
    7157.73681640625,
    25823.01171875,
    2824.823974609375,
    3867.9345703125,
    32.85194396972656,
    36.88569259643555,
    46.91033935546875,
    4999.76416015625,
    1807.1685791015625,
    1961.4866943359375,
    2141.340087890625,
    2115.060546875,
    1795.192138671875,
    1967.75244140625,
    5300.892578125,
    8460.869140625,
    6198.3154296875,
    1945.484130859375,
    1973.4847412109375,
    4475.69775390625,
    10972.59765625,
    4677.0849609375,
    1827.29736328125,
    3297.05908203125,
    14405.8642578125,
    3275.401611328125,
    3282.209228515625,
    1766.892822265625,
    8382.4697265625,
    8390.2275390625,
    23352.869140625,
    4743.24560546875,
    17508.97265625,
    10388.5927734375,
    9650.3603515625,
    9576.07421875,
    7915.69873046875,
    6838.05908203125,
    7395.4306640625,
    1968.67529296875,
    7215.060546875,
    7222.861328125,
    3413.173095703125,
    25385.119140625,
    18873.265625,
    14085.056640625,
    18673.095703125,
    23489.271484375,
    21099.494140625,
    10148.9736328125,
    3481.119873046875,
    3265.422119140625,
    3242.50244140625,
    1804.1405029296875,
    3246.72802734375,
    1772.3140869140625,
    9020.23828125,
    9534.0576171875,
    3504.97802734375,
    3811.773681640625,
    3062.5380859375,
    4586.9833984375,
    4340.0234375,
    84099.3125,
    3768.2216796875,
    10923.275390625,
    8097.578125,
    18644.51953125,
    4690.81787109375,
    41655.79296875,
    16282.8876953125,
    26530.283203125,
    22508.564453125,
    16639.537109375,
    2037.0235595703125,
    35529.15625,
    15635.4765625,
    17892.01953125,
    11475.3623046875,
    29348.822265625,
    2142.670166015625,
    4224.7177734375,
    1874.5814208984375,
    29807.7890625,
    22465.0546875,
    2965.988525390625,
    3205.227294921875,
    4353.41943359375,
    4341.29736328125,
    3839.55517578125,
    2175.5966796875,
    4473.916015625,
    5481.45263671875,
    8293.89453125,
    11419.3115234375,
    29930.369140625,
    38448.05859375,
    31973.146484375,
    29712.1484375,
    15112.240234375,
    36388.97265625,
    3409.80810546875,
    12588.9453125,
    43811.05859375,
    34499.765625,
    5917.2490234375,
    8203.7763671875,
    9076.0419921875,
    19149.697265625,
    3216.672119140625,
    9931.68359375,
    5433.181640625,
    8930.21875,
    5190.08740234375,
    5177.35595703125,
    6303.51953125,
    7801.6982421875,
    3559.792236328125,
    5602.34130859375,
    4199.13037109375,
    6784.41796875,
    4363.8818359375,
    10463.111328125,
    6887.0693359375,
    10665.9716796875,
    5035.67724609375,
    16961.796875,
    12329.0986328125,
    5012.72265625,
    14839.4111328125,
    14053.6904296875,
    18722.46875,
    7834.4482421875,
    10042.9541015625,
    6322.0224609375,
    5305.24853515625,
    19083.095703125,
    8313.6025390625,
    19112.95703125,
    22358.17578125,
    23292.36328125,
    7812.03271484375,
    7968.25244140625,
    4563.0029296875,
    11715.1005859375,
    14335.240234375,
    7009.9169921875,
    6846.70166015625,
    7344.486328125,
    7515.83837890625,
    6718.22998046875,
    5537.2431640625,
    29622.73828125,
    8437.0712890625,
    9811.390625,
    10163.91796875,
    4396.21826171875,
    6944.5341796875,
    7791.19482421875,
    6028.4775390625,
    7605.576171875,
    1886.1124267578125,
    4922.44970703125,
    4714.3701171875,
    12669.37109375,
    2388.096923828125,
    2345.762939453125,
    1919.5592041015625,
    42332.8046875,
    29110.201171875,
    10236.4833984375,
    17619.85546875,
    15982.044921875,
    3804.791748046875,
    4059.429443359375,
    4236.23583984375,
    4518.0185546875,
    9604.99609375,
    5502.7607421875,
    4341.01025390625,
    8791.623046875,
    2745.900634765625,
    2910.257080078125,
    2752.443603515625,
    3431.553466796875,
    2755.39208984375,
    3827.7666015625,
    11846.5810546875,
    4190.56396484375,
    18878.970703125,
    31971.41015625,
    10509.4697265625,
    7788.68017578125,
    6015.642578125,
    20391.466796875,
    45466.25,
    16167.5986328125,
    13726.494140625,
    23397.98046875,
    13381.873046875,
    16737.298828125,
    16208.9541015625,
    7221.37890625,
    3428.96240234375,
    93195.140625,
    19882.27734375,
    6906.93017578125,
    10673.333984375,
    33940.4296875,
    27993.234375,
    8491.7021484375,
    5417.861328125,
    26460.998046875,
    11813.650390625,
    9724.822265625,
    19097.59765625,
    11000.814453125,
    3660.441162109375,
    5095.0361328125,
    6963.7431640625,
    10146.734375,
    28232.94921875,
    3295.734619140625,
    5289.51318359375,
    2481.542236328125,
    8175.73046875,
    10753.9638671875,
    17738.01171875,
    17612.587890625,
    19868.48046875,
    7175.0537109375,
    20373.1640625,
    4648.9189453125,
    4859.37158203125,
    7561.47998046875,
    10378.412109375,
    9828.763671875,
    20340.91796875,
    11717.8603515625,
    6659.93408203125,
    10341.3505859375,
    6994.4521484375,
    9032.5849609375,
    4935.20703125,
    10014.517578125,
    17191.173828125,
    15529.5205078125,
    4576.52294921875,
    6560.830078125,
    6522.90966796875,
    61727.41015625,
    8017.69580078125,
    10583.6162109375,
    6339.03125,
    13370.775390625,
    2604.150634765625,
    2599.85107421875,
    2399.737060546875,
    3951.91015625,
    3824.735107421875,
    5782.2529296875,
    5148.06396484375,
    7848.13037109375,
    6777.0458984375,
    13551.984375,
    5568.2451171875,
    5132.94189453125,
    31759.888671875,
    3548.520751953125,
    37978.73828125,
    26910.3046875,
    3810.57177734375,
    28306.494140625,
    3810.40087890625,
    21176.287109375,
    8024.22998046875,
    4423.52001953125,
    17283.498046875,
    17288.935546875,
    9706.7509765625,
    12613.1083984375,
    6804.79931640625,
    6252.623046875,
    6762.1279296875,
    8632.0087890625,
    8632.458984375,
    28544.740234375,
    43828.40625,
    4644.54443359375,
    2757.797607421875,
    13730.08203125,
    8979.98828125,
    6616.5673828125,
    9852.232421875,
    4492.01953125,
    3873.780029296875,
    7710.56298828125,
    3546.799560546875,
    2928.792236328125,
    50126.94921875,
    10956.3955078125,
    33387.51953125,
    12310.9697265625,
    2847.59326171875,
    15445.7041015625,
    4638.9814453125,
    2504.5244140625,
    9350.5595703125,
    11279.7783203125,
    11528.333984375,
    2459.70751953125,
    4901.4921875,
    2544.330810546875,
    31915.880859375,
    20103.783203125,
    26919.37890625,
    13032.072265625,
    35408.3828125,
    10041.0048828125,
    33983.14453125,
    20846.283203125,
    17562.3828125,
    14021.44921875,
    29982.26953125,
    42931.76953125,
    17791.869140625,
    5611.3193359375,
    18513.998046875,
    17876.5859375,
    17888.224609375,
    36804.16796875,
    16099.5712890625,
    12853.55859375,
    27835.0234375,
    17795.791015625,
    36020.37890625,
    25323.31640625,
    31885.20703125,
    16461.751953125,
    28143.599609375,
    45098.71484375,
    61930.921875,
    10658.5517578125,
    10172.0673828125,
    6886.8349609375,
    101163.8359375,
    660516.0625,
    39938.09765625,
    2044.0269775390625,
    49882.09375,
    49880.37109375,
    340577.84375,
    2081.17333984375,
    46739.82421875,
    2154.05078125,
    4915.84033203125,
    39984.71484375,
    67793.9296875,
    9345.462890625,
    6443.86962890625,
    6952.39794921875,
    49166.0546875,
    2236.19677734375,
    2225.9892578125,
    36.28232955932617,
    45933.84375,
    45934.3984375,
    54690.6484375,
    2948.880126953125,
    2223.41650390625,
    17375.00390625,
    26189.66796875,
    39494.265625,
    23417.53125,
    98914.0,
    488333.96875,
    505859.34375,
    89261.328125,
    20293.12890625,
    81764.796875,
    49325.30078125,
    17490.875,
    22205.703125,
    27146.576171875,
    4839.85791015625,
    6801.93701171875,
    9657.244140625,
    18760.529296875,
    16538.671875,
    3218.19970703125,
    3102.923095703125,
    6570.359375,
    5842.62744140625,
    5888.025390625,
    22807.1796875,
    17179.68359375,
    106207.9375,
    2952.84228515625,
    70324.9375,
    5436.9072265625,
    11599.03515625,
    12781.251953125,
    6048.9599609375,
    11041.626953125,
    20997.998046875,
    14829.88671875,
    17013.474609375,
    7737.59912109375,
    3285.606201171875,
    4923.31884765625,
    34273.7734375,
    4315.0361328125,
    11118.5400390625,
    8606.6474609375,
    6310.45166015625,
    33055.88671875,
    9518.298828125,
    14555.6396484375,
    10949.00390625,
    2193.754638671875,
    3691.007080078125,
    3439.8251953125,
    11718.36328125,
    37645.015625,
    14412.630859375,
    24032.310546875,
    67095.78125,
    252051.6875,
    33083.6953125,
    25580.599609375,
    14114.1162109375,
    22603.8125,
    21702.853515625,
    17076.49609375,
    9084.9287109375,
    10119.716796875,
    57505.46875,
    15230.5,
    6544.47021484375,
    8957.298828125,
    10958.32421875,
    90715.921875,
    49867.80078125,
    8520.970703125,
    13101.7958984375,
    7424.54541015625,
    10842.365234375,
    6314.3125,
    6356.0732421875,
    36541.62890625,
    78163.7734375,
    44572.08203125,
    73373.3515625,
    212942.890625,
    114584.734375,
    152724.625,
    43147.52734375,
    304607.78125,
    30921.521484375,
    8056.65966796875,
    4589.07568359375,
    33356.671875,
    19501.59375,
    56758.78125,
    34102.36328125,
    167285.203125,
    240395.609375,
    4420.39892578125,
    129361.4921875,
    144537.0,
    214848.28125,
    49273.99609375,
    10195.9873046875,
    12575.212890625,
    5724.830078125,
    2524.3447265625,
    4250.44140625,
    10141.8916015625,
    14546.302734375,
    3129.30908203125,
    13986.318359375,
    75455.25,
    30928.337890625,
    75741.1953125,
    173238.84375,
    257964.109375,
    36386.63671875,
    24902.759765625,
    7781.81982421875,
    106432.1875,
    11588.611328125,
    23513.318359375,
    18211.0390625,
    2042.3963623046875,
    11801.8837890625,
    49364.46484375,
    11845.2392578125,
    29019.791015625,
    166674.1875,
    67427.5859375,
    103232.7578125,
    81658.6796875,
    4152.7509765625,
    5251.89990234375,
    12442.8056640625,
    13878.7841796875,
    13612.509765625,
    4518.83935546875,
    19879.001953125,
    13981.3173828125,
    12988.408203125,
    12431.9970703125,
    28733.7421875,
    6042.53955078125,
    6595.05712890625,
    6499.638671875,
    57194.12890625,
    43140.0,
    9482.2373046875,
    5302.7646484375,
    13113.2626953125,
    17138.033203125,
    10787.8115234375,
    135311.03125,
    3941.482666015625,
    3343.9375,
    6534.03857421875,
    18441.95703125,
    58968.90625,
    37047.875,
    26889.6015625,
    5316.03515625,
    4307.375,
    6500.134765625,
    5283.90234375,
    2040.5528564453125,
    4885.0732421875,
    2043.4737548828125,
    4961.72998046875,
    4173.8798828125,
    10825.2890625,
    2465.44970703125,
    2436.714599609375,
    9485.435546875,
    8678.05859375,
    5031.666015625,
    5263.68115234375,
    67880.2421875,
    37449.53125,
    19019.650390625,
    23639.3125,
    71755.7578125,
    20413.8984375,
    15829.4775390625,
    84570.46875,
    43763.98046875,
    32772.69140625,
    12090.0927734375,
    9401.203125,
    8743.310546875,
    8841.486328125,
    19782.75390625,
    6179.07568359375,
    202306.53125,
    2391.335693359375,
    22798.849609375,
    27720.810546875,
    142743.3125,
    2298.043212890625,
    2245.974853515625,
    22823.89453125,
    5166.73974609375,
    30299.556640625,
    27729.115234375,
    634297.125,
    131977.671875,
    49609.703125,
    17043.763671875,
    20751.615234375,
    26193.56640625,
    2351.69580078125,
    24697.888671875,
    32875.14453125,
    250567.9375,
    99114.5703125,
    131268.71875,
    10162.0341796875,
    22247.91796875,
    6092.66748046875,
    6072.3876953125,
    5915.34619140625,
    23708.197265625,
    28050.67578125,
    20009.3125,
    25999.83203125,
    36240.703125,
    14760.3837890625,
    20846.166015625,
    14604.6337890625,
    20609.234375,
    14577.404296875,
    20568.71484375,
    14577.515625,
    20568.9453125,
    5354.63916015625,
    9049.5927734375,
    1775.508544921875,
    18587.37109375,
    19553.294921875,
    27034.802734375,
    15174.626953125,
    14014.9384765625,
    1889.050537109375,
    8321.0517578125,
    8406.9228515625,
    10436.04296875,
    7677.3896484375,
    24166.705078125,
    13868.775390625,
    14580.2138671875,
    358.82464599609375,
    493.9838562011719,
    359.0403137207031,
    14715.2578125,
    19184.919921875,
    13738.2255859375,
    59978.60546875,
    44835.84765625,
    11490.4462890625,
    16355.4453125,
    13706.904296875,
    87192.6796875,
    11982.6865234375,
    18627.171875,
    11352.3564453125,
    11356.2294921875,
    11352.3564453125,
    11352.3564453125,
    11352.3564453125,
    11352.3564453125,
    12199.1669921875,
    12199.1669921875,
    11356.1376953125,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    12208.177734375,
    11351.8427734375,
    19585.958984375,
    19758.1875,
    4318.1416015625,
    2946.774658203125,
    8261.7138671875,
    11674.931640625,
    5184.31005859375,
    11614.158203125,
    4121.89501953125,
    5601.8642578125,
    9333.396484375,
    16662.994140625,
    37799.75390625,
    10721.005859375,
    18424.6484375,
    49757.75390625,
    11799.53125,
    25206.685546875,
    29062.994140625,
    10506.0234375,
    73714.84375,
    8345.0673828125,
    8479.7099609375,
    8353.48828125,
    7661.17138671875,
    24351.42578125,
    19500.0234375,
    19494.41796875,
    125.93838500976562,
    126.0247573852539,
    126.09892272949219,
    126.09892272949219,
    116.07447814941406,
    17903.783203125,
    18232.642578125,
    18100.79296875,
    19687.6796875,
    19687.6796875,
    18095.12890625,
    18089.5625,
    19949.693359375,
    19949.693359375,
    19948.466796875,
    19948.466796875,
    19949.693359375,
    19949.693359375,
    19948.466796875,
    19948.466796875,
    22230.228515625,
    22102.447265625,
    20265.25390625,
    19958.037109375,
    19823.87109375,
    19823.873046875,
    43187.4375,
    87692.078125,
    91524.078125,
    73763.5390625,
    91108.71875,
    31870.595703125,
    2435.563720703125,
    2921.541259765625,
    2189.30615234375,
    519.1768798828125,
    516.8269653320312,
    52.65287399291992,
    5739.470703125,
    2483.136474609375,
    2828.74853515625,
    8047.89794921875,
    1801.717529296875,
    8135.2568359375,
    2583.723388671875,
    11826.8681640625,
    8743.859375,
    5801.28515625,
    4986.419921875,
    11583.5283203125,
    2012.0821533203125,
    10184.525390625,
    7426.1943359375,
    6736.52734375,
    2079.05078125,
    8630.5322265625,
    12073.560546875,
    4727.35498046875,
    88631.9296875,
    19531.61328125,
    37357.50390625,
    7923.57763671875,
    3397.62890625,
    33502.6875,
    2306.471923828125,
    200487.140625,
    6002.56689453125,
    12178.3505859375,
    3426.234130859375,
    3775.863037109375,
    2047.349365234375,
    11772.619140625,
    2844.153564453125,
    3767.440185546875,
    3308.92236328125,
    4666.84375,
    2080.4970703125,
    4694.93603515625,
    2652.8681640625,
    2194.4609375,
    3158.76513671875,
    3216.83154296875,
    12242.7197265625,
    9128.703125,
    3845.21435546875,
    5879.7041015625,
    6400.5009765625,
    3588.556396484375,
    4919.083984375,
    14130.0712890625,
    13279.2255859375,
    3543.25,
    4344.689453125,
    39504.90234375,
    6460.14892578125,
    10305.1767578125,
    2003.08203125,
    12321.7197265625,
    10333.951171875,
    66496.78125,
    24640.90625,
    17834.380859375,
    8669.193359375,
    9154.5146484375,
    3692.32861328125,
    3692.32861328125,
    17983.271484375,
    14654.458984375,
    10088.6943359375,
    12364.2001953125,
    1880.963134765625,
    22509.58984375,
    14918.4658203125,
    4503.00927734375,
    6521.3603515625,
    1847.9393310546875,
    3365.435302734375,
    7495.892578125,
    5802.025390625,
    5599.33935546875,
    6069.06884765625,
    2147.461669921875,
    4359.9521484375,
    4424.97705078125,
    21148.306640625,
    7368.142578125,
    105184.9765625,
    5008.6533203125,
    19934.248046875,
    6188.2021484375,
    24236.978515625,
    2562.91943359375,
    4456.22998046875,
    8364.90234375,
    4559.11572265625,
    12496.76171875,
    15484.548828125,
    4137.19677734375,
    3966.68212890625,
    2473.68115234375,
    8656.0703125,
    22991.53515625,
    12026.625,
    27025.779296875,
    4502.888671875,
    13848.2529296875,
    4631.01220703125,
    2397.14453125,
    5263.66015625,
    15568.8017578125,
    12820.5361328125,
    11213.072265625,
    6303.04541015625,
    1880.9229736328125,
    4521.77490234375,
    7041.69189453125,
    8356.6083984375,
    13429.3876953125,
    11692.6162109375,
    15750.5517578125,
    9130.6513671875,
    5339.8408203125,
    23725.4921875,
    4137.46435546875,
    13703.81640625,
    15513.751953125,
    2264.944091796875,
    32804.91796875,
    4534.19970703125,
    12215.3671875,
    38216.453125,
    2587.54248046875,
    5104.97802734375,
    1982.842041015625,
    21868.7109375,
    2089.802978515625,
    8788.0732421875,
    1903.9615478515625,
    12431.4033203125,
    2157.585205078125,
    58661.4921875,
    24427.271484375,
    2024.02978515625,
    4256.2138671875,
    15694.18359375,
    8838.548828125,
    21168.283203125,
    37493.109375,
    11046.89453125,
    22740.630859375,
    2338.8095703125,
    2308.250732421875,
    5482.0498046875,
    20960.37109375,
    10565.25390625,
    12723.2861328125,
    17193.638671875,
    4816.0712890625,
    18197.380859375,
    21146.275390625,
    5233.58154296875,
    5700.22265625,
    8086.71533203125,
    14695.96484375,
    8556.9384765625,
    20100.771484375,
    7834.94140625,
    19867.865234375,
    16632.3828125,
    15413.0927734375,
    47981.078125,
    4729.80126953125,
    2507.284423828125,
    1984.5172119140625,
    27182.6875,
    2104.225341796875,
    5345.283203125,
    5203.77294921875,
    49625.3046875,
    60673.1640625,
    59583.4921875,
    132866.265625,
    38091.61328125,
    9777.6357421875,
    4778.943359375,
    47381.71484375,
    71071.1015625,
    33360.8046875,
    8194.25390625,
    9915.4013671875,
    24407.359375,
    15536.34765625,
    9329.3779296875,
    4536.10546875,
    8666.751953125,
    9825.80078125,
    13181.62109375,
    7191.091796875,
    7024.0498046875,
    6042.2666015625,
    2227.939208984375,
    26165.728515625,
    6610.9951171875,
    34488.47265625,
    6107.48681640625,
    5152.00439453125,
    12138.2568359375,
    3312.935546875,
    59314.45703125,
    14293.5703125,
    20092.5546875,
    26664.453125,
    7539.7265625,
    7550.58935546875,
    9020.0537109375,
    1897.6678466796875,
    3691.2216796875,
    22002.994140625,
    13979.5029296875,
    3887.148193359375,
    2791.005126953125,
    2628.174560546875,
    9696.361328125,
    10960.29296875,
    14358.1923828125,
    9358.7880859375,
    19528.4375,
    17244.220703125,
    6851.97900390625,
    28806.599609375,
    9793.4921875,
    2149.68310546875,
    26534.220703125,
    10086.876953125,
    11363.474609375,
    16752.86328125,
    9028.53515625,
    11571.3447265625,
    6460.2431640625,
    3234.382568359375,
    10607.759765625,
    5787.71484375,
    2371.958984375,
    20965.736328125,
    6798.1640625,
    17113.986328125,
    13466.380859375,
    7119.64501953125,
    4309.82373046875,
    22523.935546875,
    2192.458740234375,
    16161.150390625,
    16123.982421875,
    109423.8828125,
    4513.52099609375,
    21046.30078125,
    30920.728515625,
    12777.9638671875,
    23790.435546875,
    14858.4384765625,
    20498.98828125,
    29917.412109375,
    9885.1865234375,
    9795.2724609375,
    74713.7421875,
    28180.794921875,
    19042.525390625,
    5787.8427734375,
    13318.888671875,
    11794.00390625,
    23041.95703125,
    23956.2109375,
    6545.54833984375,
    4544.208984375,
    6111.43115234375,
    16751.833984375,
    9495.736328125,
    27337.884765625,
    6489.267578125,
    18650.3203125,
    8642.81640625,
    11138.333984375,
    4038.709716796875,
    12637.8046875,
    25113.578125,
    20647.380859375,
    22612.9921875,
    6295.80029296875,
    4534.17626953125,
    4131.80419921875,
    6895.66552734375,
    14133.423828125,
    22500.87890625,
    5766.31201171875,
    12502.548828125,
    7300.50244140625,
    17468.490234375,
    6122.93408203125,
    9757.9990234375,
    7767.7646484375,
    6446.2509765625,
    16276.1376953125,
    10024.2998046875,
    13923.1201171875,
    8640.0595703125,
    9910.4306640625,
    38801.0390625,
    6451.96728515625,
    38504.29296875,
    16866.123046875,
    4583.0185546875,
    4586.98388671875,
    4340.3583984375,
    4510.5654296875,
    4339.904296875,
    2281.1005859375,
    3582.950927734375,
    3579.72412109375,
    2291.6259765625,
    2341.6083984375,
    2372.276611328125,
    2333.1611328125,
    3498.880615234375,
    18433.3984375,
    41322.95703125,
    16308.0341796875,
    6903.0595703125,
    2807.751953125,
    14913.095703125,
    25489.74609375,
    16961.595703125,
    18305.0546875,
    11396.3935546875,
    50237.28515625,
    52443.87109375,
    9849.2919921875,
    2787.876953125,
    38542.58203125,
    4171.875,
    21351.087890625,
    37928.1796875,
    32926.390625,
    32726.7578125,
    24168.9765625,
    38433.87890625,
    14645.4501953125,
    2253.164794921875,
    2130.2216796875,
    2259.87939453125,
    2136.646484375,
    5537.6689453125,
    7506.77490234375,
    3556.43701171875,
    3569.69384765625,
    9201.9541015625,
    16250.6953125,
    3988.15283203125,
    14445.1884765625,
    12345.2421875,
    2233.76708984375,
    30379.943359375,
    25775.6484375,
    14498.6005859375,
    5330.0302734375,
    16617.07421875,
    13431.400390625,
    15734.865234375,
    11458.9755859375,
    2801.971923828125,
    20231.37109375,
    23479.90625,
    51116.7890625,
    18735.244140625,
    24983.6796875,
    12030.5126953125,
    9384.439453125,
    31473.76171875,
    5456.802734375,
    168723.34375,
    74214.5625,
    21834.685546875,
    12523.2822265625,
    13272.8212890625,
    108601.921875,
    104875.4609375,
    75296.875,
    96459.890625,
    80313.4140625,
    13676.8447265625,
    20358.361328125,
    50247.00390625,
    97074.3125,
    19708.041015625,
    2612.48193359375,
    26900.984375,
    17246.201171875,
    24448.654296875,
    48551.36328125,
    11114.42578125,
    45778.7109375,
    14910.4951171875,
    9794.23828125,
    205964.453125,
    38288.15234375,
    14232.1025390625,
    12197.93359375,
    26954.3125,
    4641.96240234375,
    2039.3516845703125,
    2194.461669921875,
    11022.525390625,
    3570.678955078125,
    2990.359619140625,
    6610.927734375,
    5609.0205078125,
    8207.7783203125,
    2845.1875,
    6288.84326171875,
    8717.892578125,
    3288.26904296875,
    2297.384033203125,
    16697.96484375,
    5639.28125,
    5606.1337890625,
    4197.8818359375,
    4367.13720703125,
    4164.54150390625,
    8988.4404296875,
    13159.1669921875,
    18880.99609375,
    10914.353515625,
    8561.1103515625,
    2319.4755859375,
    12761.6240234375,
    2309.37060546875,
    9616.0712890625,
    11084.0,
    13457.119140625,
    5198.2646484375,
    56553.8828125,
    48655.9765625,
    2379.406494140625,
    5136.787109375,
    10356.474609375,
    5434.36767578125,
    154.2440643310547,
    145.32745361328125,
    129.394287109375,
    5176.3515625,
    5095.7607421875,
    3682.06689453125,
    2111.09228515625,
    4761.18798828125,
    45265.83203125,
    11453.744140625,
    4478.33544921875,
    46631.640625,
    63795.16015625,
    10287.3056640625,
    20730.70703125,
    32636.95703125,
    134465.9375,
    383281.40625,
    10913.9443359375,
    14060.537109375,
    18543.38671875,
    16283.4033203125,
    127613.0859375,
    105235.3671875,
    472954.21875,
    173913.21875,
    37364.9140625,
    2223.35595703125,
    6069.01220703125,
    13095.609375,
    7606.6259765625,
    23674.927734375,
    6083.17236328125,
    40005.15234375,
    28105.89453125,
    183443.390625,
    21679.294921875,
    42393.26171875,
    34359.83203125,
    21643.234375,
    15581.90625,
    31204.751953125,
    40297.61328125,
    38774.8046875,
    5704.74072265625,
    13275.78515625,
    9140.525390625,
    6393.80419921875,
    5638.80078125,
    19338.80078125,
    91061.484375,
    70100.953125,
    12989.1865234375,
    30960.443359375,
    8256.0712890625,
    61358.14453125,
    33281.76171875,
    60292.68359375,
    87207.828125,
    160939.265625,
    319300.84375,
    5266.2119140625,
    15410.8603515625,
    23249.9609375,
    7650.51708984375,
    19144.7734375,
    35.616188049316406,
    32.85203170776367,
    201.83404541015625,
    6429.51416015625,
    621.23779296875,
    35.82900619506836,
    5073.71435546875,
    6508.4130859375,
    2152.93896484375,
    3632.443359375,
    3599.11962890625,
    8848.8583984375,
    4596.8056640625,
    8865.7861328125,
    8120.81494140625,
    8859.1943359375,
    24411.791015625,
    16649.310546875,
    6775.00244140625,
    6767.29736328125,
    13504.5166015625,
    13535.4326171875,
    12678.2236328125,
    12709.375,
    46591.0703125,
    23387.08984375,
    18419.90625,
    9070.5712890625,
    17063.443359375,
    24826.830078125,
    23685.345703125,
    6001.224609375,
    4409.900390625,
    15630.8896484375,
    7195.2041015625,
    7492.38525390625,
    6025.67578125,
    7378.2587890625,
    4336.81396484375,
    2285.36669921875,
    3609.744140625,
    2176.956787109375,
    35.78382110595703,
    576.325927734375,
    903.4550170898438,
    3803.34716796875,
    8003.701171875,
    2067.90771484375,
    2021.53466796875,
    5379.65185546875,
    4539.3115234375,
    20214.06640625,
    67728.5546875,
    16684.759765625,
    12857.0927734375,
    12890.8505859375,
    15997.056640625,
    13629.3427734375,
    10993.771484375,
    2315.030517578125,
    5692.40234375,
    4531.658203125,
    11066.9736328125,
    3874.69384765625,
    12232.560546875,
    20971.576171875,
    8299.4794921875,
    34971.78125,
    20586.4453125,
    5964.96337890625,
    5842.70703125,
    2259.302490234375,
    23271.31640625,
    38700.58203125,
    50767.07421875,
    11373.12109375,
    28766.896484375,
    24215.1171875,
    5412.970703125,
    12900.541015625,
    17063.208984375,
    8509.935546875,
    2671.8173828125,
    3169.07177734375,
    9568.251953125,
    13592.8779296875,
    43369.359375,
    10755.5322265625,
    22255.33984375,
    5541.63525390625,
    2185.95068359375,
    23189.794921875,
    4167.708984375,
    207209.265625,
    62.12560272216797,
    62.12560272216797,
    156.6793670654297,
    203.569091796875,
    32.85203170776367,
    32.85203170776367,
    35.22260665893555,
    550.381591796875,
    2172.2900390625,
    2300.552001953125,
    2216.159912109375,
    2811.079345703125,
    5549.04931640625,
    8082.6767578125,
    2207.530029296875,
    2269.28662109375,
    2805.545166015625,
    7337.72900390625,
    3346.90966796875,
    5889.55712890625,
    6768.75244140625,
    2152.35595703125,
    10452.94140625,
    5680.88525390625,
    3593.00390625,
    4993.5634765625,
    6758.59912109375,
    7459.95166015625,
    3150.7138671875,
    13166.3291015625,
    2801.52978515625,
    2375.5966796875,
    2784.22900390625,
    2669.725341796875,
    3061.223388671875,
    2946.73193359375,
    2673.946533203125,
    2559.44140625,
    2553.985595703125,
    2439.4814453125,
    7041.8671875,
    2980.010986328125,
    2865.520751953125,
    3012.110595703125,
    2897.618896484375,
    2791.4228515625,
    2676.93408203125,
    2815.8662109375,
    2701.37841796875,
    6335.14501953125,
    6354.48486328125,
    15936.98828125,
    10935.443359375,
    7501.53466796875,
    7387.10986328125,
    7690.0537109375,
    7575.6328125,
    2824.568603515625,
    9101.26953125,
    9323.49609375,
    14165.3212890625,
    6990.34716796875,
    13981.25,
    6964.953125,
    22844.48046875,
    20304.435546875,
    20468.02734375,
    10399.748046875,
    10396.0947265625,
    2701.847900390625,
    2587.34375,
    14703.021484375,
    13269.2080078125,
    15842.2568359375,
    6180.6845703125,
    6159.6923828125,
    1953.557861328125,
    1904.8878173828125,
    6219.10595703125,
    4803.11572265625,
    4061.518310546875,
    12239.3720703125,
    2439.835205078125,
    2436.221435546875,
    2436.221435546875,
    2436.221435546875,
    19304.28125,
    7807.95068359375,
    19678.7109375,
    5189.74462890625,
    241.37551879882812,
    4285.912109375,
    4853.02978515625,
    4412.03271484375,
    5015.126953125,
    4024.569580078125,
    11546.482421875,
    4776.62890625,
    3941.662353515625,
    2693.377685546875,
    2402.7998046875,
    144.16085815429688,
    383.4801940917969,
    5082.0693359375,
    5082.0693359375,
    3247.10546875,
    2402.7998046875,
    2402.7998046875,
    4612.244140625,
    781.85400390625,
    796.1351318359375,
    3192.96484375,
    3207.246337890625,
    3174.7978515625,
    3189.0791015625,
    3174.7978515625,
    3189.0791015625,
    2851.593994140625,
    2852.69775390625,
    2865.8740234375,
    2865.8740234375,
    4480.951171875,
    4509.6875,
    5311.64892578125,
    5325.923828125,
    7017.07421875,
    7031.3515625,
    5709.4814453125,
    5709.4814453125,
    5752.37744140625,
    5752.37744140625,
    8508.734375,
    8512.197265625,
    8537.31640625,
    8540.7802734375,
    3339.150390625,
    3371.3291015625,
    5375.23291015625,
    5389.50048828125,
    7027.0126953125,
    7041.28955078125,
    10234.408203125,
    17058.001953125,
    10039.478515625,
    16748.55859375,
    17334.205078125,
    10686.298828125,
    14412.4306640625,
    10298.30078125,
    5375.263671875,
    5375.263671875,
    5375.263671875,
    5375.263671875,
    4616.96826171875,
    4374.130859375,
    4373.81494140625,
    4388.16357421875,
    4388.4892578125,
    20693.66015625,
    20750.783203125,
    21696.927734375,
    28988.81640625,
    8994.1572265625,
    8716.271484375,
    8287.322265625,
    8362.4052734375,
    8284.3994140625,
    8359.4814453125,
    11967.28125,
    12067.412109375,
    8746.349609375,
    8713.83203125,
    8475.6552734375,
    11312.8515625,
    7288.65576171875,
    6193.02392578125,
    7274.8154296875,
    6176.5888671875,
    10446.2626953125,
    10450.0576171875,
    10684.1484375,
    10673.17578125,
    10658.5634765625,
    10669.5576171875,
    4617.78125,
    4617.78125,
    2505.530517578125,
    2505.530517578125,
    4617.78125,
    4617.78125,
    2505.530517578125,
    2505.530517578125,
    5043.2587890625,
    5043.2587890625,
    4612.244140625,
    4612.244140625,
    4612.244140625,
    4622.005859375,
    2528.154296875,
    2528.154296875,
    5037.87646484375,
    5037.87646484375,
    4711.87109375,
    4711.87109375,
    4711.87109375,
    4711.87109375,
    4706.3349609375,
    4706.3349609375,
    4706.3349609375,
    4706.3349609375,
    2896.130859375,
    2896.130859375,
    2896.130859375,
    2896.130859375,
    2609.72705078125,
    5305.341796875,
    3060.63623046875,
    5748.84375,
    2880.53759765625,
    2869.7685546875,
    2828.31591796875,
    5517.3564453125,
    2611.753662109375,
    5307.361328125,
    3055.780517578125,
    5757.84521484375,
    2874.3798828125,
    2869.7685546875,
    2800.5810546875,
    5511.7001953125,
    2245.713134765625,
    2645.156982421875,
    2268.315673828125,
    2626.063232421875,
    5920.53759765625,
    2168.017822265625,
    2518.020263671875,
    2304.846923828125,
    2290.092041015625,
    2140.283203125,
    4490.98388671875,
    4491.57275390625,
    2315.638916015625,
    2313.618896484375,
    2400.630615234375,
    2075.480712890625,
    2916.8955078125,
    2472.111328125,
    6630.4501953125,
    6621.388671875,
    2060.4814453125,
    2065.546142578125,
    1944.524658203125,
    2348.943359375,
    4490.85498046875,
    7181.40234375,
    11332.7275390625,
    8335.6884765625,
    4407.83154296875,
    4392.0673828125,
    4388.0537109375,
    1842.1622314453125,
    1846.7998046875,
    1952.330078125,
    1901.1904296875,
    8509.3115234375,
    4558.4384765625,
    8493.3447265625,
    8609.462890625,
    18787.365234375,
    5998.8974609375,
    6627.02880859375,
    2859.6259765625,
    2849.395751953125,
    7961.5390625,
    12562.8427734375,
    8480.0869140625,
    10657.4287109375,
    15341.3828125,
    6930.58984375,
    2073.02587890625,
    2100.67822265625,
    2080.22705078125,
    2052.685302734375,
    2046.6429443359375,
    2049.915771484375,
    2149.979736328125,
    2054.610107421875,
    2043.193115234375,
    2848.99658203125,
    2852.1396484375,
    2052.7490234375,
    2058.15234375,
    2038.9232177734375,
    2042.9268798828125,
    2053.09765625,
    2395.78515625,
    2307.864990234375,
    2192.559814453125,
    2192.042236328125,
    2168.033447265625,
    2221.234619140625,
    2039.0692138671875,
    2043.7156982421875,
    2038.9232177734375,
    2038.9232177734375,
    2416.919921875,
    2434.599365234375,
    2546.043701171875,
    3416.985107421875,
    3410.447265625,
    2846.114501953125,
    2842.4296875,
    4464.5380859375,
    5258.9462890625,
    4695.625,
    4319.23291015625,
    2913.005859375,
    2700.8671875,
    2320.379638671875,
    2307.38427734375,
    2084.18994140625,
    1857.64013671875,
    1846.1297607421875,
    1873.978515625,
    2095.672607421875,
    1840.748291015625,
    1863.0225830078125,
    1857.700439453125,
    10357.4150390625,
    4087.414794921875,
    4744.62890625,
    4744.62890625,
    2305.16357421875,
    4456.27880859375,
    2307.4765625,
    4440.06005859375,
    4510.7705078125,
    2100.5283203125,
    13777.7578125,
    6097.609375,
    16153.3134765625,
    27221.62109375,
    3970.9755859375,
    3967.451416015625,
    3964.1640625,
    3960.62353515625,
    7067.89794921875,
    4399.400390625,
    5242.04541015625,
    2082.744140625,
    2463.617919921875,
    2886.067626953125,
    8307.2822265625,
    2940.058837890625,
    2967.8291015625,
    3252.04541015625,
    6030.20068359375,
    8542.3388671875,
    2601.40283203125,
    2064.232177734375,
    2099.989990234375,
    8398.2841796875,
    9258.2919921875,
    2230.88134765625,
    2225.9697265625,
    5889.3173828125,
    5237.55712890625,
    5847.99951171875,
    5237.55712890625,
    2699.057373046875,
    2713.341064453125,
    2965.13671875,
    2979.4150390625,
    3017.046630859375,
    3031.326171875,
    5567.31201171875,
    5585.16943359375,
    5583.4228515625,
    5594.18310546875,
    5479.1533203125,
    5493.42724609375,
    5474.65771484375,
    5488.93212890625,
    5880.6279296875,
    5909.21533203125,
    2458.155517578125,
    2472.435791015625,
    3247.659423828125,
    3261.9375,
    2471.471435546875,
    2485.886962890625,
    2466.6552734375,
    2466.430908203125,
    2498.175537109375,
    2488.55029296875,
    2482.130859375,
    2484.05810546875,
    2883.332763671875,
    2883.332763671875,
    2883.332763671875,
    2883.332763671875,
    5941.4453125,
    5941.12548828125,
    5928.2568359375,
    5928.2568359375,
    1868.52783203125,
    1861.561279296875,
    1993.7335205078125,
    2036.0872802734375,
    1984.9407958984375,
    1988.755126953125,
    3249.13671875,
    3277.727294921875,
    4458.60107421875,
    4364.2177734375,
    4378.69189453125,
    4392.29541015625,
    4384.31005859375,
    5750.4833984375,
    8165.7158203125,
    7483.64892578125,
    7524.9140625,
    4449.51025390625,
    4478.24365234375,
    12085.1142578125,
    7967.27783203125,
    12113.6875,
    7995.84423828125,
    7149.84326171875,
    7221.5087890625,
    4552.9833984375,
    4596.62451171875,
    4788.4775390625,
    4831.9755859375,
    5681.89404296875,
    5739.2666015625,
    7593.8623046875,
    7588.91552734375,
    7405.43603515625,
    7400.4736328125,
    8530.03515625,
    8524.89453125,
    8292.97265625,
    8287.8056640625,
    6313.888671875,
    6309.01953125,
    8680.634765625,
    8675.4921875,
    7618.47314453125,
    7613.41162109375,
    8725.34765625,
    8905.2197265625,
    8227.685546875,
    8222.625,
    9685.2080078125,
    9679.9765625,
    2934.852783203125,
    2949.7421875,
    8995.404296875,
    9009.9873046875,
    5249.8603515625,
    5291.3896484375,
    20773.02734375,
    5596.81494140625,
    3511.935546875,
    3532.6953125,
    6548.53564453125,
    6597.70458984375,
    17628.451171875,
    18784.501953125,
    17248.55859375,
    18564.599609375,
    18772.462890625,
    19236.384765625,
    9529.5732421875,
    9554.4638671875,
    15176.0244140625,
    14336.412109375,
    7471.775390625,
    8205.8583984375,
    7443.11181640625,
    8169.25927734375,
    8528.2900390625,
    8274.064453125,
    8499.52734375,
    8258.4267578125,
    8488.7939453125,
    8460.1337890625,
    19447.4609375,
    19380.37890625,
    4342.6533203125,
    4371.24658203125,
    9320.12109375,
    9348.849609375,
    11972.5693359375,
    11972.5693359375,
    12706.3701171875,
    12702.71875,
    10125.76171875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2389.596435546875,
    2389.596435546875,
    2038.9232177734375,
    2038.9232177734375,
    2038.9232177734375,
    2038.9232177734375,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2039.0692138671875,
    2710.45849609375,
    2703.569091796875,
    2710.669921875,
    2713.335205078125,
    2081.640625,
    2081.640625,
    5834.07763671875,
    5837.51806640625,
    2270.72900390625,
    3537.47119140625,
    2054.373779296875,
    2034.2451171875,
    2042.1884765625,
    1806.92724609375,
    1878.1923828125,
    1878.0191650390625,
    1864.5389404296875,
    1846.61474609375,
    3510.21630859375,
    4630.02978515625,
    11919.283203125,
    1931.460693359375,
    4159.16064453125,
    4194.6201171875,
    11111.28515625,
    8329.12890625,
    2004.6627197265625,
    1809.43896484375,
    1934.664794921875,
    4293.45556640625,
    2645.52197265625,
    17167.109375,
    12375.447265625,
    2294.33740234375,
    9709.052734375,
    6682.8330078125,
    6882.29150390625,
    7751.80859375,
    1852.7701416015625,
    1857.1099853515625,
    9736.9013671875,
    7784.49267578125,
    4086.04736328125,
    1818.940185546875,
    1806.891357421875,
    4083.23095703125,
    2197.588623046875,
    8530.87109375,
    2022.8671875,
    4458.685546875,
    2217.50927734375,
    2238.72802734375,
    2225.45263671875,
    2147.9267578125,
    2433.416748046875,
    1833.907470703125,
    4353.90283203125,
    2552.4599609375,
    1974.5406494140625,
    1909.07861328125,
    2099.228271484375,
    1793.1007080078125,
    1813.1826171875,
    1814.499267578125,
    1966.554443359375,
    1964.359130859375,
    1992.384033203125,
    2023.599609375,
    2120.340576171875,
    2092.031494140625,
    1802.563232421875,
    1799.9287109375,
    4562.515625,
    4571.69140625,
    2314.959716796875,
    8351.365234375,
    2498.19970703125,
    2498.19970703125,
    2373.58984375,
    2279.690185546875,
    3098.26611328125,
    3098.26611328125,
    2213.163330078125,
    9492.650390625,
    2166.2783203125,
    9490.2275390625,
    2709.464111328125,
    2352.892822265625,
    5514.1123046875,
    2344.537109375,
    2627.31005859375,
    2618.963134765625,
    4923.07666015625,
    4372.16455078125,
    2181.3212890625,
    146.21063232421875,
    80.07485961914062,
    604.0341186523438,
    599.2244262695312,
    755.1446533203125,
    6741.81591796875,
    6444.58984375,
    6849.5126953125,
    9149.3525390625,
    6466.72705078125,
    9257.03125,
    6724.7392578125,
    6448.10791015625,
    6838.08349609375,
    9131.8916015625,
    6460.71337890625,
    9245.1845703125,
    4236.82177734375,
    4291.94384765625,
    2096.24267578125,
    2098.083984375,
    14365.76171875,
    232.98512268066406,
    32.85194396972656,
    190.40245056152344,
    141.96812438964844,
    32.85203170776367,
    32.85203170776367,
    531.036865234375,
    793.8900146484375,
    276.17974853515625,
    172.25128173828125,
    448.5970764160156,
    32.85194396972656,
    145.5034942626953,
    145.5034942626953,
    32.85194396972656,
    52.165504455566406,
    35.82892608642578,
    1824.637939453125,
    3213.527587890625,
    5818.9287109375,
    934.6582641601562,
    793.7275390625,
    32.85194396972656,
    32.85194396972656,
    522.9037475585938,
    32.85194396972656,
    469.34893798828125,
    32.85194396972656,
    306.8116149902344,
    302.8414306640625,
    4281.193359375,
    4281.193359375,
    4277.22412109375,
    4277.22412109375,
    604.838134765625,
    463.9622497558594,
    35.82892608642578,
    32.85194396972656,
    3630.242919921875,
    3630.242919921875,
    934.6583862304688,
    793.7275390625,
    8895.2705078125,
    13721.3681640625,
    596.1595458984375,
    1760.148681640625,
    6938.96435546875,
    766.8367309570312,
    11409.884765625,
    6933.63623046875,
    14128.0751953125,
    6933.63623046875,
    14965.38671875,
    14263.486328125,
    14263.33203125,
    596.1595458984375,
    1760.029296875,
    2772.63037109375,
    2110.802978515625,
    7490.64306640625,
    7487.89697265625,
    6505.1416015625,
    6502.3798828125,
    7170.890625,
    7168.1337890625,
    7881.28515625,
    7878.5263671875,
    11095.193359375,
    32964.59375,
    6400.3056640625,
    745.8917236328125,
    651.9924926757812,
    3722.116943359375,
    1720.8118896484375,
    3722.116943359375,
    1720.8118896484375,
    4376.41845703125,
    2374.185546875,
    3722.619140625,
    1720.8118896484375,
    4145.3837890625,
    2143.4013671875,
    2124.886962890625,
    236.9258575439453,
    65580.3984375,
    64927.72265625,
    22298.875,
    745.8917236328125,
    651.9924926757812,
    2568.343017578125,
    5092.38671875,
    1810.788818359375,
    1897.7144775390625,
    12409.9638671875,
    1933.00927734375,
    1486.46240234375,
    32.85194396972656,
    32.85194396972656,
    1851.187255859375,
    1781.72216796875,
    32.85194396972656,
    32.85194396972656,
    3953.250244140625,
    5323.30859375,
    3164.8779296875,
    3049.273681640625,
    2559.325927734375,
    2853.820068359375,
    2107.915771484375,
    3666.7138671875,
    6286.61962890625,
    7749.57177734375,
    2931.1669921875,
    3137.83154296875,
    2769.986328125,
    6091.09326171875,
    3239.617919921875,
    3453.8564453125,
    7252.19287109375,
    3756.199462890625,
    3175.954833984375,
    23782.705078125,
    66214.6171875,
    7043.52685546875,
    5181.44873046875,
    8710.5146484375,
    6965.044921875,
    6727.16357421875,
    5719.8564453125,
    14323.783203125,
    5673.02783203125,
    2863.73974609375,
    5941.14501953125,
    9676.0673828125,
    8321.3056640625,
    7019.0166015625,
    3854.6357421875,
    3857.07177734375,
    11572.5869140625,
    6416.3505859375,
    2612.758056640625,
    7069.66357421875,
    5354.84033203125,
    2804.05908203125,
    5373.478515625,
    3054.601318359375,
    4281.736328125,
    2937.1865234375,
    2157.7939453125,
    3341.8056640625,
    6853.7646484375,
    1578.2491455078125,
    1578.2491455078125,
    3322.380126953125,
    3070.234375,
    7259.53955078125,
    6764.09716796875,
    2741.638671875,
    5294.6279296875,
    4604.28466796875,
    4870.75244140625,
    4870.75244140625,
    13965.0654296875,
    58667.39453125,
    3597.0966796875,
    3114.90966796875,
    4794.14697265625,
    348.09857177734375,
    3625.32373046875,
    5419.232421875,
    6471.6279296875,
    9192.931640625,
    9200.42578125,
    5492.06640625,
    5364.50341796875,
    5279.3369140625,
    6522.7109375,
    6601.8291015625,
    6629.20166015625,
    5541.96728515625,
    6519.1923828125,
    6562.54541015625,
    6887.1298828125,
    6544.13037109375,
    5185.27783203125,
    5571.05322265625,
    5179.76904296875,
    6519.1923828125,
    5163.53173828125,
    8381.6201171875,
    7100.00439453125,
    7038.7568359375,
    8441.2099609375,
    11746.2998046875,
    7368.16162109375,
    2959.5283203125,
    5660.75390625,
    3698.561767578125,
    2957.046630859375,
    102.74431610107422,
    2869.040283203125,
    2735.8818359375,
    2829.9189453125,
    2334.594970703125,
    2564.14990234375,
    5664.78857421875,
    5503.337890625,
    8568.283203125,
    8516.9248046875,
    6456.25439453125,
    4638.09716796875,
    4295.75439453125,
    12317.2587890625,
    7010.71630859375,
    6356.50244140625,
    9333.0986328125,
    12419.142578125,
    6545.06103515625,
    6437.51220703125,
    4201.57470703125,
    5589.31689453125,
    5681.91064453125,
    7203.2841796875,
    5429.6640625,
    6303.33203125,
    5144.76611328125,
    1088.6085205078125,
    2782.740966796875,
    1216.839599609375,
    9616.734375,
    7298.146484375,
    5789.79052734375,
    2722.470458984375,
    5961.607421875,
    4985.10302734375,
    4602.1650390625,
    7271.22216796875,
    3242.54296875,
    4984.4365234375,
    5319.45166015625,
    5307.775390625,
    10360.2158203125,
    8868.521484375,
    10582.7958984375,
    2889.4140625,
    5250.73486328125,
    11764.09375,
    240.588623046875,
    2845.413330078125,
    3630.300537109375,
    3630.300537109375,
    7093.07373046875,
    7240.03759765625,
    14966.72265625,
    112.63178253173828,
    3914.12646484375,
    2464.060546875,
    7081.49658203125,
    96.03947448730469,
    7498.3564453125,
    12806.3662109375,
    7936.13525390625,
    7653.490234375,
    27878.0078125,
    8737.734375,
    11835.3974609375,
    7936.13525390625,
    8434.2939453125,
    8885.9970703125,
    3327.7109375,
    8290.630859375,
    1852.0943603515625,
    2469.292724609375,
    9688.80859375,
    7713.19873046875,
    4106.10498046875,
    3513.23291015625,
    4041.502685546875,
    5166.38623046875,
    3851.19970703125,
    8426.91015625,
    7668.25927734375,
    9022.7568359375,
    2379.95068359375,
    6810.2265625,
    4306.9951171875,
    2430.602783203125,
    3808.38623046875,
    11795.4580078125,
    6003.48583984375,
    2888.327392578125,
    6890.708984375,
    10077.9111328125,
    3946.025146484375,
    2841.360107421875,
    7995.62353515625,
    3192.59912109375,
    3070.7744140625,
    3638.111083984375,
    7358.57421875,
    3365.724609375,
    6366.22314453125,
    2852.678955078125,
    2749.751953125,
    3257.322021484375,
    7391.62646484375,
    3377.44384765625,
    5300.81591796875,
    6473.21728515625,
    4256.7587890625,
    3580.95458984375,
    4449.99072265625,
    7315.96142578125,
    2857.393310546875,
    3722.68603515625,
    10300.6123046875,
    10646.169921875,
    7034.0048828125,
    3580.95458984375,
    4102.63037109375,
    4260.388671875,
    6426.5341796875,
    2124.303955078125,
    6128.12353515625,
    17293.716796875,
    7280.1201171875,
    7209.7958984375,
    6145.99267578125,
    2023.3358154296875,
    5994.72998046875,
    1835.366455078125,
    1833.8602294921875,
    1786.3729248046875,
    6283.08642578125,
    2152.10400390625,
    5969.34619140625,
    1816.7332763671875,
    1810.788818359375,
    8670.1650390625,
    7854.16259765625,
    7604.572265625,
    3672.287353515625,
    2154.8134765625,
    6332.7626953125,
    17395.14453125,
    7503.29296875,
    7359.56005859375,
    6155.41552734375,
    2153.747314453125,
    6327.32177734375,
    2298.9326171875,
    6239.68212890625,
    2076.290771484375,
    2059.67822265625,
    1940.3753662109375,
    6136.65087890625,
    2188.867919921875,
    1933.436279296875,
    5985.609375,
    5951.12841796875,
    5955.40625,
    5933.43798828125,
    5942.55712890625,
    5943.9169921875,
    5933.43798828125,
    5954.31005859375,
    6375.0517578125,
    2305.927001953125,
    8572.5859375,
    2824.205322265625,
    8794.1533203125,
    3442.719970703125,
    3033.6181640625,
    4822.48193359375,
    6053.51708984375,
    6031.23974609375,
    6136.09765625,
    6154.17041015625,
    6865.19091796875,
    2765.904052734375,
    2206.957275390625,
    7767.21484375,
    2314.204345703125,
    6288.90625,
    7414.3369140625,
    7529.78125,
    7200.458984375,
    6127.52734375,
    6474.19384765625,
    6299.28466796875,
    6518.6591796875,
    6141.08349609375,
    1942.99609375,
    1941.4185791015625,
    1856.9383544921875,
    1901.451171875,
    1866.9080810546875,
    1993.0667724609375,
    1883.1500244140625,
    1898.439208984375,
    2012.434326171875,
    1971.86474609375,
    4341.1748046875,
    11873.267578125,
    9055.7392578125,
    8279.88671875,
    5969.107421875,
    3376.0615234375,
    3399.30126953125,
    3381.060791015625,
    2046.26806640625,
    2557.9326171875,
    6617.453125,
    2113.541259765625,
    8517.6708984375,
    3156.904296875,
    1842.73583984375,
    1851.0447998046875,
    1827.7530517578125,
    2599.6611328125,
    1841.1102294921875,
    1833.51025390625,
    1839.244384765625,
    1844.599853515625,
    7549.4599609375,
    8079.5849609375,
    8079.34033203125,
    7838.2978515625,
    7149.2666015625,
    7056.24853515625,
    5905.0458984375,
    7784.259765625,
    3519.861328125,
    3560.109130859375,
    3231.617919921875,
    3448.721923828125,
    9594.802734375,
    3215.1298828125,
    17649.908203125,
    21792.130859375,
    9642.0107421875,
    10081.7099609375,
    13642.6767578125,
    7066.076171875,
    3389.93798828125,
    10093.5302734375,
    6686.18896484375,
    5548.29150390625,
    11884.5,
    16144.67578125,
    10787.6982421875,
    4985.98876953125,
    4819.95166015625,
    6226.64404296875,
    6498.896484375,
    8893.90234375,
    10614.470703125,
    4784.734375,
    4786.16845703125,
    5120.52197265625,
    20280.623046875,
    9231.765625,
    2425.63427734375,
    3475.74462890625,
    2304.862060546875,
    5886.6533203125,
    5629.453125,
    6457.7197265625,
    9301.123046875,
    10883.8203125,
    6220.6591796875,
    6480.970703125,
    4045.37060546875,
    5790.5126953125,
    5239.35400390625,
    7609.966796875,
    11940.2138671875,
    11611.8798828125,
    3412.0927734375,
    2181.408935546875,
    2181.408935546875,
    10992.146484375,
    11072.4111328125,
    3265.802734375,
    3468.796875,
    3401.997802734375,
    3910.53515625,
    5130.03857421875,
    9588.177734375,
    2471.305419921875,
    3947.050537109375,
    7488.52587890625,
    1989.6893310546875,
    7349.42431640625,
    18428.72265625,
    7507.4853515625,
    12914.986328125,
    8656.609375,
    8466.5849609375,
    10622.5703125,
    9795.021484375,
    17442.419921875,
    10504.1865234375,
    17029.12109375,
    15858.419921875,
    14305.0517578125,
    6325.12890625,
    6284.39013671875,
    7035.654296875,
    7032.31103515625,
    7023.048828125,
    7031.814453125,
    16811.85546875,
    19519.009765625,
    14766.29296875,
    22567.2578125,
    2536.168701171875,
    20078.02734375,
    17465.345703125,
    17465.345703125,
    10482.306640625,
    8347.3544921875,
    11825.6728515625,
    11838.189453125,
    14063.6494140625,
    13055.4189453125,
    12847.3740234375,
    18330.76953125,
    13843.1513671875,
    6897.93310546875,
    9495.3330078125,
    9439.0107421875,
    14787.962890625,
    28199.365234375,
    7727.1640625,
    11287.2255859375,
    7771.9765625,
    13015.533203125,
    6588.54833984375,
    9334.1298828125,
    9299.5625,
    11455.5908203125,
    7841.552734375,
    42223.40234375,
    8318.62109375,
    10780.6494140625,
    58549.47265625,
    14141.6474609375,
    14112.6064453125,
    2385.651123046875,
    1789.7808837890625,
    4878.84033203125,
    4889.9833984375,
    6163.494140625,
    17133.328125,
    8751.8466796875,
    8519.8935546875,
    12897.52734375,
    7790.4248046875,
    17837.283203125,
    40193.51171875,
    22328.328125,
    5885.2255859375,
    8522.765625,
    19258.423828125,
    23141.5703125,
    13600.1826171875,
    17637.498046875,
    3766.440673828125,
    19924.275390625,
    28289.046875,
    6122.7021484375,
    8533.9228515625,
    25872.740234375,
    9157.7119140625,
    6169.30712890625,
    6162.48681640625,
    4655.572265625,
    4549.08837890625,
    14709.529296875,
    15322.2060546875,
    15442.837890625,
    3277.662109375,
    3277.615234375,
    4465.365234375,
    12457.916015625,
    18701.5625,
    2631.100830078125,
    2617.441650390625,
    64239.26171875,
    4780.98681640625,
    7252.7822265625,
    25818.845703125,
    25967.880859375,
    4729.42822265625,
    7205.01416015625,
    19046.537109375,
    8083.03662109375,
    19384.404296875,
    14116.7548828125,
    16352.14453125,
    22356.59375,
    13294.4228515625,
    23277.904296875,
    4062.83837890625,
    5776.576171875,
    7111.26171875,
    2616.061279296875,
    8343.42578125,
    7941.322265625,
    14749.8193359375,
    14647.0576171875,
    4592.5947265625,
    8354.392578125,
    64739.48828125,
    31236.712890625,
    11781.2431640625,
    8875.775390625,
    8398.1953125,
    56016.6015625,
    54931.56640625,
    8977.201171875,
    7084.61279296875,
    34944.484375,
    4838.69970703125,
    16370.1552734375,
    65893.625,
    3930.23046875,
    5722.52587890625,
    5470.81787109375,
    5561.7158203125,
    5724.82568359375,
    13330.7939453125,
    6454.34326171875,
    14786.3828125,
    4408.9384765625,
    8001.3505859375,
    46875.5234375,
    25039.5,
    17186.470703125,
    12908.357421875,
    4507.30517578125,
    7820.05810546875,
    35360.3046875,
    2283.79638671875,
    6326.43798828125,
    42723.01171875,
    21013.955078125,
    7831.88818359375,
    3072.98876953125,
    7562.6650390625,
    14104.6220703125,
    2288.23828125,
    6332.7255859375,
    17164.103515625,
    14982.3876953125,
    4490.7119140625,
    10018.5751953125,
    16315.27734375,
    23281.87890625,
    1998.7685546875,
    5353.77734375,
    4651.7099609375,
    10289.150390625,
    10939.2568359375,
    10909.8408203125,
    2598.815185546875,
    26696.900390625,
    4297.1826171875,
    4870.224609375,
    2881.904296875,
    4735.673828125,
    2187.1171875,
    6031.68408203125,
    2121.536376953125,
    9398.7080078125,
    15315.4541015625,
    32626.267578125,
    7873.53857421875,
    9863.619140625,
    124.8644027709961,
    21647.232421875,
    2506.810302734375,
    4034.795654296875,
    7440.35400390625,
    7509.13623046875,
    2298.035888671875,
    7505.89208984375,
    7604.94921875,
    6988.59765625,
    148.19741821289062,
    2622.003662109375,
    2757.1904296875,
    2735.27587890625,
    4089.941650390625,
    4171.884765625,
    32.85203170776367,
    12873.2705078125,
    23489.767578125,
    22455.822265625,
    160243.703125,
    8480.359375,
    8146.43505859375,
    5301.63427734375,
    5018.48046875,
    7882.14111328125,
    4659.7177734375,
    4323.7861328125,
    5088.140625,
    7551.0126953125,
    21743.05078125,
    8764.8212890625,
    3221.27001953125,
    4973.427734375,
    1831.13427734375,
    3267.2021484375,
    3267.2021484375,
    4888.9306640625,
    6108.50537109375,
    3247.938232421875,
    650.4716186523438,
    3072.996337890625,
    2884.308349609375,
    2828.674560546875,
    2894.467041015625,
    2911.92041015625,
    3074.806396484375,
    3723.88232421875,
    3024.75244140625,
    3074.5947265625,
    3017.21044921875,
    2932.46435546875,
    3655.01123046875,
    3239.493896484375,
    3232.042236328125,
    3103.50537109375,
    3401.44970703125,
    2994.44873046875,
    462.88446044921875,
    2557.072021484375,
    228.19126892089844,
    8042.64892578125,
    7923.09619140625,
    5822.7138671875,
    2434.480224609375,
    5118.5439453125,
    5699.47265625,
    8122.09375,
    8434.1103515625,
    17028.435546875,
    5902.68505859375,
    6834.98193359375,
    6721.58642578125,
    6855.2080078125,
    374.3520812988281,
    2358.499755859375,
    5759.33203125,
    13877.0166015625,
    11008.4521484375,
    29866.087890625,
    32337.310546875,
    9946.5712890625,
    2545.619140625,
    3816.7294921875,
    800.2039184570312,
    5713.19189453125,
    7585.9091796875,
    2018.12451171875,
    3354.4189453125,
    8172.76904296875,
    3500.801025390625,
    3301.019287109375,
    6503.7001953125,
    2109.28955078125,
    3258.374267578125,
    3258.374267578125,
    5160.16845703125,
    4722.99951171875,
    2808.99169921875,
    4665.55810546875,
    5979.08740234375,
    3251.1337890625,
    2352.308349609375,
    600.7282104492188,
    2960.727294921875,
    3247.00927734375,
    5554.8720703125,
    5449.43115234375,
    5567.01806640625,
    3280.0537109375,
    5591.583984375,
    2999.839599609375,
    2942.455810546875,
    2857.708251953125,
    3580.275146484375,
    3164.751708984375,
    3157.303955078125,
    5875.17919921875,
    2919.692138671875,
    7724.021484375,
    646.3991088867188,
    5972.5517578125,
    10759.056640625,
    2243.76953125,
    2239.736083984375,
    4516.69140625,
    14870.8203125,
    3801.738525390625,
    3321.781494140625,
    24075.54296875,
    11212.513671875,
    22458.4921875,
    4853.55224609375,
    4592.7880859375,
    11776.2275390625,
    5266.4716796875,
    2633.5341796875,
    4901.6279296875,
    5191.2890625,
    2423.555419921875,
    9821.4501953125,
    9180.77734375,
    5660.93603515625,
    4276.6806640625,
    3531.43994140625,
    4688.18505859375,
    5166.90234375,
    1989.2935791015625,
    3107.790771484375,
    2015.9951171875,
    2180.359375,
    3370.263671875,
    2193.282470703125,
    2046.8487548828125,
    11498.80078125,
    2043.623046875,
    23628.642578125,
    1909.5699462890625,
    1929.7733154296875,
    30309.029296875,
    1863.9842529296875,
    11862.759765625,
    18506.13671875,
    8199.66796875,
    2407.900390625,
    10833.884765625,
    13310.0263671875,
    6434.0205078125,
    22005.1171875,
    12271.3564453125,
    9882.2666015625,
    18187.345703125,
    9179.328125,
    6901.60791015625,
    16458.017578125,
    3693.064697265625,
    24879.310546875,
    15516.189453125,
    15196.5263671875,
    8177.20947265625,
    1939.068603515625,
    13941.298828125,
    13938.169921875,
    3870.783447265625,
    4188.55029296875,
    8196.716796875,
    10422.3486328125,
    18163.064453125,
    35559.24609375,
    27202.453125,
    14824.32421875,
    4858.18359375,
    7763.61181640625,
    21310.396484375,
    6594.47900390625,
    6752.6728515625,
    18319.23046875,
    8152.19921875,
    17963.19921875,
    3165.831787109375,
    8888.2294921875,
    4899.5400390625,
    4868.1923828125,
    15175.478515625,
    12849.298828125,
    16567.837890625,
    6041.47216796875,
    2080.487548828125,
    2434.46044921875,
    8127.86572265625,
    8127.86572265625,
    33342.78515625,
    19223.095703125,
    27515.27734375,
    6379.4140625,
    9074.248046875,
    9070.0615234375,
    3905.370361328125,
    8957.013671875,
    5086.302734375,
    4273.42431640625,
    6443.06201171875,
    5630.58349609375,
    8187.86865234375,
    2282.302490234375,
    5219.755859375,
    15947.9404296875,
    5429.3291015625,
    21605.638671875,
    2229.93505859375,
    2482.451171875,
    10803.3349609375,
    6958.109375,
    24283.23828125,
    7424.81787109375,
    8150.61767578125,
    5063.53076171875,
    6006.4453125,
    5016.3447265625,
    10717.623046875,
    7789.8310546875,
    5131.68505859375,
    7458.7607421875,
    6083.42431640625,
    6416.14794921875,
    7568.25927734375,
    10972.1591796875,
    6983.67578125,
    8802.1796875,
    12019.783203125,
    9932.869140625,
    13135.2080078125,
    2195.510498046875,
    6547.89501953125,
    7774.93994140625,
    8432.58984375,
    6849.984375,
    6838.6640625,
    6771.94287109375,
    5849.4033203125,
    52013.29296875,
    33161.15625,
    11186.8857421875,
    7618.455078125,
    3016.35205078125,
    3069.1328125,
    692.5982666015625,
    7887.88330078125,
    6321.3525390625,
    2185.103271484375,
    2145.147705078125,
    12623.3828125,
    1926.6746826171875,
    6492.646484375,
    2128.913818359375,
    6665.67919921875,
    4368.92626953125,
    1972.281494140625,
    5334.27099609375,
    1998.6055908203125,
    6419.25830078125,
    5281.79931640625,
    9184.9140625,
    3878.849609375,
    21034.4609375,
    10893.1845703125,
    2081.190673828125,
    14304.9228515625,
    15971.134765625,
    4594.08251953125,
    5445.29931640625,
    2146.044677734375,
    8555.8935546875,
    2122.773193359375,
    6863.3955078125,
    3416.512451171875,
    5535.2216796875,
    2118.947265625,
    5468.267578125,
    5502.96240234375,
    2143.41943359375,
    2934.407470703125,
    2149.854736328125,
    2133.1171875,
    2318.280029296875,
    7493.63330078125,
    5455.23486328125,
    2195.8974609375,
    7829.34375,
    2347.8955078125,
    2669.33935546875,
    2805.728271484375,
    2510.621826171875,
    2389.943359375,
    2354.898681640625,
    4133.8369140625,
    2759.111572265625,
    6935.09375,
    8054.9990234375,
    1961.139404296875,
    2211.191162109375,
    10710.76171875,
    3151.099609375,
    3672.299560546875,
    2818.272705078125,
    1901.546630859375,
    14114.0166015625,
    3718.40771484375,
    6075.087890625,
    6151.92333984375,
    6617.076171875,
    40312.7421875,
    52804.24609375,
    8298.2734375,
    16207.8466796875,
    2298.113525390625,
    2944.879638671875,
    12511.505859375,
    2091.9365234375,
    1940.5709228515625,
    3546.42529296875,
    3670.73291015625,
    2265.468505859375,
    5987.74267578125,
    7119.64404296875,
    3010.004638671875,
    8986.6728515625,
    6084.89599609375,
    2570.478759765625,
    2621.3798828125,
    2903.843017578125,
    5092.5576171875,
    8253.013671875,
    8245.3193359375,
    4842.546875,
    12692.8984375,
    9874.51953125,
    2259.02880859375,
    2515.2333984375,
    2258.70751953125,
    2514.912353515625,
    4519.26220703125,
    7197.63330078125,
    2529.56201171875,
    4985.71630859375,
    6667.20263671875,
    4369.158203125,
    2249.245361328125,
    7861.48046875,
    2871.537353515625,
    2858.4326171875,
    9247.9970703125,
    6965.044921875,
    6727.1640625,
    5719.8564453125,
    14861.18359375,
    5673.02783203125,
    2863.73974609375,
    5941.14501953125,
    9676.0673828125,
    8321.3056640625,
    7019.0166015625,
    3854.6357421875,
    3857.07177734375,
    38768.859375,
    15600.2109375,
    7840.59228515625,
    7890.74609375,
    9400.17578125,
    7730.12451171875,
    8983.546875,
    4744.84765625,
    2023.567138671875,
    2251.90869140625,
    4797.380859375,
    2091.4990234375,
    8852.12890625,
    1885.0948486328125,
    11761.625,
    4400.01123046875,
    11071.7236328125,
    15150.1396484375,
    2387.259521484375,
    2839.6953125,
    2821.388671875,
    6227.45703125,
    7354.0380859375,
    4150.96240234375,
    5024.912109375,
    5797.35986328125,
    2016.137939453125,
    3659.26123046875,
    3673.480224609375,
    2124.7333984375,
    2112.213623046875,
    8477.064453125,
    2629.90576171875,
    4292.4560546875,
    8336.474609375,
    6316.578125,
    4630.5712890625,
    5706.314453125,
    10332.60546875,
    2384.515380859375,
    2040.1016845703125,
    2040.2835693359375,
    4788.90673828125,
    2167.3837890625,
    8340.6953125,
    11232.216796875,
    2919.3486328125,
    986.7772827148438,
    5429.470703125,
    15723.98046875,
    5373.3505859375,
    6437.47705078125,
    7508.4072265625,
    3689.8046875,
    20893.75,
    9055.9130859375,
    9619.1767578125,
    4393.94140625,
    3572.260009765625,
    8324.87109375,
    13669.046875,
    13310.7802734375,
    4464.3740234375,
    4456.50146484375,
    4456.50146484375,
    4456.50146484375,
    4935.50830078125,
    6673.84423828125,
    4719.5869140625,
    2546.587890625,
    5076.697265625,
    6631.46923828125,
    2860.97216796875,
    2858.498046875,
    15983.67578125,
    20389.580078125,
    12082.0986328125,
    4054.384521484375,
    4102.21630859375,
    2230.87744140625,
    42.870391845703125,
    2226.90380859375,
    39.453369140625,
    4176.73193359375,
    10614.1318359375,
    4673.68115234375,
    4584.97900390625,
    4917.171875,
    4026.2529296875,
    2454.125732421875,
    4126.25634765625,
    19632.611328125,
    4430.0615234375,
    6201.7353515625,
    1826.83740234375,
    1947.6849365234375,
    1907.617919921875,
    5156.80908203125,
    4519.29443359375,
    18360.44140625,
    4541.33349609375,
    4432.70703125,
    4395.72900390625,
    3957.409423828125,
    7976.87060546875,
    20836.13671875,
    4146.66357421875,
    4145.5400390625,
    11151.42578125,
    11379.0419921875,
    11151.8154296875,
    4326.01123046875,
    3559.55859375,
    6654.80908203125,
    8496.556640625,
    2002.0380859375,
    4549.13134765625,
    6905.89404296875,
    7264.40771484375,
    6449.32470703125,
    4611.53662109375,
    11027.87109375,
    2200.089599609375,
    2300.783447265625,
    1820.656494140625,
    2005.3983154296875,
    2014.58349609375,
    2557.66162109375,
    2324.951416015625,
    2069.7265625,
    17506.380859375,
    2547.901123046875,
    2507.14599609375,
    2296.538818359375,
    2066.419189453125,
    5994.26513671875,
    2429.085693359375,
    5679.48974609375,
    3699.564697265625,
    12487.6240234375,
    2229.79638671875,
    2221.8935546875,
    4081.679931640625,
    1875.8883056640625,
    2342.125732421875,
    1845.568359375,
    4275.04248046875,
    4502.00341796875,
    8434.7373046875,
    5700.431640625,
    10578.2177734375,
    4462.78564453125,
    7316.0947265625,
    5630.55322265625,
    4036.138671875,
    4414.26953125,
    4479.01025390625,
    5001.154296875,
    8226.5146484375,
    4421.45654296875,
    4439.35009765625,
    4319.763671875,
    4899.8740234375,
    4651.853515625,
    5206.26220703125,
    12279.265625,
    4030.233642578125,
    4462.94091796875,
    2495.586181640625,
    3637.470947265625,
    5146.65771484375,
    4376.451171875,
    9890.841796875,
    4095.569091796875,
    4186.76123046875,
    4117.53955078125,
    4661.3310546875,
    2410.998046875,
    6456.529296875,
    6933.41455078125,
    4360.8427734375,
    4432.630859375,
    4149.26904296875,
    9989.3193359375,
    5243.12060546875,
    4766.06787109375,
    4469.6376953125,
    4166.0205078125,
    4412.50390625,
    4648.22607421875,
    4387.87548828125,
    4387.87548828125,
    17571.791015625,
    6764.3662109375,
    6727.53857421875,
    4447.71826171875,
    13771.4189453125,
    8985.103515625,
    14469.9052734375,
    4209.11669921875,
    6291.4443359375,
    2510.617431640625,
    2482.083740234375,
    4409.83447265625,
    4422.724609375,
    18974.9296875,
    2068.759033203125,
    7685.265625,
    4554.73046875,
    2232.720947265625,
    2340.052490234375,
    4239.6240234375,
    2167.0,
    6761.82470703125,
    5401.79638671875,
    4685.59619140625,
    2455.11083984375,
    2143.611083984375,
    2220.013671875,
    128987.9609375,
    13796.6416015625,
    4591.0625,
    15588.1943359375,
    13011.763671875,
    4479.53564453125,
    4405.58984375,
    4504.05419921875,
    14952.177734375,
    4718.68212890625,
    9575.138671875,
    2179.333740234375,
    4777.27197265625,
    5205.3994140625,
    4341.52001953125,
    4659.2861328125,
    4355.203125,
    6278.9814453125,
    2066.7041015625,
    6407.3330078125,
    4645.10400390625,
    12228.26953125,
    4327.03125,
    4323.70068359375,
    4393.82373046875,
    2472.1240234375,
    2258.216064453125,
    11484.517578125,
    4223.74951171875,
    2106.0732421875,
    6654.54541015625,
    5319.263671875,
    4573.82275390625,
    2257.00634765625,
    2237.248046875,
    2559.708984375,
    2464.389404296875,
    2473.843017578125,
    4639.8828125,
    2276.34326171875,
    2057.20654296875,
    2059.577392578125,
    4169.5859375,
    4186.98974609375,
    20883.41015625,
    9738.107421875,
    4632.12548828125,
    9881.9111328125,
    4860.29541015625,
    5064.04052734375,
    5272.35791015625,
    13187.958984375,
    4906.732421875,
    16981.220703125,
    2533.986328125,
    10958.8349609375,
    4678.1474609375,
    4465.98876953125,
    4902.0478515625,
    5535.96533203125,
    4929.3203125,
    23035.12109375,
    41706.234375,
    13030.876953125,
    17249.70703125,
    17962.478515625,
    10649.4560546875,
    10093.92578125,
    4431.26123046875,
    33344.4296875,
    32.85209655761719,
    40.39396286010742,
    2209.21484375,
    39.42367172241211,
    45.03847885131836,
    2148.158447265625,
    6824.86865234375,
    8486.775390625,
    3864.934326171875,
    4318.30029296875,
    3798.361083984375,
    4082.6123046875,
    4229.1328125,
    2250.562255859375,
    2230.156982421875,
    2209.21484375,
    54.82452392578125,
    3935.461181640625,
    4031.031005859375,
    8522.9423828125,
    4331.68408203125,
    3372.651123046875,
    9055.1552734375,
    7174.46240234375,
    6455.07373046875,
    6520.412109375,
    1875.205810546875,
    4241.67138671875,
    7844.37451171875,
    1779.16357421875,
    1809.5657958984375,
    1865.961181640625,
    4235.36865234375,
    8098.4365234375,
    7110.3056640625,
    18776.064453125,
    18665.603515625,
    9988.52734375,
    1836.4752197265625,
    8993.5283203125,
    13417.96875,
    9309.4638671875,
    47875.609375,
    21575.755859375,
    10324.701171875,
    159499.234375,
    8981.9716796875,
    89715.1015625,
    119603.6015625,
    98835.640625,
    30627.427734375,
    3172.340087890625,
    5205.89794921875,
    2107.0517578125,
    4599.84423828125,
    9095.80078125,
    10976.892578125,
    2417.64501953125,
    2589.98876953125,
    2616.35595703125,
    1923.2635498046875,
    1935.3826904296875,
    2631.91455078125,
    2144.710205078125,
    3844.45654296875,
    2741.274658203125,
    1988.6441650390625,
    5858.95556640625,
    11120.904296875,
    7093.7548828125,
    2219.970458984375,
    2267.61083984375,
    2387.0908203125,
    5631.3955078125,
    7939.90966796875,
    7930.92626953125,
    7639.53955078125,
    4308.91162109375,
    7633.73291015625,
    1793.6851806640625,
    13733.8818359375,
    9708.31640625,
    32016.50390625,
    16075.1640625,
    5307.67333984375,
    6561.42919921875,
    4028.60302734375,
    1787.7496337890625,
    6647.73486328125,
    2027.5146484375,
    6862.84619140625,
    11571.009765625,
    16783.921875,
    2468.8515625,
    423180.75,
    66314.1328125,
    10342.9345703125,
    34222.8125,
    10548.6806640625,
    2530.031494140625,
    5530.50634765625,
    2548.482177734375,
    11170.9404296875,
    10081.4345703125,
    5529.47216796875,
    35784.51171875,
    17862.109375,
    7556.48388671875,
    6003.45947265625,
    9779.6201171875,
    12967.5390625,
    10341.5146484375,
    29155.4375,
    5355.22900390625,
    5509.55322265625,
    5477.359375,
    2569.571533203125,
    13826.0068359375,
    4669.52392578125,
    4432.94677734375,
    9012.869140625,
    3129.589599609375,
    5080.78076171875,
    4609.611328125,
    4500.90185546875,
    4127.087890625,
    4012.246826171875,
    22144.259765625,
    20201.93359375,
    26128.609375,
    36402.90625,
    5624.07080078125,
    8352.7255859375,
    9470.3984375,
    15533.966796875,
    17018.04296875,
    38473.98828125,
    4772.4052734375,
    4802.830078125,
    11585.58203125,
    35541.5703125,
    4319.51953125,
    4613.01513671875,
    2169.551025390625,
    5927.90966796875,
    4334.84619140625,
    26181.7421875,
    9533.66015625,
    20308.529296875,
    15291.900390625,
    14923.4375,
    4701.72119140625,
    16992.318359375,
    8716.3359375,
    33570.7734375,
    4658.39599609375,
    14676.111328125,
    17556.888671875,
    13665.0126953125,
    32123.80078125,
    56156.9140625,
    26846.001953125,
    12144.9111328125,
    2286.254638671875,
    2278.80419921875,
    21380.744140625,
    3685.812744140625,
    8522.7392578125,
    6654.2373046875,
    40834.1484375,
    2480.917724609375,
    105.88788604736328,
    105.88788604736328,
    18928.357421875,
    18938.958984375,
    4113.8837890625,
    6964.4052734375,
    9103.60546875,
    4614.66259765625,
    18657.72265625,
    2270.474365234375,
    2280.576171875,
    12465.26171875,
    2478.955078125,
    22028.46484375,
    7848.2548828125,
    5127.58447265625,
    9217.447265625,
    10220.8173828125,
    22278.013671875,
    6970.32373046875,
    10044.5556640625,
    16223.4599609375,
    4585.021484375,
    36655.69921875,
    9335.5205078125,
    4242.2724609375,
    7240.83740234375,
    5519.828125,
    7016.7685546875,
    2893.31201171875,
    28162.89453125,
    9204.728515625,
    5266.91064453125,
    6259.248046875,
    18110.228515625,
    9629.4912109375,
    5497.29052734375,
    5496.08984375,
    18876.361328125,
    14486.86328125,
    10956.7353515625,
    19001.296875,
    7407.44140625,
    3502.941162109375,
    56926.1875,
    26012.3359375,
    7293.02099609375,
    12179.0546875,
    4564.044921875,
    20951.82421875,
    5604.43603515625,
    7920.06591796875,
    22320.853515625,
    22271.763671875,
    41454.8125,
    49826.94921875,
    13515.2919921875,
    7602.90625,
    16810.115234375,
    13260.8837890625,
    8504.10546875,
    6033.22509765625,
    6204.9541015625,
    31015.638671875,
    7586.1630859375,
    9535.90625,
    7618.00146484375,
    6094.4462890625,
    6385.8701171875,
    5859.5634765625,
    10038.8984375,
    7558.2744140625,
    7752.99462890625,
    5855.19921875,
    5188.54541015625,
    5545.58544921875,
    8615.8330078125,
    9427.66015625,
    10504.4169921875,
    12525.3115234375,
    17538.4453125,
    9065.2763671875,
    11837.455078125,
    7225.2626953125,
    9476.1162109375,
    17425.044921875,
    17874.244140625,
    15816.69140625,
    22820.703125,
    11638.880859375,
    6025.54150390625,
    13762.2890625,
    11930.201171875,
    24486.658203125,
    14865.24609375,
    5414.5498046875,
    130411.5703125,
    2695.922607421875,
    2666.029296875,
    2104.29833984375,
    2263.5146484375,
    4016.7255859375,
    2430.1025390625,
    8506.4140625,
    40594.9140625,
    26703.689453125,
    8728.58984375,
    8129.68896484375,
    7134.11376953125,
    4532.41650390625,
    43948.5546875,
    120660.71875,
    49090.55859375,
    22943.916015625,
    145149.0625,
    9778.29296875,
    4226.716796875,
    8575.013671875,
    8578.5703125,
    3885.51220703125,
    5097.509765625,
    8030.4140625,
    11870.607421875,
    17823.05859375,
    6541.33984375,
    2181.3349609375,
    2179.274658203125,
    5201.783203125,
    5199.5283203125,
    14424.859375,
    3332.067138671875,
    3827.914306640625,
    4437.7822265625,
    13100.033203125,
    19419.603515625,
    8480.6796875,
    8581.7783203125,
    8011.15478515625,
    9063.9951171875,
    5199.82275390625,
    4235.46044921875,
    21341.498046875,
    4223.67041015625,
    4449.77587890625,
    19541.58203125,
    8996.2080078125,
    5150.64306640625,
    3650.494384765625,
    8436.16015625,
    10554.7744140625,
    7412.50537109375,
    31573.49609375,
    14411.1591796875,
    8468.5478515625,
    2128.623046875,
    2220.910888671875,
    2423.744873046875,
    3455.754638671875,
    15293.619140625,
    10871.5302734375,
    2012.096923828125,
    2004.6883544921875,
    26359.1328125,
    2148.953857421875,
    6317.87890625,
    8071.34814453125,
    2597.053466796875,
    4255.47802734375,
    8007.81689453125,
    7336.32275390625,
    8963.8125,
    4743.0380859375,
    20090.24609375,
    7812.48046875,
    5317.02099609375,
    22750.12109375,
    8451.2587890625,
    13641.638671875,
    8357.0498046875,
    19803.10546875,
    8956.9287109375,
    8242.4365234375,
    13562.9521484375,
    2687.258056640625,
    2676.85498046875,
    6567.57666015625,
    2846.010498046875,
    2252.349609375,
    2489.9521484375,
    2934.46142578125,
    2406.944580078125,
    3323.92138671875,
    9115.3291015625,
    2162.856689453125,
    52206.02734375,
    7373.20263671875,
    2782.228515625,
    2782.228515625,
    19944.75,
    25500.630859375,
    27303.9140625,
    10802.98828125,
    5754.53515625,
    13544.6318359375,
    3913.72802734375,
    2416.072509765625,
    2582.089599609375,
    2577.449951171875,
    2584.350830078125,
    3898.47412109375,
    3371.512451171875,
    4015.067626953125,
    4296.39892578125,
    4005.572021484375,
    7536.291015625,
    6363.1630859375,
    4348.0986328125,
    38721.7734375,
    3647.34814453125,
    10196.9853515625,
    6023.10107421875,
    5559.5595703125,
    5679.48193359375,
    5648.45458984375,
    12827.8466796875,
    41190.171875,
    3045.1142578125,
    14691.66796875,
    4407.8759765625,
    11590.537109375,
    5927.65234375,
    2449.3642578125,
    2335.6201171875,
    1937.5184326171875,
    6828.8916015625,
    6495.78759765625,
    13199.6376953125,
    2200.722900390625,
    2064.32470703125,
    4805.76806640625,
    2078.23291015625,
    2060.342529296875,
    2506.817626953125,
    5897.9404296875,
    5313.38720703125,
    46854.50390625,
    17652.7109375,
    10020.203125,
    47491.41015625,
    2341.1650390625,
    2325.906005859375,
    4363.6728515625,
    4359.3291015625,
    4461.5712890625,
    4774.4794921875,
    4616.0419921875,
    4527.158203125,
    4705.00341796875,
    2435.642578125,
    2378.87109375,
    4643.791015625,
    2306.80078125,
    2307.589111328125,
    2283.6357421875,
    2270.2919921875,
    2201.1953125,
    2196.842529296875,
    2400.671630859375,
    2343.898681640625,
    2337.23974609375,
    2326.297607421875,
    6090.3583984375,
    2703.792724609375,
    2507.029541015625,
    2739.21923828125,
    8421.375,
    14530.7099609375,
    11117.3505859375,
    13799.9814453125,
    10424.271484375,
    7649.41748046875,
    12224.908203125,
    8747.6806640625,
    7950.962890625,
    5936.15283203125,
    17371.2265625,
    708.8660888671875,
    4299.126953125,
    2412.537109375,
    198.77589416503906,
    4297.734375,
    6109.43212890625,
    6753.7177734375,
    4539.52490234375,
    9486.19921875,
    14520.1474609375,
    9117.8046875,
    9422.4521484375,
    9912.5537109375,
    12393.1650390625,
    13564.966796875,
    4895.90625,
    7207.3828125,
    9540.455078125,
    7490.60400390625,
    9456.794921875,
    5256.7548828125,
    4511.19580078125,
    7729.23095703125,
    8785.572265625,
    6963.91748046875,
    11489.150390625,
    6207.7568359375,
    9303.68359375,
    8855.80859375,
    5567.04541015625,
    9402.7900390625,
    10583.1494140625,
    4805.64111328125,
    35494.01171875,
    10143.2744140625,
    7502.20361328125,
    9562.771484375,
    8482.748046875,
    11170.39453125,
    10764.1591796875,
    7634.1064453125,
    9036.5595703125,
    10324.2646484375,
    24295.166015625,
    12416.1484375,
    11944.294921875,
    17140.734375,
    3675.083740234375,
    9053.22265625,
    8017.25048828125,
    12809.701171875,
    15974.548828125,
    8478.8154296875,
    35064.0,
    11340.5712890625,
    8797.6123046875,
    9723.7490234375,
    15569.5302734375,
    9449.396484375,
    4600.01416015625,
    20719.361328125,
    8838.8583984375,
    6810.232421875,
    4266.77783203125,
    4333.40625,
    3629.2998046875,
    3485.878662109375,
    5434.55126953125,
    7856.28662109375,
    2969.376953125,
    10158.849609375,
    6329.494140625,
    21053.8046875,
    16262.236328125,
    17785.896484375,
    7748.76220703125,
    5450.9736328125,
    13940.2255859375,
    7559.5810546875,
    8030.9970703125,
    6542.71337890625,
    5827.45068359375,
    12229.9970703125,
    51508.4296875,
    11076.130859375,
    17192.49609375,
    9016.91015625,
    19252.69921875,
    26949.375,
    10389.814453125,
    18251.123046875,
    8969.216796875,
    11545.962890625,
    5318.548828125,
    5253.60595703125,
    14146.5390625,
    13602.884765625,
    16418.80859375,
    18183.615234375,
    10233.146484375,
    11550.1357421875,
    9187.892578125,
    5194.69140625,
    15865.0595703125,
    22586.388671875,
    48328.765625,
    36827.5703125,
    11987.2138671875,
    7381.26708984375,
    6296.349609375,
    34296.08203125,
    12137.1640625,
    43550.75,
    17897.087890625,
    5608.07080078125,
    2725.340576171875,
    12266.1953125,
    12934.849609375,
    10317.345703125,
    3337.14111328125,
    8156.51123046875,
    7063.333984375,
    2569.345703125,
    4881.537109375,
    9908.7705078125,
    4486.04248046875,
    4382.97900390625,
    13295.810546875,
    13343.0966796875,
    9913.470703125,
    16866.201171875,
    9649.8564453125,
    9837.0908203125,
    38772.09375,
    2997.9560546875,
    6978.59033203125,
    3629.76611328125,
    4150.990234375,
    14286.583984375,
    7020.8525390625,
    9800.6591796875,
    37884.59765625,
    6692.17041015625,
    4761.2177734375,
    5776.8408203125,
    2603.119873046875,
    5690.92041015625,
    13893.3759765625,
    25813.021484375,
    7309.53271484375,
    15587.9365234375,
    6689.35107421875,
    16588.75,
    32318.5,
    7145.99267578125,
    9713.841796875,
    14906.09375,
    12178.2529296875,
    6216.50439453125,
    5122.7021484375,
    14537.7109375,
    5483.97119140625,
    44804.33203125,
    5996.02685546875,
    6117.0556640625,
    10925.318359375,
    6102.314453125,
    6091.74560546875,
    5010.982421875,
    8693.3173828125,
    6818.376953125,
    17765.5546875,
    12565.9697265625,
    18918.9609375,
    12670.0390625,
    8332.287109375,
    14751.0537109375,
    10328.4541015625,
    14675.64453125,
    9415.5869140625,
    22309.712890625,
    9538.57421875,
    18133.12890625,
    17531.5234375,
    7149.64697265625,
    11741.9287109375,
    19387.56640625,
    31990.529296875,
    12981.859375,
    6682.03125,
    6694.05419921875,
    11636.2724609375,
    127631.4453125,
    14648.5673828125,
    44872.00390625,
    6636.82568359375,
    10707.298828125,
    3521.348388671875,
    3440.0068359375,
    3653.58251953125,
    4274.65966796875,
    6275.615234375,
    7851.248046875,
    10419.3740234375,
    2529.6103515625,
    2412.24169921875,
    3874.19091796875,
    3777.45263671875,
    2202.594482421875,
    5290.6328125,
    4991.1650390625,
    25203.384765625,
    17075.986328125,
    2611.80615234375,
    5404.45703125,
    14606.69140625,
    12087.28125,
    9325.11328125,
    5591.57080078125,
    3973.089599609375,
    8508.017578125,
    44812.19921875,
    16894.267578125,
    3898.484130859375,
    8349.1171875,
    3804.141845703125,
    8187.98095703125,
    11734.919921875,
    8405.787109375,
    7132.44384765625,
    20073.056640625,
    3696.724365234375,
    2715.456787109375,
    17178.427734375,
    18744.9140625,
    7271.7255859375,
    7291.89013671875,
    16048.322265625,
    13478.29296875,
    3984.864013671875,
    3739.059814453125,
    16370.8935546875,
    7056.912109375,
    16444.861328125,
    9729.962890625,
    5889.884765625,
    3676.07763671875,
    5013.849609375,
    21061.998046875,
    5259.150390625,
    6640.7490234375,
    2438.1533203125,
    2292.607177734375,
    11859.462890625,
    3705.963134765625,
    4018.853271484375,
    3379.248291015625,
    11394.5888671875,
    7139.00732421875,
    6908.91162109375,
    5115.7158203125,
    4405.2734375,
    5995.96630859375,
    6565.90283203125,
    7627.34716796875,
    8546.2578125,
    5714.89453125,
    9798.1728515625,
    9788.1142578125,
    10164.0224609375,
    9224.3818359375,
    5250.380859375,
    5629.6875,
    8144.15087890625,
    5226.83642578125,
    5601.2978515625,
    17092.83984375,
    14483.22265625,
    6541.64794921875,
    5417.4140625,
    6838.13427734375,
    7984.7578125,
    5507.76025390625,
    3665.313720703125,
    7702.57177734375,
    11359.28515625,
    13332.11328125,
    9428.56640625,
    6390.26123046875,
    3888.577392578125,
    3172.925537109375,
    3047.05908203125,
    3483.70849609375,
    3505.20361328125,
    3291.5986328125,
    3308.803466796875,
    6269.8623046875,
    6266.33544921875,
    3537.536865234375,
    3501.277099609375,
    1885.5701904296875,
    4532.89404296875,
    6560.759765625,
    8099.82470703125,
    7892.47314453125,
    8279.0087890625,
    8185.35400390625,
    7980.22705078125,
    6407.92431640625,
    7758.349609375,
    5359.83544921875,
    3842.005859375,
    7861.8251953125,
    8003.9501953125,
    6640.685546875,
    24495.30078125,
    10927.6376953125,
    10386.1396484375,
    10578.0927734375,
    11226.4462890625,
    10552.978515625,
    11737.140625,
    11929.1103515625,
    12985.876953125,
    13350.689453125,
    10499.4248046875,
    10687.939453125,
    8925.5322265625,
    16769.546875,
    33390.9765625,
    10045.619140625,
    2518.85888671875,
    2707.4560546875,
    12408.8408203125,
    10668.3896484375,
    24587.32421875,
    29127.22265625,
    4574.61376953125,
    13468.3935546875,
    4349.71044921875,
    13245.19921875,
    16208.02734375,
    17328.669921875,
    11098.5732421875,
    3340.6943359375,
    3540.581787109375,
    16495.99609375,
    19574.87890625,
    2230.8154296875,
    2142.11083984375,
    4826.8447265625,
    2727.91845703125,
    2345.391357421875,
    2719.438232421875,
    11040.9931640625,
    4922.31787109375,
    2748.85546875,
    5050.83544921875,
    3293.438720703125,
    12194.435546875,
    6128.75341796875,
    6320.2021484375,
    9159.9072265625,
    15041.52734375,
    12095.3681640625,
    42220.1796875,
    12867.23828125,
    20654.154296875,
    8783.951171875,
    15088.3037109375,
    19964.375,
    32600.248046875,
    32986.09765625,
    26478.708984375,
    10709.1728515625,
    10966.41796875,
    2723.301025390625,
    5165.89208984375,
    31033.73046875,
    16174.8935546875,
    23934.560546875,
    8809.501953125,
    3953.285400390625,
    8976.2470703125,
    9743.2939453125,
    9524.5185546875,
    10054.3564453125,
    5129.32958984375,
    2660.168701171875,
    3187.46826171875,
    13662.7275390625,
    12741.1552734375,
    19298.91015625,
    11609.7177734375,
    5169.609375,
    9240.0986328125,
    2690.680908203125,
    4235.77783203125,
    2192.799072265625,
    25457.703125,
    25380.34375,
    12310.6162109375,
    13818.0615234375,
    49197.01953125,
    9092.7333984375,
    23195.421875,
    6066.302734375,
    11785.2080078125,
    8377.546875,
    7004.4873046875,
    5860.67529296875,
    8953.1884765625,
    8323.8828125,
    9757.421875,
    16238.1728515625,
    12347.8046875,
    8850.1611328125,
    27066.71875,
    35023.92578125,
    40462.19140625,
    19018.27734375,
    168.08111572265625,
    4349.0498046875,
    5061.72265625,
    3660.15283203125,
    4845.5869140625,
    12342.7041015625,
    3730.77783203125,
    4601.7734375,
    2517.852783203125,
    2475.0166015625,
    4978.455078125,
    13298.134765625,
    3879.498779296875,
    31698.392578125,
    24135.921875,
    29844.009765625,
    3896.513671875,
    4445.56640625,
    15038.4658203125,
    32055.458984375,
    32904.0,
    17103.857421875,
    12587.6689453125,
    12515.349609375,
    9945.515625,
    14476.80078125,
    14430.7978515625,
    2440.911865234375,
    2437.723876953125,
    23265.748046875,
    5052.248046875,
    2553.4833984375,
    2881.841064453125,
    21714.703125,
    8041.251953125,
    19427.810546875,
    9011.6728515625,
    4768.1044921875,
    17797.431640625,
    3165.815185546875,
    3253.99853515625,
    4167.9521484375,
    3074.662353515625,
    3063.66357421875,
    39.985958099365234,
    62.22690200805664,
    4759.93505859375,
    1296.794677734375,
    5166.10693359375,
    1185.1925048828125,
    7964.62841796875,
    10351.998046875,
    7871.4140625,
    433.4405822753906,
    1451.2442626953125,
    4745.58203125,
    1576.1396484375,
    4331.9921875,
    5675.421875,
    12338.712890625,
    2914.80859375,
    11765.7294921875,
    2181.091796875,
    6890.80908203125,
    7068.03759765625,
    4233.17822265625,
    17155.435546875,
    350.3178405761719,
    3384.136962890625,
    9050.7734375,
    3004.5458984375,
    3303.24169921875,
    3593.81982421875,
    6457.27001953125,
    2875.258056640625,
    12681.3466796875,
    8031.484375,
    7337.47900390625,
    2310.83544921875,
    2565.68212890625,
    22033.353515625,
    9386.6728515625,
    2748.929931640625,
    11186.486328125,
    34307.31640625,
    4661.04052734375,
    3680.761962890625,
    7847.87939453125,
    7232.31640625,
    4530.93505859375,
    12772.47265625,
    5813.2177734375,
    6788.9091796875,
    4759.82861328125,
    15657.978515625,
    563.3402709960938,
    2313.35498046875,
    4076.31591796875,
    2254.43408203125,
    460.3534851074219,
    2766.685791015625,
    4201.79541015625,
    2385.767578125,
    3748.650634765625,
    2173.131103515625,
    3505.691650390625,
    4336.708984375,
    5184.17529296875,
    5268.6982421875,
    10158.830078125,
    7106.5166015625,
    7108.12451171875,
    10619.4794921875,
    2618.69287109375,
    11185.607421875,
    3051.2333984375,
    1131.9342041015625,
    2353.461181640625,
    8082.009765625,
    8315.466796875,
    6439.33740234375,
    6449.32763671875,
    6713.041015625,
    6782.3779296875,
    4791.03857421875,
    5404.34912109375,
    8927.078125,
    6126.15869140625,
    1393.2559814453125,
    1381.739013671875,
    7879.89111328125,
    2109.011962890625,
    3051.130615234375,
    11427.1865234375,
    7228.76123046875,
    4135.8427734375,
    2440.413818359375,
    3033.82568359375,
    3880.760009765625,
    5693.9853515625,
    3512.966552734375,
    2256.54248046875,
    7218.12890625,
    3897.681884765625,
    12024.7822265625,
    4930.12353515625,
    2398.668701171875,
    2399.734619140625,
    2666.71142578125,
    2989.61865234375,
    1140.47216796875,
    4379.9873046875,
    14160.2392578125,
    11875.1142578125,
    1726.7801513671875,
    7757.4912109375,
    2429.838134765625,
    3126.79248046875,
    3198.712890625,
    1213.1129150390625,
    5229.1083984375,
    4861.3046875,
    8209.8779296875,
    11742.2900390625,
    4806.330078125,
    16913.18359375,
    13616.69921875,
    12762.6123046875,
    10034.330078125,
    4589.25439453125,
    4771.05029296875,
    6861.3974609375,
    12430.8515625,
    4040.292724609375,
    4688.07666015625,
    4687.04052734375,
    4188.86669921875,
    6712.1923828125,
    2535.0244140625,
    4747.67236328125,
    8070.787109375,
    5403.91650390625,
    5645.73046875,
    2183.373046875,
    4898.00146484375,
    5389.80224609375,
    3142.0439453125,
    2783.6220703125,
    8552.5634765625,
    7390.03271484375,
    3148.2001953125,
    1161.9486083984375,
    3731.7822265625,
    1970.500244140625,
    2513.186279296875,
    5925.7373046875,
    2139.136962890625,
    2373.071044921875,
    2539.789794921875,
    4147.9111328125,
    13936.6494140625,
    4254.51806640625,
    2405.416259765625,
    2370.710205078125,
    2670.76953125,
    4671.3232421875,
    14215.4189453125,
    46251.8046875,
    5686.78466796875,
    10245.43359375,
    2452.780517578125,
    9084.4140625,
    4616.55859375,
    3587.1494140625,
    16278.244140625,
    94.71073913574219,
    6390.51416015625,
    16373.81640625,
    9096.5615234375,
    4657.36083984375,
    2263.812255859375,
    2382.397216796875,
    72.80696868896484,
    383.4801940917969,
    1905.8277587890625,
    15529.908203125,
    10837.734375,
    2856.448486328125,
    2852.726806640625,
    2852.726806640625,
    11229.4248046875,
    4729.2939453125,
    2119.411865234375,
    2646.6376953125,
    6361.908203125,
    5816.85546875,
    5160.8818359375,
    4955.62451171875,
    5241.888671875,
    8531.3671875,
    9320.41015625,
    8251.0625,
    6633.5205078125,
    5764.6484375,
    2550.70654296875,
    14688.77734375,
    5565.35986328125,
    5602.7275390625,
    3536.048828125,
    3301.2041015625,
    5719.71337890625,
    5960.03076171875,
    5686.49658203125,
    13578.3095703125,
    12192.2451171875,
    8916.1552734375,
    2234.777587890625,
    4383.50390625,
    15313.98046875,
    5089.9765625,
    2984.976318359375,
    2341.035400390625,
    8589.724609375,
    2195.992919921875,
    19652.48046875,
    797.5347900390625,
    16287.2744140625,
    7585.56298828125,
    8085.2099609375,
    2871.267333984375,
    8089.2783203125,
    2976.6220703125,
    5457.9873046875,
    7010.08935546875,
    9943.9453125,
    20685.53125,
    13418.4443359375,
    6610.37109375,
    8543.505859375,
    13090.0771484375,
    5998.779296875,
    3495.275634765625,
    8045.701171875,
    11917.6728515625,
    8830.720703125,
    6631.3369140625,
    8959.53125,
    2264.79150390625,
    4895.0224609375,
    5182.2705078125,
    2984.487060546875,
    2995.824951171875,
    3110.613037109375,
    4223.5517578125,
    9956.990234375,
    4757.43115234375,
    4756.04736328125,
    5707.23486328125,
    8374.0048828125,
    13280.0693359375,
    4106.86083984375,
    2401.535400390625,
    8969.8759765625,
    5282.37841796875,
    21208.27734375,
    16014.40234375,
    5359.4375,
    7726.353515625,
    6751.00634765625,
    10729.318359375,
    9398.4208984375,
    7155.6787109375,
    26173.169921875,
    12925.9951171875,
    33159.828125,
    12951.607421875,
    11839.373046875,
    12848.07421875,
    4870.7744140625,
    2419.297119140625,
    16463.791015625,
    20244.130859375,
    19506.09375,
    17729.146484375,
    28098.5546875,
    17721.26953125,
    14203.5,
    4713.28466796875,
    2653.16015625,
    12935.55078125,
    5127.5166015625,
    12154.859375,
    10953.5771484375,
    11694.0458984375,
    8217.4033203125,
    10387.5458984375,
    49901.55859375,
    2350.859375,
    7114.67236328125,
    4934.029296875,
    7315.29541015625,
    21223.048828125,
    11771.4248046875,
    9663.734375,
    18089.31640625,
    8204.4423828125,
    7119.19140625,
    10395.662109375,
    11758.0380859375,
    8782.03515625,
    9763.9384765625,
    9762.333984375,
    9879.34765625,
    5281.0615234375,
    5198.287109375,
    2181.625,
    4846.39990234375,
    12416.392578125,
    11157.8974609375,
    11153.9638671875,
    9360.7548828125,
    6397.5439453125,
    14413.7138671875,
    7697.2587890625,
    7991.94580078125,
    18268.388671875,
    26997.63671875,
    43347.92578125,
    24670.83984375,
    47746.69921875,
    17685.443359375,
    15813.447265625,
    18103.3984375,
    11045.7041015625,
    16813.166015625,
    16180.1591796875,
    41239.31640625,
    20473.91015625,
    4037.736328125,
    5029.400390625,
    8484.009765625,
    2060.735595703125,
    2445.622314453125,
    3239.983642578125,
    14165.8388671875,
    3071.332275390625,
    10983.5908203125,
    4281.7333984375,
    10950.7041015625,
    4236.86962890625,
    2918.103515625,
    5691.68994140625,
    10024.4404296875,
    3409.027099609375,
    11845.0361328125,
    6474.85009765625,
    5807.6171875,
    2677.36865234375,
    2737.77880859375,
    2328.884521484375,
    2583.078369140625,
    2182.322021484375,
    2191.6279296875,
    6460.681640625,
    2362.467529296875,
    182.3759765625,
    2494.21435546875,
    2642.46142578125,
    8304.400390625,
    19910.392578125,
    9890.6748046875,
    6065.43017578125,
    2865.67724609375,
    7586.94384765625,
    12453.0625,
    9882.5908203125,
    15967.7119140625,
    3552.899658203125,
    4986.568359375,
    2506.965087890625,
    1993.3331298828125,
    10057.060546875,
    14553.7900390625,
    7130.8623046875,
    2370.5419921875,
    177.4254608154297,
    3937.68994140625,
    97674.6015625,
    6782.51416015625,
    41743.23828125,
    15883.205078125,
    7706.7451171875,
    6928.80859375,
    2337.5361328125,
    2301.787353515625,
    11225.015625,
    6577.51513671875,
    10826.65234375,
    28507.123046875,
    10906.0556640625,
    2201.566162109375,
    7058.443359375,
    2242.5615234375,
    10335.3427734375,
    2813.469970703125,
    2774.755615234375,
    13637.767578125,
    20767.140625,
    8815.29296875,
    6812.6162109375,
    9366.751953125,
    479.2272644042969,
    6115.67431640625,
    4873.85107421875,
    6791.69921875,
    4416.0322265625,
    11187.701171875,
    5921.6689453125,
    3585.12744140625,
    18878.3828125,
    11867.8359375,
    4539.17431640625,
    6432.82275390625,
    6898.43115234375,
    7219.01953125,
    726.1693115234375,
    2917.165283203125,
    11093.3505859375,
    3487.22265625,
    2984.583251953125,
    4081.315185546875,
    3013.309814453125,
    3007.0439453125,
    4502.26953125,
    5298.2666015625,
    1655.8026123046875,
    1882.7841796875,
    2180.6015625,
    4459.28271484375,
    1848.8759765625,
    5598.63720703125,
    5526.4169921875,
    3420.3466796875,
    6085.52880859375,
    4986.50732421875,
    4252.91650390625,
    6106.5126953125,
    12694.9208984375,
    2893.586181640625,
    4326.37939453125,
    5480.2685546875,
    2318.35888671875,
    3006.7841796875,
    2306.020751953125,
    2931.3369140625,
    5072.44482421875,
    10680.2216796875,
    2421.761474609375,
    38970.578125,
    9407.4384765625,
    13022.244140625,
    2617.44091796875,
    6062.6806640625,
    28947.865234375,
    21324.6875,
    24433.380859375,
    4559.17236328125,
    8656.5751953125,
    5329.4013671875,
    24447.54296875,
    9341.0029296875,
    44605.84765625,
    18026.396484375,
    6336.11376953125,
    22626.751953125,
    36056.546875,
    33650.95703125,
    24670.361328125,
    33304.53515625,
    7720.49658203125,
    12049.76171875,
    22854.068359375,
    12726.19140625,
    19612.2265625,
    13585.6826171875,
    21249.46484375,
    8110.55419921875,
    12577.3251953125,
    16206.9052734375,
    5131.3798828125,
    6379.5341796875,
    6295.71728515625,
    6034.2236328125,
    14608.623046875,
    18708.435546875,
    2153.298828125,
    5973.8828125,
    2217.31884765625,
    7130.06982421875,
    9104.484375,
    15528.2314453125,
    6217.98583984375,
    6188.73583984375,
    4498.6201171875,
    4826.3720703125,
    5840.603515625,
    3474.32666015625,
    5986.47705078125,
    4054.327880859375,
    7132.2412109375,
    6404.595703125,
    5540.92724609375,
    7000.72998046875,
    9219.22265625,
    3127.57421875,
    2455.1171875,
    2712.495361328125,
    4861.75048828125,
    7561.798828125,
    9022.416015625,
    4902.79248046875,
    11571.6650390625,
    3834.931396484375,
    9540.99609375,
    3610.344970703125,
    14096.20703125,
    11706.04296875,
    2915.29296875,
    2356.83056640625,
    5125.60986328125,
    5095.1337890625,
    8468.625,
    1938.0770263671875,
    7018.3837890625,
    15486.015625,
    11123.630859375,
    6372.21630859375,
    31955.34375,
    7625.240234375,
    2223.775634765625,
    1943.578125,
    5127.76513671875,
    2154.15576171875,
    9556.716796875,
    3317.460693359375,
    2438.352783203125,
    12796.9306640625,
    4701.3359375,
    4742.77783203125,
    14525.8369140625,
    26110.4921875,
    17579.595703125,
    6737.494140625,
    4535.65380859375,
    8352.81640625,
    2160.792236328125,
    10673.5439453125,
    5639.5556640625,
    10892.6630859375,
    8475.5693359375,
    5647.00390625,
    10189.134765625,
    5809.90283203125,
    6651.70263671875,
    6983.017578125,
    9071.6953125,
    9071.6953125,
    1219.0513916015625,
    5692.7392578125,
    5686.958984375,
    7660.09814453125,
    7655.13037109375,
    6998.435546875,
    16036.2333984375,
    5195.4501953125,
    8211.5,
    6915.79736328125,
    10315.3701171875,
    7276.4130859375,
    3015.282470703125,
    9587.7763671875,
    9582.0595703125,
    16843.26171875,
    16776.34765625,
    17883.333984375,
    36133.30859375,
    17537.130859375,
    1911.7529296875,
    5917.4716796875,
    4639.95361328125,
    3263.389892578125,
    5440.94140625,
    11465.09765625,
    3783.482421875,
    6516.57275390625,
    9907.8779296875,
    2663.289306640625,
    1843.1739501953125,
    4569.98095703125,
    6156.22705078125,
    4654.333984375,
    12226.8544921875,
    2833.238037109375,
    4740.29296875,
    20872.390625,
    13041.919921875,
    12524.2734375,
    9902.4033203125,
    12312.15625,
    9159.1669921875,
    8697.697265625,
    8835.75,
    11553.650390625,
    28145.888671875,
    5550.7138671875,
    2380.045654296875,
    8699.4833984375,
    6699.61962890625,
    4538.0087890625,
    13438.9375,
    10549.2841796875,
    13718.47265625,
    13116.6357421875,
    1896.9150390625,
    2310.3720703125,
    2310.640380859375,
    4928.974609375,
    17640.47265625,
    6094.47314453125,
    25024.58203125,
    6178.41552734375,
    4060.476806640625,
    10151.90234375,
    10151.90234375,
    2192.434814453125,
    10499.5029296875,
    2133.012939453125,
    1946.8250732421875,
    2129.155029296875,
    5307.583984375,
    7098.2548828125,
    7098.2548828125,
    7098.2548828125,
    5899.58740234375,
    21810.4296875,
    6167.33447265625,
    7155.732421875,
    12433.5419921875,
    10149.279296875,
    9844.658203125,
    1982.7852783203125,
    2342.22607421875,
    2342.22607421875,
    6677.47900390625,
    4497.05859375,
    10008.3203125,
    13324.0849609375,
    19229.423828125,
    2235.7744140625,
    2235.7744140625,
    20028.76953125,
    1961.3707275390625,
    9254.5576171875,
    6158.43017578125,
    8959.7763671875,
    6671.04248046875,
    22456.666015625,
    24179.560546875,
    9387.962890625,
    10394.7685546875,
    7195.07373046875,
    10653.046875,
    1927.84912109375,
    2117.576904296875,
    9697.7705078125,
    8566.185546875,
    9492.388671875,
    8942.388671875,
    6537.7841796875,
    8554.6025390625,
    10318.044921875,
    16694.697265625,
    10585.2880859375,
    10569.4970703125,
    10585.2880859375,
    10569.4970703125,
    10567.9150390625,
    10567.9150390625,
    9705.7939453125,
    11339.4443359375,
    3450.1826171875,
    1894.242919921875,
    1878.38818359375,
    2225.611083984375,
    7845.76708984375,
    7810.3203125,
    7794.515625,
    2128.88525390625,
    2081.29541015625,
    2113.92626953125,
    4315.2099609375,
    2128.86181640625,
    5961.0419921875,
    6774.216796875,
    10177.5908203125,
    11780.3876953125,
    11754.923828125,
    11739.1201171875,
    6975.85595703125,
    596.1595458984375,
    1687.194091796875,
    3226.104248046875,
    3172.21435546875,
    1720.77685546875,
    9739.451171875,
    9183.4248046875,
    8205.1171875,
    3784.824462890625,
    3290.42431640625,
    4975.9599609375,
    3248.64892578125,
    7289.072265625,
    18126.255859375,
    6835.91015625,
    24077.04296875,
    71959.578125,
    18815.166015625,
    32812.7578125,
    10676.171875,
    4198.943359375,
    6895.62890625,
    4192.501953125,
    8955.005859375,
    4388.6181640625,
    37369.06640625,
    7870.3671875,
    2602.01806640625,
    5652.1591796875,
    12511.701171875,
    12038.5419921875,
    12544.359375,
    419.18048095703125,
    1949.1053466796875,
    1836.2706298828125,
    3960.744873046875,
    4293.90771484375,
    3282.424072265625,
    3330.1142578125,
    4367.7998046875,
    8176.9677734375,
    6240.59423828125,
    4152.20458984375,
    5912.0830078125,
    5912.3212890625,
    5620.025390625,
    19984.96484375,
    12085.61328125,
    16514.71875,
    6173.0654296875,
    7080.73876953125,
    4457.46923828125,
    4175.60986328125,
    7172.044921875,
    5911.03173828125,
    8679.0849609375,
    8645.333984375,
    8389.509765625,
    8551.669921875,
    13274.099609375,
    13423.8193359375,
    13489.755859375,
    2302.330078125,
    4528.61376953125,
    9289.78515625,
    1467.99267578125,
    5455.3759765625,
    3947.273681640625,
    2256.822998046875,
    5810.6943359375,
    5465.28173828125,
    35145.8359375,
    7379.8388671875,
    20382.779296875,
    9109.9775390625,
    14854.884765625,
    5926.326171875,
    4943.46484375,
    4196.724609375,
    6326.677734375,
    9268.9013671875,
    12249.0791015625,
    32332.625,
    49241.08984375,
    5591.67578125,
    25421.306640625,
    26364.615234375,
    6387.0361328125,
    15029.7265625,
    12033.0576171875,
    32801.09375,
    21582.994140625,
    4505.205078125,
    2960.93212890625,
    51834.5625,
    41439.546875,
    38355.09765625,
    87304.8828125,
    16625.732421875,
    7938.697265625,
    11571.7978515625,
    492.91448974609375,
    2853.05224609375,
    10403.291015625,
    95.61848449707031,
    58.68441390991211,
    2595.8154296875,
    127.19264221191406,
    132.03555297851562,
    295.64892578125,
    96.35769653320312,
    80.43307495117188,
    7877.14794921875,
    5278.75,
    1901.4073486328125,
    5507.2587890625,
    5254.693359375,
    2101.249267578125,
    5016.75341796875,
    4672.64697265625,
    2170.890869140625,
    2325.301513671875,
    4520.43505859375,
    4403.03515625,
    2212.41015625,
    1162.976806640625,
    2079.31689453125,
    8860.953125,
    7132.890625,
    2022.6224365234375,
    35.70716857910156,
    2016.4000244140625,
    32.85194396972656,
    2016.23828125,
    32.85194396972656,
    79.69546508789062,
    79.69546508789062,
    141.14581298828125,
    2446.298583984375,
    1227.3040771484375,
    69.67357635498047,
    2301.684326171875,
    2215.85595703125,
    1146.5029296875,
    2057.753173828125,
    4866.8291015625,
    5066.55810546875,
    2126.191650390625,
    1382.3543701171875,
    4535.87548828125,
    2018.0172119140625,
    1794.5947265625,
    280.89520263671875,
    42.0233268737793,
    40.81682586669922,
    401.0248107910156,
    1238.3546142578125,
    52.3144645690918,
    2397.435302734375,
    1140.2401123046875,
    2221.678955078125,
    2217.272216796875,
    3952.984130859375,
    3950.15771484375,
    2252.5546875,
    2190.818115234375,
    1464.0765380859375,
    1925.2479248046875,
    2142.856201171875,
    2553.62158203125,
    2276.63818359375,
    2339.790283203125,
    2214.181640625,
    2246.72900390625,
    2559.940185546875,
    1503.707763671875,
    5811.6181640625,
    2418.34130859375,
    2461.759521484375,
    4883.30859375,
    2251.099609375,
    2353.586181640625,
    1379.2969970703125,
    2716.6298828125,
    4979.25634765625,
    5436.365234375,
    2520.8076171875,
    5255.5859375,
    5549.06298828125,
    7524.513671875,
    1170.407470703125,
    44.90637969970703,
    36.17278289794922,
    35.83528137207031,
    35.300777435302734,
    12196.1962890625,
    14451.2333984375,
    25911.009765625,
    2923.9423828125,
    2055.42529296875,
    1177.1553955078125,
    4555.9921875,
    4722.54638671875,
    2084.640380859375,
    11802.4443359375,
    2127.138427734375,
    2150.8017578125,
    5360.59326171875,
    5402.5849609375,
    1991.3621826171875,
    4172.33349609375,
    93.84184265136719,
    1946.0205078125,
    1914.62158203125,
    2394.091552734375,
    4157.85693359375,
    2277.29150390625,
    1636.496826171875,
    3425.355224609375,
    4876.05517578125,
    4800.548828125,
    4715.05078125,
    4438.70068359375,
    4198.24951171875,
    4603.45458984375,
    4182.90185546875,
    4234.92626953125,
    1881.9560546875,
    2442.144287109375,
    4468.3603515625,
    5143.423828125,
    7371.6494140625,
    2074.8427734375,
    4453.0,
    5075.83642578125,
    3252.406005859375,
    4482.59765625,
    4449.1494140625,
    4458.58349609375,
    4404.3681640625,
    2301.013427734375,
    2021.557373046875,
    4441.97265625,
    4751.87353515625,
    4511.138671875,
    2074.8427734375,
    3951.0986328125,
    4648.48583984375,
    6589.07958984375,
    12579.2685546875,
    5049.716796875,
    5040.21875,
    2118.11962890625,
    4384.994140625,
    4656.79443359375,
    4284.23193359375,
    4262.43310546875,
    2090.915283203125,
    2067.247314453125,
    4733.62646484375,
    4732.9453125,
    4438.359375,
    4476.4814453125,
    4353.85009765625,
    4211.6640625,
    4608.95703125,
    4194.7724609375,
    4390.7802734375,
    4927.9111328125,
    2477.44873046875,
    265.4491882324219,
    5876.5595703125,
    9804.8271484375,
    4595.11865234375,
    4434.37158203125,
    4360.705078125,
    4448.86572265625,
    7054.66650390625,
    5367.30908203125,
    5208.8935546875,
    15591.212890625,
    2047.2342529296875,
    1963.859619140625,
    5070.45068359375,
    4974.75,
    2062.751953125,
    5653.22900390625,
    5615.486328125,
    13671.787109375,
    2426.250732421875,
    251.96900939941406,
    5917.5009765625,
    6780.75732421875,
    2115.743896484375,
    4575.982421875,
    4490.09130859375,
    4379.4736328125,
    4484.0185546875,
    8218.580078125,
    5396.35791015625,
    5232.37646484375,
    23390.796875,
    5065.14794921875,
    4983.2099609375,
    5007.9677734375,
    2054.72900390625,
    1984.9296875,
    5693.12060546875,
    5846.09130859375,
    13293.029296875,
    2082.448974609375,
    2363.172119140625,
    2360.3779296875,
    2351.2734375,
    2360.105712890625,
    20776.6171875,
    5464.94189453125,
    5706.80419921875,
    5463.7470703125,
    7460.06689453125,
    3212.174072265625,
    2489.47021484375,
    17942.130859375,
    4524.10693359375,
    37959.2265625,
    3987.778076171875,
    6959.396484375,
    12213.4140625,
    14166.87890625,
    15092.998046875,
    1492.759765625,
    366.35601806640625,
    1625.8690185546875,
    53.566131591796875,
    3276.626708984375,
    6674.1171875,
    3649.197998046875,
    6365.61669921875,
    9960.3681640625,
    4465.05615234375,
    3293.05810546875,
    2218.895263671875,
    4088.801513671875,
    139.4846649169922,
    139.4846649169922,
    212.79104614257812,
    1366.7655029296875,
    2573.238525390625,
    72.72648620605469,
    2306.874267578125,
    3038.619384765625,
    2062.458251953125,
    3338.52294921875,
    2192.40673828125,
    4506.728515625,
    5817.1630859375,
    8317.1279296875,
    5619.185546875,
    8754.8369140625,
    4593.28515625,
    5629.865234375,
    5595.166015625,
    4642.05810546875,
    4517.93701171875,
    4028.29150390625,
    4025.30810546875,
    4069.770751953125,
    5199.8046875,
    4363.34130859375,
    4927.06494140625,
    4826.3486328125,
    16404.009765625,
    4957.40283203125,
    4953.64111328125,
    7074.48291015625,
    7065.93017578125,
    7048.03857421875,
    7045.84814453125,
    5056.6533203125,
    5055.68994140625,
    7057.70751953125,
    7047.5751953125,
    4402.77099609375,
    4483.7939453125,
    13829.0556640625,
    11245.9326171875,
    10570.9404296875,
    5595.6220703125,
    5802.1669921875,
    5633.8115234375,
    5821.25537109375,
    6486.98974609375,
    171.68870544433594,
    37.531063079833984,
    59.26605224609375,
    4161.4208984375,
    2129.42431640625,
    3491.34814453125,
    2131.843017578125,
    2215.772216796875,
    3134.1923828125,
    7955.6513671875,
    8027.8076171875,
    10492.681640625,
    4790.9716796875,
    6148.52978515625,
    2074.676025390625,
    11120.3779296875,
    17507.244140625,
    7242.54736328125,
    7134.9931640625,
    7655.13671875,
    8513.677734375,
    8531.474609375,
    17173.58203125,
    4441.99853515625,
    4341.57958984375,
    7464.0478515625,
    6405.1923828125,
    2557.892578125,
    32.85194396972656,
    48.43075180053711,
    3411.086181640625,
    4086.342041015625,
    8174.79736328125,
    2387.48388671875,
    2371.20458984375,
    2922.593017578125,
    2917.75048828125,
    2380.85791015625,
    2367.935546875,
    5845.45751953125,
    4575.91064453125,
    2498.138671875,
    475.547607421875,
    2608.505615234375,
    4497.9541015625,
    7841.41796875,
    5182.78515625,
    3957.65283203125,
    6916.14111328125,
    2556.564208984375,
    32.85194396972656,
    50.84993362426758,
    2213.010498046875,
    7521.48876953125,
    2049.68798828125,
    2075.000244140625,
    1865.29541015625,
    1331.6610107421875,
    4009.685302734375,
    2035.951171875,
    1809.19482421875,
    2045.235595703125,
    2419.192626953125,
    2212.3427734375,
    2209.21484375,
    1943.6339111328125,
    1897.7347412109375,
    105.31945037841797,
    1559.8372802734375,
    1184.123779296875,
    3254.148193359375,
    5517.5634765625,
    2361.993896484375,
    6291.5751953125,
    3808.972900390625,
    3911.631103515625,
    2042.80810546875,
    2132.063720703125,
    4108.8720703125,
    9370.9619140625,
    4424.216796875,
    10888.0615234375,
    2266.540771484375,
    4201.279296875,
    2266.938720703125,
    2216.106689453125,
    10029.9326171875,
    1839.8095703125,
    1838.927978515625,
    1844.050048828125,
    1839.8095703125,
    2259.880615234375,
    9105.01953125,
    4598.04345703125,
    2431.3427734375,
    4414.7216796875,
    1997.5906982421875,
    4852.88525390625,
    6592.017578125,
    6251.876953125,
    2328.750732421875,
    1772.3121337890625,
    1770.7923583984375,
    2042.2950439453125,
    1766.2008056640625,
    2507.72119140625,
    20362.16015625,
    7805.40625,
    21060.4296875,
    6179.013671875,
    5217.91162109375,
    232.66058349609375,
    4351.666015625,
    4609.7080078125,
    4418.82080078125,
    4880.5732421875,
    4025.102294921875,
    12898.9599609375,
    31063.150390625,
    17807.21484375,
    9234.9248046875,
    4648.0771484375,
    4630.73974609375,
    4614.8232421875,
    4619.9208984375,
    4634.923828125,
    4638.1689453125,
    4614.8232421875,
    4619.9208984375,
    4974.1611328125,
    4971.294921875,
    4648.0771484375,
    4634.923828125,
    4630.73974609375,
    4638.1689453125,
    4619.9208984375,
    4619.9208984375,
    4991.3359375,
    5022.001953125,
    4648.0771484375,
    4630.73974609375,
    4634.923828125,
    4648.06689453125,
    32976.44921875,
    8149.0556640625,
    13211.3662109375,
    9207.275390625,
    2602.55712890625,
    3049.457275390625,
    2602.55712890625,
    3049.457275390625,
    2869.768310546875,
    2869.768310546875,
    2785.64892578125,
    2785.64892578125,
    2695.546630859375,
    2695.546630859375,
    2605.451171875,
    2605.451171875,
    3051.908203125,
    3051.908203125,
    2869.768310546875,
    2869.768310546875,
    2793.388671875,
    2788.4208984375,
    2703.78271484375,
    2699.171142578125,
    6682.341796875,
    5906.80810546875,
    3183.210205078125,
    4011.557861328125,
    4005.51611328125,
    4162.1181640625,
    4417.35107421875,
    4344.294921875,
    4565.8056640625,
    8193.21875,
    16339.5126953125,
    11248.857421875,
    12009.1748046875,
    3483.030517578125,
    9221.599609375,
    5936.638671875,
    16518.88671875,
    25228.541015625,
    11340.873046875,
    2110.32666015625,
    2634.2470703125,
    2644.717529296875,
    2644.717529296875,
    2256.43603515625,
    3456.77783203125,
    9427.03515625,
    4219.5166015625,
    18918.619140625,
    7417.2646484375,
    13595.033203125,
    15814.763671875,
    15979.078125,
    5615.9345703125,
    8562.26171875,
    13757.8447265625,
    31315.52734375,
    7634.2587890625,
    4090.439453125,
    4781.439453125,
    4190.0302734375,
    4018.8818359375,
    814.6077880859375,
    5498.19921875,
    6240.31201171875,
    7609.5302734375,
    4968.85205078125,
    2134.503173828125,
    2172.021240234375,
    2121.4609375,
    81.24662780761719,
    54.989044189453125,
    63.49755096435547,
    4258.591796875,
    2140.513671875,
    2730.60107421875,
    3719.349609375,
    9240.53125,
    6518.033203125,
    5900.07373046875,
    2025.421630859375,
    3971.606201171875,
    2176.244873046875,
    2933.730712890625,
    3489.213134765625,
    3350.363525390625,
    2251.29248046875,
    4488.7744140625,
    4631.99658203125,
    4556.15673828125,
    4658.15234375,
    4641.88720703125,
    7756.36572265625,
    5353.71826171875,
    5416.10693359375,
    5646.5439453125,
    5424.85546875,
    7114.38232421875,
    2729.901123046875,
    2234.574462890625,
    2134.252685546875,
    2189.90185546875,
    2037.74169921875,
    4922.0078125,
    5522.37158203125,
    2119.419189453125,
    1957.7589111328125,
    3778.022216796875,
    2413.53857421875,
    2270.9921875,
    2152.701416015625,
    2429.277587890625,
    2315.530517578125,
    2300.327880859375,
    4075.883056640625,
    10311.6669921875,
    5578.03125,
    3033.37646484375,
    5090.66552734375,
    15190.4453125,
    8831.9970703125,
    4185.96044921875,
    5068.83740234375,
    3051.880615234375,
    3069.65185546875,
    4287.365234375,
    4268.92626953125,
    2162.086669921875,
    2207.220458984375,
    2092.627197265625,
    1780.0037841796875,
    1843.639404296875,
    1920.9332275390625,
    119.59957122802734,
    54.17120361328125,
    69.61554718017578,
    4427.32177734375,
    4382.53125,
    3917.091552734375,
    4076.461669921875,
    1978.0706787109375,
    4515.505859375,
    351.1957092285156,
    182.1577606201172,
    2562.3447265625,
    2741.126708984375,
    2587.069091796875,
    10717.8984375,
    5630.32373046875,
    5338.48095703125,
    5347.11083984375,
    2253.36083984375,
    5812.13916015625,
    12365.1708984375,
    9566.01171875,
    9133.09375,
    2042.585693359375,
    6742.37158203125,
    4275.21337890625,
    1909.930419921875,
    4685.92626953125,
    4492.30615234375,
    4628.6396484375,
    7130.763671875,
    7137.58447265625,
    10773.0498046875,
    4328.19482421875,
    2249.368896484375,
    3170.997314453125,
    2111.1982421875,
    3362.41748046875,
    20859.783203125,
    7007.875,
    7007.875,
    6233.48193359375,
    3390.53955078125,
    3380.845458984375,
    21011.505859375,
    7807.02197265625,
    4346.1708984375,
    2231.56689453125,
    2239.75390625,
    2711.44189453125,
    6415.623046875,
    4717.3134765625,
    7320.4794921875,
    3491.4208984375,
    2118.710693359375,
    2152.294189453125,
    21432.884765625,
    16292.6083984375,
    8181.80712890625,
    43.84617614746094,
    2380.565673828125,
    1892.308837890625,
    9246.380859375,
    9561.54296875,
    1782.5029296875,
    2210.3515625,
    2027.174560546875,
    1802.32373046875,
    7870.93603515625,
    7847.72802734375,
    5011.0810546875,
    5067.5625,
    2241.292724609375,
    2270.72265625,
    2196.188232421875,
    2033.0430908203125,
    1989.003662109375,
    2050.47705078125,
    4864.0732421875,
    2265.26708984375,
    8119.990234375,
    2249.303955078125,
    8654.8779296875,
    4870.15478515625,
    7196.69580078125,
    4323.666015625,
    4151.0078125,
    7252.837890625,
    2555.027099609375,
    2121.00146484375,
    1933.4471435546875,
    4875.58056640625,
    11400.2431640625,
    4417.79931640625,
    2126.076171875,
    12673.80859375,
    10762.5,
    20303.533203125,
    9997.267578125,
    2195.486083984375,
    2183.498046875,
    5075.13232421875,
    4238.88427734375,
    5677.240234375,
    5512.47607421875,
    7936.8525390625,
    6555.46337890625,
    8382.97265625,
    4306.10107421875,
    18018.431640625,
    6092.453125,
    1771.2978515625,
    4320.3173828125,
    4272.76318359375,
    4085.406005859375,
    2127.42138671875,
    2138.165283203125,
    5225.974609375,
    4006.127685546875,
    4251.55419921875,
    2135.606689453125,
    3163.577392578125,
    2166.50732421875,
    4818.18505859375,
    6460.12255859375,
    2625.464111328125,
    6006.05126953125,
    6728.0302734375,
    6740.46923828125,
    3984.917724609375,
    3889.565673828125,
    2231.218017578125,
    2222.0693359375,
    4608.51708984375,
    1999.019287109375,
    4603.00341796875,
    1839.2330322265625,
    1820.021728515625,
    4629.30419921875,
    4540.43115234375,
    4577.236328125,
    2353.54833984375,
    5234.70849609375,
    2173.2041015625,
    5629.5341796875,
    6386.8408203125,
    4766.8505859375,
    10103.65234375,
    2155.8603515625,
    4876.2734375,
    2598.484375,
    4597.51416015625,
    4115.26611328125,
    8965.2890625,
    1874.5543212890625,
    1864.8304443359375,
    5813.2578125,
    4810.4736328125,
    8565.529296875,
    4710.19189453125,
    8208.4697265625,
    2066.553955078125,
    2051.133056640625,
    2273.486572265625,
    2663.560791015625,
    2593.950927734375,
    3811.066650390625,
    2116.6767578125,
    2367.57568359375,
    2911.67626953125,
    3930.364013671875,
    4878.90966796875,
    2021.48583984375,
    4833.22705078125,
    2509.211181640625,
    9169.533203125,
    7463.43896484375,
    2621.789794921875,
    2635.830078125,
    2521.798583984375,
    2517.6279296875,
    1975.0184326171875,
    1891.40576171875,
    59.189395904541016,
    5171.1474609375,
    2335.9951171875,
    4987.02197265625,
    4516.7783203125,
    12931.0771484375,
    2254.3369140625,
    2653.47998046875,
    2568.57958984375,
    3870.155517578125,
    2131.520263671875,
    4835.06884765625,
    4192.3291015625,
    2587.36328125,
    2611.5361328125,
    2531.641845703125,
    4451.841796875,
    2167.40234375,
    2056.669189453125,
    2178.931396484375,
    8138.513671875,
    8729.42578125,
    8198.5791015625,
    2136.61865234375,
    2047.8668212890625,
    2095.311279296875,
    99.62992858886719,
    4208.68408203125,
    4273.677734375,
    4303.92919921875,
    4188.65283203125,
    4280.8291015625,
    4277.267578125,
    2056.9140625,
    5232.16943359375,
    5232.16943359375,
    2193.12451171875,
    2172.869140625,
    2123.083740234375,
    5689.83251953125,
    3418.438232421875,
    3714.595947265625,
    3494.510498046875,
    3494.510498046875,
    5271.912109375,
    2763.841796875,
    5197.04296875,
    5231.76806640625,
    16359.728515625,
    2645.773681640625,
    4692.9169921875,
    4312.91943359375,
    5258.82470703125,
    5268.2587890625,
    1938.384521484375,
    2764.847412109375,
    4206.0498046875,
    2680.54931640625,
    2680.54931640625,
    1925.0836181640625,
    2151.6474609375,
    2082.686767578125,
    7232.470703125,
    7727.9765625,
    3428.935302734375,
    3428.935302734375,
    4375.55322265625,
    2508.29833984375,
    2575.7255859375,
    2448.123046875,
    12030.8212890625,
    5359.11474609375,
    5284.51123046875,
    5382.41455078125,
    5370.1572265625,
    5939.98193359375,
    5950.4248046875,
    11134.078125,
    10045.34765625,
    7393.7099609375,
    13846.6181640625,
    15825.189453125,
    2680.197265625,
    2534.45654296875,
    6215.79931640625,
    2291.390380859375,
    2073.13037109375,
    2187.717529296875,
    5444.0966796875,
    8367.5263671875,
    4875.08349609375,
    7258.47021484375,
    1930.47900390625,
    6236.5302734375,
    2130.51806640625,
    6032.05322265625,
    20883.95703125,
    12043.15625,
    7827.79150390625,
    11629.1416015625,
    12369.7666015625,
    24379.052734375,
    6732.349609375,
    11983.9619140625,
    12621.0888671875,
    4866.912109375,
    13747.56640625,
    10905.9033203125,
    1951.154296875,
    6328.94873046875,
    13899.314453125,
    5249.509765625,
    6050.73046875,
    4748.1015625,
    6238.1865234375,
    5959.83349609375,
    7507.7724609375,
    8840.064453125,
    10434.9248046875,
    4719.669921875,
    3440.082275390625,
    8705.6171875,
    8472.95703125,
    2407.369140625,
    5964.18798828125,
    1837.752197265625,
    9295.9033203125,
    7981.8935546875,
    5992.04248046875,
    28070.724609375,
    11690.1162109375,
    3049.297607421875,
    5284.48046875,
    3985.764892578125,
    10174.4375,
    2072.25048828125,
    55475.81640625,
    52937.63671875,
    25666.37109375,
    78663.7109375,
    267572.84375,
    48369.89453125,
    5382.6767578125,
    22251.779296875,
    75042.0625,
    3390.654541015625,
    37553.015625,
    8520.6279296875,
    2553.058837890625,
    2487.538818359375,
    6841.63232421875,
    15572.2451171875,
    48662.7265625,
    35616.94921875,
    40333.6796875,
    12397.1435546875,
    29041.068359375,
    3783.114501953125,
    7543.4775390625,
    7744.49072265625,
    7980.15673828125,
    7081.390625,
    2108.43505859375,
    7016.19482421875,
    19229.400390625,
    11762.6904296875,
    28613.673828125,
    21584.5546875,
    2249.3798828125,
    7665.44287109375,
    7727.8515625,
    8500.154296875,
    5264.70458984375,
    2230.1611328125,
    2510.4521484375,
    4842.2197265625,
    4834.1123046875,
    7373.13427734375,
    6390.23388671875,
    4634.291015625,
    4604.03515625,
    5009.478515625,
    4970.78759765625,
    5028.13720703125,
    5002.23974609375,
    15258.705078125,
    2286.691162109375,
    5082.5205078125,
    11583.455078125,
    11423.8984375,
    3375.30126953125,
    3515.03857421875,
    13190.220703125,
    9721.4130859375,
    7561.916015625,
    4218.341796875,
    10389.783203125,
    6170.41015625,
    8571.19140625,
    15970.40625,
    7787.2333984375,
    2643.950439453125,
    2158.837646484375,
    5493.30615234375,
    9739.7685546875,
    9665.8056640625,
    4850.58251953125,
    4929.3369140625,
    4957.5927734375,
    5844.5830078125,
    7392.22509765625,
    5690.21533203125,
    12665.2578125,
    39704.83984375,
    9398.6650390625,
    18837.42578125,
    45927.9140625,
    146280.625,
    9704.76953125,
    5759.25537109375,
    10749.109375,
    8696.306640625,
    9255.3544921875,
    2292.075439453125,
    3348.015869140625,
    11492.4697265625,
    5503.84033203125,
    11408.7470703125,
    5456.43994140625,
    1918.5968017578125,
    5338.29833984375,
    8523.8857421875,
    4676.6611328125,
    4460.126953125,
    4476.158203125,
    4807.6865234375,
    2225.0693359375,
    11295.5498046875,
    5500.62255859375,
    1892.4508056640625,
    4775.033203125,
    6129.181640625,
    1894.1778564453125,
    1842.6475830078125,
    6880.26318359375,
    5325.4638671875,
    4786.95947265625,
    2218.38720703125,
    12623.482421875,
    13674.4560546875,
    5904.83642578125,
    5478.25048828125,
    5419.03466796875,
    11002.736328125,
    10777.2724609375,
    4783.6376953125,
    4743.09912109375,
    6852.9111328125,
    2761.35986328125,
    6628.767578125,
    1851.6414794921875,
    1890.6209716796875,
    6070.302734375,
    4512.64990234375,
    14431.470703125,
    4532.6787109375,
    4531.75537109375,
    4528.22509765625,
    4528.09375,
    2895.52392578125,
    2453.798583984375,
    7559.4658203125,
    7677.12841796875,
    7644.63671875,
    2164.491943359375,
    2859.500732421875,
    2865.126708984375,
    2856.4638671875,
    7461.76953125,
    2859.500732421875,
    4591.10400390625,
    2471.90576171875,
    3021.093017578125,
    2396.497802734375,
    7962.34326171875,
    8031.61865234375,
    8028.20654296875,
    7824.57421875,
    7757.2294921875,
    7872.64208984375,
    7846.68408203125,
    2892.49560546875,
    2750.1484375,
    8332.4326171875,
    8332.4326171875,
    5165.146484375,
    5181.89794921875,
    7723.9501953125,
    7589.19091796875,
    8014.34033203125,
    5491.52197265625,
    5428.35693359375,
    10351.7919921875,
    10231.154296875,
    8967.140625,
    9984.76171875,
    9008.5537109375,
    5138.7939453125,
    4108.3046875,
    5662.908203125,
    1952.7020263671875,
    8487.0126953125,
    8388.7294921875,
    11380.9560546875,
    2190.77685546875,
    7390.013671875,
    290.7568664550781,
    32.85194396972656,
    33.47336959838867,
    3799.53564453125,
    32.85194396972656,
    32.85194396972656,
    32.85194396972656,
    4298.671875,
    5409.1171875,
    6118.92626953125,
    5601.380859375,
    5232.3603515625,
    2047.048095703125,
    2096.32470703125,
    11361.689453125,
    60.73054504394531,
    8909.5927734375,
    2161.693115234375,
    2253.3759765625,
    12183.5673828125,
    14219.8359375,
    4804.51220703125,
    4851.4697265625,
    4764.78369140625,
    4547.98583984375,
    18525.775390625,
    4950.1201171875,
    5015.34033203125,
    4858.5185546875,
    10547.333984375,
    2014.9219970703125,
    5944.29248046875,
    7478.69970703125,
    2528.943115234375,
    3011.057861328125,
    7754.8837890625,
    4699.490234375,
    4355.07568359375,
    140.1339569091797,
    1970.7423095703125,
    3573.5048828125,
    4881.93994140625,
    12300.6845703125,
    4906.76708984375,
    15063.36328125,
    28374.40625,
    12150.345703125,
    64068.09375,
    2459.541748046875,
    2539.236572265625,
    2552.55517578125,
    18180.365234375,
    2119.48828125,
    12659.578125,
    15269.2802734375,
    4710.8115234375,
    2496.4892578125,
    2739.72509765625,
    2924.505126953125,
    2022.40625,
    11953.6083984375,
    2056.996337890625,
    9338.353515625,
    14883.4111328125,
    12930.65234375,
    7082.4677734375,
    3104.981689453125,
    1902.3492431640625,
    9519.31640625,
    7821.25146484375,
    4654.67822265625,
    4488.63916015625,
    4582.060546875,
    4527.2197265625,
    9065.0810546875,
    348.1365966796875,
    4167.18359375,
    7671.1630859375,
    7650.951171875,
    6026.419921875,
    5698.7919921875,
    2233.23876953125,
    4446.81787109375,
    3359.433349609375,
    6848.083984375,
    7716.9775390625,
    9175.2001953125,
    8970.748046875,
    4230.42431640625,
    6166.24951171875,
    5008.0068359375,
    5112.70166015625,
    888.5693969726562,
    3977.33642578125,
    26201.953125,
    1084.105224609375,
    11850.041015625,
    4995.9052734375,
    8806.337890625,
    12517.0908203125,
    4231.83642578125,
    2527.34521484375,
    883.8451538085938,
    60598.65234375,
    5049.166015625,
    13096.4453125,
    2511.8173828125,
    27756.123046875,
    2918.32421875,
    1280.7681884765625,
    4739.72265625,
    2881.736328125,
    8294.0107421875,
    4666.08740234375,
    6596.93994140625,
    5951.38671875,
    28540.9375,
    12319.5,
    3188.115478515625,
    9928.552734375,
    8555.869140625,
    13184.2890625,
    5673.82275390625,
    15338.7294921875,
    4859.55908203125,
    10200.4599609375,
    3689.415283203125,
    6053.05322265625,
    9107.7919921875,
    4710.962890625,
    8375.96484375,
    322.70001220703125,
    3204.10546875,
    3122.544189453125,
    2530.90380859375,
    2355.28271484375,
    2866.154052734375,
    2912.93994140625,
    11206.8291015625,
    3019.016357421875,
    5251.814453125,
    2223.0234375,
    5789.66552734375,
    4104.04345703125,
    6993.94970703125,
    4051.1669921875,
    15796.2041015625,
    4968.79833984375,
    28956.951171875,
    3003.86962890625,
    7790.033203125,
    7318.15771484375,
    13066.3134765625,
    10218.5400390625,
    9359.5478515625,
    6808.59521484375,
    327.619384765625,
    2755.141357421875,
    3068.12255859375,
    4590.458984375,
    2329.55126953125,
    2870.984130859375,
    2854.7021484375,
    2004.2432861328125,
    6217.4775390625,
    5178.17919921875,
    39752.19140625,
    10342.7236328125,
    5257.07373046875,
    21619.5390625,
    6313.80615234375,
    6302.51318359375,
    7582.41796875,
    15430.5595703125,
    2683.32763671875,
    2784.64453125,
    2728.39599609375,
    2435.188232421875,
    4715.10009765625,
    7632.064453125,
    4666.359375,
    2594.457763671875,
    8677.5908203125,
    2579.886474609375,
    2637.11572265625,
    2118.992431640625,
    19917.6328125,
    8278.3017578125,
    1857.664794921875,
    1880.2667236328125,
    2484.74609375,
    7424.67626953125,
    4215.826171875,
    3412.46923828125,
    2763.243896484375,
    2257.4208984375,
    4314.7314453125,
    2285.09521484375,
    9936.0263671875,
    10830.89453125,
    2757.065673828125,
    9022.3466796875,
    12939.6962890625,
    2714.199951171875,
    2382.81787109375,
    2758.89208984375,
    3011.576904296875,
    2065.9580078125,
    2083.765380859375,
    2172.000732421875,
    4047.800048828125,
    5217.72265625,
    4324.9501953125,
    7506.17529296875,
    5352.5302734375,
    4323.17041015625,
    6654.8251953125,
    2829.040771484375,
    2623.59814453125,
    2341.416259765625,
    7103.81396484375,
    4702.7294921875,
    8829.1875,
    5117.13818359375,
    13160.9931640625,
    7480.80126953125,
    9040.0634765625,
    2411.46142578125,
    10721.623046875,
    5195.59228515625,
    452.5577087402344,
    4688.548828125,
    3615.545166015625,
    3617.135986328125,
    3628.186767578125,
    6229.6376953125,
    10362.990234375,
    10386.8310546875,
    7804.02294921875,
    7817.720703125,
    4583.68896484375,
    4560.166015625,
    2367.39990234375,
    4844.529296875,
    3603.30615234375,
    3647.047607421875,
    6632.79150390625,
    4922.91796875,
    9185.494140625,
    4522.822265625,
    4582.1728515625,
    4591.37353515625,
    12342.326171875,
    12352.609375,
    4968.3046875,
    4974.7060546875,
    16262.5537109375,
    2294.71728515625,
    5151.1787109375,
    16413.1015625,
    2299.43310546875,
    21936.94921875,
    9987.173828125,
    11347.5,
    11368.205078125,
    2139.454833984375,
    7320.28369140625,
    1927.85302734375,
    5938.0400390625,
    6388.5712890625,
    1810.7777099609375,
    2270.837158203125,
    3207.873046875,
    15742.28515625,
    13933.16015625,
    7308.18701171875,
    7259.6328125,
    10167.39453125,
    1989.4097900390625,
    5301.83349609375,
    7056.45361328125,
    1879.43798828125,
    3958.10986328125,
    9756.802734375,
    1990.776611328125,
    2022.6988525390625,
    1916.26123046875,
    2247.2646484375,
    13127.71484375,
    11711.3564453125,
    5582.19775390625,
    9106.873046875,
    4504.89111328125,
    1890.7591552734375,
    358.00836181640625,
    756.160888671875,
    4647.45166015625,
    3862.764404296875,
    3729.077392578125,
    2250.281005859375,
    2114.489990234375,
    2271.816162109375,
    2201.636474609375,
    2605.608642578125,
    8156.1337890625,
    2353.257080078125,
    2376.287109375,
    34304.1796875,
    3284.189697265625,
    2176.220947265625,
    2215.68603515625,
    6655.15869140625,
    46736.51953125,
    3287.652099609375,
    9299.37890625,
    2082.510009765625,
    17398.982421875,
    27111.001953125,
    39486.875,
    4812.69775390625,
    11046.23828125,
    29900.1328125,
    16461.935546875,
    2037.1705322265625,
    14280.9208984375,
    14344.083984375,
    7884.5771484375,
    9540.0458984375,
    8646.5107421875,
    2166.188720703125,
    2012.912109375,
    7645.828125,
    1966.6683349609375,
    1949.2415771484375,
    1967.3875732421875,
    1941.4288330078125,
    6861.7578125,
    8500.826171875,
    4797.1806640625,
    4706.7685546875,
    15322.19921875,
    2145.154296875,
    2576.516845703125,
    2547.7490234375,
    2554.997802734375,
    1918.7481689453125,
    2064.480224609375,
    2053.593994140625,
    2183.84814453125,
    1870.433837890625,
    9186.3837890625,
    9902.2158203125,
    32.85194396972656,
    36.575016021728516,
    41.66771697998047,
    2085.700439453125,
    7078.01953125,
    8413.7158203125,
    4396.2080078125,
    2577.278564453125,
    2558.451416015625,
    2056.273681640625,
    2048.62646484375,
    2537.857421875,
    2134.230712890625,
    16451.193359375,
    8926.876953125,
    15025.978515625,
    7344.65087890625,
    6461.09228515625,
    4676.89404296875,
    8491.591796875,
    1769.9857177734375,
    1766.3841552734375,
    9013.1826171875,
    15798.3798828125,
    2573.09716796875,
    2554.27001953125,
    2056.273681640625,
    2048.62646484375,
    2533.67626953125,
    2130.04931640625,
    13415.8388671875,
    15038.6845703125,
    39871.16796875,
    13727.1904296875,
    11339.6845703125,
    32709.78515625,
    6288.5986328125,
    8303.564453125,
    6893.056640625,
    1760.9027099609375,
    10485.3251953125,
    1812.5504150390625,
    4770.3466796875,
    5302.91015625,
    9063.625,
    12649.0869140625,
    4685.421875,
    7206.6630859375,
    2136.68408203125,
    5033.841796875,
    9038.4775390625,
    10443.22265625,
    2356.169921875,
    5529.16162109375,
    8024.4150390625,
    7667.64990234375,
    2874.15966796875,
    3218.894287109375,
    2733.95654296875,
    4851.8720703125,
    2910.4970703125,
    4930.32763671875,
    4780.42333984375,
    1909.934814453125,
    1972.4295654296875,
    1959.3212890625,
    7916.60546875,
    3732.62109375,
    6497.35107421875,
    8360.5673828125,
    2201.36865234375,
    4441.86865234375,
    6525.69921875,
    6569.89013671875,
    1938.1748046875,
    1902.01123046875,
    4708.1953125,
    4694.37548828125,
    4701.97265625,
    3135.452392578125,
    5016.9033203125,
    8011.38330078125,
    3991.615966796875,
    1890.4285888671875,
    2562.047119140625,
    8658.8134765625,
    9012.0791015625,
    7852.61376953125,
    2213.037353515625,
    1961.1156005859375,
    2169.278076171875,
    2298.78955078125,
    2520.22607421875,
    2485.095703125,
    2311.4931640625,
    1895.4317626953125,
    2125.369873046875,
    2590.92333984375,
    12110.392578125,
    14325.69921875,
    2043.546875,
    24932.287109375,
    15738.498046875,
    9445.7744140625,
    4097.94189453125,
    2586.322021484375,
    12770.896484375,
    12466.228515625,
    4727.05322265625,
    4703.07080078125,
    6859.1650390625,
    4045.7958984375,
    2589.8984375,
    13019.5087890625,
    6860.548828125,
    4724.416015625,
    4701.21337890625,
    21587.205078125,
    9769.03515625,
    10103.1923828125,
    12899.751953125,
    18040.810546875,
    4464.22705078125,
    3123.9736328125,
    3126.76123046875,
    10659.8095703125,
    9145.4287109375,
    9023.2529296875,
    3466.7685546875,
    2117.89013671875,
    2195.628662109375,
    14177.2421875,
    2146.1796875,
    5377.0302734375,
    2597.232666015625,
    10627.7626953125,
    13948.490234375,
    8679.4296875,
    4838.41748046875,
    4799.5615234375,
    3469.023681640625,
    5037.1435546875,
    2196.009765625,
    18127.40234375,
    2299.423095703125,
    5375.4521484375,
    9444.330078125,
    4371.3603515625,
    47710.45703125,
    53147.484375,
    36222.98828125,
    4825.01171875,
    4807.6640625,
    4707.1640625,
    36.878379821777344,
    4649.2373046875,
    2063.584228515625,
    2063.584228515625,
    9774.4765625,
    2655.625,
    6553.146484375,
    4549.21435546875,
    2630.57470703125,
    9081.123046875,
    9925.62109375,
    7433.41259765625,
    2400.196044921875,
    1090.96630859375,
    4497.20654296875,
    2978.34130859375,
    5245.68408203125,
    5470.849609375,
    4359.380859375,
    3814.548095703125,
    12885.708984375,
    7737.568359375,
    2433.16796875,
    2034.078369140625,
    25397.37109375,
    16850.751953125,
    22617.623046875,
    30229.291015625,
    21613.142578125,
    17245.912109375,
    7345.462890625,
    7604.6396484375,
    2264.44287109375,
    31453.53125,
    21076.912109375,
    9677.3994140625,
    12150.388671875,
    2963.059814453125,
    10869.30078125,
    8972.861328125,
    7456.78759765625,
    1936.9788818359375,
    10879.5810546875,
    2374.345947265625,
    2509.997314453125,
    2592.307861328125,
    2305.7333984375,
    4881.55615234375,
    45036.51171875,
    23062.61328125,
    8351.6728515625,
    10030.2587890625,
    7611.037109375,
    8792.22265625,
    18384.7734375,
    28274.08984375,
    22122.87890625,
    4599.27294921875,
    5116.4501953125,
    10482.2451171875,
    3495.112060546875,
    6350.9130859375,
    14553.51953125,
    10007.6533203125,
    6803.34814453125,
    6388.08642578125,
    2808.5390625,
    3046.01318359375,
    8210.9013671875,
    8167.455078125,
    47240.640625,
    36717.78125,
    24035.84765625,
    5234.37646484375,
    4260.076171875,
    21910.17578125,
    4287.5087890625,
    2501.263427734375,
    5772.08447265625,
    1890.09228515625,
    2581.336669921875,
    2598.57080078125,
    2569.8369140625,
    2545.860107421875,
    2516.56201171875,
    3783.318115234375,
    2142.457763671875,
    2555.19677734375,
    69.64813995361328,
    1910.6368408203125,
    4686.03173828125,
    4713.458984375,
    4687.89990234375,
    4660.39599609375,
    4631.1376953125,
    3545.75244140625,
    4265.19970703125,
    4669.72265625,
    4057.0166015625,
    4031.093994140625,
    4157.025390625,
    4149.22021484375,
    5262.6044921875,
    2764.157958984375,
    2785.076416015625,
    2719.5283203125,
    2778.0322265625,
    2902.197021484375,
    5004.90673828125,
    1909.541259765625,
    1932.4307861328125,
    5014.99365234375,
    5626.20703125,
    2132.985595703125,
    6267.1884765625,
    4110.947265625,
    1977.0616455078125,
    18158.255859375,
    1996.6817626953125,
    3881.808837890625,
    6615.33740234375,
    57394.8828125,
    21172.083984375,
    884.162353515625,
    2611.43310546875,
    4282.20947265625,
    2070.434814453125,
    2134.434814453125,
    1992.7169189453125,
    5968.91845703125,
    2569.96142578125,
    2518.93994140625,
    4232.44482421875,
    2650.33203125,
    1994.7884521484375,
    5968.837890625,
    2494.795654296875,
    2860.43408203125,
    4754.02783203125,
    4234.6357421875,
    5441.75634765625,
    7684.86572265625,
    5131.19873046875,
    2961.96923828125,
    2009.179931640625,
    36054.7734375,
    17894.490234375,
    30365.708984375,
    21503.5859375,
    9725.0517578125,
    2049.268798828125,
    2677.701171875,
    2140.52197265625,
    12253.970703125,
    2776.15185546875,
    10020.498046875,
    23096.60546875,
    4309.68408203125,
    9197.0322265625,
    9164.5732421875,
    8407.0712890625,
    9654.5498046875,
    7321.28857421875,
    12113.9970703125,
    17887.599609375,
    20072.36328125,
    2737.5029296875,
    3688.791748046875,
    4318.57275390625,
    7610.4375,
    1781.0760498046875,
    2148.385498046875,
    2297.77880859375,
    1889.697509765625,
    1888.254150390625,
    1875.467041015625,
    2131.537353515625,
    2411.391845703125,
    2401.3779296875,
    66303.25,
    8355.4580078125,
    3276.427001953125,
    38645.0625,
    16845.07421875,
    16807.5078125,
    18953.583984375,
    28541.5859375,
    9658.4072265625,
    2707.14990234375,
    6214.64892578125,
    11563.6494140625,
    13104.3583984375,
    9180.560546875,
    13328.384765625,
    3980.961181640625,
    7158.572265625,
    5628.6484375,
    6781.97216796875,
    2573.727783203125,
    28632.68359375,
    17566.240234375,
    48323.48046875,
    44733.04296875,
    25031.623046875,
    12806.2431640625,
    2931.421875,
    12484.583984375,
    4967.1025390625,
    5807.00244140625,
    5566.5244140625,
    20855.66796875,
    2010.090576171875,
    6753.494140625,
    6410.2578125,
    2137.095458984375,
    3738.1005859375,
    8564.4248046875,
    6355.77001953125,
    7333.09619140625,
    57389.3125,
    23361.78125,
    1606.899658203125,
    3376.912353515625,
    4282.20947265625,
    2073.1025390625,
    3239.446044921875,
    3963.83837890625,
    5684.28125,
    4684.6533203125,
    5589.513671875,
    6328.326171875,
    8850.462890625,
    2953.84765625,
    2441.182861328125,
    4830.76220703125,
    4135.42138671875,
    6450.43115234375,
    2199.571044921875,
    5159.48974609375,
    2130.729248046875,
    1853.75537109375,
    6020.4365234375,
    5522.84375,
    9206.1845703125,
    7984.46240234375,
    2238.3359375,
    2231.1162109375,
    2139.68017578125,
    7809.12939453125,
    52141.64453125,
    4684.2216796875,
    4574.0908203125,
    4426.51904296875,
    3995.23095703125,
    2109.624755859375,
    4041.666748046875,
    7087.5791015625,
    4540.30810546875,
    18989.4453125,
    4595.697265625,
    4464.43408203125,
    17361.07421875,
    4590.73486328125,
    16854.828125,
    4250.744140625,
    7174.66455078125,
    4083.459228515625,
    20270.09765625,
    4006.54736328125,
    8726.1611328125,
    7927.0927734375,
    8799.5673828125,
    4785.95947265625,
    2361.309326171875,
    2306.84619140625,
    2023.1300048828125,
    2048.594970703125,
    2178.577392578125,
    2238.7841796875,
    2323.107666015625,
    2043.3970947265625,
    15594.07421875,
    2559.4951171875,
    2538.0439453125,
    2457.67431640625,
    2049.361083984375,
    3434.9697265625,
    2212.587890625,
    2047.0655517578125,
    76.70850372314453,
    2054.400146484375,
    1784.36962890625,
    2082.2763671875,
    2073.080322265625,
    2046.1455078125,
    4545.76611328125,
    4557.81396484375,
    8260.927734375,
    4485.76904296875,
    12125.4697265625,
    9867.9970703125,
    3882.99169921875,
    3229.47412109375,
    2459.661376953125,
    2452.896484375,
    2668.81591796875,
    4993.10693359375,
    9237.8427734375,
    4581.99609375,
    4600.1376953125,
    15271.95703125,
    14579.62109375,
    4527.29736328125,
    9383.59375,
    4785.775390625,
    4518.4560546875,
    4534.45166015625,
    4468.08349609375,
    4468.5439453125,
    4451.5029296875,
    4124.88525390625,
    8600.955078125,
    8893.9443359375,
    4687.91162109375,
    7799.40380859375,
    2037.384033203125,
    4573.3994140625,
    2037.610107421875,
    2048.761474609375,
    4462.537109375,
    4457.80859375,
    2228.971435546875,
    2217.1328125,
    2118.18798828125,
    2200.061767578125,
    2200.061767578125,
    26172.669921875,
    2042.7763671875,
    2075.603515625,
    2347.471923828125,
    2309.805908203125,
    2155.396240234375,
    2309.80517578125,
    4158.00927734375,
    5312.1259765625,
    4448.326171875,
    2199.06494140625,
    4448.01025390625,
    4523.83056640625,
    4444.92236328125,
    4565.96826171875,
    2123.851318359375,
    2117.7177734375,
    2040.6358642578125,
    2073.662109375,
    2088.2314453125,
    2543.194091796875,
    4329.06982421875,
    4255.54345703125,
    4256.0205078125,
    61.115638732910156,
    11298.650390625,
    350.34759521484375,
    5176.9287109375,
    1957.896240234375,
    1957.896240234375,
    20835.47265625,
    3900.7685546875,
    16806.99609375,
    4260.8466796875,
    1967.0701904296875,
    4861.31103515625,
    2304.746337890625,
    4880.51123046875,
    2044.677001953125,
    2047.1456298828125,
    4775.42626953125,
    4296.24609375,
    4774.18701171875,
    4529.1123046875,
    2196.582763671875,
    2203.80908203125,
    4446.79345703125,
    4808.3876953125,
    11527.373046875,
    11299.98046875,
    10591.205078125,
    13054.1845703125,
    2018.375732421875,
    5875.82470703125,
    16612.640625,
    6418.498046875,
    15789.84375,
    7872.2099609375,
    11697.4912109375,
    1894.7098388671875,
    4758.83447265625,
    10388.580078125,
    8568.8310546875,
    13080.369140625,
    12522.85546875,
    7038.3544921875,
    4530.09521484375,
    11640.1240234375,
    25704.98046875,
    25457.021484375,
    60199.03125,
    22291.259765625,
    7661.33349609375,
    323260.5,
    13641.2666015625,
    78989.7734375,
    19355.00390625,
    5747.791015625,
    10169.896484375,
    7094.06591796875,
    11056.87109375,
    11049.470703125,
    9128.1201171875,
    7280.89306640625,
    88196.9921875,
    5515.90185546875,
    6959.771484375,
    2950.747802734375,
    9103.79296875,
    11500.1005859375,
    13325.1982421875,
    9631.443359375,
    4533.15185546875,
    4676.880859375,
    12558.8896484375,
    14140.919921875,
    2131.46923828125,
    4535.6337890625,
    7210.13525390625,
    4438.9853515625,
    2308.596923828125,
    34816.1796875,
    7610.0849609375,
    6845.587890625,
    17269.763671875,
    2778.1630859375,
    2629.92822265625,
    2535.296630859375,
    11249.3701171875,
    5440.10205078125,
    4095.9794921875,
    4194.5283203125,
    9080.927734375,
    4569.56103515625,
    4300.5732421875,
    6800.158203125,
    6579.58251953125,
    13558.9521484375,
    2976.47265625,
    11464.8125,
    8934.6201171875,
    153807.390625,
    7676.2138671875,
    14937.3125,
    10895.033203125,
    9938.994140625,
    10084.072265625,
    10154.6044921875,
    15231.8212890625,
    173854.28125,
    18910.0234375,
    17593.14453125,
    2509.9755859375,
    40370.27734375,
    6415.83154296875,
    2175.52294921875,
    15921.181640625,
    8119.6796875,
    17850.1015625,
    7835.26318359375,
    12400.8984375,
    9993.7470703125,
    188849.515625,
    164395.9375,
    2165.782958984375,
    2166.997802734375,
    6379.47021484375,
    7447.025390625,
    27992.431640625,
    9741.0556640625,
    5317.65283203125,
    2714.430908203125,
    13027.38671875,
    6208.9775390625,
    9544.5439453125,
    29171.373046875,
    19298.83984375,
    143071.125,
    28324.16796875,
    16428.03125,
    104636.3125,
    22569.078125,
    6795.56640625,
    4205.09814453125,
    15553.6376953125,
    5381.96826171875,
    10827.484375,
    49680.34375,
    2019.5740966796875,
    5168.02978515625,
    6942.703125,
    17748.30078125,
    3184.07763671875,
    4832.95263671875,
    3203.146484375,
    3999.544921875,
    7053.93115234375,
    6412.40380859375,
    4302.74365234375,
    12368.4306640625,
    3593.057861328125,
    5547.9560546875,
    32642.85546875,
    2124.896728515625,
    30521.40625,
    2489.31884765625,
    49662.484375,
    9698.2216796875,
    5476.115234375,
    8204.71875,
    1922.1119384765625,
    12731.541015625,
    4721.79541015625,
    4013.239501953125,
    8237.513671875,
    2422.5361328125,
    4449.23583984375,
    18094.6171875,
    3771.591796875,
    15598.154296875,
    2241.077880859375,
    7207.13916015625,
    5498.74267578125,
    15302.927734375,
    26064.25,
    50065.58984375,
    45382.56640625,
    44932.33203125,
    7758.474609375,
    2403.744873046875,
    10167.337890625,
    10910.6455078125,
    4474.57177734375,
    2141.666748046875,
    2563.064453125,
    5465.771484375,
    2996.55810546875,
    2619.443603515625,
    5294.91943359375,
    3100.934326171875,
    4619.4189453125,
    2163.787109375,
    2160.746337890625,
    12879.369140625,
    415388.1875,
    15224.880859375,
    4819.4501953125,
    6165.55810546875,
    4550.984375,
    4929.578125,
    11801.5751953125,
    11038.9296875,
    2250.3056640625,
    2183.80712890625,
    2180.773681640625,
    2684.629150390625,
    4820.26513671875,
    5339.564453125,
    4823.76220703125,
    46687.265625,
    5340.765625,
    2704.698486328125,
    5388.63427734375,
    25274.990234375,
    6591.6435546875,
    12379.619140625,
    4303.74755859375,
    30453.849609375,
    5913.7998046875,
    2992.654052734375,
    9340.3544921875,
    3727.52392578125,
    26658.0,
    3166.998291015625,
    3216.9033203125,
    13836.294921875,
    5366.8740234375,
    46625.2578125,
    6974.81787109375,
    10885.2265625,
    10062.146484375,
    12538.9052734375,
    9062.8486328125,
    8179.4697265625,
    5962.93310546875,
    5250.00830078125,
    2754.99755859375,
    2843.9560546875,
    5947.61474609375,
    3171.298583984375,
    5973.92822265625,
    5758.6376953125,
    5755.39111328125,
    19867.0234375,
    7438.6552734375,
    7354.4921875,
    5004.193359375,
    21205.244140625,
    28286.1171875,
    6203.693359375,
    14006.4638671875,
    8781.578125,
    5492.35595703125,
    5858.21630859375,
    4004.275146484375,
    14821.9033203125,
    9963.9912109375,
    11304.564453125,
    6195.48046875,
    455.5842590332031,
    4685.390625,
    9267.939453125,
    7846.576171875,
    9496.716796875,
    11150.830078125,
    46714.42578125,
    6839.1865234375,
    79750.109375,
    5160.92138671875,
    2112.314208984375,
    7789.90673828125,
    97278.3359375,
    24292.5625,
    20284.177734375,
    123044.1953125,
    2540.117919921875,
    2798.1640625,
    4709.154296875,
    2783.37255859375,
    2835.48681640625,
    8946.013671875,
    7612.865234375,
    3940.38330078125,
    722.1195068359375,
    14121.771484375,
    2130.4873046875,
    2118.27197265625,
    3155.932861328125,
    3155.568115234375,
    3147.22314453125,
    6303.4638671875,
    6319.20703125,
    11874.56640625,
    2817.959228515625,
    5822.19970703125,
    5148.984375,
    7257.12060546875,
    9588.775390625,
    15550.8779296875,
    2732.363525390625,
    3553.291015625,
    7346.76416015625,
    2622.08837890625,
    2235.771240234375,
    1778.505615234375,
    2658.119140625,
    3823.549072265625,
    5908.65380859375,
    2543.8134765625,
    2539.60009765625,
    7072.88916015625,
    7050.83251953125,
    6919.30419921875,
    6486.39013671875,
    5100.3291015625,
    5844.19091796875,
    5829.07470703125,
    5237.47802734375,
    5230.2734375,
    5306.03662109375,
    18808.396484375,
    8836.033203125,
    18450.82421875,
    14247.3115234375,
    20525.884765625,
    3844.7021484375,
    5891.236328125,
    2564.84619140625,
    2538.421875,
    7070.80615234375,
    7038.9736328125,
    6929.9599609375,
    6481.82861328125,
    5109.9482421875,
    5783.84814453125,
    5778.146484375,
    5296.498046875,
    5271.07421875,
    2488.17578125,
    6871.29296875,
    10317.1162109375,
    5039.677734375,
    8838.013671875,
    16130.98828125,
    7486.4775390625,
    7571.0380859375,
    2645.748046875,
    7571.2001953125,
    7464.189453125,
    2464.8779296875,
    2886.50048828125,
    3213.1015625,
    2509.235107421875,
    2279.8193359375,
    3106.431884765625,
    3918.934814453125,
    5686.13525390625,
    6908.93505859375,
    2556.291259765625,
    2416.109130859375,
    2612.099609375,
    5585.6103515625,
    6129.0625,
    7234.40869140625,
    12453.865234375,
    468.2486877441406,
    3749.186279296875,
    2655.04736328125,
    14960.8193359375,
    2937.00146484375,
    9340.0634765625,
    7294.88916015625,
    33206.5625,
    11996.884765625,
    8077.66259765625,
    49726.4296875,
    49626.671875,
    5447.01171875,
    2508.91796875,
    3675.4931640625,
    16280.267578125,
    7177.32763671875,
    9181.83203125,
    16226.0107421875,
    2708.914794921875,
    2466.21240234375,
    2555.614013671875,
    2472.30517578125,
    4625.76318359375,
    15172.947265625,
    2160.764892578125,
    4196.560546875,
    4768.53173828125,
    13854.037109375,
    5805.001953125,
    26942.177734375,
    8203.984375,
    11072.1953125,
    9865.6435546875,
    2238.1201171875,
    2233.616943359375,
    4193.21484375,
    13812.7265625,
    14196.25,
    4706.10595703125,
    6173.55224609375,
    17121.01171875,
    33774.4609375,
    5394.9931640625,
    3421.649658203125,
    5901.560546875,
    2592.287353515625,
    4815.30908203125,
    5091.02490234375,
    2520.6015625,
    10190.2998046875,
    8101.73388671875,
    19308.453125,
    8497.6298828125,
    7990.94091796875,
    12389.94921875,
    2143.310546875,
    3213.459228515625,
    4252.03564453125,
    13034.888671875,
    26214.619140625,
    5476.1923828125,
    8671.6142578125,
    8035.11767578125,
    7289.85400390625,
    2614.604736328125,
    2218.78662109375,
    2218.78662109375,
    5965.10302734375,
    2211.9228515625,
    2355.2431640625,
    2350.80419921875,
    5216.7548828125,
    5209.2529296875,
    5208.81640625,
    5603.763671875,
    7433.0166015625,
    6251.19482421875,
    7246.3662109375,
    5200.10693359375,
    6946.275390625,
    5200.10693359375,
    7066.1865234375,
    6430.75537109375,
    9281.4208984375,
    2530.189208984375,
    4931.33056640625,
    17248.546875,
    11647.12109375,
    11289.509765625,
    12094.76953125,
    4853.22705078125,
    2492.201416015625,
    8067.27197265625,
    7671.609375,
    20151.646484375,
    26682.158203125,
    9316.2666015625,
    4768.33544921875,
    7396.5615234375,
    2039.4095458984375,
    6889.17578125,
    4852.57177734375,
    7343.607421875,
    5189.0625,
    4642.0107421875,
    8844.9140625,
    18155.203125,
    16450.86328125,
    5789.90185546875,
    8680.1865234375,
    8224.6669921875,
    19661.326171875,
    6860.31591796875,
    4926.61767578125,
    12949.4755859375,
    9781.88671875,
    7460.12158203125,
    4766.6484375,
    4772.2685546875,
    2083.212890625,
    2082.18359375,
    2793.56201171875,
    2793.04833984375,
    8361.32421875,
    13239.3154296875,
    3073.539306640625,
    2498.131591796875,
    5449.3740234375,
    24883.15625,
    14469.400390625,
    2607.10009765625,
    2087.647216796875,
    1926.1966552734375,
    2074.541748046875,
    12816.26171875,
    8521.1943359375,
    13398.9462890625,
    2089.695556640625,
    2120.20263671875,
    4594.99169921875,
    12194.80859375,
    21748.134765625,
    1996.873291015625,
    4424.69775390625,
    1968.8250732421875,
    4443.9599609375,
    12341.4052734375,
    21660.51953125,
    8529.720703125,
    9928.5068359375,
    2193.51513671875,
    2947.212890625,
    2240.993408203125,
    155.08143615722656,
    5337.7607421875,
    5934.35302734375,
    7810.45703125,
    4899.40478515625,
    225.79074096679688,
    27293.880859375,
    16139.5146484375,
    10683.294921875,
    7926.01806640625,
    2629.311279296875,
    7257.02685546875,
    10240.4130859375,
    10605.9873046875,
    10105.07421875,
    8600.93359375,
    1881.61376953125,
    2422.808837890625,
    2420.615966796875,
    10719.4560546875,
    3826.900634765625,
    11181.109375,
    7601.38671875,
    11361.75,
    5025.23828125,
    2217.8212890625,
    1916.4281005859375,
    5197.66357421875,
    5194.58935546875,
    1913.6768798828125,
    5458.32861328125,
    2382.1044921875,
    19389.7421875,
    6591.94140625,
    8412.0439453125,
    1969.8028564453125,
    6415.71142578125,
    12973.505859375,
    9558.865234375,
    8126.4560546875,
    7938.5244140625,
    2580.040283203125,
    5887.97265625,
    6052.59423828125,
    13582.369140625,
    5235.9072265625,
    2896.25390625,
    8052.70166015625,
    11195.248046875,
    16297.6904296875,
    2371.086669921875,
    3300.87890625,
    4255.71826171875,
    4255.71826171875,
    14927.0341796875,
    6354.23193359375,
    81.07782745361328,
    4599.9931640625,
    7136.318359375,
    11073.5849609375,
    2308.686279296875,
    6226.71435546875,
    6222.85546875,
    2434.2744140625,
    12166.3603515625,
    18395.796875,
    10588.232421875,
    10628.34375,
    28755.34765625,
    9730.1240234375,
    5046.2275390625,
    6304.4931640625,
    11785.5703125,
    7650.8037109375,
    6984.4833984375,
    5503.8828125,
    17586.0078125,
    2571.496826171875,
    13926.4501953125,
    13287.462890625,
    2168.72119140625,
    7529.03759765625,
    5805.4609375,
    2156.689453125,
    2591.340576171875,
    2606.424560546875,
    2601.804931640625,
    2583.913330078125,
    2541.0986328125,
    2181.8623046875,
    2763.51123046875,
    2613.3046875,
    10045.0029296875,
    1760.99658203125,
    6974.818359375,
    10885.2265625,
    10062.146484375,
    12538.9072265625,
    9062.8486328125,
    8179.4697265625,
    5962.931640625,
    5250.00830078125,
    2754.99755859375,
    2843.956298828125,
    5947.6142578125,
    3171.298583984375,
    5973.92822265625,
    5758.63720703125,
    5755.39111328125,
    19867.0234375,
    7438.6552734375,
    7354.4921875,
    5004.193359375,
    21205.244140625,
    28018.3671875,
    6203.6904296875,
    14006.4638671875,
    8781.578125,
    5492.35595703125,
    5799.15771484375,
    3933.931396484375,
    14766.525390625,
    9903.4775390625,
    11245.486328125,
    6134.9736328125,
    453.6676940917969,
    4685.19091796875,
    9266.0234375,
    7787.8818359375,
    9499.7578125,
    11424.9462890625,
    46989.4140625,
    6839.1865234375,
    33629.1015625,
    79731.28125,
    3417.73193359375,
    2112.314453125,
    7789.90673828125,
    90788.3046875,
    23641.83203125,
    16885.537109375,
    120609.359375,
    2447.88037109375,
    7571.45263671875,
    15563.8525390625,
    2899.999267578125,
    2239.692138671875,
    2359.541015625,
    2622.334716796875,
    4084.232177734375,
    4121.19384765625,
    3952.385498046875,
    3919.604248046875,
    4333.515625,
    5235.08984375,
    2177.844970703125,
    2177.844970703125,
    2153.2822265625,
    2153.2822265625,
    3704.524169921875,
    5911.1953125,
    3735.2509765625,
    15555.0107421875,
    2558.49169921875,
    2507.58544921875,
    4467.25244140625,
    5215.12109375,
    4926.63037109375,
    9584.63671875,
    2277.512451171875,
    2570.443359375,
    2583.1142578125,
    4704.4873046875,
    3936.126953125,
    4409.130859375,
    14718.5654296875,
    2933.581787109375,
    3508.501708984375,
    3508.501708984375,
    16324.2353515625,
    16848.44921875,
    4370.27490234375,
    4764.408203125,
    11591.4248046875,
    18852.421875,
    7642.14599609375,
    1913.279296875,
    7427.50634765625,
    6304.9140625,
    2221.9697265625,
    2208.00048828125,
    8060.3701171875,
    5740.16357421875,
    5012.73681640625,
    6375.96826171875,
    5027.25732421875,
    4375.65673828125,
    12046.236328125,
    4621.9892578125,
    11039.0009765625,
    11611.9375,
    12637.482421875,
    3890.6416015625,
    4689.521484375,
    3475.575439453125,
    3475.575439453125,
    6912.96630859375,
    3951.27587890625,
    4348.26513671875,
    4735.0107421875,
    11548.4365234375,
    4755.3349609375,
    5027.21484375,
    2213.3125,
    6271.90966796875,
    2178.21142578125,
    2178.21142578125,
    5328.6953125,
    5720.16064453125,
    5095.77685546875,
    6346.271484375,
    4997.5322265625,
    4562.9755859375,
    2001.143798828125,
    4353.64794921875,
    2026.8836669921875,
    2207.921875,
    19166.1171875,
    19467.69140625,
    10902.6396484375,
    6838.193359375,
    5074.70703125,
    3702.516845703125,
    19738.890625,
    16885.765625,
    13043.3828125,
    4531.67431640625,
    4468.61865234375,
    11427.5537109375,
    23413.751953125,
    8119.49853515625,
    7279.94140625,
    7873.81689453125,
    6589.2724609375,
    2162.513427734375,
    2157.670654296875,
    7712.17578125,
    5908.30908203125,
    5360.62158203125,
    13110.1845703125,
    6730.2412109375,
    7786.83056640625,
    7458.330078125,
    56109.60546875,
    4865.32958984375,
    26824.775390625,
    5174.7236328125,
    6242.54248046875,
    4376.37939453125,
    5435.3642578125,
    5560.98095703125,
    5553.0693359375,
    5231.02685546875,
    2129.580322265625,
    2129.580322265625,
    2353.732666015625,
    2187.029296875,
    2187.029296875,
    1927.59033203125,
    2204.605712890625,
    2190.233642578125,
    2182.535888671875,
    5894.06884765625,
    5779.24951171875,
    2183.23291015625,
    2187.06396484375,
    2303.981201171875,
    2166.47607421875,
    2166.47607421875,
    1905.5693359375,
    2182.58203125,
    2165.9892578125,
    2165.779052734375,
    5874.0537109375,
    5728.89111328125,
    2165.9892578125,
    2166.47607421875,
    2484.1396484375,
    4547.62060546875,
    2192.29736328125,
    2534.5048828125,
    2567.98681640625,
    350.82354736328125,
    8394.65234375,
    6403.228515625,
    9429.0830078125,
    2206.820068359375,
    4691.525390625,
    4911.60009765625,
    4371.4482421875,
    11303.5400390625,
    3463.780517578125,
    11287.3154296875,
    3333.06884765625,
    6725.9833984375,
    15600.408203125,
    15629.52734375,
    63707.95703125,
    3454.371337890625,
    5974.18603515625,
    14236.7685546875,
    9379.111328125,
    3625.543212890625,
    4464.15380859375,
    4214.56396484375,
    3277.643798828125,
    11873.4658203125,
    3499.356689453125,
    7161.03662109375,
    15788.064453125,
    3133.4775390625,
    6980.81494140625,
    13499.837890625,
    10373.4169921875,
    5395.18408203125,
    15036.572265625,
    3454.17919921875,
    4723.5419921875,
    10793.2216796875,
    8798.9443359375,
    10838.8427734375,
    18148.35546875,
    18542.00390625,
    7563.0693359375,
    4425.55126953125,
    6664.01220703125,
    7973.01318359375,
    12052.51953125,
    3816.13134765625,
    3365.117919921875,
    9046.5341796875,
    9193.4970703125,
    14049.4921875,
    5249.04931640625,
    17619.46875,
    9631.3037109375,
    3860.18798828125,
    5970.1708984375,
    7503.89697265625,
    29217.470703125,
    19672.015625,
    12246.3759765625,
    12015.4990234375,
    17371.4765625,
    21965.791015625,
    24825.423828125,
    8762.8017578125,
    12805.0830078125,
    7989.98486328125,
    11061.6552734375,
    8098.318359375,
    10343.24609375,
    2702.607177734375,
    2676.060791015625,
    2669.3828125,
    25501.349609375,
    9387.5615234375,
    3523.31591796875,
    12758.5517578125,
    3584.278076171875,
    3944.248779296875,
    9618.1005859375,
    4633.78857421875,
    6420.09033203125,
    6423.65576171875,
    36653.5625,
    23380.466796875,
    17294.291015625,
    2772.501220703125,
    10588.8828125,
    12316.6650390625,
    7852.0419921875,
    12855.7392578125,
    13550.505859375,
    15384.0810546875,
    5621.8525390625,
    10703.82421875,
    7996.6240234375,
    18268.412109375,
    16117.265625,
    6881.63720703125,
    16760.744140625,
    5105.7470703125,
    9997.7353515625,
    19357.287109375,
    15828.826171875,
    7760.57568359375,
    11152.986328125,
    3840.77587890625,
    5609.88818359375,
    4157.13671875,
    7457.7392578125,
    29123.447265625,
    13389.4775390625,
    10936.7353515625,
    8090.30615234375,
    11486.5556640625,
    6304.33056640625,
    8435.220703125,
    12248.1171875,
    4492.5517578125,
    6778.5078125,
    10263.3935546875,
    20947.890625,
    8121.63232421875,
    18845.115234375,
    26423.853515625,
    5084.06982421875,
    8101.0166015625,
    8103.2763671875,
    6998.75244140625,
    6991.5947265625,
    9814.7978515625,
    9808.42578125,
    23669.126953125,
    5746.1826171875,
    4754.41552734375,
    27208.2890625,
    11011.5654296875,
    11114.7548828125,
    15830.9150390625,
    14278.9150390625,
    10097.1552734375,
    13590.365234375,
    9988.6171875,
    21153.197265625,
    6282.412109375,
    12034.4365234375,
    20599.5546875,
    11364.572265625,
    11630.1416015625,
    13238.318359375,
    49972.5546875,
    10327.1376953125,
    21012.314453125,
    8870.044921875,
    7979.06005859375,
    10971.3671875,
    3374.798583984375,
    3530.219970703125,
    3051.24365234375,
    3399.93994140625,
    2914.799560546875,
    3246.611328125,
    13571.2275390625,
    13357.5537109375,
    6067.50048828125,
    6364.52587890625,
    6921.896484375,
    16527.7890625,
    42499.92578125,
    4502.65087890625,
    8491.056640625,
    26554.2265625,
    6347.1962890625,
    14137.46484375,
    35592.6796875,
    30843.73046875,
    6594.95751953125,
    8847.2490234375,
    25589.65625,
    6562.8173828125,
    10987.14453125,
    10620.3115234375,
    11134.0693359375,
    13569.10546875,
    7547.41796875,
    6795.65771484375,
    6769.8115234375,
    11505.3671875,
    11808.890625,
    3751.16845703125,
    2788.566162109375,
    40732.8828125,
    52799.71875,
    10231.0068359375,
    19542.884765625,
    3766.2841796875,
    26720.662109375,
    10176.6953125,
    17800.8984375,
    24209.978515625,
    12421.66796875,
    44408.9609375,
    11743.6201171875,
    6938.22705078125,
    6515.86181640625,
    13060.578125,
    36438.85546875,
    8706.5361328125,
    26064.908203125,
    14202.5595703125,
    4260.9892578125,
    4265.1357421875,
    4583.4892578125,
    4583.4892578125,
    19429.146484375,
    3511.17724609375,
    7725.29248046875,
    14799.96875,
    14669.3818359375,
    14793.4814453125,
    5862.927734375,
    49570.9765625,
    32256.677734375,
    41612.484375,
    61685.7421875,
    21057.4765625,
    17898.3125,
    2069.072021484375,
    2042.434326171875,
    2124.064697265625,
    2122.568115234375,
    3912.034912109375,
    4726.8818359375,
    5634.177734375,
    3337.791015625,
    2674.481689453125,
    13284.228515625,
    611.4879760742188,
    2333.735107421875,
    19909.025390625,
    10258.5009765625,
    12600.9267578125,
    20472.490234375,
    23831.4921875,
    34034.84375,
    8456.1005859375,
    7786.32177734375,
    7185.83154296875,
    66109.5625,
    5427.72705078125,
    5665.96484375,
    2299.26708984375,
    5084.150390625,
    4627.2275390625,
    2088.786376953125,
    1966.5299072265625,
    2055.9853515625,
    5338.50390625,
    2093.067626953125,
    2866.171630859375,
    7468.43212890625,
    12213.326171875,
    5359.70654296875,
    4671.517578125,
    8192.8046875,
    9950.9384765625,
    30904.123046875,
    93437.453125,
    115999.75,
    2037.7198486328125,
    3851.077880859375,
    31795.603515625,
    2083.425048828125,
    5687.68505859375,
    10033.953125,
    20534.283203125,
    17103.98828125,
    18972.294921875,
    22998.490234375,
    38511.15625,
    12565.6689453125,
    28043.955078125,
    24814.98046875,
    18971.150390625,
    14199.25390625,
    47982.4375,
    28476.125,
    16733.51171875,
    17385.603515625,
    16254.08203125,
    16185.7412109375,
    66346.7578125,
    11365.8955078125,
    29735.275390625,
    18984.30078125,
    6199.5205078125,
    2954.00048828125,
    13044.71484375,
    4615.86083984375,
    9927.7890625,
    13738.8095703125,
    107792.9453125,
    89094.734375,
    28209.15625,
    3284.934814453125,
    3099.243408203125,
    2932.91650390625,
    3162.9453125,
    3185.620849609375,
    7276.41357421875,
    7164.54248046875,
    4621.5458984375,
    2939.61767578125,
    2848.01806640625,
    7339.150390625,
    7235.48388671875,
    14112.0166015625,
    6424.0400390625,
    10178.373046875,
    5869.46630859375,
    9398.66796875,
    3486.0537109375,
    11115.1923828125,
    2173.666015625,
    2127.0087890625,
    3404.24365234375,
    28692.0234375,
    13174.1279296875,
    5248.46728515625,
    33103.87890625,
    15931.2646484375,
    3880.146484375,
    4931.19287109375,
    5634.79541015625,
    2417.887939453125,
    4662.49609375,
    5183.37548828125,
    2601.37841796875,
    2589.44091796875,
    2442.138427734375,
    2442.138427734375,
    500.8150634765625,
    2677.390625,
    380.7838134765625,
    380.7838134765625,
    2504.13720703125,
    2506.53759765625,
    3400.9814453125,
    3429.5595703125,
    4084.19921875,
    5102.7841796875,
    7102.90087890625,
    392.69427490234375,
    3078.0126953125,
    480.46612548828125,
    2940.859130859375,
    6929.85693359375,
    8799.5234375,
    9047.3095703125,
    5945.67236328125,
    5945.67236328125,
    5945.67236328125,
    5945.67236328125,
    5945.67236328125,
    4706.31494140625,
    6601.63916015625,
    9116.4013671875,
    8714.7890625,
    5006.2666015625,
    2054.47021484375,
    2323.672607421875,
    6235.2958984375,
    2730.377197265625,
    8818.732421875,
    10612.11328125,
    18161.591796875,
    10338.5263671875,
    10343.2021484375,
    8860.875,
    9276.8896484375,
    17859.357421875,
    18251.787109375,
    10231.806640625,
    10094.8583984375,
    46670.1640625,
    150.0019073486328,
    2326.491943359375,
    4243.0908203125,
    4239.97265625,
    4155.22265625,
    4152.10498046875,
    5140.56787109375,
    5140.56787109375,
    5356.2919921875,
    2546.162353515625,
    2442.138427734375,
    2928.505126953125,
    3537.584228515625,
    3566.16796875,
    6529.123046875,
    5392.9091796875,
    13890.537109375,
    9635.337890625,
    46998.99609375,
    46998.99609375,
    6172.6513671875,
    5818.7021484375,
    10904.787109375,
    8270.048828125,
    8298.6005859375,
    2178.68212890625,
    2192.388916015625,
    3297.544677734375,
    2051.251220703125,
    2051.251220703125,
    2051.251220703125,
    2051.251220703125,
    9053.7861328125,
    6650.64794921875,
    6650.64794921875,
    9444.9697265625,
    12431.8671875,
    14786.4306640625,
    19359.130859375,
    7489.408203125,
    5176.494140625,
    2231.720458984375,
    2066.482421875,
    2733.6943359375,
    5595.9091796875,
    17318.37890625,
    3515.677001953125,
    4271.41455078125,
    4937.7255859375,
    4955.1484375,
    2472.634033203125,
    8438.2998046875,
    1792.05419921875,
    4136.34130859375,
    4571.3837890625,
    6014.69775390625,
    1974.952392578125,
    2220.41455078125,
    21291.970703125,
    4445.3115234375,
    9741.1728515625,
    4445.990234375,
    5211.19091796875,
    2252.4326171875,
    8653.8486328125,
    9413.3662109375,
    1871.7137451171875,
    1878.2373046875,
    35.65625,
    32.85194396972656,
    12411.9609375,
    12412.556640625,
    20695.671875,
    2018.9578857421875,
    4911.642578125,
    17587.693359375,
    11768.40234375,
    12186.537109375,
    6414.95654296875,
    2035.776123046875,
    5234.572265625,
    2408.58251953125,
    4799.71337890625,
    4799.71337890625,
    2454.544189453125,
    2454.544189453125,
    2454.544189453125,
    2454.544189453125,
    10798.9111328125,
    18685.892578125,
    4146.634765625,
    2059.20166015625,
    1923.979736328125,
    1928.05908203125,
    10751.880859375,
    4703.36181640625,
    1977.8228759765625,
    718.0747680664062,
    701.3253173828125,
    696.8253173828125,
    5617.14208984375,
    2106.8759765625,
    1963.8702392578125,
    2121.497802734375,
    1875.643310546875,
    2465.29638671875,
    4581.65966796875,
    17166.94921875,
    11547.8544921875,
    2555.10986328125,
    2055.732421875,
    2051.120849609375,
    2041.6373291015625,
    2046.1412353515625,
    2261.091796875,
    2095.567138671875,
    7645.6220703125,
    7659.888671875,
    13727.0625,
    5082.484375,
    10973.021484375,
    5642.20751953125,
    8236.3154296875,
    28800.837890625,
    19821.8671875,
    18901.296875,
    28028.0859375,
    339779.34375,
    11878.125,
    157810.09375,
    2084.286865234375,
    4587.9951171875,
    8639.0390625,
    2928.1298828125,
    14993.751953125,
    129723.0,
    8762.931640625,
    3050.310302734375,
    12887.2578125,
    66858.859375,
    3854.002197265625,
    8073.931640625,
    15559.7841796875,
    17895.734375,
    13807.6923828125,
    1969.83349609375,
    1974.747314453125,
    10320.4326171875,
    7023.744140625,
    21489.107421875,
    1950.98779296875,
    9878.427734375,
    5079.8193359375,
    2300.32666015625,
    9014.4619140625,
    16557.57421875,
    11429.0419921875,
    104475.203125,
    77196.6640625,
    19941.244140625,
    1874.40185546875,
    80846.484375,
    7807.01123046875,
    28198.68359375,
    21125.283203125,
    4898.22607421875,
    3648.3310546875,
    2390.6435546875,
    16112.884765625,
    3588.737060546875,
    8152.12255859375,
    10135.265625,
    8564.8046875,
    5786.0556640625,
    8581.64453125,
    6448.79638671875,
    11033.85546875,
    6756.59521484375,
    2353.44580078125,
    11338.3125,
    11326.2216796875,
    8693.6572265625,
    2566.327392578125,
    9307.12109375,
    4183.50830078125,
    2212.36962890625,
    19440.48046875,
    6025.17138671875,
    3207.527587890625,
    11259.10546875,
    14801.4931640625,
    11268.46875,
    15362.6630859375,
    4881.93212890625,
    4780.17138671875,
    6171.697265625,
    3599.789794921875,
    9383.2373046875,
    13604.2392578125,
    2467.275390625,
    13715.392578125,
    8956.1181640625,
    2205.683349609375,
    10164.6953125,
    7808.552734375,
    19030.59765625,
    17138.5546875,
    6111.44775390625,
    4239.69580078125,
    8141.23486328125,
    6526.9287109375,
    6657.0205078125,
    6192.4189453125,
    13822.8427734375,
    8004.17919921875,
    46890.65625,
    36236.3671875,
    17353.76953125,
    16415.265625,
    5954.97412109375,
    4884.02587890625,
    44234.5390625,
    18151.6328125,
    7531.99462890625,
    15544.9482421875,
    3457.65771484375,
    10883.11328125,
    15802.353515625,
    6605.1181640625,
    6618.634765625,
    2256.38720703125,
    8409.5146484375,
    6633.31640625,
    6612.09228515625,
    12913.275390625,
    10728.669921875,
    24387.349609375,
    2200.24658203125,
    2117.32763671875,
    15948.0830078125,
    39089.640625,
    8292.6630859375,
    6997.93359375,
    68988.25,
    3724.25244140625,
    3894.5859375,
    17177.173828125,
    1811.2813720703125,
    1872.2420654296875,
    10280.1494140625,
    6959.76806640625,
    19784.546875,
    1822.735107421875,
    11157.935546875,
    4830.37060546875,
    2046.811279296875,
    43102.91015625,
    10096.4921875,
    30962.34765625,
    1873.187255859375,
    15799.224609375,
    16035.4423828125,
    4612.681640625,
    38909.46875,
    50015.13671875,
    4679.56298828125,
    2412.361083984375,
    11162.40625,
    7025.9755859375,
    4205.61376953125,
    4115.89453125,
    62273.0546875,
    31117.6875,
    2124.013916015625,
    2149.271728515625,
    38636.28515625,
    4807.32763671875,
    8173.5166015625,
    4139.79931640625,
    4427.5126953125,
    26437.9140625,
    17563.03125,
    19491.875,
    4763.02099609375,
    4527.513671875,
    5209.26904296875,
    2117.38818359375,
    2118.766845703125,
    12045.4130859375,
    9826.3857421875,
    82570.1484375,
    17761.818359375,
    7099.23291015625,
    4150.61669921875,
    7333.77880859375,
    13951.4765625,
    3617.939208984375,
    3598.758544921875,
    5872.732421875,
    2644.72412109375,
    11071.0205078125,
    28509.259765625,
    18231.96484375,
    2191.342041015625,
    25429.482421875,
    20400.64453125,
    20586.12109375,
    4516.58056640625,
    4505.25048828125,
    6336.12451171875,
    4713.17431640625,
    5578.8369140625,
    5572.9619140625,
    10737.5166015625,
    4548.435546875,
    8432.044921875,
    16725.15625,
    4152.28271484375,
    81925.078125,
    11625.705078125,
    16155.2890625,
    16077.9853515625,
    20639.353515625,
    16878.0390625,
    11102.0595703125,
    108101.7890625,
    13560.732421875,
    12141.3642578125,
    4494.24560546875,
    35386.71484375,
    3461.08251953125,
    3454.5400390625,
    9554.8896484375,
    9579.06640625,
    39994.578125,
    3678.39404296875,
    17519.296875,
    1975.9368896484375,
    8962.9130859375,
    2395.306640625,
    2358.8662109375,
    34615.96875,
    2339.25244140625,
    21612.388671875,
    10758.5087890625,
    17595.884765625,
    4630.6708984375,
    9913.642578125,
    26042.603515625,
    8323.4326171875,
    8330.3662109375,
    6539.2294921875,
    50074.23046875,
    5967.3447265625,
    7731.04736328125,
    15293.736328125,
    4645.21728515625,
    1350.3916015625,
    4521.7490234375,
    4523.0810546875,
    2940.82568359375,
    2195.1826171875,
    6552.24609375,
    5633.50830078125,
    4609.55126953125,
    2197.704833984375,
    1986.5479736328125,
    24285.326171875,
    25480.296875,
    7683.46044921875,
    7328.43994140625,
    6530.17626953125,
    2316.65673828125,
    2138.880859375,
    4517.82763671875,
    4763.470703125,
    1891.598876953125,
    119784.34375,
    19660.0859375,
    13830.857421875,
    21574.35546875,
    22903.158203125,
    21759.62890625,
    21027.923828125,
    4970.47607421875,
    65980.015625,
    27132.83984375,
    5025.06201171875,
    29713.6640625,
    2492.218505859375,
    11622.388671875,
    8551.49609375,
    4525.0830078125,
    4328.07275390625,
    4762.4453125,
    21510.06640625,
    2500.255859375,
    2135.607666015625,
    2135.400390625,
    24480.689453125,
    41816.8046875,
    15807.8349609375,
    82528.8359375,
    89110.375,
    17852.26953125,
    9887.0224609375,
    1926.509033203125,
    161709.765625,
    4454.1142578125,
    6841.17236328125,
    74320.7109375,
    2257.28857421875,
    13957.859375,
    24213.248046875,
    16196.5263671875,
    12423.3564453125,
    2170.832275390625,
    2029.9422607421875,
    11122.6845703125,
    9384.869140625,
    4397.42529296875,
    2390.172607421875,
    24250.021484375,
    10795.0029296875,
    18973.451171875,
    17993.345703125,
    4658.78662109375,
    7153.7177734375,
    53732.03125,
    3774.491943359375,
    3856.329345703125,
    3370.020263671875,
    3639.793212890625,
    3434.723388671875,
    3611.95458984375,
    17679.10546875,
    3645.7412109375,
    2236.4287109375,
    1873.9034423828125,
    1886.873046875,
    3723.8759765625,
    63982.40625,
    6525.08203125,
    6520.43310546875,
    36942.5078125,
    10786.3193359375,
    9456.1494140625,
    23805.99609375,
    23804.125,
    9288.51953125,
    9286.783203125,
    2372.63330078125,
    2365.779541015625,
    12861.552734375,
    12856.138671875,
    11070.9345703125,
    4848.6611328125,
    6396.0576171875,
    6372.67919921875,
    1839.4581298828125,
    2143.946044921875,
    16412.994140625,
    19097.982421875,
    5639.84521484375,
    4568.7685546875,
    20369.119140625,
    4862.22509765625,
    15120.9462890625,
    7597.70849609375,
    4577.390625,
    2792.21728515625,
    4426.29931640625,
    44332.19921875,
    5478.74169921875,
    58740.765625,
    5470.9140625,
    20403.806640625,
    20481.537109375,
    10186.3486328125,
    13910.783203125,
    6505.92578125,
    6501.27734375,
    11551.392578125,
    10270.958984375,
    31822.8984375,
    9584.83203125,
    4674.984375,
    4848.6611328125,
    9657.4267578125,
    14879.3720703125,
    14956.5029296875,
    9288.51953125,
    9286.783203125,
    9506.6171875,
    6205.984375,
    9841.205078125,
    6212.201171875,
    21070.9921875,
    26528.931640625,
    35500.703125,
    9615.1474609375,
    5960.412109375,
    2048.56494140625,
    9832.4658203125,
    5947.57958984375,
    8786.828125,
    6372.67919921875,
    4273.8603515625,
    7237.99755859375,
    11769.47265625,
    10501.2158203125,
    4568.7685546875,
    7210.55810546875,
    4942.55419921875,
    10501.8720703125,
    7597.70849609375,
    4577.390625,
    4527.97607421875,
    7286.04638671875,
    4698.22412109375,
    14765.9892578125,
    2184.853515625,
    13738.626953125,
    7527.9990234375,
    7935.97021484375,
    7059.25830078125,
    2196.855712890625,
    9638.9375,
    13763.369140625,
    2792.21728515625,
    6138.6220703125,
    20069.7578125,
    26565.685546875,
    38814.55859375,
    37871.7109375,
    29420.013671875,
    23313.806640625,
    4388.81103515625,
    4490.22265625,
    5289.12060546875,
    15970.6455078125,
    14571.3212890625,
    24202.447265625,
    5589.87646484375,
    27679.080078125,
    10184.8759765625,
    13993.41015625,
    22972.37890625,
    16477.20703125,
    1982.4212646484375,
    1826.813232421875,
    1842.77978515625,
    39676.1953125,
    1844.1195068359375,
    3208.403564453125,
    33467.28125,
    2294.649169921875,
    16260.4765625,
    1910.083984375,
    13904.3828125,
    6576.70166015625,
    32.85194396972656,
    32.85194396972656,
    36.9156494140625,
    41.7379264831543,
    2409.892333984375,
    6251.58984375,
    14929.0224609375,
    14830.853515625,
    8660.9609375,
    8187.01513671875,
    2869.566650390625,
    3238.285888671875,
    5842.01416015625,
    5881.4384765625,
    5692.38232421875,
    340.0339660644531,
    914.0531616210938,
    625.5608520507812,
    4673.74365234375,
    322.71173095703125,
    18121.576171875,
    53165.6796875,
    3396.914306640625,
    7915.68115234375,
    2444.308349609375,
    2399.5986328125,
    1903.288330078125,
    4851.208984375,
    12758.0751953125,
    9900.5263671875,
    1855.2734375,
    1989.477294921875,
    23159.2421875,
    4754.4970703125,
    8817.966796875,
    8785.455078125,
    3044.154052734375,
    11222.8095703125,
    10411.0283203125,
    27847.892578125,
    1910.2401123046875,
    3644.911376953125,
    2246.381591796875,
    2144.80908203125,
    1946.2435302734375,
    1939.8699951171875,
    7965.958984375,
    11414.3818359375,
    1873.64404296875,
    1940.8736572265625,
    1995.4976806640625,
    1992.33740234375,
    3736.016357421875,
    1904.4388427734375,
    3738.973388671875,
    1900.4227294921875,
    7362.8466796875,
    16367.3564453125,
    15272.7568359375,
    36201.3046875,
    16366.021484375,
    136315.1875,
    15672.5947265625,
    10493.3056640625,
    10660.3759765625,
    85631.3046875,
    4644.1650390625,
    2268.191162109375,
    4042.462158203125,
    4258.57763671875,
    4305.9033203125,
    5633.2939453125,
    13991.0068359375,
    10855.9033203125,
    10465.439453125,
    11656.9130859375,
    503.57269287109375,
    2953.76318359375,
    2953.53515625,
    1334.6612548828125,
    3415.50927734375,
    4473.318359375,
    4289.130859375,
    4311.2060546875,
    27302.748046875,
    13384.3955078125,
    9209.8330078125,
    9629.935546875,
    8797.1484375,
    9220.791015625,
    9207.3818359375,
    9612.26171875,
    8797.1484375,
    9203.11328125,
    4417.18896484375,
    25910.43359375,
    6957.140625,
    8792.125,
    9220.791015625,
    8800.033203125,
    9203.11328125,
    5496.326171875,
    2541.931396484375,
    2194.025146484375,
    1874.0419921875,
    8930.126953125,
    8941.9736328125,
    4385.197265625,
    4384.6796875,
    13916.85546875,
    20074.353515625,
    20088.349609375,
    21847.462890625,
    61687.49609375,
    49200.5,
    165894.359375,
    24995.2578125,
    14474.884765625,
    9185.7275390625,
    9214.26953125,
    166952.796875,
    30155.490234375,
    30184.017578125,
    13635.65234375,
    26395.740234375,
    13420.638671875,
    27661.154296875,
    26057.49609375,
    29371.923828125,
    34558.9296875,
    55881.05859375,
    22110.669921875,
    62890.3046875,
    6249.5791015625,
    26843.033203125,
    30307.94921875,
    664.6996459960938,
    22369.755859375,
    9455.306640625,
    2588.0478515625,
    22420.279296875,
    12045.88671875,
    22829.90625,
    22825.083984375,
    6857.80517578125,
    5635.9267578125,
    5630.8583984375,
    690.9337768554688,
    703.7029418945312,
    695.7763671875,
    5655.10791015625,
    5669.37646484375,
    1826.1334228515625,
    3699.946533203125,
    3700.05078125,
    3685.777587890625,
    3685.673583984375,
    3699.97607421875,
    3700.21044921875,
    3685.855712890625,
    3685.630615234375,
    4540.86083984375,
    4532.99755859375,
    3695.56298828125,
    7468.40087890625,
    6123.44384765625,
    5442.57275390625,
    5478.48193359375,
    8759.8330078125,
    4704.0234375,
    5249.6650390625,
    4860.830078125,
    4860.830078125,
    4860.830078125,
    4871.5986328125,
    7466.83837890625,
    7564.17626953125,
    7552.109375,
    7476.57763671875,
    7344.72509765625,
    4268.3154296875,
    2232.119873046875,
    1889.967529296875,
    4839.34814453125,
    7323.5986328125,
    7624.61181640625,
    7538.7607421875,
    4289.416015625,
    9809.0751953125,
    4573.41796875,
    9046.4873046875,
    10245.09765625,
    2280.093505859375,
    3050.362060546875,
    2069.347900390625,
    7623.2392578125,
    6343.03564453125,
    2044.034423828125,
    2193.66650390625,
    2869.1982421875,
    5838.7119140625,
    6678.6318359375,
    136.88194274902344,
    5088.20654296875,
    1873.3184814453125,
    4909.46044921875,
    8487.04296875,
    8110.45703125,
    5307.81298828125,
    2100.649658203125,
    4514.15478515625,
    2095.229248046875,
    2265.437255859375,
    2508.545166015625,
    4559.34765625,
    4268.42822265625,
    7052.66552734375,
    6796.66943359375,
    8758.486328125,
    1830.899658203125,
    9355.67578125,
    5531.3046875,
    2012.941650390625,
    2003.799560546875,
    1979.796630859375,
    2417.30078125,
    4500.69482421875,
    3247.390380859375,
    2497.642333984375,
    2825.467529296875,
    9794.2666015625,
    69573.0234375,
    2298.148681640625,
    22142.857421875,
    1932.3939208984375,
    1898.8326416015625,
    1974.5670166015625,
    6831.02734375,
    2039.457275390625,
    2212.045654296875,
    10540.21875,
    6722.3544921875,
    126.81002807617188,
    125.95647430419922,
    489.8902282714844,
    2608.07177734375,
    2045.88916015625,
    126.81002807617188,
    84.04043579101562,
    125.95647430419922,
    43.84703063964844,
    489.8902282714844,
    2145.64208984375,
    2108.5361328125,
    2476.321044921875,
    2440.071533203125,
    2099.4345703125,
    4510.896484375,
    2171.3466796875,
    2136.093017578125,
    1848.98779296875,
    3772.02734375,
    4853.13134765625,
    4659.9599609375,
    5430.86474609375,
    2120.997802734375,
    6650.69189453125,
    2105.654296875,
    2121.171630859375,
    2122.703369140625,
    3641.8173828125,
    1968.967041015625,
    9342.8955078125,
    8352.814453125,
    13196.5087890625,
    11122.27734375,
    11730.158203125,
    11566.984375,
    1894.537841796875,
    1917.4595947265625,
    10027.689453125,
    1845.7777099609375,
    2200.625732421875,
    5852.9296875,
    2967.92578125,
    8083.4658203125,
    2322.921630859375,
    2329.615478515625,
    1874.5472412109375,
    4356.25390625,
    6951.546875,
    7553.11572265625,
    7739.56591796875,
    7510.04833984375,
    2190.861083984375,
    2109.553466796875,
    2525.932861328125,
    2440.64453125,
    765.010498046875,
    2526.17236328125,
    1875.9710693359375,
    2503.25634765625,
    7965.58203125,
    2044.4818115234375,
    2218.1630859375,
    5179.45361328125,
    4531.9462890625,
    2043.7364501953125,
    2013.5792236328125,
    2063.057861328125,
    2042.4481201171875,
    1947.7716064453125,
    1888.9031982421875,
    1881.6483154296875,
    1895.8184814453125,
    4540.0888671875,
    5078.42919921875,
    10183.4521484375,
    5074.76708984375,
    10183.9501953125,
    2258.43359375,
    2371.961669921875,
    3070.388671875,
    3040.4833984375,
    2537.97998046875,
    2533.616943359375,
    2556.54150390625,
    6250.44189453125,
    2669.909423828125,
    2979.314697265625,
    4027.616943359375,
    3353.098388671875,
    2929.641357421875,
    4038.184814453125,
    11785.8662109375,
    7600.39599609375,
    6379.53564453125,
    6366.90673828125,
    13695.466796875,
    10957.19921875,
    10915.59765625,
    10915.748046875,
    4406.74853515625,
    4392.4755859375,
    8284.390625,
    8270.1279296875,
    6077.52392578125,
    4711.21923828125,
    4609.7939453125,
    5090.03662109375,
    5063.64990234375,
    2845.330078125,
    2838.400390625,
    6590.73388671875,
    6589.0615234375,
    5896.9140625,
    5890.20068359375,
    15063.62109375,
    14765.4140625,
    5129.21484375,
    4813.95947265625,
    4558.974609375,
    4557.4736328125,
    4482.53271484375,
    4313.1884765625,
    4297.53955078125,
    4403.0859375,
    4184.62255859375,
    4205.7841796875,
    4209.55859375,
    4205.7841796875,
    1910.1639404296875,
    1899.11376953125,
    1848.9814453125,
    1829.7294921875,
    2064.91943359375,
    2070.686767578125,
    2045.8306884765625,
    2059.294921875,
    2056.136474609375,
    2066.788818359375,
    2053.47802734375,
    2053.47802734375,
    2057.64111328125,
    1767.704345703125,
    2053.522216796875,
    1773.4698486328125,
    2051.679931640625,
    2048.095458984375,
    4384.78369140625,
    4373.52099609375,
    4378.34912109375,
    4375.16357421875,
    4375.0380859375,
    4371.20263671875,
    4374.98193359375,
    4371.20263671875,
    4411.76220703125,
    4401.146484375,
    4405.01171875,
    4399.51513671875,
    4395.55419921875,
    4395.55419921875,
    4395.55419921875,
    4395.55419921875,
    13533.126953125,
    4419.3896484375,
    8630.04296875,
    4994.552734375,
    5532.08544921875,
    7233.029296875,
    14629.3330078125,
    16298.39453125,
    14879.4921875,
    10327.2255859375,
    4821.12353515625,
    5553.99267578125,
    5060.9287109375,
    5575.93115234375,
    4827.044921875,
    5503.91552734375,
    5007.3037109375,
    5515.96435546875,
    5725.07421875,
    4957.42236328125,
    4579.40771484375,
    4557.88427734375,
    9462.390625,
    8991.6005859375,
    4909.7373046875,
    3248.135009765625,
    3283.0771484375,
    3368.194580078125,
    4583.568359375,
    4587.2529296875,
    4589.44580078125,
    4588.84033203125,
    6317.251953125,
    3364.95458984375,
    7047.2314453125,
    4208.52197265625,
    4203.69775390625,
    4608.7236328125,
    4592.9697265625,
    1863.4241943359375,
    2040.6016845703125,
    2199.588623046875,
    14615.7587890625,
    5038.53271484375,
    4999.25830078125,
    4263.216796875,
    4258.302734375,
    10897.9736328125,
    5938.47119140625,
    5045.0263671875,
    5897.51318359375,
    1804.122802734375,
    1802.027587890625,
    2146.913818359375,
    2070.408447265625,
    1852.2398681640625,
    2161.88916015625,
    1790.8272705078125,
    1792.87451171875,
    1784.477783203125,
    1792.87451171875,
    1818.8887939453125,
    1788.6748046875,
    2173.098388671875,
    2186.988525390625,
    2175.9443359375,
    2210.36279296875,
    2042.0179443359375,
    4613.69677734375,
    4272.85986328125,
    4341.0771484375,
    4586.59326171875,
    4311.82080078125,
    4243.591796875,
    4727.2236328125,
    4816.48486328125,
    4653.9228515625,
    4653.27587890625,
    4634.5244140625,
    4630.9638671875,
    4303.5810546875,
    4296.78076171875,
    4285.8779296875,
    4287.2353515625,
    4602.63232421875,
    4604.36767578125,
    4603.26953125,
    4608.619140625,
    4515.88427734375,
    4419.85107421875,
    4440.3076171875,
    4417.6533203125,
    4254.23193359375,
    16933.79296875,
    6306.98583984375,
    6313.5849609375,
    11377.5986328125,
    22578.24609375,
    13067.2265625,
    11984.669921875,
    5942.01953125,
    4045.952392578125,
    5208.34521484375,
    4651.79638671875,
    4645.0419921875,
    4664.60693359375,
    4648.01708984375,
    4651.79638671875,
    4649.76611328125,
    4664.60693359375,
    4648.01708984375,
    4636.03955078125,
    4629.70654296875,
    4648.84814453125,
    4638.3671875,
    4636.03955078125,
    4629.70654296875,
    4648.84814453125,
    4638.3671875,
    4957.52197265625,
    4938.0087890625,
    4987.95703125,
    4963.001953125,
    4963.59814453125,
    4938.0087890625,
    4989.10986328125,
    4963.001953125,
    4365.98291015625,
    4393.90966796875,
    4679.22607421875,
    4428.44677734375,
    11338.33203125,
    1919.199462890625,
    1943.433837890625,
    1912.494873046875,
    4270.58837890625,
    4292.23974609375,
    3318.42333984375,
    4318.81201171875,
    4042.48779296875,
    5049.7158203125,
    7300.5732421875,
    13250.923828125,
    5957.9248046875,
    11478.7724609375,
    4116.98974609375,
    10277.599609375,
    4382.8974609375,
    9480.318359375,
    5303.61669921875,
    7274.10888671875,
    25379.56640625,
    16852.615234375,
    16853.5390625,
    5861.84814453125,
    19348.384765625,
    5858.5693359375,
    17042.5,
    9520.1015625,
    5656.65625,
    17979.421875,
    5558.3076171875,
    6270.23388671875,
    4408.80322265625,
    4388.486328125,
    4409.57470703125,
    4388.486328125,
    4311.4091796875,
    4559.25390625,
    4233.1376953125,
    2412.63916015625,
    1915.1734619140625,
    2845.650634765625,
    2827.38134765625,
    10083.5068359375,
    10048.89453125,
    4308.576171875,
    4300.65625,
    6378.56103515625,
    6385.32666015625,
    3055.710205078125,
    3055.710205078125,
    3936.26318359375,
    3964.83740234375,
    7926.31884765625,
    2895.85400390625,
    2707.6806640625,
    2703.608642578125,
    8552.4423828125,
    6875.90185546875,
    12443.2734375,
    6483.42578125,
    12457.53515625,
    6497.6875,
    9623.0283203125,
    9651.7392578125,
    9107.0830078125,
    9110.7626953125,
    5772.6904296875,
    5801.2783203125,
    6668.15771484375,
    6668.15771484375,
    11647.130859375,
    5138.90185546875,
    5750.5771484375,
    5753.95166015625,
    4696.98291015625,
    4724.3935546875,
    5768.10302734375,
    3141.111083984375,
    12958.6220703125,
    2061.9375,
    2217.006591796875,
    2463.114013671875,
    1814.9366455078125,
    5874.68896484375,
    2013.607177734375,
    7201.3134765625,
    7368.5302734375,
    17334.439453125,
    9730.7685546875,
    27309.48046875,
    9888.50390625,
    16928.5625,
    11908.11328125,
    11522.1953125,
    11534.466796875,
    5019.22265625,
    6765.94287109375,
    5019.31591796875,
    6765.57861328125,
    4591.80029296875,
    4591.80029296875,
    5599.8916015625,
    5599.8916015625,
    4881.4091796875,
    4881.4091796875,
    7197.00146484375,
    7193.5029296875,
    4877.1650390625,
    4877.1650390625,
    1801.4075927734375,
    1766.212646484375,
    9941.314453125,
    7500.21435546875,
    7030.7890625,
    5368.6845703125,
    16716.466796875,
    7239.56298828125,
    5110.18603515625,
    5125.3837890625,
    2367.685791015625,
    4824.32958984375,
    1935.7626953125,
    2134.00048828125,
    4152.943359375,
    4130.08642578125,
    2001.410400390625,
    2028.853515625,
    3617.498779296875,
    5058.13818359375,
    1876.4246826171875,
    4661.3583984375,
    4658.3466796875,
    2538.414306640625,
    1997.8824462890625,
    1963.14453125,
    2120.125,
    12901.8154296875,
    15883.4423828125,
    4208.72607421875,
    7323.10888671875,
    7715.98583984375,
    2273.482666015625,
    2613.111572265625,
    9961.0947265625,
    1912.6341552734375,
    5029.8603515625,
    4902.671875,
    2407.534423828125,
    2852.814208984375,
    2839.08935546875,
    12138.7646484375,
    2089.916015625,
    2276.61669921875,
    2223.675537109375,
    2294.359375,
    2370.236572265625,
    9801.755859375,
    16864.7734375,
    8121.16162109375,
    9677.609375,
    46343.12890625,
    11360.849609375,
    33561.48046875,
    3933.1552734375,
    3933.1552734375,
    3938.454833984375,
    3936.4921875,
    3936.4921875,
    4073.753662109375,
    4000.8603515625,
    4318.73046875,
    4354.669921875,
    4354.669921875,
    3959.86181640625,
    3956.13916015625,
    3956.205078125,
    3950.905517578125,
    4309.017578125,
    4301.23681640625,
    4301.23681640625,
    4301.23681640625,
    4284.0,
    5623.8720703125,
    4670.16259765625,
    4660.78076171875,
    4370.3232421875,
    12403.09375,
    7648.2978515625,
    156158.9375,
    9925.8876953125,
    9265.2080078125,
    9239.9375,
    13526.3486328125,
    13239.1533203125,
    9260.998046875,
    9235.7275390625,
    13526.3486328125,
    13239.1533203125,
    1891.9791259765625,
    1855.077880859375,
    1801.4295654296875,
    1855.077880859375,
    5680.5068359375,
    5319.8388671875,
    6611.89599609375,
    6582.03125,
    2943.992919921875,
    2917.587158203125,
    5676.2001953125,
    5685.27001953125,
    5607.8095703125,
    5611.45947265625,
    4698.5439453125,
    4698.5439453125,
    5676.2001953125,
    5685.27001953125,
    5607.8095703125,
    5611.45947265625,
    4700.9208984375,
    4698.5439453125,
    4318.7685546875,
    4314.80322265625,
    4314.94775390625,
    4313.33056640625,
    4979.63037109375,
    4982.36474609375,
    4975.76025390625,
    4980.9404296875,
    4263.330078125,
    4257.001953125,
    4263.330078125,
    4257.001953125,
    4969.2294921875,
    4969.2294921875,
    4969.2294921875,
    4969.2294921875,
    5283.2978515625,
    7400.63671875,
    4672.1201171875,
    2765.61865234375,
    2081.417236328125,
    1992.8870849609375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    6410.771484375,
    6362.63330078125,
    21660.1640625,
    7334.56787109375,
    9824.3642578125,
    8080.5419921875,
    10070.9287109375,
    9532.125,
    30640.302734375,
    58848.109375,
    7641.68212890625,
    2626.518310546875,
    3773.364013671875,
    3744.9111328125,
    3755.124267578125,
    3756.5390625,
    3745.2236328125,
    3751.95068359375,
    12367.3681640625,
    4188.3232421875,
    1978.766845703125,
    1790.9000244140625,
    1767.4581298828125,
    1795.1019287109375,
    1766.2384033203125,
    1774.8753662109375,
    10700.7587890625,
    6071.04833984375,
    4798.02783203125,
    4769.2255859375,
    1940.8983154296875,
    6803.54638671875,
    2156.74267578125,
    4341.87744140625,
    2486.38427734375,
    2260.96484375,
    1871.76708984375,
    2058.58154296875,
    2043.5755615234375,
    2840.6376953125,
    2045.4873046875,
    2037.8065185546875,
    2046.0965576171875,
    2840.54443359375,
    2042.8746337890625,
    2038.6541748046875,
    2038.9234619140625,
    2038.6541748046875,
    2040.9644775390625,
    2037.31982421875,
    2048.57568359375,
    2048.57568359375,
    1799.8865966796875,
    1799.8865966796875,
    2047.3343505859375,
    2047.3343505859375,
    2038.6541748046875,
    2038.6541748046875,
    2043.0694580078125,
    2043.0694580078125,
    2038.6541748046875,
    2038.6541748046875,
    4469.3466796875,
    4459.80029296875,
    4455.99072265625,
    4803.1044921875,
    4458.20556640625,
    4455.60302734375,
    4451.6962890625,
    4451.6962890625,
    3933.1552734375,
    3933.1552734375,
    3933.1552734375,
    1768.65185546875,
    2251.08544921875,
    2240.14306640625,
    2236.978759765625,
    6319.55126953125,
    6323.2646484375,
    5513.0400390625,
    5498.6806640625,
    5527.3125,
    5512.9541015625,
    5887.25146484375,
    5887.25146484375,
    5883.9921875,
    5883.9921875,
    2475.204833984375,
    2471.79443359375,
    2453.403076171875,
    2453.403076171875,
    10873.43359375,
    39994.75,
    5535.34716796875,
    5535.19775390625,
    2049.864501953125,
    4129.09521484375,
    7327.48046875,
    10348.3525390625,
    5290.0458984375,
    5462.0576171875,
    15048.892578125,
    8543.388671875,
    6396.79931640625,
    6077.54248046875,
    12860.9541015625,
    2366.6005859375,
    12362.6328125,
    20759.20703125,
    7901.62109375,
    9862.427734375,
    12290.8427734375,
    13066.9150390625,
    2067.99755859375,
    24996.12109375,
    2489.32763671875,
    2464.8681640625,
    2234.054443359375,
    1885.114501953125,
    6930.82080078125,
    1921.9610595703125,
    15600.876953125,
    2104.78857421875,
    2168.808837890625,
    2190.27392578125,
    2048.10498046875,
    2105.201416015625,
    6918.62890625,
    6933.052734375,
    7076.349609375,
    2881.2431640625,
    1802.170166015625,
    5540.80419921875,
    2462.695068359375,
    4206.763671875,
    385.0382080078125,
    3366.4267578125,
    2403.221923828125,
    11902.1640625,
    3464.9736328125,
    3308.37158203125,
    4770.0244140625,
    2509.023193359375,
    2752.297607421875,
    5906.90234375,
    2163.409912109375,
    2312.760009765625,
    4962.75,
    2955.711669921875,
    7423.76611328125,
    2852.026123046875,
    4666.18408203125,
    9835.1787109375,
    11879.962890625,
    7149.5068359375,
    7176.9384765625,
    7148.8017578125,
    7165.62890625,
    2353.739990234375,
    4210.5615234375,
    2342.33251953125,
    2335.703857421875,
    8448.1171875,
    8490.16015625,
    6295.388671875,
    4287.01806640625,
    1966.872802734375,
    4161.0205078125,
    8027.54150390625,
    4923.0302734375,
    2857.273681640625,
    2462.318359375,
    2411.377685546875,
    2416.666015625,
    3171.020751953125,
    8906.673828125,
    2053.72216796875,
    2557.135009765625,
    5885.57958984375,
    4474.35888671875,
    4674.12890625,
    2165.8408203125,
    1935.981201171875,
    10656.087890625,
    10283.375,
    3392.032470703125,
    3218.3974609375,
    14960.462890625,
    15556.4599609375,
    15687.0234375,
    3670.853759765625,
    39240.6953125,
    51951.7578125,
    18655.3828125,
    4799.876953125,
    4854.650390625,
    11865.048828125,
    6435.41162109375,
    5645.28076171875,
    3457.3173828125,
    9284.328125,
    11628.09375,
    9630.0126953125,
    2807.516845703125,
    7303.123046875,
    14095.244140625,
    5063.15966796875,
    5231.4130859375,
    4830.39404296875,
    5132.11865234375,
    4882.93701171875,
    55048.46875,
    5991.384765625,
    13587.6875,
    26656.041015625,
    2146.256591796875,
    2152.725830078125,
    2204.311279296875,
    2152.494873046875,
    2177.39599609375,
    2155.8544921875,
    2151.313720703125,
    2492.926513671875,
    2137.85693359375,
    2867.54833984375,
    2856.684814453125,
    2518.4677734375,
    2590.3779296875,
    5924.79931640625,
    5262.046875,
    22563.05078125,
    1953.5213623046875,
    2224.64404296875,
    6023.4375,
    2182.891357421875,
    57187.95703125,
    52878.05859375,
    10340.7265625,
    61767.73046875,
    8256.51171875,
    4957.4580078125,
    5081.1259765625,
    5058.00830078125,
    4957.4580078125,
    5081.1259765625,
    5058.00830078125,
    4404.1591796875,
    7672.689453125,
    14483.001953125,
    14761.2705078125,
    2028.098876953125,
    8029.61181640625,
    17162.873046875,
    17254.283203125,
    7370.2412109375,
    7493.89306640625,
    7470.7861328125,
    30474.08984375,
    18489.029296875,
    18428.00390625,
    16408.572265625,
    16985.794921875,
    16964.32421875,
    21809.587890625,
    4488.70654296875,
    4468.49169921875,
    4696.78076171875,
    4536.35791015625,
    4516.07666015625,
    4771.31982421875,
    2438.927001953125,
    2151.914794921875,
    8466.3935546875,
    8465.6484375,
    7370.2412109375,
    7493.89306640625,
    7470.7861328125,
    6651.50830078125,
    7679.55419921875,
    7659.4072265625,
    7878.44921875,
    7675.32763671875,
    7655.0458984375,
    8094.064453125,
    35182.84375,
    9727.0146484375,
    37143.0546875,
    9592.5400390625,
    2716.6083984375,
    1915.401611328125,
    1881.83984375,
    2109.553466796875,
    4770.05615234375,
    6714.37255859375,
    1935.1798095703125,
    3066.28759765625,
    10409.361328125,
    6182.4931640625,
    6844.45947265625,
    16818.482421875,
    20164.369140625,
    2511.041015625,
    5579.03857421875,
    2634.247314453125,
    588.4931030273438,
    559.307373046875,
    668.6734619140625,
    14616.6259765625,
    2635.97607421875,
    4528.02734375,
    2813.24609375,
    2797.58642578125,
    11314.857421875,
    4508.5625,
    4706.63037109375,
    13714.9111328125,
    13268.0673828125,
    4705.521484375,
    8735.421875,
    1888.1787109375,
    4587.4560546875,
    559.307373046875,
    668.6734619140625,
    14616.6259765625,
    4428.33984375,
    9782.9033203125,
    3892.75244140625,
    4087.97509765625,
    4496.37109375,
    4206.7841796875,
    8491.39453125,
    2014.5128173828125,
    4778.4345703125,
    4392.94482421875,
    6703.49169921875,
    13852.1103515625,
    32.85194396972656,
    542.0974731445312,
    2362.11376953125,
    2606.013916015625,
    2519.385009765625,
    6702.05517578125,
    9961.75,
    2222.750732421875,
    2209.21484375,
    19285.33203125,
    270.33740234375,
    2321.65283203125,
    2209.21484375,
    2386.723388671875,
    2386.723388671875,
    2737.418701171875,
    249.38099670410156,
    1892.3048095703125,
    2308.388427734375,
    1837.432373046875,
    2058.2822265625,
    1796.6878662109375,
    1810.8636474609375,
    634.9866333007812,
    4588.54248046875,
    11016.3623046875,
    71.10845947265625,
    2326.22900390625,
    77.24192810058594,
    1940.7650146484375,
    1861.3306884765625,
    1843.9739990234375,
    1817.4317626953125,
    1823.8634033203125,
    1805.8929443359375,
    2398.15478515625,
    7134.95751953125,
    7136.23974609375,
    4474.66259765625,
    4333.50048828125,
    2601.3994140625,
    4092.01904296875,
    4101.6806640625,
    2110.822509765625,
    2121.94677734375,
    2003.2574462890625,
    2688.96484375,
    2086.353759765625,
    2048.06005859375,
    2053.457763671875,
    1802.2452392578125,
    4893.5966796875,
    2064.59033203125,
    1827.0849609375,
    1766.985595703125,
    2180.088623046875,
    4062.8037109375,
    1939.064208984375,
    1965.684326171875,
    2074.76318359375,
    4534.50537109375,
    3580.4345703125,
    5347.57080078125,
    3597.33984375,
    4760.45068359375,
    5097.71484375,
    2603.018798828125,
    4824.21533203125,
    4481.869140625,
    7097.12548828125,
    1777.1566162109375,
    4727.85400390625,
    6858.21923828125,
    2551.04931640625,
    4699.5341796875,
    2540.420166015625,
    6905.0810546875,
    4832.083984375,
    2537.288330078125,
    2533.354736328125,
    2528.7431640625,
    2532.6767578125,
    2129.3515625,
    2129.3515625,
    2125.141845703125,
    2125.141845703125,
    2132.91650390625,
    2129.0576171875,
    2132.91650390625,
    2129.0576171875,
    4955.515625,
    4893.10888671875,
    9149.1513671875,
    9117.6533203125,
    2796.92236328125,
    2777.6953125,
    2279.951416015625,
    2269.7666015625,
    2279.951416015625,
    2269.7666015625,
    2286.565185546875,
    2273.2099609375,
    2286.565185546875,
    2273.2099609375,
    9933.82421875,
    1807.73681640625,
    1802.5421142578125,
    2131.564208984375,
    1779.06591796875,
    1773.0579833984375,
    1772.7852783203125,
    1772.7784423828125,
    2003.79638671875,
    2005.2301025390625,
    1786.971923828125,
    1788.4056396484375,
    2198.505126953125,
    1944.314697265625,
    1854.056640625,
    3321.00634765625,
    601.4746704101562,
    4752.1328125,
    61.92863082885742,
    32.85194396972656,
    32.85194396972656,
    4440.43896484375,
    4367.02978515625,
    6876.287109375,
    2766.907470703125,
    2629.24267578125,
    7249.0263671875,
    4390.212890625,
    23175.771484375,
    14357.5595703125,
    9389.234375,
    7475.23583984375,
    31507.001953125,
    15953.09375,
    2173.05126953125,
    5036.17724609375,
    3846.9365234375,
    1845.480712890625,
    5330.4638671875,
    11553.0283203125,
    5568.33447265625,
    4460.68603515625,
    5466.37890625,
    4292.08056640625,
    6889.68212890625,
    6329.76123046875,
    2031.436767578125,
    4593.7587890625,
    13961.2333984375,
    19128.369140625,
    4576.5927734375,
    4330.396484375,
    4321.5244140625,
    9663.69921875,
    6326.6328125,
    4706.86083984375,
    15699.068359375,
    19267.80078125,
    19050.203125,
    15239.0078125,
    3234.379150390625,
    15237.958984375,
    3234.379150390625,
    12528.8505859375,
    2790.787841796875,
    7093.55859375,
    32939.74609375,
    32839.75,
    14999.4990234375,
    2546.348876953125,
    16963.763671875,
    2561.41162109375,
    4147.7958984375,
    6380.69189453125,
    2175.87646484375,
    4969.44921875,
    5045.6796875,
    2538.713134765625,
    1953.838134765625,
    1916.280517578125,
    2397.206298828125,
    2034.79150390625,
    1999.955078125,
    2192.8583984375,
    2252.8701171875,
    1961.6182861328125,
    2435.746826171875,
    4479.89013671875,
    8475.41796875,
    4451.77685546875,
    4861.482421875,
    8857.310546875,
    2428.85205078125,
    11841.6806640625,
    4799.8203125,
    1910.1070556640625,
    5181.64697265625,
    2375.410888671875,
    2375.410888671875,
    2375.410888671875,
    2375.410888671875,
    2356.9677734375,
    2087.70361328125,
    2970.931640625,
    2113.126220703125,
    601.081787109375,
    495.6385498046875,
    42.000125885009766,
    2298.013427734375,
    2314.36376953125,
    2326.7587890625,
    32.85194396972656,
    32.85194396972656,
    32.85194396972656,
    11029.77734375,
    4719.86474609375,
    2389.81982421875,
    2516.614990234375,
    2522.9189453125,
    2516.614990234375,
    2516.614990234375,
    2516.614990234375,
    1822.5548095703125,
    1964.5916748046875,
    1802.418701171875,
    1793.4051513671875,
    2063.6318359375,
    2055.406982421875,
    1921.353515625,
    1917.312744140625,
    1787.7427978515625,
    1787.7427978515625,
    5277.798828125,
    4935.78076171875,
    4830.0703125,
    8155.6572265625,
    7868.69775390625,
    1892.147705078125,
    1776.0625,
    1919.903564453125,
    4717.5498046875,
    2043.271240234375,
    2043.271240234375,
    12598.53125,
    5541.50634765625,
    43577.73046875,
    7052.4150390625,
    16868.677734375,
    1881.2447509765625,
    1872.65625,
    7106.85693359375,
    4642.65869140625,
    4611.2216796875,
    4075.589599609375,
    2121.43017578125,
    4043.1962890625,
    1905.8177490234375,
    5213.32470703125,
    1875.419921875,
    5345.00244140625,
    5265.5595703125,
    5998.92529296875,
    5580.2509765625,
    8986.54296875,
    9186.5693359375,
    2224.236083984375,
    7149.52001953125,
    5936.802734375,
    5969.2548828125,
    5969.51806640625,
    2859.6240234375,
    2562.484130859375,
    6085.73876953125,
    6200.01171875,
    10619.3271484375,
    5705.34228515625,
    6086.56982421875,
    5680.59375,
    6703.49560546875,
    6294.9658203125,
    5799.6943359375,
    5807.95166015625,
    5913.7646484375,
    5921.13671875,
    5875.7578125,
    689.3689575195312,
    566.4559326171875,
    623.5792846679688,
    427.3889465332031,
    2533.472412109375,
    2479.605224609375,
    3107.007568359375,
    2607.28271484375,
    8501.3916015625,
    8360.5537109375,
    5348.35546875,
    5609.0234375,
    4634.33935546875,
    5298.04248046875,
    2382.1787109375,
    4860.70849609375,
    4853.05126953125,
    4429.62841796875,
    6016.10791015625,
    4968.64501953125,
    15718.044921875,
    10956.3076171875,
    10957.4697265625,
    9290.2294921875,
    11573.1787109375,
    15089.6630859375,
    8524.8759765625,
    7602.50537109375,
    12564.9443359375,
    8536.546875,
    2837.601806640625,
    12767.0673828125,
    11897.6103515625,
    6644.65869140625,
    6644.03466796875,
    3795.8740234375,
    3350.99462890625,
    5571.7509765625,
    5373.55126953125,
    11772.2236328125,
    10717.767578125,
    9234.88671875,
    9547.5791015625,
    7461.45654296875,
    7461.45654296875,
    7074.404296875,
    7074.404296875,
    10229.08203125,
    5115.775390625,
    3856.868896484375,
    7221.2490234375,
    7217.96923828125,
    9249.2216796875,
    8794.0107421875,
    6965.66357421875,
    9300.6357421875,
    11718.4599609375,
    6372.70703125,
    6276.31787109375,
    4872.85498046875,
    4363.17138671875,
    4757.42822265625,
    7365.6064453125,
    4706.10693359375,
    7303.01953125,
    7177.583984375,
    4860.35302734375,
    7370.66162109375,
    4810.05029296875,
    7311.49365234375,
    2560.89794921875,
    2552.39794921875,
    2610.39501953125,
    2607.23388671875,
    10213.470703125,
    10227.5830078125,
    538.5989379882812,
    547.2022094726562,
    9802.4345703125,
    9811.8310546875,
    9487.7080078125,
    9493.44140625,
    15795.8525390625,
    15804.439453125,
    2886.520751953125,
    2886.1728515625,
    5652.13623046875,
    6055.56201171875,
    3282.026611328125,
    3282.37158203125,
    7815.27880859375,
    6716.9306640625,
    7238.65625,
    57556.37109375,
    13852.345703125,
    14511.16015625,
    11055.3232421875,
    14703.5234375,
    11370.1357421875,
    11869.478515625,
    11810.4375,
    12753.447265625,
    12657.447265625,
    27999.708984375,
    13371.494140625,
    4338.671875,
    32292.892578125,
    13090.57421875,
    6046.8310546875,
    748.3463745117188,
    2138.2119140625,
    2145.532470703125,
    2137.559814453125,
    2136.72998046875,
    2127.802001953125,
    3065.314453125,
    1934.3900146484375,
    3047.262939453125,
    1910.0882568359375,
    3050.976806640625,
    1911.7899169921875,
    3064.206787109375,
    1914.37841796875,
    672.7042846679688,
    5763.0029296875,
    5758.14990234375,
    5757.6943359375,
    5754.724609375,
    4305.21728515625,
    5491.36474609375,
    27655.619140625,
    14884.8154296875,
    14613.66015625,
    19560.43359375,
    13404.8515625,
    13466.6474609375,
    23261.375,
    2199.478515625,
    6107.41650390625,
    2767.072021484375,
    8711.30859375,
    10458.193359375,
    7562.86962890625,
    5717.99560546875,
    6773.89306640625,
    5672.15576171875,
    5436.43798828125,
    6695.84814453125,
    6137.16259765625,
    5884.9228515625,
    5781.65185546875,
    5782.17919921875,
    6593.5791015625,
    6146.96923828125,
    6770.83837890625,
    10533.494140625,
    5468.091796875,
    5847.8857421875,
    9502.990234375,
    9527.7275390625,
    9739.9423828125,
    5819.58740234375,
    5813.0556640625,
    5806.63134765625,
    5809.642578125,
    5756.0322265625,
    5753.65478515625,
    5754.46435546875,
    5752.9599609375,
    6553.41943359375,
    9995.783203125,
    6955.01904296875,
    10067.404296875,
    6169.6005859375,
    5964.8720703125,
    7020.98046875,
    6116.0400390625,
    5825.822265625,
    7338.76416015625,
    6594.15234375,
    6258.6396484375,
    6103.59033203125,
    6104.38134765625,
    7175.66259765625,
    6579.6181640625,
    7145.6220703125,
    11833.517578125,
    5794.47509765625,
    6187.2490234375,
    10112.4765625,
    10127.65234375,
    10721.62890625,
    6133.60009765625,
    6130.10400390625,
    6124.70703125,
    6129.236328125,
    6065.16015625,
    6058.193359375,
    6059.369140625,
    6057.14013671875,
    9420.66015625,
    5318.26318359375,
    11057.33203125,
    9096.54296875,
    11057.33203125,
    9117.2666015625,
    8659.0234375,
    8891.08203125,
    8834.4306640625,
    8633.4521484375,
    8748.8154296875,
    8749.638671875,
    9191.33203125,
    9180.42578125,
    3727.4677734375,
    8221.275390625,
    6499.6767578125,
    6393.84423828125,
    6461.11767578125,
    6477.1025390625,
    2924.75244140625,
    3497.454345703125,
    3207.0673828125,
    3021.6171875,
    2157.2822265625,
    4890.37890625,
    5277.291015625,
    7116.150390625,
    6709.16552734375,
    7127.6552734375,
    9571.544921875,
    20413.625,
    8472.400390625,
    8704.578125,
    2894.852294921875,
    16279.1962890625,
    8789.4296875,
    9894.640625,
    9842.138671875,
    25203.974609375,
    7194.986328125,
    5251.7158203125,
    5058.98779296875,
    6633.04345703125,
    6999.29736328125,
    5242.45703125,
    4616.92041015625,
    20551.0234375,
    2194.5634765625,
    14300.431640625,
    14230.251953125,
    11933.6025390625,
    13133.443359375,
    9454.685546875,
    13027.5576171875,
    113539.671875,
    24110.537109375,
    18386.541015625,
    14027.8076171875,
    17408.724609375,
    18993.3984375,
    6798.94482421875,
    6589.2451171875,
    11464.6328125,
    19281.326171875,
    4261.35498046875,
    2549.870849609375,
    6220.22998046875,
    6065.9169921875,
    2720.363525390625,
    24946.951171875,
    3819.341064453125,
    5655.76708984375,
    1890.630859375,
    5148.806640625,
    1835.039306640625,
    2497.717529296875,
    5373.24169921875,
    15441.8359375,
    5779.96240234375,
    15334.845703125,
    2248.587158203125,
    2413.471435546875,
    6326.13916015625,
    7349.0859375,
    1951.34326171875,
    7082.9599609375,
    2748.121337890625,
    5796.32275390625,
    8290.154296875,
    8238.474609375,
    8132.64892578125,
    5627.60302734375,
    6040.26025390625,
    8633.97265625,
    8230.46875,
    4318.47802734375,
    9857.80859375,
    5762.5693359375,
    1790.69189453125,
    5996.72802734375,
    5817.31640625,
    5789.15283203125,
    5966.9462890625,
    6144.080078125,
    14905.3818359375,
    14914.7392578125,
    15248.337890625,
    15258.7255859375,
    7028.02099609375,
    2126.840087890625,
    2335.206298828125,
    6193.6298828125,
    6665.93896484375,
    20779.51171875,
    10423.8330078125,
    10376.84765625,
    14961.578125,
    14134.046875,
    8111.35107421875,
    8040.8837890625,
    13004.7724609375,
    12789.525390625,
    5600.59423828125,
    3516.472900390625,
    6708.6630859375,
    4564.396484375,
    4460.5283203125,
    16093.82421875,
    2932.8876953125,
    3306.9814453125,
    11627.3935546875,
    13994.7763671875,
    6123.80908203125,
    8090.45947265625,
    8788.6357421875,
    8806.6103515625,
    3848.551513671875,
    13091.27734375,
    3715.64501953125,
    3946.028564453125,
    3031.24755859375,
    3259.611572265625,
    3114.494873046875,
    3800.69970703125,
    1986.42919921875,
    2834.239501953125,
    2269.659423828125,
    2930.3046875,
    2379.69580078125,
    1980.145751953125,
    8117.69189453125,
    3902.048095703125,
    2093.855224609375,
    12881.4150390625,
    7669.4267578125,
    6256.93017578125,
    6769.806640625,
    6255.95166015625,
    12098.111328125,
    11713.60546875,
    12354.12109375,
    7534.55029296875,
    6928.92529296875,
    5574.37255859375,
    23656.064453125,
    6102.4697265625,
    6516.23779296875,
    6466.466796875,
    16563.890625,
    18094.171875,
    20584.212890625,
    8974.3935546875,
    12550.6279296875,
    15297.1494140625,
    19293.1015625,
    3564.825927734375,
    3562.206787109375,
    3568.5546875,
    3571.2724609375,
    2416.79736328125,
    112.6136703491211,
    302.6748352050781,
    3405.2626953125,
    2072.097412109375,
    2490.09716796875,
    4638.4150390625,
    1815.4342041015625,
    22757.001953125,
    1869.911376953125,
    9186.44921875,
    7820.52734375,
    8976.6669921875,
    12442.900390625,
    6809.3662109375,
    6211.13623046875,
    6028.919921875,
    2235.4853515625,
    5902.1162109375,
    3150.34716796875,
    6764.3154296875,
    7815.45947265625,
    6683.79638671875,
    2053.984619140625,
    126.95211791992188,
    2139.3798828125,
    2139.3798828125,
    2262.720703125,
    2257.484375,
    2243.75048828125,
    4510.72265625,
    9728.896484375,
    4377.40380859375,
    9301.150390625,
    1796.3193359375,
    6544.1884765625,
    2890.774169921875,
    633.251953125,
    12658.962890625,
    8670.1904296875,
    2663.474853515625,
    7943.51025390625,
    2437.8564453125,
    2417.02099609375,
    15801.5703125,
    5916.78857421875,
    17780.13671875,
    8113.4248046875,
    2444.34375,
    5630.00244140625,
    6036.6298828125,
    12393.7373046875,
    8303.0791015625,
    11948.5537109375,
    6667.31591796875,
    7781.27734375,
    2394.394287109375,
    5797.62158203125,
    2384.4794921875,
    10204.6572265625,
    10223.0439453125,
    4451.31884765625,
    3657.677978515625,
    13343.65234375,
    8600.3203125,
    8367.1455078125,
    5433.6318359375,
    5465.818359375,
    4963.0009765625,
    13221.4521484375,
    2292.750244140625,
    2067.48046875,
    2032.708740234375,
    2038.8133544921875,
    4930.41064453125,
    20664.248046875,
    9797.6123046875,
    2501.706787109375,
    5936.7998046875,
    13335.6396484375,
    2401.26513671875,
    6016.130859375,
    2152.774169921875,
    11853.9697265625,
    13850.6044921875,
    2075.15380859375,
    2142.205322265625,
    8008.1318359375,
    4751.57275390625,
    4269.7626953125,
    8962.6904296875,
    8941.4326171875,
    1991.31103515625,
    22261.22265625,
    1860.77392578125,
    28766.126953125,
    33929.66015625,
    13220.48046875,
    24742.578125,
    2179.99072265625,
    2009.8140869140625,
    15088.279296875,
    2630.79931640625,
    2846.935791015625,
    2162.141357421875,
    1921.083984375,
    75004.7421875,
    2593.792236328125,
    77570.53125,
    20306.7265625,
    10743.423828125,
    2599.04931640625,
    6069.40380859375,
    6009.8427734375,
    6001.4169921875,
    40627.1796875,
    4916.53369140625,
    2255.810302734375,
    8046.3759765625,
    41662.6640625,
    4698.7841796875,
    13586.66796875,
    8378.109375,
    23609.32421875,
    1023.8565673828125,
    2112.138427734375,
    2156.072265625,
    2184.196533203125,
    5316.23486328125,
    2430.70458984375,
    17385.505859375,
    16444.8125,
    5082.69921875,
    4990.45703125,
    5964.1015625,
    5962.0810546875,
    6020.1396484375,
    6019.86767578125,
    10093.65625,
    2408.38623046875,
    2340.680908203125,
    2686.241455078125,
    12535.115234375,
    8202.9912109375,
    2405.94091796875,
    5903.71630859375,
    2501.398193359375,
    3664.94140625,
    2308.197998046875,
    6822.0810546875,
    7843.76025390625,
    3863.345703125,
    17289.103515625,
    62.928466796875,
    90.96907043457031,
    215.49673461914062,
    118.69883728027344,
    62.928466796875,
    2851.893798828125,
    2510.125244140625,
    7788.47216796875,
    29605.62890625,
    9711.7177734375,
    115512.796875,
    14074.421875,
    9722.9609375,
    2612.6025390625,
    3662.627685546875,
    4482.70556640625,
    2319.3515625,
    2960.34228515625,
    17261.8984375,
    39704.765625,
    12589.380859375,
    28036.796875,
    25156.751953125,
    4756.30810546875,
    16275.046875,
    7748.6337890625,
    15252.2998046875,
    3478.072998046875,
    3478.072998046875,
    2086.3359375,
    11321.1298828125,
    25229.12890625,
    10530.4541015625,
    14134.228515625,
    24870.8203125,
    12530.2333984375,
    6650.59228515625,
    6645.4931640625,
    5846.3740234375,
    5842.91748046875,
    11187.439453125,
    11177.390625,
    11182.142578125,
    2707.621826171875,
    2693.8056640625,
    5852.248046875,
    5920.283203125,
    5990.87890625,
    12425.9404296875,
    13273.392578125,
    13337.939453125,
    14906.3896484375,
    4774.60888671875,
    16005.3310546875,
    5870.3486328125,
    16110.8408203125,
    5984.32958984375,
    7632.51123046875,
    7436.2412109375,
    7755.54248046875,
    7522.5751953125,
    6608.5537109375,
    6398.67626953125,
    10092.3349609375,
    7776.73046875,
    7719.5859375,
    5779.95947265625,
    5939.8330078125,
    5939.8330078125,
    2803.95751953125,
    80413.203125,
    8682.8193359375,
    6708.4296875,
    6707.7412109375,
    11631.677734375,
    22933.2734375,
    8348.9375,
    17884.361328125,
    5303.0,
    5671.36083984375,
    7254.88037109375,
    7180.47802734375,
    7254.88037109375,
    5854.03271484375,
    6079.57763671875,
    14741.3828125,
    5922.69775390625,
    5870.837890625,
    5922.69775390625,
    5818.55029296875,
    14683.4833984375,
    10712.025390625,
    9398.3837890625,
    7713.92626953125,
    7632.77294921875,
    7713.92626953125,
    5953.99755859375,
    6104.2275390625,
    15197.8125,
    5986.88330078125,
    5936.3154296875,
    5986.88330078125,
    5885.3134765625,
    15094.2607421875,
    11172.33203125,
    9463.841796875,
    7985.15869140625,
    7892.228515625,
    7981.36279296875,
    6048.71337890625,
    6277.61083984375,
    15449.25,
    6043.68798828125,
    5999.4609375,
    6043.68798828125,
    5954.75634765625,
    15303.9052734375,
    20363.662109375,
    9532.5087890625,
    10297.0087890625,
    10580.7548828125,
    16681.306640625,
    66141.3515625,
    12558.2470703125,
    67721.390625,
    12577.103515625,
    4343.49951171875,
    17884.552734375,
    5469.61181640625,
    11053.0732421875,
    10839.4970703125,
    3834.883056640625,
    4856.529296875,
    20174.13671875,
    10751.390625,
    12427.4189453125,
    9518.59375,
    8190.7001953125,
    9878.23828125,
    20425.6328125,
    22091.421875,
    9352.71484375,
    22119.025390625,
    13038.232421875,
    9598.904296875,
    9690.6123046875,
    96666.515625,
    6603.58056640625,
    26524.962890625,
    8131.27099609375,
    39240.01953125,
    8349.3642578125,
    2179.82470703125,
    2391.99365234375,
    194007.65625,
    162905.953125,
    298747.9375,
    114525.1875,
    208214.671875,
    119116.3984375,
    10723.7138671875,
    35757.89453125,
    68841.7734375,
    124293.28125,
    118900.0078125,
    110700.5390625,
    19017.072265625,
    190224.796875,
    74508.3203125,
    66082.203125,
    141638.09375,
    79863.234375,
    8110.54296875,
    41215.0390625,
    36825.12109375,
    457299.0,
    278963.71875,
    1661329.875,
    61170.5703125,
    241698.0625,
    365171.9375,
    561633.25,
    669741.0625,
    625529.3125,
    135541.234375,
    697574.6875,
    171908.65625,
    45595.1953125,
    76226.6640625,
    68986.1015625,
    231593.9375,
    151017.375,
    364587.3125,
    270291.625,
    123722.078125,
    17374.80078125,
    44847.54296875,
    18892.52734375,
    4793.8408203125,
    241234.25,
    19114.44921875,
    37961.77734375,
    43896.93359375,
    17782.9453125,
    6758.8505859375,
    54738.72265625,
    16753.158203125,
    44643.046875,
    33441.390625,
    13995.716796875
  ]
}
