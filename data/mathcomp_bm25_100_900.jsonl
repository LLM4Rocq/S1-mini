{
  "statement": "Lemma absz1 : `|1%R| = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma abszN1 : `|-1%R| = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma absz_id m : `|(`|m|)| = `|m|. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add3n m : 3 + m = m.+3. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add4n m : 4 + m = m.+4. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEprod x : ~` x = (~` x.1, ~` x.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEsubset A : ~` A = ~: A.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derg0 A : A^`(0) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivn0 p : p^`(0) = p.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma diffEprod x y : x `\\` y = (x.1 `\\` y.1, x.2 `\\` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma double0 : 0.*2 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr1z x : x ^ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma exprN1 x : x ^ (-1) = x^-1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fact0 : 0`! = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEprod x y : x `|` y = (x.1 `|` y.1, x.2 `|` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEsubset A B : A `|` B = A :|: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEbool x y : (x < y) = (x < y)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEprodlexi x y :\n  (x < y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 < y.2)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEprod x y : x `&` y = (x.1 `&` y.1, x.2 `&` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEsubset A B : A `&` B = A :&: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natr0E : 0 = 0%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrDE n m : n + m = (n + m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrME n m : n * m = (n * m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrXE n m : n ^+ m = (n ^ m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nonzero1z : 1%Z != 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rat1 : 1%:Q = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma sdvdE (m n : t) : m %<| n = (n != m) && (m %| n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subEbool x y : x `\\` y = x && ~~ y. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subEsubset A B : A `\\` B = A :\\: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmod1gE : 1%g = 0 :> U.            ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodVgE x : x^-1%g = - x.          ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEdual d (T : meetSemilatticeType d) (x y : T) :\n  ((x : T^d) `|^d` y) = (x `&` y).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn1 A : 'L_1(A) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEdual d (T : joinSemilatticeType d) (x y : T) :\n  ((x : T^d) `&^d` y) = (x `|` y).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat0E : nat0 = 0%N :> t. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat1E : nat1 = 1%N :> t. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ractE : raction =1 to. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma supportE x y f : (x \\in support_for y f) = (f x != y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactE : falling_factorial = ffact_rec. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natr1E : 1 = 1%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma geE x y : ge x y = (y <= x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPeq m : ubn_eq_spec m m.      ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn0 A : 'L_0(A) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rat0 : 0%:Q = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add2n m : 2 + m = m.+2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ucn0 A : 'Z_0(A) = 1.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEprod x y : (x <= y) = (x.1 <= y.1) && (x.2 <= y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEprodlexi x y :\n  (x <= y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 <= y.2)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn2 A : 'L_2(A) = A^`(1). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPgeq m : ubn_geq_spec m m.    ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPleq m : ubn_leq_spec m m.    ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eq_Mod8_D8 : 'Mod_8 = 'D_8. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivn1 p : p^`(1) = p^`().\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma horner_evalE x p : horner_eval x p = p.[x]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derg1 A : A^`(1) = [~: A, A]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodMgE x y : (x * y)%g = x + y.   ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expn0 m : m ^ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactnS n m : n ^_ m.+1 = n * n.-1 ^_ m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma modn0 m : m %% 0 = m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cat0s s : [::] ++ s = s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactn0 n : n ^_ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltn0Sn n : 0 < n.+1.              ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expg0 x : x ^+ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivnS p n : p^`(n.+1) = p^`(n)^`().\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodXgE n x : (x ^+ n)%g = x *+ n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma absz0 : `|0%R| = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leq0n n : 0 <= n.                 ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma divn0 m : m %/ 0 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma pFrobenius_autE x : x^f = x ^+ p. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nposrE x : (x \\is npos) = (x <= 0). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphpreE R : f @*^-1 R = D :&: f @^-1: R. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltnSE m n : m < n.+1 -> m <= n.   ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactSS n m : n.+1 ^_ m.+1 = n.+1 * n ^_ m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma comp_actE x e : comp_action x e = to x (f e). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma dergSn n A : A^`(n.+1) = [~: A^`(n), A^`(n)]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphimE A : f @* A = f @: (D :&: A). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma factS n : (n.+1)`!  = n.+1 * n`!. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma baseField_scaleE a (u : L) : a *: (u : L0) = a%:A *: u.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinGE G H : (G * H)%G = (G <*> H)%G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joingE A B : A <*> B = <<A :|: B>>. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma doubleS n : n.+1.*2 = n.*2.+2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commgEl x y : [~ x, y] = x^-1 * x ^ y. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEbool : compl = negb. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltnSn n : n < n.+1.               ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fmval0 : valA 0 = 1%g. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma iteriS n f x : iteri n.+1 f x = f n (iteri n f x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr1 x : x ^+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma binS n m : 'C(n.+1, m.+1) = 'C(n, m.+1) + 'C(n, m). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulr1n x : x *+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma setactJ A x : 'J^*%act A x = A :^ x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expg1 x : x ^+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqSS m n : (m.+1 == n.+1) = (m == n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_algE a : in_alg A a = a%:A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expn1 m : m ^ 1 = m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma equivE x y : (equiv x y) = (x - y \\in I). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcmz_ge0 m n : 0 <= lcmz m n.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr0z x : x ^ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <=^d y :> T^d) = (y <= x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <^d y :> T^d) = (y < x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cat1s x s : [:: x] ++ s = x :: s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma setX_prod (H1 : {set gT1}) (H2 : {set gT2}) :\n  setX H1 1 * setX 1 H2 = setX H1 H2.\n",
  "proof": "Proof.\napply/setP=> [[x y]]; rewrite !inE /=.\napply/imset2P/andP=> [[[x1 u1] [v1 y1]] | [Hx Hy]].\n  rewrite !inE /= => /andP[Hx1 /eqP->] /andP[/eqP-> Hx] [-> ->].\n  by rewrite mulg1 mul1g.\nexists (x, 1 : gT2) (1 : gT1, y); rewrite ?inE ?Hx ?eqxx //.\nby rewrite /mulg /= /extprod_mulg /= mulg1 mul1g.\nQed."
}
{
  "statement": "Lemma morphim_fstX (H1: {set gT1}) (H2 : {group gT2}) :\n  [morphism of fun x => x.1] @* setX H1 H2 = H1.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP=> x0 /[1!inE] /andP[Hx1 _] ->.\nmove=> Hx1; apply/imsetP; exists (x, 1); last by trivial.\nby rewrite in_setX Hx1 /=.\nQed."
}
{
  "statement": "Lemma Hall_setI_normal pi G K H :\n  K <| G -> pi.-Hall(G) H -> pi.-Hall(K) (H :&: K).\n",
  "proof": "Proof.\nmove=> nsKG hallH; have [sHG piH _] := and3P hallH.\nhave [sHK_H sHK_K] := (subsetIl H K, subsetIr H K).\nrewrite pHallE sHK_K /= -(part_pnat_id (pgroupS sHK_H piH)); apply/eqP.\nrewrite (widen_partn _ (subset_leq_card sHK_K)); apply: eq_bigr => p pi_p.\nhave [P sylP] := Sylow_exists p H.\nhave sylPK := Sylow_setI_normal nsKG (subHall_Sylow hallH pi_p sylP).\nrewrite -!p_part -(card_Hall sylPK); symmetry; apply: card_Hall.\nby rewrite (pHall_subl _ sHK_K) //= setIC setSI ?(pHall_sub sylP).\nQed."
}
{
  "statement": "Lemma num_spec_min (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 min xi yi) :\n  num_spec r (Order.min x%:num y%:num).\n",
  "proof": "Proof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\napply/and3P; split; rewrite ?min_real//= num_itv_bound_min real_BSide_min//.\n- apply: (comparable_le_min2 (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\n- apply: (comparable_le_min2 _ (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\nQed."
}
{
  "statement": "Lemma astabs_subact S : 'N(S | subaction) = subact_dom :&: 'N(val @: S | to).\n",
  "proof": "Proof.\napply/setP=> a; rewrite inE in_setI; apply: andb_id2l => sDa.\nhave [Da _] := setIP sDa; rewrite !inE Da.\napply/subsetP/subsetP=> [nSa _ /imsetP[x Sx ->] | nSa x Sx] /[!inE].\n  by have /[1!inE]/(imset_f val) := nSa x Sx; rewrite val_subact sDa.\nhave /[1!inE]/imsetP[y Sy def_y] := nSa _ (imset_f val Sx).\nby rewrite ((_ a =P y) _) // -val_eqE val_subact sDa def_y.\nQed."
}
{
  "statement": "Lemma cfclass_transr phi psi :\n  (psi \\in phi ^: G)%CF -> (phi ^: G =i psi ^: G)%CF.\n",
  "proof": "Proof.\nrewrite -cfclassInorm; case/cfclassP=> x Gx -> xi; rewrite -!cfclassInorm.\nhave nHN: {subset 'N_G(H) <= 'N(H)} by apply/subsetP; apply: subsetIr.\napply/cfclassP/cfclassP=> [[y Gy ->] | [y Gy ->]].\n  by exists (x^-1 * y)%g; rewrite -?cfConjgMnorm ?groupM ?groupV ?nHN // mulKVg.\nby exists (x * y)%g; rewrite -?cfConjgMnorm ?groupM ?nHN.\nQed."
}
{
  "statement": "Lemma num_spec_max (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 max xi yi) :\n  num_spec r (Order.max x%:num y%:num).\n",
  "proof": "Proof.\napply: Itv.spec_real2 (Itv.P x) (Itv.P y).\ncase: x y => [x /= _] [y /= _] => {xi yi r} -[lx ux] [ly uy]/=.\nmove=> /andP[xr /=/andP[lxx xux]] /andP[yr /=/andP[lyy yuy]].\napply/and3P; split; rewrite ?max_real//= num_itv_bound_max real_BSide_max//.\n- apply: (comparable_le_max2 (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\n- apply: (comparable_le_max2 _ (comparable_num_itv_bound _ _)) => //.\n  exact: real_comparable.\nQed."
}
{
  "statement": "Lemma size_prod_seq_eq1 (I : eqType) (s : seq I) (P : pred I) (F : I -> {poly R}) :\n  reflect (forall i, P i && (i \\in s) -> size (F i) = 1)\n          (size (\\prod_(i <- s | P i) F i) == 1%N).\n",
  "proof": "Proof.\nrewrite (big_morph _ (id1:=true) size_mul_eq1) ?size_polyC ?oner_neq0//.\nrewrite big_all_cond; apply/(iffP allP).\n  by move=> h i /andP[Pi ins]; apply/eqP/(implyP (h i ins) Pi).\nby move=> h i ins; apply/implyP => Pi; rewrite h ?Pi.\nQed."
}
{
  "statement": "Lemma morphim_sndX (H1: {group gT1}) (H2 : {set gT2}) :\n  [morphism of fun x => x.2] @* setX H1 H2 = H2.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP=> x0 /[1!inE] /andP[_ Hx2] ->.\nmove=> Hx2; apply/imsetP; exists (1, x); last by [].\nby rewrite in_setX Hx2 andbT.\nQed."
}
{
  "statement": "Lemma exponent_pX1p2n n : prime p -> odd p -> exponent p^{1+2*n} = p.\n",
  "proof": "Proof.\nmove=> p_pr odd_p; apply: prime_nt_dvdP => //.\n  rewrite -dvdn1 -trivg_exponent -cardG_gt1 card_pX1p2n //.\n  by rewrite (ltn_exp2l 0) // prime_gt1.\nelim: n => [|n IHn].\n  by rewrite (dvdn_trans (exponent_dvdn _)) ?card_pX1p2n.\ncase: pX1p2S => gz isoZ; rewrite -im_cpair /=.\napply/exponentP=> xy; case/imset2P=> x y C1x C2y ->{xy}.\nrewrite expgMn; last by red; rewrite -(centsP (im_cpair_cent isoZ)).\nrewrite (exponentP _ y C2y) ?exponent_injm ?injm_cpair1g // mulg1.\nby rewrite (exponentP _ x C1x) ?exponent_injm ?injm_cpairg1 // exponent_pX1p2.\nQed."
}
{
  "statement": "Lemma num_spec_sqrtC (i : Itv.t) (x : num_def R i) (r := sqrtC_itv i) :\n  num_spec r (sqrtC x%:num).\n",
  "proof": "Proof.\nrewrite {}/r; case: i x => [//| [l u] [x /=/and3P[xr /= lx xu]]].\ncase: l lx => [bl [l |//] |[]//] lx; apply/and3P; split=> //=.\n  by apply: sqrtC_real; case: bl lx => /[!bnd_simp] [|/ltW]; apply: le_trans.\ncase: bl lx => /[!bnd_simp] lx.\n- by rewrite sqrtC_ge0; apply: le_trans lx.\n- by rewrite sqrtC_gt0; apply: le_lt_trans lx.\nQed."
}
{
  "statement": "Lemma cardD1 x A : #|A| = (x \\in A) + #|[predD1 A & x]|.\n",
  "proof": "Proof.\ncase Ax: (x \\in A); last first.\n  by apply: eq_card => y /[!inE]/=; case: eqP => // ->.\nrewrite /= -(card1 x) -cardUI addnC /=.\nrewrite [#|predI _ _|]eq_card0 => [|y]; last by rewrite !inE; case: eqP.\nby apply: eq_card => y /[!inE]; case: eqP => // ->.\nQed."
}
{
  "statement": "Lemma cfIndM phi psi:  H \\subset G ->\n     'Ind[G] (phi * ('Res[H] psi)) = 'Ind[G] phi * psi.\n",
  "proof": "Proof.\nmove=> HsG; apply/cfun_inP=> x Gx; rewrite !cfIndE // !cfunE !cfIndE // -mulrA.\ncongr (_ * _); rewrite mulr_suml; apply: eq_bigr=> i iG; rewrite !cfunE.\ncase: (boolP (x ^ i \\in H)) => xJi; last by rewrite cfun0gen ?mul0r ?genGid.\nby rewrite !cfResE //; congr (_ * _); rewrite cfunJgen ?genGid.\nQed."
}
{
  "statement": "Lemma orthov1E u : orthov <[u]> = lker (alpha u).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubv; apply/andP.\nsplit; apply/subvP=> v; rewrite memv_ker lfunE /=.\n   by move=> /mem_orthovP-> //; rewrite ?memv_line.\nmove=> vu_eq0; apply/mem_orthovP => w /vlineP[k->].\nby apply/eqP; rewrite linearZ mulf_eq0 vu_eq0 orbT.\nQed."
}
{
  "statement": "Lemma extend_cyclic_Mho G p x :\n    p.-group G -> x \\in G -> 'Mho^1(G) = <[x ^+ p]> -> \n  forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (p ^ k)]>.\n",
  "proof": "Proof.\nmove=> pG Gx defG1 [//|k _]; have pX := mem_p_elt pG Gx.\napply/eqP; rewrite eqEsubset cycle_subG (Mho_p_elt _ Gx pX) andbT.\nrewrite (MhoE _ pG) gen_subG; apply/subsetP=> ypk; case/imsetP=> y Gy ->{ypk}.\nhave: y ^+ p \\in <[x ^+ p]> by rewrite -defG1 (Mho_p_elt 1 _ (mem_p_elt pG Gy)).\nrewrite !expnS /= !expgM => /cycleP[j ->].\nby rewrite -!expgM mulnCA mulnC expgM mem_cycle.\nQed."
}
{
  "statement": "Lemma mxval_genV : {morph mxval : x / genV x >-> invmx x}.\n",
  "proof": "Proof.\nmove=> x; rewrite /mxval [pval _]poly_rV_K ?size_poly ?mx_inv_hornerK //.\npose m B : 'M[F]_(n * n) := lin_mx (mulmxr B); set B := mxval x.\ncase uB: (B \\is a GRing.unit); last by rewrite invr_out ?uB ?horner_mx_mem.\nhave defAd: Ad = Ad *m m B *m m B^-1.\n  apply/row_matrixP=> i.\n  by rewrite !row_mul mul_rV_lin /= mx_rV_lin /= mulmxK ?vec_mxK.\nrewrite -[B^-1]mul1mx -(mul_vec_lin (mulmxr B^-1)) defAd submxMr //.\nrewrite -mxval_gen1 (submx_trans (horner_mx_mem _ _)) // {1}defAd.\nrewrite -(geq_leqif (mxrank_leqif_sup _)) ?mxrankM_maxl // -{}defAd.\napply/row_subP=> i; rewrite row_mul rowK mul_vec_lin /= -{2}[A]horner_mx_X.\nby rewrite -rmorphXn mulmxE -rmorphM horner_mx_mem.\nQed."
}
{
  "statement": "Lemma eval_mxrank e r m n (A : 'M_(m, n)) :\n  qf_eval e (mxrank_form r A) = (\\rank (eval_mx e A) == r).\n",
  "proof": "Proof.\nelim: m r n A => [|m IHm] r [|n] A /=; try by case r; rewrite unlock.\nrewrite GRing.eval_Pick !unlock /=; set pf := fun _ => _.\nrewrite -(@eq_pick _ pf) => [|k]; rewrite {}/pf ?mxE // eq_sym.\ncase: pick => [[i j]|] //=; set B := _ - _; have:= mxrankE B.\ncase: (Gaussian_elimination_ B) r => [[_ _] _] [|r] //= <-; rewrite {}IHm eqSS.\nby congr (\\rank _ == r); apply/matrixP=> k l; rewrite !(mxE, big_ord1) !tpermR.\nQed."
}
{
  "statement": "Lemma cforder_lin_char : #[xi]%CF = exponent (G / cfker xi)%g.\n",
  "proof": "Proof.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  apply/dvdn_cforderP=> x Gx; rewrite -lin_charX // -cfQuoEker ?groupX //.\n  rewrite morphX ?(subsetP (cfker_norm xi)) //= expg_exponent ?mem_quotient //.\n  by rewrite cfQuo1 ?cfker_normal ?lin_char1.\nhave abGbar: abelian (G / cfker xi) := sub_der1_abelian lin_char_der1.\nhave [_ /morphimP[x Nx Gx ->] ->] := exponent_witness (abelian_nil abGbar).\nrewrite order_dvdn -morphX //= coset_id cfkerEchar // !inE groupX //=.\nby rewrite lin_charX ?lin_char1 // (dvdn_cforderP _ _ _).\nQed."
}
{
  "statement": "Lemma deg2_poly_noroot : reflect (forall x, ~~ root p x) (delta < 0).\n",
  "proof": "Proof.\napply/(iffP idP) => [dlt0 x | /(_ r1)].\n  case: ltgtP aneq0 => [agt0 _|alt0 _|//]; rewrite rootE; last first.\n    exact/lt0r_neq0/(deg2_poly_gt0 degp (ltW alt0)).\n  rewrite -oppr_eq0 -hornerN.\n  apply/lt0r_neq0/deg2_poly_gt0; rewrite ?size_polyN ?coefN ?oppr_ge0 ?ltW//.\n  by rewrite sqrrN -mulrA mulrNN mulrA.\nby rewrite ltNge; apply: contraNN => ?; apply: deg2_poly_root1.\nQed."
}
{
  "statement": "Lemma eigenvalue_root_min a : eigenvalue A a = root p_A a.\n",
  "proof": "Proof.\napply/idP/idP=> Aa; last first.\n  rewrite eigenvalue_root_char !root_factor_theorem in Aa *.\n  exact: dvdp_trans Aa mxminpoly_dvd_char.\nhave{Aa} [v Av_av v_nz] := eigenvalueP Aa.\napply: contraR v_nz => pa_nz; rewrite -{pa_nz}(eqmx_eq0 (eqmx_scale _ pa_nz)).\napply/eqP; rewrite -(mulmx0 _ v) -mx_root_minpoly.\nelim/poly_ind: p_A => [|p c IHp].\n  by rewrite rmorph0 horner0 scale0r mulmx0.\nrewrite !hornerE rmorphD rmorphM /= horner_mx_X horner_mx_C scalerDl.\nby rewrite -scalerA mulmxDr mul_mx_scalar mulmxA -IHp -scalemxAl Av_av.\nQed."
}
{
  "statement": "Lemma card_ord_partitions m n :\n  #|[set t : m.+1.-tuple 'I_n.+1 | \\sum_(i <- t) i == n]| = 'C(m + n, m).\n",
  "proof": "Proof.\nsymmetry; set In1 := 'I_n.+1; pose x0 : In1 := ord0.\npose f_add (t : m.-tuple In1) := [tuple of sub_ord (\\sum_(x <- t) x) :: t].\nrewrite -card_partial_ord_partitions -!sum1dep_card (reindex f_add) /=.\n  by apply: eq_bigl => t; rewrite big_cons /= addnC (sameP maxn_idPr eqP) maxnE.\nexists (fun t : m.+1.-tuple In1 => [tuple of behead t]) => [t _|].\n  exact: val_inj.\ncase/tupleP=> x t /[!(inE, big_cons)] /eqP def_n.\nby apply: val_inj; congr (_ :: _); apply: val_inj; rewrite /= -{1}def_n addnK.\nQed."
}
{
  "statement": "Lemma rstab_abelem m (A : 'M_(m, n)) : rstab rG A = 'C_G(rV_E @* rowg A).\n",
  "proof": "Proof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx; apply/eqP/centP => cAx.\nmove=> _ /morphimP[u _ + ->] => /[1!inE] /submxP[{}u ->].\n  by apply/esym/commgP/conjg_fixP; rewrite -rVabelemJ -?mulmxA ?cAx.\napply/row_matrixP=> i; apply: rVabelem_inj.\nby rewrite row_mul rVabelemJ // /conjg -cAx ?mulKg ?mem_morphim // inE row_sub.\nQed."
}
{
  "statement": "Lemma leif_AGM (I : finType) (A : {pred I}) (E : I -> F) :\n    let n := #|A| in let mu := (\\sum_(i in A) E i) / n%:R in\n    {in A, forall i, 0 <= E i} ->\n  \\prod_(i in A) E i <= mu ^+ n\n                     ?= iff [forall i in A, forall j in A, E i == E j].\n",
  "proof": "Proof.\nmove=> n mu Ege0; have [n0 | n_gt0] := posnP n.\n  by rewrite n0 -big_andE !(big_pred0 _ _ _ _ (card0_eq n0)); apply/leifP.\npose E' i := E i / n%:R.\nhave defE' i: E' i *+ n = E i by rewrite -mulr_natr divfK ?pnatr_eq0 -?lt0n.\nhave /leif_AGM_scaled (i): i \\in A -> 0 <= E' i *+ n by rewrite defE' => /Ege0.\nrewrite -/n -mulr_suml (eq_bigr _ (in1W defE')); congr (_ <= _ ?= iff _).\nby do 2![apply: eq_forallb_in => ? _]; rewrite -(eqr_pMn2r n_gt0) !defE'.\nQed."
}
{
  "statement": "Lemma Fadjoin_poly_unique p v :\n  p \\is a polyOver K -> size p <= n -> p.[x] = v -> Fadjoin_poly K x v = p.\n",
  "proof": "Proof.\nhave polyKx q i: q \\is a polyOver K -> q`_i * x ^+ i \\in (K * <[x ^+ i]>)%VS.\n  by move/polyOverP=> Kq; rewrite memv_mul ?Kq ?memv_line.\nmove=> Kp szp Dv; have /Fadjoin_poly_eq/eqP := mempx_Fadjoin Kp.\nrewrite {1}Dv {Dv} !(@horner_coef_wide _ n) ?size_poly //.\nmove/polyKx in Kp; have /polyKx K_pv := Fadjoin_polyOver K x v.\nrewrite (directv_sum_unique Fadjoin_sum_direct) // => /eqfunP eq_pq.\napply/polyP=> i; have [leni|?] := leqP n i; last exact: mulIf (eq_pq (Sub i _)).\nby rewrite !nth_default ?(leq_trans _ leni) ?size_poly.\nQed."
}
{
  "statement": "Lemma inertia_isom phi : 'I_R[cfIsom isoH phi] = g @* 'I_G[phi].\n",
  "proof": "Proof.\nhave [[_ defS] [injg <-]] := (isomP isoH, isomP isoG).\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\nrewrite /inertia !setIdE morphimIdom setIA -{1}defS -injm_norm ?injmI //.\napply/setP=> gy /[!inE]; apply: andb_id2l => /morphimP[y Gy nHy ->] {gy}.\nrewrite cfConjgIsom // -sub1set -morphim_set1 // injmSK ?sub1set //= inE.\napply/eqP/eqP=> [Iphi_y | -> //].\nby apply/cfun_inP=> x Hx; rewrite -!(cfIsomE isoH) ?Iphi_y.\nQed."
}
{
  "statement": "Lemma capmxE m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :&: B :=: capmx_gen A B)%MS.\n",
  "proof": "Proof.\nrewrite unlock -sub1mx; apply/eqmxP.\nhave:= submx_refl (capmx_gen A B); rewrite !sub_capmx_gen => /andP[sIA sIB].\ncase idA: (qidmx A); first by rewrite !capmx_nopP submx_refl sub_qidmx.\ncase idB: (qidmx B); first by rewrite !capmx_nopP submx_refl sub_qidmx.\ncase s1B: (1%:M <= B)%MS; rewrite !capmx_normP ?sub_capmx_gen sIA ?sIB //=.\nby rewrite submx_refl (submx_trans (submx1 _)).\nQed."
}
{
  "statement": "Lemma card_subcent1_coset G H x :\n  x \\in G -> H <| G -> (#|'C_(G / H)[coset H x]| <= #|'C_G[x]|)%N.\n",
  "proof": "Proof.\nmove=> Gx nsHG; rewrite -leC_nat.\nmove: (second_orthogonality_relation x Gx); rewrite mulrb class_refl => <-.\nhave GHx: coset H x \\in (G / H)%g by apply: mem_quotient.\nmove: (second_orthogonality_relation (coset H x) GHx).\nrewrite mulrb class_refl => <-.\nrewrite -2!(eq_bigr _ (fun _ _ => normCK _)) sum_norm_irr_quo // -subr_ge0.\nrewrite (bigID (fun i => H \\subset cfker 'chi[G]_i)) //= addrC addKr.\nby apply: sumr_ge0 => i _; rewrite normCK mul_conjC_ge0.\nQed."
}
{
  "statement": "Lemma mxdirect_delta n f : {in P &, injective f} ->\n  mxdirect (\\sum_(i | P i) <<delta_mx 0 (f i) : 'rV[F]_n>>).\n",
  "proof": "Proof.\npose fP := image f P => Uf; have UfP: uniq fP by apply/dinjectiveP.\nsuffices /mxdirectP : mxdirect (\\sum_i <<delta_mx 0 i : 'rV[F]_n>>).\n  rewrite /= !(bigID [in fP] predT) -!big_uniq //= !big_map !big_enum.\n  by move/mxdirectP; rewrite mxdirect_addsE => /andP[].\napply/mxdirectP=> /=; transitivity (mxrank (1%:M : 'M[F]_n)).\n  apply/eqmx_rank; rewrite submx1 mx1_sum_delta summx_sub_sums // => i _.\n  by rewrite -(mul_delta_mx (0 : 'I_1)) genmxE submxMl.\nrewrite mxrank1 -[LHS]card_ord -sum1_card.\nby apply/eq_bigr=> i _; rewrite /= mxrank_gen mxrank_delta.\nQed."
}
{
  "statement": "Lemma nElemP n G E : reflect (exists p, E \\in 'E_p^n(G)) (E \\in 'E^n(G)).\n",
  "proof": "Proof.\nrewrite ['E^n(G)]big_mkord.\napply: (iffP bigcupP) => [[[p /= _] _] | [p]]; first by exists p.\ncase: n => [|n EpnE]; first by rewrite pnElem0; exists ord0; rewrite ?pnElem0.\nsuffices lepG: p < #|G|.+1  by exists (Ordinal lepG).\nhave:= EpnE; rewrite pnElemE ?(pnElem_prime EpnE) // !inE -andbA ltnS.\ncase/and3P=> sEG _ oE; rewrite dvdn_leq // (dvdn_trans _ (cardSg sEG)) //.\nby rewrite (eqP oE) dvdn_exp.\nQed."
}
{
  "statement": "Lemma center_aut_extraspecial k : coprime k p ->\n  exists2 f, f \\in Aut S & forall z, z \\in 'Z(S) -> f z = (z ^+ k)%g.\n",
  "proof": "Proof.\nhave /cyclicP[z defZ]: cyclic 'Z(S) by rewrite prime_cyclic ?oZ.\nhave oz: #[z] = p by rewrite orderE -defZ.\nrewrite coprime_sym -unitZpE ?prime_gt1 // -oz => u_k.\npose g := Zp_unitm (FinRing.unit 'Z_#[z] u_k).\nhave AutZg: g \\in Aut 'Z(S) by rewrite defZ -im_Zp_unitm mem_morphim ?inE.\nhave ZSfull := Aut_sub_fullP (center_sub S) Aut_extraspecial_full.\nhave [f [injf fS fZ]] := ZSfull _ (injm_autm AutZg) (im_autm AutZg).\nexists (aut injf fS) => [|u Zu]; first exact: Aut_aut.\nhave [Su _] := setIP Zu; have z_u: u \\in <[z]> by rewrite -defZ.\nby rewrite autE // fZ //= autmE permE /= z_u /cyclem expg_znat.\nQed."
}
{
  "statement": "Lemma ntransitive1 m :\n  0 < m -> [transitive^m G, on S | to] -> [transitive G, on S | to].\n",
  "proof": "Proof.\nhave trdom1 x: ([tuple x] \\in 1.-dtuple(S)) = (x \\in S).\n  by rewrite dtuple_on_add !inE memtE subset_all andbT.\nmove=> m_gt0 /(ntransitive_weak m_gt0) {m m_gt0}.\ncase/imsetP; case/tupleP=> x t0; rewrite {t0}(tuple0 t0) trdom1 => Sx trx.\napply/imsetP; exists x => //; apply/setP=> y; rewrite -trdom1 trx.\nby apply/imsetP/imsetP=> [[a ? [->]]|[a ? ->]]; exists a => //; apply: val_inj.\nQed."
}
{
  "statement": "Lemma Clifford_iso2 x U V :\n  mx_iso rH U V -> x \\in G -> mx_iso rH (U *m rG x) (V *m rG x).\n",
  "proof": "Proof.\ncase=> [f injf homUf defV] Gx; have Gx' := groupVr Gx.\npose fx := rG (x^-1)%g *m f *m rG x; exists fx; last 1 first.\n- by rewrite !mulmxA repr_mxK //; apply: eqmxMr.\n- by rewrite !unitmx_mul andbC !repr_mx_unit.\napply/hom_mxP=> h Hh; have Gh := subsetP sHG h Hh.\nrewrite -(mulmxA U) -repr_mxM // conjgCV repr_mxM ?groupJ // !mulmxA.\nrewrite !repr_mxK // (hom_mxP homUf) -?mem_conjg ?(normsP nHG) //=.\nby rewrite !repr_mxM ?invgK ?groupM // !mulmxA repr_mxKV.\nQed."
}
{
  "statement": "Lemma cfDetRes gT (G H : {group gT}) phi :\n  phi \\is a character -> cfDet ('Res[H, G] phi) = 'Res (cfDet phi).\n",
  "proof": "Proof.\nmove=> Nphi; have [sGH | not_sHG] := boolP (H \\subset G); last first.\n  have /natrP[n Dphi1] := Cnat_char1 Nphi.\n  rewrite !cfResEout // Dphi1 lin_char1 ?cfDet_lin_char // scale1r.\n  by rewrite scaler_nat cfDetMn ?cfDet_id ?rpred1 // expr1n.\nhave [rG ->] := char_reprP Nphi; rewrite !(=^~ cfRepr_sub, cfDetRepr) //.\napply: cfRepr_sim; exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => x Hx.\nby rewrite mulmx1 mul1mx.\nQed."
}
{
  "statement": "Lemma trivg_acomps K s : acomps K s -> (K :==: 1) = (s == [::]).\n",
  "proof": "Proof.\ncase/andP=> ls cs; apply/eqP/eqP; last first.\n  by move=> se; rewrite se /= in ls; apply/eqP.\nmove=> G1; case: s ls cs => // H s _ /=; case/andP; case/maxgroupP.\nby rewrite G1 sub1G andbF.\nQed."
}
{
  "statement": "Lemma eq_dvdp c quo q p : c != 0 -> c *: p = quo * q -> q %| p.\n",
  "proof": "Proof.\nmove=> cn0; case: (eqVneq p 0) => [->|nz_quo def_quo] //.\npose p1 : {poly R} := lead_coef q ^+ scalp p q *: quo - c *: (p %/ q).\nhave E1: c *: (p %% q) = p1 * q.\n  rewrite mulrDl mulNr -scalerAl -def_quo scalerA mulrC -scalerA.\n  by rewrite -scalerAl -scalerBr divp_eq addrAC subrr add0r.\nrewrite /dvdp; apply/idPn=> m_nz.\nhave: p1 * q != 0 by rewrite -E1 -mul_polyC mulf_neq0 // polyC_eq0.\nrewrite mulf_eq0; case/norP=> p1_nz q_nz.\nhave := ltn_modp p q; rewrite q_nz -(size_scale (p %% q) cn0) E1.\nby rewrite size_mul // polySpred // ltnNge leq_addl.\nQed."
}
{
  "statement": "Lemma pnatM pi m n : pi.-nat (m * n) = pi.-nat m && pi.-nat n.\n",
  "proof": "Proof.\nrewrite /pnat muln_gt0 andbCA -andbA andbCA.\ncase: posnP => // n_gt0; case: posnP => //= m_gt0.\napply/allP/andP=> [pi_mn | [pi_m pi_n] p].\n  by split; apply/allP=> p m_p; apply: pi_mn; rewrite primesM // m_p ?orbT.\nby rewrite primesM // => /orP[]; [apply: (allP pi_m) | apply: (allP pi_n)].\nQed."
}
{
  "statement": "Lemma mergeA : associative merge.\n",
  "proof": "Proof.\nelim=> // x xs IHxs; elim=> // y ys IHys; elim=> [|z zs IHzs] /=.\n  by case: ifP.\ncase: ifP; case: ifP => /= lexy leyz.\n- by rewrite lexy (leT_tr lexy leyz) -IHxs /= leyz.\n- by rewrite lexy leyz -IHys.\n- case: ifP => lexz; first by rewrite -IHxs //= leyz.\n  by rewrite -!/(merge (_ :: _)) IHzs /= lexy.\n- suff->: leT x z = false by rewrite leyz // -!/(merge (_ :: _)) IHzs /= lexy.\n  by apply/contraFF/leT_tr: leyz; have := leT_total x y; rewrite lexy.\nQed."
}
{
  "statement": "Lemma leqif_mul m1 n1 C1 m2 n2 C2 :\n    m1 <= n1 ?= iff C1 -> m2 <= n2 ?= iff C2 ->\n  m1 * m2 <= n1 * n2 ?= iff (n1 * n2 == 0) || (C1 && C2).\n",
  "proof": "Proof.\ncase: n1 => [|n1] le1; first by case: m1 le1 => [|m1] [_ <-] //.\ncase: n2 m2 => [|n2] [|m2] /=; try by case=> // _ <-; rewrite !muln0 ?andbF.\nhave /leq_pmul2l-/mono_leqif<-: 0 < n1.+1 by [].\nby apply: leqif_trans; have /leq_pmul2r-/mono_leqif->: 0 < m2.+1.\nQed."
}
{
  "statement": "Lemma Wedderburn_annihilate i j : i != j -> ('R_i * 'R_j)%MS = 0.\n",
  "proof": "Proof.\nmove=> ne_ij; apply/eqP; rewrite -submx0 -(Wedderburn_disjoint ne_ij).\nrewrite sub_capmx; apply/andP; split.\n  case/andP: (Wedderburn_ideal i) => _; apply: submx_trans.\n  by rewrite mulsmxS // genmxE submxMl.\ncase/andP: (Wedderburn_ideal j) => idlRj _; apply: submx_trans idlRj.\nby rewrite mulsmxS // genmxE submxMl.\nQed."
}
{
  "statement": "Lemma dvdp_trans : transitive (@dvdp R).\n",
  "proof": "Proof.\nmove=> n d m.\ncase: (eqVneq d 0) => [-> /dvd0pP -> // | dn0].\ncase: (eqVneq n 0) => [-> _ /dvd0pP -> // | nn0].\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Hq1.\nrewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> Hq2.\nhave sn0 : c1 * c2 != 0 by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\napply: (@eq_dvdp _ (q2 * q1) _ _ sn0).\nby rewrite -scalerA Hq2 scalerAr Hq1 mulrA.\nQed."
}
{
  "statement": "Lemma holds_conjn (e : seq F) (i : nat) (x : F) (ps : seq tF) :\n  all (@rterm _) ps ->\n  (GRing.holds (set_nth 0 e i x)\n               (foldr (fun t : tF => GRing.And (t != 0)) GRing.True ps) <->\n  all (fun p => ~~root p x) (map (eval_poly e \\o abstrX i) ps)).\n",
  "proof": "Proof.\nelim: ps => [|p ps ihps] //=.\ncase/andP=> rp rps; rewrite rootE abstrXP //.\nconstructor; first by case=> /eqP-> hps /=; apply/ihps.\nby case/andP=> pr psr; split; first apply/eqP=> //; apply/ihps.\nQed."
}
{
  "statement": "Lemma cfDetMorph aT rT (D G : {group aT}) (f : {morphism D >-> rT})\n                (phi : 'CF(f @* G)) :\n  phi \\is a character -> cfDet (cfMorph phi) = cfMorph (cfDet phi).\n",
  "proof": "Proof.\nmove=> Nphi; have [sGD | not_sGD] := boolP (G \\subset D); last first.\n  have /natrP[n Dphi1] := Cnat_char1 Nphi.\n  rewrite !cfMorphEout // Dphi1 lin_char1 ?cfDet_lin_char // scale1r.\n  by rewrite scaler_nat cfDetMn ?cfDet_id ?rpred1 // expr1n.\nhave [rG ->] := char_reprP Nphi; rewrite !(=^~ cfRepr_morphim, cfDetRepr) //.\napply: cfRepr_sim; exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => x Hx.\nby rewrite mulmx1 mul1mx.\nQed."
}
{
  "statement": "Lemma acts_qact_doms (H : {group rT}) :\n  H \\subset D -> [acts A, on H | to] -> qact_dom to H :=: A.\n",
  "proof": "Proof.\nmove=> sHD aH; apply/eqP; rewrite eqEsubset; apply/andP.\nsplit; first exact: qact_dom_doms.\napply/subsetP=> x Ax; rewrite qact_domE //; apply/gastabsP=> //.\nby move/gactsP: aH; move/(_ x Ax).\nQed."
}
{
  "statement": "Lemma morphim_pprodm A B :\n  A \\subset H -> B \\subset K -> f @* (A * B) = fH @* A * fK @* B.\n",
  "proof": "Proof.\nmove=> sAH sBK; rewrite [f @* _]morphimEsub /=; last first.\n  by rewrite norm_joinEr // mulgSS.\napply/setP=> y; apply/imsetP/idP=> [[_ /mulsgP[x a Ax Ba ->] ->{y}] |].\n  have Hx := subsetP sAH x Ax; have Ka := subsetP sBK a Ba.\n  by rewrite pprodmE // imset2_f ?mem_morphim.\ncase/mulsgP=> _ _ /morphimP[x Hx Ax ->] /morphimP[a Ka Ba ->] ->{y}.\nby exists (x * a); rewrite ?mem_mulg ?pprodmE.\nQed."
}
{
  "statement": "Lemma dvdn_constt_Res1_irr1 i j :\n    H <| G -> j \\in irr_constt ('Res[H, G] 'chi_i) ->\n  exists n, 'chi_i 1%g = n%:R * 'chi_j 1%g.\n",
  "proof": "Proof.\nmove=> nsHG chiHj; have [sHG nHG] := andP nsHG; rewrite -(cfResE _ sHG) //.\nrewrite {1}(Clifford_Res_sum_cfclass nsHG chiHj) cfunE sum_cfunE.\nhave /natrP[n ->]: '['Res[H] 'chi_i, 'chi_j] \\in Num.nat.\n  by rewrite Cnat_cfdot_char ?cfRes_char ?irr_char.\nexists (n * size ('chi_j ^: G)%CF)%N; rewrite natrM -mulrA; congr (_ * _).\nrewrite mulr_natl -[size _]card_ord big_tnth -sumr_const; apply: eq_bigr => k _.\nby have /cfclassP[y Gy ->]:=  mem_tnth k (in_tuple _); rewrite cfConjg1.\nQed."
}
{
  "statement": "Lemma big_trivIset_cond P (K : pred T) (E : T -> R) :\n  trivIset P -> \\big[op/idx]_(x in cover P | K x) E x = rhs_cond P K E.\n",
  "proof": "Proof.\nmove=> tiP; rewrite (partition_big (pblock P) [in P]) -/op => /= [|x].\n  apply: eq_bigr => A PA; apply: eq_bigl => x; rewrite andbAC; congr (_ && _).\n  rewrite -mem_pblock; apply/andP/idP=> [[Px /eqP <- //] | Ax].\n  by rewrite (def_pblock tiP PA Ax).\nby case/andP=> Px _; apply: pblock_mem.\nQed."
}
{
  "statement": "Lemma acts_qact_dom_norm : {acts qact_dom to H, on 'N(H) | to}.\n",
  "proof": "Proof.\nmove=> a HDa /= x; rewrite {2}(('N(H) =P to^~ a @^-1: 'N(H)) _) ?inE {x}//.\nrewrite eqEcard (card_preimset _ (act_inj _ _)) leqnn andbT.\napply/subsetP=> x Nx; rewrite inE; move/(astabs_act (H :* x)): HDa.\nrewrite mem_rcosets mulSGid ?normG // Nx => /rcosetsP[y Ny defHy].\nsuffices: to x a \\in H :* y by apply: subsetP; rewrite mul_subG ?sub1set ?normG.\nby rewrite -defHy; apply: imset_f; apply: rcoset_refl.\nQed."
}
{
  "statement": "Lemma PCanHasChoice f' : pcancel f f' -> hasChoice sT.\n",
  "proof": "Proof.\nmove=> fK; pose liftP sP := [pred x | oapp sP false (f' x)].\npose sf sP := [fun n => obind f' (find (liftP sP) n)].\nexists sf => [sP n x | sP [y sPy] | sP sQ eqPQ n] /=.\n- by case Df: (find _ n) => //= [?] Dx; have:= correct Df; rewrite /= Dx.\n- have [|n Pn] := @complete T (liftP sP); first by exists (f y); rewrite /= fK.\n  exists n; case Df: (find _ n) Pn => //= [x] _.\n  by have:= correct Df => /=; case: (f' x).\nby congr (obind _ _); apply: extensional => x /=; case: (f' x) => /=.\nQed."
}
{
  "statement": "Lemma cfBigdprodEi i (phi : 'CF(A i)) x :\n    P i -> (forall j, P j -> x j \\in A j) ->\n  cfBigdprodi phi (\\prod_(j | P j) x j)%g = phi (x i).\n",
  "proof": "Proof.\nhave [r big_r [Ur mem_r] _] := big_enumP P => Pi AxP.\nhave:= bigdprodWcp defG; rewrite -!big_r => defGr.\nhave{AxP} [r_i Axr]: i \\in r /\\ {in r, forall j, x j \\in A j}.\n  by split=> [|j]; rewrite mem_r // => /AxP.\nrewrite (perm_bigcprod defGr Axr (perm_to_rem r_i)) big_cons.\nrewrite cfDprodEl ?Pi ?cfRes_id ?Axr // big_seq group_prod // => j.\nrewrite mem_rem_uniq // => /andP[i'j /= r_j].\nby apply/mem_gen/bigcupP; exists j; [rewrite -mem_r r_j | apply: Axr].\nQed."
}
{
  "statement": "Lemma redivpT_qf (p : polyF) (q : polyF) : rpoly p -> rpoly q ->\n  qf_cps (fun x => [&& rpoly x.1.2 & rpoly x.2]) (redivpT p q).\n",
  "proof": "Proof.\nmove=> rp rq; apply: qf_cps_bind => [|[] _]; first exact: isnull_qf.\n  by apply: qf_cps_ret.\napply: qf_cps_bind => [|sp _]; first exact: sizeT_qf.\napply: qf_cps_bind => [|sq _]; first exact: sizeT_qf.\napply: qf_cps_bind => [|lq rlq]; first exact: lead_coefT_qf.\nby apply: redivp_rec_loopT_qf => //=.\nQed."
}
{
  "statement": "Lemma size_comp_poly p q :\n  (size (p \\Po q)).-1 = ((size p).-1 * (size q).-1)%N.\n",
  "proof": "Proof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite comp_poly0 size_poly0.\nhave [/size1_polyC-> | nc_q] := leqP (size q) 1.\n  by rewrite comp_polyCr !size_polyC -!sub1b -!subnS muln0.\nhave nz_q: q != 0 by rewrite -size_poly_eq0 -(subnKC nc_q).\nrewrite mulnC comp_polyE (polySpred nz_p) /= big_ord_recr /= addrC.\nrewrite size_polyDl size_scale ?lead_coef_eq0 ?size_exp //=.\nrewrite [ltnRHS]polySpred ?expf_neq0 // ltnS size_exp.\nrewrite (leq_trans (size_sum _ _ _)) //; apply/bigmax_leqP => i _.\nrewrite (leq_trans (size_scale_leq _ _)) // polySpred ?expf_neq0 //.\nby rewrite size_exp -(subnKC nc_q) ltn_pmul2l.\nQed."
}
{
  "statement": "Lemma p_rank_abelian p G : abelian G -> 'r_p(G) = logn p #|'Ohm_1(G)|.\n",
  "proof": "Proof.\nmove=> cGG; have nilG := abelian_nil cGG; case p_pr: (prime p); last first.\n  by apply/eqP; rewrite lognE p_pr eqn0Ngt p_rank_gt0 mem_primes p_pr.\ncase/dprodP: (Ohm_dprod 1 (nilpotent_pcoreC p nilG)) => _ <- _ /TI_cardMg->.\nrewrite mulnC logn_Gauss; last first.\n  rewrite prime_coprime // -p'natE // -/(pgroup _ _).\n  exact: pgroupS (Ohm_sub _ _) (pcore_pgroup _ _).\nrewrite -(p_rank_Sylow (nilpotent_pcore_Hall p nilG)) -p_rank_Ohm1.\nrewrite p_rank_abelem // Ohm1_abelem ?pcore_pgroup //.\nexact: abelianS (pcore_sub _ _) cGG.\nQed."
}
{
  "statement": "Lemma exprzDr x (ux : x \\is a GRing.unit) m n : x ^ (m + n) = x ^ m * x ^ n.\n",
  "proof": "Proof.\nmove: n m; apply: wlog_le=> n m hnm.\n  by rewrite addrC hnm commrXz //; exact/commr_sym/commrXz.\ncase: (intP m) hnm=> {m} [|m|m]; rewrite ?mul1r ?add0r //;\n case: (intP n)=> {n} [|n|n _]; rewrite ?mulr1 ?addr0 //;\n   do ?by rewrite exprzD_ss.\nrewrite -invr_expz subzSS !exprSzr invrM ?unitrX // -mulrA mulVKr //.\ncase: (leqP n m)=> [|/ltnW] hmn; rewrite -{2}(subnK hmn) exprzD_nat -subzn //.\n  by rewrite mulrK ?unitrX.\nby rewrite invrM ?unitrXz // mulVKr ?unitrXz // -opprB -invr_expz.\nQed."
}
{
  "statement": "Lemma mx_series_rcons U V :\n  mx_series (rcons U V) <-> [/\\ mx_series U, modG V & max_submod (last 0 U) V].\n",
  "proof": "Proof.\nrewrite /mx_series /mx_subseries all_rcons size_rcons -rcons_cons.\nsplit=> [ [/andP[modU modV] maxU] | [[modU maxU] modV maxV]].\n  split=> //; last first.\n    by have:= maxU _ (leqnn _); rewrite !nth_rcons leqnn ltnn eqxx -last_nth.\n  by split=> // i ltiU; have:= maxU i (ltnW ltiU); rewrite !nth_rcons leqW ltiU.\nrewrite modV; split=> // i; rewrite !nth_rcons ltnS leq_eqVlt.\ncase: eqP => [-> _ | /= _ ltiU]; first by rewrite ltnn ?eqxx -last_nth.\nby rewrite ltiU; apply: maxU.\nQed."
}
{
  "statement": "Lemma n_comp_closure2 x y :\n  n_comp e (closure e (pred2 x y)) = (~~ connect e x y).+1.\n",
  "proof": "Proof.\nrewrite -(root_connect sym_e) -card2; apply: eq_card => z.\napply/idP/idP=> [/andP[/eqP {2}<- /pred0Pn[t /andP[/= ezt exyt]]] |].\n  by case/pred2P: exyt => <-; rewrite (rootP sym_e ezt) !inE eqxx ?orbT.\nby case/pred2P=> ->; rewrite !inE roots_root //; apply/existsP;\n  [exists x | exists y]; rewrite !inE eqxx ?orbT sym_e connect_root.\nQed."
}
{
  "statement": "Lemma galois_factors K E :\n    (K <= E)%VS ->\n  reflect {in E, forall a, exists r, let r_a := [seq x a | x : gal_of E <- r] in\n            [/\\ r \\subset 'Gal(E / K), uniq r_a\n              & minPoly K a = \\prod_(b <- r_a) ('X - b%:P)]}\n          (galois K E).\n",
  "proof": "Proof.\nmove=> sKE; apply: (iffP and3P) => [[_ sepKE nKE] a Ea | galKE].\n  have [r galEr splitEa] := normalField_factors sKE nKE a Ea.\n  exists r; rewrite /= -separable_prod_XsubC !big_map -splitEa.\n  by split=> //; apply: separableP Ea.\nsplit=> //.\n  apply/separableP => a /galKE[r [_ Ur_a splitKa]].\n  by rewrite /separable_element splitKa separable_prod_XsubC.\napply/(normalField_factors sKE)=> a /galKE[r [galEr _ ->]].\nby rewrite big_map; exists r.\nQed."
}
{
  "statement": "Lemma num_field_proj : {CtoQn | CtoQn 0 = 0 & cancel QnC CtoQn}.\n",
  "proof": "Proof.\npose b := vbasis {:Qn}.\nhave Qn_bC (u : {x | x \\in Crat_span (map QnC b)}): {y | QnC y = sval u}.\n  case: u => _ /= /Crat_spanP/sig_eqW[a ->].\n  exists (\\sum_i a i *: b`_i); rewrite rmorph_sum /=; apply: eq_bigr => i _.\n  by rewrite rmorphZ_num (nth_map 0) // -(size_map QnC).\npose CtoQn x := oapp (fun u => sval (Qn_bC u)) 0 (insub x).\nsuffices QnCK: cancel QnC CtoQn by exists CtoQn; rewrite // -(rmorph0 QnC) /=.\nmove=> x; rewrite /CtoQn insubT => /= [|Qn_x]; last first.\n  by case: (Qn_bC _) => x1 /= /fmorph_inj.\nrewrite (coord_vbasis (memvf x)) rmorph_sum rpred_sum //= => i _.\nrewrite rmorphZ_num Crat_spanZ ?mem_Crat_span // -/b.\nby rewrite -tnth_nth -tnth_map mem_tnth.\nQed."
}
{
  "statement": "Lemma loopingP x n :\n  reflect (forall m, iter m f x \\in traject f x n) (looping x n).\n",
  "proof": "Proof.\napply: (iffP idP) => loop_n; last exact: loop_n.\ncase: n => // n in loop_n *; elim=> [|m /= IHm]; first exact: mem_head.\nmove: (fpath_traject x n) loop_n; rewrite /looping !iterS -last_traject /=.\nmove: (iter m f x) IHm => y /splitPl[p1 p2 def_y].\nrewrite cat_path last_cat def_y; case: p2 => // z p2 /and3P[_ /eqP-> _] _.\nby rewrite inE mem_cat mem_head !orbT.\nQed."
}
{
  "statement": "Lemma pseries_sub_catr pi1s pi2s gT (G : {group gT}) :\n  pseries pi2s G \\subset pseries (pi1s ++ pi2s) G.\n",
  "proof": "Proof.\nelim: pi1s => //= pi1 pi1s /subset_trans; apply.\nelim/last_ind: {pi1s pi2s}(_ ++ _) => [|pis pi IHpi]; first exact: sub1G.\nrewrite -rcons_cons (pseries_rcons _ (pi1 :: pis)).\nrewrite -sub_morphim_pre ?pseries_norm2 //.\napply: pcore_max; last by rewrite morphim_normal ?pseries_normal.\nhave: pi.-group (pseries (rcons pis pi) G / pseries pis G).\n  by rewrite quotient_pseries pcore_pgroup.\nby apply: pnat_dvd; rewrite !card_quotient ?pseries_norm2 // indexgS.\nQed."
}
{
  "statement": "Lemma normalField_img : normalField_cast @* 'Gal(E / K) = 'Gal(M / K).\n",
  "proof": "Proof.\nhave [[sKM sME] [sKE _ nKE]] := (andP sKME, and3P galKE).\napply/setP=> x; apply/idP/idP=> [/morphimP[{}x galEx _ ->] | galMx].\n  rewrite gal_kHom //; apply/kAHomP=> a Ka; have Ma := subvP sKM a Ka.\n  by rewrite normalField_cast_eq // (fixed_gal sKE).\nhave /(kHom_to_gal sKME nKE)[y galEy eq_xy]: kHom K M x by rewrite -gal_kHom.\napply/morphimP; exists y => //; apply/eqP/gal_eqP => a Ha.\nby rewrite normalField_cast_eq // eq_xy.\nQed."
}
{
  "statement": "Lemma principal_comp_subproof : mxsimple aG (rfix_mx aG G).\n",
  "proof": "Proof.\napply: linear_mxsimple; first exact: rfix_mx_module.\napply/eqP; rewrite rfix_regular eqn_leq rank_leq_row lt0n mxrank_eq0.\napply/eqP => /(congr1 (gring_proj 1 \\o gring_mx aG)); apply/eqP.\nrewrite /= -[gring_mx _ _]/(gring_op _ _) !linear0 !linear_sum (bigD1 1%g) //=.\nrewrite gring_opG ?gring_projE // eqxx big1 ?addr0 ?oner_eq0 // => x.\nby case/andP=> Gx nt_x; rewrite gring_opG // gring_projE // eq_sym (negPf nt_x).\nQed."
}
{
  "statement": "Lemma logn_card_GL_p n p : prime p -> logn p #|'GL_n(p)| = 'C(n, 2).\n",
  "proof": "Proof.\nmove=> p_pr; have p_gt1 := prime_gt1 p_pr.\nhave p_i_gt0: p ^ _ > 0 by move=> i; rewrite expn_gt0 ltnW.\nhave <- : #|'GL_n.-1.+1(p)| = #|'GL_n(p)| by [].\nrewrite (card_GL _ (ltn0Sn n.-1)) card_ord Fp_cast // big_add1 /=.\npose p'gt0 m := m > 0 /\\ logn p m = 0.\nsuffices [Pgt0 p'P]: p'gt0 (\\prod_(0 <= i < n.-1.+1) (p ^ i.+1 - 1))%N.\n  by rewrite lognM // p'P pfactorK // addn0; case n.\napply: big_ind => [|m1 m2 [m10 p'm1] [m20]|i _]; rewrite {}/p'gt0 ?logn1 //.\n  by rewrite muln_gt0 m10 lognM ?p'm1.\nrewrite lognE -if_neg subn_gt0 p_pr /= -{1 2}(exp1n i.+1) ltn_exp2r // p_gt1.\nby rewrite dvdn_subr ?dvdn_exp // gtnNdvd.\nQed."
}
{
  "statement": "Lemma eqpf_eq p q : reflect (exists2 c, c != 0 & p = c *: q) (p %= q).\n",
  "proof": "Proof.\napply: (iffP idP); last first.\n  case=> c nz_c ->; apply/eqpP.\n  by exists (1, c); rewrite ?scale1r ?oner_eq0.\nhave [->|nz_q] := eqVneq q 0.\n  by rewrite eqp0=> /eqP ->; exists 1; rewrite ?scale1r ?oner_eq0.\ncase/IdomainUnit.ulc_eqpP; first by rewrite unitfE lead_coef_eq0.\nby move=> c nz_c ->; exists c.\nQed."
}
{
  "statement": "Lemma holds_conj : forall e i x ps, all (@rterm _) ps ->\n  (GRing.holds (set_nth 0 e i x)\n               (foldr (fun t : tF => GRing.And (t == 0)) GRing.True%T ps)\n  <-> all ((@root _)^~ x) (map (eval_poly e \\o abstrX i) ps)).\n",
  "proof": "Proof.\nmove=> e i x; elim=> [|p ps ihps] //=.\ncase/andP=> rp rps; rewrite rootE abstrXP //.\nconstructor; first by case=> -> hps; rewrite eqxx /=; apply/ihps.\nby case/andP; move/eqP=> -> psr; split=> //; apply/ihps.\nQed."
}
{
  "statement": "Lemma afix_actby B : 'Fix_<[nRA]>(B) = ~: R :|: 'Fix_to(A :&: B).\n",
  "proof": "Proof.\napply/setP=> x; rewrite !inE /= /actby.\ncase: (x \\in R); last by apply/subsetP=> a _ /[!inE].\napply/subsetP/subsetP=> [cBx a | cABx a Ba] /[!inE].\n  by case/andP=> Aa /cBx; rewrite inE Aa.\nby case: ifP => //= Aa; have:= cABx a; rewrite !inE Aa => ->.\nQed."
}
{
  "statement": "Lemma burnside_app_iso3 :\n  (cube_coloring_number24 * 24 =\n   n ^ 6 + 6 * n ^ 3 + 3 * n ^ 4 + 8 * (n ^ 2)  + 6 * n ^ 3)%N.\n",
  "proof": "Proof.\npose iso_list := [:: id3; s05; s14; s23; r05; r14; r23; r50; r41; r32;\n                     r024; r042; r012; r021; r031; r013; r043; r034;\n                     s1; s2; s3; s4; s5; s6].\nrewrite (burnside_formula iso_list); last first.\n- by move=> p; rewrite !inE /= !(eq_sym _ p).\n- apply: map_uniq (fun p : {perm cube} => (p F0, p F1)) _ _.\n  have bsr : (fun p : {perm cube} => (p F0, p F1)) =1\n             (fun p => (nth F0 p F0, nth F0 p F1)) \\o sop.\n    by move=> x; rewrite /= -2!sop_spec.\n  by rewrite (eq_map bsr) map_comp  -(eqP Lcorrect); vm_compute.\nrewrite !big_cons big_nil {1}card_Fid3 /= F_s05 F_s14 F_s23 F_r05 F_r14 F_r23\n  F_r50 F_r41 F_r32 F_r024 F_r042 F_r012 F_r021 F_r031 F_r013 F_r043  F_r034\n  F_s1  F_s2 F_s3 F_s4 F_s5 F_s6.\nrewrite !card_n4 // !card_n3_3 // !card_n2_3 // !card_n3s //.\nby rewrite [RHS]addn.[ACl 1 * 3 * 2 * 4 * 5] !addnA !addn0.\nQed."
}
{
  "statement": "Lemma nil_class_pgroup (gT : finGroupType) (p : nat) (P : {group gT}) :\n  p.-group P -> nil_class P <= maxn 1 (logn p #|P|).-1.\n",
  "proof": "Proof.\nmove=> pP; move def_c: (nil_class P) => c.\nelim: c => // c IHc in gT P def_c pP *; set e := logn p _.\nhave nilP := pgroup_nil pP; have sZP := center_sub P.\nhave [e_le2 | e_gt2] := leqP e 2.\n  by rewrite -def_c leq_max nil_class1 (p2group_abelian pP).\nhave pPq: p.-group (P / 'Z(P)) by apply: quotient_pgroup.\nrewrite -(subnKC e_gt2) ltnS (leq_trans (IHc _ _ _ pPq)) //.\n  by rewrite nil_class_quotient_center ?def_c.\nrewrite geq_max /= -add1n -leq_subLR -subn1 -subnDA -subSS leq_sub2r //.\nrewrite ltn_log_quotient //= -(setIidPr sZP) meet_center_nil //.\nby rewrite -nil_class0 def_c.\nQed."
}
{
  "statement": "Lemma Frattini_arg H P : G <| H -> p.-Sylow(G) P -> G * 'N_H(P) = H.\n",
  "proof": "Proof.\ncase/andP=> sGH nGH sylP; rewrite -normC ?subIset ?nGH ?orbT // -astab1JG.\nmove/subgroup_transitiveP: Syl_trans => ->; rewrite ?inE //.\napply/imsetP; exists P; rewrite ?inE //.\napply/eqP; rewrite eqEsubset -{1}((atransP Syl_trans) P) ?inE // imsetS //=.\nby apply/subsetP=> _ /imsetP[x Hx ->]; rewrite inE -(normsP nGH x Hx) pHallJ2.\nQed."
}
{
  "statement": "Lemma perm_iotaP {s t : seq T} x0 (It := iota 0 (size t)) :\n  reflect (exists2 Is, perm_eq Is It & s = map (nth x0 t) Is) (perm_eq s t).\n",
  "proof": "Proof.\napply: (iffP idP) => [Est | [Is eqIst ->]]; last first.\n  by rewrite -{2}[t](mkseq_nth x0) perm_map.\nelim: t => [|x t IHt] in s It Est *.\n  by rewrite (perm_small_eq _ Est) //; exists [::].\nhave /rot_to[k s1 Ds]: x \\in s by rewrite (perm_mem Est) mem_head.\nhave [|Is1 eqIst1 Ds1] := IHt s1; first by rewrite -(perm_cons x) -Ds perm_rot.\nexists (rotr k (0 :: map succn Is1)).\n  by rewrite perm_rot /It /= perm_cons (iotaDl 1) perm_map.\nby rewrite map_rotr /= -map_comp -(@eq_map _ _ (nth x0 t)) // -Ds1 -Ds rotK.\nQed."
}
{
  "statement": "Lemma mx_abs_irr_cent_scalar :\n  mx_absolutely_irreducible -> forall A, centgmx rG A -> is_scalar_mx A.\n",
  "proof": "Proof.\ncase/mx_abs_irrP=> n_gt0 [a_ a_G] A /centgmxP cGA.\nhave{cGA a_G} cMA B: A *m B = B *m A.\n  rewrite {}[B]a_G mulmx_suml mulmx_sumr.\n  by apply: eq_bigr => x Gx; rewrite -scalemxAl -scalemxAr cGA.\npose i0 := Ordinal n_gt0; apply/is_scalar_mxP; exists (A i0 i0).\napply/matrixP=> i j; move/matrixP/(_ i0 j): (esym (cMA (delta_mx i0 i))).\nrewrite -[A *m _]trmxK trmx_mul trmx_delta -!(@mul_delta_mx _ n 1 n 0) -!mulmxA.\nby rewrite -!rowE !mxE !big_ord1 !mxE !eqxx !mulr_natl /= andbT eq_sym.\nQed."
}
{
  "statement": "Lemma consttM pi x y : commute x y -> (x * y).`_pi = x.`_pi * y.`_pi.\n",
  "proof": "Proof.\nmove=> cxy; pose m := #|<<[set x; y]>>|; have m_gt0: 0 < m := cardG_gt0 _.\npose k := chinese m`_pi m`_pi^' 1 0.\nsuffices kXpi z: z \\in <<[set x; y]>> -> z.`_pi = z ^+ k.\n  by rewrite !kXpi ?expgMn // ?groupM ?mem_gen // !inE eqxx ?orbT.\nmove=> xyz; have{xyz} zm: #[z] %| m by rewrite cardSg ?cycle_subG.\napply/eqP; rewrite eq_expg_mod_order -{3 4}[#[z]](partnC pi) //.\nrewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC //.\nrewrite -!(modn_dvdm k (partn_dvd _ m_gt0 zm)).\nrewrite chinese_modl ?chinese_modr ?coprime_partC //.\nby rewrite !modn_dvdm ?partn_dvd ?eqxx.\nQed."
}
{
  "statement": "Lemma minnormal_maxnormal G L M :\n  M <| G -> L \\subset 'N(M) -> minnormal (G / M) (L / M) -> maxnormal M G L.\n",
  "proof": "Proof.\ncase/andP=> sMG nMG nML /mingroupP[/andP[/= ntGM _] minGM]; apply/maxgroupP.\nsplit=> [|H /andP[/andP[sHG ltHG] nHL] sMH].\n  by rewrite /proper sMG nML andbT; apply: contra ntGM => /quotientS1 ->.\napply/eqP; rewrite eqEsubset sMH andbT -quotient_sub1 ?(subset_trans sHG) //.\nrewrite subG1; apply: contraR ltHG => ntHM; rewrite -(quotientSGK nMG) //.\nby rewrite (minGM (H / M)%G) ?quotientS // ntHM quotient_norms.\nQed."
}
{
  "statement": "Lemma perm_big_supp_cond [r s : seq I] [P : pred I] (F : I -> R) :\n  perm_eq\n    [seq i <- r | P i && (F i != idx)]\n    [seq i <- s | P i && (F i != idx)] ->\n  \\big[op/idx]_(i <- r | P i) F i = \\big[op/idx]_(i <- s | P i) F i.\n",
  "proof": "Proof.\nmove=> prs; rewrite !(bigID [pred i | F i == idx] P F)/=.\nrewrite big1 ?Monoid.mul1m; last by move=> i /andP[_ /eqP->].\nrewrite [in RHS]big1 ?Monoid.mul1m; last by move=> i /andP[_ /eqP->].\nby rewrite -[in LHS]big_filter -[in RHS]big_filter; apply perm_big.\nQed."
}
{
  "statement": "Lemma pi_CD (x y : C) : reflect (pi x = pi y) (eC x y).\n",
  "proof": "Proof.\napply: (iffP idP) => hxy.\n  apply: (can_inj ereprK); unlock pi canon => /=.\n  rewrite -(@eq_choose _ (eC x) (eC y)); last first.\n    by move=> z; rewrite /eC /=; apply: equiv_ltrans.\n  by apply: choose_id; rewrite ?equiv_refl //.\nrewrite (equiv_trans (chooseP (equiv_refl _ _))) //=.\nmove: hxy => /(f_equal erepr) /=; unlock pi canon => /= ->.\nby rewrite equiv_sym /= chooseP.\nQed."
}
{
  "statement": "Lemma prev_next : cancel (next p) (prev p).\n",
  "proof": "Proof.\nmove=> x; rewrite prev_nth mem_next next_nth; case p_x: (x \\in p) => //.\ncase Dp: p Up p_x => // [y q]; rewrite [uniq _]/= -Dp => /andP[q'y Uq] p_x.\nrewrite -[RHS](nth_index y p_x); congr (nth y _ _); set i := index x p.\nhave: i <= size q by rewrite -index_mem -/i Dp in p_x.\ncase: ltngtP => // [lt_i_q|->] _; first by rewrite index_uniq.\nby apply/eqP; rewrite nth_default // eqn_leq index_size leqNgt index_mem.\nQed."
}
{
  "statement": "Lemma cfIndIsom phi : 'Ind[R] (cfIsom isoH phi) = cfIsom isoG ('Ind[G] phi).\n",
  "proof": "Proof.\nhave [[injg defR] [_ defS]] := (isomP isoG, isomP isoH).\nrewrite morphimEdom (eq_in_imset eq_hg) -morphimEsub // in defS.\napply/cfun_inP=> s; rewrite -{1}defR => /morphimP[x _ Gx ->]{s}.\nrewrite cfIsomE ?cfIndE // -defR -{1}defS ?morphimS ?card_injm // morphimEdom.\ncongr (_ * _); rewrite big_imset //=; last exact/injmP.\napply: eq_bigr => y Gy; rewrite -morphJ //.\nhave [Hxy | H'xy] := boolP (x ^ y \\in H); first by rewrite -eq_hg ?cfIsomE.\nby rewrite !cfun0 -?defS // -sub1set -morphim_set1 ?injmSK ?sub1set // groupJ.\nQed."
}
{
  "statement": "Lemma sdpair_setact (G : {set rT}) a : G \\subset R -> a \\in D ->\n  sdpair1 @* (to^~ a @: G) = (sdpair1 @* G) :^ sdpair2 a.\n",
  "proof": "Proof.\nmove=> sGR Da; have GtoR := subsetP sGR; apply/eqP.\nrewrite eqEcard cardJg !(card_injm injm_sdpair1) //; last first.\n  by apply/subsetP=> _ /imsetP[x Gx ->]; rewrite gact_stable ?GtoR.\nrewrite (card_imset _ (act_inj _ _)) leqnn andbT.\napply/subsetP=> _ /morphimP[xa Rxa /imsetP[x Gx def_xa ->]].\nrewrite mem_conjg -morphV // -sdpair_act ?groupV // def_xa actKin //.\nby rewrite mem_morphim ?GtoR.\nQed."
}
{
  "statement": "Lemma dvdn_pfactor p d n : prime p ->\n  reflect (exists2 m, m <= n & d = p ^ m) (d %| p ^ n).\n",
  "proof": "Proof.\nmove=> p_pr; have pn_gt0: p ^ n > 0 by rewrite expn_gt0 prime_gt0.\napply: (iffP idP) => [dv_d_pn|[m le_m_n ->]]; last first.\n  by rewrite -(subnK le_m_n) expnD dvdn_mull.\nexists (logn p d); first by rewrite -(pfactorK n p_pr) dvdn_leq_log.\nhave d_gt0: d > 0 by apply: dvdn_gt0 dv_d_pn.\ncase: (pfactor_coprime p_pr d_gt0) => q co_p_q def_d.\nrewrite [LHS]def_d ((q =P 1) _) ?mul1n // -dvdn1.\nsuff: q %| p ^ n * 1 by rewrite Gauss_dvdr // coprime_sym coprimeXl.\nby rewrite muln1 (dvdn_trans _ dv_d_pn) // def_d dvdn_mulr.\nQed."
}
{
  "statement": "Lemma cent_mx_scalar_abs_irr : \\rank Hom_G <= 1 -> mx_absolutely_irreducible rG.\n",
  "proof": "Proof.\nrewrite leqNgt => /(has_non_scalar_mxP (scalar_mx_cent _ _)) scal_cE.\napply/andP; split; first by case/mx_irrP: irrG.\nrewrite -sub1mx; apply: submx_trans mx_Jacobson_density.\napply/memmx_subP=> B _; apply/cent_mxP=> A cGA.\ncase scalA: (is_scalar_mx A); last by case: scal_cE; exists A; rewrite ?scalA.\nby case/is_scalar_mxP: scalA => a ->; rewrite scalar_mxC.\nQed."
}
{
  "statement": "Lemma eqmxMunitP m n (U V : 'M_(m, n)) :\n  reflect (exists2 P, P \\in unitmx & U = P *m V) (U == V)%MS.\n",
  "proof": "Proof.\napply: (iffP eqmxP) => [eqUV | [P Punit ->]]; last first.\n  by apply/eqmxMfull; rewrite row_full_unit.\nhave [D defU]: exists D, U = D *m V by apply/submxP; rewrite eqUV.\nhave{eqUV} [Pt Pt_unit defUt]: {Pt | Pt \\in unitmx & V^T *m D^T = V^T *m Pt}.\n  by apply/complete_unitmx; rewrite -trmx_mul -defU !mxrank_tr eqUV.\nby exists Pt^T; last apply/trmx_inj; rewrite ?unitmx_tr // defU !trmx_mul trmxK.\nQed."
}
{
  "statement": "Lemma col'Kr m n1 n2 j2 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) :\n  col' (rshift n1 j2) (@row_mx m n1 n2 A1 A2)\n    = castmx (erefl m, mx'_cast n1 j2) (row_mx A1 (col' j2 A2)).\n",
  "proof": "Proof.\napply/matrixP=> i j; symmetry; rewrite castmxE mxE cast_ord_id.\ncase: splitP => j' /= def_j.\n  rewrite mxE -(row_mxEl _ A2); congr (row_mx _ _ _); apply: ord_inj.\n  by rewrite /= def_j /bump leqNgt ltn_addr.\nrewrite 2!mxE -(row_mxEr A1); congr (row_mx _ _ _ _); apply: ord_inj.\nby rewrite /= def_j /bump leq_add2l addnCA.\nQed."
}
{
  "statement": "Lemma mx_rsim_abs_irr n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :\n    mx_rsim rG1 rG2 ->\n  mx_absolutely_irreducible rG1 = mx_absolutely_irreducible rG2.\n",
  "proof": "Proof.\ncase=> f def_n2; rewrite -{n2}def_n2 in f rG2 *.\nrewrite row_free_unit => injf homf; congr (_ && (_ == _)).\npose Eg (g : 'M[F]_n1) := lin_mx (mulmxr (invmx g) \\o mulmx g).\nhave free_Ef: row_free (Eg f).\n  apply/row_freeP; exists (Eg (invmx f)); apply/row_matrixP=> i.\n  rewrite rowE row1 mulmxA mul_rV_lin mx_rV_lin /=.\n  by rewrite invmxK !{1}mulmxA mulmxKV // -mulmxA mulKmx // vec_mxK.\nsymmetry; rewrite -(mxrankMfree _ free_Ef); congr (\\rank _).\napply/row_matrixP=> i; rewrite row_mul !rowK mul_vec_lin /=.\nby rewrite -homf ?enum_valP // mulmxK.\nQed."
}
{
  "statement": "Lemma telescope_big (f : nat -> nat -> R) (n m : nat) :\n  (forall k, n < k < m -> op (f n k) (f k k.+1) = f n k.+1) ->\n  \\big[op/idx]_(n <= i < m) f i i.+1 = if n < m then f n m else idx.\n",
  "proof": "Proof.\nelim: m => [//| m IHm]; first by rewrite ltn0 big_geq.\nmove=> tm; rewrite ltnS; case: ltnP=> // mn; first by rewrite big_geq.\nrewrite big_nat_recr// IHm//; last first.\n  by move=> k /andP[nk /ltnW nm]; rewrite tm// nk.\nby case: ltngtP mn=> //= [nm|<-]; rewrite ?mul1m// tm// nm leqnn.\nQed."
}
{
  "statement": "Lemma pairwise_eq : antisymmetric r ->\n  forall xs ys, pairwise r xs -> pairwise r ys -> perm_eq xs ys -> xs = ys.\n",
  "proof": "Proof.\nmove=> r_asym; elim=> [|x xs IHxs] [|y ys] //=; try by move=> ? ? /perm_size.\nmove=> /andP [r_x_xs pxs] /andP [r_y_ys pys] eq_xs_ys.\nmove: (mem_head y ys) (mem_head x xs).\nrewrite -(perm_mem eq_xs_ys) [x \\in _](perm_mem eq_xs_ys) !inE.\ncase: eqVneq eq_xs_ys => /= [->|ne_xy] eq_xs_ys ys_x xs_y.\n  by rewrite (IHxs ys) // -(perm_cons x).\nby case/eqP: ne_xy; apply: r_asym; rewrite (allP r_x_xs) ?(allP r_y_ys).\nQed."
}
{
  "statement": "Lemma enumP : Finite.axiom enum.\n",
  "proof": "Proof.\ncase=> /= t t_n; rewrite -(count_map _ (pred1 t)) (pmap_filter (insubK _)).\nrewrite count_filter -(@eq_count _ (pred1 t)) => [|s /=]; last first.\n  by rewrite isSome_insub; case: eqP=> // ->.\nelim: n t t_n => [|m IHm] [|x t] //= {}/IHm; move: (iter m _ _) => em IHm.\ntransitivity (x \\in T : nat); rewrite // -mem_enum codomE.\nelim: (fintype.enum T) (enum_uniq T) => //= y e IHe /andP[/negPf ney].\nrewrite count_cat count_map inE /preim /= [in LHS]/eq_op /= eq_sym => /IHe->.\nby case: eqP => [->|_]; rewrite ?(ney, count_pred0, IHm).\nQed."
}
{
  "statement": "Lemma morph_afix : h @: 'Fix_(S | to1)(A) = 'Fix_(h @: S | to2)(f @* A).\n",
  "proof": "Proof.\napply/setP=> hu; apply/imsetP/setIP=> [[u /setIP[Su cAu] ->]|].\n  split; first by rewrite imset_f.\n  by apply/afixP=> _ /morphimP[x D1x Ax ->]; rewrite -hfJ ?(afixP cAu).\ncase=> /imsetP[u Su ->] /afixP c_hu_fA; exists u; rewrite // inE Su.\napply/afixP=> x Ax; have Dx := subsetP sAD1 x Ax.\nby apply: injh; rewrite ?actsDR ?(subsetP sSR) ?hfJ // c_hu_fA ?mem_morphim.\nQed."
}
{
  "statement": "Lemma cfExp_prime_transitive G (i j : Iirr G) :\n    prime #|G| -> i != 0 -> j != 0 ->\n  exists2 k, coprime k #['chi_i]%CF & 'chi_j = 'chi_i ^+ k.\n",
  "proof": "Proof.\nset p := #|G| => pr_p nz_i nz_j; have cycG := prime_cyclic pr_p.\nhave [L [h [injh oL Lh h_ontoL]] [h1 hM hX _ o_h]] := lin_char_group G.\nrewrite (derG1P (cyclic_abelian cycG)) indexg1 -/p in oL.\nhave /fin_all_exists[h' h'K] := h_ontoL _ (irr_cyclic_lin _ cycG).\nhave o_h' k: k != 0 -> #[h' k] = p.\n  rewrite -cforder_irr_eq1 h'K -o_h => nt_h'k.\n  by apply/prime_nt_dvdP=> //; rewrite cforder_lin_char_dvdG.\nhave{oL} genL k: k != 0 -> generator [set: L] (h' k).\n  move=> /o_h' o_h'k; rewrite /generator eq_sym eqEcard subsetT /=.\n  by rewrite cardsT oL -o_h'k.\nhave [/(_ =P <[_]>)-> gen_j] := (genL i nz_i, genL j nz_j).\nhave /cycleP[k Dj] := cycle_generator gen_j.\nby rewrite !h'K Dj o_h hX generator_coprime coprime_sym in gen_j *; exists k.\nQed."
}
{
  "statement": "Lemma stable_rowg_mxK (L : {group rVn}) :\n  [acts setT, on L | 'Zm] -> rowg (rowg_mx L) = L.\n",
  "proof": "Proof.\nmove=> linL; apply/eqP; rewrite eqEsubset sub_rowg_mx andbT.\napply/subsetP=> v; rewrite inE genmxE => /submxP[u ->{v}].\nrewrite mulmx_sum_row group_prod // => i _.\nrewrite rowK; move: (enum_val i) (enum_valP i) => v Lv.\nhave [->|] := eqVneq (u 0 i) 0; first by rewrite scale0r group1.\nby rewrite -unitfE => aP; rewrite ((actsP linL) (FinRing.Unit aP)) ?inE.\nQed."
}
{
  "statement": "Lemma cfkerEchar chi :\n  chi \\is a character -> cfker chi = [set x in G | chi x == chi 1%g].\n",
  "proof": "Proof.\nmove=> Nchi; apply/setP=> x; apply/idP/setIdP=> [Kx | [Gx /eqP chi_x]].\n  by rewrite (subsetP (cfker_sub chi)) // cfker1.\ncase/char_reprP: Nchi => rG -> in chi_x *; rewrite inE Gx; apply/forallP=> y.\nrewrite !cfunE groupMl // !mulrb; case: ifP => // Gy.\nby rewrite repr_mxM // max_cfRepr_mx1 ?mul1mx.\nQed."
}
{
  "statement": "Lemma extend_cfConjC_subset S X phi :\n    cfConjC_closed S -> ~~ has cfReal S -> phi \\in S -> phi \\notin X ->\n  cfConjC_subset X S -> cfConjC_subset [:: phi, phi^* & X]%CF S.\n",
  "proof": "Proof.\nmove=> ccS nrS Sphi X'phi [uniqX /allP-sXS ccX].\nsplit; last 1 [by apply/allP; rewrite /= Sphi ccS | apply/allP]; rewrite /= inE.\n  by rewrite negb_or X'phi eq_sym (hasPn nrS) // (contra (ccX _)) ?cfConjCK.\nby rewrite cfConjCK !mem_head orbT; apply/allP=> xi Xxi; rewrite !inE ccX ?orbT.\nQed."
}
{
  "statement": "Lemma pairwise_sort s : pairwise leT s -> sort s = s.\n",
  "proof": "Proof.\npose catss := foldr (fun x => cat ^~ x) (Nil T).\nrewrite -{1 3}[s]/(catss [::] ++ s) sortE; elim: s [::] => /= [|x s ihs] ss.\n  elim: ss [::] => //= s ss ihss t; rewrite -catA => ssst.\n  rewrite -ihss ?allrel_merge //; move: ssst; rewrite !pairwise_cat.\n  by case/and4P.\nrewrite (catA _ [:: _]) => ssxs.\nsuff x_ss_E: catss (merge_sort_push [:: x] ss) = catss ([:: x] :: ss).\n  by rewrite -[catss _ ++ _]/(catss ([:: x] :: ss)) -x_ss_E ihs // x_ss_E.\nmove: ssxs; rewrite pairwise_cat => /and3P [_ + _].\nelim: ss [:: x] => {x s ihs} //= -[|x s] ss ihss t h_pairwise;\n  rewrite /= cats0 // allrel_merge ?ihss ?catA //.\nby move: h_pairwise; rewrite -catA !pairwise_cat => /and4P [].\nQed."
}
{
  "statement": "Lemma morph_astab : f @* 'C(S | to1) = 'C(h @: S | to2).\n",
  "proof": "Proof.\napply/setP=> fx; apply/morphimP/idP=> [[x D1x cSx ->] | cSx].\n  rewrite 2!inE -{1}defD2 mem_morphim //=; apply/subsetP=> _ /imsetP[u Su ->].\n  by rewrite inE -hfJ // (astab_act cSx).\nhave [|x D1x _ def_fx] := morphimP (_ : fx \\in f @* D1).\n  by rewrite defD2 (astab_dom cSx).\nexists x => //; rewrite !inE D1x; apply/subsetP=> u Su.\nrewrite inE -(inj_in_eq injh) ?actsDR ?(subsetP sSR) ?hfJ //.\nby rewrite -def_fx (astab_act cSx) ?imset_f.\nQed."
}
{
  "statement": "Lemma ffunP (f1 f2 : fT) : (forall x, f1 x = f2 x) <-> f1 = f2.\n",
  "proof": "Proof.\nsuffices ffunK f g: (forall x, f x = g x) -> f = finfun g.\n  by split=> [/ffunK|] -> //; apply/esym/ffunK.\ncase: f => f Dg; rewrite unlock; congr FinfunOf.\nhave{} Dg x (aTx : mem_seq (enum aT) x): g x = fun_of_fin_rec f aTx.\n  by rewrite -Dg /= (bool_irrelevance (mem_enum _ _) aTx).\nelim: (enum aT) / f (enum_uniq aT) => //= x1 s y f IHf /andP[s'x1 Us] in Dg *.\nrewrite Dg ?eqxx //=; case: eqP => // /eq_axiomK-> /= _.\nrewrite {}IHf // => x s_x; rewrite Dg ?s_x ?orbT //.\nby case: eqP (memPn s'x1 x s_x) => // _ _ /(bool_irrelevance s_x) <-.\nQed."
}
{
  "statement": "Lemma simple_Alt_3 (T : finType) : #|T| = 3 -> simple 'Alt_T.\n",
  "proof": "Proof.\nmove=> T3; have{T3} oA: #|'Alt_T| = 3.\n  by apply: double_inj; rewrite -mul2n card_Alt T3.\napply/simpleP; split=> [|K]; [by rewrite trivg_card1 oA | case/andP=> sKH _].\nhave:= cardSg sKH; rewrite oA dvdn_divisors // !inE orbC /= -oA.\ncase/pred2P=> eqK; [right | left]; apply/eqP.\n  by rewrite eqEcard sKH eqK leqnn.\nby rewrite eq_sym eqEcard sub1G eqK cards1.\nQed."
}
{
  "statement": "Lemma mxminpoly_linear_is_scalar : (d <= 1) = is_scalar_mx A.\n",
  "proof": "Proof.\nhave scalP := has_non_scalar_mxP minpoly_mx1.\nrewrite leqNgt -(eqnP minpoly_mx_free); apply/scalP/idP=> [|[[B]]].\n  case scalA: (is_scalar_mx A); [by right | left].\n  by exists A; rewrite ?scalA // -{1}(horner_mx_X A) horner_mx_mem.\nmove/mx_inv_hornerK=> <- nsB; case/is_scalar_mxP=> a defA; case/negP: nsB.\nmove: {B}(_ B); apply: poly_ind => [|p c].\n  by rewrite rmorph0 ?mx0_is_scalar.\nrewrite rmorphD ?rmorphM /= horner_mx_X defA; case/is_scalar_mxP=> b ->.\nby rewrite -rmorphM horner_mx_C -rmorphD /= scalar_mx_is_scalar.\nQed."
}
{
  "statement": "Lemma prim_root_pcharF p : (p %| n)%N -> p \\in [pchar R] = false.\n",
  "proof": "Proof.\nmove=> pn; apply: contraTF isT => pchar_p; have p_prime := pcharf_prime pchar_p.\nhave /dvdnP[[|k] n_eq_kp] := pn; first by rewrite n_eq_kp in (n_gt0).\nhave /eqP := prim_expr_order prim_z; rewrite n_eq_kp exprM.\nrewrite -pFrobenius_autE -(pFrobenius_aut1 pchar_p) -subr_eq0 -rmorphB/=.\nrewrite pFrobenius_autE expf_eq0// prime_gt0//= subr_eq0 => /eqP.\nmove=> /eqP; rewrite -(prim_order_dvd prim_z) n_eq_kp.\nrewrite -[X in _ %| X]muln1 dvdn_pmul2l ?dvdn1// => /eqP peq1.\nby rewrite peq1 in p_prime.\nQed."
}
{
  "statement": "Lemma trivg_Mho G : 'Mho^n(G) == 1 -> 'Ohm_n(G) == G.\n",
  "proof": "Proof.\nrewrite -subG1 gen_subG eqEsubset Ohm_sub /= => Gp1.\nrewrite -{1}(Sylow_gen G) genS //; apply/bigcupsP=> P.\ncase/SylowP=> p p_pr /and3P[sPG pP _]; apply/subsetP=> x Px.\nhave Gx := subsetP sPG x Px; rewrite inE Gx //=.\nrewrite (sameP eqP set1P) (subsetP Gp1) ?mem_gen //; apply: imset_f.\nby rewrite inE Gx; apply: pgroup_p (mem_p_elt pP Px).\nQed."
}
{
  "statement": "Lemma injm_Frobenius_compl H sGD injf : \n  [Frobenius G with complement H] -> [Frobenius f @* G with complement f @* H].\n",
  "proof": "Proof.\ncase/andP=> neqGH /normedTI_P[nzH /subsetIP[sHG _] tiHG].\nhave sHD := subset_trans sHG sGD; have sH1D := subset_trans (subD1set H 1) sHD.\napply/andP; rewrite (can_in_eq (injmK injf)) //; split=> //.\napply/normedTI_P; rewrite normD1 -injmD1 // -!cards_eq0 card_injm // in nzH *.\nrewrite subsetI normG morphimS //; split=> // _ /morphimP[x Dx Gx ->] ti'fHx.\nrewrite mem_morphim ?tiHG //; apply: contra ti'fHx; rewrite -!setI_eq0 => tiHx.\nby rewrite -morphimJ // -injmI ?conj_subG // (eqP tiHx) morphim0.\nQed."
}
{
  "statement": "Lemma tallyE s : perm_eq (tally s) [seq (x, count_mem x s) | x <- undup s].\n",
  "proof": "Proof.\nhave /andP[Ubs _] := tallyP s; pose b := [fun s x => (x, count_mem x (tseq s))].\nsuffices /permPl->: perm_eq (tally s) (map (b (tally s)) (unzip1 (tally s))).\n  congr perm_eq: (perm_map (b (tally s)) (tallyEl s)).\n  by under eq_map do rewrite /= (permP (tallyK s)).\nelim: (tally s) Ubs => [|[x m] bs IH] //= /andP[bs'x /IH-IHbs {IH}].\nrewrite /tseq /= -/(tseq _) count_cat count_nseq /= eqxx mul1n.\nrewrite (count_memPn _) ?addn0 ?perm_cons; last first.\n  apply: contra bs'x; elim: {b IHbs}bs => //= b bs IHbs.\n  by rewrite mem_cat mem_nseq inE andbC; case: (_ == _).\ncongr perm_eq: IHbs; apply/eq_in_map=> y bs_y; congr (y, _).\nby rewrite count_cat count_nseq /= (negPf (memPnC bs'x y bs_y)).\nQed."
}
{
  "statement": "Lemma orderXpnat m n x : #[x ^+ m] = n -> \\pi(n).-nat m -> #[x] = (m * n)%N.\n",
  "proof": "Proof.\nmove=> oxm n_m; have [m_gt0 _] := andP n_m.\nsuffices m_x: m %| #[x] by rewrite -oxm orderXdiv // mulnC divnK.\napply/dvdn_partP=> // p; rewrite mem_primes => /and3P[p_pr _ p_m].\nhave n_p: p \\in \\pi(n) by apply: (pnatP _ _ n_m).\nhave p_oxm: p %| #[x ^+ (p ^ logn p m)].\n  apply: dvdn_trans (orderXdvd _ m`_p^'); rewrite -expgM -p_part ?partnC //.\n  by rewrite oxm; rewrite mem_primes in n_p; case/and3P: n_p.\nby rewrite (orderXpfactor (erefl _) p_pr p_oxm) p_part // dvdn_mulr.\nQed."
}
{
  "statement": "Lemma allpairs_uniq_dep f s t (st := [seq Tagged T y | x <- s, y <- t x]) :\n  let g (p : {x : S & T x}) : R := f (tag p) (tagged p) in\n    uniq s -> {in s, forall x, uniq (t x)} -> {in st &, injective g} ->\n  uniq [seq f x y | x <- s, y <- t x].\n",
  "proof": "Proof.\nmove=> g Us Ut; rewrite -(map_allpairs g (existT T)) => /map_inj_in_uniq->{f g}.\nelim: s Us => //= x s IHs /andP[s'x Us] in st Ut *; rewrite {st}cat_uniq.\nrewrite {}IHs {Us}// ?andbT => [|x1 s_s1]; last exact/Ut/mem_behead.\nhave injT: injective (existT T x) by move=> y z /eqP; rewrite eq_Tagged => /eqP.\nrewrite (map_inj_in_uniq (in2W injT)) {injT}Ut ?mem_head // has_sym has_map.\nby apply: contra s'x => /hasP[y _ /allpairsPdep[z [_ [? _ /(congr1 tag)/=->]]]].\nQed."
}
{
  "statement": "Lemma gacentEsd : 'C_(|to)(A) = sdpair1 @*^-1 'C(sdpair2 @* A).\n",
  "proof": "Proof.\napply/setP=> x; apply/idP/idP.\n  case/setIP=> Rx /afixP cDAx; rewrite mem_morphpre //.\n  apply/centP=> _ /morphimP[a Da Aa ->]; red.\n  by rewrite conjgC -sdpair_act // cDAx // inE Da.\ncase/morphpreP=> Rx cAx; rewrite inE Rx; apply/afixP=> a /setIP[Da Aa].\napply: (injmP injm_sdpair1); rewrite ?gact_stable /= ?sdpair_act //=.\nby rewrite /conjg (centP cAx) ?mulKg ?mem_morphim.\nQed."
}
{
  "statement": "Lemma nexpIrz n (n0 : n != 0) : {in <= 0 &, injective ((@exprz R)^~ n)}.\n",
  "proof": "Proof.\nmove=> x y; rewrite ![_ \\in _]le_eqVlt => /predU1P [-> _ /eqP|hx].\n  by rewrite exp0rz ?(negPf n0) eq_sym expfz_eq0=> /andP [_ /eqP->].\ncase/predU1P=> [-> /eqP|hy].\n  by rewrite exp0rz ?(negPf n0) expfz_eq0=> /andP [_ /eqP].\nmove=> /(f_equal ( *%R^~ (y ^ (- n)))) /eqP.\nrewrite -expfzDr ?(lt_eqF hy) // subrr expr0z -exprz_inv -expfzMl.\nrewrite pexprz_eq1 ?(negPf n0) /= ?mulr_le0 ?invr_le0 ?ltW //.\nby rewrite (can2_eq (mulrVK _) (mulrK _)) ?unitfE ?(lt_eqF hy) // mul1r=> /eqP.\nQed."
}
{
  "statement": "Lemma card_isog8_extraspecial (gT : finGroupType) (G : {group gT}) :\n  #|G| = 8 -> extraspecial G -> (G \\isog 'D_8) || (G \\isog 'Q_8).\n",
  "proof": "Proof.\nmove=> oG esG; have pG: 2.-group G by rewrite /pgroup oG.\napply/norP=> [[notG_D8 notG_Q8]].\nhave not_extG: extremal_class G = NotExtremal.\n  by rewrite /extremal_class oG andFb (negPf notG_D8) (negPf notG_Q8).\nhave [x Gx ox] := exponent_witness (pgroup_nil pG).\npose X := <[x]>; have cycX: cyclic X := cycle_cyclic x.\nhave sXG: X \\subset G by rewrite cycle_subG.\nhave iXG: #|G : X| = 2.\n  by rewrite -divgS // oG -orderE -ox exponent_2extraspecial.\nhave not_cGG := extraspecial_nonabelian esG.\nhave:= maximal_cycle_extremal pG not_cGG cycX sXG iXG.\nby rewrite /extremal2 not_extG.\nQed."
}
{
  "statement": "Lemma next_prev : cancel (prev p) (next p).\n",
  "proof": "Proof.\nmove=> x; rewrite next_nth mem_prev prev_nth; case p_x: (x \\in p) => //.\ncase def_p: p p_x => // [y q]; rewrite -def_p => p_x.\nrewrite index_uniq //; last by rewrite def_p ltnS index_size.\ncase q_x: (x \\in q); first exact: nth_index.\nrewrite nth_default; last by rewrite leqNgt index_mem q_x.\nby apply/eqP; rewrite def_p inE q_x orbF eq_sym in p_x.\nQed."
}
{
  "statement": "Lemma MhoEabelian p G :\n  p.-group G -> abelian G -> 'Mho^n(G) = [set x ^+ (p ^ n) | x in G].\n",
  "proof": "Proof.\nmove=> pG cGG; rewrite (MhoE pG); rewrite gen_set_id //; apply/group_setP.\nsplit=> [|xn yn]; first by apply/imsetP; exists 1; rewrite ?expg1n.\ncase/imsetP=> x Gx ->; case/imsetP=> y Gy ->.\nby rewrite -expgMn; [apply: imset_f; rewrite groupM | apply: (centsP cGG)].\nQed."
}
{
  "statement": "Lemma pexpIrz n (n0 : n != 0) : {in >= 0 &, injective ((@exprz R)^~ n)}.\n",
  "proof": "Proof.\nmove=> x y; rewrite ![_ \\in _]le0r=> /predU1P [-> _ /eqP|hx].\n  by rewrite exp0rz ?(negPf n0) eq_sym expfz_eq0=> /andP [_ /eqP->].\ncase/predU1P=> [-> /eqP|hy].\n  by rewrite exp0rz ?(negPf n0) expfz_eq0=> /andP [_ /eqP].\nmove=> /(f_equal ( *%R^~ (y ^ (- n)))) /eqP.\nrewrite -expfzDr ?(gt_eqF hy) // subrr expr0z -exprz_inv -expfzMl.\nrewrite pexprz_eq1 ?(negPf n0) /= ?mulr_ge0 ?invr_ge0 ?ltW //.\nby rewrite (can2_eq (mulrVK _) (mulrK _)) ?unitfE ?(gt_eqF hy) // mul1r=> /eqP.\nQed."
}
{
  "statement": "Lemma leEtprod n T (t1 t2 : n.-tuple T) :\n   t1 <= t2 = [forall i, tnth t1 i <= tnth t2 i].\n",
  "proof": "Proof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= lexx; symmetry; apply/forallP => [].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ <= _]le_cons [t1 <= t2 :> seq _]IHn.\napply/idP/forallP => [/andP[lex12 /forallP/= let12 i]|lext12].\n  by case: (unliftP ord0 i) => [j ->|->]//; rewrite !tnthS.\nrewrite (lext12 ord0)/=; apply/forallP=> i.\nby have := lext12 (lift ord0 i); rewrite !tnthS.\nQed."
}
{
  "statement": "Lemma homo_ltn_in (D : {pred nat}) (f : nat -> T) (r : T -> T -> Prop) :\n  (forall y x z, r x y -> r y z -> r x z) ->\n  {in D &, forall i j k, i < k < j -> k \\in D} ->\n  {in D, forall i, i.+1 \\in D -> r (f i) (f i.+1)} ->\n  {in D &, {homo f : i j / i < j >-> r i j}}.\n",
  "proof": "Proof.\nmove=> r_trans Dcx r_incr i j iD jD lt_ij; move: (lt_ij) (jD) => /subnKC<-.\nelim: (_ - _) => [|k ihk]; first by rewrite addn0 => Dsi; apply: r_incr.\nmove=> DSiSk [: DSik]; apply: (r_trans _ _ _ (ihk _)); rewrite ?addnS.\n  by abstract: DSik; apply: (Dcx _ _ iD DSiSk); rewrite ltn_addr ?addnS /=.\nby apply: r_incr; rewrite -?addnS.\nQed."
}
{
  "statement": "Lemma merge_stable_path x s1 s2 :\n  allrel leT' s1 s2 -> path leT_lex x s1 -> path leT_lex x s2 ->\n  path leT_lex x (merge s1 s2).\n",
  "proof": "Proof.\nelim: s1 s2 x => //= x s1 ih1; elim => //= y s2 ih2 h.\nrewrite allrel_cons2 => /and4P [xy' xs2 ys1 s1s2] /andP [hx xs1] /andP [hy ys2].\ncase: ifP => xy /=; rewrite (hx, hy) /=.\n- by apply: ih1; rewrite ?allrel_consr ?ys1 //= xy xy' implybT.\n- by apply: ih2; have:= leT_total x y; rewrite ?allrel_consl ?xs2 ?xy //= => ->.\nQed."
}
{
  "statement": "Lemma FittingEgen G :\n  'F(G) = <<\\bigcup_(p < #|G|.+1 | (p : nat) \\in \\pi(G)) 'O_p(G)>>.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset gen_subG /=.\nrewrite -{1}(bigdprodWY (erefl 'F(G))) (big_nth 0) big_mkord genS.\n  by apply/bigcupsP=> p _; rewrite -p_core_Fitting pcore_sub.\napply/bigcupsP=> [[i /= lti]] _; set p := nth _ _ i.\nhave pi_p: p \\in \\pi(G) by rewrite mem_nth.\nhave p_dv_G: p %| #|G| by rewrite mem_primes in pi_p; case/and3P: pi_p.\nhave lepG: p < #|G|.+1 by rewrite ltnS dvdn_leq.\nby rewrite (bigcup_max (Ordinal lepG)).\nQed."
}
{
  "statement": "Lemma simple_sol_prime G : solvable G -> simple G -> prime #|G|.\n",
  "proof": "Proof.\nmove=> solG /simpleP[ntG simG].\nhave{solG} cGG: abelian G.\n  apply/commG1P; case/simG: (der_normal 1 G) => // /eqP/idPn[].\n  by rewrite proper_neq // (sol_der1_proper solG).\ncase: (trivgVpdiv G) ntG => [-> | [p p_pr]]; first by rewrite eqxx.\ncase/Cauchy=> // x Gx oxp _; move: p_pr; rewrite -oxp orderE.\nhave: <[x]> <| G by rewrite -sub_abelian_normal ?cycle_subG.\nby case/simG=> -> //; rewrite cards1.\nQed."
}
{
  "statement": "Lemma eqmx_col {m} (V_ : forall i, 'M[F]_(p_ i, m)) :\n  (\\mxcol_i V_ i :=: \\sum_i <<V_ i>>)%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split.\n  apply/row_subP => i; rewrite row_mxcol.\n  by rewrite (sumsmx_sup (sig1 i))// genmxE row_sub.\napply/sumsmx_subP => i0 _; rewrite genmxE; apply/row_subP => j.\napply: (eq_row_sub (Rank _ j)); apply/rowP => k.\nby rewrite !mxE Rank2K; case: _ / esym; rewrite cast_ord_id.\nQed."
}
{
  "statement": "Lemma cfDprod_eq1 phi psi :\n    phi \\is a character -> psi \\is a character ->\n  (cfDprod KxH phi psi == 1) = (phi == 1) && (psi == 1).\n",
  "proof": "Proof.\nmove=> /Cnat_char1 Nphi /Cnat_char1 Npsi.\napply/eqP/andP=> [phi_psi_1 | [/eqP-> /eqP->]]; last by rewrite cfDprod_cfun1.\nhave /andP[/eqP phi1 /eqP psi1]: (phi 1%g == 1) && (psi 1%g == 1).\n  by rewrite -natr_mul_eq1 // -(cfDprod1 KxH) phi_psi_1 cfun11.\nrewrite -[phi](cfDprodKl KxH psi1) -{2}[psi](cfDprodKr KxH phi1) phi_psi_1.\nby rewrite !rmorph1.\nQed."
}
{
  "statement": "Lemma eqseq_pivotl x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s2 ->\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\n",
  "proof": "Proof.\nmove=> xNs1 xNs2; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\nrewrite -(@eqseq_pivot2l x)//; have /eqP/(congr1 (count_mem x)) := E.\nrewrite !count_cat/= eqxx !addnS (count_memPn _ _ xNs1) (count_memPn _ _ xNs2).\nby move=> -[/esym/eqP]; rewrite addn_eq0 => /andP[/eqP/count_memPn].\nQed."
}
{
  "statement": "Lemma dinjectiveP D : reflect {in D &, injective f} (dinjectiveb D).\n",
  "proof": "Proof.\nrewrite -[dinjectiveb D]negbK.\ncase: dinjectivePn=> [noinjf | injf]; constructor.\n  case: noinjf => x Dx [y /andP[neqxy /= Dy] eqfxy] injf.\n  by case/eqP: neqxy; apply: injf.\nmove=> x y Dx Dy /= eqfxy; apply/eqP; apply/idPn=> nxy; case: injf.\nby exists x => //; exists y => //=; rewrite inE /= eq_sym nxy.\nQed."
}
{
  "statement": "Lemma directv_add_unique {U V} :\n   reflect (forall u1 u2 v1 v2, u1 \\in U -> u2 \\in U -> v1 \\in V -> v2 \\in V ->\n             (u1 + v1 == u2 + v2) = ((u1, v1) == (u2, v2)))\n           (directv (U + V)).\n",
  "proof": "Proof.\napply: (iffP directv_addP) => [dxUV u1 u2 v1 v2 Uu1 Uu2 Vv1 Vv2 | dxUV].\n  apply/idP/idP=> [| /eqP[-> ->] //]; rewrite -subr_eq0 opprD addrACA addr_eq0.\n  move/eqP=> eq_uv; rewrite xpair_eqE -subr_eq0 eq_uv oppr_eq0 subr_eq0 andbb.\n  by rewrite -subr_eq0 -memv0 -dxUV memv_cap -memvN -eq_uv !memvB.\napply/eqP; rewrite -subv0; apply/subvP=> v /memv_capP[U1v U2v].\nby rewrite memv0 -[v == 0]andbb {1}eq_sym -xpair_eqE -dxUV ?mem0v // addrC.\nQed."
}
{
  "statement": "Lemma dprod_Iirr_onto k : k \\in codom dprod_Iirr.\n",
  "proof": "Proof.\nset D := codom _; have Df: dprod_Iirr _ \\in D := codom_f dprod_Iirr _.\nhave: 'chi_k 1%g ^+ 2 != 0 by rewrite mulf_neq0 ?irr1_neq0.\napply: contraR => notDk; move/eqP: (irr_sum_square G).\nrewrite (bigID [in D]) (reindex _ (bij_on_codom dprod_Iirr_inj (0, 0))) /=.\nhave ->: #|G|%:R = \\sum_i \\sum_j 'chi_(dprod_Iirr (i, j)) 1%g ^+ 2.\n  rewrite -(dprod_card KxH) natrM.\n  do 2![rewrite -irr_sum_square (mulr_suml, mulr_sumr); apply: eq_bigr => ? _].\n  by rewrite dprod_IirrE -exprMn -{3}(mulg1 1%g) cfDprodE.\nrewrite (eq_bigl _ _ Df) pair_bigA addrC -subr_eq0 addrK.\nby move/eqP/psumr_eq0P=> -> //= i _; rewrite irr1_degree -natrX ler0n.\nQed."
}
{
  "statement": "Lemma cap_cfcenter_irr : \\bigcap_i 'Z('chi[G]_i)%CF = 'Z(G).\n",
  "proof": "Proof.\napply/esym/eqP; rewrite eqEsubset (introT bigcapsP) /= => [|i _]; last first.\n  rewrite -(quotientSGK _ (normal_sub (cfker_center_normal _))).\n    by rewrite cfcenter_eq_center morphim_center.\n  by rewrite subIset // normal_norm // cfker_normal.\nset Z := \\bigcap_i _.\nhave sZG: Z \\subset G by rewrite (bigcap_min 0) ?cfcenter_sub.\nrewrite subsetI sZG (sameP commG1P trivgP) -(TI_cfker_irr G).\napply/bigcapsP=> i _; have nKiG := normal_norm (cfker_normal 'chi_i).\nrewrite -quotient_cents2 ?(subset_trans sZG) //.\nrewrite (subset_trans (quotientS _ (bigcap_inf i _))) //.\nby rewrite cfcenter_eq_center subsetIr.\nQed."
}
{
  "statement": "Lemma exists_acomps K : exists s, acomps K s.\n",
  "proof": "Proof.\nelim: {K} #|K| {1 3}K (leqnn #|K|) => [K | n Hi K cK].\n  by rewrite leqNgt cardG_gt0.\ncase/orP: (orbN (asimple K)) => [sK | nsK].\n  by exists [:: (1%G : {group rT})]; rewrite /acomps eqxx /= andbT.\ncase/orP: (orbN (K :==: 1))=> [tK | ntK].\n  by exists (Nil _); rewrite /acomps /= andbT.\ncase: (maxainv_exists ntK)=> N pmN.\nhave cN: #|N| <= n.\n  by rewrite -ltnS (leq_trans _ cK) // proper_card // (maxainv_proper pmN).\ncase: (Hi _ cN)=> s; case/andP=> lasts ps; exists [:: N & s]; rewrite /acomps.\nby rewrite last_cons lasts /= pmN.\nQed."
}
{
  "statement": "Lemma subseq_rem x : {homo rem x : s1 s2 / @subseq T s1 s2}.\n",
  "proof": "Proof.\nmove=> s1 s2; elim: s2 s1 => [|x2 s2 IHs2] [|x1 s1]; rewrite ?sub0seq //=.\nhave [->|_] := eqVneq x1 x2; first by case: eqP => //= _ /IHs2; rewrite eqxx.\nmove=> /IHs2/subseq_trans->//.\nby have [->|_] := eqVneq x x2; [apply: rem_subseq|apply: subseq_cons].\nQed."
}
{
  "statement": "Lemma ker_conj_aut : 'ker conj_aut = 'C(G).\n",
  "proof": "Proof.\napply/setP=> x /[1!inE]; case nGx: (x \\in 'N(G)); last first.\n  by symmetry; apply/idP=> cGx; rewrite (subsetP (cent_sub G)) in nGx.\nrewrite 2!inE /=; apply/eqP/centP=> [cx1 y Gy | cGx].\n  by rewrite /commute (conjgC y) -norm_conj_autE // cx1 perm1.\napply/permP=> y; case Gy: (y \\in G); last by rewrite !permE Gy.\nby rewrite perm1 norm_conj_autE // conjgE -cGx ?mulKg.\nQed."
}
{
  "statement": "Lemma card_geqP {A n} :\n  reflect (exists s, [/\\ uniq s, size s = n & {subset s <= A}]) (n <= #|A|).\n",
  "proof": "Proof.\napply: (iffP idP) => [n_le_A|[s] [uniq_s size_s /subsetP subA]]; last first.\n  by rewrite -size_s -(card_uniqP _ uniq_s); exact: subset_leq_card.\nexists (take n (enum A)); rewrite take_uniq ?enum_uniq // size_take.\nsplit => //; last by move => x /mem_take; rewrite mem_enum.\ncase: (ltnP n (size (enum A))) => // size_A.\nby apply/eqP; rewrite eqn_leq size_A -cardE n_le_A.\nQed."
}
{
  "statement": "Lemma logn_fact p n : prime p -> logn p n`! = \\sum_(1 <= k < n.+1) n %/ p ^ k.\n",
  "proof": "Proof.\nmove=> p_prime; transitivity (\\sum_(1 <= i < n.+1) logn p i).\n  rewrite big_add1; elim: n => /= [|n IHn]; first by rewrite logn1 big_geq.\n  by rewrite big_nat_recr // -IHn /= factS mulnC lognM ?fact_gt0.\ntransitivity (\\sum_(1 <= i < n.+1) \\sum_(1 <= k < n.+1) (p ^ k %| i)).\n  apply: eq_big_nat => i /andP[i_gt0 le_i_n]; rewrite logn_count_dvd //.\n  rewrite -!big_mkcond (big_nat_widen _ _ n.+1) 1?ltnW //; apply: eq_bigl => k.\n  by apply: andb_idr => /dvdn_leq/(leq_trans (ltn_expl _ (prime_gt1 _)))->.\nby rewrite exchange_big_nat; apply: eq_bigr => i _; rewrite divn_count_dvd.\nQed."
}
{
  "statement": "Lemma cfker_dprod phi psi :\n  cfker phi <*> cfker psi \\subset cfker (cfDprod phi psi).\n",
  "proof": "Proof.\nrewrite -genM_join gen_subG; apply/subsetP=> _ /mulsgP[x y kKx kHy ->] /=.\nhave [[Kx _] [Hy _]] := (setIdP kKx, setIdP kHy).\nhave Gxy: (x * y)%g \\in G by rewrite -(dprodW KxH) mem_mulg.\nrewrite inE Gxy; apply/forallP=> g.\nhave [Gg | G'g] := boolP (g \\in G); last by rewrite !cfun0 1?groupMl.\nhave{g Gg} [k [h [Kk Hh -> _]]] := mem_dprod KxH Gg.\nrewrite mulgA -(mulgA x) (centsP cKH y) // mulgA -mulgA !cfDprodE ?groupM //.\nby rewrite !cfkerMl.\nQed."
}
{
  "statement": "Lemma exponent_Ohm1_class2 H :\n  odd p -> p.-group H -> nil_class H <= 2 -> exponent 'Ohm_1(H) %| p.\n",
  "proof": "Proof.\nmove=> odd_p pH; rewrite nil_class2 => sH'Z; apply/exponentP=> x /=.\nrewrite (OhmE 1 pH) expn1 gen_set_id => {x} [/LdivP[] //|].\napply/group_setP; split=> [|x y]; first by rewrite !inE group1 expg1n //=.\ncase/LdivP=> Hx xp1 /LdivP[Hy yp1]; rewrite !inE groupM //=.\nhave [_ czH]: [~ y, x] \\in H /\\ centralises [~ y, x] H.\n  by apply/centerP; rewrite (subsetP sH'Z) ?mem_commg.\nrewrite expMg_Rmul ?xp1 ?yp1 /commute ?czH //= !mul1g.\nby rewrite bin2odd // -commXXg ?yp1 /commute ?czH // comm1g.\nQed."
}
{
  "statement": "Lemma Aut_prime_cycle_cyclic (a : gT) : prime #[a] -> cyclic (Aut <[a]>).\n",
  "proof": "Proof.\nmove=> pr_a; have inj_um := injm_Zp_unitm a.\nhave /eq_S/eq_S eq_a := Fp_Zcast pr_a.\npose fm := cast_ord (esym eq_a) \\o val \\o invm inj_um.\napply: (@field_mul_group_cyclic _ _ _ fm) => [f g Af Ag | f Af] /=.\n  by apply: val_inj; rewrite /= morphM ?im_Zp_unitm //= eq_a.\nsplit=> [/= fm1 |->]; last by apply: val_inj; rewrite /= morph1.\napply: (injm1 (injm_invm inj_um)); first by rewrite /= im_Zp_unitm.\nby do 2!apply: val_inj; move/(congr1 val): fm1.\nQed."
}
{
  "statement": "Lemma pcore_sub_astab_irr G M :\n    p.-group M -> M \\subset R -> acts_irreducibly G M to ->\n  'O_p(G) \\subset 'C_G(M | to).\n",
  "proof": "Proof.\nmove=> pM sMR /mingroupP[/andP[ntM nMG] minM].\nhave /andP[sGpG nGpG]: 'O_p(G) <| G := gFnormal _ G.\nhave sGD := acts_dom nMG; have sGpD: 'O_p(G) \\subset D := gFsub_trans _ sGD.\nrewrite subsetI sGpG -gacentC //=; apply/setIidPl; apply: minM (subsetIl _ _).\nrewrite nontrivial_gacent_pgroup ?pcore_pgroup //=; last first.\n  by split; rewrite ?gFsub_trans.\nby apply: subset_trans (acts_subnorm_subgacent sGpD nMG); rewrite subsetI subxx.\nQed."
}
{
  "statement": "Lemma irr_sorted_eq : irreflexive leT ->\n  forall s1 s2, sorted s1 -> sorted s2 -> s1 =i s2 -> s1 = s2.\n",
  "proof": "Proof.\nmove=> leT_irr s1 s2 s1_sort s2_sort eq_s12.\nhave: antisymmetric leT.\n  by move=> m n /andP[? ltnm]; case/idP: (leT_irr m); apply: leT_tr ltnm.\nby move/sorted_eq; apply=> //; apply: uniq_perm => //; apply: sorted_uniq.\nQed."
}
{
  "statement": "Theorem orthomx_spectralP {n} {A : 'M[C]_n}\n  (P := spectralmx A) (sp := spectral_diag A) :\n  reflect (A = invmx P *m diag_mx sp *m P) (A \\is normalmx).\n",
  "proof": "Proof.\nrewrite /P /sp /spectralmx /spectral_diag.\ncase: orthomx_spectral_subproof.\n  by move=> Psp; case: sig2_eqW => //=; constructor.\nmove=> /orthomx_spectral_subproof Ann; constructor; apply/eqP.\napply: contra Ann; rewrite invmx1 mul1mx mulmx1 => /eqP->.\nsuff -> : diag_mx 0 = 0 by rewrite qualifE trmx0 (map_mx0 conjC).\nby move=> ? ?; apply/matrixP=> i j; rewrite !mxE mul0rn.\nQed."
}
{
  "statement": "Lemma gcdp_map p q : (gcdp p q)^f = gcdp p^f q^f.\n",
  "proof": "Proof.\nwlog lt_p_q: p q / size p < size q.\n  move=> IHpq; case: (ltnP (size p) (size q)) => [|le_q_p]; first exact: IHpq.\n  rewrite gcdpE (gcdpE p^f) !size_map_poly ltnNge le_q_p /= -map_modp.\n  have [-> | q_nz] := eqVneq q 0; first by rewrite rmorph0 !gcdp0.\n  by rewrite IHpq ?ltn_modp.\nhave [m le_q_m] := ubnP (size q); elim: m => // m IHm in p q lt_p_q le_q_m *.\nrewrite gcdpE (gcdpE p^f) !size_map_poly lt_p_q -map_modp.\nhave [-> | q_nz] := eqVneq p 0; first by rewrite rmorph0 !gcdp0.\nby rewrite IHm ?(leq_trans lt_p_q) ?ltn_modp.\nQed."
}
{
  "statement": "Lemma rcosets_cycle_transversal : H_g_rcosets @: X = HGg.\n",
  "proof": "Proof.\nhave sHXgHGg x: x \\in X -> H_g_rcosets x \\in HGg.\n  by move/sXG=> Gx; apply: imset_f; rewrite -rcosetE imset_f.\napply/setP=> Hxg; apply/imsetP/idP=> [[x /sHXgHGg HGgHxg -> //] | HGgHxg].\nhave [_ /rcosetsP[z Gz ->] ->] := imsetP HGgHxg.\npose Hzg := H :* z * <[g]>; pose x := transversal_repr 1 X Hzg.\nhave HGgHzg: Hzg \\in HG :* <[g]>.\n  by rewrite mem_mulg ?set11 // -rcosetE imset_f.\nhave Hzg_x: x \\in Hzg by rewrite (repr_mem_pblock trX).\nexists x; first by rewrite (repr_mem_transversal trX).\ncase/mulsgP: Hzg_x => y u /rcoset_eqP <- /(orbit_act 'Rs) <- -> /=.\nby rewrite rcosetE -rcosetM.\nQed."
}
{
  "statement": "Lemma astab_rowg_repr m (A : 'M_(m, n)) : 'C(rowg A | 'MR rG) = rstab rG A.\n",
  "proof": "Proof.\napply/setP=> x /[!inE]/=; apply: andb_id2l => Gx.\napply/subsetP/eqP=> cAx => [|u]; last first.\n  by rewrite !inE mx_repr_actE // => /submxP[u' ->]; rewrite -mulmxA cAx.\napply/row_matrixP=> i; apply/eqP; move/implyP: (cAx (row i A)).\nby rewrite !inE row_sub mx_repr_actE //= row_mul.\nQed."
}
{
  "statement": "Lemma restrict_aut_to_num_field (nu : {rmorphism algC -> algC}) :\n    (forall x, exists y, nu (QnC x) = QnC y) ->\n  {nu0 : {lrmorphism Qn -> Qn} | {morph QnC : x / nu0 x >-> nu x}}.\n",
  "proof": "Proof.\nmove=> Qn_nu; pose nu0 x := sval (sig_eqW (Qn_nu x)).\nhave QnC_nu0: {morph QnC : x / nu0 x >-> nu x}.\n  by rewrite /nu0 => x; case: (sig_eqW _).\nhave nu0a : additive nu0.\n  by move=> x y; apply: (fmorph_inj QnC); rewrite !(QnC_nu0, rmorphB).\nhave nu0m : multiplicative nu0.\n  split=> [x y|]; apply: (fmorph_inj QnC); rewrite ?QnC_nu0 ?rmorph1 //.\n  by rewrite !rmorphM /= !QnC_nu0.\npose nu0aM := GRing.isAdditive.Build Qn Qn nu0 nu0a.\npose nu0mM := GRing.isMultiplicative.Build Qn Qn nu0 nu0m.\npose nu0RM : {rmorphism _ -> _} := HB.pack nu0 nu0aM nu0mM.\npose nu0lM := GRing.isScalable.Build rat Qn Qn *:%R nu0 (fmorph_numZ nu0RM).\npose nu0LRM : {lrmorphism _ -> _} := HB.pack nu0 nu0aM nu0mM nu0lM.\nby exists nu0LRM.\nQed."
}
{
  "statement": "Lemma leif_pprod (I : finType) (P C : pred I) (E1 E2 : I -> R) :\n    (forall i, P i -> 0 <= E1 i) ->\n    (forall i, P i -> E1 i <= E2 i ?= iff C i) ->\n  let pi E := \\prod_(i | P i) E i in\n  pi E1 <= pi E2 ?= iff (pi E2 == 0) || [forall (i | P i), C i].\n",
  "proof": "Proof.\nmove=> E1_ge0 leE12 /=; rewrite -big_andE; elim/(big_load (fun x => 0 <= x)): _.\nelim/big_rec3: _ => [|i Ci m2 m1 Pi [m1ge0 le_m12]].\n  by split=> //; apply/leifP; rewrite orbT.\nhave Ei_ge0 := E1_ge0 i Pi; split; first by rewrite mulr_ge0.\ncongr (leif _ _ _): (leif_pM Ei_ge0 m1ge0 (leE12 i Pi) le_m12).\nby rewrite mulf_eq0 -!orbA; congr (_ || _); rewrite !orb_andr orbA orbb.\nQed."
}
{
  "statement": "Lemma logn_Gauss p m n : coprime p m -> logn p (m * n) = logn p n.\n",
  "proof": "Proof.\nmove=> co_pm; case p_pr: (prime p); last by rewrite /logn p_pr.\nhave [-> | n_gt0] := posnP n; first by rewrite muln0.\nhave [m0 | m_gt0] := posnP m; first by rewrite m0 prime_coprime ?dvdn0 in co_pm.\nhave mn_gt0: m * n > 0 by rewrite muln_gt0 m_gt0.\napply/eqP; rewrite eqn_leq andbC dvdn_leq_log ?dvdn_mull //.\nset k := logn p _; have: p ^ k %| m * n by rewrite pfactor_dvdn.\nby rewrite Gauss_dvdr ?coprimeXl // -pfactor_dvdn.\nQed."
}
{
  "statement": "Lemma codiagonalizablePfull n (As : seq 'M[F]_n) :\n  codiagonalizable As <-> exists m,\n    exists2 P : 'M_(m, n), row_full P & all [pred A | similar_diag P A] As.\n",
  "proof": "Proof.\nsplit => [[P Punit SPA]|[m [P Pfull SPA]]].\n  by exists n => //; exists P; rewrite ?row_full_unit.\nhave Qfull := fullrowsub_unit Pfull.\nexists (rowsub (fullrankfun Pfull) P) => //; apply/allP => A AAs/=.\nhave /allP /(_ _ AAs)/= /similar_diagPex[d /similarPp] := SPA.\nrewrite submx_full// => /(_ isT) PA_eq.\napply/similar_diagPex; exists (colsub (fullrankfun Pfull) d).\napply/similarP => //; apply/row_matrixP => i.\nrewrite !row_mul row_diag_mx -scalemxAl -rowE !row_rowsub !mxE.\nhave /(congr1 (row (fullrankfun Pfull i))) := PA_eq.\nby rewrite !row_mul row_diag_mx -scalemxAl -rowE => ->.\nQed."
}
{
  "statement": "Lemma Wedderburn_is_id_pchar i : mxring_id 'R_i 'e_i.\n",
  "proof": "Proof.\nhave ideRi A: (A \\in 'R_i)%MS -> 'e_i *m A = A.\n  move=> RiA; rewrite -{2}[A]mul1mx -Wedderburn_sum_id_pchar mulmx_suml.\n  rewrite (bigD1 i) //= big1 ?addr0 // => j ne_ji.\n  by rewrite (Wedderburn_mulmx0 ne_ji) ?Wedderburn_id_mem.\n  split=> // [||A RiA]; first 2 [exact: Wedderburn_id_mem].\n  apply: contraNneq (nz_socle i) => e0.\n  apply/rowV0P=> v; rewrite -mem_gring_mx -(genmxE (i *m _)) => /ideRi.\n  by rewrite e0 mul0mx => /(canLR gring_mxK); rewrite linear0.\nrewrite -{2}[A]mulmx1 -Wedderburn_sum_id_pchar mulmx_sumr (bigD1 i) //=.\nrewrite big1 ?addr0 // => j; rewrite eq_sym => ne_ij.\nby rewrite (Wedderburn_mulmx0 ne_ij) ?Wedderburn_id_mem.\nQed."
}
{
  "statement": "Lemma uniq_subseq_pivot x (s1 s2 s3 s4 : seq T) (s := s3 ++ x :: s4) :\n  uniq s -> subseq (s1 ++ x :: s2) s = (subseq s1 s3 && subseq s2 s4).\n",
  "proof": "Proof.\nmove=> uniq_s; apply/idP/idP => [sub_s'_s|/andP[? ?]]; last first.\n  by rewrite cat_subseq //= eqxx.\nhave uniq_s' := subseq_uniq sub_s'_s uniq_s.\nhave/eqP {sub_s'_s uniq_s} := subseq_uniqP _ uniq_s sub_s'_s.\nrewrite !filter_cat /= mem_cat inE eqxx orbT /=.\nrewrite uniq_eqseq_pivotl // => /andP [/eqP -> /eqP ->].\nby rewrite !filter_subseq.\nQed."
}
{
  "statement": "Lemma perm_prime_atrans : [transitive <[c]>, on setT | 'P].\n",
  "proof": "Proof.\napply/imsetP; suff /existsP[x] : [exists x, ~~ (#|orbit 'P <[c]> x| < #[c])].\n  move=> oxT; suff /eqP orbit_x : orbit 'P <[c]> x == setT by exists x.\n  by rewrite eqEcard subsetT cardsT -cc leqNgt.\napply/forallP => olT; have o1 x : #|orbit 'P <[c]> x| == 1%N.\n  by case/primeP: cp => _ /(_ _ (dvdn_orbit 'P _ x))/orP[]//; rewrite ltn_eqF.\nsuff c1 : c = 1%g by rewrite c1 ?order1 in (cp).\napply/permP => x; rewrite perm1; apply/set1P.\nby rewrite -(card_orbit1 (eqP (o1 _))) (mem_orbit 'P) ?cycle_id.\nQed."
}
{
  "statement": "Lemma cfker_morph phi : cfker (cfMorph phi) = G :&: f @*^-1 (cfker phi).\n",
  "proof": "Proof.\napply/setP=> x /[!inE]; apply: andb_id2l => Gx.\nhave Dx := subsetP sGD x Gx; rewrite Dx mem_morphim //=.\napply/forallP/forallP=> Kx y.\n  have [{y} /morphimP[y Dy Gy ->] | fG'y] := boolP (y \\in f @* G).\n    by rewrite -morphM // -!(cfMorphE phi) ?groupM.\n  by rewrite !cfun0 ?groupMl // mem_morphim.\nhave [Gy | G'y] := boolP (y \\in G); last by rewrite !cfun0 ?groupMl.\nby rewrite !cfMorphE ?groupM ?morphM // (subsetP sGD).\nQed."
}
{
  "statement": "Lemma morphim_dffunXn i H : dffun_morphism i @* setXn H = H i.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset morphimE setTI /=.\napply/andP; split; apply/subsetP=> x.\n  by case/imsetP => x0 /[1!inE] /forallP/(_ i)/= ? ->.\nmove=> Hx1; apply/imsetP; exists (dfung1 x); last by rewrite dfung1_id.\nby rewrite in_setXn; apply/forallP => j /[!ffunE]; case: dfwithP.\nQed."
}
{
  "statement": "Lemma orbit_transversalP G S (P := orbit to G @: S)\n                             (X := orbit_transversal G S) :\n  [acts G, on S | to] ->\n [/\\ is_transversal X P S, X \\subset S,\n     {in X &, forall x y, (y \\in orbit to G x) = (x == y)}\n   & forall x, x \\in S -> exists2 a, a \\in G & to x a \\in X].\n",
  "proof": "Proof.\nmove/orbit_partition; rewrite -/P => partP.\nhave [/eqP defS tiP _] := and3P partP.\nhave trXP: is_transversal X P S := transversalP partP.\nhave sXS: X \\subset S := transversal_sub trXP.\nsplit=> // [x y Xx Xy /= | x Sx].\n  have Sx := subsetP sXS x Xx.\n  rewrite -(inj_in_eq (pblock_inj trXP)) // eq_pblock ?defS //.\n  by rewrite (def_pblock tiP (imset_f _ Sx)) ?orbit_refl.\nhave /imsetP[y Xy defxG]: orbit to G x \\in pblock P @: X.\n  by rewrite (pblock_transversal trXP) ?imset_f.\nsuffices /orbitP[a Ga def_y]: y \\in orbit to G x by exists a; rewrite ?def_y.\nby rewrite defxG mem_pblock defS (subsetP sXS).\nQed."
}
{
  "statement": "Lemma linear_of_free (rT : lmodType K) X (fX : seq rT) :\n  {f : {linear vT -> rT} | free X -> size fX = size X -> map f X = fX}.\n",
  "proof": "Proof.\npose f u := \\sum_i coord (in_tuple X) i u *: fX`_i.\nhave lin_f: linear f.\n  move=> k u v; rewrite scaler_sumr -big_split; apply: eq_bigr => i _.\n  by rewrite /= scalerA -scalerDl linearP.\npose flM := GRing.isLinear.Build _ _ _ _ f lin_f.\npose fL : {linear _ -> _} := HB.pack f flM.\nexists fL => freeX eq_szX.\napply/esym/(@eq_from_nth _ 0); rewrite ?size_map eq_szX // => i ltiX.\nrewrite (nth_map 0) //= /f (bigD1 (Ordinal ltiX)) //=.\nrewrite big1 => [|j /negbTE neqji]; rewrite (coord_free (Ordinal _)) //.\n  by rewrite eqxx scale1r addr0.\nby rewrite eq_sym neqji scale0r.\nQed."
}
{
  "statement": "Lemma setX_dprod (H1 : {group gT1}) (H2 : {group gT2}) :\n  setX H1 1 \\x setX 1 H2 = setX H1 H2.\n",
  "proof": "Proof.\nrewrite dprodE ?setX_prod //.\n  apply/centsP=> [[x u]] /[!inE]/= /andP[/eqP-> _] [v y].\n  by rewrite !inE /= => /andP[_ /eqP->]; congr (_, _); rewrite ?mul1g ?mulg1.\napply/trivgP; apply/subsetP=> [[x y]]; rewrite !inE /= -!andbA.\nby case/and4P=> _ /eqP-> /eqP->; rewrite eqxx.\nQed."
}
{
  "statement": "Lemma astab_mod : 'C(S | mod_action) = 'C(S | to) / H.\n",
  "proof": "Proof.\napply/setP=> Ha; apply/idP/morphimP=> [cSa | [a nHa cSa ->]].\n  case/morphimP: (astab_dom cSa) => a nHa Da defHa.\n  exists a => //; rewrite !inE Da; apply/subsetP=> x Sx; rewrite !inE.\n  by rewrite -{2}[x](astab_act cSa) // defHa /= modactE ?(subsetP fixSH).\nhave Da := astab_dom cSa; rewrite !inE mem_quotient //; apply/subsetP=> x Sx.\nby rewrite !inE /= modactE ?(astab_act cSa) ?(subsetP fixSH).\nQed."
}
{
  "statement": "Lemma determinant_alternate n (A : 'M[R]_n) i1 i2 :\n  i1 != i2 -> A i1 =1 A i2 -> \\det A = 0.\n",
  "proof": "Proof.\nmove=> neq_i12 eqA12; pose t := tperm i1 i2.\nhave oddMt s: (t * s)%g = ~~ s :> bool by rewrite odd_permM odd_tperm neq_i12.\nrewrite [\\det A](bigID (@odd_perm _)) /=.\napply: canLR (subrK _) _; rewrite add0r -sumrN.\nrewrite (reindex_inj (mulgI t)); apply: eq_big => //= s.\nrewrite oddMt => /negPf->; rewrite mulN1r mul1r; congr (- _).\nrewrite (reindex_perm t); apply: eq_bigr => /= i _.\nby rewrite permM tpermK /t; case: tpermP => // ->; rewrite eqA12.\nQed."
}
{
  "statement": "Lemma normal_max_pgroup_Hall G H :\n  [max H | pi.-subgroup(G) H] -> H <| G -> pi.-Hall(G) H.\n",
  "proof": "Proof.\ncase/maxgroupP=> /andP[sHG piH] maxH nsHG; have [_ nHG] := andP nsHG.\nrewrite /pHall sHG piH; apply/pnatP=> // p p_pr.\nrewrite inE /= -pnatE // -card_quotient //.\ncase/Cauchy=> //= Hx; rewrite -sub1set -gen_subG -/<[Hx]> /order.\ncase/inv_quotientS=> //= K -> sHK sKG {Hx}.\nrewrite card_quotient ?(subset_trans sKG) // => iKH; apply/negP=> pi_p.\nrewrite -iKH -divgS // (maxH K) ?divnn ?cardG_gt0 // in p_pr.\nby rewrite /psubgroup sKG /pgroup -(Lagrange sHK) mulnC pnatM iKH pi_p.\nQed."
}
{
  "statement": "Lemma Sylow_transversal_gen (T : {set {group gT}}) G :\n    (forall P, P \\in T -> P \\subset G) ->\n    (forall p, p \\in \\pi(G) -> exists2 P, P \\in T & p.-Sylow(G) P) ->\n  << \\bigcup_(P in T) P >> = G.\n",
  "proof": "Proof.\nmove=> G_T T_G; apply/eqP; rewrite eqEcard gen_subG.\napply/andP; split; first exact/bigcupsP.\napply: dvdn_leq (cardG_gt0 _) _; apply/dvdn_partP=> // q /T_G[P T_P sylP].\nby rewrite -(card_Hall sylP); apply: cardSg; rewrite sub_gen // bigcup_sup.\nQed."
}
{
  "statement": "Lemma card_vspace (V : {vspace vT}) : #|V| = (#|F| ^ \\dim V)%N.\n",
  "proof": "Proof.\nset n := \\dim V; pose V2rV v := \\row_i coord (vbasis V) i v.\npose rV2V (rv : 'rV_n) := \\sum_i rv 0 i *: (vbasis V)`_i.\nhave rV2V_K: cancel rV2V V2rV.\n  have freeV: free (vbasis V) := basis_free (vbasisP V).\n  by move=> rv; apply/rowP=> i; rewrite mxE coord_sum_free.\nrewrite -[n]mul1n -card_mx -(card_imset _ (can_inj rV2V_K)).\napply: eq_card => v; apply/idP/imsetP=> [/coord_vbasis-> | [rv _ ->]].\n  by exists (V2rV v) => //; apply: eq_bigr => i _; rewrite mxE.\nby apply: (@rpred_sum vT) => i _; rewrite rpredZ ?vbasis_mem ?memt_nth.\nQed."
}
{
  "statement": "Lemma sub_dsumsmx :\n    mxdirect (\\sum_(i | P i) B i) -> (A <= \\sum_(i | P i) B i)%MS ->\n  sub_dsumsmx_spec.\n",
  "proof": "Proof.\nmove/mxdirect_sumsP=> dxB /sub_sumsmxP[u defA].\npose A_ i := u i *m B i.\nexists A_ => //= [i _ | C sCB defAC i Pi]; first exact: submxMl.\napply/eqP; rewrite -subr_eq0 -submx0 -{dxB}(dxB i Pi) /=.\nrewrite sub_capmx addmx_sub ?eqmx_opp ?submxMl ?sCB //=.\nrewrite -(subrK A (C i)) -addrA -opprB addmx_sub ?eqmx_opp //.\n  rewrite addrC defAC (bigD1 i) // addKr /= summx_sub // => j Pi'j.\n  by rewrite (sumsmx_sup j) ?sCB //; case/andP: Pi'j.\nrewrite addrC defA (bigD1 i) // addKr /= summx_sub // => j Pi'j.\nby rewrite (sumsmx_sup j) ?submxMl.\nQed."
}
{
  "statement": "Lemma der1_stab_Ohm1_SCN_series : ('C(Z) :&: 'C_G(A / Z | 'Q))^`(1) \\subset A.\n",
  "proof": "Proof.\ncase/SCN_P: SCN_A => /andP[sAG nAG] {4} <-.\nrewrite subsetI {1}setICA comm_subG ?subsetIl //= gen_subG.\napply/subsetP=> w /imset2P[u v].\nrewrite -groupV -(groupV _ v) /= astabQR //= -/Z !inE groupV.\ncase/and4P=> cZu _ _ sRuZ /and4P[cZv' _ _ sRvZ] ->{w}.\napply/centP=> a Aa; rewrite /commute -!mulgA (commgCV v) (mulgA u).\nrewrite (centP cZu); last by rewrite (subsetP sRvZ) ?mem_commg ?set11 ?groupV.\nrewrite 2!(mulgA v^-1) mulKVg 4!mulgA invgK (commgC u^-1) mulgA.\nrewrite -(mulgA _ _ v^-1) -(centP cZv') ?(subsetP sRuZ) ?mem_commg ?set11//.\nby rewrite -!mulgA invgK mulKVg !mulKg.\nQed."
}
{
  "statement": "Lemma exponent_mx_group m n q :\n  m > 0 -> n > 0 -> q > 1 -> exponent [set: 'M['Z_q]_(m, n)] = q.\n",
  "proof": "Proof.\nmove=> m_gt0 n_gt0 q_gt1; apply/eqP; rewrite eqn_dvd; apply/andP; split.\n  apply/exponentP=> x _; apply/matrixP=> i j; rewrite mulmxnE !mxE.\n  by rewrite -mulr_natr -Zp_nat_mod // modnn mulr0.\npose cmx1 := const_mx 1%R : 'M['Z_q]_(m, n).\napply: dvdn_trans (dvdn_exponent (in_setT cmx1)).\nhave/matrixP/(_ (Ordinal m_gt0))/(_ (Ordinal n_gt0))/eqP := expg_order cmx1.\nby rewrite mulmxnE !mxE -order_dvdn order_Zp1 Zp_cast.\nQed."
}
{
  "statement": "Lemma component_mx_isoP U V :\n    mxsimple U -> mxsimple V ->\n  reflect (mx_iso U V) (component_mx U == component_mx V).\n",
  "proof": "Proof.\nmove=> simU simV; apply: (iffP eqP) => isoUV.\n  by apply: component_mx_iso; rewrite ?isoUV ?component_mx_id.\nrewrite -(genmx_component U) -(genmx_component V); apply/genmxP.\nwlog suffices: U V simU simV isoUV / (component_mx U <= component_mx V)%MS.\n  by move=> IH; rewrite !IH //; apply: mx_iso_sym.\nhave [I [W isoWU ->]] := component_mx_def simU.\napply/sumsmx_subP => i _; apply: mx_iso_component => //.\nexact: mx_iso_trans (mx_iso_sym isoUV) (isoWU i).\nQed."
}
{
  "statement": "Lemma primeP p :\n  reflect (p > 1 /\\ forall d, d %| p -> xpred2 1 p d) (prime p).\n",
  "proof": "Proof.\nrewrite -[prime p]negbK; have [npr_p | pr_p] := primePn p.\n  right=> [[lt1p pr_p]]; case: npr_p => [|[d n1pd]].\n    by rewrite ltnNge lt1p.\n  by move/pr_p=> /orP[] /eqP def_d; rewrite def_d ltnn ?andbF in n1pd.\nhave [lep1 | lt1p] := leqP; first by case: pr_p; left.\nleft; split=> // d dv_d_p; apply/norP=> [[nd1 ndp]]; case: pr_p; right.\nexists d; rewrite // andbC 2!ltn_neqAle ndp eq_sym nd1.\nby have lt0p := ltnW lt1p; rewrite dvdn_leq // (dvdn_gt0 lt0p).\nQed."
}
{
  "statement": "Lemma cfker_Ind chi :\n    H \\subset G -> chi \\is a character -> chi != 0 ->\n  cfker ('Ind[G, H] chi) = gcore (cfker chi) G.\n",
  "proof": "Proof.\nmove=> sHG Nchi nzchi; rewrite !cfker_nzcharE ?cfInd_char ?cfInd_eq0 //.\napply/setP=> x; rewrite inE cfIndE // (can2_eq (mulVKf _) (mulKf _)) ?neq0CG //.\nrewrite cfInd1 // mulrA -natrM Lagrange // mulr_natl -sumr_const.\napply/eqP/bigcapP=> [/normC_sum_upper ker_chiG_x y Gy | ker_chiG_x].\n  by rewrite mem_conjg inE ker_chiG_x ?groupV // => z _; apply: char1_ge_norm.\nby apply: eq_bigr => y /groupVr/ker_chiG_x; rewrite mem_conjgV inE => /eqP.\nQed."
}
{
  "statement": "Lemma Fitting_max G H : H <| G -> nilpotent H -> H \\subset 'F(G).\n",
  "proof": "Proof.\nmove=> nsHG nilH; rewrite -(Sylow_gen H) gen_subG.\napply/bigcupsP=> P /SylowP[p _ sylP].\ncase Gp: (p \\in \\pi(G)); last first.\n  rewrite card1_trivg ?sub1G // (card_Hall sylP).\n  rewrite part_p'nat // (pnat_dvd (cardSg (normal_sub nsHG))) //.\n  by rewrite /pnat cardG_gt0 all_predC has_pred1 Gp.\nrewrite {P sylP}(nilpotent_Hall_pcore nilH sylP).\nrewrite -(bigdprodWY (erefl 'F(G))) sub_gen //.\nrewrite -(filter_pi_of (ltnSn _)) big_filter big_mkord.\napply: (bigcup_max (Sub p _)) => //= [|_].\n  by have:= Gp; rewrite ltnS mem_primes => /and3P[_ ntG /dvdn_leq->].\nby rewrite pcore_max ?pcore_pgroup ?gFnormal_trans.\nQed."
}
{
  "statement": "Lemma exchange_big_dep_idem I J rI rJ (P : pred I) (Q : I -> pred J)\n                       (xQ : pred J) F :\n    (forall i j, P i -> Q i j -> xQ j) ->\n  \\big[op/x]_(i <- rI | P i) \\big[op/x]_(j <- rJ | Q i j) F i j =\n    \\big[op/x]_(j <- rJ | xQ j) \\big[op/x]_(i <- rI | P i && Q i j) F i j.\n",
  "proof": "Proof.\nmove=> PQxQ; pose p u := (u.2, u.1).\nunder [LHS]eq_bigr do rewrite big_tnth; rewrite [LHS]big_tnth.\nunder [RHS]eq_bigr do rewrite big_tnth; rewrite [RHS]big_tnth.\nrewrite !pair_big_dep_idem (reindex_onto (p _ _) (p _ _)) => [|[]] //=.\napply: eq_big => [] [j i] //=; symmetry; rewrite eqxx andbT andb_idl //.\nby case/andP; apply: PQxQ.\nQed."
}
{
  "statement": "Lemma multiplicity_XsubC p a :\n  {m | exists2 q, (p != 0) ==> ~~ root q a & p = q * ('X - a%:P) ^+ m}.\n",
  "proof": "Proof.\nhave [n le_p_n] := ubnP (size p); elim: n => // n IHn in p le_p_n *.\nhave [-> | nz_p /=] := eqVneq p 0; first by exists 0, 0; rewrite ?mul0r.\nhave [/sig_eqW[p1 Dp] | nz_pa] := altP (factor_theorem p a); last first.\n  by exists 0%N, p; rewrite ?mulr1.\nhave nz_p1: p1 != 0 by apply: contraNneq nz_p => p1_0; rewrite Dp p1_0 mul0r.\nhave /IHn[m /sig2_eqW[q nz_qa Dp1]]: size p1 < n.\n  by rewrite Dp size_Mmonic ?monicXsubC // size_XsubC addn2 in le_p_n.\nby exists m.+1, q; [rewrite nz_p1 in nz_qa | rewrite exprSr mulrA -Dp1].\nQed."
}
{
  "statement": "Lemma set_set_nth s n1 y1 n2 y2 (s2 := set_nth s n2 y2) :\n  set_nth (set_nth s n1 y1) n2 y2 = if n1 == n2 then s2 else set_nth s2 n1 y1.\n",
  "proof": "Proof.\nhave [-> | ne_n12] := eqVneq.\n  apply: eq_from_nth => [|i _]; first by rewrite !size_set_nth maxnA maxnn.\n  by do 2!rewrite !nth_set_nth /=; case: eqP.\napply: eq_from_nth => [|i _]; first by rewrite !size_set_nth maxnCA.\nby do 2!rewrite !nth_set_nth /=; case: eqP => // ->; case: eqVneq ne_n12.\nQed."
}
{
  "statement": "Lemma gactsI (N1 N2 : {set rT}) :\n  [acts A, on N1 | to] -> [acts A, on N2 | to] -> [acts A, on N1 :&: N2 | to].\n",
  "proof": "Proof.\nmove=> aAN1 aAN2.\napply/subsetP=> x Ax; rewrite !inE Ax /=; apply/subsetP=> y Ny /[1!inE].\ncase/setIP: Ny=> N1y N2y; rewrite inE ?astabs_act  ?N1y ?N2y //.\n- by move/subsetP: aAN2; move/(_ x Ax).\n- by move/subsetP: aAN1; move/(_ x Ax).\nQed."
}
{
  "statement": "Lemma exponent_witness G : nilpotent G -> {x | x \\in G & exponent G = #[x]}.\n",
  "proof": "Proof.\nmove=> nilG; have [//=| /= x Gx max_x] := @arg_maxnP _ 1 [in G] order.\nexists x => //; apply/eqP; rewrite eqn_dvd dvdn_exponent // andbT.\napply/dvdn_biglcmP=> y Gy; apply/dvdn_partP=> //= p.\nrewrite mem_primes => /andP[p_pr _]; have p_gt1: p > 1 := prime_gt1 p_pr.\nrewrite p_part pfactor_dvdn // -(leq_exp2l _ _ p_gt1) -!p_part.\nrewrite -(leq_pmul2r (part_gt0 p^' #[x])) partnC // -!order_constt.\nrewrite -orderM ?order_constt ?coprime_partC // ?max_x ?groupM ?groupX //.\ncase/dprodP: (nilpotent_pcoreC p nilG) => _ _ cGpGp' _.\nhave inGp := mem_normal_Hall (nilpotent_pcore_Hall _ nilG) (pcore_normal _ _).\nby red; rewrite -(centsP cGpGp') // inGp ?p_elt_constt ?groupX.\nQed."
}
{
  "statement": "Lemma chief_series_exists H G :\n  H <| G -> {s | (G.-chief).-series 1%G s & last 1%G s = H}.\n",
  "proof": "Proof.\nhave [m] := ubnP #|H|; elim: m H => // m IHm U leUm nsUG.\nhave [-> | ntU] := eqVneq U 1%G; first by exists [::].\nhave [V maxV]: {V : {group gT} | maxnormal V U G}.\n  by apply: ex_maxgroup; exists 1%G; rewrite proper1G ntU norms1.\nhave /andP[ltVU nVG] := maxgroupp maxV.\nhave [||s ch_s defV] := IHm V; first exact: leq_trans (proper_card ltVU) _.\n  by rewrite /normal (subset_trans (proper_sub ltVU) (normal_sub nsUG)).\nexists (rcons s U); last by rewrite last_rcons.\nby rewrite rcons_path defV /= ch_s /chief_factor; apply/and3P.\nQed."
}
{
  "statement": "Lemma sum_by_classes (R : nzRingType) (F : gT -> R) :\n    {in G &, forall g h, F (g ^ h) = F g} ->\n  \\sum_(g in G) F g = \\sum_(xG in classes G) #|xG|%:R * F (repr xG).\n",
  "proof": "Proof.\nmove=> FJ; rewrite {1}(partition_big _  _ ((@mem_classes gT)^~ G)) /=.\napply: eq_bigr => _ /imsetP[x Gx ->]; have [y Gy ->] := repr_class G x.\nrewrite mulr_natl -sumr_const FJ {y Gy}//; apply/esym/eq_big=> y /=.\n  apply/idP/andP=> [xGy | [Gy /eqP<-]]; last exact: class_refl.\n  by rewrite (class_eqP xGy) (subsetP (class_subG Gx (subxx _))).\nby case/imsetP=> z Gz ->; rewrite FJ.\nQed."
}
{
  "statement": "Lemma num_spec_inv (i : Itv.t) (x : num_def R i) (r := Itv.real1 inv i) :\n  num_spec r (x%:num^-1).\n",
  "proof": "Proof.\napply: Itv.spec_real1 (Itv.P x).\ncase: x => x /= _ [l u] /and3P[xr /= lx xu].\nrewrite /Itv.num_sem/= realV xr/=; apply/andP; split.\n- apply: num_itv_bound_keep_pos lx.\n  + by move=> ?; rewrite invr_ge0.\n  + by move=> ?; rewrite invr_gt0.\n- apply: num_itv_bound_keep_neg xu.\n  + by move=> ?; rewrite invr_le0.\n  + by move=> ?; rewrite invr_lt0.\nQed."
}
{
  "statement": "Lemma gcdp_mull m n : gcdp n (m * n) %= n.\n",
  "proof": "Proof.\nhave [-> | nn0] := eqVneq n 0; first by rewrite gcd0p mulr0 eqpxx.\nhave [-> | mn0] := eqVneq m 0; first by rewrite mul0r gcdp0 eqpxx.\nrewrite gcdpE modp_mull gcd0p size_mul //; case: leqP; last by rewrite eqpxx.\nrewrite (polySpred mn0) addSn /= -[leqRHS]add0n leq_add2r -ltnS.\nrewrite -polySpred //= leq_eqVlt ltnS size_poly_leq0 (negPf mn0) orbF.\ncase/size_poly1P=> c cn0 -> {mn0 m}; rewrite mul_polyC.\nsuff -> : n %% (c *: n) = 0 by rewrite gcd0p; apply: eqp_scale.\nby apply/modp_eq0P; rewrite dvdpZl.\nQed."
}
{
  "statement": "Lemma cfun_complement A :\n  A <| G -> ('CF(G, A) + 'CF(G, G :\\: A)%SET = 'CF(G))%VS.\n",
  "proof": "Proof.\ncase/andP=> sAG nAG; rewrite -cfunGid [rhs in _ = rhs]cfun_on_sum.\nrewrite (bigID (fun B => B \\subset A)) /=.\ncongr (_ + _)%VS; rewrite cfun_on_sum; apply: eq_bigl => /= xG.\n  rewrite andbAC; apply/esym/andb_idr=> /andP[/imsetP[x Gx ->] _].\n  by rewrite class_subG.\nrewrite -andbA; apply: andb_id2l => /imsetP[x Gx ->].\nby rewrite !class_sub_norm ?normsD ?normG // inE andbC.\nQed."
}
{
  "statement": "Lemma morph_astabs : f @* 'N(S | to1) = 'N(h @: S | to2).\n",
  "proof": "Proof.\napply/setP=> fx; apply/morphimP/idP=> [[x D1x nSx ->] | nSx].\n  rewrite 2!inE -{1}defD2 mem_morphim //=; apply/subsetP=> _ /imsetP[u Su ->].\n  by rewrite inE -hfJ ?imset_f // (astabs_act _ nSx).\nhave [|x D1x _ def_fx] := morphimP (_ : fx \\in f @* D1).\n  by rewrite defD2 (astabs_dom nSx).\nexists x => //; rewrite !inE D1x; apply/subsetP=> u Su.\nhave /imsetP[u' Su' /injh def_u']: h (to1 u x) \\in h @: S.\n  by rewrite hfJ // -def_fx (astabs_act _ nSx) imset_f.\nby rewrite inE def_u' ?actsDR ?(subsetP sSR).\nQed."
}
{
  "statement": "Lemma actby_is_groupAction : is_groupAction G <[nGAg]>.\n",
  "proof": "Proof.\nmove=> a Aa; rewrite /= inE; apply/andP; split.\n  apply/subsetP=> x; apply: contraR => Gx.\n  by rewrite actpermE /= /actby (negbTE Gx).\napply/morphicP=> x y Gx Gy; rewrite !actpermE /= /actby Aa groupM ?Gx ?Gy //=.\nby case nGAg; move/acts_dom; do 2!move/subsetP=> ?; rewrite gactM; auto.\nQed."
}
{
  "statement": "Lemma row_unitarymxP m n {M : 'M[C]_(m, n)} :\n  reflect (forall i j, '[row i M, row j M] = (i == j)%:R) (M \\is unitarymx).\n",
  "proof": "Proof.\napply: (iffP eqP) => [Mo i j|Mo].\n  have /matrixP/(_ i j) := Mo; rewrite !mxE => <-.\n  by rewrite dotmxE !mxE; apply: eq_bigr => /= k _; rewrite !mxE.\napply/matrixP=> i j; rewrite !mxE; have := Mo i j; rewrite dotmxE !mxE => <-.\nby apply: eq_bigr => /= k _; rewrite !mxE.\nQed."
}
{
  "statement": "Lemma equivalence_partition_pblock P D :\n  partition P D -> equivalence_partition (fun x y => y \\in pblock P x) D = P.\n",
  "proof": "Proof.\ncase/and3P=> /eqP <-{D} tiP notP0; apply/setP=> B /=; set D := cover P.\nhave defP x: x \\in D -> [set y in D | y \\in pblock P x] = pblock P x.\n  by move=> Dx; apply/setIidPr; rewrite (bigcup_max (pblock P x)) ?pblock_mem.\napply/imsetP/idP=> [[x Px ->{B}] | PB]; first by rewrite defP ?pblock_mem.\nhave /set0Pn[x Bx]: B != set0 := memPn notP0 B PB.\nhave Px: x \\in cover P by apply/bigcupP; exists B.\nby exists x; rewrite // defP // (def_pblock tiP PB Bx).\nQed."
}
{
  "statement": "Lemma nil_class_injm G :\n  'injm f -> G \\subset D -> nil_class (f @* G) = nil_class G.\n",
  "proof": "Proof.\nmove=> injf sGD; case nilG: (nilpotent G).\n  apply/eqP; rewrite eqn_leq nil_class_morphim //.\n  rewrite (sameP (lcn_nil_classP _ nilG) eqP) -subG1.\n  rewrite -(injmSK injf) ?gFsub_trans // morphim1.\n  by rewrite morphim_lcn // (lcn_nil_classP _ _ (leqnn _)) //= injm_nil.\ntransitivity #|G|; apply/eqP; rewrite eqn_leq.\n  rewrite -(card_injm injf sGD) (leq_trans (index_size _ _)) ?size_mkseq //.\n  by rewrite leqNgt -nilpotent_class injm_nil ?nilG.\nrewrite (leq_trans (index_size _ _)) ?size_mkseq // leqNgt -nilpotent_class.\nby rewrite nilG.\nQed."
}
{
  "statement": "Lemma field_module_semisimple F M (m := \\dim_F M) :\n    (F * M <= M)%VS ->\n  {X : m.-tuple L | {subset X <= M} /\\ 0 \\notin X\n     & let FX := (\\sum_(i < m) F * <[X`_i]>)%VS in FX = M /\\ directv FX}.\n",
  "proof": "Proof.\nmove=> modM; have dimM: (m * \\dim F)%N = \\dim M by rewrite -dim_field_module.\nhave [X [defM dxFX nzX]] := skew_field_module_semisimple (@fieldP L) modM.\nhave szX: size X == m.\n  rewrite -(eqn_pmul2r (adim_gt0 F)) dimM -defM (directvP dxFX) /=.\n  rewrite -sum1_size big_distrl; apply/eqP/eq_big_seq => x Xx /=.\n  by rewrite mul1n dim_cosetv ?(memPn nzX).\nrewrite directvE /= (big_nth 0) [eqbRHS](big_nth 0) in defM dxFX.\nrewrite (eqP szX) !big_mkord -directvE in defM dxFX.\nexists (Tuple szX) => //; split=> // _ /tnthP[i ->]; rewrite (tnth_nth 0) /=.\nby rewrite -defM memvE (sumv_sup i) ?field_subvMl.\nQed."
}
{
  "statement": "Lemma perm_sort_inP (T : eqType) (leT : rel T) (s1 s2 : seq T) :\n  {in s1 &, total leT} -> {in s1 & &, transitive leT} ->\n  {in s1 &, antisymmetric leT} ->\n  reflect (sort leT s1 = sort leT s2) (perm_eq s1 s2).\n",
  "proof": "Proof.\nmove=> /in2_sig leT_total /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_asym.\napply: (iffP idP) => s1s2; last by rewrite -(perm_sort leT) s1s2 perm_sort.\nmove: (s1s2); have /all_sigP[s1' ->] := allss s1.\nhave /all_sigP[{s1s2}s2 ->] : all [in s1] s2 by rewrite -(perm_all _ s1s2).\nby rewrite !sort_map => /(perm_map_inj val_inj) /(perm_sortP leT_total)->.\nQed."
}
{
  "statement": "Lemma envelop_mxP A :\n  reflect (exists a, A = \\sum_(x in G) a x *: rG x) (A \\in E_G)%MS.\n",
  "proof": "Proof.\nhave G_1 := group1 G; have bijG := enum_val_bij_in G_1.\nset h := enum_val in bijG; have Gh: h _ \\in G by apply: enum_valP.\napply: (iffP submxP) => [[u defA] | [a ->]].\n  exists (fun x => u 0 (enum_rank_in G_1 x)); apply: (can_inj mxvecK).\n  rewrite defA mulmx_sum_row linear_sum (reindex h) //=.\n  by apply: eq_big => [i | i _]; rewrite ?Gh // rowK linearZ enum_valK_in.\nexists (\\row_i a (h i)); rewrite mulmx_sum_row linear_sum (reindex h) //=.\nby apply: eq_big => [i | i _]; rewrite ?Gh // mxE rowK linearZ.\nQed."
}
{
  "statement": "Lemma big_ord_narrow_cond n1 n2 (P : pred 'I_n2) F (le_n12 : n1 <= n2) :\n    let w := widen_ord le_n12 in\n  \\big[op/idx]_(i < n2 | P i && (i < n1)) F i\n    = \\big[op/idx]_(i < n1 | P (w i)) F (w i).\n",
  "proof": "Proof.\ncase: n1 => [|n1] /= in le_n12 *.\n  by rewrite big_ord0 big_pred0 // => i; rewrite andbF.\nrewrite (big_ord_widen_leq _ _ le_n12); apply: eq_big => i.\n  by apply: andb_id2r => le_i_n1; congr P; apply: val_inj; rewrite /= inordK.\nby case/andP=> _ le_i_n1; congr F; apply: val_inj; rewrite /= inordK.\nQed."
}
{
  "statement": "Lemma pairwiseP x0 xs :\n  reflect {in gtn (size xs) &, {homo nth x0 xs : i j / i < j >-> r i j}}\n          (pairwise xs).\n",
  "proof": "Proof.\nelim: xs => /= [|x xs IHxs]; first exact: (iffP idP).\napply: (iffP andP) => [[r_x_xs pxs] i j|Hnth]; rewrite -?topredE /= ?ltnS.\n  by case: i j => [|i] [|j] //= gti gtj ij; [exact/all_nthP | exact/IHxs].\nsplit; last by apply/IHxs => // i j; apply/(Hnth i.+1 j.+1).\nby apply/(all_nthP x0) => i gti; apply/(Hnth 0 i.+1).\nQed."
}
{
  "statement": "Lemma deg_le2_poly_delta_ge0 : 0 <= a -> (forall x, 0 <= p.[x]) -> delta <= 0.\n",
  "proof": "Proof.\nmove=> age0 pge0; move: degp; rewrite leq_eqVlt => /orP[/eqP|] degp'.\n  exact/(Real.deg2_poly_ge0 degp' age0).\nhave a0 : a = 0 by rewrite /a nth_default.\nrewrite /delta a0 mulr0 mul0r subr0 exprn_even_le0//=.\nhave [//|/eqP nzb] := eqP; move: (pge0 ((- 1 - c) / b)).\nhave -> : p = b *: 'X + c%:P.\n  apply/polyP => + /[!coefE] => -[|[|i]] /=; rewrite !Monoid.simpm//.\n  by rewrite nth_default// -ltnS (leq_trans degp').\nby rewrite !hornerE/= mulrAC mulfV// mul1r subrK ler0N1.\nQed."
}
{
  "statement": "Lemma pgroup_cyclic_faithful (p : nat) :\n  p.-group G -> cyclic 'Z(G) -> exists i, cfaithful 'chi[G]_i.\n",
  "proof": "Proof.\npose Z := 'Ohm_1('Z(G)) => pG cycZG; have nilG := pgroup_nil pG.\nhave [-> | ntG] := eqsVneq G [1]; first by exists 0; apply: cfker_sub.\nhave{pG} [[p_pr _ _] pZ] := (pgroup_pdiv pG ntG, pgroupS (center_sub G) pG).\nhave ntZ: 'Z(G) != [1] by rewrite center_nil_eq1.\nhave{pZ} oZ: #|Z| = p by apply: Ohm1_cyclic_pgroup_prime.\napply/existsP; apply: contraR ntZ => /existsPn-not_ffulG.\nrewrite -Ohm1_eq1 -subG1 /= -/Z -(TI_cfker_irr G); apply/bigcapsP=> i _.\nrewrite prime_meetG ?oZ // setIC meet_Ohm1 // meet_center_nil ?cfker_normal //.\nby rewrite -subG1 not_ffulG.\nQed."
}
{
  "statement": "Lemma minsetP P A :\n  reflect ((P A) /\\ (forall B, P B -> B \\subset A -> B = A)) (minset P A).\n",
  "proof": "Proof.\napply: (iffP forallP) => [minA | [PA minA] B].\n  split; first by have:= minA A; rewrite subxx eqxx /= => /eqP.\n  by move=> B PB sBA; have:= minA B; rewrite PB sBA /= eqb_id => /eqP.\nby apply/implyP=> sBA; apply/eqP; apply/eqP/idP=> [-> // | /minA]; apply.\nQed."
}
{
  "statement": "Lemma dvdp_gcdlr p q : (gcdp p q %| p) && (gcdp p q %| q).\n",
  "proof": "Proof.\nhave [r] := ubnP (minn (size q) (size p)); elim: r => // r IHr in p q *.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite gcd0p dvdpp andbT.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite gcdp0 dvdpp /=.\nrewrite ltnS gcdpE; case: leqP => [le_pq | lt_pq] le_qr.\n  suffices /IHr/andP[E1 E2]: minn (size q) (size (p %% q)) < r.\n    by rewrite E2 andbT (dvdp_mod _ E2).\n  by rewrite gtn_min orbC (leq_trans _ le_qr) ?ltn_modp.\nsuffices /IHr/andP[E1 E2]: minn (size p) (size (q %% p)) < r.\n  by rewrite E2 (dvdp_mod _ E2).\nby rewrite gtn_min orbC (leq_trans _ le_qr) ?ltn_modp.\nQed."
}
{
  "statement": "Lemma p2group_abelian P : p.-group P -> logn p #|P| <= 2 -> abelian P.\n",
  "proof": "Proof.\nmove=> pP lePp2; pose Z := 'Z(P); have sZP: Z \\subset P := center_sub P.\nhave [/(trivg_center_pgroup pP) ->|] := eqVneq Z 1; first exact: abelian1.\ncase/(pgroup_pdiv (pgroupS sZP pP)) => p_pr _ [k oZ].\napply: cyclic_center_factor_abelian.\nhave [->|] := eqVneq (P / Z) 1; first exact: cyclic1.\nhave pPq := quotient_pgroup 'Z(P) pP; case/(pgroup_pdiv pPq) => _ _ [j oPq].\nrewrite prime_cyclic // oPq; case: j oPq lePp2 => //= j.\nrewrite card_quotient ?gFnorm //.\nby rewrite -(Lagrange sZP) lognM // => ->; rewrite oZ !pfactorK ?addnS.\nQed."
}
{
  "statement": "Lemma qX_exp_inj i j :\n  i < #|qT|.-1 -> j < #|qT|.-1 -> 'qX ^+ i = 'qX ^+ j :> qT -> i = j.\n",
  "proof": "Proof.\nwlog iLj : i j / (i <= j)%N => [Hw|] iL jL Hqx.\n  case: (ltngtP i j)=> // /ltnW iLj; first by apply: Hw.\n  by apply/sym_equal/Hw.\nsuff ji_eq0 : (j - i = 0)%N by rewrite -(subnK iLj) ji_eq0.\ncase: ((j - i)%N =P 0%N) => // /eqP ji_neq0.\nhave : j - i < #|qT|.-1 by apply: leq_ltn_trans (leq_subr _ _) jL.\nrewrite ltnNge => /negP[].\napply: dvdn_leq; first by rewrite lt0n.\nhave HqXi : 'qX ^+ i != 0 :> qT by rewrite expf_eq0 (negPf qX_neq0) andbF.\nby apply/qX_order_dvd/(mulIf HqXi); rewrite mul1r -exprD subnK.\nQed."
}
{
  "statement": "Lemma congr_big_nat m1 n1 m2 n2 P1 P2 F1 F2 :\n    m1 = m2 -> n1 = n2 ->\n    (forall i, m1 <= i < n2 -> P1 i = P2 i) ->\n    (forall i, P1 i && (m1 <= i < n2) -> F1 i = F2 i) ->\n  \\big[op/idx]_(m1 <= i < n1 | P1 i) F1 i\n    = \\big[op/idx]_(m2 <= i < n2 | P2 i) F2 i.\n",
  "proof": "Proof.\nmove=> <- <- eqP12 eqF12; rewrite big_seq_cond (big_seq_cond _ P2).\napply: eq_big => i; rewrite ?inE /= !mem_index_iota.\n  by apply: andb_id2l; apply: eqP12.\nby rewrite andbC; apply: eqF12.\nQed."
}
{
  "statement": "Lemma eqp_rgdco_gdco q p : rgdcop q p %= gdcop q p.\n",
  "proof": "Proof.\nrewrite /rgdcop /gdcop; move: (size p)=> n.\nelim: n p q {1 3}p {1 3}q (eqpxx p) (eqpxx q) => [|n ihn] p q s t /= sp tq.\n  case: (eqVneq t 0) tq => [-> | nt0 etq].\n    by rewrite eqp_sym eqp0 => ->; rewrite eqpxx.\n  by case: (eqVneq q 0) etq nt0 => [->|]; rewrite ?eqpxx // eqp0 => ->.\nrewrite rcoprimep_coprimep (eqp_coprimepl t sp) (eqp_coprimepr p tq).\ncase: ifP=> // _; apply: ihn => //; apply: eqp_trans (eqp_rdiv_div _ _) _.\nby apply: eqp_div => //; apply: eqp_trans (eqp_rgcd_gcd _ _) _; apply: eqp_gcd.\nQed."
}
{
  "statement": "Lemma submx_in_gen_eq m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  (V *m A <= V -> (in_gen U <= in_gen V) = (U <= V))%MS.\n",
  "proof": "Proof.\nmove=> sVA_V; apply/idP/idP=> siUV; last exact: submx_in_gen.\napply/row_subP=> i; rewrite -[row i U]in_genK in_gen_row.\ncase/submxP: (row_subP siUV i) => u ->{i U siUV}.\nrewrite mulmx_sum_row val_gen_sum summx_sub // => j _.\nrewrite val_genZ val_gen_row in_genK rowE -mulmxA mulmx_sub //.\nrewrite [mxval _]horner_poly mulmx_sumr summx_sub // => [[k _]] _ /=.\nrewrite mulmxA mul_mx_scalar -scalemxAl scalemx_sub {u j}//.\nelim: k => [|k IHk]; first by rewrite mulmx1.\nby rewrite exprSr mulmxA (submx_trans (submxMr A IHk)).\nQed."
}
{
  "statement": "Lemma maximal_eqP M G :\n  reflect (M \\subset G  /\\\n             forall H, M \\subset H -> H \\subset G -> H :=: M \\/ H :=: G)\n       (maximal_eq M G).\n",
  "proof": "Proof.\nrewrite subEproper /maximal_eq; case: eqP => [->|_]; first left.\n  by split=> // H sGH sHG; right; apply/eqP; rewrite eqEsubset sHG.\napply: (iffP maxgroupP) => [] [sMG maxM]; split=> // H.\n  by move/maxM=> maxMH; rewrite subEproper; case/predU1P; auto.\nby rewrite properEneq => /andP[/eqP neHG sHG] /maxM[].\nQed."
}
{
  "statement": "Lemma lognE p m :\n  logn p m = if [&& prime p, 0 < m & p %| m] then (logn p (m %/ p)).+1 else 0.\n",
  "proof": "Proof.\nrewrite /logn /dvdn; case p_pr: (prime p) => //.\ncase def_m: m => // [m']; rewrite !andTb [LHS]/= -def_m /divn modn_def.\ncase: edivnP def_m => [[|q] [|r] -> _] // def_m; congr _.+1; rewrite [_.1]/=.\nhave{m def_m}: q < m'.\n  by rewrite -ltnS -def_m addn0 mulnC -{1}[q.+1]mul1n ltn_pmul2r // prime_gt1.\nelim/ltn_ind: m' {q}q.+1 (ltn0Sn q) => -[_ []|r IHr m] //= m_gt0 le_mr.\nrewrite -[m in logn_rec _ _ m]prednK //=.\ncase: edivnP => [[|q] [|_] def_q _] //; rewrite addn0 in def_q.\nhave{def_q} lt_qm1: q < m.-1.\n  by rewrite -[q.+1]muln1 -ltnS prednK // def_q ltn_pmul2l // prime_gt1.\nhave{le_mr} le_m1r: m.-1 <= r by rewrite -ltnS prednK.\nby rewrite (IHr r) ?(IHr m.-1) // (leq_trans lt_qm1).\nQed."
}
{
  "statement": "Lemma cfker_repr n (rG : mx_representation algC G n) :\n  cfker (cfRepr rG) = rker rG.\n",
  "proof": "Proof.\napply/esym/setP=> x; rewrite inE mul1mx /=.\ncase Gx: (x \\in G); last by rewrite inE Gx.\napply/eqP/idP=> Kx; last by rewrite max_cfRepr_mx1 // cfker1.\nrewrite inE Gx; apply/forallP=> y; rewrite !cfunE !mulrb groupMl //.\nby case: ifP => // Gy; rewrite repr_mxM // Kx mul1mx.\nQed."
}
{
  "statement": "Lemma subset_cardP A B : #|A| = #|B| -> reflect (A =i B) (A \\subset B).\n",
  "proof": "Proof.\nmove=> eqcAB; case: (subsetP A B) (subset_eqP A B) => //= sAB.\ncase: (subsetP B A) => [//|[]] x Bx; apply/idPn => Ax.\ncase/idP: (ltnn #|A|); rewrite {2}eqcAB (cardD1 x B) Bx /=.\napply: subset_leq_card; apply/subsetP=> y Ay; rewrite inE /= andbC.\nby rewrite sAB //; apply/eqP => eqyx; rewrite -eqyx Ay in Ax.\nQed."
}
{
  "statement": "Lemma sub_capmx_gen m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A <= capmx_gen B C)%MS = (A <= B)%MS && (A <= C)%MS.\n",
  "proof": "Proof.\napply/idP/andP=> [sAI | [/submxP[B' ->{A}] /submxP[C' eqBC']]].\n  rewrite !(submx_trans sAI) ?submxMl // /capmx_gen.\n   have:= mulmx_ker (col_mx B C); set K := kermx _.\n   rewrite -{1}[K]hsubmxK mul_row_col; move/(canRL (addrK _))->.\n   by rewrite add0r -mulNmx submxMl.\nhave: (row_mx B' (- C') <= kermx (col_mx B C))%MS.\n  by rewrite sub_kermx mul_row_col eqBC' mulNmx subrr.\ncase/submxP=> D; rewrite -[kermx _]hsubmxK mul_mx_row.\nby case/eq_row_mx=> -> _; rewrite -mulmxA submxMl.\nQed."
}
{
  "statement": "Lemma mxtrace_dsum_mod (I : finType) (P : pred I) U W\n                       (modU : forall i, mG (U i)) (modW : mG W) :\n    let S := (\\sum_(i | P i) U i)%MS in (S :=: W)%MS -> mxdirect S ->\n  {in G, forall x, \\sum_(i | P i) \\tr (sr (modU i) x) = \\tr (sr modW x)}.\n",
  "proof": "Proof.\nmove=> /= sumS dxS x Gx; have [m lePm] := ubnP #|P|.\nelim: m => // m IHm in P lePm W modW sumS dxS *.\nhave [j /= Pj | P0] := pickP P; last first.\n  case: sumS (_ x); rewrite !big_pred0 // mxrank0 => <- _ rWx.\n  by rewrite [rWx]flatmx0 linear0.\nrewrite ltnS (cardD1x Pj) in lePm.\nrewrite mxdirectE /= !(bigD1 j Pj) -mxdirectE mxdirect_addsE /= in dxS sumS *.\nhave [_ dxW' dxW] := and3P dxS; rewrite (sameP eqP mxdirect_addsP) in dxW.\nrewrite (IHm _ _ _ (sumsmx_module _ (fun i _ => modU i)) (eqmx_refl _)) //.\nexact: mxtrace_dadd_mod.\nQed."
}
{
  "statement": "Lemma foldExistsP I e :\n  (exists2 e', {in [predC I], same_env e e'} & holds e' f)\n    <-> holds e (foldr Exists f I).\n",
  "proof": "Proof.\nelim: I e => /= [|i I IHi] e.\n  by split=> [[e' eq_e] |]; [apply: eq_holds => i; rewrite eq_e | exists e].\nsplit=> [[e' eq_e f_e'] | [x]]; last set e_x := set_nth 0 e i x.\n  exists e'`_i; apply/IHi; exists e' => // j.\n  by have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP => // ->.\ncase/IHi=> e' eq_e f_e'; exists e' => // j.\nby have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP.\nQed."
}
{
  "statement": "Lemma set1gXnP {i} (H : {set gT i}) x :\n  reflect (exists2 h, h \\in H & x = dfung1 h) (x \\in set1gXn H).\n",
  "proof": "Proof.\nrewrite set1gXnE/=; apply: (iffP setXnP) => [xP|[h hH ->] j]; last first.\n  by rewrite ffunE; case: dfwithP => [|k ?]; rewrite (dfwith_in, dfwith_out).\nexists (x i); first by have := xP i; rewrite dfwith_in.\napply/ffunP => j; have := xP j; rewrite ffunE.\ncase: dfwithP => // [xiH|k neq_ik]; first by rewrite dfwith_in.\nby move=> /set1gP->; rewrite dfwith_out.\nQed."
}
{
  "statement": "Theorem Frobenius_Ind_irrP j :\n  reflect (exists2 i, i != 0 & 'chi_j = 'Ind[G, K] 'chi_i)\n          (~~ (K \\subset cfker 'chi_j)).\n",
  "proof": "Proof.\nhave [_ _ nsKG _] := Frobenius_kerP frobGK; have [sKG nKG] := andP nsKG.\napply: (iffP idP) => [not_chijK1 | [i nzi ->]]; last first.\n  by rewrite cfker_Ind_irr ?sub_gcore // subGcfker.\nhave /neq0_has_constt[i chijKi]: 'Res[K] 'chi_j != 0 by apply: Res_irr_neq0.\nhave nz_i: i != 0.\n  by apply: contraNneq not_chijK1 => i0; rewrite constt0_Res_cfker // -i0.\nhave /irrP[k def_chik] := irr_induced_Frobenius_ker nz_i.\nhave: '['chi_j, 'chi_k] != 0 by rewrite -def_chik -cfdot_Res_l.\nby rewrite cfdot_irr pnatr_eq0; case: (j =P k) => // ->; exists i.\nQed."
}
{
  "statement": "Lemma mem_prime_decomp n p e :\n  (p, e) \\in prime_decomp n -> [/\\ prime p, e > 0 & p ^ e %| n].\n",
  "proof": "Proof.\ncase: (posnP n) => [-> //| /prime_decomp_correct[def_n mem_pd ord_pd pd_pe]].\nhave /andP[pr_p ->] := allP mem_pd _ pd_pe; split=> //; last first.\n  case/splitPr: pd_pe def_n => pd1 pd2 ->.\n  by rewrite big_cat big_cons /= mulnCA dvdn_mulr.\nhave lt1p: 1 < p.\n  apply: (allP (order_path_min ltn_trans ord_pd)).\n  by apply/mapP; exists (p, e).\napply/primeP; split=> // d dv_d_p; apply/norP=> [[nd1 ndp]].\ncase/hasP: pr_p; exists d => //.\nrewrite mem_index_iota andbC 2!ltn_neqAle ndp eq_sym nd1.\nby have lt0p := ltnW lt1p; rewrite dvdn_leq // (dvdn_gt0 lt0p).\nQed."
}
{
  "statement": "Lemma cfRes_irr_irr chi :\n  chi \\is a character -> 'Res[H] chi \\in irr H -> chi \\in irr G.\n",
  "proof": "Proof.\nhave [sHG /char_reprP[rG ->] | not_sHG Nchi] := boolP (H \\subset G).\n  rewrite -(cfRepr_sub _ sHG) => /irr_reprP[rH irrH def_rH]; apply/irr_reprP.\n  suffices /subg_mx_irr: mx_irreducible (subg_repr rG sHG) by exists rG.\n  by apply: mx_rsim_irr irrH; apply/cfRepr_rsimP/eqP.\nrewrite cfResEout // => /irrP[j Dchi_j]; apply/lin_char_irr/cfRes_lin_lin=> //.\nsuffices j0: j = 0 by rewrite cfResEout // Dchi_j j0 irr0 rpred1.\napply: contraNeq (irr1_neq0 j) => nz_j.\nhave:= xcfun_id j 0; rewrite -Dchi_j cfunE xcfunZl -irr0 xcfun_id eqxx => ->.\nby rewrite (negPf nz_j).\nQed."
}
{
  "statement": "Lemma astabs_mod : 'N(S | mod_action) = 'N(S | to) / H.\n",
  "proof": "Proof.\napply/setP=> Ha; apply/idP/morphimP=> [nSa | [a nHa nSa ->]].\n  case/morphimP: (astabs_dom nSa) => a nHa Da defHa.\n  exists a => //; rewrite !inE Da; apply/subsetP=> x Sx; rewrite !inE.\n  by have:= Sx; rewrite -(astabs_act x nSa) defHa /= modactE ?(subsetP fixSH).\nhave Da := astabs_dom nSa; rewrite !inE mem_quotient //; apply/subsetP=> x Sx.\nby rewrite !inE /= modactE ?(astabs_act x nSa) ?(subsetP fixSH).\nQed."
}
{
  "statement": "Lemma cfun_base_free A : free (cfun_base G A).\n",
  "proof": "Proof.\nhave b_i (i : 'I_#|classes G ::&: A|) : (cfun_base G A)`_i = '1_(enum_val i).\n  by rewrite /enum_val -!tnth_nth tnth_map.\napply/freeP => s S0 i; move/cfunP/(_ (repr (enum_val i))): S0.\nrewrite sum_cfunE (bigD1 i) //= big1 ?addr0 => [|j].\n  rewrite b_i !cfunE; have /setIdP[/imsetP[x Gx ->] _] := enum_valP i.\n  by rewrite cfun_repr cfun_classE Gx class_refl mulr1.\napply: contraNeq; rewrite b_i !cfunE mulf_eq0 => /norP[_].\nrewrite -(inj_eq enum_val_inj).\nhave /setIdP[/imsetP[x _ ->] _] := enum_valP i; rewrite cfun_repr.\nhave /setIdP[/imsetP[y Gy ->] _] := enum_valP j; rewrite cfun_classE Gy.\nby rewrite pnatr_eq0 -lt0n lt0b => /class_eqP->.\nQed."
}
{
  "statement": "Lemma pi_center_nilpotent G : nilpotent G -> \\pi('Z(G)) = \\pi(G).\n",
  "proof": "Proof.\nmove=> nilG; apply/eq_piP => /= p.\napply/idP/idP=> [|pG]; first exact: (piSg (center_sub _)).\nmove: (pG); rewrite !mem_primes !cardG_gt0; case/andP=> p_pr _.\npose Z := 'O_p(G) :&: 'Z(G); have ntZ: Z != 1.\n  rewrite meet_center_nil ?pcore_normal // trivg_card_le1 -ltnNge.\n  rewrite (card_Hall (nilpotent_pcore_Hall p nilG)) p_part.\n  by rewrite (ltn_exp2l 0 _ (prime_gt1 p_pr)) logn_gt0.\nhave pZ: p.-group Z := pgroupS (subsetIl _ _) (pcore_pgroup _ _).\nhave{ntZ pZ} [_ pZ _] := pgroup_pdiv pZ ntZ.\nby rewrite p_pr (dvdn_trans pZ) // cardSg ?subsetIr.\nQed."
}
{
  "statement": "Lemma mem_orthovPn V u : reflect (exists2 v, v \\in V & '[u, v] != 0) (u \\notin orthov V).\n",
  "proof": "Proof.\napply: (iffP idP) => [u_orthovV|[v /coord_vbasis-> uvNorthov]]; last first.\n  apply/subv_bigcapP => uP.\n  rewrite linear_sumr big1 ?eqxx//= in uvNorthov.\n  move=> i _; have := uP i isT.\n  by rewrite -memvE memv_ker lfunE/= linearZr/= => /eqP/= ->; rewrite mulr0.\nsuff /existsP [i ui_neq0] : [exists i : 'I_(\\dim V), '[u, (vbasis V)`_i] != 0].\n  by exists (vbasis V)`_i => //; rewrite vbasis_mem ?mem_nth ?size_tuple.\napply: contraNT u_orthovV; rewrite negb_exists => /forallP ui_eq0.\napply/subv_bigcapP => i _.\nby rewrite -memvE memv_ker lfunE /= -[_ == _]negbK.\nQed."
}
{
  "statement": "Lemma subseq_uniqP s1 s2 :\n  uniq s2 -> reflect (s1 = filter [in s1] s2) (subseq s1 s2).\n",
  "proof": "Proof.\nmove=> uniq_s2; apply: (iffP idP) => [ss12 | ->]; last exact: filter_subseq.\napply/eqP; rewrite -size_subseq_leqif ?subseq_filter ?(introT allP) //.\napply/eqP/esym/perm_size.\nrewrite uniq_perm ?filter_uniq ?(subseq_uniq ss12) // => x.\nby rewrite mem_filter; apply: andb_idr; apply: (mem_subseq ss12).\nQed."
}
{
  "statement": "Lemma perm_zip1 {S T : eqType} (t1 t2 : seq T) (s1 s2 : seq S): \n  size s1 = size t1 -> size s2 = size t2 -> \n  perm_eq (zip s1 t1) (zip s2 t2) -> perm_eq s1 s2.\n",
  "proof": "Proof.\nwlog [x y] : s1 s2 t1 t2 / (S * T)%type => [hwlog|].\n  case: s2 t2 => [|x s2] [|y t2] //; last exact: hwlog.\n  by case: s1 t1 => [|u s1] [|v t1]//= _ _ /perm_nilP.\nmove=> eq1 eq2 /(perm_iotaP (x, y))[ns nsP /(congr1 (@unzip1 _ _))].\nrewrite unzip1_zip ?unzip1_map_nth_zip -?eq1// => ->.\nby apply/(perm_iotaP x); exists ns; rewrite // size_zip -eq2 minnn in nsP.\nQed."
}
{
  "statement": "Lemma sub_annihilant_neq0 p q : p != 0 -> q != 0 -> sub_annihilant p q != 0.\n",
  "proof": "Proof.\nrewrite resultant_eq0; set p1 := poly_XaY p => nz_p nz_q.\nhave [nz_p1 nz_q1]: p1 != 0 /\\ q^:P != 0 by rewrite poly_XaY_eq0 map_polyC_eq0.\nrewrite -leqNgt eq_leq //; apply/eqP/Bezout_coprimepPn=> // [[[u v]]] /=.\nrewrite !size_poly_gt0 -andbA => /and4P[nz_u ltuq nz_v _] Duv.\nhave /eqP/= := congr1 (size \\o (lead_coef \\o swapXY)) Duv.\nrewrite ltn_eqF // !rmorphM !lead_coefM (leq_trans (leq_ltn_trans _ ltuq)) //=.\n  rewrite -{2}[u]swapXYK -sizeYE swapXY_poly_XaY lead_coef_poly_XaY.\n  by rewrite mulrC mul_polyC size_scale ?max_size_lead_coefXY ?lead_coef_eq0.\nrewrite swapXY_map_polyC lead_coefC size_map_polyC.\nset v1 := lead_coef _; have nz_v1: v1 != 0 by rewrite lead_coef_eq0 swapXY_eq0.\nrewrite [leqRHS]polySpred ?mulf_neq0 // size_mul //.\nby rewrite (polySpred nz_v1) addnC addnS polySpred // ltnS leq_addr.\nQed."
}
{
  "statement": "Lemma coef0_prod_XsubC (ps : seq R) :\n  (\\prod_(p <- ps) ('X - p%:P))`_0 =\n  (-1) ^+ (size ps) * \\prod_(p <- ps) p.\n",
  "proof": "Proof.\nrewrite coef_prod_XsubC// subn0; congr GRing.mul.\ntransitivity (\\sum_(I in [set setT : {set 'I_(size ps)}]) \\prod_(i in I) ps`_i).\n  apply: congr_big =>// i/=.\n  apply/idP/set1P => [/eqP cardE | ->]; last by rewrite cardsT card_ord.\n  by apply/eqP; rewrite eqEcard subsetT cardsT card_ord cardE leqnn.\nrewrite big_set1 -[in RHS](in_tupleE ps) -(map_tnth_enum (_ ps)) big_map enumT.\napply: congr_big => // i; first exact: in_setT.\nby rewrite (tnth_nth 0).\nQed."
}
{
  "statement": "Lemma edivp_eq d q r : size r < size d -> lead_coef d \\in GRing.unit ->\n  edivp (q * d + r) d = (0, q, r).\n",
  "proof": "Proof.\nhave hC : GRing.comm d (lead_coef d)%:P by apply: mulrC.\nmove=> hsrd hu; rewrite unlock hu; case et: (redivp _ _) => [[s qq] rr].\nhave cdn0 : lead_coef d != 0 by case: eqP hu => //= ->; rewrite unitr0.\nmove: (et); rewrite RingComRreg.redivp_eq //; last exact/rregP.\nrewrite et /= mulrC (mulrC r) !mul_polyC; case=> <- <-.\nby rewrite !scalerA mulVr ?scale1r // unitrX.\nQed."
}
{
  "statement": "Lemma rot_is_rot : rot = rotations.\n",
  "proof": "Proof.\napply/setP=> r; apply/idP/idP => [|/rotations_is_rot] /[!inE]// h.\nhave -> : r = r1 ^+ (r c0) by apply: rot_eq_c0; rewrite // -rot_r1.\nhave e2: 2 = r2 c0 by rewrite permE /=.\nhave e3: 3 = r3 c0 by rewrite permE /=.\ncase (r c0); do 4?[case] => // ?; rewrite ?(expg1, eqxx, orbT) //.\n  by rewrite [nat_of_ord _]/= e2 -rot_r1 ?(eqxx, orbT, rotations_is_rot, inE).\nby rewrite [nat_of_ord _]/= e3 -rot_r1 ?(eqxx, orbT, rotations_is_rot, inE).\nQed."
}
{
  "statement": "Lemma Hall_Frattini_arg pi (G K H : {group gT}) :\n  solvable K -> K <| G -> pi.-Hall(K) H -> K * 'N_G(H) = G.\n",
  "proof": "Proof.\nmove=> solK /andP[sKG nKG] hallH.\nhave sHG: H \\subset G by apply: subset_trans sKG; case/andP: hallH.\nrewrite setIC group_modl //; apply/setIidPr/subsetP=> x Gx.\npose H1 := (H :^ x^-1)%G.\nhave hallH1: pi.-Hall(K) H1 by rewrite pHallJnorm // groupV (subsetP nKG).\ncase: (Hall_trans solK hallH hallH1) => y Ky defH.\nrewrite -(mulKVg y x) mem_mulg //; apply/normP.\nby rewrite conjsgM {1}defH conjsgK conjsgKV.\nQed."
}
{
  "statement": "Lemma isog_simple gT rT (G : {group gT}) (M : {group rT}) :\n  G \\isog M -> simple G = simple M.\n",
  "proof": "Proof.\nmove=> eqGM; wlog suffices: gT rT G M eqGM / simple M -> simple G.\n  by move=> IH; apply/idP/idP; apply: IH; rewrite // isog_sym.\ncase/isogP: eqGM => f injf <- /simpleP[ntGf simGf].\napply/simpleP; split=> [|N nsNG]; first by rewrite -(morphim_injm_eq1 injf).\nrewrite -(morphim_invm injf (normal_sub nsNG)).\nhave: f @* N <| f @* G by rewrite morphim_normal.\nby case/simGf=> /= ->; [left | right]; rewrite (morphim1, morphim_invm).\nQed."
}
{
  "statement": "Lemma primePns n :\n  reflect (n < 2 \\/ exists p, [/\\ prime p, p ^ 2 <= n & p %| n]) (~~ prime n).\n",
  "proof": "Proof.\napply: (iffP idP) => [npr_p|]; last first.\n  case=> [|[p [pr_p le_p2_n dv_p_n]]]; first by case: n => [|[]].\n  apply/negP=> pr_n; move: dv_p_n le_p2_n; rewrite dvdn_prime2 //; move/eqP->.\n  by rewrite leqNgt -[ltnLHS]muln1 ltn_pmul2l ?prime_gt1 ?prime_gt0.\nhave [lt1p|] := leqP; [right | by left].\nexists (pdiv n); rewrite pdiv_dvd pdiv_prime //; split=> //.\nby case: leqP npr_p => // /ltn_pdiv2_prime -> //; exact: ltnW.\nQed."
}
{
  "statement": "Lemma map_pairwise_orthogonal : pairwise_orthogonal (map nu S).\n",
  "proof": "Proof.\nhave inj_nu: {in S &, injective nu}.\n  move=> phi psi Sphi Spsi /= eq_nu; apply: contraNeq (memPn notS0 _ Sphi).\n  by rewrite -cfnorm_eq0 -Inu ?Z_S // {2}eq_nu Inu ?Z_S // => /dotSS->.\nhave notSnu0: 0 \\notin map nu S.\n  apply: contra notS0 => /mapP[phi Sphi /esym/eqP].\n  by rewrite -cfnorm_eq0 Inu ?Z_S // cfnorm_eq0 => /eqP <-.\napply/pairwise_orthogonalP; split; first by rewrite /= notSnu0 map_inj_in_uniq.\nmove=> _ _ /mapP[phi Sphi ->] /mapP[psi Spsi ->].\nby rewrite (inj_in_eq inj_nu) // Inu ?Z_S //; apply: dotSS.\nQed."
}
{
  "statement": "Lemma addsmx_diff_cap_eq m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :\\: B + A :&: B :=: A)%MS.\n",
  "proof": "Proof.\napply/eqmxP; rewrite addsmx_sub capmxSl diffmxSl /=.\nset C := (A :\\: B)%MS; set D := capmx_gen A B.\nsuffices sACD: (A <= C + D)%MS.\n  by rewrite (submx_trans sACD) ?addsmxS ?capmxE.\nhave:= addsmx_compl_full D; rewrite /row_full addsmxE.\ncase/row_fullP=> U /(congr1 (mulmx A)); rewrite mulmx1.\nrewrite -[U]hsubmxK mul_row_col mulmxDr addrC 2!mulmxA.\nset V := _ *m _ => defA; rewrite -defA; move/(canRL (addrK _)): defA => defV.\nsuffices /submxP[W ->]: (V <= C)%MS by rewrite -mul_row_col addsmxE submxMl.\nrewrite diffmxE sub_capmx {1}defV -mulNmx addmx_sub 1?mulmx_sub //.\nby rewrite -capmxE capmxSl.\nQed."
}
{
  "statement": "Lemma normal_fixedField_galois : galois K (fixedField G).\n",
  "proof": "Proof.\nhave [[sKE sepKE nKE] [sGgal nGgal]] := (and3P galKE, andP nsGgalE).\nrewrite /galois -(galois_connection _ sKE) sGgal.\nrewrite (separableSr _ sepKE) ?capvSl //; apply/forall_inP=> f autKf.\nrewrite eqEdim limg_dim_eq ?(eqP (AEnd_lker0 _)) ?capv0 // leqnn andbT.\napply/subvP => _ /memv_imgP[a /mem_fixedFieldP[Ea cGa] ->].\nhave /kAut_to_gal[x galEx -> //]: kAut K E f.\n  rewrite /kAut (forall_inP nKE) // andbT; apply/kAHomP.\n  by move: autKf; rewrite inE kAutfE => /kHomP[].\napply/fixedFieldP=> [|y Gy]; first exact: memv_gal.\nby rewrite -galM // conjgCV galM //= cGa // memJ_norm ?groupV ?(subsetP nGgal).\nQed."
}
{
  "statement": "Lemma astabs_quotient (G : {group rT}) :\n   H <| G -> 'N(G / H | quotient_action) = 'N_qact_dom(G | to).\n",
  "proof": "Proof.\nmove=> nsHG; have [_ nHG] := andP nsHG.\napply/eqP; rewrite eqEsubset acts_quotient // andbT.\napply/subsetP=> a nGa; have dHa := astabs_dom nGa; have [Da _]:= setIdP dHa.\nrewrite inE dHa 2!inE Da; apply/subsetP=> x Gx; have nHx := subsetP nHG x Gx.\nrewrite -(quotientGK nsHG) 2!inE (acts_act acts_qact_dom) ?nHx //= inE.\nby rewrite -qactE // (astabs_act _ nGa) mem_morphim.\nQed."
}
{
  "statement": "Lemma cprod_extraspecial G H K :\n    p.-group G -> H \\* K = G -> H :&: K = 'Z(H) ->\n  extraspecial H -> extraspecial K -> extraspecial G.\n",
  "proof": "Proof.\nmove=> pG defG ziHK [[PhiH defH'] ZH_pr] [[PhiK defK'] ZK_pr].\nhave [_ defHK cHK]:= cprodP defG.\nhave sZHK: 'Z(H) \\subset 'Z(K).\n  by rewrite subsetI -{1}ziHK subsetIr subIset // centsC cHK.\nhave{sZHK} defZH: 'Z(H) = 'Z(K).\n  by apply/eqP; rewrite eqEcard sZHK leq_eqVlt eq_sym -dvdn_prime2 ?cardSg.\nhave defZ: 'Z(G) = 'Z(K).\n  by case/cprodP: (center_cprod defG) => /= _ <- _; rewrite defZH mulGid.\nsplit; first split; rewrite defZ //.\n  by have /cprodP[_ <- _] := Phi_cprod pG defG; rewrite PhiH PhiK defZH mulGid.\nby have /cprodP[_ <- _] := der_cprod 1 defG; rewrite defH' defK' defZH mulGid.\nQed."
}
{
  "statement": "Lemma eqmxP m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  reflect (A :=: B)%MS (A == B)%MS.\n",
  "proof": "Proof.\napply: (iffP andP) => [[sAB sBA] | eqAB]; last by rewrite !eqAB.\nsplit=> [|m3 C]; first by apply/eqP; rewrite eqn_leq !mxrankS.\nsplit; first by apply/idP/idP; apply: submx_trans.\nby apply/idP/idP=> sC; apply: submx_trans sC _.\nQed."
}
{
  "statement": "Lemma up_log2S n : 0 < n -> up_log 2 n.+1 = (up_log 2 (n./2.+1)).+1.\n",
  "proof": "Proof.\ncase: n=> // [] [|n] // _.\napply: up_log_eq => //; apply/andP; split.\n  apply: leq_trans (_ : n./2.+1.*2 < n.+3); last first.\n    by rewrite doubleS !ltnS -[leqRHS]odd_double_half leq_addl.\n  have /= /andP[H1n _] := up_log_bounds (isT : 1 < 2) (isT : 1 < n./2.+2).\n  by rewrite ltnS -leq_double -mul2n -expnS prednK ?up_log_gt0 // in H1n.\nrewrite -[_./2.+1]/(n./2.+2).\nhave /= /andP[_ H2n] := up_log_bounds (isT : 1 < 2) (isT : 1 < n./2.+2).\nrewrite -leq_double -!mul2n -expnS in H2n.\napply: leq_trans H2n.\nrewrite mul2n !doubleS !ltnS.\nby rewrite -[leqLHS]odd_double_half -add1n leq_add2r; case: odd.\nQed."
}
{
  "statement": "Lemma closed_rootP p : reflect (exists x, root p x) (size p != 1).\n",
  "proof": "Proof.\nhave [-> | nz_p] := eqVneq p 0.\n  by rewrite size_poly0; left; exists 0; rewrite root0.\nrewrite neq_ltn [in _ < 1]polySpred //=.\napply: (iffP idP) => [p_gt1 | [a]]; last exact: root_size_gt1.\npose n := (size p).-1; have n_gt0: n > 0 by rewrite -ltnS -polySpred.\nhave [a Dan] := closedF (fun i => - p`_i / lead_coef p) n_gt0.\nexists a; apply/rootP; rewrite horner_coef polySpred // big_ord_recr /= -/n.\nrewrite {}Dan mulr_sumr -big_split big1 //= => i _.\nby rewrite -!mulrA mulrCA mulNr mulVKf ?subrr ?lead_coef_eq0.\nQed."
}
{
  "statement": "Lemma nilpotent_maxp_normal pi G H :\n  nilpotent G -> [max H | pi.-subgroup(G) H] -> H <| G.\n",
  "proof": "Proof.\nmove=> nilG /maxgroupP[/andP[sHG piH] maxH].\nhave nHN: H <| 'N_G(H) by rewrite normal_subnorm.\nhave{maxH} hallH: pi.-Hall('N_G(H)) H.\n  apply: normal_max_pgroup_Hall => //; apply/maxgroupP.\n  rewrite /psubgroup normal_sub // piH; split=> // K.\n  by rewrite subsetI -andbA andbCA => /andP[_ /maxH].\nrewrite /normal sHG; apply/setIidPl/esym.\napply: nilpotent_sub_norm; rewrite ?subsetIl ?setIS //= char_norms //.\nby congr (_ \\char _): (pcore_char pi 'N_G(H)); apply: normal_Hall_pcore.\nQed."
}
{
  "statement": "Theorem second_orthogonality_relation x y :\n    y \\in G ->\n  \\sum_i 'chi[G]_i x * ('chi_i y)^* = #|'C_G[x]|%:R *+ (x \\in y ^: G).\n",
  "proof": "Proof.\nmove=> Gy; pose i_x := iC (x ^: G); pose i_y := iC (y ^: G).\nhave [Gx | notGx] := boolP (x \\in G); last first.\n  rewrite (contraNF (subsetP _ x) notGx) ?class_subG ?big1 // => i _.\n  by rewrite cfun0 ?mul0r.\ntransitivity ((#|'C_G[repr (y ^: G)]|%:R *: (X' *m X)) i_y i_x).\n  rewrite scalemxAl !mxE; apply: eq_bigr => k _; rewrite !mxE mulrC -!mulrA.\n  by rewrite !class_IirrK ?mem_classes // !cfun_repr mulVKf ?neq0CG.\nrewrite mulmx1C // !mxE -!divg_index !(index_cent1, =^~ indexgI).\nrewrite (class_eqP (mem_repr y _)) ?class_refl // mulr_natr.\nrewrite (can_in_eq class_IirrK) ?mem_classes //.\nhave [-> | not_yGx] := eqVneq; first by rewrite class_refl.\nby rewrite [x \\in _](contraNF _ not_yGx) // => /class_eqP->.\nQed."
}
{
  "statement": "Lemma sig_big_dep_idem (I : finType) (J : I -> finType)\n    (P : pred I) (Q : forall {i}, pred (J i)) (F : forall {i}, J i -> R) :\n  \\big[op/x]_(i | P i) \\big[op/x]_(j : J i | Q j) F j =\n  \\big[op/x]_(p : {i : I & J i} | P (tag p) && Q (tagged p)) F (tagged p).\n",
  "proof": "Proof.\npose s := [seq Tagged J j | i <- index_enum I, j <- index_enum (J i)].\nrewrite [LHS]big_mkcond_idem big_mkcondl_idem.\nrewrite [RHS]big_mkcond_idem -[RHS](@perm_big _ s).\n  rewrite big_allpairs_dep_idem/=; apply: eq_bigr => i _.\n  by rewrite -big_mkcond_idem/=; case: P; rewrite // big1_idem.\nrewrite uniq_perm ?index_enum_uniq//.\n  by rewrite allpairs_uniq_dep// => [|i|[i j] []]; rewrite ?index_enum_uniq.\nby move=> [i j]; rewrite ?mem_index_enum; apply/allpairsPdep; exists i, j.\nQed."
}
{
  "statement": "Lemma ulc_eqpP p q : lead_coef q \\is a GRing.unit ->\n  reflect (exists2 c : R, c != 0 & p = c *: q) (p %= q).\n",
  "proof": "Proof.\nhave [->|] := eqVneq (lead_coef q) 0; first by rewrite unitr0.\nrewrite lead_coef_eq0 => nz_q ulcq; apply: (iffP idP).\n  have [->|nz_p] := eqVneq p 0; first by rewrite eqp_sym eqp0 (negPf nz_q).\n  move/eqp_eq=> eq; exists (lead_coef p / lead_coef q).\n    by rewrite mulf_neq0 // ?invr_eq0 lead_coef_eq0.\n  by apply/(scaler_injl ulcq); rewrite scalerA mulrCA divrr // mulr1.\nby case=> c nz_c ->; apply/eqpP; exists (1, c); rewrite ?scale1r ?oner_eq0.\nQed."
}
{
  "statement": "Lemma mx_reducible_semisimple V :\n  mxmodule V -> mx_completely_reducible V -> classically (mxsemisimple V).\n",
  "proof": "Proof.\nmove=> modV redV [] // nssimV; have [r leVr] := ubnP (\\rank V).\nelim: r => // r IHr in V leVr modV redV nssimV.\nhave [V0 | nzV] := eqVneq V 0.\n  by rewrite nssimV ?V0 //; apply: mxsemisimple0.\napply: (mxsimple_exists modV nzV) => [[U simU sUV]]; have [modU nzU _] := simU.\nhave [W modW defUW dxUW] := redV U modU sUV.\nhave sWV: (W <= V)%MS by rewrite -defUW addsmxSr.\napply: IHr (mx_reducibleS modW sWV redV) _ => // [|ssimW].\n  rewrite ltnS -defUW (mxdirectP dxUW) /= in leVr; apply: leq_trans leVr.\n  by rewrite -add1n leq_add2r lt0n mxrank_eq0.\napply: nssimV (eqmx_semisimple defUW (addsmx_semisimple _ ssimW)).\nexact: mxsimple_semisimple.\nQed."
}
{
  "statement": "Lemma lead_coefTP (k : tF -> fF) :\n (forall x e, qf_eval e (k x) = qf_eval e (k (eval e x)%:T%T)) ->\n  forall (p : polyF) (e : seq F),\n  qf_eval e (lead_coefT p k) = qf_eval e (k (lead_coef (eval_poly e p))%:T%T).\n",
  "proof": "Proof.\nmove=> kP p e; elim: p => [|a p IHp]/= in k kP e *.\n  by rewrite lead_coef0 kP.\nrewrite IHp; last by move=> *; rewrite //= -kP.\nrewrite GRing.eval_If /= lead_coef_eq0.\ncase p'0: (_ == _); first by rewrite (eqP p'0) mul0r add0r lead_coefC -kP.\nrewrite lead_coefDl ?lead_coefMX // polyseqC size_mul ?p'0 //; last first.\n  by rewrite -size_poly_eq0 size_polyX.\nrewrite size_polyX addnC /=; case: (_ == _)=> //=.\nby rewrite ltnS lt0n size_poly_eq0 p'0.\nQed."
}
{
  "statement": "Lemma Frobenius_cent1_ker : {in K^#, forall x, 'C_G[x] \\subset K}.\n",
  "proof": "Proof.\nhave [/eqP defG _ /normedTI_memJ_P[_ _ tiHG]] := and3P frobG.\nmove=> x /setD1P[ntx Kx]; have [_ /mulG_sub[sKG _] _ tiKH] := sdprodP defG.\nhave [/eqP <- _ _] := and3P Frobenius_partition; rewrite big_distrl /=.\napply/bigcupsP=> _ /setU1P[|/imsetP[y Ky]] ->; first exact: subsetIl.\napply: contraR ntx => /subsetPn[z]; rewrite inE mem_conjg => /andP[Hzy cxz] _.\nrewrite -(conjg_eq1 x y^-1) -in_set1 -set1gE -tiKH inE andbC.\nrewrite -(tiHG _ _ Hzy) ?(subsetP sKG) ?in_group // Ky andbT -conjJg.\nby rewrite /(z ^ x) (cent1P cxz) mulKg.\nQed."
}
{
  "statement": "Lemma gacentQ (gT : finGroupType) (H : {group gT}) (A : {set gT}) :\n  'C_(|'Q)(A) = 'C(A / H).\n",
  "proof": "Proof.\napply/setP=> Hx; case: (cosetP Hx) => x Nx ->{Hx}.\nrewrite -sub_cent1 -astab1J astabC sub1set -(quotientInorm H A).\nhave defD: qact_dom 'J H = 'N(H) by rewrite qact_domE ?subsetT ?astabsJ.\nrewrite !(inE, mem_quotient) //= defD setIC.\napply/subsetP/subsetP=> [cAx _ /morphimP[a Na Aa ->] | cAx a Aa].\n  by move/cAx: Aa; rewrite !inE qactE ?defD ?morphJ.\nhave [_ Na] := setIP Aa; move/implyP: (cAx (coset H a)); rewrite mem_morphim //.\nby rewrite !inE qactE ?defD ?morphJ.\nQed."
}
{
  "statement": "Lemma deg_le2_poly_ge0 : (forall x, 0 <= p.[x]) -> delta <= 0.\n",
  "proof": "Proof.\nhave [age0|alt0] := leP 0 a; first exact: deg_le2_poly_delta_ge0.\nmove=> pge0; move: degp; rewrite leq_eqVlt => /orP[/eqP|] degp'; last first.\n  by move: alt0; rewrite /a nth_default ?ltxx.\nhave [//|dge0] := leP delta 0.\npose r1 := (- b - sqrt delta) / (2 * a).\npose r2 := (- b + sqrt delta) / (2 * a).\npose x0 := Num.max (r1 + 1) (r2 + 1).\nmove: (pge0 x0); rewrite (Real.deg2_poly_factor degp' (ltW dge0)).\nrewrite !hornerE/= -mulrA nmulr_rge0// leNgt => /negbTE<-.\nby apply: mulr_gt0; rewrite subr_gt0 lt_max ltrDl ltr01 ?orbT.\nQed."
}
{
  "statement": "Lemma ahom_inP {f : 'Hom(aT, rT)} {U : {vspace aT}} :\n  reflect ({in U &, {morph f : x y / x * y >-> x * y}} * (f 1 = 1))\n          (ahom_in U f).\n",
  "proof": "Proof.\napply: (iffP andP) => [[/allrelP fM /eqP f1] | [fM f1]]; last first.\n  rewrite f1; split=> //; apply/allrelP => x y Ax Ay.\n  by rewrite fM // vbasis_mem.\nsplit=> // x y /coord_vbasis -> /coord_vbasis ->.\nrewrite !mulr_suml ![f _]linear_sum mulr_suml; apply: eq_bigr => i _ /=.\nrewrite !mulr_sumr linear_sum; apply: eq_bigr => j _ /=.\nrewrite !linearZ -!scalerAr -!scalerAl 2!linearZ /=; congr (_ *: (_ *: _)).\nby apply/eqP/fM; apply: memt_nth.\nQed."
}
{
  "statement": "Lemma redivp_rec_loopT_qf (q : polyF) (sq : nat) (cq : tF)\n  (c : nat) (qq r : polyF) (n : nat) :\n  rpoly q -> rterm cq -> rpoly qq -> rpoly r ->\n  qf_cps (fun x => [&& rpoly x.1.2 & rpoly x.2])\n         (redivp_rec_loopT q sq cq c qq r n).\n",
  "proof": "Proof.\ndo ![move=>x/(pair x){x}] => rw; elim: n => [|n IHn]//= in q sq cq c qq r rw *;\napply: qf_cps_bind; do ?[by apply: sizeT_qf; rewrite !rw] => sr _;\ncase: ifPn => // _; do ?[by apply: qf_cps_ret; rewrite //= ?rw];\napply: qf_cps_bind; do ?[by apply: lead_coefT_qf; rewrite !rw] => lr /= rlr;\n[apply: qf_cps_ret|apply: IHn];\nby do !rewrite ?(rsumpT,rmulpT,ramulXnT,rpoly_map_mul,rlr,rw) //=.\nQed."
}
{
  "statement": "Lemma Cint_spanP n (s : n.-tuple algC) x :\n  reflect (inIntSpan s x) (x \\in Cint_span s).\n",
  "proof": "Proof.\nrewrite unfold_in; case: (dec_Cint_span _ _) => [Zs_x | Zs'x] /=.\n  left; have{Zs_x} [] := Zs_x; rewrite /= size_map size_tuple => a /rowP/(_ 0).\n  rewrite !mxE => ->; exists a; rewrite summxE; apply: eq_bigr => i _.\n  by rewrite -scaler_int (nth_map 0) ?size_tuple // !mxE mulrzl.\nright=> [[a Dx]]; have{Zs'x} [] := Zs'x.\nrewrite /inIntSpan /= size_map size_tuple; exists a.\napply/rowP=> i0; rewrite !mxE summxE Dx; apply: eq_bigr => i _.\nby rewrite -scaler_int mxE mulrzl (nth_map 0) ?size_tuple // !mxE.\nQed."
}
{
  "statement": "Lemma modact_is_action : is_action (D / H) modact.\n",
  "proof": "Proof.\nsplit=> [Ha x y | x Ha Hb]; last first.\n  case/morphimP=> a Na Da ->{Ha}; case/morphimP=> b Nb Db ->{Hb}.\n  rewrite -morphM //= !modactEcond // ?groupM ?(introT setIP _) //.\n  by case: ifP => Cx; rewrite ?(acts_dom, Cx, actMin, introT setIP _).\ncase: (set_0Vmem (D :&: Ha)) => [Da0 | [a /setIP[Da NHa]]].\n  by rewrite /modact Da0 repr_set0 !act1 !if_same.\nhave Na := subsetP (coset_norm _) _ NHa.\nhave NDa: a \\in 'N_D(H) by rewrite inE Da.\nrewrite -(coset_mem NHa) !modactEcond //.\ndo 2![case: ifP]=> Cy Cx // eqxy; first exact: act_inj eqxy.\n  by rewrite -eqxy acts_dom ?Cx in Cy.\nby rewrite eqxy acts_dom ?Cy in Cx.\nQed."
}
{
  "statement": "Lemma morphpreMl R S :\n  R \\subset f @* D -> f @*^-1 (R * S) = f @*^-1 R * f @*^-1 S.\n",
  "proof": "Proof.\nmove=> sRfD; apply/setP=> x; rewrite !inE.\napply/andP/imset2P=> [[Dx] | [y z]]; last first.\n  rewrite !inE => /andP[Dy Rfy] /andP[Dz Rfz] ->.\n  by rewrite ?(groupM, morphM, imset2_f).\ncase/imset2P=> fy fz Rfy Rfz def_fx.\nhave /morphimP[y Dy _ def_fy]: fy \\in f @* D := subsetP sRfD fy Rfy.\nexists y (y^-1 * x); last by rewrite mulKVg.\n  by rewrite !inE Dy -def_fy.\nby rewrite !inE groupM ?(morphM, morphV, groupV) // def_fx -def_fy mulKg.\nQed."
}
{
  "statement": "Lemma strong_Primitive_Element_Theorem K x y :\n    separable_element <<K; x>> y ->\n  exists2 z : L, (<< <<K; y>>; x>> = <<K; z>>)%VS\n               & separable_element K x -> separable_element K y.\n",
  "proof": "Proof.\nmove=> sepKx_y; have [n /andP[pcharLn sepKyn]] := separable_exponent_pchar K y.\nhave adjK_C z t: (<<<<K; z>>; t>> = <<<<K; t>>; z>>)%VS.\n  by rewrite !agenv_add_id -!addvA (addvC <[_]>%VS).\nhave [z defKz] := Primitive_Element_Theorem x sepKyn.\nexists z => [|/adjoin_separable->]; rewrite ?sepKx_y // -defKz.\nhave [|n_gt1|-> //] := ltngtP n 1; first by case: (n) pcharLn.\napply/eqP; rewrite !(adjK_C _ x) eqEsubv; apply/andP.\nsplit; apply/FadjoinP/andP; rewrite subv_adjoin ?rpredX ?memv_adjoin //=.\nby rewrite -pcharf_n_separable ?sepKx_y.\nQed."
}
{
  "statement": "Lemma transfer_indep X (rX := transversal_repr 1 X) :\n  is_transversal X HG G -> {in G, transfer =1 V rX}.\n",
  "proof": "Proof.\nmove=> trX g Gg; have mem_rX := repr_mem_pblock trX 1; rewrite -/rX in mem_rX.\napply: (addrI (\\sum_(Hx in HG) fmalpha (repr Hx * (rX Hx)^-1))).\nrewrite {1}(reindex_acts 'Rs _ Gg) ?actsRs_rcosets // -!big_split /=.\napply: eq_bigr => _ /rcosetsP[x Gx ->]; rewrite !rcosetE -!rcosetM.\ncase: repr_rcosetP => h1 Hh1; case: repr_rcosetP => h2 Hh2.\nhave: H :* (x * g) \\in rcosets H G by rewrite -rcosetE imset_f ?groupM.\nhave: H :* x \\in rcosets H G by rewrite -rcosetE imset_f.\ncase/mem_rX/rcosetP=> h3 Hh3 -> /mem_rX/rcosetP[h4 Hh4 ->].\nrewrite -!(mulgA h1) -!(mulgA h2) -!(mulgA h3) !(mulKVg, invMg).\nby rewrite addrC -!zmodMgE -!morphM ?groupM ?groupV // -!mulgA !mulKg.\nQed."
}
{
  "statement": "Lemma solvable_AltF : 4 < #|T| -> solvable 'Alt_T = false.\n",
  "proof": "Proof.\nmove=> card_T; apply/negP => Alt_solvable.\nhave/simple_Alt5 Alt_simple := card_T.\nhave := simple_sol_prime Alt_solvable Alt_simple.\nhave lt_T n : n <= 4 -> n < #|T| by move/leq_ltn_trans; apply.\nhave -> : #|('Alt_T)%G| = #|T|`! %/ 2 by rewrite -card_Alt ?mulKn ?lt_T.\nmove/even_prime => [/eqP|]; apply/negP.\n  rewrite neq_ltn leq_divRL // mulnC -[2 * 3]/(3`!).\n  by apply/orP; right; apply/ltnW/ltn_fact/lt_T.\nby rewrite -dvdn2 dvdn_divRL dvdn_fact //=; apply/ltnW/lt_T.\nQed."
}
{
  "statement": "Lemma all_allpairsP\n      (S : eqType) (T : S -> eqType) (R : Type)\n      (p : pred R) (f : forall x : S, T x -> R)\n      (s : seq S) (t : forall x : S, seq (T x)) :\n  reflect (forall (x : S) (y : T x), x \\in s -> y \\in t x -> p (f x y))\n          (all p [seq f x y | x <- s, y <- t x]).\n",
  "proof": "Proof.\nelim: s => [|x s IHs]; first by constructor.\nrewrite /= all_cat all_map /preim.\napply/(iffP andP)=> [[/allP /= ? ? x' y x'_in_xs]|p_xs_t].\n  by move: x'_in_xs y => /[1!inE] /predU1P [-> //|? ?]; exact: IHs.\nsplit; first by apply/allP => ?; exact/p_xs_t/mem_head.\nby apply/IHs => x' y x'_in_s; apply: p_xs_t; rewrite inE x'_in_s orbT.\nQed."
}
{
  "statement": "Lemma prime_FrobeniusP G K H :\n    K :!=: 1 -> prime #|H| ->\n  reflect (K ><| H = G /\\ 'C_K(H) = 1) [Frobenius G = K ><| H].\n",
  "proof": "Proof.\nmove=> ntK H_pr; have ntH: H :!=: 1 by rewrite -cardG_gt1 prime_gt1.\nhave [defG | not_sdG] := eqVneq (K ><| H) G; last first.\n  by apply: (iffP andP) => [] [defG]; rewrite defG ?eqxx in not_sdG.\napply: (iffP (Frobenius_semiregularP defG ntK ntH)) => [regH | [_ regH x]].\n  split=> //; have [x defH] := cyclicP (prime_cyclic H_pr).\n  by rewrite defH cent_cycle regH // !inE defH cycle_id andbT -cycle_eq1 -defH.\ncase/setD1P=> nt_x Hx; apply/trivgP; rewrite -regH setIS //= -cent_cycle.\nby rewrite centS // prime_meetG // (setIidPr _) ?cycle_eq1 ?cycle_subG.\nQed."
}
{
  "statement": "Lemma cardSg_cyclic G H K :\n  cyclic G -> H \\subset G -> K \\subset G -> (#|H| %| #|K|) = (H \\subset K).\n",
  "proof": "Proof.\nmove=> cycG sHG sKG; apply/idP/idP; last exact: cardSg.\ncase/cyclicP: (cyclicS sKG cycG) => x defK; rewrite {K}defK in sKG *.\ncase/dvdnP=> k ox; suffices ->: H :=: <[x ^+ k]> by apply: cycleX.\napply/eqP; rewrite (eq_subG_cyclic cycG) ?(subset_trans (cycleX _ _)) //.\nrewrite -orderE orderXdiv orderE ox ?dvdn_mulr ?mulKn //.\nby have:= order_gt0 x; rewrite orderE ox; case k.\nQed."
}
{
  "statement": "Lemma orthonormalP S :\n  reflect (uniq S /\\ {in S &, forall phi psi, '[phi, psi]_G = (phi == psi)%:R})\n          (orthonormal S).\n",
  "proof": "Proof.\nrewrite orthonormalE; have [/= normS | not_normS] := allP; last first.\n  by right=> [[_ o1S]]; case: not_normS => phi Sphi; rewrite /= o1S ?eqxx.\napply: (iffP (pairwise_orthogonalP S)) => [] [uniqS oSS].\n  split=> // [|phi psi]; first by case/andP: uniqS.\n  by have [-> _ /normS/eqP | /oSS] := eqVneq.\nsplit=> // [|phi psi Sphi Spsi /negbTE]; last by rewrite oSS // => ->.\nby rewrite /= (contra (normS _)) // cfdot0r eq_sym oner_eq0.\nQed."
}
{
  "statement": "Lemma qf_to_dnf_rterm f b : rformula f -> all dnf_rterm (qf_to_dnf f b).\n",
  "proof": "Proof.\nset ok := all dnf_rterm.\nhave cat_ok bcs1 bcs2: ok bcs1 -> ok bcs2 -> ok (bcs1 ++ bcs2).\n  by move=> ok1 ok2; rewrite [ok _]all_cat; apply/andP.\nhave and_ok bcs1 bcs2: ok bcs1 -> ok bcs2 -> ok (and_dnf bcs1 bcs2).\n  rewrite /and_dnf unlock; elim: bcs1 => //= cl1 bcs1 IH1; rewrite -andbA.\n  case/and3P=> ok11 ok12 ok1 ok2; rewrite cat_ok ?{}IH1 {bcs1 ok1}//.\n  elim: bcs2 ok2 => //= cl2 bcs2 IH2 /andP[ok2 /IH2->].\n  by rewrite /dnf_rterm !all_cat ok11 ok12 /= !andbT.\nelim: f b => //=; [ by do 2!case | | | | | by auto | | ];\n  try by repeat case/andP || intro; case: ifP; auto.\nby rewrite /dnf_rterm => ?? [] /= ->.\nQed."
}
{
  "statement": "Lemma maxnormal_charsimple G H L :\n  G <| L -> maxnormal H G L -> charsimple (G / H).\n",
  "proof": "Proof.\ncase/andP=> sGL nGL /maxgroupP[/andP[/andP[sHG not_sGH] nHL] maxH].\nhave nHG: G \\subset 'N(H) := subset_trans sGL nHL.\napply/charsimpleP; rewrite -subG1 quotient_sub1 //; split=> // HK ntHK chHK.\ncase/(inv_quotientN _): (char_normal chHK) => [|K defHK sHK]; first exact/andP.\ncase/andP; rewrite subEproper defHK => /predU1P[-> // | ltKG] nKG.\nhave nHK: H <| K by rewrite /normal sHK (subset_trans (proper_sub ltKG)).\ncase/negP: ntHK; rewrite defHK -subG1 quotient_sub1 ?normal_norm //.\nrewrite (maxH K) // ltKG -(quotientGK nHK) -defHK norm_quotient_pre //.\nby rewrite (char_norm_trans chHK) ?quotient_norms.\nQed."
}
{
  "statement": "Lemma gX_all : <[gX]>%g = [set: {unit qT}]%G.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEcard; apply/andP; split.\n  by apply/subsetP=> i; rewrite inE.\nrewrite leq_eqVlt; apply/orP; left; apply/eqP.\nrewrite -orderE gX_order card_qfpoly -[in RHS](mk_monicE primitive_mi).\nrewrite -card_qpoly -(cardC1 (0 : {poly %/ h with primitive_mi})).\nrewrite cardsT card_sub.\nby apply: eq_card => x; rewrite [LHS]unitfE.\nQed."
}
{
  "statement": "Lemma rfix_abelem (H : {set gT}) :\n  H \\subset G -> (rfix_mx rG H :=: rowg_mx (ErV @* 'C_E(H)%g))%MS.\n",
  "proof": "Proof.\nmove/subsetP=> sHG; apply/eqmxP/andP; split.\n  rewrite -rowgS rowg_mxK -sub_rVabelem_im // subsetI sub_rVabelem /=.\n  apply/centsP=> y /morphimP[v _] /[1!inE] cGv ->{y} x Gx.\n  by apply/commgP/conjg_fixP; rewrite /= -rVabelemJ ?sHG ?(rfix_mxP H _).\nrewrite genmxE; apply/rfix_mxP=> x Hx; apply/row_matrixP=> i.\nrewrite row_mul rowK; case/morphimP: (enum_valP i) => z Ez /setIP[_ cHz] ->.\nby rewrite -abelem_rV_J ?sHG // conjgE (centP cHz) ?mulKg.\nQed."
}
{
  "statement": "Lemma acts_gen A S :\n  S \\subset R -> [acts A, on S | to] -> [acts A, on <<S>> | to].\n",
  "proof": "Proof.\nmove=> sSR actsA; apply: {A}subset_trans actsA _.\napply/subsetP=> a nSa; have Da := astabs_dom nSa; rewrite !inE Da.\napply: subset_trans (_ : <<S>> \\subset actm to a @*^-1 <<S>>) _.\n  rewrite gen_subG subsetI sSR; apply/subsetP=> x Sx.\n  by rewrite inE /= actmE ?mem_gen // astabs_act.\nby apply/subsetP=> x /[!inE]; case/andP=> Rx; rewrite /= actmE.\nQed."
}
{
  "statement": "Lemma iso_eq_F0_F1 : forall r s : {perm cube}, r \\in dir_iso3 ->\n  s \\in dir_iso3 -> r F0 = s F0 -> r F1 = s F1 -> r = s.\n",
  "proof": "Proof.\nmove=> r s; rewrite !L_iso => hr hs hrs0 hrs1; apply: sop_inj; apply/eqP.\nmove/eqP: hrs0; apply/implyP; move/eqP: hrs1; apply/implyP; rewrite -!sop_spec.\nby move/sop: r hr; apply/allP; move/sop: s hs; apply/allP; vm_compute.\nQed."
}
{
  "statement": "Lemma gen_prodgP A x :\n  reflect (exists n, exists2 c, forall i : 'I_n, c i \\in A & x = \\prod_i c i)\n          (x \\in <<A>>).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[n [c Ac ->]]]; last first.\n  by apply: group_prod => i _; rewrite mem_gen ?Ac.\nhave [n ->] := gen_expgs A; rewrite /expgn Monoid.iteropE /=.\nrewrite -[n]card_ord -big_const => /prodsgP[/= c Ac def_x]. \nhave{Ac def_x} ->: x = \\prod_(i | c i \\in A) c i.\n  rewrite big_mkcond {x}def_x; apply: eq_bigr => i _.\n  by case/setU1P: (Ac i isT) => -> //; rewrite if_same.\nhave [e <- [_ /= mem_e] _] := big_enumP [preim c of A].\npose t := in_tuple e; rewrite -[e]/(val t) big_tuple.\nby exists (size e), (c \\o tnth t) => // i; rewrite -mem_e mem_tnth.\nQed."
}
{
  "statement": "Lemma reducible_cubic_root p q :\n  size p <= 4 -> 1 < size q < size p -> q %| p -> {r | root p r}.\n",
  "proof": "Proof.\nmove=> p_le4 /andP[]; rewrite leq_eqVlt eq_sym.\nhave [/poly2_root[x qx0] _ _ | _ /= q_gt2 p_gt_q] := size q =P 2.\n  by exists x; rewrite -!dvdp_XsubCl in qx0 *; apply: (dvdp_trans qx0).\ncase/dvdpP/sig_eqW=> r def_p; rewrite def_p.\nsuffices /poly2_root[x rx0]: size r = 2 by exists x; rewrite rootM rx0.\nhave /norP[nz_r nz_q]: ~~ [|| r == 0 | q == 0].\n  by rewrite -mulf_eq0 -def_p -size_poly_gt0 (leq_ltn_trans _ p_gt_q).\nrewrite def_p size_mul // -subn1 leq_subLR ltn_subRL in p_gt_q p_le4.\nby apply/eqP; rewrite -(eqn_add2r (size q)) eqn_leq (leq_trans p_le4).\nQed."
}
{
  "statement": "Lemma big_nat_widenl (m1 m2 n : nat) (P : pred nat) F :\n  m2 <= m1 ->\n  \\big[op/idx]_(m1 <= i < n | P i) F i =\n  \\big[op/idx]_(m2 <= i < n | P i && (m1 <= i)) F i.\n",
  "proof": "Proof.\nmove=> le_m21; have [le_nm1|lt_m1n] := leqP n m1.\n  rewrite big_geq// big_nat_cond big1//.\n  by move=> i /and3P[/andP[_ /leq_trans/(_ le_nm1)/ltn_geF->]].\nrewrite big_mkcond big_mkcondl (big_cat_nat _ _ le_m21) 1?ltnW//.\nrewrite [X in op X]big_nat_cond [X in op X]big_pred0; last first.\n  by move=> k; case: ltnP; rewrite andbF.\nby rewrite Monoid.mul1m; apply: congr_big_nat => // k /andP[].\nQed."
}
{
  "statement": "Lemma MhoE p G : p.-group G -> 'Mho^n(G) = <<[set x ^+ (p ^ n) | x in G]>>.\n",
  "proof": "Proof.\nmove=> pG; apply/eqP; rewrite eqEsubset !gen_subG; apply/andP.\ndo [split; apply/subsetP=> xpn; case/imsetP=> x] => [|Gx ->]; last first.\n  by rewrite Mho_p_elt ?(mem_p_elt pG).\ncase/setIdP=> Gx _ ->; have [-> | ntx] := eqVneq x 1; first by rewrite expg1n.\nby rewrite (pdiv_p_elt (mem_p_elt pG Gx) ntx) mem_gen //; apply: imset_f.\nQed."
}
{
  "statement": "Lemma find_ex_minn : {m | P m & forall n, P n -> n >= m}.\n",
  "proof": "Proof.\nhave: forall n, P n -> n >= 0 by [].\nhave: acc_nat 0.\n  case exP => n; rewrite -(addn0 n); elim: n 0 => [|n IHn] j; first by left.\n  by rewrite addSnnS; right; apply: IHn.\nmove: 0; fix find_ex_minn 2 => m IHm m_lb; case Pm: (P m); first by exists m.\napply: find_ex_minn m.+1 _ _ => [|n Pn]; first by case: IHm; rewrite ?Pm.\nby rewrite ltn_neqAle m_lb //; case: eqP Pm => // -> /idP[].\nQed."
}
{
  "statement": "Theorem factor_theorem p a : reflect (exists q, p = q * ('X - a%:P)) (root p a).\n",
  "proof": "Proof.\napply: (iffP eqP) => [pa0 | [q ->]]; last first.\n  by rewrite hornerM_comm /comm_poly hornerXsubC subrr ?simp.\nexists (\\poly_(i < size p) horner_rec (drop i.+1 p) a).\napply/polyP=> i; rewrite mulrBr coefB coefMX coefMC !coef_poly.\napply: canRL (addrK _) _; rewrite addrC; have [le_p_i | lt_i_p] := leqP.\n  rewrite nth_default // !simp drop_oversize ?if_same //.\n  exact: leq_trans (leqSpred _).\ncase: i => [|i] in lt_i_p *; last by rewrite ltnW // (drop_nth 0 lt_i_p).\nby rewrite drop1 /= -{}pa0 /horner; case: (p : seq R) lt_i_p.\nQed."
}
{
  "statement": "Lemma quotient_pseries_cat pi1s pi2s gT (G : {group gT}) :\n  pseries (pi1s ++ pi2s) G / pseries pi1s G\n    = pseries pi2s (G / pseries pi1s G).\n",
  "proof": "Proof.\nelim/last_ind: pi2s => [|pi2s pi IHpi]; first by rewrite cats0 trivg_quotient.\nhave psN := pseries_normal _ G; set K := pseries _ G.\ncase: (third_isom (pseries_sub_catl pi1s pi2s G) (psN _)) => //= f inj_f im_f.\nhave nH2H: pseries pi2s (G / K) <| pseries (pi1s ++ rcons pi2s pi) G / K.\n  rewrite -IHpi morphim_normal // -cats1 catA.\n  by apply/andP; rewrite pseries_sub_catl pseries_norm2.\napply: (quotient_inj nH2H).\n  by apply/andP; rewrite /= -cats1 pseries_sub_catl pseries_norm2.\nrewrite /= quotient_pseries /= -IHpi -rcons_cat.\nrewrite -[G / _ / _](morphim_invm inj_f) //= {2}im_f //.\nrewrite -(@injmF [igFun of @pcore pi]) /= ?injm_invm ?im_f // -quotient_pseries.\nby rewrite -im_f ?morphim_invm ?morphimS ?normal_sub.\nQed."
}
{
  "statement": "Lemma perm_onC (S1 S2 : {set T}) (u1 u2 : {perm T}) :\n    perm_on S1 u1 -> perm_on S2 u2 ->\n    [disjoint S1 & S2] ->\n  commute u1 u2.\n",
  "proof": "Proof.\nmove=> pS1 pS2 S12; apply/permP => t; rewrite !permM.\ncase/boolP : (t \\in S1) => tS1.\n  have /[!disjoint_subset] /subsetP {}S12 := S12.\n  by rewrite !(out_perm pS2) //; apply: S12; rewrite // perm_closed.\ncase/boolP : (t \\in S2) => tS2.\n  have /[1!disjoint_sym] /[!disjoint_subset] /subsetP {}S12 := S12.\n  by rewrite !(out_perm pS1) //; apply: S12; rewrite // perm_closed.\nby rewrite (out_perm pS1) // (out_perm pS2) // (out_perm pS1).\nQed."
}
{
  "statement": "Lemma cfIndInd phi :\n  K \\subset G -> H \\subset K -> 'Ind[G] ('Ind[K] phi) = 'Ind[G] phi.\n",
  "proof": "Proof.\nmove=> sKG sHK; apply/cfun_inP=> x Gx; rewrite !cfIndE ?(subset_trans sHK) //.\napply: canLR (mulKf (neq0CG K)) _; rewrite mulr_sumr mulr_natl.\ntransitivity (\\sum_(y in G) \\sum_(z in K) #|H|%:R^-1 * phi ((x ^ y) ^ z)).\n  by apply: eq_bigr => y Gy; rewrite cfIndE // -mulr_sumr.\nsymmetry; rewrite exchange_big /= -sumr_const; apply: eq_bigr => z Kz.\nrewrite (reindex_inj (mulIg z)).\nby apply: eq_big => [y | y _]; rewrite ?conjgM // groupMr // (subsetP sKG).\nQed."
}
{
  "statement": "Lemma purely_inseparable_elementP_pchar {K x} :\n  reflect (exists2 n, [pchar L].-nat n & x ^+ n \\in K)\n          (purely_inseparable_element K x).\n",
  "proof": "Proof.\nrewrite /purely_inseparable_element.\ncase: ex_minnP => n /andP[pcharLn /=]; rewrite subfield_closed => sepKxn min_xn.\napply: (iffP idP) => [Kxn | [m pcharLm Kxm]]; first by exists n.\nhave{min_xn}: n <= m by rewrite min_xn ?pcharLm ?base_separable.\nrewrite leq_eqVlt => /predU1P[-> // | ltnm]; pose p := pdiv m.\nhave m_gt1: 1 < m by have [/leq_ltn_trans->] := andP pcharLn.\nhave pcharLp: p \\in [pchar L] by rewrite (pnatPpi pcharLm) ?pi_pdiv.\nhave [/p_natP[em Dm] /p_natP[en Dn]]: p.-nat m /\\ p.-nat n.\n  by rewrite -!(eq_pnat _ (pcharf_eq pcharLp)).\nrewrite Dn Dm ltn_exp2l ?prime_gt1 ?pdiv_prime // in ltnm.\nrewrite -(Fadjoin_idP Kxm) Dm -(subnKC ltnm) addSnnS expnD exprM -Dn.\nby rewrite -pcharf_p_separable.\nQed."
}
{
  "statement": "Lemma vcharP phi :\n  reflect (exists2 chi1, chi1 \\is a character\n            & exists2 chi2, chi2 \\is a character & phi = chi1 - chi2)\n          (phi \\in 'Z[irr G]).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [a Na [b Nb ->]]]; last by rewrite rpredB ?char_vchar.\ncase/zchar_tuple_expansion=> z Zz ->; rewrite (bigID (fun i => 0 <= z i)) /=.\nset chi1 := \\sum_(i | _) _; set nchi2 := \\sum_(i | _) _.\nexists chi1; last exists (- nchi2); last by rewrite opprK.\n  apply: rpred_sum => i zi_ge0; rewrite -tnth_nth rpredZ_nat ?irr_char //.\n  by rewrite natrEint Zz.\nrewrite -sumrN rpred_sum // => i zi_lt0; rewrite -scaleNr -tnth_nth.\nrewrite rpredZ_nat ?irr_char // natrEint rpredN Zz oppr_ge0 ltW //.\nby rewrite real_ltNge ?Rreal_int.\nQed."
}
{
  "statement": "Lemma field_mul_group_cyclic (F : fieldType) (f : gT -> F) :\n    {in G &, {morph f : u v / u * v >-> (u * v)%R}} ->\n    {in G, forall x, f x = 1%R <-> x = 1} ->\n  cyclic G.\n",
  "proof": "Proof.\nmove=> fM f1P; have f1 : f 1 = 1%R by apply/f1P.\napply: (div_ring_mul_group_cyclic f1 fM) => [x|].\n  case/setD1P=> x1 Gx; rewrite unitfE; apply: contra x1.\n  by rewrite subr_eq0 => /eqP/f1P->.\napply/centsP=> x Gx y Gy; apply/commgP/eqP.\napply/f1P; rewrite ?fM ?groupM ?groupV //.\nby rewrite mulrCA -!fM ?groupM ?groupV // mulKg mulVg.\nQed."
}
{
  "statement": "Lemma sposDl x y : lt 0 x -> le 0 y -> lt 0 (x + y).\n",
  "proof": "Proof.\n  have sqrtJ z : le 0 z -> conj (sqrt z) = sqrt z.\n    rewrite posE -{2}[z]sqrtK -subr_eq0 -mulrBr mulf_eq0 subr_eq0.\n    by case/pred2P=> ->; rewrite ?rmorph0.\n  case/andP=> nz_x /sqrtJ uJ /sqrtJ vJ.\n  set u := sqrt x in uJ; set v := sqrt y in vJ; pose w := u + i * v.\n  have ->: x + y = w * conj w.\n    rewrite rmorphD rmorphM /= iJ uJ vJ mulNr mulrC -subr_sqr sqrMi opprK.\n    by rewrite !sqrtK.\n  apply/andP; split; last by apply/posP; exists w.\n  rewrite -normK expf_eq0 //=; apply: contraNneq nz_x => /norm_eq0 w0.\n  rewrite -[x]sqrtK expf_eq0 /= -/u -(inj_eq mul2I) !mulr2n -{2}(rmorph0 conj).\n  by rewrite -w0 rmorphD rmorphM /= iJ uJ vJ mulNr addrACA subrr addr0.\nQed."
}
{
  "statement": "Lemma cyclic_dprod K H G :\n  K \\x H = G -> cyclic K -> cyclic H -> cyclic G = coprime #|K| #|H| .\n",
  "proof": "Proof.\ncase/dprodP=> _ defKH cKH tiKH cycK cycH; pose m := lcmn #|K| #|H|.\napply/idP/idP=> [/cyclicP[x defG] | coKH]; last by rewrite -defKH cyclicM.\nrewrite /coprime -dvdn1 -(@dvdn_pmul2l m) ?lcmn_gt0 ?cardG_gt0 //.\nrewrite muln_lcm_gcd muln1 -TI_cardMg // defKH defG order_dvdn.\nhave /mulsgP[y z Ky Hz ->]: x \\in K * H by rewrite defKH defG cycle_id.\nrewrite -[1]mulg1 expgMn; last exact/commute_sym/(centsP cKH).\napply/eqP; congr (_ * _); apply/eqP; rewrite -order_dvdn.\n  exact: dvdn_trans (order_dvdG Ky) (dvdn_lcml _ _).\nexact: dvdn_trans (order_dvdG Hz) (dvdn_lcmr _ _).\nQed."
}
{
  "statement": "Lemma eq_abelian_type_isog G H :\n  abelian G -> abelian H -> isog G H = (abelian_type G == abelian_type H).\n",
  "proof": "Proof.\nmove=> cGG cHH; apply/idP/eqP; first exact: isog_abelian_type.\nhave{cGG} [bG defG <-] := abelian_structure cGG.\nhave{cHH} [bH defH <-] := abelian_structure cHH.\nelim: bG bH G H defG defH => [|x bG IHb] [|y bH] // G H.\n  rewrite !big_nil => <- <- _.\n  by rewrite isog_cyclic_card ?cyclic1 ?cards1.\nrewrite !big_cons => defG defH /= [eqxy eqb].\napply: (isog_dprod defG defH).\n  by rewrite isog_cyclic_card ?cycle_cyclic -?orderE ?eqxy /=.\ncase/dprodP: defG => [[_ G' _ defG]] _ _ _; rewrite defG.\ncase/dprodP: defH => [[_ H' _ defH]] _ _ _; rewrite defH.\nexact: IHb eqb.\nQed."
}
{
  "statement": "Lemma permutationsE s :\n    0 < size s ->\n  perm_eq (perms s) [seq x :: t | x <- undup s, t <- perms (rem x s)].\n",
  "proof": "Proof.\nmove=> nt_s; apply/uniq_perm=> [||t]; first exact: permutations_uniq.\n  apply/allpairs_uniq_dep=> [|x _|]; rewrite ?undup_uniq  ?permutations_uniq //.\n  by case=> [_ _] [x t] _ _ [-> ->].\nrewrite mem_permutations; apply/idP/allpairsPdep=> [Dt | [x [t1 []]]].\n  rewrite -(perm_size Dt) in nt_s; case: t nt_s => // x t _ in Dt *.\n  have s_x: x \\in s by rewrite -(perm_mem Dt) mem_head.\n  exists x, t; rewrite mem_undup mem_permutations; split=> //.\n  by rewrite -(perm_cons x) (permPl Dt) perm_to_rem.\nrewrite mem_undup mem_permutations -(perm_cons x) => s_x Dt1 ->.\nby rewrite (permPl Dt1) perm_sym perm_to_rem.\nQed."
}
{
  "statement": "Lemma mx_rsim_in_submod U V (modU : mG U) (modV : mG V) :\n  let U' := <<in_submod V U>>%MS in\n    (U <= V)%MS ->\n  exists modU' : mxmodule (sr modV) U', mx_rsim (sr modU) (sr modU').\n",
  "proof": "Proof.\nmove=> U' sUV; have modU': mxmodule (sr modV) U'.\n  by rewrite (eqmx_module _ (genmxE _)) in_submod_module.\nhave rankU': \\rank U = \\rank U' by rewrite genmxE mxrank_in_submod.\npose v1 := val_submod 1%:M; pose U1 := v1 _ U.\nhave sU1V: (U1 <= V)%MS by rewrite val_submod1.\nhave sU1U': (in_submod V U1 <= U')%MS by rewrite genmxE submxMr ?val_submod1.\nexists modU', (in_submod U' (in_submod V U1)) => // [|x Gx].\n  apply/row_freeP; exists (v1 _ _ *m v1 _ _ *m in_submod U 1%:M).\n  rewrite mulmxA [X in X *m _]mulmxA -in_submodE.\n  by rewrite -!val_submodE !in_submodK ?val_submodK.\nrewrite -!in_submodJ // -(val_submodJ modU) // mul1mx.\nby rewrite 2!{1}in_submodE mulmxA (mulmxA _ U1) -val_submodE -!in_submodE.\nQed."
}
{
  "statement": "Lemma Mho_cprod A B G : A \\* B = G -> 'Mho^n(A) \\* 'Mho^n(B) = 'Mho^n(G).\n",
  "proof": "Proof.\ncase/cprodP => [[H K -> ->{A B}]] <- cHK; rewrite cprodEY //; last first.\n  by rewrite (subset_trans (subset_trans _ cHK)) ?centS ?Mho_sub.\napply/eqP; rewrite -(cent_joinEr cHK) eqEsubset join_subG /=.\nrewrite !MhoS ?joing_subl ?joing_subr //= cent_joinEr // -genM_join.\napply: genS; apply/subsetP=> xypn /imsetP[_ /setIdP[/imset2P[x y Hx Ky ->]]].\nmove/constt_p_elt; move: (pdiv _) => p <- ->.\nhave cxy: commute x y by red; rewrite -(centsP cHK).\nrewrite consttM // expgMn; last exact: commuteX2.\nby rewrite mem_mulg ?Mho_p_elt ?groupX ?p_elt_constt.\nQed."
}
{
  "statement": "Lemma maxnormal_minnormal G L M :\n    G \\subset 'N(M) -> L \\subset 'N(G) ->  maxnormal M G L ->\n  minnormal (G / M) (L / M).\n",
  "proof": "Proof.\nmove=> nMG nGL /maxgroupP[/andP[/andP[sMG ltMG] nML] maxM]; apply/mingroupP.\nrewrite -subG1 quotient_sub1 ?ltMG ?quotient_norms //.\nsplit=> // Hb /andP[ntHb nHbL]; have nsMG: M <| G by apply/andP.\ncase/inv_quotientS=> // H defHb sMH sHG; rewrite defHb; congr (_ / M).\napply/eqP; rewrite eqEproper sHG /=; apply: contra ntHb => ltHG.\nhave nsMH: M <| H := normalS sMH sHG nsMG.\nrewrite defHb quotientS1 // (maxM H) // ltHG /=  -(quotientGK nsMH) -defHb.\nexact: norm_quotient_pre.\nQed."
}
{
  "statement": "Lemma coprime_has_primes m n :\n  0 < m -> 0 < n -> coprime m n = ~~ has [in primes m] (primes n).\n",
  "proof": "Proof.\nmove=> m_gt0 n_gt0; apply/eqP/hasPn=> [mn1 p | no_p_mn].\n  rewrite /= !mem_primes m_gt0 n_gt0 /= => /andP[pr_p p_n].\n  have:= prime_gt1 pr_p; rewrite pr_p ltnNge -mn1 /=; apply: contra => p_m.\n  by rewrite dvdn_leq ?gcdn_gt0 ?m_gt0 // dvdn_gcd ?p_m.\napply/eqP; rewrite eqn_leq gcdn_gt0 m_gt0 andbT leqNgt; apply/negP.\nmove/pdiv_prime; set p := pdiv _ => pr_p.\nmove/implyP: (no_p_mn p); rewrite /= !mem_primes m_gt0 n_gt0 pr_p /=.\nby rewrite !(dvdn_trans (pdiv_dvd _)) // (dvdn_gcdl, dvdn_gcdr).\nQed."
}
{
  "statement": "Lemma injm_p_rank p : 'r_p(f @* G) = 'r_p(G).\n",
  "proof": "Proof.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  have [fE] := p_rank_witness p (f @* G); move: 'r_p(_) => n Ep_fE.\n  apply/p_rank_geP; exists (f @*^-1 fE)%G.\n  rewrite -injm_pnElem ?subsetIl ?(group_inj (morphpreK _)) //.\n  by case/pnElemP: Ep_fE => sfEG _ _; rewrite (subset_trans sfEG) ?morphimS.\nhave [E] := p_rank_witness p G; move: 'r_p(_) => n EpE.\napply/p_rank_geP; exists (f @* E)%G; rewrite injm_pnElem //.\nby case/pnElemP: EpE => sEG _ _; rewrite (subset_trans sEG).\nQed."
}
{
  "statement": "Lemma has_non_scalar_mxP m n (R : 'A_(m, n)) :\n    (1%:M \\in R)%MS ->\n  reflect (exists2 A, A \\in R & ~~ is_scalar_mx A)%MS (1 < \\rank R).\n",
  "proof": "Proof.\ncase: (posnP n) => [-> | n_gt0] in R *; set S := mxvec _ => sSR.\n  by rewrite [R]thinmx0 mxrank0; right; case; rewrite /is_scalar_mx ?insubF.\nhave rankS: \\rank S = 1%N.\n  apply/eqP; rewrite eqn_leq rank_leq_row lt0n mxrank_eq0 mxvec_eq0.\n  by rewrite -mxrank_eq0 mxrank1 -lt0n.\nrewrite -{2}rankS (ltn_leqif (mxrank_leqif_sup sSR)).\napply: (iffP idP) => [/row_subPn[i] | [A sAR]].\n  rewrite -[row i R]vec_mxK memmx1; set A := vec_mx _ => nsA.\n  by exists A; rewrite // vec_mxK row_sub.\nby rewrite -memmx1; apply/contra/submx_trans.\nQed."
}
{
  "statement": "Lemma morphim_Mho rT D G (f : {morphism D >-> rT}) :\n  G \\subset D -> f @* 'Mho^n(G) = 'Mho^n(f @* G).\n",
  "proof": "Proof.\nmove=> sGD; have sGnD := subset_trans (Mho_sub G) sGD.\napply/eqP; rewrite eqEsubset {1}morphim_gen -1?gen_subG // !gen_subG.\napply/andP; split; apply/subsetP=> y.\n  case/morphimP=> xpn _ /imsetP[x /setIdP[Gx]].\n  set p := pdiv _ => p_x -> -> {xpn y}; have Dx := subsetP sGD x Gx.\n  by rewrite morphX // Mho_p_elt ?morph_p_elt ?mem_morphim.\ncase/imsetP=> _ /setIdP[/morphimP[x Dx Gx ->]].\nset p := pdiv _ => p_fx ->{y}; rewrite -(constt_p_elt p_fx) -morph_constt //.\nby rewrite -morphX ?mem_morphim ?Mho_p_elt ?groupX ?p_elt_constt.\nQed."
}
{
  "statement": "Lemma abstrXP  (i : nat) (t : tF) (e : seq F) (x : F) :\n  rterm t -> (eval_poly e (abstrX i t)).[x] = eval (set_nth 0 e i x) t.\n",
  "proof": "Proof.\nelim: t => [n | r | n | t tP s sP | t tP | t tP n | t tP s sP | t tP | t tP n] h.\n- move=> /=; case ni: (_ == _);\n    rewrite //= ?(mul0r,add0r,addr0,polyC1,mul1r,hornerX,hornerC);\n    by rewrite // nth_set_nth /= ni.\n- by rewrite /= mul0r add0r hornerC.\n- by rewrite /= mul0r add0r hornerC.\n- by case/andP: h => *; rewrite /= eval_sumpT hornerD tP ?sP.\n- by rewrite /= eval_opppT hornerN tP.\n- by rewrite /= eval_natmulpT hornerMn tP.\n- by case/andP: h => *; rewrite /= eval_mulpT hornerM tP ?sP.\n- by [].\n- elim: n h => [|n ihn] rt; first by rewrite /= expr0 mul0r add0r hornerC.\n  by rewrite /= eval_mulpT exprSr hornerM ihn // mulrC tP.\nQed."
}
{
  "statement": "Lemma dvdp_mul2r r p q : r != 0 -> (p * r %| q * r) = (p %| q).\n",
  "proof": "Proof.\nmove=> nzr.\nhave [-> | pn0] := eqVneq p 0.\n  by rewrite mul0r !dvd0p mulf_eq0 (negPf nzr) orbF.\nhave [-> | qn0] := eqVneq q 0; first by rewrite mul0r !dvdp0.\napply/idP/idP; last by move=> ?; rewrite dvdp_mul ?dvdpp.\nrewrite dvdp_eq; set c := _ ^+ _; set x := _ %/ _; move/eqP=> Hx.\napply: (@eq_dvdp c x); first by rewrite expf_neq0 // lead_coef_eq0 mulf_neq0.\nby apply: (mulIf nzr); rewrite -mulrA -scalerAl.\nQed."
}
{
  "statement": "Lemma orthonormalP S :\n  reflect (uniq S /\\ {in S &, forall phi psi, '[phi, psi] = (phi == psi)%:R})\n          (orthonormal form S).\n",
  "proof": "Proof.\nrewrite orthonormalE; have [/= normS | not_normS] := allP; last first.\n  by right=> [[_ o1S]]; case: not_normS => phi Sphi; rewrite /= o1S ?eqxx.\napply: (iffP (pairwise_orthogonalP S)) => [] [uniqS oSS].\n  split=> // [|phi psi]; first by case/andP: uniqS.\n  by have [-> _ /normS/eqP | /oSS] := altP eqP.\nsplit=> // [|phi psi Sphi Spsi /negbTE]; last by rewrite oSS // => ->.\nby rewrite /= (contra (normS _)) // linear0r  eq_sym oner_eq0.\nQed."
}
{
  "statement": "Lemma cfclassP (A : {group gT}) phi psi :\n  reflect (exists2 y, y \\in A & psi = phi ^ y)%CF (psi \\in phi ^: A)%CF.\n",
  "proof": "Proof.\napply: (iffP imageP) => [[_ /rcosetsP[y Ay ->] ->] | [y Ay ->]].\n  by case: repr_rcosetP => z /setIdP[Az _]; exists (z * y)%g; rewrite ?groupM.\nwithout loss nHy: y Ay / y \\in 'N(H).\n  have [nHy | /cfConjgEout->] := boolP (y \\in 'N(H)); first exact.\n  by move/(_ 1%g); rewrite !group1 !cfConjgJ1; apply.\nexists ('I_A[phi] :* y); first by rewrite -rcosetE imset_f.\ncase: repr_rcosetP => z /setIP[_ /setIdP[nHz /eqP Tz]].\nby rewrite cfConjgMnorm ?Tz.\nQed."
}
{
  "statement": "Lemma nil_class_quotient_center G :\n  nilpotent (G) -> nil_class (G / 'Z(G)) = (nil_class G).-1.\n",
  "proof": "Proof.\nmove=> nilG; have nsZ1G := ucn_normal 1 G.\napply/eqP; rewrite -ucn1 eqn_leq; apply/andP; split.\n  apply/ucn_nil_classP; rewrite ?quotient_nil //= -quotient_ucn_add ucn1.\n  by rewrite (ucn_nil_classP _ _ _) ?addn1 ?leqSpred.\nrewrite -subn1 leq_subLR addnC; apply/ucn_nil_classP => //=.\napply: (quotient_inj _ nsZ1G) => /=.\n  by apply: normalS (ucn_sub _ _) nsZ1G; rewrite /= addnS ucn_sub_geq.\nby rewrite quotient_ucn_add; apply/ucn_nil_classP; rewrite //= quotient_nil.\nQed."
}
{
  "statement": "Lemma fcycle_consEflatten : exists k, x :: p = flatten (nseq k.+1 (orbit x)).\n",
  "proof": "Proof.\nmove: f_p; rewrite fcycle_consE; elim/ltn_ind: (size p) => n IHn t_cycle.\nhave := order_le_cycle t_cycle (mem_head _ _); rewrite size_traject.\ncase: ltngtP => [||<-] //; last by exists 0; rewrite /= cats0.\nrewrite ltnS => n_ge _; have := t_cycle.\nrewrite -(subnKC n_ge) -addnS trajectD.\nrewrite (iter_order_in (mem_fcycle f_p) (inj_cycle f_p)) ?mem_head//.\nset m := (_ - _) => cycle_cat.\nhave [||k->] := IHn m; last by exists k.+1.\n  by rewrite ltn_subrL (leq_trans _ n_ge) ?order_gt0.\nmove: cycle_cat; rewrite -orderSpred/= rcons_cat rcons_cons -cat_rcons.\nby rewrite cat_path last_rcons => /andP[].\nQed."
}
{
  "statement": "Lemma fin_all_exists U (P : forall x : T, U x -> Prop) :\n  (forall x, exists u, P x u) -> (exists u, forall x, P x (u x)).\n",
  "proof": "Proof.\nmove=> ex_u; pose Q m x := enum_rank x < m -> {ux | P x ux}.\nsuffices: forall m, m <= #|T| -> exists w : forall x, Q m x, True.\n  case/(_ #|T|)=> // w _; pose u x := sval (w x (ltn_ord _)).\n  by exists u => x; rewrite {}/u; case: (w x _).\nelim=> [|m IHm] ltmX; first by have w x: Q 0 x by []; exists w.\nhave{IHm} [w _] := IHm (ltnW ltmX); pose i := Ordinal ltmX.\nhave [u Pu] := ex_u (enum_val i); suffices w' x: Q m.+1 x by exists w'.\nrewrite /Q ltnS leq_eqVlt (val_eqE _ i); case: eqP => [def_i _ | _ /w //].\nby rewrite -def_i enum_rankK in u Pu; exists u.\nQed."
}
{
  "statement": "Lemma big_only1 (I : finType) (i : I) (P : pred I) (F : I -> R) : P i ->\n    (forall j, j != i -> P j -> F j = idx) ->\n  \\big[op/idx]_(j | P j) F j = F i.\n",
  "proof": "Proof.\nmove=> Pi Fisx; have := index_enum_uniq I.\nhave : i \\in index_enum I by rewrite mem_index_enum.\nelim: index_enum => //= j r IHr /[!inE]; case: eqVneq => [<-|nij]//=.\n  move=> _ /andP[iNr runiq]; rewrite big_cons/= Pi big1_seq ?Monoid.mulm1//.\n  by move=> {}j /andP[/Fisx + jr] => ->//; apply: contraNneq iNr => <-.\nmove=> ir /andP[jNr runiq]; rewrite big_cons IHr//.\nby case: ifPn => // /Fisx->; rewrite 1?eq_sym// Monoid.mul1m.\nQed."
}
{
  "statement": "Lemma qacts_coset (H K : {group rT}) :\n    H \\subset D -> [acts A, on K | to] ->\n  [acts qact_dom to H, on (coset H) @* K | to / H].\n",
  "proof": "Proof.\nmove=> sHD aK.\napply/subsetP=> x qdx; rewrite inE qdx inE; apply/subsetP=> y.\ncase/morphimP=> z Nz Kz /= e; rewrite e inE qactE // imset_f // inE.\nmove/gactsP: aK; move/(_ x (subsetP (qact_dom_doms sHD) _ qdx) z); rewrite Kz.\nmove->; move/acts_act: (acts_qact_dom to H); move/(_ x qdx z).\nby rewrite Nz andbT.\nQed."
}
{
  "statement": "Lemma injm_pmaxElem p (E : {group aT}) :\n  E \\subset D -> ((f @* E)%G \\in 'E*_p(f @* G)) = (E \\in 'E*_p(G)).\n",
  "proof": "Proof.\nmove=> sED; have defE := morphim_invm injf sED.\napply/pmaxElemP/pmaxElemP=> [] [EpE maxE].\n  split=> [|H EpH sEH]; first by rewrite injm_pElem in EpE.\n  have sHD: H \\subset D by apply: subset_trans (sGD); case/pElemP: EpH.\n  by rewrite -(morphim_invm injf sHD) [f @* H]maxE ?morphimS ?injm_pElem.\nrewrite injm_pElem //; split=> // fH Ep_fH sfEH; have [sfHG _] := pElemP Ep_fH.\nhave sfHD : fH \\subset f @* D by rewrite (subset_trans sfHG) ?morphimS.\nrewrite -(morphpreK sfHD); congr (f @* _).\nrewrite [_ @*^-1 fH]maxE -?sub_morphim_pre //.\nby rewrite -injm_pElem ?subsetIl // (group_inj (morphpreK sfHD)).\nQed."
}
{
  "statement": "Lemma dvdp_gdcor p q : q != 0 -> p %| (gdcop q p) * (q ^+ size p).\n",
  "proof": "Proof.\nrewrite /gdcop => nz_q; have [n hsp] := ubnPleq (size p).\nelim: n => [|n IHn] /= in p hsp *; first by rewrite (negPf nz_q) mul0r dvdp0.\nhave [_ | ncop_pq] := ifPn; first by rewrite dvdp_mulr.\nhave g_gt1: 1 < size (gcdp p q).\n  rewrite ltn_neqAle eq_sym ncop_pq size_poly_gt0 gcdp_eq0.\n  by rewrite negb_and nz_q orbT.\nhave [-> | nz_p] := eqVneq p 0.\n  by rewrite div0p exprSr mulrA dvdp_mulr // IHn // size_poly0.\nhave le_d_p: size (p %/ gcdp p q) < size p.\n  rewrite size_divp -?size_poly_eq0 -(subnKC g_gt1) // add2n /=.\n  by rewrite polySpred // ltnS subSS leq_subr.\nrewrite -[p in p %| _](divpK (dvdp_gcdl p q)) exprSr mulrA.\nby rewrite dvdp_mul ?IHn ?dvdp_gcdr // -ltnS (leq_trans le_d_p).\nQed."
}
{
  "statement": "Lemma astabsEsd : 'N(G | to) = sdpair2 @*^-1 'N(sdpair1 @* G).\n",
  "proof": "Proof.\napply/setP=> a; apply/idP/idP=> [nGa|].\n  have Da := astabs_dom nGa; rewrite mem_morphpre // inE sub_conjg.\n  apply/subsetP=> _ /morphimP[x Rx Gx ->].\n  by rewrite mem_conjgV -sdpair_act // mem_morphim ?gact_stable ?astabs_act.\ncase/morphpreP=> Da nGa; rewrite !inE Da; apply/subsetP=> x Gx.\nhave Rx := subsetP sGR _ Gx; have Rxa: to x a \\in R by rewrite gact_stable.\nrewrite inE -sub1set -(injmSK injm_sdpair1) ?morphim_set1 ?sub1set //=.\nby rewrite sdpair_act ?memJ_norm ?mem_morphim.\nQed."
}
{
  "statement": "Lemma dvdp_mul d1 d2 m1 m2 : d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2.\n",
  "proof": "Proof.\ncase: (eqVneq d1 0) => [-> /dvd0pP -> | d1n0]; first by rewrite !mul0r dvdpp.\ncase: (eqVneq d2 0) => [-> _ /dvd0pP -> | d2n0]; first by rewrite !mulr0.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Hq1.\nrewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> Hq2.\napply: (@eq_dvdp (c1 * c2) (q1 * q2)).\n  by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\nrewrite -scalerA scalerAr scalerAl Hq1 Hq2 -!mulrA.\nby rewrite [d1 * (q2 * _)]mulrCA.\nQed."
}
{
  "statement": "Lemma eq_onthP {s1 s2} :\n  [<-> s1 = s2;\n   forall i : nat, i < maxn (size s1) (size s2) -> onth s1 i = onth s2 i;\n   forall i : nat, onth s1 i = onth s2 i].\n",
  "proof": "Proof.\ntfae=> [->//|eqs12 i|eqs12].\n  have := eqs12 i; case: ltnP => [_ ->//|].\n  by rewrite geq_max => /andP[is1 is2] _; rewrite !onth_default.\nhave /eqP eq_size_12 : size s1 == size s2.\n  by rewrite eqn_leq -!onthNE eqs12 onthNE -eqs12 onthNE !leqnn.\napply/(inj_map Some_inj)/(@eq_from_nth _ None); rewrite !size_map//.\nby move=> i _; rewrite -!onthE eqs12.\nQed."
}
{
  "statement": "Lemma capmx_subSocle m (M : 'M_(m, n)) :\n  mxmodule M -> (M :&: S :=: \\sum_(W : sG | P W) (M :&: W))%MS.\n",
  "proof": "Proof.\nmove=> modM; apply/eqmxP/andP; split; last first.\n  by apply/sumsmx_subP=> W P_W; rewrite capmxS // (sumsmx_sup W).\nhave modMS: mxmodule (M :&: S)%MS by rewrite capmx_module ?subSocle_module.\nhave [J /= U simU defMS _] := mxsemisimpleS modMS (capmxSr M S) ssimS.\nrewrite -defMS; apply/sumsmx_subP=> j _.\nhave [sUjV sUjS]: (U j <= M /\\ U j <= S)%MS.\n  by apply/andP; rewrite -sub_capmx -defMS (sumsmx_sup j).\nhave [W P_W isoWU] := subSocle_iso (simU j) sUjS.\nrewrite (sumsmx_sup W) // sub_capmx sUjV mx_iso_component //.\nexact: socle_simple.\nQed."
}
{
  "statement": "Lemma ltn_divpl d q p : d != 0 ->\n   (size (q %/ d) < size p) = (size q < size (p * d)).\n",
  "proof": "Proof.\nmove=> dn0.\nhave: (lead_coef d) ^+ (scalp q d) != 0 by apply: lc_expn_scalp_neq0.\nmove/(size_scale q)<-; rewrite divp_eq; have [->|quo0] := eqVneq (q %/ d) 0.\n  rewrite mul0r add0r size_poly0 size_poly_gt0.\n  have [->|pn0] := eqVneq p 0; first by rewrite mul0r size_poly0 ltn0.\n  by rewrite size_mul // (polySpred pn0) addSn ltn_addl // ltn_modp.\nrewrite size_polyDl; last first.\n  by rewrite size_mul // (polySpred quo0) addSn /= ltn_addl // ltn_modp.\nhave [->|pn0] := eqVneq p 0; first by rewrite mul0r size_poly0 !ltn0.\nby rewrite !size_mul ?quo0 // (polySpred dn0) !addnS ltn_add2r.\nQed."
}
{
  "statement": "Lemma Falgebra_FieldMixin :\n  GRing.integral_domain_axiom aT -> GRing.field_axiom aT.\n",
  "proof": "Proof.\nmove=> domT u nz_u; apply/unitrP.\nhave kerMu: lker (amulr u) == 0%VS.\n  rewrite eqEsubv sub0v andbT; apply/subvP=> v; rewrite memv_ker lfunE /=.\n  by move/eqP/domT; rewrite (negPf nz_u) orbF memv0.\nhave /memv_imgP[v _ vu1]: 1 \\in limg (amulr u); last rewrite lfunE /= in vu1.\n  suffices /eqP->: limg (amulr u) == fullv by rewrite memvf.\n  by rewrite -dimv_leqif_eq ?subvf ?limg_dim_eq // (eqP kerMu) capv0.\nexists v; split=> //; apply: (lker0P kerMu).\nby rewrite !lfunE /= -mulrA -vu1 mulr1 mul1r.\nQed."
}
{
  "statement": "Theorem Frobenius_Cauchy G S : [acts G, on S | to] ->\n  \\sum_(a in G) #|'Fix_(S | to)[a]| = (#|orbit to G @: S| * #|G|)%N.\n",
  "proof": "Proof.\nmove=> GactS; have sGD := acts_dom GactS.\ntransitivity (\\sum_(a in G) \\sum_(x in 'Fix_(S | to)[a]) 1%N).\n  by apply: eq_bigr => a _; rewrite -sum1_card.\nrewrite (exchange_big_dep [in S]) /= => [|a x _]; last by case/setIP.\nrewrite (set_partition_big _ (orbit_partition GactS)) -sum_nat_const /=.\napply: eq_bigr => _ /imsetP[x Sx ->].\nrewrite -(card_orbit_in_stab x sGD) -sum_nat_const.\napply: eq_bigr => y; rewrite orbit_in_sym // => /imsetP[a Ga defx].\nrewrite defx astab1_act_in ?(subsetP sGD) //.\nrewrite -{2}(conjGid Ga) -conjIg cardJg -sum1_card setIA (setIidPl sGD).\nby apply: eq_bigl => b; rewrite !(sub1set, inE) -(acts_act GactS Ga) -defx Sx.\nQed."
}
{
  "statement": "Lemma Im_rootC_ge0 n x : (n > 1)%N -> 0 <= 'Im (n.-root x).\n",
  "proof": "Proof.\nset y := n.-root x => n_gt1; have n_gt0 := ltnW n_gt1.\napply: wlog_neg; rewrite -real_ltNge ?rpred0 // => ltIy0.\nsuffices [z zn_x leI0z]: exists2 z, z ^+ n = x & 'Im z >= 0.\n  by rewrite /y; case_rootC => /= y1 _ /(_ z n_gt0 zn_x)/argCleP[].\nhave [w wn1 ltRw0] := neg_unity_root n_gt1.\nwlog leRI0yw: w wn1 ltRw0 / 0 <= 'Re y * 'Im w.\n  move=> IHw; have: 'Re y * 'Im w \\is real by rewrite rpredM.\n  case/real_ge0P=> [|/ltW leRIyw0]; first exact: IHw.\n  apply: (IHw w^* ); rewrite ?Re_conj ?Im_conj ?mulrN ?oppr_ge0 //.\n  by rewrite -rmorphXn wn1 rmorph1.\nexists (w * y); first by rewrite exprMn wn1 mul1r rootCK.\nrewrite [w]Crect [y]Crect mulC_rect.\nby rewrite Im_rect ?rpredD ?rpredN 1?rpredM // addr_ge0 // ltW ?nmulr_rgt0.\nQed."
}
{
  "statement": "Lemma vspaceOverP V_F :\n  {V | [/\\ V_F = vspaceOver V, (F * V <= V)%VS & V_F =i V]}.\n",
  "proof": "Proof.\npose V := (F * <<vbasis V_F : seq L>>)%VS.\nhave idV: (F * V)%VS = V by rewrite prodvA prodv_id.\nsuffices defVF: V_F = vspaceOver V.\n  by exists V; split=> [||u]; rewrite ?defVF ?mem_vspaceOver ?idV.\napply/vspaceP=> v; rewrite mem_vspaceOver idV.\ndo [apply/idP/idP; last rewrite /V unlock] => [/coord_vbasis|/coord_span] ->.\n  by apply: memv_suml => i _; rewrite memv_mul ?subvsP ?memv_span ?memt_nth.\napply: memv_suml => i _; rewrite -tnth_nth; set xu := tnth _ i.\nhave /allpairsP[[x u] /=]: xu \\in _ := mem_tnth i _.\ncase=> /vbasis_mem Fx /vbasis_mem Vu ->.\nrewrite scalerAl (coord_span Vu) mulr_sumr memv_suml // => j_.\nby rewrite -scalerCA (memvZ (Subvs _)) ?memvZ // vbasis_mem ?memt_nth.\nQed."
}
{
  "statement": "Lemma Clifford_simple M x : mxsimple rH M -> x \\in G -> mxsimple rH (M *m rG x).\n",
  "proof": "Proof.\nhave modmG m U y: y \\in G -> (mxmodule rH) m U -> mxmodule rH (U *m rG y).\n  move=> Gy modU; apply/mxmoduleP=> h Hh; have Gh := subsetP sHG h Hh.\n  rewrite -mulmxA -repr_mxM // conjgCV repr_mxM ?groupJ ?groupV // mulmxA.\n  by rewrite submxMr ?(mxmoduleP modU) // -mem_conjg (normsP nHG).\nhave nzmG m y (U : 'M_(m, n)): y \\in G -> (U *m rG y == 0) = (U == 0).\n  by move=> Gy; rewrite -{1}(mul0mx m (rG y)) (can_eq (repr_mxK rG Gy)).\ncase=> [modM nzM simM] Gx; have Gx' := groupVr Gx.\nsplit=> [||U modU sUMx nzU]; rewrite ?modmG ?nzmG //.\nrewrite -(repr_mxKV rG Gx U) submxMr //.\nby rewrite (simM (U *m _)) ?modmG ?nzmG // -(repr_mxK rG Gx M) submxMr.\nQed."
}
{
  "statement": "Lemma exp_prim_root k : (n %/ gcdn k n).-primitive_root (z ^+ k).\n",
  "proof": "Proof.\nset d := gcdn k n; have d_gt0: (0 < d)%N by rewrite gcdn_gt0 orbC n_gt0.\nhave [d_dv_k d_dv_n]: (d %| k /\\ d %| n)%N by rewrite dvdn_gcdl dvdn_gcdr.\nset q := (n %/ d)%N; rewrite /q.-primitive_root ltn_divRL // n_gt0.\napply/forallP=> i; rewrite unity_rootE -exprM -prim_order_dvd.\nrewrite -(divnK d_dv_n) -/q -(divnK d_dv_k) mulnAC dvdn_pmul2r //.\napply/eqP; apply/idP/idP=> [|/eqP->]; last by rewrite dvdn_mull.\nrewrite Gauss_dvdr; first by rewrite eqn_leq ltn_ord; apply: dvdn_leq.\nby rewrite /coprime gcdnC -(eqn_pmul2r d_gt0) mul1n muln_gcdl !divnK.\nQed."
}
{
  "statement": "Lemma semidihedral_classP :\n  extremal_class G = SemiDihedral <-> (exists2 n, n > 3 & G \\isog 'SD_(2 ^ n)).\n",
  "proof": "Proof.\nrewrite /extremal_class; split=> [ | [n n_gt3 isoG]].\n  by move: (logn _ _) => n; do 4?case: ifP => //; case/andP; exists n.\nrewrite (card_isog isoG) card_semidihedral //.\nrewrite -(ltn_predK n_gt3) pdiv_pfactor // pfactorK // (ltn_predK n_gt3) n_gt3.\nhave [[x y] genG [oy _]]:= generators_semidihedral n_gt3 isoG.\nhave [_ Gx _ X'y]:= genG.\ncase: andP => [[n_gt1 isoGD]|_].\n  have [[_ oxy _ _] _ _ _]:= semidihedral_structure n_gt3 genG isoG oy.\n  case: (dihedral2_structure n_gt1 genG isoGD) oxy => [[_ ->]] //.\n  by rewrite !inE !groupMl ?cycle_id in X'y *.\ncase: andP => // [[n_gt2 isoGQ]|]; last by rewrite isoG.\nby case: (quaternion_structure n_gt2 genG isoGQ) oy => [[_ ->]].\nQed."
}
{
  "statement": "Lemma astabEsd : 'C(G | to) = sdpair2 @*^-1 'C(sdpair1 @* G).\n",
  "proof": "Proof.\nhave ssGR := subsetP sGR; apply/setP=> a; apply/idP/idP=> [cGa|].\n  rewrite mem_morphpre ?(astab_dom cGa) //.\n  apply/centP=> _ /morphimP[x Rx Gx ->]; symmetry.\n  by rewrite conjgC -sdpair_act ?(astab_act cGa)  ?(astab_dom cGa).\ncase/morphpreP=> Da cGa; rewrite !inE Da; apply/subsetP=> x Gx; rewrite inE.\napply/eqP; apply: (injmP injm_sdpair1); rewrite ?gact_stable ?ssGR //=.\nby rewrite sdpair_act ?ssGR // /conjg -(centP cGa) ?mulKg ?mem_morphim ?ssGR.\nQed."
}
{
  "statement": "Lemma center_prod H K : K \\subset 'C(H) -> 'Z(H) * 'Z(K) = 'Z(H * K).\n",
  "proof": "Proof.\nmove=> cHK; apply/setP=> z; rewrite {3}/center centM !inE.\nhave cKH: H \\subset 'C(K) by rewrite centsC.\napply/imset2P/and3P=> [[x y /setIP[Hx cHx] /setIP[Ky cKy] ->{z}]| []].\n  by rewrite imset2_f ?groupM // ?(subsetP cHK) ?(subsetP cKH).\ncase/imset2P=> x y Hx Ky ->{z}.\nrewrite groupMr => [cHx|]; last exact: subsetP Ky.\nrewrite groupMl => [cKy|]; last exact: subsetP Hx.\nby exists x y; rewrite ?inE ?Hx ?Ky.\nQed."
}
{
  "statement": "Lemma cfConjgQuo_norm H K (phi : 'CF(H)) y :\n  y \\in 'N(K) -> y \\in 'N(H) -> ((phi / K) ^ coset K y)%CF = (phi ^ y / K)%CF.\n",
  "proof": "Proof.\nmove=> nKy nHy; have keryK: (K \\subset cfker (phi ^ y)) = (K \\subset cfker phi).\n  by rewrite cfker_conjg // -{1}(normP nKy) conjSg.\nhave [kerK | not_kerK] := boolP (K \\subset cfker phi); last first.\n  by rewrite !cfQuoEout ?rmorph_alg ?cfConjg1 ?keryK.\napply/cfun_inP=> _ /morphimP[x nKx Hx ->].\nhave nHyb: coset K y \\in 'N(H / K) by rewrite inE -morphimJ ?(normP nHy).\nrewrite !(cfConjgE, cfQuoEnorm) ?keryK // ?in_setI ?Hx //.\nrewrite -morphV -?morphJ ?groupV // cfQuoEnorm //.\nby rewrite inE memJ_norm ?Hx ?groupJ ?groupV.\nQed."
}
{
  "statement": "Lemma perm_on_id u S : perm_on S u -> #|S| <= 1 -> u = 1%g.\n",
  "proof": "Proof.\nrewrite leq_eqVlt ltnS leqn0 => pSu S10; apply/permP => t; rewrite perm1.\ncase/orP : S10; last first.\n  by move/eqP/cards0_eq => S0; apply: (out_perm pSu); rewrite S0 inE.\nmove=> /cards1P[x Sx].\nhave [-> | ntx] := eqVneq t x; last by apply: (out_perm pSu); rewrite Sx inE.\nby apply/eqP; have := perm_closed x pSu; rewrite Sx !inE => ->.\nQed."
}
{
  "statement": "Lemma egcdp_map p q :\n  egcdp (map_poly f p) (map_poly f q)\n     = (map_poly f (egcdp p q).1, map_poly f (egcdp p q).2).\n",
  "proof": "Proof.\nwlog le_qp: p q / size q <= size p.\n  move=> IH; have [/IH// | lt_qp] := leqP (size q) (size p).\n  have /IH := ltnW lt_qp; rewrite /egcdp !size_map_poly ltnW // leqNgt lt_qp /=.\n  by case: (egcdp_rec _ _ _) => u v [-> ->].\nrewrite /egcdp !size_map_poly {}le_qp; move: (size q) => n.\nelim: n => /= [|n IHn] in p q *; first by rewrite rmorph1 rmorph0.\nrewrite map_poly_eq0; have [_ | nz_q] := ifPn; first by rewrite rmorph1 rmorph0.\nrewrite -map_modp (IHn q (p %% q)); case: (egcdp_rec _ _ n) => u v /=.\nrewrite map_polyZ lead_coef_map -rmorphXn scalp_map rmorphB rmorphM.\nby rewrite -map_divp.\nQed."
}
{
  "statement": "Lemma cormen_lup_correct n (A : 'M_n.+1) :\n  let: (P, L, U) := cormen_lup A in P * A = L * U.\n",
  "proof": "Proof.\nelim: n => [|n IHn] /= in A *; first by rewrite !mul1r.\nset k := odflt _ _; set A1 : 'M_(1 + _) := xrow _ _ _.\nset A' := _ - _; move/(_ A'): IHn; case: cormen_lup => [[P' L' U']] /= IHn.\nrewrite -mulrA -!mulmxE -xrowE -/A1 /= -[n.+2]/(1 + n.+1)%N -{1}(submxK A1).\nrewrite !mulmx_block !mul0mx !mulmx0 !add0r !addr0 !mul1mx -{L' U'}[L' *m _]IHn.\nrewrite -scalemxAl !scalemxAr -!mulmxA addrC -mulrDr {A'}subrK.\ncongr (block_mx _ _ (_ *m _) _).\nrewrite [_ *: _]mx11_scalar !mxE lshift0 tpermL {}/A1 {}/k.\ncase: pickP => /= [k nzAk0 | no_k]; first by rewrite mulVf ?mulmx1.\nrewrite (_ : dlsubmx _ = 0) ?mul0mx //; apply/colP=> i.\nby rewrite !mxE lshift0 (elimNf eqP (no_k _)).\nQed."
}
{
  "statement": "Lemma solP n f : reflect (exists2 s, size s = n & holds s f) (sat (sol n f) f).\n",
  "proof": "Proof.\nrewrite /sol; case: sol_subproof => [sP | sPn].\n  case/andP: (xchooseP sP) => _ ->; left.\n  by case: sP => s; case/andP; move/eqP=> <-; move/satP; exists s.\napply: (iffP (satP _ _)); first by exists (nseq n 0); rewrite ?size_nseq.\nby case=> s sz_s; move/satP=> f_s; case: sPn; exists s; rewrite sz_s eqxx.\nQed."
}
{
  "statement": "Lemma mul_lead_coef p q :\n  lead_coef p * lead_coef q = (p * q)`_(size p + size q).-2.\n",
  "proof": "Proof.\npose dp := (size p).-1; pose dq := (size q).-1.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite lead_coef0 !mul0r coef0.\nhave [-> | nz_q] := eqVneq q 0; first by rewrite lead_coef0 !mulr0 coef0.\nhave ->: (size p + size q).-2 = (dp + dq)%N.\n  by do 2!rewrite polySpred // addSn addnC.\nhave lt_p_pq: dp < (dp + dq).+1 by rewrite ltnS leq_addr.\nrewrite coefM (bigD1 (Ordinal lt_p_pq)) ?big1 ?simp ?addKn //= => i.\nrewrite -val_eqE neq_ltn /= => /orP[lt_i_p | gt_i_p]; last first.\n  by rewrite nth_default ?mul0r //; rewrite -polySpred in gt_i_p.\nrewrite [q`__]nth_default ?mulr0 //= -subSS -{1}addnS -polySpred //.\nby rewrite addnC -addnBA ?leq_addr.\nQed."
}
{
  "statement": "Lemma card_irr_pchar : #|sG| = tG.\n",
  "proof": "Proof.\nrewrite -(eqnP classg_base_free) classg_base_center.\nhave:= mxdirect_sums_center\n  Wedderburn_sum_pchar Wedderburn_direct Wedderburn_ideal.\nmove->; rewrite (mxdirectP _) /=; last first.\n  apply/mxdirect_sumsP=> i _; apply/eqP; rewrite -submx0.\n  rewrite -{2}(mxdirect_sumsP Wedderburn_direct i) // capmxS ?capmxSl //=.\n  by apply/sumsmx_subP=> j neji; rewrite (sumsmx_sup j) ?capmxSl.\nrewrite -sum1_card; apply: eq_bigr => i _; apply/eqP.\nrewrite Wedderburn_subring_center_pchar eqn_leq rank_leq_row lt0n mxrank_eq0.\nby rewrite andbT mxvec_eq0; case: (Wedderburn_is_id_pchar i).\nQed."
}
{
  "statement": "Lemma Wedderburn_ideal i : mx_ideal R_G 'R_i.\n",
  "proof": "Proof.\napply/andP; split; last first.\n  rewrite /right_mx_ideal genmxE (muls_eqmx (genmxE _) (eqmx_refl _)).\n  by rewrite -[(_ <= _)%MS]regular_module_ideal component_mx_module.\napply/mulsmx_subP=> A B R_A; rewrite !genmxE !mem_sub_gring => /andP[R_B SiB].\nrewrite envelop_mxM {R_A}// gring_row_mul -{R_B}(gring_rowK R_B).\npose f := mulmx (gring_row A) \\o gring_mx aG.\nrewrite -[_ *m _](mul_rV_lin1 f).\nsuffices: (i *m lin1_mx f <= i)%MS by apply: submx_trans; rewrite submxMr.\napply: hom_component_mx; first exact: socle_simple.\napply/rV_subP=> v _; apply/hom_mxP=> x Gx.\nby rewrite !mul_rV_lin1 /f /= gring_mxJ ?mulmxA.\nQed."
}
{
  "statement": "Lemma nderiv_taylor p x h :\n  GRing.comm x h -> p.[x + h] = \\sum_(i < size p) p^`N(i).[x] * h ^+ i.\n",
  "proof": "Proof.\nmove/commrX=> cxh; elim/poly_ind: p => [|p c IHp].\n  by rewrite size_poly0 big_ord0 horner0.\nrewrite hornerMXaddC size_MXaddC.\nhave [-> | nz_p] := eqVneq p 0.\n  rewrite horner0 !simp; have [-> | _] := c =P 0; first by rewrite big_ord0.\n  by rewrite size_poly0 big_ord_recl big_ord0 nderivn0 hornerC !simp.\nrewrite big_ord_recl nderivn0 !simp hornerMXaddC addrAC; congr (_ + _).\nrewrite mulrDr {}IHp !big_distrl polySpred //= big_ord_recl /= mulr1 -addrA.\nrewrite nderivn0 /bump /(addn 1) /=; congr (_ + _).\nrewrite !big_ord_recr /= nderivnMXaddC -mulrA -exprSr -polySpred // !addrA.\ncongr (_ + _); last by rewrite (nderivn_poly0 (leqnn _)) !simp.\nrewrite addrC -big_split /=; apply: eq_bigr => i _.\nby rewrite nderivnMXaddC !hornerE_comm /= mulrDl -!mulrA -exprSr cxh.\nQed."
}
{
  "statement": "Lemma extremal_generators_facts gT (G : {group gT}) p n x y :\n    prime p -> extremal_generators G p n (x, y) ->\n  [/\\ p.-group G, maximal <[x]> G, <[x]> <| G,\n      <[x]> * <[y]> = G & <[y]> \\subset 'N(<[x]>)].\n",
  "proof": "Proof.\nmove=> p_pr [oG Gx ox] /setDP[Gy notXy].\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave maxX: maximal <[x]> G.\n  rewrite p_index_maximal -?divgS ?cycle_subG // -orderE oG ox.\n  case: (n) oG => [|n' _]; last by rewrite -expnB ?subSnn ?leqnSn ?prime_gt0.\n  move/eqP; rewrite -trivg_card1; case/trivgPn.\n  by exists y; rewrite // (group1_contra notXy).\nhave nsXG := p_maximal_normal pG maxX; split=> //.\n  by apply: mulg_normal_maximal; rewrite ?cycle_subG.\nby rewrite cycle_subG (subsetP (normal_norm nsXG)).\nQed."
}
{
  "statement": "Lemma Grp'_dihedral : 'D_m \\isog Grp (x : y : x ^+ 2, y ^+ 2, (x * y) ^+ q).\n",
  "proof": "Proof.\nmove=> gT G; rewrite Grp_dihedral; apply/existsP/existsP=> [] [[x y]] /=.\n  case/eqP=> <- xq1 y2 xy; exists (x * y, y); rewrite !xpair_eqE /= eqEsubset.\n  rewrite !join_subG !joing_subr !cycle_subG -{3}(mulgK y x) /=.\n  rewrite 2?groupM ?groupV ?mem_gen ?inE ?cycle_id ?orbT //= -mulgA expgS.\n  by rewrite {1}(conjgC x) xy -mulgA mulKg -(expgS y 1) y2 mulg1 xq1 !eqxx.\ncase/eqP=> <- x2 y2 xyq; exists (x * y, y); rewrite !xpair_eqE /= eqEsubset.\nrewrite !join_subG !joing_subr !cycle_subG -{3}(mulgK y x) /=.\nrewrite 2?groupM ?groupV ?mem_gen ?inE ?cycle_id ?orbT //= xyq y2 !eqxx /=.\nby rewrite eq_sym eq_invg_mul !mulgA mulgK -mulgA -!(expgS _ 1) x2 y2 mulg1.\nQed."
}
{
  "statement": "Lemma inertia_morph_pre (phi : 'CF(f @* H)) :\n  H <| G -> G \\subset D -> 'I_G[cfMorph phi] = G :&: f @*^-1 'I_(f @* G)[phi].\n",
  "proof": "Proof.\ncase/andP=> sHG nHG sGD; have sHD := subset_trans sHG sGD.\napply/setP=> y; rewrite !in_setI; apply: andb_id2l => Gy.\nhave [Dy nHy] := (subsetP sGD y Gy, subsetP nHG y Gy).\nrewrite Dy inE nHy 4!inE mem_morphim // -morphimJ ?(normP nHy) // subxx /=.\nrewrite cfConjgMorph //; apply/eqP/eqP=> [Iphi_y | -> //].\nby apply/cfun_inP=> _ /morphimP[x Dx Hx ->]; rewrite -!cfMorphE ?Iphi_y.\nQed."
}
{
  "statement": "Lemma dvdp_gcd p m n : p %| gcdp m n = (p %| m) && (p %| n).\n",
  "proof": "Proof.\napply/idP/andP=> [dv_pmn | []].\n  by rewrite ?(dvdp_trans dv_pmn) ?dvdp_gcdl ?dvdp_gcdr.\nhave [r] := ubnP (minn (size n) (size m)); elim: r => // r IHr in m n *.\nhave [-> | nz_m] := eqVneq m 0; first by rewrite gcd0p.\nhave [-> | nz_n] := eqVneq n 0; first by rewrite gcdp0.\nrewrite gcdpE ltnS; case: leqP => [le_nm | lt_mn] le_r dv_m dv_n.\n  apply: IHr => //; last by rewrite -(dvdp_mod _ dv_n).\n  by rewrite gtn_min orbC (leq_trans _ le_r) ?ltn_modp.\napply: IHr => //; last by rewrite -(dvdp_mod _ dv_m).\nby rewrite gtn_min orbC (leq_trans _ le_r) ?ltn_modp.\nQed."
}
{
  "statement": "Lemma monic_Cauchy_bound : p \\is monic -> {b | forall x, x >= b -> p.[x] > 0}.\n",
  "proof": "Proof.\nmove/monicP=> mon_p; pose n := (size p - 2)%N.\nhave [p_le1 | p_gt1] := leqP (size p) 1.\n  exists 0 => x _; rewrite (size1_polyC p_le1) hornerC.\n  by rewrite -[p`_0]lead_coefC -size1_polyC // mon_p ltr01.\npose lb := \\sum_(j < n.+1) `|p`_j|; exists (lb + 1) => x le_ub_x.\nhave x_ge1: 1 <= x; last have x_gt0 := lt_le_trans ltr01 x_ge1.\n  by rewrite -(lerD2l lb) ler_wpDl ?sumr_ge0 // => j _.\nrewrite horner_coef -(subnK p_gt1) -/n addnS big_ord_recr /= addn1.\nrewrite [in p`__]subnSK // subn1 -lead_coefE mon_p mul1r -ltrBlDl sub0r.\napply: le_lt_trans (_ : lb * x ^+ n < _); last first.\n  by rewrite exprS ltr_pM2r ?exprn_gt0// -(ltrD2r 1) ltr_pwDr.\nrewrite -sumrN mulr_suml ler_sum // => j _; apply: le_trans (ler_norm _) _.\nrewrite normrN normrM ler_wpM2l // normrX.\nby rewrite ger0_norm ?(ltW x_gt0) // ler_weXn2l ?leq_ord.\nQed."
}
{
  "statement": "Lemma simple_compsP G s : comps G s -> reflect (s = [:: 1%G]) (simple G).\n",
  "proof": "Proof.\nmove=> cs; apply: (iffP idP) => [|s1]; last first.\n  by rewrite s1 /comps eqxx /= andbT -simple_maxnormal in cs.\ncase: s cs => [/trivg_comps/eqP-> | H s]; first by case/simpleP; rewrite eqxx.\nrewrite [comps _ _]andbCA /= => /andP[/maxgroupp maxH /trivg_comps/esym nil_s].\nrewrite simple_maxnormal => /maxgroupP[_ simG].\nhave H1: H = 1%G by apply/val_inj/simG; rewrite // sub1G.\nby move: nil_s; rewrite H1 eqxx => /eqP->.\nQed."
}
{
  "statement": "Lemma cycle_traject x : <[x]> =i traject (mulg x) 1 #[x].\n",
  "proof": "Proof.\nset t := _ 1; apply: fsym; apply/subset_cardP; last first.\n  by apply/subsetP=> _ /trajectP[i _ ->]; rewrite -iteropE mem_cycle.\nrewrite (card_uniqP _) ?size_traject //; case def_n: #[_] => // [n].\nrewrite looping_uniq; apply: contraL (card_size (t n)) => /loopingP t_xi.\nrewrite -ltnNge size_traject -def_n ?subset_leq_card //.\nrewrite -(eq_subset_r (in_set _)) {}/t; set G := finset _.\nrewrite -[x]mulg1 -[G]gen_set_id ?genS ?sub1set ?inE ?(t_xi 1%N)//.\napply/group_setP; split=> [|y z]; rewrite !inE ?(t_xi 0) //.\nby do 2!case/trajectP=> ? _ ->; rewrite -!iteropE -expgD [x ^+ _]iteropE.\nQed."
}
{
  "statement": "Lemma card_powerset (T : finType) (A : {set T}) : #|powerset A| = 2 ^ #|A|.\n",
  "proof": "Proof.\nrewrite -card_bool -(card_pffun_on false) -(card_imset _ val_inj).\napply: eq_card => f; pose sf := false.-support f; pose D := finset sf.\nhave sDA: (D \\subset A) = (sf \\subset A) by apply: eq_subset; apply: in_set.\nhave eq_sf x : sf x = f x by rewrite /= negb_eqb addbF.\nhave valD: val D = f by rewrite /D unlock; apply/ffunP=> x; rewrite ffunE eq_sf.\napply/imsetP/pffun_onP=> [[B] | [sBA _]]; last by exists D; rewrite // inE ?sDA.\nby rewrite inE -sDA -valD => sBA /val_inj->.\nQed."
}
{
  "statement": "Lemma modact_is_groupAction : is_groupAction 'C_(|to)(H) (to %% H).\n",
  "proof": "Proof.\nmove=> Ha /morphimP[a Na Da ->]; have NDa: a \\in 'N_D(H) by apply/setIP.\nrewrite inE; apply/andP; split.\n  apply/subsetP=> x; rewrite 2!inE andbC actpermE /= modactEcond //.\n  by apply: contraR; case: ifP => // E Rx; rewrite gact_out.\napply/morphicP=> x y /setIP[Rx cHx] /setIP[Ry cHy].\nrewrite /= !actpermE /= !modactE ?gactM //.\nsuffices: x * y \\in 'C_(|to)(H) by case/setIP.\nby rewrite groupM //; apply/setIP.\nQed."
}
{
  "statement": "Lemma qacts_cosetpre (H : {group rT}) (K' : {group coset_of H}) :\n    H \\subset D -> [acts A, on H | to] ->\n    [acts qact_dom to H, on K' | to / H] ->\n  [acts A, on coset H @*^-1 K' | to].\n",
  "proof": "Proof.\nmove=> sHD aH aK'; apply/subsetP=> x Ax; move: (Ax) (subsetP aK').\nrewrite -{1}(acts_qact_doms sHD aH) => qdx; move/(_ x qdx) => nx.\nrewrite !inE Ax; apply/subsetP=> y; case/morphpreP=> Ny /= K'Hy /[1!inE].\napply/morphpreP; split; first by rewrite acts_qact_dom_norm.\nby move/gastabsP: nx; move/(_  qdx (coset H y)); rewrite K'Hy qactE.\nQed."
}
{
  "statement": "Lemma extremumP : extremum_spec ord P F extremum.\n",
  "proof": "Proof.\nrewrite /extremum; case: pickP => [i /andP[Pi /'forall_implyP/= min_i] | no_i].\n  by split=> // j; apply/implyP.\nhave := sort_sorted ord_total [seq F i | i <- enum P].\nset s := sort _ _ => ss; have s_gt0 : size s > 0\n   by rewrite size_sort size_map -cardE; apply/card_gt0P; exists i0.\npose t0 := nth (F i0) s 0; have: t0 \\in s by rewrite mem_nth.\nrewrite mem_sort => /mapP/sig2_eqW[it0]; rewrite mem_enum => it0P def_t0.\nhave /negP[/=] := no_i it0; rewrite [P _]it0P/=; apply/'forall_implyP=> j Pj.\nhave /(nthP (F i0))[k g_lt <-] : F j \\in s by rewrite mem_sort map_f ?mem_enum.\nby rewrite -def_t0 sorted_leq_nth.\nQed."
}
{
  "statement": "Lemma foldForallP I e :\n  (forall e', {in [predC I], same_env e e'} -> holds e' f)\n    <-> holds e (foldr Forall f I).\n",
  "proof": "Proof.\nelim: I e => /= [|i I IHi] e.\n  by split=> [|f_e e' eq_e]; [apply | apply: eq_holds f_e => i; rewrite eq_e].\nsplit=> [f_e' x | f_e e' eq_e]; first set e_x := set_nth 0 e i x.\n  apply/IHi=> e' eq_e; apply: f_e' => j.\n  by have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP.\nmove/IHi: (f_e e'`_i); apply=> j.\nby have:= eq_e j; rewrite nth_set_nth /= !inE; case: eqP => // ->.\nQed."
}
{
  "statement": "Lemma rfix_mx_conjsg (H : {set gT}) x :\n  x \\in G -> H \\subset G -> (rfix_mx (H :^ x) :=: rfix_mx H *m rG x)%MS.\n",
  "proof": "Proof.\nmove=> Gx sHG; pose rf y := rfix_mx (H :^ y).\nsuffices{x Gx} IH: {in G &, forall y z, rf y *m rG z <= rf (y * z)%g}%MS.\n  apply/eqmxP; rewrite -/(rf x) -[H]conjsg1 -/(rf 1%g).\n  rewrite -{4}[x] mul1g -{1}[rf x](repr_mxKV rG Gx) -{1}(mulgV x).\n  by rewrite submxMr IH ?groupV.\nmove=> x y Gx Gy; apply/rfix_mxP=> zxy; rewrite actM => /imsetP[zx Hzx ->].\nhave Gzx: zx \\in G by apply: subsetP Hzx; rewrite conj_subG.\nrewrite -mulmxA -repr_mxM ?groupM ?groupV // -conjgC repr_mxM // mulmxA.\nby rewrite rfix_mx_id.\nQed."
}
{
  "statement": "Lemma hermitian_spectral_diag_real n (A : 'M[C]_n) : A \\is hermsymmx ->\n  spectral_diag A \\is a realmx.\n",
  "proof": "Proof.\nmove=> Ahermi; have /hermitian_normalmx /orthomx_spectralP A_eq := Ahermi.\nhave /(congr1 ( fun X => X^t* )) := A_eq.\nrewrite invmx_unitary ?spectral_unitarymx //.\nrewrite !trmx_mul !map_mxM map_trmx trmxK -map_mx_comp.\nrewrite tr_diag_mx map_diag_mx (map_mx_id (@conjCK _)).\nrewrite -[in RHS]invmx_unitary ?spectral_unitarymx //.\nhave := is_hermitianmxP _ _ _ Ahermi; rewrite expr0 scale1r => <-.\nrewrite {1}A_eq mulmxA => /(congr1 (mulmx^~ (invmx (spectralmx A)))).\nrewrite !mulmxK ?spectral_unit//.\nmove=> /(congr1 (mulmx (spectralmx A))); rewrite !mulKVmx ?spectral_unit//.\nmove=> eq_A_conjA; apply/mxOverP => i j; rewrite ord1 {i}.\nhave /matrixP /(_ j j) := eq_A_conjA; rewrite !mxE eqxx !mulr1n.\nby move=> /esym/CrealP.\nQed."
}
{
  "statement": "Lemma homo_sort_map (T : Type) (T' : eqType) (f : T -> T') leT leT' :\n  antisymmetric (relpre f leT') -> transitive (relpre f leT') -> total leT ->\n  {homo f : x y / leT x y >-> leT' x y} ->\n  forall s : seq T, sort leT' (map f s) = map f (sort leT s).\n",
  "proof": "Proof.\nmove=> leT'_asym leT'_trans leT_total f_homo s; case Ds: s => // [x s'].\nrewrite -{}Ds -(mkseq_nth x s) [in RHS]sort_map -!map_comp /comp.\napply: (@sorted_eq_in _ leT') => [? ? ?|? ?|||]; rewrite ?mem_sort.\n- by move=> /mapP[? _ ->] /mapP[? _ ->] /mapP[? _ ->]; apply/leT'_trans.\n- by move=> /mapP[? _ ->] /mapP[? _ ->] /leT'_asym ->.\n- apply: (sort_sorted_in _ (allss _)) => _ _ /mapP[y _ ->] /mapP[z _ ->].\n  by case/orP: (leT_total (nth x s y) (nth x s z)) => /f_homo ->; rewrite ?orbT.\n- by rewrite map_comp -sort_map; exact/homo_sorted/sort_sorted.\n- by rewrite perm_sort perm_map // perm_sym perm_sort.\nQed."
}
{
  "statement": "Lemma reindex_bigcprod (I J : finType) (h : J -> I) P (A : I -> {set gT}) G x :\n    {on SimplPred P, bijective h} -> \\big[cprod/1]_(i | P i) A i = G ->\n    {in SimplPred P, forall i, x i \\in A i} ->\n  \\prod_(i | P i) x i = \\prod_(j | P (h j)) x (h j).\n",
  "proof": "Proof.\ncase=> h1 hK h1K defG Ax; have [e big_e [Ue mem_e] _] := big_enumP P.\nrewrite -!big_e in defG *; rewrite -(big_map h P x) -[RHS]big_filter filter_map.\napply: perm_bigcprod defG _ _ => [i|]; first by rewrite mem_e => /Ax.\nhave [r _ [Ur /= mem_r] _] := big_enumP; apply: uniq_perm Ue _ _ => [|i].\n  by rewrite map_inj_in_uniq // => i j; rewrite !mem_r ; apply: (can_in_inj hK).\nrewrite mem_e; apply/idP/mapP=> [Pi|[j r_j ->]]; last by rewrite -mem_r.\nby exists (h1 i); rewrite ?mem_r h1K.\nQed."
}
{
  "statement": "Lemma dvdn_partP n m : 0 < n ->\n  reflect (forall p, p \\in \\pi(n) -> n`_p %| m) (n %| m).\n",
  "proof": "Proof.\nmove=> n_gt0; apply: (iffP idP) => n_dvd_m => [p _|].\n  by apply: dvdn_trans n_dvd_m; apply: dvdn_part.\nhave [-> // | m_gt0] := posnP m.\nrewrite -(partnT n_gt0) -(partnT m_gt0).\nrewrite !(@widen_partn (m + n)) ?leq_addl ?leq_addr // /in_mem /=.\nelim/big_ind2: _ => // [* | q _]; first exact: dvdn_mul.\nhave [-> // | ] := posnP (logn q n); rewrite logn_gt0 => q_n.\nhave pr_q: prime q by move: q_n; rewrite mem_primes; case/andP.\nby have:= n_dvd_m q q_n; rewrite p_part !pfactor_dvdn // pfactorK.\nQed."
}
{
  "statement": "Lemma mul_mx_adj n (A : 'M[R]_n) : A *m \\adj A = (\\det A)%:M.\n",
  "proof": "Proof.\napply/matrixP=> i1 i2 /[!mxE]; have [->|Di] := eqVneq.\n  rewrite (expand_det_row _ i2) //=.\n  by apply: eq_bigr => j _; congr (_ * _); rewrite mxE.\npose B := \\matrix_(i, j) (if i == i2 then A i1 j else A i j).\nhave EBi12: B i1 =1 B i2 by move=> j; rewrite /= !mxE eqxx (negPf Di).\nrewrite -[_ *+ _](determinant_alternate Di EBi12) (expand_det_row _ i2).\napply: eq_bigr => j _; rewrite !mxE eqxx; congr (_ * (_ * _)).\napply: eq_bigr => s _; congr (_ * _); apply: eq_bigr => i _.\nby rewrite !mxE eq_sym -if_neg neq_lift.\nQed."
}
{
  "statement": "Lemma genmx_cap m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  <<A :&: B>>%MS = (<<A>> :&: <<B>>)%MS.\n",
  "proof": "Proof.\nrewrite -(eq_genmx (cap_eqmx (genmxE A) (genmxE B))).\ncase idAB: (qidmx <<A>> || qidmx <<B>>)%MS.\n  rewrite [@capmx]unlock !capmx_nop_id !(fun_if (@genmx _ _ _)) !genmx_id.\n  by case: (qidmx _) idAB => //= ->.\ncase idA: (qidmx _) idAB => //= idB; rewrite {2}capmx_eq_norm ?idA //.\nset C := (_ :&: _)%MS; have eq_idC: row_full C = qidmx C.\n  rewrite qidmx_cap idA -sub1mx sub_capmx genmxE; apply/andP=> [[s1A]].\n  by case/idP: idA; rewrite qidmx_eq1 -genmx1 (sameP eqP genmxP) submx1.\nrewrite unlock /capmx_norm eq_idC.\nby apply: choose_id (capmx_witnessP _); rewrite -eq_idC genmx_witnessP.\nQed."
}
{
  "statement": "Lemma trunc_log_eq0 p n : (trunc_log p n == 0) = (p <= 1) || (n <= p.-1).\n",
  "proof": "Proof.\ncase: p => [|[|p]]; case: n => // n; rewrite /= ltnS.\nhave /= /andP[] := trunc_log_bounds (isT : 1 < p.+2) (isT : 0 < n.+1).\ncase: trunc_log => [//|k] b1 b2.\napply/idP/idP => [/eqP sk0 | nlep]; first by move: b2; rewrite sk0.\nsymmetry; rewrite -[_ == _]/false /is_true -b1; apply/negbTE; rewrite -ltnNge.\nmove: nlep; rewrite -ltnS => nlep; apply: (leq_ltn_trans nlep).\nby rewrite -[leqLHS]expn1; apply: leq_pexp2l.\nQed."
}
{
  "statement": "Lemma Clifford_componentJ M x :\n    mxsimple rH M -> x \\in G ->\n  (component_mx rH (M *m rG x) :=: component_mx rH M *m rG x)%MS.\n",
  "proof": "Proof.\nset simH := mxsimple rH; set cH := component_mx rH.\nhave actG: {in G, forall y M, simH M -> cH M *m rG y <= cH (M *m rG y)}%MS.\n  move=> {M} y Gy /= M simM; have [I [U isoU def_cHM]] := component_mx_def simM.\n  rewrite /cH def_cHM sumsmxMr; apply/sumsmx_subP=> i _.\n  by apply: mx_iso_component; [apply: Clifford_simple | apply: Clifford_iso2].\nmove=> simM Gx; apply/eqmxP; rewrite actG // -/cH.\nrewrite -{1}[cH _](repr_mxKV rG Gx) submxMr // -{2}[M](repr_mxK rG Gx).\nby rewrite actG ?groupV //; apply: Clifford_simple.\nQed."
}
{
  "statement": "Lemma abelian_abs_irr : abelian G -> mx_absolutely_irreducible = (n == 1).\n",
  "proof": "Proof.\nmove=> cGG; apply/idP/eqP=> [absG|]; last exact: linear_mx_abs_irr.\nhave [n_gt0 _] := andP absG.\npose M := <<delta_mx 0 (Ordinal n_gt0) : 'rV[F]_n>>%MS.\nhave rM: \\rank M = 1 by rewrite genmxE mxrank_delta.\nsuffices defM: (M == 1%:M)%MS by rewrite (eqmxP defM) mxrank1 in rM.\ncase: (mx_abs_irrW absG) => _ _ ->; rewrite ?submx1 -?mxrank_eq0 ?rM //.\napply/mxmoduleP=> x Gx; suffices: is_scalar_mx (rG x).\n  by case/is_scalar_mxP=> a ->; rewrite mul_mx_scalar scalemx_sub.\napply: (mx_abs_irr_cent_scalar absG).\nby apply/centgmxP=> y Gy; rewrite -!repr_mxM // (centsP cGG).\nQed."
}
{
  "statement": "Lemma orbitPcycle {x} : [<->\n   fcycle f (orbit x);\n   order (f x) = order x;\n   x \\in fconnect f (f x);\n   exists k, iter k.+1 f x = x;\n   iter (order x) f x = x;\n   {in orbit x &, injective f}].\n",
  "proof": "Proof.\ntfae=> [xorbit_cycle|||[k fkx]|fx y z|/injectivePcycle//].\n- by apply: eq_order_cycle xorbit_cycle _ _ _ _; rewrite ?mem_orbit.\n- move=> /subset_cardP/(_ _)->; rewrite ?inE//; apply/subsetP=> y.\n  by apply: connect_trans; apply: fconnect1.\n- by exists (findex (f x) x); rewrite // iterSr iter_findex.\n- apply: (@iter_order_cycle (traject f x k.+1)); rewrite /= ?mem_head//.\n  by apply/fpathP; exists k.+1; rewrite trajectSr -iterSr fkx.\n- rewrite -!fconnect_orbit => /iter_findex <- /iter_findex <-.\n  move/(congr1 (iter (order x).-1 f)).\n  by rewrite -!iterSr !orderSpred -!iterD ![order _ + _]addnC !iterD fx.\nQed."
}
{
  "statement": "Lemma module_baseVspace M0 :\n  (F1 * M0 <= M0)%VS -> {V | M0 = baseVspace V & M0 =i V}.\n",
  "proof": "Proof.\nmove=> modM0; pose V := <<vbasis (vspaceOver F1 M0) : seq L>>%VS.\nsuffices memM0: M0 =i V.\n  by exists V => //; apply/vspaceP=> v; rewrite mem_baseVspace memM0.\nmove=> v; rewrite -{1}(field_module_eq modM0) -(mem_vspaceOver M0) {}/V.\nmove: (vspaceOver F1 M0) => M.\napply/idP/idP=> [/coord_vbasis|/coord_span]->; apply/memv_suml=> i _.\n  rewrite /(_ *: _) /= /fieldOver_scale; case: (coord _ i _) => /= x.\n  rewrite {1}F1unlock mem_baseVspace => /vlineP[{}x ->].\n  by rewrite -(@scalerAl F L) mul1r memvZ ?memv_span ?memt_nth.\nmove: (coord _ i _) => x; rewrite -[_`_i]mul1r scalerAl -tnth_nth.\nhave F1x: x%:A \\in F1.\n  by rewrite F1unlock mem_baseVspace (@memvZ F L) // mem1v.\nby congr (_ \\in M): (memvZ (Subvs F1x) (vbasis_mem (mem_tnth i _))).\nQed."
}
{
  "statement": "Theorem generalized_orthogonality_relation y (i j : Iirr G) :\n  #|G|%:R^-1 * (\\sum_(x in G) 'chi_i (x * y)%g * 'chi_j x^-1%g)\n    = (i == j)%:R * ('chi_i y / 'chi_i 1%g).\n",
  "proof": "Proof.\npose W := @socle_of_Iirr _ G; pose e k := Wedderburn_id (W k).\npose aG := regular_repr algC G.\nhave [Gy | notGy] := boolP (y \\in G); last first.\n  rewrite cfun0 // mul0r big1 ?mulr0 // => x Gx.\n  by rewrite cfun0 ?groupMl ?mul0r.\ntransitivity (('chi_i).[e j *m aG y]%CF / 'chi_j 1%g).\n  rewrite [e j]Wedderburn_id_expansion -scalemxAl xcfunZr -mulrA; congr (_ * _).\n  rewrite mulmx_suml raddf_sum big_distrl; apply: eq_bigr => x Gx /=.\n  rewrite -scalemxAl xcfunZr -repr_mxM // xcfunG ?groupM // mulrAC mulrC.\n  by congr (_ * _); rewrite mulrC mulKf ?irr1_neq0.\nrewrite mulr_natl mulrb; have [<-{j} | neq_ij] := eqVneq.\n  by congr (_ / _); rewrite xcfun_mul_id ?envelop_mx_id ?xcfunG.\nrewrite (xcfun_annihilate neq_ij) ?mul0r //.\ncase/andP: (Wedderburn_ideal (W j)) => _; apply: submx_trans.\nby rewrite mem_mulsmx ?Wedderburn_id_mem ?envelop_mx_id.\nQed."
}
{
  "statement": "Lemma map_minPoly :  map_poly f (minPoly K x) = minPoly (f @: K) (f x).\n",
  "proof": "Proof.\nset fp := minPoly (f @: K) (f x).\nhave [p Kp Dp]: exists2 p, p \\is a polyOver K & map_poly f p = fp.\n  have Kfp: fp \\is a polyOver (f @: K)%VS by apply: minPolyOver.\n  exists (map_poly f^-1%VF fp).\n    apply/polyOver_poly=> j _; have /memv_imgP[y Ky ->] := polyOverP Kfp j.\n    by rewrite lker0_lfunK ?AHom_lker0.\n  rewrite -map_poly_comp map_poly_id // => _ /(allP Kfp)/memv_imgP[y _ ->].\n  by rewrite /= limg_lfunVK ?memv_img ?memvf.\napply/eqP; rewrite -eqp_monic ?monic_map ?monic_minPoly // -Dp eqp_map.\nhave: ~~ (p %= 1) by rewrite -size_poly_eq1 -(size_map_poly f) Dp size_minPoly.\napply: implyP; rewrite implyNb orbC eqp_sym minPoly_irr //.\nrewrite -(dvdp_map f) Dp minPoly_dvdp ?fmorph_root ?root_minPoly //.\nby apply/polyOver_poly=> j _; apply/memv_img/polyOverP/minPolyOver.\nQed."
}
{
  "statement": "Lemma catCA_perm_ind P :\n    (forall s1 s2 s3, P (s1 ++ s2 ++ s3) -> P (s2 ++ s1 ++ s3)) ->\n  (forall s1 s2, perm_eq s1 s2 -> P s1 -> P s2).\n",
  "proof": "Proof.\nmove=> PcatCA s1 s2 eq_s12; rewrite -[s1]cats0 -[s2]cats0.\nelim: s2 nil => [|x s2 IHs] s3 in s1 eq_s12 *.\n  by case: s1 {eq_s12}(perm_size eq_s12).\nhave /rot_to[i s' def_s1]: x \\in s1 by rewrite (perm_mem eq_s12) mem_head.\nrewrite -(cat_take_drop i s1) -catA => /PcatCA.\nrewrite catA -/(rot i s1) def_s1 /= -cat1s => /PcatCA/IHs/PcatCA; apply.\nby rewrite -(perm_cons x) -def_s1 perm_rot.\nQed."
}
{
  "statement": "Lemma p_rank_dprod K H G : K \\x H = G -> 'r_p(K) + 'r_p(H) = 'r_p(G).\n",
  "proof": "Proof.\nmove=> defG; apply/eqP; rewrite eqn_leq -leq_subLR andbC.\nhave [_ defKH cKH tiKH] := dprodP defG; have nKH := cents_norm cKH.\nrewrite {1}(isog_p_rank (quotient_isog nKH tiKH)) /= -quotientMidl defKH.\nrewrite p_rank_quotient; last by rewrite -defKH mul_subG ?normG.\nhave [[E EpE] [F EpF]] := (p_rank_witness p K, p_rank_witness p H).\nhave [[sEK abelE <-] [sFH abelF <-]] := (pnElemP EpE, pnElemP EpF).\nhave defEF: E \\x F = E <*> F.\n  by rewrite dprodEY ?(centSS sFH sEK) //; apply/trivgP; rewrite -tiKH setISS.\napply/p_rank_geP; exists (E <*> F)%G; rewrite !inE (dprod_abelem p defEF).\nrewrite -lognM ?cargG_gt0 // (dprod_card defEF) abelE abelF eqxx.\nby rewrite -(genGid G) -defKH genM_join genS ?setUSS.\nQed."
}
{
  "statement": "Lemma permutations_uniq s : uniq (permutations s).\n",
  "proof": "Proof.\nhave{s} [n [bs [-> Dn _ Ubs]]] := permsP s.\nelim: n => //= n IHn in bs Dn Ubs *; rewrite -[bs]cats0 /unzip1 in Dn Ubs.\nelim: bs [::] => [|[x [|m]] bs IHbs] //= bs2 in Dn Ubs *.\n  by case/andP: Ubs => _ /IHbs->.\nrewrite /= cons_permsE cat_uniq has_sym andbCA andbC.\nrewrite {}IHbs; first 1 last; first by rewrite (perm_size (perm_tseq bsCA)).\n  by rewrite (perm_uniq (perm_map _ bsCA)).\nrewrite (map_inj_uniq (rcons_injl x)) {}IHn {Dn}//=.\nhave: x \\notin unzip1 bs by apply: contraL Ubs; rewrite map_cat mem_cat => ->.\nmove: {bs2 m Ubs}(perms_rec n _ _ _) (_ :: bs2) => ts.\nelim: bs => [|[y [|m]] bs IHbs] //= /[1!inE] bs2 /norP[x'y /IHbs//].\nrewrite cons_permsE has_cat negb_or has_map => ->.\nby apply/hasPn=> t _; apply: contra x'y => /mapP[t1 _ /rcons_inj[_ ->]].\nQed."
}
{
  "statement": "Lemma partn_biglcm (I : finType) (P : pred I) F pi :\n    (forall i, P i -> F i > 0) ->\n  (\\big[lcmn/1%N]_(i | P i) F i)`_pi = \\big[lcmn/1%N]_(i | P i) (F i)`_pi.\n",
  "proof": "Proof.\nmove=> F_gt0; set m := \\big[lcmn/1%N]_(i | P i) F i.\nhave m_gt0: 0 < m by elim/big_ind: m => // p q p_gt0; rewrite lcmn_gt0 p_gt0.\napply/eqP; rewrite eqn_dvd andbC; apply/andP; split.\n  by apply/dvdn_biglcmP=> i Pi; rewrite partn_dvd // (@biglcmn_sup _ i).\nrewrite -(dvdn_pmul2r (part_gt0 pi^' m)) partnC //.\napply/dvdn_biglcmP=> i Pi; rewrite -(partnC pi (F_gt0 i Pi)) dvdn_mul //.\n  by rewrite (@biglcmn_sup _ i).\nby rewrite partn_dvd // (@biglcmn_sup _ i).\nQed."
}
{
  "statement": "Lemma mxsimple_exists m (U : 'M_(m, n)) :\n  mxmodule U -> U != 0 -> classically (exists2 V, mxsimple V & V <= U)%MS.\n",
  "proof": "Proof.\nmove=> modU nzU [] // simU; move: {2}_.+1 (ltnSn (\\rank U)) => r leUr.\nelim: r => // r IHr in m U leUr modU nzU simU.\nhave genU := genmxE U; apply: (simU); exists <<U>>%MS; last by rewrite genU.\napply/mxsimpleP; split; rewrite ?(eqmx_eq0 genU) ?(eqmx_module genU) //.\ncase=> V; rewrite !genU=> /and4P[modV sVU nzV ltVU]; case: notF.\napply: IHr nzV _ => // [|[W simW sWV]]; first exact: leq_trans ltVU _.\nby apply: simU; exists W => //; apply: submx_trans sWV sVU.\nQed."
}
{
  "statement": "Lemma eq_rank_unitmx m1 m2 n (U : 'M_(m1, n)) (V : 'M_(m2, n)) :\n  \\rank U = \\rank V -> {f : 'M_n | f \\in unitmx & V :=: U *m f}%MS.\n",
  "proof": "Proof.\nmove=> eqrUV; pose f := invmx (row_ebase <<U>>%MS) *m row_ebase <<V>>%MS.\nhave defUf: (<<U>> *m f :=: <<V>>)%MS.\n  rewrite -[<<U>>%MS]mulmx_ebase mulmxA mulmxK ?row_ebase_unit // -mulmxA.\n  rewrite genmxE eqrUV -genmxE -{3}[<<V>>%MS]mulmx_ebase -mulmxA.\n  move: (pid_mx _ *m _) => W; apply/eqmxP.\n  by rewrite !eqmxMfull ?andbb // row_full_unit col_ebase_unit.\nhave{defUf} defV: (V :=: U *m f)%MS.\n  by apply/eqmxP; rewrite -!(eqmxMr f (genmxE U)) !defUf !genmxE andbb.\nhave injfU: \\rank (U *m f) = \\rank U by rewrite -defV eqrUV.\nby have [g injg defUg] := complete_unitmx injfU; exists g; rewrite -?defUg.\nQed."
}
{
  "statement": "Lemma qact_is_groupAction : is_groupAction (R / H) (to / H).\n",
  "proof": "Proof.\nmove=> a HDa /=; have Da := astabs_dom HDa.\nrewrite inE; apply/andP; split.\n  apply/subsetP=> Hx /=; case: (cosetP Hx) => x Nx ->{Hx}.\n  apply: contraR => R'Hx; rewrite actpermE qactE // gact_out //.\n  by apply: contra R'Hx; apply: mem_morphim.\napply/morphicP=> Hx Hy; rewrite !actpermE.\ncase/morphimP=> x Nx Gx ->{Hx}; case/morphimP=> y Ny Gy ->{Hy}.\nby rewrite -morphM ?qactE ?groupM ?gactM // morphM ?acts_qact_dom_norm.\nQed."
}
{
  "statement": "Lemma invariant_subnormal A G H :\n    A \\subset 'N(G) -> A \\subset 'N(H) -> H <|<| G ->\n  exists2 s, (A.-invariant).-series H s & last H s = G.\n",
  "proof": "Proof.\nmove=> nGA nHA /andP[]; move: #|G| => m.\nelim: m => [|m IHm] in G nGA * => sHG.\n  by rewrite eq_sym; exists [::]; last apply/eqP.\nrewrite iterSr; set K := <<_>>.\nhave nKA: A \\subset 'N(K) by rewrite norms_gen ?norms_class_support.\nhave sHK: H \\subset K by rewrite sub_gen ?sub_class_support.\ncase/IHm=> // s Hsn defK; exists (rcons s G); last by rewrite last_rcons.\nrewrite rcons_path Hsn !andbA defK nGA nKA /= -/K.\nby rewrite gen_subG class_support_subG ?norms_gen ?class_support_norm.\nQed."
}
{
  "statement": "Lemma det_ublock n1 n2 Aul (Aur : 'M[R]_(n1, n2)) Adr :\n  \\det (block_mx Aul Aur 0 Adr) = \\det Aul * \\det Adr.\n",
  "proof": "Proof.\nelim: n1 => [|n1 IHn1] in Aul Aur *.\n  have ->: Aul = 1%:M by apply/matrixP=> i [].\n  rewrite det1 mul1r; congr (\\det _); apply/matrixP=> i j.\n  by do 2![rewrite !mxE; case: splitP => [[]|k] //=; move/val_inj=> <- {k}].\nrewrite (expand_det_col _ (lshift n2 0)) big_split_ord /=.\nrewrite addrC big1 1?simp => [|i _]; last by rewrite block_mxEdl mxE simp.\nrewrite (expand_det_col _ 0) big_distrl /=; apply: eq_bigr=> i _.\nrewrite block_mxEul -!mulrA; do 2!congr (_ * _).\nby rewrite col'_col_mx !col'Kl raddf0 row'Ku row'_row_mx IHn1.\nQed."
}
{
  "statement": "Lemma dvdn_pexp2r m n k : k > 0 -> (m ^ k %| n ^ k) = (m %| n).\n",
  "proof": "Proof.\nmove=> k_gt0; apply/idP/idP=> [dv_mn_k|]; last exact: dvdn_exp2r.\nhave [->|n_gt0] := posnP n; first by rewrite dvdn0.\nhave [n' def_n] := dvdnP (dvdn_gcdr m n); set d := gcdn m n in def_n.\nhave [m' def_m] := dvdnP (dvdn_gcdl m n); rewrite -/d in def_m.\nhave d_gt0: d > 0 by rewrite gcdn_gt0 n_gt0 orbT.\nrewrite def_m def_n !expnMn dvdn_pmul2r ?expn_gt0 ?d_gt0 // in dv_mn_k.\nhave: coprime (m' ^ k) (n' ^ k).\n  rewrite coprime_pexpl // coprime_pexpr // /coprime -(eqn_pmul2r d_gt0) mul1n.\n  by rewrite muln_gcdl -def_m -def_n.\nrewrite /coprime -gcdn_modr (eqnP dv_mn_k) gcdn0 -(exp1n k).\nby rewrite (inj_eq (expIn k_gt0)) def_m; move/eqP->; rewrite mul1n dvdn_gcdr.\nQed."
}
{
  "statement": "Lemma subseq_trans : transitive subseq.\n",
  "proof": "Proof.\nmove=> _ _ s /subseqP[m2 _ ->] /subseqP[m1 _ ->].\nelim: s => [|x s IHs] in m2 m1 *; first by rewrite !mask0.\ncase: m1 => [|[] m1]; first by rewrite mask0.\n  case: m2 => [|[] m2] //; first by rewrite /= eqxx IHs.\n  case/subseqP: (IHs m2 m1) => m sz_m def_s; apply/subseqP.\n  by exists (false :: m); rewrite //= sz_m.\ncase/subseqP: (IHs m2 m1) => m sz_m def_s; apply/subseqP.\nby exists (false :: m); rewrite //= sz_m.\nQed."
}
{
  "statement": "Lemma cfkerE chi :\n    chi \\is a character ->\n  cfker chi = G :&: \\bigcap_(i in irr_constt chi) cfker 'chi_i.\n",
  "proof": "Proof.\nmove=> Nchi; rewrite cfkerEchar //; apply/setP=> x; rewrite !inE.\napply: andb_id2l => Gx; rewrite {1 2}[chi]cfun_sum_constt !sum_cfunE.\napply/eqP/bigcapP=> [Kx i Ci | Kx]; last first.\n  by apply: eq_bigr => i /Kx Kx_i; rewrite !cfunE cfker1.\nrewrite cfkerEirr inE /= -(inj_eq (mulfI Ci)).\nhave:= (normC_sum_upper _ Kx) i; rewrite !cfunE => -> // {Ci}i _.\nhave chi_i_ge0: 0 <= '[chi, 'chi_i].\n  by rewrite natr_ge0 ?Cnat_cfdot_char_irr.\nby rewrite !cfunE normrM (normr_idP _) ?ler_wpM2l ?char1_ge_norm ?irr_char.\nQed."
}
{
  "statement": "Lemma divp_eq0 p q : (p %/ q == 0) = [|| p == 0, q ==0 | size p < size q].\n",
  "proof": "Proof.\napply/eqP/idP=> [d0|]; last first.\n  case/or3P; [by move/eqP->; rewrite div0p| by move/eqP->; rewrite divp0|].\n  by move/divp_small.\ncase: eqVneq => // _; case: eqVneq => // qn0.\nmove: (divp_eq p q); rewrite d0 mul0r add0r.\nmove/(f_equal (fun x : {poly R} => size x)).\nby rewrite size_scale ?lc_expn_scalp_neq0 // => ->; rewrite ltn_modp qn0 !orbT.\nQed."
}
{
  "statement": "Lemma mx_faithful_irr_center_cyclic n (rG : mx_representation F G n) :\n  mx_faithful rG -> mx_irreducible rG -> cyclic 'Z(G).\n",
  "proof": "Proof.\ncase: n rG => [|n] rG injG irrG; first by case/mx_irrP: irrG.\nmove/trivgP: injG => KrG1; pose rZ := subg_repr rG (center_sub _).\napply: (div_ring_mul_group_cyclic (repr_mx1 rZ)) (repr_mxM rZ) _ _; last first.\n  exact: center_abelian.\nmove=> x; rewrite -[[set _]]KrG1 !inE mul1mx -subr_eq0 andbC; set U := _ - _.\ndo 2![case/andP]=> Gx cGx; rewrite Gx /=; apply: (mx_Schur irrG).\napply/centgmxP=> y Gy; rewrite mulmxBl mulmxBr mulmx1 mul1mx.\nby rewrite -!repr_mxM // (centP cGx).\nQed."
}
{
  "statement": "Lemma eval_lift (e : seq F) (p : {poly F}) : eval_poly e (lift p) = p.\n",
  "proof": "Proof.\nelim/poly_ind: p => [|p c]; first by rewrite /lift polyseq0.\nrewrite -cons_poly_def /lift polyseq_cons /nilp.\ncase pn0: (_ == _) => /=; last by move->; rewrite -cons_poly_def.\nmove=> _; rewrite polyseqC.\ncase c0: (_==_)=> /=.\n  move: pn0; rewrite (eqP c0) size_poly_eq0; move/eqP->.\n  by apply: val_inj=> /=; rewrite polyseq_cons // polyseq0.\nby rewrite mul0r add0r; apply: val_inj=> /=; rewrite polyseq_cons // /nilp pn0.\nQed."
}
{
  "statement": "Lemma mxsimple_abelemP (U : 'M['F_p]_n) :\n  reflect (mxsimple rG U) (minnormal (rV_E @* rowg U) G).\n",
  "proof": "Proof.\napply: (iffP mingroupP) => [[/andP[ntU modU] minU] | [modU ntU minU]].\n  split=> [||V modV sVU ntV]; first by rewrite mxmodule_abelem.\n    by apply: contraNneq ntU => ->; rewrite /= rowg0 morphim1.\n  rewrite -rowgS -rVabelemS [_ @* rowg V]minU //.\n    rewrite -subG1 sub_rVabelem_im morphim1 subG1 trivg_rowg ntV /=.\n    by rewrite -mxmodule_abelem.\n  by rewrite rVabelemS rowgS.\nsplit=> [|D /andP[ntD nDG sDU]].\n  rewrite -subG1 sub_rVabelem_im morphim1 subG1 trivg_rowg ntU /=.\n  by rewrite -mxmodule_abelem.\napply/eqP; rewrite eqEsubset sDU sub_rVabelem_im /= -rowg_mxSK rowgK.\nhave sDE: D \\subset E := subset_trans sDU (sub_rVabelem _).\nrewrite minU ?mxmodule_abelemG //.\n  by rewrite -rowgS rowg_mxK sub_abelem_rV_im.\nby rewrite rowg_mx_eq0 (morphim_injm_eq1 abelem_rV_injm).\nQed."
}
{
  "statement": "Lemma bigcprod_coprime_dprod (I : finType) (P : pred I) (A : I -> {set gT}) G :\n    \\big[cprod/1]_(i | P i) A i = G ->\n    (forall i j, P i -> P j -> i != j -> coprime #|A i| #|A j|) ->\n  \\big[dprod/1]_(i | P i) A i = G.\n",
  "proof": "Proof.\nmove=> defG coA; set Q := P in defG *; have sQP: subpred Q P by [].\nhave [m leQm] := ubnP #|Q|; elim: m => // m IHm in (Q) leQm G defG sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0 in defG *.\nmove: defG; rewrite !(bigD1 i Qi) /= => /cprodP[[Hi Gi defAi defGi] <-].\nrewrite defAi defGi => cHGi.\nhave{} defGi: \\big[dprod/1]_(j | Q j && (j != i)) A j = Gi.\n  by apply: IHm => [||j /andP[/sQP]] //; rewrite (cardD1x Qi) in leQm.\nrewrite defGi dprodE // coprime_TIg // -defAi -(bigdprod_card defGi).\nelim/big_rec: _ => [|j n /andP[neq_ji Qj] IHn]; first exact: coprimen1.\nby rewrite coprimeMr coprime_sym coA ?sQP.\nQed."
}
{
  "statement": "Lemma eq_irr_mem_classP x y :\n  y \\in G -> reflect (forall i, 'chi[G]_i x = 'chi_i y) (x \\in y ^: G).\n",
  "proof": "Proof.\nmove=> Gy; apply: (iffP idP) => [/imsetP[z Gz ->] i | xGy]; first exact: cfunJ.\nhave Gx: x \\in G.\n  congr is_true: Gy; apply/eqP; rewrite -(can_eq oddb) -eqC_nat -!cfun1E.\n  by rewrite -irr0 xGy.\ncongr is_true: (class_refl G x); apply/eqP; rewrite -(can_eq oddb).\nrewrite -(eqn_pmul2l (cardG_gt0 'C_G[x])) -eqC_nat !mulrnA; apply/eqP.\nby rewrite -!second_orthogonality_relation //; apply/eq_bigr=> i _; rewrite xGy.\nQed."
}
{
  "statement": "Lemma shortenP x p : path e x p -> shorten_spec x p (last x p) (shorten x p).\n",
  "proof": "Proof.\nmove=> e_p; have: x \\in x :: p by apply: mem_head.\nelim: p x {1 3 5}x e_p => [|y2 p IHp] x y1.\n  by rewrite mem_seq1 => _ /eqP->.\nrewrite inE orbC /= => /andP[ey12 {}/IHp IHp].\ncase: ifPn => [y2p_x _ | not_y2p_x /eqP def_x].\n  have [p' e_p' Up' p'p] := IHp _ y2p_x.\n  by split=> // y /p'p; apply: predU1r.\nhave [p' e_p' Up' p'p] := IHp y2 (mem_head y2 p).\nhave{} p'p z: z \\in y2 :: p' -> z \\in y2 :: p.\n  by rewrite !inE; case: (z == y2) => // /p'p.\nrewrite -(last_cons y1) def_x; split=> //=; first by rewrite ey12.\nby rewrite (contra (p'p y1)) -?def_x.\nQed."
}
{
  "statement": "Lemma big_imset h (A : {pred I}) G : {in A &, injective h} ->\n  \\big[aop/idx]_(j in h @: A) G j = \\big[aop/idx]_(i in A) G (h i).\n",
  "proof": "Proof.\nmove=> injh; pose hA := mem (image h A).\nrewrite (eq_bigl hA) => [|j]; last exact/imsetP/imageP.\npose h' := omap (fun u : {j | hA j} => iinv (svalP u)) \\o insub.\nrewrite (reindex_omap h h') => [|j hAj]; rewrite {}/h'/= ?insubT/= ?f_iinv//.\napply: eq_bigl => i; case: insubP => [u /= -> def_u | nhAhi]; last first.\n  by apply/andP/idP => [[]//| Ai]; case/imageP: nhAhi; exists i.\nset i' := iinv _; have Ai' : i' \\in A := mem_iinv (svalP u).\nby apply/eqP/idP => [[<-] // | Ai]; congr Some; apply: injh; rewrite ?f_iinv.\nQed."
}
{
  "statement": "Lemma subfx_irreducibleP :\n (forall q, root q^iota z -> q != 0 -> size p <= size q) <-> irreducible_poly p.\n",
  "proof": "Proof.\nsplit=> [min_p | irr_p q qz0 nz_q].\n  split=> [|q nonC_q q_dv_p].\n    by rewrite -(size_map_poly iota) (root_size_gt1 _ pz0) ?map_poly_eq0.\n  have /dvdpP[r Dp] := q_dv_p; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  have [nz_r nz_q]: r != 0 /\\ q != 0 by apply/norP; rewrite -mulf_eq0 -Dp.\n  have: root r^iota z || root q^iota z by rewrite -rootM -rmorphM -Dp.\n  case/orP=> /min_p; [case/(_ _)/idPn=> // | exact].\n  rewrite polySpred // -leqNgt Dp size_mul //= polySpred // -subn2 ltn_subRL.\n  by rewrite addSnnS addnC ltn_add2l ltn_neqAle eq_sym nonC_q size_poly_gt0.\npose r := gcdp p q; have nz_r: r != 0 by rewrite gcdp_eq0 (negPf nz_p).\nsuffices /eqp_size <-: r %= p by rewrite dvdp_leq ?dvdp_gcdr.\nrewrite (irr_p _) ?dvdp_gcdl // -(size_map_poly iota) gtn_eqF //.\nby rewrite (@root_size_gt1 _ z) ?map_poly_eq0 // gcdp_map root_gcd pz0.\nQed."
}
{
  "statement": "Lemma cf_triangle_leif phi psi :\n  sqrtC '[phi + psi] <= sqrtC '[phi] + sqrtC '[psi]\n           ?= iff ~~ free (phi :: psi) && (0 <= coord [tuple psi] 0 phi).\n",
  "proof": "Proof.\nrewrite -(mono_in_leif ler_sqr) ?rpredD ?qualifE/= ?sqrtC_ge0 ?cfnorm_ge0 //;\n  [| exact: O.. ].\nrewrite andbC sqrrD !sqrtCK addrAC cfnormD (mono_leif (lerD2l _)).\nrewrite -mulr_natr -[_ + _](divfK (negbT (eqC_nat 2 0))) -/('Re _).\nrewrite (mono_leif (ler_pM2r _)) ?ltr0n //.\nhave:= leif_trans (leif_Re_Creal '[phi, psi]) (cfCauchySchwarz_sqrt phi psi).\ncongr (_ <= _ ?= iff _); first by rewrite ReE.\napply: andb_id2r; rewrite free_cons span_seq1 seq1_free -negb_or negbK orbC /=.\nhave [-> | nz_psi] := eqVneq psi 0; first by rewrite cfdot0r coord0.\ncase/vlineP=> [x ->]; rewrite cfdotZl linearZ pmulr_lge0 ?cfnorm_gt0 //=.\nby rewrite (coord_free 0) ?seq1_free // eqxx mulr1.\nQed."
}
{
  "statement": "Lemma SylowP G P : reflect (exists2 p, prime p & p.-Sylow(G) P) (Sylow G P).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [p _]]; last exact: p_Sylow.\ncase/andP=> /p_groupP[p p_pr] /p_natP[[P1 _ | n oP /Hall_pi]]; last first.\n  by rewrite /= oP pi_of_exp // (eq_pHall _ _ (pi_of_prime _)) //; exists p.\nhave{p p_pr P1} ->: P :=: 1 by apply: card1_trivg; rewrite P1.\npose p := pdiv #|G|.+1; have p_pr: prime p by rewrite pdiv_prime ?ltnS.\nexists p; rewrite // pHallE sub1G cards1 part_p'nat //.\napply/pgroupP=> q pr_q qG; apply/eqnP=> def_q.\nhave: p %| #|G| + 1 by rewrite addn1 pdiv_dvd.\nby rewrite dvdn_addr -def_q // Euclid_dvd1.\nQed."
}
{
  "statement": "Lemma cfcenter_eq_center (i : Iirr G) :\n  ('Z('chi_i)%CF / cfker 'chi_i)%g = 'Z(G / cfker 'chi_i)%g.\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset; rewrite cfcenter_subset_center ?irr_char //.\napply/subsetP=> _ /setIP[/morphimP[x /= _ Gx ->] cGx]; rewrite mem_quotient //=.\nrewrite -irrRepr cfker_repr cfcenter_repr inE Gx in cGx *.\napply: mx_abs_irr_cent_scalar 'Chi_i _ _ _; first exact/groupC/socle_irr.\nhave nKG: G \\subset 'N(rker 'Chi_i) by apply: rker_norm.\n\napply/centgmxP=> y Gy; rewrite [eq]lock -2?(quo_repr_coset (subxx _) nKG) //.\nmove: (quo_repr _ _) => rG; rewrite -2?repr_mxM ?mem_quotient // -lock.\nby rewrite (centP cGx) // mem_quotient.\nQed."
}
{
  "statement": "Lemma cfMorph_iso aT rT (G D : {group aT}) (f : {morphism D >-> rT}) :\n  G \\subset D -> isometry (cfMorph : 'CF(f @* G) -> 'CF(G)).\n",
  "proof": "Proof.\nmove=> sGD phi psi; rewrite !cfdotE card_morphim (setIidPr sGD).\nrewrite -(LagrangeI G ('ker f)) /= mulnC natrM invfM -mulrA.\ncongr (_ * _); apply: (canLR (mulKf (neq0CG _))).\nrewrite mulr_sumr (partition_big_imset f) /= -morphimEsub //.\napply: eq_bigr => _ /morphimP[x Dx Gx ->].\nrewrite -(card_rcoset _ x) mulr_natl -sumr_const.\napply/eq_big => [y | y /andP[Gy /eqP <-]]; last by rewrite !cfMorphE.\nrewrite mem_rcoset inE groupMr ?groupV // -mem_rcoset.\nby apply: andb_id2l => /(subsetP sGD) Dy; apply: sameP eqP (rcoset_kerP f _ _).\nQed."
}
{
  "statement": "Lemma gactsM (N1 N2 : {set rT}) :\n    N1 \\subset D -> N2 \\subset D ->\n  [acts A, on N1 | to] -> [acts A, on N2 | to] -> [acts A, on N1 * N2 | to].\n",
  "proof": "Proof.\nmove=> sN1D sN2D aAN1 aAN2; apply/gactsP=> x Ax y.\napply/idP/idP; case/mulsgP=> y1 y2 N1y1 N2y2 e.\n  move: (actKin to Ax y); rewrite e; move<-.\n  rewrite gactM ?groupV ?(subsetP sN1D y1) ?(subsetP sN2D) //.\n  by apply: mem_mulg; rewrite ?(gactsP _ aAN1) ?(gactsP _ aAN2) // groupV.\nrewrite e gactM // ?(subsetP sN1D y1) ?(subsetP sN2D) //.\nby apply: mem_mulg; rewrite ?(gactsP _ aAN1) // ?(gactsP _ aAN2).\nQed."
}
{
  "statement": "Lemma mx_iso_component V : mx_iso U V -> (V <= compU)%MS.\n",
  "proof": "Proof.\nmove=> isoUV; have [f injf homUf defV] := isoUV.\nhave simV := mx_iso_simple isoUV simU.\nhave hom_u_f := submx_trans Uu homUf.\nhave ->: (V :=: cyclic_mx (u *m f))%MS.\n  apply: eqmx_trans (hom_cyclic_mx hom_u_f).\n  exact: eqmx_trans (eqmx_sym defV) (eqmxMr _ defU).\nhave iso_uf: (u *m f <= iso_u)%MS by apply/row_hom_mxP; exists f.\nrewrite genmxE; apply/row_subP=> j; rewrite row_mul mul_rV_lin1 /=.\nset a := vec_mx _; apply: submx_trans (submxMr _ iso_uf) _.\napply/row_subP=> i; rewrite row_mul [in compU]unlock (sumsmx_sup i) //.\nby apply/cyclic_mxP; exists a; rewrite // vec_mxK row_sub.\nQed."
}
{
  "statement": "Lemma row_freePn m n (M : 'M[F]_(m, n)) :\n reflect (exists i, (row i M <= row' i M)%MS) (~~ row_free M).\n",
  "proof": "Proof.\nrewrite -kermx_eq0; apply: (iffP (rowV0Pn _)) => [|[i0 /submxP[D rM]]].\n  move=> [v /sub_kermxP vM_eq0 /rV0Pn[i0 vi0_neq0]]; exists i0.\n  have := vM_eq0; rewrite mulmx_sum_row (bigD1_ord i0)//=.\n  move=> /(canRL (addrK _))/(canRL (scalerK _))->//.\n  rewrite sub0r scalerN -scaleNr scalemx_sub// summx_sub// => l _.\n  by rewrite scalemx_sub// -row_rowsub row_sub.\nexists (\\row_j oapp (D 0) (- 1) (unlift i0 j)); last first.\n  by apply/rV0Pn; exists i0; rewrite !mxE unlift_none/= oppr_eq0 oner_eq0.\napply/sub_kermxP; rewrite mulmx_sum_row (bigD1_ord i0)//= !mxE.\nrewrite unlift_none scaleN1r rM mulmx_sum_row addrC -sumrB big1 // => l _.\nby rewrite !mxE liftK row_rowsub subrr.\nQed."
}
{
  "statement": "Lemma ex_minset P : (exists A, P A) -> {A | minset P A}.\n",
  "proof": "Proof.\nmove=> exP; pose pS n := [pred B | P B & #|B| == n].\npose p n := ~~ pred0b (pS n); have{exP}: exists n, p n.\n  by case: exP => A PA; exists #|A|; apply/existsP; exists A; rewrite /= PA /=.\ncase/ex_minnP=> n /pred0P; case: (pickP (pS n)) => // A /andP[PA] /eqP <-{n} _.\nmove=> minA; exists A => //; apply/minsetP; split=> // B PB sBA; apply/eqP.\nby rewrite eqEcard sBA minA //; apply/pred0Pn; exists B; rewrite /= PB /=.\nQed."
}
{
  "statement": "Lemma coprime_mulG_setI_norm H G K R :\n    K * R = G -> G \\subset 'N(H) -> coprime #|K| #|R| ->\n  (K :&: H) * (R :&: H) = G :&: H.\n",
  "proof": "Proof.\nmove=> defG nHG coKR; apply/eqP; rewrite eqEcard mulG_subG /= -defG.\nrewrite !setSI ?mulG_subl ?mulG_subr //=.\nrewrite coprime_cardMg ?(coKR, coprimeSg (subsetIl _ _), coprime_sym) //=.\npose pi := \\pi(K); have piK: pi.-group K by apply: pgroup_pi.\nhave pi'R: pi^'.-group R by rewrite /pgroup -coprime_pi' /=.\nhave [hallK hallR] := coprime_mulpG_Hall defG piK pi'R.\nhave nsHG: H :&: G <| G by rewrite /normal subsetIr normsI ?normG.\nrewrite -!(setIC H) defG -(partnC pi (cardG_gt0 _)).\nrewrite -(card_Hall (Hall_setI_normal nsHG hallR)) /= setICA.\nrewrite -(card_Hall (Hall_setI_normal nsHG hallK)) /= setICA.\nby rewrite -defG (setIidPl (mulG_subl _ _)) (setIidPl (mulG_subr _ _)).\nQed."
}
{
  "statement": "Lemma leq_divpl d p q :\n  d %| p -> (size (p %/ d) <= size q) = (size p <= size (q * d)).\n",
  "proof": "Proof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | nd0 hd].\n  by rewrite divp0 size_poly0 !leq0n.\nrewrite leq_eqVlt ltn_divpl // (leq_eqVlt (size p)).\ncase lhs: (size p < size (q * d)); rewrite ?orbT ?orbF //.\nhave: (lead_coef d) ^+ (scalp p d) != 0 by rewrite expf_neq0 // lead_coef_eq0.\nmove/(size_scale p)<-; rewrite divp_eq; move/modp_eq0P: hd->; rewrite addr0.\nhave [-> | quon0] := eqVneq (p %/ d) 0.\n  rewrite mul0r size_poly0 2!(eq_sym 0) !size_poly_eq0.\n  by rewrite mulf_eq0 (negPf nd0) orbF.\nhave [-> | nq0] := eqVneq q 0.\n  by rewrite mul0r size_poly0 !size_poly_eq0 mulf_eq0 (negPf nd0) orbF.\nby rewrite !size_mul // (polySpred nd0) !addnS /= eqn_add2r.\nQed."
}
{
  "statement": "Lemma normedTI_memJ_P A G L :\n  reflect [/\\ A != set0, L \\subset G\n            & {in A & G, forall a g, (a ^ g \\in A) = (g \\in L)}]\n          (normedTI A G L).\n",
  "proof": "Proof.\napply: (iffP normedTI_P) => [[-> /subsetIP[sLG nAL] tiAG] | [-> sLG tiAG]].\n  split=> // a g Aa Gg; apply/idP/idP=> [Aag | Lg]; last first.\n    by rewrite memJ_norm ?(subsetP nAL).\n  by apply/tiAG/pred0Pn=> //; exists (a ^ g)%g; rewrite /= Aag memJ_conjg.\nsplit=> // [ | g Gg /pred0Pn[ag /=]]; last first.\n  by rewrite andbC => /andP[/imsetP[a Aa ->]]; rewrite tiAG.\napply/subsetP=> g Lg; have Gg := subsetP sLG g Lg.\nby rewrite !inE Gg; apply/subsetP=> _ /imsetP[a Aa ->]; rewrite tiAG.\nQed."
}
{
  "statement": "Lemma card_extraspecial : {n | n > 0 & #|S| = (p ^ n.*2.+1)%N}.\n",
  "proof": "Proof.\nset T := S; exists (logn p #|T|)./2.\n  rewrite half_gt0 ltnW // -(leq_exp2l _ _ (prime_gt1 p_pr)) -card_pgroup //.\n  exact: min_card_extraspecial.\nhave [Es] := extraspecial_structure pS esS; rewrite -[in RHS]/T.\nelim: Es T => [_ _ <-| E s IHs T] /=.\n  by rewrite big_nil cprod1g oZ (pfactorK 1).\nrewrite -andbA big_cons -cprodA => /and3P[/eqP oEp3 /eqP defZE].\nmove=> /IHs{}IHs /cprodP[[_ U _ defU]]; rewrite defU => defT cEU.\nrewrite -(mulnK #|T| (cardG_gt0 (E :&: U))) -defT -mul_cardG /=.\nhave ->: E :&: U = 'Z(S).\n  apply/eqP; rewrite eqEsubset subsetI -{1 2}defZE subsetIl setIS //=.\n  by case/cprodP: defU => [[V _ -> _]]  <- _; apply: mulG_subr.\nrewrite (IHs U) // oEp3 oZ -expnD addSn expnS mulKn ?prime_gt0 //.\nby rewrite pfactorK //= uphalf_double.\nQed."
}
{
  "statement": "Lemma morphimR A B :\n  A \\subset D -> B \\subset D -> f @* [~: A, B] = [~: f @* A, f @* B].\n",
  "proof": "Proof.\nmove/subsetP=> sAD /subsetP sBD.\nrewrite morphim_gen; last first; last congr <<_>>.\n  by apply/subsetP=> _ /imset2P[x y Ax By ->]; rewrite groupR; auto.\napply/setP=> fz; apply/morphimP/imset2P=> [[z _] | [fx fy]].\n  case/imset2P=> x y Ax By -> -> {z fz}.\n  have Dx := sAD x Ax; have Dy := sBD y By.\n  by exists (f x) (f y); rewrite ?(imset_f, morphR) // ?(inE, Dx, Dy).\ncase/morphimP=> x Dx Ax ->{fx}; case/morphimP=> y Dy By ->{fy} -> {fz}.\nby exists [~ x, y]; rewrite ?(inE, morphR, groupR, imset2_f).\nQed."
}
{
  "statement": "Lemma uniq4_uniq6 : forall x y z t : cube,\n  uniq [:: x; y; z; t] -> exists u, exists v, uniq [:: x; y; z; t; u; v].\n",
  "proof": "Proof.\nmove=> x y z t Uxt; move: (cardC [in [:: x; y; z; t]]).\nrewrite card_ord  (card_uniq_tuple Uxt) => hcard.\nhave hcard2: #|[predC [:: x; y; z; t]]| = 2.\n  by apply: (@addnI 4); rewrite /injective  hcard.\nhave:  #|[predC [:: x; y; z; t]]| != 0 by rewrite hcard2.\ncase/existsP=> u Hu; exists u.\nmove: (cardC [in [:: x; y; z; t; u]]); rewrite card_ord => hcard5.\nhave: #|[predC [:: x; y; z; t; u]]| !=0.\n  rewrite -lt0n  -(ltn_add2l #|[:: x; y; z; t; u]|) hcard5 addn0.\n  by apply: (leq_ltn_trans (card_size [:: x; y; z; t; u])).\ncase/existsP => v; rewrite (mem_cat _ [:: _; _; _; _]) => /norP[Hv Huv].\nexists v; rewrite (cat_uniq [:: x; y; z; t]) Uxt andTb -rev_uniq /= orbF.\nby rewrite negb_or Hu Hv Huv.\nQed."
}
{
  "statement": "Lemma leq_size_uniq s1 s2 :\n  uniq s1 -> {subset s1 <= s2} -> size s2 <= size s1 -> uniq s2.\n",
  "proof": "Proof.\nelim: s1 s2 => [[] | x s1 IHs s2] // Us1x; have /andP[not_s1x Us1] := Us1x.\ncase/forall_cons => /rot_to[i s3 def_s2] ss12 le_s21.\nrewrite -(rot_uniq i) -(size_rot i) def_s2 /= in le_s21 *.\nhave ss13 y (s1y : y \\in s1): y \\in s3.\n  by have:= ss12 y s1y; rewrite -(mem_rot i) def_s2 inE (negPf (memPn _ y s1y)).\nrewrite IHs // andbT; apply: contraL _ le_s21 => s3x; rewrite -leqNgt.\nby apply/(uniq_leq_size Us1x)/allP; rewrite /= s3x; apply/allP.\nQed."
}
{
  "statement": "Lemma derivedP G : reflect (exists n, G^`(n) = 1) (solvable G).\n",
  "proof": "Proof.\napply: (iffP idP) => [solG | [n solGn]]; last first.\n  apply/forall_inP=> H /subsetIP[sHG sHH'].\n  rewrite -subG1 -{}solGn; elim: n => // n IHn.\n  exact: subset_trans sHH' (commgSS _ _).\nsuffices IHn n: #|G^`(n)| <= (#|G|.-1 - n).+1.\n  by exists #|G|.-1; rewrite [G^`(_)]card_le1_trivg ?(leq_trans (IHn _)) ?subnn.\nelim: n => [|n IHn]; first by rewrite subn0 prednK.\nrewrite dergSn subnS -ltnS.\nhave [-> | ntGn] := eqVneq G^`(n) 1; first by rewrite commG1 cards1.\ncase: (_ - _) IHn => [|n']; first by rewrite leqNgt cardG_gt1 ntGn.\nby apply: leq_trans (proper_card _); apply: sol_der1_proper (der_sub _ _) _.\nQed."
}
{
  "statement": "Lemma mxtrace_dadd_mod U V W (modU : mG U) (modV : mG V) (modW : mG W) :\n    (U + V :=: W)%MS -> mxdirect (U + V) ->\n  {in G, forall x, \\tr (sr modU x) + \\tr (sr modV x) = \\tr (sr modW x)}.\n",
  "proof": "Proof.\nmove=> defW dxW x Gx; have [sUW sVW]: (U <= W)%MS /\\ (V <= W)%MS.\n  by apply/andP; rewrite -addsmx_sub defW.\npose U' := <<in_submod W U>>%MS; pose V' := <<in_submod W V>>%MS.\nhave addUV': (U' + V' :=: 1%:M)%MS.\n  apply/eqmxP; rewrite submx1 /= (adds_eqmx (genmxE _) (genmxE _)).\n  by rewrite -addsmxMr -val_submodS val_submod1 in_submodK ?defW.\nhave dxUV': mxdirect (U' + V').\n  apply/eqnP; rewrite /= addUV' mxrank1 !genmxE !mxrank_in_submod //.\n  by rewrite -(mxdirectP dxW) /= defW.\nhave [modU' simU] := mx_rsim_in_submod modU modW sUW.\nhave [modV' simV] := mx_rsim_in_submod modV modW sVW.\nrewrite (mxtrace_rsim simU) // (mxtrace_rsim simV) //.\nrewrite -(mxtrace_sub_fact_mod modV') addrC; congr (_ + _).\nby rewrite (mxtrace_rsim (mx_rsim_factmod modU' modV' addUV' dxUV')).\nQed."
}
{
  "statement": "Lemma exchange_big_dep_nat_idem m1 n1 m2 n2 (P : pred nat) (Q : rel nat)\n                           (xQ : pred nat) F :\n    (forall i j, m1 <= i < n1 -> m2 <= j < n2 -> P i -> Q i j -> xQ j) ->\n  \\big[op/x]_(m1 <= i < n1 | P i) \\big[op/x]_(m2 <= j < n2 | Q i j) F i j =\n    \\big[op/x]_(m2 <= j < n2 | xQ j)\n       \\big[op/x]_(m1 <= i < n1 | P i && Q i j) F i j.\n",
  "proof": "Proof.\nmove=> PQxQ; under eq_bigr do rewrite big_seq_cond.\nrewrite big_seq_cond /= (exchange_big_dep_idem xQ) => [|i j]; last first.\n  by rewrite !mem_index_iota => /andP[mn_i Pi] /andP[mn_j /PQxQ->].\nrewrite 2!(big_seq_cond _ _ _ xQ); apply: eq_bigr => j /andP[-> _] /=.\nby rewrite [rhs in _ = rhs]big_seq_cond; apply: eq_bigl => i; rewrite -andbA.\nQed."
}
{
  "statement": "Lemma leqifD_distz m1 m2 m3 :\n  `|m1 - m3| <= `|m1 - m2| + `|m2 - m3|\n             ?= iff (m1 <= m2 <= m3)%R || (m3 <= m2 <= m1)%R.\n",
  "proof": "Proof.\napply/leqifP; rewrite -ltz_nat -eqz_nat PoszD !abszE; apply/leifP.\nwlog le_m31 : m1 m3 / (m3 <= m1)%R.\n  move=> IH; case/orP: (le_total m1 m3) => /IH //.\n  by rewrite (addrC `|_|)%R orbC !(distrC m1) !(distrC m3).\nrewrite ger0_norm ?subr_ge0 // orb_idl => [|/andP[le_m12 le_m23]]; last first.\n  by have /eqP->: m2 == m3; rewrite ?lexx // eq_le le_m23 (le_trans le_m31).\nrewrite -{1}(subrK m2 m1) -(addrA _ m2) -subr_ge0 andbC -[X in X && _]subr_ge0.\nby apply: leifD; apply/real_leif_norm/num_real.\nQed."
}
{
  "statement": "Lemma rcosets_partition_mul G H : partition (rcosets H G) (H * G).\n",
  "proof": "Proof.\nset HG := H * G; have sGHG: {subset G <= HG} by apply/subsetP/mulG_subr.\nhave defHx x: x \\in HG -> [set y in HG | rcoset H x == rcoset H y] = H :* x.\n  move=> HGx; apply/setP=> y; rewrite inE !rcosetE (sameP eqP rcoset_eqP).\n  by rewrite rcoset_sym; apply/andb_idl/subsetP; rewrite mulGS sub1set.\nhave:= preim_partitionP (rcoset H) HG; congr (partition _ _); apply/setP=> Hx.\napply/imsetP/idP=> [[x HGx ->] | ]; first by rewrite defHx // mem_rcosets.\nby case/rcosetsP=> x /sGHG-HGx ->; exists x; rewrite ?defHx.\nQed."
}
{
  "statement": "Lemma bigcprodYP (I : finType) (P : pred I) (H : I -> {group gT}) :\n  reflect (forall i j, P i -> P j -> i != j -> H i \\subset 'C(H j))\n          (\\big[cprod/1]_(i | P i) H i == (\\prod_(i | P i) H i)%G).\n",
  "proof": "Proof.\napply: (iffP eqP) => [defG i j Pi Pj neq_ij | cHH].\n  rewrite (bigD1 j) // (bigD1 i) /= ?cprodA in defG; last exact/andP.\n  by case/cprodP: defG => [[K _ /cprodP[//]]].\nset Q := P; have sQP: subpred Q P by []; have [n leQn] := ubnP #|Q|.\nelim: n => // n IHn in (Q) leQn sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0.\nrewrite (cardD1x Qi) add1n ltnS !(bigD1 i Qi) /= in leQn *.\nrewrite {}IHn {n leQn}// => [|j /andP[/sQP //]].\nrewrite bigprodGE cprodEY // gen_subG; apply/bigcupsP=> j /andP[neq_ji Qj].\nby rewrite cHH ?sQP.\nQed."
}
{
  "statement": "Lemma hom_mxP m f (W : 'M_(m, n)) :\n  reflect (forall x, x \\in G -> W *m rG x *m f = W *m f *m rG x)\n          (W <= dom_hom_mx f)%MS.\n",
  "proof": "Proof.\napply: (iffP row_subP) => [cGf x Gx | cGf i].\n  apply/row_matrixP=> i; apply/eqP; rewrite -subr_eq0 -!mulmxA -!linearB /=.\n  have:= sub_kermxP (cGf i); rewrite mul_rV_lin1 /=.\n  move/(canRL mxvecK)/row_matrixP/(_ (enum_rank_in Gx x))/eqP; rewrite !linear0.\n  by rewrite !row_mul rowK mul_vec_lin /= mul_vec_lin_row enum_rankK_in.\napply/sub_kermxP; rewrite mul_rV_lin1 /=; apply: (canLR vec_mxK).\napply/row_matrixP=> j; rewrite !row_mul rowK mul_vec_lin /= mul_vec_lin_row.\nby rewrite -!row_mul mulmxBr !mulmxA cGf ?enum_valP // subrr !linear0.\nQed."
}
{
  "statement": "Lemma cfnorm_Res_leif H phi :\n    H \\subset G ->\n  '['Res[H] phi] <= #|G : H|%:R * '[phi] ?= iff (phi \\in 'CF(G, H)).\n",
  "proof": "Proof.\nmove=> sHG; rewrite cfun_onE mulrCA natf_indexg // -mulrA mulKf ?neq0CG //.\nrewrite (big_setID H) (setIidPr sHG) /= addrC.\nrewrite (mono_leif (ler_pM2l _)) ?invr_gt0 ?gt0CG // -leifBLR -sumrB.\nrewrite big1 => [|x Hx]; last by rewrite !cfResE ?subrr.\nhave ->: (support phi \\subset H) = (G :\\: H \\subset [set x | phi x == 0]).\n  rewrite subDset setUC -subDset; apply: eq_subset => x.\n  by rewrite !inE (andb_idr (contraR _)) // => /cfun0->.\nrewrite (sameP subsetP forall_inP); apply: leif_0_sum => x _.\nby rewrite !inE /<?=%R mul_conjC_ge0 eq_sym mul_conjC_eq0.\nQed."
}
{
  "statement": "Lemma Frobenius_coprime_quotient (gT : finGroupType) (G K H N : {group gT}) :\n    K ><| H = G -> N <| G -> coprime #|K| #|H| /\\ H :!=: 1%g ->\n    N \\proper K /\\ {in H^#, forall x, 'C_K[x] \\subset N} ->\n  [Frobenius G / N = (K / N) ><| (H / N)]%g.\n",
  "proof": "Proof.\nmove=> defG nsNG [coKH ntH] [ltNK regH].\nhave [[sNK _] [_ /mulG_sub[sKG sHG] _ _]] := (andP ltNK, sdprodP defG).\nhave [_ nNG] := andP nsNG; have nNH := subset_trans sHG nNG.\napply/Frobenius_semiregularP; first exact: quotient_coprime_sdprod.\n- by rewrite quotient_neq1 ?(normalS _ sKG).\n- by rewrite -(isog_eq1 (quotient_isog _ _)) ?coprime_TIg ?(coprimeSg sNK).\nmove=> _ /(subsetP (quotientD1 _ _))/morphimP[x nNx H1x ->].\nrewrite -cent_cycle -quotient_cycle //=.\nrewrite -strongest_coprime_quotient_cent ?cycle_subG //.\n- by rewrite cent_cycle quotientS1 ?regH.\n- by rewrite subIset ?sNK.\n- rewrite (coprimeSg (subsetIl N _)) ?(coprimeSg sNK) ?(coprimegS _ coKH) //.\n  by rewrite cycle_subG; case/setD1P: H1x.\nby rewrite orbC abelian_sol ?cycle_abelian.\nQed."
}
{
  "statement": "Lemma acts_irrQ G U V :\n    G \\subset 'N(V) -> V <| U ->\n  acts_irreducibly G (U / V) 'Q = minnormal (U / V) (G / V).\n",
  "proof": "Proof.\nmove=> nVG nsVU; apply/mingroupP/mingroupP; case=> /andP[->] /=.\n  rewrite astabsQ // subsetI nVG /= => nUG minUV.\n  rewrite quotient_norms //; split=> // H /andP[ntH nHG] sHU.\n  by apply: minUV (sHU); rewrite ntH -(cosetpreK H) actsQ // norm_quotient_pre.\nrewrite sub_quotient_pre // => nUG minU; rewrite astabsQ //.\nrewrite (subset_trans nUG); last first.\n  by rewrite subsetI subsetIl /= -{2}(quotientGK nsVU) morphpre_norm.\nsplit=> // H /andP[ntH nHG] sHU.\nrewrite -{1}(cosetpreK H) astabsQ ?normal_cosetpre ?subsetI ?nVG //= in nHG.\napply: minU sHU; rewrite ntH; apply: subset_trans (quotientS _ nHG) _.\nby rewrite -{2}(cosetpreK H) quotient_norm.\nQed."
}
{
  "statement": "Lemma bigcap_p'core pi G :\n  G :&: \\bigcap_(p < #|G|.+1 | (p : nat) \\in pi) 'O_p^'(G) = 'O_pi^'(G).\n",
  "proof": "Proof.\napply/eqP; rewrite eqEsubset subsetI pcore_sub pcore_max /=.\n- by apply/bigcapsP=> p pi_p; apply: sub_pcore => r; apply: contraNneq => ->.\n- apply/pgroupP=> q q_pr qGpi'; apply: contraL (eqxx q) => /= pi_q.\n  apply: (pgroupP (pcore_pgroup q^' G)) => //.\n  have qG: q %| #|G| by rewrite (dvdn_trans qGpi') // cardSg ?subsetIl.\n  have ltqG: q < #|G|.+1 by rewrite ltnS dvdn_leq.\n  rewrite (dvdn_trans qGpi') ?cardSg ?subIset //= orbC.\n  by rewrite (bigcap_inf (Ordinal ltqG)).\nrewrite /normal subsetIl normsI ?normG // norms_bigcap //.\nby apply/bigcapsP => p _; apply: gFnorm.\nQed."
}
{
  "statement": "Theorem max_poly_roots p rs :\n  p != 0 -> all (root p) rs -> uniq rs -> size rs < size p.\n",
  "proof": "Proof.\nelim: rs p => [p pn0 _ _ | r rs ihrs p pn0] /=; first by rewrite size_poly_gt0.\ncase/andP => rpr arrs /andP [rnrs urs]; case/factor_theorem: rpr => q epq.\nhave [q0 | ?] := eqVneq q 0; first by move: pn0; rewrite epq q0 mul0r eqxx.\nhave -> : size p = (size q).+1.\n   by rewrite epq size_Mmonic ?monicXsubC // size_XsubC addnC.\nsuff /eq_in_all h : {in rs, root q =1 root p} by apply: ihrs => //; rewrite h.\nmove=> x xrs; rewrite epq rootM root_XsubC orbC; case: (eqVneq x r) => // exr.\nby move: rnrs; rewrite -exr xrs.\nQed."
}
{
  "statement": "Lemma totient_coprime m n :\n  coprime m n -> totient (m * n) = totient m * totient n.\n",
  "proof": "Proof.\nmove=> co_mn; have [-> //| m_gt0] := posnP m.\nhave [->|n_gt0] := posnP n; first by rewrite !muln0.\nrewrite !totientE ?muln_gt0 ?m_gt0 //.\nhave /(perm_big _)->: perm_eq (primes (m * n)) (primes m ++ primes n).\n  apply: uniq_perm => [||p]; first exact: primes_uniq.\n    by rewrite cat_uniq !primes_uniq -coprime_has_primes // co_mn.\n  by rewrite mem_cat primesM.\nrewrite big_cat /= !big_seq.\ncongr (_ * _); apply: eq_bigr => p; rewrite mem_primes => /and3P[_ _ dvp].\n  rewrite (mulnC m) logn_Gauss //; move: co_mn.\n  by rewrite -(divnK dvp) coprimeMl => /andP[].\nrewrite logn_Gauss //; move: co_mn.\nby rewrite coprime_sym -(divnK dvp) coprimeMl => /andP[].\nQed."
}
{
  "statement": "Lemma root_monic_Aint p x :\n  root p x -> p \\is monic -> p \\is a polyOver Num.int -> x \\in Aint.\n",
  "proof": "Proof.\nhave pZtoQtoC pz: pQtoC (pZtoQ pz) = pZtoC pz.\n  by rewrite -map_poly_comp; apply: eq_map_poly => b; rewrite /= rmorph_int.\nmove=> px0 mon_p /floorpP[pz Dp]; rewrite unfold_in.\nmove: px0; rewrite Dp -pZtoQtoC; have [q [-> mon_q] ->] := minCpolyP x.\ncase/dvdpP_rat_int=> qz [a nz_a Dq] [r].\nmove/(congr1 (fun q1 => lead_coef (a *: pZtoQ q1))).\nrewrite rmorphM scalerAl -Dq lead_coefZ lead_coefM /=.\nhave /monicP->: pZtoQ pz \\is monic by rewrite -(map_monic QtoC) pZtoQtoC -Dp.\nrewrite (monicP mon_q) mul1r mulr1 lead_coef_map_inj //; last exact: intr_inj.\nrewrite Dq => ->; apply/polyOverP=> i; rewrite !(coefZ, coef_map).\nby rewrite -rmorphM /= rmorph_int.\nQed."
}
{
  "statement": "Lemma cfIndEsdprod (phi : 'CF(K)) x :\n  K ><| H = G -> 'Ind[G] phi x = \\sum_(w in H) phi (x ^ w)%g.\n",
  "proof": "Proof.\nmove=> defG; have [/andP[sKG _] _ mulKH nKH _] := sdprod_context defG.\nrewrite cfIndE //; apply: canLR (mulKf (neq0CG _)) _; rewrite -mulKH mulr_sumr.\nrewrite (set_partition_big _ (rcosets_partition_mul H K)) ?big_imset /=.\n  apply: eq_bigr => y Hy; rewrite rcosetE norm_rlcoset ?(subsetP nKH) //.\n  rewrite -lcosetE mulr_natl big_imset /=; last exact: in2W (mulgI _).\n  by rewrite -sumr_const; apply: eq_bigr => z Kz; rewrite conjgM cfunJ.\nhave [{}nKH /isomP[injf _]] := sdprod_isom defG.\napply: can_in_inj (fun Ky => invm injf (coset K (repr Ky))) _ => y Hy.\nby rewrite rcosetE -val_coset ?(subsetP nKH) // coset_reprK invmE.\nQed."
}
{
  "statement": "Lemma dvdpP q p :\n  reflect (exists2 cqq, cqq.1 != 0 & cqq.1 *: p = cqq.2 * q) (q %| p).\n",
  "proof": "Proof.\nrewrite dvdp_eq; apply: (iffP eqP) => [e | [[c qq] cn0 e]].\n  by exists (lead_coef q ^+ scalp p q, p %/ q) => //=.\napply/eqP; rewrite -dvdp_eq dvdpE.\nhave Ecc: c%:P != 0 by rewrite polyC_eq0.\nhave [->|nz_p] := eqVneq p 0; first by rewrite rdvdp0.\npose p1 : {poly R} := lead_coef q ^+ rscalp p q *: qq - c *: (rdivp p q).\nhave E1: c *: rmodp p q = p1 * q.\n  rewrite mulrDl mulNr -scalerAl -e scalerA mulrC -scalerA -scalerAl.\n  by rewrite -scalerBr rdivp_eq addrC addKr.\nsuff: p1 * q == 0 by rewrite -E1 -mul_polyC mulf_eq0 (negPf Ecc).\nrewrite mulf_eq0; apply/norP; case=> p1_nz q_nz; have:= ltn_rmodp p q.\nby rewrite q_nz -(size_scale _ cn0) E1 size_mul // polySpred // ltnNge leq_addl.\nQed."
}
{
  "statement": "Lemma divp_pmul2l p q : lead_coef q \\in GRing.unit -> d * p %/ (d * q) = p %/ q.\n",
  "proof": "Proof.\nmove=> uq; rewrite {1}(divp_eq uq p) mulrDr mulrCA divp_addl_mul //; last first.\n  by rewrite lead_coefM unitrM_comm ?ulcd //; red; rewrite mulrC.\nhave dn0 : d != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcd => ->; rewrite unitr0.\nhave qn0 : q != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq uq => ->; rewrite unitr0.\nhave dqn0 : d * q != 0 by rewrite mulf_eq0 negb_or dn0.\nsuff : size (d * (p %% q)) < size (d * q).\n  by rewrite ltnNge -divpN0 // negbK => /eqP ->; rewrite addr0.\nhave [-> | rn0] := eqVneq (p %% q) 0.\n  by rewrite mulr0 size_poly0 size_poly_gt0.\nby rewrite !size_mul // (polySpred dn0) !addSn /= ltn_add2l ltn_modp.\nQed."
}
{
  "statement": "Lemma mxrank_disjoint_sum m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (A :&: B)%MS = 0 -> \\rank (A + B)%MS = (\\rank A + \\rank B)%N.\n",
  "proof": "Proof.\nmove=> AB0; pose Ar := row_base A; pose Br := row_base B.\nhave [Afree Bfree]: row_free Ar /\\ row_free Br by rewrite !row_base_free.\nhave: (Ar :&: Br <= A :&: B)%MS by rewrite capmxS ?eq_row_base.\nrewrite {}AB0 submx0 -mxrank_eq0 capmxE mxrankMfree //.\nset Cr := col_mx Ar Br; set Crl := lsubmx _; rewrite mxrank_eq0 => /eqP Crl0.\nrewrite -(adds_eqmx (eq_row_base _) (eq_row_base _)) addsmxE -/Cr.\nsuffices K0: kermx Cr = 0.\n  by apply/eqP; rewrite eqn_leq rank_leq_row -subn_eq0 -mxrank_ker K0 mxrank0.\nmove/eqP: (mulmx_ker Cr); rewrite -[kermx Cr]hsubmxK mul_row_col -/Crl Crl0.\nrewrite mul0mx add0r -mxrank_eq0 mxrankMfree // mxrank_eq0 => /eqP->.\nexact: row_mx0.\nQed."
}
{
  "statement": "Lemma char_from_quotient (gT : finGroupType) (G H K : {group gT}) :\n  H <| K -> H \\char G -> K / H \\char G / H -> K \\char G.\n",
  "proof": "Proof.\ncase/andP=> sHK nHK chHG.\nhave nsHG := char_normal chHG; have [sHG nHG] := andP nsHG.\ncase/charP; rewrite quotientSGK // => sKG /= chKG.\napply/charP; split=> // f injf Gf; apply/morphim_fixP => //.\nrewrite -(quotientSGK _ sHK); last by rewrite -morphimIim Gf subIset ?nHG.\nhave{chHG} Hf: f @* H = H by case/charP: chHG => _; apply.\nset q := quotm_morphism f nsHG; have{injf}: 'injm q by apply: injm_quotm.\nhave: q @* _ = _ := morphim_quotm _ _ _; move: q; rewrite Hf => q im_q injq.\nby rewrite -im_q chKG // im_q Gf.\nQed."
}
{
  "statement": "Lemma group_closure_closed_field (F : closedFieldType) gT :\n  group_closure_field F gT.\n",
  "proof": "Proof.\nmove=> G [|n] rG irrG; first by case/mx_irrP: irrG.\napply: cent_mx_scalar_abs_irr => //; rewrite leqNgt.\napply/(has_non_scalar_mxP (scalar_mx_cent _ _)) => [[A cGA nscalA]].\nhave [a]: exists a, eigenvalue A a.\n  pose P := mxminpoly A; pose d := degree_mxminpoly A.\n  have Pd1: P`_d = 1.\n    by rewrite -(eqP (mxminpoly_monic A)) /lead_coef size_mxminpoly.\n  have d_gt0: d > 0 := mxminpoly_nonconstant A.\n  have [a def_ad] := solve_monicpoly (nth 0 (- P)) d_gt0.\n  exists a; rewrite eigenvalue_root_min -/P /root -oppr_eq0 -hornerN.\n  rewrite horner_coef size_polyN size_mxminpoly -/d big_ord_recr -def_ad.\n  by rewrite coefN Pd1 mulN1r /= subrr.\ncase/negP; rewrite kermx_eq0 row_free_unit (mx_Schur irrG) ?subr_eq0 //.\n  by rewrite -memmx_cent_envelop -raddfN linearD addmx_sub ?scalar_mx_cent.\nby apply: contraNneq nscalA => ->; exact: scalar_mx_is_scalar.\nQed."
}
{
  "statement": "Lemma subcent1_extraspecial_maximal U x :\n  U \\subset G -> x \\in G :\\: 'C(U) -> maximal 'C_U[x] U.\n",
  "proof": "Proof.\nmove=> sUG /setDP[Gx not_cUx]; apply/maxgroupP; split=> [|H ltHU sCxH].\n  by rewrite /proper subsetIl subsetI subxx sub_cent1.\ncase/andP: ltHU => sHU not_sHU; have sHG := subset_trans sHU sUG.\napply/eqP; rewrite eqEsubset sCxH subsetI sHU /= andbT.\napply: contraR not_sHU => not_sHCx.\nhave maxCx: maximal 'C_G[x] G.\n  rewrite cent1_extraspecial_maximal //; apply: contra not_cUx.\n  by rewrite inE Gx; apply: subsetP (centS sUG) _.\nhave nsCx := p_maximal_normal pG maxCx.\nrewrite -(setIidPl sUG) -(mulg_normal_maximal nsCx maxCx sHG) ?subsetI ?sHG //.\nby rewrite -group_modr //= setIA (setIidPl sUG) mul_subG.\nQed."
}
{
  "statement": "Lemma count_maskP s1 s2 :\n  (forall x, count_mem x s1 <= count_mem x s2) <->\n    exists2 m : bitseq, size m = size s2 & perm_eq s1 (mask m s2).\n",
  "proof": "Proof.\nsplit=> [s1_le|[m _ /permP s1ms2 x]]; last by rewrite s1ms2 leq_count_mask.\nsuff [m mP]: exists m, perm_eq s1 (mask m s2).\n  by have [m' sm' eqm] := resize_mask m s2; exists m'; rewrite -?eqm.\nelim: s2 => [|x s2 IHs]//= in s1 s1_le *.\n  by exists [::]; apply/allP => x _/=; rewrite eqn_leq s1_le.\nhave [y|m s1s2] := IHs (rem x s1); first by rewrite count_mem_rem leq_subLR.\nexists ((x \\in s1) :: m); have [|/rem_id<-//] := boolP (x \\in s1).\nby move/perm_to_rem/permPl->; rewrite perm_cons.\nQed."
}
{
  "statement": "Theorem orthomx_spectral_subproof n {A : 'M[C]_n} : reflect\n  (exists2 sp : 'M_n * 'rV_n,\n                sp.1 \\is unitarymx &\n                A = invmx sp.1 *m diag_mx sp.2 *m sp.1)\n  (A \\is normalmx).\n",
  "proof": "Proof.\napply: (iffP normalmxP); last first.\n  move=> [[/= P D] P_unitary ->].\n  rewrite !trmx_mul !map_mxM !mulmxA invmx_unitary //.\n  rewrite !trmxCK ![_ *m P *m _]mulmxtVK //.\n  by rewrite -[X in X *m P]mulmxA tr_diag_mx map_diag_mx diag_mxC mulmxA.\nmove=> /cotrigonalization2 [P Punitary /andP[]] PA PATC.\nhave Punit := unitarymx_unit Punitary.\nsuff: similar_diag P A.\n  move=> /similar_diagPex[D] PAD; exists (P, D) => //=.\n  by rewrite -conjVmx//; exact/similarLR.\napply/similar_diagPp => // i j; case: ltngtP => // [lt_ij|lt_ji] _.\n  by have /is_trig_mxP-> := PA.\nhave /is_trig_mxP -/(_ j i lt_ji)/eqP := PATC.\nrewrite !conjumx// invmx_unitary// -[P as X in X *m _]trmxCK.\nby rewrite -!map_mxM -!trmx_mul mulmxA 2!mxE conjC_eq0 => /eqP.\nQed."
}
{
  "statement": "Lemma cfDet_mul_lin gT (G : {group gT}) (lambda phi : 'CF(G)) :\n    lambda \\is a linear_char -> phi \\is a character ->\n  cfDet (lambda * phi) = lambda ^+ Num.truncn (phi 1%g) * cfDet phi.\n",
  "proof": "Proof.\ncase/andP=> /char_reprP[[n1 rG1] ->] /= n1_1 /char_reprP[[n2 rG2] ->] /=.\ndo [rewrite !cfRepr1 pnatr_eq1 natrK; move/eqP] in n1_1 *.\nrewrite {n1}n1_1 in rG1 *; rewrite cfRepr_prod cfDetRepr.\napply/cfun_inP=> x Gx; rewrite !cfunE cfDetRepr cfunE Gx !mulrb !trace_mx11.\nrewrite !mxE prod_repr_lin ?mulrb //=; case: _ / (esym _); rewrite detZ.\ncongr (_ * _); case: {rG2}n2 => [|n2]; first by rewrite cfun1E Gx.\nby rewrite expS_cfunE //= cfunE Gx trace_mx11.\nQed."
}
{
  "statement": "Lemma isometry_of_dnorm S tauS :\n    pairwise_orthogonal form1 S -> pairwise_orthogonal form2 tauS ->\n    map normf2 tauS = map normf1 S ->\n  {tau : {linear U1 -> U2} | map tau S = tauS\n                                   & {in <<S>>%VS &, isometry form2 form1 tau}}.\n",
  "proof": "Proof.\nmove=> oS oT eq_nST; have freeS := orthogonal_free oS.\nhave eq_sz: size tauS = size S by have:= congr1 size eq_nST; rewrite !size_map.\nhave [tau defT] := linear_of_free S tauS; rewrite -[S]/(tval (in_tuple S)).\nexists tau => [|u v /coord_span-> /coord_span->]; rewrite ?raddf_sum ?defT //=.\napply: eq_bigr => i _ /=; rewrite !linearZ/= !linear_sumlz; congr (_ * _).\napply: eq_bigr => j _ /=; rewrite linearZ !linearZl; congr (_ * _).\nrewrite -!(nth_map 0 0 tau) ?{}defT //; have [-> | neq_ji] := eqVneq j i.\n  by rewrite /=  -[RHS](nth_map 0 0 normf1) -?[LHS](nth_map 0 0 normf2) ?eq_sz // eq_nST.\nhave{oS} [/=/andP[_ uS] oS] := pairwise_orthogonalP oS.\nhave{oT} [/=/andP[_ uT] oT] := pairwise_orthogonalP oT.\nby rewrite oS ?oT ?mem_nth ?nth_uniq ?eq_sz.\nQed."
}
{
  "statement": "Lemma partition_big I (s : seq I)\n      (J : finType) (P : pred I) (p : I -> J) (Q : pred J) F :\n  (forall i, P i -> Q (p i)) ->\n  \\big[*%M/1]_(i <- s | P i) F i =\n  \\big[*%M/1]_(j : J | Q j) \\big[*%M/1]_(i <- s | (P i) && (p i == j)) F i.\n",
  "proof": "Proof.\nmove=> Qp; transitivity (\\big[*%M/1]_(i <- s | P i && Q (p i)) F i).\n  by apply: eq_bigl => i; case Pi: (P i); rewrite // Qp.\nhave [n leQn] := ubnP #|Q|; elim: n => // n IHn in Q {Qp} leQn *.\ncase: (pickP Q) => [j Qj | Q0]; last first.\n  by rewrite !big_pred0 // => i; rewrite Q0 andbF.\nrewrite (bigD1 j) // -IHn; last by rewrite ltnS (cardD1x Qj) in leQn.\nrewrite (bigID (fun i => p i == j)); congr (_ * _); apply: eq_bigl => i.\n  by case: eqP => [-> | _]; rewrite !(Qj, simpm).\nby rewrite andbA.\nQed."
}
{
  "statement": "Lemma sum_nat_eq1 (I : finType) (P : pred I) (F : I -> nat) :\n  reflect\n    (exists i : I, [/\\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]%N)\n    (\\sum_(i | P i) F i == 1)%N.\n",
  "proof": "Proof.\napply/(iffP idP) => [sumF_eq1 | [i [Pi Fi1 zFj]]]; last first.\n  rewrite (bigD1 i)//= Fi1 addn_eq1//= orbF sum_nat_eq0.\n  by apply/forall_inP => j /andP[Pj ji]; apply/eqP/zFj.\nhave /forall_inPn [i Pi FiN0]: ~~ [forall i in P, F i == 0].\n  by apply: contraTN sumF_eq1 => /'forall_in_eqP F0; rewrite big1.\nmove: sumF_eq1; rewrite (bigD1 i)//= addn_eq1 (negPf FiN0)/= orbF.\nmove=> /andP[/eqP Fi1]; rewrite sum_nat_eq0 => /'forall_in_eqP FNi0.\nby exists i; split; rewrite // => j /[swap] Nij /(conj Nij)/andP/FNi0.\nQed."
}
{
  "statement": "Lemma card_n :\n #|[set x | (coin0 x == coin1 x)&&(coin1 x == coin2 x)&& (coin2 x == coin3 x)]|\n   = n.\n",
  "proof": "Proof.\nrewrite -[n]card_ord /coin0 /coin1 /coin2 /coin3.\npose f (p : col_squares) := p c3; rewrite -(@card_in_image _ _ f).\n  apply: eq_card => c /=; apply/imageP.\n  exists ([ffun => c] : col_squares); last by rewrite /f ffunE.\n  by rewrite /= inE !ffunE !eqxx.\nmove=> p1 p2; rewrite /= !inE /f -!andbA => eqp1 eqp2 eqp12.\napply/eqP; rewrite eqperm_map /= andbT.\ncase/and3P: eqp1; do 3!move/eqP->; case/and3P: eqp2; do 3!move/eqP->.\nby rewrite !andbb eqp12.\nQed."
}
{
  "statement": "Theorem abelian_structure G :\n    abelian G ->\n  {b | \\big[dprod/1]_(x <- b) <[x]> = G & map order b = abelian_type G}.\n",
  "proof": "Proof.\nrewrite /abelian_type genGidG; have [n] := ubnPleq #|G|.\nelim: n G => /= [|n IHn] G leGn cGG; first by rewrite leqNgt cardG_gt0 in leGn.\nrewrite [in _ && _]cGG /=; case: ifP => [ntG|/eqP->]; last first.\n  by exists [::]; rewrite ?big_nil.\ncase: (abelian_type_subproof G) => H /= [//|x ox xdefG]; rewrite -ox.\nhave [_ defG cxH tixH] := dprodP xdefG.\nhave sHG: H \\subset G by rewrite -defG mulG_subr.\ncase/IHn: (abelianS sHG cGG) => [|b defH <-].\n  rewrite -ltnS (leq_trans _ leGn) // -defG TI_cardMg // -orderE.\n  rewrite ltn_Pmull ?cardG_gt0 // ltn_neqAle order_gt0 eq_sym -dvdn1.\n  by rewrite ox -trivg_exponent ntG.\nby exists (x :: b); rewrite // big_cons defH xdefG.\nQed."
}
{
  "statement": "Lemma bigA_distr_big_dep (I J : finType) (Q : I -> pred J) F :\n  \\big[*%M/1]_i \\big[+%M/0]_(j | Q i j) F i j\n    = \\big[+%M/0]_(f in family Q) \\big[*%M/1]_i F i (f i).\n",
  "proof": "Proof.\nhave [j _ | J0] := pickP J; first by rewrite (big_distr_big_dep j).\nhave Q0 i: Q i =i pred0 by move=> /J0/esym/notF[].\ntransitivity (iter #|I| ( *%M 0) 1).\n  by rewrite -big_const; apply/eq_bigr=> i; have /(big_pred0 _)-> := Q0 i.\nhave [i _ | I0] := pickP I.\n  rewrite (cardD1 i) //= mul0m big_pred0 // => f.\n  by apply/familyP=> /(_ i); rewrite Q0.\nhave f: I -> J by move=> /I0/esym/notF[].\nrewrite eq_card0 // (big_pred1 (finfun f)) ?big_pred0 // => g.\nby apply/familyP/eqP=> _; first apply/ffunP; move=> /I0/esym/notF[].\nQed."
}
{
  "statement": "Lemma mxdirect_sum_kermx n (g : 'M_n)\n    (I : finType) (P : {pred I}) (p_ : I -> {poly K}) :\n  {in P &, forall i j, j != i -> coprimep (p_ i) (p_ j)} ->\n  mxdirect (\\sum_(i | P i) kermxpoly g (p_ i))%MS.\n",
  "proof": "Proof.\nmove=> p_coprime; apply/mxdirect_sumsP => i Pi; apply/eqmx0P.\nhave cpNi : {in [pred j | P j && (j != i)] &,\n    forall j k : I, k != j -> coprimep (p_ j) (p_ k)}.\n  by move=> j k /andP[Pj _] /andP[Pk _]; apply: p_coprime.\nrewrite -!(cap_eqmx (eqmx_refl _) (kermxpoly_prod g _))//.\nrewrite mxdirect_kermxpoly ?submx_refl//.\nrewrite (@big_morph _ _ _ true andb) ?big_all_cond ?coprimep1//; last first.\n  by move=> p q; rewrite coprimepMr.\nby apply/allP => j _; apply/implyP => /andP[Pj neq_ji]; apply: p_coprime.\nQed."
}
{
  "statement": "Lemma isometry_of_cfnorm S tauS :\n    pairwise_orthogonal S -> pairwise_orthogonal tauS ->\n    map cfnorm tauS = map cfnorm S ->\n  {tau : {linear 'CF(L) -> 'CF(G)} | map tau S = tauS\n                                   & {in <<S>>%VS &, isometry tau}}.\n",
  "proof": "Proof.\nmove=> oS oT eq_nST; have freeS := orthogonal_free oS.\nhave eq_sz: size tauS = size S by have:= congr1 size eq_nST; rewrite !size_map.\nhave [tau defT] := linear_of_free S tauS; rewrite -[S]/(tval (in_tuple S)).\nexists tau => [|u v /coord_span-> /coord_span->]; rewrite ?raddf_sum ?defT //=.\napply: eq_bigr => i _ /=; rewrite linearZ !cfdotZr !cfdot_suml; congr (_ * _).\napply: eq_bigr => j _ /=; rewrite linearZ !cfdotZl; congr (_ * _).\nrewrite -!(nth_map 0 0 tau) ?{}defT //; have [-> | neq_ji] := eqVneq j i.\n  by rewrite -!['[_]](nth_map 0 0 cfnorm) ?eq_sz // eq_nST.\nhave{oS} [/=/andP[_ uS] oS] := pairwise_orthogonalP oS.\nhave{oT} [/=/andP[_ uT] oT] := pairwise_orthogonalP oT.\nby rewrite oS ?oT ?mem_nth ?nth_uniq ?eq_sz.\nQed."
}
{
  "statement": "Lemma uniq_roots_prod_XsubC p rs :\n    all (root p) rs -> uniq_roots rs ->\n  exists q, p = q * \\prod_(z <- rs) ('X - z%:P).\n",
  "proof": "Proof.\nelim: rs => [|z rs IHrs] /=; first by rewrite big_nil; exists p; rewrite mulr1.\ncase/andP=> rpz rprs /andP[drs urs]; case: IHrs => {urs rprs}// q def_p.\nhave [|q' def_q] := factor_theorem q z _; last first.\n  by exists q'; rewrite big_cons mulrA -def_q.\nrewrite {p}def_p in rpz.\nelim/last_ind: rs drs rpz => [|rs t IHrs] /=; first by rewrite big_nil mulr1.\nrewrite all_rcons => /andP[/andP[/eqP czt Uzt] /IHrs{}IHrs].\nrewrite -cats1 big_cat big_seq1 /= mulrA rootE hornerM_comm; last first.\n  by rewrite /comm_poly hornerXsubC mulrBl mulrBr czt.\nrewrite hornerXsubC -opprB mulrN oppr_eq0 -(mul0r (t - z)).\nby rewrite (inj_eq (mulIr Uzt)) => /IHrs.\nQed."
}
{
  "statement": "Lemma nil_Zgroup_cyclic G : Zgroup G -> nilpotent G -> cyclic G.\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n G => // n IHn G /ltnSE-leGn ZgG nilG.\nhave [->|[p pr_p pG]] := trivgVpdiv G; first by rewrite -cycle1 cycle_cyclic.\nhave /dprodP[_ defG Cpp' _] := nilpotent_pcoreC p nilG.\nhave /cyclicP[x def_p]: cyclic 'O_p(G).\n  have:= forallP ZgG 'O_p(G)%G.\n  by rewrite (p_Sylow (nilpotent_pcore_Hall p nilG)).\nhave /cyclicP[x' def_p']: cyclic 'O_p^'(G).\n  have sp'G := pcore_sub p^' G.\n  apply: IHn (leq_trans _ leGn) (ZgroupS sp'G _) (nilpotentS sp'G _) => //.\n  rewrite proper_card // properEneq sp'G andbT; case: eqP => //= def_p'.\n  by have:= pcore_pgroup p^' G; rewrite def_p' /pgroup p'natE ?pG.\napply/cyclicP; exists (x * x'); rewrite -{}defG def_p def_p' cycleM //.\n  by red; rewrite -(centsP Cpp') // (def_p, def_p') cycle_id.\nby rewrite /order -def_p -def_p' (@pnat_coprime p) //; apply: pcore_pgroup.\nQed."
}
{
  "statement": "Lemma Alt_index : 1 < n -> #|'Sym_T : 'Alt_T| = 2.\n",
  "proof": "Proof.\nmove=> lt1n; rewrite -card_quotient ?Alt_norm //=.\nhave : ('Sym_T / 'Alt_T) \\isog (@odd_perm T @* 'Sym_T) by apply: first_isog.\ncase/isogP=> g /injmP/card_in_imset <-.\nrewrite /morphim setIid=> ->; rewrite -card_bool; apply: eq_card => b.\napply/imsetP; case: b => /=; last first.\n  by exists (1 : {perm T}); [rewrite setIid inE | rewrite odd_perm1].\ncase: (pickP T) lt1n => [x1 _ | d0]; last by rewrite /n eq_card0.\nrewrite /n (cardD1 x1) ltnS lt0n => /existsP[x2 /=].\nby rewrite eq_sym andbT -odd_tperm; exists (tperm x1 x2); rewrite ?inE.\nQed."
}
{
  "statement": "Lemma kermxpoly_prod n (g : 'M_n)\n    (I : finType) (P : {pred I}) (p_ : I -> {poly K}) :\n  {in P &, forall i j, j != i -> coprimep (p_ i) (p_ j)} ->\n  (kermxpoly g (\\prod_(i | P i) p_ i) :=: \\sum_(i | P i) kermxpoly g (p_ i))%MS.\n",
  "proof": "Proof.\nmove=> p_coprime; elim: index_enum (index_enum_uniq I).\n  by rewrite !big_nil ?kermxpoly1 ?submx_refl//.\nmove=> j js ihjs /= /andP[jNjs js_uniq]; apply/eqmxP.\nrewrite !big_cons; case: ifP => [Pj|PNj]; rewrite ?ihjs ?submx_refl//.\nsuff cjjs: coprimep (p_ j) (\\prod_(i <- js | P i) p_ i).\n  by rewrite !kermxpolyM// !(adds_eqmx (eqmx_refl _) (ihjs _)) ?submx_refl.\nrewrite (@big_morph _ _ _ true andb) ?big_all_cond ?coprimep1//; last first.\n  by move=> p q; rewrite coprimepMr.\napply/allP => i i_js; apply/implyP => Pi; apply: p_coprime => //.\nby apply: contraNneq jNjs => <-.\nQed."
}
{
  "statement": "Lemma Aint_gring_mode_class_sum k : 'omega_i['K_k] \\in Aint.\n",
  "proof": "Proof.\nmove: k; pose X := [tuple 'omega_i['K_k] | k < #|classes G| ].\nhave memX k: 'omega_i['K_k] \\in X by apply: image_f.\nhave S_P := Cint_spanP X; set S := Cint_span X in S_P.\nhave S_X: {subset X <= S} by apply: mem_Cint_span.\nhave S_1: 1 \\in S.\n  apply: S_X; apply/codomP; exists (enum_rank_in (classes1 G) 1%g).\n  rewrite (@gring_mode_class_sum_eq _ 1%g) ?enum_rankK_in ?classes1 //.\n  by rewrite mulfK ?irr1_neq0 // class1G cards1.\nsuffices Smul: mulr_closed S.\n  by move=> k; apply: fin_Csubring_Aint S_P _ _; rewrite ?S_X.\nsplit=> // _ _ /S_P[x ->] /S_P[y ->].\nrewrite mulr_sumr rpred_sum // => j _.\nrewrite mulrzAr mulr_suml rpredMz ?rpred_sum // => k _.\nrewrite mulrzAl rpredMz {x y}// !nth_mktuple.\nrewrite -gring_irr_modeM ?gring_class_sum_central //.\nrewrite gring_classM_expansion raddf_sum rpred_sum // => jk _.\nby rewrite scaler_nat raddfMn rpredMn ?S_X ?memX.\nQed."
}
{
  "statement": "Lemma prod_constt x : \\prod_(0 <= p < #[x].+1) x.`_p = x.\n",
  "proof": "Proof.\npose lp n := [pred p | p < n].\nhave: (lp #[x].+1).-elt x by apply/pnatP=> // p _; apply: dvdn_leq.\nmove/constt_p_elt=> def_x; symmetry; rewrite -{1}def_x {def_x}.\nelim: _.+1 => [|p IHp].\n  by rewrite big_nil; apply/constt1P; apply/pgroupP.\nrewrite big_nat_recr //= -{}IHp -(consttC (lp p) x.`__); congr (_ * _).\n  by rewrite sub_in_constt // => q _; apply: leqW.\nset y := _.`__; rewrite -(consttC p y) (constt1P p^' _ _) ?mulg1.\n  by rewrite 2?sub_in_constt // => q _; move/eqnP->; rewrite !inE ?ltnn.\nrewrite /p_elt pnatNK !order_constt -partnI.\napply: sub_in_pnat (part_pnat _ _) => q _.\nby rewrite !inE ltnS -leqNgt -eqn_leq.\nQed."
}
{
  "statement": "Theorem extraspecial_structure S : p.-group S -> extraspecial S ->\n  {Es | all (fun E => (#|E| == p ^ 3)%N && ('Z(E) == 'Z(S))) Es\n      & \\big[cprod/1%g]_(E <- Es) E \\* 'Z(S) = S}.\n",
  "proof": "Proof.\nhave [m] := ubnP #|S|; elim: m S => // m IHm S leSm pS esS.\nhave [x Z'x]: {x | x \\in S :\\: 'Z(S)}.\n  apply/sigW/set0Pn; rewrite -subset0 subDset setU0.\n  apply: contra (extraspecial_nonabelian esS) => sSZ.\n  exact: abelianS sSZ (center_abelian S).\nhave [E [R [[oE oR]]]]:= split1_extraspecial pS esS Z'x.\ncase=> defS _ [defZE defZR] _; case: ifP => [_ defR | _ esR].\n  by exists [:: E]; rewrite /= ?oE ?defZE ?eqxx // big_seq1 -defR.\nhave sRS: R \\subset S by case/cprodP: defS => _ <- _; rewrite mulG_subr.\nhave [|Es esEs defR] := IHm _ _ (pgroupS sRS pS) esR.\n  rewrite oR (leq_trans (ltn_Pdiv _ _)) ?cardG_gt0 // (ltn_exp2l 0) //.\n  exact: prime_gt1 (extraspecial_prime pS esS).\nexists (E :: Es); first by rewrite /= oE defZE !eqxx -defZR.\nby rewrite -defZR big_cons -cprodA defR.\nQed."
}
{
  "statement": "Lemma abelian_type_dprod_homocyclic p K H G :\n    K \\x H = G -> p.-group G -> homocyclic G ->\n     abelian_type K = nseq 'r(K) (exponent G)\n  /\\ abelian_type H = nseq 'r(H) (exponent G).\n",
  "proof": "Proof.\nmove=> defG pG homG; have [cGG _] := andP homG.\nhave /mulG_sub[sKG sHG]: K * H = G by case/dprodP: defG.\nhave [cKK cHH] := (abelianS sKG cGG, abelianS sHG cGG).\nsuffices: all (pred1 (exponent G)) (abelian_type K ++ abelian_type H).\n  rewrite all_cat => /andP[/all_pred1P-> /all_pred1P->].\n  by rewrite !size_abelian_type.\nsuffices def_atG: abelian_type K ++ abelian_type H =i abelian_type G.\n  rewrite (eq_all_r def_atG); apply/all_pred1P.\n  by rewrite size_abelian_type // -abelian_type_homocyclic.\nhave [bK defK atK] := abelian_structure cKK.\nhave [bH defH atH] := abelian_structure cHH.\napply/perm_mem; rewrite perm_sym -atK -atH -map_cat.\napply: (abelian_type_pgroup pG); first by rewrite big_cat defK defH.\nhave: all [pred m | m > 1] (map order (bK ++ bH)).\n  by rewrite map_cat all_cat atK atH !abelian_type_gt1.\nby rewrite all_map (eq_all (@order_gt1 _)) all_predC has_pred1.\nQed."
}
{
  "statement": "Lemma mx_rsim_factmod n (rG : reprG n) U V\n                     (modU : mxmodule rG U) (modV : mxmodule rG V) :\n    (U + V :=: 1%:M)%MS -> mxdirect (U + V) ->\n  mx_rsim (factmod_repr modV) (submod_repr modU).\n",
  "proof": "Proof.\nmove=> addUV dxUV.\nhave eqUV: \\rank U = \\rank (cokermx V).\n  by rewrite mxrank_coker -{3}(mxrank1 F n) -addUV (mxdirectP dxUV) addnK.\nhave{} dxUV: (U :&: V = 0)%MS by apply/mxdirect_addsP.\nexists (in_submod U (val_factmod 1%:M *m proj_mx U V)) => // [|x Gx].\n  rewrite /row_free -{6}eqUV -[_ == _]sub1mx -val_submodS val_submod1.\n  rewrite in_submodK ?proj_mx_sub // -{1}[U](proj_mx_id dxUV) //.\n  rewrite -{1}(add_sub_fact_mod V U) mulmxDl proj_mx_0 ?val_submodP // add0r.\n  by rewrite submxMr // val_factmodS submx1.\nrewrite -in_submodJ ?proj_mx_sub // -(hom_mxP _) //; last first.\n  by apply: submx_trans (submx1 _) _; rewrite -addUV proj_mx_hom.\nrewrite mulmxA; congr (_ *m _); rewrite mulmxA -val_factmodE; apply/eqP.\nrewrite eq_sym -subr_eq0 -mulmxBl proj_mx_0 //.\nby rewrite -[_ *m rG x](add_sub_fact_mod V) addrK val_submodP.\nQed."
}
{
  "statement": "Lemma quantifier_elim_wf f :\n  let qf := quantifier_elim f in rformula f -> qf_form qf && rformula qf.\n",
  "proof": "Proof.\nsuffices aux_wf f0 n : let qf := elim_aux f0 n in\n  rformula f0 -> qf_form qf && rformula qf.\n- by elim: f => //=; do ?[  move=> f1 IH1 f2 IH2;\n                     case/andP=> rf1 rf2;\n                     case/andP:(IH1 rf1)=> -> ->;\n                     case/andP:(IH2 rf2)=> -> -> //\n                  |  move=> n f1 IH rf1;\n                     case/andP: (IH rf1)=> qff rf;\n                     rewrite aux_wf ].\nrewrite /elim_aux => rf.\nsuffices or_wf fs : let ofs := foldr Or False fs in\n  all (@qf_form F) fs && all (@rformula F) fs -> qf_form ofs && rformula ofs.\n- apply: or_wf.\n  suffices map_proj_wf bcs: let mbcs := map (proj n) bcs in\n    all dnf_rterm bcs -> all (@qf_form _) mbcs && all (@rformula _) mbcs.\n    by apply/map_proj_wf/qf_to_dnf_rterm.\n  elim: bcs => [|bc bcs ihb] bcsr //= /andP[rbc rbcs].\n  by rewrite andbAC andbA wf_proj //= andbC ihb.\nelim: fs => //= g gs ihg; rewrite -andbA => /and4P[-> qgs -> rgs] /=.\nby apply: ihg; rewrite qgs rgs.\nQed."
}
{
  "statement": "Lemma generators_2dihedral :\n    n > 1 -> G \\isog 'D_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in #[y] = 2 /\\ x ^ y = x^-1.\n",
  "proof": "Proof.\nmove=> n_gt1; have [def2q _ ltqm _] := def2qr n_gt1.\ncase/(isoGrpP _ (Grp_2dihedral n_gt1)); rewrite card_2dihedral // -/ m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy groupV cycle_id.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave oy: #[y] = 2 by apply: nt_prime_order (group1_contra notXy).\nhave ox: #[x] = q.\n  apply: double_inj; rewrite -muln2 -oy -mul2n def2q -oG -defG TI_cardMg //.\n  by rewrite setIC prime_TIg ?cycle_subG // -orderE oy.\nexists (x, y) => //=.\nby rewrite oG ox !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed."
}
{
  "statement": "Lemma generators_semidihedral :\n    n > 3 -> G \\isog 'SD_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in #[y] = 2 /\\ x ^ y = x ^+ r.-1.\n",
  "proof": "Proof.\nmove=> n_gt3; have [def2q _ ltqm _] := def2qr (ltnW (ltnW n_gt3)).\ncase/(isoGrpP _ (Grp_semidihedral n_gt3)).\nrewrite card_semidihedral // -/m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q -/r => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy mem_cycle.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave oy: #[y] = 2 by apply: nt_prime_order (group1_contra notXy).\nhave ox: #[x] = q.\n  apply: double_inj; rewrite -muln2 -oy -mul2n def2q -oG -defG TI_cardMg //.\n  by rewrite setIC prime_TIg ?cycle_subG // -orderE oy.\nexists (x, y) => //=.\nby rewrite oG ox !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed."
}
{
  "statement": "Lemma lone_subgroup_char G H :\n  H \\subset G -> (forall K, K \\subset G -> K \\isog H -> K \\subset H) ->\n  H \\char G.\n",
  "proof": "Proof.\nmove=> sHG Huniq; apply/charP; split=> // f injf Gf; apply/eqP.\nhave{} injf: {in H &, injective f}.\n  by move/injmP: injf; apply: sub_in2; apply/subsetP.\nhave fH: f @* H = f @: H by rewrite /morphim (setIidPr sHG).\nrewrite eqEcard {2}fH card_in_imset ?{}Huniq //=.\n  by rewrite -{3}Gf morphimS.\nrewrite isog_sym; apply/isogP.\nexists [morphism of restrm sHG f] => //=; first exact/injmP.\nby rewrite morphimEdom fH.\nQed."
}
{
  "statement": "Lemma dim_baseVspace V : \\dim (baseVspace V) = (\\dim V * n)%N.\n",
  "proof": "Proof.\npose bV0 := baseVspace_basis V; set m := \\dim V in bV0 *.\nsuffices /size_basis->: basis_of (baseVspace V) bV0.\n  by rewrite card_prod !card_ord.\nrewrite /basis_of eqxx.\napply/freeP=> s sb0 k; rewrite -(enum_valK k); case/enum_val: k => i j.\nhave free_baseP := freeP (basis_free (vbasisP _)).\nmove: j; apply: (free_baseP _ _ fullv); move: i; apply: (free_baseP _ _ V).\ntransitivity (\\sum_i \\sum_j s (enum_rank (i, j)) *: bV0`_(enum_rank (i, j))).\n  apply: eq_bigr => i _; rewrite scaler_suml; apply: eq_bigr => j _.\n  by rewrite -F0ZEZ nth_image enum_rankK -!tnth_nth.\nrewrite pair_bigA (reindex _ (onW_bij _ (enum_val_bij _))); apply: etrans sb0.\nby apply: eq_bigr => k _; rewrite -{5 6}[k](enum_valK k); case/enum_val: k.\nQed."
}
{
  "statement": "Lemma set_gring_classM_coef (i j k : 'I_#|classes G|) g :\n    g \\in enum_val k ->\n  a i j k = #|gring_classM_coef_set (enum_val i) (enum_val j) g|.\n",
  "proof": "Proof.\nrewrite /a; have /repr_classesP[] := enum_valP k; move: (repr _) => g1 Gg1 ->.\nhave [/imsetP[zi Gzi ->] /imsetP[zj Gzj ->]] := (enum_valP i, enum_valP j).\nmove=> g1Gg; have Gg := subsetP (class_subG Gg1 (subxx _)) _ g1Gg.\nset Aij := gring_classM_coef_set _ _.\nwithout loss suffices IH: g g1 Gg Gg1 g1Gg / (#|Aij g1| <= #|Aij g|)%N.\n  by apply/eqP; rewrite eqn_leq !IH // class_sym.\nhave [w Gw Dg] := imsetP g1Gg; pose J2 (v : gT) xy := (xy.1 ^ v, xy.2 ^ v)%g.\nhave J2inj: injective (J2 w).\n  by apply: can_inj (J2 w^-1)%g _ => [[x y]]; rewrite /J2 /= !conjgK.\nrewrite -(card_imset _ J2inj) subset_leq_card //; apply/subsetP.\nmove=> _ /imsetP[[x y] /setIdP[/andP[/= x1Gx y1Gy] Dxy1] ->] /[!inE]/=.\nrewrite !(class_sym _ (_ ^ _)) !classGidl // class_sym x1Gx class_sym y1Gy.\nby rewrite -conjMg (eqP Dxy1) /= -Dg.\nQed."
}
{
  "statement": "Lemma all_iffLR P0 Ps : all_iff P0 Ps ->\n  forall m n, nth P0 (P0 :: Ps) m -> nth P0 (P0 :: Ps) n.\n",
  "proof": "Proof.\nmove=> iffPs; have PsS n: nth P0 Ps n -> nth P0 Ps n.+1.\n  elim: n P0 Ps iffPs => [|n IHn] P0 [|P [|Q Ps]] //= [iP0P] //; first by case.\n    by rewrite nth_nil.\n  by case=> iPQ iffPs; apply: IHn; split=> // /iP0P.\nhave{PsS} lePs: {homo nth P0 Ps : m n / m <= n >-> (m -> n)}.\n  by move=> m n /subnK<-; elim: {n}(n - m) => // n IHn /IHn; apply: PsS.\nmove=> m n P_m; have{m P_m} hP0: P0.\n  case: m P_m => //= m /(lePs m _ (leq_maxl m (size Ps))).\n  by rewrite nth_default ?leq_maxr.\ncase: n =>// n; apply: lePs 0 n (leq0n n) _.\nby case: Ps iffPs hP0 => // P Ps [].\nQed."
}
{
  "statement": "Lemma rabstrX (i : nat) (t : tF) : rterm t -> rpoly (abstrX i t).\n",
  "proof": "Proof.\nelim: t; do ?[ by move=> * //=; do ?case: (_ == _)].\n- move=> t irt s irs /=; case/andP=> rt rs.\n  by apply: rsumpT; rewrite ?irt ?irs //.\n- by move=> t irt /= rt; rewrite rpoly_map_mul ?irt //.\n- by move=> t irt /= n rt; rewrite rpoly_map_mul ?irt //.\n- move=> t irt s irs /=; case/andP=> rt rs.\n  by apply: rmulpT; rewrite ?irt ?irs //.\n- move=> t irt /= n rt; move: (irt rt) => {}rt; elim: n => [|n ihn] //=.\n  exact: rmulpT.\nQed."
}
{
  "statement": "Lemma leif_pM x1 x2 y1 y2 C1 C2 :\n    0 <= x1 -> 0 <= x2 -> x1 <= y1 ?= iff C1 -> x2 <= y2 ?= iff C2 ->\n  x1 * x2 <= y1 * y2 ?= iff (y1 * y2 == 0) || C1 && C2.\n",
  "proof": "Proof.\nmove=> x1_ge0 x2_ge0 le_xy1 le_xy2; have [y_0 | ] := eqVneq _ 0.\n  apply/leifP; rewrite y_0 /= mulf_eq0 !eq_le x1_ge0 x2_ge0 !andbT.\n  move/eqP: y_0; rewrite mulf_eq0.\n  by case/pred2P=> <-; rewrite (le_xy1, le_xy2) ?orbT.\nrewrite /= mulf_eq0 => /norP[y1nz y2nz].\nhave y1_gt0: 0 < y1 by rewrite lt_def y1nz (le_trans _ le_xy1).\nhave [x2_0 | x2nz] := eqVneq x2 0.\n  apply/leifP; rewrite -le_xy2 x2_0 eq_sym (negPf y2nz) andbF mulr0.\n  by rewrite mulr_gt0 // lt_def y2nz -x2_0 le_xy2.\nhave:= le_xy2; rewrite -[X in X -> _](mono_leif (ler_pM2l y1_gt0)).\nby apply: leif_trans; rewrite (mono_leif (ler_pM2r _)) // lt_def x2nz.\nQed."
}
{
  "statement": "Lemma constt_charP (i : Iirr G) chi :\n    chi \\is a character ->\n  reflect (exists2 chi', chi' \\is a character & chi = 'chi_i + chi')\n          (i \\in irr_constt chi).\n",
  "proof": "Proof.\nmove=> Nchi; apply: (iffP idP) => [i_in_chi| [chi' Nchi' ->]]; last first.\n  rewrite inE /= cfdotDl cfdot_irr eqxx -(eqP (Cnat_cfdot_char_irr i Nchi')).\n  by rewrite -natrD pnatr_eq0.\nexists (chi - 'chi_i); last by rewrite addrC subrK.\napply/forallP=> j; rewrite coord_cfdot cfdotBl cfdot_irr.\nhave [<- | _] := eqP; last by rewrite subr0 Cnat_cfdot_char_irr.\nmove: i_in_chi; rewrite inE; case/natrP: (Cnat_cfdot_char_irr i Nchi) => n ->.\nby rewrite pnatr_eq0 -lt0n => /natrB <-; apply: rpred_nat.\nQed."
}
{
  "statement": "Lemma orthogonal_split S beta :\n  {X : 'CF(G) & X \\in <<S>>%VS &\n      {Y | [/\\ beta = X + Y, '[X, Y] = 0 & orthogonal Y S]}}.\n",
  "proof": "Proof.\nsuffices [X S_X [Y -> oYS]]:\n  {X : _ & X \\in <<S>>%VS & {Y | beta = X + Y & orthogonal Y S}}.\n- exists X => //; exists Y.\n  by rewrite cfdotC (span_orthogonal oYS) ?memv_span1 ?conjC0.\nelim: S beta => [|phi S IHS] beta.\n  by exists 0; last exists beta; rewrite ?mem0v ?add0r.\nhave [[U S_U [V -> oVS]] [X S_X [Y -> oYS]]] := (IHS phi, IHS beta).\npose Z := '[Y, V] / '[V] *: V; exists (X + Z).\n  rewrite /Z -{4}(addKr U V) scalerDr scalerN addrA addrC span_cons.\n  by rewrite memv_add ?memvB ?memvZ ?memv_line.\nexists (Y - Z); first by rewrite addrCA !addrA addrK addrC.\napply/orthoPl=> psi /[!inE] /predU1P[-> | Spsi]; last first.\n  by rewrite cfdotBl cfdotZl (orthoPl oVS _ Spsi) mulr0 subr0 (orthoPl oYS).\nrewrite cfdotBl !cfdotDr (span_orthogonal oYS) // ?memv_span ?mem_head //.\nrewrite !cfdotZl (span_orthogonal oVS _ S_U) ?mulr0 ?memv_span ?mem_head //.\nhave [-> | nzV] := eqVneq V 0; first by rewrite cfdot0r !mul0r subrr.\nby rewrite divfK ?cfnorm_eq0 ?subrr.\nQed."
}
{
  "statement": "Lemma nilpotent_class G : nilpotent G = (nil_class G < #|G|).\n",
  "proof": "Proof.\nrewrite /nil_class; set s := mkseq _ _.\ntransitivity (1 \\in s); last by rewrite -index_mem size_mkseq.\napply/idP/mapP=> {s}/= [nilG | [n _ Ln1]]; last first.\n  apply/forall_inP=> H /subsetIP[sHG sHR].\n  rewrite -subG1 {}Ln1; elim: n => // n IHn.\n  by rewrite (subset_trans sHR) ?commSg.\npose m := #|G|.-1; exists m; first by rewrite mem_iota /= prednK.\nset n := m; rewrite ['L__(G)]card_le1_trivg //= -(subnn m) -[m in _ - m]/n.\nelim: n => [|n]; [by rewrite subn0 prednK | rewrite lcnSn subnS].\ncase: (eqsVneq 'L_n.+1(G) 1) => [-> | ntLn]; first by rewrite comm1G cards1.\ncase: (m - n) => [|m' /= IHn]; first by rewrite leqNgt cardG_gt1 ntLn.\nrewrite -ltnS (leq_trans (proper_card _) IHn) //.\nby rewrite (nil_comm_properl nilG) ?lcn_sub // subsetI subxx lcn_norm.\nQed."
}
{
  "statement": "Lemma subSocle_iso M :\n  mxsimple M -> (M <= S)%MS -> {W : sG | P W & mx_iso (socle_base W) M}.\n",
  "proof": "Proof.\nmove=> simM sMS; have [modM nzM _] := simM.\nhave [V /= modV defMV] := mxsemisimple_reducible ssimS modM sMS.\nmove/mxdirect_addsP=> dxMV; pose p := proj_mx M V; pose Sp (W : sG) := W *m p.\ncase: (pickP [pred i | P i & Sp i != 0]) => [/= W | Sp0]; last first.\n  case/negP: nzM; rewrite -submx0 -[M](proj_mx_id dxMV) //.\n  rewrite (submx_trans (submxMr _ sMS)) // sumsmxMr big1 // => W P_W.\n  by apply/eqP; move/negbT: (Sp0 W); rewrite /= P_W negbK.\nrewrite {}/Sp /= => /andP[P_W nzSp]; exists W => //.\nhave homWp: (W <= dom_hom_mx p)%MS.\n  apply: submx_trans (proj_mx_hom dxMV modM modV).\n  by rewrite defMV (sumsmx_sup W).\nhave simWP := socle_simple W; apply: hom_component_mx_iso (homWp) _ => //.\nby rewrite (mx_Schur_onto _ simM) ?proj_mx_sub ?component_mx_module.\nQed."
}
{
  "statement": "Lemma Exists_rowP e k f :\n  d > 0 ->\n   ((exists v : 'rV[F]_d, holds (row_env (set_nth 0 e k v)) f)\n      <-> holds (row_env e) (Exists_row_form k f)).\n",
  "proof": "Proof.\nmove=> d_gt0; pose i_ j := Ordinal (ltn_pmod j d_gt0).\nhave d_eq j: (j = j %/ d * d + i_ j)%N := divn_eq j d.\nsplit=> [[v f_v] | ]; last case/GRing.foldExistsP=> e' ee' f_e'.\n  apply/GRing.foldExistsP; exists (row_env (set_nth 0 e k v)) => {f f_v}// j.\n  rewrite [j]d_eq !nth_row_env nth_set_nth /=; case: eqP => // ->.\n  by case/imageP; exists (i_ j).\nexists (\\row_i e'`_(k * d + i)); apply: eq_holds f_e' => j /=.\nmove/(_ j): ee'; rewrite [j]d_eq !nth_row_env nth_set_nth /=.\ncase: eqP => [-> | ne_j_k -> //]; first by rewrite mxE.\napply/mapP=> [[r lt_r_d]]; rewrite -d_eq => def_j; case: ne_j_k.\nby rewrite def_j divnMDl // divn_small ?addn0.\nQed."
}
{
  "statement": "Lemma Sym_trans : [transitive^n 'Sym_T, on setT | 'P].\n",
  "proof": "Proof.\napply/imsetP; pose t1 := [tuple of enum T].\nhave dt1: t1 \\in n.-dtuple(setT) by rewrite inE enum_uniq; apply/subsetP.\nexists t1 => //; apply/setP=> t; apply/idP/imsetP=> [|[a _ ->{t}]]; last first.\n  by apply: n_act_dtuple => //; apply/astabsP=> x; rewrite !inE.\ncase/dtuple_onP=> injt _; have injf := inj_comp injt enum_rank_inj.\nexists (perm injf); first by rewrite inE.\napply: eq_from_tnth => i; rewrite tnth_map /= [aperm _ _]permE; congr tnth.\nby rewrite (tnth_nth (enum_default i)) enum_valK.\nQed."
}
{
  "statement": "Lemma bound_leEmeet b1 b2 : (b1 <= b2) = (bound_meet b1 b2 == b1).\n",
  "proof": "Proof.\ncase: b1 b2 => [[]t[][]|[][][]] //=; rewrite ?eqxx// => t';\n  rewrite [LHS]/<=%O /eq_op ?andbT ?andbF ?orbF/= /eq_op/= /eq_op/=;\n  case: lcomparableP => //=; rewrite ?eqxx//=; [| | |].\n- by move/lt_eqF.\n- move=> ic; apply: esym; apply: contraNF ic.\n  by move=> /eqP/meet_idPl; apply: le_comparable.\n- by move/lt_eqF.\n- move=> ic; apply: esym; apply: contraNF ic.\n  by move=> /eqP/meet_idPl; apply: le_comparable.\nQed."
}
{
  "statement": "Lemma algebraic_inv u : algebraicOver FtoE u -> algebraicOver FtoE u^-1.\n",
  "proof": "Proof.\nhave [-> | /expf_neq0 nz_u_n] := eqVneq u 0; first by rewrite invr0.\ncase=> p nz_p pu0; exists (Poly (rev p)).\n  apply/eqP=> /polyP/(_ 0); rewrite coef_Poly coef0 nth_rev ?size_poly_gt0 //.\n  by apply/eqP; rewrite subn1 lead_coef_eq0.\napply/eqP/(mulfI (nz_u_n (size p).-1)); rewrite mulr0 -(rootP pu0).\nrewrite (@horner_coef_wide _ (size p)); last first.\n  by rewrite size_map_poly -(size_rev p) size_Poly.\nrewrite horner_coef mulr_sumr size_map_poly.\nrewrite [rhs in _ = rhs](reindex_inj rev_ord_inj) /=.\napply: eq_bigr => i _; rewrite !coef_map coef_Poly nth_rev // mulrCA.\nby congr (_ * _); rewrite -{1}(subnKC (valP i)) addSn addnC exprD exprVn ?mulfK.\nQed."
}
{
  "statement": "Lemma diagonalizable_for_sum (F : fieldType) (m n : nat) (p_ : 'I_n -> nat)\n      (V_ : forall i, 'M[F]_(p_ i, m)) (A : 'M[F]_m) :\n    mxdirect (\\sum_i <<V_ i>>) ->\n    (forall i, stablemx (V_ i) A) ->\n    (forall i, row_free (V_ i)) ->\n  diagonalizable_for (\\mxcol_i V_ i) A = [forall i, diagonalizable_for (V_ i) A].\n",
  "proof": "Proof.\nmove=> Vd VA rAV; have aVA : stablemx (\\mxcol_i V_ i) A.\n  rewrite (eqmx_stable _ (eqmx_col _)) stablemx_sums//.\n  by move=> i; rewrite (eqmx_stable _ (genmxE _)).\napply/diagonalizable_forPex/'forall_diagonalizable_forPex => /=\n    [[D /(simmxPp aVA) +] i|/(_ _)/sigW DoA].\n  rewrite mxcol_mul -[D]submxrowK diag_mxrow mul_mxdiag_mxcol.\n  move=> /eq_mxcolP/(_ i); set D0 := (submxrow _ _) => VMeq.\n  by exists D0; apply/simmxW.\nexists (\\mxrow_i tag (DoA i)); apply/simmxW.\n   rewrite -row_leq_rank eqmx_col (mxdirectP Vd)/=.\n   by under [leqRHS]eq_bigr do rewrite genmxE (eqP (rAV _)).\nrewrite mxcol_mul diag_mxrow mul_mxdiag_mxcol; apply: eq_mxcol => i.\nby case: DoA => /= k /(simmxPp); rewrite VA => /(_ isT) ->.\nQed."
}
{
  "statement": "Lemma prim_order_exists n z :\n  n > 0 -> z ^+ n = 1 -> {m | m.-primitive_root z & (m %| n)}.\n",
  "proof": "Proof.\nmove=> n_gt0 zn1.\nhave: exists m, (m > 0) && (z ^+ m == 1) by exists n; rewrite n_gt0 /= zn1.\ncase/ex_minnP=> m /andP[m_gt0 /eqP zm1] m_min.\nexists m.\n  apply/andP; split=> //; apply/eqfunP=> [[i]] /=.\n  rewrite leq_eqVlt unity_rootE.\n  case: eqP => [-> _ | _]; first by rewrite zm1 eqxx.\n  by apply: contraTF => zi1; rewrite -leqNgt m_min.\nhave: n %% m < m by rewrite ltn_mod.\napply: contraLR; rewrite -lt0n -leqNgt => nm_gt0; apply: m_min.\nby rewrite nm_gt0 /= expr_mod ?zn1.\nQed."
}
{
  "statement": "Lemma Grp_ext_dihedral : ED \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x^-1).\n",
  "proof": "Proof.\nsuffices isoED: ED \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ q.-1).\n  move=> gT G; rewrite isoED.\n  apply: eq_existsb => [[x y]] /=; rewrite !xpair_eqE.\n  congr (_ && _); apply: andb_id2l; move/eqP=> xq1; congr (_ && (_ == _)).\n  by apply/eqP; rewrite eq_sym eq_invg_mul -expgS (ltn_predK q_gt1) xq1.\nhave unitrN1 : (- 1)%R \\in GRing.unit by move=> R; rewrite unitrN unitr1.\npose uN1 := FinRing.unit ('Z_#[Zp1 : 'Z_q]) (unitrN1 _).\napply: Extremal.Grp => //; exists (Zp_unitm uN1).\nrewrite Aut_aut order_injm ?injm_Zp_unitm ?in_setT //; split=> //.\n  by rewrite (dvdn_trans _ even_p) // order_dvdn -val_eqE /= mulrNN.\napply/eqP; rewrite autE ?cycle_id // eq_expg_mod_order /=.\nby rewrite order_Zp1 !Zp_cast // !modn_mod (modn_small q_gt1) subn1.\nQed."
}
{
  "statement": "Lemma classg_base_free : row_free classg_base.\n",
  "proof": "Proof.\nrewrite -kermx_eq0; apply/rowV0P=> v /sub_kermxP; rewrite mulmx_sum_row => v0.\napply/rowP=> k /[1!mxE].\nhave [x Gx def_k] := imsetP (enum_valP k).\ntransitivity (@gring_proj F _ G x (vec_mx 0) 0 0); last first.\n  by rewrite !linear0 !mxE.\nrewrite -{}v0 !linear_sum (bigD1 k) //= 2!linearZ /= rowK mxvecK def_k.\nrewrite linear_sum (bigD1 x) ?class_refl //= gring_projE // eqxx.\nrewrite !big1 ?addr0 ?mxE ?mulr1 // => [k' | y /andP[xGy ne_yx]]; first 1 last.\n  by rewrite gring_projE ?(groupCl Gx xGy) // eq_sym (negPf ne_yx).\nrewrite rowK 2!linearZ /= mxvecK -(inj_eq enum_val_inj) def_k eq_sym.\nhave [z Gz ->] := imsetP (enum_valP k').\nmove/eqP=> not_Gxz; rewrite linear_sum big1 ?scaler0 //= => y zGy.\nrewrite gring_projE ?(groupCl Gz zGy) //.\nby case: eqP zGy => // <- /class_eqP.\nQed."
}
{
  "statement": "Lemma intro_adjunction (h' : forall x, x \\in a -> T') :\n   (forall x a_x,\n      [/\\ connect e x (h (h' x a_x))\n        & forall y a_y, e x y -> connect e' (h' x a_x) (h' y a_y)]) ->\n   (forall x' a_x,\n      [/\\ connect e' x' (h' (h x') a_x)\n        & forall y', e' x' y' -> connect e (h x') (h y')]) ->\n  rel_adjunction.\n",
  "proof": "Proof.\nmove=> Aee' Ae'e; split=> [y a_y | x' z' a_x].\n  by exists (h' y a_y); case/Aee': (a_y).\napply/idP/idP=> [/connectP[p e'p ->{z'}] | /connectP[p e_p p_z']].\n  elim: p x' a_x e'p => //= y' p IHp x' a_x.\n  case: (Ae'e x' a_x) => _ Ae'x /andP[/Ae'x e_xy /IHp e_yz] {Ae'x}.\n  by apply: connect_trans (e_yz _); rewrite // -(closed_connect cl_a e_xy).\ncase: (Ae'e x' a_x) => /connect_trans-> //.\nelim: p {x'}(h x') p_z' a_x e_p => /= [|y p IHp] x p_z' a_x.\n  by rewrite -p_z' in a_x *; case: (Ae'e _ a_x); rewrite sym_e'.\ncase/andP=> e_xy /(IHp _ p_z') e'yz; have a_y: y \\in a by rewrite -(cl_a e_xy).\nby apply: connect_trans (e'yz a_y); case: (Aee' _ a_x) => _ ->.\nQed."
}
{
  "statement": "Lemma partition_partition (T : finType) (D : {set T}) P Q :\n    partition P D -> partition Q P ->\n  partition (cover @: Q) D /\\ {in Q &, injective cover}.\n",
  "proof": "Proof.\nmove=> /and3P[/eqP defG tiP notP0] /and3P[/eqP defP tiQ notQ0].\nhave sQP E: E \\in Q -> {subset E <= P}.\n  by move=> Q_E; apply/subsetP; rewrite -defP (bigcup_max E).\nrewrite /partition cover_imset -(big_trivIset _ tiQ) defP -defG eqxx /= andbC.\nhave{} notQ0: set0 \\notin cover @: Q.\n  apply: contra notP0 => /imsetP[E Q_E E0].\n  have /set0Pn[/= A E_A] := memPn notQ0 E Q_E.\n  congr (_ \\in P): (sQP E Q_E A E_A).\n  by apply/eqP; rewrite -subset0 E0 (bigcup_max A).\nrewrite notQ0; apply: trivIimset => // E F Q_E Q_F.\napply: contraR => /pred0Pn[x /andP[/bigcupP[A E_A Ax] /bigcupP[B F_B Bx]]].\nrewrite -(def_pblock tiQ Q_E E_A) -(def_pblock tiP _ Ax) ?(sQP E) //.\nby rewrite -(def_pblock tiQ Q_F F_B) -(def_pblock tiP _ Bx) ?(sQP F).\nQed."
}
{
  "statement": "Lemma edivpP m d : edivp_spec m d (edivp m d) (lead_coef d \\in GRing.unit).\n",
  "proof": "Proof.\nhave hC : GRing.comm d (lead_coef d)%:P by rewrite /GRing.comm mulrC.\ncase ud: (lead_coef d \\in GRing.unit); last first.\n  rewrite edivp_redivp // redivp_def; constructor; rewrite ?ltn_rmodp // ?ud //.\n  by rewrite rdivp_eq.\nhave cdn0: lead_coef d != 0 by apply: contraTneq ud => ->; rewrite unitr0.\nrewrite unlock ud redivp_def; constructor => //.\n  rewrite -scalerAl -scalerDr -mul_polyC.\n  have hn0 : (lead_coef d ^+ rscalp m d)%:P != 0.\n    by rewrite polyC_eq0; apply: expf_neq0.\n  apply: (mulfI hn0); rewrite !mulrA -exprVn !polyC_exp -exprMn -polyCM.\n  by rewrite divrr // expr1n mul1r -polyC_exp mul_polyC rdivp_eq.\nmove=> dn0; rewrite size_scale ?ltn_rmodp // -exprVn expf_eq0 negb_and.\nby rewrite invr_eq0 cdn0 orbT.\nQed."
}
{
  "statement": "Lemma similar_diag_sum (F : fieldType) (m n : nat) (p_ : 'I_n -> nat)\n      (V_ : forall i, 'M[F]_(p_ i, m)) (f : 'M[F]_m) :\n    mxdirect (\\sum_i <<V_ i>>) ->\n    (forall i, stablemx (V_ i) f) ->\n    (forall i, row_free (V_ i)) ->\n  similar_diag (\\mxcol_i V_ i) f = [forall i, similar_diag (V_ i) f].\n",
  "proof": "Proof.\nmove=> Vd Vf rfV; have aVf : stablemx (\\mxcol_i V_ i) f.\n  rewrite (eqmx_stable _ (eqmx_col _)) stablemx_sums//.\n  by move=> i; rewrite (eqmx_stable _ (genmxE _)).\napply/similar_diagPex/'forall_similar_diagPex => /=\n    [[D /(similarPp aVf) +] i|/(_ _)/sigW Dof].\n  rewrite mxcol_mul -[D]submxrowK diag_mxrow mul_mxdiag_mxcol.\n  move=> /eq_mxcolP/(_ i); set D0 := (submxrow _ _) => VMeq.\n  by exists D0; apply/similarW.\nexists (\\mxrow_i tag (Dof i)); apply/similarW.\n   rewrite -row_leq_rank eqmx_col (mxdirectP Vd)/=.\n   by under [X in (_ <= X)%N]eq_bigr do rewrite genmxE (eqP (rfV _)).\nrewrite mxcol_mul diag_mxrow mul_mxdiag_mxcol; apply: eq_mxcol => i.\nby case: Dof => /= k /(similarPp); rewrite Vf => /(_ isT) ->.\nQed."
}
{
  "statement": "Lemma itv_total_join3E i1 i2 i3 :\n  i1 `|` i2 `|` i3 \\in [:: i1 `|` i2; i1 `|` i3; i2 `|` i3].\n",
  "proof": "Proof.\ncase: i1 i2 i3 => [b1l b1r] [b2l b2r] [b3l b3r]; rewrite !inE /eq_op /=.\ncase: (leP b1l b2l); case: (leP b1l b3l); case: (leP b2l b3l);\n  case: (leP b1r b2r); case: (leP b1r b3r); case: (leP b2r b3r);\n  rewrite ?eqxx ?orbT //= => b23r b13r b12r b23l b13l b12l.\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\nQed."
}
{
  "statement": "Lemma itv_total_meet3E i1 i2 i3 :\n  i1 `&` i2 `&` i3 \\in [:: i1 `&` i2; i1 `&` i3; i2 `&` i3].\n",
  "proof": "Proof.\ncase: i1 i2 i3 => [b1l b1r] [b2l b2r] [b3l b3r]; rewrite !inE /eq_op /=.\ncase: (leP b1l b2l); case: (leP b1l b3l); case: (leP b2l b3l);\n  case: (leP b1r b2r); case: (leP b1r b3r); case: (leP b2r b3r);\n  rewrite ?eqxx ?orbT //= => b23r b13r b12r b23l b13l b12l.\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13l (le_trans b12l b23l).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13r (le_trans b12r b23r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13l (lt_trans b23l b12l).\n- by case: leP b13r (lt_trans b23r b12r).\n- by case: leP b13r (lt_trans b23r b12r).\nQed."
}
{
  "statement": "Lemma dec_factor_theorem (p : {poly F}) :\n  {s : seq F & {q : {poly F} | p = q * \\prod_(x <- s) ('X - x%:P)\n                             /\\ (q != 0 -> forall x, ~~ root q x)}}.\n",
  "proof": "Proof.\npose polyT (p : seq F) := (foldr (fun c f => f * 'X_0 + c%:T) (0%R)%:T p)%T.\nhave eval_polyT (q : {poly F}) x : GRing.eval [:: x] (polyT q) = q.[x].\n  by rewrite /horner; elim: (val q) => //= ? ? ->.\nhave [n] := ubnP (size p); elim: n => // n IHn in p *.\nhave /decPcases /= := @satP F [::] ('exists 'X_0, polyT p == 0%T).\ncase: ifP => [_ /sig_eqW[x]|_ noroot]; last first.\n  exists [::], p; rewrite big_nil mulr1; split => // p_neq0 x.\n  by apply/negP=> /rootP rpx; apply: noroot; exists x; rewrite eval_polyT.\nrewrite eval_polyT => /rootP/factor_theorem/sig_eqW[p1 ->].\nhave [->|nz_p1] := eqVneq p1 0; first by exists [::], 0; rewrite !mul0r eqxx.\nrewrite size_Mmonic ?monicXsubC // size_XsubC addn2 => /IHn[s [q [-> irr_q]]].\nby exists (rcons s x), q; rewrite -cats1 big_cat big_seq1 mulrA.\nQed."
}
{
  "statement": "Lemma has_prim_root_subproof (F : fieldType) (n : nat) (rs : seq F)\n    (n_gt0 : n > 0)\n    (rsn1 : all n.-unity_root rs)\n    (Urs : uniq rs)\n    (sz_rs : size rs = n)\n    (r := fun s => val (s : seq_sub rs))\n    (rn1 : forall x : seq_sub rs, r x ^+ n = 1)\n    (prim_r : forall z : F, z ^+ n = 1 -> z \\in rs)\n    (r' := (fun s (e : s ^+ n = 1) => {| ssval := s; ssvalP := prim_r s e |})\n       : forall s : F, s ^+ n = 1 -> seq_sub rs)\n    (sG_1 := r' 1 (expr1n F n) : seq_sub rs)\n    (sG_VP : forall s : seq_sub rs, r s ^+ n.-1 ^+ n = 1)\n    (sG_MP : forall s s0 : seq_sub rs, (r s * r s0) ^+ n = 1)\n    (sG_V := (fun s : seq_sub rs => r' (r s ^+ n.-1) (sG_VP s))\n       : seq_sub rs -> seq_sub rs)\n    (sG_M := (fun s s0 : seq_sub rs => r' (r s * r s0) (sG_MP s s0))\n       : seq_sub rs -> seq_sub rs -> seq_sub rs)\n    (sG_Ag : associative sG_M)\n    (sG_1g : left_id sG_1 sG_M)\n    (sG_Vg : left_inverse sG_1 sG_V sG_M) :\n  has n.-primitive_root rs.\n",
  "proof": "Proof.\npose ssMG : isMulGroup (seq_sub rs) := isMulGroup.Build (seq_sub rs) sG_Ag sG_1g sG_Vg.\npose gT : finGroupType := HB.pack (seq_sub rs) ssMG.\nhave /cyclicP[x gen_x]: @cyclic gT setT.\n  apply: (@field_mul_group_cyclic gT [set: _] F r) => // x _.\n  by split=> [ri1 | ->]; first apply: val_inj.\napply/hasP; exists (r x); first exact: (valP x).\nhave [m prim_x dvdmn] := prim_order_exists n_gt0 (rn1 x).\nrewrite -((m =P n) _) // eqn_dvd {}dvdmn -sz_rs -(card_seq_sub Urs) -cardsT.\nrewrite gen_x (@order_dvdn gT) /(_ == _) /= -{prim_x}(prim_expr_order prim_x).\nby apply/eqP; elim: m => //= m IHm; rewrite exprS expgS /= -IHm.\nQed."
}
{
  "statement": "Lemma adjunction_n_comp :\n  rel_adjunction -> n_comp e a = n_comp e' [preim h of a].\n",
  "proof": "Proof.\ncase=> Aee' Ae'e.\nhave inj_h: {in predI (roots e') [preim h of a] &, injective (root e \\o h)}.\n  move=> x' y' /andP[/eqP r_x' /= a_x'] /andP[/eqP r_y' _] /(rootP sym_e).\n  by rewrite -Ae'e // => /(rootP sym_e'); rewrite r_x' r_y'.\nrewrite /n_comp_mem -(card_in_image inj_h); apply: eq_card => x.\napply/andP/imageP=> [[/eqP rx a_x] | [x' /andP[/eqP r_x' a_x'] ->]]; last first.\n  by rewrite /= -(ccl_a (connect_root _ _)) roots_root.\nhave [y' e_xy]:= Aee' x a_x; pose x' := root e' y'.\nhave ay': h y' \\in a by rewrite -(ccl_a e_xy).\nhave e_yx: connect e (h y') (h x') by rewrite -Ae'e ?connect_root.\nexists x'; first by rewrite inE /= -(ccl_a e_yx) ?roots_root.\nby rewrite /= -(rootP sym_e e_yx) -(rootP sym_e e_xy).\nQed."
}
{
  "statement": "Lemma coef_prod_XsubC (ps : seq R) (n : nat) :\n  (n <= size ps)%N ->\n  (\\prod_(p <- ps) ('X - p%:P))`_n =\n  (-1) ^+ (size ps - n)%N *\n    \\sum_(I in {set 'I_(size ps)} | #|I| == (size ps - n)%N)\n        \\prod_(i in I) ps`_i.\n",
  "proof": "Proof.\nmove=> nle.\nunder eq_bigr => i _ do rewrite addrC -raddfN/=.\nrewrite -{1}(in_tupleE ps) -(map_tnth_enum (_ ps)) big_map.\nrewrite enumT bigA_distr /= coef_sum.\ntransitivity (\\sum_(I in {set 'I_(size ps)}) if #|I| == (size ps - n)%N then\n                  \\prod_(i < size ps | i \\in I) - ps`_i else 0).\n  apply eq_bigr => I _.\n  rewrite big_if/= big_const iter_mulr_1 -rmorph_prod/= coefCM coefXn.\n  under eq_bigr => i _ do rewrite (tnth_nth 0)/=.\n  rewrite -[#|I| == _](eqn_add2r n) subnK//.\n  rewrite -[X in (_ + _)%N == X]card_ord -(cardC I) eqn_add2l.\n  by case: ifP; rewrite ?mulr1 ?mulr0.\nby rewrite -big_mkcond mulr_sumr/=; apply: eq_bigr => I /eqP <-; rewrite prodrN.\nQed."
}
{
  "statement": "Lemma uniq_min_size s1 s2 :\n    uniq s1 -> {subset s1 <= s2} -> size s2 <= size s1 ->\n  (size s1 = size s2) * (s1 =i s2).\n",
  "proof": "Proof.\nmove=> Us1 ss12 le_s21; have Us2: uniq s2 := leq_size_uniq Us1 ss12 le_s21.\nsuffices: s1 =i s2 by split; first by apply/eqP; rewrite -uniq_size_uniq.\nmove=> x; apply/idP/idP=> [/ss12// | s2x]; apply: contraLR le_s21 => not_s1x.\nrewrite -ltnNge (@uniq_leq_size (x :: s1)) /= ?not_s1x //.\nby apply/allP; rewrite /= s2x; apply/allP.\nQed."
}
{
  "statement": "Lemma card_uniq_tuples T n (A : pred T) :\n  #|[set t : n.-tuple T | all A t & uniq t]| = #|A| ^_ n.\n",
  "proof": "Proof.\nelim: n A => [|n IHn] A.\n  by rewrite (@eq_card1 _ [tuple]) // => t; rewrite [t]tuple0 inE.\nrewrite -sum1dep_card (partition_big (@thead _ _) A) /= => [|t]; last first.\n  by case/tupleP: t => x t; do 2!case/andP.\nrewrite ffactnS -sum_nat_const; apply: eq_bigr => x Ax.\nrewrite (cardD1 x) [x \\in A]Ax /= -(IHn [predD1 A & x]) -sum1dep_card.\nrewrite (reindex (fun t : n.-tuple T => [tuple of x :: t])) /=; last first.\n  pose ttail (t : n.+1.-tuple T) := [tuple of behead t].\n  exists ttail => [t _ | t /andP[_ /eqP <-]]; first exact: val_inj.\n  by rewrite -tuple_eta.\napply: eq_bigl=> t; rewrite Ax theadE eqxx andbT /= andbA; congr (_ && _).\nby rewrite all_predI all_predC has_pred1 andbC.\nQed."
}
{
  "statement": "Lemma rfix_mxP m (W : 'M_(m, n)) (H : {set gT}) :\n  reflect (forall x, x \\in H -> W *m rG x = W) (W <= rfix_mx H)%MS.\n",
  "proof": "Proof.\nrewrite /rfix_mx; set C := \\matrix_i _.\napply: (iffP row_subP) => [cHW x Hx | cHW j].\n  apply/row_matrixP=> j; apply/eqP; rewrite -subr_eq0 row_mul.\n  move/sub_kermxP: {cHW}(cHW j); rewrite mul_rV_lin1 /=; move/(canRL mxvecK).\n  move/row_matrixP/(_ (enum_rank_in Hx x)); rewrite row_mul rowK !linear0.\n  by rewrite enum_rankK_in // mul_vec_lin_row mulmxBr mulmx1 => ->.\napply/sub_kermxP; rewrite mul_rV_lin1 /=; apply: (canLR vec_mxK).\napply/row_matrixP=> i; rewrite row_mul rowK mul_vec_lin_row -row_mul.\nby rewrite mulmxBr mulmx1 cHW ?enum_valP // subrr !linear0.\nQed."
}
{
  "statement": "Lemma dim_vspaceOver M : (F * M <= M)%VS -> \\dim (vspaceOver M) = \\dim_F M.\n",
  "proof": "Proof.\nmove=> modM; have [] := field_module_semisimple modM.\nset n := \\dim_F M => b [Mb nz_b] [defM dx_b].\nsuff: basis_of (vspaceOver M) b by apply: size_basis.\napply/andP; split.\n  rewrite eqEsubv; apply/andP; split; apply/span_subvP=> u.\n    by rewrite mem_vspaceOver field_module_eq // => /Mb.\n  move/(@vbasis_mem _ _ _ M); rewrite -defM => /memv_sumP[{}u Fu ->].\n  apply: memv_suml => i _; have /memv_cosetP[a Fa ->] := Fu i isT.\n  by apply: (memvZ (Subvs Fa)); rewrite memv_span ?memt_nth.\napply/freeP=> a /(directv_sum_independent dx_b) a_0 i.\nhave{a_0}: a i *: (b`_i : L_F) == 0.\n  by rewrite a_0 {i}// => i _; rewrite memv_mul ?memv_line ?subvsP.\nby rewrite scaler_eq0=> /predU1P[] // /idPn[]; rewrite (memPn nz_b) ?memt_nth.\nQed."
}
{
  "statement": "Lemma im_Zp_unitm : Zp_unitm @* units_Zp #[a] = Aut <[a]>.\n",
  "proof": "Proof.\nrewrite morphimEdom; apply/setP=> f; pose n := invm (injm_Zpm a) (f a).\napply/imsetP/idP=> [[u _ ->] | Af]; first exact: Aut_aut.\nhave [a1 | nta] := eqVneq a 1.\n  by rewrite a1 cycle1 Aut1 in Af; exists 1; rewrite // morph1 (set1P Af).\nhave a_fa: <[a]> = <[f a]>.\n  by rewrite -(autmE Af) -morphim_cycle ?im_autm ?cycle_id.\nhave def_n: a ^+ n = f a.\n  by rewrite -/(Zpm n) invmK // im_Zpm a_fa cycle_id.\nhave co_a_n: coprime #[a].-2.+2 n.\n  by rewrite {1}Zp_cast ?order_gt1 // -generator_coprime def_n; apply/eqP.\nexists (FinRing.unit 'Z_#[a] co_a_n); rewrite ?inE //.\napply: eq_Aut (Af) (Aut_aut _ _) _ => x ax.\nrewrite autE //= /cyclem; case/cycleP: ax => k ->{x}.\nby rewrite -(autmE Af) morphX ?cycle_id //= autmE -def_n -!expgM mulnC.\nQed."
}
{
  "statement": "Lemma mulsmxP m1 m2 n A (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n  reflect (exists2 A1, forall i, A1 i \\in R1\n            & exists2 A2, forall i, A2 i \\in R2\n           & A = \\sum_(i < n ^ 2) A1 i *m A2 i)\n          (A \\in R1 * R2)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [R_A|[A1 R_A1 [A2 R_A2 ->{A}]]]; last first.\n  by rewrite linear_sum summx_sub // => i _; rewrite mem_mulsmx.\nhave{R_A}: (A \\in R1 * <<R2>>)%MS.\n  by apply: memmx_subP R_A; rewrite mulsmxS ?genmxE.\ncase/memmx_sumsP=> A_ -> R_A; pose A2_ i := vec_mx (row i <<R2>>%MS).\npose A1_ i := mxvec (A_ i) *m pinvmx (R1 *m lin_mx (mulmxr (A2_ i))) *m R1.\nexists (vec_mx \\o A1_) => [i|]; first by rewrite vec_mxK submxMl.\nexists A2_ => [i|]; first by rewrite vec_mxK -(genmxE R2) row_sub.\napply: eq_bigr => i _; rewrite -[_ *m _](mx_rV_lin (mulmxr (A2_ i))).\nby rewrite -mulmxA mulmxKpV ?mxvecK // -(genmxE (_ *m _)) R_A.\nQed."
}
{
  "statement": "Lemma orthogonal_split S beta :\n  {X : U  & X \\in <<S>>%VS &\n      {Y :U | [/\\ beta = X + Y, '[X, Y] = 0 & orthogonal form [:: Y] S]}}.\n",
  "proof": "Proof.\nsuffices [X S_X [Y -> oYS]]:\n  {X : _ & X \\in <<S>>%VS & {Y | beta = X + Y & orthogonal form [:: Y] S}}.\n- exists X => //; exists Y.\n  by rewrite hermC /= (span_orthogonal oYS) ?memv_span1 ?conjC0 // mulr0.\nelim: S beta => [|phi S IHS] beta.\n  by exists 0; last exists beta; rewrite ?mem0v ?add0r.\nhave [[UU S_U [V -> oVS]] [X S_X [Y -> oYS]]] := (IHS phi, IHS beta).\npose Z := '[Y, V] / '[V] *: V; exists (X + Z).\n  rewrite /Z -{4}(addKr UU V) scalerDr scalerN addrA addrC span_cons.\n  by rewrite memv_add ?memvB ?memvZ ?memv_line.\nexists (Y - Z); first by rewrite addrCA !addrA addrK addrC.\napply/orthoPl=> psi; rewrite !inE => /predU1P[-> | Spsi]; last first.\n  by rewrite linearBl linearZl_LR /= (orthoPl oVS _ Spsi) mulr0 subr0 (orthoPl oYS).\nrewrite linearBl !linearDr /= (span_orthogonal oYS) // ?memv_span ?mem_head //.\nrewrite !linearZl_LR /= (span_orthogonal oVS _ S_U) ?mulr0 ?memv_span ?mem_head //.\nhave [-> | nzV] := eqVneq V 0; first by rewrite linear0r !mul0r subrr.\nby rewrite divfK ?dnorm_eq0 ?subrr.\nQed."
}
{
  "statement": "Lemma partition_big_idem I (s : seq I)\n      (J : finType) (P : pred I) (p : I -> J) (Q : pred J) F :\n  (forall i, P i -> Q (p i)) ->\n  \\big[op/x]_(i <- s | P i) F i =\n  \\big[op/x]_(j : J | Q j) \\big[op/x]_(i <- s | (P i) && (p i == j)) F i.\n",
  "proof": "Proof.\nmove=> Qp; transitivity (\\big[op/x]_(i <- s | P i && Q (p i)) F i).\n  by apply: eq_bigl => i; case Pi: (P i); rewrite // Qp.\nhave [n leQn] := ubnP #|Q|; elim: n => // n IHn in Q {Qp} leQn *.\ncase: (pickP Q) => [j Qj | Q0]; last first.\n  by rewrite !big_pred0 // => i; rewrite Q0 andbF.\nrewrite (bigD1 j) // -IHn; last by rewrite ltnS (cardD1x j Qj) in leQn.\nrewrite (bigID_idem (fun i => p i == j)).\ncongr (op : _ -> _); apply: eq_bigl => i; last by rewrite andbA.\nby case: eqP => [->|_]; rewrite !(Qj, andbT, andbF).\nQed."
}
{
  "statement": "Lemma cfBigdprodK phi (Phi := cfBigdprod phi) i (a := phi i 1%g / Phi 1%g) :\n  Phi 1%g != 0 -> P i -> a != 0 /\\ a *: 'Res[A i] Phi = phi i.\n",
  "proof": "Proof.\nmove=> nzPhi Pi; split.\n  rewrite mulf_neq0 ?invr_eq0 // (contraNneq _ nzPhi) // => phi_i0.\n  by rewrite cfBigdprod1 (bigD1 i) //= phi_i0 mul0r.\napply/cfun_inP=> x Aix; rewrite cfunE cfResE ?sAG // mulrAC.\nhave {1}->: x = (\\prod_(j | P j) (if j == i then x else 1))%g.\n  rewrite -big_mkcondr (big_pred1 i) ?eqxx // => j /=.\n  by apply: andb_idl => /eqP->.\nrewrite cfBigdprodE => [|j _]; last by case: eqP => // ->.\napply: canLR (mulfK nzPhi) _; rewrite cfBigdprod1 !(bigD1 i Pi) /= eqxx.\nby rewrite mulrCA !mulrA; congr (_ * _); apply: eq_bigr => j /andP[_ /negPf->].\nQed."
}
{
  "statement": "Lemma qf_evalP e f : qf_form f -> reflect (holds e f) (qf_eval e f).\n",
  "proof": "Proof.\nelim: f => //=; try by move=> *; apply: idP.\n- by move=> t1 t2 _; apply: eqP.\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1T]; last by right; case.\n  by case/IHf2; [left | right; case].\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1F]; first by do 2 left.\n  by case/IHf2; [left; right | right; case].\n- move=> f1 IHf1 f2 IHf2 /= /andP[/IHf1[] f1T]; last by left.\n  by case/IHf2; [left | right; move/(_ f1T)].\nby move=> f1 IHf1 /IHf1[]; [right | left].\nQed."
}
{
  "statement": "Lemma max_card_abelian G :\n  abelian G -> #|G| <= exponent G ^ 'r(G) ?= iff homocyclic G.\n",
  "proof": "Proof.\nmove=> cGG; have [b defG def_tG] := abelian_structure cGG.\nhave Gb: all [in G] b.\n  apply/allP=> x b_x; rewrite -(bigdprodWY defG); have [b1 b2] := splitPr b_x.\n  by rewrite big_cat big_cons /= mem_gen // setUCA inE cycle_id.\nhave ->: homocyclic G = all (pred1 (exponent G)) (abelian_type G).\n  rewrite /homocyclic cGG /abelian_type; case: #|G| => //= n.\n  by move: (_ (tag _)) => t; case: ifP => //= _; rewrite genGid eqxx.\nrewrite -size_abelian_type // -{}def_tG -{defG}(bigdprod_card defG) size_map.\nrewrite unlock; elim: b Gb => //= x b IHb; case/andP=> Gx Gb.\nhave eGgt0: exponent G > 0 := exponent_gt0 G.\nhave le_x_G: #[x] <= exponent G by rewrite dvdn_leq ?dvdn_exponent.\nhave:= leqif_mul (leqif_eq le_x_G) (IHb Gb).\nby rewrite -expnS expn_eq0 eqn0Ngt eGgt0.\nQed."
}
{
  "statement": "Lemma gFmod_hereditary : GFunctor.hereditary (F1 %% F2).\n",
  "proof": "Proof.\nmove=> gT H G sHG; set FGH := _ :&: H; have nF2H := gFnorm F2 H.\nrewrite -sub_quotient_pre; last exact: subset_trans (subsetIr _ _) _.\npose rH := restrm nF2H (coset (F2 _ H)); pose rHM := [morphism of rH].\nhave rnorm_simpl: rHM @* H = H / F2 _ H by rewrite morphim_restrm setIid.\nhave nF2G := subset_trans sHG (gFnorm F2 G).\npose rG := restrm nF2G (coset (F2 _ G)); pose rGM := [morphism of rG].\nhave sqKfK: 'ker rGM \\subset 'ker rHM.\n  rewrite !ker_restrm !ker_coset (setIidPr (gFsub F2 _)) setIC /=.\n  exact: gFhereditary.\nhave sHH := subxx H; rewrite -rnorm_simpl /= -(morphim_factm sqKfK sHH) /=.\napply: subset_trans (gFcont F1 _); rewrite /= {2}morphim_restrm setIid /=.\napply: subset_trans (morphimS _ (gFhereditary _ (quotientS _ sHG))) => /=.\nhave ->: FGH / _ = restrm nF2H (coset _) @* FGH.\n  by rewrite morphim_restrm setICA setIid.\nrewrite -(morphim_factm sqKfK sHH) morphimS //= morphim_restrm -quotientE.\nby rewrite setICA setIid (subset_trans (quotientI _ _ _)) // cosetpreK.\nQed."
}
{
  "statement": "Lemma eval_Pick e (qev := qf_eval e) :\n  let P i := qev (pred_f i) in\n  qev Pick = (if pick P is Some i then qev (then_f i) else qev else_f).\n",
  "proof": "Proof.\nmove=> P; rewrite ((big_morph qev) false orb) //= big_orE /=.\napply/existsP/idP=> [[p] | true_at_P].\n  rewrite ((big_morph qev) true andb) //= big_andE /=.\n  case/andP=> /forallP-eq_p_P.\n  rewrite (@eq_pick _ _ P) => [|i]; first by case: pick.\n  by move/(_ i): eq_p_P => /=; case: (p i) => //= /negPf.\nexists [ffun i => P i] => /=; apply/andP; split.\n  rewrite ((big_morph qev) true andb) //= big_andE /=.\n  by apply/forallP=> i; rewrite /= ffunE; case Pi: (P i) => //=; apply: negbT.\nrewrite (@eq_pick _ _ P) => [|i]; first by case: pick true_at_P.\nby rewrite ffunE.\nQed."
}
{
  "statement": "Lemma mx_rsim_dsum (I : finType) (P : pred I) U rU (W : 'M_n)\n    (modU : forall i, mxmodule rG (U i)) (modW : mxmodule rG W) :\n    let S := (\\sum_(i | P i) U i)%MS in (S :=: W)%MS -> mxdirect S ->\n    (forall i, mx_rsim (submod_repr (modU i)) (rU i : representation)) ->\n  mx_rsim (submod_repr modW) (\\big[dadd_grepr/grepr0]_(i | P i) rU i).\n",
  "proof": "Proof.\nmove=> /= defW dxW rsimU.\nrewrite mxdirectE /= -!(big_filter _ P) in dxW defW *.\nelim: {P}(filter P _) => [|i e IHe] in W modW dxW defW *.\n  rewrite !big_nil /= in defW *.\n  by exists 0 => [||? _]; rewrite ?mul0mx ?mulmx0 // /row_free -defW !mxrank0.\nrewrite !big_cons /= in dxW defW *.\nrewrite 2!(big_nth i) !big_mkord /= in IHe dxW defW.\nset Wi := (\\sum_i _)%MS in defW dxW IHe.\nrewrite -mxdirectE mxdirect_addsE !mxdirectE eqxx /= -/Wi in dxW.\nhave modWi: mxmodule rG Wi by apply: sumsmx_module.\ncase/andP: dxW; move/(IHe Wi modWi) {IHe}; move/(_ (eqmx_refl _))=> rsimWi.\nby move/eqP; move/mxdirect_addsP=> dxUiWi; apply: mx_rsim_dadd (rsimU i) rsimWi.\nQed."
}
{
  "statement": "Lemma totient_gt1 n : (totient n > 1) = (n > 2).\n",
  "proof": "Proof.\ncase: n => [|[|[|[|n']]]]//=; set n := n'.+4; rewrite [RHS]isT.\nwlog [q] : / exists k, k.+3 \\in primes n; last first.\n  rewrite mem_primes => /and3P[qp ngt0 qn].\n  have [[|k]// cqk ->] := pfactor_coprime qp ngt0.\n  rewrite totient_coprime 1?coprime_sym ?coprimeXl//.\n  rewrite totient_pfactor// -?pfactor_dvdn// mulnCA/= (@leq_trans q.+2)//.\n  by rewrite leq_pmulr// muln_gt0 totient_gt0 expn_gt0.\nhave := @prod_prime_decomp n isT; rewrite prime_decompE big_map/=.\ncase: (primes n) (all_prime_primes n) (sorted_primes n) =>\n    [|[|[|p']]// [|[|[|[|q']]] r]]//=; first by rewrite big_nil.\n  case: p' => [_ _|p' _ _ _]; last by apply; exists p'; rewrite ?mem_head.\n  rewrite big_seq1; case: logn => [|[|k]]//= ->.\n  by rewrite totient_pfactor//= mul1n (@leq_pexp2l 2 1)//.\nby move=> _ _ _; apply; exists q'=> //; rewrite !in_cons eqxx orbT.\nQed."
}
{
  "statement": "Lemma Grp_semidihedral n : n > 3 ->\n  'SD_(2 ^ n) \\isog\n     Grp (x : y : x ^+ (2 ^ n.-1), y ^+ 2, x ^ y = x ^+ (2 ^ n.-2).-1).\n",
  "proof": "Proof.\nmove=> n_gt3.\nrewrite /('SD__)%type -(subnKC (ltnW (ltnW n_gt3))) pdiv_pfactor //.\nrewrite !expnS !mulKn // -!expnS /=; set q := (2 ^ _)%N.\nhave q_gt1: q > 1 by rewrite (ltn_exp2l 0).\napply: Extremal.Grp => //; set B := <[_]>.\nhave oB: #|B| = q by rewrite -orderE order_Zp1 Zp_cast.\nhave pB: 2.-group B by rewrite /pgroup oB pnatX.\nhave ntB: B != 1 by rewrite -cardG_gt1 oB.\nhave [] := cyclic_pgroup_Aut_structure pB (cycle_cyclic _) ntB.\nrewrite oB /= pfactorK //= -/B => m [[def_m _ _ _ _] _].\nrewrite -{1 2}(subnKC n_gt3) => [[t [At ot _ [s [_ _ _ defA]]]]].\ncase/dprodP: defA => _ defA cst _.\nhave{cst defA} cAt: t \\in 'C(Aut B).\n  rewrite -defA centM inE -sub_cent1 -cent_cycle centsC cst /=.\n  by rewrite cent_cycle cent1id.\ncase=> s0 [As0 os0 _ def_s0t _]; exists (s0 * t).\nrewrite -def_m ?groupM ?cycle_id // def_s0t !Zp_expg !mul1n valZpK Zp_nat.\nrewrite order_dvdn expgMn /commute 1?(centP cAt) // -{1}os0 -{1}ot.\nby rewrite !expg_order mul1g.\nQed."
}
{
  "statement": "Lemma filter_sort T (leT : rel T) :\n  total leT -> transitive leT ->\n  forall p s, filter p (sort leT s) = sort leT (filter p s).\n",
  "proof": "Proof.\nmove=> leT_total leT_tr p s; case Ds: s => // [x s1].\npose leN := relpre (nth x s) leT.\npose lt_lex := [rel n m | leN n m && (leN m n ==> (n < m))].\nhave lt_lex_tr: transitive lt_lex.\n  rewrite /lt_lex /leN => ? ? ? /= /andP [xy xy'] /andP [yz yz'].\n  rewrite (leT_tr _ _ _ xy yz); apply/implyP => zx; move: xy' yz'.\n  by rewrite (leT_tr _ _ _ yz zx) (leT_tr _ _ _ zx xy); apply: ltn_trans.\nrewrite -{s1}Ds -(mkseq_nth x s) !(filter_map, sort_map); congr map.\napply/(@irr_sorted_eq _ lt_lex); rewrite /lt_lex /leN //=.\n- by move=> ?; rewrite /= ltnn implybF andbN.\n- exact/sorted_filter/sort_iota_stable.\n- exact/sort_stable/sorted_filter/iota_ltn_sorted/ltn_trans/ltn_trans.\n- by move=> ?; rewrite !(mem_filter, mem_sort).\nQed."
}
{
  "statement": "Lemma num_itv_mul_boundl b1 b2 (x1 x2 : R) :\n  (BLeft 0%:Z <= b1 -> BLeft 0%:Z <= b2 ->\n   num_itv_bound R b1 <= BLeft x1 ->\n   num_itv_bound R b2 <= BLeft x2 ->\n   num_itv_bound R (mul_boundl b1 b2) <= BLeft (x1 * x2))%O.\n",
  "proof": "Proof.\nmove: b1 b2 => [[] b1 | []//] [[] b2 | []//] /=; rewrite 4!bnd_simp.\n- set bl := match b1 with 0%Z => _ | _ => _ end.\n  have -> : bl = BLeft (b1 * b2).\n    rewrite {}/bl; move: b1 b2 => [[|p1]|p1] [[|p2]|p2]; congr BLeft.\n    by rewrite mulr0.\n  by rewrite bnd_simp intrM -2!(ler0z R); apply: ler_pM.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp// => b1p b2p sx1 sx2.\n  + by rewrite mulr_ge0 ?(le_trans _ (ltW sx2)) ?ler0z.\n  + rewrite intrM (@lt_le_trans _ _ (b1.+1%:~R * x2)) ?ltr_pM2l//.\n    by rewrite ler_pM2r// (le_lt_trans _ sx2) ?ler0z.\n- case: b2 => [[|b2] | b2]; rewrite !bnd_simp// => b1p b2p sx1 sx2.\n  + by rewrite mulr_ge0 ?(le_trans _ (ltW sx1)) ?ler0z.\n  + rewrite intrM (@le_lt_trans _ _ (b1%:~R * x2)) ?ler_wpM2l ?ler0z//.\n    by rewrite ltr_pM2r ?(lt_le_trans _ sx2).\n- by rewrite -2!(ler0z R) bnd_simp intrM; apply: ltr_pM.\nQed."
}
{
  "statement": "Lemma pairwise_trans s : antisymmetric r ->\n   pairwise r s -> {in s & &, transitive r}.\n",
  "proof": "Proof.\nmove=> /(_ _ _ _)/eqP r_anti + y x z => /pairwiseP-/(_ y) ltP ys xs zs.\nhave [-> //|neqxy] := eqVneq x y; have [-> //|neqzy] := eqVneq z y.\nmove=> lxy lyz; move: ys xs zs lxy neqxy lyz neqzy.\nmove=> /(nthP y)[j jlt <-] /(nthP y)[i ilt <-] /(nthP y)[k klt <-].\nhave [ltij|ltji|->] := ltngtP i j; last 2 first.\n- by move=> leij; rewrite r_anti// leij ltP.\n- by move=> lejj; rewrite r_anti// lejj.\nmove=> _ _; have [ltjk|ltkj|->] := ltngtP j k; last 2 first.\n- by move=> lejk; rewrite r_anti// lejk ltP.\n- by move=> lekk; rewrite r_anti// lekk.\nby move=> _ _; apply: (ltP) => //; apply: ltn_trans ltjk.\nQed."
}
{
  "statement": "Lemma prim_trans_norm (H : {group aT}) :\n    [primitive G, on S | to] -> H <| G ->\n  H \\subset 'C_G(S | to) \\/ [transitive H, on S | to].\n",
  "proof": "Proof.\nmove=> primG /andP[sHG nHG]; rewrite subsetI sHG.\nhave [trG _] := andP primG; have [x Sx defS] := imsetP trG.\nmove: primG; rewrite (trans_prim_astab Sx) // => /maximal_eqP[_].\ncase/(_ ('C_G[x | to] <*> H)%G) => /= [||cxH|]; first exact: joing_subl.\n- by rewrite join_subG subsetIl.\n- have{} cxH: H \\subset 'C_G[x | to] by rewrite -cxH joing_subr.\n  rewrite subsetI sHG /= in cxH; left; apply/subsetP=> a Ha.\n  apply/astabP=> y Sy; have [b Gb ->] := atransP2 trG Sx Sy.\n  rewrite actCJV [to x (a ^ _)](astab1P _) ?(subsetP cxH) //.\n  by rewrite -mem_conjg (normsP nHG).\nrewrite norm_joinEl 1?subIset ?nHG //.\nby move/(subgroup_transitiveP Sx sHG trG); right.\nQed."
}
{
  "statement": "Lemma Fitting_group_set G : group_set (Fitting G).\n",
  "proof": "Proof.\nsuffices [F ->]: exists F : {group gT}, Fitting G = F by apply: groupP.\nrewrite /Fitting; elim: primes (primes_uniq #|G|) => [_|p r IHr] /=.\n  by exists [1 gT]%G; rewrite big_nil.\ncase/andP=> rp /IHr[F defF]; rewrite big_cons defF.\nsuffices{IHr} /and3P[p'F sFG nFG]: p^'.-group F && (F <| G).\n  have nFGp: 'O_p(G) \\subset 'N(F) := gFsub_trans _ nFG.\n  have pGp: p.-group('O_p(G)) := pcore_pgroup p G.\n  have{pGp} tiGpF: 'O_p(G) :&: F = 1 by rewrite coprime_TIg ?(pnat_coprime pGp).\n  exists ('O_p(G) <*> F)%G; rewrite dprodEY // (sameP commG1P trivgP) -tiGpF.\n  by rewrite subsetI commg_subl commg_subr (subset_trans sFG) // gFnorm.\nmove/bigdprodWY: defF => <- {F}; elim: r rp => [_|q r IHr] /=.\n  by rewrite big_nil gen0 pgroup1 normal1.\nrewrite inE eq_sym big_cons -joingE -joing_idr => /norP[qp /IHr {IHr}].\nset F := <<_>> => /andP[p'F nsFG].\nrewrite norm_joinEl /= -/F; last exact/gFsub_trans/normal_norm.\nby rewrite pgroupM p'F normalM ?pcore_normal //= (pi_pgroup (pcore_pgroup q G)).\nQed."
}
{
  "statement": "Lemma ext_coprime_Hall_trans (H1 H2 : {group gT}) :\n    pi.-Hall(G) H1 -> [acts A, on H1 | to] ->\n    pi.-Hall(G) H2 -> [acts A, on H2 | to] ->\n  exists2 x, x \\in 'C_(G | to)(A) & H1 :=: H2 :^ x.\n",
  "proof": "Proof.\nmove=> hallH1 nH1A hallH2 nH2A.\nhave sH1G := pHall_sub hallH1; have sH2G := pHall_sub hallH2.\nrewrite !actsEsd // in nH1A nH2A.\nhave hallH1': pi.-Hall(G') (inG @* H1) by rewrite morphim_pHall.\nhave hallH2': pi.-Hall(G') (inG @* H2) by rewrite morphim_pHall.\nhave [x'] := coprime_Hall_trans nGA' coGA' solG' hallH1' nH1A hallH2' nH2A.\ncase/setIP=> /= Gx' cAx' /eqP defH1; pose x := invm injG x'.\nhave Gx: x \\in G by rewrite -(im_invm injG) mem_morphim.\nhave def_x': x' = inG x by rewrite invmK.\nexists x; first by rewrite inE Gx gacentEsd mem_morphpre /= -?def_x'.\napply/eqP; move: defH1; rewrite def_x' /= -morphimJ //=.\nby rewrite !eqEsubset !injmSK // conj_subG.\nQed."
}
{
  "statement": "Lemma perm_bigcprod (I : eqType) r1 r2 (A : I -> {set gT}) G x :\n    \\big[cprod/1]_(i <- r1) A i = G -> {in r1, forall i, x i \\in A i} ->\n    perm_eq r1 r2 ->\n  \\prod_(i <- r1) x i = \\prod_(i <- r2) x i.\n",
  "proof": "Proof.\nelim: r1 r2 G => [|i r1 IHr] r2 G defG Ax eq_r12.\n  by rewrite perm_sym in eq_r12; rewrite (perm_small_eq _ eq_r12) ?big_nil.\nhave /rot_to[n r3 Dr2]: i \\in r2 by rewrite -(perm_mem eq_r12) mem_head.\ntransitivity (\\prod_(j <- rot n r2) x j).\n  rewrite Dr2 !big_cons in defG Ax *; have [[_ G1 _ defG1] _ _] := cprodP defG.\n  rewrite (IHr r3 G1) //; first by case/allP/andP: Ax => _ /allP.\n  by rewrite -(perm_cons i) -Dr2 perm_sym perm_rot perm_sym.\nrewrite -(cat_take_drop n r2) [in LHS]cat_take_drop in eq_r12 *.\nrewrite (perm_big _ eq_r12) !big_cat /= !(big_nth i) !big_mkord in defG *.\nhave /cprodP[[G1 G2 defG1 defG2] _ /centsP-> //] := defG.\n  rewrite defG2 -(bigcprodW defG2) mem_prodg // => k _; apply: Ax.\n  by rewrite (perm_mem eq_r12) mem_cat orbC mem_nth.\nrewrite defG1 -(bigcprodW defG1) mem_prodg // => k _; apply: Ax.\nby rewrite (perm_mem eq_r12) mem_cat mem_nth.\nQed."
}
{
  "statement": "Lemma complete_unitmx m n (U : 'M_(m, n)) (f : 'M_n) :\n  \\rank (U *m f) = \\rank U -> {g : 'M_n | g \\in unitmx & U *m f = U *m g}.\n",
  "proof": "Proof.\nmove=> injfU; pose V := <<U>>%MS; pose W := V *m f.\npose g := proj_mx V (V^C)%MS *m f + cokermx V *m row_ebase W.\nhave defW: V *m g = W.\n  rewrite mulmxDr mulmxA proj_mx_id ?genmxE ?capmx_compl //.\n  by rewrite mulmxA mulmx_coker mul0mx addr0.\nexists g; last first.\n  have /submxP[u ->]: (U <= V)%MS by rewrite genmxE.\n  by rewrite -!mulmxA defW.\nrewrite -row_full_unit -sub1mx; apply/submxP.\nhave: (invmx (col_ebase W) *m W <= V *m g)%MS by rewrite defW submxMl.\ncase/submxP=> v def_v; exists (invmx (row_ebase W) *m (v *m V + (V^C)%MS)).\nrewrite -mulmxA mulmxDl -mulmxA -def_v -{3}[W]mulmx_ebase -mulmxA.\nrewrite mulKmx ?col_ebase_unit // [_ *m g]mulmxDr mulmxA.\nrewrite (proj_mx_0 (capmx_compl _)) // mul0mx add0r 2!mulmxA.\nrewrite mulmxK ?row_ebase_unit // copid_mx_id ?rank_leq_row //.\nrewrite (eqmxMr _ (genmxE U)) injfU genmxE addrC -mulmxDl subrK.\nby rewrite mul1mx mulVmx ?row_ebase_unit.\nQed."
}
{
  "statement": "Lemma isog_2X1p2 : 2^{1+2} \\isog 'D_8.\n",
  "proof": "Proof.\nhave pr2: prime 2 by []; have oG := card_pX1p2 pr2; rewrite -[8]oG.\ncase/existsP: (isoGrp_hom (Grp_pX1p2 pr2)) => [[x y]] /=.\nrewrite -/2^{1+2}; case/eqP=> defG x2 y2 _ _.\nhave not_oG_2: ~~ (#|2^{1+2}| %| 2) by rewrite oG.\nhave ox: #[x] = 2.\n  apply: nt_prime_order => //; apply: contra not_oG_2 => x1.\n  by rewrite -defG (eqP x1) cycle1 joing1G order_dvdn y2.\nhave oy: #[y] = 2.\n  apply: nt_prime_order => //; apply: contra not_oG_2 => y1.\n  by rewrite -defG (eqP y1) cycle1 joingG1 order_dvdn x2.\nrewrite -defG joing_idl joing_idr involutions_gen_dihedral //.\napply: contra not_oG_2 => eq_xy; rewrite -defG (eqP eq_xy) (joing_idPl _) //.\nby rewrite -orderE oy.\nQed."
}
{
  "statement": "Lemma sum_ncycle_totient :\n  \\sum_(d < #|G|.+1) #|[set <[x]> | x in G & #[x] == d]| * totient d = #|G|.\n",
  "proof": "Proof.\npose h (x : gT) : 'I_#|G|.+1 := inord #[x].\nsymmetry; rewrite -{1}sum1_card (partition_big h xpredT) //=.\napply: eq_bigr => d _; set Gd := finset _.\nrewrite -sum_nat_const sum1dep_card -sum1_card (_ : finset _ = Gd); last first.\n  apply/setP=> x /[!inE]; apply: andb_id2l => Gx.\n  by rewrite /eq_op /= inordK // ltnS subset_leq_card ?cycle_subG.\nrewrite (partition_big_imset cycle) {}/Gd; apply: eq_bigr => C /=.\ncase/imsetP=> x /setIdP[Gx /eqP <-] -> {C d}.\nrewrite sum1dep_card totient_gen; apply: eq_card => y; rewrite !inE /generator.\nmove: Gx; rewrite andbC eq_sym -!cycle_subG /order.\nby case: eqP => // -> ->; rewrite eqxx.\nQed."
}
{
  "statement": "Lemma directv_sum_unique {Us : I -> {vspace vT}} :\n  reflect (forall us vs,\n              (forall i, P i -> us i \\in Us i) ->\n              (forall i, P i -> vs i \\in Us i) ->\n            (\\sum_(i | P i) us i == \\sum_(i | P i) vs i)\n              = [forall (i | P i), us i == vs i])\n          (directv (\\sum_(i | P i) Us i)).\n",
  "proof": "Proof.\napply: (iffP directv_sum_independent) => [dxU us vs Uu Uv | dxU us Uu u_0 i Pi].\n  apply/idP/forall_inP=> [|eq_uv]; last by apply/eqP/eq_bigr => i /eq_uv/eqP.\n  rewrite -subr_eq0 -sumrB => /eqP/dxU eq_uv i Pi.\n  by rewrite -subr_eq0 eq_uv // => j Pj; apply: memvB; move: j Pj.\napply/eqP; have:= esym (dxU us \\0 Uu _); rewrite u_0 big1_eq eqxx.\nby move/(_ _)/forall_inP=> -> // j _; apply: mem0v.\nQed."
}
{
  "statement": "Lemma mxminpoly_diag {F : fieldType} {n} (d : 'rV[F]_n.+1)\n    (u := undup [seq d 0 i | i <- enum 'I_n.+1]) :\n  mxminpoly (diag_mx d) = \\prod_(r <- u) ('X - r%:P).\n",
  "proof": "Proof.\napply/eqP; rewrite -eqp_monic ?mxminpoly_monic ?monic_prod_XsubC// /eqp.\nrewrite mxminpoly_min/=; last first.\n  rewrite horner_mx_diag; apply/matrixP => i j; rewrite !mxE horner_prod.\n  case: (altP (i =P j)) => [->|neq_ij//]; rewrite mulr1n.\n  rewrite (bigD1_seq (d 0 j)) ?undup_uniq ?mem_undup ?map_f// /=.\n  by rewrite hornerD hornerN hornerX hornerC subrr mul0r.\napply: uniq_roots_dvdp; last by rewrite uniq_rootsE undup_uniq.\napply/allP => x; rewrite mem_undup root_mxminpoly char_poly_trig//.\nrewrite -(big_map _ predT (fun x => _ - x%:P)) root_prod_XsubC.\nby move=> /mapP[i _ ->]; apply/mapP; exists i; rewrite ?(mxE, eqxx).\nQed."
}
{
  "statement": "Lemma horner_mx_mem p : (horner_mx A p \\in Ad)%MS.\n",
  "proof": "Proof.\nelim/poly_ind: p => [|p a IHp]; first by rewrite rmorph0 // linear0 sub0mx.\nrewrite rmorphD rmorphM /= horner_mx_C horner_mx_X.\nrewrite addrC -scalemx1 linearP /= -(mul_vec_lin (mulmxr A)).\ncase/submxP: IHp => u ->{p}.\nhave: (powers_mx A (1 + d) <= Ad)%MS.\n  rewrite -(geq_leqif (mxrank_leqif_sup _)).\n    by rewrite (eqnP minpoly_mx_free) /d; case: ex_minnP.\n  rewrite addnC; apply/row_subP=> i.\n  by apply: eq_row_sub (lshift 1 i) _; rewrite !rowK.\napply: submx_trans; rewrite addmx_sub ?scalemx_sub //.\n  by apply: (eq_row_sub 0); rewrite rowK.\nrewrite -mulmxA mulmx_sub {u}//; apply/row_subP=> i.\nrewrite row_mul rowK mul_vec_lin /= mulmxE -exprSr.\nby apply: (eq_row_sub (rshift 1 i)); rewrite rowK.\nQed."
}
{
  "statement": "Lemma directv_sum_independent {Us : I -> {vspace vT}} :\n   reflect (forall us,\n               (forall i, P i -> us i \\in Us i) -> \\sum_(i | P i) us i = 0 ->\n             (forall i, P i -> us i = 0))\n           (directv (\\sum_(i | P i) Us i)).\n",
  "proof": "Proof.\napply: (iffP directv_sumP) => [dxU us Uu u_0 i Pi | dxU i Pi].\n  apply/eqP; rewrite -memv0 -(dxU i Pi) memv_cap Uu //= -memvN -sub0r -{1}u_0.\n  by rewrite (bigD1 i) //= addrC addKr memv_sumr // => j /andP[/Uu].\napply/eqP; rewrite -subv0; apply/subvP=> v.\nrewrite memv_cap memv0 => /andP[Uiv /memv_sumP[us Uu Dv]].\nhave: \\sum_(j | P j) [eta us with i |-> - v] j = 0.\n  rewrite (bigD1 i) //= eqxx {1}Dv addrC -sumrB big1 // => j /andP[_ i'j].\n  by rewrite (negPf i'j) subrr.\nmove/dxU/(_ i Pi); rewrite /= eqxx -oppr_eq0 => -> // j Pj.\nby have [-> | i'j] := eqVneq; rewrite ?memvN // Uu ?Pj.\nQed."
}
{
  "statement": "Lemma iso_eq_F0_F1_F2 : forall r s : {perm cube}, is_iso3 r ->\n   is_iso3 s -> r F0 = s F0 -> r F1 = s F1 ->  r F2 = s F2 -> r = s.\n",
  "proof": "Proof.\nmove=> r s hr hs hrs0 hrs1 hrs2.\nhave:= hrs0; have:= hrs1; have:= hrs2.\nhave e23: F2 = s0 F3 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nhave e14: F1 = s0 F4 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nhave e05: F0 = s0 F5 by apply/eqP; rewrite permE /S0f (tnth_nth F0).\nrewrite e23 e14 e05; rewrite !hr !hs.\nmove/perm_inj=> hrs3; move/perm_inj=> hrs4; move/perm_inj=> hrs5.\nby apply/eqP; rewrite eqperm /= hrs0 hrs1 hrs2 hrs3 hrs4 hrs5 !eqxx.\nQed."
}
{
  "statement": "Lemma partn_biggcd (I : finType) (P : pred I) F pi :\n    #|SimplPred P| > 0 -> (forall i, P i -> F i > 0) ->\n  (\\big[gcdn/0]_(i | P i) F i)`_pi = \\big[gcdn/0]_(i | P i) (F i)`_pi.\n",
  "proof": "Proof.\nmove=> ntP F_gt0; set d := \\big[gcdn/0]_(i | P i) F i.\nhave d_gt0: 0 < d.\n  case/card_gt0P: ntP => i /= Pi; have:= F_gt0 i Pi.\n  rewrite !lt0n -!dvd0n; apply: contra => dv0d.\n  by rewrite (dvdn_trans dv0d) // (@biggcdn_inf _ i).\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  by apply/dvdn_biggcdP=> i Pi; rewrite partn_dvd ?F_gt0 // (@biggcdn_inf _ i).\nrewrite -(dvdn_pmul2r (part_gt0 pi^' d)) partnC //.\napply/dvdn_biggcdP=> i Pi; rewrite -(partnC pi (F_gt0 i Pi)) dvdn_mul //.\n  by rewrite (@biggcdn_inf _ i).\nby rewrite partn_dvd ?F_gt0 // (@biggcdn_inf _ i).\nQed."
}
{
  "statement": "Lemma p3group_extraspecial G :\n  p.-group G -> ~~ abelian G -> logn p #|G| <= 3 -> extraspecial G.\n",
  "proof": "Proof.\nmove=> pG not_cGG; have /andP[sZG nZG] := center_normal G.\nhave ntG: G :!=: 1 by apply: contraNneq not_cGG => ->; apply: abelian1.\nhave ntZ: 'Z(G) != 1 by rewrite (center_nil_eq1 (pgroup_nil pG)).\nhave [p_pr _ [n oG]] := pgroup_pdiv pG ntG; rewrite oG pfactorK //.\nhave [_ _ [m oZ]] := pgroup_pdiv (pgroupS sZG pG) ntZ.\nhave lt_m1_n: m.+1 < n.\n  suffices: 1 < logn p #|(G / 'Z(G))|.\n    rewrite card_quotient // -divgS // logn_div ?cardSg //.\n    by rewrite oG oZ !pfactorK // ltn_subRL addn1.\n  rewrite ltnNge; apply: contra not_cGG => cycGs.\n  apply: cyclic_center_factor_abelian; rewrite (dvdn_prime_cyclic p_pr) //.\n  by rewrite (card_pgroup (quotient_pgroup _ pG)) (dvdn_exp2l _ cycGs).\nrewrite -{lt_m1_n}(subnKC lt_m1_n) !addSn !ltnS leqn0 in oG *.\ncase: m => // in oZ oG * => /eqP n2; rewrite {n}n2 in oG.\nexact: card_p3group_extraspecial oZ.\nQed."
}
{
  "statement": "Lemma generators_modular_group gT (G : {group gT}) :\n    G \\isog 'Mod_m ->\n  exists2 xy, extremal_generators G p n xy & modular_group_generators xy.\n",
  "proof": "Proof.\ncase/(isoGrpP _ Grp_modular_group); rewrite card_modular_group // -/m => oG.\ncase/existsP=> -[x y] /= /eqP[defG xq yp xy].\nrewrite norm_joinEr ?norms_cycle ?xy ?mem_cycle // in defG.\nhave [Gx Gy]: x \\in G /\\ y \\in G.\n  by apply/andP; rewrite -!cycle_subG -mulG_subG defG.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm; rewrite -cycle_subG -oG -defG; move/mulGidPl->.\n  by rewrite -leqNgt dvdn_leq ?(ltnW q_gt1) // order_dvdn xq.\nhave oy: #[y] = p by apply: nt_prime_order (group1_contra notXy).\nexists (x, y) => //=; split; rewrite ?inE ?notXy //.\napply/eqP; rewrite -(eqn_pmul2r p_gt0) -expnSr -{1}oy (ltn_predK n_gt2) -/m.\nby rewrite -TI_cardMg ?defG ?oG // setIC prime_TIg ?cycle_subG // -orderE oy.\nQed."
}
{
  "statement": "Lemma Grp_modular_group :\n  'Mod_(p ^ n) \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ r.+1).\n",
  "proof": "Proof.\nrewrite /modular_gtype def_p def_q def_r; apply: Extremal.Grp => //.\nset B := <[_]>; have Bb: Zp1 \\in B by apply: cycle_id.\nhave oB: #|B| = q by rewrite -orderE order_Zp1 Zp_cast.\nhave cycB: cyclic B by rewrite cycle_cyclic.\nhave pB: p.-group B by rewrite /pgroup oB pnatX ?pnat_id.\nhave ntB: B != 1 by rewrite -cardG_gt1 oB.\nhave [] := cyclic_pgroup_Aut_structure pB cycB ntB.\nrewrite oB pfactorK //= -/B -(expg_znat r.+1 Bb) oB => mB [[def_mB _ _ _ _] _].\nrewrite {1}def_n /= => [[t [At ot mBt]]].\nhave [p2 | ->] := even_prime p_pr; last first.\n  by case=> _ _ [s [As os mBs _]]; exists s; rewrite os -mBs def_mB.\nrewrite {1}p2 /= -2!eqSS -addn2 -2!{1}subn1 -subnDA subnK 1?ltnW //.\ncase: eqP => [n3 _ | _ [_ [_ _ _ _ [s [As os mBs _ _]{t At ot mBt}]]]].\n  by exists t; rewrite At ot -def_mB // mBt /q /r p2 n3.\nby exists s; rewrite As os -def_mB // mBs /r p2.\nQed."
}
{
  "statement": "Lemma permP s1 s2 : reflect (count^~ s1 =1 count^~ s2) (perm_eq s1 s2).\n",
  "proof": "Proof.\napply: (iffP allP) => /= [eq_cnt1 a | eq_cnt x _]; last exact/eqP.\nhave [n le_an] := ubnP (count a (s1 ++ s2)); elim: n => // n IHn in a le_an *.\nhave [/eqP|] := posnP (count a (s1 ++ s2)).\n  by rewrite count_cat addn_eq0; do 2!case: eqP => // ->.\nrewrite -has_count => /hasP[x s12x a_x]; pose a' := predD1 a x.\nhave cnt_a' s: count a s = count_mem x s + count a' s.\n  rewrite -count_predUI -[LHS]addn0 -(count_pred0 s).\n  by congr (_ + _); apply: eq_count => y /=; case: eqP => // ->.\nrewrite !cnt_a' (eqnP (eq_cnt1 _ s12x)) (IHn a') // -ltnS.\napply: leq_trans le_an.\nby rewrite ltnS cnt_a' -add1n leq_add2r -has_count has_pred1.\nQed."
}
{
  "statement": "Lemma sub_sums_genmxP P m n p (A : 'M_(m, p)) (B_ : I -> 'M_(n, p)) :\n  reflect (exists u_ : I -> 'M_(m, n), A = \\sum_(i | P i) u_ i *m B_ i)\n          (A <= \\sum_(i | P i) <<B_ i>>)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => [| [u_ ->]]; last first.\n  by apply: summx_sub_sums => i _; rewrite genmxE; apply: submxMl.\nhave [b] := ubnP #|P|; elim: b => // b IHb in P A *.\ncase: (pickP P) => [i Pi | P0 _]; last first.\n  rewrite big_pred0 //; move/submx0null->.\n  by exists (fun _ => 0); rewrite big_pred0.\nrewrite (cardD1x Pi) (bigD1 i) //= => /IHb{b IHb} /= IHi.\nrewrite (adds_eqmx (genmxE _) (eqmx_refl _)) => /sub_addsmxP[u ->].\nhave [u_ ->] := IHi _ (submxMl u.2 _).\nexists [eta u_ with i |-> u.1]; rewrite (bigD1 i Pi)/= eqxx; congr (_ + _).\nby apply: eq_bigr => j /andP[_ /negPf->].\nQed."
}
{
  "statement": "Lemma dvdp_addr m d n : d %| m -> (d %| m + n) = (d %| n).\n",
  "proof": "Proof.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite add0r.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Eq1.\napply/idP/idP; rewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _.\n  have sn0 : c1 * c2 != 0.\n    by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\n  move/eqP=> Eq2; apply: (@eq_dvdp _ (c1 *: q2 - c2 *: q1) _ _ sn0).\n  rewrite mulrDl -scaleNr -!scalerAl -Eq1 -Eq2 !scalerA.\n  by rewrite mulNr mulrC scaleNr -scalerBr addrC addKr.\nhave sn0 : c1 * c2 != 0.\n  by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\nmove/eqP=> Eq2; apply: (@eq_dvdp _ (c1 *: q2 + c2 *: q1) _ _ sn0).\nby rewrite mulrDl -!scalerAl -Eq1 -Eq2 !scalerA mulrC addrC scalerDr.\nQed."
}
{
  "statement": "Lemma rank_mx_group m n q : 'r([set: 'M['Z_q]_(m, n)]) = (m * n)%N.\n",
  "proof": "Proof.\nwlog q_gt1: q / q > 1 by case: q => [|[|q -> //]] /(_ 2)->.\nset G := setT; have cGG: abelian G := zmod_abelian _.\nhave [mn0 | ] := posnP (m * n).\n  by rewrite [G](card1_trivg _) ?rank1 // cardsT card_mx mn0.\nrewrite muln_gt0 => /andP[m_gt0 n_gt0].\nhave expG: exponent G = q := exponent_mx_group m_gt0 n_gt0 q_gt1.\napply/eqP; rewrite eqn_leq andbC -(leq_exp2l _ _ q_gt1) -{2}expG.\nhave ->: (q ^ (m * n))%N = #|G| by rewrite cardsT card_mx card_ord Zp_cast.\nrewrite max_card_abelian //= -grank_abelian //= -/G.\npose B : {set 'M['Z_q]_(m, n)} := [set delta_mx ij.1 ij.2 | ij : 'I_m * 'I_n].\nsuffices ->: G = <<B>>.\n  have ->: (m * n)%N = #|{: 'I_m * 'I_n}| by rewrite card_prod !card_ord.\n  exact: leq_trans (grank_min _) (leq_imset_card _ _).\napply/setP=> v; rewrite inE (matrix_sum_delta v).\nrewrite group_prod // => i _; rewrite group_prod // => j _.\nrewrite -[v i j]natr_Zp scaler_nat groupX // mem_gen //.\nby apply/imsetP; exists (i, j).\nQed."
}
{
  "statement": "Lemma kermxpolyM n (g : 'M_n) (p q : {poly K}) : coprimep p q ->\n  (kermxpoly g (p * q) :=: kermxpoly g p + kermxpoly g q)%MS.\n",
  "proof": "Proof.\ncase: n => [|n] in g *; first by rewrite !thinmx0.\nmove=> /Bezout_eq1_coprimepP [[/= u v]]; rewrite mulrC [v * _]mulrC => cpq.\napply/eqmxP/andP; split; last first.\n  apply/sub_kermxP/eqmx0P; rewrite !addsmxMr [in X in (_ + X)%MS]mulrC.\n  by rewrite !rmorphM/= !mulmxA !mulmx_ker !mul0mx !addsmx0 submx_refl.\nmove: cpq => /(congr1 (horner_mx g))/=; rewrite rmorph1 rmorphD/=.\nrewrite -[X in (X <= _)%MS]mulr1 => <-; rewrite mulrDr [p * u]mulrC addrC.\nrewrite addmx_sub_adds//; apply/sub_kermxP; rewrite mulmxE -mulrA -rmorphM.\n  by rewrite mulrAC [q * p]mulrC rmorphM/= mulrA -!mulmxE mulmx_ker mul0mx.\nrewrite -[_ * _ * q]mulrA [u * _]mulrC.\nby rewrite rmorphM mulrA -!mulmxE mulmx_ker mul0mx.\nQed."
}
{
  "statement": "Lemma eqp_rgcd_gcd p q : rgcdp p q %= gcdp p q.\n",
  "proof": "Proof.\nmove: {2}(minn (size p) (size q)) (leqnn (minn (size p) (size q))) => n.\nelim: n p q => [p q|n ihn p q hs].\n  rewrite leqn0; case: ltnP => _; rewrite size_poly_eq0; move/eqP->.\n    by rewrite gcd0p rgcd0p eqpxx.\n  by rewrite gcdp0 rgcdp0 eqpxx.\nhave [-> | pn0] := eqVneq p 0; first by rewrite gcd0p rgcd0p eqpxx.\nhave [-> | qn0] := eqVneq q 0; first by rewrite gcdp0 rgcdp0 eqpxx.\nrewrite gcdpE rgcdpE; case: ltnP hs => sp hs.\n  have e := eqp_rmod_mod q p; apply/eqp_trans/ihn: (eqp_gcdl p e).\n  by rewrite (eqp_size e) geq_min -ltnS (leq_trans _ hs) ?ltn_modp.\nhave e := eqp_rmod_mod p q; apply/eqp_trans/ihn: (eqp_gcdl q e).\nby rewrite (eqp_size e) geq_min -ltnS (leq_trans _ hs) ?ltn_modp.\nQed."
}
{
  "statement": "Lemma morph_gact_irr A M :\n    A \\subset D1 -> M \\subset R1 ->\n  acts_irreducibly (f @* A) (h @* M) to2 = acts_irreducibly A M to1.\n",
  "proof": "Proof.\nmove=> sAD1 sMR1.\nhave [[injf defD2] [injh defR2]] := (isomP iso_f, isomP iso_h).\nhave h_eq1 := morphim_injm_eq1 injh.\napply/mingroupP/mingroupP=> [] [/andP[ntM actAM] minM].\n  split=> [|U]; first by rewrite -h_eq1 // ntM -(injmSK injf) ?morph_gastabs.\n  case/andP=> ntU acts_fAU sUM; have sUR1 := subset_trans sUM sMR1.\n  apply: (injm_morphim_inj injh) => //; apply: minM; last exact: morphimS.\n  by rewrite h_eq1 // ntU -morph_gastabs ?morphimS.\nsplit=> [|U]; first by rewrite h_eq1 // ntM -morph_gastabs ?morphimS.\ncase/andP=> ntU acts_fAU sUhM.\nhave sUhR1 := subset_trans sUhM (morphimS h sMR1).\nhave sU'M: h @*^-1 U \\subset M by rewrite sub_morphpre_injm.\nrewrite /= -(minM _ _ sU'M) ?morphpreK // -h_eq1 ?subsetIl // -(injmSK injf) //.\nby rewrite morph_gastabs ?(subset_trans sU'M) // morphpreK ?ntU.\nQed."
}
{
  "statement": "Lemma pgroup_fix_mod (p : nat) (G : {group aT}) (S : {set sT}) :\n  p.-group G -> [acts G, on S | to] -> #|S| = #|'Fix_(S | to)(G)| %[mod p].\n",
  "proof": "Proof.\nmove=> pG nSG; have sGD: G \\subset D := acts_dom nSG.\napply/eqP; rewrite -(cardsID 'Fix_to(G)) eqn_mod_dvd (leq_addr, addKn) //.\nhave: [acts G, on S :\\: 'Fix_to(G) | to]; last move/acts_sum_card_orbit <-.\n  rewrite actsD // -(setIidPr sGD); apply: subset_trans (acts_subnorm_fix _ _).\n  by rewrite setIS ?normG.\napply: dvdn_sum => _ /imsetP[x /setDP[_ nfx] ->].\nhave [k oGx]: {k | #|orbit to G x| = (p ^ k)%N}.\n  by apply: p_natP; apply: pnat_dvd pG; rewrite card_orbit_in ?dvdn_indexg.\ncase: k oGx => [/card_orbit1 fix_x | k ->]; last by rewrite expnS dvdn_mulr.\nby case/afixP: nfx => a Ga; apply/set1P; rewrite -fix_x mem_orbit.\nQed."
}
{
  "statement": "Lemma Ohm_p_cycle p x :\n  p.-elt x -> 'Ohm_n(<[x]>) = <[x ^+ (p ^ (logn p #[x] - n))]>.\n",
  "proof": "Proof.\nmove=> p_x; apply/eqP; rewrite (OhmE p_x) eqEsubset cycle_subG mem_gen.\n  rewrite gen_subG andbT; apply/subsetP=> y /LdivP[x_y ypn].\n  case: (leqP (logn p #[x]) n) => [|lt_n_x].\n    by rewrite -subn_eq0 => /eqP->.\n  have p_pr: prime p by move: lt_n_x; rewrite lognE; case: (prime p).\n  have def_y: <[y]> = <[x ^+ (#[x] %/ #[y])]>.\n    apply: congr_group; apply/set1P.\n    by rewrite -cycle_sub_group ?cardSg ?inE ?cycle_subG ?x_y /=.\n  rewrite -cycle_subG def_y cycle_subG -{1}(part_pnat_id p_x) p_part.\n  rewrite -{1}(subnK (ltnW lt_n_x)) expnD -muln_divA ?order_dvdn ?ypn //.\n  by rewrite expgM mem_cycle.\nrewrite !inE mem_cycle -expgM -expnD addnC -maxnE -order_dvdn.\nby rewrite -{1}(part_pnat_id p_x) p_part dvdn_exp2l ?leq_maxr.\nQed."
}
{
  "statement": "Lemma homocyclic_Ohm_Mho n p G :\n  p.-group G -> homocyclic G -> 'Ohm_n(G) = 'Mho^(logn p (exponent G) - n)(G).\n",
  "proof": "Proof.\nmove=> pG /andP[cGG homoG]; set e := exponent G.\nhave{pG} p_e: p.-nat e by apply: pnat_dvd pG; apply: exponent_dvdn.\nhave{homoG}: all (pred1 e) (abelian_type G).\n  move: homoG; rewrite /abelian_type -(prednK (cardG_gt0 G)) /=.\n  by case: (_ && _) (tag _); rewrite //= genGid eqxx.\nhave{cGG} [b defG <-] := abelian_structure cGG.\nmove: e => e in p_e *; elim: b => /= [|x b IHb] in G defG *.\n  by rewrite -defG big_nil (trivgP (Ohm_sub _ _)) (trivgP (Mho_sub _ _)).\ncase/andP=> /eqP ox e_b; rewrite big_cons in defG.\nrewrite -(Ohm_dprod _ defG) -(Mho_dprod _ defG).\ncase/dprodP: defG => [[_ H _ defH] _ _ _]; rewrite defH IHb //; congr (_ \\x _).\nby rewrite -ox in p_e *; rewrite (Ohm_p_cycle _ p_e) (Mho_p_cycle _ p_e).\nQed."
}
{
  "statement": "Lemma min_subfx_vect : Vector.axiom (size p).-1 subFExtend.\n",
  "proof": "Proof.\nmove/subfx_irreducibleP: irr_p => /=/(_ nz_p) min_p; set d := (size p).-1.\nhave Dd: d.+1 = size p by rewrite polySpred.\npose Fz2v x : 'rV_d := poly_rV (sval (sig_eqW (subfxE x)) %% p).\npose vFz : 'rV_d -> subFExtend := subfx_eval \\o rVpoly.\nhave FLinj: injective subfx_inj by apply: fmorph_inj.\nhave Fz2vK: cancel Fz2v vFz.\n  move=> x; rewrite /vFz /Fz2v; case: (sig_eqW _) => /= q ->.\n  apply: FLinj; rewrite !subfx_inj_eval // {2}(divp_eq q p) rmorphD rmorphM /=.\n  by rewrite !hornerE (eqP pz0) mulr0 add0r poly_rV_K // -ltnS Dd ltn_modpN0.\nsuffices vFzK: cancel vFz Fz2v.\n  by exists Fz2v; [apply: can2_linear Fz2vK | exists vFz].\napply: inj_can_sym Fz2vK _ => v1 v2 /(congr1 subfx_inj)/eqP.\nrewrite -subr_eq0 -!raddfB /= subfx_inj_eval // => /min_p/implyP.\nrewrite leqNgt implybNN -Dd ltnS size_poly linearB subr_eq0 /=.\nby move/eqP/(can_inj rVpolyK).\nQed."
}
{
  "statement": "Lemma mxtrace_component U (simU : mxsimple rG U) :\n   let V := component_mx rG U in\n   let modV := component_mx_module rG U in let modU := mxsimple_module simU in\n  {in G, forall x, \\tr (sr modV x) = \\tr (sr modU x) *+ (\\rank V %/ \\rank U)}.\n",
  "proof": "Proof.\nmove=> V modV modU x Gx.\nhave [I W S simW defV dxV] := component_mx_semisimple simU.\nrewrite -(mxtrace_dsum_mod (fun i => mxsimple_module (simW i)) modV defV) //.\nhave rankU_gt0: \\rank U > 0 by rewrite lt0n mxrank_eq0; case simU.\nhave isoW i: mx_iso rG U (W i).\n  by apply: component_mx_iso; rewrite ?simU // -defV (sumsmx_sup i).\nhave ->: (\\rank V %/ \\rank U)%N = #|I|.\n  symmetry; rewrite -(mulnK #|I| rankU_gt0); congr (_ %/ _)%N.\n  rewrite -defV (mxdirectP dxV) /= -sum_nat_const.\n  by apply: eq_bigr => i _; apply: mxrank_iso.\nrewrite -sumr_const; apply: eq_bigr => i _; symmetry.\nby apply: mxtrace_rsim Gx; apply/mx_rsim_iso; apply: isoW.\nQed."
}
{
  "statement": "Lemma submx_rowval_gen m1 m2 (U : 'M_(m1, n)) (V : 'M_(m2, nA)) :\n  (U <= rowval_gen V)%MS = (in_gen U <= V)%MS.\n",
  "proof": "Proof.\nrewrite genmxE; apply/idP/idP=> sUV.\n  apply: submx_trans (submx_in_gen sUV) _.\n  apply/row_subP; case/mxvec_indexP=> i k; rewrite -in_gen_row rowK mxvecE mxE.\n  rewrite -mxval_grootXn -val_gen_row -val_genZ val_genK scalemx_sub //.\n  exact: row_sub.\nrewrite -[U]in_genK; case/submxP: sUV => u ->{U}.\napply/row_subP=> i0; rewrite -val_gen_row row_mul; move: {i0 u}(row _ u) => u.\nrewrite mulmx_sum_row val_gen_sum summx_sub // => i _.\nrewrite val_genZ [mxval _]horner_rVpoly [_ *m Ad]mulmx_sum_row.\nrewrite !linear_sum summx_sub // => k _.\nrewrite 2!linearZ scalemx_sub {u}//= rowK mxvecK val_gen_row.\nby apply: (eq_row_sub (mxvec_index i k)); rewrite rowK mxvecE mxE.\nQed."
}
{
  "statement": "Lemma inertia_bigdprod phi (Phi := cfBigdprod defG phi) :\n  Phi 1%g != 0 -> 'I_L[Phi] = L :&: \\bigcap_(i | P i) 'I_L[phi i].\n",
  "proof": "Proof.\nmove=> nz_Phi; apply/eqP; rewrite eqEsubset; apply/andP; split.\n  rewrite subsetI Inertia_sub; apply/bigcapsP=> i Pi.\n  have [] := cfBigdprodK nz_Phi Pi; move: (_ / _) => a nz_a <-.\n  by rewrite inertia_scale_nz ?sub_inertia_Res //= ?nAL.\nrewrite subsetI subsetIl; apply: subset_trans (inertia_prod _ _ _).\napply: setISS.\n  by rewrite -(bigdprodWY defG) norms_gen ?norms_bigcup //; apply/bigcapsP.\napply/bigcapsP=> i Pi; rewrite (bigcap_min i) //.\nby rewrite -inertia_bigdprodi ?subsetIr.\nQed."
}
{
  "statement": "Lemma nilpotent_sub_norm G H :\n  nilpotent G -> H \\subset G -> 'N_G(H) \\subset H -> G :=: H.\n",
  "proof": "Proof.\nmove=> nilG sHG sNH; apply/eqP; rewrite eqEsubset sHG andbT; apply/negP=> nsGH.\nhave{nsGH} [i sZH []]: exists2 i, 'Z_i(G) \\subset H & ~ 'Z_i.+1(G) \\subset H.\n  case/ucnP: nilG => n ZnG; rewrite -{}ZnG in nsGH.\n  elim: n => [|i IHi] in nsGH *; first by rewrite sub1G in nsGH.\n  by case sZH: ('Z_i(G) \\subset H); [exists i | apply: IHi; rewrite sZH].\napply: subset_trans sNH; rewrite subsetI ucn_sub -commg_subr.\nby apply: subset_trans sZH; apply: subset_trans (ucn_comm i G); apply: commgS.\nQed."
}
{
  "statement": "Lemma gal_conjg K E x : 'Gal(E / K) :^ x = 'Gal(E / x @: K).\n",
  "proof": "Proof.\nwithout loss sKE: K / (K <= E)%VS.\n  move=> IH_K; rewrite gal_cap {}IH_K ?capvSr //.\n  transitivity 'Gal(E / x @: K :&: x @: E); last by rewrite limg_gal -gal_cap.\n  congr 'Gal(E / _); apply/eqP; rewrite eqEsubv limg_cap; apply/subvP=> a.\n  rewrite memv_cap => /andP[/memv_imgP[b Kb ->] /memv_imgP[c Ec] eq_bc].\n  by rewrite memv_img // memv_cap Kb (lker0P (AEnd_lker0 _) _ _ eq_bc).\nwlog suffices IHx: x K sKE / 'Gal(E / K) :^ x \\subset 'Gal(E / x @: K).\n  apply/eqP; rewrite eqEsubset IHx // -sub_conjgV (subset_trans (IHx _ _ _)) //.\n    by apply/subvP=> _ /memv_imgP[a Ka ->]; rewrite memv_gal ?(subvP sKE).\n  rewrite -limg_comp (etrans (eq_in_limg _) (lim1g _)) // => a /(subvP sKE)Ka.\n  by rewrite !(@lfunE _ _ L) /= -galM // mulgV gal_id.\napply/subsetP=> _ /imsetP[y galEy ->]; rewrite gal_cap gal_kHom ?capvSr //=.\napply/kAHomP=> _ /memv_capP[/memv_imgP[a Ka ->] _]; have Ea := subvP sKE a Ka.\nby rewrite -galM // -conjgC galM // (fixed_gal sKE galEy).\nQed."
}
{
  "statement": "Lemma agenvEl U : agenv U = (1 + U * agenv U)%VS.\n",
  "proof": "Proof.\npose f V := (1 + U * V)%VS; rewrite -/(f _); pose n := \\dim {:aT}.\nhave ->: agenv U = iter n f 0%VS.\n  rewrite /agenv -/n; elim: n => [|n IHn]; first by rewrite big_ord0.\n  rewrite big_ord_recl /= -{}IHn; congr (1 + _)%VS; rewrite big_distrr /=.\n  by apply: eq_bigr => i; rewrite expvSl.\nhave fS i j: i <= j -> (iter i f 0 <= iter j f 0)%VS.\n  by elim: i j => [|i IHi] [|j] leij; rewrite ?sub0v //= addvS ?prodvSr ?IHi.\nsuffices /(@trajectP _ f _ n.+1)[i le_i_n Dfi]: looping f 0%VS n.+1.\n  by apply/eqP; rewrite eqEsubv -iterS fS // Dfi fS.\napply: contraLR (dimvS (subvf (iter n.+1 f 0%VS))); rewrite -/n -ltnNge.\nrewrite -looping_uniq; elim: n.+1 => // i IHi; rewrite trajectSr rcons_uniq.\nrewrite {1}trajectSr mem_rcons inE negb_or eq_sym eqEdim fS ?leqW // -ltnNge.\nby rewrite -andbA => /and3P[lt_fi _ /IHi/leq_ltn_trans->].\nQed."
}
{
  "statement": "Lemma cyclic_pgroup_dprod_trivg p A B C :\n    p.-group C -> cyclic C -> A \\x B = C ->\n  A = 1 /\\ B = C \\/ B = 1 /\\ A = C.\n",
  "proof": "Proof.\nmove=> pC cycC; case/cyclicP: cycC pC => x ->{C} pC defC.\ncase/dprodP: defC => [] [G H -> ->{A B}] defC _ tiGH; rewrite -defC.\nhave [/trivgP | ntC] := eqVneq <[x]> 1.\n  by rewrite -defC mulG_subG => /andP[/trivgP-> _]; rewrite mul1g; left.\nhave [pr_p _ _] := pgroup_pdiv pC ntC; pose K := 'Ohm_1(<[x]>).\nhave prK : prime #|K| by rewrite (Ohm1_cyclic_pgroup_prime _ pC) ?cycle_cyclic.\ncase: (prime_subgroupVti G prK) => [sKG |]; last first.\n  move/TI_Ohm1; rewrite -defC (setIidPl (mulG_subl _ _)) => ->.\n  by left; rewrite mul1g.\ncase: (prime_subgroupVti H prK) => [sKH |]; last first.\n  move/TI_Ohm1; rewrite -defC (setIidPl (mulG_subr _ _)) => ->.\n  by right; rewrite mulg1.\nhave K1: K :=: 1 by apply/trivgP; rewrite -tiGH subsetI sKG.\nby rewrite K1 cards1 in prK.\nQed."
}
{
  "statement": "Lemma cfMorph_charE chi :\n  G \\subset D -> (cfMorph chi \\is a character) = (chi \\is a character).\n",
  "proof": "Proof.\nmove=> sGD; apply/idP/idP=> [/char_reprP[[n rG] /=Dfchi] | /cfMorph_char//].\npose H := 'ker_G f; have kerH: H \\subset rker rG.\n  by rewrite -cfker_repr -Dfchi cfker_morph // setIS // ker_sub_pre.\nhave nHG: G \\subset 'N(H) by rewrite normsI // (subset_trans sGD) ?ker_norm.\nhave [h injh im_h] := first_isom_loc f sGD; rewrite -/H in h injh im_h.\nhave DfG: invm injh @*^-1 (G / H) == (f @* G)%g by rewrite morphpre_invm im_h.\npose rfG := eqg_repr (morphpre_repr _ (quo_repr kerH nHG)) DfG.\napply/char_reprP; exists (Representation rfG).\napply/cfun_inP=> _ /morphimP[x Dx Gx ->]; rewrite -cfMorphE // Dfchi !cfunE Gx.\npose xH := coset H x; have GxH: xH \\in (G / H)%g by apply: mem_quotient.\nsuffices Dfx: f x = h xH by rewrite mem_morphim //= Dfx invmE ?quo_repr_coset.\nby apply/set1_inj; rewrite -?morphim_set1 ?im_h ?(subsetP nHG) ?sub1set.\nQed."
}
{
  "statement": "Lemma cfBigdprod_eq1 phi :\n    (forall i, P i -> phi i \\is a character) ->\n  (cfBigdprod defG phi == 1) = [forall (i | P i), phi i == 1].\n",
  "proof": "Proof.\nmove=> Nphi; set Phi := cfBigdprod defG phi.\napply/eqP/eqfun_inP=> [Phi1 i Pi | phi1]; last first.\n  by apply: big1 => i /phi1->; rewrite rmorph1.\nhave Phi1_1: Phi 1%g = 1 by rewrite Phi1 cfun1E group1.\nhave nz_Phi1: Phi 1%g != 0 by rewrite Phi1_1 oner_eq0.\nhave [_ <-] := cfBigdprodK nz_Phi1 Pi.\nrewrite Phi1_1 divr1 -/Phi Phi1 rmorph1.\nrewrite prod_cfunE // in Phi1_1; have := natr_prod_eq1 _ Phi1_1 Pi.\nrewrite -(cfRes1 (A i)) cfBigdprodiK // => ->; first by rewrite scale1r.\nby move=> {i Pi} j /Nphi Nphi_j; rewrite Cnat_char1 ?cfBigdprodi_char.\nQed."
}
{
  "statement": "Lemma reindex_omap (I J : finType) (h : J -> I) h' (P : pred I) F :\n    (forall i, P i -> omap h (h' i) = some i) ->\n  \\big[op/x]_(i | P i) F i =\n    \\big[op/x]_(j | P (h j) && (h' (h j) == some j)) F (h j).\n",
  "proof": "Proof.\nmove=> h'K; have [n lePn] := ubnP #|P|; elim: n => // n IHn in P h'K lePn *.\ncase: (pickP P) => [i Pi | P0]; last first.\n  by rewrite !big_pred0 // => j; rewrite P0.\nhave := h'K i Pi; case h'i_eq : (h' i) => [/= j|//] [hj_eq].\nrewrite (bigD1 i Pi) (bigD1 j) hj_eq ?Pi ?h'i_eq ?eqxx //=; congr (op : _ -> _).\nrewrite {}IHn => [|k /andP[]|]; [|by auto | by rewrite (cardD1x i) in lePn].\napply: eq_bigl => k; rewrite andbC -andbA (andbCA (P _)); case: eqP => //= hK.\ncongr (_ && ~~ _); apply/eqP/eqP => [|->//].\nby move=> /(congr1 h'); rewrite h'i_eq hK => -[].\nQed."
}
{
  "statement": "Lemma mem_permutations s t : (t \\in permutations s) = perm_eq t s.\n",
  "proof": "Proof.\nhave{s} [n [bs [-> Dn /permPr<- _]]] := permsP s.\nelim: n => [|n IHn] /= in t bs Dn *.\n  by rewrite inE (nilP Dn); apply/eqP/perm_nilP.\nrewrite -[bs in tseq bs]cats0 in Dn *; have x0 : T by case: (tseq _) Dn.\nrewrite -[RHS](@andb_idl (last x0 t \\in tseq bs)); last first.\n  case/lastP: t {IHn} => [|t x] Dt; first by rewrite -(perm_size Dt) in Dn.\n  by rewrite -[bs]cats0 -(perm_mem Dt) last_rcons mem_rcons mem_head.\nelim: bs [::] => [|[x [|m]] bs IHbs] //= bs2 in Dn *.\nrewrite cons_permsE -!cat_cons !mem_cat (mem_nseq m.+1) orbC andb_orl.\nrewrite {}IHbs ?(perm_size (perm_tseq bsCA)) //= (permPr (perm_tseq bsCA)).\ncongr (_ || _); apply/mapP/andP=> [[t1 Dt1 ->] | [/eqP]].\n  by rewrite last_rcons perm_rcons perm_cons IHn in Dt1 *.\ncase/lastP: t => [_ /perm_size//|t y]; rewrite last_rcons perm_rcons => ->.\nby rewrite perm_cons; exists t; rewrite ?IHn.\nQed."
}
{
  "statement": "Lemma rootC_lt0 n x : (1 < n)%N -> (n.-root x < 0) = false.\n",
  "proof": "Proof.\nset y := n.-root x => n_gt1; have n_gt0 := ltnW n_gt1.\napply: negbTE; apply: wlog_neg => /negbNE lt0y; rewrite le_gtF //.\nhave Rx: x \\is real by rewrite -[x](rootCK n_gt0) rpredX // ltr0_real.\nhave Re_y: 'Re y = y by apply/Creal_ReP; rewrite ltr0_real.\nhave [z zn_x leR0z]: exists2 z, z ^+ n = x & 'Re z >= 0.\n  have [w wn1 ltRw0] := neg_unity_root n_gt1.\n  exists (w * y); first by rewrite exprMn wn1 mul1r rootCK.\n  by rewrite ReMr ?ltr0_real // ltW // nmulr_lgt0.\nwithout loss leI0z: z zn_x leR0z / 'Im z >= 0.\n  move=> IHz; have: 'Im z \\is real by [].\n  case/real_ge0P=> [|/ltW leIz0]; first exact: IHz.\n  apply: (IHz z^* ); rewrite ?Re_conj ?Im_conj ?oppr_ge0 //.\n  by rewrite -rmorphXn /= zn_x conj_Creal.\nby apply: le_trans leR0z _; rewrite -Re_y ?rootC_Re_max ?ltr0_real.\nQed."
}
{
  "statement": "Lemma dinjectivePn D :\n  reflect (exists2 x, x \\in D & exists2 y, y \\in [predD1 D & x] & f x = f y)\n          (~~ dinjectiveb D).\n",
  "proof": "Proof.\napply: (iffP idP) => [injf | [x Dx [y Dxy eqfxy]]]; last first.\n  move: Dx; rewrite -(mem_enum D) => /rot_to[i E defE].\n  rewrite /dinjectiveb -(rot_uniq i) -map_rot defE /=; apply/nandP; left.\n  rewrite inE /= -(mem_enum D) -(mem_rot i) defE inE in Dxy.\n  rewrite andb_orr andbC andbN in Dxy.\n  by rewrite eqfxy map_f //; case/andP: Dxy.\npose p := [pred x in D | [exists (y | y \\in [predD1 D & x]), f x == f y]].\ncase: (pickP p) => [x /= /andP[Dx /exists_inP[y Dxy /eqP eqfxy]] | no_p].\n  by exists x; last exists y.\nrewrite /dinjectiveb map_inj_in_uniq ?enum_uniq // in injf => x y Dx Dy eqfxy.\napply: contraNeq (negbT (no_p x)) => ne_xy /=; rewrite -mem_enum Dx.\nby apply/existsP; exists y; rewrite /= !inE eq_sym ne_xy -mem_enum Dy eqfxy /=.\nQed."
}
{
  "statement": "Lemma divzMDl q m d : d != 0 -> ((q * d + m) %/ d)%Z = q + (m %/ d)%Z.\n",
  "proof": "Proof.\nrewrite neq_lt -oppr_gt0 => nz_d.\nwlog{nz_d} d_gt0: q d / d > 0; last case: d => // d in d_gt0 *.\n  move=> IH; case/orP: nz_d => /IH// /(_  (- q)).\n  by rewrite mulrNN !divzN -opprD => /oppr_inj.\nwlog q_gt0: q m / q >= 0; last case: q q_gt0 => // q _.\n  move=> IH; case: q => n; first exact: IH; rewrite NegzE mulNr.\n  by apply: canRL (addKr _) _; rewrite -IH ?addNKr.\ncase: m => n; first by rewrite !divz_nat divnMDl.\nhave [le_qd_n | lt_qd_n] := leqP (q * d) n.\n  rewrite divNz_nat // NegzE -(subnKC le_qd_n) divnMDl //.\n  by rewrite -!addnS !PoszD !opprD !addNKr divNz_nat.\nrewrite divNz_nat // NegzE -PoszM subzn // divz_nat.\napply: canRL (addrK _) _; congr _%:Z; rewrite addnC -divnMDl // mulSnr.\nrewrite -{3}(subnKC (ltn_pmod n d_gt0)) addnA addnS -divn_eq addnAC.\nby rewrite subnKC // divnMDl // divn_small ?addn0 // subnSK ?ltn_mod ?leq_subr.\nQed."
}
{
  "statement": "Lemma group_closure_field_exists gT F :\n  classically {Fs : fieldType & {rmorphism F -> Fs}\n                              & group_closure_field Fs gT}.\n",
  "proof": "Proof.\nset n := #|{group gT}|.\nsuffices: classically {Fs : fieldType & {rmorphism F -> Fs}\n   & forall G : {group gT}, enum_rank G < n -> group_splitting_field Fs G}.\n- apply: classic_bind => [[Fs f splitFs]] _ -> //.\n  by exists Fs => // G; apply: splitFs.\nelim: (n) => [|i IHi]; first by move=> _ -> //; exists F => //; exists id.\napply: classic_bind IHi => [[F' f splitF']].\nhave [le_n_i _ -> // | lt_i_n] := leqP n i.\n  by exists F' => // G _; apply: splitF'; apply: leq_trans le_n_i.\nhave:= @group_splitting_field_exists _ (enum_val (Ordinal lt_i_n)) F'.\napply: classic_bind => [[Fs f' splitFs]] _ -> //.\nexists Fs => [|G]; first exact: (f' \\o f).\nrewrite ltnS leq_eqVlt -{1}[i]/(val (Ordinal lt_i_n)) val_eqE.\ncase/predU1P=> [defG | ltGi]; first by rewrite -[G]enum_rankK defG.\nby apply: (extend_group_splitting_field f'); apply: splitF'.\nQed."
}
{
  "statement": "Lemma minPoly_irr p :\n  p \\is a polyOver K -> p %| minPoly K x -> (p %= minPoly K x) || (p %= 1).\n",
  "proof": "Proof.\nrewrite dvdp_eq; set q := _ %/ _ => Kp def_pq.\nhave Kq: q \\is a polyOver K by rewrite divp_polyOver // minPolyOver.\nmove: q Kq def_pq root_minPoly (size_minPoly K x) => q Kq /eqP->.\nrewrite rootM => pqx0 szpq.\nhave [nzq nzp]: q != 0 /\\ p != 0.\n  by apply/norP; rewrite -mulf_eq0 -size_poly_eq0 szpq.\nwithout loss{pqx0} qx0: q p Kp Kq nzp nzq szpq / root q x.\n  move=> IH; case/orP: pqx0 => /IH{}IH; first exact: IH.\n  have{IH} /orP[]: (q %= p * q) || (q %= 1) by apply: IH => //; rewrite mulrC.\n    by rewrite orbC -{1}[q]mul1r eqp_mul2r // eqp_sym => ->.\n  by rewrite -{1}[p]mul1r eqp_sym eqp_mul2r // => ->.\napply/orP; right; rewrite -size_poly_eq1 eqn_leq lt0n size_poly_eq0 nzp andbT.\nrewrite -(leq_add2r (size q)) -leq_subLR subn1 -size_mul // mulrC szpq.\nby rewrite ltnNge; apply: contra nzq => /(root_small_adjoin_poly Kq) <-.\nQed."
}
{
  "statement": "Lemma fcard_order_set n (a : {pred T}) :\n  a \\subset order_set n -> fclosed f a -> fcard f a * n = #|a|.\n",
  "proof": "Proof.\nmove=> a_n cl_a; rewrite /n_comp_mem; set b := [predI froots f & a].\nsuff <-: #|preim (froot f) b| = #|b| * n.\n  apply: eq_card => x; rewrite !inE (roots_root fconnect_sym).\n  exact/esym/(closed_connect cl_a)/connect_root.\nhave{cl_a a_n} (x): b x -> froot f x = x /\\ order x = n.\n  by case/andP=> /eqP-> /(subsetP a_n)/eqnP->.\nelim: {a b}#|b| {1 3 4}b (eqxx #|b|) => [|m IHm] b def_m f_b.\n  by rewrite eq_card0 // => x; apply: (pred0P def_m).\nhave [x b_x | b0] := pickP b; last by rewrite (eq_card0 b0) in def_m.\nhave [r_x ox_n] := f_b x b_x; rewrite (cardD1 x) [x \\in b]b_x eqSS in def_m.\nrewrite mulSn -{1}ox_n -(IHm _ def_m) => [|_ /andP[_ /f_b //]].\nrewrite -(cardID (fconnect f x)); congr (_ + _); apply: eq_card => y.\n  by apply: andb_idl => /= fxy; rewrite !inE -(rootP symf fxy) r_x.\nby congr (~~ _ && _); rewrite /= /in_mem /= symf -(root_connect symf) r_x.\nQed."
}
{
  "statement": "Lemma mxnonsimpleP U :\n  U != 0 -> reflect (mxnonsimple rG U) (mxnonsimple_sat U).\n",
  "proof": "Proof.\nrewrite /mxnonsimple_sat {1}/mxnonsimple_form; set Vt := vec_mx _ => /= nzU.\npose nsim V := [&& mxmodule rG V, (V <= U)%MS, V != 0 & \\rank V < \\rank U].\nset nsimUt := (_ /\\ _)%T; have: qf_form nsimUt.\n  by rewrite /= mxmodule_form_qf !mxrank_form_qf !submx_form_qf.\nmove/GRing.qf_evalP; set qev := @GRing.qf_eval _ => qevP.\nhave qev_nsim u: qev (row_env [:: u]) nsimUt = nsim n (vec_mx u).\n  rewrite /nsim -mxrank_eq0 /qev /= eval_mxmodule eval_mxrank.\n  rewrite !eval_submx eval_mx_term eval_vec_mx eval_row_var /=.\n  do 2!bool_congr; apply: andb_id2l => sUV.\n  by rewrite ltn_neqAle andbC !mxrank_leqif_sup.\nhave n2gt0: n ^ 2 > 0.\n  by move: nzU; rewrite muln_gt0 -mxrank_eq0 unlock; case: posnP (U) => // ->.\napply: (iffP satP) => [|[V nsimV]].\n  by case/Exists_rowP=> // v; move/qevP; rewrite qev_nsim; exists (vec_mx v).\napply/Exists_rowP=> //; exists (mxvec V); apply/qevP.\nby rewrite qev_nsim mxvecK.\nQed."
}
{
  "statement": "Lemma gal_independent_contra E (P : pred (gal_of E)) (c_ : gal_of E -> L) x :\n    P x -> c_ x != 0 ->\n  exists2 a, a \\in E & \\sum_(y | P y) c_ y * y a != 0.\n",
  "proof": "Proof.\nhave [n] := ubnP #|P|; elim: n c_ x P => // n IHn c_ x P lePn Px nz_cx.\nrewrite ltnS (cardD1x Px) in lePn; move/IHn: lePn => {n IHn}/=IH_P.\nhave [/eqfun_inP c_Px'_0 | ] := boolP [forall (y | P y && (y != x)), c_ y == 0].\n  exists 1; rewrite ?mem1v // (bigD1 x Px) /= rmorph1 mulr1.\n  by rewrite big1 ?addr0 // => y /c_Px'_0->; rewrite mul0r.\ncase/forall_inPn => y Px'y nz_cy.\nhave [Py /gal_eqP/eqlfun_inP/subvPn[a Ea]] := andP Px'y.\nrewrite memv_ker !lfun_simp => nz_yxa; pose d_ y := c_ y * (y a - x a).\nhave /IH_P[//|b Eb nz_sumb]: d_ y != 0 by rewrite mulf_neq0.\nhave [sumb_0|] := eqVneq (\\sum_(z | P z) c_ z * z b) 0; last by exists b.\nexists (a * b); first exact: rpredM.\nrewrite -subr_eq0 -[z in _ - z](mulr0 (x a)) -[in z in _ - z]sumb_0.\nrewrite mulr_sumr -sumrB (bigD1 x Px) rmorphM /= mulrCA subrr add0r.\ncongr (_ != 0): nz_sumb; apply: eq_bigr => z _.\nby rewrite mulrCA rmorphM -mulrBr -mulrBl mulrA.\nQed."
}
{
  "statement": "Lemma Ohm_dprod A B G : A \\x B = G -> 'Ohm_n(A) \\x 'Ohm_n(B) = 'Ohm_n(G).\n",
  "proof": "Proof.\ncase/dprodP => [[H K -> ->{A B}]] <- cHK tiHK.\nrewrite dprodEY //; last first.\n- by apply/trivgP; rewrite -tiHK setISS ?Ohm_sub.\n- by rewrite (subset_trans (subset_trans _ cHK)) ?centS ?Ohm_sub.\napply/eqP; rewrite -(cent_joinEr cHK) eqEsubset join_subG /=.\nrewrite !OhmS ?joing_subl ?joing_subr //= cent_joinEr //= -genM_join genS //.\napply/subsetP=> _ /setIdP[/imset2P[x y Hx Ky ->] /OhmPredP[p p_pr /eqP]].\nhave cxy: commute x y by red; rewrite -(centsP cHK).\nrewrite ?expgMn // -eq_invg_mul => /eqP def_x.\nhave ypn1: y ^+ (p ^ n) = 1.\n  by apply/set1P; rewrite -[[set 1]]tiHK inE -{1}def_x groupV !groupX.\nhave xpn1: x ^+ (p ^ n) = 1 by rewrite -[x ^+ _]invgK def_x ypn1 invg1.\nby rewrite mem_mulg ?mem_gen // inE (Hx, Ky); apply/OhmPredP; exists p.\nQed."
}
{
  "statement": "Lemma mx_JordanHolder_max U (m := size U) V compU modV :\n    (last 0 U :=: 1%:M)%MS -> mx_irreducible (@factmod_repr _ G n rG V modV) ->\n  exists i : 'I_m, mx_rsim (factmod_repr modV) (@series_repr U i compU).\n",
  "proof": "Proof.\nrewrite {}/m; set Um := last 0 U => Um1 irrV.\nhave modUm: modG Um := last_mod compU; have simV := rsimC (mx_factmod_sub modV).\nhave maxV: max_submod V Um.\n  move/max_submodP: (mx_rsim_irr simV irrV) => /(_ (submx1 _)).\n  by apply: max_submod_eqmx; last apply: eqmx_sym.\nhave [W compW lastW] := mx_JordanHolder_exists compU modV maxV.\nhave compWU: mx_series (rcons W Um) by apply/mx_series_rcons; rewrite lastW.\nhave:= mx_JordanHolder compU compWU; rewrite last_rcons size_rcons.\ncase=> // szW [p pUW]; have ltWU: size W < size U by rewrite szW.\npose i := Ordinal ltWU; exists ((p^-1)%g i).\napply: rsimT simV (rsimT _ (rsimC (pUW _))); rewrite permKV.\napply: rsimT (rsimC _) (rsim_last (last_mod compW) modUm _).\nby apply: section_eqmx; rewrite ?lastW.\nQed."
}
{
  "statement": "Lemma capmxA m1 m2 m3 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) (C : 'M_(m3, n)) :\n  (A :&: (B :&: C) = A :&: B :&: C)%MS.\n",
  "proof": "Proof.\nrewrite (capmxC A B) capmxC; wlog idA: m1 m3 A C / qidmx A.\n  move=> IH; case idA: (qidmx A); first exact: IH.\n  case idC: (qidmx C); first by rewrite -IH.\n  rewrite (@capmx_eq_norm n m3) ?qidmx_cap ?idA ?idC ?andbF //.\n  rewrite capmx_eq_norm ?qidmx_cap ?idA ?idC ?andbF //.\n  apply: capmx_norm_eq; first by rewrite !qidmx_cap andbAC.\n  by apply/andP; split; rewrite !sub_capmx andbAC -!sub_capmx.\nrewrite -!(capmxC A) [in @capmx _ m1]unlock idA capmx_nop_id.\nhave [eqBC|] := eqVneq (qidmx B) (qidmx C).\n  rewrite (@capmx_eq_norm n) ?capmx_nopP // capmx_eq_norm //.\n  by apply: capmx_norm_eq; rewrite ?qidmx_cap ?capmxS ?capmx_nopP.\nby rewrite !unlock capmx_nopP capmx_nop_id; do 2?case: (qidmx _) => //.\nQed."
}
{
  "statement": "Lemma extremum_inP : extremum_spec ord P F (extremum ord i0 P F).\n",
  "proof": "Proof.\nrewrite /extremum; case: pickP => [i /andP[Pi /'forall_implyP/= min_i] | no_i].\n  by split=> // j; apply/implyP.\npose TP := seq_sub [seq F i | i <- enum P].\nhave FPP (iP : {i | P i}) : F (proj1_sig iP) \\in [seq F i | i <- enum P].\n  by rewrite map_f// mem_enum; apply: valP.\npose FP := SeqSub (FPP _).\nhave []//= := @extremumP _ _ (relpre val ord) (exist P i0 Pi0) xpredT FP.\n- by move=> [/= _/mapP[i iP ->]]; apply: ord_refl; rewrite mem_enum in iP.\n- move=> [/= _/mapP[j jP ->]] [/= _/mapP[i iP ->]] [/= _/mapP[k kP ->]].\n  by apply: ord_trans; rewrite !mem_enum in iP jP kP.\n- move=> [/= _/mapP[i iP ->]] [/= _/mapP[j jP ->]].\n  by apply: ord_total; rewrite !mem_enum in iP jP.\n- rewrite /FP => -[/= i Pi] _ /(_ (exist _ _ _))/= ordF.\n  have /negP/negP/= := no_i i; rewrite Pi/= negb_forall => /existsP/sigW[j].\n  by rewrite negb_imply => /andP[Pj]; rewrite ordF.\nQed."
}
{
  "statement": "Lemma normC_sum_eq (I : finType) (P : pred I) (F : I -> C) :\n     `|\\sum_(i | P i) F i| = \\sum_(i | P i) `|F i| ->\n   {t : C | `|t| == 1 & forall i, P i -> F i = `|F i| * t}.\n",
  "proof": "Proof.\nhave [i /andP[Pi nzFi] | F0] := pickP [pred i | P i & F i != 0]; last first.\n  exists 1 => [|i Pi]; first by rewrite normr1.\n  by case/nandP: (F0 i) => [/negP[]// | /negbNE/eqP->]; rewrite normr0 mul0r.\nrewrite !(bigD1 i Pi) /= => norm_sumF; pose Q j := P j && (j != i).\nrewrite -normr_eq0 in nzFi; set c := F i / `|F i|; exists c => [|j Pj].\n  by rewrite normrM normfV normr_id divff.\nhave [Qj | /nandP[/negP[]// | /negbNE/eqP->]] := boolP (Q j); last first.\n  by rewrite mulrC divfK.\nhave: `|F i + F j| = `|F i| + `|F j|.\n  do [rewrite !(bigD1 j Qj) /=; set z := \\sum_(k | _) `|_|] in norm_sumF.\n  apply/eqP; rewrite eq_le ler_normD -(lerD2r z) -addrA -norm_sumF addrA.\n  by rewrite (le_trans (ler_normD _ _)) // lerD2l ler_norm_sum.\nby case/normCDeq=> k _ [/(canLR (mulKf nzFi)) <-]; rewrite -(mulrC (F i)).\nQed."
}
{
  "statement": "Lemma mx_butterfly U V W modU modV modW :\n    ~~ (U == V)%MS -> max_submod U W -> max_submod V W ->\n  let modUV := capmx_module modU modV in\n     max_submod (U :&: V)%MS U\n  /\\ mx_rsim (@section_repr V W modV modW) (@section_repr _ U modUV modU).\n",
  "proof": "Proof.\nmove=> neUV maxU maxV modUV; have{neUV maxU} defW: (U + V :=: W)%MS.\n  wlog{neUV modUV} ltUV: U V modU modV maxU maxV / ~~ (V <= U)%MS.\n    by case/nandP: neUV => ?; first rewrite addsmxC; apply.\n  apply/eqmxP/idPn=> neUVW; case: maxU => ltUW; case/(_ (U + V)%MS).\n  rewrite addsmx_module // ltmxE ltmxEneq neUVW addsmxSl !addsmx_sub.\n  by have [ltVW _] := maxV; rewrite submx_refl andbT ltUV !ltmxW.\nhave sUV_U := capmxSl U V; have sVW: (V <= W)%MS by rewrite -defW addsmxSr.\nset goal := mx_rsim _ _; suffices{maxV} simUV: goal.\n  split=> //; apply/(max_submodP modUV modU sUV_U).\n  by apply: mx_rsim_irr simUV _; apply/max_submodP.\napply: {goal}mx_rsim_sym.\nby apply: mx_rsim_trans (mx_second_rsim modU modV) _; apply: section_eqmx.\nQed."
}
{
  "statement": "Lemma holds_fsubst e f i v :\n  holds e (fsubst f (i, v%:T)%T) <-> holds (set_nth 0 e i v) f.\n",
  "proof": "Proof.\nelim: f e => //=; do [\n  by move=> *; rewrite !eval_tsubst\n| move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto\n| move=> f IHf e; move: (IHf e); tauto\n| move=> j f IHf e].\n- case eq_ji: (j == i); first rewrite (eqP eq_ji).\n    by split=> [] [x f_x]; exists x; rewrite set_set_nth eqxx in f_x *.\n  split=> [] [x f_x]; exists x; move: f_x; rewrite set_set_nth eq_sym eq_ji;\n     have:= IHf (set_nth 0 e j x); tauto.\ncase eq_ji: (j == i); first rewrite (eqP eq_ji).\n  by split=> [] f_ x; move: (f_ x); rewrite set_set_nth eqxx.\nsplit=> [] f_ x; move: (IHf (set_nth 0 e j x)) (f_ x);\n  by rewrite set_set_nth eq_sym eq_ji; tauto.\nQed."
}
{
  "statement": "Lemma coefPn_prod_XsubC (ps : seq R) : size ps != 0 ->\n  (\\prod_(p <- ps) ('X - p%:P))`_((size ps).-1) =\n  - \\sum_(p <- ps) p.\n",
  "proof": "Proof.\nrewrite coef_prod_XsubC ?leq_pred// => ps0.\nhave -> : (size ps - (size ps).-1 = 1)%N.\n  by move: ps0; case: (size ps) => // n _; exact: subSnn.\nrewrite expr1 mulN1r; congr GRing.opp.\nset f : 'I_(size ps) -> {set 'I_(size ps)} := fun a => [set a].\ntransitivity (\\sum_(I in imset f (mem setT)) \\prod_(i in I) ps`_i).\n  apply: congr_big => // I /=.\n  by apply/cards1P/imsetP => [[a ->] | [a _ ->]]; exists a.\nrewrite big_imset/=; last first.\n  by move=> i j _ _ ij; apply/set1P; rewrite -/(f j) -ij set11.\nrewrite -[in RHS](in_tupleE ps) -(map_tnth_enum (_ ps)) big_map enumT.\napply: congr_big => // i; first exact: in_setT.\nby rewrite big_set1 (tnth_nth 0).\nQed."
}
{
  "statement": "Lemma decidable : GRing.decidable_field_axiom sat.\n  ",
  "proof": "Proof.\n  move=> e f; elim: f e;\n  try by move=> f1 IH1 f2 IH2 e /=; case IH1; case IH2; constructor; tauto.\n  - by move=> b e; apply: idP.\n  - by move=> t1 t2 e; apply: eqP.\n  - by move=> t e; apply: idP.\n  - by move=> f IH e /=; case: IH; constructor.\n  - by move=> i f IH e; apply: (iffP existsP) => [] [x fx]; exists x; apply/IH.\n    by move=> i f IH e; apply: (iffP forallP) => f_ x; apply/IH.\n  Qed."
}
{
  "statement": "Lemma atrans_acts_card G S :\n  [transitive G, on S | to] =\n     [acts G, on S | to] && (#|orbit to G @: S| == 1%N).\n",
  "proof": "Proof.\napply/idP/andP=> [GtrS | [nSG]].\n  split; first exact: atrans_acts.\n  rewrite ((_ @: S =P [set S]) _) ?cards1 // eqEsubset sub1set.\n  apply/andP; split=> //; apply/subsetP=> _ /imsetP[x Sx ->].\n  by rewrite inE (atransP GtrS).\nrewrite eqn_leq andbC lt0n => /andP[/existsP[X /imsetP[x Sx X_Gx]]].\nrewrite (cardD1 X) {X}X_Gx imset_f // ltnS leqn0 => /eqP GtrS.\napply/imsetP; exists x => //; apply/eqP.\nrewrite eqEsubset acts_sub_orbit // Sx andbT.\napply/subsetP=> y Sy; have:= card0_eq GtrS (orbit to G y).\nby rewrite !inE /= imset_f // andbT => /eqP <-; apply: orbit_refl.\nQed."
}
{
  "statement": "Lemma bigdprodYP (I : finType) (P : pred I) (F : I -> {group gT}) :\n  reflect (forall i, P i ->\n             (\\prod_(j | P j && (j != i)) F j)%G \\subset 'C(F i) :\\: (F i)^#)\n          (\\big[dprod/1]_(i | P i) F i == (\\prod_(i | P i) F i)%G).\n",
  "proof": "Proof.\napply: (iffP eqP) => [defG i Pi | dxG].\n  rewrite !(bigD1 i Pi) /= in defG; have [[_ G' _ defG'] _ _ _] := dprodP defG.\n  by apply/dprodYP; rewrite -defG defG' bigprodGE (bigdprodWY defG').\nset Q := P; have sQP: subpred Q P by []; have [n leQn] := ubnP #|Q|.\nelim: n => // n IHn in (Q) leQn sQP *.\nhave [i Qi | Q0] := pickP Q; last by rewrite !big_pred0.\nrewrite (cardD1x Qi) add1n ltnS !(bigD1 i Qi) /= in leQn *.\nrewrite {}IHn {n leQn}// => [|j /andP[/sQP //]].\napply/dprodYP; apply: subset_trans (dxG i (sQP i Qi)); rewrite !bigprodGE.\nby apply: genS; apply/bigcupsP=> j /andP[Qj ne_ji]; rewrite (bigcup_max j) ?sQP.\nQed."
}
{
  "statement": "Lemma quotient_sdprodr_isom G A B M :\n    A ><| B = G -> M <| B ->\n  {f : {morphism B / M >-> coset_of (A <*> M)} |\n    isom (B / M) (G / (A <*> M)) f\n  & forall L, L \\subset B -> f @* (L / M) = A <*> L / (A <*> M)}.\n",
  "proof": "Proof.\nmove=> defG nsMH; have [defA defB]: A = <<A>>%G /\\ B = <<B>>%G.\n  by have [[K1 H1 -> ->] _ _ _] := sdprodP defG; rewrite /= !genGid.\ndo [rewrite {}defA {}defB; move: {A}<<A>>%G {B}<<B>>%G => K H] in defG nsMH *.\nhave [[nKH /isomP[injKH imKH]] sMH] := (sdprod_isom defG, normal_sub nsMH).\nhave [[nsKG sHG mulKH _ _] nKM] := (sdprod_context defG, subset_trans sMH nKH).\nhave nsKMG: K <*> M <| G.\n  by rewrite -quotientYK // -mulKH -quotientK ?cosetpre_normal ?quotient_normal.\nhave [/= f inj_f im_f] := third_isom (joing_subl K M) nsKG nsKMG.\nrewrite quotientYidl //= -imKH -(restrm_quotientE nKH sMH) in f inj_f im_f.\nhave /domP[h [_ ker_h _ im_h]]: 'dom (f \\o quotm _ nsMH) = H / M.\n  by rewrite ['dom _]morphpre_quotm injmK.\nhave{} im_h L: L \\subset H -> h @* (L / M) = K <*> L / (K <*> M).\n  move=> sLH; have [sLG sKKM] := (subset_trans sLH sHG, joing_subl K M).\n  rewrite im_h morphim_comp morphim_quotm [_ @* L]restrm_quotientE ?im_f //.\n  rewrite quotientY ?(normsG sKKM) ?(subset_trans sLG) ?normal_norm //.\n  by rewrite (quotientS1 sKKM) joing1G.\nexists h => //; apply/isomP; split; last by rewrite im_h //= (sdprodWY defG).\nby rewrite ker_h injm_comp ?injm_quotm.\nQed."
}
{
  "statement": "Lemma dvdp_exp_XsubCP (p : {poly R}) (c : R) (n : nat) :\n  reflect (exists2 k, (k <= n)%N & p %= ('X - c%:P) ^+ k)\n          (p %| ('X - c%:P) ^+ n).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[k lkn /eqp_dvdl->]]; last by rewrite dvdp_exp2l.\nmove=> /Pdiv.WeakIdomain.dvdpP[[/= a q] a_neq0].\nhave [m [r]] := multiplicity_XsubC p c; have [->|pN0]/= := eqVneq p 0.\n  rewrite mulr0 => _ _ /eqP;  rewrite scale_poly_eq0 (negPf a_neq0)/=.\n  by rewrite expf_eq0/= andbC polyXsubC_eq0.\nmove=> rNc ->; rewrite mulrA => eq_qrm; exists m.\n  have: ('X - c%:P) ^+ m %| a *: ('X - c%:P) ^+ n by rewrite eq_qrm dvdp_mull.\n  by rewrite (eqp_dvdr _ (eqp_scale _ _))// dvdp_Pexp2l// size_XsubC.\nsuff /eqP : size r = 1%N.\n  by rewrite size_poly_eq1 => /eqp_mulr/eqp_trans->//; rewrite mul1r eqpxx.\nhave : r %| a *: ('X - c%:P) ^+ n by rewrite eq_qrm mulrAC dvdp_mull.\nrewrite (eqp_dvdr _ (eqp_scale _ _))//.\nmove: rNc; rewrite -coprimep_XsubC => /(coprimep_expr n) /coprimepP.\nby move=> /(_ _ (dvdpp _)); rewrite -size_poly_eq1 => /(_ _)/eqP.\nQed."
}
{
  "statement": "Lemma vchar_norm2 phi :\n    phi \\in 'Z[irr G, G^#] -> '[phi] = 2 ->\n  exists i, exists2 j, j != i & phi = 'chi_i - 'chi_j.\n",
  "proof": "Proof.\nrewrite zchar_split cfunD1E => /andP[Zphi phi1_0].\ncase/zchar_small_norm => // [[[|chi [|xi [|?]]] //= S2]].\ncase=> /andP[/and3P[Nchi Nxi _] /= ochi] /allP/and3P[Zchi Zxi _].\nrewrite big_cons big_seq1 => def_phi.\nhave [b [i def_chi]] := vchar_norm1P Zchi (eqP Nchi).\nhave [c [j def_xi]] := vchar_norm1P Zxi (eqP Nxi).\nhave neq_ji: j != i.\n  apply: contraTneq ochi; rewrite !andbT def_chi def_xi => ->.\n  rewrite cfdotZl cfdotZr rmorph_sign cfnorm_irr mulr1 -signr_addb.\n  by rewrite signr_eq0.\nhave neq_bc: b != c.\n  apply: contraTneq phi1_0; rewrite def_phi def_chi def_xi => ->.\n  rewrite -scalerDr !cfunE mulf_eq0 signr_eq0 eq_le lt_geF //.\n  by rewrite ltr_pDl ?irr1_gt0.\nrewrite {}def_phi {}def_chi {}def_xi !scaler_sign.\ncase: b c neq_bc => [|] [|] // _; last by exists i, j.\nby exists j, i; rewrite 1?eq_sym // addrC.\nQed."
}
{
  "statement": "Lemma cfQuo_char G H (chi : 'CF(G)) :\n  chi \\is a character -> (chi / H)%CF \\is a character.\n",
  "proof": "Proof.\nmove=> Nchi; without loss kerH: / H \\subset cfker chi.\n  move/contraNF=> IHchi; apply/wlog_neg=> N'chiH.\n  suffices ->: (chi / H)%CF = (chi 1%g)%:A.\n    by rewrite rpredZ_nat ?Cnat_char1 ?rpred1.\n  by apply/cfunP=> x; rewrite cfunE cfun1E mulr_natr cfunElock IHchi.\nwithout loss nsHG: G chi Nchi kerH / H <| G.\n  move=> IHchi; have nsHN := normalSG (subset_trans kerH (cfker_sub chi)).\n  rewrite cfQuoInorm//; apply/cfRes_char/IHchi => //; first exact: cfRes_char. \n  by apply: sub_cfker_Res => //; apply: normal_sub.\nhave [rG Dchi] := char_reprP Nchi; rewrite Dchi cfker_repr in kerH.\napply/char_reprP; exists (Representation (quo_repr kerH (normal_norm nsHG))).\napply/cfun_inP=> _ /morphimP[x nHx Gx ->]; rewrite Dchi cfQuoE ?cfker_repr //=.\nby rewrite !cfunE Gx quo_repr_coset ?mem_quotient.\nQed."
}
{
  "statement": "Lemma Wedderburn_id_expansion i :\n  'e_i = #|G|%:R^-1 *: \\sum_(x in G) 'chi_i 1%g * 'chi_i x^-1%g *: aG x.\n",
  "proof": "Proof.\nhave Rei: ('e_i \\in 'R_i)%MS by apply: Wedderburn_id_mem.\nhave /envelop_mxP[a def_e]: ('e_i \\in R_G)%MS; last rewrite -/aG in def_e.\n  by move: Rei; rewrite genmxE mem_sub_gring => /andP[].\napply: canRL (scalerK (neq0CG _)) _; rewrite def_e linear_sum /=.\napply: eq_bigr => x Gx; have Gx' := groupVr Gx; rewrite scalerA; congr (_ *: _).\ntransitivity (cfReg G).['e_i *m aG x^-1%g]%CF.\n  rewrite def_e mulmx_suml raddf_sum (bigD1 x) //= -scalemxAl xcfunZr.\n  rewrite -repr_mxM // mulgV xcfunG // cfRegE eqxx mulrC big1 ?addr0 //.\n  move=> y /andP[Gy /negbTE neq_xy]; rewrite -scalemxAl xcfunZr -repr_mxM //.\n  by rewrite xcfunG ?groupM // cfRegE -eq_mulgV1 neq_xy mulr0.\nrewrite cfReg_sum -xcfun_rE raddf_sum /= (bigD1 i) //= xcfunZl.\nrewrite xcfun_mul_id ?envelop_mx_id ?xcfunG ?groupV ?big1 ?addr0 // => j ne_ji.\nrewrite xcfunZl (xcfun_annihilate ne_ji) ?mulr0 //.\nhave /andP[_ /(submx_trans _)-> //] := Wedderburn_ideal (W i).\nby rewrite mem_mulsmx // envelop_mx_id ?groupV.\nQed."
}
{
  "statement": "Lemma redivp_rec_loopTP (k : nat * polyF * polyF -> fF) :\n  (forall c qq r e,  qf_eval e (k (c,qq,r))\n    = qf_eval e (k (c, lift (eval_poly e qq), lift (eval_poly e r))))\n  -> forall q sq cq c qq r n e\n    (d := redivp_rec_loop (eval_poly e q) sq (eval e cq)\n      c (eval_poly e qq) (eval_poly e r) n),\n    qf_eval e (redivp_rec_loopT q sq cq c qq r n k)\n    = qf_eval e (k (d.1.1, lift d.1.2, lift d.2)).\n",
  "proof": "Proof.\nmove=> Pk q sq cq c qq r n e /=.\nelim: n c qq r k Pk e => [|n Pn] c qq r k Pk e; rewrite sizeTP.\n  case ltrq : (_ < _); first by rewrite /= ltrq /= -Pk.\n  rewrite lead_coefTP => [|a p]; rewrite Pk.\n    rewrite ?(eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT) //=.\n    by rewrite ltrq //= !mul_polyC ?(mul0r,add0r,scale0r).\n  by symmetry; rewrite Pk ?(eval_mulpT,eval_amulXnT,eval_sumpT, eval_opppT).\ncase ltrq : (_<_); first by rewrite /= ltrq Pk.\nrewrite lead_coefTP.\n  rewrite Pn ?(eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT) //=.\n  by rewrite ltrq //= !mul_polyC ?(mul0r,add0r,scale0r).\nrewrite -/redivp_rec_loopT => x e'.\nrewrite Pn; last by move=> *; rewrite Pk.\nsymmetry; rewrite Pn; last by move=> *; rewrite Pk.\nrewrite Pk ?(eval_lift,eval_mulpT,eval_amulXnT,eval_sumpT,eval_opppT).\nby rewrite mul_polyC ?(mul0r,add0r).\nQed."
}
{
  "statement": "Lemma generators_quaternion :\n    n > 2 -> G \\isog 'Q_m ->\n  exists2 xy, extremal_generators G 2 n xy\n           & let: (x, y) := xy in [/\\ #[y] = 4, y ^+ 2 = x ^+ r & x ^ y = x^-1].\n",
  "proof": "Proof.\nmove=> n_gt2; have [def2q def2r ltqm _] := def2qr (ltnW n_gt2).\ncase/(isoGrpP _ (Grp_quaternion n_gt2)); rewrite card_quaternion // -/m => oG.\ncase/existsP=> -[x y] /=; rewrite -/q -/r => /eqP[defG xq y2 xy].\nhave{} defG: <[x]> * <[y]> = G.\n  by rewrite -norm_joinEr // norms_cycle xy groupV cycle_id.\nhave notXy: y \\notin <[x]>.\n  apply: contraL ltqm => Xy; rewrite -leqNgt -oG -defG mulGSid ?cycle_subG //.\n  by rewrite dvdn_leq // order_dvdn xq.\nhave ox: #[x] = q.\n  apply/eqP; rewrite eqn_leq dvdn_leq ?order_dvdn ?xq //=.\n  rewrite -(leq_pmul2r (order_gt0 y)) mul_cardG defG oG -def2q mulnAC mulnC.\n  rewrite leq_pmul2r // dvdn_leq ?muln_gt0 ?cardG_gt0 // order_dvdn expgM.\n  by rewrite -order_dvdn order_dvdG //= inE {1}y2 !mem_cycle.\nhave oy2: #[y ^+ 2] = 2 by rewrite y2 orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nexists (x, y) => /=; last by rewrite (orderXprime oy2).\nby rewrite oG !inE notXy -!cycle_subG /= -defG  mulG_subl mulG_subr.\nQed."
}
{
  "statement": "Theorem CauchySchwarz (u v : U) :\n  `|'[u, v]| ^+ 2 <= '[u] * '[v] ?= iff ~~ free [:: u; v].\n",
  "proof": "Proof.\nrewrite free_cons span_seq1 seq1_free -negb_or negbK orbC.\nhave [-> | nz_v] /= := altP (v =P 0).\n  by apply/leifP; rewrite /= !linear0r normCK mul0r mulr0.\nwithout loss ou: u / '[u, v] = 0.\n  move=> IHo; pose a := '[u, v] / '[v]; pose u1 := u - a *: v.\n  have ou: '[u1, v] = 0.\n    rewrite linearBl/=.\n    rewrite linearZl_LR.\n    by rewrite divfK ?dnorm_eq0 ?subrr.\n  rewrite (canRL (subrK _) (erefl u1)) rpredDr ?rpredZ ?memv_line //.\n  rewrite linearDl /= ou add0r.\n  rewrite linearZl_LR/= normrM (ger0_norm (dnorm_ge0 _ _)).\n  rewrite exprMn mulrA -dnormZ hnormDd/=; last by rewrite linearZr_LR/= ou mulr0.\n  have:= IHo _ ou.\n  by rewrite mulrDl -leifBLR subrr ou normCK mul0r.\nrewrite ou normCK mul0r; split; first by rewrite mulr_ge0.\nrewrite eq_sym mulf_eq0 orbC dnorm_eq0 (negPf nz_v) /=.\napply/idP/idP=> [|/vlineP[a {2}->]]; last by rewrite linearZr_LR/= ou mulr0.\nby rewrite dnorm_eq0 => /eqP->; apply: rpred0.\nQed."
}
{
  "statement": "Lemma equivalence_partitionP : partition P D.\n",
  "proof": "Proof.\nhave defD: cover P == D.\n  rewrite eqEsubset; apply/andP; split.\n    by apply/bigcupsP=> _ /imsetP[x Dx ->]; rewrite /Px setIdE subsetIl.\n  by apply/subsetP=> x Dx; apply/bigcupP; exists (Px x); rewrite (Pxx, PPx).\nhave tiP: trivIset P.\n  apply/trivIsetP=> _ _ /imsetP[x Dx ->] /imsetP[y Dy ->]; apply: contraR.\n  case/pred0Pn=> z /andP[] /[!inE] /andP[Dz Rxz] /andP[_ Ryz].\n  apply/eqP/setP=> t /[!inE]; apply: andb_id2l => Dt.\n  by rewrite (eqiR Dx Dz Dt) // (eqiR Dy Dz Dt).\nrewrite /partition tiP defD /=.\nby apply/imsetP=> [[x /Pxx Px_x Px0]]; rewrite -Px0 inE in Px_x.\nQed."
}
{
  "statement": "Lemma rootCMl n x z : 0 <= x -> n.-root (x * z) = n.-root x * n.-root z.\n",
  "proof": "Proof.\nrewrite le0r => /predU1P[-> | x_gt0]; first by rewrite !(mul0r, rootC0).\nhave [| n_gt1 | ->] := ltngtP n 1; last by rewrite !root1C.\n  by case: n => //; rewrite !root0C mul0r.\nhave [x_ge0 n_gt0] := (ltW x_gt0, ltnW n_gt1).\nhave nx_gt0: 0 < n.-root x by rewrite rootC_gt0.\nhave Rnx: n.-root x \\is real by rewrite ger0_real ?ltW.\napply: eqC_semipolar; last 1 first; try apply/eqP.\n- by rewrite ImMl // !(Im_rootC_ge0, mulr_ge0, rootC_ge0).\n- by rewrite -(eqrXn2 n_gt0) // -!normrX exprMn !rootCK.\nrewrite eq_le; apply/andP; split; last first.\n  rewrite rootC_Re_max ?exprMn ?rootCK ?ImMl //.\n  by rewrite mulr_ge0 ?Im_rootC_ge0 ?ltW.\nrewrite -[n.-root _](mulVKf (negbT (gt_eqF nx_gt0))) !(ReMl Rnx) //.\nrewrite ler_pM2l // rootC_Re_max ?exprMn ?exprVn ?rootCK ?mulKf ?gt_eqF //.\nby rewrite ImMl ?rpredV // mulr_ge0 ?invr_ge0 ?Im_rootC_ge0 ?ltW.\nQed."
}
{
  "statement": "Lemma algC_PET (s : seq algC) :\n  {z | exists a : nat ^ size s, z = \\sum_(i < size s) s`_i *+ a i\n     & exists ps, s = [seq (pQtoC p).[z] | p <- ps]}.\n",
  "proof": "Proof.\nelim: s => [|x s [z /sig_eqW[a Dz] /sig_eqW[ps Ds]]].\n  by exists 0; [exists [ffun _ => 2%N]; rewrite big_ord0 | exists nil].\nhave r_exists (y : algC): {r | r != 0 & root (pQtoC r) y}.\n  have [r [_ mon_r] dv_r] := minCpolyP y.\n  by exists r; rewrite ?monic_neq0 ?dv_r.\nsuffices /sig_eqW[[n [|px [|pz []]]]// [Dpx Dpz]]:\n  exists np, let zn := x *+ np.1 + z in\n    [:: x; z] = [seq (pQtoC p).[zn] | p <- np.2].\n- exists (x *+ n + z).\n    exists [ffun i => oapp a n (unlift ord0 i)].\n    rewrite /= big_ord_recl ffunE unlift_none Dz; congr (_ + _).\n    by apply: eq_bigr => i _; rewrite ffunE liftK.\n  exists (px :: [seq p \\Po pz | p <- ps]); rewrite /= -Dpx; congr (_ :: _).\n  rewrite -map_comp Ds; apply: eq_map => p /=.\n  by rewrite map_comp_poly horner_comp -Dpz.\nhave [rx nz_rx rx0] := r_exists x.\nhave [rz nz_rz rz0] := r_exists (- z).\nhave pchar0_Q: [pchar rat] =i pred0 by apply: pchar_num.\nhave [n [[pz Dpz] [px Dpx]]] := pchar0_PET nz_rz rz0 nz_rx rx0 pchar0_Q.\nby exists (n, [:: px; - pz]); rewrite /= !raddfN hornerN -[z]opprK Dpz Dpx.\nQed."
}
{
  "statement": "Lemma eq_holds e e' f : same_env e e' -> holds e f -> holds e' f.\n",
  "proof": "Proof.\npose sv := set_nth (0 : R).\nhave eq_i i v e1 e2: same_env e1 e2 -> same_env (sv e1 i v) (sv e2 i v).\n  by move=> eq_e j; rewrite !nth_set_nth /= eq_e.\nelim: f e e' => //=.\n- by move=> t1 t2 e e' eq_e; rewrite !(eq_eval _ eq_e).\n- by move=> t e e' eq_e; rewrite (eq_eval _ eq_e).\n- by move=> f1 IH1 f2 IH2 e e' eq_e; move/IH2: (eq_e); move/IH1: eq_e; tauto.\n- by move=> f1 IH1 f2 IH2 e e' eq_e; move/IH2: (eq_e); move/IH1: eq_e; tauto.\n- by move=> f1 IH1 f2 IH2 e e' eq_e f12; move/IH1: (same_env_sym eq_e); eauto.\n- by move=> f1 IH1 e e'; move/same_env_sym; move/IH1; tauto.\n- by move=> i f1 IH1 e e'; move/(eq_i i)=> eq_e [x f_ex]; exists x; eauto.\nby move=> i f1 IH1 e e'; move/(eq_i i); eauto.\nQed."
}
{
  "statement": "Lemma prod_tpermP s :\n  {ts : seq (T * T) | s = \\prod_(t <- ts) tperm t.1 t.2 & all dpair ts}.\n",
  "proof": "Proof.\nhave [n] := ubnP #|[pred x | s x != x]|; elim: n s => // n IHn s /ltnSE-le_s_n.\ncase: (pickP (fun x => s x != x)) => [x s_x | s_id]; last first.\n  exists nil; rewrite // big_nil; apply/permP=> x.\n  by apply/eqP/idPn; rewrite perm1 s_id.\nhave [|ts def_s ne_ts] := IHn (tperm x (s^-1 x) * s); last first.\n  exists ((x, s^-1 x) :: ts); last by rewrite /= -(canF_eq (permK _)) s_x.\n  by rewrite big_cons -def_s mulgA tperm2 mul1g.\nrewrite (cardD1 x) !inE s_x in le_s_n; apply: leq_ltn_trans le_s_n.\napply: subset_leq_card; apply/subsetP=> y.\nrewrite !inE permM permE /= -(canF_eq (permK _)).\nhave [-> | ne_yx] := eqVneq y x; first by rewrite permKV eqxx.\nby case: (s y =P x) => // -> _; rewrite eq_sym.\nQed."
}
{
  "statement": "Lemma mx_rsim_socle (sG : socleType rG) (W : sG) (rW : representation) :\n    let modW : mxmodule rG W := component_mx_module rG (socle_base W) in\n    mx_rsim (socle_repr W) rW ->\n  mx_rsim (submod_repr modW) (muln_grepr rW (socle_mult W)).\n",
  "proof": "Proof.\nset M := socle_base W => modW rsimM.\nhave simM: mxsimple rG M := socle_simple W.\nhave rankM_gt0: (\\rank M > 0)%N by rewrite lt0n mxrank_eq0; case: simM.\nhave [I /= U_I simU]: mxsemisimple rG W by apply: component_mx_semisimple.\npose U (i : 'I_#|I|) := U_I (enum_val i).\nhave reindexI := reindex _ (onW_bij I (enum_val_bij I)).\nrewrite mxdirectE /= !reindexI -mxdirectE /= => defW dxW.\nhave isoU: forall i, mx_iso rG M (U i).\n  move=> i; have sUiW: (U i <= W)%MS  by rewrite -defW (sumsmx_sup i).\n  exact: component_mx_iso (simU _) sUiW.\nhave ->: socle_mult W = #|I|.\n  rewrite -(mulnK #|I| rankM_gt0); congr (_ %/ _)%N.\n  rewrite -defW (mxdirectP dxW) /= -sum_nat_const reindexI /=.\n  by apply: eq_bigr => i _; rewrite -(mxrank_iso (isoU i)).\nhave modU: mxmodule rG (U _) := mxsimple_module (simU _).\nsuff: mx_rsim (submod_repr (modU _)) rW by apply: mx_rsim_dsum defW dxW.\nby move=> i; apply: mx_rsim_trans (mx_rsim_sym _) rsimM; apply/mx_rsim_iso.\nQed."
}
{
  "statement": "Lemma num_itv_bound_exprn_le1 (x : R) n l u :\n  (num_itv_bound R l <= BLeft x)%O ->\n  (BRight x <= num_itv_bound R u)%O ->\n  (BRight (x ^+ n) <= num_itv_bound R (exprn_le1_bound l u))%O.\n",
  "proof": "Proof.\ncase: u => [bu [[//|[|//]] |//] | []//].\nrewrite /exprn_le1_bound; case: (leP _ l) => [lge1 /= |//] lx xu.\nrewrite bnd_simp; case: n => [| n]; rewrite ?expr0//.\nhave xN1 : -1 <= x.\n  case: l lge1 lx => [[] l | []//]; rewrite !bnd_simp -(@ler_int R).\n  - exact: le_trans.\n  - by move=> + /ltW; apply: le_trans.\nhave x1 : x <= 1 by case: bu xu; rewrite bnd_simp// => /ltW.\nhave xr : x \\is Num.real by exact: ler1_real.\ncase: (real_ge0P xr) => x0; first by rewrite expr_le1.\nrewrite -[x]opprK exprNn; apply: le_trans (ler_piMl _ _) _.\n- by rewrite exprn_ge0 ?oppr_ge0 1?ltW.\n- suff: -1 <= (-1) ^+ n.+1 :> R /\\ (-1) ^+ n.+1 <= 1 :> R => [[]//|].\n  elim: n => [|n [IHn1 IHn2]]; rewrite ?expr1// ![_ ^+ n.+2]exprS !mulN1r.\n  by rewrite lerNl opprK lerNl.\n- by rewrite expr_le1 ?oppr_ge0 1?lerNl// ltW.\nQed."
}
{
  "statement": "Lemma cfdot_sum_dchi (phi1 phi2 : 'CF(G)) :\n  '[\\sum_(i in dirr_constt phi1) dchi i,\n    \\sum_(i in dirr_constt phi2) dchi i] =\n  #|dirr_constt phi1 :&: dirr_constt phi2|%:R -\n    #|dirr_constt phi1 :&: dirr_constt (- phi2)|%:R.\n",
  "proof": "Proof.\nrewrite addrC (big_setID (dirr_constt (- phi2))) /= cfdotDl; congr (_ + _).\n  rewrite cfdot_suml -sumr_const -sumrN; apply: eq_bigr => i /setIP[p1i p2i].\n  rewrite cfdot_sumr (bigD1 (ndirr i)) -?dirr_constt_oppr //= dchi_ndirrE.\n  rewrite cfdotNr cfnorm_dchi big1 ?addr0 // => j /andP[p2j i'j].\n  rewrite cfdot_dchi -(inv_eq ndirrK) [in rhs in - rhs]eq_sym (negPf i'j) subr0.\n  rewrite (negPf (contraTneq _ p2i)) // => ->.\n  by rewrite dirr_constt_oppr dirr_constt_oppl.\nrewrite cfdot_sumr (big_setID (dirr_constt phi1)) setIC /= addrC.\nrewrite big1 ?add0r => [|j /setDP[p2j p1'j]]; last first.\n  rewrite cfdot_suml big1 // => i /setDP[p1i p2'i].\n  rewrite cfdot_dchi (negPf (contraTneq _ p1i)) => [|-> //].\n  rewrite (negPf (contraNneq _ p2'i)) ?subrr // => ->.\n  by rewrite dirr_constt_oppr ndirrK.\nrewrite -sumr_const; apply: eq_bigr => i /setIP[p1i p2i]; rewrite cfdot_suml.\nrewrite (bigD1 i) /=; last by rewrite inE dirr_constt_oppr dirr_constt_oppl.\nrewrite cfnorm_dchi big1 ?addr0 // => j /andP[/setDP[p1j _] i'j].\nrewrite cfdot_dchi (negPf i'j) (negPf (contraTneq _ p1j)) ?subrr // => ->.\nexact: dirr_constt_oppl.\nQed."
}
{
  "statement": "Lemma separable_exponent_pchar K x :\n  exists n, [pchar L].-nat n && separable_element K (x ^+ n).\n",
  "proof": "Proof.\npose d := adjoin_degree K x; move: {2}d.+1 (ltnSn d) => n.\nelim: n => // n IHn in x @d *; rewrite ltnS => le_d_n.\nhave [[p pcharLp]|] := altP (separablePn_pchar K x); last by rewrite negbK; exists 1.\ncase=> g Kg defKx; have p_pr := pcharf_prime pcharLp.\nsuffices /IHn[m /andP[pcharLm sepKxpm]]: adjoin_degree K (x ^+ p) < n.\n  by exists (p * m)%N; rewrite pnatM pnatE // pcharLp pcharLm exprM.\napply: leq_trans le_d_n; rewrite -ltnS -!size_minPoly.\nhave nzKx: minPoly K x != 0 by rewrite monic_neq0 ?monic_minPoly.\nhave nzg: g != 0 by apply: contra_eqN defKx => /eqP->; rewrite comp_poly0.\napply: leq_ltn_trans (dvdp_leq nzg _) _.\n  by rewrite minPoly_dvdp // rootE -hornerXn -horner_comp -defKx minPolyxx.\nrewrite (polySpred nzKx) ltnS defKx size_comp_poly size_polyXn /=.\nsuffices g_gt1: 1 < size g by rewrite -(subnKC g_gt1) ltn_Pmulr ?prime_gt1.\napply: contra_eqT (size_minPoly K x); rewrite defKx -leqNgt => /size1_polyC->.\nby rewrite comp_polyC size_polyC; case: (_ != 0).\nQed."
}
{
  "statement": "Lemma partition_disjoint_bigcup (F : I -> {set T}) E :\n    (forall i j, i != j -> [disjoint F i & F j]) ->\n  \\big[op/idx]_(x in \\bigcup_i F i) E x =\n    \\big[op/idx]_i \\big[op/idx]_(x in F i) E x.\n",
  "proof": "Proof.\nmove=> disjF; pose P := [set F i | i in I & F i != set0].\nhave trivP: trivIset P.\n  apply/trivIsetP=> _ _ /imsetP[i _ ->] /imsetP[j _ ->] neqFij.\n  by apply: disjF; apply: contraNneq neqFij => ->.\nhave ->: \\bigcup_i F i = cover P.\n  apply/esym; rewrite cover_imset big_mkcond; apply: eq_bigr => i _.\n  by rewrite inE; case: eqP.\nrewrite big_trivIset // /rhs big_imset => [|i j _ /setIdP[_ notFj0] eqFij].\n  rewrite big_mkcond; apply: eq_bigr => i _; rewrite inE.\n  by case: eqP => //= ->; rewrite big_set0.\nby apply: contraNeq (disjF _ _) _; rewrite -setI_eq0 eqFij setIid.\nQed."
}
{
  "statement": "Lemma plogp_X (p q : {poly F}) :\n  2 < size p -> primitive_poly p -> ~~ (p %| q) -> p %| q - 'X ^+ plogp p q.\n",
  "proof": "Proof.\nmove=> sp_gt2 Hh pNDq.\nrewrite /plogp.\ncase (boolP (primitive_poly p)) => // Hh'; last by case/negP: Hh'.\nhave pM : p \\is monic by case/and4P: Hh'.\nhave pMi : monic_irreducible_poly p by apply: primitive_mi.\nset q' : {poly %/ p with primitive_mi Hh'} := in_qpoly p q.\napply/modp_eq0P; rewrite modpD modpN; apply/eqP; rewrite subr_eq0; apply/eqP.\nrewrite !Pdiv.IdomainMonic.modpE //=.\nsuff /val_eqP/eqP/= : 'qX ^+ qlogp q' = q'.\n  rewrite /= [X in rmodp _ X]mk_monicE // => <-.\n  by rewrite poly_of_qpolyX /= mk_monicE // [rmodp 'X p]rmodp_small ?size_polyX.\napply: qlogp_qX => //.\napply/eqP=> /val_eqP/eqP.\nrewrite /= mk_monicE // => /rmodp_eq0P; rewrite -dvdpE => pDq.\nby case/negP: pNDq.\nQed."
}
{
  "statement": "Lemma natr_sum_eq1 (I : finType) (P : pred I) (F : I -> R) :\n     (forall i, P i -> F i \\is a nat_num) -> \\sum_(i | P i) F i = 1 ->\n   {i : I | [/\\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]}.\n",
  "proof": "Proof.\nmove=> natF /eqP; rewrite -sum_truncnK// -[1]/1%:R eqr_nat => /sum_nat_eq1 exi.\nhave [i /and3P[Pi /eqP f1 /forallP a]] : {i : I | [&& P i, truncn (F i) == 1\n    & [forall j : I, ((j != i) ==> P j ==> (truncn (F j) == 0))]]}.\n  apply/sigW; have [i [Pi /eqP f1 a]] := exi; exists i; apply/and3P; split=> //.\n  by apply/forallP => j; apply/implyP => ji; apply/implyP => Pj; apply/eqP/a.\nexists i; split=> [//||j ji Pj]; rewrite -[LHS]truncnK ?natF ?f1//; apply/eqP.\nby rewrite -[0]/0%:R eqr_nat; apply: implyP Pj; apply: implyP ji; apply: a.\nQed."
}
{
  "statement": "Lemma prime_decompE n : prime_decomp n = [seq (p, logn p n) | p <- primes n].\n",
  "proof": "Proof.\ncase: n => // n; pose f0 := (0, 0); rewrite -map_comp.\napply: (@eq_from_nth _ f0) => [|i lt_i_n]; first by rewrite size_map.\nrewrite (nth_map f0) //; case def_f: (nth _ _ i) => [p e] /=.\ncongr (_, _); rewrite [n.+1]prod_prime_decomp //.\nhave: (p, e) \\in prime_decomp n.+1 by rewrite -def_f mem_nth.\ncase/mem_prime_decomp=> pr_p _ _.\nrewrite (big_nth f0) big_mkord (bigD1 (Ordinal lt_i_n)) //=.\nrewrite def_f mulnC logn_Gauss ?pfactorK //.\napply big_ind => [|m1 m2 com1 com2| [j ltj] /=]; first exact: coprimen1.\n  by rewrite coprimeMr com1.\nrewrite -val_eqE /= => nji; case def_j: (nth _ _ j) => [q e1] /=.\nhave: (q, e1) \\in prime_decomp n.+1 by rewrite -def_j mem_nth.\ncase/mem_prime_decomp=> pr_q e1_gt0 _; rewrite coprime_pexpr //.\nrewrite prime_coprime // dvdn_prime2 //; apply: contra nji => eq_pq.\nrewrite -(nth_uniq 0 _ _ (primes_uniq n.+1)) ?size_map //=.\nby rewrite !(nth_map f0) //  def_f def_j /= eq_sym.\nQed."
}
{
  "statement": "Lemma gFmod_cont : GFunctor.continuous (F1 %% F2).\n",
  "proof": "Proof.\nmove=> gT rT G f; have nF2 := gFnorm F2.\nhave sDF: G \\subset 'dom (coset (F2 _ G)) by rewrite nF2.\nhave sDFf: G \\subset 'dom (coset (F2 _ (f @* G)) \\o f).\n  by rewrite -sub_morphim_pre ?subsetIl // nF2.\npose K := 'ker (restrm sDFf (coset (F2 _ (f @* G)) \\o f)).\nhave sFK: 'ker (restrm sDF (coset (F2 _ G))) \\subset K.\n  rewrite {}/K !ker_restrm ker_comp /= subsetI subsetIl !ker_coset /=.\n  by rewrite -sub_morphim_pre ?subsetIl // morphimIdom ?morphimF.\nhave sOF := gFsub F1 (G / F2 _ G); have sGG: G \\subset G by [].\nrewrite -sub_quotient_pre; last first.\n  by apply: subset_trans (nF2 _ _); rewrite morphimS ?gFmod_closed.\nsuffices im_fact H : F2 _ G \\subset gval H -> H \\subset G ->\n  factm sFK sGG @* (H / F2 _ G) = f @* H / F2 _ (f @* G).\n- rewrite -2?im_fact ?gFmod_closed ?gFsub //.\n    by rewrite cosetpreK morphimF /= ?morphim_restrm ?setIid.\n  by rewrite -sub_quotient_pre ?normG //= trivg_quotient sub1G.\nmove=> sFH sHG; rewrite -(morphimIdom _ (H / _)) /= {2}morphim_restrm setIid.\nrewrite -morphimIG ?ker_coset // -(morphim_restrm sDF) morphim_factm.\nby rewrite morphim_restrm morphim_comp -quotientE morphimIdom.\nQed."
}
{
  "statement": "Lemma max_SCN A :\n  p.-group G -> [max A | A <| G & abelian A] -> A \\in 'SCN(G).\n",
  "proof": "Proof.\nmove/pgroup_nil=> nilG; rewrite /abelian.\ncase/maxgroupP=> /andP[nsAG abelA] maxA; have [sAG nAG] := andP nsAG.\nrewrite inE nsAG eqEsubset /= andbC subsetI abelA normal_sub //=.\nrewrite -quotient_sub1; last by rewrite subIset 1?normal_norm.\napply/trivgP; apply: (TI_center_nil (quotient_nil A nilG)).\n  by rewrite quotient_normal // /normal subsetIl normsI ?normG ?norms_cent.\napply/trivgP/subsetP=> _ /setIP[/morphimP[x Nx /setIP[_ Cx]] ->].\nrewrite -cycle_subG in Cx => /setIP[GAx CAx].\nhave{CAx GAx}: <[coset A x]> <| G / A.\n  by rewrite /normal cycle_subG GAx cents_norm // centsC cycle_subG.\ncase/(inv_quotientN nsAG)=> B /= defB sAB nBG.\nrewrite -cycle_subG defB (maxA B) ?trivg_quotient // nBG.\nhave{} defB : B :=: A * <[x]>.\n  rewrite -quotientK ?cycle_subG ?quotient_cycle // defB quotientGK //.\n  exact: normalS (normal_sub nBG) nsAG.\napply/setIidPl; rewrite ?defB -[_ :&: _]center_prod //=.\nrewrite /center !(setIidPl _) //; apply: cycle_abelian.\nQed."
}
{
  "statement": "Lemma primes_part pi n : primes n`_pi = filter [in pi] (primes n).\n",
  "proof": "Proof.\nhave ltnT := ltn_trans; have [->|n_gt0] := posnP n; first by rewrite partn0.\napply: (irr_sorted_eq ltnT ltnn); rewrite ?(sorted_primes, sorted_filter) //.\nmove=> p; rewrite mem_filter /= !mem_primes n_gt0 part_gt0 /=.\napply/andP/and3P=> [[p_pr] | [pi_p p_pr dv_p_n]].\n  rewrite /partn; apply big_ind => [|n1 n2 IHn1 IHn2|q pi_q].\n  - by rewrite dvdn1; case: eqP p_pr => // ->.\n  - by rewrite Euclid_dvdM //; case/orP.\n  rewrite -{1}(expn1 p) pfactor_dvdn // lognX muln_gt0.\n  rewrite logn_gt0 mem_primes n_gt0 - andbA /=; case/and3P=> pr_q dv_q_n.\n  by rewrite logn_prime //; case: eqP => // ->.\nhave le_p_n: p < n.+1 by rewrite ltnS dvdn_leq.\nrewrite [n`_pi]big_mkord (bigD1 (Ordinal le_p_n)) //= dvdn_mulr //.\nby rewrite lognE p_pr n_gt0 dv_p_n expnS dvdn_mulr.\nQed."
}
{
  "statement": "Lemma normCDeq x y :\n    `|x + y| = `|x| + `|y| ->\n  {t : C | `|t| == 1 & (x, y) = (`|x| * t, `|y| * t)}.\n",
  "proof": "Proof.\nmove=> lin_xy; apply: sig2_eqW; pose u z := if z == 0 then 1 else z / `|z|.\nhave uE z: (`|u z| = 1) * (`|z| * u z = z).\n  rewrite /u; have [->|nz_z] := eqVneq; first by rewrite normr0 normr1 mul0r.\n  by rewrite normf_div normr_id mulrCA divff ?mulr1 ?normr_eq0.\nhave [->|nz_x] := eqVneq x 0; first by exists (u y); rewrite uE ?normr0 ?mul0r.\nexists (u x); rewrite uE // /u (negPf nz_x); congr (_ , _).\nhave{lin_xy} def2xy: `|x| * `|y| *+ 2 = x * y ^* + y * x ^*.\n  apply/(addrI (x * x^* ))/(addIr (y * y^* )); rewrite -2!{1}normCK -sqrrD.\n  by rewrite addrA -addrA -!mulrDr -mulrDl -rmorphD -normCK lin_xy.\nhave def_xy: x * y^* = y * x^*.\n  apply/eqP; rewrite -subr_eq0 -[_ == 0](@expf_eq0 _ _ 2).\n  rewrite (canRL (subrK _) (subr_sqrDB _ _)) opprK -def2xy exprMn_n exprMn.\n  by rewrite mulrN (@GRing.mul C).[AC (2*2) (1*4*(3*2))] -!normCK mulNrn addNr.\nhave{def_xy def2xy} def_yx: `|y * x| = y * x^*.\n  by apply: (mulIf nz2); rewrite !mulr_natr mulrC normrM def2xy def_xy.\nrewrite -{1}(divfK nz_x y) invC_norm mulrCA -{}def_yx !normrM invfM.\nby rewrite mulrCA divfK ?normr_eq0 // mulrAC mulrA.\nQed."
}
{
  "statement": "Lemma normedTI_P A G L : \n  reflect [/\\ A != set0, L \\subset 'N_G(A)\n           & {in G, forall g, ~~ [disjoint A & A :^ g] -> g \\in L}]\n          (normedTI A G L).\n",
  "proof": "Proof.\napply: (iffP and3P) => [[nzA /trivIsetP tiAG /eqP <-] | [nzA sLN tiAG]].\n  split=> // g Gg; rewrite inE Gg (sameP normP eqP) /= eq_sym; apply: contraR.\n  by apply: tiAG; rewrite ?mem_orbit ?orbit_refl.\nhave [/set0Pn[a Aa] /subsetIP[_ nAL]] := (nzA, sLN); split=> //; last first.\n  rewrite eqEsubset sLN andbT; apply/subsetP=> x /setIP[Gx nAx].\n  by apply/tiAG/pred0Pn=> //; exists a; rewrite /= (normP nAx) Aa.\napply/trivIsetP=> _ _ /imsetP[x Gx ->] /imsetP[y Gy ->]; apply: contraR.\nrewrite -setI_eq0 -(mulgKV x y) conjsgM; set g := (y * x^-1)%g.\nhave Gg: g \\in G by rewrite groupMl ?groupV.\nrewrite -conjIg (inj_eq (act_inj 'Js x)) (eq_sym A) (sameP eqP normP).\nby rewrite -cards_eq0 cardJg cards_eq0 setI_eq0 => /tiAG/(subsetP nAL)->.\nQed."
}
{
  "statement": "Lemma orthomxP p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  reflect (forall (u v : 'rV_n), u <= A -> v <= B -> u '_|_ v)%MS\n          (A '_|_ B)%MS.\n",
  "proof": "Proof.\napply: (iffP idP) => AnB.\n  move=> u v uA vB; rewrite (submx_trans uA) // (submx_trans AnB) //.\n  apply/sub_kermxP; have /submxP [w ->] := vB.\n  rewrite trmx_mul map_mxM !mulmxA -[kermx _ *m _ *m _]mulmxA.\n  by rewrite [kermx _ *m _](sub_kermxP _) // mul0mx.\napply/rV_subP => u /AnB /(_ _) /sub_kermxP uMv; apply/sub_kermxP.\nsuff: forall m (v : 'rV[R]_m),\n  (forall i, v *m 'e_i ^t theta = 0 :> 'M_1) -> v = 0.\n  apply => i; rewrite !mulmxA -!mulmxA -map_mxM -trmx_mul uMv //.\n  by apply/submxP; exists 'e_i.\nmove=> /= m v Hv; apply: (can_inj (@trmxK _ _ _)).\nrewrite trmx0; apply/row_matrixP=> i; rewrite row0 rowE.\napply: (can_inj (@trmxK _ _ _)); rewrite trmx0 trmx_mul trmxK.\nby rewrite -(map_delta_mx theta) map_trmx Hv.\nQed."
}
{
  "statement": "Lemma normalP p q (A : 'M_(p, n)) (B :'M_(q, n)) :\n  reflect (forall (u v : 'rV_n), (u <= A)%MS -> (v <= B)%MS -> u '_|_ v)\n          (A '_|_ B).\n",
  "proof": "Proof.\napply: (iffP idP) => AnB.\n  move=> u v uA vB; rewrite (submx_trans uA) // (submx_trans AnB) //.\n  apply/sub_kermxP; have /submxP [w ->] := vB.\n  rewrite trmx_mul map_mxM !mulmxA -[kermx _ *m _ *m _]mulmxA.\n  by rewrite [kermx _ *m _](sub_kermxP _) // mul0mx.\napply/rV_subP => u /AnB /(_ _) /sub_kermxP uMv; apply/sub_kermxP.\nsuff: forall m (v : 'rV[R]_m),\n  (forall i, v *m 'e_i ^t theta = 0 :> 'M_1) -> v = 0.\n  apply => i; rewrite !mulmxA -!mulmxA -map_mxM -trmx_mul uMv //.\n  by apply/submxP; exists 'e_i.\nmove=> /= m v Hv; apply: (can_inj (@trmxK _ _ _)).\nrewrite trmx0; apply/row_matrixP=> i; rewrite row0 rowE.\napply: (can_inj (@trmxK _ _ _)); rewrite trmx0 trmx_mul trmxK.\nby rewrite -(map_delta_mx theta) map_trmx Hv.\nQed."
}
{
  "statement": "Lemma row_gen_sum_mxval W (i : 'I_m) :\n  row i (val_gen W) = \\sum_j row (gen_base 0 j) (mxval (W i j)).\n",
  "proof": "Proof.\nrewrite -val_gen_row [row i W]row_sum_delta val_gen_sum.\napply: eq_bigr => /= j _ /[1!mxE]; move: {W i}(W i j) => x.\nhave ->: x = \\sum_k gen (val x 0 k) * inFA (delta_mx 0 k).\n  case: x => u; apply: mxval_inj; rewrite {1}[u]row_sum_delta.\n  rewrite mxval_sum [mxval _]horner_rVpoly mulmx_suml linear_sum /=.\n  apply: eq_bigr => k _; rewrite mxvalM genK [mxval _]horner_rVpoly /=.\n  by rewrite mul_scalar_mx -scalemxAl linearZ.\nrewrite scaler_suml val_gen_sum mxval_sum linear_sum; apply: eq_bigr => k _.\nrewrite mxvalM genK mul_scalar_mx linearZ [mxval _]horner_rVpoly /=.\nrewrite -scalerA; apply: (canLR in_genK); rewrite in_genZ; congr (_ *: _).\napply: (canRL val_genK); transitivity (row (mxvec_index j k) base); last first.\n  by rewrite -rowE rowK mxvecE mxE rowK mxvecK.\nrewrite rowE -mxvec_delta -[val_gen _](row_id 0) rowK /=; congr (mxvec _ *m _).\napply/row_matrixP=> j'; rewrite rowK !mxE mulr_natr rowE mul_delta_mx_cond.\nby rewrite !mulrb (fun_if rVval).\nQed."
}
{
  "statement": "Lemma normalFieldP K E :\n  reflect {in E, forall a, exists2 r,\n            all [in E] r & minPoly K a = \\prod_(b <- r) ('X - b%:P)}\n          (normalField K E).\n",
  "proof": "Proof.\napply: (iffP eqfun_inP) => [nKE a Ea | nKE x]; last first.\n  rewrite inE kAutfE => homKx; suffices: kAut K E x by case/andP=> _ /eqP.\n  rewrite kAutE (kHomSr (subvf E)) //=; apply/subvP=> _ /memv_imgP[a Ea ->].\n  have [r /allP/=srE splitEa] := nKE a Ea.\n  rewrite srE // -root_prod_XsubC -splitEa.\n  by rewrite -(kHom_poly_id homKx (minPolyOver K a)) fmorph_root root_minPoly.\nhave [r /eqP splitKa] := splitting_field_normal K a.\nexists r => //; apply/allP => b; rewrite -root_prod_XsubC -splitKa => pKa_b_0.\npose y := kHomExtend K \\1 a b; have [hom1K lf1p] := (kHom1 K K, lfun1_poly).\nhave homKy: kHom K <<K; a>> y by apply/kHomExtendP; rewrite ?lf1p.\nhave [[g Dy] [_ idKy]] := (kHom_to_AEnd homKy, kHomP homKy).\nhave <-: g a = b by rewrite -Dy ?memv_adjoin // (kHomExtend_val hom1K) ?lf1p.\nsuffices /nKE <-: g \\in kAEndf K by apply: memv_img.\nby rewrite inE kAutfE; apply/kAHomP=> c Kc; rewrite -Dy ?subvP_adjoin ?idKy.\nQed."
}
{
  "statement": "Lemma center_special_abelem : p.-group G -> special G -> p.-abelem 'Z(G).\n",
  "proof": "Proof.\nmove=> pG [defPhi defG'].\nhave [-> | ntG] := eqsVneq G 1; first by rewrite center1 abelem1.\nhave [p_pr _ _] := pgroup_pdiv pG ntG.\nhave fM: {in 'Z(G) &, {morph expgn^~ p : x y / x * y}}.\n  by move=> x y /setIP[_ /centP cxG] /setIP[/cxG cxy _]; apply: expgMn.\nrewrite abelemE //= center_abelian; apply/exponentP=> /= z Zz.\napply: (@kerP _ _ _ (Morphism fM)) => //; apply: subsetP z Zz.\nrewrite -{1}defG' gen_subG; apply/subsetP=> _ /imset2P[x y Gx Gy ->].\nhave Zxy: [~ x, y] \\in 'Z(G) by rewrite -defG' mem_commg.\nhave Zxp: x ^+ p \\in 'Z(G).\n  rewrite -defPhi (Phi_joing pG) (MhoE 1 pG) joing_idr mem_gen // !inE.\n  by rewrite expn1 orbC (imset_f (expgn^~ p)).\nrewrite mem_morphpre /= ?defG' ?Zxy // inE -commXg; last first.\n  by red; case/setIP: Zxy => _ /centP->.\nby apply/commgP; red; case/setIP: Zxp => _ /centP->.\nQed."
}
{
  "statement": "Lemma non_linear_gen_reducible : d > 1 -> mxnonsimple (map_repr gen rG) 1%:M.\n",
  "proof": "Proof.\nrewrite ltnNge mxminpoly_linear_is_scalar => Anscal.\npose Af := map_mx gen A; exists (kermx (Af - groot%:M)).\nrewrite submx1 kermx_centg_module /=; last first.\n  apply/centgmxP=> z Gz; rewrite mulmxBl mulmxBr scalar_mxC.\n  by rewrite -!map_mxM 1?(centgmxP cGA).\nrewrite andbC mxrank_ker -subn_gt0 mxrank1 subKn ?rank_leq_row // lt0n.\nrewrite mxrank_eq0 subr_eq0; case: eqP => [defAf | _].\n  rewrite -(map_mx_is_scalar gen) -/Af in Anscal.\n  by case/is_scalar_mxP: Anscal; exists groot.\nrewrite -mxrank_eq0 mxrank_ker subn_eq0 row_leq_rank.\napply/row_freeP=> [[XA' XAK]].\nhave pAf0: (mxminpoly Af).[groot] == 0.\n  by rewrite mxminpoly_map ?map_mxminpoly_groot.\nhave{pAf0} [q def_pAf]:= factor_theorem _ _ pAf0.\nhave q_nz: q != 0.\n  case: eqP (congr1 (fun p : {poly _} => size p) def_pAf) => // ->.\n  by rewrite size_mxminpoly mul0r size_poly0.\nhave qAf0: horner_mx Af q = 0.\n  rewrite -[_ q]mulr1 -[1]XAK mulrA -{2}(horner_mx_X Af) -(horner_mx_C Af).\n  by rewrite -rmorphB -rmorphM -def_pAf /= mx_root_minpoly mul0r.\nhave{qAf0} := dvdp_leq q_nz (mxminpoly_min qAf0); rewrite def_pAf.\nby rewrite size_Mmonic ?monicXsubC // polyseqXsubC addn2 ltnn.\nQed."
}
{
  "statement": "Lemma row_mxA m n1 n2 n3 (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) (A3 : 'M_(m, n3)) :\n  let cast := (erefl m, esym (addnA n1 n2 n3)) in\n  row_mx A1 (row_mx A2 A3) = castmx cast (row_mx (row_mx A1 A2) A3).\n",
  "proof": "Proof.\napply: (canRL (castmxKV _ _)); apply/matrixP=> i j.\nrewrite castmxE !mxE cast_ord_id; case: splitP => j1 /= def_j.\n  have: (j < n1 + n2) && (j < n1) by rewrite def_j lshift_subproof /=.\n  by move: def_j; do 2![case: splitP => // ? ->; rewrite ?mxE] => /ord_inj->.\ncase: splitP def_j => j2 ->{j} def_j /[!mxE].\n  have: ~~ (j2 < n1) by rewrite -leqNgt def_j leq_addr.\n  have: j1 < n2 by rewrite -(ltn_add2l n1) -def_j.\n  by move: def_j; do 2![case: splitP => // ? ->] => /addnI/val_inj->.\nhave: ~~ (j1 < n2) by rewrite -leqNgt -(leq_add2l n1) -def_j leq_addr.\nby case: splitP def_j => // ? ->; rewrite addnA => /addnI/val_inj->.\nQed."
}
{
  "statement": "Lemma pairwise_orthogonalP S :\n  reflect (uniq (0 :: S)\n             /\\ {in S &, forall phi psi, phi != psi -> '[phi, psi] = 0})\n          (pairwise_orthogonal S).\n",
  "proof": "Proof.\nrewrite /pairwise_orthogonal /=; case notS0: (~~ _); last by right; case.\nelim: S notS0 => [|phi S IH] /=; first by left.\nrewrite inE eq_sym andbT => /norP[nz_phi /IH{}IH].\nhave [opS | not_opS] := allP; last first.\n  right=> [[/andP[notSp _] opS]]; case: not_opS => psi Spsi /=.\n  by rewrite opS ?mem_head 1?mem_behead // (memPnC notSp).\nrewrite (contra (opS _)) /= ?cfnorm_eq0 //.\napply: (iffP IH) => [] [uniqS oSS]; last first.\n  by split=> //; apply: sub_in2 oSS => psi Spsi; apply: mem_behead.\nsplit=> // psi xi /[!inE] /predU1P[-> // | Spsi].\n  by case/predU1P=> [-> | /opS] /eqP.\ncase/predU1P=> [-> _ | Sxi /oSS-> //].\nby apply/eqP; rewrite cfdotC conjC_eq0 [_ == 0]opS.\nQed."
}
{
  "statement": "Lemma kHom_extends K E f p U :\n    (K <= E)%VS -> kHom K E f ->\n     p \\is a polyOver K -> splittingFieldFor E p U ->\n  {g | kHom K U g & {in E, f =1 g}}.\n",
  "proof": "Proof.\nmove=> sKE homEf Kp /sig2_eqW[rs Dp <-{U}].\nset r := rs; have rs_r: all [in rs] r by apply/allP.\nelim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in E f sKE homEf *.\n  by exists f; rewrite ?Fadjoin_nil.\nset Ez := <<E; z>>%AS; pose fpEz := map_poly f (minPoly E z).\nsuffices{IHr} /sigW[y fpEz_y]: exists y, root fpEz y.\n  have homEz_fz: kHom K Ez (kHomExtend E f z y) by apply: kHomExtendP.\n  have sKEz: (K <= Ez)%VS := subv_trans sKE (subv_adjoin E z).\n  have [g homGg Dg] := IHr rs_r _ _ sKEz homEz_fz.\n  exists g => [|x Ex]; first by rewrite adjoin_cons.\n  by rewrite -Dg ?subvP_adjoin // kHomExtend_id.\nhave [m DfpEz]: {m | fpEz %= \\prod_(w <- mask m rs) ('X - w%:P)}.\n  apply: dvdp_prod_XsubC; rewrite -(eqp_dvdr _ Dp) -(kHom_poly_id homEf Kp).\n  have /polyOver_subvs[q Dq] := polyOverSv sKE Kp.\n  have /polyOver_subvs[qz Dqz] := minPolyOver E z.\n  rewrite /fpEz Dq Dqz -2?{1}map_poly_comp (dvdp_map (kHom_rmorphism homEf)).\n  rewrite -(dvdp_map (@vsval _ _ E)) -Dqz -Dq.\n  by rewrite minPoly_dvdp ?(polyOverSv sKE) // (eqp_root Dp) root_prod_XsubC.\nexists (mask m rs)`_0; rewrite (eqp_root DfpEz) root_prod_XsubC mem_nth //.\nrewrite -ltnS -(size_prod_XsubC _ id) -(eqp_size DfpEz).\nrewrite size_poly_eq -?lead_coefE ?size_minPoly // (monicP (monic_minPoly E z)).\nby have [_ idKf] := kHomP homEf; rewrite idKf ?mem1v ?oner_eq0.\nQed."
}
{
  "statement": "Lemma injm_pprodm :\n  'injm f = [&& 'injm fH, 'injm fK & fH @* H :&: fK @* K == fH @* K].\n",
  "proof": "Proof.\napply/idP/and3P=> [injf | [injfH injfK]].\n  rewrite eq_sym -{1}morphimIdom -(morphim_pprodml (subsetIl _ _)) injmI //.\n  rewrite morphim_pprodml // morphim_pprodmr //=; split=> //.\n    apply/injmP=> x y Hx Hy /=; rewrite -!pprodmEl //.\n    by apply: (injmP injf); rewrite ?mem_gen ?inE ?Hx ?Hy.\n  apply/injmP=> a b Ka Kb /=; rewrite -!pprodmEr //.\n  by apply: (injmP injf); rewrite ?mem_gen //; apply/setUP; right.\nmove/eqP=> fHK; rewrite ker_pprodm; apply/subsetP=> y.\ncase/imset2P=> x a Hx /setIdP[Ka /eqP fxa] ->.\nhave: fH x \\in fH @* K by rewrite -fHK inE {2}fxa !mem_morphim.\ncase/morphimP=> z Hz Kz /(injmP injfH) def_x.\nrewrite def_x // eqfHK ?inE ?Hz // in fxa.\nby rewrite def_x // (injmP injfK _ _ Kz Ka fxa) mulgV set11.\nQed."
}
{
  "statement": "Lemma bigA_distr (R : Type) (zero one : R) (mul : Monoid.mul_law zero)\n  (add : Monoid.add_law zero mul) (I : finType) (F G : I -> R) :\n  \\big[mul/one]_i add (F i) (G i) =\n  \\big[add/zero]_(J in {set I}) \\big[mul/one]_i (if i \\in J then F i else G i).\n",
  "proof": "Proof.\nunder eq_bigr => i _ do rewrite -(big_bool _ (fun b => if b then F i else G i)).\nrewrite bigA_distr_bigA.\nset f := fun J : {set I} => val J.\ntransitivity (\\big[add/zero]_(f0 in (imset f (mem setT)))\n                \\big[mul/one]_i (if f0 i then F i else G i)).\n  suff <-: setT = imset f (mem setT) by apply: congr_big=>// i; rewrite in_setT.\n  apply/esym/eqP; rewrite -subTset; apply/subsetP => b _.\n  by apply/imsetP; exists (FinSet b).\nrewrite big_imset; last by case=> g; case=> h _ _; rewrite /f => /= ->.\napply: congr_big => //; case=> g; first exact: in_setT.\nby move=> _; apply: eq_bigr => i _; congr (if _ then _ else _); rewrite unlock.\nQed."
}
{
  "statement": "Lemma cycle_sub_group (a : gT) m :\n     m %| #[a] ->\n  [set H : {group gT} | H \\subset <[a]> & #|H| == m]\n     = [set <[a ^+ (#[a] %/ m)]>%G].\n",
  "proof": "Proof.\nmove=> m_dv_a; have m_gt0: 0 < m by apply: dvdn_gt0 m_dv_a.\nhave oam: #|<[a ^+ (#[a] %/ m)]>| = m.\n  apply/eqP; rewrite [#|_|]orderXgcd -(divnMr m_gt0) muln_gcdl divnK //.\n  by rewrite gcdnC gcdnMr mulKn.\napply/eqP; rewrite eqEsubset sub1set inE /= cycleX oam eqxx !andbT.\napply/subsetP=> X; rewrite in_set1 inE -val_eqE /= eqEcard oam.\ncase/andP=> sXa /eqP oX; rewrite oX leqnn andbT.\napply/subsetP=> x Xx; case/cycleP: (subsetP sXa _ Xx) => k def_x.\nhave: (x ^+ m == 1)%g by rewrite -oX -order_dvdn cardSg // gen_subG sub1set.\nrewrite {x Xx}def_x -expgM -order_dvdn -[#[a]](Lagrange sXa) -oX mulnC.\nrewrite dvdn_pmul2r // mulnK // => /dvdnP[i ->].\nby rewrite mulnC expgM groupX // cycle_id.\nQed."
}
{
  "statement": "Lemma rankEsum p : rank p = \\sum_(i < n | (i < tag p)%N) p_ i + tagged p :> nat.\n",
  "proof": "Proof.\npose sum p := \\sum_(i < n | (i < tag p)%N) p_ i + tagged p.\nrewrite -/(sum _); have sumlt : forall p, (sum p < \\sum_i p_ i)%N.\n  rewrite /sum => -[/= i j].\n  rewrite [ltnRHS](bigID [pred i' : 'I__ | (i' < i)%N])/= ltn_add2l.\n  by rewrite (bigD1 i) ?ltnn//= ltn_addr.\nsuff: rank =1 (fun p => Ordinal (sumlt p)) by move=> /(_ p)/(congr1 val).\napply: (Order.mono_unique _ _ le_rank) => //=.\n- exact: le_total.\n- by rewrite card card_ord.\napply: le_mono => /= -[i j] -[i' j']; rewrite ltEsig/= !ltEord/= /sum leEord/=.\ncase: (ltngtP i i') => //= [ltii' _|/val_inj ii']; last first.\n  by rewrite -ii' in j' *; rewrite tagged_asE => ltjj'; rewrite ltn_add2l.\nrewrite ltn_addr// (@leq_trans (\\sum_(i0 < n | (i0 < i)%N) p_ i0 + p_ i))%N//.\n  by rewrite ltn_add2l.\nrewrite [leqRHS](bigID [pred i' : 'I__ | (i' < i)%N])/=.\nrewrite leq_add//; last first.\n  by rewrite (bigD1 i) ?ltnn ?ltii'//= leq_addr.\nrewrite [leqRHS](eq_bigl [pred k : 'I_n | (k < i)%N])// => k/=.\nby case: (ltnP k i); rewrite ?andbF// => /ltn_trans->.\nQed."
}
{
  "statement": "Lemma tprodE m1 n1 p1 (A1 :'M[F]_(m1,n1)) (A2 :'M[F]_(n1,p1))\n             m2 n2 p2 (B1 :'M[F]_(m2,n2)) (B2 :'M[F]_(n2,p2)) :\n  tprod (A1 *m A2) (B1 *m B2) = (tprod A1 B1) *m (tprod A2 B2).\n",
  "proof": "Proof.\nelim: m1 n1 p1 A1 A2 m2 n2 p2 B1 B2 => /= [|m1 IH].\n  by move=> *; rewrite mul0mx.\nmove=> n1 p1 A1 A2 m2 n2 p2 B1 B2.\nrewrite mul_col_mx -IH.\ncongr col_mx; last by rewrite dsumx_mul.\nrewrite usumx_mul.\nelim: n1 {A1}(usubmx (A1: 'M_(1 + m1, n1))) p1 A2=> //= [u p1 A2|].\n  by rewrite [A2](flatmx0) !mulmx0 -trowbE linear0.\nmove=> n1 IH1 A p1 A2 //=.\nset Al := lsubmx _; set Ar := rsubmx _.\nset Su := usubmx _; set Sd := dsubmx _.\nrewrite mul_row_col -IH1.\nrewrite -{1}(@hsubmxK F 1 1 n1 A).\nrewrite -{1}(@vsubmxK F 1 n1 p1 A2).\nrewrite (@mul_row_col F 1 1 n1 p1).\nrewrite -trowbE linearD /= trowbE -/Al.\ncongr (_ + _).\nrewrite {1}[Al]mx11_scalar mul_scalar_mx.\nby rewrite -trowbE linearZ /= trowbE -/Su trow_mul scalemxAl.\nQed."
}
{
  "statement": "Lemma divp_divl r p q :\n    lead_coef r \\in GRing.unit -> lead_coef p \\in GRing.unit ->\n  q %/ p %/ r = q %/ (p * r).\n",
  "proof": "Proof.\nmove=> ulcr ulcp.\nhave e : q = (q %/ p %/ r) * (p * r) + ((q %/ p) %% r * p + q %% p).\n  by rewrite addrA (mulrC p) mulrA -mulrDl; rewrite -divp_eq //; apply: divp_eq.\nhave pn0 : p != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcp => ->; rewrite unitr0.\nhave rn0 : r != 0.\n  by rewrite -lead_coef_eq0; apply: contraTneq ulcr => ->; rewrite unitr0.\nhave s : size ((q %/ p) %% r * p + q %% p) < size (p * r).\n  have [-> | qn0] := eqVneq ((q %/ p) %% r) 0.\n    rewrite mul0r add0r size_mul // (polySpred rn0) addnS /=.\n    by apply: leq_trans (leq_addr _ _); rewrite ltn_modp.\n  rewrite size_polyDl mulrC.\n    by rewrite !size_mul // (polySpred pn0) !addSn /= ltn_add2l ltn_modp.\n  rewrite size_mul // (polySpred qn0) addnS /=.\n  by apply: leq_trans (leq_addr _ _); rewrite ltn_modp.\ncase: (edivpP _ e s) => //; rewrite lead_coefM unitrM_comm ?ulcp //.\nby red; rewrite mulrC.\nQed."
}
{
  "statement": "Lemma Cauchy_root_bound p : p != 0 -> {b | forall x, root p x -> `|x| <= b}.\n",
  "proof": "Proof.\nmove=> nz_p; set a := lead_coef p; set n := (size p).-1.\nhave [q Dp]: {q | forall x, x != 0 -> p.[x] = (a - q.[x^-1] / x) * x ^+ n}.\n  exists (- \\poly_(i < n) p`_(n - i.+1)) => x nz_x.\n  rewrite hornerN mulNr opprK horner_poly mulrDl !mulr_suml addrC.\n  rewrite horner_coef polySpred // big_ord_recr (reindex_inj rev_ord_inj) /=.\n  rewrite -/n -lead_coefE; congr (_ + _); apply: eq_bigr=> i _.\n  by rewrite exprB ?unitfE // -exprVn mulrA mulrAC exprSr mulrA.\nhave [b ub_q] := poly_disk_bound q 1; exists (b / `|a| + 1) => x px0.\nhave b_ge0: 0 <= b by rewrite (le_trans (normr_ge0 q.[1])) ?ub_q ?normr1.\nhave{b_ge0} ba_ge0: 0 <= b / `|a| by rewrite divr_ge0.\nrewrite real_leNgt ?rpredD ?rpred1 ?ger0_real //.\napply: contraL px0 => lb_x; rewrite rootE.\nhave x_ge1: 1 <= `|x| by rewrite (le_trans _ (ltW lb_x)) // ler_wpDl.\nhave nz_x: x != 0 by rewrite -normr_gt0 (lt_le_trans ltr01).\nrewrite {}Dp // mulf_neq0 ?expf_neq0 // subr_eq0 eq_sym.\nhave: (b / `|a|) < `|x| by rewrite (lt_trans _ lb_x) // ltr_pwDr ?ltr01.\napply: contraTneq => /(canRL (divfK nz_x))Dax.\nrewrite ltr_pdivrMr ?normr_gt0 ?lead_coef_eq0 // mulrC -normrM -{}Dax.\nby rewrite le_gtF // ub_q // normfV invf_le1 ?normr_gt0.\nQed."
}
{
  "statement": "Lemma gen_expgs A : {n | <<A>> = (1 |: A) ^+ n}.\n",
  "proof": "Proof.\nset B := (1 |: A); pose N := #|gT|.\nhave BsubG n : B ^+ n \\subset <<A>>.\n  by elim: n => [|n IHn]; rewrite ?expgS ?mul_subG ?subUset ?sub1G ?subset_gen.\nhave B_1 n : 1 \\in B ^+ n.\n  by elim: n => [|n IHn]; rewrite ?set11 // expgS mulUg mul1g inE IHn.\ncase: (pickP (fun i : 'I_N => B ^+ i.+1 \\subset B ^+ i)) => [n fixBn | no_fix].\n  exists n; apply/eqP; rewrite eqEsubset BsubG andbT.\n  rewrite -[B ^+ n]gen_set_id ?genS ?subsetUr //.\n    by apply: subset_trans fixBn; rewrite expgS mulUg subsetU ?mulg_subl ?orbT.\n  rewrite /group_set B_1 /=.\n  elim: {2}(n : nat) => [|m IHm]; first by rewrite mulg1.\n  by apply: subset_trans fixBn; rewrite !expgSr mulgA mulSg.\nsuffices: N < #|B ^+ N| by rewrite ltnNge max_card.\nhave [] := ubnPgeq N; elim=> [|n IHn] lt_nN; first by rewrite cards1.\napply: leq_ltn_trans (IHn (ltnW lt_nN)) (proper_card _).\nby rewrite /proper (no_fix (Ordinal lt_nN)) expgS mulUg mul1g subsetUl.\nQed."
}
{
  "statement": "Lemma component_mx_def : {I : finType & {W : I -> 'M_n |\n  forall i, mx_iso U (W i) & compU = \\sum_i W i}}%MS.\n",
  "proof": "Proof.\npose r i := row i iso_u; pose r_nz i := r i != 0; pose I := {i | r_nz i}.\nexists I; exists (fun i => cyclic_mx (r (sval i))) => [i|].\n  apply/mxsimple_isoP=> //; apply/and3P.\n  split; first by rewrite cyclic_mx_module.\n    apply/rowV0Pn; exists (r (sval i)); last exact: (svalP i).\n    by rewrite sub_capmx cyclic_mx_id row_sub.\n  have [f hom_u_f <-] := @row_hom_mxP u (r (sval i)) (row_sub _ _).\n  by rewrite defU -hom_cyclic_mx ?mxrankM_maxl.\nrewrite -(eq_bigr _ (fun _ _ => genmx_id _)) -genmx_sums -genmx_component.\nrewrite [in compU]unlock; apply/genmxP/andP; split; last first.\n  by apply/sumsmx_subP => i _; rewrite (sumsmx_sup (sval i)).\napply/sumsmx_subP => i _.\ncase i0: (r_nz i); first by rewrite (sumsmx_sup (Sub i i0)).\nby move/negbFE: i0; rewrite -cyclic_mx_eq0 => /eqP->; apply: sub0mx.\nQed."
}
{
  "statement": "Lemma Frobenius_reciprocity phi psi : '[phi, 'Res[H] psi] = '['Ind[G] phi, psi].\n",
  "proof": "Proof.\nhave [sHG | not_sHG] := boolP (H \\subset G); last first.\n  rewrite cfResEout // cfIndEout // cfdotZr cfdotZl mulrAC; congr (_ * _).\n  rewrite (cfdotEl _ (cfuni_on _ _)) mulVKf ?neq0CG // big_set1.\n  by rewrite cfuniE ?normal1 ?set11 ?mul1r.\ntransitivity (#|H|%:R^-1 * \\sum_(x in G) phi x * (psi x)^* ).\n  rewrite (big_setID H) /= (setIidPr sHG) addrC big1 ?add0r; last first.\n    by move=> x /setDP[_ /cfun0->]; rewrite mul0r.\n  by congr (_ * _); apply: eq_bigr => x Hx; rewrite cfResE.\nset h' := _^-1; apply: canRL (mulKf (neq0CG G)) _.\ntransitivity (h' * \\sum_(y in G) \\sum_(x in G) phi (x ^ y) * (psi (x ^ y))^* ).\n  rewrite mulrCA mulr_natl -sumr_const; congr (_ * _); apply: eq_bigr => y Gy.\n  by rewrite (reindex_acts 'J _ Gy) ?astabsJ ?normG.\nrewrite exchange_big mulr_sumr; apply: eq_bigr => x _; rewrite cfIndE //=.\nby rewrite -mulrA mulr_suml; congr (_ * _); apply: eq_bigr => y /(cfunJ psi)->.\nQed."
}
{
  "statement": "Lemma Frobenius_partition : partition (gval K |: (H^# :^: K)) G.\n",
  "proof": "Proof.\nhave [/eqP defG _ tiHG] := and3P frobG; have [_ tiH1G /eqP defN] := and3P tiHG.\nhave [[_ /mulG_sub[sKG sHG] nKH tiKH] mulHK] := (sdprodP defG, sdprodWC defG).\nset HG := H^# :^: K; set KHG := _ |: _.\nhave defHG: HG = H^# :^: G.\n  have: 'C_G[H^# | 'Js] * K = G by rewrite astab1Js defN mulHK.\n  move/subgroup_transitiveP/atransP.\n  by apply; rewrite ?atrans_orbit ?orbit_refl.\nhave /and3P[defHK _ nzHG] := partition_normedTI tiHG.\nrewrite -defHG in defHK nzHG tiH1G.\nhave [tiKHG HG'K]: trivIset KHG /\\ gval K \\notin HG.\n  apply: trivIsetU1 => // _ /imsetP[x Kx ->]; rewrite -setI_eq0.\n  by rewrite -(conjGid Kx) -conjIg setIDA tiKH setDv conj0g.\nrewrite /partition andbC tiKHG !inE negb_or nzHG eq_sym -card_gt0 cardG_gt0 /=.\nrewrite eqEcard; apply/andP; split.\n  rewrite /cover big_setU1 //= subUset sKG -/(cover HG) (eqP defHK).\n  by rewrite class_support_subG // (subset_trans _ sHG) ?subD1set.\nrewrite -(eqnP tiKHG) big_setU1 //= (eqnP tiH1G) (eqP defHK).\nrewrite (card_support_normedTI tiHG) -(Lagrange sHG) (cardsD1 1) group1 mulSn.\nby rewrite leq_add2r -mulHK indexMg -indexgI tiKH indexg1.\nQed."
}
{
  "statement": "Lemma cprodA : associative cprod.\n",
  "proof": "Proof.\nmove=> A B C; case A1: (A == 1); first by rewrite (eqP A1) !cprod1g.\ncase B1: (B == 1); first by rewrite (eqP B1) cprod1g cprodg1.\ncase C1: (C == 1); first by rewrite (eqP C1) !cprodg1.\nrewrite !(triv_cprod, cprod_ntriv) ?{}A1 ?{}B1 ?{}C1 //.\ncase: isgroupP => [[G ->{A}] | _]; last by rewrite group0.\ncase: (isgroupP B) => [[H ->{B}] | _]; last by rewrite group0.\ncase: (isgroupP C) => [[K ->{C}] | _]; last by rewrite group0 !andbF.\ncase cGH: (H \\subset 'C(G)); case cHK: (K \\subset 'C(H)); last first.\n- by rewrite group0.\n- by rewrite group0 /= mulG_subG cGH andbF.\n- by rewrite group0 /= centM subsetI cHK !andbF.\nrewrite /= mulgA mulG_subG centM subsetI cGH cHK andbT -(cent_joinEr cHK).\nby rewrite -(cent_joinEr cGH) !groupP.\nQed."
}
{
  "statement": "Lemma mem_bigdprod (I : finType) (P : pred I) F G x :\n    \\big[dprod/1]_(i | P i) F i = G -> x \\in G ->\n  exists c, [/\\ forall i, P i -> c i \\in F i, x = \\prod_(i | P i) c i\n              & forall e, (forall i, P i -> e i \\in F i) ->\n                          x = \\prod_(i | P i) e i ->\n                forall i, P i -> e i = c i].\n",
  "proof": "Proof.\nmove=> defG; rewrite -(bigdprodW defG) => /prodsgP[c Fc ->].\nhave [r big_r [_ mem_r] _] := big_enumP P.\nexists c; split=> // e Fe eq_ce i Pi; rewrite -!{}big_r in defG eq_ce.\nhave{Pi}: i \\in r by rewrite mem_r.\nhave{mem_r}: all P r by apply/allP=> j; rewrite mem_r.\nelim: r G defG eq_ce => // j r IHr G.\nrewrite !big_cons inE /= => /dprodP[[K H defK defH] _ _].\nrewrite defK defH => tiFjH eq_ce /andP[Pj Pr].\nsuffices{i IHr} eq_cej: c j = e j.\n  case/predU1P=> [-> //|]; apply: IHr defH _ Pr.\n  by apply: (mulgI (c j)); rewrite eq_ce eq_cej.\nrewrite !(big_nth j) !big_mkord in defH eq_ce.\nmove/(congr1 (divgr K H)): eq_ce; move/bigdprodW: defH => defH.\nmove/(all_nthP j) in Pr.\nby rewrite !divgrMid // -?defK -?defH ?mem_prodg // => *; rewrite ?Fc ?Fe ?Pr.\nQed."
}
{
  "statement": "Lemma partn_exponentS pi H G :\n  H \\subset G -> #|G|`_pi %| #|H| -> (exponent H)`_pi = (exponent G)`_pi.\n",
  "proof": "Proof.\nmove=> sHG Gpi_dvd_H; apply/eqP; rewrite eqn_dvd.\nrewrite partn_dvd ?exponentS ?exponent_gt0 //=; apply/dvdn_partP=> // p.\nrewrite pi_of_part ?exponent_gt0 // => /andP[_ /= pi_p].\nhave sppi: {subset (p : nat_pred) <= pi} by move=> q /eqnP->.\nhave [P sylP] := Sylow_exists p H; have sPH := pHall_sub sylP.\nhave{} sylP: p.-Sylow(G) P.\n  rewrite pHallE (subset_trans sPH) //= (card_Hall sylP) eqn_dvd andbC.\n  by rewrite -{1}(partn_part _ sppi) !partn_dvd ?cardSg ?cardG_gt0.\nrewrite partn_part ?partn_biglcm //.\napply: (@big_ind _ (dvdn^~ _)) => [|m n|x Gx]; first exact: dvd1n.\n  by rewrite dvdn_lcm => ->.\nrewrite -order_constt; have p_y := p_elt_constt p x; set y := x.`_p in p_y *.\nhave sYG: <[y]> \\subset G by rewrite cycle_subG groupX.\nhave [z _ Pyz] := Sylow_Jsub sylP sYG p_y.\nrewrite (bigD1 (y ^ z))  ?(subsetP sPH) -?cycle_subG ?cycleJ //=.\nby rewrite orderJ part_pnat_id ?dvdn_lcml // (pi_pnat p_y).\nQed."
}
{
  "statement": "Lemma order_inj_cyclic :\n  {in G &, forall x y, #[x] = #[y] -> <[x]> = <[y]>} -> cyclic G.\n",
  "proof": "Proof.\nmove=> ucG; apply: negbNE (contra _ (negbT (ltnn #|G|))) => ncG.\nrewrite -{2}[#|G|]sum_totient_dvd big_mkcond (bigD1 ord_max) ?dvdnn //=.\nrewrite -{1}[#|G|]sum_ncycle_totient (bigD1 ord_max) //= -addSn leq_add //.\n  rewrite eq_card0 ?totient_gt0 ?cardG_gt0 // => C.\n  apply/imsetP=> [[x /setIdP[Gx /eqP oxG]]]; case/cyclicP: ncG.\n  by exists x; apply/eqP; rewrite eq_sym eqEcard cycle_subG Gx -oxG /=.\nelim/big_ind2: _ => // [m1 n1 m2 n2 | d _]; first exact: leq_add.\nset Gd := _ @: _; case: (set_0Vmem Gd) => [-> | [C]]; first by rewrite cards0.\nrewrite {}/Gd => /imsetP[x /setIdP[Gx /eqP <-] _ {C d}].\nrewrite order_dvdG // (@eq_card1 _ <[x]>) ?mul1n // => C.\napply/idP/eqP=> [|-> {C}]; last by rewrite imset_f // inE Gx eqxx.\nby case/imsetP=> y /setIdP[Gy /eqP/ucG->].\nQed."
}
{
  "statement": "Lemma Clifford_Res_sum_cfclass i j :\n     H <| G -> j \\in irr_constt ('Res[H, G] 'chi_i) ->\n  'Res[H] 'chi_i =\n     '['Res[H] 'chi_i, 'chi_j] *: (\\sum_(chi <- ('chi_j ^: G)%CF) chi).\n",
  "proof": "Proof.\nmove=> nsHG chiHj; have [sHG /subsetP nHG] := andP nsHG.\nrewrite reindex_cfclass //= big_mkcond.\nrewrite {1}['Res _]cfun_sum_cfdot linear_sum /=; apply: eq_bigr => k _.\nhave [[y Gy ->] | ] := altP (cfclassP _ _ _); first by rewrite cfdot_Res_conjg.\napply: contraNeq; rewrite scaler0 scaler_eq0 orbC => /norP[_ chiHk].\nhave{chiHk chiHj}: '['Res[H] ('Ind[G] 'chi_j), 'chi_k] != 0.\n  rewrite !inE !cfdot_Res_l in chiHj chiHk *.\n  apply: contraNneq chiHk; rewrite cfdot_sum_irr => /psumr_eq0P/(_ i isT)/eqP.\n  rewrite -cfdotC cfdotC mulf_eq0 conjC_eq0 (negbTE chiHj) /= => -> // i1.\n  by rewrite -cfdotC natr_ge0 // rpredM ?Cnat_cfdot_char ?cfInd_char ?irr_char.\nrewrite cfResInd // cfdotZl mulf_eq0 cfdot_suml => /norP[_].\napply: contraR => chiGk'j; rewrite big1 // => x Gx; apply: contraNeq chiGk'j.\nrewrite -conjg_IirrE cfdot_irr pnatr_eq0; case: (_ =P k) => // <- _.\nby rewrite conjg_IirrE; apply/cfclassP; exists x.\nQed."
}
{
  "statement": "Lemma cfIndMorph (f : {morphism D >-> rT}) (phi : 'CF(f @* H)) :\n    'ker f \\subset H -> H \\subset G -> G \\subset D ->\n  'Ind[G] (cfMorph phi) = cfMorph ('Ind[f @* G] phi).\n",
  "proof": "Proof.\nmove=> sKH sHG sGD; have [sHD inD] := (subset_trans sHG sGD, subsetP sGD).\napply/cfun_inP=> /= x Gx; have [Dx sKG] := (inD x Gx, subset_trans sKH sHG).\nrewrite cfMorphE ?cfIndE ?morphimS // (partition_big_imset f) -morphimEsub //=.\nrewrite card_morphim (setIidPr sHD) natf_indexg // invfM invrK -mulrA.\ncongr (_ * _); rewrite mulr_sumr; apply: eq_bigr => _ /morphimP[y Dy Gy ->].\nrewrite -(card_rcoset _ y) mulr_natl -sumr_const.\napply: eq_big => [z | z /andP[Gz /eqP <-]].\n  have [Gz | G'z] := boolP (z \\in G).\n    by rewrite (sameP eqP (rcoset_kerP _ _ _)) ?inD.\n  by case: rcosetP G'z => // [[t Kt ->]]; rewrite groupM // (subsetP sKG).\nhave [Dz Dxz] := (inD z Gz, inD (x ^ z) (groupJ Gx Gz)); rewrite -morphJ //.\nhave [Hxz | notHxz] := boolP (x ^ z \\in H); first by rewrite cfMorphE.\nby rewrite !cfun0 // -sub1set -morphim_set1 // morphimSGK ?sub1set.\nQed."
}
{
  "statement": "Lemma card_n2 : forall x y z t : square, uniq [:: x; y; z; t] ->\n  #|[set p : col_squares | (p x == p y) && (p z == p t)]| = (n ^ 2)%N.\n",
  "proof": "Proof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\npose f (p : col_squares) := (p x, p z); rewrite -(@card_in_image _ _ f).\n  rewrite -mulnn -card_prod; apply: eq_card => [] [c d] /=; apply/imageP.\n  rewrite (cat_uniq [::x; y]) in Uxt; case/and3P: Uxt => _.\n  rewrite /= !orbF !andbT => /norP[] /[!inE] nxzt nyzt _.\n  exists [ffun i => if pred2 x y i then c else d].\n    by rewrite inE !ffunE /= !eqxx orbT (negbTE nxzt) (negbTE nyzt) !eqxx.\n  by rewrite {}/f !ffunE /= eqxx (negbTE nxzt).\nmove=> p1 p2 /[!inE] /andP[p1y p1t] /andP[p2y p2t] [px pz].\nhave eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t].\n  by rewrite /= -(eqP p1y) -(eqP p1t) -(eqP p2y) -(eqP p2t) px pz !eqxx.\napply/ffunP=> i; apply/eqP; apply: (allP eqp12).\nby rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxt) card_ord.\nQed."
}
{
  "statement": "Lemma eval_gen_term e t :\n  GRing.rterm t -> eval_mx (gen_env e) (gen_term t) = val (GRing.eval e t).\n",
  "proof": "Proof.\nelim: t => //=.\n- by move=> k _; apply/rowP=> i; rewrite !mxE /= nth_row_env nth_map_rVval.\n- by move=> x _; rewrite eval_mx_term.\n- by move=> x _; rewrite eval_mx_term.\n- by move=> t1 + t2 + /andP[rt1 rt2] => <-// <-//; apply/rowP => k /[!mxE].\n- by move=> t1 + rt1 => <-//; apply/rowP=> k /[!mxE].\n- move=> t1 IH1 n1 rt1; rewrite eval_mulmx eval_mx_term mul_scalar_mx.\n  by rewrite scaler_nat {}IH1 //; elim: n1 => //= n1 IHn1; rewrite !mulrS IHn1.\n- by move=> t1 IH1 t2 IH2 /andP[rt1 rt2]; rewrite eval_mulT IH1 ?IH2.\nmove=> t1 + n1 => /[apply] IH1.\nelim: n1 => [|n1 IHn1] /=; first by rewrite eval_mx_term.\nby rewrite eval_mulT exprS IH1 IHn1.\nQed."
}
{
  "statement": "Lemma dec_mx_reducible_semisimple U :\n  mxmodule rG U -> mx_completely_reducible rG U -> mxsemisimple rG U.\n",
  "proof": "Proof.\nhave [m] := ubnP (\\rank U); elim: m U => // m IHm U leUm modU redU.\nhave [U0 | nzU] := eqVneq U 0.\n  have{} U0: (\\sum_(i < 0) 0 :=: U)%MS by rewrite big_ord0 U0.\n  by apply: (intro_mxsemisimple U0); case.\nhave [V simV sVU] := dec_mxsimple_exists modU nzU; have [modV nzV _] := simV.\nhave [W modW defVW dxVW] := redU V modV sVU.\nhave [||I W_ /= simW defW _] := IHm W _ modW.\n- rewrite ltnS in leUm; apply: leq_trans leUm.\n  by rewrite -defVW (mxdirectP dxVW) /= -add1n leq_add2r lt0n mxrank_eq0.\n- by apply: mx_reducibleS redU; rewrite // -defVW addsmxSr.\nsuffices defU: (\\sum_i oapp W_ V i :=: U)%MS.\n  by apply: (intro_mxsemisimple defU) => [] [|i] //=.\napply: eqmx_trans defVW; rewrite (bigD1 None) //=; apply/eqmxP.\nhave [i0 _ | I0] := pickP I.\n  by rewrite (reindex some) ?addsmxS ?defW //; exists (odflt i0) => //; case.\nrewrite big_pred0 //; last by case=> // /I0.\nby rewrite !addsmxS ?sub0mx // -defW big_pred0.\nQed."
}
{
  "statement": "Lemma zcontentsM p q : zcontents (p * q) = zcontents p * zcontents q.\n",
  "proof": "Proof.\nhave [-> | nz_p] := eqVneq p 0; first by rewrite !(mul0r, zcontents0).\nhave [-> | nz_q] := eqVneq q 0; first by rewrite !(mulr0, zcontents0).\nrewrite -[zcontents q]mulr1 {1}[p]zpolyEprim {1}[q]zpolyEprim.\nrewrite -scalerAl -scalerAr !zcontentsZ; congr (_ * (_ * _)).\nrewrite [zcontents _]intEsg sgz_contents lead_coefM sgzM !sgz_lead_primitive.\napply/eqP; rewrite nz_p nz_q !mul1r [_ == _]eqn_leq absz_gt0 zcontents_eq0.\nrewrite mulf_neq0 ?zprimitive_eq0 // andbT leqNgt.\napply/negP=> /pdivP[r r_pr r_dv_d]; pose to_r : int -> 'F_r := intr.\nhave nz_prim_r q1: q1 != 0 -> map_poly to_r (zprimitive q1) != 0.\n  move=> nz_q1; apply: contraTneq (prime_gt1 r_pr) => r_dv_q1.\n  rewrite -leqNgt dvdn_leq // -(dvdzE r true) -nz_q1 -zcontents_primitive.\n  rewrite dvdz_contents; apply/polyOverP=> i /=; rewrite dvdzE /=.\n  have /polyP/(_ i)/eqP := r_dv_q1; rewrite coef_map coef0 /=.\n  rewrite {1}[_`_i]intEsign rmorphM /= rmorph_sign /= mulf_eq0 signr_eq0 /=.\n  by rewrite -val_eqE /= val_Fp_nat.\nsuffices{nz_prim_r} /idPn[]: map_poly to_r (zprimitive p * zprimitive q) == 0.\n  by rewrite rmorphM mulf_neq0 ?nz_prim_r.\nrewrite [_ * _]zpolyEprim [zcontents _]intEsign mulrC -scalerA map_polyZ /=.\nby rewrite scale_poly_eq0 -val_eqE /= val_Fp_nat ?(eqnP r_dv_d).\nQed."
}
{
  "statement": "Lemma maxainv_asimple_quo (G H : {group rT}) :\n   H \\subset D -> maxainv to G H -> asimple (to / H) (G / H).\n",
  "proof": "Proof.\nmove=> sHD /maxgroupP[/and3P[nHG pHG aH] Hmax].\napply/asimpleP; split; first by rewrite -subG1 quotient_sub1 ?normal_norm.\nmove=> K' nK'Q aK'.\nhave: (K' \\proper (G / H)) || (G / H == K').\n  by rewrite properE eqEsubset andbC (normal_sub nK'Q) !andbT orbC orbN.\ncase/orP=> [ pHQ | eQH]; last by right; apply sym_eq; apply/eqP.\nleft; pose K := ((coset H) @*^-1 K')%G.\nhave eK'I : K' \\subset (coset H) @* 'N(H).\n  by rewrite (subset_trans (normal_sub nK'Q)) ?morphimS ?normal_norm.\nhave eKK' : K' :=: K / H by rewrite /(K / H) morphpreK //=.\nsuff eKH : K :=: H by rewrite -trivg_quotient eKK' eKH.\nhave sHK : H \\subset K by rewrite -ker_coset kerE morphpreS // sub1set group1.\napply: Hmax => //; apply/and3P; split; last exact: qacts_cosetpre.\n  by rewrite -(quotientGK nHG) cosetpre_normal.\nby move: (proper_subn pHQ); rewrite sub_morphim_pre ?normal_norm.\nQed."
}
{
  "statement": "Lemma tprod1 m n : tprod (1%:M : 'M[F]_(m,m)) (1%:M : 'M[F]_(n,n)) = 1%:M.\n",
  "proof": "Proof.\nelim: m n => [|m IH] n //=; first by rewrite [1%:M]flatmx0.\nrewrite tprod_tr.\nset u := rsubmx _; have->: u = 0.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j=> /= j Hj; case.\nset v := lsubmx (dsubmx _); have->: v = 0.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j; case.\nset w := rsubmx _; have->: w = 1%:M.\n  apply/matrixP=> i j; rewrite !mxE.\n  by case: i; case: j; case.\nrewrite IH -!trowbE !linear0.\nrewrite -block_mxEv.\nset z := (lsubmx _) 0 0; have->: z = 1.\n  by rewrite /z !mxE eqxx.\nby rewrite scale1r scalar_mx_block.\nQed."
}
{
  "statement": "Lemma qpoly_mulVz (p : {poly %/ h}) : coprimep hQ p -> (qpoly_inv p * p = 1)%R.\n",
  "proof": "Proof.\nhave hQM := monic_mk_monic h.\nmove=> hCp; apply: val_inj; rewrite /qpoly_inv /in_qpoly hCp /=.\nhave p_neq0 : p != 0%R.\n  apply/eqP=> pZ; move: hCp; rewrite pZ.\n  rewrite coprimep0 -size_poly_eq1.\n  by case: size (size_mk_monic_gt1 h) => [|[]].\nhave F : (egcdp hQ p).1 * hQ + (egcdp hQ p).2 * p %= 1.\n  apply: eqp_trans _ (_ : gcdp hQ p %= _).\n    rewrite eqp_sym.\n    by case: (egcdpP (mk_monic_neq0 h) p_neq0).\n  by rewrite -size_poly_eq1.\nrewrite rmodp_mulml // -scalerAl rmodpZ // rmodp_mulml //.\nrewrite -[rmodp]/Pdiv.Ring.rmodp -!Pdiv.IdomainMonic.modpE //.\nhave := eqp_modpl hQ F.\nrewrite modpD // modp_mull add0r // .\nrewrite [(1 %% _)%R]modp_small => // [egcdE|]; last first.\n  by rewrite size_polyC oner_eq0 size_mk_monic_gt1.\nrewrite {2}(eqpfP egcdE) lead_coefC divr1 alg_polyC scale_polyC mulVf //.\nrewrite lead_coef_eq0.\napply/eqP => egcdZ.\nby move: egcdE; rewrite -size_poly_eq1 egcdZ size_polyC eq_sym  eqxx.\nQed."
}
{
  "statement": "Lemma sum_totient_dvd n : \\sum_(d < n.+1 | d %| n) totient d = n.\n",
  "proof": "Proof.\ncase: n => [|[|n']]; try by rewrite big_mkcond !big_ord_recl big_ord0.\nset n := n'.+2; pose x1 : 'Z_n := 1%R.\nhave ox1: #[x1] = n by rewrite /order -Zp_cycle card_Zp.\nrewrite -[rhs in _ = rhs]ox1 -[#[_]]sum_ncycle_totient [#|_|]ox1 big_mkcond /=.\napply: eq_bigr => d _; rewrite -{2}ox1; case: ifP => [|ndv_dG]; last first.\n  rewrite eq_card0 // => C; apply/imsetP=> [[x /setIdP[Gx oxd] _{C}]].\n  by rewrite -(eqP oxd) order_dvdG in ndv_dG.\nmove/cycle_sub_group; set Gd := [set _] => def_Gd.\nrewrite (_ : _ @: _ = @gval _ @: Gd); first by rewrite imset_set1 cards1 mul1n.\napply/setP=> C; apply/idP/imsetP=> [| [gC GdC ->{C}]].\n  case/imsetP=> x /setIdP[_ oxd] ->; exists <[x]>%G => //.\n  by rewrite -def_Gd inE -Zp_cycle subsetT.\nhave:= GdC; rewrite -def_Gd => /setIdP[_ /eqP <-].\nby rewrite (set1P GdC) /= imset_f // inE eqxx (mem_cycle x1).\nQed."
}
{
  "statement": "Lemma cfcenter_cyclic chi : cyclic ('Z(chi)%CF / cfker chi)%g.\n",
  "proof": "Proof.\ncase Nchi: (chi \\is a character); last first.\n  by rewrite /cfcenter Nchi trivg_quotient cyclic1.\nhave [-> | nz_chi] := eqVneq chi 0.\n  rewrite quotientS1 ?cyclic1 //= /cfcenter cfkerEchar ?cfun0_char //.\n  by apply/subsetP=> x /setIdP[Gx _]; rewrite inE Gx /= !cfunE.\nhave [xi Lxi def_chi] := cfcenter_Res chi.\nset Z := ('Z(_))%CF in xi Lxi def_chi *.\nhave sZG: Z \\subset G by apply: cfcenter_sub.\nhave ->: cfker chi = cfker xi.\n  rewrite -(setIidPr (normal_sub (cfker_center_normal _))) -/Z.\n  rewrite !cfkerEchar // ?lin_charW //= -/Z.\n  apply/setP=> x /[!inE]; apply: andb_id2l => Zx.\n  rewrite (subsetP sZG) //= -!(cfResE chi sZG) ?group1 // def_chi !cfunE.\n  by rewrite (inj_eq (mulfI _)) ?char1_eq0.\nhave: abelian (Z / cfker xi) by rewrite sub_der1_abelian ?lin_char_der1.\nhave /irr_reprP[rG irrG ->] := lin_char_irr Lxi; rewrite cfker_repr.\napply: mx_faithful_irr_abelian_cyclic (kquo_mx_faithful rG) _.\nexact/quo_mx_irr.\nQed."
}
{
  "statement": "Lemma mx_rsim_iso n (rG : reprG n) (U V : 'M_n)\n                  (modU : mxmodule rG U) (modV : mxmodule rG V) :\n  mx_rsim (submod_repr modU) (submod_repr modV) <-> mx_iso rG U V.\n",
  "proof": "Proof.\nsplit=> [[B eqrUV injB homB] | [f injf homf defV]].\n  have: \\rank (U *m val_submod (in_submod U 1%:M *m B)) = \\rank U.\n    do 2!rewrite mulmxA mxrankMfree ?row_base_free //.\n    by rewrite -(eqmxMr _ (val_submod1 U)) -in_submodE val_submodK mxrank1.\n  case/complete_unitmx => f injf defUf; exists f => //.\n    apply/hom_mxP=> x Gx; rewrite -defUf -2!mulmxA -(val_submodJ modV) //.\n    rewrite -(mulmxA _ B) -homB // val_submodE 3!(mulmxA U) (mulmxA _ _ B).\n    rewrite -in_submodE -in_submodJ //.\n    have [u ->] := submxP (mxmoduleP modU x Gx).\n    by rewrite in_submodE -mulmxA -defUf !mulmxA !mulmx1.\n  apply/eqmxP; rewrite -mxrank_leqif_eq.\n    by rewrite mxrankMfree ?eqrUV ?row_free_unit.\n  by rewrite -defUf mulmxA val_submodP.\nhave eqrUV: \\rank U = \\rank V by rewrite -defV mxrankMfree ?row_free_unit.\nexists (in_submod V (val_submod 1%:M *m f)) => // [|x Gx].\n  rewrite /row_free {6}eqrUV -[_ == _]sub1mx -val_submodS.\n  rewrite in_submodK; last by rewrite -defV submxMr ?val_submodP.\n  by rewrite val_submod1 -defV submxMr ?val_submod1.\nrewrite -in_submodJ; last by rewrite -defV submxMr ?val_submodP.\nrewrite -(hom_mxP (submx_trans (val_submodP _) homf)) // -(val_submodJ modU) //.\nby rewrite  mul1mx 2!(mulmxA ((submod_repr _) x)) -val_submodE.\nQed."
}
{
  "statement": "Lemma row_hom_mxP u v :\n  reflect (exists2 f, u <= dom_hom_mx f & u *m f = v)%MS (v <= row_hom_mx u)%MS.\n",
  "proof": "Proof.\napply: (iffP sub_bigcapmxP) => [iso_uv | [f hom_uf <-] i _].\n  have{iso_uv} uv0 A: (A \\in E_G)%MS /\\ u *m A = 0 -> v *m A = 0.\n    move/annihilator_mxP=> /submxP[a defA].\n    rewrite -[A]mxvecK {A}defA [a *m _]mulmx_sum_row !linear_sum big1 // => i _.\n    by rewrite !linearZ /= (sub_kermxP _) ?scaler0 ?iso_uv.\n  pose U := E_G *m lin_mul_row u; pose V :=  E_G *m lin_mul_row v.\n  pose f := pinvmx U *m V.\n  have hom_uv_f x: x \\in G -> u *m rG x *m f = v *m rG x.\n    move=> Gx; apply/eqP; rewrite 2!mulmxA mul_rV_lin1 -subr_eq0 -mulmxBr /=.\n    rewrite uv0 // linearB /= mulmxBr vec_mxK; split. \n      by rewrite addmx_sub ?submxMl // eqmx_opp envelop_mx_id.\n    have Uux: (u *m rG x <= U)%MS.\n      by rewrite -(genmxE U) mxmodule_trans ?cyclic_mx_id ?cyclic_mx_module.\n    by rewrite -{2}(mulmxKpV Uux) [_ *m U]mulmxA mul_rV_lin1 subrr.\n  have def_uf: u *m f = v.\n    by rewrite -[u]mulmx1 -[v]mulmx1 -(repr_mx1 rG) hom_uv_f.\n  by exists f => //; apply/hom_mxP=> x Gx; rewrite def_uf hom_uv_f.\napply/sub_kermxP; set A := vec_mx _.\nhave: (A \\in annihilator_mx u)%MS by rewrite vec_mxK row_sub.\nby case/annihilator_mxP => E_A uA0; rewrite -hom_envelop_mxC // uA0 mul0mx.\nQed."
}
{
  "statement": "Theorem fin_Csubring_Aint S n (Y : n.-tuple algC) :\n     mulr_closed S -> (forall x, reflect (inIntSpan Y x) (x \\in S)) ->\n  {subset S <= Aint}.\n",
  "proof": "Proof.\nmove=> mulS.\npose Sm := GRing.isMulClosed.Build _ _ mulS.\npose SC : mulrClosed _ := HB.pack S Sm.\nhave ZP_C c: (ZtoC c)%:P \\is a polyOver Num.int_num_subdef.\n  by rewrite raddfMz rpred_int.\nmove=> S_P x Sx; pose v := \\row_(i < n) Y`_i.\nhave [v0 | nz_v] := eqVneq v 0.\n  case/S_P: Sx => {}x ->; rewrite big1 ?isAlgInt0 // => i _.\n  by have /rowP/(_ i)/[!mxE] -> := v0; rewrite mul0rz.\nhave sYS (i : 'I_n): x * Y`_i \\in SC.\n  by rewrite rpredM //; apply/S_P/Cint_spanP/mem_Cint_span/memt_nth.\npose A := \\matrix_(i, j < n) sval (sig_eqW (S_P _ (sYS j))) i.\npose p := char_poly (map_mx ZtoC A).\nhave: p \\is a polyOver Num.int_num_subdef.\n  rewrite rpred_sum // => s _; rewrite rpredMsign rpred_prod // => j _.\n  by rewrite !mxE /= rpredB ?rpredMn ?polyOverX.\napply: root_monic_Aint (char_poly_monic _).\nrewrite -eigenvalue_root_char; apply/eigenvalueP; exists v => //.\napply/rowP=> j; case dAj: (sig_eqW (S_P _ (sYS j))) => [a DxY].\nby rewrite !mxE DxY; apply: eq_bigr => i _; rewrite !mxE dAj /= mulrzr.\nQed."
}
{
  "statement": "Lemma asimple_acompsP K s : acomps K s -> reflect (s = [:: 1%G]) (asimple K).\n",
  "proof": "Proof.\nmove=> cs; apply: (iffP idP); last first.\n  by move=> se; move: cs; rewrite se /=; case/andP=> /=; rewrite andbT.\ncase: s cs.\n  by rewrite /acomps /= andbT; move/eqP->; case/asimpleP; rewrite eqxx.\nmove=> H s cs sG; apply/eqP.\nrewrite eqseq_cons -(trivg_acomps (acomps_cons cs)) andbC andbb.\ncase/acompsP: cs => /= ls; case/andP=> mH ps.\ncase/maxgroupP: sG; case/and3P => _ ntG _ ->; rewrite ?sub1G //.\nrewrite (maxainv_norm mH); case/andP: (maxainv_proper mH)=> _ ->.\nexact: (maxainv_ainvar mH).\nQed."
}
{
  "statement": "Lemma dirr_small_norm (phi : 'CF(G)) n :\n  phi \\in 'Z[irr G] -> '[phi] = n%:R -> (n < 4)%N ->\n  [/\\ #|dirr_constt phi| = n, dirr_constt phi :&: dirr_constt (- phi) = set0 &\n      phi = \\sum_(i in dirr_constt phi) dchi i].\n",
  "proof": "Proof.\nmove=> PiZ Pln; rewrite ltnNge -leC_nat => Nl4.\nsuffices Fd i: i \\in dirr_constt phi -> '[phi, dchi i] = 1.\n  split; last 2 [by apply/setP=> u; rewrite !inE cfdotNl oppr_gt0 lt_asym].\n    apply/eqP; rewrite -eqC_nat -sumr_const -Pln (cnorm_dconstt PiZ).\n    by apply/eqP/eq_bigr=> i Hi; rewrite Fd // expr1n.\n  rewrite {1}[phi]cfun_sum_dconstt //.\n  by apply: eq_bigr => i /Fd->; rewrite scale1r.\nmove=> IiD; apply: contraNeq Nl4 => phi_i_neq1.\nrewrite -Pln cnorm_dconstt // (bigD1 i) ?ler_wpDr ?sumr_ge0 //=.\n  by move=> j /andP[JiD _]; rewrite exprn_ge0 ?natr_ge0 ?Cnat_dirr.\nhave /natrP[m Dm] := Cnat_dirr PiZ IiD; rewrite Dm -natrX ler_nat (leq_sqr 2).\nby rewrite ltn_neqAle eq_sym -eqC_nat -ltC_nat -Dm phi_i_neq1 -dirr_consttE.\nQed."
}
{
  "statement": "Lemma maxrowsub_free : row_free (rowsub mxf A).\n",
  "proof": "Proof.\nrewrite /mxf; case: arg_maxnP => //= f _ fM; apply/negP => /negP rfA.\nhave [i NriA] : exists i, ~~ (row i A <= rowsub f A)%MS.\n  by apply/row_subPn; apply: contraNN rfA => /mxrankS; rewrite row_leq_rank.\nhave [j rjfA] : exists j, (row (f j) A <= rowsub (f \\o lift j) A)%MS.\n  case/row_freePn: rfA => j.\n  by rewrite row_rowsub row'Esub -mxsub_comp; exists j.\npose g : 'I_m ^ \\rank A := finfun [eta f with j |-> i].\nsuff: (rowsub f A < rowsub g A)%MS by rewrite ltmxErank andbC ltnNge fM.\nrewrite ltmxE; apply/andP; split; last first.\n  apply: contra NriA; apply: submx_trans.\n  by rewrite (eq_row_sub j)// row_rowsub ffunE/= eqxx.\napply/row_subP => k; rewrite !row_rowsub.\nhave [->|/negPf eq_kjF] := eqVneq k j; last first.\n  by rewrite (eq_row_sub k)// row_rowsub ffunE/= eq_kjF.\nrewrite (submx_trans rjfA)// (submx_rowsub (lift j))// => l /=.\nby rewrite ffunE/= eq_sym (negPf (neq_lift _ _)).\nQed."
}
{
  "statement": "Lemma signP (l u : itv_bound int) (x : R) :\n    (num_itv_bound R l <= BLeft x)%O -> (BRight x <= num_itv_bound R u)%O ->\n    x \\in Num.real ->\n  sign_spec l u x (sign (Interval l u)).\n",
  "proof": "Proof.\nmove=> + + xr; rewrite /sign/sign_boundl/sign_boundr.\nhave [lneg|lpos|->] := ltgtP l; have [uneg|upos|->] := ltgtP u => lx xu.\n- apply: ISignNonPos => //; first exact: ltW.\n  have:= le_trans xu (eqbRL (le_num_itv_bound _ _) (ltW uneg)).\n  by rewrite bnd_simp.\n- exact: ISignBoth.\n- exact: ISignNonPos.\n- have:= @ltxx _ _ (num_itv_bound R l).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound (le_trans (ltW uneg)).\n- apply: ISignNonNeg => //; first exact: ltW.\n  have:= le_trans (eqbRL (le_num_itv_bound _ _) (ltW lpos)) lx.\n  by rewrite bnd_simp.\n- have:= @ltxx _ _ (num_itv_bound R l).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound ?leBRight_ltBLeft.\n- have:= @ltxx _ _ (num_itv_bound R (BLeft 0%Z)).\n  rewrite (le_lt_trans lx) -?leBRight_ltBLeft ?(le_trans xu)//.\n  by rewrite le_num_itv_bound -?ltBRight_leBLeft.\n- exact: ISignNonNeg.\n- apply: ISignEqZero => //.\n  by apply/le_anti/andP; move: lx xu; rewrite !bnd_simp.\nQed."
}
{
  "statement": "Lemma morphim_pcore_mod pi gT rT (D G : {group gT}) (f : {morphism D >-> rT}) :\n  f @* pcore_mod G pi (F _ G) \\subset pcore_mod (f @* G) pi (F _ (f @* G)).\n",
  "proof": "Proof.\nhave sDF: D :&: G \\subset 'dom (coset (F _ G)).\n  by rewrite setIC subIset ?gFnorm.\nhave sDFf: D :&: G \\subset 'dom (coset (F _ (f @* G)) \\o f).\n  by rewrite -sub_morphim_pre ?subsetIl // morphimIdom gFnorm.\npose K := 'ker (restrm sDFf (coset (F _ (f @* G)) \\o f)).\nhave sFK: 'ker (restrm sDF (coset (F _ G))) \\subset K.\n  rewrite /K !ker_restrm ker_comp /= subsetI subsetIl /= -setIA.\n  rewrite -sub_morphim_pre ?subsetIl //.\n  by rewrite morphimIdom !ker_coset (setIidPr _) ?pmorphimF ?gFsub.\nhave sOF := pcore_sub pi (G / F _ G); have sDD: D :&: G \\subset D :&: G by [].\nrewrite -sub_morphim_pre -?quotientE; last first.\n  by apply: subset_trans (gFnorm F _); rewrite morphimS ?pcore_mod_sub.\nsuffices im_fact (H : {group gT}) : F _ G \\subset H -> H \\subset G ->\n  factm sFK sDD @* (H / F _ G) = f @* H / F _ (f @* G).\n- rewrite -2?im_fact ?pcore_mod_sub ?gFsub //;\n    try by rewrite -{1}[F _ G]ker_coset morphpreS ?sub1G.\n  by rewrite quotient_pcore_mod morphim_pcore.\nmove=> sFH sHG; rewrite -(morphimIdom _ (H / _)) /= {2}morphim_restrm setIid.\nrewrite -morphimIG ?ker_coset //.\nrewrite -(morphim_restrm sDF) morphim_factm morphim_restrm.\nby rewrite morphim_comp -quotientE -setIA morphimIdom (setIidPr _).\nQed."
}
{
  "statement": "Lemma normC_sum_upper (I : finType) (P : pred I) (F G : I -> C) :\n     (forall i, P i -> `|F i| <= G i) ->\n     \\sum_(i | P i) F i = \\sum_(i | P i) G i ->\n   forall i, P i -> F i = G i.\n",
  "proof": "Proof.\nset sumF := \\sum_(i | _) _; set sumG := \\sum_(i | _) _ => leFG eq_sumFG.\nhave posG i: P i -> 0 <= G i by move/leFG; apply: le_trans.\nhave norm_sumG: `|sumG| = sumG by rewrite ger0_norm ?sumr_ge0.\nhave norm_sumF: `|sumF| = \\sum_(i | P i) `|F i|.\n  apply/eqP; rewrite eq_le ler_norm_sum eq_sumFG norm_sumG -subr_ge0 -sumrB.\n  by rewrite sumr_ge0 // => i Pi; rewrite subr_ge0 ?leFG.\nhave [t _ defF] := normC_sum_eq norm_sumF.\nhave [/(psumr_eq0P posG) G0 i Pi | nz_sumG] := eqVneq sumG 0.\n  by apply/eqP; rewrite G0 // -normr_eq0 eq_le normr_ge0 -(G0 i Pi) leFG.\nhave t1: t = 1.\n  apply: (mulfI nz_sumG); rewrite mulr1 -{1}norm_sumG -eq_sumFG norm_sumF.\n  by rewrite mulr_suml -(eq_bigr _ defF).\nhave /psumr_eq0P eqFG i: P i -> 0 <= G i - F i.\n  by move=> Pi; rewrite subr_ge0 defF // t1 mulr1 leFG.\nmove=> i /eqFG/(canRL (subrK _))->; rewrite ?add0r //.\nby rewrite sumrB -/sumF eq_sumFG subrr.\nQed."
}
{
  "statement": "Lemma cfDetRepr n rG : cfDet (cfRepr rG) = @detRepr _ _ n rG.\n",
  "proof": "Proof.\ntransitivity (\\prod_W detRepr (socle_repr W) ^+ standard_irr_coef rG W).\n  rewrite (reindex _ (socle_of_Iirr_bij _)) unlock /=.\n  apply: eq_bigr => i _; congr (_ ^+ _).\n  rewrite (cfRepr_sim (mx_rsim_standard rG)) cfRepr_standard.\n  rewrite cfdot_suml (bigD1 i) ?big1 //= => [|j i'j]; last first.\n    by rewrite cfdotZl cfdot_irr (negPf i'j) mulr0.\n  by rewrite cfdotZl cfnorm_irr mulr1 addr0 natrK.\napply/cfun_inP=> x Gx; rewrite prod_cfunE //.\ntransitivity (detRepr (standard_grepr rG) x); last first.\n  rewrite !cfunE Gx !trace_mx11 !mxE eqxx !mulrb.\n  case: (standard_grepr rG) (mx_rsim_standard rG) => /= n1 rG1 [B Dn1].\n  rewrite -{n1}Dn1 in rG1 B *; rewrite row_free_unit => uB rG_B.\n  by rewrite -[rG x](mulmxK uB) rG_B // !det_mulmx mulrC -!det_mulmx mulKmx.\nrewrite /standard_grepr; elim/big_rec2: _ => [|W y _ _ ->].\n  by rewrite cfunE trace_mx11 mxE Gx det1.\nrewrite !cfunE Gx /= !{1}trace_mx11 !{1}mxE det_ublock; congr (_ * _).\nrewrite exp_cfunE //; elim: (standard_irr_coef rG W) => /= [|k IHk].\n  by rewrite /muln_grepr big_ord0 det1.\nrewrite exprS /muln_grepr big_ord_recl det_ublock -IHk; congr (_ * _).\nby rewrite cfunE trace_mx11 mxE Gx.\nQed."
}
{
  "statement": "Lemma Clifford_rstabs_simple (W : sH) :\n  mxsimple (subg_repr rG (rstabs_sub rG W)) W.\n",
  "proof": "Proof.\nsplit => [||U modU sUW nzU]; last 2 [exact: nz_socle].\n  by rewrite /mxmodule rstabs_subg setIid.\nhave modUH: mxmodule rH U.\n  apply/mxmoduleP=> h Hh; rewrite (mxmoduleP modU) //.\n  rewrite /= -Clifford_astab1 !(inE, sub1set) (subsetP sHG) //.\n  rewrite (astab_act (subsetP Clifford_astab h _)) ?inE //=.\n  by rewrite mem_gen // inE Hh.\napply: (mxsimple_exists modUH nzU) => [[M simM sMU]].\nhave [t [x_ /(_ W)[Gx_ defW _]]] := Clifford_component_basis simM.\nrewrite -defW; apply/sumsmx_subP=> j _; set x := x_ W j.\nhave{Gx_} Gx: x \\in G by rewrite Gx_.\napply: submx_trans (submxMr _ sMU) _; apply: (mxmoduleP modU).\nrewrite inE -val_Clifford_act Gx //; set Wx := 'Cl%act W x.\ncase: (eqVneq Wx W) (simM) => [-> //=|] neWxW [_ /negP[]]; rewrite -submx0.\nrewrite (canF_eq (actKin 'Cl Gx)) in neWxW.\nrewrite -(component_mx_disjoint _ _ neWxW); try exact: socle_simple.\nrewrite sub_capmx {1}(submx_trans sMU sUW) val_Clifford_act ?groupV //.\nby rewrite -(eqmxMr _ defW) sumsmxMr (sumsmx_sup j) ?repr_mxK.\nQed."
}
{
  "statement": "Lemma normal_pgroup r P N :\n    p.-group P -> N <| P -> r <= logn p #|N| ->\n  exists Q : {group gT}, [/\\ Q \\subset N, Q <| P & #|Q| = (p ^ r)%N].\n",
  "proof": "Proof.\nelim: r gT P N => [|r IHr] gTr P N pP nNP le_r.\n  by exists (1%G : {group gTr}); rewrite sub1G normal1 cards1.\nhave [NZ_1 | ntNZ] := eqVneq (N :&: 'Z(P)) 1.\n  by rewrite (TI_center_nil (pgroup_nil pP)) // cards1 logn1 in le_r.\nhave: p.-group (N :&: 'Z(P)) by apply: pgroupS pP; rewrite /= setICA subsetIl.\ncase/pgroup_pdiv=> // p_pr /Cauchy[// | z].\nrewrite -cycle_subG !subsetI => /and3P[szN szP cPz] ozp _.\nhave{cPz} nzP: P \\subset 'N(<[z]>) by rewrite cents_norm // centsC.\nhave: N / <[z]> <| P / <[z]> by rewrite morphim_normal.\ncase/IHr=> [||Qb [sQNb nQPb]]; first exact: morphim_pgroup.\n  rewrite card_quotient ?(subset_trans (normal_sub nNP)) // -ltnS.\n  apply: (leq_trans le_r); rewrite -(Lagrange szN) [#|_|]ozp.\n  by rewrite lognM // ?prime_gt0 // logn_prime ?eqxx.\ncase/(inv_quotientN _): nQPb sQNb => [|Q -> szQ nQP]; first exact/andP.\nhave nzQ := subset_trans (normal_sub nQP) nzP.\nrewrite quotientSGK // card_quotient // => sQN izQ.\nby exists Q; split=> //; rewrite expnS -izQ -ozp Lagrange.\nQed."
}
{
  "statement": "Lemma hom_mxsemisimple_iso I P U W f :\n  let V := (\\sum_(i : I |  P i) W i)%MS in\n  mxsimple U -> (forall i, P i -> W i != 0 -> mxsimple (W i)) ->\n  (V <= dom_hom_mx f)%MS -> (U <= V *m f)%MS ->\n  {i | P i & mx_iso (W i) U}.\n",
  "proof": "Proof.\nmove=> V simU simW homVf sUVf; have [modU nzU _] := simU.\nhave ssimVf: mxsemisimple (V *m f).\n  exact: hom_mxsemisimple (intro_mxsemisimple (eqmx_refl V) simW) homVf.\nhave [U' modU' defVf] := mxsemisimple_reducible ssimVf modU sUVf.\nmove/mxdirect_addsP=> dxUU'; pose p := f *m proj_mx U U'.\ncase: (pickP (fun i => P i && (W i *m p != 0))) => [i /andP[Pi nzWip] | no_i].\n  have sWiV: (W i <= V)%MS by rewrite (sumsmx_sup i).\n  have sWipU: (W i *m p <= U)%MS by rewrite mulmxA proj_mx_sub.\n  exists i => //; apply: (mx_Schur_iso (simW i Pi _) simU _ sWipU nzWip).\n    by apply: contraNneq nzWip => ->; rewrite mul0mx.\n  apply: (submx_trans sWiV); apply/hom_mxP=> x Gx.\n  by rewrite mulmxA [_ *m p]mulmxA 2?(hom_mxP _) -?defVf ?proj_mx_hom.\ncase/negP: nzU; rewrite -submx0 -[U](proj_mx_id dxUU') //.\nrewrite (submx_trans (submxMr _ sUVf)) // -mulmxA -/p sumsmxMr.\nby apply/sumsmx_subP=> i Pi; move/negbT: (no_i i); rewrite Pi negbK submx0.\nQed."
}
{
  "statement": "Lemma cfCauchySchwarz phi psi :\n  `|'[phi, psi]| ^+ 2 <= '[phi] * '[psi] ?= iff ~~ free (phi :: psi).\n",
  "proof": "Proof.\nrewrite free_cons span_seq1 seq1_free -negb_or negbK orbC.\nhave [-> | nz_psi] /= := eqVneq psi 0.\n  by apply/leifP; rewrite !cfdot0r normCK mul0r mulr0.\nwithout loss ophi: phi / '[phi, psi] = 0.\n  move=> IHo; pose a := '[phi, psi] / '[psi]; pose phi1 := phi - a *: psi.\n  have ophi: '[phi1, psi] = 0.\n    by rewrite cfdotBl cfdotZl divfK ?cfnorm_eq0 ?subrr.\n  rewrite (canRL (subrK _) (erefl phi1)) rpredDr ?rpredZ ?memv_line //.\n  rewrite cfdotDl ophi add0r cfdotZl normrM (ger0_norm (cfnorm_ge0 _)).\n  rewrite exprMn mulrA -cfnormZ cfnormDd; last by rewrite cfdotZr ophi mulr0.\n  by have:= IHo _ ophi; rewrite mulrDl -leifBLR subrr ophi normCK mul0r.\nrewrite ophi normCK mul0r; split; first by rewrite mulr_ge0 ?cfnorm_ge0.\nrewrite eq_sym mulf_eq0 orbC cfnorm_eq0 (negPf nz_psi) /=.\napply/idP/idP=> [|/vlineP[a {2}->]]; last by rewrite cfdotZr ophi mulr0.\nby rewrite cfnorm_eq0 => /eqP->; apply: rpred0.\nQed."
}
{
  "statement": "Lemma rat_algebraic_archimedean (C : numFieldType) (QtoC : Qmorphism C) :\n  integralRange QtoC -> Num.archimedean_axiom C.\n",
  "proof": "Proof.\nmove=> algC x.\nwithout loss x_ge0: x / 0 <= x by rewrite -normr_id; apply.\nhave [-> | nz_x] := eqVneq x 0; first by exists 1; rewrite normr0.\nhave [p mon_p px0] := algC x; exists (\\sum_(j < size p) `|numq p`_j|)%N.\nrewrite ger0_norm // real_ltNge ?rpred_nat ?ger0_real //.\napply: contraL px0 => lb_x; rewrite rootE gt_eqF // horner_coef size_map_poly.\nhave x_gt0 k: 0 < x ^+ k by rewrite exprn_gt0 // lt_def nz_x.\nmove: lb_x; rewrite polySpred ?monic_neq0 // !big_ord_recr coef_map /=.\nrewrite -lead_coefE (monicP mon_p) natrD [QtoC _]rmorph1 mul1r => lb_x.\ncase: _.-1 (lb_x) => [|n]; first by rewrite !big_ord0 !add0r ltr01.\nrewrite -ltrBlDl add0r -(ler_pM2r (x_gt0 n)) -exprS.\napply: lt_le_trans; rewrite mulrDl mul1r ltr_pwDr // -sumrN.\nrewrite natr_sum mulr_suml ler_sum // => j _.\nrewrite coef_map /= fmorph_eq_rat (le_trans (real_ler_norm _)) //.\n  by rewrite rpredN rpredM ?rpred_rat ?rpredX // ger0_real.\nrewrite normrN normrM ler_pM //.\n  rewrite normf_div -!intr_norm -!abszE ler_piMr ?ler0n //.\n  by rewrite invf_le1 ?ler1n ?ltr0n absz_gt0.\nrewrite normrX ger0_norm ?(ltrW x_gt0) // ler_weXn2l ?leq_ord //.\nby rewrite (le_trans _ lb_x) // natr1 ler1n.\nQed."
}
{
  "statement": "Lemma dvdp_mod d n m : d %| n -> (d %| m) = (d %| m %% n).\n",
  "proof": "Proof.\nhave [-> | nn0] := eqVneq n 0; first by rewrite modp0.\ncase: (eqVneq d 0) => [-> /dvd0pP -> | dn0]; first by rewrite modp0.\nrewrite dvdp_eq; set c1 := _ ^+ _; set q1 := _ %/ _; move/eqP=> Eq1.\napply/idP/idP; rewrite dvdp_eq; set c2 := _ ^+ _; set q2 := _ %/ _.\n  have sn0 : c1 * c2 != 0.\n   by rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 (negPf dn0) andbF.\n  pose quo := (c1 * lead_coef n ^+ scalp m n) *: q2 - c2 *: (m %/ n) * q1.\n  move/eqP=> Eq2; apply: (@eq_dvdp _ quo _ _ sn0).\n  rewrite mulrDl mulNr -!scalerAl -!mulrA -Eq1 -Eq2 -scalerAr !scalerA.\n  rewrite mulrC [_ * c2]mulrC mulrA -[((_ * _) * _) *: _]scalerA -scalerBr.\n  by rewrite divp_eq addrC addKr.\nhave sn0 : c1 * c2 * lead_coef n ^+ scalp m n != 0.\n  rewrite !mulf_neq0 // expf_eq0 lead_coef_eq0 ?(negPf dn0) ?andbF //.\n  by rewrite (negPf nn0) andbF.\nmove/eqP=> Eq2; apply: (@eq_dvdp _ (c2 *: (m %/ n) * q1 + c1 *: q2) _ _ sn0).\nrewrite -scalerA divp_eq scalerDr -!scalerA Eq2 scalerAl scalerAr Eq1.\nby rewrite scalerAl mulrDl mulrA.\nQed."
}
{
  "statement": "Lemma mx_abs_irrP :\n  reflect (n > 0 /\\ exists a_, forall A, A = \\sum_(x in G) a_ x A *: rG x)\n          mx_absolutely_irreducible.\n",
  "proof": "Proof.\nhave G_1 := group1 G; have bijG := enum_val_bij_in G_1.\nset h := enum_val in bijG; have Gh : h _ \\in G by apply: enum_valP.\nrewrite /mx_absolutely_irreducible; case: (n > 0); last by right; case.\napply: (iffP row_fullP) => [[E' E'G] | [_ [a_ a_G]]].\n  split=> //; exists (fun x B => (mxvec B *m E') 0 (enum_rank_in G_1 x)) => B.\n  apply: (can_inj mxvecK); rewrite -{1}[mxvec B]mulmx1 -{}E'G mulmxA.\n  move: {B E'}(_ *m E') => u; apply/rowP=> j.\n  rewrite linear_sum (reindex h) //= mxE summxE.\n  by apply: eq_big => [k| k _]; rewrite ?Gh // enum_valK_in linearZ !mxE.\nexists (\\matrix_(j, i) a_ (h i) (vec_mx (row j 1%:M))).\napply/row_matrixP=> i; rewrite -[row i 1%:M]vec_mxK {}[vec_mx _]a_G.\napply/rowP=> j; rewrite linear_sum (reindex h) //= 2!mxE summxE.\nby apply: eq_big => [k| k _]; [rewrite Gh | rewrite linearZ !mxE].\nQed."
}
{
  "statement": "Lemma cfun_onP A phi :\n  reflect (forall x, x \\notin A -> phi x = 0) (phi \\in 'CF(G, A)).\n",
  "proof": "Proof.\napply: (iffP idP) => [/coord_span-> x notAx | Aphi].\n  set b := cfun_base G A; rewrite sum_cfunE big1 // => i _; rewrite cfunE.\n  have /mapP[xG]: b`_i \\in b by rewrite -tnth_nth mem_tnth.\n  rewrite mem_enum => /setIdP[/imsetP[y Gy ->] Ay] ->.\n  by rewrite cfun_classE Gy (contraNF (subsetP Ay x)) ?mulr0.\nsuffices <-: \\sum_(xG in classes G) phi (repr xG) *: '1_xG = phi.\n  apply: memv_suml => _ /imsetP[x Gx ->]; rewrite rpredZeq cfun_repr.\n  have [s_xG_A | /subsetPn[_ /imsetP[y Gy ->]]] := boolP (x ^: G \\subset A).\n    by rewrite cfun_on_sum [_ \\in _](sumv_sup (x ^: G)) ?mem_classes ?orbT.\n  by move/Aphi; rewrite cfunJ // => ->; rewrite eqxx.\napply/cfun_inP=> x Gx; rewrite sum_cfunE (bigD1 (x ^: G)) ?mem_classes //=.\nrewrite cfunE cfun_repr cfun_classE Gx class_refl mulr1.\nrewrite big1 ?addr0 // => _ /andP[/imsetP[y Gy ->]]; apply: contraNeq.\nrewrite cfunE cfun_repr cfun_classE Gy mulf_eq0 => /norP[_].\nby rewrite pnatr_eq0 -lt0n lt0b => /class_eqP->.\nQed."
}
{
  "statement": "Lemma num_spec_exprz (xi ki : Itv.t) (x : num_def R xi) (k : num_def int ki)\n    (r := Itv.real2 exprz xi ki) :\n  num_spec r (x%:num ^ k%:num).\n",
  "proof": "Proof.\nrewrite {}/r; case: ki k => [|[lk uk]] k; first by case: xi x.\ncase: xi x => [//|xi x]; rewrite /Itv.real2.\nhave P : Itv.num_sem\n    (let 'Interval l _ := xi in Interval (keep_pos_bound l) +oo)\n    (x%:num ^ k%:num).\n  case: xi x => lx ux x; apply/and3P; split=> [||//].\n    have xr : x%:num \\is Num.real by case: x => x /=/andP[].\n    by case: k%:num => n; rewrite ?realV realX.\n  apply: (@num_itv_bound_keep_pos (fun x => x ^ k%:num));\n    [exact: exprz_ge0 | exact: exprz_gt0 |].\n  by case: x => x /=/and3P[].\ncase: lk k P => [slk [lk | lk] | slk] k P; [|exact: P..].\ncase: k P => -[k | k] /= => [_ _|]; rewrite -/(exprn xi); last first.\n  by move=> /and3P[_ /=]; case: slk; rewrite bnd_simp -pmulrn natz.\nexact: (@num_spec_exprn (Itv.Real xi)).\nQed."
}
{
  "statement": "Lemma mulgmP H1 H2 G : reflect (H1 \\x H2 = G) (misom (setX H1 H2) G mulgm).\n",
  "proof": "Proof.\napply: (iffP misomP) => [[pM /isomP[injf /= <-]] | ].\n  have /dprodP[_ /= defX cH12] := setX_dprod H1 H2.\n  rewrite -{4}defX {}defX => /(congr1 (fun A => morphm pM @* A)).\n  move/(morphimS (morphm_morphism pM)): cH12 => /=.\n  have sH1H: setX H1 1 \\subset setX H1 H2 by rewrite setXS ?sub1G.\n  have sH2H: setX 1 H2 \\subset setX H1 H2 by rewrite setXS ?sub1G.\n  rewrite morphim1 injm_cent ?injmI //= subsetI => /andP[_].\n  by rewrite !morphimEsub //= !imset_mulgm mulg1 mul1g; apply: dprodE.\ncase/dprodP=> _ defG cH12 trH12.\nhave fM: morphic (setX H1 H2) mulgm.\n  apply/morphicP=> [[x1 x2] [y1 y2] /setXP[_ Hx2] /setXP[Hy1 _]].\n  by rewrite /= mulgA -(mulgA x1) -(centsP cH12 x2) ?mulgA.\nexists fM; apply/isomP; split; last by rewrite morphimEsub //= imset_mulgm.\napply/subsetP=> [[x1 x2]]; rewrite !inE /= andbC -eq_invg_mul.\ncase: eqP => //= <-; rewrite groupV -in_setI trH12 => /set1P->.\nby rewrite invg1 eqxx.\nQed."
}
{
  "statement": "Lemma rfix_regular : (rfix_mx aG G :=: gring_row (gset_mx G))%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split; last first.\n  apply/rfix_mxP => x Gx; rewrite -gring_row_mul; congr gring_row.\n  rewrite {2}/gset_mx (reindex_astabs 'R x) ?astabsR //= mulmx_suml.\n  by apply: eq_bigr => y Gy; rewrite repr_mxM.\napply/rV_subP=> v /rfix_mxP cGv.\nhave /envelop_mxP[a def_v]: (gring_mx aG v \\in R_G)%MS.\n  by rewrite vec_mxK submxMl.\nsuffices ->: v = a 1%g *: gring_row (gset_mx G) by rewrite scalemx_sub.\nrewrite -linearZ scaler_sumr -[v]gring_mxK def_v; congr (gring_row _).\napply: eq_bigr => x Gx; congr (_ *: _).\nmove/rowP/(_ 0): (congr1 (gring_proj x \\o gring_mx aG) (cGv x Gx)).\nrewrite /= gring_mxJ // def_v mulmx_suml !linear_sum (bigD1 1%g) //=.\nrewrite repr_mx1 -scalemxAl mul1mx linearZ /= gring_projE // eqxx scalemx1.\nrewrite big1 ?addr0 ?mxE /= => [ | y /andP[Gy nt_y]]; last first.\n  rewrite -scalemxAl linearZ -repr_mxM //= gring_projE ?groupM //.\n  by rewrite eq_sym eq_mulgV1 mulgK (negPf nt_y) scaler0.\nrewrite (bigD1 x) //= linearZ /= gring_projE // eqxx scalemx1.\nrewrite big1 ?addr0 ?mxE // => y /andP[Gy ne_yx].\nby rewrite linearZ /= gring_projE // eq_sym (negPf ne_yx) scaler0.\nQed."
}
{
  "statement": "Lemma cfcenter_Res chi :\n  exists2 chi1, chi1 \\is a linear_char & 'Res['Z(chi)%CF] chi = chi 1%g *: chi1.\n",
  "proof": "Proof.\nhave [[rG ->] | /negbTE notNphi] := altP (@char_reprP _ _ chi); last first.\n  exists 1; first exact: cfun1_lin_char.\n  rewrite /cfcenter notNphi; apply/cfun_inP=> x Kx.\n  by rewrite cfunE cfun1E Kx mulr1 cfResE ?cfker_sub // cfker1.\nrewrite cfcenter_repr -(cfRepr_sub _ (normal_sub (rcenter_normal _))).\ncase: rG => [[|n] rG] /=; rewrite cfRepr1.\n  exists 1; first exact: cfun1_lin_char.\n  by apply/cfun_inP=> x Zx; rewrite scale0r !cfunE flatmx0 raddf0 Zx.\npose rZmx x := ((rG x 0 0)%:M : 'M_(1,1)).\nhave rZmxP: mx_repr [group of rcenter rG] rZmx.\n  split=> [|x y]; first by rewrite /rZmx repr_mx1 mxE eqxx.\n  move=> /setIdP[Gx /is_scalar_mxP[a rGx]] /setIdP[Gy /is_scalar_mxP[b rGy]].\n  by rewrite /rZmx repr_mxM // rGx rGy -!scalar_mxM !mxE.\nexists (cfRepr (MxRepresentation rZmxP)).\n  by rewrite qualifE/= cfRepr_char cfRepr1 eqxx.\napply/cfun_inP=> x Zx; rewrite !cfunE Zx /= /rZmx mulr_natl.\nby case/setIdP: Zx => Gx /is_scalar_mxP[a ->]; rewrite mxE !mxtrace_scalar.\nQed."
}
{
  "statement": "Lemma subgroup_transitivePin G H S x :\n     x \\in S -> H \\subset G -> G \\subset D -> [transitive G, on S | to] ->\n  reflect ('C_G[x | to] * H = G) [transitive H, on S | to].\n",
  "proof": "Proof.\nmove=> Sx sHG sGD trG; have sHD := subset_trans sHG sGD.\napply: (iffP idP) => [trH | defG].\n  rewrite group_modr //; apply/setIidPl/subsetP=> a Ga.\n  have Sxa: to x a \\in S by rewrite (acts_act (atrans_acts_in sGD trG)).\n  have [b Hb xab]:= atransP2in sHD trH Sxa Sx.\n  have Da := subsetP sGD a Ga; have Db := subsetP sHD b Hb.\n  rewrite -(mulgK b a) mem_mulg ?groupV // !inE groupM //= sub1set inE.\n  by rewrite actMin -?xab.\napply/imsetP; exists x => //; apply/setP=> y; rewrite -(atransPin sGD trG Sx).\napply/imsetP/imsetP=> [] [a]; last by exists a; first apply: (subsetP sHG).\nrewrite -defG => /imset2P[c b /setIP[_ cxc] Hb ->] ->.\nexists b; rewrite ?actMin ?(astab_dom cxc) ?(subsetP sHD) //.\nby rewrite (astab_act cxc) ?inE.\nQed."
}
{
  "statement": "Lemma mulmx_ebase m n (A : 'M_(m, n)) :\n  col_ebase A *m pid_mx (\\rank A) *m row_ebase A = A.\n",
  "proof": "Proof.\nrewrite mxrankE /col_ebase /row_ebase unlock.\nelim: m n A => [n A | m IHm]; first by rewrite [A]flatmx0 [_ *m _]flatmx0.\ncase=> [A | n]; first by rewrite [_ *m _]thinmx0 [A]thinmx0.\nrewrite -(add1n m) -?(add1n n) => A /=.\ncase: pickP => [[i0 j0] | A0] /=; last first.\n  apply/matrixP=> i j; rewrite pid_mx_0 mulmx0 mul0mx mxE.\n  by move/eqP: (A0 (i, j)).\nset a := A i0 j0 => nz_a; set A1 := xrow _ _ _.\nset u := ursubmx _; set v := _ *: _; set B : 'M_(m, n) := _ - _.\nmove: (rank_leq_col B) (rank_leq_row B) {IHm}(IHm n B); rewrite mxrankE.\ncase: (GaussE B) => [[L U] r] /= r_m r_n defB.\nhave ->: pid_mx (1 + r) = block_mx 1 0 0 (pid_mx r) :> 'M[F]_(1 + m, 1 + n).\n  rewrite -(subnKC r_m) -(subnKC r_n) pid_mx_block -col_mx0 -row_mx0.\n  by rewrite block_mxA castmx_id col_mx0 row_mx0 -scalar_mx_block -pid_mx_block.\nrewrite xcolE xrowE mulmxA -xcolE -!mulmxA.\nrewrite !(addr0, add0r, mulmx0, mul0mx, mulmx_block, mul1mx) mulmxA defB.\nrewrite addrC subrK mul_mx_scalar scalerA divff // scale1r.\nhave ->: a%:M = ulsubmx A1 by rewrite [_ A1]mx11_scalar !mxE !lshift0 !tpermR.\nrewrite submxK /A1 xrowE !xcolE -!mulmxA mulmxA -!perm_mxM !tperm2 !perm_mx1.\nby rewrite mulmx1 mul1mx.\nQed."
}
{
  "statement": "Lemma skew_field_module_semisimple A M :\n  let sumA X := (\\sum_(x <- X) A * <[x]>)%VS in\n  (A * M <= M)%VS -> {X | [/\\ sumA X = M, directv (sumA X) & 0 \\notin X]}.\n",
  "proof": "Proof.\nmove=> sumA sAM_M; pose X := Nil aT; pose k := (\\dim (A * M) - \\dim (sumA X))%N.\nhave: (\\dim (A * M) - \\dim (sumA X) < k.+1)%N by [].\nhave: [/\\ (sumA X <= A * M)%VS, directv (sumA X) & 0 \\notin X].\n  by rewrite /sumA directvE /= !big_nil sub0v dimv0.\nelim: {X k}k.+1 (X) => // k IHk X [sAX_AM dxAX nzX]; rewrite ltnS => leAXk.\nhave [sM_AX | /subvPn/sig2W[y My notAXy]] := boolP (M <= sumA X)%VS.\n  by exists X; split=> //; apply/eqP; rewrite eqEsubv (subv_trans sAX_AM).\nhave nz_y: y != 0 by rewrite (memPnC notAXy) ?mem0v.\npose AY := sumA (y :: X).\nhave sAY_AM: (AY <= A * M)%VS by rewrite [AY]big_cons subv_add ?prodvSr.\nhave dxAY: directv AY.\n  rewrite directvE /= !big_cons [_ == _]directv_addE dxAX directvE eqxx /=.\n  rewrite -/(sumA X) eqEsubv sub0v andbT -limg_amulr.\n  apply/subvP=> _ /memv_capP[/memv_imgP[a Aa ->]]/[!lfunE]/= AXay.\n  rewrite memv0 (mulIr_eq0 a (mulIr _)) ?fieldT //.\n  apply: contraR notAXy => /fieldT-Ua; rewrite -[y](mulKr Ua) /sumA.\n  by rewrite -big_distrr -(prodv_id A) /= -prodvA big_distrr memv_mul ?memvV.\napply: (IHk (y :: X)); first by rewrite !inE eq_sym negb_or nz_y.\nrewrite -subSn ?dimvS // (directvP dxAY) /= big_cons -(directvP dxAX) /=.\nrewrite subnDA (leq_trans _ leAXk) ?leq_sub2r // leq_subLR -add1n leq_add2r.\nby rewrite dim_cosetv_unit ?fieldT ?adim_gt0.\nQed."
}
{
  "statement": "Lemma Alt_trans : [transitive^n.-2 'Alt_T, on setT | 'P].\n",
  "proof": "Proof.\ncase n_m2: n Sym_trans => [|[|m]] /= tr_m2; try exact: ntransitive0.\nhave tr_m := ntransitive_weak (leqW (leqnSn m)) tr_m2.\ncase/imsetP: tr_m2; case/tupleP=> x; case/tupleP=> y t.\nrewrite !dtuple_on_add 2![x \\in _]inE inE negb_or /= -!andbA.\ncase/and4P=> nxy ntx nty dt _; apply/imsetP; exists t => //; apply/setP=> u.\napply/idP/imsetP=> [|[a _ ->{u}]]; last first.\n  by apply: n_act_dtuple => //; apply/astabsP=> z; rewrite !inE.\ncase/(atransP2 tr_m dt)=> /= a _ ->{u}.\ncase odd_a: (odd_perm a); last by exists a => //; rewrite !inE /= odd_a.\nexists (tperm x y * a); first by rewrite !inE /= odd_permM odd_tperm nxy odd_a.\napply/val_inj/eq_in_map => z tz; rewrite actM /= /aperm; congr (a _).\nby case: tpermP ntx nty => // <-; rewrite tz.\nQed."
}
{
  "statement": "Lemma edivpP p q r : p = q * d + r -> size r < size d ->\n  q = (p %/ d) /\\ r = p %% d.\n",
  "proof": "Proof.\nmove=> ep srd; have := divp_eq p; rewrite [LHS]ep.\nmove/eqP; rewrite -subr_eq -addrA addrC eq_sym -subr_eq -mulrBl; move/eqP.\nhave lcdn0 : lead_coef d != 0 by apply: contraTneq ulcd => ->; rewrite unitr0.\nhave [-> /esym /eqP|abs] := eqVneq (p %/ d) q.\n  by rewrite subrr mul0r subr_eq0 => /eqP<-.\nhave hleq : size d <= size ((p %/ d - q) * d).\n  rewrite size_proper_mul; last first.\n    by rewrite mulf_eq0 (negPf lcdn0) orbF lead_coef_eq0 subr_eq0.\n  by move: abs; rewrite -subr_eq0; move/polySpred->; rewrite addSn /= leq_addl.\nhave hlt : size (r - p %% d) < size d.\n  apply: leq_ltn_trans (size_polyD _ _) _.\n  by rewrite gtn_max srd size_polyN ltn_modp -lead_coef_eq0.\nby move=> e; have:= leq_trans hlt hleq; rewrite e ltnn.\nQed."
}
{
  "statement": "Lemma irreducibleP : reflect (irreducible_poly p) irreducibleb.\n",
  "proof": "Proof.\nrewrite /irreducibleb /irreducible_poly.\napply: (iffP idP) => [/andP[sp /'forall_implyP /= Fp]|[sp Fpoly]].\n  have sp_gt0 : size p > 0 by case: size sp.\n  have p_neq0 : p != 0 by rewrite -size_poly_eq0; case: size sp.\n  split => // q sq_neq1 dvd_qp; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  apply: contraNT sq_neq1; rewrite -ltnNge => sq_lt_sp.\n  have q_small: (size q <= (size p).-1)%N by rewrite -ltnS prednK.\n  rewrite Pdiv.Idomain.dvdpE in dvd_qp.\n  have /= := Fp (NPoly q_small) dvd_qp.\n  rewrite leq_eqVlt ltnS => /orP[//|]; rewrite size_poly_leq0 => /eqP q_eq0.\n  by rewrite -Pdiv.Idomain.dvdpE q_eq0 dvd0p (negPf p_neq0) in dvd_qp.\nhave sp_gt0 : size p > 0 by case: size sp.\nrewrite sp /=; apply/'forall_implyP => /= q.\nrewrite -Pdiv.Idomain.dvdpE=> dvd_qp.\nhave [/eqP->//|/Fpoly/(_ dvd_qp)/eqp_size sq_eq_sp] := boolP (size q == 1%N).\nby have := size_npoly q; rewrite sq_eq_sp -ltnS prednK ?ltnn.\nQed."
}
{
  "statement": "Lemma trivIsetP P :\n  reflect {in P &, forall A B, A != B -> [disjoint A & B]} (trivIset P).\n",
  "proof": "Proof.\nrewrite -[P]set_enum; elim: {P}(enum _) (enum_uniq P) => [_ | A e IHe] /=.\n  by rewrite /trivIset /cover !big_set0 cards0; left=> A; rewrite inE.\ncase/andP; rewrite set_cons -(in_set (fun B => B \\in e)) => PA {}/IHe.\nmove: {e}[set x in e] PA => P PA IHP.\nrewrite /trivIset /cover !big_setU1 //= eq_sym.\nhave:= leq_card_cover P; rewrite -(mono_leqif (leq_add2l #|A|)).\nmove/(leqif_trans (leq_card_setU _ _))->; rewrite disjoints_subset setC_bigcup.\ncase: bigcapsP => [disjA | meetA]; last first.\n  right=> [tI]; case: meetA => B PB; rewrite -disjoints_subset.\n  by rewrite tI ?setU11 ?setU1r //; apply: contraNneq PA => ->.\napply: (iffP IHP) => [] tI B C PB PC; last by apply: tI; apply: setU1r.\nby case/setU1P: PC PB => [->|PC] /setU1P[->|PB]; try by [apply: tI | case/eqP];\n  first rewrite disjoint_sym; rewrite disjoints_subset disjA.\nQed."
}
{
  "statement": "Lemma Fadjoin_sum_direct : directv sumKx.\n",
  "proof": "Proof.\nrewrite directvE /=; case: (ubnPgeq n) (isT : n > 0) => -[//|m] ltmn _.\nelim: m ltmn => [|m IHm] ltm1n; rewrite ?big_ord1 // !(big_ord_recr m.+1) /=.\ndo [move/(_ (ltnW ltm1n))/eqP; set S := (\\sum_i _)%VS] in IHm *.\nrewrite -IHm dimv_add_leqif; apply/subvP=> z; rewrite memv_cap => /andP[Sz].\ncase/memv_cosetP=> y Ky Dz; rewrite memv0 Dz mulf_eq0 expf_eq0 /=.\napply: contraLR ltm1n => /norP[nz_y nz_x].\nrewrite -leqNgt -(leq_pmul2r (adim_gt0 K)) -dim_Fadjoin.\nhave{IHm} ->: (m.+1 * \\dim K)%N = \\dim S.\n  rewrite -[m.+1]card_ord -sum_nat_const IHm.\n  by apply: eq_bigr => i; rewrite dim_cosetv ?expf_neq0.\napply/dimvS/agenv_sub_modl; first by rewrite (sumv_sup 0) //= prodv1 sub1v.\nrewrite prodvDl subv_add -[S]big_distrr prodvA prodv_id subvv !big_distrr /=.\napply/subv_sumP=> i _; rewrite -expv_line prodvCA -expvSl expv_line.\nhave [ltim | lemi] := ltnP i m; first by rewrite (sumv_sup (Sub i.+1 _)).\nhave{lemi} /eqP->: i == m :> nat by rewrite eqn_leq leq_ord.\nrewrite -big_distrr -2!{2}(prodv_id K) /= -!prodvA big_distrr -/S prodvSr //=.\nby rewrite -(canLR (mulKf nz_y) Dz) -memvE memv_mul ?rpredV.\nQed."
}
{
  "statement": "Lemma tuple_permP {T : eqType} {n} {s : seq T} {t : n.-tuple T} :\n  reflect (exists p : 'S_n, s = [tuple tnth t (p i) | i < n]) (perm_eq s t).\n",
  "proof": "Proof.\napply: (iffP idP) => [|[p ->]]; last first.\n  rewrite /= (map_comp (tnth t)) -{1}(map_tnth_enum t) perm_map //.\n  apply: uniq_perm => [||i]; rewrite ?enum_uniq //.\n    by apply/injectiveP; apply: perm_inj.\n  by rewrite mem_enum -[i](permKV p) image_f.\ncase: n => [|n] in t *; last have x0 := tnth t ord0.\n  rewrite tuple0 => /perm_small_eq-> //.\n  by exists 1; rewrite [mktuple _]tuple0.\ncase/(perm_iotaP x0); rewrite size_tuple => Is eqIst ->{s}.\nhave uniqIs: uniq Is by rewrite (perm_uniq eqIst) iota_uniq.\nhave szIs: size Is == n.+1 by rewrite (perm_size eqIst) !size_tuple.\nhave pP i : tnth (Tuple szIs) i < n.+1.\n  by rewrite -[_ < _](mem_iota 0) -(perm_mem eqIst) mem_tnth.\nhave inj_p: injective (fun i => Ordinal (pP i)).\n  by apply/injectiveP/(@map_uniq _ _ val); rewrite -map_comp map_tnth_enum.\nexists (perm inj_p); rewrite -[Is]/(tval (Tuple szIs)); congr (tval _).\nby apply: eq_from_tnth => i; rewrite tnth_map tnth_mktuple permE (tnth_nth x0).\nQed."
}
{
  "statement": "Lemma partition_pigeonhole P D A :\n  partition P D -> #|P| <= #|A| -> A \\subset D -> {in P, forall B, #|A :&: B| <= 1} ->\n  {in P, forall B, A :&: B != set0}.\n",
  "proof": "Proof.\nmove=> partP card_A_P /subsetP subAD sub1; apply/forall_inP.\napply: contraTT card_A_P => /forall_inPn [B BP]; rewrite negbK => AB0.\nrewrite -!ltnNge -(setD1K BP) cardsU1 !inE eqxx /= add1n ltnS.\nhave [tP covP] := (partition_trivIset partP,cover_partition partP).\nhave APx x : x \\in A -> x \\in pblock P x by rewrite mem_pblock covP; apply: subAD.\nhave inj_f : {in A &, injective (pblock P)}.\n  move=> x y xA yA /eqP; rewrite eq_pblock ?covP ?subAD // => Pxy.\n  apply: (@card_le1_eqP _ (A :&: pblock P x)); rewrite ?inE ?Pxy ?APx ?andbT //.\n  by apply: sub1; rewrite pblock_mem ?covP ?subAD.\nrewrite -(card_in_imset inj_f); apply: subset_leq_card.\napply/subsetP => ? /imsetP[x xA ->].\nrewrite !inE pblock_mem ?covP ?subAD ?andbT //.\nby apply: contraTneq AB0 => <-; apply/set0Pn; exists x; rewrite inE APx ?andbT.\nQed."
}
{
  "statement": "Lemma ltxi_tupleP n T (t1 t2 : n.-tuple T) :\n   reflect (exists k : 'I_n, forall i : 'I_n, (i <= k)%N ->\n               tnth t1 i <= tnth t2 i ?= iff (i != k :> nat)) (t1 < t2).\n",
  "proof": "Proof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= ltxx; constructor => - [] [].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ < _]ltxi_cons; apply: (iffP idP) => [|[k leif_xt12]].\n  case: (comparableP x1 x2) => //= [ltx12 _|-> /IHn[k kP]].\n    exists ord0 => i; rewrite leqn0 => /eqP/(@ord_inj n.+1 i ord0)->.\n    by apply/leifP; rewrite !tnth0.\n  exists (lift ord0 k) => i; case: (unliftP ord0 i) => {i} [i ->|-> _].\n    by rewrite !ltnS => /kP; rewrite !tnthS.\n  by apply/leifP; rewrite !tnth0 eqxx.\nhave /= := leif_xt12 ord0 isT; rewrite !tnth0 => leif_x12.\nrewrite leif_x12/=; move: leif_x12 leif_xt12 => /leifP.\ncase: (unliftP ord0 k) => {k} [k-> /eqP<-{x2}|-> /lt_geF->//] leif_xt12.\nrewrite lexx implyTb; apply/IHn; exists k => i le_ik.\nby have := leif_xt12 (lift ord0 i) le_ik; rewrite !tnthS.\nQed."
}
{
  "statement": "Lemma eq_addZ_irr a b (i j r t : Iirr G) :\n  (a *: 'chi_i + b *: 'chi_j == a *: 'chi_r + b *: 'chi_t)\n   = [|| [&& (a == 0) || (i == r) & (b == 0) || (j == t)],\n         [&& i == t, j == r & a == b] | [&& i == j, r == t & a == - b]].\n",
  "proof": "Proof.\nrewrite -!eq_scale_irr; apply/eqP/idP; last first.\n  case/orP; first by case/andP=> /eqP-> /eqP->.\n  case/orP=> /and3P[/eqP-> /eqP-> /eqP->]; first by rewrite addrC.\n  by rewrite !scaleNr !addNr.\nhave [-> /addrI/eqP-> // | /=] := eqVneq.\nrewrite eq_scale_irr => /norP[/negP nz_a /negPf neq_ir].\nmove/(congr1 (cfdotr 'chi__))/esym/eqP => /= eq_cfdot.\nmove: {eq_cfdot}(eq_cfdot i) (eq_cfdot r); rewrite eq_sym !cfdotDl !cfdotZl.\nrewrite !cfdot_irr !mulr_natr !mulrb !eqxx -!(eq_sym i) neq_ir !add0r.\nhave [<- _ | _] := i =P t; first by rewrite neq_ir addr0; case: ifP => // _ ->.\nrewrite 2!fun_if if_arg addr0 addr_eq0; case: eqP => //= <- ->.\nby rewrite neq_ir 2!fun_if if_arg eq_sym addr0; case: ifP.\nQed."
}
{
  "statement": "Lemma lexi_tupleP n T (t1 t2 : n.-tuple T) :\n   reflect (exists k : 'I_n.+1, forall i : 'I_n, (i <= k)%N ->\n               tnth t1 i <= tnth t2 i ?= iff (i != k :> nat)) (t1 <= t2).\n",
  "proof": "Proof.\nelim: n => [|n IHn] in t1 t2 *.\n  by rewrite tuple0 [t2]tuple0/= lexx; constructor; exists ord0 => -[].\ncase: (tupleP t1) (tupleP t2) => [x1 {}t1] [x2 {}t2].\nrewrite [_ <= _]lexi_cons; apply: (iffP idP) => [|[k leif_xt12]].\n  case: comparableP => //= [ltx12 _|-> /IHn[k kP]].\n    exists ord0 => i; rewrite leqn0 => /eqP/(@ord_inj n.+1 i ord0)->.\n    by apply/leifP; rewrite !tnth0.\n  exists (lift ord0 k) => i; case: (unliftP ord0 i) => [j ->|-> _].\n    by rewrite !ltnS => /kP; rewrite !tnthS.\n  by apply/leifP; rewrite !tnth0 eqxx.\nhave /= := leif_xt12 ord0 isT; rewrite !tnth0 => leif_x12.\nrewrite leif_x12/=; move: leif_x12 leif_xt12 => /leifP.\ncase: (unliftP ord0 k) => {k} [k-> /eqP<-{x2}|-> /lt_geF->//] leif_xt12.\nrewrite lexx implyTb; apply/IHn; exists k => i le_ik.\nby have := leif_xt12 (lift ord0 i) le_ik; rewrite !tnthS.\nQed."
}
{
  "statement": "Lemma transversalP P D : partition P D -> is_transversal (transversal P D) P D.\n",
  "proof": "Proof.\ncase/and3P=> /eqP <- tiP notP0; apply/and3P; split; first exact/and3P.\n  apply/subsetP=> _ /imsetP[x Px ->]; case: pickP => //= y Pxy.\n  by apply/bigcupP; exists (pblock P x); rewrite ?pblock_mem //.\napply/forall_inP=> B PB; have /set0Pn[x Bx]: B != set0 := memPn notP0 B PB.\napply/cards1P; exists (odflt x [pick y in pblock P x]); apply/esym/eqP.\nrewrite eqEsubset sub1set !inE -andbA; apply/andP; split.\n  by apply/imset_f/bigcupP; exists B.\nrewrite (def_pblock tiP PB Bx); case def_y: _ / pickP => [y By | /(_ x)/idP//].\nrewrite By /=; apply/subsetP=> _ /setIP[/imsetP[z Pz ->]].\ncase: {1}_ / pickP => [t zPt Bt | /(_ z)/idP[]]; last by rewrite mem_pblock.\nby rewrite -(same_pblock tiP zPt) (def_pblock tiP PB Bt) def_y inE.\nQed."
}
{
  "statement": "Lemma Gauss_dvdp m n p : coprimep m n -> (m * n %| p) = (m %| p) && (n %| p).\n",
  "proof": "Proof.\nhave [-> | mn0] := eqVneq m 0.\n  by rewrite coprime0p => /eqp_dvdl->; rewrite !mul0r dvd0p dvd1p andbT.\nhave [-> | nn0] := eqVneq n 0.\n  by rewrite coprimep0 => /eqp_dvdl->; rewrite !mulr0 dvd1p.\nmove=> hc; apply/idP/idP => [mnmp | /andP [dmp dnp]].\n  move/Gauss_dvdpl: hc => <-; move: (dvdp_mull m mnmp); rewrite dvdp_mul2l //.\n  move->; move: (dvdp_mulr n mnmp); rewrite dvdp_mul2r // andbT.\n  exact: dvdp_mulr.\nmove: (dnp); rewrite dvdp_eq.\nset c2 := _ ^+ _; set q2 := _ %/ _; move/eqP=> e2.\nhave/esym := Gauss_dvdpl q2 hc; rewrite -e2.\nhave -> : m %| c2 *: p by rewrite -mul_polyC dvdp_mull.\nrewrite dvdp_eq; set c3 := _ ^+ _; set q3 := _ %/ _; move/eqP=> e3.\napply: (@eq_dvdp (c3 * c2) q3).\n  by rewrite mulf_neq0 // expf_neq0 // lead_coef_eq0.\nby rewrite mulrA -e3 -scalerAl -e2 scalerA.\nQed."
}
{
  "statement": "Theorem nonlinear_irr_vanish gT (G : {group gT}) i :\n  'chi[G]_i 1%g > 1 -> exists2 x, x \\in G & 'chi_i x = 0.\n",
  "proof": "Proof.\nmove=> chi1gt1; apply/exists_eq_inP; apply: contraFT (lt_geF chi1gt1).\nmove=> /exists_inPn-nz_chi.\nrewrite -(norm_natr (Cnat_irr1 i)) -(@expr_le1 _ 2)//.\nrewrite -(lerD2r (#|G|%:R * '['chi_i])) {1}cfnorm_irr mulr1.\nrewrite (cfnormE (cfun_onG _)) mulVKf ?neq0CG // (big_setD1 1%g) //=.\nrewrite addrCA lerD2l (cardsD1 1%g) group1 mulrS lerD2l.\nrewrite -sumr_const !(partition_big_imset (fun s => <[s]>)) /=.\napply: ler_sum => _ /imsetP[g /setD1P[ntg Gg] ->].\nhave sgG: <[g]> \\subset G by rewrite cycle_subG.\npose S := [pred s | generator <[g]> s]; pose chi := 'Res[<[g]>] 'chi_i.\nhave defS: [pred s in G^# | <[s]> == <[g]>] =i S.\n  move=> s; rewrite inE /= eq_sym andb_idl // !inE -cycle_eq1 -cycle_subG.\n  by move/eqP <-; rewrite cycle_eq1 ntg.\nhave resS: {in S, 'chi_i =1 chi}.\n  by move=> s /cycle_generator=> g_s; rewrite cfResE ?cycle_subG.\nrewrite !(eq_bigl _ _ defS) sumr_const.\nrewrite (eq_bigr (fun s => `|chi s| ^+ 2)) => [|s /resS-> //].\napply: sum_norm2_char_generators => [|s Ss].\n  by rewrite cfRes_char ?irr_char.\nby rewrite -resS // nz_chi ?(subsetP sgG) ?cycle_generator.\nQed."
}
{
  "statement": "Lemma mxdirect_sum_eigenspace (P : pred I) a_ :\n  {in P &, injective a_} -> mxdirect (\\sum_(i | P i) eigenspace (a_ i)).\n",
  "proof": "Proof.\nhave [m] := ubnP #|P|; elim: m P => // m IHm P lePm inj_a.\napply/mxdirect_sumsP=> i Pi; apply/eqP/rowV0P => v.\nrewrite sub_capmx => /andP[/eigenspaceP def_vg].\nset Vi' := (\\sum_(i | _) _)%MS => Vi'v.\nhave dxVi': mxdirect Vi'.\n  rewrite (cardD1x Pi) in lePm; apply: IHm => //.\n  by apply: sub_in2 inj_a => j /andP[].\ncase/sub_dsumsmx: Vi'v => // u Vi'u def_v _.\nrewrite def_v big1 // => j Pi'j; apply/eqP.\nhave nz_aij: a_ i - a_ j != 0.\n  by case/andP: Pi'j => Pj ne_ji; rewrite subr_eq0 eq_sym (inj_in_eq inj_a).\ncase: (sub_dsumsmx dxVi' (sub0mx 1 _)) => C _ _ uniqC.\nrewrite -(eqmx_eq0 (eqmx_scale _ nz_aij)).\nrewrite (uniqC (fun k => (a_ i - a_ k) *: u k)) => // [|k Pi'k|].\n- by rewrite -(uniqC (fun _ => 0)) ?big1 // => k Pi'k; apply: sub0mx.\n- by rewrite scalemx_sub ?Vi'u.\nrewrite -{1}(subrr (v *m g)) {1}def_vg def_v scaler_sumr mulmx_suml -sumrB.\nby apply: eq_bigr => k /Vi'u/eigenspaceP->; rewrite scalerBl.\nQed."
}
{
  "statement": "Lemma is_trig_mxblockP (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  reflect [/\\ forall (i j : 'I_p), (i < j)%N -> B_ i j = 0 &\n              forall i, is_trig_mx (B_ i i)]\n          (is_trig_mx (\\mxblock_(i, j) B_ i j)).\n",
  "proof": "Proof.\napply: (iffP is_trig_mxP); last first.\n  move=> [Blt1 /(_ _)/is_trig_mxP Blt2]/= s s'; rewrite !mxE.\n  rewrite -[_ < _]lt_sig ltEsig/= /sig1 /sig2 leEord.\n  case: ltngtP => //= ii'; first by rewrite (Blt1 _ _ ii') mxE.\n  move: (sig s) (sig s') ii' => -[/= i j] [/= i' +] /val_inj ii'.\n  by case: _ / ii' => j'; rewrite tagged_asE => /Blt2->.\nmove=> Btrig; split=> [i i' lti|i].\n  apply/matrixP => j j'; have := Btrig (Rank _ j) (Rank _ j').\n  rewrite !mxE !Rank2K; do !case: _ / esym; rewrite !cast_ord_id.\n  rewrite /Rank [_ <= _]lt_rank.\n  by rewrite ltEsig/= leEord ltnW//= (ltn_geF lti)//= => /(_ isT).\napply/is_trig_mxP => j j' ltj; have := Btrig (Rank _ j) (Rank _ j').\nrewrite !mxE !Rank2K; do! case: _ / esym; rewrite !cast_ord_id.\nby rewrite [_ <= _]lt_rank ltEsig/= !leEord leqnn/= tagged_asE; apply.\nQed."
}
{
  "statement": "Lemma mono_unique d (T T' : finPOrderType d) (f g : T -> T') :\n    total (<=%O : rel T) -> (#|T'| <= #|T|)%N ->\n    {mono f : x y / x <= y} -> {mono g : x y / x <= y} ->\n  f =1 g.\n",
  "proof": "Proof.\nmove=> le_total leT'T lef leg x0; move: {+}x0.\nsuff: finfun f = finfun g by move=> /ffunP + x => /(_ x); rewrite !ffunE.\napply: (can_inj fgraphK); apply/val_inj => /=; rewrite !codomE.\nunder eq_map do rewrite ffunE; under [RHS]eq_map do rewrite ffunE.\nhave [finj ginj] := (inc_inj lef, inc_inj leg).\nhave [f' fK f'K] := inj_card_bij finj leT'T.\nhave [g' gK g'K] := inj_card_bij ginj leT'T.\napply/eqP; have : [seq f i | i <- Order.enum T] = [seq g i | i <- Order.enum T].\n  apply: (@sorted_eq _ <=%O le_trans le_anti); rewrite ?mono_sorted_enum//.\n  apply: uniq_perm; rewrite ?map_inj_uniq ?sort_uniq ?fintype.enum_uniq//.\n  move=> x; apply/mapP/mapP => -[y _ ->].\n    by exists (g' (f y)); rewrite ?Order.mem_enum.\n  by exists (f' (g y)); rewrite ?Order.mem_enum.\nmove=> /eqP; rewrite !eq_map_all all_map [in X in _ -> X]all_map.\nby have /permPl/perm_all-> := perm_sort <=%O (fintype.enum T).\nQed."
}
{
  "statement": "Lemma pairwise_orthogonalP  S :\n  reflect (uniq (0 :: S)\n             /\\ {in S &, forall phi psi, phi != psi -> '[phi, psi] = 0})\n          (pairwise_orthogonal form S).\n",
  "proof": "Proof.\nrewrite /pairwise_orthogonal /=; case notS0: (~~ _); last by right; case.\nelim: S notS0 => [|phi S IH] /=; first by left.\nrewrite inE eq_sym andbT => /norP[nz_phi {}/IH IH].\nhave [opS | not_opS] := allP; last first.\n  right=> [[/andP[notSp _] opS]]; case: not_opS => psi Spsi /=.\n  by rewrite opS ?mem_head 1?mem_behead // (memPnC notSp).\nrewrite (contra (opS _)) /= ?dnorm_eq0 //.\napply: (iffP IH) => [] [uniqS oSS]; last first.\n  by split=> //; apply: sub_in2 oSS => psi Spsi; apply: mem_behead.\nsplit=> // psi xi; rewrite !inE => /predU1P[-> // | Spsi].\n  by case/predU1P=> [-> | /opS] /eqP.\ncase/predU1P=> [-> _ | Sxi /oSS-> //].\napply/eqP; rewrite hermC.\nby move: (opS psi Spsi) => /= /eqP ->; rewrite rmorph0 mulr0.\nQed."
}
{
  "statement": "Lemma primePn n :\n  reflect (n < 2 \\/ exists2 d, 1 < d < n & d %| n) (~~ prime n).\n",
  "proof": "Proof.\nrewrite /prime; case: n => [|[|p2]]; try by do 2!left.\ncase: (@prime_decomp_correct p2.+2) => //; rewrite unlock.\ncase: prime_decomp => [|[q [|[|e]]] pd] //=; last first; last by rewrite andbF.\n  rewrite {1}/pfactor 2!expnS -!mulnA /=.\n  case: (_ ^ _ * _) => [|u -> _ /andP[lt1q _]]; first by rewrite !muln0.\n  left; right; exists q; last by rewrite dvdn_mulr.\n  have lt0q := ltnW lt1q; rewrite lt1q -[ltnLHS]muln1 ltn_pmul2l //.\n  by rewrite -[2]muln1 leq_mul.\nrewrite {1}/pfactor expn1; case: pd => [|[r e] pd] /=; last first.\n  case: e => [|e] /=; first by rewrite !andbF.\n  rewrite {1}/pfactor expnS -mulnA.\n  case: (_ ^ _ * _) => [|u -> _ /and3P[lt1q ltqr _]]; first by rewrite !muln0.\n  left; right; exists q; last by rewrite dvdn_mulr.\n  by rewrite lt1q -[ltnLHS]mul1n ltn_mul // -[q.+1]muln1 leq_mul.\nrewrite muln1 !andbT => def_q pr_q lt1q; right=> [[]] // [d].\nby rewrite def_q -mem_index_iota => in_d_2q dv_d_q; case/hasP: pr_q; exists d.\nQed."
}
{
  "statement": "Lemma Primitive_Element_Theorem : exists z, (<< <<K; y>>; x>> = <<K; z>>)%VS.\n",
  "proof": "Proof.\nhave /polyOver_subvs[p Dp]: minPoly K x \\is a polyOver K := minPolyOver K x.\nhave nz_pKx: minPoly K x != 0 by rewrite monic_neq0 ?monic_minPoly.\nhave{nz_pKx} nz_p: p != 0 by rewrite Dp map_poly_eq0 in nz_pKx.\nhave{Dp} px0: root (map_poly vsval p) x by rewrite -Dp root_minPoly.\nhave [q0 [Kq0 q0y0 sepKq0]] := separable_elementP sepKy.\nhave /polyOver_subvs[q Dq]: minPoly K y \\is a polyOver K := minPolyOver K y.\nhave qy0: root (map_poly vsval q) y by rewrite -Dq root_minPoly.\nhave sep_pKy: separable_poly (minPoly K y).\n  by rewrite (dvdp_separable _ sepKq0) ?minPoly_dvdp.\nhave{sep_pKy} sep_q: separable_poly q by rewrite Dq separable_map in sep_pKy.\nhave [r nz_r PETr] := large_field_PET nz_p px0 qy0 sep_q.\nhave [[s [Us Ks /ltnW leNs]] | //] := finite_PET (size r).\nhave{s Us leNs} /allPn[t {}/Ks Kt nz_rt]: ~~ all (root r) s.\n  by apply: contraTN leNs; rewrite -ltnNge => /max_poly_roots->.\nhave{PETr} [/= [p1 Dx] [q1 Dy]] := PETr (Subvs Kt) nz_rt.\nset z := t * y - x in Dx Dy; exists z; apply/eqP.\nrewrite eqEsubv !(sameP FadjoinP andP) subv_adjoin.\nhave Kz_p1z (r1 : {poly subvs_of K}): (map_poly vsval r1).[z] \\in <<K; z>>%VS.\n  rewrite rpred_horner ?memv_adjoin ?(polyOverSv (subv_adjoin K z)) //.\n  by apply/polyOver_subvs; exists r1.\nrewrite -{1}Dx -{1}Dy !{Dx Dy}Kz_p1z /=.\nrewrite (subv_trans (subv_adjoin K y)) ?subv_adjoin // rpredB ?memv_adjoin //.\nby rewrite subvP_adjoin // rpredM ?memv_adjoin ?subvP_adjoin.\nQed."
}
{
  "statement": "Lemma mxring_idP m n (R : 'A_(m, n)) :\n  reflect (exists e, mxring_id R e) (has_mxring_id R).\n",
  "proof": "Proof.\napply: (iffP andP) => [[nzR] | [e [nz_e Re ideR idRe]]].\n  case/submxP=> v; rewrite -[v]vec_mxK; move/vec_mx: v => e.\n  rewrite !mul_mx_row; case/eq_row_mx => /eqP.\n  rewrite eq_sym -submxE => Re.\n  case/eq_row_mx; rewrite !{1}mul_rV_lin1 /= mxvecK.\n  set u := (_ *m _) => /(can_inj mxvecK) idRe /(can_inj mxvecK) ideR.\n  exists e; split=> // [ | A /submxP[a defA] | A /submxP[a defA]].\n  - by apply: contra nzR; rewrite ideR => /eqP->; rewrite !linear0.\n  - by rewrite -{2}[A]mxvecK defA idRe mulmxA mx_rV_lin -defA /= mxvecK.\n  by rewrite -{2}[A]mxvecK defA ideR mulmxA mx_rV_lin -defA /= mxvecK.\nsplit.\n  by apply: contraNneq nz_e => R0; rewrite R0 eqmx0 in Re; rewrite (memmx0 Re).\napply/submxP; exists (mxvec e); rewrite !mul_mx_row !{1}mul_rV_lin1.\nrewrite submxE in Re; rewrite {Re}(eqP Re).\ncongr (row_mx 0 (row_mx (mxvec _) (mxvec _))); apply/row_matrixP=> i.\n  by rewrite !row_mul !mul_rV_lin1 /= mxvecK ideR vec_mxK ?row_sub.\nby rewrite !row_mul !mul_rV_lin1 /= mxvecK idRe vec_mxK ?row_sub.\nQed."
}
{
  "statement": "Lemma socle_exists : classically socleType.\n",
  "proof": "Proof.\npose V : 'M[F]_n := 0; have: mxsemisimple V by apply: mxsemisimple0.\nhave: n - \\rank V < n.+1 by rewrite mxrank0 subn0.\nelim: _.+1 V => // n' IHn' V; rewrite ltnS => le_nV_n' ssimV.\ncase=> // maxV; apply: (maxV); have [I /= U simU defV _] := ssimV.\nexists (codom U) => [M | M simM]; first by case/mapP=> i _ ->.\nsuffices sMV: (M <= V)%MS.\n  rewrite -defV -(mulmx1 (\\sum_i _)%MS) in sMV.\n  have [//| i _] := hom_mxsemisimple_iso simM _ (scalar_mx_hom _ _) sMV.\n  move/mx_iso_sym=> isoM; apply/hasP.\n  by exists (U i); [apply: codom_f | apply/mxsimple_isoP].\nhave ssimMV := addsmx_semisimple (mxsimple_semisimple simM) ssimV.\napply: contraLR isT => nsMV; apply: IHn' ssimMV _ maxV.\napply: leq_trans le_nV_n'; rewrite ltn_sub2l //.\n  rewrite ltn_neqAle rank_leq_row andbT -[_ == _]sub1mx.\n  by apply: contra nsMV; apply: submx_trans; apply: submx1.\nrewrite (ltn_leqif (mxrank_leqif_sup _)) ?addsmxSr //.\nby rewrite addsmx_sub submx_refl andbT.\nQed."
}
{
  "statement": "Lemma galois_dim K E : galois K E -> \\dim_K E = #|'Gal(E / K)|.\n",
  "proof": "Proof.\ncase/and3P=> sKE /eq_adjoin_separable_generator-> // nKE.\nset a := separable_generator K E in nKE *.\nhave [r /allP/=Er splitKa] := normalFieldP nKE a (memv_adjoin K a).\nrewrite (dim_sup_field (subv_adjoin K a)) mulnK ?adim_gt0 //.\napply/eqP; rewrite -eqSS -adjoin_degreeE -size_minPoly splitKa size_prod_XsubC.\nset n := size r; rewrite eqSS -[n]card_ord.\nhave x_ (i : 'I_n): {x | x \\in 'Gal(<<K; a>> / K) & x a = r`_i}.\n  apply/sig2_eqW/normalField_root_minPoly; rewrite ?subv_adjoin ?memv_adjoin //.\n  by rewrite splitKa root_prod_XsubC mem_nth.\nhave /card_image <-: injective (fun i => s2val (x_ i)).\n  move=> i j /eqP; case: (x_ i) (x_ j) => y /= galEy Dya [z /= galEx Dza].\n  rewrite gal_adjoin_eq // Dya Dza nth_uniq // => [/(i =P j)//|].\n  by rewrite -separable_prod_XsubC -splitKa; apply: separable_generatorP.\napply/eqP/eq_card=> x; apply/codomP/idP=> [[i ->] | galEx]; first by case: x_.\nhave /(nthP 0) [i ltin Dxa]: x a \\in r.\n  rewrite -root_prod_XsubC -splitKa.\n  by rewrite root_minPoly_gal ?memv_adjoin ?subv_adjoin.\nexists (Ordinal ltin); apply/esym/eqP.\nby case: x_ => y /= galEy /eqP; rewrite Dxa gal_adjoin_eq.\nQed."
}
{
  "statement": "Lemma Aut_cprod_full G H K :\n    H \\* K = G -> 'Z(H) = 'Z(K) ->\n    Aut_in (Aut H) 'Z(H) \\isog Aut 'Z(H) ->\n    Aut_in (Aut K) 'Z(K) \\isog Aut 'Z(K) ->\n  Aut_in (Aut G) 'Z(G) \\isog Aut 'Z(G).\n",
  "proof": "Proof.\nmove=> defG eqZHK; have [_ defHK cHK] := cprodP defG.\nhave defZ: 'Z(G) = 'Z(H) by rewrite -defHK -center_prod // eqZHK mulGid.\nhave ziHK: H :&: K = 'Z(K).\n  by apply/eqP; rewrite eqEsubset subsetI -{1 2}eqZHK !center_sub setIS.\nhave AutZP := Aut_sub_fullP (@center_sub gT _).\nmove/AutZP=> AutZHfull /AutZP AutZKfull; apply/AutZP=> g injg gZ.\nhave [gH [def_gH ker_gH _ im_gH]] := domP g defZ.\nhave [gK [def_gK ker_gK _ im_gK]] := domP g (etrans defZ eqZHK).\nhave [injgH injgK]: 'injm gH /\\ 'injm gK by rewrite ker_gH ker_gK.\nhave [gHH gKK]: gH @* 'Z(H) = 'Z(H) /\\ gK @* 'Z(K) = 'Z(K).\n  by rewrite im_gH im_gK -eqZHK -defZ.\nhave [|fH [injfH im_fH fHZ]] := AutZHfull gH injgH.\n  by rewrite im_gH /= -defZ.\nhave [|fK [injfK im_fK fKZ]] := AutZKfull gK injgK.\n  by rewrite im_gK /= -eqZHK -defZ.\nhave cfHK: fK @* K \\subset 'C(fH @* H) by rewrite im_fH im_fK.\nhave eq_fHK: {in H :&: K, fH =1 fK}.\n  by move=> z; rewrite ziHK => Zz; rewrite fHZ ?fKZ /= ?eqZHK // def_gH def_gK.\nexists (cprodm_morphism defG cfHK eq_fHK).\nrewrite injm_cprodm injfH injfK im_cprodm im_fH im_fK defHK.\nrewrite -morphimIdom ziHK -eqZHK injm_center // im_fH eqxx.\nsplit=> //= z; rewrite {1}defZ => Zz; have [Hz _] := setIP Zz.\nby rewrite cprodmEl // fHZ // def_gH.\nQed."
}
{
  "statement": "Lemma splitting_galoisField K E :\n  reflect (exists p, [/\\ p \\is a polyOver K, separable_poly p\n                       & splittingFieldFor K p E])     \n          (galois K E).\n",
  "proof": "Proof.\napply: (iffP and3P) => [[sKE sepKE nKE]|[p [Kp sep_p [r Dp defE]]]].\n  rewrite (eq_adjoin_separable_generator sepKE) // in nKE *.\n  set a := separable_generator K E in nKE *; exists (minPoly K a).\n  split; first 1 [exact: minPolyOver | exact/separable_generatorP].\n  have [r /= /allP Er splitKa] := normalFieldP nKE a (memv_adjoin _ _).\n  exists r; first by rewrite splitKa eqpxx.\n  apply/eqP; rewrite eqEsubv; apply/andP; split.\n    by apply/Fadjoin_seqP; split => //; apply: subv_adjoin.\n  apply/FadjoinP; split; first exact: subv_adjoin_seq.\n  by rewrite seqv_sub_adjoin // -root_prod_XsubC -splitKa root_minPoly.\nhave sKE: (K <= E)%VS by rewrite -defE subv_adjoin_seq.\nsplit=> //; last by apply/splitting_normalField=> //; exists p; last exists r.\nrewrite -defE; apply/separable_Fadjoin_seq/allP=> a r_a.\nby apply/separable_elementP; exists p; rewrite (eqp_root Dp) root_prod_XsubC.\nQed."
}
{
  "statement": "Lemma Clifford_atrans : [transitive G, on [set: sH] | 'Cl].\n",
  "proof": "Proof.\nhave [_ nz1 _] := irrG.\napply: mxsimple_exists (mxmodule1 rH) nz1 _ _ => [[M simM _]].\npose W1 := PackSocle (component_socle sH simM).\nhave [X sXG [def1 _]] := Clifford_basis simM; move/subsetP: sXG => sXG.\napply/imsetP; exists W1; first by rewrite inE.\nsymmetry; apply/setP=> W /[1!inE]; have simW := socle_simple W.\nhave:= submx1 (socle_base W); rewrite -def1 -[(\\sum_(x in X) _)%MS]mulmx1.\ncase/(hom_mxsemisimple_iso simW) => [x Xx _ | | x Xx isoMxW].\n- by apply: Clifford_simple; rewrite ?sXG.\n- exact: scalar_mx_hom.\nhave Gx := sXG x Xx; apply/imsetP; exists x => //; apply/socleP/eqmxP/eqmx_sym.\napply: eqmx_trans (val_Clifford_act _ Gx) _; rewrite PackSocleK.\napply: eqmx_trans (eqmx_sym (Clifford_componentJ simM Gx)) _.\napply/eqmxP; rewrite (sameP genmxP eqP) !{1}genmx_component.\nby apply/component_mx_isoP=> //; apply: Clifford_simple.\nQed."
}
{
  "statement": "Lemma ltn_rmodp p q : (size (rmodp p q) < size q) = (q != 0).\n",
  "proof": "Proof.\nrewrite /rdivp /rmodp /rscalp unlock; have [->|q0] := eqVneq q 0.\n  by rewrite /= size_poly0 ltn0.\nelim: (size p) 0%N 0 {1 3}p (leqnn (size p)) => [|n ihn] k q1 r.\n  move/size_poly_leq0P->.\n  by rewrite /= size_poly0 size_poly_gt0 q0 size_poly0 size_poly_gt0.\nmove=> hr /=; case: (ltnP (size r)) => // hsrq; apply/ihn/leq_sizeP => j hnj.\nrewrite coefB -scalerAl !coefZ coefXnM coefMC ltn_subRL ltnNge.\nhave sq: 0 < size q by rewrite size_poly_gt0.\nhave sr: 0 < size r by apply: leq_trans hsrq.\nhave hj: (size r).-1 <= j by apply: leq_trans hnj; rewrite -ltnS prednK.\nmove: (leq_add sq hj); rewrite add1n prednK // => -> /=.\nmove: hj; rewrite leq_eqVlt prednK // => /predU1P [<- | hj].\n  by rewrite -predn_sub subKn // !lead_coefE subrr.\nhave/leq_sizeP -> //: size q <= j - (size r - size q).\n  by rewrite subnBA // leq_subRL ?leq_add2r // (leq_trans hj) // leq_addr.\nby move/leq_sizeP: hj => -> //; rewrite mul0r mulr0 subr0.\nQed."
}
{
  "statement": "Lemma abelem_charsimple p G : p.-abelem G -> G :!=: 1 -> charsimple G.\n",
  "proof": "Proof.\nmove=> abelG ntG; apply/charsimpleP; split=> // K ntK /charP[sKG chK].\ncase/eqVproper: sKG => // /properP[sKG [x Gx notKx]].\nhave ox := abelem_order_p abelG Gx (group1_contra notKx).\nhave [A [sAG oA defA]] := p_abelem_split1 abelG Gx.\ncase/trivgPn: ntK => y Ky nty; have Gy := subsetP sKG y Ky.\nhave{nty} oy := abelem_order_p abelG Gy nty.\nhave [B [sBG oB defB]] := p_abelem_split1 abelG Gy.\nhave: isog A B; last case/isogP=> fAB injAB defAB.\n  rewrite (isog_abelem_card _ (abelemS sAG abelG)) (abelemS sBG) //=.\n  by rewrite oA oB ox oy.\nhave: isog <[x]> <[y]>; last case/isogP=> fxy injxy /= defxy.\n  by rewrite isog_cyclic_card ?cycle_cyclic // [#|_|]oy -ox eqxx.\nhave cfxA: fAB @* A \\subset 'C(fxy @* <[x]>).\n  by rewrite defAB defxy; case/dprodP: defB.\nhave injf: 'injm (dprodm defA cfxA).\n  by rewrite injm_dprodm injAB injxy defAB defxy; apply/eqP; case/dprodP: defB.\ncase/negP: notKx; rewrite -cycle_subG -(injmSK injf) ?cycle_subG //=.\nrewrite morphim_dprodml // defxy cycle_subG /= chK //.\nhave [_ {4}<- _ _] := dprodP defB; have [_ {3}<- _ _] := dprodP defA.\nby rewrite morphim_dprodm // defAB defxy.\nQed."
}
{
  "statement": "Lemma sol_coprime_Sylow_exists A G :\n    solvable A -> A \\subset 'N(G) -> coprime #|G| #|A| ->\n  exists2 P : {group gT}, p.-Sylow(G) P & A \\subset 'N(P).\n",
  "proof": "Proof.\nmove=> solA nGA coGA; pose AG := A <*> G.\nhave nsG_AG: G <| AG by rewrite /normal joing_subr join_subG nGA normG.\nhave [sG_AG nG_AG]:= andP nsG_AG.\nhave [P sylP] := Sylow_exists p G; pose N := 'N_AG(P); pose NG := G :&: N.\nhave nGN: N \\subset 'N(G) by rewrite subIset ?nG_AG.\nhave sNG_G: NG \\subset G := subsetIl G N.\nhave nsNG_N: NG <| N by rewrite /normal subsetIr normsI ?normG.\nhave defAG: G * N = AG := Frattini_arg nsG_AG sylP.\nhave oA : #|A| = #|N| %/ #|NG|.\n  rewrite /NG setIC divgI -card_quotient // -quotientMidl defAG.\n  rewrite card_quotient -?divgS //= norm_joinEl //.\n  by rewrite coprime_cardMg 1?coprime_sym // mulnK.\nhave: [splits N, over NG].\n  rewrite SchurZassenhaus_split // /Hall -divgS subsetIr //.\n  by rewrite -oA (coprimeSg sNG_G).\ncase/splitsP=> B; case/complP=> tNG_B defN.\nhave [nPB]: B \\subset 'N(P) /\\ B \\subset AG.\n  by apply/andP; rewrite andbC -subsetI -/N -defN mulG_subr.\ncase/SchurZassenhaus_trans_actsol => // [|x Gx defB].\n  by rewrite oA -defN TI_cardMg // mulKn.\nexists (P :^ x^-1)%G; first by rewrite pHallJ ?groupV.\nby rewrite normJ -sub_conjg -defB.\nQed."
}
{
  "statement": "Lemma prodsgP (I : finType) (P : pred I) (A : I -> {set gT}) x :\n  reflect (exists2 c, forall i, P i -> c i \\in A i & x = \\prod_(i | P i) c i)\n          (x \\in \\prod_(i | P i) A i).\n",
  "proof": "Proof.\nhave [r big_r [Ur mem_r] _] := big_enumP P.\npose inA c := all (fun i => c i \\in A i); rewrite -big_r; set piAx := x \\in _.\nsuffices{big_r} IHr: reflect (exists2 c, inA c r & x = \\prod_(i <- r) c i) piAx.\n  apply: (iffP IHr) => -[c inAc ->]; do [exists c; last by rewrite big_r].\n    by move=> i Pi; rewrite (allP inAc) ?mem_r.\n  by apply/allP=> i; rewrite mem_r => /inAc.\nelim: {P mem_r}r x @piAx Ur => /= [x _ | i r IHr x /andP[r'i /IHr{}IHr]].\n  by rewrite unlock; apply: (iffP set1P) => [-> | [] //]; exists (fun=> x).\nrewrite big_cons; apply: (iffP idP) => [|[c /andP[Aci Ac] ->]]; last first.\n  by rewrite big_cons mem_mulg //; apply/IHr=> //; exists c.\ncase/mulsgP=> c_i _ Ac_i /IHr[c /allP-inAcr ->] ->{x}.\nexists [eta c with i |-> c_i]; rewrite /= ?big_cons eqxx ?Ac_i.\n  by apply/allP=> j rj; rewrite /= ifN ?(memPn r'i) ?inAcr.\nby congr (_ * _); apply: eq_big_seq => j rj; rewrite ifN ?(memPn r'i).\nQed."
}
{
  "statement": "Lemma is_diag_mxblockP (B_ : forall i j, 'M[V]_(p_ i, p_ j)) :\n  reflect [/\\ forall (i j : 'I_p), i != j -> B_ i j = 0 &\n              forall i, is_diag_mx (B_ i i)]\n          (is_diag_mx (\\mxblock_(i, j) B_ i j)).\n",
  "proof": "Proof.\napply: (iffP is_diag_mxP); last first.\n  move=> [Bneq1 /(_ _)/is_diag_mxP Bneq2]/= s s'; rewrite !mxE.\n  rewrite val_eqE -(can_eq sigK) /sig1 /sig2.\n  move: (sig s) (sig s') => -[/= i j] [/= i' j'].\n  rewrite -tag_eqE/= /tag_eq/= negb_and.\n  case: eqVneq => /= [ii'|/Bneq1->]; last by rewrite !mxE.\n  by rewrite -ii' in j' *; rewrite tagged_asE => /Bneq2.\nmove=> Bdiag; split=> [i i' Ni|i].\n  apply/matrixP => j j'; have := Bdiag (Rank _ j) (Rank _ j').\n  rewrite !mxE !Rank2K; do !case: _ / esym; rewrite !cast_ord_id.\n  by rewrite eq_Rank negb_and Ni; apply.\napply/is_diag_mxP => j j' Nj; have := Bdiag (Rank _ j) (Rank _ j').\nrewrite !mxE !Rank2K; do! case: _ / esym; rewrite !cast_ord_id.\nby rewrite eq_Rank negb_and val_eqE Nj orbT; apply.\nQed."
}
{
  "statement": "Lemma rsim_irr_comp_pchar : mx_rsim rG (irr_repr iG).\n",
  "proof": "Proof.\nhave [M [modM rsimM]] := rsim_regular_submod_pchar irrG F'G.\nhave simM: mxsimple aG M.\n  case/mx_irrP: irrG => n_gt0 minG.\n  have [f def_n injf homf] := mx_rsim_sym rsimM.\n  apply/(submod_mx_irr modM)/mx_irrP.\n  split=> [|U modU nzU]; first by rewrite def_n.\n  rewrite /row_full -(mxrankMfree _ injf) -genmxE {4}def_n.\n  apply: minG; last by rewrite -mxrank_eq0 genmxE mxrankMfree // mxrank_eq0.\n  rewrite (eqmx_module _ (genmxE _)); apply/mxmoduleP=> x Gx.\n  by rewrite -mulmxA -homf // mulmxA submxMr // (mxmoduleP modU).\npose i := PackSocle (component_socle sG simM).\nhave{modM} rsimM: mx_rsim rG (socle_repr i).\n  apply: mx_rsim_trans rsimM (mx_rsim_sym _); apply/mx_rsim_iso.\n  apply: (component_mx_iso (socle_simple _)) => //.\n  by rewrite [component_mx _ _]PackSocleK component_mx_id.\nhave [<- // | ne_i_iG] := eqVneq i iG.\nsuffices {i M simM ne_i_iG rsimM}: gring_op rG 'e_iG != 0.\n  by rewrite (not_rsim_op0_pchar rsimM ne_i_iG) ?Wedderburn_id_mem ?eqxx.\nrewrite /iG; case: pickP => //= G0.\nsuffices: rG 1%g == 0.\n  by case/idPn; rewrite -mxrank_eq0 repr_mx1 mxrank1 -lt0n; case/mx_irrP: irrG.\nrewrite -gring_opG // repr_mx1 -Wedderburn_sum_id_pchar linear_sum big1 //.\nby move=> j _; move/eqP: (G0 j).\nQed."
}
{
  "statement": "Lemma ucn_cprod n A B G : A \\* B = G -> 'Z_n(A) \\* 'Z_n(B) = 'Z_n(G).\n",
  "proof": "Proof.\ncase/cprodP=> [[H K -> ->{A B}] mulHK cHK].\nelim: n => [|n /cprodP[_ /= defZ cZn]]; first exact: cprod1g.\nset Z := 'Z_n(G) in defZ cZn; rewrite (ucnSn n G) /= -/Z.\nhave /mulGsubP[nZH nZK]: H * K \\subset 'N(Z) by rewrite mulHK gFnorm.\nhave <-: 'Z(H / Z) * 'Z(K / Z) = 'Z(G / Z).\n  by rewrite -mulHK quotientMl // center_prod ?quotient_cents.\nhave ZquoZ (B A : {group gT}):\n  B \\subset 'C(A) -> 'Z_n(A) * 'Z_n(B) = Z -> 'Z(A / Z) = 'Z_n.+1(A) / Z.\n- move=> cAB {}defZ; have cAZnB: 'Z_n(B) \\subset 'C(A) := gFsub_trans _ cAB.\n  have /second_isom[/=]: A \\subset 'N(Z).\n    by rewrite -defZ normsM ?gFnorm ?cents_norm // centsC.\n  suffices ->: Z :&: A = 'Z_n(A).\n    by move=> f inj_f im_f; rewrite -!im_f ?gFsub // ucn_central injm_center.\n  rewrite -defZ -group_modl ?gFsub //; apply/mulGidPl.\n  have [-> | n_gt0] := posnP n; first exact: subsetIl.\n  by apply: subset_trans (ucn_sub_geq A n_gt0); rewrite /= setIC ucn1 setIS.\nrewrite (ZquoZ H K) 1?centsC 1?(centC cZn) // {ZquoZ}(ZquoZ K H) //.\nhave cZn1: 'Z_n.+1(K) \\subset 'C('Z_n.+1(H)) by apply: centSS cHK; apply: gFsub.\nrewrite -quotientMl ?quotientK ?mul_subG ?gFsub_trans //=.\nrewrite cprodE // -cent_joinEr ?mulSGid //= cent_joinEr //= -/Z.\nby rewrite -defZ mulgSS ?ucn_subS.\nQed."
}
{
  "statement": "Lemma involutions_gen_dihedral gT (x y : gT) :\n    let G := <<[set x; y]>> in\n  #[x] = 2 -> #[y] = 2 -> x != y -> G \\isog 'D_#|G|.\n",
  "proof": "Proof.\nmove=> G ox oy ne_x_y; pose q := #[x * y].\nhave q_gt1: q > 1 by rewrite order_gt1 -eq_invg_mul invg_expg ox.\nhave homG: G \\homg 'D_q.*2.\n  rewrite Grp'_dihedral //; apply/existsP; exists (x, y); rewrite /= !xpair_eqE.\n  by rewrite joing_idl joing_idr -{1}ox -oy !expg_order !eqxx.\nsuff oG: #|G| = q.*2 by rewrite oG isogEcard oG card_dihedral ?leqnn ?andbT.\nhave: #|G| %| q.*2  by rewrite -card_dihedral ?card_homg.\nhave Gxy: <[x * y]> \\subset G.\n  by rewrite cycle_subG groupM ?mem_gen ?set21 ?set22.\nhave[k oG]: exists k, #|G| = (k * q)%N by apply/dvdnP; rewrite cardSg.\nrewrite oG -mul2n dvdn_pmul2r ?order_gt0 ?dvdn_divisors // !inE /=.\ncase/pred2P=> [k1 | -> //]; case/negP: ne_x_y.\nhave cycG: cyclic G.\n  apply/cyclicP; exists (x * y); apply/eqP.\n  by rewrite eq_sym eqEcard Gxy oG k1 mul1n leqnn.\nhave: <[x]> == <[y]>.\n  by rewrite (eq_subG_cyclic cycG) ?genS ?subsetUl ?subsetUr -?orderE ?ox ?oy.\nby rewrite eqEcard cycle_subG /= cycle2g // !inE -order_eq1 ox; case/andP.\nQed."
}
{
  "statement": "Lemma Frobenius_semiregularP G K H :\n    K ><| H = G -> K :!=: 1 -> H :!=: 1 ->\n  reflect (semiregular K H) [Frobenius G = K ><| H].\n",
  "proof": "Proof.\nmove=> defG ntK ntH.\napply: (iffP idP) => [|regG]; first exact: Frobenius_reg_ker.\nhave [nsKG sHG defKH nKH tiKH]:= sdprod_context defG; have [sKG _]:= andP nsKG.\napply/and3P; split; first by rewrite defG.\n  by rewrite eqEcard sHG -(sdprod_card defG) -ltnNge ltn_Pmull ?cardG_gt1.\napply/normedTI_memJ_P; rewrite setD_eq0 subG1 sHG -defKH -(normC nKH).\nsplit=> // z _ /setD1P[ntz Hz] /mulsgP[y x Hy Kx ->]; rewrite groupMl // !inE.\nrewrite conjg_eq1 ntz; apply/idP/idP=> [Hzxy | Hx]; last by rewrite !in_group.\napply: (subsetP (sub1G H)); have Hzy: z ^ y \\in H by apply: groupJ.\nrewrite -(regG (z ^ y)); last by apply/setD1P; rewrite conjg_eq1.\nrewrite inE Kx cent1C (sameP cent1P commgP) -in_set1 -[[set 1]]tiKH inE /=.\nrewrite andbC groupM ?groupV -?conjgM //= commgEr groupMr //.\nby rewrite memJ_norm ?(subsetP nKH) ?groupV.\nQed."
}
{
  "statement": "Lemma mx_JordanHolder_exists U V :\n    mx_composition_series U -> modG V -> max_submod V (last 0 U) ->\n  {W : seq 'M_n | mx_composition_series W & last 0 W = V}.\n",
  "proof": "Proof.\nelim/last_ind: U V => [|U Um IHU] V compU modV; first by case; rewrite ltmx0.\nrewrite last_rcons => maxV; case/mx_series_rcons: compU => compU modUm maxUm.\ncase eqUV: (last 0 U == V)%MS.\n  case/lastP: U eqUV compU {maxUm IHU} => [|U' Um'].\n    by rewrite andbC; move/eqmx0P->; exists [::].\n  rewrite last_rcons; move/eqmxP=> eqU'V; case/mx_series_rcons=> compU _ maxUm'.\n  exists (rcons U' V); last by rewrite last_rcons.\n  by apply/mx_series_rcons; split => //; apply: max_submod_eqmx maxUm'.\nset Um' := last 0 U in maxUm eqUV; have [modU _] := compU.\nhave modUm': modG Um' by rewrite /Um' (last_nth 0) mx_subseries_module'.\nhave [|||W compW lastW] := IHU (V :&: Um')%MS; rewrite ?capmx_module //.\n  by case: (mx_butterfly modUm' modV modUm); rewrite ?eqUV // {1}capmxC.\nexists (rcons W V); last by rewrite last_rcons.\napply/mx_series_rcons; split; rewrite // lastW.\nby case: (mx_butterfly modV modUm' modUm); rewrite // andbC eqUV.\nQed."
}
{
  "statement": "Lemma irr1_abelian_bound (i : Iirr G) :\n  abelian (G / 'Z('chi_i)%CF) -> ('chi_i 1%g) ^+ 2 = #|G : 'Z('chi_i)%CF|%:R.\n",
  "proof": "Proof.\nmove=> AbGc; apply/eqP; rewrite irr1_bound cfun_onE; apply/subsetP=> x nz_chi_x.\nhave Gx: x \\in G by apply: contraR nz_chi_x => /cfun0->.\nhave nKx := subsetP (normal_norm (cfker_normal 'chi_i)) _ Gx.\nrewrite -(quotientGK (cfker_center_normal _)) inE nKx inE /=.\nrewrite cfcenter_eq_center inE mem_quotient //=.\napply/centP=> _ /morphimP[y nKy Gy ->]; apply/commgP; rewrite -morphR //=.\nset z := [~ x, y]; rewrite coset_id //.\nhave: z \\in 'Z('chi_i)%CF.\n  apply: subsetP (mem_commg Gx Gy).\n  by rewrite der1_min // normal_norm ?cfcenter_normal.\nrewrite -irrRepr cfker_repr cfcenter_repr !inE in nz_chi_x *.\ncase/andP=> Gz /is_scalar_mxP[c Chi_z]; rewrite Gz Chi_z mul1mx /=.\napply/eqP; congr _%:M; apply: (mulIf nz_chi_x); rewrite mul1r.\nrewrite -{2}(cfunJ _ x Gy) conjg_mulR -/z !cfunE Gx groupM // !{1}mulrb.\nby rewrite repr_mxM // Chi_z mul_mx_scalar mxtraceZ.\nQed."
}
{
  "statement": "Theorem gring_classM_expansion i j : 'K_i *m 'K_j = \\sum_k (a i j k)%:R *: 'K_k.\n",
  "proof": "Proof.\nhave [/imsetP[zi Gzi dKi] /imsetP[zj Gzj dKj]] := (enum_valP i, enum_valP j).\npose aG := regular_repr F G; have sKG := subsetP (class_subG _ (subxx G)).\ntransitivity (\\sum_(x in zi ^: G) \\sum_(y in zj ^: G) aG (x * y)%g).\n  rewrite mulmx_suml -/aG dKi; apply: eq_bigr => x /sKG Gx.\n  rewrite mulmx_sumr -/aG dKj; apply: eq_bigr => y /sKG Gy.\n  by rewrite repr_mxM ?Gx ?Gy.\npose h2 xy : gT := (xy.1 * xy.2)%g.\npose h1 xy := enum_rank_in (classes1 G) (h2 xy ^: G).\nrewrite pair_big (partition_big h1 xpredT) //=; apply: eq_bigr => k _.\nrewrite (partition_big h2 [in enum_val k]) /= => [|[x y]]; last first.\n  case/andP=> /andP[/= /sKG Gx /sKG Gy] /eqP <-.\n  by rewrite enum_rankK_in ?class_refl ?mem_classes ?groupM ?Gx ?Gy.\nrewrite scaler_sumr; apply: eq_bigr => g Kk_g; rewrite scaler_nat.\nrewrite (set_gring_classM_coef _ _ Kk_g) -sumr_const; apply: eq_big => [] [x y].\n  rewrite !inE /= dKi dKj /h1 /h2 /=; apply: andb_id2r => /eqP ->.\n  have /imsetP[zk Gzk dKk] := enum_valP k; rewrite dKk in Kk_g.\n  by rewrite (class_eqP Kk_g) -dKk enum_valK_in eqxx andbT.\nby rewrite /h2 /= => /andP[_ /eqP->].\nQed."
}
{
  "statement": "Theorem stab_ntransitiveI m x :\n     x \\in S -> [transitive G, on S | to] ->\n     [transitive^m 'C_G[x | to], on S :\\ x | to] ->\n  [transitive^m.+1 G, on S | to].\n",
  "proof": "Proof.\nmove=> Sx Gtr Gntr.\nhave t_to_x t: t \\in m.+1.-dtuple(S) ->\n  exists2 a, a \\in G & exists2 t', t' \\in m.-dtuple(S :\\ x)\n                                 & t = n_act to [tuple of x :: t'] a.\n- case/tupleP: t => y t St.\n  have Sy: y \\in S by rewrite dtuple_on_add_D1 in St; case/andP: St.\n  rewrite -(atransP Gtr _ Sy) in Sx; case/imsetP: Sx => a Ga toya.\n  exists a^-1; first exact: groupVr.\n  exists (n_act to t a); last by rewrite n_act_add toya !actK.\n  move/(n_act_dtuple (subsetP (atrans_acts Gtr) a Ga)): St.\n  by rewrite n_act_add -toya dtuple_on_add_D1 => /andP[].\ncase: (imsetP Gntr) => t dt S_tG; pose xt := [tuple of x :: t].\nhave dxt: xt \\in m.+1.-dtuple(S) by rewrite dtuple_on_add_D1 Sx.\napply/imsetP; exists xt => //; apply/setP=> t2.\napply/esym; apply/imsetP/idP=> [[a Ga ->] | ].\n  by apply: n_act_dtuple; rewrite // (subsetP (atrans_acts Gtr)).\ncase/t_to_x=> a2 Ga2 [t2']; rewrite S_tG.\ncase/imsetP=> a /setIP[Ga /astab1P toxa] -> -> {t2 t2'}.\nby exists (a * a2); rewrite (groupM, actM) //= !n_act_add toxa.\nQed."
}
{
  "statement": "Lemma size_divp p q : q != 0 -> size (p %/ q) = (size p - (size q).-1)%N.\n",
  "proof": "Proof.\nmove=> nq0; case: (leqP (size q) (size p)) => sqp; last first.\n  move: (sqp); rewrite -{1}(ltn_predK sqp) ltnS -subn_eq0 divp_small //.\n  by move/eqP->; rewrite size_poly0.\nhave np0 : p != 0.\n  by rewrite -size_poly_gt0; apply: leq_trans sqp; rewrite size_poly_gt0.\nhave /= := congr1 (size \\o @polyseq R) (divp_eq p q).\nrewrite size_scale; last by rewrite expf_eq0 lead_coef_eq0 (negPf nq0) andbF.\nhave [->|qq0] := eqVneq (p %/ q) 0.\n  by rewrite mul0r add0r=> es; move: nq0; rewrite -(ltn_modp p) -es ltnNge sqp.\nrewrite size_polyDl.\n  by move->; apply/eqP; rewrite size_mul // (polySpred nq0) addnS /= addnK.\nrewrite size_mul ?qq0 //.\nmove: nq0; rewrite -(ltn_modp p); move/leq_trans; apply.\nby rewrite (polySpred qq0) addSn /= leq_addl.\nQed."
}
{
  "statement": "Lemma intro_mxsemisimple (I : Type) r (P : pred I) W V :\n    (\\sum_(i <- r | P i) W i :=: V)%MS ->\n    (forall i, P i -> W i != 0 -> mxsimple (W i)) ->\n  mxsemisimple V.\n",
  "proof": "Proof.\nmove=> defV simW; pose W_0 := [pred i | W i == 0].\nhave [-> | nzV] := eqVneq V 0; first exact: mxsemisimple0.\ncase def_r: r => [| i0 r'] => [|{r' def_r}].\n  by rewrite -mxrank_eq0 -defV def_r big_nil mxrank0 in nzV.\nmove: defV; rewrite (bigID W_0) /= addsmxC -big_filter !(big_nth i0) !big_mkord.\nrewrite addsmxC big1 ?adds0mx_id => [|i /andP[_ /eqP] //].\nset tI := 'I_(_); set r_ := nth _ _ => defV.\nhave{simW} simWr (i : tI) : mxsimple (W (r_ i)).\n  case: i => m /=; set Pr := fun i => _ => lt_m_r /=.\n  suffices: (Pr (r_ m)) by case/andP; apply: simW.\n  apply: all_nthP m lt_m_r; apply/all_filterP.\n  by rewrite -filter_predI; apply: eq_filter => i; rewrite /= andbb.\nhave [J []] := sum_mxsimple_direct_sub simWr defV.\ncase: (set_0Vmem J) => [-> V0 | [j0 Jj0]].\n  by rewrite -mxrank_eq0 -V0 big_set0 mxrank0 in nzV.\npose K := {j | j \\in J}; pose k0 : K := Sub j0 Jj0.\nhave bij_KJ: {on J, bijective (sval : K -> _)}.\n  by exists (insubd k0) => [k _ | j Jj]; rewrite ?valKd ?insubdK.\nhave J_K (k : K) : sval k \\in J by apply: valP k.\nrewrite mxdirectE /= !(reindex _ bij_KJ) !(eq_bigl _ _ J_K) -mxdirectE /= -/tI.\nexact: MxSemisimple.\nQed."
}
{
  "statement": "Lemma gen_tperm_step n (k : 'I_n.+1) : coprime n.+1 k ->\n  <<[set tperm i (i + k) | i : 'I_n.+1]>>%g = [set: 'S_n.+1].\n",
  "proof": "Proof.\ncase: n k => [|n] k.\n  move=> _; apply/eqP; rewrite eqEsubset subsetT/= -(gen_tperm 0)/= gen_subG.\n  apply/subsetP => s /imsetP[/= [][|//] lt01 _ ->].\n  have ->: (Ordinal lt01) = 0 by apply/val_inj.\n  by rewrite tperm1 group1.\nrewrite -unitZpE// natr_Zp => k_unit.\napply/eqP; rewrite eqEsubset subsetT/= -(gen_tperm 0)/= gen_subG.\napply/subsetP => s /imsetP[/= i _ ->].\nrewrite -[i](mulVKr k_unit) -[_ * i]natr_Zp mulr_natr.\nelim: (val _) => //= {i} [|[|i] IHi]; first by rewrite tperm1 group1.\n  by rewrite mulrSr mem_gen//; apply/imsetP; exists 0.\nhave [->|kS2N0] := eqVneq (k *+ i.+2) 0; first by rewrite tperm1 group1.\nhave kSSneqkS : k *+ i.+2 != k *+ i.+1.\n  rewrite -subr_eq0 -mulrnBr// subSnn mulr1n.\n  by apply: contraTneq k_unit => ->; rewrite unitr0.\nrewrite -(@tpermJ_tperm _ (k *+ i.+1)) 1?eq_sym//.\nrewrite groupJ// 1?tpermC// mulrSr 1?tpermC.\nby rewrite mem_gen//; apply/imsetP; exists (k *+ i.+1).\nQed."
}
{
  "statement": "Lemma normal_field_splitting (F : fieldType) (L : fieldExtType F) :\n  (forall (K : {subfield L}) x,\n    exists r, minPoly K x == \\prod_(y <- r) ('X - y%:P)) ->\n  SplittingField.axiom L.\n",
  "proof": "Proof.\nmove=> normalL; pose r i := sval (sigW (normalL 1%AS (tnth (vbasis {:L}) i))).\nhave sz_r i: size (r i) <= \\dim {:L}.\n  rewrite -ltnS -(size_prod_XsubC _ id) /r; case: sigW => _ /= /eqP <-.\n  rewrite size_minPoly ltnS; move: (tnth _ _) => x.\n  by rewrite adjoin_degreeE dimv1 divn1 dimvS // subvf.\npose mkf (z : L) := 'X - z%:P.\nexists (\\prod_i \\prod_(j < \\dim {:L} | j < size (r i)) mkf (r i)`_j).\n  apply: rpred_prod => i _; rewrite big_ord_narrow /= /r; case: sigW => rs /=.\n  by rewrite (big_nth 0) big_mkord => /eqP <- {rs}; apply: minPolyOver.\nrewrite pair_big_dep /= -big_filter -(big_map _ xpredT mkf).\nset rF := map _ _; exists rF; first exact: eqpxx.\napply/eqP; rewrite eqEsubv subvf -(span_basis (vbasisP {:L})).\napply/span_subvP=> _ /tnthP[i ->]; set x := tnth _ i.\nhave /tnthP[j ->]: x \\in in_tuple (r i).\n  by rewrite -root_prod_XsubC /r; case: sigW => _ /=/eqP<-; apply: root_minPoly.\napply/seqv_sub_adjoin/mapP; rewrite (tnth_nth 0).\nexists (i, widen_ord (sz_r i) j) => //.\nby rewrite mem_filter /= ltn_ord mem_index_enum.\nQed."
}
{
  "statement": "Lemma asimpleP K :\n  reflect [/\\ K :!=: 1\n            & forall H, H <| K -> [acts A, on H | to] -> H :=: 1 \\/ H :=: K]\n          (asimple K).\n",
  "proof": "Proof.\napply: (iffP idP).\n  case/maxgroupP; rewrite normal1 /=; case/andP=> nsK1 aK H1.\n  rewrite eqEsubset negb_and nsK1 /=; split => // H nHK ha.\n  case eHK : (H :==: K); first by right; apply/eqP.\n  left; apply: H1; rewrite ?sub1G // nHK; move/negbT: eHK.\n  by rewrite eqEsubset negb_and normal_sub //=; move->.\ncase=> ntK h; apply/maxgroupP; split.\n  move: ntK; rewrite eqEsubset sub1G andbT normal1; move->.\n  apply/subsetP=> a Da; rewrite !inE Da /= sub1set !inE.\n  by rewrite /= -actmE // morph1 eqxx.\nmove=> H /andP[nHK /andP[nsKH ha]] _.\ncase: (h _ nHK ha)=> // /eqP; rewrite eqEsubset.\nby rewrite (negbTE nsKH) andbF.\nQed."
}
{
  "statement": "Lemma Phi_joing : 'Phi(P) = P^`(1) <*> 'Mho^1(P).\n",
  "proof": "Proof.\nhave [sPhiP nPhiP] := andP (Phi_normal P).\napply/eqP; rewrite eqEsubset join_subG.\ncase: (eqsVneq P 1) => [-> | ntP] in sPhiP *.\n  by rewrite /= (trivgP sPhiP) sub1G der_subS Mho_sub.\nhave [p_pr _ _] := pgroup_pdiv pP ntP.\nhave [abP x1P] := abelemP p_pr Phi_quotient_abelem.\napply/andP; split.\n  have nMP: P \\subset 'N(P^`(1) <*> 'Mho^1(P)) by rewrite normsY // !gFnorm.\n  rewrite -quotient_sub1 ?gFsub_trans //=.\n  suffices <-: 'Phi(P / (P^`(1) <*> 'Mho^1(P))) = 1 by apply: morphimF.\n  apply/eqP; rewrite (trivg_Phi (morphim_pgroup _ pP)) /= -quotientE.\n  apply/abelemP=> //; rewrite [abelian _]quotient_cents2 ?joing_subl //.\n  split=> // _ /morphimP[x Nx Px ->] /=.\n  rewrite -morphX //= coset_id // (MhoE 1 pP) joing_idr expn1.\n  by rewrite mem_gen //; apply/setUP; right; apply: imset_f.\nrewrite -quotient_cents2 // [_ \\subset 'C(_)]abP (MhoE 1 pP) gen_subG /=.\napply/subsetP=> _ /imsetP[x Px ->]; rewrite expn1.\nhave nPhi_x: x \\in 'N('Phi(P)) by apply: (subsetP nPhiP).\nby rewrite coset_idr ?groupX ?morphX ?x1P ?mem_morphim.\nQed."
}
{
  "statement": "Lemma section_eqmx_add U1 U2 V1 V2 modU1 modU2 modV1 modV2 :\n    (U1 :=: U2)%MS -> (U1 + V1 :=: U2 + V2)%MS ->\n  mx_rsim (@section_repr U1 V1 modU1 modV1) (@section_repr U2 V2 modU2 modV2).\n",
  "proof": "Proof.\nmove=> eqU12 eqV12; set n1 := {1}(\\rank _).\npose v1 := val_factmod (val_submod (1%:M : 'M_n1)).\nhave sv12: (v1 <= U2 + V2)%MS.\n  rewrite -eqV12 (submx_trans _ (proj_factmodS _ _)) //.\n  by rewrite submxMr // val_submod1 genmxE.\nexists (v1 *m in_factmod _ 1%:M *m in_submod _ 1%:M) => [||x Gx].\n- apply: (@addIn (\\rank U1)); rewrite {2}eqU12 /n1 !{1}genmxE.\n  by rewrite !{1}mxrank_in_factmod eqV12.\n- rewrite -kermx_eq0; apply/rowV0P=> u; rewrite (sameP sub_kermxP eqP) mulmxA.\n  rewrite -in_submodE mulmxA -in_factmodE -(inj_eq val_submod_inj) linear0.\n  rewrite in_submodK ?in_factmod_eq0 -?eqU12 => [U1uv1|]; last first.\n    by rewrite genmxE -(in_factmod_addsK U2 V2) submxMr // mulmx_sub.\n  apply: val_submod_inj; apply/eqP; rewrite linear0 -[val_submod _]val_factmodK.\n  by rewrite in_factmod_eq0 val_factmodE val_submodE -mulmxA -val_factmodE.\nsymmetry; rewrite -{1}in_submodE -{1}in_factmodE -{1}in_submodJ; last first.\n  by rewrite genmxE -(in_factmod_addsK U2 V2) submxMr.\nrewrite -{1}in_factmodJ // mulmxA in_submodE; congr (_ *m _); apply/eqP.\nrewrite mulmxA -in_factmodE -subr_eq0 -linearB in_factmod_eq0 -eqU12.\nrewrite -in_factmod_eq0 linearB /= subr_eq0 {1}(in_factmodJ modU1) //.\nrewrite val_factmodK /v1 val_factmodE eq_sym mulmxA -val_factmodE val_factmodK.\nby rewrite -[_ *m _]mul1mx mulmxA -val_submodE val_submodJ.\nQed."
}
{
  "statement": "Lemma normalField_factors K E :\n   (K <= E)%VS ->\n reflect {in E, forall a, exists2 r : seq (gal_of E),\n            r \\subset 'Gal(E / K)\n          & minPoly K a = \\prod_(x <- r) ('X - (x a)%:P)}\n   (normalField K E).\n",
  "proof": "Proof.\nmove=> sKE; apply: (iffP idP) => [nKE a Ea | nKE]; last first.\n  apply/normalFieldP=> a Ea; have [r _ ->] := nKE a Ea.\n  exists [seq x a | x : gal_of E <- r]; last by rewrite big_map.\n  by rewrite all_map; apply/allP=> b _; apply: memv_gal.\nhave [r Er splitKa] := normalFieldP nKE a Ea.\npose f b := [pick x in 'Gal(E / K) | x a == b].\nexists (pmap f r).\n  apply/subsetP=> x; rewrite mem_pmap /f => /mapP[b _].\n  by case: (pickP _) => // c /andP[galEc _] [->].\nrewrite splitKa; have{splitKa}: all (root (minPoly K a)) r.\n  by apply/allP => b; rewrite splitKa root_prod_XsubC.\nelim: r Er => /= [|b r IHr]; first by rewrite !big_nil.\ncase/andP=> Eb Er /andP[pKa_b_0 /(IHr Er){Er}IHr].\nhave [x galE /eqP xa_b] := normalField_root_minPoly sKE nKE Ea pKa_b_0.\nrewrite /(f b); case: (pickP _) => [y /andP[_ /eqP<-]|/(_ x)/andP[]//].\nby rewrite !big_cons IHr.\nQed."
}
{
  "statement": "Lemma has_prim_root (F : fieldType) (n : nat) (rs : seq F) :\n    n > 0 -> all n.-unity_root rs -> uniq rs -> size rs >= n ->\n  has n.-primitive_root rs.\n",
  "proof": "Proof.\nmove=> n_gt0 rsn1 Urs; rewrite leq_eqVlt ltnNge max_unity_roots // orbF eq_sym.\nmove/eqP=> sz_rs; pose r := val (_ : seq_sub rs).\nhave rn1 x: r x ^+ n = 1.\n  by apply/eqP; rewrite -unity_rootE (allP rsn1) ?(valP x).\nhave prim_r z: z ^+ n = 1 -> z \\in rs.\n  by move/eqP; rewrite -unity_rootE -(mem_unity_roots n_gt0).\npose r' := SeqSub (prim_r _ _); pose sG_1 := r' _ (expr1n _ _).\nhave sG_VP: r _ ^+ n.-1 ^+ n = 1.\n  by move=> x; rewrite -exprM mulnC exprM rn1 expr1n.\nhave sG_MP: (r _ * r _) ^+ n = 1 by move=> x y; rewrite exprMn !rn1 mul1r.\npose sG_V := r' _ (sG_VP _); pose sG_M := r' _ (sG_MP _ _).\nhave sG_Ag: associative sG_M by move=> x y z; apply: val_inj; rewrite /= mulrA.\nhave sG_1g: left_id sG_1 sG_M by move=> x; apply: val_inj; rewrite /= mul1r.\nhave sG_Vg: left_inverse sG_1 sG_V sG_M.\n  by move=> x; apply: val_inj; rewrite /= -exprSr prednK ?rn1.\nexact: has_prim_root_subproof.\nQed."
}
{
  "statement": "Lemma Clifford_astab : H <*> 'C_G(H) \\subset 'C([set: sH] | 'Cl).\n",
  "proof": "Proof.\nrewrite join_subG !subsetI sHG subsetIl /=; apply/andP; split.\n  apply/subsetP=> h Hh /[1!inE]; have Gh := subsetP sHG h Hh.\n  apply/subsetP=> W _; have simW := socle_simple W; have [modW _ _] := simW.\n  have simWh: mxsimple rH (socle_base W *m rG h) by apply: Clifford_simple.\n  rewrite inE -val_eqE /= PackSocleK eq_sym.\n  apply/component_mx_isoP; rewrite ?subgK //; apply: component_mx_iso => //.\n  by apply: submx_trans (component_mx_id simW); move/mxmoduleP: modW => ->.\napply/subsetP=> z cHz /[1!inE]; have [Gz _] := setIP cHz.\napply/subsetP=> W _; have simW := socle_simple W; have [modW _ _] := simW.\nhave simWz: mxsimple rH (socle_base W *m rG z) by apply: Clifford_simple.\nrewrite inE -val_eqE /= PackSocleK eq_sym.\nby apply/component_mx_isoP; rewrite ?subgK //; apply: Clifford_iso.\nQed."
}
{
  "statement": "Lemma Frobenius_kerP G K :\n  reflect [/\\ K :!=: 1, K \\proper G, K <| G\n            & {in K^#, forall x, 'C_G[x] \\subset K}]\n          [Frobenius G with kernel K].\n",
  "proof": "Proof.\napply: (iffP existsP) => [[H frobG] | [ntK ltKG nsKG regK]].\n  have [/sdprod_context[nsKG _ _ _ _] ntK _ ltKG _] := Frobenius_context frobG.\n  by split=> //; apply: Frobenius_cent1_ker frobG.\nhave /andP[sKG nKG] := nsKG.\nhave hallK: Hall G K.\n  rewrite /Hall sKG //= coprime_sym coprime_pi' //.\n  apply: sub_pgroup (pgroup_pi K) => p; have [P sylP] := Sylow_exists p G.\n  have [[sPG pP p'GiP] sylPK] := (and3P sylP, Hall_setI_normal nsKG sylP).\n  rewrite -p_rank_gt0 -(rank_Sylow sylPK) rank_gt0 => ntPK.\n  rewrite inE /= -p'natEpi // (pnat_dvd _ p'GiP) ?indexgS //.\n  have /trivgPn[z]: P :&: K :&: 'Z(P) != 1.\n    by rewrite meet_center_nil ?(pgroup_nil pP) ?(normalGI sPG nsKG).\n  rewrite !inE -andbA -sub_cent1=> /and4P[_ Kz _ cPz] ntz.\n  by apply: subset_trans (regK z _); [apply/subsetIP | apply/setD1P].\nhave /splitsP[H /complP[tiKH defG]] := SchurZassenhaus_split hallK nsKG.\nhave [_ sHG] := mulG_sub defG; have nKH := subset_trans sHG nKG.\nexists H; apply/Frobenius_semiregularP; rewrite ?sdprodE //.\n  by apply: contraNneq (proper_subn ltKG) => H1; rewrite -defG H1 mulg1.\napply: semiregular_sym => x Kx; apply/trivgP; rewrite -tiKH.\nby rewrite subsetI subsetIl (subset_trans _ (regK x _)) ?setSI.\nQed."
}
{
  "statement": "Lemma perm_allpairs_dep f s1 t1 s2 t2 :\n    perm_eq s1 s2 -> {in s1, forall x, perm_eq (t1 x) (t2 x)} ->\n  perm_eq [seq f x y | x <- s1, y <- t1 x] [seq f x y | x <- s2, y <- t2 x].\n",
  "proof": "Proof.\nelim: s1 s2 t1 t2 => [s2 t1 t2 |a s1 IH s2 t1 t2 perm_s2 perm_t1].\n  by rewrite perm_sym => /perm_nilP->.\nhave mem_a : a \\in s2 by rewrite -(perm_mem perm_s2) inE eqxx.\nrewrite -[s2](cat_take_drop (index a s2)).\nrewrite allpairs_cat (drop_nth a) ?index_mem //= nth_index //=.\nrewrite perm_sym perm_catC -catA perm_cat //; last first.\n  rewrite perm_catC -allpairs_cat.\n  rewrite -remE perm_sym IH // => [|x xI]; last first.\n    by apply: perm_t1; rewrite inE xI orbT.\n  by rewrite -(perm_cons a) (perm_trans perm_s2 (perm_to_rem _)).\nhave /perm_t1 : a \\in a :: s1  by rewrite inE eqxx.\nrewrite perm_sym; elim: (t2 a) (t1 a) => /= [s4|b s3 IH1 s4 perm_s4].\n  by rewrite perm_sym => /perm_nilP->.\nhave mem_b : b \\in s4 by rewrite -(perm_mem perm_s4) inE eqxx.\nrewrite -[s4](cat_take_drop (index b s4)).\nrewrite map_cat /= (drop_nth b) ?index_mem //= nth_index //=.\nrewrite perm_sym perm_catC /= perm_cons // perm_catC -map_cat.\nrewrite -remE perm_sym IH1 // -(perm_cons b).\nby apply: perm_trans perm_s4 (perm_to_rem _).\nQed."
}
{
  "statement": "Lemma iJ : conj i = - i.\n",
  "proof": "Proof.\n  have nz2 := nz2.\n  have /sqrtE[b]: conj i ^+ 2 = - 1 by rewrite -rmorphXn /= sqrtK rmorphN1.\n  rewrite mulr_sign -/i; case: b => // Ri.\n  case: conj_nt => z; wlog zJ: z / conj z = - z.\n    move/(_ (z - conj z)); rewrite !rmorphB conjK opprB => zJ.\n    by apply/mul2I/(canRL (subrK _)); rewrite -addrA zJ // addrC subrK.\n  have [-> | nz_z] := eqVneq z 0; first exact: rmorph0.\n  have [u Ru [v Rv Dz]]:\n    exists2 u, conj u = u & exists2 v, conj v = v & (u + z * v) ^+ 2 = z.\n  - pose y := sqrt z; exists ((y + conj y) / 2).\n      by rewrite fmorph_div rmorphD /= conjK addrC rmorph_nat.\n    exists ((y - conj y) / (z *+ 2)).\n      rewrite fmorph_div rmorphMn /= zJ mulNrn invrN mulrN -mulNr rmorphB opprB.\n      by rewrite conjK.\n    rewrite -(mulr_natl z) invfM (mulrC z) !mulrA divfK // -mulrDl addrACA.\n    \n    by rewrite subrr addr0 -mulr2n -[_ *+ 2]mulr_natr mulfK ?Neq0 ?sqrtK.\n  suff u0: u = 0 by rewrite -Dz u0 add0r rmorphXn rmorphM /= Rv zJ mulNr sqrrN.\n  suff [b Du]: exists b : bool, u = (-1) ^+ b * i * z * v.\n    apply: mul2I; rewrite mul0rn mulr2n -{2}Ru.\n    by rewrite Du !rmorphM /= rmorph_sign Rv Ri zJ !mulrN mulNr subrr.\n  have/eqP:= zJ; rewrite -addr_eq0 -{1 2}Dz rmorphXn rmorphD rmorphM /= Ru Rv zJ.\n  rewrite mulNr sqrrB sqrrD addrACA (addrACA (u ^+ 2)) addNr addr0 -!mulr2n.\n  rewrite -mulrnDl -(mul0rn _ 2) (inj_eq mul2I) /= -[rhs in _ + rhs]opprK.\n  rewrite -sqrMi subr_eq0 eqf_sqr -mulNr !mulrA.\n  by case/pred2P=> ->; [exists false | exists true]; rewrite mulr_sign.\nQed."
}
{
  "statement": "Lemma sum_mxsimple_direct_compl m I W (U : 'M_(m, n)) :\n    let V := (\\sum_(i : I) W i)%MS in\n    (forall i : I, mxsimple (W i)) -> mxmodule U -> (U <= V)%MS ->\n  {J : {set I} | let S := U + \\sum_(i in J) W i in S :=: V /\\ mxdirect S}%MS.\n",
  "proof": "Proof.\nmove=> V simW modU sUV; pose V_ (J : {set I}) := (\\sum_(i in J) W i)%MS.\npose dxU (J : {set I}) := mxdirect (U + V_ J).\nhave [J maxJ]: {J | maxset dxU J}; last case/maxsetP: maxJ => dxUVJ maxJ.\n  apply: ex_maxset; exists set0.\n  by rewrite /dxU mxdirectE /V_ /= !big_set0 addn0 addsmx0 /=.\nhave modWJ: mxmodule (V_ J) by apply: sumsmx_module => i _; case: (simW i).\nexists J; split=> //; apply/eqmxP; rewrite addsmx_sub sUV; apply/andP; split.\n  by apply/sumsmx_subP=> i Ji; rewrite (sumsmx_sup i).\nrewrite -/(V_ J); apply/sumsmx_subP=> i _.\ncase Ji: (i \\in J).\n  by apply: submx_trans (addsmxSr _ _); apply: (sumsmx_sup i).\nhave [modWi nzWi simWi] := simW i.\nrewrite (sameP capmx_idPl eqmxP) simWi ?capmxSl ?capmx_module ?addsmx_module //.\napply: contraFT (Ji); rewrite negbK => dxWiUVJ.\nrewrite -(maxJ (i |: J)) ?setU11 ?subsetUr // /dxU.\nrewrite mxdirectE /= !big_setU1 ?Ji //=.\nrewrite addnCA addsmxA (addsmxC U) -addsmxA -mxdirectE /=.\nby rewrite mxdirect_addsE /= mxdirect_trivial -/(dxU _) dxUVJ.\nQed."
}
{
  "statement": "Lemma make_separable p : p != 0 -> separable (p %/ gcdp p p^`()).\n",
  "proof": "Proof.\nset g := gcdp p p^`() => nz_p; apply/separable_polyP.\nhave max_dvd_u (u : {poly R}): 1 < size u -> exists k, ~~ (u ^+ k %| p).\n  move=> u_gt1; exists (size p); rewrite gtNdvdp // polySpred //.\n  by rewrite -(ltn_subRL 1) subn1 size_exp leq_pmull // -(subnKC u_gt1).\nsplit=> [|u u_pg u_gt1]; last first.\n  apply/eqP=> u'0 /=; have [k /negP[]] := max_dvd_u u u_gt1.\n  elim: k => [|k IHk]; first by rewrite dvd1p.\n  suffices: u ^+ k.+1 %| (p %/ g) * g.\n    by rewrite Pdiv.Idomain.divpK ?dvdp_gcdl // dvdpZr ?lcn_neq0.\n  rewrite exprS dvdp_mul // dvdp_gcd IHk //=.\n  suffices: u ^+ k %| (p %/ u ^+ k * u ^+ k)^`().\n    by rewrite Pdiv.Idomain.divpK // derivZ dvdpZr ?lcn_neq0.\n  by rewrite !derivCE u'0 mul0r mul0rn mulr0 addr0 dvdp_mull.\nhave pg_dv_p: p %/ g %| p by rewrite divp_dvd ?dvdp_gcdl.\napply/poly_square_freeP=> u; rewrite neq_ltn ltnS leqn0 size_poly_eq0.\ncase/predU1P=> [-> | /max_dvd_u[k]].\n  by apply: contra nz_p; rewrite expr0n -dvd0p => /dvdp_trans->.\napply: contra => u2_dv_pg; case: k; [by rewrite dvd1p | elim=> [|n IHn]].\n  exact: dvdp_trans (dvdp_mulr _ _) (dvdp_trans u2_dv_pg pg_dv_p).\nsuff: u ^+ n.+2 %| (p %/ g) * g.\n  by rewrite Pdiv.Idomain.divpK ?dvdp_gcdl // dvdpZr ?lcn_neq0.\nrewrite -add2n exprD dvdp_mul // dvdp_gcd.\nrewrite (dvdp_trans _ IHn) ?exprS ?dvdp_mull //=.\nsuff: u ^+ n %| ((p %/ u ^+ n.+1) * u ^+ n.+1)^`().\n  by rewrite Pdiv.Idomain.divpK // derivZ dvdpZr ?lcn_neq0.\nby rewrite !derivCE dvdp_add // -1?mulr_natl ?exprS !dvdp_mull.\nQed."
}
{
  "statement": "Lemma adjoin_separableP {K x} :\n  reflect (forall y, y \\in <<K; x>>%VS -> separable_element K y)\n          (separable_element K x).\n",
  "proof": "Proof.\napply: (iffP idP) => [sepKx | -> //]; last exact: memv_adjoin.\nmove=> _ /Fadjoin_polyP[q Kq ->]; apply/Derivation_separableP=> D derD DK_0.\napply/subvP=> _ /Fadjoin_polyP[p Kp ->].\nrewrite memv_ker -(extendDerivation_id x D (mempx_Fadjoin _ Kp)).\nhave sepFyx: (separable_element <<K; q.[x]>> x).\n  by apply: (separable_elementS (subv_adjoin _ _)).\nhave KyxEqKx: (<< <<K; q.[x]>>; x>> = <<K; x>>)%VS.\n  apply/eqP; rewrite eqEsubv andbC adjoinSl ?subv_adjoin //=.\n  apply/FadjoinP/andP; rewrite memv_adjoin andbT.\n  by apply/FadjoinP/andP; rewrite subv_adjoin mempx_Fadjoin.\nhave /[!KyxEqKx] derDx := extendDerivationP derD sepFyx.\nrewrite -horner_comp (Derivation_horner derDx) ?memv_adjoin //; last first.\n  by apply: (polyOverSv (subv_adjoin _ _)); apply: polyOver_comp.\nset Dx_p := map_poly _; have Dx_p_0 t: t \\is a polyOver K -> (Dx_p t).[x] = 0.\n  move/polyOverP=> Kt; congr (_.[x] = 0): (horner0 x); apply/esym/polyP => i.\n  have /eqP Dti_0: D t`_i == 0 by rewrite -memv_ker (subvP DK_0) ?Kt.\n  by rewrite coef0 coef_map /= {1}extendDerivation_id ?subvP_adjoin.\nrewrite (Derivation_separable derDx sepKx) -/Dx_p Dx_p_0 ?polyOver_comp //.\nby rewrite add0r mulrCA Dx_p_0 ?minPolyOver ?oppr0 ?mul0r.\nQed."
}
{
  "statement": "Lemma Wedderburn_min_ideal_pchar m i (E : 'A_(m, nG)) :\n  E != 0 -> (E <= 'R_i)%MS -> mx_ideal R_G E -> (E :=: 'R_i)%MS.\n",
  "proof": "Proof.\nmove=> nzE sE_Ri /andP[idlE idrE]; apply/eqmxP; rewrite sE_Ri.\npose M := E *m pinvmx R_G; have defE: E = M *m R_G.\n  by rewrite mulmxKpV // (submx_trans sE_Ri) // genmxE submxMl.\nhave modM: mxmodule aG M by rewrite regular_module_ideal -defE.\nhave simSi := socle_simple i; set Si := socle_base i in simSi.\nhave [I [W isoW defW]]:= component_mx_def simSi.\nrewrite /'R_i /socle_val /= defW genmxE defE submxMr //.\napply/sumsmx_subP=> j _.\nhave simW := mx_iso_simple (isoW j) simSi; have [modW _ minW] := simW.\nhave [{minW}dxWE | nzWE] := eqVneq (W j :&: M)%MS 0; last first.\n  by rewrite (sameP capmx_idPl eqmxP) minW ?capmxSl ?capmx_module.\nhave [_ Rei ideRi _] := Wedderburn_is_id_pchar i.\nhave:= nzE; rewrite -submx0 => /memmx_subP[A E_A].\nrewrite -(ideRi _ (memmx_subP sE_Ri _ E_A)).\nhave:= E_A; rewrite defE mem_sub_gring => /andP[R_A M_A].\nhave:= Rei; rewrite genmxE mem_sub_gring => /andP[Re].\nrewrite -{2}(gring_rowK Re) /socle_val defW => /sub_sumsmxP[e ->].\nrewrite !(linear_sum, mulmx_suml) summx_sub //= => k _.\nrewrite -(gring_rowK R_A) -gring_mxA -mulmxA gring_rowK //.\nrewrite ((W k *m _ =P 0) _) ?linear0 ?sub0mx //.\nhave [f _ homWf defWk] := mx_iso_trans (mx_iso_sym (isoW j)) (isoW k).\nrewrite -submx0 -{k defWk}(eqmxMr _ defWk) -(hom_envelop_mxC homWf) //.\nrewrite -(mul0mx _ f) submxMr {f homWf}// -dxWE sub_capmx.\nrewrite (mxmodule_envelop modW) //=; apply/row_subP=> k.\nrewrite row_mul -mem_gring_mx -(gring_rowK R_A) gring_mxA gring_rowK //.\nby rewrite -defE (memmx_subP idlE) // mem_mulsmx ?gring_mxP.\nQed."
}
{
  "statement": "Lemma card_subcent_extraspecial U :\n  U \\subset G -> #|'C_G(U)| = (#|'Z(G) :&: U| * #|G : U|)%N.\n",
  "proof": "Proof.\nmove=> sUG; rewrite setIAC (setIidPr sUG).\nhave [m leUm] := ubnP #|U|; elim: m => // m IHm in U leUm sUG *.\nhave [cUG | not_cUG]:= orP (orbN (G \\subset 'C(U))).\n  by rewrite !(setIidPl _) ?Lagrange // centsC.\nhave{not_cUG} [x Gx not_cUx] := subsetPn not_cUG.\npose W := 'C_U[x]; have sCW_G: 'C_G(W) \\subset G := subsetIl G _.\nhave maxW: maximal W U by rewrite subcent1_extraspecial_maximal // inE not_cUx.\nhave nsWU: W <| U := p_maximal_normal (pgroupS sUG pG) maxW.\nhave ltWU: W \\proper U by apply: maxgroupp maxW.\nhave [sWU [u Uu notWu]] := properP ltWU; have sWG := subset_trans sWU sUG.\nhave defU: W * <[u]> = U by rewrite (mulg_normal_maximal nsWU) ?cycle_subG.\nhave iCW_CU: #|'C_G(W) : 'C_G(U)| = p.\n  rewrite -defU centM cent_cycle setIA /=; rewrite inE Uu cent1C in notWu.\n  apply: p_maximal_index (pgroupS sCW_G pG) _.\n  apply: subcent1_extraspecial_maximal sCW_G _.\n  rewrite inE andbC (subsetP sUG) //= -sub_cent1.\n  by apply/subsetPn; exists x; rewrite // inE Gx -sub_cent1 subsetIr.\napply/eqP; rewrite -(eqn_pmul2r p_gt0) -{1}iCW_CU Lagrange ?setIS ?centS //.\nrewrite IHm ?(leq_trans (proper_card ltWU)) // -setIA -mulnA.\nrewrite -(Lagrange_index sUG sWU) (p_maximal_index (pgroupS sUG pG)) //=.\nby rewrite -cent_set1 (setIidPr (centS _)) ?sub1set.\nQed."
}
{
  "statement": "Lemma gen_diso3 :  dir_iso3 = <<[set r05; r14]>>.\n",
  "proof": "Proof.\napply/setP/subset_eqP/andP; split; first last.\n  rewrite gen_subG; apply/subsetP.\n  by move=> x /[!inE] /orP[] /eqP->; rewrite !eqxx !orbT.\napply/subsetP => x /[!inE].\nhave -> : s05 = r05 * r05  by iso_tac.\nhave -> : s14 = r14 * r14  by iso_tac.\nhave -> : s23 = r14 * r14 * r05 * r05 by iso_tac.\nhave -> : r23 = r05 * r14 * r05 * r14 * r14 by iso_tac.\nhave -> : r50 = r05  * r05 * r05 by iso_tac.\nhave -> : r41 = r14 * r14 * r14 by iso_tac.\nhave -> : r32 = r14 * r14 * r14 * r05* r14 by iso_tac.\nhave -> : r024 = r05 * r14 * r14 * r14 by iso_tac.\nhave -> : r042 = r14 * r05 * r05 * r05 by iso_tac.\nhave -> : r012 = r14 * r05 by iso_tac.\nhave -> : r021 = r05 * r14 * r05 * r05 by iso_tac.\nhave -> : r031 = r05 * r14 by iso_tac.\nhave -> : r013 = r05 * r05 * r14 * r05 by iso_tac.\nhave -> : r043 = r14 * r14 * r14 * r05 by iso_tac.\nhave -> : r034 = r05 * r05 * r05 * r14 by iso_tac.\nhave -> : s1 = r14 * r14 * r05 by iso_tac.\nhave -> : s2 = r05 * r14 * r14 by iso_tac.\nhave -> : s3 = r05 * r14 * r05 by iso_tac.\nhave -> : s4 = r05 * r14  * r14 * r14 * r05 by iso_tac.\nhave -> : s5 = r14  * r05 * r05 by iso_tac.\nhave -> : s6 = r05 * r05 * r14 by iso_tac.\nby do ?case/predU1P=> [<-|]; first exact: group1; last (move/eqP<-);\n   rewrite ?groupMl ?mem_gen // !inE eqxx ?orbT.\nQed."
}
{
  "statement": "Lemma card_n2_3 : forall x y z t u v: cube, uniq [:: x; y; z; t; u; v] ->\n  #|[set p : col_cubes | (p x == p y) && (p y == p z)&& (p t == p u )\n                            && (p u== p v)]|  = (n ^ 2)%N.\n",
  "proof": "Proof.\nmove=> x y z t u v  Uxv; rewrite -[n]card_ord .\npose ff (p : col_cubes) := (p x, p t).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and4P[/eqP p1xy /eqP p1yz /eqP p1tu /eqP p1uv].\n  move=> /and4P[/eqP p2xy/eqP  p2yz /eqP p2tu /eqP p2uv] [px pu].\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1yz -p2yz -p1xy -p2xy -p1uv -p2uv -p1tu -p2tu px pu !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nrewrite -mulnn -!card_prod; apply: eq_card => [] [c d]/=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z]) => /= /and3P[Uxt + nuv].\nmove=> /[!orbF] /norP[] /[!inE] /negPf nxyzt /norP[/negPf nxyzu /negPf nxyzv].\nexists [ffun i =>  if (i \\in [:: x; y; z] ) then c else d].\n  by rewrite /= !(inE, ffunE, eqxx, orbT, nxyzt, nxyzu, nxyzv).\nby rewrite {}/ff !ffunE  !inE /= !eqxx /= nxyzt.\nQed."
}
{
  "statement": "Lemma abelem_splits p G H : p.-abelem G -> H \\subset G -> [splits G, over H].\n",
  "proof": "Proof.\nhave [m] := ubnP #|G|; elim: m G H => // m IHm G H /ltnSE-leGm abelG sHG.\nhave [-> | ] := eqsVneq H 1. \n  by apply/splitsP; exists G; rewrite inE mul1g -subG1 subsetIl /=.\ncase/trivgPn=> x Hx ntx; have Gx := subsetP sHG x Hx.\nhave [_ cGG eGp] := and3P abelG.\nhave ox: #[x] = exponent G.\n  by apply/eqP; rewrite eqn_dvd dvdn_exponent // (abelem_order_p abelG).\ncase/splitsP: (abelian_splits Gx ox cGG) => K; case/complP=> tixK defG.\nhave sKG: K \\subset G by rewrite -defG mulG_subr.\nhave ltKm: #|K| < m.\n  rewrite (leq_trans _ leGm) ?proper_card //; apply/properP; split=> //.\n  exists x => //; apply: contra ntx => Kx; rewrite -cycle_eq1 -subG1 -tixK.\n  by rewrite subsetI subxx cycle_subG.\ncase/splitsP: (IHm _ _ ltKm (abelemS sKG abelG) (subsetIr H K)) => L.\ncase/complP=> tiHKL defK; apply/splitsP; exists L; rewrite inE.\nrewrite -subG1 -tiHKL -setIA setIS; last by rewrite subsetI -defK mulG_subr /=.\nby rewrite -(setIidPr sHG) -defG -group_modl ?cycle_subG //= setIC -mulgA defK.\nQed."
}
{
  "statement": "Lemma nz2: 2 != 0 :> L.\n",
  "proof": "Proof.\n  apply/eqP=> pchar2; apply: conj_nt => e; apply/eqP/idPn=> eJ.\n  have opp_id x: - x = x :> L.\n    by apply/esym/eqP; rewrite -addr_eq0 -mulr2n -mulr_natl pchar2 mul0r.\n  have{} pchar2: 2%N \\in [pchar L] by apply/eqP.\n  without loss{eJ} eJ: e / conj e = e + 1.\n    move/(_ (e / (e + conj e))); apply.\n    rewrite fmorph_div rmorphD /= conjK -{1}[conj e](addNKr e) mulrDl.\n    by rewrite opp_id (addrC e) divff // addr_eq0 opp_id.\n  pose a := e * conj e; have aJ: conj a = a by rewrite rmorphM /= conjK mulrC.\n  have [w Dw] := @solve_monicpoly _ 2%N (nth 0 [:: e * a; - 1]) isT.\n  have{} Dw: w ^+ 2 + w = e * a.\n    by rewrite Dw !big_ord_recl big_ord0 /= mulr1 mulN1r addr0 subrK.\n  pose b := w + conj w; have bJ: conj b = b by rewrite rmorphD /= conjK addrC.\n  have Db2: b ^+ 2 + b = a.\n    rewrite -pFrobenius_autE // rmorphD addrACA Dw /= pFrobenius_autE -rmorphXn.\n    by rewrite -rmorphD Dw rmorphM /= aJ eJ -mulrDl -{1}[e]opp_id addKr mul1r.\n  have /eqP[] := oner_eq0 L; apply: (addrI b); rewrite addr0 -{2}bJ.\n  have: (b + e) * (b + conj e) == 0.\n    \n    rewrite mulrDl 2![_ * (b + _)]mulrDr -/a.\n    rewrite addrA addr_eq0 opp_id (mulrC e) -addrA.\n    by rewrite -mulrDr eJ addrAC -{2}[e]opp_id subrr add0r mulr1 Db2.\n  rewrite mulf_eq0 !addr_eq0 !opp_id => /pred2P[] -> //.\n  by rewrite {2}eJ rmorphD rmorph1.\nQed."
}
{
  "statement": "Lemma size2_dvdp_gdco p q d : p != 0 -> size d = 2 ->\n  (d %| (gdcop q p)) = (d %| p) && ~~(d %| q).\n",
  "proof": "Proof.\nhave [-> | dn0] := eqVneq d 0; first by rewrite size_poly0.\nmove=> p0 sd; apply/idP/idP.\n  case: gdcopP=> r rp crq maxr dr; move/negPf: (p0)=> p0f.\n  rewrite (dvdp_trans dr) //=.\n  apply: contraL crq => dq; rewrite p0f orbF; apply/coprimepPn.\n    by apply: contraNneq p0 => r0; move: rp; rewrite r0 dvd0p.\n  by exists d; rewrite dvdp_gcd dr dq -size_poly_eq1 sd.\ncase/andP=> dp dq; case: gdcopP=> r rp crq maxr; apply: maxr=> //.\napply/coprimepP=> x xd xq.\nmove: (dvdp_leq dn0 xd); rewrite leq_eqVlt sd; case/orP; last first.\n  rewrite ltnS leq_eqVlt ltnS size_poly_leq0 orbC.\n  case/predU1P => [x0|]; last by rewrite -size_poly_eq1.\n  by move: xd; rewrite x0 dvd0p (negPf dn0).\nby rewrite -sd dvdp_size_eqp //; move/(eqp_dvdl q); rewrite xq (negPf dq).\nQed."
}
{
  "statement": "Theorem faithful_degree_p_part gT (p : nat) (G P : {group gT}) i :\n    cfaithful 'chi[G]_i -> p.-nat (Num.truncn ('chi_i 1%g)) ->\n    p.-Sylow(G) P -> abelian P ->\n  'chi_i 1%g = (#|G : 'Z(G)|`_p)%:R.\n",
  "proof": "Proof.\nhave [p_pr | pr'p] := boolP (prime p); last first.\n  have p'n n: (n > 0)%N -> p^'.-nat n.\n    by move/p'natEpi->; rewrite mem_primes (negPf pr'p).\n  rewrite irr1_degree natrK => _ /pnat_1-> => [_ _|].\n    by rewrite part_p'nat ?p'n.\n  by rewrite p'n ?irr_degree_gt0.\nmove=> fful_i /p_natP[a Dchi1] sylP cPP.\nhave Dchi1C: 'chi_i 1%g = (p ^ a)%:R by rewrite -Dchi1 irr1_degree natrK.\nhave pa_dv_ZiG: (p ^ a %| #|G : 'Z(G)|)%N.\n  rewrite -dvdC_nat -[pa in (pa %| _)%C]Dchi1C -(cfcenter_fful_irr fful_i).\n  exact: dvd_irr1_index_center.\nhave [sPG pP p'PiG] := and3P sylP.\nhave ZchiP: 'Res[P] 'chi_i \\in 'CF(P, P :&: 'Z(G)).\n  apply/cfun_onP=> x /[1!inE]; have [Px | /cfun0->//] := boolP (x \\in P).\n  rewrite /= -(cfcenter_fful_irr fful_i) cfResE //.\n  apply: coprime_degree_support_cfcenter.\n  rewrite Dchi1 coprimeXl // prime_coprime // -p'natE //.\n  apply: pnat_dvd p'PiG; rewrite -index_cent1 indexgS // subsetI sPG.\n  by rewrite sub_cent1 (subsetP cPP).\nhave /andP[_ nZG] := center_normal G; have nZP := subset_trans sPG nZG.\napply/eqP; rewrite Dchi1C eqr_nat eqn_dvd -{1}(pfactorK a p_pr) -p_part.\nrewrite partn_dvd //= -dvdC_nat -[pa in (_ %| pa)%C]Dchi1C -card_quotient //=.\nrewrite -(card_Hall (quotient_pHall nZP sylP)) card_quotient // -indexgI.\nrewrite -(cfResE _ sPG) // index_support_dvd_degree ?subsetIl ?cPP ?orbT //.\nby rewrite cfRes_char ?irr_char.\nQed."
}
{
  "statement": "Lemma pmaxElem_LdivP p G E :\n  prime p -> reflect ('Ldiv_p('C_G(E)) = E) (E \\in 'E*_p(G)).\n",
  "proof": "Proof.\nmove=> p_pr; apply: (iffP (pmaxElemP p G E)) => [[] | defE].\n  case/pElemP=> sEG abelE maxE; have [_ cEE eE] := and3P abelE.\n  apply/setP=> x; rewrite !inE -andbA; apply/and3P/idP=> [[Gx cEx xp] | Ex].\n    rewrite -(maxE (<[x]> <*> E)%G) ?joing_subr //.\n      by rewrite -cycle_subG joing_subl.\n    rewrite inE join_subG cycle_subG Gx sEG /=.\n    rewrite (cprod_abelem _ (cprodEY _)); last by rewrite centsC cycle_subG.\n    by rewrite cycle_abelem ?p_pr ?orbT // order_dvdn xp.\n  by rewrite (subsetP sEG) // (subsetP cEE) // (exponentP eE).\nsplit=> [|H]; last first.\n  case/pElemP=> sHG /abelemP[// | cHH Hp1] sEH.\n  apply/eqP; rewrite eqEsubset sEH andbC /= -defE; apply/subsetP=> x Hx.\n  by rewrite 3!inE (subsetP sHG) // Hp1 ?(subsetP (centsS _ cHH)) /=.\napply/pElemP; split; first by rewrite -defE -setIA subsetIl.\napply/abelemP=> //; rewrite /abelian -{1 3}defE setIAC subsetIr.\nby split=> //; apply/exponentP; rewrite -sub_LdivT setIAC subsetIr.\nQed."
}
{
  "statement": "Lemma Aut_sub_fullP :\n  reflect (forall h : {morphism H >-> gT}, 'injm h -> h @* H = H ->\n             exists g : {morphism G >-> gT},\n             [/\\ 'injm g, g @* G = G & {in H, g =1 h}])\n          (Aut_in (Aut G) H \\isog Aut H).\n",
  "proof": "Proof.\nrewrite (isog_transl _ Aut_in_isog) /=; set rG := _ @* _.\napply: (iffP idP) => [iso_rG h injh hH| AutHinG].\n  have: aut injh hH \\in rG; last case/morphimP=> g nHg AutGg def_g.\n    suffices ->: rG = Aut H by apply: Aut_aut.\n    by apply/eqP; rewrite eqEcard restr_perm_Aut /= (card_isog iso_rG).\n  exists (autm_morphism AutGg); rewrite injm_autm im_autm; split=> // x Hx.\n  by rewrite -(autE injh hH Hx) def_g actpermE actbyE.\nsuffices ->: rG = Aut H by apply: isog_refl.\napply/eqP; rewrite eqEsubset restr_perm_Aut /=.\napply/subsetP=> h AutHh; have hH := im_autm AutHh.\nhave [g [injg gG eq_gh]] := AutHinG _ (injm_autm AutHh) hH.\nhave [Ng AutGg]: aut injg gG \\in 'N(H | 'P) /\\ aut injg gG \\in Aut G.\n  rewrite Aut_aut !inE; split=> //; apply/subsetP=> x Hx.\n  by rewrite inE /= /aperm autE ?(subsetP sHG) // -hH eq_gh ?mem_morphim.\napply/morphimP; exists (aut injg gG) => //; apply: (eq_Aut AutHh) => [|x Hx].\n  by rewrite (subsetP restr_perm_Aut) // mem_morphim.\nby rewrite restr_permE //= /aperm autE ?eq_gh ?(subsetP sHG).\nQed."
}
{
  "statement": "Lemma det_mulmx n (A B : 'M[R]_n) : \\det (A *m B) = \\det A * \\det B.\n",
  "proof": "Proof.\nrewrite big_distrl /=.\npose F := ('I_n ^ n)%type; pose AB s i j := A i j * B j (s i).\ntransitivity (\\sum_(f : F) \\sum_(s : 'S_n) (-1) ^+ s * \\prod_i AB s i (f i)).\n  rewrite exchange_big; apply: eq_bigr => /= s _; rewrite -big_distrr /=.\n  congr (_ * _); rewrite -(bigA_distr_bigA (AB s)) /=.\n  by apply: eq_bigr => x _; rewrite mxE.\nrewrite (bigID (fun f : F => injectiveb f)) /= addrC big1 ?add0r => [|f Uf].\n  rewrite (reindex (@pval _)) /=; last first.\n    pose in_Sn := insubd (1%g : 'S_n).\n    by exists in_Sn => /= f Uf; first apply: val_inj; apply: insubdK.\n  apply: eq_big => /= [s | s _]; rewrite ?(valP s) // big_distrr /=.\n  rewrite (reindex_inj (mulgI s)); apply: eq_bigr => t _ /=.\n  rewrite big_split /= [in LHS]mulrA mulrCA mulrA mulrCA mulrA.\n  rewrite -signr_addb odd_permM !pvalE; congr (_ * _); symmetry.\n  by rewrite (reindex_perm s); apply: eq_bigr => i; rewrite permM.\ntransitivity (\\det (\\matrix_(i, j) B (f i) j) * \\prod_i A i (f i)).\n  rewrite mulrC big_distrr /=; apply: eq_bigr => s _.\n  rewrite mulrCA big_split //=; congr (_ * (_ * _)).\n  by apply: eq_bigr => x _; rewrite mxE.\ncase/injectivePn: Uf => i1 [i2 Di12 Ef12].\nby rewrite (determinant_alternate Di12) ?simp //= => j; rewrite !mxE Ef12.\nQed."
}
{
  "statement": "Lemma qf_to_dnfP e :\n  let qev f b := qf_eval e (dnf_to_form (qf_to_dnf f b)) in\n  forall f, qf_form f && rformula f -> qev f false = qf_eval e f.\n",
  "proof": "Proof.\nmove=> qev; have qevT f: qev f true = ~~ qev f false.\n  rewrite {}/qev; elim: f => //=; do [by case | move=> f1 IH1 f2 IH2 | ].\n  - by move=> t1 t2; rewrite !andbT !orbF.\n  - by rewrite and_dnfP cat_dnfP negb_and -IH1 -IH2.\n  - by rewrite and_dnfP cat_dnfP negb_or -IH1 -IH2.\n  - by rewrite and_dnfP cat_dnfP /= negb_or IH1 -IH2 negbK.\n  by move=> t1 ->; rewrite negbK.\nrewrite /qev; elim=> //=; first by case.\n- by move=> t1 t2 _; rewrite subr_eq0 !andbT orbF.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite and_dnfP /= => /IH1-> /IH2->.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite cat_dnfP /= => /IH1-> => /IH2->.\n- move=> f1 IH1 f2 IH2; rewrite andbCA -andbA andbCA andbA; case/andP.\n  by rewrite cat_dnfP /= [qf_eval _ _]qevT -implybE => /IH1 <- /IH2->.\nby move=> f1 IH1 /IH1 <-; rewrite -qevT.\nQed."
}
{
  "statement": "Lemma pchar0_PET (q : {poly F}) :\n    q != 0 -> root (q ^ iota) y -> [pchar F] =i pred0 ->\n  exists n, let z := y *+ n - x in inFz z x /\\ inFz z y.\n",
  "proof": "Proof.\nmove=> nz_q qy_0 /pcharf0P pcharF0.\nwithout loss{nz_q} sep_q: q qy_0 / separable_poly q.\n  move=> IHq; apply: IHq (make_separable nz_q).\n  have /dvdpP[q1 Dq] := dvdp_gcdl q q^`().\n  rewrite {1}Dq mulpK ?gcdp_eq0; last by apply/nandP; left.\n  have [n [r nz_ry Dr]] := multiplicity_XsubC (q ^ iota) y.\n  rewrite map_poly_eq0 nz_q /= in nz_ry.\n  case: n => [|n] in Dr; first by rewrite Dr mulr1 (negPf nz_ry) in qy_0.\n  have: ('X - y%:P) ^+ n.+1 %| q ^ iota by rewrite Dr dvdp_mulIr.\n  rewrite Dq rmorphM /= gcdp_map -(eqp_dvdr _ (gcdp_mul2l _ _ _)) -deriv_map Dr.\n  rewrite dvdp_gcd derivM deriv_exp derivXsubC mul1r !mulrA dvdp_mulIr /=.\n  rewrite mulrDr mulrA dvdp_addr ?dvdp_mulIr // exprS -scaler_nat -!scalerAr.\n  rewrite dvdpZr -?(rmorph_nat iota) ?fmorph_eq0 ?pcharF0 //.\n  rewrite mulrA dvdp_mul2r ?expf_neq0 ?polyXsubC_eq0 //.\n  by rewrite Gauss_dvdpl ?dvdp_XsubCl // coprimep_sym coprimep_XsubC.\nhave [r nz_r PETxy] := large_field_PET qy_0 sep_q.\npose ts := mkseq (fun n => iota n%:R) (size r).\nhave /(max_ring_poly_roots nz_r)/=/implyP: uniq_roots ts.\n  rewrite uniq_rootsE mkseq_uniq // => m n eq_mn; apply/eqP; rewrite eqn_leq.\n  wlog suffices: m n eq_mn / m <= n by move=> IHmn; rewrite !IHmn.\n  move/fmorph_inj/eqP: eq_mn; rewrite -subr_eq0 leqNgt; apply: contraL => lt_mn.\n  by rewrite -natrB ?(ltnW lt_mn) // pcharF0 -lt0n subn_gt0.\nrewrite size_mkseq ltnn implybF all_map => /allPn[n _ /= /PETxy].\nby rewrite rmorph_nat mulr_natl; exists n.\nQed."
}
{
  "statement": "Lemma size_abelian_type G : abelian G -> size (abelian_type G) = 'r(G).\n",
  "proof": "Proof.\nmove=> cGG; have [b defG def_t] := abelian_structure cGG.\napply/eqP; rewrite -def_t size_map eqn_leq andbC; apply/andP; split.\n  have [p p_pr ->] := rank_witness G; rewrite p_rank_abelian //.\n  by rewrite -indexg1 -(Ohm0 G) -(count_logn_dprod_cycle _ _ defG) count_size.\ncase/lastP def_b: b => // [b' x]; pose p := pdiv #[x].\nhave p_pr: prime p.\n  have:= abelian_type_gt1 G; rewrite -def_t def_b map_rcons -cats1 all_cat.\n  by rewrite /= andbT => /andP[_]; apply: pdiv_prime.\nsuffices: all [pred y | logn p #[y] > 0] b.\n  rewrite all_count (count_logn_dprod_cycle _ _ defG) -def_b; move/eqP <-.\n  by rewrite Ohm0 indexg1 -p_rank_abelian ?p_rank_le_rank.\napply/allP=> y; rewrite def_b mem_rcons inE /= => b_y.\nrewrite lognE p_pr order_gt0 (dvdn_trans (pdiv_dvd _)) //.\ncase/predU1P: b_y => [-> // | b'_y].\nhave:= abelian_type_dvdn_sorted G; rewrite -def_t def_b.\ncase/splitPr: b'_y => b1 b2; rewrite -cat_rcons rcons_cat map_cat !map_rcons.\nrewrite headI /= cat_path -(last_cons 2) -headI last_rcons.\ncase/andP=> _ /order_path_min min_y.\napply: (allP (min_y _)) => [? ? ? ? dv|]; first exact: (dvdn_trans dv).\nby rewrite mem_rcons mem_head.\nQed."
}
{
  "statement": "Lemma extend_group_splitting_field :\n  group_splitting_field aF G -> group_splitting_field rF G.\n",
  "proof": "Proof.\nmove=> splitG n rG irrG.\nhave modU0: all ((mxmodule (regular_repr aF G)) #|G|) [::] by [].\napply: (mx_Schreier modU0 _) => // [[U [compU lastU _]]]; have [modU _]:= compU.\npose Uf := map (map_mx f) U.\nhave{lastU} lastUf: (last 0 Uf :=: 1%:M)%MS.\n  by rewrite -(map_mx0 f) -(map_mx1 f) last_map; apply/map_eqmx.\nhave modUf: mx_subseries (regular_repr rF G) Uf.\n  rewrite /mx_subseries all_map; apply: etrans modU; apply: eq_all => Ui /=.\n  rewrite -mxmodule_map; apply: eq_subset_r => x.\n  by rewrite !inE map_regular_repr.\nhave absUf i: i < size U -> mx_absolutely_irreducible (subseries_repr i modUf).\n  move=> lt_i_U; rewrite -(mx_rsim_abs_irr (map_regular_subseries i modU _)).\n  rewrite map_mx_abs_irr; apply: splitG.\n  by apply: mx_rsim_irr (mx_series_repr_irr compU lt_i_U); apply: section_eqmx.\nhave compUf: mx_composition_series (regular_repr rF G) Uf.\n  split=> // i; rewrite size_map => ltiU.\n  move/max_submodP: (mx_abs_irrW (absUf i ltiU)); apply.\n  rewrite -{2}(map_mx0 f) -map_cons !(nth_map 0) ?leqW //.\n  by rewrite map_submx // ltmxW // (pathP _ (mx_series_lt compU)).\nhave [[i ltiU] simUi] := rsim_regular_series irrG compUf lastUf.\nhave{} simUi: mx_rsim rG (subseries_repr i modUf).\n  by apply: mx_rsim_trans simUi _; apply: section_eqmx.\nby rewrite (mx_rsim_abs_irr simUi) absUf; rewrite size_map in ltiU.\nQed."
}
{
  "statement": "Lemma ntransitive_weak k m :\n  k <= m -> [transitive^m G, on S | to] -> [transitive^k G, on S | to].\n",
  "proof": "Proof.\nmove/subnKC <-; rewrite addnC; elim: {m}(m - k) => // m IHm.\nrewrite addSn => tr_m1; apply: IHm; move: {m k}(m + k) tr_m1 => m tr_m1.\nhave ext_t t: t \\in dtuple_on m S ->\n  exists x, [tuple of x :: t] \\in m.+1.-dtuple(S).\n- move=> dt.\n  have [sSt | /subsetPn[x Sx ntx]] := boolP (S \\subset t); last first.\n    by exists x; rewrite dtuple_on_add andbA /= Sx ntx.\n  case/imsetP: tr_m1 dt => t1 /[!inE] /andP[Ut1 St1] _ /andP[Ut _].\n  have /subset_leq_card := subset_trans St1 sSt.\n  by rewrite !card_uniq_tuple // ltnn.\ncase/imsetP: (tr_m1); case/tupleP=> [x t]; rewrite dtuple_on_add.\ncase/and3P=> Sx ntx dt; set xt := [tuple of _] => tr_xt.\napply/imsetP; exists t => //.\napply/setP=> u; apply/idP/imsetP=> [du | [a Ga ->{u}]].\n  case: (ext_t u du) => y; rewrite tr_xt.\n  by case/imsetP=> a Ga [_ def_u]; exists a => //; apply: val_inj.\nhave: n_act to xt a \\in dtuple_on _ S by rewrite tr_xt imset_f.\nby rewrite n_act_add dtuple_on_add; case/and3P.\nQed."
}
{
  "statement": "Lemma Wedderburn_subring_center_pchar i : ('Z('R_i) :=: mxvec 'e_i)%MS.\n",
  "proof": "Proof.\nhave [nz_e Re ideR idRe] := Wedderburn_is_id_pchar i.\nhave Ze: (mxvec 'e_i <= 'Z('R_i))%MS.\n  rewrite sub_capmx [(_ <= _)%MS]Re.\n  by apply/cent_mxP=> A R_A; rewrite ideR // idRe.\npose irrG := socle_irr i; set rG := socle_repr i in irrG.\npose E_G := enveloping_algebra_mx rG; have absG := splitG irrG.\napply/eqmxP; rewrite andbC -(geq_leqif (mxrank_leqif_eq Ze)).\nhave ->: \\rank (mxvec 'e_i) = (0 + 1)%N.\n  by apply/eqP; rewrite eqn_leq rank_leq_row lt0n mxrank_eq0 mxvec_eq0.\nrewrite -(mxrank_mul_ker _ (lin_mx (gring_op rG))) addnC leq_add //.\n  rewrite leqn0 mxrank_eq0 -submx0 -(ker_irr_comp_op_pchar irrG) capmxS //.\n  by rewrite irr_reprK_pchar capmxSl.\napply: leq_trans (mxrankS _) (rank_leq_row (mxvec 1%:M)).\napply/memmx_subP=> Ar; case/submxP=> a ->{Ar}.\nrewrite mulmxA mul_rV_lin /=; set A := vec_mx _.\nrewrite memmx1 (mx_abs_irr_cent_scalar absG) // -memmx_cent_envelop.\napply/cent_mxP=> Br; rewrite -(irr_comp_envelop_pchar irrG) irr_reprK_pchar.\ncase/submxP=> b /(canRL mxvecK) ->{Br}; rewrite mulmxA mx_rV_lin /=.\nset B := vec_mx _; have RiB: (B \\in 'R_i)%MS by rewrite vec_mxK submxMl.\nhave sRiR: ('R_i <= R_G)%MS by rewrite -Wedderburn_sum_pchar (sumsmx_sup i).\nhave: (A \\in 'Z('R_i))%MS by rewrite vec_mxK submxMl.\nrewrite sub_capmx => /andP[RiA /cent_mxP cRiA].\nby rewrite -!gring_opM ?(memmx_subP sRiR) 1?cRiA.\nQed."
}
{
  "statement": "Lemma ntransitive_primitive m :\n  1 < m -> [transitive^m G, on S | to] -> [primitive G, on S | to].\n",
  "proof": "Proof.\nmove=> lt1m /(ntransitive_weak lt1m) {m lt1m}tr2G.\nhave trG: [transitive G, on S | to] by apply: ntransitive1 tr2G.\nhave [x Sx _]:= imsetP trG; rewrite (trans_prim_astab Sx trG).\napply/maximal_eqP; split=> [|H]; first exact: subsetIl; rewrite subEproper.\ncase/predU1P; first by [left]; case/andP=> sCH /subsetPn[a Ha nCa] sHG.\nright; rewrite -(subgroup_transitiveP Sx sHG trG _) ?mulSGid //.\nhave actH := subset_trans sHG (atrans_acts trG).\npose y := to x a; have Sy: y \\in S by rewrite (actsP actH).\nhave{nCa} yx: y != x by rewrite inE (sameP astab1P eqP) (subsetP sHG) in nCa.\napply/imsetP; exists y => //; apply/eqP.\nrewrite eqEsubset acts_sub_orbit // Sy andbT; apply/subsetP=> z Sz.\nhave [-> | zx] := eqVneq z x; first by rewrite orbit_sym mem_orbit.\npose ty := [tuple y; x]; pose tz := [tuple z; x].\nhave [Sty Stz]: ty \\in 2.-dtuple(S) /\\ tz \\in 2.-dtuple(S).\n  by rewrite !inE !memtE !subset_all /= !mem_seq1 !andbT; split; apply/and3P.\ncase: (atransP2 tr2G Sty Stz) => b Gb [->] /esym/astab1P cxb.\nby rewrite mem_orbit // (subsetP sCH) // inE Gb.\nQed."
}
{
  "statement": "Theorem stab_ntransitive m x :\n    0 < m -> x \\in S -> [transitive^m.+1 G, on S | to] ->\n  [transitive^m 'C_G[x | to], on S :\\ x | to].\n",
  "proof": "Proof.\nmove=> m_gt0 Sx Gtr; have sSxS: S :\\ x \\subset S by rewrite subsetDl.\ncase: (imsetP Gtr); case/tupleP=> x1 t1; rewrite dtuple_on_add.\ncase/and3P=> Sx1 nt1x1 dt1 trt1; have Gtr1 := ntransitive1 (ltn0Sn _) Gtr.\ncase: (atransP2 Gtr1 Sx1 Sx) => // a Ga x1ax.\npose t := n_act to t1 a.\nhave dxt: [tuple of x :: t] \\in m.+1.-dtuple(S).\n  by rewrite trt1 x1ax; apply/imsetP; exists a => //; apply: val_inj.\napply/imsetP; exists t; first by rewrite dtuple_on_add_D1 Sx in dxt.\napply/setP=> t2; apply/idP/imsetP => [dt2|[b]].\n  have: [tuple of x :: t2] \\in dtuple_on _ S by rewrite dtuple_on_add_D1 Sx.\n  case/(atransP2 Gtr dxt)=> b Gb [xbx tbt2].\n  by exists b; [rewrite inE Gb; apply/astab1P | apply: val_inj].\ncase/setIP=> Gb /astab1P xbx ->{t2}.\nrewrite n_act_dtuple //; last by rewrite dtuple_on_add_D1 Sx in dxt.\napply/astabsP=> y; rewrite !inE -{1}xbx (inj_eq (act_inj _ _)).\nby rewrite (actsP (atrans_acts Gtr1)).\nQed."
}
{
  "statement": "Lemma comm_redivpP m d : comm_redivp_spec m d (redivp m d).\n",
  "proof": "Proof.\nrewrite unlock; have [->|Hd] := eqVneq d 0.\n  by constructor; rewrite !(simp, eqxx).\nhave: GRing.comm d (lead_coef d)%:P -> m * (lead_coef d ^+ 0)%:P = 0 * d + m.\n  by rewrite !simp.\nelim: (size m) 0%N 0 {1 4 6}m (leqnn (size m)) => [|n IHn] k q r Hr /=.\n  move/size_poly_leq0P: Hr ->.\n  suff hsd: size (0: {poly R}) < size d by rewrite hsd => /= ?; constructor.\n  by rewrite size_poly0 size_poly_gt0.\ncase: ltnP => Hlt Heq; first by constructor.\napply/IHn=> [|Cda]; last first.\n  rewrite mulrDl addrAC -addrA subrK exprSr polyCM mulrA Heq //.\n  by rewrite mulrDl -mulrA Cda mulrA.\napply/leq_sizeP => j Hj; rewrite coefB coefMC -scalerAl coefZ coefXnM.\nrewrite ltn_subRL ltnNge (leq_trans Hr) /=; last first.\n  by apply: leq_ltn_trans Hj _; rewrite -add1n leq_add2r size_poly_gt0.\nmove: Hj; rewrite leq_eqVlt; case/predU1P => [<-{j} | Hj]; last first.\n  rewrite !nth_default ?simp ?oppr0 ?(leq_trans Hr) //.\n  by rewrite -{1}(subKn Hlt) leq_sub2r // (leq_trans Hr).\nmove: Hr; rewrite leq_eqVlt ltnS; case/predU1P=> Hqq; last first.\n  by rewrite !nth_default ?simp ?oppr0 // -{1}(subKn Hlt) leq_sub2r.\nrewrite /lead_coef Hqq polySpred // subSS subKn ?addrN //.\nby rewrite -subn1 leq_subLR add1n -Hqq.\nQed."
}
{
  "statement": "Lemma odd_lift_perm i j s : lift_perm i j s = odd i (+) odd j (+) s :> bool.\n",
  "proof": "Proof.\nrewrite -{1}(mul1g s) -(lift_permM _ j) odd_permM.\ncongr (_ (+) _); last first.\n  case: (prod_tpermP s) => ts ->{s} _.\n  elim: ts => [|t ts IHts] /=; first by rewrite big_nil lift_perm1 !odd_perm1.\n  rewrite big_cons odd_mul_tperm -(lift_permM _ j) odd_permM {}IHts //.\n  congr (_ (+) _); transitivity (tperm (lift j t.1) (lift j t.2)); last first.\n     by rewrite odd_tperm (inj_eq (pcan_inj (liftK j))).\n  congr odd_perm; apply/permP=> k; case: (unliftP j k) => [k'|] ->.\n    by rewrite lift_perm_lift inj_tperm //; apply: lift_inj.\n  by rewrite lift_perm_id tpermD // eq_sym neq_lift.\nsuff{i j s} odd_lift0 (k : 'I_n.+1): lift_perm ord0 k 1 = odd k :> bool.\n  rewrite -!odd_lift0 -{2}invg1 -lift_permV odd_permV -odd_permM.\n  by rewrite lift_permM mulg1.\nelim: {k}(k : nat) {1 3}k (erefl (k : nat)) => [|m IHm] k def_k.\n  by rewrite (_ : k = ord0) ?lift_perm1 ?odd_perm1 //; apply: val_inj.\nhave le_mn: m < n.+1 by [rewrite -def_k ltnW]; pose j := Ordinal le_mn.\nrewrite -(mulg1 1)%g -(lift_permM _ j) odd_permM {}IHm // addbC.\nrewrite (_ : _ 1 = tperm j k); first by rewrite odd_tperm neq_ltn/= def_k leqnn.\napply/permP=> i; case: (unliftP j i) => [i'|] ->; last first.\n  by rewrite lift_perm_id tpermL.\napply: ord_inj; rewrite lift_perm_lift !permE /= eq_sym -if_neg neq_lift.\nrewrite fun_if -val_eqE /= def_k /bump ltn_neqAle andbC.\ncase: leqP => [_ | lt_i'm] /=; last by rewrite -if_neg neq_ltn leqW.\nby rewrite add1n eqSS; case: eqVneq.\nQed."
}
{
  "statement": "Lemma expand_cofactor n (A : 'M[R]_n) i j :\n  cofactor A i j =\n    \\sum_(s : 'S_n | s i == j) (-1) ^+ s * \\prod_(k | i != k) A k (s k).\n",
  "proof": "Proof.\ncase: n A i j => [|n] A i0 j0; first by case: i0.\nrewrite (reindex (lift_perm i0 j0)); last first.\n  pose ulsf i (s : 'S_n.+1) k := odflt k (unlift (s i) (s (lift i k))).\n  have ulsfK i (s : 'S_n.+1) k: lift (s i) (ulsf i s k) = s (lift i k).\n    rewrite /ulsf; have:= neq_lift i k.\n    by rewrite -(can_eq (permK s)) => /unlift_some[] ? ? ->.\n  have inj_ulsf: injective (ulsf i0 _).\n    move=> s; apply: can_inj (ulsf (s i0) s^-1%g) _ => k'.\n    by rewrite {1}/ulsf ulsfK !permK liftK.\n  exists (fun s => perm (inj_ulsf s)) => [s _ | s].\n    by apply/permP=> k'; rewrite permE /ulsf lift_perm_lift lift_perm_id liftK.\n  move/(s _ =P _) => si0; apply/permP=> k.\n  case: (unliftP i0 k) => [k'|] ->; rewrite ?lift_perm_id //.\n  by rewrite lift_perm_lift -si0 permE ulsfK.\nrewrite /cofactor big_distrr /=.\napply: eq_big => [s | s _]; first by rewrite lift_perm_id eqxx.\nrewrite -signr_odd mulrA -signr_addb oddD -odd_lift_perm; congr (_ * _).\ncase: (pickP 'I_n) => [k0 _ | n0]; last first.\n  by rewrite !big1 // => [j /unlift_some[i] | i _]; have:= n0 i.\nrewrite (reindex (lift i0)).\n  by apply: eq_big => [k | k _] /=; rewrite ?neq_lift // !mxE lift_perm_lift.\nexists (fun k => odflt k0 (unlift i0 k)) => k; first by rewrite liftK.\nby case/unlift_some=> k' -> ->.\nQed."
}
{
  "statement": "Lemma num_field_exists (s : seq algC) :\n  {Qs : fieldExtType rat & {QsC : {rmorphism Qs -> algC}\n   & {s1 : seq Qs | map QsC s1 = s & <<1 & s1>>%VS = fullv}}}.\n",
  "proof": "Proof.\nhave [z /sig_eqW[a Dz] /sig_eqW[ps Ds]] := algC_PET s.\nsuffices [Qs [QsC [z1 z1C z1gen]]]:\n  {Qs : fieldExtType rat & {QsC : {rmorphism Qs -> algC} &\n     {z1 : Qs | QsC z1 = z & forall xx, exists p, fieldExt_horner z1 p = xx}}}.\n- set inQs := fieldExt_horner z1 in z1gen *; pose s1 := map inQs ps.\n  have inQsK p: QsC (inQs p) = (pQtoC p).[z].\n    rewrite /= -horner_map z1C -map_poly_comp; congr _.[z].\n    by apply: eq_map_poly => b /=; rewrite alg_num_field fmorph_rat.\n  exists Qs, QsC, s1; first by rewrite -map_comp Ds (eq_map inQsK).\n  have sz_ps: size ps = size s by rewrite Ds size_map.\n  apply/vspaceP=> x; rewrite memvf; have [p {x}<-] := z1gen x.\n  elim/poly_ind: p => [|p b ApQs]; first by rewrite /inQs rmorph0 mem0v.\n  rewrite /inQs rmorphD rmorphM /= fieldExt_hornerX fieldExt_hornerC -/inQs /=.\n  suffices ->: z1 = \\sum_(i < size s) s1`_i *+ a i.\n    rewrite memvD ?memvZ ?mem1v ?memvM ?memv_suml // => i _.\n    by rewrite rpredMn ?seqv_sub_adjoin ?mem_nth // size_map sz_ps.\n  apply: (fmorph_inj QsC); rewrite z1C Dz rmorph_sum; apply: eq_bigr => i _.\n  by rewrite rmorphMn {1}Ds !(nth_map 0) ?sz_ps //= inQsK.\nhave [r [Dr /monic_neq0 nz_r] dv_r] := minCpolyP z.\nhave rz0: root (pQtoC r) z by rewrite dv_r.\nhave irr_r: irreducible_poly r.\n  by apply/(subfx_irreducibleP rz0 nz_r)=> q qz0 nzq; rewrite dvdp_leq // -dv_r.\nexists (SubFieldExtType rz0 irr_r), (@subfx_inj _ _ QtoC z r).\nexists (subfx_root _ z r) => [|x]; first exact: subfx_inj_root.\nby have{x} [p ->] := subfxEroot rz0 nz_r x; exists p.\nQed."
}
{
  "statement": "Lemma max_submodP U V (modU : modG U) (modV : modG V) :\n  (U <= V)%MS -> (max_submod U V <-> mx_irreducible (section_repr modU modV)).\n",
  "proof": "Proof.\nmove=> sUV; split=> [[ltUV maxU] | ].\n  apply/mx_irrP; split=> [|WU modWU nzWU].\n    by rewrite genmxE lt0n mxrank_eq0 in_factmod_eq0; case/andP: ltUV.\n  rewrite -sub1mx -val_submodS val_submod1 genmxE.\n  pose W := (U + val_factmod (val_submod WU))%MS.\n  suffices sVW: (V <= W)%MS.\n    rewrite {2}in_factmodE (submx_trans (submxMr _ sVW)) //.\n    rewrite addsmxMr -!in_factmodE val_factmodK.\n    by rewrite ((in_factmod U U =P 0) _) ?adds0mx ?in_factmod_eq0.\n  move/and3P: {maxU}(maxU W); apply: contraR; rewrite /ltmx addsmxSl => -> /=.\n  move: modWU; rewrite /mxmodule rstabs_submod rstabs_factmod => -> /=.\n  rewrite addsmx_sub submx_refl -in_factmod_eq0 val_factmodK.\n  move: nzWU; rewrite -[_ == 0](inj_eq val_submod_inj) linear0 => ->.\n  rewrite -(in_factmodsK sUV) addsmxS // val_factmodS.\n  by rewrite -(genmxE (in_factmod U V)) val_submodP.\ncase/mx_irrP; rewrite lt0n {1}genmxE mxrank_eq0 in_factmod_eq0 => ltUV maxV.\nsplit=> // [|W [modW /andP[sUW ltUW] /andP[sWV /negP[]]]]; first exact/andP.\nrewrite -(in_factmodsK sUV) -(in_factmodsK sUW) addsmxS // val_factmodS.\nrewrite -genmxE -val_submod1; set VU := <<_>>%MS.\nhave sW_VU: (in_factmod U W <= VU)%MS.\n  by rewrite genmxE -val_factmodS !submxMr.\nrewrite -(in_submodK sW_VU) val_submodS -(genmxE (in_submod _ _)).\nrewrite sub1mx maxV //.\n  rewrite (eqmx_module _ (genmxE _)) in_submod_module ?genmxE ?submxMr //.\n  by rewrite in_factmod_module addsmx_module.\nrewrite -submx0 [(_ <= 0)%MS]genmxE -val_submodS linear0 in_submodK //.\nby rewrite eqmx0 submx0 in_factmod_eq0.\nQed."
}
{
  "statement": "Lemma cent1_extraspecial_maximal x :\n  x \\in G -> x \\notin 'Z(G) -> maximal 'C_G[x] G.\n",
  "proof": "Proof.\nmove=> Gx notZx; pose f y := [~ x, y]; have [[_ defG'] prZ] := esG.\nhave{defG'} fZ y: y \\in G -> f y \\in 'Z(G).\n  by move=> Gy; rewrite -defG' mem_commg.\nhave fM: {in G &, {morph f : y z / y * z}}%g.\n  move=> y z Gy Gz; rewrite {1}/f commgMJ conjgCV -conjgM (conjg_fixP _) //.\n  rewrite (sameP commgP cent1P); apply: subsetP (fZ y Gy).\n  by rewrite subIset // orbC -cent_set1 centS // sub1set !(groupM, groupV).\npose fm := Morphism fM.\nhave fmG: fm @* G = 'Z(G).\n  have sfmG: fm @* G \\subset 'Z(G).\n    by apply/subsetP=> _ /morphimP[z _ Gz ->]; apply: fZ.\n  apply/eqP; rewrite eqEsubset sfmG; apply: contraR notZx => /(prime_TIg prZ).\n  rewrite (setIidPr _) // => fmG1; rewrite inE Gx; apply/centP=> y Gy.\n  by apply/commgP; rewrite -in_set1 -[[set _]]fmG1; apply: mem_morphim.\nhave ->: 'C_G[x] = 'ker fm.\n  apply/setP=> z; rewrite inE (sameP cent1P commgP) !inE.\n  by rewrite -invg_comm eq_invg_mul mulg1.\nrewrite p_index_maximal ?subsetIl // -card_quotient ?ker_norm //.\nby rewrite (card_isog (first_isog fm)) /= fmG.\nQed."
}
{
  "statement": "Lemma mx_rsim_dadd  (U V W : 'M_n) (rU rV : representation)\n    (modU : mxmodule rG U) (modV : mxmodule rG V) (modW : mxmodule rG W) :\n    (U + V :=: W)%MS -> mxdirect (U + V) ->\n    mx_rsim (submod_repr modU) rU -> mx_rsim (submod_repr modV) rV ->\n  mx_rsim (submod_repr modW) (dadd_grepr rU rV).\n",
  "proof": "Proof.\ncase: rU; case: rV=> nV rV nU rU defW dxUV /=.\nhave tiUV := mxdirect_addsP dxUV.\nmove=> [fU def_nU]; rewrite -{nU}def_nU in rU fU * => inv_fU hom_fU.\nmove=> [fV def_nV]; rewrite -{nV}def_nV in rV fV * => inv_fV hom_fV.\npose pU := in_submod U (proj_mx U V) *m fU.\npose pV := in_submod V (proj_mx V U) *m fV.\nexists (val_submod 1%:M *m row_mx pU pV) => [||g Gg].\n- by rewrite -defW (mxdirectP dxUV).\n- apply/row_freeP.\n  pose pU' := invmx fU *m val_submod 1%:M.\n  pose pV' := invmx fV *m val_submod 1%:M.\n  exists (in_submod _ (col_mx pU' pV')).\n  rewrite in_submodE mulmxA -in_submodE -mulmxA mul_row_col mulmxDr.\n  rewrite -[pU *m _]mulmxA -[pV *m _]mulmxA !mulKVmx -?row_free_unit //.\n  rewrite addrC (in_submodE V) 2![val_submod 1%:M *m _]mulmxA -in_submodE.\n  rewrite addrC (in_submodE U) 2![val_submod 1%:M *m _ in X in X + _]mulmxA.\n  rewrite -in_submodE -!val_submodE !in_submodK ?proj_mx_sub //.\n  by rewrite add_proj_mx ?val_submodK // val_submod1 defW.\nrewrite mulmxA -val_submodE -[submod_repr _ g]mul1mx val_submodJ //.\nrewrite -(mulmxA _ (rG g)) mul_mx_row -[in RHS]mulmxA mul_row_block.\nrewrite !mulmx0 addr0 add0r !mul_mx_row.\nset W' := val_submod 1%:M; congr (row_mx _ _).\n  rewrite 3!mulmxA in_submodE mulmxA.\n  have hom_pU: (W' <= dom_hom_mx rG (proj_mx U V))%MS.\n    by rewrite val_submod1 -defW proj_mx_hom.\n  rewrite (hom_mxP hom_pU) // -in_submodE (in_submodJ modU) ?proj_mx_sub //.\n  rewrite -(mulmxA _ _ fU) hom_fU // in_submodE -2!(mulmxA W') -in_submodE.\n  by rewrite -mulmxA (mulmxA _ fU).\nrewrite 3!mulmxA in_submodE mulmxA.\nhave hom_pV: (W' <= dom_hom_mx rG (proj_mx V U))%MS.\n  by rewrite val_submod1 -defW addsmxC proj_mx_hom // capmxC.\nrewrite (hom_mxP hom_pV) // -in_submodE (in_submodJ modV) ?proj_mx_sub //.\nrewrite -(mulmxA _ _ fV) hom_fV // in_submodE -2!(mulmxA W') -in_submodE.\nby rewrite -mulmxA (mulmxA _ fV).\nQed."
}
{
  "statement": "Lemma to_rform_rformula f : rformula (to_rform f).\n",
  "proof": "Proof.\nsuffices eq0_ring t1: rformula (eq0_rform t1) by elim: f => //= => f1 ->.\nrewrite /eq0_rform; move: (ub_var t1) => m; set tr := _ m.\nsuffices: all rterm (tr.1 :: tr.2).\n  case: tr => {}t1 r /= /andP[t1_r].\n  by elim: r m => [|t r IHr] m; rewrite /= ?andbT // => /andP[->]; apply: IHr.\nhave: all rterm [::] by [].\nrewrite {}/tr; elim: t1 [::] => //=.\n- move=> t1 IHt1 t2 IHt2 r.\n  move/IHt1; case: to_rterm => {r IHt1}t1 r /= /andP[t1_r].\n  move/IHt2; case: to_rterm => {r IHt2}t2 r /= /andP[t2_r].\n  by rewrite t1_r t2_r.\n- by move=> t1 IHt1 r /IHt1; case: to_rterm.\n- by move=> t1 IHt1 n r /IHt1; case: to_rterm.\n- move=> t1 IHt1 t2 IHt2 r.\n  move/IHt1; case: to_rterm => {r IHt1}t1 r /= /andP[t1_r].\n  move/IHt2; case: to_rterm => {r IHt2}t2 r /= /andP[t2_r].\n  by rewrite t1_r t2_r.\n- move=> t1 IHt1 r.\n  by move/IHt1; case: to_rterm => {r IHt1}t1 r /=; rewrite all_rcons.\n- by move=> t1 IHt1 n r /IHt1; case: to_rterm.\nQed."
}
{
  "statement": "Lemma common_eigenvector {C : numClosedFieldType} n (As : seq 'M[C]_n) :\n  (n > 0)%N -> {in As &, forall A B, comm_mx A B} ->\n  exists2 v : 'rV_n, v != 0 & all (fun A => stablemx v A) As.\n",
  "proof": "Proof.\nmove=> n_gt0 /all_comm_mxP; have [k sAsk] := ubnP (size As).\nelim: k n n_gt0 As sAsk => [//|k IHk]  n n_gt0 [|A As].\n  exists (const_mx 1) => //; apply/negP => /eqP/rowP/(_ (Ordinal n_gt0)).\n  by rewrite !mxE => /eqP; rewrite oner_eq0.\nrewrite ltnS all_comm_mx_cons => sAsk /andP[].\nmove=> /allP/(_ _ _)/eqP/= A_comm /all_comm_mxP As_comm.\nhave [a a_eigen] := eigenvalue_closed A n_gt0.\nhave [] := IHk _ _ [seq restrictmx (eigenspace A a) B | B <- As].\n- by rewrite lt0n mxrank_eq0.\n- by rewrite size_map.\n- apply/all_comm_mxP; move=> _ _ /= /mapP /= [B B_in ->] /mapP /= [B' B'_in ->].\n  rewrite -?conjmxM ?inE ?stablemx_row_base ?comm_mx_stable_eigenspace//;\n  by [rewrite As_comm | apply: As_comm | apply: A_comm].\nmove=> v vN0 /allP /= vP; exists (v *m (row_base (eigenspace A a))).\n  by rewrite mulmx_free_eq0 ?row_base_free.\napply/andP; split.\n  by apply/eigenvectorP; exists a; rewrite mulmx_sub // eq_row_base.\napply/allP => B B_in; rewrite -stablemx_restrict ?vP //.\n  by apply/mapP; exists B.\nby rewrite comm_mx_stable_eigenspace //; exact: A_comm.\nQed."
}
{
  "statement": "Lemma gring_classM_coef_sum_eq gT (G : {group gT}) j1 j2 k g1 g2 g :\n   let a := @gring_classM_coef gT G j1 j2 in let a_k := a k in\n   g1 \\in enum_val j1 -> g2 \\in enum_val j2 -> g \\in enum_val k ->\n   let sum12g := \\sum_i 'chi[G]_i g1 * 'chi_i g2 * ('chi_i g)^* / 'chi_i 1%g in\n  a_k%:R = (#|enum_val j1| * #|enum_val j2|)%:R / #|G|%:R * sum12g.\n",
  "proof": "Proof.\nmove=> a /= Kg1 Kg2 Kg; rewrite mulrAC; apply: canRL (mulfK (neq0CG G)) _.\ntransitivity (\\sum_j (#|G| * a j)%:R *+ (j == k) : algC).\n  by rewrite (bigD1 k) //= eqxx -natrM mulnC big1 ?addr0 // => j /negPf->.\nhave defK (j : 'I_#|classes G|) x: x \\in enum_val j -> enum_val j = x ^: G.\n  by have /imsetP[y Gy ->] := enum_valP j => /class_eqP.\nhave Gg: g \\in G.\n  by case/imsetP: (enum_valP k) Kg => x Gx -> /imsetP[y Gy ->]; apply: groupJ.\ntransitivity (\\sum_j \\sum_i 'omega_i['K_j] * 'chi_i 1%g * ('chi_i g)^* *+ a j).\n  apply: eq_bigr => j _; have /imsetP[z Gz Dj] := enum_valP j.\n  have Kz: z \\in enum_val j by rewrite Dj class_refl.\n  rewrite -(Lagrange (subsetIl G 'C[z])) index_cent1 -mulnA natrM -mulrnAl.\n  have ->: (j == k) = (z \\in enum_val k).\n    by rewrite -(inj_eq enum_val_inj); apply/eqP/idP=> [<-|/defK->].\n  rewrite (defK _ g) // -second_orthogonality_relation // mulr_suml.\n  apply: eq_bigr=> i _; rewrite natrM mulrA mulr_natr mulrC mulrA.\n  by rewrite (gring_mode_class_sum_eq i Kz) divfK ?irr1_neq0.\nrewrite exchange_big /= mulr_sumr; apply: eq_bigr => i _.\ntransitivity ('omega_i['K_j1 *m 'K_j2] * 'chi_i 1%g * ('chi_i g)^*).\n  rewrite gring_classM_expansion -/a raddf_sum !mulr_suml /=.\n  by apply: eq_bigr => j _; rewrite xcfunZr -!mulrA mulr_natl.\nrewrite !mulrA 2![_ / _]mulrAC (defK _ _ Kg1) (defK _ _ Kg2); congr (_ * _).\nrewrite gring_irr_modeM ?gring_class_sum_central // mulnC natrM.\nrewrite (gring_mode_class_sum_eq i Kg2) !mulrA divfK ?irr1_neq0 //.\nby congr (_ * _); rewrite [_ * _]mulrC (gring_mode_class_sum_eq i Kg1) !mulrA.\nQed."
}
{
  "statement": "Lemma codiagonalizable_on m n (V_ : 'I_n -> 'M[F]_m) (As : seq 'M[F]_m) :\n  (\\sum_i V_ i :=: 1%:M)%MS -> mxdirect (\\sum_i V_ i) ->\n  (forall i, all (fun A => stablemx (V_ i) A) As) ->\n  (forall i, codiagonalizable (map (restrictmx (V_ i)) As)) -> codiagonalizable As.\n",
  "proof": "Proof.\nmove=> V1 Vdirect /(_ _)/allP AV /(_ _) /sig2W/= Pof.\npose P_ i := tag (Pof i).\nhave P_unit i : P_ i \\in unitmx by rewrite /P_; case: {+}Pof.\nhave P_diag i A : A \\in As -> similar_diag (P_ i *m row_base (V_ i)) A.\n  move=> AAs; rewrite /P_; case: {+}Pof => /= P Punit.\n  rewrite all_map => /allP/(_ A AAs); rewrite /similar_to/=.\n  by rewrite conjuMmx ?row_base_free ?stablemx_row_base ?AV.\npose P := \\mxcol_i (P_ i *m row_base (V_ i)).\nhave P_full i : row_full (P_ i) by rewrite row_full_unit.\nhave PrV i : (P_ i *m row_base (V_ i) :=: V_ i)%MS.\n  exact/(eqmx_trans _ (eq_row_base _))/eqmxMfull.\napply/codiagonalizablePfull; eexists _; last exists P; rewrite /=.\n- rewrite -sub1mx eqmx_col.\n  by under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\napply/allP => A AAs /=; rewrite similar_diag_sum.\n- by apply/forallP => i; apply: P_diag.\n- rewrite mxdirectE/=.\n  under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\n  by under eq_bigr do rewrite genmxE PrV; rewrite  -(mxdirectP Vdirect)//= V1.\n- by move=> i; rewrite (eqmx_stable _ (PrV _)) ?AV.\n- by move=> i; rewrite /row_free eqmxMfull ?eq_row_base ?row_full_unit.\nQed."
}
{
  "statement": "Lemma codiagonalizable_on m n (V_ : 'I_n -> 'M[F]_m) (As : seq 'M[F]_m) :\n    (\\sum_i V_ i :=: 1%:M)%MS -> mxdirect (\\sum_i V_ i) ->\n    (forall i, all (fun A => stablemx (V_ i) A) As) ->\n    (forall i, codiagonalizable (map (restrictmx (V_ i)) As)) ->\n  codiagonalizable As.\n",
  "proof": "Proof.\nmove=> V1 Vdirect /(_ _)/allP AV /(_ _) /sig2W/= Pof.\npose P_ i := tag (Pof i).\nhave P_unit i : P_ i \\in unitmx by rewrite /P_; case: {+}Pof.\nhave P_diag i A : A \\in As -> diagonalizable_for (P_ i *m row_base (V_ i)) A.\n  move=> AAs; rewrite /P_; case: {+}Pof => /= P Punit.\n  rewrite all_map => /allP/(_ A AAs); rewrite /= !/(diagonalizable_for _ _).\n  by rewrite conjuMmx ?row_base_free ?stablemx_row_base ?AV.\npose P := \\mxcol_i (P_ i *m row_base (V_ i)).\nhave P_full i : row_full (P_ i) by rewrite row_full_unit.\nhave PrV i : (P_ i *m row_base (V_ i) :=: V_ i)%MS.\n  exact/(eqmx_trans _ (eq_row_base _))/eqmxMfull.\napply/codiagonalizablePfull; eexists _; last exists P; rewrite /=.\n- rewrite -sub1mx eqmx_col.\n  by under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\napply/allP => A AAs /=; rewrite diagonalizable_for_sum.\n- by apply/forallP => i; apply: P_diag.\n- rewrite mxdirectE/=.\n  under eq_bigr do rewrite (eq_genmx (PrV _)); rewrite -genmx_sums genmxE V1.\n  by under eq_bigr do rewrite genmxE PrV; rewrite  -(mxdirectP Vdirect)//= V1.\n- by move=> i; rewrite (eqmx_stable _ (PrV _)) ?AV.\n- by move=> i; rewrite /row_free eqmxMfull ?eq_row_base ?row_full_unit.\nQed."
}
{
  "statement": "Theorem mx_Schreier U :\n    mx_subseries U -> path ltmx 0 U ->\n  classically (exists V, [/\\ mx_series V, last 0 V :=: 1%:M & subseq U V])%MS.\n",
  "proof": "Proof.\nmove: U => U0; set U := {1 2}U0; have: subseq U0 U := subseq_refl U.\npose n' := n.+1; have: n < size U + n' by rewrite leq_addl.\nelim: n' U => [|n' IH_U] U ltUn' sU0U modU incU [] // noV.\n  rewrite addn0 ltnNge in ltUn'; case/negP: ltUn'.\n  by rewrite (leq_trans (max_size_mx_series incU)) ?rank_leq_row.\napply: (noV); exists U; split => //; first split=> // i lt_iU; last first.\n  apply/eqmxP; apply: contraT => neU1.\n  apply: {IH_U}(IH_U (rcons U 1%:M)) noV.\n  - by rewrite size_rcons addSnnS.\n  - by rewrite (subseq_trans sU0U) ?subseq_rcons.\n  - by rewrite /mx_subseries all_rcons mxmodule1.\n  by rewrite rcons_path ltmxEneq neU1 submx1 !andbT.\nset U'i := _`_i; set Ui := _`_i; have defU := cat_take_drop i U.\nhave defU'i: U'i = last 0 (take i U).\n  rewrite (last_nth 0) /U'i -{1}defU -cat_cons nth_cat /=.\n  by rewrite size_take lt_iU leqnn.\nmove: incU; rewrite -defU cat_path (drop_nth 0) //= -/Ui -defU'i.\nset U' := take i U; set U'' := drop _ U; case/and3P=> incU' ltUi incU''.\nsplit=> // W [modW ltUW ltWV]; case: notF.\napply: {IH_U}(IH_U (U' ++ W :: Ui :: U'')) noV; last 2 first.\n- by rewrite /mx_subseries -drop_nth // all_cat /= modW -all_cat defU.\n- by rewrite cat_path /= -defU'i; apply/and4P.\n- by rewrite -drop_nth // size_cat /= addnS -size_cat defU addSnnS.\nby rewrite (subseq_trans sU0U) // -defU cat_subseq // -drop_nth ?subseq_cons.\nQed."
}
{
  "statement": "Lemma mx_second_rsim U V (modU : modG U) (modV : modG V) :\n  let modI := capmx_module modU modV in let modA := addsmx_module modU modV in\n  mx_rsim (section_repr modI modU) (section_repr modV modA).\n",
  "proof": "Proof.\nmove=> modI modA; set nI := {1}(\\rank _).\nhave sIU := capmxSl U V; have sVA := addsmxSr U V.\npose valI := val_factmod (val_submod (1%:M : 'M_nI)).\nhave UvalI: (valI <= U)%MS.\n  rewrite -(addsmx_idPr sIU) (submx_trans _ (proj_factmodS _ _)) //.\n  by rewrite submxMr // val_submod1 genmxE.\nexists (valI *m in_factmod _ 1%:M *m in_submod _ 1%:M) => [||x Gx].\n- apply: (@addIn (\\rank (U :&: V) + \\rank V)%N); rewrite genmxE addnA addnCA.\n  rewrite /nI genmxE !{1}mxrank_in_factmod 2?(addsmx_idPr _) //.\n  by rewrite -mxrank_sum_cap addnC.\n- rewrite -kermx_eq0; apply/rowV0P=> u; rewrite (sameP sub_kermxP eqP).\n  rewrite mulmxA -in_submodE mulmxA -in_factmodE -(inj_eq val_submod_inj).\n  rewrite linear0 in_submodK ?in_factmod_eq0 => [Vvu|]; last first.\n    by rewrite genmxE addsmxC in_factmod_addsK submxMr // mulmx_sub.\n  apply: val_submod_inj; apply/eqP; rewrite linear0 -[val_submod u]val_factmodK.\n  rewrite val_submodE val_factmodE -mulmxA -val_factmodE -/valI.\n  by rewrite in_factmod_eq0 sub_capmx mulmx_sub.\nsymmetry; rewrite -{1}in_submodE -{1}in_submodJ; last first.\n   by rewrite genmxE addsmxC in_factmod_addsK -in_factmodE submxMr.\nrewrite -{1}in_factmodE -{1}in_factmodJ // mulmxA in_submodE; congr (_ *m _).\napply/eqP; rewrite mulmxA -in_factmodE -subr_eq0 -linearB in_factmod_eq0.\napply: submx_trans (capmxSr U V); rewrite -in_factmod_eq0 linearB /=.\nrewrite subr_eq0 {1}(in_factmodJ modI) // val_factmodK eq_sym.\nrewrite /valI val_factmodE mulmxA -val_factmodE val_factmodK.\nby rewrite -[submod_mx _ _]mul1mx -val_submodE val_submodJ.\nQed."
}
{
  "statement": "Lemma grank_abelian G : abelian G -> 'm(G) = 'r(G).\n",
  "proof": "Proof.\nmove=> cGG; apply/eqP; rewrite eqn_leq; apply/andP; split.\n  rewrite -size_abelian_type //; case/abelian_structure: cGG => b defG <-.\n  suffices <-: <<[set x in b]>> = G.\n    by rewrite (leq_trans (grank_min _)) // size_map cardsE card_size.\n  rewrite -{G defG}(bigdprodWY defG).\n  elim: b => [|x b IHb]; first by rewrite big_nil gen0.\n  by rewrite big_cons -joingE -joing_idr -IHb joing_idl joing_idr set_cons.\nhave [p p_pr ->] := rank_witness G; pose K := 'Mho^1(G).\nhave ->: 'r_p(G) = logn p #|G / K|.\n  rewrite p_rank_abelian // card_quotient /= ?gFnorm // -divgS ?Mho_sub //.\n  by rewrite -(mul_card_Ohm_Mho_abelian 1 cGG) mulnK ?cardG_gt0.\ncase: (grank_witness G) => B genB <-; rewrite -genB.\nhave{genB}: <<B>> \\subset G by rewrite genB.\nhave [m] := ubnP #|B|; elim: m B => // m IHm B.\nhave [-> | [x Bx]] := set_0Vmem B; first by rewrite gen0 quotient1 cards1 logn1.\nrewrite ltnS (cardsD1 x) Bx -[in <<B>>](setD1K Bx); set B' := B :\\ x => ltB'm.\nrewrite -joingE -joing_idl -joing_idr -/<[x]> join_subG => /andP[Gx sB'G].\nrewrite cent_joinEl ?(sub_abelian_cent2 cGG) //.\nhave nKx: x \\in 'N(K) by rewrite -cycle_subG (subset_trans Gx) ?gFnorm.\nrewrite quotientMl ?cycle_subG // quotient_cycle //= -/K.\nhave le_Kxp_1: logn p #[coset K x] <= 1.\n  rewrite -(dvdn_Pexp2l _ _ (prime_gt1 p_pr)) -p_part -order_constt.\n  rewrite order_dvdn -morph_constt // -morphX ?groupX //= coset_id //.\n  by rewrite Mho_p_elt ?p_elt_constt ?groupX -?cycle_subG.\napply: leq_trans (leq_add le_Kxp_1 (IHm _ ltB'm sB'G)).\nby rewrite -lognM ?dvdn_leq_log ?muln_gt0 ?cardG_gt0 // mul_cardG dvdn_mulr.\nQed."
}
{
  "statement": "Lemma mxrow_recl n (B_ : forall j, 'M[T]_(n, p_ j)) :\n  \\mxrow_j B_ j = castmx (erefl, mxsize_recl)\n    (row_mx (B_ 0) (\\mxrow_j B_ (lift ord0 j))).\n",
  "proof": "Proof.\napply/mxrowP => i; rewrite mxrowK.\napply/matrixP => j k; rewrite !(castmxE, mxE)/=.\ncase: splitP => l /=; do [\n    rewrite [LHS]RankEsum big_mkcond big_ord_recl -big_mkcond/=;\n    rewrite /bump/= -addnA cast_ord_id;\n    under eq_bigl do rewrite add1n -ltn_predRL/=].\n  case: posnP => i0; last first.\n    by move=> lE; have := ltn_ord l; rewrite /= -lE -ltn_subRL subnn.\n  by rewrite (@val_inj _ _ _ i 0 i0) big_pred0_eq in k * => /val_inj->.\ncase: posnP => i0.\n  rewrite (@val_inj _ _ _ i 0 i0) big_pred0_eq in k l * => kE.\n  by have := ltn_ord k; rewrite /= [val k]kE -ltn_subRL subnn.\nhave i_lt : i.-1 < m by rewrite -subn1 ltn_subLR.\nset i' := lift ord0 (Ordinal i_lt).\nhave ii' : i = i' by apply/val_inj; rewrite /=/bump/= add1n prednK.\nhave k_lt : k < p_ i' by rewrite -ii'.\nmove=> /addnI; rewrite eqRank => /val_inj/= /[dup] kl<-; rewrite mxE.\nrewrite Rank2K//; case: _ / esym; rewrite cast_ord_id/=.\nrewrite -/i'; set j' := Ordinal _; have : k = j' :> nat by [].\nby move: j'; rewrite -ii' => j' /val_inj->.\nQed."
}
{
  "statement": "Lemma ker_irr_comp_op_pchar : ('R_iG :&: kermx (lin_mx (gring_op rG)))%MS = 0.\n",
  "proof": "Proof.\napply/eqP; rewrite -submx0; apply/memmx_subP=> A.\nrewrite sub_capmx /= submx0 mxvec_eq0 => /andP[R_A].\nrewrite (sameP sub_kermxP eqP) mul_vec_lin mxvec_eq0 /= => opA0.\nhave [_ Re ideR _] := Wedderburn_is_id_pchar iG; rewrite -[A]ideR {ideR}//.\nmove: Re; rewrite genmxE mem_sub_gring /socle_val => /andP[Re].\nrewrite -{2}(gring_rowK Re) -submx0.\npose simMi := socle_simple iG; have [J [M isoM ->]] := component_mx_def simMi.\ncase/sub_sumsmxP=> e ->; rewrite linear_sum mulmx_suml summx_sub // => j _.\nrewrite -(in_submodK (submxMl _ (M j))); move: (in_submod _ _) => v.\nhave modMj: mxmodule aG (M j) by apply: mx_iso_module (isoM j) _; case: simMi.\nhave rsimMj: mx_rsim rG (submod_repr modMj).\n  by apply: mx_rsim_trans rsim_irr_comp_pchar _; apply/mx_rsim_iso.\nhave [f [f' _ hom_f]] := mx_rsim_def (mx_rsim_sym rsimMj); rewrite submx0.\nhave <-: (gring_mx aG (val_submod (v *m (f *m gring_op rG A *m f')))) = 0.\n  by rewrite (eqP opA0) !(mul0mx, linear0).\nhave: (A \\in R_G)%MS by rewrite -Wedderburn_sum_pchar (sumsmx_sup iG).\ncase/envelop_mxP=> a ->; rewrite !(linear_sum, mulmx_suml) /=; apply/eqP.\napply: eq_bigr=> x Gx; rewrite 3!linearZ -scalemxAl 3!linearZ /=.\nby rewrite gring_opG // -hom_f // val_submodJ // gring_mxJ.\nQed."
}
{
  "statement": "Lemma card_afix_irr_classes (ito : action A (Iirr G)) (cto : action A _) a :\n    a \\in A -> [acts A, on classes G | cto] ->\n    (forall i x y, x \\in G -> y \\in cto (x ^: G) a ->\n      'chi_i x = 'chi_(ito i a) y) ->\n  #|'Fix_ito[a]| = #|'Fix_(classes G | cto)[a]|.\n",
  "proof": "Proof.\nmove=> Aa actsAG stabAchi; apply/eqP; rewrite -eqC_nat; apply/eqP.\nhave [[cP cK] iCK] := (irr_classP, irr_classK, class_IirrK).\npose icto b i := iC (cto (c i) b).\nhave Gca i: cto (c i) a \\in classes G by rewrite (acts_act actsAG).\nhave inj_qa: injective (icto a).\n  by apply: can_inj (icto a^-1%g) _ => i; rewrite /icto iCK ?actKin ?cK.\npose Pa : 'M[algC]_(Nirr G) := perm_mx (actperm ito a).\npose qa := perm inj_qa; pose Qa : 'M[algC]_(Nirr G) := perm_mx qa^-1^-1%g.\ntransitivity (\\tr Pa).\n  rewrite -sumr_const big_mkcond; apply: eq_bigr => i _.\n  by rewrite !mxE permE inE sub1set inE; case: ifP.\nsymmetry; transitivity (\\tr Qa).\n  rewrite cardsE -sumr_const -big_filter_cond big_mkcond big_filter /=.\n  rewrite reindex_irr_class; apply: eq_bigr => i _; rewrite !mxE invgK permE.\n  by rewrite inE sub1set inE -(can_eq cK) iCK //; case: ifP.\nrewrite -[Pa](mulmxK uX) -[Qa](mulKmx uX) mxtrace_mulC; congr (\\tr(_ *m _)).\nrewrite -row_permE -col_permE; apply/matrixP=> i j; rewrite !mxE.\nrewrite -{2}[j](permKV qa); move: {j}(_ j) => j; rewrite !permE iCK //.\napply: stabAchi; first by case/repr_classesP: (cP j).\nby rewrite repr_irr_classK (mem_repr_classes (Gca _)).\nQed."
}
{
  "statement": "Lemma redivp_eq q r :\n    size r < size d ->\n    let k := (redivp (q * d + r) d).1.1 in\n    let c := (lead_coef d ^+ k)%:P in\n  redivp (q * d + r) d = (k, q * c, r * c).\n",
  "proof": "Proof.\nmove=> lt_rd; case: comm_redivpP=> k q1 r1 /(_ Cdl) Heq.\nhave dn0: d != 0 by case: (size d) lt_rd (size_poly_eq0 d) => // n _ <-.\nmove=> /(_ dn0) Hs.\nhave eC : q * d * (lead_coef d ^+ k)%:P = q * (lead_coef d ^+ k)%:P * d.\n  by rewrite -mulrA polyC_exp (commrX k Cdl) mulrA.\nsuff e1 : q1 = q * (lead_coef d ^+ k)%:P.\n  congr (_, _, _) => //=; move/eqP: Heq.\n  by rewrite [_ + r1]addrC -subr_eq e1 mulrDl addrAC eC subrr add0r; move/eqP.\nhave : (q1 - q * (lead_coef d ^+ k)%:P) * d = r * (lead_coef d ^+ k)%:P - r1.\n  apply: (@addIr _ r1); rewrite subrK.\n  apply: (@addrI _ ((q * (lead_coef d ^+ k)%:P) * d)).\n  by rewrite mulrDl mulNr !addrA [_ + (q1 * d)]addrC addrK -eC -mulrDl.\nmove/eqP; rewrite -[_ == _ - _]subr_eq0 rreg_div0 //.\n  by case/andP; rewrite subr_eq0; move/eqP.\nrewrite size_polyN; apply: (leq_ltn_trans (size_polyD _ _)); rewrite size_polyN.\nrewrite gtn_max Hs (leq_ltn_trans (size_polyMleq _ _)) //.\nrewrite size_polyC; case: (_ == _); last by rewrite addnS addn0.\nby rewrite addn0; apply: leq_ltn_trans lt_rd; case: size.\nQed."
}
{
  "statement": "Lemma separable_polyP {p} :\n  reflect [/\\ forall u v, u * v %| p -> coprimep u v\n            & forall u, u %| p -> 1 < size u -> u^`() != 0]\n          (separable p).\n",
  "proof": "Proof.\napply: (iffP idP) => [sep_p | [sq'p nz_der1p]].\n  split=> [u v | u u_dv_p]; last first.\n    apply: contraTneq => u'0; rewrite unlock in sep_p; rewrite -leqNgt -(eqnP sep_p).\n    rewrite dvdp_leq -?size_poly_eq0 ?(eqnP sep_p) // dvdp_gcd u_dv_p.\n    have /dvdpZr <-: lead_coef u ^+ scalp p u != 0 by rewrite lcn_neq0.\n    by rewrite -derivZ -Pdiv.Idomain.divpK //= derivM u'0 mulr0 addr0 dvdp_mull.\n  rewrite Pdiv.Idomain.dvdp_eq mulrCA mulrA; set c := _ ^+ _ => /eqP Dcp.\n  have nz_c: c != 0 by rewrite lcn_neq0.\n  move: sep_p; rewrite coprimep_sym unlock -(coprimepZl _ _ nz_c).\n  rewrite -(coprimepZr _ _ nz_c) -derivZ Dcp derivM coprimepMl.\n  by rewrite coprimep_addl_mul !coprimepMr -andbA => /and4P[].\nrewrite unlock coprimep_def eqn_leq size_poly_gt0; set g := gcdp _ _.\nhave nz_g: g != 0.\n  rewrite -dvd0p dvdp_gcd -(mulr0 0); apply/nandP; left.\n  by have /poly_square_freeP-> := sq'p; rewrite ?size_poly0.\nhave [g_p]: g %| p /\\ g %| p^`() by rewrite dvdp_gcdr ?dvdp_gcdl.\npose c := lead_coef g ^+ scalp p g; have nz_c: c != 0 by rewrite lcn_neq0.\nhave Dcp: c *: p = p %/ g * g by rewrite Pdiv.Idomain.divpK.\nrewrite nz_g andbT leqNgt -(dvdpZr _ _ nz_c) -derivZ Dcp derivM.\nrewrite dvdp_addr; last by rewrite dvdp_mull.\nrewrite Gauss_dvdpr; last by rewrite sq'p // mulrC -Dcp dvdpZl.\nby apply: contraL => /nz_der1p nz_g'; rewrite gtNdvdp ?nz_g' ?lt_size_deriv.\nQed."
}
{
  "statement": "Lemma prod_cyclotomic :\n  'X^n - 1 = \\prod_(d <- divisors n) cyclotomic (z ^+ (n %/ d)) d.\n",
  "proof": "Proof.\nhave in_d d: (d %| n)%N -> val (@inord n d) = d by move/dvdn_leq/inordK=> /= ->.\nhave dv_n k: (n %/ gcdn k n %| n)%N.\n  by rewrite -{3}(divnK (dvdn_gcdr k n)) dvdn_mulr.\nhave [uDn _ inDn] := divisors_correct n_gt0.\nhave defDn: divisors n = map val (map (@inord n) (divisors n)).\n  by rewrite -map_comp map_id_in // => d; rewrite inDn => /in_d.\nrewrite defDn big_map big_uniq /=; last first.\n  by rewrite -(map_inj_uniq val_inj) -defDn.\npose h (k : 'I_n) : 'I_n.+1 := inord (n %/ gcdn k n).\nrewrite -(factor_Xn_sub_1 prim_z) big_mkord.\nrewrite (partition_big h (dvdn^~ n)) /= => [|k _]; last by rewrite in_d ?dv_n.\napply: eq_big => d; first by rewrite -(mem_map val_inj) -defDn inDn.\nset q := (n %/ d)%N => d_dv_n.\nhave [q_gt0 d_gt0]: (0 < q /\\ 0 < d)%N by apply/andP; rewrite -muln_gt0 divnK.\nhave fP (k : 'I_d): (q * k < n)%N by rewrite divn_mulAC ?ltn_divLR ?ltn_pmul2l.\nrewrite (reindex (fun k => Ordinal (fP k))); last first.\n  have f'P (k : 'I_n): (k %/ q < d)%N by rewrite ltn_divLR // mulnC divnK.\n  exists (fun k => Ordinal (f'P k)) => [k _ | k /eqnP/=].\n    by apply: val_inj; rewrite /= mulKn.\n  rewrite in_d // => Dd; apply: val_inj; rewrite /= mulnC divnK // /q -Dd.\n  by rewrite divnA ?mulKn ?dvdn_gcdl ?dvdn_gcdr.\napply: eq_big => k; rewrite ?exprM // -val_eqE in_d //=.\nrewrite -eqn_mul ?dvdn_gcdr ?gcdn_gt0 ?n_gt0 ?orbT //.\nrewrite -[n in gcdn _ n](divnK d_dv_n) -muln_gcdr mulnCA mulnA divnK //.\nby rewrite mulnC eqn_mul // divnn n_gt0 eq_sym.\nQed."
}
{
  "statement": "Lemma sol_coprime_Sylow_subset A G X :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> solvable A ->\n  X \\subset G -> p.-group X -> A \\subset 'N(X) ->\n  exists P : {group gT}, [/\\ p.-Sylow(G) P, A \\subset 'N(P) & X \\subset P].\n",
  "proof": "Proof.\nmove=> nGA coGA solA sXG pX nXA.\npose nAp (Q : {group gT}) := [&& p.-group Q, Q \\subset G & A \\subset 'N(Q)].\nhave: nAp X by apply/and3P.\ncase/maxgroup_exists=> R; case/maxgroupP; case/and3P=> pR sRG nRA maxR sXR.\nhave [P sylP sRP]:= Sylow_superset sRG pR.\nsuffices defP: P :=: R by exists P; rewrite sylP defP.\ncase/and3P: sylP => sPG pP _; apply: (nilpotent_sub_norm (pgroup_nil pP)) => //.\npose N := 'N_G(R); have{sPG} sPN_N: 'N_P(R) \\subset N by apply: setSI.\napply: norm_sub_max_pgroup (pgroupS (subsetIl _ _) pP) sPN_N (subsetIr _ _).\nhave nNA: A \\subset 'N(N) by rewrite normsI ?norms_norm.\nhave coNA: coprime #|N| #|A| by apply: coprimeSg coGA; rewrite subsetIl.\nhave{solA coNA} [Q sylQ nQA] := sol_coprime_Sylow_exists solA nNA coNA.\nsuffices defQ: Q :=: R by rewrite max_pgroup_Sylow -{2}defQ.\napply: maxR; first by apply/and3P; case/and3P: sylQ; rewrite subsetI; case/andP.\nby apply: normal_sub_max_pgroup (Hall_max sylQ) pR _; rewrite normal_subnorm.\nQed."
}
{
  "statement": "Lemma prime_Ohm1P gT p (G : {group gT}) :\n    p.-group G -> G :!=: 1 ->\n  reflect (#|'Ohm_1(G)| = p)\n          (cyclic G || (p == 2) && (extremal_class G == Quaternion)).\n",
  "proof": "Proof.\nmove=> pG ntG; have [p_pr p_dvd_G _] := pgroup_pdiv pG ntG.\napply: (iffP idP) => [|oG1p].\n  case/orP=> [cycG|]; first exact: Ohm1_cyclic_pgroup_prime.\n  case/andP=> /eqP p2 /eqP/quaternion_classP[n n_gt2 isoG].\n  rewrite p2; have [[x y]] := generators_quaternion n_gt2 isoG.\n  by case/quaternion_structure=> // _ _ [<- oZ _ [->]].\nhave [X nsXG cXX|-> //|]:= normal_rank1_structure pG.\n  have [sXG _] := andP nsXG; have pX := pgroupS sXG pG.\n  rewrite abelian_rank1_cyclic // (rank_pgroup pX) p_rank_abelian //.\n  rewrite -{2}(pfactorK 1 p_pr) -{3}oG1p dvdn_leq_log ?cardG_gt0 //.\n  by rewrite cardSg ?OhmS.\ncase/and3P=> /eqP p2; rewrite p2 (orbC (cyclic G)) /extremal2.\ncase cG: (extremal_class G) => //; case: notF.\n  case/dihedral_classP: cG => n n_gt1 isoG.\n  have [[x y] genG _] := generators_2dihedral n_gt1 isoG.\n  have [oG _ _ _] := genG; case/dihedral2_structure: genG => // _ _ [defG1 _] _.\n  by case/idPn: n_gt1; rewrite -(@ltn_exp2l 2) // -oG -defG1 oG1p p2.\ncase/semidihedral_classP: cG => n n_gt3 isoG.\nhave [[x y] genG [oy _]] := generators_semidihedral n_gt3 isoG.\ncase/semidihedral_structure: genG => // _ _ [_ _ [defG1 _] _] _ [isoG1 _ _].\ncase/idPn: (n_gt3); rewrite -(ltn_predK n_gt3) ltnS -leqNgt -(@leq_exp2l 2) //.\nrewrite -card_2dihedral //; last by rewrite -(subnKC n_gt3).\nby rewrite -(card_isog isoG1) /= -defG1 oG1p p2.\nQed."
}
{
  "statement": "Lemma dvdp_size_eqp p q : p %| q -> size p == size q = (p %= q).\n",
  "proof": "Proof.\nmove=> pq; apply/idP/idP; last by move/eqp_size->.\nhave [->|Hq] := eqVneq q 0; first by rewrite size_poly0 size_poly_eq0 eqp0.\nhave [->|Hp] := eqVneq p 0.\n  by rewrite size_poly0 eq_sym size_poly_eq0 eqp_sym eqp0.\nmove: pq; rewrite dvdp_eq; set c := _ ^+ _; set x := _ %/ _; move/eqP=> eqpq.\nhave /= := congr1 (size \\o @polyseq R) eqpq.\nhave cn0 : c != 0 by rewrite expf_neq0 // lead_coef_eq0.\nrewrite (@eqp_size _ q); last exact: eqp_scale.\nrewrite size_mul ?p0 // => [-> HH|]; last first.\n  apply/eqP=> HH; move: eqpq; rewrite HH mul0r.\n  by move/eqP; rewrite scale_poly_eq0 (negPf Hq) (negPf cn0).\nsuff: size x == 1%N.\n  case/size_poly1P=> y H1y H2y.\n  by apply/eqpP; exists (y, c); rewrite ?H1y // eqpq H2y mul_polyC.\ncase: (size p) HH (size_poly_eq0 p)=> [|n]; first by case: eqP Hp.\nby rewrite addnS -add1n eqn_add2r; move/eqP->.\nQed."
}
{
  "statement": "Lemma normD x y : le (norm (x + y)) (norm x + norm y).\n",
  "proof": "Proof.\n  have sposM u v: lt 0 u -> le 0 (u * v) -> le 0 v.\n    by rewrite /lt !posE normM andbC => /andP[/eqP-> /mulfI/inj_eq->].\n  have posD u v: le 0 u -> le 0 v -> le 0 (u + v).\n    have [-> | nz_u u_ge0 v_ge0] := eqVneq u 0; first by rewrite add0r.\n    by have /andP[]: lt 0 (u + v) by rewrite sposDl // /lt nz_u.\n  have le_sqr u v: conj u = u -> le 0 v -> le (u ^+ 2) (v ^+ 2) -> le u v.\n    case: (eqVneq u 0) => [-> //|nz_u Ru v_ge0].\n    have [u_gt0 | u_le0 _] := boolP (lt 0 u).\n      by rewrite leB (leB u) subr_sqr mulrC addrC; apply: sposM; apply: sposDl.\n    rewrite leB posD // posE normN -addr_eq0; apply/eqP.\n    rewrite /lt nz_u posE -subr_eq0 in u_le0; apply: (mulfI u_le0).\n    by rewrite mulr0 -subr_sqr normK Ru subrr.\n  have pos_norm z: le 0 (norm z) by apply/posP; exists (sqrt z).\n  rewrite le_sqr ?posJ ?posD // sqrrD !normK -normM rmorphD mulrDl !mulrDr.\n  rewrite addrA addrC !addrA -(addrC (y * conj y)) !addrA.\n  move: (y * _ + _) => u; rewrite -!addrA leB opprD addrACA {u}subrr add0r -leB.\n  rewrite {}le_sqr ?posD //.\n    by rewrite rmorphD !rmorphM /= !conjK addrC mulrC (mulrC y).\n  rewrite -mulr2n -mulr_natr exprMn normK -natrX mulr_natr sqrrD mulrACA.\n  rewrite -rmorphM (mulrC y x) addrAC leB mulrnA mulr2n opprD addrACA.\n  rewrite subrr addr0 {2}(mulrC x) rmorphM mulrACA -opprB addrAC -sqrrB -sqrMi.\n  apply/posP; exists (i * (x * conj y - y * conj x)); congr (_ * _).\n  rewrite !(rmorphM, rmorphB) iJ !conjK mulNr -mulrN opprB.\n  by rewrite (mulrC x) (mulrC y).\nQed."
}
{
  "statement": "Lemma mx_Maschke_pchar : [pchar F]^'.-group G -> mx_completely_reducible 1%:M.\n",
  "proof": "Proof.\nrewrite /pgroup pcharf'_nat; set nG := _%:R => nzG U => /mxmoduleP Umod _.\npose phi := nG^-1 *: (\\sum_(x in G) rG x^-1 *m pinvmx U *m U *m rG x).\nhave phiG x: x \\in G -> phi *m rG x = rG x *m phi.\n  move=> Gx; rewrite -scalemxAl -scalemxAr; congr (_ *: _).\n  rewrite {2}(reindex_acts 'R _ Gx) ?astabsR //= mulmx_suml mulmx_sumr.\n  apply: eq_bigr => y Gy; rewrite !mulmxA -repr_mxM ?groupV ?groupM //.\n  by rewrite invMg mulKVg repr_mxM ?mulmxA.\nhave Uphi: U *m phi = U.\n  rewrite -scalemxAr mulmx_sumr (eq_bigr (fun _ => U)) => [|x Gx].\n    by rewrite sumr_const -scaler_nat !scalerA  mulVf ?scale1r.\n  by rewrite 3!mulmxA mulmxKpV ?repr_mxKV ?Umod ?groupV.\nhave tiUker: (U :&: kermx phi = 0)%MS.\n  apply/eqP/rowV0P=> v; rewrite sub_capmx => /andP[/submxP[u ->] /sub_kermxP].\n  by rewrite -mulmxA Uphi.\nexists (kermx phi); last exact/mxdirect_addsP.\n  apply/mxmoduleP=> x Gx; apply/sub_kermxP.\n  by rewrite -mulmxA -phiG // mulmxA mulmx_ker mul0mx.\napply/eqmxP; rewrite submx1 sub1mx.\nrewrite /row_full mxrank_disjoint_sum //= mxrank_ker.\nsuffices ->: (U :=: phi)%MS by rewrite subnKC ?rank_leq_row.\napply/eqmxP; rewrite -{1}Uphi submxMl scalemx_sub //.\nby rewrite summx_sub // => x Gx; rewrite -mulmxA mulmx_sub ?Umod.\nQed."
}
{
  "statement": "Lemma Clifford_basis M : mxsimple rH M ->\n  {X : {set gT} | X \\subset G &\n    let S := \\sum_(x in X) M *m rG x in S :=: 1%:M /\\ mxdirect S}%MS.\n",
  "proof": "Proof.\nmove=> simM. have simMG (g : [subg G]) : mxsimple rH (M *m rG (val g)).\n  by case: g => x Gx; apply: Clifford_simple.\nhave [|XG [defX1 dxX1]] := sum_mxsimple_direct_sub simMG (_ : _ :=: 1%:M)%MS.\n  apply/eqmxP; case irrG => _ _ ->; rewrite ?submx1 //; last first.\n    rewrite -submx0; apply/sumsmx_subP; move/(_ 1%g (erefl _)); apply: negP.\n    by rewrite submx0 repr_mx1 mulmx1; case simM.\n  apply/mxmoduleP=> x Gx; rewrite sumsmxMr; apply/sumsmx_subP=> [[y Gy]] /= _.\n  by rewrite (sumsmx_sup (subg G (y * x)))// subgK ?groupM// -mulmxA repr_mxM.\nexists (val @: XG); first by apply/subsetP=> ?; case/imsetP=> [[x Gx]] _ ->.\nhave bij_val: {on val @: XG, bijective (@sgval _ G)}.\n  exists (subg G) => [g _ | x]; first exact: sgvalK.\n  by case/imsetP=> [[x' Gx]] _ ->; rewrite subgK.\nhave defXG g: (val g \\in val @: XG) = (g \\in XG).\n  by apply/imsetP/idP=> [[h XGh] | XGg]; [move/val_inj-> | exists g].\nby rewrite /= mxdirectE /= !(reindex _ bij_val) !(eq_bigl _ _ defXG).\nQed."
}
{
  "statement": "Lemma Bezout_coprimepPn p q : p != 0 -> q != 0 ->\n  reflect (exists2 uv : {poly R} * {poly R},\n    (0 < size uv.1 < size q) && (0 < size uv.2 < size p) &\n      uv.1 * p = uv.2 * q)\n    (~~ (coprimep p q)).\n",
  "proof": "Proof.\nmove=> pn0 qn0; apply: (iffP idP); last first.\n  case=> [[u v] /= /andP [/andP [ps1 s1] /andP [ps2 s2]] e].\n  have: ~~(size (q * p) <= size (u * p)).\n    rewrite -ltnNge !size_mul // -?size_poly_gt0 // (polySpred pn0) !addnS.\n    by rewrite ltn_add2r.\n  apply: contra => ?; apply: dvdp_leq; rewrite ?mulf_neq0 // -?size_poly_gt0 //.\n  by rewrite mulrC Gauss_dvdp // dvdp_mull // e dvdp_mull.\nrewrite coprimep_def neq_ltn ltnS size_poly_leq0 gcdp_eq0.\nrewrite (negPf pn0) (negPf qn0) /=.\ncase sg: (size (gcdp p q)) => [|n] //; case: n sg=> [|n] // sg _.\nmove: (dvdp_gcdl p q); rewrite dvdp_eq; set c1 := _ ^+ _; move/eqP=> hu1.\nmove: (dvdp_gcdr p q); rewrite dvdp_eq; set c2 := _ ^+ _; move/eqP=> hv1.\nexists (c1 *: (q %/ gcdp p q), c2 *: (p %/ gcdp p q)); last first.\n  by rewrite -!scalerAl !scalerAr hu1 hv1 mulrCA.\nrewrite !size_scale ?lc_expn_scalp_neq0 //= !size_poly_gt0 !divp_eq0.\nrewrite gcdp_eq0 !(negPf pn0) !(negPf qn0) /= -!leqNgt leq_gcdpl //.\nrewrite leq_gcdpr //= !ltn_divpl -?size_poly_eq0 ?sg //.\nrewrite !size_mul // -?size_poly_eq0 ?sg // ![(_ + n.+2)%N]addnS /=.\nby rewrite -!(addn1 (size _)) !leq_add2l.\nQed."
}
{
  "statement": "Lemma eqpP m n :\n  reflect (exists2 c12, (c12.1 != 0) && (c12.2 != 0) & c12.1 *: m = c12.2 *: n)\n          (m %= n).\n",
  "proof": "Proof.\napply: (iffP idP) => [| [[c1 c2]/andP[nz_c1 nz_c2 eq_cmn]]]; last first.\n  rewrite /eqp (@eq_dvdp c2 c1%:P) -?eq_cmn ?mul_polyC // (@eq_dvdp c1 c2%:P)//.\n  by rewrite eq_cmn mul_polyC.\ncase: (eqVneq m 0) => [-> /andP [/dvd0pP -> _] | m_nz].\n  by exists (1, 1); rewrite ?scaler0 // oner_eq0.\ncase: (eqVneq n 0) => [-> /andP [_ /dvd0pP ->] | n_nz /andP []].\n  by exists (1, 1); rewrite ?scaler0 // oner_eq0.\nrewrite !dvdp_eq; set c1 := _ ^+ _; set c2 := _ ^+ _.\nset q1 := _ %/ _; set q2 := _ %/ _; move/eqP => Hq1 /eqP Hq2;\nhave Hc1 : c1 != 0 by rewrite expf_eq0 lead_coef_eq0 negb_and m_nz orbT.\nhave Hc2 : c2 != 0 by rewrite expf_eq0 lead_coef_eq0 negb_and n_nz orbT.\nhave def_q12: q1 * q2 = (c1 * c2)%:P.\n  apply: (mulIf m_nz); rewrite mulrAC mulrC -Hq1 -scalerAr -Hq2 scalerA.\n  by rewrite -mul_polyC.\nhave: q1 * q2 != 0 by rewrite def_q12 -size_poly_eq0 size_polyC mulf_neq0.\nrewrite mulf_eq0; case/norP=> nz_q1 nz_q2.\nhave: size q2 <= 1.\n  have:= size_mul nz_q1 nz_q2; rewrite def_q12 size_polyC mulf_neq0 //=.\n  by rewrite polySpred // => ->; rewrite leq_addl.\nrewrite leq_eqVlt ltnS size_poly_leq0 (negPf nz_q2) orbF.\ncase/size_poly1P=> c cn0 cqe; exists (c2, c); first by rewrite Hc2.\nby rewrite Hq2 -mul_polyC -cqe.\nQed."
}
{
  "statement": "Lemma gX_order : #[gX]%g  = (#|qT|).-1.\n",
  "proof": "Proof.\nhave /primitive_polyP[Hp1 Hp2 Hp3] := Hh.\nset n := _.-1 in Hp2 Hp3 *.\nhave n_gt0 : 0 < n by rewrite ltn_predRL card_qfpoly_gt1.\nhave [hM hI] := primitive_mi.\nhave gX_neq1 : gX != 1%g.\n  apply/eqP/val_eqP/eqP/val_eqP=> /=.\n  rewrite [X in X != _]qpolyXE /= //.\n  by apply/eqP=> Hx1; have := @size_polyX F; rewrite Hx1 size_poly1.\nhave Hx : (gX ^+ n)%g = 1%g by apply/eqP; rewrite -dvdp_order.\nhave Hf i : 0 < i < n -> (gX ^+ i != 1)%g by rewrite -dvdp_order => /Hp3.\nhave o_gt0 : 0 < #[gX]%g by rewrite order_gt0.\nhave : n <= #[gX]%g.\n  rewrite leqNgt; apply/negP=> oLx.\n  have /Hf/eqP[] : 0 < #[gX]%g < n by rewrite o_gt0.\n  by rewrite expg_order.\ncase: ltngtP => nLo _ //.\nhave: uniq (path.traject (mulg gX) 1%g #[gX]%g).\n  by apply/card_uniqP; rewrite path.size_traject -(eq_card (cycle_traject gX)).\ncase: #[gX]%g o_gt0 nLo => //= n1 _ nLn1 /andP[/negP[]].\napply/path.trajectP; exists n.-1; first by rewrite prednK.\nrewrite -iterSr prednK // -[LHS]Hx.\nby elim: (n) => //= n2 <-; rewrite expgS.\nQed."
}
{
  "statement": "Lemma subnormalP H G :\n  reflect (exists2 s, normal.-series H s & last H s = G) (H <|<| G).\n",
  "proof": "Proof.\napply: (iffP andP) => [[sHG snHG] | [s Hsn <-{G}]].\n  move: #|G| snHG => m; elim: m => [|m IHm] in G sHG *.\n    by exists [::]; last by apply/eqP; rewrite eq_sym.\n  rewrite iterSr => /IHm[|s Hsn defG].\n    by rewrite sub_gen // class_supportEr (bigD1 1) //= conjsg1 subsetUl.\n  exists (rcons s G); rewrite ?last_rcons // -cats1 cat_path Hsn defG /=.\n  rewrite /normal gen_subG class_support_subG //=.\n  by rewrite norms_gen ?class_support_norm.\nset f := fun _ => <<_>>; have idf: iter _ f H == H.\n  by elim=> //= m IHm; rewrite (eqP IHm) /f class_support_id genGid.\nhave [m] := ubnP (size s); elim: m s Hsn => // m IHm /lastP[//|s G].\nrewrite size_rcons last_rcons rcons_path /= ltnS.\nset K := last H s => /andP[Hsn /andP[sKG nKG]] lt_s_m.\nhave /[1!subEproper]/predU1P[<-|prKG] := sKG; first exact: IHm.\npose L := [group of f G].\nhave sHK: H \\subset K by case/IHm: Hsn.\nhave sLK: L \\subset K by rewrite gen_subG class_support_sub_norm.\nrewrite -(subnK (proper_card (sub_proper_trans sLK prKG))) iterD iterSr.\nhave defH: H = setIgr L H by rewrite -sub_setIgr ?sub_gen ?sub_class_support.\nhave: normal.-series H (map (setIgr L) s) by rewrite defH path_setIgr.\ncase/IHm=> [|_]; first by rewrite size_map.\nrewrite [in last _]defH last_map (subset_trans sHK) //=.\nby rewrite (setIidPr sLK) => /eqP->.\nQed."
}
{
  "statement": "Lemma map_section_repr n (rG : mx_representation aF G n) rGf U V\n                       (modU : mxmodule rG U) (modV : mxmodule rG V)\n                       (modUf : mxmodule rGf U^f) (modVf : mxmodule rGf V^f) :\n    map_repr f rG =1 rGf ->\n  mx_rsim (map_repr f (section_repr modU modV)) (section_repr modUf modVf).\n",
  "proof": "Proof.\nmove=> def_rGf; set VU := <<_>>%MS.\npose valUV := val_factmod (val_submod (1%:M : 'M[aF]_(\\rank VU))).\nhave sUV_Uf: (valUV^f <= U^f + V^f)%MS.\n  rewrite -map_addsmx map_submx; apply: submx_trans (proj_factmodS _ _).\n  by rewrite val_factmodS val_submod1 genmxE.\nexists (in_submod _ (in_factmod U^f valUV^f)) => [||x Gx].\n- rewrite !genmxE -(mxrank_map f) map_mxM map_col_base.\n  by case: (\\rank (cokermx U)) / (mxrank_map _ _); rewrite map_cokermx.\n- rewrite -kermx_eq0 -submx0; apply/rV_subP=> u.\n  rewrite (sameP sub_kermxP eqP) submx0 -val_submod_eq0.\n  rewrite val_submodE -mulmxA -val_submodE in_submodK; last first.\n    by rewrite genmxE -(in_factmod_addsK _ V^f) submxMr.\n  rewrite in_factmodE mulmxA -in_factmodE in_factmod_eq0.\n  move/(submxMr (in_factmod U 1%:M *m in_submod VU 1%:M)^f).\n  rewrite -mulmxA -!map_mxM //; do 2!rewrite mulmxA -in_factmodE -in_submodE.\n  rewrite val_factmodK val_submodK map_mx1 mulmx1.\n  have ->: in_factmod U U = 0 by apply/eqP; rewrite in_factmod_eq0.\n  by rewrite linear0 map_mx0 eqmx0 submx0.\nrewrite {1}in_submodE mulmxA -in_submodE -in_submodJ; last first.\n  by rewrite genmxE -(in_factmod_addsK _ V^f) submxMr.\ncongr (in_submod _ _); rewrite -in_factmodJ // in_factmodE mulmxA -in_factmodE.\napply/eqP; rewrite -subr_eq0 -def_rGf -!map_mxM -linearB in_factmod_eq0.\nrewrite -map_mxB map_submx -in_factmod_eq0 linearB.\nrewrite /= (in_factmodJ modU) // val_factmodK.\nrewrite [valUV]val_factmodE mulmxA -val_factmodE val_factmodK.\nrewrite -val_submodE in_submodK ?subrr //.\nby rewrite mxmodule_trans ?section_module // val_submod1.\nQed."
}
{
  "statement": "Lemma Frobenius_action_kernel_def G H K sT S to :\n    K ><| H = G -> @Frobenius_action _ G H sT S to ->\n  K :=: 1 :|: [set x in G | 'Fix_(S | to)[x] == set0].\n",
  "proof": "Proof.\nmove=> defG FrobG.\nhave partG: partition (gval K |: (H^# :^: K)) G.\n  apply: Frobenius_partition; apply/andP; rewrite defG; split=> //.\n  by apply/Frobenius_actionP; apply: hasFrobeniusAction FrobG.\nhave{FrobG} [ffulG transG regG ntH [u Su defH]]:= FrobG.\napply/setP=> x /[!inE]; have [-> | ntx] := eqVneq; first exact: group1.\nrewrite /= -(cover_partition partG) /cover.\nhave neKHy y: gval K <> H^# :^ y.\n  by move/setP/(_ 1); rewrite group1 conjD1g setD11.\nrewrite big_setU1 /= ?inE; last by apply/imsetP=> [[y _ /neKHy]].\nhave [nsKG sHG _ _ tiKH] := sdprod_context defG; have [sKG nKG]:= andP nsKG.\nsymmetry; case Kx: (x \\in K) => /=.\n  apply/set0Pn=> [[v /setIP[Sv]]]; have [y Gy ->] := atransP2 transG Su Sv.\n  rewrite -sub1set -astabC sub1set astab1_act mem_conjg => Hxy.\n  case/negP: ntx; rewrite -in_set1 -(conjgKV y x) -mem_conjgV conjs1g -tiKH.\n  by rewrite defH setIA inE -mem_conjg (setIidPl sKG) (normsP nKG) ?Kx.\napply/andP=> [[/bigcupP[_ /imsetP[y Ky ->] Hyx] /set0Pn[]]]; exists (to u y).\nrewrite inE (actsP (atrans_acts transG)) ?(subsetP sKG) // Su.\nrewrite -sub1set -astabC sub1set astab1_act.\nby rewrite conjD1g defH conjIg !inE in Hyx; case/and3P: Hyx.\nQed."
}
{
  "statement": "Lemma separablePn_pchar :\n  reflect (exists2 p, p \\in [pchar L] &\n            exists2 g, g \\is a polyOver K & minPoly K x = g \\Po 'X^p)\n          (~~ separable_element K x).\n",
  "proof": "Proof.\nrewrite separable_nz_der negbK; set f := minPoly K x.\napply: (iffP eqP) => [f'0 | [p Hp [g _ ->]]]; last first.\n  by rewrite deriv_comp derivXn -scaler_nat (pcharf0 Hp) scale0r mulr0.\npose n := adjoin_degree K x; have sz_f: size f = n.+1 := size_minPoly K x.\nhave fn1: f`_n = 1 by rewrite -(monicP (monic_minPoly K x)) lead_coefE sz_f.\nhave dimKx: (adjoin_degree K x)%:R == 0 :> L.\n  by rewrite -(coef0 _ n.-1) -f'0 coef_deriv fn1.\nhave /natf0_pchar[// | p pcharLp] := dimKx.\nhave /dvdnP[r Dn]: (p %| n)%N by rewrite (dvdn_pcharf pcharLp).\nexists p => //; exists (\\poly_(i < r.+1) f`_(i * p)).\n  by apply: polyOver_poly => i _; rewrite (polyOverP _) ?minPolyOver.\nrewrite comp_polyE size_poly_eq -?Dn ?fn1 ?oner_eq0 //.\nhave pr_p := pcharf_prime pcharLp; have p_gt0 := prime_gt0 pr_p.\napply/polyP=> i; rewrite coef_sum.\nhave [[{}i ->] | p'i] := altP (@dvdnP p i); last first.\n  rewrite big1 => [|j _]; last first.\n    rewrite coefZ -exprM coefXn [_ == _](contraNF _ p'i) ?mulr0 // => /eqP->.\n    by rewrite dvdn_mulr.\n  rewrite (dvdn_pcharf pcharLp) in p'i; apply: mulfI p'i _ _ _.\n  by rewrite mulr0 mulr_natl; case: i => // i; rewrite -coef_deriv f'0 coef0.\nhave [ltri | leir] := leqP r.+1 i.\n  rewrite nth_default ?sz_f ?Dn ?ltn_pmul2r ?big1 // => j _.\n  rewrite coefZ -exprM coefXn mulnC gtn_eqF ?mulr0 //.\n  by rewrite ltn_pmul2l ?(leq_trans _ ltri).\nrewrite (bigD1 (Sub i _)) //= big1 ?addr0 => [|j i'j]; last first.\n  by rewrite coefZ -exprM coefXn mulnC eqn_pmul2l // mulr_natr mulrb ifN_eqC.\nby rewrite coef_poly leir coefZ -exprM coefXn mulnC eqxx mulr1.\nQed."
}
{
  "statement": "Lemma root_annihilant x p (pEx := (p ^ pFtoE).[x%:P]) :\n    pEx != 0 -> algebraicOver FtoE x ->\n  exists2 r : {poly F}, r != 0 & forall y, root pEx y -> root (r ^ FtoE) y.\n",
  "proof": "Proof.\nmove=> nz_px [q nz_q qx0].\nhave [/size1_polyC Dp | p_gt1] := leqP (size p) 1.\n  by rewrite {}/pEx Dp map_polyC hornerC map_poly_eq0 in nz_px *; exists p`_0.\nhave nz_p: p != 0 by rewrite -size_poly_gt0 ltnW.\nhave [m le_qm] := ubnP (size q); elim: m => // m IHm in q le_qm nz_q qx0 *.\nhave nz_q1: q^:P != 0 by rewrite map_poly_eq0.\nhave sz_q1: size q^:P = size q by rewrite size_map_polyC.\nhave q1_gt1: size q^:P > 1.\n  by rewrite sz_q1 -(size_map_poly FtoE) (root_size_gt1 _ qx0) ?map_poly_eq0.\nhave [uv _ Dr] := resultant_in_ideal p_gt1 q1_gt1; set r := resultant p _ in Dr.\nhave /eqP q1x0: (q^:P ^ pFtoE).[x%:P] == 0.\n  by rewrite -swapXY_polyC -swapXY_map horner_swapXY !map_polyC polyC_eq0.\nhave [|r_nz] := boolP (r == 0); last first.\n  exists r => // y pxy0; rewrite -[r ^ _](hornerC _ x%:P) -map_polyC Dr.\n  by rewrite rmorphD !rmorphM !hornerE q1x0 mulr0 addr0 rootM pxy0 orbT.\nrewrite resultant_eq0 => /gtn_eqF/Bezout_coprimepPn[]// [q2 p1] /=.\nrewrite size_poly_gt0 sz_q1 => /andP[/andP[nz_q2 ltq2] _] Dq.\npose n := (size (lead_coef q2)).-1; pose q3 := map_poly (coefp n) q2.\nhave nz_q3: q3 != 0 by rewrite map_poly_eq0_id0 ?lead_coef_eq0.\napply: (IHm q3); rewrite ?(leq_ltn_trans (size_poly _ _)) ?(leq_trans ltq2) //.\nhave /polyP/(_ n)/eqP: (q2 ^ pFtoE).[x%:P] = 0.\napply: (mulIf nz_px); rewrite -hornerM -rmorphM Dq rmorphM hornerM /= q1x0.\n  by rewrite mul0r mulr0.\nrewrite coef0; congr (_ == 0); rewrite !horner_coef coef_sum.\nrewrite size_map_poly !size_map_poly_id0 ?map_poly_eq0 ?lead_coef_eq0 //.\nby apply: eq_bigr => i _; rewrite -rmorphXn coefMC !coef_map.\nQed."
}
{
  "statement": "Lemma pcharf_p_separable K x e p :\n  p \\in [pchar L] -> separable_element K x = (x \\in <<K; x ^+ (p ^ e.+1)>>%VS).\n",
  "proof": "Proof.\nmove=> pcharLp; apply/idP/idP=> [sepKx | /Fadjoin_poly_eq]; last first.\n  set m := p ^ _; set f := Fadjoin_poly K _ x => Dx; apply/separable_elementP.\n  have mL0: m%:R = 0 :> L by apply/eqP; rewrite -(dvdn_pcharf pcharLp) dvdn_exp.\n  exists ('X - (f \\Po 'X^m)); split.\n  - by rewrite rpredB ?polyOver_comp ?rpredX ?polyOverX ?Fadjoin_polyOver.\n  - by rewrite rootE !hornerE horner_comp hornerXn Dx subrr.\n  rewrite unlock !(derivE, deriv_comp) -mulr_natr -rmorphMn /= mL0.\n  by rewrite !mulr0 subr0 coprimep1.\nwithout loss{e} ->: e x sepKx / e = 0.\n  move=> IH; elim: {e}e.+1 => [|e]; [exact: memv_adjoin | apply: subvP].\n  apply/FadjoinP/andP; rewrite subv_adjoin expnSr exprM (IH 0) //.\n  by have /adjoin_separableP-> := sepKx; rewrite ?rpredX ?memv_adjoin.\nset K' := <<K; x ^+ p>>%VS; have sKK': (K <= K')%VS := subv_adjoin _ _.\npose q := minPoly K' x; pose g := 'X^p - (x ^+ p)%:P.\nhave [K'g]: g \\is a polyOver K' /\\ q \\is a polyOver K'.\n  by rewrite minPolyOver rpredB ?rpredX ?polyOverX // polyOverC memv_adjoin.\nhave /dvdpP[c Dq]: 'X - x%:P %| q by rewrite dvdp_XsubCl root_minPoly.\nhave co_c_g: coprimep c g.\n  have pcharPp: p \\in [pchar {poly L}] := rmorph_pchar polyC pcharLp.\n  rewrite /g polyC_exp -!(pFrobenius_autE pcharPp) -rmorphB coprimep_expr //.\n  have: separable_poly q := separable_elementS sKK' sepKx.\n  by rewrite Dq separable_mul => /and3P[].\nhave{g K'g co_c_g} /size_poly1P[a nz_a Dc]: size c == 1.\n  suffices c_dv_g: c %| g by rewrite -(eqp_size (dvdp_gcd_idl c_dv_g)).\n  have: q %| g by rewrite minPoly_dvdp // rootE !hornerE subrr.\n  by apply: dvdp_trans; rewrite Dq dvdp_mulIl.\nrewrite {q}Dq {c}Dc mulrBr -rmorphM -rmorphN -cons_poly_def qualifE /=.\nby rewrite polyseq_cons !polyseqC nz_a /= rpredN andbCA => /and3P[/fpredMl->].\nQed."
}
{
  "statement": "Lemma pPrimePowerField p k (m := (p ^ k)%N) :\n  prime p -> 0 < k -> {Fm : finFieldType | p \\in [pchar Fm] & #|Fm| = m}.\n",
  "proof": "Proof.\nmove=> pr_p k_gt0; have m_gt1: m > 1 by rewrite (ltn_exp2l 0) ?prime_gt1.\nhave m_gt0 := ltnW m_gt1; have m1_gt0: m.-1 > 0 by rewrite -ltnS prednK.\npose q := 'X^m - 'X; have Dq R: q R = ('X^m.-1 - 1) * ('X - 0).\n  by rewrite subr0 mulrBl mul1r -exprSr prednK.\nhave /FinSplittingFieldFor[/= L splitLq]: q 'F_p != 0.\n  by rewrite Dq monic_neq0 ?rpredM ?monicXsubC ?monicXnsubC.\nrewrite [_^%:A]rmorphB rmorphXn /= map_polyX -/(q L) in splitLq.\nhave pcharL: p \\in [pchar L] by rewrite pchar_lalg pchar_Fp.\npose Fm := FinFieldExtType L; exists Fm => //.\nhave /finField_galois_generator[/= a _ Da]: (1 <= {:L})%VS by apply: sub1v.\npose Em := fixedSpace (a ^+ k)%g; rewrite card_Fp //= dimv1 expn1 in Da.\nhave{splitLq} [zs DqL defL] := splitLq.\nhave Uzs: uniq zs.\n  rewrite -separable_prod_XsubC -(eqp_separable DqL) Dq separable_root andbC.\n  rewrite /root !hornerE subr_eq0 eq_sym expr0n gtn_eqF ?oner_eq0 //=.\n  rewrite cyclotomic.separable_Xn_sub_1 // -subn1 natrB // subr_eq0.\n  by rewrite natrX pcharf0 // expr0n gtn_eqF // eq_sym oner_eq0.\nsuffices /eq_card->: Fm =i zs.\n  apply: succn_inj; rewrite (card_uniqP _) //= -(size_prod_XsubC _ id).\n  by rewrite -(eqp_size DqL) size_polyDl size_polyXn // size_polyN size_polyX.\nhave in_zs: zs =i Em.\n  move=> z; rewrite -root_prod_XsubC -(eqp_root DqL) (sameP fixedSpaceP eqP).\n  rewrite /root !hornerE subr_eq0 /= /m; congr (_ == z).\n  elim: (k) => [|i IHi]; first by rewrite gal_id.\n  by rewrite expgSr expnSr exprM IHi galM ?Da ?memvf.\nsuffices defEm: Em = {:L}%VS by move=> z; rewrite in_zs defEm memvf.\napply/eqP; rewrite eqEsubv subvf -defL -[Em]subfield_closed agenvS //.\nby rewrite subv_add sub1v; apply/span_subvP=> z; rewrite in_zs.\nQed."
}
{
  "statement": "Lemma card_n3 : forall x y : square, x != y ->\n  #|[set k : col_squares | k x == k y]| = (n ^ 3)%N.\n",
  "proof": "Proof.\nmove=> x y nxy; apply/eqP; case: (posnP n) => [n0|].\n  by rewrite n0; apply/existsP=> [] [p _]; case: (p c0) => i; rewrite n0.\nmove/eqn_pmul2l <-; rewrite -expnS -card_Fid Fid cardsT.\nrewrite -{1}[n]card_ord -cardX.\npose pk k := [ffun i => k (if i == y then x else i) : colors].\nrewrite -(@card_image _ _ (fun k : col_squares => (k y, pk k))).\n  apply/eqP; apply: eq_card => ck /=; rewrite inE /= [_ \\in _]inE.\n  apply/eqP/imageP; last first.\n    by case=> k _ -> /=; rewrite !ffunE if_same eqxx.\n  case: ck => c k /= kxy.\n  exists [ffun i => if i == y then c else k i]; first by rewrite inE.\n  rewrite !ffunE eqxx; congr (_, _); apply/ffunP=> i; rewrite !ffunE.\n  case Eiy: (i == y); last by rewrite Eiy.\n  by rewrite (negbTE nxy) (eqP Eiy).\nmove=> k1 k2 [Eky Epk]; apply/ffunP=> i.\nhave{Epk}: pk k1 i = pk k2 i by rewrite Epk.\nby rewrite !ffunE; case: eqP => // ->.\nQed."
}
{
  "statement": "Lemma asimple_quo_maxainv (G H : {group rT}) :\n    H \\subset D -> G \\subset D -> [acts A, on G | to] -> [acts A, on H | to] ->\n    H <| G -> asimple (to / H) (G / H) ->\n  maxainv to G H.\n",
  "proof": "Proof.\nmove=> sHD sGD aG aH nHG /asimpleP[ntQ maxQ]; apply/maxgroupP; split.\n  by rewrite nHG -quotient_sub1 ?normal_norm // subG1 ntQ.\nmove=> K /and3P[nKG nsGK aK] sHK.\npose K' := (K / H)%G.\nhave K'dQ : K' <| (G / H)%G by apply: morphim_normal.\nhave nKH : H <| K by rewrite (normalS _ _ nHG) // normal_sub.\nhave: K' :=: 1%G \\/ K' :=: (G / H).\n  apply: (maxQ K' K'dQ) => /=.\n  apply/subsetP=> x Adx. rewrite inE Adx /= inE. apply/subsetP=> y.\n  rewrite quotientE; case/morphimP=> z Nz Kz ->; rewrite /= !inE qactE //.\n  have ntoyx :  to z x \\in 'N(H) by  rewrite (acts_qact_dom_norm Adx).\n  apply/morphimP; exists (to z x) => //.\n  suff h: qact_dom to H \\subset A.\n    by rewrite astabs_act // (subsetP aK) //; apply: (subsetP h).\n  by apply/subsetP=> t; rewrite qact_domE // inE; case/andP.\ncase=> [|/quotient_injG /[!inE]/(_ nKH nHG) c]; last by rewrite c subxx in nsGK.\nrewrite /= -trivg_quotient => tK'; apply: (congr1 (@gval _)); move: tK'.\nby apply: (@quotient_injG _ H); rewrite ?inE /= ?normal_refl.\nQed."
}
{
  "statement": "Lemma permutationsErot x s (le_x := fun t => iota 0 (index x t + 1)) :\n  perm_eq (perms (x :: s)) [seq rot i (x :: t) | t <- perms s, i <- le_x t].\n",
  "proof": "Proof.\nhave take'x t i: i <= index x t -> i <= size t /\\ x \\notin take i t.\n  move=> le_i_x; have le_i_t: i <= size t := leq_trans le_i_x (index_size x t).\n  case: (nthP x) => // -[j lt_j_i /eqP]; rewrite size_takel // in lt_j_i.\n  by rewrite nth_take // [_ == _](before_find x (leq_trans lt_j_i le_i_x)).\npose xrot t i := rot i (x :: t); pose xrotV t := index x (rev (rot 1 t)).\nhave xrotK t: {in le_x t, cancel (xrot t) xrotV}.\n  move=> i; rewrite mem_iota addn1 /xrotV => /take'x[le_i_t ti'x].\n  rewrite -rotD ?rev_cat //= rev_cons cat_rcons index_cat mem_rev size_rev.\n  by rewrite ifN // size_takel //= eqxx addn0.\napply/uniq_perm=> [||t]; first exact: permutations_uniq.\n  apply/allpairs_uniq_dep=> [|t _|]; rewrite ?permutations_uniq ?iota_uniq //.\n  move=> _ _ /allpairsPdep[t [i [_ ? ->]]] /allpairsPdep[u [j [_ ? ->]]] Etu.\n  have Eij: i = j by rewrite -(xrotK t i) // /xrot Etu xrotK.\n  by move: Etu; rewrite Eij => /rot_inj[->].\nrewrite mem_permutations; apply/esym; apply/allpairsPdep/idP=> [[u [i]] | Dt].\n  rewrite mem_permutations => -[Du _ /(canLR (rotK i))]; rewrite /rotr.\n  by set j := (j in rot j _) => Dt; apply/perm_consP; exists j, u.\npose r := rev (rot 1 t); pose i := index x r; pose u := rev (take i r).\nhave r_x: x \\in r by rewrite mem_rev mem_rot (perm_mem Dt) mem_head.\nhave [v Duv]: {v | rot i (x :: u ++ v) = t}; first exists (rev (drop i.+1 r)).\n  rewrite -rev_cat -rev_rcons -rot1_cons -cat_cons -(nth_index x r_x).\n  by rewrite -drop_nth ?index_mem // rot_rot !rev_rot revK rotK rotrK.\nexists (u ++ v), i; rewrite mem_permutations -(perm_cons x) -(perm_rot i) Duv.\nrewrite mem_iota addn1 ltnS /= index_cat mem_rev size_rev.\nby have /take'x[le_i_t ti'x] := leqnn i; rewrite ifN ?size_takel ?leq_addr.\nQed."
}
{
  "statement": "Lemma qact_domE : H \\subset R -> qact_dom to H = 'N(H | to).\n",
  "proof": "Proof.\nmove=> sHR; apply/setP=> a; apply/idP/idP=> nHa; have Da := astabs_dom nHa.\n  rewrite !inE Da; apply/subsetP=> x Hx; rewrite inE -(rcoset1 H).\n  have /rcosetsP[y Ny defHy]: to^~ a @: H \\in rcosets H 'N(H).\n    by rewrite (astabs_act _ nHa); apply/rcosetsP; exists 1; rewrite ?mulg1.\n  by rewrite (rcoset_eqP (_ : 1 \\in H :* y)) -defHy -1?(gact1 Da) mem_setact.\nrewrite !inE Da; apply/subsetP=> Hx /[1!inE] /rcosetsP[x Nx ->{Hx}].\napply/imsetP; exists (to x a).\n  case Rx: (x \\in R); last by rewrite gact_out ?Rx.\n  rewrite inE; apply/subsetP=> _ /imsetP[y Hy ->].\n  rewrite -(actKVin to Da y) -gactJ // ?(subsetP sHR, astabs_act, groupV) //.\n  by rewrite memJ_norm // astabs_act ?groupV.\napply/eqP; rewrite rcosetE eqEcard.\nrewrite (card_imset _ (act_inj _ _)) !card_rcoset leqnn andbT.\napply/subsetP=> _ /imsetP[y Hxy ->]; rewrite !mem_rcoset in Hxy *.\nhave Rxy := subsetP sHR _ Hxy; rewrite -(mulgKV x y).\ncase Rx: (x \\in R); last by rewrite !gact_out ?mulgK // 1?groupMl ?Rx.\nby rewrite -gactV // -gactM 1?groupMr ?groupV // mulgK astabs_act.\nQed."
}
{
  "statement": "Lemma card_n4 : forall x y z t : cube, uniq [:: x; y; z; t] ->\n   #|[set p : col_cubes | (p x == p y) && (p z == p t)]| = (n ^ 4)%N.\n",
  "proof": "Proof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\ncase: (uniq4_uniq6 Uxt) => u [v Uxv].\npose ff (p : col_cubes) := (p x, p z, p u, p v).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE] /andP[p1y p1t] /andP[p2y p2t] [px pz] pu pv.\n  have eqp12 : all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n   by rewrite /= -(eqP p1y) -(eqP p1t) -(eqP p2y) -(eqP p2t) px pz pu pv !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 4 = n * n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[[c d] e] g] /=; apply/imageP => /=.\nmove: Uxv; rewrite (cat_uniq [:: x; y; z; t]) => /and3P[_]/=; rewrite orbF.\nmove=> /norP[] /[!inE] + + /andP[/negPf nuv _].\nrewrite orbA => /norP[/negPf nxyu /negPf nztu].\nrewrite orbA => /norP[/negPf nxyv /negPf nztv].\nmove: Uxt; rewrite (cat_uniq [::x; y]) => /and3P[_]/= /[!(andbT, orbF)].\nmove=> /norP[] /[!inE] /negPf nxyz /negPf nxyt _.\nexists [ffun i => if pred2 x y i then c else if pred2 z t i then d\n                  else if u == i then e else g].\n  by rewrite !(inE, ffunE, eqxx,orbT)//= nxyz nxyt.\nby rewrite {}/ff !ffunE /= !eqxx /= nxyz nxyu nztu nxyv nztv nuv.\nQed."
}
{
  "statement": "Lemma mxsimple_isoP U V :\n  mxsimple U -> reflect (mx_iso U V) (mxsimple_iso U V).\n",
  "proof": "Proof.\nmove=> simU; pose u := nz_row U.\nhave [Uu nz_u]: (u <= U)%MS /\\ u != 0 by rewrite nz_row_sub nz_row_mxsimple.\napply: (iffP and3P) => [[modV] | isoUV]; last first.\n  split; last by rewrite (mxrank_iso isoUV).\n    by case: (mx_iso_simple isoUV simU).\n  have [f injf homUf defV] := isoUV; apply/rowV0Pn; exists (u *m f).\n    rewrite sub_capmx -defV submxMr //.\n    by apply/row_hom_mxP; exists f; first apply: (submx_trans Uu).\n  by rewrite -(mul0mx _ f) (can_eq (mulmxK injf)) nz_u.\ncase/rowV0Pn=> v; rewrite sub_capmx => /andP[Vv].\ncase/row_hom_mxP => f homMf def_v nz_v eqrUV.\npose uG := cyclic_mx u; pose vG := cyclic_mx v.\nhave def_vG: (uG *m f :=: vG)%MS by rewrite /vG -def_v; apply: hom_cyclic_mx.\nhave defU: (U :=: uG)%MS by apply: mxsimple_cyclic.\nhave mod_uG: mxmodule uG by rewrite cyclic_mx_module.\nhave homUf: (U <= dom_hom_mx f)%MS.\n  by rewrite defU cyclic_mx_sub ?dom_hom_mx_module.\nhave isoUf: mx_iso U (U *m f).\n  apply: mx_Schur_inj_iso => //; apply: contra nz_v; rewrite -!submx0.\n  by rewrite (eqmxMr f defU) def_vG; apply: submx_trans (cyclic_mx_id v).\napply: mx_iso_trans (isoUf) (eqmx_iso _); apply/eqmxP.\nhave sUfV: (U *m f <= V)%MS by rewrite (eqmxMr f defU) def_vG cyclic_mx_sub.\nby rewrite -mxrank_leqif_eq ?eqn_leq 1?mxrankS // -(mxrank_iso isoUf).\nQed."
}
{
  "statement": "Lemma real_similar {C : numClosedFieldType} {n} (A B : 'M[C]_n) :\n  similar_in unitmx A B ->\n  A \\is a realmx -> B \\is a realmx -> similar_in [predI realmx & unitmx] A B.\n",
  "proof": "Proof.\ncase=> [P /=]; pose Pr := P ^ (@Re _); pose Pi := P ^ (@Im _).\nhave Pr_real : Pr \\is a realmx by apply/mxOverP=> i j; rewrite !mxE Creal_Re.\nhave Pi_real : Pi \\is a realmx by apply/mxOverP=> i j; rewrite !mxE Creal_Im.\npose Q x := P ^ (@Re _) + x *: P ^ (@Im _).\nhave -> : P = Q 'i by apply/matrixP=> i j; rewrite !mxE -Crect.\nmove=> Qi_unit eq_AP_PB Areal Breal.\npose p := \\det (Pr ^ polyC + 'X *: Pi ^ polyC).\nhave horner_evaliC x : horner_eval (x : C) \\o polyC =1 id := fun=> hornerC _ _.\nhave Qunit x : Q x \\in unitmx = (p.[x] != 0).\n  rewrite /p -horner_evalE -det_map_mx map_mxD map_mxZ/= horner_evalE hornerX.\n  by rewrite -![(_ ^ polyC) ^ _]map_mx_comp !map_mx_id// unitmxE unitfE.\nhave p_neq0 : p != 0.\n  by move: Qi_unit; rewrite Qunit; apply: contra_neq => ->; rewrite hornerE.\nhave [a a_real rootNa] : exists2 a, a \\is Num.real &  ~~ root p a.\n  have rs_uniq : uniq [seq (i%:R : C) | i <- iota 0 (size p)].\n    by rewrite map_inj_uniq ?iota_uniq //; apply: mulrIn; rewrite oner_eq0.\n  have := contraNN (fun x => max_poly_roots p_neq0 x rs_uniq).\n  rewrite size_map size_iota ltnn => /(_ isT) /allPn[a a_in rootNpa].\n  by exists a => //; by move: a_in => /mapP [i _ ->]; rewrite realn.\nexists (Q a).\n  rewrite inE Qunit rootNa andbT.\n  rewrite /Q/=.\n  by rewrite realmxD// mxOverZ.\napply/similarP; rewrite ?Qunit//; move: eq_AP_PB => /(similarP Qi_unit).\nrewrite !mulmxDl !mulmxDr -!scalemxAr -!scalemxAl => /eqmx_ReiIm.\nby rewrite !mxOverM// => /(_ isT isT isT isT) [-> ->].\nQed."
}
{
  "statement": "Lemma coprime_abel_cent_TI (gT : finGroupType) (A G : {group gT}) :\n  A \\subset 'N(G) -> coprime #|G| #|A| -> abelian G -> 'C_[~: G, A](A) = 1.\n",
  "proof": "Proof.\nmove=> nGA coGA abG; pose f x := val (\\sum_(a in A) fmod abG x ^@ a)%R.\nhave fM: {in G &, {morph f : x y / x * y}}.\n  move=> x y Gx Gy /=; rewrite -fmvalA -big_split /=; congr (fmval _).\n  by apply: eq_bigr => a Aa; rewrite fmodM // actAr.\nhave nfA x a: a \\in A -> f (x ^ a) = f x.\n  move=> Aa; rewrite {2}/f (reindex_inj (mulgI a)) /=; congr (fmval _).\n  apply: eq_big => [b | b Ab]; first by rewrite groupMl.\n  by rewrite -!fmodJ ?groupM ?(subsetP nGA) // conjgM.\nhave kerR: [~: G, A] \\subset 'ker (Morphism fM).\n  rewrite gen_subG; apply/subsetP=> xa; case/imset2P=> x a Gx Aa -> {xa}.\n  have Gxa: x ^ a \\in G by rewrite memJ_norm ?(subsetP nGA).\n  rewrite commgEl; apply/kerP; rewrite (groupM, morphM) ?(groupV, morphV) //=.\n  by rewrite nfA ?mulVg.\napply/trivgP; apply/subsetP=> x /setIP[Rx cAx]; apply/set1P.\nhave Gx: x \\in G by apply: subsetP Rx; rewrite commg_subl.\nrewrite -(expgK coGA Gx) (_ : x ^+ _ = 1) ?expg1n //.\nrewrite -(fmodK abG Gx) -fmvalZ -(mker (subsetP kerR x Rx)); congr fmval.\nrewrite -GRing.sumr_const; apply: eq_bigr => a Aa.\nby rewrite -fmodJ ?(subsetP nGA) // /conjg (centP cAx) // mulKg.\nQed."
}
{
  "statement": "Lemma mxdirect_sums_center (I : finType) m n (R : 'A_(m, n)) R_ :\n    (\\sum_i R_ i :=: R)%MS -> mxdirect (\\sum_i R_ i) ->\n    (forall i : I, mx_ideal R (R_ i)) ->\n  ('Z(R) :=: \\sum_i 'Z(R_ i))%MS.\n",
  "proof": "Proof.\nmove=> defR dxR idealR.\nhave sR_R: (R_ _ <= R)%MS by move=> i; rewrite -defR (sumsmx_sup i).\nhave anhR i j A B : i != j -> A \\in R_ i -> B \\in R_ j -> A *m B = 0.\n  move=> ne_ij RiA RjB; apply: memmx0.\n  have [[_ idRiR] [idRRj _]] := (andP (idealR i), andP (idealR j)).\n  rewrite -(mxdirect_sumsP dxR j) // sub_capmx (sumsmx_sup i) //.\n    by rewrite (mulsmx_subP idRRj) // (memmx_subP (sR_R i)).\n  by rewrite (mulsmx_subP idRiR) // (memmx_subP (sR_R j)).\napply/eqmxP/andP; split.\n  apply/memmx_subP=> Z; rewrite sub_capmx => /andP[].\n  rewrite -{1}defR => /memmx_sumsP[z ->{Z} Rz cRz].\n  apply/memmx_sumsP; exists z => // i; rewrite sub_capmx Rz.\n  apply/cent_mxP=> A RiA; have:= cent_mxP cRz A (memmx_subP (sR_R i) A RiA).\n  rewrite (bigD1 i) //= mulmxDl mulmxDr mulmx_suml mulmx_sumr.\n  by rewrite !big1 ?addr0 // => j; last rewrite eq_sym; move/anhR->.\napply/sumsmx_subP => i _; apply/memmx_subP=> z; rewrite sub_capmx.\ncase/andP=> Riz cRiz; rewrite sub_capmx (memmx_subP (sR_R i)) //=.\napply/cent_mxP=> A; rewrite -{1}defR; case/memmx_sumsP=> a -> R_a.\nrewrite (bigD1 i) // mulmxDl mulmxDr mulmx_suml mulmx_sumr.\nrewrite !big1 => [|j|j]; first by rewrite !addr0 (cent_mxP cRiz).\n  by rewrite eq_sym => /anhR->.\nby move/anhR->.\nQed."
}
{
  "statement": "Lemma dvdp_pexp2r m n k : k > 0 -> (m ^+ k %| n ^+ k) = (m %| n).\n",
  "proof": "Proof.\nmove=> k_gt0; apply/idP/idP; last exact: dvdp_exp2r.\nhave [-> // | nn0] := eqVneq n 0; have [-> | mn0] := eqVneq m 0.\n  move/prednK: k_gt0=> {1}<-; rewrite exprS mul0r //= !dvd0p expf_eq0.\n  by case/andP=> _ ->.\nset d := gcdp m n; have := dvdp_gcdr m n; rewrite -/d dvdp_eq.\nset c1 := _ ^+ _; set n' := _ %/ _; move/eqP=> def_n.\nhave := dvdp_gcdl m n; rewrite -/d dvdp_eq.\nset c2 := _ ^+ _; set m' := _ %/ _; move/eqP=> def_m.\nhave dn0 : d != 0 by rewrite gcdp_eq0 negb_and nn0 orbT.\nhave c1n0 : c1 != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nhave c2n0 : c2 != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nhave c2k_n0 : c2 ^+ k != 0 by rewrite !expf_neq0 // lead_coef_eq0.\nrewrite -(@dvdpZr (c1 ^+ k)) ?expf_neq0 ?lead_coef_eq0 //.\nrewrite -(@dvdpZl (c2 ^+ k)) // -!exprZn def_m def_n !exprMn.\nrewrite dvdp_mul2r ?expf_neq0 //.\nhave: coprimep (m' ^+ k) (n' ^+ k).\n  by rewrite coprimep_pexpl // coprimep_pexpr // coprimep_div_gcd ?mn0.\nmove/coprimepP=> hc hd.\nhave /size_poly1P [c cn0 em'] : size m' == 1.\n  case: (eqVneq m' 0) def_m => [-> /eqP | m'_n0 def_m].\n    by rewrite mul0r scale_poly_eq0 (negPf mn0) (negPf c2n0).\n  have := hc _ (dvdpp _) hd; rewrite -size_poly_eq1.\n  rewrite polySpred; last by rewrite expf_eq0 negb_and m'_n0 orbT.\n  by rewrite size_exp eqSS muln_eq0 orbC eqn0Ngt k_gt0 /= -eqSS -polySpred.\nrewrite -(@dvdpZl c2) // def_m em' mul_polyC dvdpZl //.\nby rewrite -(@dvdpZr c1) // def_n dvdp_mull.\nQed."
}
{
  "statement": "Lemma normal_rank1_structure gT p (G : {group gT}) :\n    p.-group G -> (forall X : {group gT}, X <| G -> abelian X -> cyclic X) ->\n  cyclic G \\/ [&& p == 2, extremal2 G & (#|G| >= 16) || (G \\isog 'Q_8)].\n",
  "proof": "Proof.\nmove=> pG dn_G_1.\nhave [cGG | not_cGG] := boolP (abelian G); first by left; rewrite dn_G_1.\nhave [X maxX]: {X | [max X | X <| G & abelian X]}.\n  by apply: ex_maxgroup; exists 1%G; rewrite normal1 abelian1.\nhave cycX: cyclic X by rewrite dn_G_1; case/andP: (maxgroupp maxX).\nhave scX: X \\in 'SCN(G) := max_SCN pG maxX.\nhave [[p2 _ cG] | [M [_ _ _]]] := cyclic_SCN pG scX not_cGG cycX; last first.\n  rewrite 2!inE -andbA => /and3P[sEG abelE dimE_2] charE.\n  have:= dn_G_1 _ (char_normal charE) (abelem_abelian abelE).\n  by rewrite (abelem_cyclic abelE) (eqP dimE_2).\nhave [n oG] := p_natP pG; right; rewrite p2 cG /= in oG *.\nrewrite oG (@leq_exp2l 2 4) //.\nrewrite /extremal2 /extremal_class oG pfactorKpdiv // in cG.\ncase: andP cG => [[n_gt1 isoG] _ | _]; last first.\n  by case: (ltngtP 3 n) => //= <-; do 2?case: ifP.\nhave [[x y] genG _] := generators_2dihedral n_gt1 isoG.\nhave [_ _ _ [_ _ maxG]] := dihedral2_structure n_gt1 genG isoG.\nrewrite 2!ltn_neqAle n_gt1 !(eq_sym _ n).\ncase: eqP => [_ abelG| _]; first by rewrite (abelem_abelian abelG) in not_cGG.\ncase: eqP => // -> [_ _ isoY _ _]; set Y := <<_>> in isoY.\nhave nxYG: Y <| G by rewrite (p_maximal_normal pG) // maxG !inE eqxx orbT.\nhave [// | [u v] genY _] := generators_2dihedral _ isoY.\ncase/dihedral2_structure: (genY) => //= _ _ _ _ abelY.\nhave:= dn_G_1 _ nxYG (abelem_abelian abelY).\nby rewrite (abelem_cyclic abelY); case: genY => ->.\nQed."
}
{
  "statement": "Lemma primitive_root_splitting_abelian (z : F) :\n  #|G|.-primitive_root z -> abelian G -> group_splitting_field G.\n",
  "proof": "Proof.\nmove=> ozG cGG [|n] rG irrG; first by case/mx_irrP: irrG.\ncase: (pickP [pred x in G | ~~ is_scalar_mx (rG x)]) => [x | scalG].\n  case/andP=> Gx nscal_rGx; have: horner_mx (rG x) ('X^#|G| - 1) == 0.\n    rewrite rmorphB rmorphXn /= horner_mx_C horner_mx_X.\n    rewrite -repr_mxX ?inE // ((_ ^+ _ =P 1)%g _) ?repr_mx1 ?subrr //.\n    by rewrite -order_dvdn order_dvdG.\n  case/idPn; rewrite -mxrank_eq0 -(factor_Xn_sub_1 ozG).\n  elim: #|G| => [|i IHi]; first by rewrite big_nil horner_mx_C mxrank1.\n  rewrite big_nat_recr => [|//]; rewrite rmorphM mxrankMfree {IHi}//=.\n  rewrite row_free_unit rmorphB /= horner_mx_X horner_mx_C.\n  rewrite (mx_Schur irrG) ?subr_eq0 //; last first.\n    by apply: contraNneq nscal_rGx => ->; apply: scalar_mx_is_scalar.\n  rewrite -memmx_cent_envelop raddfB.\n  rewrite addmx_sub ?eqmx_opp ?scalar_mx_cent //= memmx_cent_envelop.\n  by apply/centgmxP=> j Zh_j; rewrite -!repr_mxM // (centsP cGG).\npose M := <<delta_mx 0 0 : 'rV[F]_n.+1>>%MS.\nhave linM: \\rank M = 1 by rewrite genmxE mxrank_delta.\nhave modM: mxmodule rG M.\n  apply/mxmoduleP=> x Gx; move/idPn: (scalG x); rewrite /= Gx negbK.\n  by case/is_scalar_mxP=> ? ->; rewrite scalar_mxC submxMl.\napply: linear_mx_abs_irr; apply/eqP; rewrite eq_sym -linM.\nby case/mx_irrP: irrG => _; apply; rewrite // -mxrank_eq0 linM.\nQed."
}
{
  "statement": "Lemma poly_algR_pfactor (p : {poly algR}) :\n  { r : seq algC |\n    p ^^ algRval = val (lead_coef p) *: \\prod_(z <- r) algC_pfactor z }.\n",
  "proof": "Proof.\nwlog p_monic : p / p \\is monic => [hwlog|].\n  have [->|pN0] := eqVneq p 0.\n    by exists [::]; rewrite lead_coef0/= rmorph0 scale0r.\n  have [|r] := hwlog ((lead_coef p)^-1 *: p).\n    by rewrite monicE lead_coefZ mulVf ?lead_coef_eq0//.\n  rewrite !lead_coefZ mulVf ?lead_coef_eq0//= scale1r.\n  rewrite map_polyZ/= => /(canRL (scalerKV _))->; first by exists r.\n  by rewrite fmorph_eq0 lead_coef_eq0.\nsuff: {r : seq algC | p ^^ algRval = \\prod_(z <- r) algC_pfactor z}.\n  by move=> [r rP]; exists r; rewrite rP (monicP _)// scale1r.\nhave [/= r pr] := closed_field_poly_normal (p ^^ algRval).\nrewrite (monicP _) ?monic_map ?scale1r// {p_monic} in pr *.\nhave [n] := ubnP (size r).\nelim: n r => // n IHn [|x r]/= in p pr *.\n by exists [::]; rewrite pr !big_nil.\nrewrite ltnS => r_lt.\nhave xJxr : x^* \\in x :: r.\n  rewrite -root_prod_XsubC -pr.\n  have /eq_map_poly-> : algRval =1 Num.conj_op \\o algRval.\n    by move=> a /=; rewrite (CrealP (algRvalP _)).\n  by rewrite map_poly_comp mapf_root pr root_prod_XsubC mem_head.\nhave xJr : (x \\isn't Creal) ==> (x^* \\in r) by rewrite implyNb CrealE.\nhave pxdvdC : algC_pfactor x %| p ^^ algRval.\n  rewrite pr algC_pfactorE big_cons/= dvdp_mul2l ?polyXsubC_eq0//.\n  by case: (_ \\is _) xJr; rewrite ?dvd1p// dvdp_XsubCl root_prod_XsubC.\npose pr'x := p %/ algR_pfactor x.\nhave [||r'] := IHn (if x \\is Creal then r else rem x^* r) pr'x; last 2 first.\n- by case: (_ \\is _) in xJr *; rewrite ?size_rem// (leq_ltn_trans (leq_pred _)).\n- move=> /eqP; rewrite map_divp -dvdp_eq_mul ?algC_pfactor_eq0//= => /eqP->.\n  by exists (x :: r'); rewrite big_cons mulrC.\nrewrite map_divp/= pr big_cons algC_pfactorE/=.\nrewrite divp_pmul2l ?expf_neq0 ?polyXsubC_eq0//.\ncase: (_ \\is _) => /= in xJr *; first by rewrite divp1//.\nby rewrite (big_rem _ xJr)/= mulKp ?polyXsubC_eq0.\nQed."
}
{
  "statement": "Lemma card_ltn_sorted_tuples m n :\n  #|[set t : m.-tuple 'I_n | sorted ltn (map val t)]| = 'C(n, m).\n",
  "proof": "Proof.\nhave [-> | n_gt0] := posnP n; last pose i0 := Ordinal n_gt0.\n  case: m => [|m]; last by apply: eq_card0; case/tupleP=> [[]].\n  by apply: (@eq_card1 _ [tuple]) => t; rewrite [t]tuple0 inE.\nrewrite -[n in RHS]card_ord -card_draws.\npose f_t (t : m.-tuple 'I_n) := [set i in t].\npose f_A (A : {set 'I_n}) := [tuple of mkseq (nth i0 (enum A)) m].\nhave val_fA (A : {set 'I_n}) : #|A| = m -> val (f_A A) = enum A.\n  by move=> Am; rewrite -[enum _](mkseq_nth i0) -cardE Am.\nhave inc_A (A : {set 'I_n}) : sorted ltn (map val (enum A)).\n  rewrite -[enum _](eq_filter (mem_enum _)).\n  rewrite -(eq_filter (mem_map val_inj _)) -filter_map.\n  by rewrite (sorted_filter ltn_trans) // unlock val_ord_enum iota_ltn_sorted.\nrewrite -!sum1dep_card (reindex_onto f_t f_A) /= => [|A]; last first.\n  by move/eqP=> cardAm; apply/setP=> x; rewrite inE -(mem_enum A) -val_fA.\napply: eq_bigl => t.\napply/idP/idP => [inc_t|/andP [/eqP t_m /eqP <-]]; last by rewrite val_fA.\nhave ft_m: #|f_t t| = m.\n  rewrite cardsE (card_uniqP _) ?size_tuple // -(map_inj_uniq val_inj).\n  exact: (sorted_uniq ltn_trans ltnn).\nrewrite ft_m eqxx -val_eqE val_fA // -(inj_eq (inj_map val_inj)) /=.\napply/eqP/(irr_sorted_eq ltn_trans ltnn) => // y.\nby apply/mapP/mapP=> [] [x t_x ->]; exists x; rewrite // mem_enum inE in t_x *.\nQed."
}
{
  "statement": "Lemma card_p3group_extraspecial E :\n  prime p -> #|E| = (p ^ 3)%N -> #|'Z(E)| = p -> extraspecial E.\n",
  "proof": "Proof.\nmove=> p_pr oEp3 oZp; have p_gt0 := prime_gt0 p_pr.\nhave pE: p.-group E by rewrite /pgroup oEp3 pnatX pnat_id.\nhave pEq: p.-group (E / 'Z(E))%g by rewrite quotient_pgroup.\nhave /andP[sZE nZE] := center_normal E.\nhave oEq: #|E / 'Z(E)|%g = (p ^ 2)%N.\n  by rewrite card_quotient -?divgS // oEp3 oZp expnS mulKn.\nhave cEEq: abelian (E / 'Z(E))%g by apply: card_p2group_abelian oEq.\nhave not_cEE: ~~ abelian E.\n  have: #|'Z(E)| < #|E| by rewrite oEp3 oZp (ltn_exp2l 1) ?prime_gt1.\n  by apply: contraL => cEE; rewrite -leqNgt subset_leq_card // subsetI subxx.\nhave defE': E^`(1) = 'Z(E).\n  apply/eqP; rewrite eqEsubset der1_min //=; apply: contraR not_cEE => not_sE'Z.\n  apply/commG1P/(TI_center_nil (pgroup_nil pE) (der_normal 1 _)).\n  by rewrite setIC prime_TIg ?oZp.\nsplit; [split=> // | by rewrite oZp]; apply/eqP.\nrewrite eqEsubset andbC -{1}defE' {1}(Phi_joing pE) joing_subl.\nrewrite -quotient_sub1 ?gFsub_trans ?subG1 //=.\nrewrite (quotient_Phi pE) //= (trivg_Phi pEq).\napply/abelemP=> //; split=> // Zx EqZx; apply/eqP; rewrite -order_dvdn /order.\nrewrite (card_pgroup (mem_p_elt pEq EqZx)) (@dvdn_exp2l _ _ 1) //.\nrewrite leqNgt -pfactor_dvdn // -oEq; apply: contra not_cEE => sEqZx.\nrewrite cyclic_center_factor_abelian //; apply/cyclicP.\nexists Zx; apply/eqP; rewrite eq_sym eqEcard cycle_subG EqZx -orderE.\nexact: dvdn_leq sEqZx.\nQed."
}
{
  "statement": "Lemma diagonalizablePeigen {n} {f : 'M[F]_n} :\n  diagonalizable f <->\n  exists2 rs, uniq rs & (\\sum_(r <- rs) eigenspace f r :=: 1%:M)%MS.\n",
  "proof": "Proof.\nsplit=> [df|[rs urs rsP]].\n  suff [rs rsP] : exists rs, (\\sum_(r <- rs) eigenspace f r :=: 1%:M)%MS.\n    exists (undup rs); rewrite ?undup_uniq//; apply: eqmx_trans rsP.\n    elim: rs => //= r rs IHrs; rewrite big_cons.\n    case: ifPn => in_rs; rewrite ?big_cons; last exact: adds_eqmx.\n    apply/(eqmx_trans IHrs)/eqmx_sym/addsmx_idPr.\n    have rrs : (index r rs < size rs)%N by rewrite index_mem.\n    rewrite (big_nth 0) big_mkord (sumsmx_sup (Ordinal rrs)) ?nth_index//.\n  move: df => [P Punit /(similar_diagLR Punit)[d ->]].\n  exists [seq d 0 i | i <- enum 'I_n]; rewrite big_image/=.\n  apply: (@eqmx_trans _ _ _ _ _ _ P); apply/eqmxP;\n    rewrite ?sub1mx ?submx1 ?row_full_unit//.\n  rewrite submx_full ?row_full_unit//=.\n  apply/row_subP => i; rewrite rowE (sumsmx_sup i)//.\n  apply/eigenspaceP; rewrite conjVmx// !mulmxA mulmxK//.\n  by rewrite -rowE row_diag_mx scalemxAl.\nhave mxdirect_eigenspaces : mxdirect (\\sum_(i < size rs) eigenspace f rs`_i).\n  apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\nrewrite (big_nth 0) big_mkord in rsP; apply/codiagonalizable1.\napply/(codiagonalizable_on _ mxdirect_eigenspaces) => // i/=.\n  case: n => [|n] in f {mxdirect_eigenspaces} rsP *.\n    by rewrite thinmx0 sub0mx.\n  by rewrite comm_mx_stable_eigenspace.\napply/codiagonalizable1.\nby rewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free.\nQed."
}
{
  "statement": "Lemma maxainvM (G H K : {group rT}) :\n    H \\subset D -> K \\subset D -> maxainv G H -> maxainv G K ->\n  H :<>: K -> H * K = G.\n",
  "proof": "Proof.\nmove: H K => N1 N2 sN1D sN2D pmN1 pmN2 neN12.\nhave cN12 : commute N1 N2.\n  apply: normC; apply: (subset_trans (maxainv_sub pmN1)).\n  by rewrite normal_norm ?maxainv_norm.\nwlog nsN21 : G N1 N2 sN1D sN2D pmN1 pmN2 neN12 cN12/ ~~(N1 \\subset N2).\n  move/eqP: (neN12); rewrite eqEsubset negb_and; case/orP=> ns; first by apply.\n  by rewrite cN12; apply=> //; apply: sym_not_eq.\nhave nP : N1 * N2 <| G by rewrite normalM ?maxainv_norm.\nhave sN2P : N2 \\subset N1 * N2 by rewrite mulg_subr ?group1.\ncase/maxgroupP: (pmN1); case/andP=> nN1G pN1G mN1.\ncase/maxgroupP: (pmN2); case/andP=> nN2G pN2G mN2.\ncase/andP: pN1G=> nsGN1 ha1; case/andP: pN2G=> nsGN2 ha2.\ncase e : (G \\subset N1 * N2).\n  by apply/eqP; rewrite eqEsubset e mulG_subG !normal_sub.\nhave: N1 <*> N2 = N2 by apply: mN2; rewrite /= ?comm_joingE // nP e /= gactsM.\nby rewrite comm_joingE // => h; move: nsN21; rewrite -h mulg_subl.\nQed."
}
{
  "statement": "Lemma card_n3s : forall x y z t u v: cube, uniq [:: x; y; z; t; u; v] ->\n  #|[set p : col_cubes | (p x == p y) && (p z == p t)&& (p u == p v )]|\n    = (n ^ 3)%N.\n",
  "proof": "Proof.\nmove=> x y z t u v Uxv; rewrite -[n]card_ord .\npose ff (p : col_cubes) := (p x, p z, p u).\nrewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and3P[/eqP p1xy /eqP p1zt /eqP p1uv].\n  move=> /and3P[/eqP p2xy /eqP p2zt /eqP p2uv] [px pz] pu.\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1xy -p2xy -p1zt -p2zt -p1uv -p2uv px pz pu !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 3 = n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[c d] e] /=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z; t]) => /and3P[Uxt + nuv].\nmove=> /= /[!orbF] /norP[] /[!inE].\nrewrite orbA => /norP[/negPf nxyu /negPf nztu].\nrewrite orbA => /norP[/negPf nxyv /negPf nztv].\nmove: Uxt; rewrite (cat_uniq [::x; y]) => /and3P[_].\nrewrite /= !orbF !andbT => /norP[] /[!inE] /negPf nxyz /negPf nxyt _.\nexists [ffun i => if i \\in [:: x; y] then c\n                  else if i \\in [:: z; t] then d else e].\n  by rewrite !(inE, ffunE, eqxx,orbT)//= nxyz nxyt nxyu nztu nxyv nztv !eqxx.\nby rewrite {}/ff !ffunE !inE /= !eqxx nxyz nxyu nztu.\nQed."
}
{
  "statement": "Lemma card_n3_3 : forall x y z t: cube, uniq [:: x; y; z; t] ->\n  #|[set p : col_cubes | (p x == p y) && (p y == p z)&& (p z == p t)]|\n      = (n ^ 3)%N.\n",
  "proof": "Proof.\nmove=> x y z t Uxt; rewrite -[n]card_ord.\ncase: (uniq4_uniq6 Uxt) => u [v Uxv].\npose ff (p : col_cubes) := (p x, p u, p v);\n    rewrite -(@card_in_image _ _ ff); first last.\n  move=> p1 p2 /[!inE]; rewrite -!andbA.\n  move=> /and3P[/eqP p1xy /eqP p1yz /eqP p1zt].\n  move=> /and3P[/eqP p2xy /eqP p2yz /eqP p2zt] [px pu] pv.\n  have eqp12: all (fun i => p1 i == p2 i) [:: x; y; z; t; u; v].\n    by rewrite /= -p1zt -p2zt -p1yz -p2yz -p1xy -p2xy px pu pv !eqxx.\n  apply/ffunP=> i; apply/eqP; apply: (allP eqp12).\n  by rewrite (subset_cardP _ (subset_predT _)) // (card_uniqP Uxv) card_ord.\nhave -> : forall n, (n ^ 3 = n * n * n)%N by move=> ?; rewrite -!mulnA.\nrewrite -!card_prod; apply: eq_card => [] [[c d] e] /=; apply/imageP.\nmove: Uxv; rewrite (cat_uniq [::x; y; z; t]) => /and3P[_ hasxt].\nrewrite /uniq !inE !andbT => /negPf nuv.\nexists [ffun i => if i \\in [:: x; y; z; t] then c else if u == i then d else e].\n  by rewrite /= !(inE, ffunE, eqxx, orbT).\nrewrite {}/ff !(ffunE, inE, eqxx) /=; move: hasxt; rewrite nuv.\nby do 8![case E: ( _ ==  _ ); rewrite ?(eqP E)/= ?inE ?eqxx //= ?E {E}].\nQed."
}
{
  "statement": "Lemma Cauchy p G : prime p -> p %| #|G| -> {x | x \\in G & #[x] = p}.\n",
  "proof": "Proof.\nmove=> p_pr; have [n] := ubnP #|G|; elim: n G => // n IHn G /ltnSE-leGn pG.\npose xpG := [pred x in G | #[x] == p].\nhave [x /andP[Gx /eqP] | no_x] := pickP xpG; first by exists x.\nhave{pG n leGn IHn} pZ: p %| #|'C_G(G)|.\n  suffices /dvdn_addl <-:  p %| #|G :\\: 'C(G)| by rewrite cardsID.\n  have /acts_sum_card_orbit <-: [acts G, on G :\\: 'C(G) | 'J].\n    by apply/actsP=> x Gx y; rewrite !inE -!mem_conjgV -centJ conjGid ?groupV.\n  elim/big_rec: _ => // _ _ /imsetP[x /setDP[Gx nCx] ->] /dvdn_addl->.\n  have ltCx: 'C_G[x] \\proper G by rewrite properE subsetIl subsetIidl sub_cent1.\n  have /negP: ~ p %| #|'C_G[x]|.\n    case/(IHn _ (leq_trans (proper_card ltCx) leGn))=> y /setIP[Gy _] /eqP-oy.\n    by have /andP[] := no_x y.\n  by apply/implyP; rewrite -index_cent1 indexgI implyNb -Euclid_dvdM ?LagrangeI.\nhave [Q maxQ _]: {Q | [max Q | p^'.-subgroup('C_G(G)) Q] & 1%G \\subset Q}.\n  by apply: maxgroup_exists; apply: psubgroup1.\ncase/andP: (maxgroupp maxQ) => sQC; rewrite /pgroup p'natE // => /negP[].\napply: dvdn_trans pZ (cardSg _); apply/subsetP=> x /setIP[Gx Cx].\nrewrite -sub1set -gen_subG (normal_sub_max_pgroup maxQ) //; last first.\n  rewrite /normal subsetI !cycle_subG ?Gx ?cents_norm ?subIset ?andbT //=.\n  by rewrite centsC cycle_subG Cx.\nrewrite /pgroup p'natE //= -[#|_|]/#[x]; apply/dvdnP=> [[m oxm]].\nhave m_gt0: 0 < m by apply: dvdn_gt0 (order_gt0 x) _; rewrite oxm dvdn_mulr.\ncase/idP: (no_x (x ^+ m)); rewrite /= groupX //= orderXgcd //= oxm.\nby rewrite gcdnC gcdnMr mulKn.\nQed."
}
{
  "statement": "Lemma zchar_small_norm phi n :\n    phi \\in 'Z[irr G] -> '[phi] = n%:R -> (n < 4)%N ->\n  {S : n.-tuple 'CF(G) |\n    [/\\ orthonormal S, {subset S <= 'Z[irr G]} & phi = \\sum_(xi <- S) xi]}.\n",
  "proof": "Proof.\nmove=> Zphi def_n lt_n_4.\npose S := [seq '[phi, 'chi_i] *: 'chi_i | i in irr_constt phi].\nhave def_phi: phi = \\sum_(xi <- S) xi.\n  rewrite big_image big_mkcond {1}[phi]cfun_sum_cfdot.\n  by apply: eq_bigr => i _; rewrite if_neg; case: eqP => // ->; rewrite scale0r.\nhave orthS: orthonormal S.\n  apply/orthonormalP; split=> [|_ _ /mapP[i phi_i ->] /mapP[j _ ->]].\n    rewrite map_inj_in_uniq ?enum_uniq // => i j; rewrite mem_enum => phi_i _.\n    by move/eqP; rewrite eq_scaled_irr (negbTE phi_i) => /andP[_ /= /eqP].\n  rewrite eq_scaled_irr cfdotZl cfdotZr cfdot_irr mulrA mulr_natr mulrb.\n  rewrite mem_enum in phi_i; rewrite (negbTE phi_i) andbC; case: eqP => // <-.\n  have /natrP[m def_m] := natr_norm_int (Cint_cfdot_vchar_irr i Zphi).\n  apply/eqP; rewrite eqxx /= -normCK def_m -natrX eqr_nat eqn_leq lt0n.\n  rewrite expn_eq0 andbT -eqC_nat -def_m normr_eq0 [~~ _]phi_i andbT.\n  rewrite (leq_exp2r _ 1) // -ltnS -(@ltn_exp2r _ _ 2) //.\n  apply: leq_ltn_trans lt_n_4; rewrite -leC_nat -def_n natrX.\n  rewrite cfdot_sum_irr (bigD1 i) //= -normCK def_m addrC -subr_ge0 addrK.\n  by rewrite sumr_ge0 // => ? _; apply: mul_conjC_ge0.\nhave <-: size S = n.\n  by apply/eqP; rewrite -eqC_nat -def_n def_phi cfnorm_orthonormal.\nexists (in_tuple S); split=> // _ /mapP[i _ ->].\nby rewrite scale_zchar ?irr_vchar // Cint_cfdot_vchar_irr.\nQed."
}
{
  "statement": "Lemma card_GL n : n > 0 ->\n  #|'GL_n[F]| = (#|F| ^ 'C(n, 2) * \\prod_(1 <= i < n.+1) (#|F| ^ i - 1))%N.\n",
  "proof": "Proof.\ncase: n => // n' _; set n := n'.+1; set p := #|F|.\nrewrite big_nat_rev big_add1 -bin2_sum expn_sum -big_split /=.\npose fr m := [pred A : 'M[F]_(m, n) | \\rank A == m].\nset m := n; rewrite [in m.+1]/m; transitivity #|fr m|.\n  by rewrite cardsT /= card_sub; apply: eq_card => A; rewrite -row_free_unit.\nhave: m <= n by []; elim: m => [_ | m IHm /ltnW-le_mn].\n  rewrite (@eq_card1 _ (0 : 'M_(0, n))) ?big_geq //= => A.\n  by rewrite flatmx0 !inE mxrank.unlock !eqxx.\nrewrite big_nat_recr // -{}IHm //= !subSS mulnBr muln1 -expnD subnKC //.\nrewrite -sum_nat_const /= -sum1_card -add1n.\nrewrite (partition_big dsubmx (fr m)) /= => [|A]; last first.\n  rewrite !inE -{1}(vsubmxK A); move: {A}(_ A) (_ A) => Ad Au Afull.\n  rewrite eqn_leq rank_leq_row -(leq_add2l (\\rank Au)) -mxrank_sum_cap.\n  rewrite {1 3}[@mxrank]lock addsmxE (eqnP Afull) -lock -addnA.\n  by rewrite leq_add ?rank_leq_row ?leq_addr.\napply: eq_bigr => A rAm; rewrite (reindex (col_mx^~ A)) /=; last first.\n  exists usubmx => [v _ | vA]; first by rewrite col_mxKu.\n  by case/andP=> _ /eqP <-; rewrite vsubmxK.\ntransitivity #|~: [set v *m A | v in 'rV_m]|; last first.\n  rewrite cardsCs setCK card_imset ?card_mx ?card_ord ?mul1n //.\n  have [B AB1] := row_freeP rAm; apply: can_inj (mulmx^~ B) _ => v.\n  by rewrite -mulmxA AB1 mulmx1.\nrewrite -sum1_card; apply: eq_bigl => v; rewrite !inE col_mxKd eqxx.\nrewrite andbT eqn_leq rank_leq_row /= -(leq_add2r (\\rank (v :&: A)%MS)).\nrewrite -addsmxE mxrank_sum_cap (eqnP rAm) addnAC leq_add2r.\nrewrite (ltn_leqif (mxrank_leqif_sup _)) ?capmxSl // sub_capmx submx_refl.\nby congr (~~ _); apply/submxP/imsetP=> [] [u]; exists u.\nQed."
}
{
  "statement": "Lemma setXn_dprod H : \\big[dprod/1]_i set1gXn (H i) = setXn H.\n",
  "proof": "Proof.\nrewrite -setXn_prod//=.\nsuff -> : \\big[dprod/1]_i groupXn1 (H i) = (\\prod_i groupXn1 (H i))%G.\n  by rewrite comm_prodG//=; apply: in2W; apply: set1gXn_commute.\napply/eqP; apply/bigdprodYP => i //= _; rewrite subsetD.\napply/andP; split.\n  rewrite comm_prodG; last by apply: in2W; apply: set1gXn_commute.\n  apply/centsP => _ /prodsgP[/= h_ h_P ->] _ /set1gXnP [h hH ->].\n  apply/ffunP => j; rewrite !ffunE/=.\n  rewrite (big_morph _ (@dffunM j) (_ : _ = 1)) ?ffunE//.\n  case: dfwithP => {j} [|? ?]; last by rewrite mulg1 mul1g.\n  rewrite big1 ?mulg1 ?mul1g// => j neq_ji.\n  by have /set1gXnP[? _ ->] := h_P j neq_ji; rewrite ffunE dfwith_out.\nrewrite -setI_eq0 -subset0; apply/subsetP => /= x; rewrite !inE.\nrewrite comm_prodG; last by apply: in2W; apply: set1gXn_commute.\nmove=> /and3P[+ + /set1gXnP [h _ x_h]]; rewrite {x}x_h.\nmove=> /prodsgP[x_ x_P /ffunP/(_ i)]; rewrite ffunE dfwith_in => {h}->.\napply: contra_neqT => _; apply/ffunP => j; rewrite !ffunE/=.\ncase: dfwithP => // {j}; rewrite (big_morph _ (@dffunM i) (_ : _ = 1)) ?ffunE//.\nrewrite big1// => j neq_ji.\nby have /set1gXnP[g gH /ffunP->] := x_P _ neq_ji; rewrite ffunE dfwith_out.\nQed."
}
{
  "statement": "Lemma rsim_regular_factmod :\n  {U : 'M_nG & {modU : mxmodule aG U & mx_rsim rG (factmod_repr modU)}}.\n",
  "proof": "Proof.\npose v : 'rV[F]_n := nz_row 1%:M.\npose fU := lin1_mx (mulmx v \\o gring_mx rG); pose U := kermx fU.\nhave modU: mxmodule aG U.\n  apply/mxmoduleP => x Gx; apply/sub_kermxP/row_matrixP=> i.\n  rewrite 2!row_mul row0; move: (row i U) (sub_kermxP (row_sub i U)) => u.\n  by rewrite !mul_rV_lin1 /= gring_mxJ // mulmxA => ->; rewrite mul0mx.\nhave def_n: \\rank (cokermx U) = n.\n  apply/eqP; rewrite mxrank_coker mxrank_ker subKn ?rank_leq_row // -genmxE.\n  rewrite -[_ == _]sub1mx; have [_ _ ->] := irrG; rewrite ?submx1 //.\n    rewrite (eqmx_module _ (genmxE _)); apply/mxmoduleP=> x Gx.\n    apply/row_subP=> i; apply: eq_row_sub (gring_index G (enum_val i * x)) _.\n    rewrite !rowE mulmxA !mul_rV_lin1 /= -mulmxA -gring_mxJ //.\n    by rewrite -rowE rowK.\n  rewrite (eqmx_eq0 (genmxE _)); apply/rowV0Pn.\n  exists v; last exact: (nz_row_mxsimple irrG).\n  apply/submxP; exists (gring_row (aG 1%g)); rewrite mul_rV_lin1 /=.\n  by rewrite -gring_opE gring_opG // repr_mx1 mulmx1.\nexists U; exists modU; apply: mx_rsim_sym.\nexists (val_factmod 1%:M *m fU) => // [|x Gx].\n  rewrite /row_free eqn_leq rank_leq_row /= -subn_eq0 -mxrank_ker mxrank_eq0.\n  apply/rowV0P=> u /sub_kermxP; rewrite mulmxA => /sub_kermxP.\n  by rewrite -/U -in_factmod_eq0 mulmxA mulmx1 val_factmodK => /eqP.\nrewrite mulmxA -val_factmodE (canRL (addKr _) (add_sub_fact_mod U _)).\nrewrite mulmxDl mulNmx (sub_kermxP (val_submodP _)) oppr0 add0r.\napply/row_matrixP=> i; move: (val_factmod _) => zz.\nby rewrite !row_mul !mul_rV_lin1 /= gring_mxJ // mulmxA.\nQed."
}
{
  "statement": "Lemma Hilbert's_theorem_90 K E x a :\n   generator 'Gal(E / K) x -> a \\in E ->\n reflect (exists2 b, b \\in E /\\ b != 0 & a = b / x b) (galNorm K E a == 1).\n",
  "proof": "Proof.\nmove/(_ =P <[x]>)=> DgalE Ea.\nhave galEx: x \\in 'Gal(E / K) by rewrite DgalE cycle_id.\napply: (iffP eqP) => [normEa1 | [b [Eb nzb] ->]]; last first.\n  by rewrite galNormM galNormV galNorm_gal // mulfV // galNorm_eq0.\nhave [x1 | ntx] := eqVneq x 1%g.\n  exists 1; first by rewrite mem1v oner_neq0.\n  by rewrite -{1}normEa1 /galNorm DgalE x1 cycle1 big_set1 !gal_id divr1.\npose c_ y := \\prod_(i < invm (injm_Zpm x) y) (x ^+ i)%g a.\nhave nz_c1: c_ 1%g != 0 by rewrite /c_ morph1 big_ord0 oner_neq0.\nhave [d] := @gal_independent_contra _ [in 'Gal(E / K)] _ _ (group1 _) nz_c1.\nset b := \\sum_(y in _) _ => Ed nz_b; exists b.\n  split=> //; apply: rpred_sum => y galEy.\n  by apply: rpredM; first apply: rpred_prod => i _; apply: memv_gal.\napply: canRL (mulfK _) _; first by rewrite fmorph_eq0.\nrewrite rmorph_sum mulr_sumr [b](reindex_acts 'R _ galEx) ?astabsR //=.\napply: eq_bigr => y galEy; rewrite galM // rmorphM mulrA; congr (_ * _).\nhave /morphimP[/= i _ _ ->] /=: y \\in Zpm @* Zp #[x] by rewrite im_Zpm -DgalE.\nhave <-: Zpm (i + 1) = (Zpm i * x)%g by rewrite morphM ?mem_Zp ?order_gt1.\nrewrite /c_ !invmE ?mem_Zp ?order_gt1 //= addn1; set n := _.+2.\ntransitivity (\\prod_(j < i.+1) (x ^+ j)%g a).\n  rewrite big_ord_recl gal_id rmorph_prod; congr (_ * _).\n  by apply: eq_bigr => j _; rewrite expgSr galM ?lfunE.\nhave [/modn_small->//||->] := ltngtP i.+1 n; first by rewrite ltnNge ltn_ord.\nrewrite modnn big_ord0; apply: etrans normEa1; rewrite /galNorm DgalE -im_Zpm.\nrewrite morphimEdom big_imset /=; last exact/injmP/injm_Zpm.\nby apply: eq_bigl => j /=; rewrite mem_Zp ?order_gt1.\nQed."
}
{
  "statement": "Lemma dvdn_orderC x n : (#[x]%C %| n)%N = (x ^+ n == 1).\n",
  "proof": "Proof.\napply/idP/eqP=> [|x_n_1]; first by apply: expr_dvd; apply: exp_orderC.\nhave [-> | n_gt0] := posnP n; first by rewrite dvdn0.\nhave [m prim_x m_dv_n] := prim_order_exists n_gt0 x_n_1.\nhave{n_gt0} m_gt0 := dvdn_gt0 n_gt0 m_dv_n; congr (_ %| n)%N: m_dv_n.\npose p := minCpoly x; have Dp: p = cyclotomic x m := minCpoly_cyclotomic prim_x.\nrewrite /orderC; case: pickP => /= [k /eqP Dp_k | no_k]; last first.\n  suffices lt_m_2p: (m < 2 * size p ^ 2)%N.\n    have /eqP[] := no_k (Ordinal lt_m_2p).\n    by rewrite /= -/p Dp -Cintr_Cyclotomic.\n  rewrite Dp size_cyclotomic (sqrnD 1) addnAC mulnDr -add1n leq_add //.\n  suffices: (m <= \\prod_(q <- primes m | q == 2) q * totient m ^ 2)%N.\n    have [m_even | m_odd] := boolP (2%N \\in primes m).\n      by rewrite -big_filter filter_pred1_uniq ?primes_uniq // big_seq1.\n    by rewrite big_hasC ?has_pred1 // => /leq_trans-> //; apply: leq_addl.\n  rewrite big_mkcond totientE // -mulnn -!big_split /=.\n  rewrite {1}[m]prod_prime_decomp // prime_decompE big_map /= !big_seq.\n  elim/big_ind2: _ => // [n1 m1 n2 m2 | q]; first exact: leq_mul.\n  rewrite mem_primes => /and3P[q_pr _ q_dv_m].\n  rewrite lognE q_pr m_gt0 q_dv_m /=; move: (logn q _) => k.\n  rewrite !mulnA expnS leq_mul //.\n  case: (ltngtP q 2) (prime_gt1 q_pr) => // [q_gt2|->] _.\n    rewrite mul1n mulnAC mulnn -{1}[q]muln1 leq_mul ?expn_gt0 ?prime_gt0 //.\n    by rewrite -(subnKC q_gt2) (ltn_exp2l 1).\n  by rewrite !muln1 -expnS (ltn_exp2l 0).\nhave k_prim_x: k.-primitive_root x.\n  have k_gt0: (0 < k)%N.\n    rewrite lt0n; apply: contraTneq (size_minCpoly x) => k0.\n    by rewrite Dp_k k0 Cyclotomic0 rmorph1 size_poly1.\n  have [z prim_z] := C_prim_root_exists k_gt0.\n  rewrite -(root_cyclotomic prim_z) -Cintr_Cyclotomic //.\n  by rewrite -Dp_k root_minCpoly.\napply/eqP; rewrite eqn_dvd !(@prim_order_dvd _ _ x) //.\nby rewrite !prim_expr_order ?eqxx.\nQed."
}
{
  "statement": "Lemma mul_card_Ohm_Mho_abelian n G :\n  abelian G -> (#|'Ohm_n(G)| * #|'Mho^n(G)|)%N = #|G|.\n",
  "proof": "Proof.\ncase/abelian_structure => b defG _.\nelim: b G defG => [_ <-|x b IHb G].\n  by rewrite !big_nil (trivgP (Ohm_sub _ _)) (trivgP (Mho_sub _ _)) !cards1.\nrewrite big_cons => defG; rewrite -(dprod_card defG).\nrewrite -(dprod_card (Ohm_dprod n defG)) -(dprod_card (Mho_dprod n defG)) /=.\nrewrite mulnCA -!mulnA mulnCA mulnA; case/dprodP: defG => [[_ H _ defH] _ _ _].\nrewrite defH {b G defH IHb}(IHb H defH); congr (_ * _)%N => {H}.\nhave [m] := ubnP #[x]; elim: m x => // m IHm x /ltnSE-lexm.\ncase p_x: (p_group <[x]>); last first.\n  case: (eqVneq x 1) p_x => [-> |]; first by rewrite cycle1 p_group1.\n  rewrite -order_gt1 /p_group -orderE; set p := pdiv _ => ntx p'x.\n  have def_x: <[x.`_p]> \\x <[x.`_p^']> = <[x]>.\n    have ?: coprime #[x.`_p] #[x.`_p^'] by rewrite !order_constt coprime_partC.\n    have ?: commute x.`_p x.`_p^' by apply: commuteX2.\n    rewrite dprodE ?coprime_TIg -?cycleM ?consttC //.\n    by rewrite cent_cycle cycle_subG; apply/cent1P.\n  rewrite -(dprod_card (Ohm_dprod n def_x)) -(dprod_card (Mho_dprod n def_x)).\n  rewrite mulnCA -mulnA mulnCA mulnA.\n  rewrite !{}IHm ?(dprod_card def_x) ?(leq_trans _ lexm) {m lexm}//.\n    rewrite /order -(dprod_card def_x) -!orderE !order_constt ltn_Pmull //.\n    rewrite p_part -(expn0 p) ltn_exp2l 1?lognE ?prime_gt1 ?pdiv_prime //.\n    by rewrite order_gt0 pdiv_dvd.\n  rewrite proper_card // properEneq cycle_subG mem_cycle andbT.\n  by apply: contra (negbT p'x); move/eqP <-; apply: p_elt_constt.\ncase/p_groupP: p_x => p p_pr p_x.\nrewrite (Ohm_p_cycle n p_x) (Mho_p_cycle n p_x) -!orderE.\nset k := logn p #[x]; have ox: #[x] = (p ^ k)%N by rewrite -card_pgroup.\ncase: (leqP k n) => [le_k_n | lt_n_k].\n  rewrite -(subnKC le_k_n) subnDA subnn expg1 expnD expgM -ox.\n  by rewrite expg_order expg1n order1 muln1.\nrewrite !orderXgcd ox -[in (p ^ k)%N](subnKC (ltnW lt_n_k)) expnD.\nrewrite gcdnC gcdnMl gcdnC gcdnMr.\nby rewrite mulnK ?mulKn ?expn_gt0 ?prime_gt0.\nQed."
}
{
  "statement": "Lemma det_Vandermonde (R : comPzRingType) (n : nat) (a : 'rV[R]_n) :\n  \\det (Vandermonde n a) = \\prod_(i < n) \\prod_(j < n | i < j) (a 0 j - a 0 i).\n",
  "proof": "Proof.\nset V := @Vandermonde R.\nelim: n => [|n IHn] in a *; first by rewrite det_mx00 big1// => -[] [].\npose b : 'rV_n := \\row_i a 0 (lift 0 i).\npose C : 'M_n := diag_mx (\\row_(i < n) (b 0 i - a 0 0)).\npose D : 'M_n.+1 := 1 - a 0 0 *: \\matrix_(i, j) (i == j.+1 :> nat)%:R. \nhave detD : \\det D = 1.\n  rewrite det_trig ?big_ord_recl ?mxE ?mulr0 ?subr0 ?eqxx.\n    by rewrite ?big1 ?mulr1// => i; rewrite !mxE eqxx ltn_eqF// mulr0 subr0.\n  by apply/is_trig_mxP => *; rewrite !mxE ![_ == _]ltn_eqF ?mulr0 ?subr0 ?leqW.\nsuff: D * V _ _ a = block_mx 1 (const_mx 1) 0 (V _ _ b *m C) :> 'M_(1 + n).\n  move=> /(congr1 determinant); rewrite detM detD mul1r => ->.\n  rewrite det_ublock det1 mul1r det_mulmx IHn big_ord_recl mulrC; congr (_ * _).\n    rewrite big_mkcond big_ord_recl/= mul1r det_diag.\n    by under eq_bigr do rewrite !mxE.\n  apply: eq_bigr => i _; under eq_bigr do rewrite !mxE.\n  by rewrite big_mkcond [RHS]big_mkcond big_ord_recl/= mul1r.\nrewrite mulrBl mul1r -[_ * _]scalemxAl; apply/matrixP => i j; rewrite !mxE.\nunder eq_bigr do rewrite !mxE; case: splitP => [{i}_ -> /[!ord1]|{}i ->].\n  rewrite !expr0 big1; last by move=> ?; rewrite mul0r.\n  by rewrite ?mulr0 ?subr0 ?mxE; case: splitP => k; rewrite ?ord1 mxE//.\nunder eq_bigr do rewrite eqSS mulr_natl mulrb eq_sym.\nrewrite -big_mkcond/= big_ord1_eq exprS ifT// ?leqW// -mulrBl !mxE/=.\ncase: split_ordP => [{j}_ -> /[!ord1]|{}j ->]; rewrite ?lshift0 ?rshift1 ?mxE.\n   by rewrite ?subrr ?mul0r//.\nunder eq_bigr do rewrite !mxE mulrnAr mulrb.\nby rewrite -big_mkcond big_pred1_eq /= mulrC.\nQed."
}
{
  "statement": "Lemma Ohm_Mho_homocyclic (n p : nat) G :\n    abelian G -> p.-group G -> 0 < n < logn p (exponent G) ->\n  'Ohm_n(G) = 'Mho^(logn p (exponent G) - n)(G) -> homocyclic G.\n",
  "proof": "Proof.\nset e := exponent G => cGG pG /andP[n_gt0 n_lte] eq_Ohm_Mho.\nsuffices: all (pred1 e) (abelian_type G).\n  by rewrite /homocyclic cGG; apply: all_pred1_constant.\ncase/abelian_structure: cGG (abelian_type_gt1 G) => b defG <-.\nset H := G in defG eq_Ohm_Mho *; have sHG: H \\subset G by [].\nelim: b H defG sHG eq_Ohm_Mho => //= x b IHb H.\nrewrite big_cons => defG; case/dprodP: defG (defG) => [[_ K _ defK]].\nrewrite defK => defHm cxK; rewrite setIC => /trivgP-tiKx defHd.\nrewrite -{}[in H \\subset G]defHm mulG_subG cycle_subG ltnNge -trivg_card_le1.\ncase/andP=> Gx sKG; rewrite -(Mho_dprod _ defHd) => /esym defMho /andP[ntx ntb].\nhave{defHd} defOhm := Ohm_dprod n defHd.\napply/andP; split; last first.\n  apply: (IHb K) => //; have:= dprod_modr defMho (Mho_sub _ _).\n  rewrite -(dprod_modr defOhm (Ohm_sub _ _)).\n  rewrite !(trivgP (subset_trans (setIS _ _) tiKx)) ?Ohm_sub ?Mho_sub //.\n  by rewrite !dprod1g.\nhave:= dprod_modl defMho (Mho_sub _ _).\nrewrite -(dprod_modl defOhm (Ohm_sub _ _)) .\nrewrite !(trivgP (subset_trans (setSI _ _) tiKx)) ?Ohm_sub ?Mho_sub //.\nmove/eqP; rewrite eqEcard => /andP[_].\nhave p_x: p.-elt x := mem_p_elt pG Gx.\nhave [p_pr p_dv_x _] := pgroup_pdiv p_x ntx.\nrewrite !dprodg1 (Ohm_p_cycle _ p_x) (Mho_p_cycle _ p_x) -!orderE.\nrewrite orderXdiv ?leq_divLR ?pfactor_dvdn ?leq_subr //.\nrewrite orderXgcd divn_mulAC ?dvdn_gcdl // leq_divRL ?gcdn_gt0 ?order_gt0 //.\nrewrite leq_pmul2l //; apply: contraLR.\nrewrite eqn_dvd dvdn_exponent //= -ltnNge => lt_x_e.\nrewrite (leq_trans (ltn_Pmull (prime_gt1 p_pr) _)) ?expn_gt0 ?prime_gt0 //.\nrewrite -expnS dvdn_leq // ?gcdn_gt0 ?order_gt0 // dvdn_gcd.\nrewrite pfactor_dvdn // dvdn_exp2l.\n  by rewrite -[ltnRHS]subn0 ltn_sub2l // lognE p_pr order_gt0 p_dv_x.\nrewrite ltn_sub2r // ltnNge -(dvdn_Pexp2l _ _ (prime_gt1 p_pr)) -!p_part.\nby rewrite !part_pnat_id // (pnat_dvd (exponent_dvdn G)).\nQed."
}
{
  "statement": "Lemma diagonalizablePeigen {n} {A : 'M[F]_n} :\n  diagonalizable A <->\n  exists2 rs, uniq rs & (\\sum_(r <- rs) eigenspace A r :=: 1%:M)%MS.\n",
  "proof": "Proof.\nsplit=> [df|[rs urs rsP]].\n  suff [rs rsP] : exists rs, (\\sum_(r <- rs) eigenspace A r :=: 1%:M)%MS.\n    exists (undup rs); rewrite ?undup_uniq//; apply: eqmx_trans rsP.\n    elim: rs => //= r rs IHrs; rewrite big_cons.\n    case: ifPn => in_rs; rewrite ?big_cons; last exact: adds_eqmx.\n    apply/(eqmx_trans IHrs)/eqmx_sym/addsmx_idPr.\n    have rrs : (index r rs < size rs)%N by rewrite index_mem.\n    rewrite (big_nth 0) big_mkord (sumsmx_sup (Ordinal rrs)) ?nth_index//.\n  move: df => [P Punit /(diagonalizable_forLR Punit)[d ->]].\n  exists [seq d 0 i | i <- enum 'I_n]; rewrite big_image/=.\n  apply: (@eqmx_trans _ _ _ _ _ _ P); apply/eqmxP;\n    rewrite ?sub1mx ?submx1 ?row_full_unit//.\n  rewrite submx_full ?row_full_unit//=.\n  apply/row_subP => i; rewrite rowE (sumsmx_sup i)//.\n  apply/eigenspaceP; rewrite conjVmx// !mulmxA mulmxK//.\n  by rewrite -rowE row_diag_mx scalemxAl.\nhave mxdirect_eigenspaces : mxdirect (\\sum_(i < size rs) eigenspace A rs`_i).\n  apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\nrewrite (big_nth 0) big_mkord in rsP; apply/codiagonalizable1.\napply/(codiagonalizable_on _ mxdirect_eigenspaces) => // i/=.\n  case: n => [|n] in A {mxdirect_eigenspaces} rsP *.\n    by rewrite thinmx0 sub0mx.\n  by rewrite comm_mx_stable_eigenspace.\napply/codiagonalizable1.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i); first exact: diagonalizable_scalar.\n  by rewrite eq_row_base.\nby rewrite row_base_free.\nQed."
}
{
  "statement": "Lemma Qn_aut_exists k n :\n    coprime k n ->\n  {u : {rmorphism algC -> algC} | forall z, z ^+ n = 1 -> u z = z ^+ k}.\n",
  "proof": "Proof.\nhave [-> /eqnP | n_gt0 co_k_n] := posnP n.\n  by rewrite gcdn0 => ->; exists idfun.\nhave [z prim_z] := C_prim_root_exists n_gt0.\nhave [Qn [QnC [[|zn []] // [Dz]]] genQn] := num_field_exists [:: z].\npose phi := kHomExtend 1 \\1 zn (zn ^+ k).\nhave homQn1: kHom 1 1 (\\1%VF : 'End(Qn)) by rewrite kHom1.\nhave pzn_zk0: root (map_poly \\1%VF (minPoly 1 zn)) (zn ^+ k).\n  rewrite -(fmorph_root QnC) rmorphXn /= Dz -map_poly_comp.\n  rewrite (@eq_map_poly _ _ _ QnC) => [|a]; last by rewrite /= id_lfunE.\n  set p1 := map_poly _ _.\n  have [q1 Dp1]: exists q1, p1 = pQtoC q1.\n    have aP i: (minPoly 1 zn)`_i \\in 1%VS.\n      by apply/polyOverP; apply: minPolyOver.\n    have{aP} a_ i := sig_eqW (vlineP _ _ (aP i)).\n    exists (\\poly_(i < size (minPoly 1 zn)) sval (a_ i)).\n    apply/polyP=> i; rewrite coef_poly coef_map coef_poly /=.\n    case: ifP => _; rewrite ?rmorph0 //; case: (a_ i) => a /= ->.\n    by rewrite alg_num_field fmorph_rat.\n  have: root p1 z by rewrite -Dz fmorph_root root_minPoly.\n  rewrite Dp1; have [q2 [Dq2 _] ->] := minCpolyP z.\n  case/dvdpP=> r1 ->; rewrite rmorphM rootM /= -Dq2; apply/orP; right.\n  rewrite (minCpoly_cyclotomic prim_z) /cyclotomic.\n  rewrite (bigD1 (Ordinal (ltn_pmod k n_gt0))) ?coprime_modl //=.\n  by rewrite rootM root_XsubC prim_expr_mod ?eqxx.\nhave phim : multiplicative phi.\n  by apply/kHom_lrmorphism; rewrite -genQn span_seq1 /= kHomExtendP.\npose phimM := GRing.isMultiplicative.Build _ _ phi phim.\npose phiRM : {rmorphism _ -> _} := HB.pack (fun_of_lfun phi) phimM.\nhave [nu Dnu] := extend_algC_subfield_aut QnC phiRM.\nexists nu => _ /(prim_rootP prim_z)[i ->].\nrewrite rmorphXn /= exprAC -Dz -Dnu /= -{1}[zn]hornerX /phi.\nrewrite (kHomExtend_poly homQn1) ?polyOverX //.\nrewrite map_polyE map_id_in => [|?]; last by rewrite id_lfunE.\nby rewrite polyseqK hornerX rmorphXn.\nQed."
}
{
  "statement": "Lemma subseqP s1 s2 :\n  reflect (exists2 m, size m = size s2 & s1 = mask m s2) (subseq s1 s2).\n",
  "proof": "Proof.\nelim: s2 s1 => [|y s2 IHs2] [|x s1].\n- by left; exists [::].\n- by right=> -[m /eqP/nilP->].\n- by left; exists (nseq (size s2).+1 false); rewrite ?size_nseq //= mask_false.\napply: {IHs2}(iffP (IHs2 _)) => [] [m sz_m def_s1].\n  by exists ((x == y) :: m); rewrite /= ?sz_m // -def_s1; case: eqP => // ->.\ncase: eqP => [_ | ne_xy]; last first.\n  by case: m def_s1 sz_m => [|[] m] //; [case | move=> -> [<-]; exists m].\npose i := index true m; have def_m_i: take i m = nseq (size (take i m)) false.\n  apply/all_pred1P; apply/(all_nthP true) => j.\n  rewrite size_take ltnNge geq_min negb_or -ltnNge => /andP[lt_j_i _].\n  rewrite nth_take //= -negb_add addbF -addbT -negb_eqb.\n  by rewrite [_ == _](before_find _ lt_j_i).\nhave lt_i_m: i < size m.\n  rewrite ltnNge; apply/negP=> le_m_i; rewrite take_oversize // in def_m_i.\n  by rewrite def_m_i mask_false in def_s1.\nrewrite size_take lt_i_m in def_m_i.\nexists (take i m ++ drop i.+1 m).\n  rewrite size_cat size_take size_drop lt_i_m.\n  by rewrite sz_m in lt_i_m *; rewrite subnKC.\nrewrite {s1 def_s1}[s1](congr1 behead def_s1).\nrewrite -[s2](cat_take_drop i) -[m in LHS](cat_take_drop i) {}def_m_i -cat_cons.\nhave sz_i_s2: size (take i s2) = i by apply: size_takel; rewrite sz_m in lt_i_m.\nrewrite lastI cat_rcons !mask_cat ?size_nseq ?size_belast ?mask_false //=.\nby rewrite (drop_nth true) // nth_index -?index_mem.\nQed."
}
{
  "statement": "Lemma cfdot_bigdprod phi psi :\n  '[cfBigdprod phi, cfBigdprod psi] = \\prod_(i | P i) '[phi i, psi i].\n",
  "proof": "Proof.\napply: canLR (mulKf (neq0CG G)) _; rewrite -(bigdprod_card defG).\nrewrite (big_morph _ (@natrM _) (erefl _)) -big_split /=.\nrewrite (eq_bigr _ (fun i _ => mulVKf (neq0CG _) _)) (big_distr_big_dep 1%g) /=.\nset F := pfamily _ _ _; pose h (f : {ffun I -> gT}) := (\\prod_(i | P i) f i)%g.\npose is_hK x f := forall f1, (f1 \\in F) && (h f1 == x) = (f == f1).\nhave /fin_all_exists[h1 Dh1] x: exists f, x \\in G -> is_hK x f.\n  case Gx: (x \\in G); last by exists [ffun _ => x].\n  have [f [Af fK Uf]] := mem_bigdprod defG Gx.\n  exists [ffun i => if P i then f i else 1%g] => _ f1.\n  apply/andP/eqP=> [[/pfamilyP[Pf1 Af1] /eqP Dx] | <-].\n    by apply/ffunP=> i; rewrite ffunE; case: ifPn => [/Uf-> | /(supportP Pf1)].\n  split; last by rewrite fK; apply/eqP/eq_bigr=> i Pi; rewrite ffunE Pi.\n  by apply/familyP=> i; rewrite ffunE !unfold_in; case: ifP => //= /Af.\nrewrite (reindex_onto h h1) /= => [|x /Dh1/(_ (h1 x))]; last first.\n  by rewrite eqxx => /andP[_ /eqP].\napply/eq_big => [f | f /andP[/Dh1<- /andP[/pfamilyP[_ Af] _]]]; last first.\n  by rewrite !cfBigdprodE // rmorph_prod -big_split /=.\napply/idP/idP=> [/andP[/Dh1<-] | Ff]; first by rewrite eqxx andbT.\nhave /pfamilyP[_ Af] := Ff; suffices Ghf: h f \\in G by rewrite -Dh1 ?Ghf ?Ff /=.\nby apply/group_prod=> i Pi; rewrite (subsetP (sAG Pi)) ?Af.\nQed."
}
{
  "statement": "Lemma trans_subnorm_fixP x G H S :\n  let C := 'C_G[x | to] in let T := 'Fix_(S | to)(H) in\n    [transitive G, on S | to] -> x \\in S -> H \\subset C ->\n  reflect ((H :^: G) ::&: C = H :^: C) [transitive 'N_G(H), on T | to].\n",
  "proof": "Proof.\nmove=> C T trGS Sx sHC; have actGS := acts_act (atrans_acts trGS).\nhave:= sHC; rewrite subsetI sub_astab1 => /andP[sHG cHx].\nhave Tx: x \\in T by rewrite inE Sx.\napply: (iffP idP) => [trN | trC].\n  apply/setP=> Ha; apply/setIdP/imsetP=> [[]|[a Ca ->{Ha}]]; last first.\n    by rewrite conj_subG //; case/setIP: Ca => Ga _; rewrite imset_f.\n  case/imsetP=> a Ga ->{Ha}; rewrite subsetI !sub_conjg => /andP[_ sHCa].\n  have Txa: to x a^-1 \\in T.\n    by rewrite inE -sub_astab1 astab1_act actGS ?Sx ?groupV.\n  have [b] := atransP2 trN Tx Txa; case/setIP=> Gb nHb cxba.\n  exists (b * a); last by rewrite conjsgM (normP nHb).\n  by rewrite inE groupM //; apply/astab1P; rewrite actM -cxba actKV.\napply/imsetP; exists x => //; apply/setP=> y; apply/idP/idP=> [Ty|].\n  have [Sy cHy]:= setIP Ty; have [a Ga defy] := atransP2 trGS Sx Sy.\n  have: H :^ a^-1 \\in H :^: C.\n    rewrite -trC inE subsetI imset_f 1?conj_subG ?groupV // sub_conjgV.\n    by rewrite -astab1_act -defy sub_astab1.\n  case/imsetP=> b /setIP[Gb /astab1P cxb] defHb.\n  rewrite defy -{1}cxb -actM mem_orbit // inE groupM //.\n  by apply/normP; rewrite conjsgM -defHb conjsgKV.\ncase/imsetP=> a /setIP[Ga nHa] ->{y}.\nby rewrite inE actGS // Sx (acts_act (acts_fix_norm _) nHa).\nQed."
}
{
  "statement": "Lemma card_perm A : #|perm_on A| = (#|A|)`!.\n",
  "proof": "Proof.\npose ffA := {ffun {x | x \\in A} -> T}.\nrewrite -ffactnn -{2}(card_sig [in A]) /= -card_inj_ffuns_on.\npose fT (f : ffA) := [ffun x => oapp f x (insub x)].\npose pfT f := insubd (1 : {perm T}) (fT f).\npose fA s : ffA := [ffun u => s (val u)].\nrewrite -!sum1dep_card -sum1_card (reindex_onto fA pfT) => [|f].\n  apply: eq_bigl => p; rewrite andbC; apply/idP/and3P=> [onA | []]; first split.\n  - apply/eqP; suffices fTAp: fT (fA p) = pval p.\n      by apply/permP=> x; rewrite -!pvalE insubdK fTAp //; apply: (valP p).\n    apply/ffunP=> x; rewrite ffunE pvalE.\n    by case: insubP => [u _ <- | /out_perm->] //=; rewrite ffunE.\n  - by apply/forallP=> [[x Ax]]; rewrite ffunE /= perm_closed.\n  - by apply/injectiveP=> u v; rewrite !ffunE => /perm_inj; apply: val_inj.\n  move/eqP=> <- _ _; apply/subsetP=> x; rewrite !inE -pvalE val_insubd fun_if.\n  by rewrite if_arg ffunE; case: insubP; rewrite // pvalE perm1 if_same eqxx.\ncase/andP=> /forallP-onA /injectiveP-f_inj.\napply/ffunP=> u; rewrite ffunE -pvalE insubdK; first by rewrite ffunE valK.\napply/injectiveP=> {u} x y; rewrite !ffunE.\ncase: insubP => [u _ <-|]; case: insubP => [v _ <-|] //=; first by move/f_inj->.\n  by move=> Ay' def_y; rewrite -def_y [_ \\in A]onA in Ay'.\nby move=> Ax' def_x; rewrite def_x [_ \\in A]onA in Ax'.\nQed."
}
{
  "statement": "Lemma separable_inseparable_decomposition E K :\n  {x | x \\in E /\\ separable_element K x & purely_inseparable <<K; x>> E}.\n",
  "proof": "Proof.\nwithout loss sKE: K / (K <= E)%VS.\n  case/(_ _ (capvSr K E)) => x [Ex sepKEx] /purely_inseparableP sep'KExE.\n  exists x; first by split; last exact/(separable_elementS _ sepKEx)/capvSl.\n  apply/purely_inseparableP=> y /sep'KExE; apply: sub_inseparable.\n  exact/adjoinSl/capvSl.\npose E_ i := (vbasis E)`_i; pose fP i := separable_exponent_pchar K (E_ i).\npose f i := E_ i ^+ ex_minn (fP i); pose s := mkseq f (\\dim E).\npose K' := <<K & s>>%VS.\nhave sepKs: all (separable_element K) s.\n  by rewrite all_map /f; apply/allP=> i _ /=; case: ex_minnP => m /andP[].\nhave [x sepKx defKx]: {x | x \\in E /\\ separable_element K x & K' = <<K; x>>%VS}.\n  have: all [in E] s.\n    rewrite all_map; apply/allP=> i; rewrite mem_iota => ltis /=.\n    by rewrite rpredX // vbasis_mem // memt_nth.\n  rewrite {}/K'; elim/last_ind: s sepKs => [|s t IHs].\n    by exists 0; [rewrite base_separable mem0v | rewrite adjoin_nil addv0].\n  rewrite adjoin_rcons !all_rcons => /andP[sepKt sepKs] /andP[/= Et Es].\n  have{IHs sepKs Es} [y [Ey sepKy] ->{s}] := IHs sepKs Es.\n  have /sig_eqW[x defKx] := Primitive_Element_Theorem t sepKy.\n  exists x; [split | exact: defKx].\n    suffices: (<<K; x>> <= E)%VS by case/FadjoinP.\n    by rewrite -defKx !(sameP FadjoinP andP) sKE Ey Et.\n  apply/adjoin_separableP=> z; rewrite -defKx => Kyt_z.\n  apply: adjoin_separable sepKy _; apply: adjoin_separableP Kyt_z.\n  exact: separable_elementS (subv_adjoin K y) sepKt.\nexists x; rewrite // -defKx; apply/(all_nthP 0)=> i; rewrite size_tuple => ltiE.\napply/purely_inseparable_elementP_pchar.\nexists (ex_minn (fP i)); first by case: ex_minnP => n /andP[].\nby apply/seqv_sub_adjoin/map_f; rewrite mem_iota.\nQed."
}
{
  "statement": "Lemma Derivation_separableP :\n  reflect\n    (forall D, Derivation <<K; x>> D -> K <= lker D -> <<K; x>> <= lker D)%VS\n    (separable_element K x).\n",
  "proof": "Proof.\napply: (iffP idP) => [sepKx D derD /subvP DK_0 | derKx_0].\n  have{} DK_0 q: q \\is a polyOver K -> map_poly D q = 0.\n    move=> /polyOverP Kq; apply/polyP=> i; apply/eqP.\n    by rewrite coef0 coef_map -memv_ker DK_0.\n  apply/subvP=> _ /Fadjoin_polyP[p Kp ->]; rewrite memv_ker.\n  rewrite (Derivation_horner derD) ?(polyOverSv sKxK) //.\n  rewrite (Derivation_separable derD sepKx) !DK_0 ?minPolyOver //.\n  by rewrite horner0 oppr0 mul0r mulr0 addr0.\napply: wlog_neg; rewrite {1}separable_nz_der negbK => /eqP pKx'_0.\npose Df := fun y => (Fadjoin_poly K x y)^`().[x].\nhave Dlin: linear Df.\n  move=> a u v; rewrite /Df linearP /= -mul_polyC derivD derivM derivC.\n  by rewrite mul0r add0r hornerD hornerM hornerC -scalerAl mul1r.\npose DlinM := GRing.isLinear.Build _ _ _ _ Df Dlin.\npose DL : {linear _ -> _} := HB.pack Df DlinM.\npose D := linfun DL; apply: base_separable.\nhave DK_0: (K <= lker D)%VS.\n  apply/subvP=> v Kv; rewrite memv_ker lfunE /= /Df Fadjoin_polyC //.\n  by rewrite derivC horner0.\nhave Dder: Derivation <<K; x>> D.\n  apply/allrelP=> u v /vbasis_mem Kx_u /vbasis_mem Kx_v; apply/eqP.\n  rewrite !lfunE /= /Df; set Px := Fadjoin_poly K x.\n  set Px_u := Px u; rewrite -(Fadjoin_poly_eq Kx_u) -/Px -/Px_u.\n  set Px_v := Px v; rewrite -(Fadjoin_poly_eq Kx_v) -/Px -/Px_v.\n  rewrite -!hornerM -hornerD -derivM.\n  rewrite /Px Fadjoin_poly_mod ?rpredM ?Fadjoin_polyOver //.\n  rewrite [in RHS](divp_eq (Px_u * Px_v) (minPoly K x)) derivD derivM.\n  by rewrite pKx'_0 mulr0 addr0 hornerD hornerM minPolyxx mulr0 add0r.\nhave{Dder DK_0}: x \\in lker D by apply: subvP Kx_x; apply: derKx_0.\napply: contraLR => K'x; rewrite memv_ker lfunE /= /Df Fadjoin_polyX //.\nby rewrite derivX hornerC oner_eq0.\nQed."
}
{
  "statement": "Lemma card_partial_ord_partitions m n :\n  #|[set t : m.-tuple 'I_n.+1 | \\sum_(i <- t) i <= n]| = 'C(m + n, m).\n",
  "proof": "Proof.\nsymmetry; set In1 := 'I_n.+1; pose x0 : In1 := ord0.\npose add_mn (i j : In1) : In1 := inord (i + j).\npose f_add (t : m.-tuple In1) := [tuple of scanl add_mn x0 t].\nrewrite -card_sorted_tuples -!sum1dep_card (reindex f_add) /=.\n  apply: eq_bigl => t; rewrite -[\\sum_(i <- t) i]add0n.\n  transitivity (path leq x0 (map val (f_add t))) => /=; first by case: map.\n  rewrite -{1 2}[0]/(val x0); elim: {t}(val t) (x0) => /= [|x t IHt] s.\n    by rewrite big_nil addn0 -ltnS ltn_ord.\n  rewrite big_cons addnA IHt /= val_insubd ltnS.\n  have [_ | ltn_n_sx] := leqP (s + x) n; first by rewrite leq_addr.\n  rewrite -(leq_add2r x) leqNgt (leq_trans (valP x)) //=.\n  by rewrite leqNgt (leq_trans ltn_n_sx) ?leq_addr.\npose sub_mn (i j : In1) := Ordinal (leq_ltn_trans (leq_subr i j) (valP j)).\nexists (fun t : m.-tuple In1 => [tuple of pairmap sub_mn x0 t]) => /= t inc_t.\n  apply: val_inj => /=; have{inc_t}: path leq x0 (map val (f_add t)).\n    by move: inc_t; rewrite inE /=; case: map.\n  rewrite [map _ _]/=; elim: {t}(val t) (x0) => //= x t IHt s.\n  case/andP=> le_s_sx /IHt->; congr (_ :: _); apply: val_inj => /=.\n  move: le_s_sx; rewrite val_insubd.\n  case le_sx_n: (_ < n.+1); first by rewrite addKn.\n  by case: (val s) le_sx_n; rewrite ?ltn_ord.\napply: val_inj => /=; have{inc_t}: path leq x0 (map val t).\n  by move: inc_t; rewrite inE /=; case: map.\nelim: {t}(val t) (x0) => //= x t IHt s /andP[le_s_sx inc_t].\nsuffices ->: add_mn s (sub_mn s x) = x by rewrite IHt.\nby apply: val_inj; rewrite /add_mn /= subnKC ?inord_val.\nQed."
}
{
  "statement": "Lemma modular_group_classP :\n  extremal_class G = ModularGroup\n     <-> (exists2 p, prime p &\n          exists2 n, n >= (p == 2) + 3 & G \\isog 'Mod_(p ^ n)).\n",
  "proof": "Proof.\nrewrite /extremal_class; split=> [ | [p p_pr [n n_gt23 isoG]]].\n  move: (pdiv _) => p; set n := logn p _; do 4?case: ifP => //.\n  case/andP=> n_gt2 isoG _ _; rewrite ltnW //= => not_isoG _.\n  exists p; first by move: n_gt2; rewrite /n lognE; case (prime p).\n  exists n => //; case: eqP => // p2; rewrite ltn_neqAle; case: eqP => // n3.\n  by case/idP: not_isoG; rewrite p2 -n3 in isoG *.\nhave n_gt2 := leq_trans (leq_addl _ _) n_gt23; have n_gt1 := ltnW n_gt2.\nhave n_gt0 := ltnW n_gt1; have def_n := prednK n_gt0.\nhave [[x y] genG mod_xy] := generators_modular_group p_pr n_gt2 isoG.\ncase/modular_group_structure: (genG) => // _ _ [_ _ nil2G] _ _.\nhave [oG _ _ _] := genG; have [oy _] := mod_xy.\nrewrite oG -def_n pdiv_pfactor // def_n pfactorK // n_gt1 n_gt2 {}isoG /=.\ncase: (ltngtP p 2) => [|p_gt2|p2]; first by rewrite ltnNge prime_gt1.\n  rewrite !(isog_sym G) !isogEcard card_2dihedral ?card_quaternion //= oG.\n  rewrite leq_exp2r // leqNgt p_gt2 !andbF; case: and3P=> // [[n_gt3 _]].\n  by rewrite card_semidihedral // leq_exp2r // leqNgt p_gt2.\nrewrite p2 in genG oy n_gt23; rewrite n_gt23.\nhave: nil_class G <> n.-1.\n  by apply/eqP; rewrite neq_ltn -ltnS nil2G def_n n_gt23.\ncase: ifP => [isoG | _]; first by case/dihedral2_structure: genG => // _ [].\ncase: ifP => [isoG | _]; first by case/quaternion_structure: genG => // _ [].\nby case: ifP => // isoG; case/semidihedral_structure: genG => // _ [].\nQed."
}
{
  "statement": "Lemma rank_Dn n : 'r_2('D^n) = n.+1.\n",
  "proof": "Proof.\nelim: n => [|n IHn]; first by rewrite p_rank_abelem ?prime_abelem ?card_pX1p2n.\nhave oDDn: #|'D^n.+1| = (2 ^ n.+1.*2.+1)%N by apply: card_pX1p2n.\nhave esDDn: extraspecial 'D^n.+1 by apply: pX1p2n_extraspecial.\ndo [case: pX1p2S => gz isoZ; set DDn := [set: _]] in oDDn esDDn *.\nhave pDDn: 2.-group DDn by rewrite /pgroup oDDn pnatX.\napply/eqP; rewrite eqn_leq; apply/andP; split.\n  have [E EprE]:= p_rank_witness 2 [group of DDn].\n  have [sEDDn abelE <-] := pnElemP EprE; have [pE cEE _]:= and3P abelE.\n  rewrite -(@leq_exp2l 2) // -p_part part_pnat_id // -leq_sqr -expnM -mulnn.\n  rewrite muln2 doubleS expnS -oDDn -(@leq_pmul2r #|'C_DDn(E)|) ?cardG_gt0 //.\n  rewrite {1}(card_subcent_extraspecial pDDn) // mulnCA -mulnA Lagrange //=.\n  rewrite mulnAC mulnA leq_pmul2r ?cardG_gt0 // setTI.\n  have ->: (2 * #|'C(E)| = #|'Z(DDn)| * #|'C(E)|)%N.\n    by rewrite (card_center_extraspecial pDDn).\n  by rewrite leq_mul ?subset_leq_card ?subsetIl.\nhave [inj1 injn] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\npose D := cpairg1 isoZ @* 2^{1+2}; pose Dn := cpair1g isoZ @* 'D^n.\nhave [E EprE] := p_rank_witness 2 [group of Dn].\nrewrite injm_p_rank //= IHn in EprE; have [sEDn abelE dimE]:= pnElemP EprE.\nhave [x [Dx ox] notDnx]: exists x, [/\\ x \\in D, #[x] = 2 & x \\notin Dn].\n  have isoD: D \\isog 'D_(2 ^ 3).\n    by rewrite isog_sym -(isog_transl _ isog_2X1p2) sub_isog.\n  have [//| [x y] genD [oy _]] := generators_2dihedral _ isoD.\n  have [_ _ _ X'y] := genD; case/setDP: X'y; rewrite /= -/D => Dy notXy.\n  exists y; split=> //; apply: contra notXy => Dny.\n  case/dihedral2_structure: genD => // _ _ _ _ [defZD _ _ _ _].\n  by rewrite (subsetP (cycleX x 2)) // -defZD -setI_im_cpair inE Dy.\nhave def_xE: <[x]> \\x E = <[x]> <*> E.\n  rewrite dprodEY ?prime_TIg -?orderE ?ox //.\n    by rewrite (centSS sEDn _ (im_cpair_cent _)) ?cycle_subG.\n  by rewrite cycle_subG (contra (subsetP sEDn x)).\napply/p_rank_geP; exists (<[x]> <*> E)%G.\nrewrite 2!inE subsetT (dprod_abelem _ def_xE) abelE -(dprod_card def_xE).\nby rewrite prime_abelem -?orderE ?ox //= lognM ?cardG_gt0 ?dimE.\nQed."
}
{
  "statement": "Lemma group_num_field_exists (gT : finGroupType) (G : {group gT}) :\n  {Qn : splittingFieldType rat & galois 1 {:Qn} &\n    {QnC : {rmorphism Qn -> algC}\n         & forall nuQn : argumentType [in 'Gal({:Qn} / 1)],\n              {nu : {rmorphism algC -> algC} |\n                 {morph QnC: a / nuQn a >-> nu a}}\n         & {w : Qn & #|G|.-primitive_root w /\\ <<1; w>>%VS = fullv\n              & forall (hT : finGroupType) (H : {group hT}) (phi : 'CF(H)),\n                       phi \\is a character ->\n                       forall x, (#[x] %| #|G|)%N -> {a | QnC a = phi x}}}}.\n",
  "proof": "Proof.\nhave [z prim_z] := C_prim_root_exists (cardG_gt0 G); set n := #|G| in prim_z *.\nhave [Qn [QnC [[|w []] // [Dz] genQn]]] := num_field_exists [:: z].\nhave prim_w: n.-primitive_root w by rewrite -Dz fmorph_primitive_root in prim_z.\nhave Q_Xn1: ('X^n - 1 : {poly Qn}) \\is a polyOver 1%AS.\n  by rewrite rpredB ?rpred1 ?rpredX //= polyOverX.\nhave splitXn1: splittingFieldFor 1 ('X^n - 1) {:Qn}.\n  pose r := codom (fun i : 'I_n => w ^+ i).\n  have Dr: 'X^n - 1 = \\prod_(y <- r) ('X - y%:P).\n    by rewrite -(factor_Xn_sub_1 prim_w) big_mkord big_image.\n  exists r; first by rewrite -Dr eqpxx.\n  apply/eqP; rewrite eqEsubv subvf -genQn adjoin_seqSr //; apply/allP=> /=.\n  by rewrite andbT -root_prod_XsubC -Dr; apply/unity_rootP/prim_expr_order.\nhave Qn_ax : FieldExt_isSplittingField _ Qn by constructor; exists ('X^n - 1).\nexists (HB.pack_for (splittingFieldType rat) Qn Qn_ax).\n  apply/splitting_galoisField.\n  exists ('X^n - 1); split => //.\n  apply: separable_Xn_sub_1; rewrite -(fmorph_eq0 QnC) rmorph_nat.\n  by rewrite pnatr_eq0 -lt0n cardG_gt0.\nexists QnC => [// nuQn|]; first exact: (extend_algC_subfield_aut QnC nuQn).\nrewrite span_seq1 in genQn.\nexists w => // hT H phi Nphi x x_dv_n.\napply: sig_eqW; have [rH ->] := char_reprP Nphi.\nhave [Hx | /cfun0->] := boolP (x \\in H); last by exists 0; rewrite rmorph0.\nhave [e [_ [enx1 _] [-> _] _]] := repr_rsim_diag rH Hx.\nhave /fin_all_exists[k Dk] i: exists k, e 0 i = z ^+ k.\n  have [|k ->] := (prim_rootP prim_z) (e 0 i); last by exists k.\n  by have /dvdnP[q ->] := x_dv_n; rewrite mulnC exprM enx1 expr1n.\nexists (\\sum_i w ^+ k i); rewrite rmorph_sum; apply/eq_bigr => i _.\nby rewrite rmorphXn /= Dz Dk.\nQed."
}
{
  "statement": "Lemma splitting_normalField E K :\n   (K <= E)%VS ->\n  reflect (exists2 p, p \\is a polyOver K & splittingFieldFor K p E)\n          (normalField K E).\n",
  "proof": "Proof.\nmove=> sKE; apply: (iffP idP) => [nKE| [p Kp [rs Dp defE]]]; last first.\n  apply/forall_inP=> g /[!(inE, kAutE)] /andP[homKg _].\n  rewrite -dimv_leqif_eq ?limg_dim_eq ?(eqP (AEnd_lker0 g)) ?capv0 //.\n  rewrite -defE aimg_adjoin_seq; have [_ /fixedSpace_limg->] := andP homKg.\n  apply/adjoin_seqSr=> _ /mapP[a rs_a ->].\n  rewrite -!root_prod_XsubC -!(eqp_root Dp) in rs_a *.\n  by apply: kHom_root_id homKg Kp _ rs_a; rewrite ?subvf ?memvf.\npose splitK a r := minPoly K a = \\prod_(b <- r) ('X - b%:P).\nhave{nKE} rK_ a: {r | a \\in E -> all [in E] r /\\ splitK a r}.\n  case Ea: (a \\in E); last by exists [::].\n  by have /sig2_eqW[r] := normalFieldP _ _ nKE a Ea; exists r.\nhave sXE := basis_mem (vbasisP E); set X : seq L := vbasis E in sXE.\nexists (\\prod_(a <- X) minPoly K a).\n  by apply: rpred_prod => a _; apply: minPolyOver.\nexists (flatten [seq (sval (rK_ a)) | a <- X]).\n  move/allP: sXE; elim: X => [|a X IHX]; first by rewrite !big_nil eqpxx.\n  rewrite big_cons /= big_cat /= => /andP[Ea sXE].\n  by case: (rK_ a) => /= r [] // _ <-; apply/eqp_mull/IHX.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  apply/Fadjoin_seqP; split=> // b /flatten_mapP[a /sXE Ea].\n  by apply/allP; case: rK_ => r /= [].\nrewrite -{1}(span_basis (vbasisP E)); apply/span_subvP=> a Xa.\napply/seqv_sub_adjoin/flatten_mapP; exists a => //; rewrite -root_prod_XsubC.\nby case: rK_ => /= r [| _ <-]; rewrite ?sXE ?root_minPoly.\nQed."
}
{
  "statement": "Lemma Grp : (exists s, [/\\ s \\in Aut B, #[s] %| p & s b = b ^+ e]) ->\n  [set: gtype] \\isog Grp (x : y : x ^+ q, y ^+ p, x ^ y = x ^+ e).\n",
  "proof": "Proof.\nrewrite [gtype.body]unlock => [[s [AutBs dvd_s_p sb]]].\nhave memB: _ \\in B by move=> c; rewrite -Zp_cycle inE.\nhave Aa: a \\in <[a]> by rewrite !cycle_id.\nhave [oa ob]: #[a] = p /\\ #[b] = q by rewrite !order_Zp1 !Zp_cast.\nhave def_s: aut_of = s.\n  rewrite /aut_of; case: pickP => /= [t | ]; last first.\n    by move/(_ s); case/and4P; rewrite sb.\n  case/and4P=> AutBt _ _ tb; apply: (eq_Aut AutBt) => // b_i.\n  case/cycleP=> i ->; rewrite -(autmE AutBt) -(autmE AutBs) !morphX //=.\n  by rewrite !autmE // sb (eqP tb).\napply: intro_isoGrp => [|gT G].\n  apply/existsP; exists (sdpair1 _ b, sdpair2 _ a); rewrite /= !xpair_eqE.\n  apply/andP; split.\n    by rewrite -!morphim_cycle ?norm_joinEr ?im_sdpair ?im_sdpair_norm ?eqxx //=.\n  rewrite -!order_dvdn !order_injm ?injm_sdpair1 ?injm_sdpair2 // oa ob !dvdnn.\n  by rewrite -sdpair_act // [act _ _ _]apermE /= eltm_id -morphX // -sb -def_s.\ncase/existsP=> -[x y] /= /eqP[defG xq1 yp1 xy].\nhave fxP: #[x] %| #[b] by rewrite order_dvdn ob xq1.\nhave fyP: #[y] %| #[a] by rewrite order_dvdn oa yp1.\nhave fP: {in <[b]> & <[a]>, morph_act gact 'J (eltm fxP) (eltm fyP)}.\n  move=> bj ai; case/cycleP=> j ->{bj}; case/cycleP=> i ->{ai}.\n  rewrite /= !eltmE def_s gactX ?groupX // conjXg morphX //=; congr (_ ^+ j).\n  rewrite /autact /= apermE; elim: i {j} => /= [|i IHi].\n    by rewrite perm1 eltm_id conjg1.\n  rewrite !expgS permM sb -(autmE (groupX i AutBs)) !morphX //= {}IHi.\n  by rewrite -conjXg -xy -conjgM.\napply/homgP; exists (xsdprod_morphism fP).\nrewrite im_xsdprodm !morphim_cycle //= !eltm_id -norm_joinEr //.\nby rewrite norms_cycle xy mem_cycle.\nQed."
}
{
  "statement": "Lemma sol_coprime_Sylow_trans A G :\n    solvable A -> A \\subset 'N(G) -> coprime #|G| #|A| ->\n  [transitive 'C_G(A), on [set P in 'Syl_p(G) | A \\subset 'N(P)] | 'JG].\n",
  "proof": "Proof.\nmove=> solA nGA coGA; pose AG := A <*> G; set FpA := finset _.\nhave nG_AG: AG \\subset 'N(G) by rewrite join_subG nGA normG.\nhave [P sylP nPA] := sol_coprime_Sylow_exists solA nGA coGA.\npose N := 'N_AG(P); have sAN: A \\subset N by rewrite subsetI joing_subl.\nhave trNPA: A :^: AG ::&: N = A :^: N.\n  pose NG := 'N_G(P); have sNG_G : NG \\subset G := subsetIl _ _.\n  have nNGA: A \\subset 'N(NG) by rewrite normsI ?norms_norm.\n  apply/setP=> Ax; apply/setIdP/imsetP=> [[]|[x Nx ->{Ax}]]; last first.\n    by rewrite conj_subG //; case/setIP: Nx => AGx; rewrite imset_f.\n  have ->: N = A <*> NG by rewrite /N /AG !norm_joinEl // -group_modl.\n  have coNG_A := coprimeSg sNG_G coGA; case/imsetP=> x AGx ->{Ax}.\n  case/SchurZassenhaus_trans_actsol; rewrite ?cardJg // => y Ny /= ->.\n  by exists y; rewrite // mem_gen 1?inE ?Ny ?orbT.\nhave{trNPA}: [transitive 'N_AG(A), on FpA | 'JG].\n  have ->: FpA = 'Fix_('Syl_p(G) | 'JG)(A).\n    by apply/setP=> Q; rewrite 4!inE afixJG.\n  have SylP : P \\in 'Syl_p(G) by rewrite inE.\n  apply/(trans_subnorm_fixP _ SylP); rewrite ?astab1JG //.\n  rewrite (atrans_supgroup _ (Syl_trans _ _)) ?joing_subr //= -/AG.\n  by apply/actsP=> x /= AGx Q /=; rewrite !inE -{1}(normsP nG_AG x) ?pHallJ2.\nrewrite {1}/AG norm_joinEl // -group_modl ?normG ?coprime_norm_cent //=.\nrewrite -cent_joinEr ?subsetIr // => trC_FpA.\nhave FpA_P: P \\in FpA by rewrite !inE sylP.\napply/(subgroup_transitiveP FpA_P _ trC_FpA); rewrite ?joing_subr //=.\nrewrite astab1JG cent_joinEr ?subsetIr // -group_modl // -mulgA.\nby congr (_ * _); rewrite mulSGid ?subsetIl.\nQed."
}
{
  "statement": "Lemma rgcdpE p q :\n  rgcdp p q = if size p < size q\n    then rgcdp (rmodp q p) p else rgcdp (rmodp p q) q.\n",
  "proof": "Proof.\npose rgcdp_rec := fix rgcdp_rec (n : nat) (pp qq : {poly R}) {struct n} :=\n   let rr := rmodp pp qq in\n   if rr == 0 then qq else\n   if n is n1.+1 then rgcdp_rec n1 qq rr else rr.\nhave Irec: forall m n p q, size q <= m -> size q <= n\n      -> size q < size p -> rgcdp_rec m p q = rgcdp_rec n p q.\n  + elim=> [|m Hrec] [|n] //= p1 q1.\n    - move/size_poly_leq0P=> -> _; rewrite size_poly0 size_poly_gt0 rmodp0.\n      by move/negPf->; case: n => [|n] /=; rewrite rmod0p eqxx.\n    - move=> _ /size_poly_leq0P ->; rewrite size_poly0 size_poly_gt0 rmodp0.\n      by move/negPf->; case: m {Hrec} => [|m] /=; rewrite rmod0p eqxx.\n  case: eqVneq => Epq Sm Sn Sq //; have [->|nzq] := eqVneq q1 0.\n    by case: n m {Sm Sn Hrec} => [|m] [|n] //=; rewrite rmod0p eqxx.\n  apply: Hrec; last by rewrite ltn_rmodp.\n    by rewrite -ltnS (leq_trans _ Sm) // ltn_rmodp.\n  by rewrite -ltnS (leq_trans _ Sn) // ltn_rmodp.\nhave [->|nzp] := eqVneq p 0.\n  by rewrite rmod0p rmodp0 rgcd0p rgcdp0 if_same.\nhave [->|nzq] := eqVneq q 0.\n  by rewrite rmod0p rmodp0 rgcd0p rgcdp0 if_same.\nrewrite /rgcdp -/rgcdp_rec !ltn_rmodp (negPf nzp) (negPf nzq) /=.\nhave [ltpq|leqp] := ltnP; rewrite !(negPf nzp, negPf nzq) //= polySpred //=.\n  have [->|nzqp] := eqVneq.\n    by case: (size p) => [|[|s]]; rewrite /= rmodp0 (negPf nzp) // rmod0p eqxx.\n  apply: Irec => //; last by rewrite ltn_rmodp.\n    by rewrite -ltnS -polySpred // (leq_trans _ ltpq) ?leqW // ltn_rmodp.\n  by rewrite ltnW // ltn_rmodp.\nhave [->|nzpq] := eqVneq.\n  by case: (size q) => [|[|s]]; rewrite /= rmodp0 (negPf nzq) // rmod0p eqxx.\napply: Irec => //; last by rewrite ltn_rmodp.\n  by rewrite -ltnS -polySpred // (leq_trans _ leqp) // ltn_rmodp.\nby rewrite ltnW // ltn_rmodp.\nQed."
}
{
  "statement": "Lemma companionmxK {R : comNzRingType} (p : {poly R}) :\n   p \\is monic -> char_poly (companionmx p) = p.\n",
  "proof": "Proof.\npose D n : 'M[{poly R}]_n := \\matrix_(i, j)\n   ('X *+ (i == j.+1 :> nat) - ((i == j)%:R)%:P).\nhave detD n : \\det (D n) = (-1) ^+ n.\n  elim: n => [|n IHn]; first by rewrite det_mx00.\n  rewrite (expand_det_row _ ord0) big_ord_recl !mxE /= sub0r.\n  rewrite big1 ?addr0; last by move=> i _; rewrite !mxE /= subrr mul0r.\n  rewrite /cofactor mul1r [X in \\det X](_ : _ = D _) ?IHn ?exprS//.\n  by apply/matrixP=> i j; rewrite !mxE /= /bump !add1n eqSS.\nelim/poly_ind: p => [|p c IHp].\n  by rewrite monicE lead_coef0 eq_sym oner_eq0.\nhave [->|p_neq0] := eqVneq p 0.\n  rewrite mul0r add0r monicE lead_coefC => /eqP->.\n  by rewrite /companionmx /char_poly size_poly1 det_mx00.\nrewrite monicE lead_coefDl ?lead_coefMX => [p_monic|]; last first.\n  rewrite size_polyC size_mulX ?polyX_eq0// ltnS.\n  by rewrite (leq_trans (leq_b1 _)) ?size_poly_gt0.\nrewrite -[in RHS]IHp // /companionmx size_MXaddC (negPf p_neq0) /=.\nrewrite /char_poly polySpred //.\nhave [->|spV1_gt0] := posnP (size p).-1.\n  rewrite [X in \\det X]mx11_scalar det_scalar1 !mxE ?eqxx det_mx00.\n  by rewrite mul1r -horner_coef0 hornerMXaddC mulr0 add0r rmorphN opprK.\nrewrite (expand_det_col _ ord0) /= -[(size p).-1]prednK //.\nrewrite big_ord_recr big_ord_recl/= big1 ?add0r //=; last first.\n  move=> i _; rewrite !mxE -val_eqE /= /bump leq0n add1n eqSS.\n  by rewrite ltn_eqF ?subrr ?mul0r.\nrewrite !mxE ?subnn -horner_coef0 /= hornerMXaddC.\nrewrite !(eqxx, mulr0, add0r, addr0, subr0, rmorphN, opprK)/=.\nrewrite mulrC /cofactor; congr (_ * 'X + _).\n  rewrite /cofactor -signr_odd oddD addbb mul1r; congr (\\det _).\n  apply/matrixP => i j; rewrite !mxE -val_eqE coefD coefMX coefC.\n  by rewrite /= /bump /= !add1n !eqSS addr0.\nrewrite /cofactor [X in \\det X](_ : _ = D _).\n  by rewrite detD /= addn0 -signr_odd -signr_addb addbb mulr1.\napply/matrixP=> i j; rewrite !mxE -!val_eqE /= /bump /=.\nby rewrite leqNgt ltn_ord add0n add1n [_ == _.-2.+1]ltn_eqF.\nQed."
}
{
  "statement": "Lemma abelian_type_pgroup p b G :\n    p.-group G -> \\big[dprod/1]_(x <- b) <[x]> = G -> 1 \\notin b ->\n  perm_eq (abelian_type G) (map order b).\n",
  "proof": "Proof.\nrewrite perm_sym; move: b => b1 pG defG1 ntb1.\nhave cGG: abelian G.\n  elim: (b1) {pG}G defG1 => [_ <-|x b IHb G]; first by rewrite big_nil abelian1.\n  rewrite big_cons; case/dprodP=> [[_ H _ defH]] <-; rewrite defH => cxH _.\n  by rewrite abelianM cycle_abelian IHb.\nhave p_bG b: \\big[dprod/1]_(x <- b) <[x]> = G -> all (p_elt p) b.\n  elim: b {defG1 cGG}G pG => //= x b IHb G pG; rewrite big_cons.\n  case/dprodP=> [[_ H _ defH]]; rewrite defH andbC => defG _ _.\n  by rewrite -defG pgroupM in pG; case/andP: pG => p_x /IHb->.\nhave [b2 defG2 def_t] := abelian_structure cGG.\nhave ntb2: 1 \\notin b2.\n  apply: contraL (abelian_type_gt1 G) => b2_1.\n  rewrite -def_t -has_predC has_map.\n  by apply/hasP; exists 1; rewrite //= order1.\nrewrite -{}def_t; apply/allP=> m; rewrite -map_cat => /mapP[x b_x def_m].\nhave{ntb1 ntb2} ntx: x != 1.\n  by apply: contraL b_x; move/eqP->; rewrite mem_cat negb_or ntb1 ntb2.\nhave p_x: p.-elt x by apply: allP (x) b_x; rewrite all_cat !p_bG.\nrewrite -cycle_eq1 in ntx; have [p_pr _ [k ox]] := pgroup_pdiv p_x ntx.\napply/eqnP; rewrite {m}def_m orderE ox !count_map.\npose cnt_p k := count [pred x : gT | logn p #[x] > k].\nhave cnt_b b: \\big[dprod/1]_(x <- b) <[x]> = G ->\n  count [pred x | #[x] == p ^ k.+1]%N b = cnt_p k b - cnt_p k.+1 b.\n- move/p_bG; elim: b => //= _ b IHb /andP[/p_natP[j ->] /IHb-> {IHb}].\n  rewrite eqn_leq !leq_exp2l ?prime_gt1 // -eqn_leq pfactorK //.\n  case: (ltngtP k.+1) => // _ {j}; rewrite subSn // add0n.\n  by elim: b => //= y b IHb; rewrite leq_add // ltn_neqAle; case: (~~ _).\nby rewrite !cnt_b // /cnt_p !(@count_logn_dprod_cycle _ _ _ G).\nQed."
}
{
  "statement": "Lemma cprod_by_uniq :\n  exists f : {morphism G >-> cprod_by},\n    [/\\ isom G C f, f @* GH = CH & f @* GK = CK].\n",
  "proof": "Proof.\nhave [_ defGHK cGKH] := cprodP defG.\nhave AutZinH := Aut_sub_fullP sZH AutZHfull.\nhave [fH injfH defGH]:= isogP (isog_symr isoGH).\nhave [fK injfK defGK]:= isogP (isog_symr isoGK).\nhave sfHZfK: fH @* 'Z(H) \\subset fK @* K.\n  by rewrite injm_center //= defGH defGK -ziGHK subsetIr.\nhave gzZ_id: gz @* 'Z(H) = invm injfK @* (fH @* 'Z(H)).\n  apply: gzZ_lone => /=.\n    rewrite injm_center // defGH -ziGHK sub_morphim_pre /= ?defGK ?subsetIr //.\n    by rewrite setIC morphpre_invm injm_center // defGK setIS 1?centsC.\n  rewrite -morphim_comp.\n  apply: isog_trans (sub_isog _ _); first by rewrite isog_sym sub_isog.\n    by rewrite -sub_morphim_pre.\n  by rewrite !injm_comp ?injm_invm.\nhave: 'dom (invm injfH \\o fK \\o gz) = 'Z(H).\n  rewrite /dom /= -(morphpreIdom gz); apply/setIidPl.\n  by rewrite -2?sub_morphim_pre // gzZ_id morphim_invmE morphpreK ?morphimS.\ncase/domP=> gzH [def_gzH ker_gzH _ im_gzH].\nhave{ker_gzH} injgzH: 'injm gzH by rewrite ker_gzH !injm_comp ?injm_invm.\nhave{AutZinH} [|gH [injgH gH_H def_gH]] := AutZinH _ injgzH.\n  by rewrite im_gzH !morphim_comp /= gzZ_id !morphim_invmE morphpreK ?injmK.\nhave: 'dom (fH \\o gH) = H by rewrite /dom /= -{3}gH_H injmK.\ncase/domP=> gfH [def_gfH ker_gfH _ im_gfH].\nhave{im_gfH} gfH_H: gfH @* H = GH by rewrite im_gfH morphim_comp gH_H.\nhave cgfHfK: fK @* K \\subset 'C(gfH @* H) by rewrite gfH_H defGK.\nhave eq_gfHK: {in 'Z(H), gfH =1 fK \\o gz}.\n  move=> z Zz; rewrite def_gfH /= def_gH //= def_gzH /= invmK //.\n  have {Zz}: gz z \\in gz @* 'Z(H) by rewrite mem_morphim.\n  rewrite gzZ_id morphim_invmE; case/morphpreP=> _.\n  exact: (subsetP (morphimS _ _)).\npose f := xcprodm cgfHfK eq_gfHK.\nhave injf: 'injm f by rewrite injm_xcprodm ker_gfH injm_comp.\nhave fCH: f @* CH = GH by rewrite im_xcprodml gfH_H.\nhave fCK: f @* CK = GK by rewrite im_xcprodmr defGK.\nhave fC: f @* C = G by rewrite im_xcprodm gfH_H defGK defGHK.\nhave [f' [_ ker_f' _ im_f']] := domP (invm_morphism injf) fC.\nexists f'; rewrite -fCH -fCK !{1}im_f' !{1}morphim_invm ?subsetT //.\nby split=> //; apply/isomP; rewrite ker_f' injm_invm im_f' -fC im_invm.\nQed."
}
{
  "statement": "Lemma rfd_iso : 'C_('Alt_T)[x | 'P] \\isog 'Alt_T'.\n",
  "proof": "Proof.\nhave rgd_x p: rgd p x = x by rewrite permE /= insubF //= eqxx.\nhave rfd_rgd p: rfd (rgd p) = p.\n  apply/permP => [[z Hz]]; apply/val_eqP; rewrite !permE.\n  by rewrite /= [rgd _ _]permE /= insubF eqxx // permE /= insubT.\nhave sSd: 'C_('Alt_T)[x | 'P] \\subset 'dom rfd.\n  by apply/subsetP=> p /[!inE]/= /andP[].\napply/isogP; exists [morphism of restrm sSd rfd] => /=; last first.\n  rewrite morphim_restrm setIid; apply/setP=> z; apply/morphimP/idP=> [[p _]|].\n    case/setIP; rewrite Alt_even => Hp; move/astab1P=> Hp1 ->.\n    by rewrite Alt_even rfd_odd.\n  have dz': rgd z x == x by rewrite rgd_x.\n  move=> kz; exists (rgd z); last by rewrite /= rfd_rgd.\n    by rewrite 2!inE (sameP astab1P eqP).\n  rewrite 4!inE /= (sameP astab1P eqP) dz' -rfd_odd; last exact/eqP.\n  by rewrite rfd_rgd mker // ?set11.\napply/injmP=> x1 y1 /=.\ncase/setIP=> Hax1; move/astab1P; rewrite /= /aperm => Hx1.\ncase/setIP=> Hay1; move/astab1P; rewrite /= /aperm => Hy1 Hr.\napply/permP => z.\ncase (z =P x) => [->|]; [by rewrite Hx1 | move/eqP => nzx].\nmove: (congr1 (fun q : {perm T'} => q (Sub z nzx)) Hr).\nby rewrite !permE => [[]]; rewrite Hx1 Hy1 !eqxx.\nQed."
}
{
  "statement": "Lemma trivg_Phi : p.-group P -> ('Phi(P) == 1) = p.-abelem P.\n",
  "proof": "Proof.\nmove=> pP; case: (eqsVneq P 1) => [P1 | ntP].\n  by rewrite P1 abelem1 -subG1 -P1 Phi_sub.\nhave [p_pr _ _] := pgroup_pdiv pP ntP.\napply/eqP/idP=> [trPhi | abP].\n  apply/abelemP=> //; split=> [|x Px].\n    apply/commG1P/trivgP; rewrite -trPhi.\n    apply/bigcapsP=> M /predU1P[-> | maxM]; first exact: der1_subG.\n    have /andP[_ nMP]: M <| P := p_maximal_normal pP maxM.\n    rewrite der1_min // cyclic_abelian // prime_cyclic // card_quotient //.\n    by rewrite (p_maximal_index pP).\n  apply/set1gP; rewrite -trPhi; apply/bigcapP=> M.\n  case/predU1P=> [-> | maxM]; first exact: groupX.\n  have /andP[_ nMP] := p_maximal_normal pP maxM.\n  have nMx : x \\in 'N(M) by apply: subsetP Px.\n  apply: coset_idr; rewrite ?groupX ?morphX //=; apply/eqP.\n  rewrite -(p_maximal_index pP maxM) -card_quotient // -order_dvdn cardSg //=.\n  by rewrite cycle_subG mem_quotient.\napply/trivgP/subsetP=> x Phi_x; rewrite -cycle_subG.\nhave Px: x \\in P by apply: (subsetP (Phi_sub P)).\nhave sxP: <[x]> \\subset P by rewrite cycle_subG.\ncase/splitsP: (abelem_splits abP sxP) => K /complP[tiKx defP].\nhave [-> | nt_x] := eqVneq x 1; first by rewrite cycle1.\nhave oxp := abelem_order_p abP Px nt_x.\nrewrite /= -tiKx subsetI subxx cycle_subG.\napply: (bigcapP Phi_x); apply/orP; right.\napply: p_index_maximal; rewrite -?divgS -defP ?mulG_subr //.\nby rewrite (TI_cardMg tiKx) mulnK // [#|_|]oxp.\nQed."
}
{
  "statement": "Lemma strongest_coprime_quotient_cent A G H :\n      let R := H :&: [~: G, A] in\n      A \\subset 'N(H) -> R \\subset G -> coprime #|R| #|A| ->\n      solvable R || solvable A ->\n  'C_G(A) / H = 'C_(G / H)(A / H).\n",
  "proof": "Proof.\nmove=> R nHA sRG coRA solRA.\nhave nRA: A \\subset 'N(R) by rewrite normsI ?commg_normr.\napply/eqP; rewrite eqEsubset subsetI morphimS ?subsetIl //=.\nrewrite (subset_trans _ (morphim_cent _ _)) ?morphimS ?subsetIr //=.\napply/subsetP=> _ /setIP[/morphimP[x Nx Gx ->] cAHx].\nhave{cAHx} cAxR y: y \\in A -> [~ x, y] \\in R.\n  move=> Ay; have Ny: y \\in 'N(H) by apply: subsetP Ay.\n  rewrite inE mem_commg // andbT coset_idr ?groupR // morphR //=.\n  by apply/eqP; apply/commgP; apply: (centP cAHx); rewrite mem_quotient.\nhave AxRA: A :^ x \\subset R * A.\n  apply/subsetP=> _ /imsetP[y Ay ->].\n  rewrite -normC // -(mulKVg y (y ^ x)) -commgEl mem_mulg //.\n  by rewrite -groupV invg_comm cAxR.\nhave [y Ry def_Ax]: exists2 y, y \\in R & A :^ x = A :^ y.\n  have oAx: #|A :^ x| = #|A| by rewrite cardJg.\n  have [solR | solA] := orP solRA; first exact: SchurZassenhaus_trans_sol.\n  by apply: SchurZassenhaus_trans_actsol; rewrite // joingC norm_joinEr.\nrewrite -imset_coset; apply/imsetP; exists (x * y^-1); last first.\n  by rewrite conjgCV mkerl // ker_coset memJ_norm groupV; case/setIP: Ry.\nrewrite /= inE groupMl // ?(groupV, subsetP sRG) //=.\napply/centP=> z Az; apply/commgP/eqP/set1P.\nrewrite -[[set 1]](coprime_TIg coRA) inE {1}commgEl commgEr /= -/R.\nrewrite invMg -mulgA invgK groupMl // conjMg mulgA -commgEl.\nrewrite groupMl ?cAxR // memJ_norm ?(groupV, subsetP nRA) // Ry /=.\nby rewrite groupMr // conjVg groupV conjgM -mem_conjg -def_Ax memJ_conjg.\nQed."
}
{
  "statement": "Lemma cycle_repr_structure_pchar x (sG : irrType G) :\n    G :=: <[x]> -> [pchar F]^'.-group G -> group_splitting_field G ->\n  exists2 w : F, #|G|.-primitive_root w &\n  exists iphi : 'I_#|G| -> sG,\n  [/\\ bijective iphi,\n      #|sG| = #|G|,\n      forall i, irr_mode (iphi i) x = w ^+ i\n    & forall i, irr_repr (iphi i) x = (w ^+ i)%:M].\n",
  "proof": "Proof.\nmove=> defG; rewrite {defG}(group_inj defG) -/#[x] in sG * => F'X splitF.\nhave Xx := cycle_id x; have cXX := cycle_abelian x.\nhave card_sG: #|sG| = #[x].\n  by rewrite card_irr_pchar //; apply/eqP; rewrite -card_classes_abelian.\nhave linX := irr_degree_abelian splitF cXX (_ : sG).\npose r (W : sG) := irr_mode W x.\nhave scalX W: irr_repr W x = (r W)%:M.\n  by apply: irr_center_scalar; rewrite ?(center_idP _).\nhave inj_r: injective r.\n  move=> V W eqVW; rewrite -(irr_reprK_pchar F'X V) -(irr_reprK_pchar F'X W).\n  move: (irr_repr V) (irr_repr W) (scalX V) (scalX W).\n  rewrite !linX {}eqVW => rV rW <- rWx; apply: irr_comp_rsim_pchar => //.\n  exists 1%:M; rewrite ?row_free_unit ?unitmx1 // => xk; case/cycleP=> k ->{xk}.\n  by rewrite mulmx1 mul1mx !repr_mxX // rWx.\nhave rx1 W: r W ^+ #[x] = 1.\n  by rewrite -irr_modeX ?(center_idP _) // expg_order irr_mode1.\nhave /hasP[w _ prim_w]: has #[x].-primitive_root (map r (enum sG)).\n  rewrite has_prim_root 1?map_inj_uniq ?enum_uniq //; first 1 last.\n    by rewrite size_map -cardE card_sG.\n  by apply/allP=> _ /mapP[W _ ->]; rewrite unity_rootE rx1.\nhave iphi'P := prim_rootP prim_w (rx1 _); pose iphi' := sval (iphi'P _).\nhave def_r W: r W = w ^+ iphi' W by apply: svalP (iphi'P W).\nhave inj_iphi': injective iphi'.\n  by move=> i j eq_ij; apply: inj_r; rewrite !def_r eq_ij.\nhave iphiP: codom iphi' =i 'I_#[x].\n  by apply/subset_cardP; rewrite ?subset_predT // card_ord card_image.\npose iphi i := iinv (iphiP i); exists w => //; exists iphi.\nhave iphiK: cancel iphi iphi' by move=> i; apply: f_iinv.\nhave r_iphi i: r (iphi i) = w ^+ i by rewrite def_r iphiK.\nsplit=> // [|i]; last by rewrite scalX r_iphi.\nby exists iphi' => // W; rewrite /iphi iinv_f.\nQed."
}
{
  "statement": "Lemma mxdirect_adds_center m1 m2 n (R1 : 'A_(m1, n)) (R2 : 'A_(m2, n)) :\n    mx_ideal (R1 + R2)%MS R1 -> mx_ideal (R1 + R2)%MS R2 ->\n    mxdirect (R1 + R2) ->\n  ('Z((R1 + R2)%MS) :=: 'Z(R1) + 'Z(R2))%MS.\n",
  "proof": "Proof.\ncase/andP=> idlR1 idrR1 /andP[idlR2 idrR2] /mxdirect_addsP dxR12.\napply/eqmxP/andP; split.\n  apply/memmx_subP=> z0; rewrite sub_capmx => /andP[].\n  case/memmx_addsP=> z [R1z1 R2z2 ->{z0}] Cz.\n  rewrite linearD addmx_sub_adds //= ?sub_capmx ?R1z1 ?R2z2 /=.\n    apply/cent_mxP=> A R1_A; have R_A := submx_trans R1_A (addsmxSl R1 R2).\n    have Rz2 := submx_trans R2z2 (addsmxSr R1 R2).\n    rewrite -{1}[z.1](addrK z.2) mulmxBr (cent_mxP Cz) // mulmxDl.\n    rewrite [A *m z.2]memmx0 1?[z.2 *m A]memmx0 ?addrK //.\n      by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  apply/cent_mxP=> A R2_A; have R_A := submx_trans R2_A (addsmxSr R1 R2).\n  have Rz1 := submx_trans R1z1 (addsmxSl R1 R2).\n  rewrite -{1}[z.2](addKr z.1) mulmxDr (cent_mxP Cz) // mulmxDl.\n  rewrite mulmxN [A *m z.1]memmx0 1?[z.1 *m A]memmx0 ?addKr //.\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\nrewrite addsmx_sub; apply/andP; split.\n  apply/memmx_subP=> z; rewrite sub_capmx => /andP[R1z cR1z].\n  have Rz := submx_trans R1z (addsmxSl R1 R2).\n  rewrite sub_capmx Rz; apply/cent_mxP=> A0.\n  case/memmx_addsP=> A [R1_A1 R2_A2] ->{A0}.\n  have R_A2 := submx_trans R2_A2 (addsmxSr R1 R2).\n  rewrite mulmxDl mulmxDr (cent_mxP cR1z) //; congr (_ + _).\n  rewrite [A.2 *m z]memmx0 1?[z *m A.2]memmx0 //.\n    by rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\napply/memmx_subP=> z; rewrite !sub_capmx => /andP[R2z cR2z].\nhave Rz := submx_trans R2z (addsmxSr R1 R2); rewrite Rz.\napply/cent_mxP=> _ /memmx_addsP[A [R1_A1 R2_A2 ->]].\nrewrite mulmxDl mulmxDr (cent_mxP cR2z _ R2_A2) //; congr (_ + _).\nhave R_A1 := submx_trans R1_A1 (addsmxSl R1 R2).\nrewrite [A.1 *m z]memmx0 1?[z *m A.1]memmx0 //.\n  by rewrite -dxR12 sub_capmx (mulsmx_subP idlR1) // (mulsmx_subP idrR2).\nby rewrite -dxR12 sub_capmx (mulsmx_subP idrR1) // (mulsmx_subP idlR2).\nQed."
}
{
  "statement": "Lemma gcdpE p q :\n  gcdp p q = if size p < size q\n    then gcdp (modp q p) p else gcdp (modp p q) q.\n",
  "proof": "Proof.\npose gcdpE_rec := fix gcdpE_rec (n : nat) (pp qq : {poly R}) {struct n} :=\n   let rr := modp pp qq in\n   if rr == 0 then qq else\n   if n is n1.+1 then gcdpE_rec n1 qq rr else rr.\nhave Irec: forall k l p q, size q <= k -> size q <= l\n      -> size q < size p -> gcdpE_rec k p q = gcdpE_rec l p q.\n+ elim=> [|m Hrec] [|n] //= p1 q1.\n  - move/size_poly_leq0P=> -> _; rewrite size_poly0 size_poly_gt0 modp0.\n    by move/negPf ->; case: n => [|n] /=; rewrite mod0p eqxx.\n  - move=> _ /size_poly_leq0P ->; rewrite size_poly0 size_poly_gt0 modp0.\n    by move/negPf ->; case: m {Hrec} => [|m] /=; rewrite mod0p eqxx.\n  case: eqP => Epq Sm Sn Sq //; have [->|nzq] := eqVneq q1 0.\n    by case: n m {Sm Sn Hrec} => [|m] [|n] //=; rewrite mod0p eqxx.\n  apply: Hrec; last by rewrite ltn_modp.\n    by rewrite -ltnS (leq_trans _ Sm) // ltn_modp.\n  by rewrite -ltnS (leq_trans _ Sn) // ltn_modp.\nhave [->|nzp] := eqVneq p 0; first by rewrite mod0p modp0 gcd0p gcdp0 if_same.\nhave [->|nzq] := eqVneq q 0; first by rewrite mod0p modp0 gcd0p gcdp0 if_same.\nrewrite /gcdp !ltn_modp !(negPf nzp, negPf nzq) /=.\nhave [ltpq|leqp] := ltnP; rewrite !(negPf nzp, negPf nzq) /= polySpred //.\n  have [->|nzqp] := eqVneq.\n    by case: (size p) => [|[|s]]; rewrite /= modp0 (negPf nzp) // mod0p eqxx.\n  apply: Irec => //; last by rewrite ltn_modp.\n    by rewrite -ltnS -polySpred // (leq_trans _ ltpq) ?leqW // ltn_modp.\n  by rewrite ltnW // ltn_modp.\ncase: eqVneq => [->|nzpq].\n  by case: (size q) => [|[|s]]; rewrite /= modp0 (negPf nzq) // mod0p eqxx.\napply: Irec => //; rewrite ?ltn_modp //.\n  by rewrite -ltnS -polySpred // (leq_trans _ leqp) // ltn_modp.\nby rewrite ltnW // ltn_modp.\nQed."
}
{
  "statement": "Lemma count_logn_dprod_cycle p n b G :\n    \\big[dprod/1]_(x <- b) <[x]> = G ->\n  count [pred x | logn p #[x] > n] b = logn p #|'Ohm_n.+1(G) : 'Ohm_n(G)|.\n",
  "proof": "Proof.\nhave sOn1 H: 'Ohm_n(H) \\subset 'Ohm_n.+1(H) by apply: Ohm_leq.\npose lnO i (A : {set gT}) := logn p #|'Ohm_i(A)|.\nhave lnO_le H: lnO n H <= lnO n.+1 H.\n  by rewrite dvdn_leq_log ?cardG_gt0 // cardSg ?sOn1.\nhave lnOx i A B H: A \\x B = H -> lnO i A + lnO i B = lnO i H.\n  move=> defH; case/dprodP: defH (defH) => {A B}[[A B -> ->]] _ _ _ defH.\n  rewrite /lnO; case/dprodP: (Ohm_dprod i defH) => _ <- _ tiOAB.\n  by rewrite TI_cardMg ?lognM.\nrewrite -divgS //= logn_div ?cardSg //= -/(lnO _ _) -/(lnO _ _).\nelim: b G => [_ <-|x b IHb G] /=.\n  by rewrite big_nil /lnO !(trivgP (Ohm_sub _ _)) subnn.\nrewrite /= big_cons => defG; rewrite -!(lnOx _ _ _ _ defG) subnDA.\ncase/dprodP: defG => [[_ H _ defH] _ _ _] {G}; rewrite defH (IHb _ defH).\nsymmetry; do 2!rewrite addnC -addnBA ?lnO_le //; congr (_ + _).\npose y := x.`_p; have p_y: p.-elt y by rewrite p_elt_constt.\nhave{lnOx} lnOy i: lnO i <[x]> = lnO i <[y]>.\n  have cXX := cycle_abelian x.\n  have co_yx': coprime #[y] #[x.`_p^'] by rewrite !order_constt coprime_partC.\n  have defX: <[y]> \\x <[x.`_p^']> = <[x]>.\n    rewrite dprodE ?coprime_TIg //.\n      by rewrite -cycleM ?consttC //; apply: (centsP cXX); apply: mem_cycle.\n    by apply: (sub_abelian_cent2 cXX); rewrite cycle_subG mem_cycle.\n  rewrite -(lnOx i _ _ _ defX) addnC {1}/lnO lognE.\n  case: and3P => // [[p_pr _ /idPn[]]]; rewrite -p'natE //.\n  exact: pgroupS (Ohm_sub _ _) (p_elt_constt _ _).\nrewrite -logn_part -order_constt -/y !{}lnOy /lnO !(Ohm_p_cycle _ p_y).\ncase: leqP => [| lt_n_y].\n  by rewrite -subn_eq0 -addn1 subnDA => /eqP->; rewrite subnn.\nrewrite -!orderE -(subSS n) subSn // expnSr expgM.\nhave p_pr: prime p by move: lt_n_y; rewrite lognE; case: prime.\nset m := (p ^ _)%N; have m_gt0: m > 0 by rewrite expn_gt0 prime_gt0.\nsuffices p_ym: p %| #[y ^+ m].\n  rewrite -logn_div ?orderXdvd // (orderXdiv p_ym) divnA // mulKn //.\n  by rewrite logn_prime ?eqxx.\nrewrite orderXdiv ?pfactor_dvdn ?leq_subr // -(dvdn_pmul2r m_gt0).\nby rewrite -expnS -subSn // subSS divnK pfactor_dvdn ?leq_subr.\nQed."
}
{
  "statement": "Lemma finite_PET : K_is_large \\/ exists z, (<< <<K; y>>; x>> = <<K; z>>)%VS.\n",
  "proof": "Proof.\nhave [-> | /cyclic_or_large[|[a Dxa]]] := eqVneq x 0; first 2 [by left].\n  by rewrite addv0 subfield_closed; right; exists y.\nhave [-> | /cyclic_or_large[|[b Dyb]]] := eqVneq y 0; first 2 [by left].\n  by rewrite addv0 subfield_closed; right; exists x.\npose h0 (ij : 'I_a.+1 * 'I_b.+1) := x ^+ ij.1 * y ^+ ij.2.\npose H := <<[set ij | h0 ij == 1%R]>>%G; pose h (u : coset_of H) := h0 (repr u).\nhave h0M: {morph h0: ij1 ij2 / (ij1 * ij2)%g >-> ij1 * ij2}.\n  by rewrite /h0 => [] [i1 j1] [i2 j2] /=; rewrite mulrACA -!exprD !expr_mod.\nhave memH ij: (ij \\in H) = (h0 ij == 1).\n  rewrite /= gen_set_id ?inE //; apply/group_setP; rewrite inE [h0 _]mulr1.\n  by split=> // ? ? /[!(inE, h0M)] /eqP-> /eqP->; rewrite mulr1.\nhave nH ij: ij \\in 'N(H)%g.\n  by apply/(subsetP (cent_sub _))/centP=> ij1 _; congr (_, _); rewrite Zp_mulgC.\nhave hE ij: h (coset H ij) = h0 ij.\n  rewrite /h val_coset //; case: repr_rcosetP => ij1.\n  by rewrite memH h0M => /eqP->; rewrite mul1r.\nhave h1: h 1%g = 1 by rewrite /h repr_coset1 [h0 _]mulr1.\nhave hM: {morph h: u v / (u * v)%g >-> u * v}.\n  by do 2![move=> u; have{u} [? _ ->] := cosetP u]; rewrite -morphM // !hE h0M.\nhave /cyclicP[w defW]: cyclic [set: coset_of H].\n  apply: field_mul_group_cyclic (in2W hM) _ => u _; have [ij _ ->] := cosetP u.\n  by split=> [/eqP | -> //]; rewrite hE -memH => /coset_id.\nhave Kw_h ij t: h0 ij = t -> t \\in <<K; h w>>%VS.\n  have /cycleP[k Dk]: coset H ij \\in <[w]>%g by rewrite -defW inE.\n  rewrite -hE {}Dk => <-; elim: k => [|k IHk]; first by rewrite h1 rpred1.\n  by rewrite expgS hM rpredM // memv_adjoin.\nright; exists (h w); apply/eqP; rewrite eqEsubv !(sameP FadjoinP andP).\nrewrite subv_adjoin (subv_trans (subv_adjoin K y)) ?subv_adjoin //=.\nrewrite (Kw_h (0, inZp 1)) 1?(Kw_h (inZp 1, 0)) /h0 ?mulr1 ?mul1r ?expr_mod //=.\nby rewrite rpredM ?rpredX ?memv_adjoin // subvP_adjoin ?memv_adjoin.\nQed."
}
{
  "statement": "Lemma Cintr_Cyclotomic n z :\n  n.-primitive_root z -> pZtoC 'Phi_n = cyclotomic z n.\n",
  "proof": "Proof.\nelim/ltn_ind: n z => n IHn z0 prim_z0.\nrewrite /'Phi_n; case: (C_prim_root_exists _) => z /=.\nhave n_gt0 := prim_order_gt0 prim_z0; rewrite prednK // => prim_z.\nhave [uDn _ inDn] := divisors_correct n_gt0.\npose q := \\prod_(d <- rem n (divisors n)) 'Phi_d.\nhave mon_q: q \\is monic by apply: monic_prod => d _; apply: Cyclotomic_monic.\nhave defXn1: cyclotomic z n * pZtoC q = 'X^n - 1.\n  rewrite (prod_cyclotomic prim_z) (big_rem n) ?inDn //=.\n  rewrite divnn n_gt0 rmorph_prod /=; congr (_ * _).\n  apply: eq_big_seq => d; rewrite mem_rem_uniq ?inE //= inDn => /andP[n'd ddvn].\n  by rewrite -IHn ?dvdn_prim_root // ltn_neqAle n'd dvdn_leq.\nhave mapXn1 (R1 R2 : nzRingType) (f : {rmorphism R1 -> R2}):\n  map_poly f ('X^n - 1) = 'X^n - 1.\n- by rewrite rmorphB /= rmorph1 map_polyXn.\nhave nz_q: pZtoC q != 0.\n  by rewrite -size_poly_eq0 size_map_inj_poly // size_poly_eq0 monic_neq0.\nhave [r def_zn]: exists r, cyclotomic z n = pZtoC r.\n  have defZtoC: ZtoC =1 QtoC \\o ZtoQ by move=> a; rewrite /= rmorph_int.\n  have /dvdpP[r0 Dr0]: map_poly ZtoQ q %| 'X^n - 1.\n    rewrite -(dvdp_map (@ratr algC)) mapXn1 -map_poly_comp.\n    by rewrite -(eq_map_poly defZtoC) -defXn1 dvdp_mull.\n  have [r [a nz_a Dr]] := rat_poly_scale r0.\n  exists (zprimitive r); apply: (mulIf nz_q); rewrite defXn1.\n  rewrite -rmorphM -(zprimitive_monic mon_q) -zprimitiveM /=.\n  have ->: r * q = a *: ('X^n - 1).\n    apply: (map_inj_poly (intr_inj : injective ZtoQ)) => //.\n    rewrite map_polyZ mapXn1 Dr0 Dr -scalerAl scalerKV ?intr_eq0 //.\n    by rewrite rmorphM.\n  by rewrite zprimitiveZ // zprimitive_monic ?monicXnsubC ?mapXn1.\nrewrite floorpK; last by apply/polyOverP=> i; rewrite def_zn coef_map /=.\npose f e (k : 'I_n) := Ordinal (ltn_pmod (k * e) n_gt0).\nhave [e Dz0] := prim_rootP prim_z (prim_expr_order prim_z0).\nhave co_e_n: coprime e n by rewrite -(prim_root_exp_coprime e prim_z) -Dz0.\nhave injf: injective (f e).\n  apply: can_inj (f (egcdn e n).1) _ => k; apply: val_inj => /=.\n  rewrite modnMml -mulnA -modnMmr -{1}(mul1n e).\n  by rewrite (chinese_modr co_e_n 0) modnMmr muln1 modn_small.\nrewrite [_ n](reindex_inj injf); apply: eq_big => k /=.\n  by rewrite coprime_modl coprimeMl co_e_n andbT.\nby rewrite prim_expr_mod // mulnC exprM -Dz0.\nQed."
}
{
  "statement": "Lemma card_p1Elem_pnElem p n A E :\n  E \\in 'E_p^n(A) -> #|'E_p^1(E)| = (\\sum_(i < n) p ^ i)%N.\n",
  "proof": "Proof.\ncase/pnElemP=> _ {A} abelE dimE; have [pE cEE _] := and3P abelE.\nhave [E1 | ntE] := eqsVneq E 1.\n  rewrite -dimE E1 cards1 logn1 big_ord0 eq_card0 // => X.\n  by rewrite !inE subG1 trivg_card1; case: eqP => // ->; rewrite logn1 andbF.\nhave [p_pr _ _] := pgroup_pdiv pE ntE; have p_gt1 := prime_gt1 p_pr.\napply/eqP; rewrite -(@eqn_pmul2l (p - 1)) ?subn_gt0 // subn1 -predn_exp.\nhave groupD1_inj: injective (fun X => (gval X)^#).\n  apply: can_inj (@generated_group _) _ => X.\n  by apply: val_inj; rewrite /= genD1 ?group1 ?genGid.\nrewrite -dimE -card_pgroup // (cardsD1 1 E) group1 /= mulnC.\nrewrite -(card_imset _ groupD1_inj) eq_sym.\napply/eqP; apply: card_uniform_partition => [X'|].\n  case/imsetP=> X; rewrite pnElemE // expn1 => /setIdP[_ /eqP <-] ->.\n  by rewrite (cardsD1 1 X) group1.\napply/and3P; split; last 1 first.\n- apply/imsetP=> [[X /card_p1Elem oX X'0]].\n  by rewrite -oX (cardsD1 1) -X'0 group1 cards0 in p_pr.\n- rewrite eqEsubset; apply/andP; split.\n    by apply/bigcupsP=> _ /imsetP[X /pnElemP[sXE _ _] ->]; apply: setSD.\n  apply/subsetP=> x /setD1P[ntx Ex].\n  apply/bigcupP; exists <[x]>^#; last by rewrite !inE ntx cycle_id.\n  apply/imsetP; exists <[x]>%G; rewrite ?p1ElemE // !inE cycle_subG Ex /=.\n  by rewrite -orderE (abelem_order_p abelE).\napply/trivIsetP=> _ _ /imsetP[X EpX ->] /imsetP[Y EpY ->]; apply/implyP.\nrewrite (inj_eq groupD1_inj) -setI_eq0 -setDIl setD_eq0 subG1.\nby rewrite (sameP eqP (TIp1ElemP EpX EpY)) implybb.\nQed."
}
{
  "statement": "Lemma dprodA : associative dprod.\n",
  "proof": "Proof.\nmove=> A B C; case A1: (A == 1); first by rewrite (eqP A1) !dprod1g.\ncase B1: (B == 1); first by rewrite (eqP B1) dprod1g dprodg1.\ncase C1: (C == 1); first by rewrite (eqP C1) !dprodg1.\nrewrite /dprod (fun_if (cprod A)) (fun_if (cprod^~ C)) -cprodA.\nrewrite -(cprodC set0) !cprod0g cprod_ntriv ?B1 ?{}C1 //.\ncase: and3P B1 => [[] | _ _]; last by rewrite cprodC cprod0g !if_same.\ncase/isgroupP=> H ->; case/isgroupP=> K -> {B C}; move/cent_joinEr=> eHK H1.\nrewrite cprod_ntriv ?trivMg ?{}A1 ?{}H1 // mulG_subG.\ncase: and4P => [[] | _]; last by rewrite !if_same.\ncase/isgroupP=> G ->{A} _ cGH _; rewrite cprodEY // -eHK.\ncase trGH: (G :&: H \\subset _); case trHK: (H :&: K \\subset _); last first.\n- by rewrite !if_same.\n- rewrite if_same; case: ifP => // trG_HK; case/negP: trGH.\n  by apply: subset_trans trG_HK; rewrite setIS ?joing_subl.\n- rewrite if_same; case: ifP => // trGH_K; case/negP: trHK.\n  by apply: subset_trans trGH_K; rewrite setSI ?joing_subr.\ndo 2![case: ifP] => // trGH_K trG_HK; [case/negP: trGH_K | case/negP: trG_HK].\n  apply: subset_trans trHK; rewrite subsetI subsetIr -{2}(mulg1 H) -mulGS.\n  rewrite setIC group_modl ?joing_subr //= cent_joinEr // -eHK.\n  by rewrite -group_modr ?joing_subl //= setIC -(normC (sub1G _)) mulSg.\napply: subset_trans trGH; rewrite subsetI subsetIl -{2}(mul1g H) -mulSG.\nrewrite setIC group_modr ?joing_subl //= eHK -(cent_joinEr cGH).\nby rewrite -group_modl ?joing_subr //= setIC (normC (sub1G _)) mulgS.\nQed."
}
{
  "statement": "Theorem Burnside_p_a_q_b gT (G : {group gT}) :\n  (size (primes #|G|) <= 2)%N -> solvable G.\n",
  "proof": "Proof.\nmove: {2}_.+1 (ltnSn #|G|) => n; elim: n => // n IHn in gT G *.\nrewrite ltnS => leGn piGle2; have [simpleG | ] := boolP (simple G); last first.\n  rewrite negb_forall_in => /exists_inP[N sNG]; rewrite eq_sym.\n  have [->|] := eqVneq N G.\n    rewrite groupP /= genGid normG andbT eqb_id negbK => /eqP->.\n    exact: solvable1.\n  rewrite [N == G]eqEproper sNG eqbF_neg !negbK => ltNG /and3P[grN].\n  case/isgroupP: grN => {}N -> in sNG ltNG *; rewrite /= genGid => ntN nNG.\n  have nsNG: N <| G by apply/andP.\n  have dv_le_pi m: (m %| #|G| -> size (primes m) <= 2)%N.\n    move=> m_dv_G; apply: leq_trans piGle2.\n    by rewrite uniq_leq_size ?primes_uniq //; apply: pi_of_dvd.\n  rewrite (series_sol nsNG) !IHn ?dv_le_pi ?cardSg ?dvdn_quotient //.\n    by apply: leq_trans leGn; apply: ltn_quotient.\n  by apply: leq_trans leGn; apply: proper_card.\nhave [->|[p p_pr p_dv_G]] := trivgVpdiv G; first exact: solvable1.\nhave piGp: p \\in \\pi(G) by rewrite mem_primes p_pr cardG_gt0.\nhave [P sylP] := Sylow_exists p G; have [sPG pP p'GP] := and3P sylP.\nhave ntP: P :!=: 1%g by rewrite -rank_gt0 (rank_Sylow sylP) p_rank_gt0.\nhave /trivgPn[g /setIP[Pg cPg] nt_g]: 'Z(P) != 1%g.\n  by rewrite center_nil_eq1 // (pgroup_nil pP).\napply: abelian_sol; have: (size (primes #|g ^: G|) <= 1)%N.\n  rewrite -ltnS -[_.+1]/(size (p :: _)) (leq_trans _ piGle2) //.\n  rewrite -index_cent1 uniq_leq_size // => [/= | q].\n    rewrite primes_uniq -p'natEpi ?(pnat_dvd _ p'GP) ?indexgS //.\n    by rewrite subsetI sPG sub_cent1.\n  by rewrite inE => /predU1P[-> // |]; apply: pi_of_dvd; rewrite ?dvdn_indexg.\nrewrite leqNgt; apply: contraR => /primes_class_simple_gt1-> //.\nby rewrite !inE classG_eq1 nt_g mem_classes // (subsetP sPG).\nQed."
}
{
  "statement": "Lemma is_trig_block_mx m1 m2 n1 n2 ul ur dl dr : m1 = n1 ->\n  @is_trig_mx (m1 + m2) (n1 + n2) (block_mx ul ur dl dr) =\n  [&& ur == 0, is_trig_mx ul & is_trig_mx dr].\n",
  "proof": "Proof.\nmove=> eq_m1_n1; rewrite {}eq_m1_n1 in ul ur dl dr *.\napply/is_trig_mxP/and3P => [Atrig|]; last first.\n  move=> [/eqP-> /is_trig_mxP ul_trig /is_trig_mxP dr_trig] i j; rewrite !mxE.\n  do 2![case: split_ordP => ? ->; rewrite ?mxE//=] => lt_ij; rewrite ?ul_trig//.\n    move: lt_ij; rewrite ltnNge -ltnS.\n    by rewrite (leq_trans (ltn_ord _))// -addnS leq_addr.\n  by rewrite dr_trig//; move: lt_ij; rewrite ltn_add2l.\nsplit.\n- apply/eqP/matrixP => i j; have := Atrig (lshift _ i) (rshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP-> /eqP<- <- //.\n  by rewrite /= (leq_trans (ltn_ord _)) ?leq_addr.\n- apply/is_trig_mxP => i j lt_ij; have := Atrig (lshift _ i) (lshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  by case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP<- /eqP<- ->.\n- apply/is_trig_mxP => i j lt_ij; have := Atrig (rshift _ i) (rshift _ j).\n  rewrite !mxE; case: split_ordP => k /eqP; rewrite eq_shift// ?mxE.\n  case: split_ordP => l /eqP; rewrite eq_shift// ?mxE => /eqP<- /eqP<- -> //.\n  by rewrite /= ltn_add2l.\nQed."
}
{
  "statement": "Theorem solvable_irr_extendible_from_det G N s (theta := 'chi[N]_s) :\n    N <| G -> solvable (G / N) ->\n    G \\subset 'I[theta] -> coprime #|G : N| (Num.truncn (theta 1%g)) ->\n  [exists c, 'Res 'chi[G]_c == theta]\n    = [exists u, 'Res 'chi[G]_u == cfDet theta].\n",
  "proof": "Proof.\nset e := #|G : N|; set f := Num.truncn _ => nsNG solG IGtheta co_e_f.\napply/exists_eqP/exists_eqP=> [[c cNth] | [u uNdth]].\n  have /lin_char_irr/irrP[u Du] := cfDet_lin_char 'chi_c.\n  by exists u; rewrite -Du -cfDetRes ?irr_char ?cNth.\nmove: {2}e.+1 (ltnSn e) => m.\nelim: m => // m IHm in G u e nsNG solG IGtheta co_e_f uNdth *.\nrewrite ltnS => le_e; have [sNG nNG] := andP nsNG.\nhave [<- | ltNG] := eqsVneq N G; first by exists s; rewrite cfRes_id.\nhave [G0 maxG0 sNG0]: {G0 | maxnormal (gval G0) G G & N \\subset G0}.\n  by apply: maxgroup_exists; rewrite properEneq ltNG sNG.\nhave [/andP[ltG0G nG0G] maxG0_P] := maxgroupP maxG0.\nset mu := 'chi_u in uNdth; have lin_mu: mu \\is a linear_char.\n  by rewrite qualifE/= irr_char -(cfRes1 N) uNdth /= lin_char1 ?cfDet_lin_char.\nhave sG0G := proper_sub ltG0G; have nsNG0 := normalS sNG0 sG0G nsNG.\nhave nsG0G: G0 <| G by apply/andP.\nhave /lin_char_irr/irrP[u0 Du0] := cfRes_lin_char G0 lin_mu.\nhave u0Ndth: 'Res 'chi_u0 = cfDet theta by rewrite -Du0 cfResRes.\nhave IG0theta: G0 \\subset 'I[theta].\n  by rewrite (subset_trans sG0G) // -IGtheta subsetIr.\nhave coG0f: coprime #|G0 : N| f by rewrite (coprime_dvdl _ co_e_f) ?indexSg.\nhave{m IHm le_e} [c0 c0Ns]: exists c0, 'Res 'chi[G0]_c0 = theta.\n  have solG0: solvable (G0 / N) := solvableS (quotientS N sG0G) solG.\n  apply: IHm nsNG0 solG0 IG0theta coG0f u0Ndth (leq_trans _ le_e).\n  by rewrite -(ltn_pmul2l (cardG_gt0 N)) !Lagrange ?proper_card.\nhave{c0 c0Ns} [c0 [c0Ns dc0_u0] Uc0] := extend_to_cfdet nsNG0 coG0f c0Ns u0Ndth.\nhave IGc0: G \\subset 'I['chi_c0].\n  apply/subsetP=> x Gx; rewrite inE (subsetP nG0G) //= -conjg_IirrE.\n  apply/eqP; congr 'chi__; apply: Uc0; rewrite conjg_IirrE.\n    by rewrite -(cfConjgRes _ nsG0G nsNG) // c0Ns inertiaJ ?(subsetP IGtheta).\n  by rewrite cfDetConjg dc0_u0 -Du0 (cfConjgRes _ _ nsG0G) // cfConjg_id.\nhave prG0G: prime #|G : G0|.\n  have [h injh im_h] := third_isom sNG0 nsNG nsG0G.\n  rewrite -card_quotient // -im_h // card_injm //.\n  rewrite simple_sol_prime 1?quotient_sol //.\n  by rewrite /simple -(injm_minnormal injh) // im_h // maxnormal_minnormal.\nhave [t tG0c0] := prime_invariant_irr_extendible nsG0G (erefl _) prG0G IGc0.\nby exists t; rewrite /theta -c0Ns -tG0c0 cfResRes.\nQed."
}
{
  "statement": "Lemma pmaxElem_extraspecial : 'E*_p(G) = 'E_p^('r_p(G))(G).\n",
  "proof": "Proof.\nhave sZmax: {in 'E*_p(G), forall E, 'Z(G) \\subset E}.\n  move=> E maxE; have defE := pmaxElem_LdivP p_pr maxE.\n  have abelZ: p.-abelem 'Z(G) by rewrite prime_abelem ?oZ.\n  rewrite -(Ohm1_id abelZ) (OhmE 1 (abelem_pgroup abelZ)) gen_subG -defE.\n  by rewrite setSI // setIS ?centS // -defE !subIset ?subxx.\nsuffices card_max: {in 'E*_p(G) &, forall E F, #|E| <= #|F| }.\n  have EprGmax: 'E_p^('r_p(G))(G) \\subset 'E*_p(G) := p_rankElem_max p G.\n  have [E EprE]:= p_rank_witness p G; have maxE := subsetP EprGmax E EprE.\n  apply/eqP; rewrite eqEsubset EprGmax andbT; apply/subsetP=> F maxF.\n  rewrite inE; have [-> _]:= pmaxElemP maxF; have [_ _ <-]:= pnElemP EprE.\n  by apply/eqP; congr (logn p _); apply/eqP; rewrite eqn_leq !card_max.\nmove=> E F maxE maxF; set U := E :&: F.\nhave [sUE sUF]: U \\subset E /\\ U \\subset F by apply/andP; rewrite -subsetI.\nhave sZU: 'Z(G) \\subset U by rewrite subsetI !sZmax.\nhave [EpE _]:= pmaxElemP maxE; have{EpE} [sEG abelE] := pElemP EpE.\nhave [EpF _]:= pmaxElemP maxF; have{EpF} [sFG abelF] := pElemP EpF.\nhave [V] := abelem_split_dprod abelE sUE; case/dprodP=> _ defE cUV tiUV.\nhave [W] := abelem_split_dprod abelF sUF; case/dprodP=> _ defF _ tiUW.\nhave [sVE sWF]: V \\subset E /\\ W \\subset F by rewrite -defE -defF !mulG_subr.\nhave [sVG sWG] := (subset_trans sVE sEG, subset_trans sWF sFG).\nrewrite -defE -defF !TI_cardMg // leq_pmul2l ?cardG_gt0 //.\nrewrite -(leq_pmul2r (cardG_gt0 'C_G(W))) mul_cardG.\nrewrite card_subcent_extraspecial // mulnCA Lagrange // mulnC.\nrewrite leq_mul ?subset_leq_card //; last by rewrite mul_subG ?subsetIl.\napply: subset_trans (sub1G _); rewrite -tiUV !subsetI subsetIl subIset ?sVE //=.\nrewrite -(pmaxElem_LdivP p_pr maxF) -defF centM -!setIA -(setICA 'C(W)).\nrewrite setIC (setIA G) setIS // subsetI cUV sub_LdivT.\nby case/and3P: (abelemS sVE abelE).\nQed."
}
{
  "statement": "Lemma det0P n (A : 'M[R]_n) :\n  reflect (exists2 v : 'rV[R]_n, v != 0 & v *m A = 0) (\\det A == 0).\n",
  "proof": "Proof.\napply: (iffP eqP) => [detA0 | [v n0v vA0]]; last first.\n  apply: contraNeq n0v => nz_detA; rewrite -(inj_eq (scalemx_inj nz_detA)).\n  by rewrite scaler0 -mul_mx_scalar -mul_mx_adj mulmxA vA0 mul0mx.\nelim: n => [|n IHn] in A detA0 *.\n  by case/idP: (oner_eq0 R); rewrite -detA0 [A]thinmx0 -(thinmx0 1%:M) det1.\nhave [{detA0}A'0 | nzA'] := eqVneq (row 0 (\\adj A)) 0; last first.\n  exists (row 0 (\\adj A)) => //; rewrite rowE -mulmxA mul_adj_mx detA0.\n  by rewrite mul_mx_scalar scale0r.\npose A' := col' 0 A; pose vA := col 0 A.\nhave defA: A = row_mx vA A'.\n  apply/matrixP=> i j /[!mxE].\n  by case: split_ordP => j' -> /[!(mxE, ord1)]; congr (A i _); apply: val_inj.\nhave{IHn} w_ j : exists w : 'rV_n.+1, [/\\ w != 0, w 0 j = 0 & w *m A' = 0].\n  have [|wj nzwj wjA'0] := IHn (row' j A').\n    by apply/eqP; move/rowP/(_ j)/eqP: A'0; rewrite !mxE mulf_eq0 signr_eq0.\n  exists (\\row_k oapp (wj 0) 0 (unlift j k)).\n  rewrite !mxE unlift_none -wjA'0; split=> //.\n    apply: contraNneq nzwj => w0; apply/eqP/rowP=> k'.\n    by move/rowP/(_ (lift j k')): w0; rewrite !mxE liftK.\n  apply/rowP=> k; rewrite !mxE (bigD1_ord j) //= mxE unlift_none mul0r add0r.\n  by apply: eq_big => //= k'; rewrite !mxE/= liftK.\nhave [w0 [/rV0Pn[j nz_w0j] w00_0 w0A']] := w_ 0; pose a0 := (w0 *m vA) 0 0.\nhave{w_} [wj [nz_wj wj0_0 wjA']] := w_ j; pose aj := (wj *m vA) 0 0.\nhave [aj0 | nz_aj] := eqVneq aj 0.\n  exists wj => //; rewrite defA (@mul_mx_row _ _ _ 1) [_ *m _]mx11_scalar -/aj.\n  by rewrite aj0 raddf0 wjA' row_mx0.\nexists (aj *: w0 - a0 *: wj).\n  apply: contraNneq nz_aj; move/rowP/(_ j)/eqP; rewrite !mxE wj0_0 mulr0 subr0.\n  by rewrite mulf_eq0 (negPf nz_w0j) orbF.\nrewrite defA (@mul_mx_row _ _ _ 1) !mulmxBl -!scalemxAl w0A' wjA' !linear0.\nby rewrite -mul_mx_scalar -mul_scalar_mx -!mx11_scalar subrr addr0 row_mx0.\nQed."
}
{
  "statement": "Lemma LUP_card_GL n : n > 0 ->\n  #|'GL_n[F]| = (#|F| ^ 'C(n, 2) * \\prod_(1 <= i < n.+1) (#|F| ^ i - 1))%N.\n",
  "proof": "Proof.\ncase: n => // n' _; set n := n'.+1; set p := #|F|.\nrewrite cardsT /= card_sub /GRing.unit /= big_add1 /= -bin2_sum -/n /=.\nelim: {n'}n => [|n IHn].\n  rewrite !big_geq // mul1n (@eq_card _ _ predT) ?card_mx //= => M.\n  by rewrite {1}[M]flatmx0 -(flatmx0 1%:M) unitmx1.\nrewrite !big_nat_recr //= expnD mulnAC mulnA -{}IHn -mulnA mulnC.\nset LHS := #|_|; rewrite -[n.+1]muln1 -{2}[n]mul1n {}/LHS.\nrewrite -!card_mx subn1 -(cardC1 0) -mulnA; set nzC := predC1 _.\nrewrite -sum1_card (partition_big lsubmx nzC) => [|A]; last first.\n  rewrite unitmxE unitfE; apply: contra; move/eqP=> v0.\n  rewrite -[A]hsubmxK v0 -[n.+1]/(1 + n)%N -col_mx0.\n  rewrite -[rsubmx _]vsubmxK -det_tr tr_row_mx !tr_col_mx !trmx0.\n  by rewrite det_lblock [0]mx11_scalar det_scalar1 mxE mul0r.\nrewrite -sum_nat_const; apply: eq_bigr => /= v /cV0Pn[k nza].\nhave xrkK: involutive (@xrow F _ _ 0 k).\n  by move=> m A /=; rewrite /xrow -row_permM tperm2 row_perm1.\nrewrite (reindex_inj (inv_inj (xrkK (1 + n)%N))) /= -[n.+1]/(1 + n)%N.\nrewrite (partition_big ursubmx xpredT) //= -sum_nat_const.\napply: eq_bigr => u _; set a : F := v _ _ in nza.\nset v1 : 'cV_(1 + n) := xrow 0 k v.\nhave def_a: usubmx v1 = a%:M.\n  by rewrite [_ v1]mx11_scalar mxE lshift0 mxE tpermL.\npose Schur := dsubmx v1 *m (a^-1 *: u).\npose L : 'M_(1 + n) := block_mx a%:M 0 (dsubmx v1) 1%:M.\npose U B : 'M_(1 + n) := block_mx 1 (a^-1 *: u) 0 B.\nrewrite (reindex (fun B => L *m U B)); last first.\n  exists (fun A1 => drsubmx A1 - Schur) => [B _ | A1].\n    by rewrite mulmx_block block_mxKdr mul1mx addrC addKr.\n  rewrite !inE mulmx_block !mulmx0 mul0mx !mulmx1 !addr0 mul1mx addrC subrK.\n  rewrite mul_scalar_mx scalerA divff // scale1r andbC; case/and3P => /eqP <- _.\n  rewrite -{1}(hsubmxK A1) xrowE mul_mx_row row_mxKl -xrowE => /eqP def_v.\n  rewrite -def_a block_mxEh vsubmxK /v1 -def_v xrkK.\n  apply: trmx_inj; rewrite tr_row_mx tr_col_mx trmx_ursub trmx_drsub trmx_lsub.\n  by rewrite hsubmxK vsubmxK.\nrewrite -sum1_card; apply: eq_bigl => B; rewrite xrowE unitmxE.\nrewrite !det_mulmx unitrM -unitmxE unitmx_perm det_lblock det_ublock.\nrewrite !det_scalar1 det1 mulr1 mul1r unitrM unitfE nza -unitmxE.\nrewrite mulmx_block !mulmx0 mul0mx !addr0 !mulmx1 mul1mx block_mxKur.\nrewrite mul_scalar_mx scalerA divff // scale1r eqxx andbT.\nby rewrite block_mxEh mul_mx_row row_mxKl -def_a vsubmxK -xrowE xrkK eqxx andbT.\nQed."
}
{
  "statement": "Lemma card_linear_irr (sG : irrType G) :\n    [pchar F]^'.-group G -> group_splitting_field G ->\n  #|linear_irr sG| = #|G : G^`(1)|%g.\n",
  "proof": "Proof.\nmove=> F'G splitG; apply/eqP.\nwlog sGq: / irrType (G / G^`(1))%G by apply: socle_exists.\nhave [_ nG'G] := andP (der_normal 1 G); apply/eqP; rewrite -card_quotient //.\nhave cGqGq: abelian (G / G^`(1))%g by apply: sub_der1_abelian.\nhave F'Gq: [pchar F]^'.-group (G / G^`(1))%g by apply: morphim_pgroup.\nhave splitGq: group_splitting_field (G / G^`(1))%G.\n  exact: quotient_splitting_field.\nrewrite -(sum_irr_degree_pchar sGq) // -sum1_card.\npose rG (j : sGq) := morphim_repr (socle_repr j) nG'G.\nhave irrG j: mx_irreducible (rG j) by apply/morphim_mx_irr; apply: socle_irr.\nrewrite (reindex (fun j => irr_comp sG (rG j))) /=.\n  apply: eq_big => [j | j _]; last by rewrite irr_degree_abelian.\n  have [_ lin_j _ _] := rsim_irr_comp_pchar sG F'G (irrG j).\n  by rewrite inE -lin_j -irr_degreeE irr_degree_abelian.\npose sGlin := {i | i \\in linear_irr sG}.\nhave sG'k (i : sGlin) : G^`(1)%g \\subset rker (irr_repr (val i)).\n  by case: i => i /= /[!inE] lin; rewrite rker_linear //=; apply/eqP.\npose h' u := irr_comp sGq (quo_repr (sG'k u) nG'G).\nhave irrGq u: mx_irreducible (quo_repr (sG'k u) nG'G).\n  by apply/quo_mx_irr; apply: socle_irr.\nexists (fun i => oapp h' [1 sGq]%irr (insub i)) => [j | i] lin_i.\n  rewrite (insubT [in _] lin_i) /=; apply/esym/eqP/socle_rsimP.\n  apply: mx_rsim_trans (rsim_irr_comp_pchar sGq F'Gq (irrGq _)).\n  have [g lin_g inj_g hom_g] := rsim_irr_comp_pchar sG F'G (irrG j).\n  exists g => [||G'x]; last 1 [case/morphimP=> x _ Gx ->] || by [].\n  by rewrite quo_repr_coset ?hom_g.\nrewrite (insubT (mem _) lin_i) /=; apply/esym/eqP/socle_rsimP.\nset u := Sub i lin_i.\napply: mx_rsim_trans (rsim_irr_comp_pchar sG F'G (irrG _)).\nhave [g lin_g inj_g hom_g] := rsim_irr_comp_pchar sGq F'Gq (irrGq u).\nexists g => [||x Gx]; last 1 [have:= hom_g (coset _ x)] || by [].\nby rewrite quo_repr_coset; first by apply; rewrite mem_quotient.\nQed."
}
{
  "statement": "Lemma classg_base_center : (classg_base :=: 'Z(R_G))%MS.\n",
  "proof": "Proof.\napply/eqmxP/andP; split.\n  apply/row_subP=> k; rewrite rowK /gset_mx sub_capmx {1}linear_sum.\n  have [x Gx ->{k}] := imsetP (enum_valP k); have sxGG := groupCl Gx.\n  rewrite summx_sub => [|y xGy]; last by rewrite envelop_mx_id ?sxGG.\n  rewrite memmx_cent_envelop; apply/centgmxP=> y Gy.\n  rewrite {2}(reindex_acts 'J _ Gy) ?astabsJ ?class_norm //=.\n  rewrite mulmx_suml mulmx_sumr; apply: eq_bigr => z; move/sxGG=> Gz.\n  by rewrite -!repr_mxM ?groupJ -?conjgC.\napply/memmx_subP=> A; rewrite sub_capmx memmx_cent_envelop.\ncase/andP=> /envelop_mxP[a ->{A}] cGa.\nrewrite (partition_big_imset (class^~ G)) -/(classes G) /=.\nrewrite linear_sum summx_sub //= => xG GxG; have [x Gx def_xG] := imsetP GxG.\napply: submx_trans (scalemx_sub (a x) (submx_refl _)).\nrewrite (eq_row_sub (enum_rank_in GxG xG)) // linearZ /= rowK enum_rankK_in //.\nrewrite !linear_sum {xG GxG}def_xG; apply: eq_big  => [y | xy] /=.\n  apply/idP/andP=> [| [_ xGy]]; last by rewrite -(eqP xGy) class_refl.\n  by case/imsetP=> z Gz ->; rewrite groupJ // classGidl.\ncase/imsetP=> y Gy ->{xy}; rewrite linearZ; congr (_ *: _).\nmove/(canRL (repr_mxK aG Gy)): (centgmxP cGa y Gy); have Gy' := groupVr Gy.\nmove/(congr1 (gring_proj x)); rewrite -mulmxA mulmx_suml !linear_sum.\nrewrite (bigD1 x Gx) big1 => [|z /andP[Gz]]; rewrite linearZ /=; last first.\n  by rewrite eq_sym gring_projE // => /negPf->; rewrite scaler0.\nrewrite gring_projE // eqxx scalemx1 (bigD1 (x ^ y)%g) ?groupJ //=.\nrewrite big1 => [|z /andP[Gz]]; rewrite -scalemxAl 2!linearZ /=.\n  rewrite !addr0 -!repr_mxM ?groupM // mulgA mulKVg mulgK => /rowP/(_ 0).\n  by rewrite gring_projE // eqxx scalemx1 !mxE.\nrewrite eq_sym -(can_eq (conjgKV y)) conjgK conjgE invgK.\nby rewrite -!repr_mxM ?gring_projE ?groupM // => /negPf->; rewrite scaler0.\nQed."
}
{
  "statement": "Theorem primes_class_simple_gt1 C :\n  simple G -> ~~ abelian G -> C \\in (classes G)^# -> (size (primes #|C|) > 1)%N.\n",
  "proof": "Proof.\nmove=> simpleG not_cGG /setD1P[ntC /imsetP[g Gg defC]].\nhave{ntC} nt_g: g != 1%g by rewrite defC classG_eq1 in ntC.\nrewrite ltnNge {C}defC; set m := #|_|; apply/negP=> p_natC.\nhave{p_natC} [p p_pr [a Dm]]: {p : nat & prime p & {a | m = p ^ a}%N}.\n  have /prod_prime_decomp->: (0 < m)%N by rewrite /m -index_cent1.\n  rewrite prime_decompE; case Dpr: (primes _) p_natC => [|p []] // _.\n    by exists 2%N => //; rewrite big_nil; exists 0.\n  rewrite big_seq1; exists p; last by exists (logn p m).\n  by have:= mem_primes p m; rewrite Dpr mem_head => /esym/and3P[].\nhave{simpleG} [ntG minG] := simpleP _ simpleG.\npose p_dv1 i := (p %| 'chi[G]_i 1%g)%C.\nhave p_dvd_supp_g i: ~~ p_dv1 i && (i != 0) -> 'chi_i g = 0.\n  rewrite /p_dv1 irr1_degree dvdC_nat -prime_coprime // => /andP[co_p_i1 nz_i].\n  have fful_i: cfker 'chi_i = [1].\n    have /minG[//|/eqP] := cfker_normal 'chi_i.\n    by rewrite eqEsubset subGcfker (negPf nz_i) andbF.\n  have trivZ: 'Z(G) = [1] by have /minG[|/center_idP/idPn] := center_normal G.\n  have trivZi: ('Z('chi_i))%CF = [1].\n    apply/trivgP; rewrite -quotient_sub1 ?norms1 //= -fful_i cfcenter_eq_center.\n    rewrite fful_i subG1 -(isog_eq1 (isog_center (quotient1_isog G))) /=.\n    by rewrite trivZ.\n  rewrite coprime_degree_support_cfcenter ?trivZi ?inE //.\n  by rewrite -/m Dm irr1_degree natrK coprime_sym coprimeXl.\npose alpha := \\sum_(i | p_dv1 i && (i != 0)) 'chi_i 1%g / p%:R * 'chi_i g.\nhave nz_p: p%:R != 0 :> algC by rewrite pnatr_eq0 -lt0n prime_gt0.\nhave Dalpha: alpha = - 1 / p%:R.\n  apply/(canRL (mulfK nz_p))/eqP; rewrite -addr_eq0 addrC; apply/eqP/esym.\n  transitivity (cfReg G g); first by rewrite cfRegE (negPf nt_g).\n  rewrite cfReg_sum sum_cfunE (bigD1 0) //= irr0 !cfunE cfun11 cfun1E Gg.\n  rewrite mulr1; congr (1 + _); rewrite (bigID p_dv1) /= addrC big_andbC.\n  rewrite big1 => [|i /p_dvd_supp_g chig0]; last by rewrite cfunE chig0 mulr0.\n  rewrite add0r big_andbC mulr_suml; apply: eq_bigr => i _.\n  by rewrite mulrAC divfK // cfunE.\nsuffices: (p %| 1)%C by rewrite (dvdC_nat p 1) dvdn1 -(subnKC (prime_gt1 p_pr)).\nrewrite unfold_in (negPf nz_p).\nrewrite Cint_rat_Aint ?rpred_div ?rpred1 ?rpred_nat //.\nrewrite -rpredN // -mulNr -Dalpha rpred_sum // => i /andP[/dvdCP[c Zc ->] _].\nby rewrite mulfK // rpredM ?Aint_irr ?Aint_Cint.\nQed."
}
{
  "statement": "Theorem inertia_Frobenius_ker i : i != 0 -> 'I_G['chi[K]_i] = K.\n",
  "proof": "Proof.\nhave [_ _ nsKG regK] := Frobenius_kerP frobGK; have [sKG nKG] := andP nsKG.\nmove=> nzi; apply/eqP; rewrite eqEsubset sub_Inertia // andbT.\napply/subsetP=> x /setIP[Gx /setIdP[nKx /eqP x_stab_i]].\nhave actIirrK: is_action G (@conjg_Iirr _ K).\n  split=> [y j k eq_jk | j y z Gy Gz].\n    by apply/irr_inj/(can_inj (cfConjgK y)); rewrite -!conjg_IirrE eq_jk.\n  by apply: irr_inj; rewrite !conjg_IirrE (cfConjgM _ nsKG).\npose ito := Action actIirrK; pose cto := ('Js \\ (subsetT G))%act.\nhave acts_Js : [acts G, on classes K | 'Js].\n  apply/subsetP=> y Gy; have nKy := subsetP nKG y Gy.\n  rewrite !inE; apply/subsetP=> _ /imsetP[z Gz ->] /[!inE]/=.\n  rewrite -class_rcoset norm_rlcoset // class_lcoset.\n  by apply: imset_f; rewrite memJ_norm.\nhave acts_cto : [acts G, on classes K | cto] by rewrite astabs_ract subsetIidl.\npose m := #|'Fix_(classes K | cto)[x]|.\nhave def_m: #|'Fix_ito[x]| = m.\n  apply: card_afix_irr_classes => // j y _ Ky /imsetP[_ /imsetP[z Kz ->] ->].\n  by rewrite conjg_IirrE cfConjgEJ // cfunJ.\nhave: (m != 1)%N.\n  rewrite -def_m (cardD1 (0 : Iirr K)) (cardD1 i) !(inE, sub1set) /=.\n  by rewrite conjg_Iirr0 nzi eqxx -(inj_eq irr_inj) conjg_IirrE x_stab_i eqxx.\napply: contraR => notKx; apply/cards1P; exists 1%g; apply/esym/eqP.\nrewrite eqEsubset !(sub1set, inE) classes1 /= conjs1g eqxx /=.\napply/subsetP=> _ /setIP[/imsetP[y Ky ->] /afix1P /= cyKx].\nhave /imsetP[z Kz def_yx]: y ^ x \\in y ^: K.\n  by rewrite -cyKx; apply: imset_f; apply: class_refl.\nrewrite inE classG_eq1; apply: contraR notKx => nty.\nrewrite -(groupMr x (groupVr Kz)).\napply: (subsetP (regK y _)); first exact/setD1P.\nrewrite !inE groupMl // groupV (subsetP sKG) //=.\nby rewrite conjg_set1 conjgM def_yx conjgK.\nQed."
}
{
  "statement": "Lemma holds_ex_elim: GRing.valid_QE_proj ex_elim.\n",
  "proof": "Proof.\nmove=> i [ps qs] /= e; case/andP=> /= rps rqs.\nrewrite ex_elim_seqP big_map.\nhave -> : \\big[@rgcdp _/0%:P]_(j <- ps) eval_poly e (abstrX i j) =\n          \\big[@rgcdp _/0%:P]_(j <- (map (eval_poly e) (map (abstrX i) (ps)))) j.\n  by rewrite !big_map.\nrewrite -!map_comp.\n  have aux I (l : seq I) (P : I -> {poly F}) :\n    \\big[(@gcdp F)/0]_(j <- l) P j %= \\big[(@rgcdp F)/0]_(j <- l) P j.\n    elim: l => [| u l ihl] /=; first by rewrite !big_nil eqpxx.\n    rewrite !big_cons; move: ihl; move/(eqp_gcdr (P u)) => h.\n    by apply: eqp_trans h _; rewrite eqp_sym; apply: eqp_rgcd_gcd.\ncase g0: (\\big[(@rgcdp F)/0%:P]_(j <- map (eval_poly e \\o abstrX i) ps) j == 0).\n  rewrite (eqP g0) rgdcop0.\n  case m0 : (_ == 0)=> //=; rewrite ?(size_poly1,size_poly0) //=.\n    rewrite abstrX_bigmul eval_bigmul -bigmap_id in m0.\n    constructor=> [[x] // []] //.\n    case=> _; move/holds_conjn=> hc; move/hc:rqs.\n    by rewrite -root_bigmul //= (eqP m0) root0.\n  constructor; move/negP:m0; move/negP=>m0.\n  case: (closed_nonrootP F_closed _ m0) => x {m0}.\n  rewrite abstrX_bigmul eval_bigmul -bigmap_id root_bigmul=> m0.\n  exists x; do 2?constructor=> //; last by apply/holds_conjn.\n  apply/holds_conj; rewrite //= -root_biggcd.\n  by rewrite (eqp_root (aux _ _ _ )) (eqP g0) root0.\napply: (iffP (closed_rootP F_closed _)) => -[x Px]; exists x; move: Px => //=.\n  rewrite (eqp_root (@eqp_rgdco_gdco F _ _)) root_gdco ?g0 //.\n  rewrite -(eqp_root (aux _ _ _ )) root_biggcd  abstrX_bigmul eval_bigmul.\n  rewrite -bigmap_id root_bigmul; case/andP=> psr qsr.\n  do 2?constructor; first by apply/holds_conj.\n  by apply/holds_conjn.\nrewrite (eqp_root(@eqp_rgdco_gdco F _ _)) root_gdco?g0// -(eqp_root(aux _ _ _)).\nrewrite root_biggcd abstrX_bigmul eval_bigmul -bigmap_id.\nrewrite root_bigmul=> [[] // [hps hqs]]; apply/andP.\nconstructor; first by apply/holds_conj.\nby apply/holds_conjn.\nQed."
}
{
  "statement": "Lemma card_sorted_tuples m n :\n  #|[set t : m.-tuple 'I_n.+1 | sorted leq (map val t)]| = 'C(m + n, m).\n",
  "proof": "Proof.\nset In1 := 'I_n.+1; pose x0 : In1 := ord0.\nhave add_mnP (i : 'I_m) (x : In1) : i + x < m + n.\n  by rewrite -ltnS -addSn -!addnS leq_add.\npose add_mn t i := Ordinal (add_mnP i (tnth t i)).\npose add_mn_nat (t : m.-tuple In1) i := i + nth x0 t i.\nhave add_mnC t: val \\o add_mn t =1 add_mn_nat t \\o val.\n  by move=> i; rewrite /= (tnth_nth x0).\npose f_add t := [tuple of map (add_mn t) (ord_tuple m)].\nrewrite -card_ltn_sorted_tuples -!sum1dep_card (reindex f_add) /=.\n  apply: eq_bigl => t; rewrite -map_comp (eq_map (add_mnC t)) map_comp.\n  rewrite enumT unlock val_ord_enum -[in LHS](drop0 t).\n  have [m0 | m_gt0] := posnP m.\n    by rewrite {2}m0 /= drop_oversize // size_tuple m0.\n  have def_m := subnK m_gt0; rewrite -{2}def_m addn1 /= {1}/add_mn_nat.\n  move: 0 (m - 1) def_m => i k; rewrite -[in RHS](size_tuple t) => def_m.\n  rewrite (drop_nth x0) /=; last by rewrite -def_m leq_addl.\n  elim: k i (nth x0 t i) def_m => [|k IHk] i x /=.\n    by rewrite add0n => ->; rewrite drop_size.\n  rewrite addSnnS => def_m; rewrite -addSn leq_add2l -IHk //.\n  by rewrite (drop_nth x0) // -def_m leq_addl.\npose sub_mn (t : m.-tuple 'I_(m + n)) i : In1 := inord (tnth t i - i).\nexists (fun t => [tuple of map (sub_mn t) (ord_tuple m)]) => [t _ | t].\n  apply: eq_from_tnth => i; apply: val_inj.\n  by rewrite /sub_mn !(tnth_ord_tuple, tnth_map) addKn inord_val.\nrewrite inE /= => inc_t; apply: eq_from_tnth => i; apply: val_inj.\nrewrite tnth_map tnth_ord_tuple /= tnth_map tnth_ord_tuple.\nsuffices [le_i_ti le_ti_ni]: i <= tnth t i /\\ tnth t i <= i + n.\n  by rewrite /sub_mn inordK ?subnKC // ltnS leq_subLR.\npose y0 := tnth t i; rewrite (tnth_nth y0) -(nth_map _ (val i)) ?size_tuple //.\ncase def_e: (map _ _) => [|x e] /=; first by rewrite nth_nil ?leq_addr.\nset nth_i := nth (i : nat); rewrite def_e in inc_t; split.\n  have: i < size (x :: e) by rewrite -def_e size_map size_tuple ltn_ord.\n  elim: (val i) => //= j IHj lt_j_e.\n  by apply: leq_trans (pathP (val i) inc_t _ lt_j_e); rewrite ltnS IHj 1?ltnW.\nmove: (_ - _) (subnK (valP i)) => k /=.\nelim: k (val i) => /= [|k IHk] j; rewrite -ltnS -addSn ?add0n => def_m.\n  by rewrite def_m -def_e /nth_i (nth_map y0) ?ltn_ord // size_tuple -def_m.\nrewrite (leq_trans _ (IHk _ _)) -1?addSnnS //; apply: (pathP _ inc_t).\nrewrite -ltnS (leq_trans (leq_addl k _)) // -addSnnS def_m.\nby rewrite -(size_tuple t) -(size_map val) def_e.\nQed."
}
{
  "statement": "Lemma egcdp_recP : forall k p q, q != 0 -> size q <= k -> size q <= size p ->\n  let e := (egcdp_rec p q k) in\n    [/\\ size e.1 <= size q, size e.2 <= size p & gcdp p q %= e.1 * p + e.2 * q].\n",
  "proof": "Proof.\nelim=> [|k ihk] p q /= qn0; first by rewrite size_poly_leq0 (negPf qn0).\nmove=> sqSn qsp; rewrite (negPf qn0).\nhave sp : size p > 0 by apply: leq_trans qsp; rewrite size_poly_gt0.\nhave [r0 | rn0] /= := eqVneq (p %%q) 0.\n  rewrite r0 /egcdp_rec; case: k ihk sqSn => [|n] ihn sqSn /=.\n    rewrite !scaler0 !mul0r subr0 add0r mul1r size_poly0 size_poly1.\n    by rewrite dvdp_gcd_idr /dvdp ?r0.\n  rewrite !eqxx mul0r scaler0 /= mul0r add0r subr0 mul1r size_poly0 size_poly1.\n  by rewrite dvdp_gcd_idr /dvdp ?r0 //.\nhave h1 : size (p %% q) <= k.\n  by rewrite -ltnS; apply: leq_trans sqSn; rewrite ltn_modp.\nhave h2 : size (p %% q) <= size q by rewrite ltnW // ltn_modp.\nhave := ihk q (p %% q) rn0 h1 h2.\ncase: (egcdp_rec _ _)=> u v /= => [[ihn'1 ihn'2 ihn'3]].\nrewrite gcdpE ltnNge qsp //= (eqp_ltrans (gcdpC _ _)); split; last first.\n- apply: (eqp_trans ihn'3).\n  rewrite mulrBl addrCA -scalerAl scalerAr -mulrA -mulrBr.\n  by rewrite divp_eq addrAC subrr add0r eqpxx.\n- apply: (leq_trans (size_polyD _ _)).\n  have [-> | vn0] := eqVneq v 0.\n    rewrite mul0r size_polyN size_poly0 maxn0; apply: leq_trans ihn'1 _.\n    exact: leq_modp.\n  have [-> | qqn0] := eqVneq (p %/ q) 0.\n    rewrite mulr0 size_polyN size_poly0 maxn0; apply: leq_trans ihn'1 _.\n    exact: leq_modp.\n  rewrite geq_max (leq_trans ihn'1) ?leq_modp //= size_polyN size_mul //.\n  move: (ihn'2); rewrite (polySpred vn0) (polySpred qn0).\n  rewrite -(ltn_add2r (size (p %/ q))) !addSn /= ltnS; move/leq_trans; apply.\n  rewrite size_divp // addnBA ?addKn //.\n  by apply: leq_trans qsp; apply: leq_pred.\n- by rewrite size_scale // lc_expn_scalp_neq0.\nQed."
}
{
  "statement": "Lemma codiagonalizableP n (fs : seq 'M[F]_n) :\n  {in fs &, forall f g, comm_mx f g} /\\ (forall f, f \\in fs -> diagonalizable f)\n  <-> codiagonalizable fs.\n",
  "proof": "Proof.\nsplit => [cdfs|[P Punit /allP/= fsD]]/=; last first.\n  split; last by exists P; rewrite // fsD.\n  move=> f g ffs gfs; move=> /(_ _ _)/similar_diagPex/sigW in fsD.\n  have [[df /similarLR->//] [dg /similarLR->//]] := (fsD _ ffs, fsD _ gfs).\n  by rewrite /comm_mx -!conjmxM 1?diag_mxC// inE stablemx_unit ?unitmx_inv.\nmove: cdfs => [/(rwP (all_comm_mxP _)).1 cdfs1 cdfs2].\nhave [k] := ubnP (size fs); elim: k => [|k IHk]//= in n fs cdfs1 cdfs2 *.\ncase: fs cdfs1 cdfs2 => [|f fs]//=; first by exists 1%:M; rewrite ?unitmx1.\nrewrite ltnS all_comm_mx_cons => /andP[/allP/(_ _ _)/eqP ffsC fsC dffs] fsk.\nhave /diagonalizablePeigen [rs urs rs1] := dffs _ (mem_head _ _).\nrewrite (big_nth 0) big_mkord in rs1.\nhave efg (i : 'I_(size rs)) g : g \\in f :: fs -> stablemx (eigenspace f rs`_i) g.\n   case: n => [|n'] in g f fs ffsC fsC {dffs rs1 fsk} * => g_ffs.\n      by rewrite thinmx0 sub0mx.\n  rewrite comm_mx_stable_eigenspace//.\n  by move: g_ffs; rewrite !inE => /predU1P [->//|/ffsC].\napply/(@codiagonalizable_on _ _ _ (_ :: _) rs1) => [|i|i /=].\n- apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\n- by apply/allP => g g_ffs; rewrite efg.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free//.\nset gs := map _ _; suff [P Punit /= Pgs] : codiagonalizable gs.\n  exists P; rewrite /= ?Pgs ?andbT// /similar_to.\n  by rewrite conjmx_scalar ?mx_scalar_is_diag// row_free_unit.\napply: IHk; rewrite ?size_map/= ?ltnS//.\n  apply/all_comm_mxP => _ _ /mapP[/= g gfs ->] /mapP[/= h hfs ->].\n  rewrite -!conjmxM ?inE ?stablemx_row_base ?efg ?inE ?gfs ?hfs ?orbT//.\n  by rewrite (all_comm_mxP _ fsC).\nmove=> _ /mapP[/= g gfs ->].\nhave: stablemx (row_base (eigenspace f rs`_i)) g.\n  by rewrite stablemx_row_base efg// inE gfs orbT.\nhave := dffs g; rewrite inE gfs orbT => /(_ isT) [P Punit].\nmove=> /similar_diagPex[D /(similarLR Punit)->] sePD.\nhave rfeP : row_free (row_base (eigenspace f rs`_i) *m invmx P).\n  by rewrite /row_free mxrankMfree ?row_free_unit ?unitmx_inv// eq_row_base.\nrewrite -conjMumx ?unitmx_inv ?row_base_free//.\napply/diagonalizable_conj_diag => //.\nby rewrite stablemx_comp// stablemx_unit ?unitmx_inv.\nQed."
}
{
  "statement": "Lemma totient_count_coprime n : totient n = \\sum_(0 <= d < n) coprime n d.\n",
  "proof": "Proof.\nelim/ltn_ind: n => // n IHn.\ncase: (leqP n 1) => [|lt1n]; first by rewrite unlock; case: (n) => [|[]].\npose p := pdiv n; have p_pr: prime p by apply: pdiv_prime.\nhave p1 := prime_gt1 p_pr; have p0 := ltnW p1.\npose np := n`_p; pose np' := n`_p^'.\nhave co_npp': coprime np np' by rewrite coprime_partC.\nhave [n0 np0 np'0]: [/\\ n > 0, np > 0 & np' > 0] by rewrite ltnW ?part_gt0.\nhave def_n: n = np * np' by rewrite partnC.\nhave lnp0: 0 < logn p n by rewrite lognE p_pr n0 pdiv_dvd.\npose in_mod k (k0 : k > 0) d := Ordinal (ltn_pmod d k0).\nrewrite {1}def_n totient_coprime // {IHn}(IHn np') ?big_mkord; last first.\n  by rewrite def_n ltn_Pmull // /np p_part -(expn0 p) ltn_exp2l.\nhave ->: totient np = #|[pred d : 'I_np | coprime np d]|.\n  rewrite [np in LHS]p_part totient_pfactor //=; set q := p ^ _.\n  apply: (@addnI (1 * q)); rewrite -mulnDl [1 + _]prednK // mul1n.\n  have def_np: np = p * q by rewrite -expnS prednK // -p_part.\n  pose mulp := [fun d : 'I_q => in_mod _ np0 (p * d)].\n  rewrite -def_np -{1}[np]card_ord -(cardC [in codom mulp]).\n  rewrite card_in_image => [|[d1 ltd1] [d2 ltd2] /= _ _ []]; last first.\n    move/eqP; rewrite def_np -!muln_modr ?modn_small //.\n    by rewrite eqn_pmul2l // => eq_op12; apply/eqP.\n  rewrite card_ord; congr (q + _); apply: eq_card => d /=.\n  rewrite !inE [np in coprime np _]p_part coprime_pexpl ?prime_coprime //.\n  congr (~~ _); apply/codomP/idP=> [[d' -> /=] | /dvdnP[r def_d]].\n    by rewrite def_np -muln_modr // dvdn_mulr.\n  do [rewrite mulnC; case: d => d ltd /=] in def_d *.\n  have ltr: r < q by rewrite -(ltn_pmul2l p0) -def_np -def_d.\n  by exists (Ordinal ltr); apply: val_inj; rewrite /= -def_d modn_small.\npose h (d : 'I_n) := (in_mod _ np0 d, in_mod _ np'0 d).\npose h' (d : 'I_np * 'I_np') := in_mod _ n0 (chinese np np' d.1 d.2).\nrewrite -!big_mkcond -sum_nat_const pair_big (reindex_onto h h') => [|[d d'] _].\n  apply: eq_bigl => [[d ltd] /=]; rewrite !inE -val_eqE /= andbC !coprime_modr.\n  by rewrite def_n -chinese_mod // -coprimeMl -def_n modn_small ?eqxx.\napply/eqP; rewrite /eq_op /= /eq_op /= !modn_dvdm ?dvdn_part //.\nby rewrite chinese_modl // chinese_modr // !modn_small ?eqxx ?ltn_ord.\nQed."
}
{
  "statement": "Lemma codiagonalizableP n (As : seq 'M[F]_n) :\n  {in As &, forall A B, comm_mx A B} /\\ {in As, forall A, diagonalizable A}\n  <-> codiagonalizable As.\n",
  "proof": "Proof.\nsplit => [cdAs|[P Punit /allP/= AsD]]/=; last first.\n  split; last by exists P; rewrite // AsD.\n  move=> A B AAs BAs; move=> /(_ _ _)/diagonalizable_forPex/sigW in AsD.\n  have [[dA /simmxLR->//] [dB /simmxLR->//]] := (AsD _ AAs, AsD _ BAs).\n  by rewrite /comm_mx -!conjmxM 1?diag_mxC// inE stablemx_unit ?unitmx_inv.\nmove: cdAs => -[]; move/(rwP (all_comm_mxP _)) => cdAs cdAs'.\nhave [k] := ubnP (size As); elim: k => [|k IHk]//= in n As cdAs cdAs' *.\ncase: As cdAs cdAs' => [|A As]//=; first by exists 1%:M; rewrite ?unitmx1.\nrewrite ltnS all_comm_mx_cons => /andP[/allP/(_ _ _)/eqP AAsC AsC dAAs] Ask.\nhave /diagonalizablePeigen [rs urs rs1] := dAAs _ (mem_head _ _).\nrewrite (big_nth 0) big_mkord in rs1.\nhave eAB (i : 'I_(size rs)) B : B \\in A :: As -> stablemx (eigenspace A rs`_i) B.\n   case: n => [|n'] in B A As AAsC AsC {dAAs rs1 Ask} * => B_AAs.\n      by rewrite thinmx0 sub0mx.\n  rewrite comm_mx_stable_eigenspace//.\n  by move: B_AAs; rewrite !inE => /predU1P [->//|/AAsC].\napply/(@codiagonalizable_on _ _ _ (_ :: _) rs1) => [|i|i /=].\n- apply: mxdirect_sum_eigenspace => i j _ _ rsij; apply/val_inj.\n  by apply: uniqP rsij; rewrite ?inE.\n- by apply/allP => B B_AAs; rewrite eAB.\nrewrite (@conjmx_eigenvalue _ _ _ rs`_i) ?eq_row_base ?row_base_free//.\nset Bs := map _ _; suff [P Punit /= PBs] : codiagonalizable Bs.\n  exists P; rewrite /= ?PBs ?andbT// /(diagonalizable_for _ _).\n  by rewrite conjmx_scalar ?mx_scalar_is_diag// row_free_unit.\napply: IHk; rewrite ?size_map/= ?ltnS//.\n  apply/all_comm_mxP => _ _ /mapP[/= B BAs ->] /mapP[/= h hAs ->].\n  rewrite -!conjmxM ?inE ?stablemx_row_base ?eAB ?inE ?BAs ?hAs ?orbT//.\n  by rewrite (all_comm_mxP _ AsC).\nmove=> _ /mapP[/= B BAs ->].\nhave: stablemx (row_base (eigenspace A rs`_i)) B.\n  by rewrite stablemx_row_base eAB// inE BAs orbT.\nhave := dAAs B; rewrite inE BAs orbT => /(_ isT) [P Punit].\nmove=> /diagonalizable_forPex[D /(simmxLR Punit)->] sePD.\nhave rAeP : row_free (row_base (eigenspace A rs`_i) *m invmx P).\n  by rewrite /row_free mxrankMfree ?row_free_unit ?unitmx_inv// eq_row_base.\nrewrite -conjMumx ?unitmx_inv ?row_base_free => [|//|//|//].\napply/diagonalizable_conj_diag => //.\nby rewrite stablemx_comp// stablemx_unit ?unitmx_inv.\nQed."
}
{
  "statement": "Theorem Gaschutz_transitive : {in [complements to H in G] &,\n  forall K L,  K :&: P = L :&: P -> exists2 x, x \\in H & L :=: K :^ x}.\n",
  "proof": "Proof.\nmove=> K L /=; set Q := K :&: P => /complP[tiHK eqHK] cpHL QeqLP.\nhave [trHL eqHL] := complP cpHL.\npose nu x := fmod (divgr H L x^-1).\nhave sKG: {subset K <= G} by apply/subsetP; rewrite -eqHK mulG_subr.\nhave sLG: {subset L <= G} by apply/subsetP; rewrite -eqHL mulG_subr.\nhave val_nu x: x \\in G -> val (nu x) = divgr H L x^-1.\n  by move=> Gx; rewrite fmodK // mem_divgr // eqHL groupV.\nhave nu_cocycle: {in G &, forall x y, nu (x * y)%g = nu x ^@ y + nu y}%R.\n  move=> x y Gx Gy; apply: val_inj; rewrite fmvalA fmvalJ ?nHG //.\n  rewrite !val_nu ?groupM // /divgr conjgE !mulgA mulgK.\n  by rewrite !(invMg, remgrM cpHL) ?groupV ?mulgA.\nhave nuL x: x \\in L -> nu x = 0%R.\n  move=> Lx; apply: val_inj; rewrite val_nu ?sLG //.\n  by rewrite /divgr remgr_id ?groupV ?mulgV.\nexists (fmval ((\\sum_(X in rcosets Q K) nu (repr X)) *+ m)).\n  exact: fmodP.\napply/eqP; rewrite eq_sym eqEcard; apply/andP; split; last first.\n  by rewrite cardJg -(leq_pmul2l (cardG_gt0 H)) -!TI_cardMg // eqHL eqHK.\napply/subsetP=> _ /imsetP[x Kx ->]; rewrite conjgE mulgA (conjgC _ x).\nhave Gx: x \\in G by rewrite sKG.\nrewrite conjVg -mulgA -fmvalJ ?nHG // -fmvalN -fmvalA (_ : _ + _ = nu x)%R.\n  by rewrite val_nu // mulKVg groupV mem_remgr // eqHL groupV.\nrewrite actZr -!mulNrn -mulrnDl actr_sum.\nrewrite addrC (reindex_acts _ (actsRs_rcosets _ K) Kx) -sumrB /= -/Q.\nrewrite (eq_bigr (fun _ => nu x)) => [|_ /imsetP[y Ky ->]]; last first.\n  rewrite !rcosetE -rcosetM QeqLP.\n  case: repr_rcosetP => z /setIP[Lz _]; case: repr_rcosetP => t /setIP[Lt _].\n  rewrite !nu_cocycle ?groupM ?(sKG y) // ?sLG //.\n  by rewrite (nuL z) ?(nuL t) // !act0r !add0r addrC addKr.\napply: val_inj; rewrite sumr_const !fmvalZ.\nrewrite -{2}(expgK coHiPG (fmodP (nu x))); congr (_ ^+ _ ^+ _).\nrewrite -[#|_|]divgS ?subsetIl // -(divnMl (cardG_gt0 H)).\nrewrite -!TI_cardMg //; last by rewrite setIA setIAC (setIidPl sHP).\nby rewrite group_modl // eqHK (setIidPr sPG) divgS.\nQed."
}
{
  "statement": "Lemma mx_rsim_standard : mx_rsim rG standard_grepr.\n",
  "proof": "Proof.\npose W i := oapp val 0 (soc i); pose S := (\\sum_i W i)%MS.\nhave C'G: [pchar algC]^'.-group G := algC'G_pchar G.\nhave [defS dxS]: (S :=: 1%:M)%MS /\\ mxdirect S.\n  rewrite /S mxdirectE /= !(bigID soc xpredT) /=.\n  rewrite addsmxC big1 => [|i]; last by rewrite /W; case (soc i).\n  rewrite adds0mx_id addnC (@big1 nat) ?add0n => [|i]; last first.\n    by rewrite /W; case: (soc i); rewrite ?mxrank0.\n  have <-: Socle sG = 1%:M := reducible_Socle1 sG (mx_Maschke_pchar rG C'G).\n  have [W0 _ | noW] := pickP sG; last first.\n    suff no_i: (soc : pred iG) =1 xpred0 by rewrite /Socle !big_pred0 ?mxrank0.\n    by move=> i; rewrite /soc; case: pickP => // W0; have:= noW W0.\n  have irrK Wi: soc (standard_irr Wi) = Some Wi.\n    rewrite /soc; case: pickP => [W' | /(_ Wi)] /= /eqP // eqWi.\n    apply/eqP/socle_rsimP.\n    apply: mx_rsim_trans\n      (rsim_irr_comp_pchar iG C'G (socle_irr _)) (mx_rsim_sym _).\n    by rewrite [irr_comp _ _]eqWi; apply: rsim_irr_comp_pchar (socle_irr _).\n  have bij_irr: {on [pred i | soc i], bijective standard_irr}.\n    exists (odflt W0 \\o soc) => [Wi _ | i]; first by rewrite /= irrK.\n    by rewrite inE /soc /=; case: pickP => //= Wi; move/eqP.\n  rewrite !(reindex standard_irr) {bij_irr}//=.\n  have all_soc Wi: soc (standard_irr Wi) by rewrite irrK.\n  rewrite (eq_bigr val) => [|Wi _]; last by rewrite /W irrK.\n  rewrite !(eq_bigl _ _ all_soc); split=> //.\n  rewrite (eq_bigr (mxrank \\o val)) => [|Wi _]; last by rewrite /W irrK.\n  by rewrite -mxdirectE /= Socle_direct.\npose modW i : mxmodule rG (W i) :=\n  if soc i is Some Wi as oWi return mxmodule rG (oapp val 0 oWi) then\n    component_mx_module rG (socle_base Wi)\n  else mxmodule0 rG n.\napply: mx_rsim_trans (mx_rsim_sym (rsim_submod1 (mxmodule1 rG) _)) _ => //.\napply: mx_rsim_dsum (modW) _ defS dxS _ => i.\nrewrite /W /standard_irr_coef /modW /soc; case: pickP => [Wi|_] /=; last first.\n  rewrite /muln_grepr big_ord0.\n  by exists 0 => [||x _]; rewrite /row_free ?mxrank0 ?mulmx0 ?mul0mx.\nmove/eqP=> <-; apply: mx_rsim_socle.\nexact: rsim_irr_comp_pchar (socle_irr Wi).\nQed."
}
{
  "statement": "Theorem coprime_degree_support_cfcenter g :\n    coprime (Num.truncn ('chi_i 1%g)) #|g ^: G| -> g \\notin ('Z('chi_i))%CF ->\n  'chi_i g = 0.\n",
  "proof": "Proof.\nset m := Num.truncn _ => co_m_gG notZg.\nhave [Gg | /cfun0-> //] := boolP (g \\in G).\nhave Dm: 'chi_i 1%g = m%:R by rewrite truncnK ?Cnat_irr1.\nhave m_gt0: (0 < m)%N by rewrite -ltC_nat -Dm irr1_gt0.\nhave nz_m: m%:R != 0 :> algC by rewrite pnatr_eq0 -lt0n.\npose alpha := 'chi_i g / m%:R.\nhave a_lt1: `|alpha| < 1.\n  rewrite normrM normfV normr_nat -{2}(divff nz_m).\n  rewrite lt_def (can_eq (mulfVK nz_m)) eq_sym -{1}Dm -irr_cfcenterE // notZg.\n  by rewrite ler_pM2r ?invr_gt0 ?ltr0n // -Dm char1_ge_norm ?irr_char.\nhave Za: alpha \\in Aint.\n  have [u _ /dvdnP[v eq_uv]] := Bezoutl #|g ^: G| m_gt0.\n  suffices ->: alpha = v%:R * 'chi_i g - u%:R * (alpha * #|g ^: G|%:R).\n    rewrite rpredB // rpredM ?rpred_nat ?Aint_irr //.\n    by rewrite mulrC mulrA -Dm Aint_class_div_irr1.\n  rewrite -mulrCA -[v%:R](mulfK nz_m) -!natrM -eq_uv (eqnP co_m_gG).\n  by rewrite mulrAC -mulrA -/alpha mulr_natl mulr_natr mulrS addrK.\nhave [Qn galQn [QnC gQnC [_ _ Qn_g]]] := group_num_field_exists <[g]>.\nhave{Qn_g} [a Da]: exists a, QnC a = alpha.\n  rewrite /alpha; have [a <-] := Qn_g _ G _ (irr_char i) g (dvdnn _).\n  by exists (a / m%:R); rewrite fmorph_div rmorph_nat.\nhave Za_nu nu: sval (gQnC nu) alpha \\in Aint by rewrite Aint_aut.\nhave norm_a_nu nu: `|sval (gQnC nu) alpha| <= 1.\n  move: {nu}(sval _) => nu; rewrite fmorph_div rmorph_nat normrM normfV.\n  rewrite normr_nat -Dm -(ler_pM2r (irr1_gt0 (aut_Iirr nu i))) mul1r.\n  congr (_ <= _): (char1_ge_norm g (irr_char (aut_Iirr nu i))).\n  by rewrite !aut_IirrE !cfunE Dm rmorph_nat divfK.\npose beta := QnC (galNorm 1 {:Qn} a).\nhave Dbeta: beta = \\prod_(nu in 'Gal({:Qn} / 1)) sval (gQnC nu) alpha.\n  rewrite /beta rmorph_prod. apply: eq_bigr => nu _.\n  by case: (gQnC nu) => f /= ->; rewrite Da.\nhave Zbeta: beta \\in Num.int.\n  apply: Cint_rat_Aint; last by rewrite Dbeta rpred_prod.\n  rewrite /beta; have /vlineP[/= c ->] := mem_galNorm galQn (memvf a).\n  by rewrite alg_num_field fmorph_rat rpred_rat.\nhave [|nz_a] := boolP (alpha == 0).\n  by rewrite (can2_eq (divfK _) (mulfK _)) // mul0r => /eqP.\nhave: beta != 0 by rewrite Dbeta; apply/prodf_neq0 => nu _; rewrite fmorph_eq0.\nmove/(norm_intr_ge1 Zbeta); rewrite lt_geF //; apply: le_lt_trans a_lt1.\nrewrite -[`|alpha|]mulr1 Dbeta (bigD1 1%g) ?group1 //= -Da.\ncase: (gQnC _) => /= _ <-.\nrewrite gal_id normrM -subr_ge0 -mulrBr mulr_ge0 // Da subr_ge0.\nelim/big_rec: _ => [|nu c _]; first by rewrite normr1 lexx.\napply: le_trans; rewrite -subr_ge0 -{1}[`|c|]mul1r normrM -mulrBl.\nby rewrite mulr_ge0 // subr_ge0 norm_a_nu.\nQed."
}
{
  "statement": "Lemma extend_to_cfdet G N s c0 u :\n    let theta := 'chi_s in let lambda := cfDet theta in let mu := 'chi_u in\n    N <| G -> coprime #|G : N| (Num.truncn (theta 1%g)) ->\n    'Res[N, G] 'chi_c0 = theta -> 'Res[N, G] mu = lambda ->\n  exists2 c, 'Res 'chi_c = theta /\\ cfDet 'chi_c = mu\n          & forall c1, 'Res 'chi_c1 = theta -> cfDet 'chi_c1 = mu -> c1 = c.\n",
  "proof": "Proof.\nmove=> theta lambda mu nsNG; set e := #|G : N|; set f := Num.truncn _.\nset eta := 'chi_c0 => co_e_f etaNth muNlam; have [sNG nNG] := andP nsNG.\nhave fE: f%:R = theta 1%g by rewrite truncnK ?Cnat_irr1.\npose nu := cfDet eta; have lin_nu: nu \\is a linear_char := cfDet_lin_char _.\nhave nuNlam: 'Res nu = lambda by rewrite -cfDetRes ?irr_char ?etaNth.\nhave lin_lam: lambda \\is a linear_char := cfDet_lin_char _.\nhave lin_mu: mu \\is a linear_char.\n  by have:= lin_lam; rewrite -muNlam; apply: cfRes_lin_lin; apply: irr_char.\nhave [Unu Ulam] := (lin_char_unitr lin_nu, lin_char_unitr lin_lam).\npose alpha := mu / nu.\nhave alphaN_1: 'Res[N] alpha = 1 by rewrite rmorph_div //= muNlam nuNlam divrr.\nhave lin_alpha: alpha \\is a linear_char by apply: rpred_div.\nhave alpha_e: alpha ^+ e = 1.\n  have kerNalpha: N \\subset cfker alpha.\n    by rewrite -subsetIidl -cfker_Res ?lin_charW // alphaN_1 cfker_cfun1.\n  apply/eqP; rewrite -(cfQuoK nsNG kerNalpha) -rmorphXn cfMod_eq1 //.\n  rewrite -dvdn_cforder /e -card_quotient //.\n  by rewrite cforder_lin_char_dvdG ?cfQuo_lin_char.\nhave det_alphaXeta b: cfDet (alpha ^+ b * eta) = alpha ^+ (b * f) * nu.\n  by rewrite cfDet_mul_lin ?rpredX ?irr_char // -exprM -(cfRes1 N) etaNth.\nhave [b bf_mod_e]: exists b, b * f = 1 %[mod e].\n  rewrite -(chinese_modl co_e_f 1 0) /chinese !mul0n addn0 !mul1n mulnC.\n  by exists (egcdn f e).1.\nhave alpha_bf: alpha ^+ (b * f) = alpha.\n  by rewrite -(expr_mod _ alpha_e) bf_mod_e expr_mod.\nhave /irrP[c Dc]: alpha ^+ b * eta \\in irr G.\n  by rewrite mul_lin_irr ?rpredX ?mem_irr.\nhave chiN: 'Res 'chi_c = theta.\n  by rewrite -Dc rmorphM rmorphXn /= alphaN_1 expr1n mul1r.\nhave det_chi: cfDet 'chi_c = mu by rewrite -Dc det_alphaXeta alpha_bf divrK.\nexists c => // c2 c2Nth det_c2_mu; apply: irr_inj.\nhave [irrMc _ imMc _] := constt_Ind_ext nsNG chiN.\nhave /codomP[s2 Dc2]: c2 \\in codom (@mul_mod_Iirr G N c).\n  by rewrite -imMc constt_Ind_Res c2Nth constt_irr ?inE.\nhave{} Dc2: 'chi_c2 = ('chi_s2 %% N)%CF * 'chi_c.\n  by rewrite Dc2 cfIirrE // mod_IirrE.\nhave s2_lin: 'chi_s2 \\is a linear_char.\n  rewrite qualifE/= irr_char; apply/eqP/(mulIf (irr1_neq0 c)).\n  rewrite mul1r -[in RHS](cfRes1 N) chiN -c2Nth cfRes1.\n  by rewrite Dc2 cfunE cfMod1.\nhave s2Xf_1: 'chi_s2 ^+ f = 1.\n  apply/(can_inj (cfModK nsNG))/(mulIr (lin_char_unitr lin_mu))/esym.\n  rewrite rmorph1 rmorphXn /= mul1r -{1}det_c2_mu Dc2 -det_chi.\n  by rewrite cfDet_mul_lin ?cfMod_lin_char ?irr_char // -(cfRes1 N) chiN.\nsuffices /eqP s2_1: 'chi_s2 == 1 by rewrite Dc2 s2_1 rmorph1 mul1r.\nrewrite -['chi_s2]expr1 -dvdn_cforder -(eqnP co_e_f) dvdn_gcd.\nby rewrite /e -card_quotient ?cforder_lin_char_dvdG //= dvdn_cforder s2Xf_1.\nQed."
}
{
  "statement": "Lemma rfd_odd (p : {perm T}) : p x = x -> rfd p = p :> bool.\n",
  "proof": "Proof.\nhave rfd1: rfd 1 = 1.\n  by apply/permP => u; apply: val_inj; rewrite permE /= if_same !perm1.\nhave [n] := ubnP #|[set x | p x != x]|; elim: n p => // n IHn p le_p_n px_x.\nhave [p_id | [x1 Hx1]] := set_0Vmem [set x | p x != x].\n  suffices ->: p = 1 by rewrite rfd1 !odd_perm1.\n  by apply/permP => z; apply: contraFeq (in_set0 z); rewrite perm1 -p_id inE.\nhave nx1x: x1 != x by apply: contraTneq Hx1 => ->; rewrite inE px_x eqxx.\nhave npxx1: p x != x1 by apply: contraNneq nx1x => <-; rewrite px_x.\nhave npx1x: p x1 != x by rewrite -px_x (inj_eq perm_inj).\npose p1 := p * tperm x1 (p x1).\nhave fix_p1 y: p y = y -> p1 y = y.\n  by move=> pyy; rewrite permM; have [<-|/perm_inj<-|] := tpermP; rewrite ?pyy.\nhave p1x_x: p1 x = x by apply: fix_p1.\nhave{le_p_n} lt_p1_n: #|[set x | p1 x != x]| < n.\n  move: le_p_n; rewrite ltnS (cardsD1 x1) Hx1; apply/leq_trans/subset_leq_card.\n  rewrite subsetD1 inE permM tpermR eqxx andbT.\n  by apply/subsetP=> y /[!inE]; apply: contraNneq=> /fix_p1->.\ntransitivity (p1 (+) true); last first.\n  by rewrite odd_permM odd_tperm -Hx1 inE eq_sym addbK.\nhave ->: p = p1 * tperm x1 (p x1) by rewrite -tpermV mulgK.\nrewrite morphM; last 2 first; first by rewrite 2!inE; apply/astab1P.\n  by rewrite 2!inE; apply/astab1P; rewrite -[RHS]p1x_x permM px_x.\nrewrite odd_permM IHn //=; congr (_ (+) _).\npose x2 : T' := Sub x1 nx1x; pose px2 : T' := Sub (p x1) npx1x.\nsuffices ->: rfd (tperm x1 (p x1)) = tperm x2 px2.\n  by rewrite odd_tperm eq_sym; rewrite inE in Hx1.\napply/permP => z; apply/val_eqP; rewrite permE /= tpermD // eqxx.\nby rewrite !permE /= -!val_eqE /= !(fun_if sval) /=.\nQed."
}
{
  "statement": "Lemma big_distr_big_dep (I J : finType) j0 (P : pred I) (Q : I -> pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[+%M/0]_(j | Q i j) F i j =\n     \\big[+%M/0]_(f in pfamily j0 P Q) \\big[*%M/1]_(i | P i) F i (f i).\n",
  "proof": "Proof.\npose fIJ := {ffun I -> J}; pose Pf := pfamily j0 (_ : seq I) Q.\nhave [r big_r [Ur mem_r] _] := big_enumP P.\nsymmetry; transitivity (\\big[+%M/0]_(f in Pf r) \\big[*%M/1]_(i <- r) F i (f i)).\n  by apply: eq_big => // f; apply: eq_forallb => i; rewrite /= mem_r.\nrewrite -{P mem_r}big_r; elim: r Ur => /= [_ | i r IHr].\n  rewrite (big_pred1 [ffun=> j0]) ?big_nil //= => f.\n  apply/familyP/eqP=> /= [Df |->{f} i]; last by rewrite ffunE !inE.\n  by apply/ffunP=> i; rewrite ffunE; apply/eqP/Df.\ncase/andP=> /negbTE nri; rewrite big_cons big_distrl => {}/IHr<-.\nrewrite (partition_big (fun f : fIJ => f i) (Q i)) => [|f]; last first.\n  by move/familyP/(_ i); rewrite /= inE /= eqxx.\npose seti j (f : fIJ) := [ffun k => if k == i then j else f k].\napply: eq_bigr => j Qij.\nrewrite (reindex_onto (seti j) (seti j0)) => [|f /andP[_ /eqP fi]]; last first.\n  by apply/ffunP=> k; rewrite !ffunE; case: eqP => // ->.\nrewrite big_distrr; apply: eq_big => [f | f eq_f]; last first.\n  rewrite big_cons ffunE eqxx !big_seq; congr (_ * _).\n  by apply: eq_bigr => k; rewrite ffunE; case: eqP nri => // -> ->.\nrewrite !ffunE !eqxx andbT; apply/andP/familyP=> /= [[Pjf fij0] k | Pff].\n  have /[!(ffunE, inE)] := familyP Pjf k; case: eqP => // -> _.\n  by rewrite nri -(eqP fij0) !ffunE !inE !eqxx.\nsplit; [apply/familyP | apply/eqP/ffunP] => k; have /[!(ffunE, inE)]:= Pff k.\n  by case: eqP => // ->.\nby case: eqP => // ->; rewrite nri /= => /eqP.\nQed."
}
{
  "statement": "Lemma minPoly_decidable_closure\n  (F : fieldType) (L : closedFieldType) (FtoL : {rmorphism F -> L}) x :\n    decidable_embedding FtoL -> integralOver FtoL x ->\n  {p | [/\\ p \\is monic, root (p ^ FtoL) x & irreducible_poly p]}.\n",
  "proof": "Proof.\nmove=> isF /sig2W[p /monicP mon_p px0].\nhave [r Dp] := closed_field_poly_normal (p ^ FtoL); pose n := size r.\nrewrite lead_coef_map {}mon_p rmorph1 scale1r in Dp.\npose Fpx q := (q \\is a polyOver isF) && root q x.\nhave FpxF q: Fpx (q ^ FtoL) = root (q ^ FtoL) x.\n  by rewrite /Fpx polyOver_poly // => j _; apply/sumboolP; exists q`_j.\npose p_ (I : {set 'I_n}) := \\prod_(i <- enum I) ('X - (r`_i)%:P).\nhave{px0 Dp} /ex_minset[I /minsetP[/andP[FpI pIx0] minI]]: exists I, Fpx (p_ I).\n  exists setT; suffices ->: p_ setT = p ^ FtoL by rewrite FpxF.\n  by rewrite Dp (big_nth 0) big_mkord /p_ big_enum; apply/eq_bigl => i /[1!inE].\nhave{p} [p DpI]: {p | p_ I = p ^ FtoL}.\n  exists (p_ I ^ (fun y => if isF y is left Fy then sval (sig_eqW Fy) else 0)).\n  rewrite -map_poly_comp map_poly_id // => y /(allP FpI) /=.\n  by rewrite unfold_in; case: (isF y) => // Fy _; case: (sig_eqW _).\nhave mon_pI: p_ I \\is monic by apply: monic_prod_XsubC.\nhave mon_p: p \\is monic by rewrite -(map_monic FtoL) -DpI.\nexists p; rewrite -DpI; split=> //; split=> [|q nCq q_dv_p].\n  by rewrite -(size_map_poly FtoL) -DpI (root_size_gt1 _ pIx0) ?monic_neq0.\nrewrite -dvdp_size_eqp //; apply/eqP.\nwithout loss mon_q: q nCq q_dv_p / q \\is monic.\n  move=> IHq; pose a := lead_coef q; pose q1 := a^-1 *: q.\n  have nz_a: a != 0 by rewrite lead_coef_eq0 (dvdpN0 q_dv_p) ?monic_neq0.\n  have /IHq IHq1: q1 \\is monic by rewrite monicE lead_coefZ mulVf.\n  by rewrite -IHq1 ?size_scale ?dvdpZl ?invr_eq0.\nwithout loss{nCq} qx0: q mon_q q_dv_p / root (q ^ FtoL) x.\n  have /dvdpP[q1 Dp] := q_dv_p; rewrite DpI Dp rmorphM rootM -implyNb in pIx0.\n  have mon_q1: q1 \\is monic by rewrite Dp monicMr in mon_p.\n  move=> IH; apply: (IH) (implyP pIx0 _) => //; apply: contra nCq => /IH IHq1.\n  rewrite natr1E -(subnn (size q1)) {1}IHq1 ?Dp ?dvdp_mulr //.\n  rewrite polySpred ?monic_neq0 //.\n  by rewrite eqSS size_monicM ?monic_neq0 // -!subn1 subnAC addKn.\nhave /dvdp_prod_XsubC[m Dq]: q ^ FtoL %| p_ I by rewrite DpI dvdp_map.\npose B := [set j in mask m (enum I)]; have{} Dq: q ^ FtoL = p_ B.\n  apply/eqP; rewrite -eqp_monic ?monic_map ?monic_prod_XsubC //.\n  congr (_ %= _): Dq; apply: perm_big => //.\n  by rewrite uniq_perm ?mask_uniq ?enum_uniq // => j; rewrite mem_enum inE.\nrewrite -!(size_map_poly FtoL) Dq -DpI (minI B) // -?Dq ?FpxF //.\nby apply/subsetP=> j /[1!inE] /mem_mask; rewrite mem_enum.\nQed."
}
{
  "statement": "Lemma egcdnP m n : m > 0 -> egcdn_spec m n (egcdn m n).\n",
  "proof": "Proof.\nhave [-> /= | n_gt0 m_gt0] := posnP n; first by split; rewrite // mul1n gcdn0.\nrewrite /egcdn; set s := (s in egcdn_rec _ _ s); pose bz := Bezout_rec n m [::].\nhave: n < s.+1 by []; move defSpec: (egcdn_spec bz.2 bz.1) s => Spec s.\nelim: s => [[]|s IHs] //= in n m (qs := [::]) bz defSpec n_gt0 m_gt0 *.\ncase: edivnP => q r def_m; rewrite n_gt0 ltnS /= => lt_rn le_ns1.\ncase: posnP => [r0 {s le_ns1 IHs lt_rn}|r_gt0]; last first.\n  by apply: IHs => //=; [rewrite natTrecE -def_m | rewrite (leq_trans lt_rn)].\nrewrite {r}r0 addn0 in def_m; set b := odd _; pose d := gcdn m n.\npose km := ~~ b : nat; pose kn := if b then 1 else q.-1.\nrewrite [bz in Spec bz](_ : _ = Bezout_rec km kn qs); last first.\n  by rewrite /kn /km; case: (b) => //=; rewrite natTrecE addn0 muln1.\nhave def_d: d = n by rewrite /d def_m gcdnC gcdnE modnMl gcd0n -[n]prednK.\nhave: km * m + 2 * b * d = kn * n + d.\n  rewrite {}/kn {}/km def_m def_d -mulSnr; case: b; rewrite //= addn0 mul1n.\n  by rewrite prednK //; apply: dvdn_gt0 m_gt0 _; rewrite def_m dvdn_mulr.\nhave{def_m}: kn * d <= m.\n  have q_gt0 : 0 < q by rewrite def_m muln_gt0 n_gt0 ?andbT in m_gt0.\n  by rewrite /kn; case b; rewrite def_d def_m leq_pmul2r // leq_pred.\nhave{def_d}: km * d <= n by rewrite -[n]mul1n def_d leq_pmul2r // leq_b1.\nmove: km {q}kn m_gt0 n_gt0 defSpec; rewrite {}/b {}/d {}/bz.\nelim: qs m n => [|q qs IHq] n r kn kr n_gt0 r_gt0 /=.\n  set d := gcdn n r; rewrite mul0n addn0 => <- le_kn_r _ def_d; split=> //.\n  have d_gt0: 0 < d by rewrite gcdn_gt0 n_gt0.\n  have /ltn_pmul2l<-: 0 < kn by rewrite -(ltn_pmul2r n_gt0) def_d ltn_addl.\n  by rewrite def_d -addn1 leq_add // mulnCA leq_mul2l le_kn_r orbT.\nrewrite !natTrecE; set m := _ + r; set km := _ + kn; pose d := gcdn m n.\nhave ->: gcdn n r = d by rewrite [d]gcdnC gcdnMDl.\nhave m_gt0: 0 < m by rewrite addn_gt0 r_gt0 orbT.\nhave d_gt0: 0 < d by rewrite gcdn_gt0 m_gt0.\nmove=> {}/IHq IHq le_kn_r le_kr_n def_d; apply: IHq => //; rewrite -/d.\n  by rewrite mulnDl leq_add // -mulnA leq_mul2l le_kr_n orbT.\napply: (@addIn d); rewrite mulnDr -addnA addnACA -def_d addnACA mulnA.\nrewrite -!mulnDl -mulnDr -addnA [kr * _]mulnC; congr addn.\nby rewrite addnC addn_negb muln1 mul2n addnn.\nQed."
}
{
  "statement": "Lemma Thompson_critical : p.-group G -> {K : {group gT} | critical K G}.\n",
  "proof": "Proof.\nmove=> pG; pose qcr A := (A \\char G) && ('Phi(A) :|: [~: G, A] \\subset 'Z(A)).\nhave [|K]:= @maxgroup_exists _ qcr 1 _.\n  by rewrite /qcr char1 center1 commG1 subUset Phi_sub subxx.\ncase/maxgroupP; rewrite {}/qcr subUset => /and3P[chK sPhiZ sRZ] maxK _.\nhave sKG := char_sub chK; have nKG := char_normal chK.\nexists K; split=> //; apply/eqP; rewrite eqEsubset andbC setSI //=.\nhave chZ: 'Z(K) \\char G by [apply: subcent_char]; have nZG := char_norm chZ.\nhave chC: 'C_G(K) \\char G by apply: subcent_char chK.\nrewrite -quotient_sub1; last by rewrite subIset // char_norm.\napply/trivgP; apply: (TI_center_nil (quotient_nil _ (pgroup_nil pG))).\n  by rewrite quotient_normal ?norm_normalI ?norms_cent ?normal_norm.\napply: TI_Ohm1; apply/trivgP; rewrite -trivg_quotient -sub_cosetpre_quo //.\nrewrite morphpreI quotientGK /=; last first.\n  by apply: normalS (char_normal chZ); rewrite ?subsetIl ?setSI.\nset X := _ :&: _; pose gX := [group of X].\nhave sXG: X \\subset G by rewrite subIset ?subsetIl.\nhave cXK: K \\subset 'C(gX) by rewrite centsC 2?subIset // subxx orbT.\nrewrite subsetI centsC cXK andbT -(mul1g K) -mulSG mul1g -(cent_joinEr cXK).\nrewrite [_ <*> K]maxK ?joing_subr //= andbC (cent_joinEr cXK).\nrewrite -center_prod // (subset_trans _ (mulG_subr _ _)).\n  rewrite charM 1?charI ?(char_from_quotient (normal_cosetpre _)) //.\n  by rewrite cosetpreK !gFchar_trans.\nrewrite (@Phi_mulg p) ?(pgroupS _ pG) // subUset commGC commMG; last first.\n  by rewrite normsR ?(normsG sKG) // cents_norm // centsC.\nrewrite !mul_subG 1?commGC //.\n  apply: subset_trans (commgS _ (subsetIr _ _)) _.\n  rewrite -quotient_cents2 ?subsetIl // centsC // cosetpreK //.\n  exact/gFsub_trans/subsetIr.\nhave nZX := subset_trans sXG nZG; have pX : p.-group gX by apply: pgroupS pG.\nrewrite -quotient_sub1 ?gFsub_trans //=.\nhave pXZ: p.-group (gX / 'Z(K)) by apply: morphim_pgroup.\nrewrite (quotient_Phi pX nZX) subG1 (trivg_Phi pXZ).\napply: (abelemS (quotientS _ (subsetIr _ _))); rewrite /= cosetpreK /=.\nhave pZ: p.-group 'Z(G / 'Z(K)).\n  by rewrite (pgroupS (center_sub _)) ?morphim_pgroup.\nby rewrite Ohm1_abelem ?center_abelian.\nQed."
}
{
  "statement": "Lemma leq_rdivp p q : size (rdivp p q) <= size p.\n",
  "proof": "Proof.\nhave [/rdivp_small->|] := ltnP (size p) (size q); first by rewrite size_poly0.\nrewrite /rdivp /rmodp /rscalp unlock.\nhave [->|q0] //= := eqVneq q 0.\nhave: size (0 : {poly R}) <= size p by rewrite size_poly0.\nmove: {2 3 4 6}(size p) (leqnn (size p)) => A.\nelim: (size p) 0%N (0 : {poly R}) {1 3 4}p (leqnn (size p)) => [|n ihn] k q1 r.\n  by move/size_poly_leq0P->; rewrite /= size_poly0 size_poly_gt0 q0.\nmove=> /= hrn hr hq1 hq; case: ltnP => //= hqr.\nhave sq: 0 < size q by rewrite size_poly_gt0.\nhave sr: 0 < size r by apply: leq_trans sq hqr.\napply: ihn => //.\n- apply/leq_sizeP => j hnj.\n  rewrite coefB -scalerAl coefZ coefXnM ltn_subRL ltnNge.\n  have hj : (size r).-1 <= j by apply: leq_trans hnj; rewrite -ltnS prednK.\n  rewrite [leqLHS]polySpred -?size_poly_gt0 // coefMC.\n  rewrite (leq_ltn_trans hj) /=; last by rewrite -add1n leq_add2r.\n  move: hj; rewrite leq_eqVlt prednK // => /predU1P [<- | hj].\n    by rewrite -subn1 subnAC subKn // !subn1 !lead_coefE subrr.\n  have/leq_sizeP-> //: size q <= j - (size r - size q).\n    by rewrite subnBA // leq_psubRL // leq_add2r.\n  by move/leq_sizeP: (hj) => -> //; rewrite mul0r mulr0 subr0.\n- apply: leq_trans (size_polyD _ _) _; rewrite geq_max; apply/andP; split.\n    apply: leq_trans (size_polyMleq _ _) _.\n    by rewrite size_polyC lead_coef_eq0 q0 /= addn1.\n  rewrite size_polyN; apply: leq_trans (size_polyMleq _ _) _.\n  apply: leq_trans hr; rewrite -subn1 leq_subLR -[in (1 + _)%N](subnK hqr).\n  by rewrite addnA leq_add2r add1n -(@size_polyXn R) size_scale_leq.\napply: leq_trans (size_polyD _ _) _; rewrite geq_max; apply/andP; split.\n  apply: leq_trans (size_polyMleq _ _) _.\n  by rewrite size_polyC lead_coef_eq0 q0 /= addnS addn0.\napply: leq_trans (size_scale_leq _ _) _.\nby rewrite size_polyXn -subSn // leq_subLR -add1n leq_add.\nQed."
}
{
  "statement": "Lemma divisors_correct n : n > 0 ->\n  [/\\ uniq (divisors n), sorted leq (divisors n)\n    & forall d, (d \\in divisors n) = (d %| n)].\n",
  "proof": "Proof.\nmove/prod_prime_decomp=> def_n; rewrite {4}def_n {def_n}.\nhave: all prime (primes n) by apply/allP=> p; rewrite mem_primes; case/andP.\nhave:= primes_uniq n; rewrite /primes /divisors; move/prime_decomp: n.\nelim=> [|[p e] pd] /=; first by split=> // d; rewrite big_nil dvdn1 mem_seq1.\nrewrite big_cons /=; move: (foldr _ _ pd) => divs.\nmove=> IHpd /andP[npd_p Upd] /andP[pr_p pr_pd].\nhave lt0p: 0 < p by apply: prime_gt0.\nhave {IHpd Upd}[Udivs Odivs mem_divs] := IHpd Upd pr_pd.\nhave ndivs_p m: p * m \\notin divs.\n  suffices: p \\notin divs; rewrite !mem_divs.\n    by apply: contra => /dvdnP[n ->]; rewrite mulnCA dvdn_mulr.\n  have ndv_p_1: ~~(p %| 1) by rewrite dvdn1 neq_ltn orbC prime_gt1.\n  rewrite big_seq; elim/big_ind: _ => [//|u v npu npv|[q f] /= pd_qf].\n    by rewrite Euclid_dvdM //; apply/norP.\n  elim: (f) => // f'; rewrite expnS Euclid_dvdM // orbC negb_or => -> {f'}/=.\n  have pd_q: q \\in unzip1 pd by apply/mapP; exists (q, f).\n  by apply: contra npd_p; rewrite dvdn_prime2 // ?(allP pr_pd) // => /eqP->.\nelim: e => [|e] /=; first by split=> // d; rewrite mul1n.\nhave Tmulp_inj: injective (NatTrec.mul p).\n  by move=> u v /eqP; rewrite !natTrecE eqn_pmul2l // => /eqP.\nmove: (iter e _ _) => divs' [Udivs' Odivs' mem_divs']; split=> [||d].\n- rewrite merge_uniq cat_uniq map_inj_uniq // Udivs Udivs' andbT /=.\n  apply/hasP=> [[d dv_d /mapP[d' _ def_d]]].\n  by case/idPn: dv_d; rewrite def_d natTrecE.\n- rewrite (merge_sorted leq_total) //; case: (divs') Odivs' => //= d ds.\n  rewrite (@map_path _ _ _ _ leq xpred0) ?has_pred0 // => u v _.\n  by rewrite !natTrecE leq_pmul2l.\nrewrite mem_merge mem_cat; case dv_d_p: (p %| d).\n  case/dvdnP: dv_d_p => d' ->{d}; rewrite mulnC (negbTE (ndivs_p d')) orbF.\n  rewrite expnS -mulnA dvdn_pmul2l // -mem_divs'.\n  by rewrite -(mem_map Tmulp_inj divs') natTrecE.\ncase pdiv_d: (_ \\in _).\n  by case/mapP: pdiv_d dv_d_p => d' _ ->; rewrite natTrecE dvdn_mulr.\nrewrite mem_divs Gauss_dvdr // coprime_sym.\nby rewrite coprimeXl ?prime_coprime ?dv_d_p.\nQed."
}
{
  "statement": "Lemma lin_char_group G :\n  {linG : finGroupType & {cF : linG -> 'CF(G) |\n         [/\\ injective cF, #|linG| = #|G : G^`(1)|,\n             forall u, cF u \\is a linear_char\n           & forall phi, phi \\is a linear_char -> exists u, phi = cF u]\n       & [/\\ cF 1%g = 1%R,\n             {morph cF : u v / (u * v)%g >-> (u * v)%R},\n             forall k, {morph cF : u / (u^+ k)%g >-> u ^+ k},\n             {morph cF: u / u^-1%g >-> u^-1%CF}\n           & {mono cF: u / #[u]%g >-> #[u]%CF} ]}}.\n",
  "proof": "Proof.\npose linT := {i : Iirr G | 'chi_i \\is a linear_char}.\npose cF (u : linT) := 'chi_(sval u).\nhave cFlin u: cF u \\is a linear_char := svalP u.\nhave cFinj: injective cF := inj_comp irr_inj val_inj.\nhave inT xi : xi \\is a linear_char -> {u | cF u = xi}.\n  move=> lin_xi; have /irrP/sig_eqW[i Dxi] := lin_char_irr lin_xi.\n  by apply: (exist _ (Sub i _)) => //; rewrite -Dxi.\nhave [one cFone] := inT 1 (rpred1 _).\npose inv u := sval (inT _ (rpredVr (cFlin u))).\npose mul u v := sval (inT _ (rpredM (cFlin u) (cFlin v))).\nhave cFmul u v: cF (mul u v) = cF u * cF v := svalP (inT _ _).\nhave cFinv u: cF (inv u) = (cF u)^-1 := svalP (inT _ _).\nhave mulA: associative mul by move=> u v w; apply: cFinj; rewrite !cFmul mulrA.\nhave mul1: left_id one mul by move=> u; apply: cFinj; rewrite cFmul cFone mul1r.\nhave mulV: left_inverse one inv mul.\n  by move=> u; apply: cFinj; rewrite cFmul cFinv cFone mulVr ?lin_char_unitr.\npose imA := isMulGroup.Build linT mulA mul1 mulV.\npose linG : finGroupType := HB.pack linT imA.\nhave cFexp k: {morph cF : u / ((u : linG) ^+ k)%g >-> u ^+ k}.\n  by move=> u; elim: k => // k IHk; rewrite expgS exprS cFmul IHk.\ndo [exists linG, cF; split=> //] => [|xi /inT[u <-]|u]; first 2 [by exists u].\n  have inj_cFI: injective (cfIirr \\o cF).\n    apply: can_inj (insubd one) _ => u; apply: val_inj.\n    by rewrite insubdK /= ?irrK //; apply: cFlin.\n  rewrite -(card_image inj_cFI) -card_lin_irr.\n  apply/eq_card=> i /[1!inE]; apply/codomP/idP=> [[u ->] | /inT[u Du]].\n    by rewrite /= irrK; apply: cFlin.\n  by exists u; apply: irr_inj; rewrite /= irrK.\napply/eqP; rewrite eqn_dvd; apply/andP; split.\n  by rewrite dvdn_cforder; rewrite -cFexp expg_order cFone.\nby rewrite order_dvdn -(inj_eq cFinj) cFone cFexp exp_cforder.\nQed."
}
{
  "statement": "Lemma rank_DnQ n : 'r_2('D^n*Q) = n.+1.\n",
  "proof": "Proof.\nhave pDnQ: 2.-group 'D^n*Q := DnQ_pgroup n.\nhave esDnQ: extraspecial 'D^n*Q := DnQ_extraspecial n.\ndo [case: DnQ_P => gz isoZ; set DnQ := setT] in pDnQ esDnQ *.\nsuffices [E]: exists2 E, E \\in 'E*_2(DnQ) & logn 2 #|E| = n.+1.\n  by rewrite (pmaxElem_extraspecial pDnQ esDnQ); case/pnElemP=> _ _ <-.\nhave oZ: #|'Z(DnQ)| = 2 by apply: card_center_extraspecial.\npose Dn := cpairg1 isoZ @* 'D^n; pose Q := cpair1g isoZ @* 'Q_8.\nhave [injDn injQ] := (injm_cpairg1 isoZ, injm_cpair1g isoZ).\nhave [E EprE]:= p_rank_witness 2 [group of Dn].\nhave [sEDn abelE dimE] := pnElemP EprE; have [pE cEE eE]:= and3P abelE.\nrewrite injm_p_rank // rank_Dn in dimE; exists E => //.\nhave sZE: 'Z(DnQ) \\subset E.\n  have maxE := subsetP (p_rankElem_max _ _) E EprE.\n  have abelZ: 2.-abelem 'Z(DnQ) by rewrite prime_abelem ?oZ.\n  rewrite -(Ohm1_id abelZ) (OhmE _ (abelem_pgroup abelZ)) gen_subG.\n  rewrite -(pmaxElem_LdivP _ maxE) // setSI //=.\n  by rewrite -cpairg1_center injm_center // setIS ?centS.\nhave scE: 'C_Dn(E) = E.\n  apply/eqP; rewrite eq_sym eqEcard subsetI sEDn -abelianE cEE /=.\n  have [n0 | n_gt0] := posnP n.\n    rewrite subset_leq_card // subIset // (subset_trans _ sZE) //.\n    by rewrite -cpairg1_center morphimS // n0 center_ncprod0.\n  have pDn: 2.-group Dn by rewrite morphim_pgroup ?pX1p2n_pgroup.\n  have esDn: extraspecial Dn.\n    exact: injm_extraspecial (pX1p2n_extraspecial _ _).\n  rewrite dvdn_leq ?cardG_gt0 // (card_subcent_extraspecial pDn) //=.\n  rewrite -injm_center // cpairg1_center (setIidPl sZE) oZ.\n  rewrite -(dvdn_pmul2l (cardG_gt0 E)) mulnn mulnCA Lagrange //.\n  rewrite card_injm ?card_pX1p2n // -expnS pfactor_dvdn ?expn_gt0 ?cardG_gt0 //.\n  by rewrite lognX dimE mul2n.\napply/pmaxElemP; split=> [|F E2F sEF]; first by rewrite inE subsetT abelE.\nhave{E2F} [_ abelF] := pElemP E2F; have [pF cFF eF] := and3P abelF.\napply/eqP; rewrite eqEsubset sEF andbT; apply/subsetP=> x Fx.\nhave DnQx: x \\in Dn * Q by rewrite im_cpair inE.\nhave{DnQx} [y z Dn_y Qz def_x]:= imset2P DnQx.\nhave{Dn_y} Ey: y \\in E.\n  have cEz: z \\in 'C(E).\n    by rewrite (subsetP (centS sEDn)) // (subsetP (im_cpair_cent _)).\n  rewrite -scE inE Dn_y -(groupMr _ cEz) -def_x (subsetP (centS sEF)) //.\n  by rewrite (subsetP cFF).\nrewrite def_x groupMl // (subsetP sZE) // -cpair1g_center injm_center //= -/Q.\nhave: z \\in 'Ohm_1(Q).\n  rewrite (OhmE 1 (pgroupS (subsetT Q) pDnQ)) mem_gen // !inE Qz /=.\n  rewrite -[z](mulKg y) -def_x (exponentP eF) ?groupM //.\n  by rewrite groupV (subsetP sEF).\nhave isoQ: Q \\isog 'Q_(2 ^ 3) by rewrite isog_sym sub_isog.\nhave [//|[u v] genQ _] := generators_quaternion _ isoQ.\nby case/quaternion_structure: genQ => // _ _ [-> _ _ [-> _] _] _ _.\nQed."
}
{
  "statement": "Lemma sat_gen_form e f : GRing.rformula f ->\n  reflect (GRing.holds e f) (GRing.sat (gen_env e) (gen_form f)).\n",
  "proof": "Proof.\nhave ExP := Exists_rowP; have set_val := set_nth_map_rVval.\nelim: f e => //.\n- by move=> b e _; apply: (iffP satP).\n- rewrite /gen_form => t1 t2 e rt_t; set t := (_ - _)%T.\n  have:= GRing.qf_evalP (gen_env e) (mxrank_form_qf 0 (gen_term t)).\n  rewrite eval_mxrank mxrank_eq0 eval_gen_term // => tP.\n  by rewrite (sameP satP tP) /= subr_eq0 val_eqE; apply: eqP.\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => [[/satP/f1P ? /satP/f2P] | [/f1P/satP ? /f2P/satP]].\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => /= [] [];\n    try move/satP; do [move/f1P | move/f2P]; try move/satP; auto.\n- move=> f1 IH1 f2 IH2 s /= /andP[/(IH1 s)f1P /(IH2 s)f2P].\n  by apply: (iffP satP) => /= implP;\n    try move/satP; move/f1P; try move/satP; move/implP;\n    try move/satP; move/f2P; try move/satP.\n- move=> f1 IH1 s /= /(IH1 s) f1P.\n  by apply: (iffP satP) => /= notP; try move/satP; move/f1P; try move/satP.\n- move=> k f1 IHf1 s /IHf1 f1P; apply: (iffP satP) => /= [|[[v f1v]]].\n    by case/ExP=> // x /satP; rewrite set_val => /f1P; exists (inFA x).\n  by apply/ExP=> //; exists v; rewrite set_val; apply/satP/f1P.\nmove=> i f1 IHf1 s /IHf1 f1P; apply: (iffP satP) => /= allf1 => [[v]|].\n  apply/f1P; case: satP => // notf1x; case: allf1; apply/ExP=> //.\n  by exists v; rewrite set_val.\nby case/ExP=> //= v []; apply/satP; rewrite set_val; apply/f1P.\nQed."
}
{
  "statement": "Lemma isog_pX1p2n n (gT : finGroupType) (G : {group gT}) :\n    prime p -> extraspecial G -> #|G| = (p ^ n.*2.+1)%N -> exponent G %| p ->\n  G \\isog p^{1+2*n}.\n",
  "proof": "Proof.\nmove=> p_pr esG oG expG; have p_gt1 := prime_gt1 p_pr.\nhave not_le_p3_p: ~~ (p ^ 3 <= p) by rewrite (leq_exp2l 3 1).\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave oZ := card_center_extraspecial pG esG.\nhave{pG esG} [Es p3Es defG] := extraspecial_structure pG esG.\nset Z := 'Z(G) in oZ defG p3Es.\nelim: Es {+}G => [|E Es IHs] S in n oG expG p3Es defG *.\n  rewrite big_nil cprod1g in defG; rewrite -defG.\n  have ->: n = 0.\n    apply: double_inj; apply/eqP.\n    by rewrite -eqSS -(eqn_exp2l _ _ p_gt1) -oG -defG oZ.\n  by rewrite isog_cyclic_card prime_cyclic ?oZ ?card_pX1p2n //=.\nrewrite big_cons -cprodA in defG; rewrite /= -andbA in p3Es.\nhave [[_ T _ defT] defET cTE] := cprodP defG; rewrite defT in defET cTE defG.\nmove: p3Es => /and3P[/eqP oE /eqP defZE /IHs{}IHs].\nhave not_cEE: ~~ abelian E.\n  by apply: contra not_le_p3_p => cEE; rewrite -oE -oZ -defZE (center_idP _).\nhave sES: E \\subset S by rewrite -defET mulG_subl.\nhave sTS: T \\subset S by rewrite -defET mulG_subr.\nhave expE: exponent E %| p by apply: dvdn_trans (exponentS sES) expG.\nhave expT: exponent T %| p by apply: dvdn_trans (exponentS sTS) expG.\nhave{expE not_cEE} isoE: E \\isog p^{1+2}.\n  apply: isog_pX1p2 => //.\n  by apply: card_p3group_extraspecial p_pr oE _; rewrite defZE.\nhave sZT: 'Z(E) \\subset T.\n  by case/cprodP: defT => [[U _ -> _] <- _]; rewrite defZE mulG_subr.\ncase def_n: n => [|n'].\n  case/negP: not_le_p3_p; rewrite def_n in oG; rewrite -oE -[p]oG.\n  exact: subset_leq_card.\nhave zI_ET: E :&: T = 'Z(E).\n  by apply/eqP; rewrite eqEsubset subsetI sZT subsetIl setIS // centsC.\nhave{n def_n oG} oT: #|T| = (p ^ n'.*2.+1)%N.\n  apply/eqP; rewrite -(eqn_pmul2l (cardG_gt0 E)) mul_cardG zI_ET defET.\n  by rewrite defZE oE oG oZ -expnSr -expnD def_n.\nhave{IHs oT expT defT Es} isoT: T \\isog p^{1+2*n'} by rewrite IHs.\ncase: pX1p2S => gz isoZ; rewrite (isog_cprod_by _ defG) //.\nexact: Aut_extraspecial_full (pX1p2_pgroup p_pr) (pX1p2_extraspecial p_pr).\nQed."
}
{
  "statement": "Lemma div_ring_mul_group_cyclic (R : unitRingType) (f : gT -> R) :\n    f 1 = 1%R -> {in G &, {morph f : u v / u * v >-> (u * v)%R}} ->\n    {in G^#, forall x, f x - 1 \\in GRing.unit}%R ->\n  abelian G -> cyclic G.\n",
  "proof": "Proof.\nmove=> f1 fM f1P abelG.\nhave fX n: {in G, {morph f : u / u ^+ n >-> (u ^+ n)%R}}.\n  by case: n => // n x Gx; elim: n => //= n IHn; rewrite expgS fM ?groupX ?IHn.\nhave fU x: x \\in G -> f x \\in GRing.unit.\n  by move=> Gx; apply/unitrP; exists (f x^-1); rewrite -!fM ?groupV ?gsimp.\napply: order_inj_cyclic => x y Gx Gy; set n := #[x] => yn.\napply/eqP; rewrite eq_sym eqEcard -[#|_|]/n yn leqnn andbT cycle_subG /=.\nsuff{y Gy yn} ->: <[x]> = G :&: [set z | #[z] %| n] by rewrite !inE Gy yn /=.\napply/eqP; rewrite eqEcard subsetI cycle_subG {}Gx /= cardE; set rs := enum _.\napply/andP; split; first by apply/subsetP=> y xy; rewrite inE order_dvdG.\npose P : {poly R} := ('X^n - 1)%R; have n_gt0: n > 0 by apply: order_gt0.\nhave szP : size P = n.+1.\n  by rewrite size_polyDl size_polyXn ?size_polyN ?size_poly1.\nrewrite -ltnS -szP -(size_map f) max_ring_poly_roots -?size_poly_eq0 ?{}szP //.\n  apply/allP=> fy /mapP[y]; rewrite mem_enum !inE order_dvdn => /andP[Gy].\n  move/eqP=> yn1 ->{fy}; apply/eqP.\n  by rewrite !(hornerE, hornerXn) -fX // yn1 f1 subrr.\nhave: uniq rs by apply: enum_uniq.\nhave: all [in G] rs by apply/allP=> y; rewrite mem_enum; case/setIP.\nelim: rs => //= y rs IHrs /andP[Gy Grs] /andP[y_rs]; rewrite andbC.\nmove/IHrs=> -> {IHrs}//; apply/allP=> _ /mapP[z rs_z ->].\nhave{Grs} Gz := allP Grs z rs_z; rewrite /diff_roots -!fM // (centsP abelG) //.\nrewrite eqxx -[f y]mul1r -(mulgKV y z) fM ?groupM ?groupV //=.\nrewrite -mulNr -mulrDl unitrMl ?fU ?f1P // !inE.\nby rewrite groupM ?groupV // andbT -eq_mulgV1; apply: contra y_rs; move/eqP <-.\nQed."
}
{
  "statement": "Lemma vchar_orthonormalP S :\n    {subset S <= 'Z[irr G]} ->\n  reflect (exists I : {set Iirr G}, exists b : Iirr G -> bool,\n           perm_eq S [seq (-1) ^+ b i *: 'chi_i | i in I])\n          (orthonormal S).\n",
  "proof": "Proof.\nmove=> vcS; apply: (equivP orthonormalP).\nsplit=> [[uniqS oSS] | [I [b defS]]]; last first.\n  split=> [|xi1 xi2]; rewrite ?(perm_mem defS).\n    rewrite (perm_uniq defS) map_inj_uniq ?enum_uniq // => i j /eqP.\n    by rewrite eq_signed_irr => /andP[_ /eqP].\n  case/mapP=> [i _ ->] /mapP[j _ ->]; rewrite eq_signed_irr.\n  rewrite cfdotZl cfdotZr rmorph_sign mulrA cfdot_irr -signr_addb mulr_natr.\n  by rewrite mulrb andbC; case: eqP => //= ->; rewrite addbb eqxx.\npose I := [set i | ('chi_i \\in S) || (- 'chi_i \\in S)].\npose b i := - 'chi_i \\in S; exists I, b.\napply: uniq_perm => // [|xi].\n  rewrite map_inj_uniq ?enum_uniq // => i j /eqP.\n  by rewrite eq_signed_irr => /andP[_ /eqP].\napply/idP/mapP=> [Sxi | [i Ii ->{xi}]]; last first.\n  move: Ii; rewrite mem_enum inE orbC -/(b i).\n  by case b_i: (b i); rewrite (scale1r, scaleN1r).\nhave: '[xi] = 1 by rewrite oSS ?eqxx.\nhave vc_xi := vcS _ Sxi; rewrite cfdot_sum_irr.\ncase/natr_sum_eq1 => [i _ | i [_ /eqP norm_xi_i xi_i'_0]].\n  by rewrite -normCK rpredX // natr_norm_int ?Cint_cfdot_vchar_irr.\nsuffices def_xi: xi = (-1) ^+ b i *: 'chi_i.\n  exists i; rewrite // mem_enum inE -/(b i) orbC.\n  by case: (b i) def_xi Sxi => // ->; rewrite scale1r.\nmove: Sxi; rewrite [xi]cfun_sum_cfdot (bigD1 i) //.\nrewrite big1 //= ?addr0 => [|j ne_ji]; last first.\n  apply/eqP; rewrite scaler_eq0 -normr_eq0 -[_ == 0](expf_eq0 _ 2) normCK.\n  by rewrite xi_i'_0 ?eqxx.\nhave:= norm_xi_i; rewrite (aut_intr _ (Cint_cfdot_vchar_irr _ _)) //.\nrewrite -subr_eq0 subr_sqr_1 mulf_eq0 subr_eq0 addr_eq0 /b scaler_sign.\ncase/pred2P=> ->; last by rewrite scaleN1r => ->.\nrewrite scale1r => Sxi; case: ifP => // SNxi.\nhave:= oSS _ _ Sxi SNxi; rewrite cfdotNr cfdot_irr eqxx; case: eqP => // _.\nby move/eqP; rewrite oppr_eq0 oner_eq0.\nQed."
}
{
  "statement": "Lemma base_full : row_full base.\n",
  "proof": "Proof.\nrewrite /row_full (eqnP base_free) /nA; case: ex_maxnP => nA.\ncase/existsP=> /= B /eqnP Bfree nA_max; rewrite -Bfree eqn_leq rank_leq_col.\nrewrite -{1}(mxrank1 F n) mxrankS //; apply/row_subP=> j; set u := row _ _.\nmove/implyP: {nA_max}(nA_max nA.+1); rewrite ltnn implybF.\napply: contraR => nBj; apply/existsP.\nexists (row_mx (const_mx j : 'M_1) B); rewrite -row_leq_rank.\npose Bj := Ad *m lin1_mx (mulmx u \\o vec_mx).\nhave rBj: \\rank Bj = d.\n  apply/eqP; rewrite eqn_leq rank_leq_row -subn_eq0 -mxrank_ker mxrank_eq0 /=.\n  apply/rowV0P=> v /sub_kermxP; rewrite mulmxA mul_rV_lin1 /=.\n  rewrite -horner_rVpoly; pose x := inFA v; rewrite -/(mxval x).\n  have [[] // | nzx /(congr1 (mulmx^~ (mxval x^-1)))] := eqVneq x 0.\n  rewrite mul0mx /= -mulmxA -mxvalM divff // mxval1 mulmx1.\n  by move/rowP/(_ j)/eqP; rewrite !mxE !eqxx oner_eq0.\nrewrite {1}mulSn -Bfree -{1}rBj {rBj} -mxrank_disjoint_sum.\n  rewrite mxrankS // addsmx_sub -[nA.+1]/(1 + nA)%N; apply/andP; split.\n    apply/row_subP=> k; rewrite row_mul mul_rV_lin1 /=.\n    apply: eq_row_sub (mxvec_index (lshift _ 0) k)  _.\n    by rewrite !rowK mxvecK mxvecE mxE row_mxEl mxE -row_mul mul1mx.\n  apply/row_subP; case/mxvec_indexP=> i k.\n  apply: eq_row_sub (mxvec_index (rshift 1 i) k) _.\n  by rewrite !rowK !mxvecE 2!mxE row_mxEr.\napply/eqP/rowV0P=> v; rewrite sub_capmx => /andP[/submxP[w]].\nset x := inFA w; rewrite {Bj}mulmxA mul_rV_lin1 /= -horner_rVpoly -/(mxval x).\nhave [-> | nzx ->] := eqVneq x 0; first by rewrite mxval0 mulmx0.\nmove/(submxMr (mxval x^-1)); rewrite -mulmxA -mxvalM divff {nzx}//.\nrewrite mxval1 mulmx1 => Bx'j; rewrite (submx_trans Bx'j) in nBj => {Bx'j} //.\napply/row_subP; case/mxvec_indexP=> i k.\nrewrite row_mul rowK mxvecE mxE rowE -mulmxA.\nhave ->: A ^+ k *m mxval x^-1 = mxval (groot ^+ k / x).\n  by rewrite mxvalM rmorphXn /= mxval_groot.\nrewrite [mxval _]horner_rVpoly; move: {k u x}(val _) => u.\nrewrite (mulmx_sum_row u) !linear_sum summx_sub //= => k _.\nrewrite 2!linearZ scalemx_sub //= rowK mxvecK -rowE.\nby apply: eq_row_sub (mxvec_index i k) _; rewrite rowK mxvecE mxE.\nQed."
}
{
  "statement": "Lemma not_simple_Alt_4 (T : finType) : #|T| = 4 -> ~~ simple 'Alt_T.\n",
  "proof": "Proof.\nmove=> oT; set A := 'Alt_T.\nhave oA: #|A| = 12 by apply: double_inj; rewrite -mul2n card_Alt oT.\nsuffices [p]: exists p, [/\\ prime p, 1 < #|A|`_p < #|A| & #|'Syl_p(A)| == 1%N].\n  case=> p_pr pA_int; rewrite /A; case/normal_sylowP=> P; case/pHallP.\n  rewrite /= -/A => sPA pP nPA; apply/simpleP=> [] [_]; rewrite -pP in pA_int.\n  by case/(_ P)=> // defP; rewrite defP oA ?cards1 in pA_int.\nhave: #|'Syl_3(A)| \\in filter [pred d | d %% 3 == 1%N] (divisors 12).\n  by rewrite mem_filter -dvdn_divisors //= -oA card_Syl_dvd ?card_Syl_mod.\nrewrite /= oA mem_seq2 orbC.\ncase/predU1P=> [oQ3|]; [exists 2 | exists 3]; split; rewrite ?p_part //.\npose A3 := [set x : {perm T} | #[x] == 3]; suffices oA3: #|A :&: A3| = 8.\n  have sQ2 P: P \\in 'Syl_2(A) -> P :=: A :\\: A3.\n    rewrite inE pHallE oA p_part -natTrecE /= => /andP[sPA /eqP oP].\n    apply/eqP; rewrite eqEcard -(leq_add2l 8) -{1}oA3 cardsID oA oP.\n    rewrite andbT subsetD sPA; apply/exists_inP=> -[x] /= Px.\n    by rewrite inE => /eqP ox; have:= order_dvdG Px; rewrite oP ox.\n  have [/= P sylP] := Sylow_exists 2 [group of A].\n  rewrite -(([set P] =P 'Syl_2(A)) _) ?cards1 // eqEsubset sub1set inE sylP.\n  by apply/subsetP=> Q sylQ; rewrite inE -val_eqE /= !sQ2 // inE.\nrewrite -[8]/(4 * 2)%N -{}oQ3 -sum1_card -sum_nat_const.\nrewrite (partition_big (fun x => <[x]>%G) [in 'Syl_3(A)]) => [|x]; last first.\n  by case/setIP=> Ax; rewrite /= !inE pHallE p_part cycle_subG Ax oA.\napply: eq_bigr => Q; rewrite inE pHallE oA p_part -?natTrecE //=.\ncase/andP=> sQA /eqP oQ; have:= oQ.\nrewrite (cardsD1 1) group1 -sum1_card => [[/= <-]]; apply: eq_bigl => x.\nrewrite setIC -val_eqE /= 2!inE in_setD1 -andbA -{4}[x]expg1 -order_dvdn dvdn1.\napply/and3P/andP=> [[/eqP-> _ /eqP <-] | [ntx Qx]]; first by rewrite cycle_id.\nhave:= order_dvdG Qx; rewrite oQ dvdn_divisors // mem_seq2 (negPf ntx) /=.\nby rewrite eqEcard cycle_subG Qx (subsetP sQA) // oQ /order => /eqP->.\nQed."
}
{
  "statement": "Lemma Frobenius_actionP G H :\n  reflect (has_Frobenius_action G H) [Frobenius G with complement H].\n",
  "proof": "Proof.\napply: (iffP andP) => [[neqHG] | [sT S to [ffulG transG regG ntH [u Su defH]]]].\n  case/normedTI_P=> nzH /subsetIP[sHG _] tiHG.\n  suffices: Frobenius_action G H (rcosets H G) 'Rs by apply: hasFrobeniusAction.\n  pose Hfix x := 'Fix_(rcosets H G | 'Rs)[x].\n  have regG: {in G^#, forall x, #|Hfix x| <= 1}.\n    move=> x /setD1P[ntx Gx].\n    apply: wlog_neg; rewrite -ltnNge => /ltnW/card_gt0P/=[Hy].\n    rewrite -(cards1 Hy) => /setIP[/imsetP[y Gy ->{Hy}] cHyx].\n    apply/subset_leq_card/subsetP=> _ /setIP[/imsetP[z Gz ->] cHzx].\n    rewrite -!sub_astab1 !astab1_act !sub1set astab1Rs in cHyx cHzx *.\n    rewrite !rcosetE; apply/set1P/rcoset_eqP; rewrite mem_rcoset.\n    apply: tiHG; [by rewrite !in_group | apply/pred0Pn; exists (x ^ y^-1)].\n    by rewrite conjD1g !inE conjg_eq1 ntx -mem_conjg cHyx conjsgM memJ_conjg.\n  have ntH: H :!=: 1 by rewrite -subG1 -setD_eq0.\n  split=> //; first 1 last; first exact: transRs_rcosets.\n    by exists (val H); rewrite ?orbit_refl // astab1Rs (setIidPr sHG).\n  apply/subsetP=> y /setIP[Gy cHy]; apply: contraR neqHG => nt_y.\n  rewrite (index1g sHG) //; apply/eqP; rewrite eqn_leq indexg_gt0 andbT.\n  apply: leq_trans (regG y _); last by rewrite setDE 2!inE Gy nt_y /=.\n  by rewrite /Hfix (setIidPl _) -1?astabC ?sub1set.\nhave sHG: H \\subset G by rewrite defH subsetIl.\nsplit.\n  apply: contraNneq ntH => /= defG.\n  suffices defS: S = [set u] by rewrite -(trivgP ffulG) /= defS defH.\n  apply/eqP; rewrite eq_sym eqEcard sub1set Su.\n  by rewrite -(atransP transG u Su) card_orbit -defH defG indexgg cards1.\napply/normedTI_P; rewrite setD_eq0 subG1 normD1 subsetI sHG normG.\nsplit=> // x Gx; rewrite -setI_eq0 conjD1g defH inE Gx conjIg conjGid //.\nrewrite -setDIl -setIIr -astab1_act setDIl => /set0Pn[y /setIP[Gy /setD1P[_]]].\ncase/setIP; rewrite 2!(sameP astab1P afix1P) => cuy cuxy; apply/astab1P.\napply: contraTeq (regG y Gy) => cu'x.\nrewrite (cardD1 u) (cardD1 (to u x)) inE Su cuy inE /= inE cu'x cuxy.\nby rewrite (actsP (atrans_acts transG)) ?Su.\nQed."
}
{
  "statement": "Theorem extremal2_structure (gT : finGroupType) (G : {group gT}) n x y :\n  let cG := extremal_class G in\n  let m := (2 ^ n)%N in let q := (2 ^ n.-1)%N in let r := (2 ^ n.-2)%N in\n  let X := <[x]> in let yG := y ^: G in let xyG := (x * y) ^: G in\n  let My := <<yG>> in let Mxy := <<xyG>> in\n     extremal_generators G 2 n (x, y) ->\n     extremal2 G -> (cG == SemiDihedral) ==> (#[y] == 2) ->\n [/\\ [/\\ (if cG == Quaternion then pprod X <[y]> else X ><| <[y]>) = G,\n         if cG == SemiDihedral then #[x * y] = 4 else\n           {in G :\\: X, forall z, #[z] = (if cG == Dihedral then 2 else 4)},\n         if cG != Quaternion then True else\n         {in G, forall z, #[z] = 2 -> z = x ^+ r}\n       & {in X & G :\\: X, forall t z,\n            t ^ z = (if cG == SemiDihedral then t ^+ r.-1 else t^-1)}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ if n > 2 then 'Z(G) = <[x ^+ r]> /\\ #|'Z(G)| = 2 else 2.-abelem G,\n          'Ohm_1(G) = (if cG == Quaternion then <[x ^+ r]> else\n                       if cG == SemiDihedral then My else G),\n          'Ohm_2(G) = G\n        & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n     [/\\ yG :|: xyG = G :\\: X, [disjoint yG & xyG]\n       & forall H : {group gT}, maximal H G = (gval H \\in pred3 X My Mxy)]\n   & if n <= (cG == Quaternion) + 2 then True else\n     [/\\ forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X,\n         if cG == Quaternion then My \\isog 'Q_q else My \\isog 'D_q,\n         extremal_class My = (if cG == Quaternion then cG else Dihedral),\n         if cG == Dihedral then Mxy \\isog 'D_q else Mxy \\isog 'Q_q\n       & extremal_class Mxy = (if cG == Dihedral then cG else Quaternion)]].\n",
  "proof": "Proof.\nmove=> cG m q r X yG xyG My Mxy genG; have [oG _ _ _] := genG.\nhave logG: logn (pdiv #|G|) #|G| = n by rewrite oG pfactorKpdiv.\nrewrite /extremal2 -/cG; do [rewrite {1}/extremal_class /= {}logG] in cG *.\ncase: ifP => [isoG | _] in cG * => [_ _ /=|].\n  case/andP: isoG => n_gt1 isoG.\n  have:= dihedral2_structure n_gt1 genG isoG; rewrite -/X -/q -/r -/yG -/xyG.\n  case=> [[defG oX' invXX'] nilG [defOhm defMho] maxG defZ].\n  rewrite eqn_leq n_gt1 andbT add0n in defZ *; split=> //.\n    split=> //; first by case: leqP defZ => // _ [].\n    by apply/eqP; rewrite eqEsubset Ohm_sub -{1}defOhm Ohm_leq.\n  case: leqP defZ => // n_gt2 [_ _ isoMy isoMxy defX].\n  have n1_gt1: n.-1 > 1 by rewrite -(subnKC n_gt2).\n  by split=> //; apply/dihedral_classP; exists n.-1.\ncase: ifP => [isoG | _] in cG * => [_ _ /=|].\n  case/andP: isoG => n_gt2 isoG; rewrite n_gt2 add1n.\n  have:= quaternion_structure n_gt2 genG isoG; rewrite -/X -/q -/r -/yG -/xyG.\n  case=> [[defG oX' invXX'] nilG [defZ oZ def2 [-> ->] defMho]].\n  case=> [[-> ->] maxG] isoM; split=> //.\n  case: leqP isoM => // n_gt3 [//|isoMy isoMxy defX].\n  have n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\n  by split=> //; apply/quaternion_classP; exists n.-1.\ndo [case: ifP => [isoG | _]; last by case: ifP] in cG * => /= _; move/eqnP=> oy.\ncase/andP: isoG => n_gt3 isoG; rewrite (leqNgt n) (ltnW n_gt3) /=.\nhave n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\nhave:= semidihedral_structure n_gt3 genG isoG oy.\nrewrite -/X -/q -/r -/yG -/xyG -/My -/Mxy.\ncase=> [[defG oxy invXX'] nilG [defZ oZ [-> ->] defMho] [[defX' tiX'] maxG]].\ncase=> isoMy isoMxy defX; do 2!split=> //.\n  by apply/dihedral_classP; exists n.-1; first apply: ltnW.\nby apply/quaternion_classP; exists n.-1.\nQed."
}
{
  "statement": "Lemma div_annihilant_neq0 p q : p != 0 -> q.[0] != 0 -> div_annihilant p q != 0.\n",
  "proof": "Proof.\nhave factorX u: u != 0 -> root u 0 -> exists2 v, v != 0 & u = v * 'X.\n  move=> nz_u /factor_theorem[v]; rewrite subr0 => Du; exists v => //.\n  by apply: contraNneq nz_u => v0; rewrite Du v0 mul0r.\nhave nzX: 'X != 0 := monic_neq0 (monicX _); have rootC0 := root_polyC _ 0.\nrewrite resultant_eq0 -leqNgt -rootE // => nz_p nz_q0; apply/eq_leq/eqP.\nhave nz_q: q != 0 by apply: contraNneq nz_q0 => ->; rewrite root0.\napply/Bezout_coprimepPn; rewrite ?map_polyC_eq0 ?poly_XmY_eq0 // => [[uv]].\nrewrite !size_poly_gt0 -andbA ltnNge => /and4P[nz_u /negP ltuq nz_v _] Duv.\npose u := swapXY uv.1; pose v := swapXY uv.2.\nsuffices{ltuq}: size q <= sizeY u by rewrite sizeYE swapXYK -size_map_polyC.\nhave{nz_u nz_v} [nz_u nz_v Dvu]: [/\\ u != 0, v != 0 & q *: v = u * poly_XmY p].\n  rewrite !swapXY_eq0; split=> //; apply: (can_inj swapXYK).\n  by rewrite linearZ rmorphM /= !swapXYK swapXY_poly_XmY Duv mulrC.\nhave{Duv} [n ltvn]: {n | size v < n} by exists (size v).+1.\nelim: n {uv} => // n IHn in p (v) (u) nz_u nz_v Dvu nz_p ltvn *.\nhave Dp0: root (poly_XmY p) 0 = root p 0 by rewrite root_comp !hornerE rootC0.\nhave Dv0: root u 0 || root p 0 = root v 0 by rewrite -Dp0 -rootM -Dvu rootZ.\nhave [v0_0 | nz_v0] := boolP (root v 0); last first.\n  have nz_p0: ~~ root p 0 by apply: contra nz_v0; rewrite -Dv0 orbC => ->.\n  apply: (@leq_trans (size (q * v.[0]))).\n    by rewrite size_mul // (polySpred nz_v0) addnS leq_addr.\n  rewrite -hornerZ Dvu !(horner_comp, hornerE) horner_map mulrC size_Cmul //.\n  by rewrite horner_coef0 max_size_coefXY.\nhave [v1 nz_v1 Dv] := factorX _ _ nz_v v0_0; rewrite Dv size_mulX // in ltvn.\nhave /orP[/factorX[//|u1 nz_u1 Du] | p0_0]: root u 0 || root p 0 by rewrite Dv0.\n  rewrite Du sizeY_mulX; apply: IHn nz_u1 nz_v1 _ nz_p ltvn.\n  by apply: (mulIf (nzX _)); rewrite mulrAC -scalerAl -Du -Dv.\nhave /factorX[|v2 nz_v2 Dv1]: root (swapXY v1) 0; rewrite ?swapXY_eq0 //.\n  suffices: root (swapXY v1 * 'Y) 0 by rewrite mulrC mul_polyC rootZ ?polyX_eq0.\n  have: root (swapXY (q *: v)) 0.\n    by rewrite Dvu rmorphM rootM /= swapXY_poly_XmY Dp0 p0_0 orbT.\n  by rewrite linearZ rootM rootC0 (negPf nz_q0) /= Dv rmorphM /= swapXY_X.\nrewrite ltnS (canRL swapXYK Dv1) -sizeYE sizeY_mulX sizeYE in ltvn.\nhave [p1 nz_p1 Dp] := factorX _ _ nz_p p0_0.\napply: IHn nz_u _ _ nz_p1 ltvn; first by rewrite swapXY_eq0.\nhave: 'X * 'Y != 0 :> {poly {poly R}} by rewrite mulf_neq0 ?polyC_eq0 ?nzX.\nmove/mulIf; apply.\nrewrite -scalerAl mulrA mulrAC -{1}swapXY_X -rmorphM /= -Dv1 swapXYK -Dv Dvu.\nby rewrite /poly_XmY Dp rmorphM /= map_polyX comp_polyM comp_polyX mulrA.\nQed."
}
{
  "statement": "Lemma dec_Cint_span (V : vectType algC) m (s : m.-tuple V) v :\n  decidable (inIntSpan s v).\n",
  "proof": "Proof.\nhave s_s (i : 'I_m): s`_i \\in <<s>>%VS by rewrite memv_span ?memt_nth.\nhave s_Zs a: \\sum_(i < m) s`_i *~ a i \\in <<s>>%VS.\n  by rewrite memv_suml // => i _; rewrite -scaler_int memvZ.\ncase s_v: (v \\in <<s>>%VS); last by right=> [[a Dv]]; rewrite Dv s_Zs in s_v.\npose IzT := {: 'I_m * 'I_(\\dim <<s>>)}; pose Iz := 'I_#|IzT|.\npose b := vbasis <<s>>.\npose z_s := [seq coord b ij.2 (tnth s ij.1) | ij : IzT].\npose rank2 j i: Iz := enum_rank (i, j); pose val21 (p : Iz) := (enum_val p).1.\npose inQzs w := [forall j, Crat_span z_s (coord b j w)].\nhave enum_pairK j: {in predT, cancel (rank2 j) val21}.\n  by move=> i; rewrite /val21 enum_rankK.\nhave Qz_Zs a: inQzs (\\sum_(i < m) s`_i *~ a i).\n  apply/forallP=> j; apply/Crat_spanP; rewrite /in_Crat_span size_map -cardE.\n  exists [ffun ij => (a (val21 ij))%:Q *+ ((enum_val ij).2 == j)].\n  rewrite linear_sum {1}(reindex_onto _ _ (enum_pairK j)) big_mkcond /=.\n  apply: eq_bigr => ij _ /=; rewrite nth_image (tnth_nth 0) ffunE /val21.\n  rewrite raddfMz rmorphMn rmorph_int mulrnAl mulrzl /=.\n  rewrite (can2_eq (@enum_rankK _) (@enum_valK _)).\n  by case: (enum_val ij) => i j1; rewrite xpair_eqE eqxx; have [->|] := eqVneq.\ncase Qz_v: (inQzs v); last by right=> [[a Dv]]; rewrite Dv Qz_Zs in Qz_v.\nhave [Qz [QzC [z1s Dz_s _]]] := num_field_exists z_s.\nhave sz_z1s: size z1s = #|IzT| by rewrite -(size_map QzC) Dz_s size_map cardE.\nhave xv j: {x | coord b j v = QzC x}.\n  apply: sig_eqW; have /Crat_spanP[x ->] := forallP Qz_v j.\n  exists (\\sum_ij x ij *: z1s`_ij); rewrite rmorph_sum; apply: eq_bigr => ij _.\n  by rewrite rmorphZ_num -[in RHS](nth_map _ 0) ?Dz_s // -(size_map QzC) Dz_s.\npose sz := [tuple [ffun j => z1s`_(rank2 j i)] | i < m].\nhave [Zsv | Zs'v] := dec_Qint_span sz [ffun j => sval (xv j)].\n  left; have{Zsv} [a Dv] := Zsv; exists a.\n  transitivity (\\sum_j \\sum_(i < m) QzC ((sz`_i *~ a i) j) *: b`_j).\n    rewrite {1}(coord_vbasis s_v) -/b; apply: eq_bigr => j _.\n    rewrite -scaler_suml; congr (_ *: _).\n    have{Dv} /ffunP/(_ j) := Dv; rewrite sum_ffunE !ffunE -rmorph_sum => <-.\n    by case: (xv j).\n  rewrite exchange_big; apply: eq_bigr => i _.\n  rewrite (coord_vbasis (s_s i)) -/b mulrz_suml; apply: eq_bigr => j _.\n  rewrite scalerMzl ffunMzE rmorphMz; congr ((_ *~ _) *: _).\n  rewrite nth_mktuple ffunE -(nth_map _ 0) ?sz_z1s // Dz_s.\n  by rewrite nth_image enum_rankK /= (tnth_nth 0).\nright=> [[a Dv]]; case: Zs'v; exists a.\napply/ffunP=> j; rewrite sum_ffunE !ffunE; apply: (fmorph_inj QzC).\ncase: (xv j) => /= _ <-; rewrite Dv linear_sum rmorph_sum /=.\napply: eq_bigr => i _; rewrite nth_mktuple raddfMz !ffunMzE rmorphMz ffunE.\nby rewrite -(nth_map _ 0 QzC) ?sz_z1s // Dz_s nth_image enum_rankK -tnth_nth.\nQed."
}
{
  "statement": "Lemma large_field_PET q :\n    root (q ^ iota) y -> separable_poly q ->\n  exists2 r, r != 0\n  & forall t (z := iota t * y - x), ~~ root r (iota t) -> inFz z x /\\ inFz z y.\n",
  "proof": "Proof.\nmove=> qy_0 sep_q; have nz_q := separable_poly_neq0 sep_q.\nhave /factor_theorem[q0 Dq] := qy_0.\nset p1 := p ^ iota \\Po ('X + x%:P); set q1 := q0 \\Po ('X + y%:P).\nhave nz_p1: p1 != 0.\n  apply: contraNneq nz_p => /(canRL (fun r => comp_polyXaddC_K r _))/eqP.\n  by rewrite comp_poly0 map_poly_eq0.\nhave{sep_q} nz_q10: q1.[0] != 0.\n  move: sep_q; rewrite -(separable_map iota) Dq separable_root => /andP[_].\n  by rewrite horner_comp !hornerE.\nhave nz_q1: q1 != 0 by apply: contraNneq nz_q10 => ->; rewrite horner0.\npose p2 := p1 ^ polyC \\Po ('X * 'Y); pose q2 := q1 ^ polyC.\nhave /Bezout_coprimepP[[u v]]: coprimep p2 q2.\n  rewrite coprimep_def eqn_leq leqNgt andbC size_poly_gt0 gcdp_eq0 poly_XmY_eq0.\n  by rewrite map_polyC_eq0 (negPf nz_p1) -resultant_eq0 div_annihilant_neq0.\nrewrite -size_poly_eq1 => /size_poly1P[r nzr Dr]; exists r => {nzr}// t z nz_rt.\nhave [r1 nz_r1 r1z_0]: algebraicOver iota z.\n  apply/algebraic_sub; last by exists p.\n  by apply: algebraic_mul; [apply: algebraic_id | exists q].\npose Fz := subFExtend iota z r1; pose kappa : Fz -> L := subfx_inj.\npose kappa' := inj_subfx iota z r1.\nhave /eq_map_poly Diota: kappa \\o kappa' =1 iota.\n  by move=> w; rewrite /kappa /= subfx_inj_eval // map_polyC hornerC.\nsuffices [y3]: exists y3, y = kappa y3.\n  have [q3 ->] := subfxE y3; rewrite /kappa subfx_inj_eval // => Dy.\n  split; [exists (t *: q3 - 'X) | by exists q3].\n  by rewrite rmorphB /= linearZ map_polyX !hornerE -Dy opprB addrC addrNK.\npose p0 := p ^ iota \\Po (iota t *: 'X - z%:P).\nhave co_p0_q0: coprimep p0 q0.\n  pose at_t := horner_eval (iota t); have at_t0: at_t 0 = 0 by apply: rmorph0.\n  have /map_polyK polyCK: cancel polyC at_t by move=> w; apply: hornerC.\n  have ->: p0 = p2 ^ at_t \\Po ('X - y%:P).\n    rewrite map_comp_poly polyCK // rmorphM /= map_polyC map_polyX /=.\n    rewrite horner_evalE hornerX.\n    rewrite -!comp_polyA comp_polyM comp_polyD !comp_polyC !comp_polyX.\n    by rewrite mulrC mulrBr mul_polyC addrAC -addrA -opprB -rmorphM -rmorphB.\n  have ->: q0 = q2 ^ at_t \\Po ('X - y%:P) by rewrite polyCK ?comp_polyXaddC_K.\n  apply/coprimep_comp_poly/Bezout_coprimepP; exists (u ^ at_t, v ^ at_t).\n  by rewrite /= -!rmorphM -rmorphD Dr /= map_polyC polyC_eqp1.\nhave{co_p0_q0}: gcdp p0 (q ^ iota) %= 'X - y%:P.\n  rewrite /eqp Dq (eqp_dvdl _ (Gauss_gcdpr _ _)) // dvdp_gcdr dvdp_gcd.\n  rewrite dvdp_mull // -root_factor_theorem rootE horner_comp !hornerE.\n  by rewrite opprB addrC subrK.\nhave{p0} [p3 ->]: exists p3, p0 = p3 ^ kappa.\n  exists (p ^ kappa' \\Po (kappa' t *: 'X - (subfx_eval iota z r1 'X)%:P)).\n  rewrite map_comp_poly rmorphB /= linearZ /= map_polyC map_polyX /=.\n  rewrite !subfx_inj_eval // map_polyC hornerC map_polyX hornerX.\n  by rewrite -map_poly_comp Diota.\nrewrite -Diota map_poly_comp -gcdp_map /= -/kappa.\nmove: (gcdp _ _) => r3 /eqpf_eq[c nz_c Dr3].\nexists (- (r3`_0 / r3`_1)); rewrite [kappa _]rmorphN fmorph_div -!coef_map Dr3.\nby rewrite !coefZ polyseqXsubC mulr1 mulrC mulKf ?opprK.\nQed."
}
{
  "statement": "Lemma faithful_repr_extraspecial_pchar :\n \\rank U = (p ^ n)%N /\\\n   (forall V, mxsimple rS V -> mx_iso rZ U V -> mx_iso rS U V).\n",
  "proof": "Proof.\nsuffices IH V: mxsimple rS V -> mx_iso rZ U V ->\n  [&& \\rank U == (p ^ n)%N & mxsimple_iso rS U V].\n- split=> [|/= V simV isoUV].\n    by case/andP: (IH U simU (mx_iso_refl _ _)) => /eqP.\n  by case/andP: (IH V simV isoUV) => _ /(mxsimple_isoP simU).\nmove=> simV isoUV; wlog sS: / irrType F S by apply: socle_exists.\nhave [[_ defS'] prZ] := esS.\nhave{prZ} ntZ: 'Z(S) :!=: 1%g by case: eqP prZ => // ->; rewrite cards1.\nhave [_ [iphi]] := extraspecial_repr_structure_pchar sS.\nset phi := fun i => _ => [] [inj_phi im_phi _ phiZ dim_phi] _.\nhave [modU nzU _]:= simU; pose rU := submod_repr modU.\nhave nlinU: \\rank U != 1.\n  apply/eqP=> /(rker_linear rU); apply/negP; rewrite /rker rstab_submod.\n  by rewrite (eqmx_rstab _ (val_submod1 _)) (eqP ffulU) defS' subG1.\nhave irrU: mx_irreducible rU by apply/submod_mx_irr.\nhave rsimU := rsim_irr_comp_pchar sS F'S irrU.\nset iU := irr_comp sS rU in rsimU; have [_ degU _ _]:= rsimU.\nhave phiUP: iU \\in codom iphi by rewrite im_phi !inE -degU.\nrewrite degU -(f_iinv phiUP) dim_phi eqxx /=; apply/(mxsimple_isoP simU).\nhave [modV _ _]:= simV; pose rV := submod_repr modV.\nhave irrV: mx_irreducible rV by apply/submod_mx_irr.\nhave rsimV := rsim_irr_comp_pchar sS F'S irrV.\nset iV := irr_comp sS rV in rsimV; have [_ degV _ _]:= rsimV.\nhave phiVP: iV \\in codom iphi by rewrite im_phi !inE -degV -(mxrank_iso isoUV).\npose jU := iinv phiUP; pose jV := iinv phiVP.\nhave [z Zz ntz]:= trivgPn _ ntZ.\nhave [|w prim_w phi_z] := phiZ z; first by rewrite 2!inE ntz.\nsuffices eqjUV: jU == jV.\n  apply/(mx_rsim_iso modU modV); apply: mx_rsim_trans rsimU _.\n  by rewrite -(f_iinv phiUP) -/jU (eqP eqjUV) f_iinv; apply: mx_rsim_sym.\nhave rsimUV: mx_rsim (subg_repr (phi jU) sZS) (subg_repr (phi jV) sZS).\n  have [bU _ bUfree bUhom] := mx_rsim_sym rsimU.\n  have [bV _ bVfree bVhom] := rsimV.\n  have modUZ := mxmodule_subg sZS modU; have modVZ := mxmodule_subg sZS modV.\n  case/(mx_rsim_iso modUZ modVZ): isoUV => [bZ degZ bZfree bZhom].\n  rewrite /phi !f_iinv; exists (bU *m bZ *m bV)=> [||x Zx].\n  - by rewrite -degU degZ degV.\n  - by rewrite /row_free !mxrankMfree.\n  have Sx := subsetP sZS x Zx.\n  by rewrite 2!mulmxA bUhom // -(mulmxA _ _ bZ) bZhom // -4!mulmxA bVhom.\nhave{rsimUV} [B [B' _ homB]] := mx_rsim_def rsimUV.\nhave:= eqxx (irr_mode (iphi jU) z); rewrite /irr_mode; set i0 := Ordinal _.\nrewrite {2}[_ z]homB // ![_ z]phi_z mxE mulr1n -scalemx1 -scalemxAr -scalemxAl.\nrewrite -(repr_mx1 (subg_repr (phi jV) sZS)) -{B B'}homB // repr_mx1 scalemx1.\nby rewrite mxE (eq_prim_root_expr prim_w) !modIp'.\nQed."
}
{
  "statement": "Lemma enum_AEnd : {kAutL : seq 'AEnd(L) | forall f, f \\in kAutL}.\n",
  "proof": "Proof.\npose isAutL (s : seq 'AEnd(L)) (f : 'AEnd(L)) := kHom 1 {:L} f = (f \\in s).\nsuffices [kAutL in_kAutL] : {kAutL : seq 'AEnd(L) | forall f, isAutL kAutL f}.\n  by exists kAutL => f; rewrite -in_kAutL k1AHom.\nhave [p Kp /sig2_eqW[rs Dp defL]] := splittingPoly.\ndo [rewrite {}/isAutL -(erefl (asval 1)); set r := rs; set E := 1%AS] in defL *.\nhave [sKE rs_r]: (1 <= E)%VS /\\ all [in rs] r by split; last apply/allP.\nelim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in (E) sKE defL *.\n  rewrite Fadjoin_nil in defL; exists [tuple \\1%AF] => f; rewrite defL inE.\n  apply/idP/eqP=> [/kAHomP f1 | ->]; last exact: kHom1.\n  by apply/val_inj/lfunP=> x; rewrite id_lfunE f1 ?memvf.\ndo [set Ez := <<E; z>>%VS; rewrite adjoin_cons] in defL.\nhave sEEz: (E <= Ez)%VS := subv_adjoin E z; have sKEz := subv_trans sKE sEEz.\nhave{IHr} [homEz DhomEz] := IHr rs_r _ sKEz defL.\nhave Ep: p \\in polyOver E := polyOverSv sKE Kp.\nhave{rs_z} pz0: root p z by rewrite (eqp_root Dp) root_prod_XsubC.\npose pEz := minPoly E z; pose n := \\dim_E Ez.\nhave{pz0} [rz DpEz]: {rz : n.-tuple L | pEz %= \\prod_(w <- rz) ('X - w%:P)}.\n  have /dvdp_prod_XsubC[m DpEz]: pEz %| \\prod_(w <- rs) ('X - w%:P).\n    by rewrite -(eqp_dvdr _ Dp) minPoly_dvdp ?(polyOverSv sKE).\n  suffices sz_rz: size (mask m rs) == n by exists (Tuple sz_rz).\n  rewrite -[n]adjoin_degreeE -eqSS -size_minPoly.\n  by rewrite (eqp_size DpEz) size_prod_XsubC.\nhave fEz i (y := tnth rz i): {f : 'AEnd(L) | kHom E {:L} f & f z = y}.\n  have homEfz: kHom E Ez (kHomExtend E \\1 z y).\n    rewrite kHomExtendP ?kHom1 // lfun1_poly.\n    by rewrite (eqp_root DpEz) -/rz root_prod_XsubC mem_tnth.\n  have splitFp: splittingFieldFor Ez p {:L}.\n    exists rs => //; apply/eqP; rewrite eqEsubv subvf -defL adjoin_seqSr //.\n    exact/allP.\n  have [f homLf Df] := kHom_extends sEEz homEfz Ep splitFp.\n  have [ahomf _] := andP homLf; exists (AHom ahomf) => //.\n  rewrite -Df ?memv_adjoin ?(kHomExtend_val (kHom1 E E)) // lfun1_poly.\n  by rewrite (eqp_root DpEz) root_prod_XsubC mem_tnth.\nexists [seq (s2val (fEz i) \\o f)%AF| i <- enum 'I_n, f <- homEz] => f.\napply/idP/allpairsP => [homLf | [[i g] [_ Hg ->]] /=]; last first.\n  by case: (fEz i) => fi /= /comp_kHom->; rewrite ?(kHomSl sEEz) ?DhomEz.\nhave /tnthP[i Dfz]: f z \\in rz.\n  rewrite memtE /= -root_prod_XsubC -(eqp_root DpEz).\n  by rewrite (kHom_root_id _ homLf) ?memvf ?subvf ?minPolyOver ?root_minPoly.\ncase Dfi: (fEz i) => [fi homLfi fi_z]; have kerfi0 := kAutf_lker0 homLfi.\nset fj := (fi ^-1 \\o f)%AF; suffices Hfj : fj \\in homEz.\n  exists (i, fj) => //=; rewrite mem_enum inE Hfj; split => //.\n  by apply/val_inj; rewrite {}Dfi /= (lker0_compVKf kerfi0).\nrewrite -DhomEz; apply/kAHomP => _ /Fadjoin_polyP[q Eq ->].\nhave homLfj: kHom E {:L} fj := comp_kHom (inv_kHomf homLfi) homLf.\nhave /kHom_lrmorphism fjM := kHomSl (sub1v _) homLfj.\npose fjmM := GRing.isMultiplicative.Build _ _ _ fjM.\npose fjRM : {rmorphism _ -> _} := HB.pack (fun_of_lfun fj) fjmM.\nrewrite -[fj _](horner_map fjRM) (kHom_poly_id homLfj) //=.\nby rewrite (@lfunE _ _ L) /= Dfz -fi_z lker0_lfunK.\nQed."
}
{
  "statement": "Lemma rat_algebraic_decidable (C : fieldType) (QtoC : Qmorphism C) :\n  integralRange QtoC -> decidable_embedding QtoC.\n",
  "proof": "Proof.\nhave QtoCinj: injective QtoC by apply: fmorph_inj.\npose ZtoQ : int -> rat := intr; pose ZtoC : int -> C := intr.\nhave ZtoQinj: injective ZtoQ by apply: intr_inj.\nhave defZtoC: ZtoC =1 QtoC \\o ZtoQ by move=> m; rewrite /= rmorph_int.\nmove=> algC x; have /sig2_eqW[q mon_q qx0] := algC x; pose d := (size q).-1.\nhave [n ub_n]: {n | forall y, root q y -> `|y| < n}.\n  have [n1 ub_n1] := monic_Cauchy_bound mon_q.\n  have /monic_Cauchy_bound[n2 ub_n2]: (-1) ^+ d *: (q \\Po - 'X) \\is monic.\n    rewrite monicE lead_coefZ lead_coef_comp ?size_polyN ?size_polyX // -/d.\n    by rewrite lead_coefN lead_coefX (monicP mon_q) (mulrC 1) signrMK.\n  exists (Num.max n1 n2) => y; rewrite ltNge ler_normr !leUx rootE.\n  apply: contraL => /orP[]/andP[] => [/ub_n1/gt_eqF->// | _ /ub_n2/gt_eqF].\n  by rewrite hornerZ horner_comp !hornerE opprK mulf_eq0 signr_eq0 => /= ->.\nhave [p [a nz_a Dq]] := rat_poly_scale q; pose N := Num.bound `|n * a%:~R|.\npose xa : seq rat := [seq (m%:R - N%:R) / a%:~R | m <- iota 0 N.*2].\nhave [/sig2_eqW[y _ ->] | xa'x] := @mapP _ _ QtoC xa x; first by left; exists y.\nright=> [[y Dx]]; case: xa'x; exists y => //.\nhave{x Dx qx0} qy0: root q y by rewrite Dx fmorph_root in qx0.\nhave /dvdzP[b Da]: (denq y %| a)%Z.\n  have /Gauss_dvdzl <-: coprimez (denq y) (numq y ^+ d).\n    by rewrite coprimez_sym coprimezXl //; apply: coprime_num_den.\n  pose p1 : {poly int} := a *: 'X^d - p.\n  have Dp1: p1 ^ intr = a%:~R *: ('X^d - q).\n    by rewrite rmorphB /= linearZ /= map_polyXn scalerBr Dq scalerKV ?intr_eq0.\n  apply/dvdzP; exists (\\sum_(i < d) p1`_i * numq y ^+ i * denq y ^+ (d - i.+1)).\n  apply: ZtoQinj; rewrite /ZtoQ rmorphM mulr_suml rmorph_sum /=.\n  transitivity ((p1 ^ intr).[y] * (denq y ^+ d)%:~R).\n    rewrite Dp1 !hornerE (rootP qy0) subr0.\n    by rewrite !rmorphXn /= numqE exprMn mulrA.\n  have sz_p1: (size (p1 ^ ZtoQ)%R <= d)%N.\n    rewrite Dp1 size_scale ?intr_eq0 //; apply/leq_sizeP=> i.\n    rewrite leq_eqVlt eq_sym -polySpred ?monic_neq0 // coefB coefXn.\n    case: eqP => [-> _ | _ /(nth_default 0)->//].\n    by rewrite -lead_coefE (monicP mon_q).\n  rewrite (horner_coef_wide _ sz_p1) mulr_suml; apply: eq_bigr => i _.\n  rewrite -!mulrA -exprSr coef_map !rmorphM !rmorphXn /= numqE exprMn -mulrA.\n  by rewrite -exprD -addSnnS subnKC.\npose m := `|(numq y * b + N)%R|%N.\nhave Dm: m%:R = `|y * a%:~R + N%:R|.\n  by rewrite pmulrn abszE intr_norm Da rmorphD !rmorphM /= numqE mulrAC mulrA.\nhave ltr_Qnat n1 n2 : (n1%:R < n2%:R :> rat = _) := ltr_nat _ n1 n2.\nhave ub_y: `|y * a%:~R| < N%:R.\n  apply: le_lt_trans (archi_boundP (normr_ge0 _)); rewrite !normrM.\n  by rewrite ler_pM // (le_trans _ (ler_norm n)) ?ltW ?ub_n.\napply/mapP; exists m.\n  rewrite mem_iota /= add0n -addnn -ltr_Qnat Dm natrD.\n  by rewrite (le_lt_trans (ler_normD _ _)) // normr_nat ltrD2.\nrewrite Dm ger0_norm ?addrK ?mulfK ?intr_eq0 // -lerBlDl sub0r.\nby rewrite (le_trans (ler_norm _)) ?normrN ?ltW.\nQed."
}
{
  "statement": "Theorem Clifford_component_basis M : mxsimple rH M ->\n  {t : nat & {x_ : sH -> 'I_t -> gT |\n    forall W, let sW := (\\sum_j M *m rG (x_ W j))%MS in\n      [/\\ forall j, x_ W j \\in G, (sW :=: W)%MS & mxdirect sW]}}.\n",
  "proof": "Proof.\nmove=> simM; pose t := (n %/ #|sH| %/ \\rank M)%N; exists t.\nhave [X /subsetP sXG [defX1 dxX1]] := Clifford_basis simM.\npose sMv (W : sH) x := (M *m rG x <= W)%MS; pose Xv := [pred x in X | sMv _ x].\nhave sXvG W: {subset Xv W <= G} by move=> x /andP[/sXG].\nhave defW W: (\\sum_(x in Xv W) M *m rG x :=: W)%MS.\n  apply/eqmxP; rewrite -(geq_leqif (mxrank_leqif_eq _)); last first.\n    by apply/sumsmx_subP=> x /andP[].\n  rewrite -(leq_add2r (\\sum_(W' | W' != W) \\rank W')) -((bigD1 W) predT) //=.\n  rewrite -(mxdirectP (Socle_direct sH)) /= -/(Socle _) Clifford_Socle1 -defX1.\n  apply: leq_trans (mxrankS _) (mxrank_sum_leqif _).1 => /=.\n  rewrite (bigID (sMv W))%MS addsmxS //=.\n  apply/sumsmx_subP=> x /andP[Xx notW_Mx]; have Gx := sXG x Xx.\n  have simMx := Clifford_simple simM Gx.\n  pose Wx := PackSocle (component_socle sH simMx).\n  have sMxWx: (M *m rG x <= Wx)%MS by rewrite PackSocleK component_mx_id.\n  by rewrite (sumsmx_sup Wx) //; apply: contra notW_Mx => /eqP <-.\nhave dxXv W: mxdirect (\\sum_(x in Xv W) M *m rG x).\n  move: dxX1; rewrite !mxdirectE /= !(bigID (sMv W) [in X]) /=.\n  by rewrite -mxdirectE mxdirect_addsE /= => /andP[].\nhave def_t W: #|Xv W| = t.\n  rewrite /t -{1}(Clifford_rank_components W) mulKn 1?(cardD1 W) //.\n  rewrite -defW (mxdirectP (dxXv W)) /= (eq_bigr (fun _ => \\rank M)) => [|x].\n    rewrite sum_nat_const mulnK //; last by rewrite lt0n mxrank_eq0; case simM.\n  by move/sXvG=> Gx; rewrite mxrankMfree // row_free_unit repr_mx_unit.\nexists (fun W i => enum_val (cast_ord (esym (def_t W)) i)) => W.\ncase: {def_t}t / (def_t W) => sW.\ncase: (pickP (Xv W)) => [x0 XvWx0 | XvW0]; last first.\n  by case/negP: (nz_socle W); rewrite -submx0 -defW big_pred0.\nhave{x0 XvWx0} reXv := reindex _ (enum_val_bij_in XvWx0).\nhave def_sW: (sW :=: W)%MS.\n  apply: eqmx_trans (defW W); apply/eqmxP; apply/genmxP; congr <<_>>%MS.\n  rewrite reXv /=; apply: eq_big => [j | j _]; first by have:= enum_valP j.\n  by rewrite cast_ord_id.\nsplit=> // [j|]; first by rewrite (sXvG W) ?enum_valP.\napply/mxdirectP; rewrite def_sW -(defW W) /= (mxdirectP (dxXv W)) /= reXv /=.\nby apply: eq_big => [j | j _]; [move: (enum_valP j) | rewrite cast_ord_id].\nQed."
}
{
  "statement": "Lemma FinSplittingFieldFor (F : finFieldType) (p : {poly F}) :\n  p != 0 -> {L : splittingFieldType F | splittingFieldFor 1 p^%:A {:L}}.\n",
  "proof": "Proof.\nhave mapXsubC (f : {rmorphism _ -> _}) x:\n    map_poly f ('X - x%:P) = 'X - (f x)%:P.\n  by rewrite rmorphB /= map_polyX map_polyC.\nmove=> nz_p; pose splits q := {zs | q %= \\prod_(z <- zs) ('X - z%:P)}.\nsuffices [L splitLp]: {L : fieldExtType F | splittingFieldFor 1 p^%:A {:L}}.\n  by exists (FinSplittingFieldType F L).\nsuffices [L [ys Dp]]: {L : fieldExtType F & splits L p^%:A}.\n  pose Lp := subvs_of <<1 & ys>>; pose toL := linfun (vsval : Lp -> L).\n  have [zs Dys]: {zs | map toL zs = ys}.\n    exists (map (vsproj _) ys); rewrite -map_comp map_id_in // => y ys_y.\n    by rewrite /= lfunE /= vsprojK ?seqv_sub_adjoin.\n  exists Lp, zs.\n    set lhs := (lhs in lhs %= _); set rhs := (rhs in _ %= rhs).\n    suffices: map_poly toL lhs %= map_poly toL rhs by rewrite eqp_map.\n    rewrite -Dys big_map in Dp; apply: etrans Dp; apply: congr2.\n      by rewrite -map_poly_comp; apply/eq_map_poly=> x; apply: rmorph_alg.\n    by rewrite rmorph_prod; apply/eq_bigr=> z _; apply mapXsubC.\n  set Lzs := LHS; pose Lys := (toL @: Lzs)%VS; apply/vspaceP=> u.\n  have: val u \\in Lys by rewrite /Lys aimg_adjoin_seq aimg1 Dys (valP u).\n  by case/memv_imgP=> v Lzs_v; rewrite memvf lfunE => /val_inj->.\nmove: {2}_.+1 (ltnSn (size p)) => n; elim: n => // n IHn in F p nz_p * => lbn.\nhave [Cp|C'p] := leqP (size p) 1.\n  exists F^o, [::].\n  by rewrite big_nil -size_poly_eq1 size_map_poly eqn_leq Cp size_poly_gt0.\nhave [r r_dv_p irr_r]: {r | r %| p & irreducible_poly r}.\n  pose rVp (v : 'rV_n) (r := rVpoly v) := (1 < size r) && (r %| p).\n  have [v0 Dp]: {v0 | rVpoly v0 = p & rVp v0}.\n    by exists (poly_rV p); rewrite /rVp poly_rV_K ?C'p /=.\n  case/(arg_minnP (size \\o rVpoly))=> /= v; set r := rVpoly v.\n  case/andP=> C'r r_dv_p min_r; exists r => //; split=> // q C'q q_dv_r.\n  have nz_r: r != 0 by rewrite -size_poly_gt0 ltnW.\n  have le_q_r: size q <= size r by rewrite dvdp_leq.\n  have [u Dq]: {u : 'rV_n | rVpoly u = q}.\n    by exists (poly_rV q); rewrite poly_rV_K ?(leq_trans le_q_r) ?size_poly.\n  rewrite -dvdp_size_eqp // eqn_leq le_q_r -Dq min_r // /rVp Dq.\n  rewrite ltn_neqAle eq_sym C'q size_poly_gt0 (dvdpN0 q_dv_r) //=.\n  exact: dvdp_trans q_dv_r r_dv_p.\nhave{irr_r} [K _ [x rx0 defK]] := irredp_FAdjoin irr_r.\nhave{r rx0 r_dv_p} /factor_theorem/sig_eqW[q Dp]: root p^%:A x.\n  by rewrite -(divpK r_dv_p) [_^%:A]rmorphM rootM rx0 orbT.\nhave Dszp: size p = size (q * ('X - x%:P)) by rewrite -Dp size_map_poly.\nhave nz_q: q != 0.\n  by move: nz_p; rewrite -size_poly_eq0 Dszp size_poly_eq0 mulf_eq0 => /norP[].\nhave [L [zs Dq]]: {L : fieldExtType K & splits L q^%:A}.\n  apply: (IHn (FinFieldExtType K) q nz_q).\n  by rewrite ltnS Dszp size_mul ?polyXsubC_eq0 ?size_XsubC ?addn2 in lbn.\nsuffices: splits L p^%:A^%:A.\n  rewrite -[_^%:A]map_poly_comp.\n\n  rewrite -(eq_map_poly (fun a : F => baseField_scaleE a 1)).\n  by exists (baseFieldType L).\nexists (x%:A :: zs); rewrite big_cons; set rhs := _ * _.\nby rewrite Dp mulrC [_^%:A]rmorphM /= mapXsubC /= eqp_mull.\nQed."
}
{
  "statement": "Lemma galois_fixedField K E :\n  reflect (fixedField 'Gal(E / K) = K) (galois K E).\n",
  "proof": "Proof.\napply: (iffP idP) => [/and3P[sKE /separableP sepKE nKE] | fixedKE].\n  apply/eqP; rewrite eqEsubv galois_connection_subv ?andbT //.\n  apply/subvP=> a /mem_fixedFieldP[Ea fixEa]; rewrite -adjoin_deg_eq1.\n  have [r /allP Er splitKa] := normalFieldP nKE a Ea.\n  rewrite -eqSS -size_minPoly splitKa size_prod_XsubC eqSS -[1]/(size [:: a]).\n  have Ur: uniq r by rewrite -separable_prod_XsubC -splitKa; apply: sepKE.\n  rewrite -uniq_size_uniq {Ur}// => b; rewrite inE -root_prod_XsubC -splitKa.\n  apply/eqP/idP=> [-> | pKa_b_0]; first exact: root_minPoly.\n  by have [x /fixEa-> ->] := normalField_root_minPoly sKE nKE Ea pKa_b_0.\nhave sKE: (K <= E)%VS by rewrite -fixedKE capvSl.\napply/galois_factors=> // a Ea.\npose r_pKa := [seq x a | x : gal_of E in 'Gal(E / K)].\nhave /fin_all_exists2[x_ galEx_ Dx_a] (b : seq_sub r_pKa) := imageP (valP b).\nexists (codom x_); rewrite -map_comp; set r := map _ _.\nhave r_xa x: x \\in 'Gal(E / K) -> x a \\in r.\n  move=> galEx; have r_pKa_xa: x a \\in r_pKa by apply/imageP; exists x.\n  by rewrite [x a](Dx_a (SeqSub r_pKa_xa)); apply: codom_f.\nhave Ur: uniq r by apply/injectiveP=> b c /=; rewrite -!Dx_a => /val_inj.\nsplit=> //; first by apply/subsetP=> _ /codomP[b ->].\napply/eqP; rewrite -eqp_monic ?monic_minPoly ?monic_prod_XsubC //.\napply/andP; split; last first.\n  rewrite uniq_roots_dvdp ?uniq_rootsE // all_map.\n  by apply/allP=> b _ /=; rewrite root_minPoly_gal.\napply: minPoly_dvdp; last by rewrite root_prod_XsubC -(gal_id E a) r_xa ?group1.\nrewrite -fixedKE; apply/polyOverP => i; apply/fixedFieldP=> [|x galEx].\n  rewrite (polyOverP _) // big_map rpred_prod // => b _.\n  by rewrite polyOverXsubC memv_gal.\nrewrite -coef_map rmorph_prod; congr (_ : {poly _})`_i.\nsymmetry; rewrite (perm_big (map x r)) /= ?(big_map x).\n  by apply: eq_bigr => b _; rewrite rmorphB /= map_polyX map_polyC.\nhave Uxr: uniq (map x r) by rewrite map_inj_uniq //; apply: fmorph_inj.\nhave /uniq_min_size: {subset map x r <= r}.\n  by rewrite -map_comp => _ /codomP[b ->] /=; rewrite -galM // r_xa ?groupM.\nby rewrite (size_map x) perm_sym; case=> // _ /uniq_perm->.\nQed."
}
{
  "statement": "Lemma isog_pX1p2 (gT : finGroupType) (G : {group gT}) :\n  extraspecial G -> exponent G %| p -> #|G| = (p ^ 3)%N -> G \\isog p^{1+2}.\n",
  "proof": "Proof.\nmove=> esG expGp oG; apply/(isoGrpP _ Grp_pX1p2).\nrewrite card_pX1p2; split=> //.\nhave pG: p.-group G by rewrite /pgroup oG pnatX pnat_id.\nhave oZ := card_center_extraspecial pG esG.\nhave [x Gx notZx]: exists2 x, x \\in G & x \\notin 'Z(G).\n  apply/subsetPn; rewrite proper_subn // properEcard center_sub oZ oG.\n  by rewrite (ltn_exp2l 1 3).\nhave ox: #[x] = p.\n  by apply: nt_prime_order; rewrite ?(exponentP expGp) ?(group1_contra notZx).\nhave [y Gy not_cxy]: exists2 y, y \\in G & y \\notin 'C[x].\n  by apply/subsetPn; rewrite sub_cent1; rewrite inE Gx in notZx.\napply/existsP; exists (x, y) => /=; set z := [~ x, y].\nhave [[defPhiG defG'] _] := esG.\nhave Zz: z \\in 'Z(G) by rewrite -defG' mem_commg.\nhave [Gz cGz] := setIP Zz; rewrite !xpair_eqE !(exponentP expGp) //.\nhave [_ nZG] := andP (center_normal G).\nrewrite /commg /conjg !(centP cGz) // !mulKg mulVg !eqxx !andbT.\nhave sXY_G: <[x]> <*> <[y]> \\subset G by rewrite join_subG !cycle_subG Gx.\nhave defZ: <[z]> = 'Z(G).\n  apply/eqP; rewrite eqEcard cycle_subG Zz oZ /= -orderE.\n  rewrite (nt_prime_order p_pr) ?(exponentP expGp) //.\n  by rewrite (sameP commgP cent1P) cent1C.\nhave sZ_XY: 'Z(G) \\subset <[x]> <*> <[y]>.\n  by rewrite -defZ cycle_subG groupR // mem_gen // inE cycle_id ?orbT.\nrewrite eqEcard sXY_G /= oG -(Lagrange sZ_XY) oZ leq_pmul2l //.\nrewrite -card_quotient ?(subset_trans sXY_G) //.\nrewrite quotientY ?quotient_cycle ?cycle_subG ?(subsetP nZG) //.\nhave abelGz: p.-abelem (G / 'Z(G)) by rewrite -defPhiG Phi_quotient_abelem.\nhave [cGzGz expGz] := abelemP p_pr abelGz.\nrewrite cent_joinEr ?(sub_abelian_cent2 cGzGz) ?cycle_subG ?mem_quotient //.\nhave oZx: #|<[coset 'Z(G) x]>| = p.\n  rewrite -orderE (nt_prime_order p_pr) ?expGz ?mem_quotient //.\n  by apply: contra notZx; move/eqP=> Zx; rewrite coset_idr ?(subsetP nZG).\nrewrite TI_cardMg ?oZx -?orderE ?(nt_prime_order p_pr) ?expGz ?mem_quotient //.\n  apply: contra not_cxy; move/eqP=> Zy.\n  rewrite -cent_cycle (subsetP _ y (coset_idr _ Zy)) ?(subsetP nZG) //.\n  by rewrite subIset ?centS ?orbT ?cycle_subG.\nrewrite prime_TIg ?oZx // cycle_subG; apply: contra not_cxy.\ncase/cycleP=> i; rewrite -morphX ?(subsetP nZG) // => /rcoset_kercosetP.\nrewrite groupX ?(subsetP nZG) // cent1C => /(_ isT isT); apply: subsetP.\nrewrite mul_subG ?sub1set ?groupX ?cent1id //= -cent_cycle subIset // orbC.\nby rewrite centS ?cycle_subG.\nQed."
}
{
  "statement": "Lemma mx_poly_ring_isom (R : nzRingType) n' (n := n'.+1) :\n  exists phi : {rmorphism 'M[{poly R}]_n -> {poly 'M[R]_n}},\n  [/\\ bijective phi,\n      forall p, phi p%:M = map_poly scalar_mx p,\n      forall A, phi (map_mx polyC A) = A%:P\n    & forall A i j k, (phi A)`_k i j = (A i j)`_k].\n",
  "proof": "Proof.\nset M_RX := 'M[{poly R}]_n; set MR_X := ({poly 'M[R]_n}).\npose Msize (A : M_RX) := \\max_i \\max_j size (A i j).\npose phi (A : M_RX) := \\poly_(k < Msize A) \\matrix_(i, j) (A i j)`_k.\nhave coef_phi A i j k: (phi A)`_k i j = (A i j)`_k.\n  rewrite coef_poly; case: (ltnP k _) => le_m_k; rewrite mxE // nth_default //.\n  by apply: leq_trans (leq_trans (leq_bigmax i) le_m_k); apply: (leq_bigmax j).\nhave phi_is_additive : additive phi.\n  move=> A B; apply/polyP => k; apply/matrixP => i j.\n  by rewrite !(coef_phi, mxE, coefD, coefN).\nhave phi_is_multiplicative : multiplicative phi.\n  split=> [A B|]; apply/polyP => k; apply/matrixP => i j; last first.\n    by rewrite coef_phi mxE coefMn !coefC; case: (k == _); rewrite ?mxE ?mul0rn.\n  rewrite !coef_phi !mxE !coefM summxE coef_sum.\n  pose F k1 k2 := (A i k1)`_k2 * (B k1 j)`_(k - k2).\n  transitivity (\\sum_k1 \\sum_(k2 < k.+1) F k1 k2); rewrite {}/F.\n    by apply: eq_bigr=> k1 _; rewrite coefM.\n  rewrite exchange_big /=; apply: eq_bigr => k2 _.\n  by rewrite mxE; apply: eq_bigr => k1 _; rewrite !coef_phi.\nhave bij_phi: bijective phi.\n  exists (fun P : MR_X => \\matrix_(i, j) \\poly_(k < size P) P`_k i j) => [A|P].\n    apply/matrixP=> i j; rewrite mxE; apply/polyP=> k.\n    rewrite coef_poly -coef_phi.\n    by case: leqP => // P_le_k; rewrite nth_default ?mxE.\n  apply/polyP=> k; apply/matrixP=> i j; rewrite coef_phi mxE coef_poly.\n  by case: leqP => // P_le_k; rewrite nth_default ?mxE.\npose phiaM := GRing.isAdditive.Build _ _ phi phi_is_additive.\npose phimM := GRing.isMultiplicative.Build _ _ phi phi_is_multiplicative.\npose phiRM : {rmorphism _ -> _} := HB.pack phi phiaM phimM.\nexists phiRM; split=> // [p | A]; apply/polyP=> k; apply/matrixP=> i j.\n  by rewrite coef_phi coef_map !mxE coefMn.\nby rewrite coef_phi !mxE !coefC; case k; last rewrite /= mxE.\nQed."
}
{
  "statement": "Lemma critical_p_stab_Aut H :\n  critical H G -> p.-group G -> p.-group 'C(H | [Aut G]).\n",
  "proof": "Proof.\nmove=> [chH sPhiZ sRZ eqCZ] pG; have sHG := char_sub chH.\npose G' := (sdpair1 [Aut G] @* G)%G; pose H' := (sdpair1 [Aut G] @* H)%G.\napply/pgroupP=> q pr_q; case/Cauchy=> //= f cHF; move: (cHF); rewrite astab_ract.\ncase/setIP=> Af cHFP ofq; rewrite -cycle_subG in cHF; apply: (pgroupP pG) => //.\npose F' := (sdpair2 [Aut G] @* <[f]>)%G.\nhave trHF: [~: H', F'] = 1.\n  apply/trivgP; rewrite gen_subG; apply/subsetP=> u; case/imset2P=> x' a'.\n  case/morphimP=> x Gx Hx ->; case/morphimP=> a Aa Fa -> -> {u x' a'}.\n  by rewrite inE commgEl -sdpair_act ?(astab_act (subsetP cHF _ Fa) Hx) ?mulVg.\nhave sGH_H: [~: G', H'] \\subset H'.\n  by rewrite -morphimR ?(char_sub chH) // morphimS // commg_subr char_norm.\nhave{trHF sGH_H} trFGH: [~: F', G', H'] = 1.\n  apply: three_subgroup; last by rewrite trHF comm1G.\n  by apply/trivgP; rewrite -trHF commSg.\napply/negP=> qG; case: (qG); rewrite -ofq.\nsuffices ->: f = 1 by rewrite order1 dvd1n.\napply/permP=> x; rewrite perm1; case Gx: (x \\in G); last first.\n  by apply: out_perm (negbT Gx); case/setIdP: Af.\nhave Gfx: f x \\in G by rewrite -(im_autm Af) -{1}(autmE Af) mem_morphim.\npose y := x^-1 * f x; have Gy: y \\in G by rewrite groupMl ?groupV.\nhave [inj1 inj2] := (injm_sdpair1 [Aut G], injm_sdpair2 [Aut G]).\nhave Hy: y \\in H.\n  rewrite (subsetP (center_sub H)) // -eqCZ -cycle_subG.\n  rewrite -(injmSK inj1) ?cycle_subG // injm_subcent // subsetI.\n  rewrite morphimS ?morphim_cycle ?cycle_subG //=.\n  suffices: sdpair1 [Aut G] y \\in [~: G', F'].\n    by rewrite commGC; apply: subsetP; apply/commG1P.\n  rewrite morphM ?groupV ?morphV //= sdpair_act // -commgEl.\n  by rewrite mem_commg ?mem_morphim ?cycle_id.\nhave fy: f y = y := astabP cHFP _ Hy.\nhave: (f ^+ q) x = x * y ^+ q.\n  elim: (q) => [|i IHi]; first by rewrite perm1 mulg1.\n  rewrite expgSr permM {}IHi -(autmE Af) morphM ?morphX ?groupX //= autmE.\n  by rewrite fy expgS mulgA mulKVg.\nmove/eqP; rewrite -{1}ofq expg_order perm1 eq_mulVg1 mulKg -order_dvdn.\ncase/primeP: pr_q => _ pr_q /pr_q; rewrite order_eq1 -eq_mulVg1.\nby case: eqP => //= _ /eqP oyq; case: qG; rewrite -oyq order_dvdG.\nQed."
}
{
  "statement": "Lemma dfs_pathP n x y v :\n  #|T| <= #|v| + n -> y \\notin v -> reflect (dfs_path v x y) (y \\in dfs n v x).\n",
  "proof": "Proof.\nhave dfs_id w z: z \\notin w -> dfs_path w z z.\n  by exists [::]; rewrite ?disjoint_has //= orbF.\nelim: n => [|n IHn] /= in x y v * => le_v'_n not_vy.\n  rewrite addn0 (geq_leqif (subset_leqif_card (subset_predT _))) in le_v'_n.\n  by rewrite predT_subset in not_vy.\nhave [v_x | not_vx] := ifPn.\n  by rewrite (negPf not_vy); right=> [] [p _ _]; rewrite disjoint_has /= v_x.\nset v1 := x :: v; set a := g x; have sub_dfs := subsetP (subset_dfs n _ _).\nhave [-> | neq_yx] := eqVneq y x.\n  by rewrite sub_dfs ?mem_head //; left; apply: dfs_id.\napply: (@equivP (exists2 x1, x1 \\in a & dfs_path v1 x1 y)); last first.\n  split=> {IHn} [[x1 a_x1 [p g_p p_y]] | [p /shortenP[]]].\n    rewrite disjoint_has has_sym /= has_sym /= => /norP[_ not_pv].\n    by exists (x1 :: p); rewrite /= ?a_x1 // disjoint_has negb_or not_vx.\n  case=> [_ _ _ eq_yx | x1 p1 /=]; first by case/eqP: neq_yx.\n  case/andP=> a_x1 g_p1 /andP[not_p1x _] /subsetP p_p1 p1y not_pv.\n  exists x1 => //; exists p1 => //.\n  rewrite disjoint_sym disjoint_cons not_p1x disjoint_sym.\n  by move: not_pv; rewrite disjoint_cons => /andP[_ /disjointWl->].\nhave{neq_yx not_vy}: y \\notin v1 by apply/norP.\nhave{le_v'_n not_vx}: #|T| <= #|v1| + n by rewrite cardU1 not_vx addSnnS.\nelim: {x v}a v1 => [|x a IHa] v /= le_v'_n not_vy.\n  by rewrite (negPf not_vy); right=> [] [].\nset v2 := dfs n v x; have v2v: v \\subset v2 := subset_dfs n v [:: x].\nhave [v2y | not_v2y] := boolP (y \\in v2).\n  by rewrite sub_dfs //; left; exists x; [apply: mem_head | apply: IHn].\napply: {IHa}(equivP (IHa _ _ not_v2y)).\n  by rewrite (leq_trans le_v'_n) // leq_add2r subset_leq_card.\nsplit=> [] [x1 a_x1 [p g_p p_y not_pv]].\n  exists x1; [exact: predU1r | exists p => //].\n  by rewrite disjoint_sym (disjointWl v2v) // disjoint_sym.\nsuffices not_p1v2: [disjoint x1 :: p & v2].\n  case/predU1P: a_x1 => [def_x1 | ]; last by exists x1; last exists p.\n  case/pred0Pn: not_p1v2; exists x; rewrite /= def_x1 mem_head /=.\n  suffices not_vx: x \\notin v by apply/IHn; last apply: dfs_id.\n  by move: not_pv; rewrite disjoint_cons def_x1 => /andP[].\napply: contraR not_v2y => /pred0Pn[x2 /andP[/= p_x2 v2x2]].\ncase/splitPl: p_x2 p_y g_p not_pv => p0 p2 p0x2.\nrewrite last_cat cat_path -cat_cons lastI cat_rcons {}p0x2 => p2y /andP[_ g_p2].\nrewrite disjoint_cat disjoint_cons => /and3P[{p0}_ not_vx2 not_p2v].\nhave{not_vx2 v2x2} [p1 g_p1 p1_x2 not_p1v] := IHn _ _ v le_v'_n not_vx2 v2x2.\napply/IHn=> //; exists (p1 ++ p2); rewrite ?cat_path ?last_cat -?p1_x2 ?g_p1 //.\nby rewrite -cat_cons disjoint_cat not_p1v.\nQed."
}
{
  "statement": "Lemma rfix_pgroup_pchar G H n (rG : mx_representation F G n) :\n  n > 0 -> p.-group H -> H \\subset G -> rfix_mx rG H != 0.\n",
  "proof": "Proof.\nmove=> n_gt0 pH sHG; rewrite -(rfix_subg rG sHG).\nmove: {2}_.+1 (ltnSn (n + #|H|)) {rG G sHG}(subg_repr _ _) => m.\nelim: m gT H pH => // m IHm gT' G pG in n n_gt0 *; rewrite ltnS => le_nG_m rG.\napply/eqP=> Gregular; have irrG: mx_irreducible rG.\n  apply/mx_irrP; split=> // U modU; rewrite -mxrank_eq0 -lt0n => Unz.\n  rewrite /row_full eqn_leq rank_leq_col leqNgt; apply/negP=> ltUn.\n  have: rfix_mx (submod_repr modU) G != 0.\n    by apply: IHm => //; apply: leq_trans le_nG_m; rewrite ltn_add2r.\n  by rewrite -mxrank_eq0 (rfix_submod modU) // Gregular capmx0 linear0 mxrank0.\nhave{m le_nG_m IHm} faithfulG: mx_faithful rG.\n  apply/trivgP/eqP/idPn; set C := _ rG => ntC.\n  suffices: rfix_mx (kquo_repr rG) (G / _)%g != 0.\n    by rewrite -mxrank_eq0 rfix_quo // Gregular mxrank0.\n  apply: (IHm _ _ (morphim_pgroup _ _)) => //.\n  by apply: leq_trans le_nG_m; rewrite ltn_add2l ltn_quotient // rstab_sub.\nhave{Gregular} ntG: G :!=: 1%g.\n  apply: contraL n_gt0; move/eqP=> G1; rewrite -leqNgt -(mxrank1 F n).\n  rewrite -(mxrank0 F n n) -Gregular mxrankS //; apply/rfix_mxP=> x.\n  by rewrite {1}G1 mul1mx => /set1P->; rewrite repr_mx1.\nhave p_pr: prime p by case/andP: pcharFp.\nhave{ntG pG} [z]: {z | z \\in 'Z(G) & #[z] = p}; last case/setIP=> Gz cGz ozp.\n  apply: Cauchy => //; apply: contraR ntG; rewrite -p'natE // => p'Z.\n  have pZ: p.-group 'Z(G) by rewrite (pgroupS (center_sub G)).\n  by rewrite (trivg_center_pgroup pG (card1_trivg (pnat_1 pZ p'Z))).\nhave{cGz} cGz1: centgmx rG (rG z - 1%:M).\n  apply/centgmxP=> x Gx; rewrite mulmxBl mulmxBr mulmx1 mul1mx.\n  by rewrite -!repr_mxM // (centP cGz).\nhave{irrG faithfulG cGz1} Urz1: rG z - 1%:M \\in unitmx.\n  apply: (mx_Schur irrG) cGz1 _; rewrite subr_eq0.\n  move/implyP: (subsetP faithfulG z).\n  by rewrite !inE Gz mul1mx -order_eq1 ozp -implybNN neq_ltn orbC prime_gt1.\ndo [case: n n_gt0 => // n' _; set n := n'.+1] in rG Urz1 *.\nhave pcharMp: p \\in [pchar 'M[F]_n].\n  exact: (rmorph_pchar (@scalar_mx F n)).\nhave{Urz1}: pFrobenius_aut pcharMp (rG z - 1) \\in GRing.unit by rewrite unitrX.\nrewrite (pFrobenius_autB_comm _ (commr1 _)) pFrobenius_aut1.\nby rewrite -[_ (rG z)](repr_mxX rG) // -ozp expg_order repr_mx1 subrr unitr0.\nQed."
}
{
  "statement": "Lemma quantifier_elim_rformP e f :\n  rformula f -> reflect (holds e f) (qf_eval e (quantifier_elim f)).\n",
  "proof": "Proof.\npose rc e n f := exists x, qf_eval (set_nth 0 e n x) f.\nhave auxP f0 e0 n0: qf_form f0 && rformula f0 ->\n  reflect (rc e0 n0 f0) (qf_eval e0 (elim_aux f0 n0)).\n+ rewrite /elim_aux => cf; set bcs := qf_to_dnf f0 false.\n  apply: (@iffP (rc e0 n0 (dnf_to_form bcs))); last first.\n  - by case=> x; rewrite -qf_to_dnfP //; exists x.\n  - by case=> x; rewrite qf_to_dnfP //; exists x.\n  have: all dnf_rterm bcs by case/andP: cf => _; apply: qf_to_dnf_rterm.\n  elim: {f0 cf}bcs => [|bc bcs IHbcs] /=; first by right; case.\n  case/andP=> r_bc /IHbcs {IHbcs}bcsP.\n  have f_qf := dnf_to_form_qf [:: bc].\n  case: ok_proj => //= [ex_x|no_x].\n    left; case: ex_x => x /(qf_evalP _ f_qf); rewrite /= orbF => bc_x.\n    by exists x; rewrite /= bc_x.\n  apply: (iffP bcsP) => [[x bcs_x] | [x]] /=.\n    by exists x; rewrite /= bcs_x orbT.\n  case/orP => [bc_x|]; last by exists x.\n  by case: no_x; exists x; apply/(qf_evalP _ f_qf); rewrite /= bc_x.\nelim: f e => //.\n- by move=> b e _; apply: idP.\n- by move=> t1 t2 e _; apply: eqP.\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; last by right; case.\n  by case/IH2; [left | right; case].\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; first by do 2!left.\n  by case/IH2; [left; right | right; case].\n- move=> f1 IH1 f2 IH2 e /= /andP[/IH1[] f1e]; last by left.\n  by case/IH2; [left | right; move/(_ f1e)].\n- by move=> f IHf e /= /IHf[]; [right | left].\n- move=> n f IHf e /= rf; have rqf := quantifier_elim_wf rf.\n  by apply: (iffP (auxP _ _ _ rqf)) => [] [x]; exists x; apply/IHf.\nmove=> n f IHf e /= rf; have rqf := quantifier_elim_wf rf.\ncase: auxP => // [f_x|no_x]; first by right=> no_x; case: f_x => x /IHf[].\nby left=> x; apply/IHf=> //; apply/idPn=> f_x; case: no_x; exists x.\nQed."
}
{
  "statement": "Lemma homGrp_trans rT gT (H : {set rT}) (G : {group gT}) p :\n  H \\homg G -> G \\homg Grp p -> H \\homg Grp p.\n",
  "proof": "Proof.\ncase/homgP=> h <-{H}; rewrite /hom; move: {p}(p _) => p.\nhave evalG e t: all [in G] e -> eval (map h e) t = h (eval e t).\n  move=> Ge; apply: (@proj2 (eval e t \\in G)); elim: t => /=.\n  - move=> i; case: (leqP (size e) i) => [le_e_i | lt_i_e].\n      by rewrite !nth_default ?size_map ?morph1.\n    by rewrite (nth_map 1) // [_ \\in G](allP Ge) ?mem_nth.\n  - by rewrite morph1.\n  - by move=> t [Gt ->]; rewrite groupV morphV.\n  - by move=> t [Gt ->] n; rewrite groupX ?morphX.\n  - by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupM ?morphM.\n  - by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupJ ?morphJ.\n  by move=> t1 [Gt1 ->] t2 [Gt2 ->]; rewrite groupR ?morphR.\nhave and_relE xT x1 x2 r: @and_rel xT x1 x2 r = (x1 == x2) && r :> bool.\n  by case: r => //=; rewrite andbT.\nhave rsatG e f: all [in G] e -> rel e f NoRel -> rel (map h e) f NoRel.\n  move=> Ge; have: NoRel -> NoRel by []; move: NoRel {2 4}NoRel.\n  elim: f => [x1 x2 | f1 IH1 f2 IH2] r hr IHr; last by apply: IH1; apply: IH2.\n  by rewrite !and_relE !evalG //; case/andP; move/eqP->; rewrite eqxx.\nset s := env1; set vT := gT : finType in s *.\nset s' := env1; set vT' := rT : finType in s' *.\nhave (v): let: Env A e := s v in\n  A \\subset G -> all [in G] e /\\ exists v', s' v' = Env (h @* A) (map h e).\n- rewrite /= cycle_subG andbT => Gv; rewrite morphim_cycle //.\n  by split; last exists (h v).\nelim: p 1%N vT vT' s s' => /= [p IHp | f] n vT vT' s s' Gs.\n  apply: IHp => [[v x]] /=; case: (s v) {Gs}(Gs v) => A e /= Gs.\n  rewrite join_subG cycle_subG; case/andP=> sAG Gx; rewrite Gx.\n  have [//|-> [v' def_v']] := Gs; split=> //; exists (v', h x); rewrite def_v'.\n  by congr (Env _ _); rewrite morphimY ?cycle_subG // morphim_cycle.\ncase/existsP=> v; case: (s v) {Gs}(Gs v) => /= A e Gs.\nrewrite and_relE => /andP[/eqP defA rel_f].\nhave{Gs} [|Ge [v' def_v']] := Gs; first by rewrite defA.\napply/existsP; exists v'; rewrite def_v' and_relE defA eqxx /=.\nby rewrite -map_rev rsatG ?(eq_all_r (mem_rev e)).\nQed."
}
{
  "statement": "Lemma group_splitting_field_exists gT (G : {group gT}) F :\n  classically {Fs : fieldType & {rmorphism F -> Fs}\n                              & group_splitting_field Fs G}.\n",
  "proof": "Proof.\nmove: F => F0 [] // nosplit; pose nG := #|G|; pose aG F := regular_repr F G.\npose m := nG.+1; pose F := F0; pose U : seq 'M[F]_nG := [::].\nsuffices: size U + m <= nG by rewrite ltnn.\nhave: mx_subseries (aG F) U /\\ path ltmx 0 U by [].\npose f : {rmorphism F0 -> F} := idfun.\nelim: m F U f => [|m IHm] F U f [modU ltU].\n  by rewrite addn0 (leq_trans (max_size_mx_series ltU)) ?rank_leq_row.\nrewrite addnS ltnNge -implybF; apply/implyP=> le_nG_Um; apply: nosplit.\nexists F => //; case=> [|n] rG irrG; first by case/mx_irrP: irrG.\napply/idPn=> nabsG; pose cG := ('C(enveloping_algebra_mx rG))%MS.\nhave{nabsG} [A]: exists2 A, (A \\in cG)%MS & ~~ is_scalar_mx A.\n  apply/has_non_scalar_mxP; rewrite ?scalar_mx_cent // ltnNge.\n  by apply: contra nabsG; apply: cent_mx_scalar_abs_irr.\nrewrite {cG}memmx_cent_envelop -mxminpoly_linear_is_scalar -ltnNge => cGA.\nmove/(non_linear_gen_reducible irrG cGA).\n\nset F' := _ irrG cGA; set rG' := @map_repr _ F' _ _ _ _ rG.\nmove: F' (gen _ _ : {rmorphism F -> F'}) => F' f' in rG' * => irrG'.\npose U' := [seq map_mx f' Ui | Ui <- U].\nhave modU': mx_subseries (aG F') U'.\n  apply: etrans modU; rewrite /mx_subseries all_map; apply: eq_all => Ui.\n  rewrite -(mxmodule_map f'); apply: eq_subset_r => x.\n  by rewrite !inE map_regular_repr.\ncase: notF; apply: (mx_Schreier modU ltU) => [[V [compV lastV sUV]]].\nhave{lastV} [] := rsim_regular_series irrG compV lastV.\nhave{sUV} defV: V = U.\n  apply/eqP; rewrite eq_sym -(geq_leqif (size_subseq_leqif sUV)).\n  rewrite -(leq_add2r m); apply: leq_trans le_nG_Um.\n  by apply: IHm f _; rewrite (mx_series_lt compV); case: compV.\nrewrite {V}defV in compV * => i rsimVi.\napply: (mx_Schreier modU') => [|[V' [compV' _ sUV']]].\n  rewrite {modU' compV modU i le_nG_Um rsimVi}/U' -(map_mx0 f').\n  by apply: etrans ltU; elim: U 0 => //= Ui U IHU Ui'; rewrite IHU map_ltmx.\nhave{sUV'} defV': V' = U'; last rewrite {V'}defV' in compV'.\n  apply/eqP; rewrite eq_sym -(geq_leqif (size_subseq_leqif sUV')) size_map.\n  rewrite -(leq_add2r m); apply: leq_trans le_nG_Um.\n  apply: IHm (f' \\o f) _.\n  by rewrite (mx_series_lt compV'); case: compV'.\nsuffices{irrG'}: mx_irreducible rG' by case/mxsimpleP=> _ _ [].\nhave ltiU': i < size U' by rewrite size_map.\napply: mx_rsim_irr (mx_rsim_sym _ ) (mx_series_repr_irr compV' ltiU').\nby apply: mx_rsim_trans (mx_rsim_map f' rsimVi) _; apply: map_regular_subseries.\nQed."
}
{
  "statement": "Theorem SchurZassenhaus_trans_sol gT (H K K1 : {group gT}) :\n    solvable H -> K \\subset 'N(H) -> K1 \\subset H * K ->\n    coprime #|H| #|K| -> #|K1| = #|K| ->\n  exists2 x, x \\in H & K1 :=: K :^ x.\n",
  "proof": "Proof.\nhave [n] := ubnP #|H|.\nelim: n => // n IHn in gT H K K1 * => /ltnSE-leHn solH nHK.\nhave [-> | ] := eqsVneq H 1.\n  rewrite mul1g => sK1K _ eqK1K; exists 1; first exact: set11.\n  by apply/eqP; rewrite conjsg1 eqEcard sK1K eqK1K /=.\npose G := (H <*> K)%G.\nhave defG: G :=: H * K by rewrite -normC // -norm_joinEl // joingC.\nhave sHG: H \\subset G by apply: joing_subl.\nhave sKG: K \\subset G by apply: joing_subr.\nhave nsHG: H <| G by rewrite /(H <| G) sHG join_subG normG.\ncase/(solvable_norm_abelem solH nsHG)=> M [sMH nsMG ntM] /and3P[_ abelM _].\nhave [sMG nMG] := andP nsMG; rewrite -defG => sK1G coHK oK1K.\nhave nMsG (L : {set gT}): L \\subset G -> L \\subset 'N(M).\n  by move/subset_trans->.\nhave [coKM coHMK]: coprime #|M| #|K| /\\ coprime #|H / M| #|K|.\n  by apply/andP; rewrite -coprimeMl card_quotient ?nMsG ?Lagrange.\nhave oKM (K' : {group gT}): K' \\subset G -> #|K'| = #|K| -> #|K' / M| = #|K|.\n  move=> sK'G oK'.\n  rewrite -quotientMidr -?norm_joinEl ?card_quotient ?nMsG //; last first.\n    by rewrite gen_subG subUset sK'G.\n  rewrite -divgS /=; last by rewrite -gen_subG genS ?subsetUr.\n  by rewrite norm_joinEl ?nMsG // coprime_cardMg ?mulnK // oK' coprime_sym.\nhave [xb]: exists2 xb, xb \\in H / M & K1 / M = (K / M) :^ xb.\n  apply: IHn; try by rewrite (quotient_sol, morphim_norms, oKM K) ?(oKM K1).\n    by apply: leq_trans leHn; rewrite ltn_quotient.\n  by rewrite -morphimMl ?nMsG // -defG morphimS.\ncase/morphimP=> x nMx Hx ->{xb} eqK1Kx; pose K2 := (K :^ x)%G.\nhave{eqK1Kx} eqK12: K1 / M = K2 / M by rewrite quotientJ.\nsuff [y My ->]: exists2 y, y \\in M & K1 :=: K2 :^ y.\n  by exists (x * y); [rewrite groupMl // (subsetP sMH) | rewrite conjsgM].\nhave nMK1: K1 \\subset 'N(M) by apply: nMsG.\nhave defMK: M * K1 = M <*> K1 by rewrite -normC // -norm_joinEl // joingC.\nhave sMKM: M \\subset M <*> K1 by rewrite joing_subl.\nhave nMKM: M <| M <*> K1 by rewrite normalYl.\nhave trMK1: M :&: K1 = 1 by rewrite coprime_TIg ?oK1K.\nhave trMK2: M :&: K2 = 1 by rewrite coprime_TIg ?cardJg ?oK1K.\napply: (Gaschutz_transitive nMKM _ sMKM) => //=; last 2 first.\n- by rewrite inE trMK1 defMK !eqxx.\n- by rewrite -!(setIC M) trMK1.\n- by rewrite -divgS //= -defMK coprime_cardMg oK1K // mulKn.\nrewrite inE trMK2 eqxx eq_sym eqEcard /= -defMK andbC.\nby rewrite !coprime_cardMg ?cardJg ?oK1K ?leqnn //= mulGS -quotientSK -?eqK12.\nQed."
}
{
  "statement": "Lemma critical_extraspecial R S :\n    p.-group R -> S \\subset R -> extraspecial S -> [~: S, R] \\subset S^`(1) ->\n  S \\* 'C_R(S) = R.\n",
  "proof": "Proof.\nmove=> pR sSR esS sSR_S'; have [[defPhi defS'] _] := esS.\nhave [pS [sPS nPS]] := (pgroupS sSR pR, andP (Phi_normal S : 'Phi(S) <| S)).\nhave{esS} oZS: #|'Z(S)| = p := card_center_extraspecial pS esS.\nhave nSR: R \\subset 'N(S) by rewrite -commg_subl (subset_trans sSR_S') ?der_sub.\nhave nsCR: 'C_R(S) <| R by rewrite (normalGI nSR) ?cent_normal.\nhave nCS: S \\subset 'N('C_R(S)) by rewrite cents_norm // centsC subsetIr.\nrewrite cprodE ?subsetIr //= -{2}(quotientGK nsCR) normC -?quotientK //.\ncongr (_ @*^-1 _); apply/eqP; rewrite eqEcard quotientS //=.\nrewrite -(card_isog (second_isog nCS)) setIAC (setIidPr sSR) /= -/'Z(S) -defPhi.\nrewrite -ker_conj_aut (card_isog (first_isog_loc _ nSR)) //=; set A := _ @* R.\nhave{pS} abelSb := Phi_quotient_abelem pS; have [pSb cSSb _] := and3P abelSb.\nhave [/= Xb defSb oXb] := grank_witness (S / 'Phi(S)).\npose X := (repr \\o val : coset_of _ -> gT) @: Xb.\nhave sXS: X \\subset S; last have nPX := subset_trans sXS nPS.\n  apply/subsetP=> x; case/imsetP=> xb Xxb ->; have nPx := repr_coset_norm xb.\n  rewrite -sub1set -(quotientSGK _ sPS) ?sub1set ?quotient_set1 //= sub1set.\n  by rewrite coset_reprK -defSb mem_gen.\nhave defS: <<X>> = S.\n  apply: Phi_nongen; apply/eqP; rewrite eqEsubset join_subG sPS sXS -joing_idr.\n  rewrite -genM_join sub_gen // -quotientSK ?quotient_gen // -defSb genS //.\n  apply/subsetP=> xb Xxb; apply/imsetP; rewrite (setIidPr nPX).\n  by exists (repr xb); rewrite /= ?coset_reprK //; apply: imset_f.\npose f (a : {perm gT}) := [ffun x => if x \\in X then x^-1 * a x else 1].\nhave injf: {in A &, injective f}.\n  move=> _ _ /morphimP[y nSy Ry ->] /morphimP[z nSz Rz ->].\n  move/ffunP=> eq_fyz; apply: (@eq_Aut _ S); rewrite ?Aut_aut //= => x Sx.\n  rewrite !norm_conj_autE //; apply: canRL (conjgKV z) _; rewrite -conjgM.\n  rewrite /conjg -(centP _ x Sx) ?mulKg {x Sx}// -defS cent_gen -sub_cent1.\n  apply/subsetP=> x Xx; have Sx := subsetP sXS x Xx.\n  move/(_ x): eq_fyz; rewrite !ffunE Xx !norm_conj_autE // => /mulgI xy_xz.\n  by rewrite cent1C inE conjg_set1 conjgM xy_xz conjgK.\nhave sfA_XS': f @: A \\subset pffun_on 1 X S^`(1).\n  apply/subsetP=> _ /imsetP[_ /morphimP[y nSy Ry ->] ->].\n  apply/pffun_onP; split=> [|_ /imageP[x /= Xx ->]].\n    by apply/subsetP=> x; apply: contraNT => /[!ffunE]/negPf->.\n  have Sx := subsetP sXS x Xx.\n  by rewrite ffunE Xx norm_conj_autE // (subsetP sSR_S') ?mem_commg.\nrewrite -(card_in_imset injf) (leq_trans (subset_leq_card sfA_XS')) // defS'.\nrewrite card_pffun_on (card_pgroup pSb) -rank_abelem -?grank_abelian // -oXb.\nby rewrite -oZS ?leq_pexp2l ?cardG_gt0 ?leq_imset_card.\nQed."
}
{
  "statement": "Lemma schmidt_subproof m n (A : 'M[C]_(m, n)) : (m <= n)%N ->\n  exists2 B : 'M_(m, n), B \\is unitarymx & [forall i : 'I_m,\n   (row i A <= (\\sum_(k < m | (k <= i)%N) <<row k B>>))%MS\n   && ('[row i A, row i B] >= 0) ].\n",
  "proof": "Proof.\nelim: m A => [|m IHm].\n  exists (pid_mx n); first by rewrite qualifE !thinmx0.\n  by apply/forallP=> -[].\nrewrite -addn1 => A leq_Sm_n.\nhave lemSm : (m <= m + 1)%N by rewrite addn1.\nhave ltmSm : (m < m + 1)%N by rewrite addn1.\nhave lemn : (m <= n)%N by rewrite ltnW // -addn1.\nhave [B Bortho] := IHm (usubmx A) lemn.\nmove=> /forallP /= subAB.\nhave [v /and4P [vBn v_neq0 dAv_ge0 dAsub]] :\n  exists v, [&& B '_|_ v, v != 0, '[dsubmx A, v] >= 0 & (dsubmx A <= B + v)%MS].\n  have := add_proj_ortho B (dsubmx A).\n  set BoSn := (_ *m proj_ortho _^!%MS) => pBE.\n  have [BoSn_eq0|BoSn_neq0] := eqVneq BoSn 0.\n    rewrite BoSn_eq0 addr0 in pBE.\n    have /rowV0Pn [v vBn v_neq0] : B^!%MS != 0.\n      rewrite -mxrank_eq0 rank_ortho -lt0n subn_gt0.\n      by rewrite mxrank_unitary // -addn1.\n    rewrite orthomx_sym in vBn.\n    exists v; rewrite vBn v_neq0 -pBE.\n      rewrite ['[_, _]](hermmx_eq0P _ _) ?lexx //=.\n      rewrite (submx_trans (proj_ortho_sub _ _)) //.\n      by rewrite -{1}[B]addr0 addmx_sub_adds ?sub0mx.\n    by rewrite (submx_trans _ vBn) // proj_ortho_sub.\n  pose c := (sqrtC '[BoSn])^-1; have c_gt0 : c > 0.\n    by rewrite invr_gt0 sqrtC_gt0 lt_def ?dnorm_eq0 ?dnorm_ge0 BoSn_neq0.\n  exists BoSn; apply/and4P; split => //.\n  - by rewrite orthomx_sym ?proj_ortho_sub // /gtr_eqF.\n  - rewrite -pBE linearDl //.\n    rewrite [X in X + '[_]](hermmx_eq0P _ _) ?add0r ?dnorm_ge0 //.\n    by rewrite orthomx_proj_mx_ortho // orthomx_sym.\n  - by rewrite -pBE addmx_sub_adds // proj_ortho_sub.\nwlog nv_eq1 : v vBn v_neq0 dAv_ge0 dAsub / '[v] = 1.\n  pose c := (sqrtC '[v])^-1.\n  have c_gt0 : c > 0 by rewrite invr_gt0 sqrtC_gt0 ?dnorm_gt0.\n  have [c_ge0 c_eq0F] := (ltW c_gt0, gt_eqF c_gt0).\n  move=> /(_ (c *: v)); apply.\n  - by rewrite orthomxZ ?c_eq0F.\n  - by rewrite scaler_eq0 c_eq0F.\n  - by rewrite linearZr mulr_ge0 // conjC_ge0.\n  - by rewrite (submx_trans dAsub) // addsmxS // eqmx_scale // c_eq0F.\n  - rewrite dnormZ normfV ger0_norm ?sqrtC_ge0 ?dnorm_ge0 //.\n    by rewrite exprVn rootCK ?mulVf // dnorm_eq0.\nexists (col_mx B v).\n  apply/row_unitarymxP => i j.\n  case: (split_ordP i) (split_ordP j) => [] i' -> [] j' ->;\n    rewrite eq_shift ?(rowKu, rowKd, row_id, ord1) -?val_eqE /=\n            ?(row_unitarymxP _) //= ?addn0.\n    by rewrite ['[_, _]](hermmx_eq0P _ _)//= (submx_trans _ vBn)// row_sub.\n  rewrite ['[_, _]](hermmx_eq0P _ _)//= orthomx_sym (submx_trans _ vBn) //.\n  exact: row_sub.\napply/forallP => i; case: (split_ordP i) => j -> /=.\n  have /andP [sABj dot_gt0] := subAB j.\n  rewrite rowKu -row_usubmx (submx_trans sABj) //=.\n  rewrite (eq_rect _ (submx _) (submx_refl _)) //.\n  rewrite [in RHS](reindex (lshift 1)) /=.\n    by apply: eq_bigr=> k k_le; rewrite rowKu.\n  exists (fun k => insubd j k) => k; rewrite inE /= => le_kj;\n  by apply/val_inj; rewrite /= insubdK // -topredE /= (leq_ltn_trans le_kj).\nrewrite rowKd -row_dsubmx !row_id ord1 ?dAv_ge0 ?andbT {j} addn0.\nrewrite (bigD1 (rshift _ ord0)) /= ?addn0 ?rowKd ?row_id // addsmxC.\nrewrite (submx_trans dAsub) // addsmxS ?genmxE //.\napply/row_subP => j; apply/(sumsmx_sup (lshift _ j)) => //=.\n  by rewrite ltnW ?ltn_ord //= -val_eqE /= addn0 ltn_eqF.\nby rewrite rowKu genmxE.\nQed."
}
{
  "statement": "Lemma repr_rsim_diag (G : {group gT}) f (rG : mx_representation algC G f) x :\n    x \\in G -> let chi := cfRepr rG in\n  exists e,\n [/\\  exists2 B, B \\in unitmx & rG x = invmx B *m diag_mx e *m B,\n      (forall i, e 0 i ^+ #[x] = 1) /\\ (forall i, `|e 0 i| = 1),\n      chi x = \\sum_i e 0 i /\\ `|chi x| <= chi 1%g\n   &  chi x^-1%g = (chi x)^*].\n",
  "proof": "Proof.\nmove=> Gx; without loss cGG: G rG Gx / abelian G.\n  have sXG: <[x]> \\subset G by rewrite cycle_subG.\n  move/(_ _ (subg_repr rG sXG) (cycle_id x) (cycle_abelian x)).\n  by rewrite /= !cfunE !groupV Gx (cycle_id x) !group1.\nhave [I U W simU W1 dxW]: mxsemisimple rG 1%:M.\n  rewrite -(reducible_Socle1 (DecSocleType rG)\n    (mx_Maschke_pchar _ (algC'G_pchar G))).\n  exact: Socle_semisimple.\nhave linU i: \\rank (U i) = 1.\n  by apply: mxsimple_abelian_linear cGG (simU i); apply: groupC.\nhave castI: f = #|I|.\n  by rewrite -(mxrank1 algC f) -W1 (eqnP dxW) /= -sum1_card; apply/eq_bigr.\npose B := \\matrix_j nz_row (U (enum_val (cast_ord castI j))).\nhave rowU i: (nz_row (U i) :=: U i)%MS.\n  apply/eqmxP; rewrite -(geq_leqif (mxrank_leqif_eq (nz_row_sub _))) linU.\n  by rewrite lt0n mxrank_eq0 (nz_row_mxsimple (simU i)).\nhave unitB: B \\in unitmx.\n  rewrite -row_full_unit -sub1mx -W1; apply/sumsmx_subP=> i _.\n  pose j := cast_ord (esym castI) (enum_rank i).\n  by rewrite (submx_trans _ (row_sub j B)) // rowK cast_ordKV enum_rankK rowU.\npose e := \\row_j row j (B *m rG x *m invmx B) 0 j.\nhave rGx: rG x = invmx B *m diag_mx e *m B.\n  rewrite -mulmxA; apply: canRL (mulKmx unitB) _.\n  apply/row_matrixP=> j; rewrite 2!row_mul; set u := row j B.\n  have /sub_rVP[a def_ux]: (u *m rG x <= u)%MS.\n    rewrite /u rowK rowU (eqmxMr _ (rowU _)).\n    exact: (mxmoduleP (mxsimple_module (simU _))).\n  rewrite def_ux [u]rowE scalemxAl; congr (_ *m _).\n  apply/rowP=> k; rewrite 5!mxE !row_mul def_ux [u]rowE scalemxAl mulmxK //.\n  by rewrite !mxE !eqxx !mulr_natr eq_sym.\nhave exp_e j: e 0 j ^+ #[x] = 1.\n  suffices: (diag_mx e j j) ^+ #[x] = (B *m rG (x ^+ #[x])%g *m invmx B) j j.\n    by rewrite expg_order repr_mx1 mulmx1 mulmxV // [e]lock !mxE eqxx.\n  elim: #[x] => [|n IHn]; first by rewrite repr_mx1 mulmx1 mulmxV // !mxE eqxx.\n  rewrite expgS repr_mxM ?groupX // {1}rGx -!mulmxA mulKVmx //.\n  by rewrite mul_diag_mx mulmxA [M in _ = M]mxE -IHn exprS {1}mxE eqxx.\nhave norm1_e j: `|e 0 j| = 1.\n  by apply/eqP; rewrite -(@pexpr_eq1 _ _ #[x]) // -normrX exp_e normr1.\nexists e; split=> //; first by exists B.\n  rewrite cfRepr1 !cfunE Gx rGx mxtrace_mulC mulKVmx // mxtrace_diag.\n  split=> //=; apply: (le_trans (ler_norm_sum _ _ _)).\n  by rewrite (eq_bigr _ (in1W norm1_e)) sumr_const card_ord lexx.\nrewrite !cfunE groupV !mulrb Gx rGx mxtrace_mulC mulKVmx //.\nrewrite -trace_map_mx map_diag_mx; set d' := diag_mx _.\nrewrite -[d'](mulKVmx unitB) mxtrace_mulC -[_ *m _](repr_mxK rG Gx) rGx.\nrewrite -!mulmxA mulKVmx // (mulmxA d').\nsuffices->: d' *m diag_mx e = 1%:M by rewrite mul1mx mulKmx.\nrewrite mulmx_diag -diag_const_mx; congr diag_mx; apply/rowP=> j.\nby rewrite [e]lock !mxE mulrC -normCK -lock norm1_e expr1n.\nQed."
}
{
  "statement": "Lemma leif_AGM_scaled (I : finType) (A : {pred I}) (E : I -> R) (n := #|A|) :\n    {in A, forall i, 0 <= E i *+ n} ->\n  \\prod_(i in A) (E i *+ n) <= (\\sum_(i in A) E i) ^+ n\n                            ?= iff [forall i in A, forall j in A, E i == E j].\n",
  "proof": "Proof.\nhave [m leAm] := ubnP #|A|; elim: m => // m IHm in A leAm E n * => Ege0.\napply/leifP; case: ifPn => [/forall_inP-Econstant | Enonconstant].\n  have [i /= Ai | A0] := pickP [in A]; last by rewrite [n]eq_card0 ?big_pred0.\n  have /eqfun_inP-E_i := Econstant i Ai; rewrite -(eq_bigr _ E_i) sumr_const.\n  by rewrite exprMn_n prodrMn_const -(eq_bigr _ E_i) prodr_const.\nset mu := \\sum_(i in A) E i; pose En i := E i *+ n.\npose cmp_mu s := [pred i | s * mu < s * En i].\nhave{Enonconstant} has_cmp_mu e (s := (-1) ^+ e): {i | i \\in A & cmp_mu s i}.\n  apply/sig2W/exists_inP; apply: contraR Enonconstant => /exists_inPn-mu_s_A.\n  have n_gt0 i: i \\in A -> (0 < n)%N by rewrite [n](cardD1 i) => ->.\n  have{} mu_s_A i: i \\in A -> s * En i <= s * mu.\n    move=> Ai; rewrite real_leNgt ?mu_s_A ?rpredMsign ?ger0_real ?Ege0 //.\n    by rewrite -(pmulrn_lge0 _ (n_gt0 i Ai)) -sumrMnl sumr_ge0.\n  have [_ /esym/eqfun_inP] := leif_sum (fun i Ai => leif_eq (mu_s_A i Ai)).\n  rewrite sumr_const -/n -mulr_sumr sumrMnl -/mu mulrnAr eqxx => A_mu.\n  apply/forall_inP=> i Ai; apply/eqfun_inP=> j Aj.\n  by apply: (pmulrnI (n_gt0 i Ai)); apply: (can_inj (signrMK e)); rewrite !A_mu.\nhave [[i Ai Ei_lt_mu] [j Aj Ej_gt_mu]] := (has_cmp_mu 1, has_cmp_mu 0)%N.\nrewrite {cmp_mu has_cmp_mu}/= !mul1r !mulN1r ltrN2 in Ei_lt_mu Ej_gt_mu.\npose A' := [predD1 A & i]; pose n' := #|A'|.\nhave [Dn n_gt0]: n = n'.+1 /\\ (n > 0)%N  by rewrite [n](cardD1 i) Ai.\nhave i'j: j != i by apply: contraTneq Ej_gt_mu => ->; rewrite lt_gtF.\nhave{i'j} A'j: j \\in A' by rewrite !inE Aj i'j.\nhave mu_gt0: 0 < mu := le_lt_trans (Ege0 i Ai) Ei_lt_mu.\nrewrite (bigD1 i) // big_andbC (bigD1 j) //= mulrA; set pi := \\prod_(k | _) _.\nhave [-> | nz_pi] := eqVneq pi 0; first by rewrite !mulr0 exprn_gt0.\nhave{nz_pi} pi_gt0: 0 < pi.\n  by rewrite lt_def nz_pi prodr_ge0 // => k /andP[/andP[_ /Ege0]].\nrewrite -/(En i) -/(En j); pose E' := [eta En with j |-> En i + En j - mu].\nhave E'ge0 k: k \\in A' -> E' k *+ n' >= 0.\n  case/andP=> /= _ Ak; apply: mulrn_wge0; case: ifP => _; last exact: Ege0.\n  by rewrite subr_ge0 ler_wpDl ?Ege0 // ltW.\nrewrite -/n Dn in leAm; have{leAm IHm E'ge0}: _ <= _ := IHm _ leAm _ E'ge0.\nhave ->: \\sum_(k in A') E' k = mu *+ n'.\n  apply: (addrI mu); rewrite -mulrS -Dn -sumrMnl (bigD1 i Ai) big_andbC /=.\n  rewrite !(bigD1 j A'j) /= addrCA eqxx !addrA subrK; congr (_ + _).\n  by apply: eq_bigr => k /andP[_ /negPf->].\nrewrite prodrMn_const exprMn_n -/n' ler_pMn2r ?expn_gt0; last by case: (n').\nhave ->: \\prod_(k in A') E' k = E' j * pi.\n  by rewrite (bigD1 j) //=; congr *%R; apply: eq_bigr => k /andP[_ /negPf->].\nrewrite -(ler_pM2l mu_gt0) -exprS -Dn mulrA; apply: lt_le_trans.\nrewrite ltr_pM2r //= eqxx -addrA mulrDr mulrC -ltrBlDl -mulrBl.\nby rewrite mulrC ltr_pM2r ?subr_gt0.\nQed."
}
{
  "statement": "Lemma eisenstein_crit (p : nat) (q : {poly int}) : prime p -> (size q != 1)%N ->\n  ~~ (p %| lead_coef q)%Z -> ~~ (p ^+ 2 %| q`_0)%Z ->\n  (forall i, (i < (size q).-1)%N -> p %| q`_i)%Z ->\n  irreducible_poly q.\n",
  "proof": "Proof.\nmove=> p_prime qN1 Ndvd_pql Ndvd_pq0 dvd_pq.\napply/irreducible_rat_int.\nhave qN0 : q != 0 by rewrite -lead_coef_eq0; apply: contraNneq Ndvd_pql => ->.\nsplit.\n  rewrite size_map_poly_id0 ?intr_eq0 ?lead_coef_eq0//.\n  by rewrite ltn_neqAle eq_sym qN1 size_poly_gt0.\nmove=> f' +/dvdpP_rat_int[f [d dN0 feq]]; rewrite {f'}feq size_scale// => fN1.\nmove=> /= [g q_eq]; rewrite q_eq (eqp_trans (eqp_scale _ _))//.\nhave fN0 : f != 0 by apply: contra_neq qN0; rewrite q_eq => ->; rewrite mul0r.\nhave gN0 : g != 0 by apply: contra_neq qN0; rewrite q_eq => ->; rewrite mulr0.\nrewrite size_map_poly_id0 ?intr_eq0 ?lead_coef_eq0// in fN1.\nhave [/eqP/size_poly1P[c cN0 ->]|gN1] := eqVneq (size g) 1%N.\n  by rewrite mulrC mul_polyC map_polyZ/= eqp_sym eqp_scale// intr_eq0.\nhave c_neq0 : (lead_coef q)%:~R != 0 :> 'F_p\n   by rewrite -(dvdz_pcharf (pchar_Fp _)).\nhave : map_poly (intr : int -> 'F_p) q = (lead_coef q)%:~R *: 'X^(size q).-1.\n  apply/val_inj/(@eq_from_nth _ 0) => [|i]; rewrite size_map_poly_id0//.\n    by rewrite size_scale// size_polyXn -polySpred.\n  move=> i_small; rewrite coef_poly i_small coefZ coefXn lead_coefE.\n  move: i_small; rewrite polySpred// ltnS/=.\n  case: ltngtP => // [i_lt|->]; rewrite (mulr1, mulr0)//= => _.\n  by apply/eqP; rewrite -(dvdz_pcharf (pchar_Fp _))// dvd_pq.\nrewrite [in LHS]q_eq rmorphM/=.\nset c := (X in X *: _); set n := (_.-1).\nset pf := map_poly _ f; set pg := map_poly _ g => pfMpg.\nhave dvdXn (r : {poly _}) : size r != 1%N -> r %| c *: 'X^n -> r`_0 = 0.\n  move=> rN1; rewrite (eqp_dvdr _ (eqp_scale _ _))//.\n  rewrite -['X]subr0; move=> /dvdp_exp_XsubCP[k lekn]; rewrite subr0.\n  move=> /eqpP[u /andP[u1N0 u2N0]]; have [->|k_gt0] := posnP k.\n    move=> /(congr1 (size \\o val))/eqP.\n    by rewrite /= !size_scale// size_polyXn (negPf rN1).\n  move=> /(congr1 (fun p : {poly _} => p`_0))/eqP.\n  by rewrite !coefZ coefXn ltn_eqF// mulr0 mulf_eq0 (negPf u1N0) => /eqP.\nsuff : ((p : int) ^+ 2 %| q`_0)%Z by rewrite (negPf Ndvd_pq0).\nhave := c_neq0; rewrite q_eq coefM big_ord1.\nrewrite lead_coefM rmorphM mulf_eq0 negb_or => /andP[lpfN0 qfN0].\nhave pfN1 : size pf != 1%N by rewrite size_map_poly_id0.\nhave pgN1 : size pg != 1%N by rewrite size_map_poly_id0.\nhave /(dvdXn _ pgN1) /eqP : pg %| c *: 'X^n by rewrite -pfMpg dvdp_mull.\nhave /(dvdXn _ pfN1) /eqP : pf %| c *: 'X^n by rewrite -pfMpg dvdp_mulr.\nby rewrite !coef_map// -!(dvdz_pcharf (pchar_Fp _))//; apply: dvdz_mul.\nQed."
}
{
  "statement": "Lemma cards_draws T (B : {set T}) k :\n  #|[set A : {set T} | A \\subset B & #|A| == k]| = 'C(#|B|, k).\n",
  "proof": "Proof.\nhave [ltTk | lekT] := ltnP #|B| k.\n  rewrite bin_small // eq_card0 // => A.\n  rewrite inE eqn_leq [k <= _]leqNgt.\n  have [AsubB /=|//] := boolP (A \\subset B).\n  by rewrite (leq_ltn_trans (subset_leq_card AsubB)) ?andbF.\napply/eqP; rewrite -(eqn_pmul2r (fact_gt0 k)) bin_ffact // eq_sym.\nrewrite -sum_nat_cond_const -{1 3}(card_ord k).\nrewrite -card_inj_ffuns_on -sum1dep_card.\npose imIk (f : {ffun 'I_k -> T}) := f @: 'I_k.\nrewrite (partition_big imIk (fun A => (A \\subset B) && (#|A| == k))) /=\n  => [|f]; last first.\n  move=> /andP [/ffun_onP f_ffun /injectiveP inj_f].\n  rewrite card_imset ?card_ord // eqxx andbT.\n  by apply/subsetP => x /imsetP [i _ ->]; rewrite f_ffun.\napply/eqP; apply: eq_bigr => A /andP [AsubB /eqP cardAk].\nhave [f0 inj_f0 im_f0]: exists2 f, injective f & f @: 'I_k = A.\n  rewrite -cardAk; exists enum_val; first exact: enum_val_inj.\n  apply/setP=> a; apply/imsetP/idP=> [[i _ ->] | Aa]; first exact: enum_valP.\n  by exists (enum_rank_in Aa a); rewrite ?enum_rankK_in.\nrewrite (reindex (fun p : {ffun _} => [ffun i => f0 (p i)])) /=; last first.\n  pose ff0' f i := odflt i [pick j | f i == f0 j].\n  exists (fun f => [ffun i => ff0' f i]) => [p _ | f].\n    apply/ffunP=> i; rewrite ffunE /ff0'; case: pickP => [j | /(_ (p i))].\n      by rewrite ffunE (inj_eq inj_f0) => /eqP.\n    by rewrite ffunE eqxx.\n  rewrite -im_f0 => /andP[/andP[/ffun_onP f_ffun /injectiveP injf] /eqP im_f].\n  apply/ffunP=> i; rewrite !ffunE /ff0'; case: pickP => [y /eqP //|].\n  have /imsetP[j _ eq_f0j_fi]: f i \\in f0 @: 'I_k by rewrite -im_f imset_f.\n  by move/(_ j)/eqP.\nrewrite -ffactnn -card_inj_ffuns -sum1dep_card; apply: eq_bigl => p.\nrewrite -andbA.\napply/and3P/injectiveP=> [[_ /injectiveP inj_f0p _] i j eq_pij | inj_p].\n  by apply: inj_f0p; rewrite !ffunE eq_pij.\nset f := finfun _.\nhave injf: injective f by move=> i j /[!ffunE] /inj_f0; apply: inj_p.\nhave imIkf : imIk f == A.\n  rewrite eqEcard card_imset // cardAk card_ord leqnn andbT -im_f0.\n  by apply/subsetP=> x /imsetP[i _ ->]; rewrite ffunE imset_f.\nsplit; [|exact/injectiveP|exact: imIkf].\nby apply/ffun_onP => x; apply: (subsetP AsubB); rewrite -(eqP imIkf) imset_f.\nQed."
}
{
  "statement": "Lemma card_family (F : forall x, pred (rT x)) :\n  #|(family F : simpl_pred fT)| = foldr muln 1 [seq #|F x| | x : aT].\n",
  "proof": "Proof.\nrewrite /image_mem; set E := enum aT in (uniqE := enum_uniq aT) *.\nhave trivF x: x \\notin E -> #|F x| = 1 by rewrite mem_enum.\nelim: E uniqE => /= [_ | x0 E IH_E /andP[E'x0 uniqE]] in F trivF *.\n  have /fin_all_exists[f0 Ff0] x: exists y0, F x =i pred1 y0.\n    have /pred0Pn[y Fy]: #|F x| != 0 by rewrite trivF.\n    by exists y; apply/fsym/subset_cardP; rewrite ?subset_pred1 // card1 trivF.\n  apply: eq_card1 (finfun f0 : fT) _ _ => f; apply/familyP/eqP=> [Ff | {f}-> x].\n    by apply/ffunP=> x; have /[!(Ff0, ffunE)]/eqP := Ff x.\n  by rewrite ffunE Ff0 inE /=.\nhave [y0 Fxy0 | Fx00] := pickP (F x0); last first.\n  by rewrite !eq_card0 // => f; apply: contraFF (Fx00 (f x0))=> /familyP; apply.\npose F1 x := if eqP is ReflectT Dx then xpred1 (ecast x (rT x) Dx y0) else F x.\ntransitivity (#|[predX F x0 & family F1 : pred fT]|); last first.\n  rewrite cardX {}IH_E {uniqE}// => [|x E'x]; last first.\n    rewrite /F1; case: eqP => [Dx | /nesym/eqP-x0'x]; first exact: card1.\n    by rewrite trivF // negb_or x0'x.\n  congr (_ * foldr _ _ _); apply/eq_in_map=> x Ex.\n  by rewrite /F1; case: eqP => // Dx0; rewrite Dx0 Ex in E'x0.\npose g yf : fT := let: (y, f) := yf : rT x0 * fT in\n  [ffun x => if eqP is ReflectT Dx then ecast x (rT x) Dx y else f x].\nhave gK: cancel (fun f : fT => (f x0, g (y0, f))) g.\n  by move=> f; apply/ffunP=> x; rewrite !ffunE; case: eqP => //; case: x /.\nrewrite -(card_image (can_inj gK)); apply: eq_card => [] [y f] /=.\napply/imageP/andP=> [[f1 /familyP/=Ff1] [-> ->]| [/=Fx0y /familyP/=Ff]].\n  split=> //; apply/familyP=> x; rewrite ffunE /F1 /=.\n  by case: eqP => // Dx; apply: eqxx.\nexists (g (y, f)).\n  by apply/familyP=> x; have:= Ff x; rewrite ffunE /F1; case: eqP; [case: x /|].\ncongr (_, _); first by rewrite /= ffunE; case: eqP => // Dx; rewrite eq_axiomK.\nby apply/ffunP=> x; have:= Ff x; rewrite !ffunE /F1; case: eqP => // Dx /eqP.\nQed."
}
{
  "statement": "Lemma asimpleI (N1 N2 : {group rT}) :\n    N2 \\subset 'N(N1) -> N1 \\subset D ->\n    [acts A, on N1 | to] -> [acts A, on N2 | to] ->\n    asimple (to / N1) (N2 / N1) ->\n  asimple (to / (N2 :&: N1)) (N2 / (N2 :&: N1)).\n",
  "proof": "Proof.\nmove=> nN21 sN1D aN1 aN2 /asimpleP[ntQ1 max1].\nhave [f1 [f1e f1ker f1pre f1im]] := restrmP (coset_morphism N1) nN21.\nhave hf2' : N2 \\subset 'N(N2 :&: N1) by apply: normsI => //; rewrite normG.\nhave hf2'' : 'ker (coset (N2 :&: N1)) \\subset 'ker f1.\n  by rewrite f1ker !ker_coset.\npose f2 := factm_morphism  hf2'' hf2'.\napply/asimpleP; split.\n   rewrite /= setIC; apply/negP; move: (second_isog nN21); move/isog_eq1->.\n   by apply/negP.\nmove=> H nHQ2 aH; pose K := f2 @* H.\nhave nKQ1 : K <| N2 / N1.\n  rewrite (_ : N2 / N1 = f2 @* (N2 / (N2 :&: N1))) ?morphim_normal //.\n  by rewrite morphim_factm f1im.\nhave sqA : qact_dom to N1 \\subset A.\n  by apply/subsetP=> t; rewrite qact_domE // inE; case/andP.\nhave nNN2 : (N2 :&: N1) <| N2.\n  by rewrite /normal subsetIl; apply: normsI => //; apply: normG.\nhave aKQ1 : [acts qact_dom to N1, on K | to / N1].\n  pose H':= coset (N2 :&: N1)@*^-1 H.\n  have eHH' : H :=: H' / (N2 :&: N1) by rewrite cosetpreK.\n  have -> : K :=: f1 @* H' by rewrite /K eHH' morphim_factm.\n  have sH'N2 : H' \\subset N2.\n    rewrite /H' eHH' quotientGK ?normal_cosetpre //=.\n    by rewrite sub_cosetpre_quo ?normal_sub.\n  have -> : f1 @* H' = coset N1 @* H' by rewrite f1im //=.\n  apply: qacts_coset => //; apply: qacts_cosetpre => //; last exact: gactsI.\n  by apply: (subset_trans (subsetIr _ _)).\nhave injf2 : 'injm f2.\n  by rewrite ker_factm f1ker /= ker_coset /= subG1 /= -quotientE trivg_quotient.\nhave iHK : H \\isog K.\n  apply/isogP; pose f3 := restrm_morphism (normal_sub nHQ2) f2.\n  by exists f3; rewrite 1?injm_restrm // morphim_restrm setIid.\ncase: (max1 _ nKQ1 aKQ1).\n  by move/eqP; rewrite -(isog_eq1 iHK); move/eqP->; left.\nmove=> he /=; right; apply/eqP; rewrite eqEcard normal_sub //=.\nmove: (second_isog nN21); rewrite setIC; move/card_isog->; rewrite -he.\nby move/card_isog: iHK=> <-; rewrite leqnn.\nQed."
}
{
  "statement": "Lemma gdcop_recP q p k : size p <= k -> gdcop_spec q p (gdcop_rec q p k).\n",
  "proof": "Proof.\nelim: k p => [p | k ihk p] /=.\n  move/size_poly_leq0P->.\n  have [->|q0] := eqVneq; split; rewrite ?coprime1p // ?eqxx ?orbT //.\n  by move=> d _; rewrite coprimep0 dvdp1 size_poly_eq1.\nmove=> hs; case cop : (coprimep _ _); first by split; rewrite ?dvdpp ?cop.\nhave [-> | p0] := eqVneq p 0.\n  by rewrite div0p; apply: ihk; rewrite size_poly0 leq0n.\nhave [-> | q0] := eqVneq q 0.\n  rewrite gcdp0 divpp ?p0 //= => {hs ihk}; case: k=> /=.\n    rewrite eqxx; split; rewrite ?dvd1p ?coprimep0 ?eqpxx //=.\n    by move=> d _; rewrite coprimep0 dvdp1 size_poly_eq1.\n  move=> n; rewrite coprimep0 polyC_eqp1 //; rewrite lc_expn_scalp_neq0.\n  split; first by rewrite (@eqp_dvdl 1) ?dvd1p // polyC_eqp1 lc_expn_scalp_neq0.\n    by rewrite coprimep0 polyC_eqp1 // ?lc_expn_scalp_neq0.\n  by move=> d _; rewrite coprimep0; move/eqp_dvdl->; rewrite dvd1p.\nmove: (dvdp_gcdl p q); rewrite dvdp_eq; move/eqP=> e.\nhave sgp : size (gcdp p q) <= size p.\n  by apply: dvdp_leq; rewrite ?gcdp_eq0 ?p0 ?q0 // dvdp_gcdl.\nhave : p %/ gcdp p q != 0; last move/negPf=>p'n0.\n  apply: dvdpN0 (dvdp_mulIl (p %/ gcdp p q) (gcdp p q)) _.\n  by rewrite -e scale_poly_eq0 negb_or lc_expn_scalp_neq0.\nhave gn0 : gcdp p q != 0.\n  apply: dvdpN0 (dvdp_mulIr (p %/ gcdp p q) (gcdp p q)) _.\n  by rewrite -e scale_poly_eq0 negb_or lc_expn_scalp_neq0.\nhave sp' : size (p %/ (gcdp p q)) <= k.\n  rewrite size_divp ?sgp // leq_subLR (leq_trans hs) // -add1n leq_add2r -subn1.\n  by rewrite ltn_subRL add1n ltn_neqAle eq_sym [_ == _]cop size_poly_gt0 gn0.\ncase (ihk _ sp')=> r' dr'p'; first rewrite p'n0 orbF=> cr'q maxr'.\nconstructor=> //=; rewrite ?(negPf p0) ?orbF //.\n  exact/(dvdp_trans dr'p')/divp_dvd/dvdp_gcdl.\nmove=> d dp cdq; apply: maxr'; last by rewrite cdq.\ncase dpq: (d %| gcdp p q).\n  move: (dpq); rewrite dvdp_gcd dp /= => dq; apply: dvdUp.\n  apply: contraLR cdq => nd1; apply/coprimepPn; last first.\n    by exists d; rewrite dvdp_gcd dvdpp dq nd1.\n  by apply: contraNneq p0 => d0; move: dp; rewrite d0 dvd0p.\napply: contraLR dp => ndp'.\nrewrite (@eqp_dvdr ((lead_coef (gcdp p q) ^+ scalp p (gcdp p q))*:p)).\n  by rewrite e; rewrite Gauss_dvdpl //; apply: (coprimep_dvdl (dvdp_gcdr _ _)).\nby rewrite eqp_sym eqp_scale // lc_expn_scalp_neq0.\nQed."
}
{
  "statement": "Theorem constt_Ind_mul_ext f (phi := 'chi_f) (psi := phi * theta) :\n  G \\subset 'I[phi] -> psi \\in irr N ->\n  let calS := irr_constt ('Ind phi) in\n  [/\\ {in calS, forall b, 'chi_b * chi \\in irr G},\n      {in calS &, injective mul_Iirr},\n      irr_constt ('Ind psi) =i [seq mul_Iirr b | b in calS]\n    & 'Ind psi = \\sum_(b in calS) '['Ind phi, 'chi_b] *: 'chi_(mul_Iirr b)].\n",
  "proof": "Proof.\nmove=> IGphi irr_psi calS.\nhave IGpsi: G \\subset 'I[psi].\n  by rewrite (subset_trans _ (inertia_mul _ _)) // subsetI IGphi.\npose e b := '['Ind[G] phi, 'chi_b]; pose d b g := '['chi_b * chi, 'chi_g * chi].\nhave Ne b: e b \\in Num.nat by rewrite Cnat_cfdot_char ?cfInd_char ?irr_char.\nhave egt0 b: b \\in calS -> e b > 0 by rewrite natr_gt0.\nhave DphiG: 'Ind phi = \\sum_(b in calS) e b *: 'chi_b := cfun_sum_constt _.\nhave DpsiG: 'Ind psi = \\sum_(b in calS) e b *: 'chi_b * chi.\n  by rewrite /psi -cNt cfIndM // DphiG mulr_suml.\npose d_delta := [forall b in calS, forall g in calS, d b g == (b == g)%:R].\nhave charMchi b: 'chi_b * chi \\is a character by rewrite rpredM ?irr_char.\nhave [_]: '['Ind[G] phi] <= '['Ind[G] psi] ?= iff d_delta.\n  pose sum_delta := \\sum_(b in calS) e b * \\sum_(g in calS) e g * (b == g)%:R.\n  pose sum_d := \\sum_(b in calS) e b * \\sum_(g in calS) e g * d b g.\n  have ->: '['Ind[G] phi] = sum_delta.\n    rewrite DphiG cfdot_suml; apply: eq_bigr => b _; rewrite cfdotZl cfdot_sumr.\n    by congr (_ * _); apply: eq_bigr => g; rewrite cfdotZr cfdot_irr conj_natr.\n  have ->: '['Ind[G] psi] = sum_d.\n    rewrite DpsiG cfdot_suml; apply: eq_bigr => b _.\n    rewrite -scalerAl cfdotZl cfdot_sumr; congr (_ * _).\n    by apply: eq_bigr => g _; rewrite -scalerAl cfdotZr conj_natr.\n  have eMmono := mono_leif (ler_pM2l (egt0 _ _)).\n  apply: leif_sum => b /eMmono->; apply: leif_sum => g /eMmono->.\n  split; last exact: eq_sym.\n  have /natrP[n Dd]: d b g \\in Num.nat by rewrite Cnat_cfdot_char.\n  have [Db | _] := eqP; rewrite Dd leC_nat // -ltC_nat -Dd Db cfnorm_gt0.\n  by rewrite -char1_eq0 // cfunE mulf_neq0 ?irr1_neq0.\nrewrite -!cfdot_Res_l ?cfRes_Ind_invariant // !cfdotZl cfnorm_irr irrWnorm //.\nrewrite eqxx => /esym/forall_inP/(_ _ _)/eqfun_inP; rewrite /d /= => Dd.\nhave irrMchi: {in calS, forall b, 'chi_b * chi \\in irr G}.\n  by move=> b Sb; rewrite /= irrEchar charMchi Dd ?eqxx.\nhave injMchi: {in calS &, injective mul_Iirr}.\n  move=> b g Sb Sg /(congr1 (fun s => '['chi_s, 'chi_(mul_Iirr g)]))/eqP.\n  by rewrite cfnorm_irr !cfIirrE ?irrMchi ?Dd // pnatr_eq1; case: (b =P g).\nhave{DpsiG} ->: 'Ind psi = \\sum_(b in calS) e b *: 'chi_(mul_Iirr b).\n  by rewrite DpsiG; apply: eq_bigr => b Sb; rewrite -scalerAl cfIirrE ?irrMchi.\nsplit=> // i; rewrite irr_consttE cfdot_suml;\napply/idP/idP=> [|/imageP[b Sb ->]].\n  apply: contraR => N'i; rewrite big1 // => b Sb.\n  rewrite cfdotZl cfdot_irr mulrb ifN_eqC ?mulr0 //.\n  by apply: contraNneq N'i => ->; apply: image_f.\nrewrite gt_eqF // (bigD1 b) //= cfdotZl cfnorm_irr mulr1 ltr_wpDr ?egt0 //.\napply: sumr_ge0 => g /andP[Sg _]; rewrite cfdotZl cfdot_irr.\nby rewrite mulr_ge0 ?ler0n ?natr_ge0.\nQed."
}
{
  "statement": "Lemma resultant_eq0 (R : idomainType) (p q : {poly R}) :\n  (resultant p q == 0) = (size (gcdp p q) > 1).\n",
  "proof": "Proof.\nhave dvdpp := dvdpp; set r := gcdp p q.\npose dp := (size p).-1; pose dq := (size q).-1.\nhave /andP[r_p r_q]: (r %| p) && (r %| q) by rewrite -dvdp_gcd.\napply/det0P/idP=> [[uv nz_uv] | r_nonC].\n  have [p0 _ | p_nz] := eqVneq p 0.\n    have: dq + dp > 0.\n      rewrite lt0n; apply: contraNneq nz_uv => dqp0.\n      by rewrite dqp0 in uv *; rewrite [uv]thinmx0.\n    by rewrite /dp /dq /r p0 size_poly0 addn0 gcd0p -subn1 subn_gt0.\n  do [rewrite -[uv]hsubmxK -{1}row_mx0 mul_row_col !mul_rV_lin1 /=] in nz_uv *.\n  set u := rVpoly _; set v := rVpoly _; pose m := gcdp (v * p) (v * q).\n  have lt_vp: size v < size p by rewrite (polySpred p_nz) ltnS size_poly.\n  move/(congr1 rVpoly)/eqP; rewrite -linearD linear0 poly_rV_K; last first.\n    rewrite (leq_trans (size_polyD _ _)) // geq_max.\n    rewrite !(leq_trans (size_polyMleq _ _)) // -subn1 leq_subLR.\n      by rewrite addnC addnA leq_add ?leqSpred ?size_poly.\n    by rewrite addnCA leq_add ?leqSpred ?size_poly.\n  rewrite addrC addr_eq0 => /eqP vq_up.\n  have nz_v: v != 0.\n    apply: contraNneq nz_uv => v0; apply/eqP.\n    congr row_mx; apply: (can_inj rVpolyK); rewrite linear0 // -/u.\n    by apply: contra_eq vq_up; rewrite v0 mul0r -addr_eq0 add0r => /mulf_neq0->.\n  have r_nz: r != 0 := dvdpN0 r_p p_nz.\n  have /dvdpP [[c w] /= nz_c wv]: v %| m by rewrite dvdp_gcd !dvdp_mulr.\n  have m_wd d: m %| v * d -> w %| d.\n    case/dvdpP=> [[k f]] /= nz_k /(congr1 ( *:%R c)).\n    rewrite mulrC scalerA scalerAl scalerAr wv mulrA => /(mulIf nz_v)def_fw.\n    by apply/dvdpP; exists (c * k, f); rewrite //= mulf_neq0.\n  have w_r: w %| r by rewrite dvdp_gcd !m_wd ?dvdp_gcdl ?dvdp_gcdr.\n  have w_nz: w != 0 := dvdpN0 w_r r_nz.\n  have p_m: p %| m  by rewrite dvdp_gcd vq_up -mulNr !dvdp_mull.\n  rewrite (leq_trans _ (dvdp_leq r_nz w_r)) // -(ltn_add2l (size v)).\n  rewrite addnC -ltn_subRL subn1 -size_mul // mulrC -wv size_scale //.\n  rewrite (leq_trans lt_vp) // dvdp_leq // -size_poly_eq0.\n  by rewrite -(size_scale _ nz_c) size_poly_eq0 wv mulf_neq0.\nhave [[c p'] /= nz_c p'r] := dvdpP _ _ r_p.\nhave [[k q'] /= nz_k q'r] := dvdpP _ _ r_q.\nhave def_r := subnKC r_nonC; have r_nz: r != 0 by rewrite -size_poly_eq0 -def_r.\nhave le_p'_dp: size p' <= dp.\n  have [-> | nz_p'] := eqVneq p' 0; first by rewrite size_poly0.\n  by rewrite /dp -(size_scale p nz_c) p'r size_mul // addnC -def_r leq_addl.\nhave le_q'_dq: size q' <= dq.\n  have [-> | nz_q'] := eqVneq q' 0; first by rewrite size_poly0.\n  by rewrite /dq -(size_scale q nz_k) q'r size_mul // addnC -def_r leq_addl.\nexists (row_mx (- c *: poly_rV q') (k *: poly_rV p')); last first.\n  rewrite mul_row_col scaleNr mulNmx !mul_rV_lin1 /= 2!linearZ /= !poly_rV_K //.\n  by rewrite !scalerCA p'r q'r mulrCA addNr.\napply: contraNneq r_nz; rewrite -row_mx0 => /eq_row_mx[/eqP].\nrewrite scaleNr oppr_eq0 gcdp_eq0 -!size_poly_eq0 => /eqP q0 p0.\nrewrite -(size_scale p nz_c) -(size_scale (c *: p) nz_k) p'r.\nrewrite -(size_scale q nz_k) -(size_scale (k *: q) nz_c) q'r !scalerAl.\nrewrite -(poly_rV_K le_p'_dp) -(poly_rV_K le_q'_dq).\nby rewrite -2![_ *: rVpoly _]linearZ p0 q0 !linear0 mul0r size_poly0.\nQed."
}
{
  "statement": "Lemma num_itv_mul_boundr b1 b2 (x1 x2 : R) :\n  (0 <= x1 -> 0 <= x2 ->\n   BRight x1 <= num_itv_bound R b1 ->\n   BRight x2 <= num_itv_bound R b2 ->\n   BRight (x1 * x2) <= num_itv_bound R (mul_boundr b1 b2))%O.\n",
  "proof": "Proof.\ncase: b1 b2 => [b1b b1 | []] [b2b b2 | []] //= x1p x2p; last first.\n- case: b2b b2 => -[[|//] | //] _ x20.\n  + have:= @ltxx _ (itv_bound R) (BLeft 0%:~R).\n    by rewrite (lt_le_trans _ x20).\n  + have -> : x2 = 0 by apply/le_anti/andP.\n    by rewrite mulr0.\n- case: b1b b1 => -[[|//] |//] x10 _.\n  + have:= @ltxx _ (itv_bound R) (BLeft 0%Z%:~R).\n    by rewrite (lt_le_trans _ x10).\n  + by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\ncase: b1b b2b => -[]; rewrite -[intRing.mulz]/GRing.mul.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have:= @ltxx _ R 0; rewrite (le_lt_trans x1p x1b).\n  + case: b2 x2b => [[| b2] | b2] => x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ R 0; rewrite (le_lt_trans x2p x2b).\n    * by rewrite intrM ltr_pM.\n    * have:= @ltxx _ R 0; rewrite (le_lt_trans x2p)//.\n      by rewrite (lt_le_trans x2b) ?lerz0.\n  + have:= @ltxx _ R 0; rewrite (le_lt_trans x1p)//.\n    by rewrite (lt_le_trans x1b) ?lerz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have:= @ltxx _ R 0; rewrite (le_lt_trans x1p x1b).\n  + case: b2 x2b => [[| b2] | b2] x2b; rewrite bnd_simp.\n    * exact: mulr_ge0_le0.\n    * by rewrite intrM (le_lt_trans (ler_wpM2l x1p x2b)) ?ltr_pM2r.\n    * have:= @ltxx _ _ x2.\n      by rewrite (le_lt_trans x2b) ?(lt_le_trans _ x2p) ?ltrz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (lt_le_trans x1b) ?(le_trans _ x1p) ?lerz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + case: b2 x2b => [[|b2] | b2] x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ _ x2; rewrite (lt_le_trans x2b).\n    * by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\n    * have:= @ltxx _ _ x2.\n      by rewrite (lt_le_trans x2b) ?(le_trans _ x2p) ?lerz0.\n  + case: b2 x2b => [[|b2] | b2] x2b; rewrite bnd_simp.\n    * by have:= @ltxx _ _ x2; rewrite (lt_le_trans x2b).\n    * by rewrite intrM (le_lt_trans (ler_wpM2r x2p x1b)) ?ltr_pM2l.\n    * have:= @ltxx _ _ x2.\n      by rewrite (lt_le_trans x2b) ?(le_trans _ x2p) ?lerz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (le_lt_trans x1b) ?(lt_le_trans _ x1p) ?ltrz0.\n- case: b1 => [[|b1] | b1]; rewrite !bnd_simp => x1b x2b.\n  + by have -> : x1 = 0; [apply/le_anti/andP | rewrite mul0r].\n  + case: b2 x2b => [[| b2] | b2] x2b; rewrite bnd_simp.\n    * by have -> : x2 = 0; [apply/le_anti/andP | rewrite mulr0].\n    * by rewrite intrM ler_pM.\n    * have:= @ltxx _ _ x2.\n      by rewrite (le_lt_trans x2b) ?(lt_le_trans _ x2p) ?ltrz0.\n  + have:= @ltxx _ _ x1.\n    by rewrite (le_lt_trans x1b) ?(lt_le_trans _ x1p) ?ltrz0.\nQed."
}
{
  "statement": "Lemma ext_coprime_quotient_cent (H : {group gT}) :\n    H \\subset G -> [acts A, on H | to] -> coprime #|H| #|A| -> solvable H ->\n 'C_(|to)(A) / H = 'C_(|to / H)(A).\n",
  "proof": "Proof.\nmove=> sHG nHA coHA solH; pose N := 'N_G(H).\nhave nsHN: H <| N by rewrite normal_subnorm.\nhave [sHN nHn] := andP nsHN.\nhave sNG: N \\subset G by apply: subsetIl.\nhave nNA: {acts A, on group N | to}.\n  split; rewrite // actsEsd // injm_subnorm ?injm_sdpair1 //=.\n  by rewrite normsI ?norms_norm ?im_sdpair_norm -?actsEsd.\nrewrite -!(gacentIdom _ A) -quotientInorm -gacentIim setIAC.\nrewrite -(gacent_actby nNA) gacentEsd -morphpreIim /= -/N.\nhave:= (injm_sdpair1 <[nNA]>, injm_sdpair2 <[nNA]>).\nset inG := sdpair1 _; set inA := sdpair2 _ => [[injG injA]].\nset G' := inG @* N; set A' := inA @* A; pose H' := inG @* H.\nhave defN: 'N(H | to) = A by apply/eqP; rewrite eqEsubset subsetIl.\nhave def_Dq: qact_dom to H = A by rewrite qact_domE.\nhave sAq: A \\subset qact_dom to H by rewrite def_Dq.\nrewrite {2}def_Dq -(gacent_ract _ sAq); set to_q := (_ \\ _)%gact.\nhave:= And3 (sdprod_sdpair to_q) (injm_sdpair1 to_q) (injm_sdpair2 to_q).\nrewrite gacentEsd; set inAq := sdpair2 _; set inGq := sdpair1 _ => /=.\nset Gq := inGq @* _; set Aq := inAq @* _ => [[q_d iGq iAq]].\nhave nH': 'N(H') = setT.\n  apply/eqP; rewrite -subTset -im_sdpair mulG_subG morphim_norms //=.\n  by rewrite -actsEsd // acts_actby subxx /= (setIidPr sHN).\nhave: 'dom (coset H' \\o inA \\o invm iAq) = Aq.\n  by rewrite ['dom _]morphpre_invm /= nH' morphpreT.\ncase/domP=> /= qA [def_qA ker_qA _ im_qA].\nhave{coHA} coHA': coprime #|H'| #|A'| by rewrite !card_injm.\nhave{ker_qA} injAq: 'injm qA.\n  rewrite {}ker_qA !ker_comp ker_coset morphpre_invm -morphpreIim /= setIC.\n  by rewrite coprime_TIg // -kerE (trivgP injA) morphim1.\nhave{im_qA} im_Aq : qA @* Aq = A' / H'.\n  by rewrite {}im_qA !morphim_comp im_invm.\nhave: 'dom (quotm (sdpair1_morphism <[nNA]>) nsHN \\o invm iGq) = Gq.\n  by rewrite ['dom _]morphpre_invm /= quotientInorm.\ncase/domP=> /= qG [def_qG ker_qG _ im_qG].\nhave{ker_qG} injGq: 'injm qG.\n  rewrite {}ker_qG ker_comp ker_quotm morphpre_invm (trivgP injG).\n  by rewrite quotient1 morphim1.\nhave im_Gq: qG @* Gq = G' / H'.\n  rewrite {}im_qG morphim_comp im_invm morphim_quotm //= -/inG -/H'.\n  by rewrite -morphimIdom setIAC setIid.\nhave{def_qA def_qG} q_J : {in Gq & Aq, morph_act 'J 'J qG qA}.\n  move=> x' a'; case/morphimP=> Hx; case/morphimP=> x nHx Gx -> GHx ->{Hx x'}.\n  case/morphimP=> a _ Aa ->{a'} /=; rewrite -/inAq -/inGq.\n  rewrite !{}def_qG {}def_qA /= !invmE // -sdpair_act //= -/inG -/inA.\n  have Nx: x \\in N by rewrite inE Gx.\n  have Nxa: to x a \\in N by case: (nNA); move/acts_act->.\n  have [Gxa nHxa] := setIP Nxa.\n  rewrite invmE qactE ?quotmE ?mem_morphim ?def_Dq //=.\n  by rewrite -morphJ /= ?nH' ?inE // -sdpair_act //= actbyE.\npose q := sdprodm q_d q_J.\nhave{injAq injGq} injq: 'injm q.\n  rewrite injm_sdprodm injAq injGq /= {}im_Aq {}im_Gq -/Aq .\n  by rewrite -quotientGI ?im_sdpair_TI ?morphimS //= quotient1.\nrewrite -[inGq @*^-1 _]morphpreIim -/Gq.\nhave sC'G: inG @*^-1 'C_G'(A') \\subset G by rewrite !subIset ?subxx.\nrewrite -[_ / _](injmK iGq) ?quotientS //= -/inGq; congr (_ @*^-1 _).\napply: (injm_morphim_inj injq); rewrite 1?injm_subcent ?subsetT //= -/q.\nrewrite 2?morphim_sdprodml ?morphimS //= im_Gq.\nrewrite morphim_sdprodmr ?morphimS //= im_Aq.\nrewrite {}im_qG morphim_comp morphim_invm ?morphimS //.\nrewrite morphim_quotm morphpreK ?subsetIl //= -/H'.\nrewrite coprime_norm_quotient_cent ?im_sdpair_norm ?nH' ?subsetT //=.\nexact: morphim_sol.\nQed."
}
{
  "statement": "Lemma num_spec_mul (xi yi : Itv.t) (x : num_def R xi) (y : num_def R yi)\n    (r := Itv.real2 mul xi yi) :\n  num_spec r (x%:num * y%:num).\n",
  "proof": "Proof.\nrewrite {}/r; case: xi yi x y => [//| [xl xu]] [//| [yl yu]].\ncase=> [x /=/and3P[xr /= xlx xxu]] [y /=/and3P[yr /= yly yyu]].\nrewrite -/(sign (Interval xl xu)) -/(sign (Interval yl yu)).\nhave ns000 : @Itv.num_sem R `[0, 0] 0 by apply/and3P.\nhave xyr : x * y \\in Num.real by exact: realM.\ncase: (signP xlx xxu xr) => xlb xub xs.\n- by rewrite xs mul0r; case: (signP yly yyu yr).\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=.\n    * exact: num_itv_mul_boundl xlx yly.\n    * exact: num_itv_mul_boundr xxu yyu.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK -mulrN.\n    * by rewrite opp_boundl num_itv_mul_boundr ?oppr_ge0// opp_boundr.\n    * by rewrite opp_boundr num_itv_mul_boundl ?opp_boundl// opp_bound_ge0.\n  + apply/and3P; split=> //=.\n    * rewrite  -[x * y]opprK -mulrN opp_boundl.\n      by rewrite BRight_le_mul_boundr ?realN ?opp_boundr// opp_bound_gt0 ltW.\n    * by rewrite BRight_le_mul_boundr// ltW.\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK -mulNr.\n    * rewrite opp_boundl.\n      by rewrite num_itv_mul_boundr ?oppr_ge0 ?opp_boundr.\n    * by rewrite opp_boundr num_itv_mul_boundl ?opp_boundl// opp_bound_ge0.\n  + apply/and3P; split=> //=; rewrite -mulrNN.\n    * by rewrite num_itv_mul_boundl ?opp_bound_ge0 ?opp_boundl.\n    * by rewrite num_itv_mul_boundr ?oppr_ge0 ?opp_boundr.\n  + apply/and3P; split=> //=; rewrite -[x * y]opprK.\n    * rewrite -mulNr opp_boundl BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr//.\n      exact: ltW.\n    * rewrite opprK -mulrNN.\n      by rewrite BRight_le_mul_boundr ?opp_boundr\n              ?oppr_ge0 ?realN ?opp_bound_gt0// ltW.\n- case: (signP yly yyu yr) => ylb yub ys.\n  + by rewrite ys mulr0.\n  + apply/and3P; split=> //=; rewrite mulrC mul_boundrC.\n    * rewrite -[y * x]opprK -mulrN opp_boundl.\n      rewrite BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n      by rewrite opp_bound_gt0 ltW.\n    * by rewrite BRight_le_mul_boundr// ltW.\n  + apply/and3P; split=> //=; rewrite mulrC mul_boundrC.\n    * rewrite -[y * x]opprK -mulNr opp_boundl.\n      by rewrite BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr// ltW.\n    * rewrite -mulrNN BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n      by rewrite opp_bound_gt0 ltW.\napply/and3P; rewrite xyr/= num_itv_bound_min num_itv_bound_max.\nrewrite (comparable_ge_min _ (comparable_num_itv_bound _ _)).\nrewrite (comparable_le_max _ (comparable_num_itv_bound _ _)).\ncase: (comparable_leP xr) => [x0 | /ltW x0]; split=> //.\n- apply/orP; right; rewrite -[x * y]opprK -mulrN opp_boundl.\n  by rewrite BRight_le_mul_boundr ?realN ?opp_boundr// opp_bound_gt0 ltW.\n- by apply/orP; right; rewrite BRight_le_mul_boundr// ltW.\n- apply/orP; left; rewrite -[x * y]opprK -mulNr opp_boundl.\n  by rewrite BRight_le_mul_boundr ?oppr_ge0 ?opp_boundr// ltW.\n- apply/orP; left; rewrite -mulrNN.\n  rewrite BRight_le_mul_boundr ?oppr_ge0 ?realN ?opp_boundr//.\n  by rewrite opp_bound_gt0 ltW.\nQed."
}
{
  "statement": "Lemma Ohm1_stab_Ohm1_SCN_series :\n  odd p -> p.-group G -> 'Ohm_1('C_G(Z)) \\subset 'C_G(A / Z | 'Q).\n",
  "proof": "Proof.\nhave [-> | ntG] := eqsVneq G 1; first by rewrite !(setIidPl (sub1G _)) Ohm1.\nmove=> p_odd pG; have{ntG} [p_pr _ _] := pgroup_pdiv pG ntG.\ncase/SCN_P: SCN_A => /andP[sAG nAG] _; have pA := pgroupS sAG pG.\nhave pCGZ : p.-group 'C_G(Z) by rewrite (pgroupS _ pG) // subsetIl.\nrewrite {pCGZ}(OhmE 1 pCGZ) gen_subG; apply/subsetP=> x; rewrite 3!inE -andbA.\nrewrite -!cycle_subG => /and3P[sXG cZX xp1] /=; have cXX := cycle_abelian x.\nhave nZX := cents_norm cZX; have{nAG} nAX := subset_trans sXG nAG.\npose XA := <[x]> <*> A; pose C := 'C(<[x]> / Z | 'Q); pose CA := A :&: C.\npose Y := <[x]> <*> CA; pose W := 'Ohm_1(Y).\nhave sXC: <[x]> \\subset C by rewrite sub_astabQ nZX (quotient_cents _ cXX).\nhave defY : Y = <[x]> * CA by rewrite -norm_joinEl // normsI ?nAX ?normsG.\nhave{nAX} defXA: XA = <[x]> * A := norm_joinEl nAX.\nsuffices{sXC}: XA \\subset Y.\n  rewrite subsetI sXG /= sub_astabQ nZX centsC defY group_modl //= -/Z -/C.\n  by rewrite subsetI sub_astabQ defXA quotientMl //= !mulG_subG; case/and4P.\nhave sZCA: Z \\subset CA by rewrite subsetI sZA [C]astabQ sub_cosetpre.\nhave cZCA: CA \\subset 'C(Z) by rewrite subIset 1?(sub_abelian_cent2 cAA).\nhave sZY: Z \\subset Y by rewrite (subset_trans sZCA) ?joing_subr.\nhave{cZCA cZX} cZY: Y \\subset 'C(Z) by rewrite join_subG cZX.\nhave{cXX nZX} sY'Z : Y^`(1) \\subset Z.\n  rewrite der1_min ?cents_norm //= -/Y defY quotientMl // abelianM /= -/Z -/CA.\n  rewrite !quotient_abelian // ?(abelianS _ cAA) ?subsetIl //=.\n  by rewrite /= quotientGI ?Ohm_sub // quotient_astabQ subsetIr.\nhave{sY'Z cZY} nil_classY: nil_class Y <= 2.\n  by rewrite nil_class2 (subset_trans sY'Z ) // subsetI sZY centsC.\nhave pY: p.-group Y by rewrite (pgroupS _ pG) // join_subG sXG subIset ?sAG.\nhave sXW: <[x]> \\subset W.\n  by rewrite [W](OhmE 1 pY) ?genS // sub1set !inE -cycle_subG joing_subl.\nhave{nil_classY pY sXW sZY sZCA} defW: W = <[x]> * Z.\n  rewrite -[W](setIidPr (Ohm_sub _ _)) /= -/Y {1}defY -group_modl //= -/Y -/W.\n  congr (_ * _); apply/eqP; rewrite eqEsubset {1}[Z](OhmE 1 pA).\n  rewrite subsetI setIAC subIset //; first by rewrite sZCA -[Z]Ohm_id OhmS.\n  rewrite sub_gen ?setIS //; apply/subsetP=> w Ww; rewrite inE.\n  by apply/eqP; apply: exponentP w Ww; apply: exponent_Ohm1_class2.\nhave{sXG sAG} sXAG: XA \\subset G by rewrite join_subG sXG.\nhave{sXAG} nilXA: nilpotent XA := nilpotentS sXAG (pgroup_nil pG).\nhave sYXA: Y \\subset XA by rewrite defY defXA mulgS ?subsetIl.\nrewrite -[Y](nilpotent_sub_norm nilXA) {nilXA sYXA}//= -/Y -/XA.\nsuffices: 'N_XA('Ohm_1(Y)) \\subset Y by apply/subset_trans/setIS/gFnorms.\nrewrite {XA}defXA -group_modl ?normsG /= -/W ?{W}defW ?mulG_subl //.\nrewrite {Y}defY mulgS // subsetI subsetIl {CA C}sub_astabQ subIset ?nZA //= -/Z.\nrewrite (subset_trans (quotient_subnorm _ _ _)) //= quotientMidr /= -/Z.\nrewrite -quotient_sub1 ?subIset ?cent_norm ?orbT //.\nrewrite (subset_trans (quotientI _ _ _)) ?coprime_TIg //.\nrewrite (@pnat_coprime p) // -/(p.-group _) ?quotient_pgroup {pA}//= -pgroupE.\nrewrite -(setIidPr (cent_sub _)) p'group_quotient_cent_prime //.\nby rewrite (dvdn_trans (dvdn_quotient _ _)) ?order_dvdn.\nQed."
}
{
  "statement": "Lemma Aint_subring_exists (X : seq algC) :\n    {subset X <= Aint} ->\n  {S : pred algC &\n      subring_closed S\n  /\\  {subset X <= S}\n   &  {Y : {n : nat & n.-tuple algC} &\n                {subset tagged Y <= S}\n              & forall x, reflect (inIntSpan (tagged Y) x) (x \\in S)}}.\n",
  "proof": "Proof.\nmove=> AZ_X; pose m := (size X).+1.\npose n (i : 'I_m) := (size (minCpoly X`_i)).-2; pose N := (\\max_i n i).+1.\npose IY := family (fun i => [pred e : 'I_N | e <= n i]%N).\nhave IY_0: 0 \\in IY by apply/familyP=> // i; rewrite ffunE.\npose inIY := enum_rank_in IY_0.\npose Y := [seq \\prod_(i < m) X`_i ^+ (f : 'I_N ^ m) i | f in IY].\nhave S_P := Cint_spanP [tuple of Y]; set S := Cint_span _ in S_P.\nhave sYS: {subset Y <= S} by apply: mem_Cint_span.\nhave S_1: 1 \\in S.\n  by apply/sYS/imageP; exists 0 => //; rewrite big1 // => i; rewrite ffunE.\nhave SmulX (i : 'I_m): {in S, forall x, x * X`_i \\in S}.\n  move=> _ /S_P[x ->]; rewrite mulr_suml rpred_sum // => j _.\n  rewrite mulrzAl rpredMz {x}// nth_image mulrC (bigD1 i) //= mulrA -exprS.\n  move: {j}(enum_val j) (familyP (enum_valP j)) => f fP.\n  have:= fP i; rewrite inE /= leq_eqVlt => /predU1P[-> | fi_ltn]; last first.\n    apply/sYS/imageP; have fiK: (inord (f i).+1 : 'I_N) = (f i).+1 :> nat.\n      by rewrite inordK // ltnS (bigmax_sup i).\n    exists (finfun [eta f with i |-> inord (f i).+1]).\n      apply/familyP=> i1; rewrite inE ffunE /= fun_if fiK.\n      by case: eqP => [-> // | _]; apply: fP.\n    rewrite (bigD1 i isT) ffunE /= eqxx fiK; congr (_ * _).\n    by apply: eq_bigr => i1 /[!ffunE]/= /negPf->.\n  have [/monicP ] := (minCpoly_monic X`_i, root_minCpoly X`_i).\n  rewrite /root horner_coef lead_coefE -(subnKC (size_minCpoly _)) subn2.\n  rewrite big_ord_recr /= addrC addr_eq0 => ->; rewrite mul1r => /eqP->.\n  have /floorpP[p Dp]: X`_i \\in Aint.\n    by have [/(nth_default 0)-> | /(mem_nth 0)/AZ_X] := leqP (size X) i.\n  rewrite -/(n i) Dp mulNr rpredN // mulr_suml rpred_sum // => [[e le_e]] /= _.\n  rewrite coef_map -mulrA mulrzl rpredMz ?sYS //; apply/imageP.\n  have eK: (inord e : 'I_N) = e :> nat by rewrite inordK // ltnS (bigmax_sup i).\n  exists (finfun [eta f with i |-> inord e]).\n    apply/familyP=> i1; rewrite inE ffunE /= fun_if eK.\n    by case: eqP => [-> // | _]; apply: fP.\n  rewrite (bigD1 i isT) ffunE /= eqxx eK; congr (_ * _).\n  by apply: eq_bigr => i1 /[!ffunE] /= /negPf->.\nexists S; last by exists (Tagged (fun n => n.-tuple _) [tuple of Y]).\nsplit=> [|x Xx]; last first.\n  by rewrite -[x]mul1r -(nth_index 0 Xx) (SmulX (Ordinal _)) // ltnS index_size.\nsplit=> // x y Sx Sy; first by rewrite rpredB.\ncase/S_P: Sy => {y}[y ->]; rewrite mulr_sumr rpred_sum //= => j.\nrewrite mulrzAr rpredMz {y}// nth_image; move: {j}(enum_val j) => f.\nelim/big_rec: _ => [|i y _ IHy] in x Sx *; first by rewrite mulr1.\nrewrite mulrA {y}IHy //.\nelim: {f}(f i : nat) => [|e IHe] in x Sx *; first by rewrite mulr1.\nby rewrite exprS mulrA IHe // SmulX.\nQed."
}
{
  "statement": "Lemma abelian_splits x G :\n  x \\in G -> #[x] = exponent G -> abelian G -> [splits G, over <[x]>].\n",
  "proof": "Proof.\nmove=> Gx ox cGG; apply/splitsP; have [n] := ubnP #|G|.\nelim: n gT => // n IHn aT in x G Gx ox cGG * => /ltnSE-leGn.\nhave: <[x]> \\subset G by [rewrite cycle_subG]; rewrite subEproper.\ncase/predU1P=> [<- | /properP[sxG [y]]].\n  by exists 1%G; rewrite inE -subG1 subsetIr mulg1 /=.\nhave [m] := ubnP #[y]; elim: m y => // m IHm y /ltnSE-leym Gy x'y.\ncase: (trivgVpdiv <[y]>) => [y1 | [p p_pr p_dv_y]].\n  by rewrite -cycle_subG y1 sub1G in x'y.\ncase x_yp: (y ^+ p \\in <[x]>); last first.\n  apply: IHm (negbT x_yp); rewrite ?groupX ?(leq_trans _ leym) //.\n  by rewrite orderXdiv // ltn_Pdiv ?prime_gt1.\nhave{x_yp} xp_yp: (y ^+ p \\in <[x ^+ p]>).\n  have: <[y ^+ p]>%G \\in [set <[x ^+ (#[x] %/ #[y ^+ p])]>%G].\n    by rewrite -cycle_sub_group ?order_dvdG // inE cycle_subG x_yp eqxx.\n  rewrite inE -cycle_subG -val_eqE /=; move/eqP->.\n  rewrite cycle_subG orderXdiv // divnA // mulnC ox.\n  by rewrite -muln_divA ?dvdn_exponent ?expgM 1?groupX ?cycle_id.\nhave: p <= #[y] by rewrite dvdn_leq.\nrewrite leq_eqVlt => /predU1P[{xp_yp m IHm leym}oy | ltpy]; last first.\n  case/cycleP: xp_yp => k; rewrite -expgM mulnC expgM => def_yp.\n  suffices: #[y * x ^- k] < m.\n    by move/IHm; apply; rewrite groupMr // groupV groupX ?cycle_id.\n  apply: leq_ltn_trans (leq_trans ltpy leym).\n  rewrite dvdn_leq ?prime_gt0 // order_dvdn expgMn.\n    by rewrite expgVn def_yp mulgV.\n  by apply: (centsP cGG); rewrite ?groupV ?groupX.\npose Y := <[y]>; have nsYG: Y <| G by rewrite -sub_abelian_normal ?cycle_subG.\nhave [sYG nYG] := andP nsYG; have nYx := subsetP nYG x Gx.\nhave GxY: coset Y x \\in G / Y by rewrite mem_morphim.\nhave tiYx: Y :&: <[x]> = 1 by rewrite prime_TIg ?indexg1 -?[#|_|]oy ?cycle_subG.\nhave: #[coset Y x] = exponent (G / Y).\n  apply/eqP; rewrite eqn_dvd dvdn_exponent //.\n  apply/exponentP=> _ /morphimP[z Nz Gz ->].\n  rewrite -morphX // ((z ^+ _ =P 1) _) ?morph1 //.\n  rewrite orderE -quotient_cycle ?card_quotient ?cycle_subG // -indexgI /=.\n  by rewrite setIC tiYx indexg1 -orderE ox -order_dvdn dvdn_exponent.\ncase/IHn => // [||Hq]; first exact: quotient_abelian.\n  apply: leq_trans leGn; rewrite ltn_quotient // cycle_eq1.\n  by apply: contra x'y; move/eqP->; rewrite group1.\ncase/complP=> /= ti_x_Hq defGq.\nhave: Hq \\subset G / Y by rewrite -defGq mulG_subr.\ncase/inv_quotientS=> // H defHq sYH sHG; exists H.\nhave nYX: <[x]> \\subset 'N(Y) by rewrite cycle_subG.\nrewrite inE -subG1 eqEsubset mul_subG //= -tiYx subsetI subsetIl andbT.\nrewrite -{2}(mulSGid sYH) mulgA (normC nYX) -mulgA -quotientSK ?quotientMl //.\nrewrite -quotient_sub1 ?(subset_trans (subsetIl _ _)) // quotientIG //= -/Y.\nby rewrite -defHq quotient_cycle // ti_x_Hq defGq !subxx.\nQed."
}
{
  "statement": "Theorem abelian_charsimple_special :\n    p.-group G -> coprime #|G| #|A| -> [~: G, A] = G ->\n    \\bigcup_(H : {group gT} | (H \\char G) && abelian H) H \\subset 'C(A) ->\n  special G /\\ 'C_G(A) = 'Z(G).\n",
  "proof": "Proof.\nmove=> pG coGA defG /bigcupsP cChaA.\nhave cZA: 'Z(G) \\subset 'C_G(A).\n  by rewrite subsetI center_sub cChaA // center_char center_abelian.\nhave cChaG (H : {group gT}): H \\char G -> abelian H -> H \\subset 'Z(G).\n  move=> chH abH; rewrite subsetI char_sub //= centsC -defG.\n  rewrite comm_norm_cent_cent ?(char_norm chH) -?commg_subl ?defG //.\n  by rewrite centsC cChaA ?chH.\nhave cZ2GG: [~: 'Z_2(G), G, G] = 1.\n  by apply/commG1P; rewrite (subset_trans (ucn_comm 1 G)) // ucn1 subsetIr.\nhave{cZ2GG} cG'Z: 'Z_2(G) \\subset 'C(G^`(1)).\n  by rewrite centsC; apply/commG1P; rewrite three_subgroup // (commGC G).\nhave{cG'Z} sZ2G'_Z: 'Z_2(G) :&: G^`(1) \\subset 'Z(G).\n  apply: cChaG; first by rewrite charI ?ucn_char ?der_char.\n  by rewrite /abelian subIset // (subset_trans cG'Z) // centS ?subsetIr.\nhave{sZ2G'_Z} sG'Z: G^`(1) \\subset 'Z(G).\n  rewrite der1_min ?gFnorm //; apply/derG1P.\n  have /TI_center_nil: nilpotent (G / 'Z(G)) := quotient_nil _ (pgroup_nil pG).\n  apply; first exact: gFnormal; rewrite /= setIC -ucn1 -ucn_central.\n  rewrite -quotient_der ?gFnorm // -quotientGI ?ucn_subS ?quotientS1 //=.\n  by rewrite ucn1.\nhave sCG': 'C_G(A) \\subset G^`(1).\n  rewrite -quotient_sub1 //; last by rewrite subIset ?gFnorm.\n  rewrite (subset_trans (quotient_subcent _ G A)) //= -[G in G / _]defG.\n  have nGA: A \\subset 'N(G) by rewrite -commg_subl defG.\n  rewrite quotientR ?gFnorm_trans ?normG //.\n  rewrite coprime_abel_cent_TI ?quotient_norms ?coprime_morph //.\n  exact: sub_der1_abelian.\nhave defZ: 'Z(G) = G^`(1) by apply/eqP; rewrite eqEsubset (subset_trans cZA).\nsplit; last by apply/eqP; rewrite eqEsubset cZA defZ sCG'.\nsplit=> //; apply/eqP; rewrite eqEsubset defZ (Phi_joing pG) joing_subl.\nhave:= pG; rewrite -pnat_exponent => /p_natP[n expGpn].\nrewrite join_subG subxx andbT /= -defZ -(subnn n.-1).\nelim: {2}n.-1 => [|m IHm].\n  rewrite (MhoE _ pG) gen_subG; apply/subsetP=> _ /imsetP[x Gx ->].\n  rewrite subn0 -subn1 -add1n -maxnE maxnC maxnE expnD.\n  by rewrite expgM -expGpn expg_exponent ?groupX ?group1.\nrewrite cChaG ?Mho_char //= (MhoE _ pG) /abelian cent_gen gen_subG.\napply/centsP=> _ /imsetP[x Gx ->] _ /imsetP[y Gy ->].\nmove: sG'Z; rewrite subsetI centsC => /andP[_ /centsP cGG'].\napply/commgP; rewrite {1}expnSr expgM.\nrewrite commXg -?commgX; try by apply: cGG'; rewrite ?mem_commg ?groupX.\napply/commgP; rewrite subsetI Mho_sub centsC in IHm.\napply: (centsP IHm); first by rewrite groupX.\nrewrite -add1n -(addn1 m) subnDA -maxnE maxnC maxnE.\nrewrite -expgM -expnSr -addSn expnD expgM groupX //=.\nby rewrite Mho_p_elt ?(mem_p_elt pG).\nQed."
}
{
  "statement": "Lemma SchurZassenhaus_trans_actsol gT (G A B : {group gT}) :\n    solvable A -> A \\subset 'N(G) -> B \\subset A <*> G ->\n    coprime #|G| #|A| -> #|A| = #|B| ->\n  exists2 x, x \\in G & B :=: A :^ x.\n",
  "proof": "Proof.\nset AG := A <*> G; have [n] := ubnP #|AG|.\nelim: n => // n IHn in gT A B G AG * => /ltnSE-leAn solA nGA sB_AG coGA oAB.\nhave [A1 | ntA] := eqsVneq A 1.\n  by exists 1; rewrite // conjsg1 A1 (@card1_trivg _ B) // -oAB A1 cards1.\nhave [M [sMA nsMA ntM]] := solvable_norm_abelem solA (normal_refl A) ntA.\ncase/is_abelemP=> q q_pr /abelem_pgroup qM; have nMA := normal_norm nsMA.\nhave defAG: AG = A * G := norm_joinEl nGA.\nhave sA_AG: A \\subset AG := joing_subl _ _.\nhave sG_AG: G \\subset AG := joing_subr _ _.\nhave sM_AG := subset_trans sMA sA_AG.\nhave oAG: #|AG| = (#|A| * #|G|)%N by rewrite defAG coprime_cardMg 1?coprime_sym.\nhave q'G: #|G|`_q = 1%N.\n  rewrite part_p'nat ?p'natE -?prime_coprime // coprime_sym.\n  have [_ _ [k oM]] := pgroup_pdiv qM ntM.\n  by rewrite -(@coprime_pexpr k.+1) // -oM (coprimegS sMA).\nhave coBG: coprime #|B| #|G| by rewrite -oAB coprime_sym.\nhave defBG: B * G = AG.\n  by apply/eqP; rewrite eqEcard mul_subG ?sG_AG //= oAG oAB coprime_cardMg.\ncase nMG: (G \\subset 'N(M)).\n  have nsM_AG: M <| AG by rewrite /normal sM_AG join_subG nMA.\n  have nMB: B \\subset 'N(M) := subset_trans sB_AG (normal_norm nsM_AG).\n  have sMB: M \\subset B.\n    have [Q sylQ]:= Sylow_exists q B; have sQB := pHall_sub sylQ.\n    apply: subset_trans (normal_sub_max_pgroup (Hall_max _) qM nsM_AG) (sQB).\n    rewrite pHallE (subset_trans sQB) //= oAG partnM // q'G muln1 oAB.\n    by rewrite (card_Hall sylQ).\n  have defAGq: AG / M = (A / M) <*> (G / M).\n    by rewrite quotient_gen ?quotientU ?subUset ?nMA.\n  have: B / M \\subset (A / M) <*> (G / M) by rewrite -defAGq quotientS.\n  case/IHn; rewrite ?morphim_sol ?quotient_norms ?coprime_morph //.\n  - by rewrite -defAGq (leq_trans _ leAn) ?ltn_quotient.\n  - by rewrite !card_quotient // -!divgS // oAB.\n  move=> Mx; case/morphimP=> x Nx Gx ->{Mx} //; rewrite -quotientJ //= => defBq.\n  exists x => //; apply: quotient_inj defBq; first by rewrite /normal sMB.\n  by rewrite -(normsP nMG x Gx) /normal normJ !conjSg.\npose K := M <*> G; pose R := K :&: B; pose N := 'N_G(M).\nhave defK: K = M * G by rewrite -norm_joinEl ?(subset_trans sMA).\nhave oK: #|K| = (#|M| * #|G|)%N.\n  by rewrite defK coprime_cardMg // coprime_sym (coprimegS sMA).\nhave sylM: q.-Sylow(K) M.\n  by rewrite pHallE joing_subl /= oK partnM // q'G muln1 part_pnat_id.\nhave sylR: q.-Sylow(K) R.\n  rewrite pHallE subsetIl /= -(card_Hall sylM) -(@eqn_pmul2r #|G|) // -oK.\n  rewrite -coprime_cardMg ?(coprimeSg _ coBG) ?subsetIr //=.\n  by rewrite group_modr ?joing_subr ?(setIidPl _) // defBG join_subG sM_AG.\nhave [mx] := Sylow_trans sylM sylR.\nrewrite /= -/K defK; case/imset2P=> m x Mm Gx ->{mx}.\nrewrite conjsgM conjGid {m Mm}// => defR.\nhave sNG: N \\subset G := subsetIl _ _.\nhave pNG: N \\proper G by rewrite /proper sNG subsetI subxx nMG.\nhave nNA: A \\subset 'N(N) by rewrite normsI ?norms_norm.\nhave: B :^ x^-1 \\subset A <*> N.\n  rewrite norm_joinEl ?group_modl // -defAG subsetI !sub_conjgV -normJ -defR.\n  rewrite conjGid ?(subsetP sG_AG) // normsI ?normsG // (subset_trans sB_AG) //.\n  by rewrite join_subG normsM // -defK normsG ?joing_subr.\ndo [case/IHn; rewrite ?cardJg ?(coprimeSg _ coGA) //= -/N] => [|y Ny defB].\n  rewrite joingC norm_joinEr // coprime_cardMg ?(coprimeSg sNG) //.\n  by rewrite (leq_trans _ leAn) // oAG mulnC ltn_pmul2l // proper_card.\nexists (y * x); first by rewrite groupM // (subsetP sNG).\nby rewrite conjsgM -defB conjsgKV.\nQed."
}
{
  "statement": "Lemma cotrigonalization n (As : seq 'M[C]_n) :\n  {in As &, forall A B, comm_mx A B} ->\n  cotrigonalizable_in (@unitarymx C n n) As.\n",
  "proof": "Proof.\nelim: n {-2}n (leqnn n) As => [|N IHN] n.\n  rewrite leqn0 => /eqP n_eq0.\n  exists 1%:M; first by rewrite qualifE mul1mx trmx1 map_mx1.\n  apply/allP => ? ?; apply/is_trig_mxP => i j.\n  by suff: False by []; move: i; rewrite n_eq0 => -[].\nrewrite leq_eqVlt => /predU1P [n_eqSN|/IHN//].\nhave /andP [n_gt0 n_small] : (n > 0)%N && (n - 1 <= N)%N.\n  by rewrite n_eqSN /= subn1.\nmove=> As As_comm;\nhave [v vN0 /allP /= vP] := common_eigenvector n_gt0 As_comm.\nsuff: exists2 P : 'M[C]_(\\rank v + \\rank v^!, n), P \\is unitarymx &\n  all (fun A => is_trig_mx (P *m A *m ( P^t* ))) As.\n  rewrite add_rank_ortho // => -[P P_unitary] /=; rewrite -invmx_unitary//.\n  by under eq_all do rewrite -conjumx ?unitarymx_unit//; exists P.\npose S := schmidt_complete v.\npose r A := S *m A *m S^t*.\nhave vSvo X : stablemx v X ->\n  schmidt (row_base v) *m X *m schmidt (row_base v^!%MS) ^t* = 0.\n  move=> /eigenvectorP [a v_in].\n  rewrite (eigenspaceP (_ : (_ <= _ a))%MS); last first.\n    by rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base.\n  rewrite -scalemxAl (orthomx1P _) ?scaler0 //.\n  by do 2!rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base // orthomx_sym.\nhave drrE X : drsubmx (r X) =\n  schmidt (row_base v^!%MS) *m X *m schmidt (row_base v^!%MS) ^t*.\n  by rewrite /r mul_col_mx tr_col_mx map_row_mx mul_col_row block_mxKdr.\nhave vSv X a : (v <= eigenspace X a)%MS ->\n  schmidt (row_base v) *m X *m schmidt (row_base v) ^t* = a%:M.\n  move=> vXa; rewrite (eigenspaceP (_ : (_ <= _ a)%MS)); last first.\n    by rewrite eqmx_schmidt_free ?row_base_free ?eq_row_base.\n  by rewrite -scalemxAl (unitarymxP _) ?scalemx1 ?schmidt_unitarymx ?rank_leq_col.\nhave [] := IHN _ _ [seq drsubmx (r A) | A <- As].\n- by rewrite rank_ortho rank_rV vN0.\n- move=> _ _ /mapP[/= A A_in ->] /mapP[/= B B_in ->].\n  have : (r A) *m (r B) = (r B) *m (r A).\n    rewrite /r !mulmxA !mulmxKtV // ?schmidt_complete_unitarymx //;\n    by rewrite ?add_rank_ortho // -![S *m _ *m _]mulmxA As_comm.\n  rewrite -[r A in X in X -> _]submxK -[r B  in X in X -> _]submxK.\n  rewrite 2!mulmx_block => /eq_block_mx [_ _ _].\n  suff urr_eq0 X : X \\in As -> ursubmx (r X) = 0.\n    by rewrite !urr_eq0 ?mulmx0 ?add0r.\n  rewrite /r /S ![schmidt_complete _ *m _]mul_col_mx.\n  rewrite !tr_col_mx !map_row_mx !mul_col_row !block_mxKur.\n  by move=> X_in; rewrite vSvo // vP.\nmove=> P' P'_unitary /allP /= P'P.\nexists ((block_mx 1%:M 0 0 P') *m S).\n  rewrite mul_unitarymx ?schmidt_complete_unitarymx //.\n  apply/unitarymxP; rewrite tr_block_mx map_block_mx mulmx_block.\n  rewrite !trmx0 !(@map_mx0 _ _ conjC) !tr_scalar_mx !map_scalar_mx ?conjC1.\n  rewrite !(mulmx1, mul1mx, mulmx0, mul0mx, addr0, add0r).\n  by rewrite (unitarymxP _) -?scalar_mx_block //.\napply/allP => /= A A_in.\nrewrite trmx_mul map_mxM tr_block_mx map_block_mx.\nrewrite !trmx0 !map_mx0 !tr_scalar_mx !map_scalar_mx ?conjC1.\nrewrite mulmxA -[_ *m S *m _]mulmxA -[_ *m _ *m S^t*]mulmxA.\nrewrite /S ![schmidt_complete _ *m _]mul_col_mx.\nrewrite !tr_col_mx !map_row_mx !mul_col_row !mulmx_block.\nrewrite !(mulmx1, mul1mx, mulmx0, mul0mx, addr0, add0r).\napply/is_trig_mxP => /= i j lt_ij; rewrite mxE.\ncase: splitP => //= i' i_eq; rewrite !mxE;\ncase: splitP => //= j' j_eq.\n- have /vP /eigenvectorP [a v_in] := A_in.\n  by rewrite (vSv _ _ v_in) mxE -val_eqE ltn_eqF //= -i_eq -j_eq.\n- by rewrite vSvo ?mul0mx ?mxE // vP //.\n- move: lt_ij; rewrite i_eq j_eq ltnNge -ltnS (leq_trans (ltn_ord j'))//.\n  by rewrite -addnS leq_addr.\n- set A' := _ *m A *m _; rewrite -invmx_unitary // -conjumx ?unitarymx_unit//.\n  have /(_ _) /is_trig_mxP -> // := P'P A'; last first.\n    by move: lt_ij; rewrite i_eq j_eq ltn_add2l.\n  by apply/mapP; exists A; rewrite //= drrE.\nQed."
}
{
  "statement": "Lemma gen_tperm_circular_shift (X : finType) x y c : prime #|X| ->\n  x != y -> #[c]%g = #|X| ->\n  <<[set tperm x y; c]>>%g = ('Sym_X)%g.\n",
  "proof": "Proof.\nmove=> Xprime neq_xy ord_c; apply/eqP; rewrite eqEsubset subsetT/=.\nhave c_gt1 : (1 < #[c]%g)%N by rewrite ord_c prime_gt1.\nhave cppSS : #[c]%g.-2.+2 = #|X| by rewrite ?prednK ?ltn_predRL.\npose f (i : 'Z_#[c]%g) : X := Zpm i x.\nhave [g fK gK] : bijective f.\n  apply: inj_card_bij; rewrite ?cppSS ?card_ord// /f /Zpm => i j cijx.\n  pose stabx := ('C_<[c]>[x | 'P])%g.\n  have cjix : (c ^+ (j - i)%R)%g x = x.\n    by apply: (@perm_inj _ (c ^+ i)%g); rewrite -permM -expgD_Zp// addrNK.\n  have : (c ^+ (j - i)%R)%g \\in stabx.\n    by rewrite !inE ?groupX ?mem_gen ?sub1set ?inE// ['P%act _ _]cjix eqxx.\n  rewrite [stabx]perm_prime_astab// => /set1gP.\n  move=> /(congr1 (mulg (c ^+ i))); rewrite -expgD_Zp// addrC addrNK mulg1.\n  by move=> /eqP; rewrite eq_expg_ord// ?cppSS ?ord_c// => /eqP->.\npose gsf s := g \\o s \\o f.\nhave gsf_inj (s : {perm X}) : injective (gsf s).\n  apply: inj_comp; last exact: can_inj fK.\n  by apply: inj_comp; [exact: can_inj gK|exact: perm_inj].\npose fsg s := f \\o s \\o g.\nhave fsg_inj (s : {perm _}) : injective (fsg s).\n  apply: inj_comp; last exact: can_inj gK.\n  by apply: inj_comp; [exact: can_inj fK|exact: perm_inj].\nhave gsf_morphic : morphic 'Sym_X (fun s => perm (gsf_inj s)).\n  apply/morphicP => u v _ _; apply/permP => /= i.\n  by rewrite !permE/= !permE /gsf /= gK permM.\npose phi := morphm gsf_morphic; rewrite /= in phi.\nhave phi_inj : ('injm phi)%g.\n  apply/subsetP => /= u /mker/=; rewrite morphmE => gsfu1.\n  apply/set1gP/permP=> z; have /permP/(_ (g z)) := gsfu1.\n  by rewrite !perm1 permE /gsf/= gK => /(can_inj gK).\nhave phiT : (phi @* 'Sym_X)%g = [set: {perm 'Z_#[c]%g}].\n  apply/eqP; rewrite eqEsubset subsetT/=; apply/subsetP => /= u _.\n  apply/morphimP; exists (perm (fsg_inj u)); rewrite ?in_setT//.\n  by apply/permP => /= i; rewrite morphmE permE /gsf/fsg/= permE/= !fK.\nhave f0 : f 0%R = x by rewrite /f /Zpm permX.\npose k := g y; have k_gt0 : (k > 0)%N.\n  by rewrite lt0n (val_eqE k 0%R) -(can_eq fK) eq_sym gK f0.\nhave phixy : phi (tperm x y) = tperm (0%R : 'Z_#[c]) k.\n  apply/permP => i; rewrite permE/= /gsf/=; apply: (canLR fK).\n  by rewrite !permE/= -f0 -[y]gK !(can_eq fK) -!fun_if.\nhave phic : phi c = perm (addrI (1%R : 'Z_#[c])).\n  apply/permP => i; rewrite /phi morphmE !permE /gsf/=; apply: (canLR fK).\n  by rewrite /f /Zpm -permM addrC expgD_Zp.\nrewrite -(injmSK phi_inj)//= morphim_gen/= ?subsetT//= -/phi.\nrewrite phiT /morphim !setTI/= -/phi imsetU1 imset_set1/= phixy phic.\nsuff /gen_tpermn_circular_shift<- : coprime #[c]%g.-2.+2 (k - 0)%R by [].\nby rewrite subr0 prime_coprime ?gtnNdvd// ?cppSS.\nQed."
}
{
  "statement": "Lemma irredp_FAdjoin (F : fieldType) (p : {poly F}) :\n    irreducible_poly p ->\n  {L : fieldExtType F & \\dim {:L} = (size p).-1 &\n    {z | root (map_poly (in_alg L) p) z & <<1; z>>%VS = fullv}}.\n",
  "proof": "Proof.\ncase=> p_gt1 irr_p; set n := (size p).-1; pose vL : vectType F := 'rV_n.\nhave Dn: n.+1 = size p := ltn_predK p_gt1.\nhave nz_p: p != 0 by rewrite -size_poly_eq0 -Dn.\nsuffices [L dimL [toPF [toL toPF_K toL_K]]]:\n   {L : fieldExtType F & \\dim {:L} = (size p).-1\n      & {toPF : {linear L -> {poly F}} & {toL : {lrmorphism {poly F} -> L} |\n         cancel toPF toL & forall q, toPF (toL q) = q %% p}}}.\n- exists L => //; pose z := toL 'X; set iota := in_alg _.\n  suffices q_z q: toPF (map_poly iota q).[z] = q %% p.\n    exists z; first by rewrite /root -(can_eq toPF_K) q_z modpp linear0.\n    apply/vspaceP=> x; rewrite memvf; apply/Fadjoin_polyP.\n    exists (map_poly iota (toPF x)).\n      by apply/polyOverP=> i; rewrite coef_map memvZ ?mem1v.\n    by apply: (can_inj toPF_K); rewrite q_z -toL_K toPF_K.\n  elim/poly_ind: q => [|a q IHq].\n    by rewrite map_poly0 horner0 linear0 mod0p.\n  rewrite rmorphD rmorphM /= map_polyX map_polyC hornerMXaddC linearD /=.\n  rewrite linearZ /= -(rmorph1 toL) toL_K -modpZl alg_polyC modpD.\n  congr (_ + _); rewrite -toL_K rmorphM -/z; congr (toPF (_ * z)).\n  by apply: (can_inj toPF_K); rewrite toL_K.\npose toL q : vL := poly_rV (q %% p); pose toPF (x : vL) := rVpoly x.\nhave toL_K q : toPF (toL q) = q %% p.\n  by rewrite /toPF poly_rV_K // -ltnS Dn ?ltn_modp -?Dn.\nhave toPF_K: cancel toPF toL.\n  by move=> x; rewrite /toL modp_small ?rVpolyK // -Dn ltnS size_poly.\nhave toPinj := can_inj toPF_K.\npose mul x y := toL (toPF x * toPF y); pose L1 := toL 1.\nhave L1K: toPF L1 = 1 by rewrite toL_K modp_small ?size_poly1.\nhave mulC: commutative mul by rewrite /mul => x y; rewrite mulrC.\nhave mulA: associative mul.\n  by move=> x y z; apply: toPinj; rewrite -!(mulC z) !toL_K !modp_mul mulrCA.\nhave mul1: left_id L1 mul.\n  by move=> x; apply: toPinj; rewrite mulC !toL_K modp_mul mulr1 -toL_K toPF_K.\nhave mulD: left_distributive mul +%R.\n  move=> x y z; apply: toPinj; rewrite /toPF raddfD /= -!/(toPF _).\n  by rewrite !toL_K /toPF raddfD mulrDl modpD.\nhave nzL1: L1 != 0 by rewrite -(inj_eq toPinj) L1K /toPF raddf0 oner_eq0.\npose mulM := GRing.Zmodule_isComNzRing.Build _ mulA mulC mul1 mulD nzL1.\npose rL : comNzRingType := HB.pack vL mulM.\nhave mulZlM : GRing.Lmodule_isLalgebra F rL.\n  constructor => a x y; apply: toPinj.\n  by rewrite toL_K /toPF !linearZ /= -!/(toPF _) toL_K -scalerAl modpZl.\npose laL : lalgType F := HB.pack rL mulZlM.\nhave mulZrM : GRing.Lalgebra_isAlgebra F laL.\n  by constructor => a x y; rewrite !(mulrC x) scalerAl.\npose aL : algType F := HB.pack laL mulZrM.\npose uLM := Algebra_isFalgebra.Build F aL.\npose cuL : comUnitRingType := HB.pack aL uLM.\nhave unitM : GRing.ComUnitRing_isField cuL.\n  constructor => x nz_x; apply/unitrP; set q := toPF x.\n  have nz_q: q != 0 by rewrite -(inj_eq toPinj) /toPF raddf0 in nz_x.\n  have /Bezout_eq1_coprimepP[u upq1]: coprimep p q.\n    apply: contraLR (leq_gcdpr p nz_q) => /irr_p/implyP.\n    rewrite dvdp_gcdl -ltnNge /= => /eqp_size->.\n    by rewrite (polySpred nz_p) ltnS size_poly.\n  suffices: x * toL u.2 = 1 by exists (toL u.2); rewrite mulrC.\n  apply: toPinj; rewrite !toL_K -upq1 modp_mul modpD mulrC.\n  by rewrite modp_mull add0r.\npose feL : fieldExtType F := HB.pack vL aL cuL unitM.\nexists feL; first by rewrite dimvf; apply: mul1n.\nexists toPF.\nhave tol_lin: linear toL by move=> a q1 q2; rewrite -linearP -modpZl -modpD.\nhave tol_mul : multiplicative (toL : {poly F} -> aL).\n  by split=> [q r|];\n    apply: toPinj; rewrite !toL_K // modp_mul -!(mulrC r) modp_mul.\npose toLlM := GRing.isLinear.Build _ _ _ _ toL tol_lin.\npose toLmM := GRing.isMultiplicative.Build _ _ _ tol_mul.\npose toLLRM : {lrmorphism _ -> feL} := HB.pack toL toLlM toLmM.\nby exists toLLRM.\nQed."
}
{
  "statement": "Lemma index_support_dvd_degree gT (G H : {group gT}) chi :\n    H \\subset G -> chi \\is a character -> chi \\in 'CF(G, H) ->\n    (H :==: 1%g) || abelian G ->\n  (#|G : H| %| chi 1%g)%C.\n",
  "proof": "Proof.\nmove=> sHG Nchi Hchi ZHG.\nsuffices: (#|G : H| %| 'Res[H] chi 1%g)%C by rewrite cfResE ?group1.\nrewrite ['Res _]cfun_sum_cfdot sum_cfunE rpred_sum // => i _.\nrewrite cfunE dvdC_mulr ?intr_nat ?Cnat_irr1 //.\nhave [j ->]: exists j, 'chi_i = 'Res 'chi[G]_j.\n  case/predU1P: ZHG => [-> | cGG] in i *.\n    suffices ->: i = 0 by exists 0; rewrite !irr0 cfRes_cfun1 ?sub1G.\n    apply/val_inj; case: i => [[|i] //=]; rewrite ltnNge NirrE.\n    by rewrite (@leq_trans 1) // leqNgt classes_gt1 eqxx.\n  have linG := char_abelianP G cGG; have linG1 j := eqP (proj2 (andP (linG j))).\n  have /fin_all_exists[rH DrH] j: exists k, 'Res[H, G] 'chi_j = 'chi_k.\n    apply/irrP/lin_char_irr/andP.\n    by rewrite cfRes_char ?irr_char // cfRes1 ?linG1.\n  suffices{i} all_rH: codom rH =i Iirr H.\n    by exists (iinv (all_rH i)); rewrite DrH f_iinv.\n  apply/subset_cardP; last exact/subsetP; apply/esym/eqP.\n  rewrite card_Iirr_abelian ?(abelianS sHG) //.\n  rewrite -(eqn_pmul2r (indexg_gt0 G H)) Lagrange //; apply/eqP.\n  rewrite -sum_nat_const -card_Iirr_abelian // -sum1_card.\n  rewrite (partition_big rH [in codom rH]) /=; last exact: image_f.\n  have nsHG: H <| G by rewrite -sub_abelian_normal.\n  apply: eq_bigr => _ /codomP[i ->]; rewrite -card_quotient ?normal_norm //.\n  rewrite -card_Iirr_abelian ?quotient_abelian //.\n  have Mlin j1 j2: exists k, 'chi_j1 * 'chi_j2 = 'chi[G]_k.\n    exact/irrP/lin_char_irr/rpredM.\n  have /fin_all_exists[rQ DrQ] (j : Iirr (G / H)) := Mlin i (mod_Iirr j).\n  have mulJi: ('chi[G]_i)^*%CF * 'chi_i = 1.\n    apply/cfun_inP=> x Gx; rewrite !cfunE /= -lin_charV_conj ?linG // cfun1E Gx.\n    by rewrite lin_charV ?mulVf ?lin_char_neq0 ?linG.\n  have inj_rQ: injective rQ.\n    move=> j1 j2 /(congr1 (fun k => (('chi_i)^*%CF * 'chi_k) / H)%CF).\n    by rewrite -!DrQ !mulrA mulJi !mul1r !mod_IirrE ?cfModK // => /irr_inj.\n  rewrite -(card_imset _ inj_rQ) -sum1_card; apply: eq_bigl => j.\n  rewrite -(inj_eq irr_inj) -!DrH; apply/eqP/imsetP=> [eq_ij | [k _ ->]].\n    have [k Dk] := Mlin (conjC_Iirr i) j; exists (quo_Iirr H k) => //.\n    apply/irr_inj; rewrite -DrQ quo_IirrK //.\n      by rewrite -Dk conjC_IirrE mulrCA mulrA mulJi mul1r.\n    apply/subsetP=> x Hx; have Gx := subsetP sHG x Hx.\n    rewrite cfkerEirr inE linG1 -Dk conjC_IirrE; apply/eqP.\n    transitivity ((1 : 'CF(G)) x); last by rewrite cfun1E Gx.\n    by rewrite -mulJi !cfunE -!(cfResE _ sHG Hx) eq_ij.\n  rewrite -DrQ; apply/cfun_inP=> x Hx; rewrite !cfResE // cfunE mulrC.\n  by rewrite cfker1 ?linG1 ?mul1r ?(subsetP _ x Hx) // mod_IirrE ?cfker_mod.\nhave: (#|G : H| %| #|G : H|%:R * '[chi, 'chi_j])%C.\n  by rewrite dvdC_mulr ?intr_nat ?Cnat_cfdot_char_irr.\ncongr (_ %| _)%C; rewrite (cfdotEl _ Hchi) -(Lagrange sHG) mulnC natrM.\nrewrite invfM -mulrA mulVKf ?neq0CiG //; congr (_ * _).\nby apply: eq_bigr => x Hx; rewrite !cfResE.\nQed."
}
{
  "statement": "Lemma JordanHolderUniqueness (G : gTg) (s1 s2 : seq gTg) :\n  comps G s1 -> comps G s2 -> perm_eq (mkfactors G s1) (mkfactors G s2).\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n G => // n Hi G in s1 s2 * => /ltnSE-cG cs1 cs2.\nhave [G1 | ntG] := boolP (G :==: 1).\n  have -> : s1 = [::] by apply/eqP; rewrite -(trivg_comps cs1).\n  have -> : s2 = [::] by apply/eqP; rewrite -(trivg_comps cs2).\n  by rewrite /= perm_refl.\nhave [sG | nsG] := boolP (simple G).\n  by rewrite (simple_compsP cs1 sG) (simple_compsP cs2 sG) perm_refl.\ncase es1: s1 cs1 => [|N1 st1] cs1.\n  by move: (trivg_comps cs1); rewrite eqxx; move/negP:ntG.\ncase es2: s2 cs2 => [|N2 st2] cs2 {s1 es1}.\n  by move: (trivg_comps cs2); rewrite eqxx; move/negP:ntG.\ncase/andP: cs1 => /= lst1; case/andP=> maxN_1 pst1.\ncase/andP: cs2 => /= lst2; case/andP=> maxN_2 pst2.\nhave cN1 : #|N1| < n.\n  by rewrite (leq_trans _ cG) ?proper_card ?(maxnormal_proper maxN_1).\nhave cN2 : #|N2| < n.\n  by rewrite (leq_trans _ cG) ?proper_card ?(maxnormal_proper maxN_2).\ncase: (N1 =P N2) {s2 es2} => [eN12 |].\n  by rewrite eN12 /= perm_cons Hi // /comps ?lst2 //= -eN12 lst1.\nmove/eqP; rewrite -val_eqE /=; move/eqP=> neN12.\nhave nN1G : N1 <| G by apply: maxnormal_normal.\nhave nN2G : N2 <| G by apply: maxnormal_normal.\npose N := (N1 :&: N2)%G.\nhave nNG : N <| G.\n  by rewrite /normal subIset ?(normal_sub nN1G) //= normsI ?normal_norm.\nhave iso1 : (G / N1)%G \\isog (N2 / N)%G.\n  rewrite isog_sym /= -(maxnormalM maxN_1 maxN_2) //.\n  rewrite (@normC _ N1 N2) ?(subset_trans (normal_sub nN1G)) ?normal_norm //.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN2G)) ?normal_norm.\nhave iso2 : (G / N2)%G \\isog (N1 / N)%G.\n  rewrite isog_sym /= -(maxnormalM maxN_1 maxN_2) // setIC.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN1G)) ?normal_norm.\nhave [sN /andP[lsN csN]] := exists_comps N.\nhave i1 : perm_eq (mksrepr G N1 :: mkfactors N1 st1)\n                  [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N1 [:: N & sN]).\n  apply: Hi=> //; rewrite /comps ?lst1 //= lsN csN andbT /=.\n  rewrite -quotient_simple.\n    by rewrite -(isog_simple iso2) quotient_simple.\n  by rewrite (normalS (subsetIl N1 N2) (normal_sub nN1G)).\nhave i2 : perm_eq (mksrepr G N2 :: mkfactors N2 st2)\n                  [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N2 [:: N & sN]).\n  apply: Hi=> //; rewrite /comps ?lst2 //= lsN csN andbT /=.\n  rewrite -quotient_simple.\n    by rewrite -(isog_simple iso1) quotient_simple.\n  by rewrite (normalS (subsetIr N1 N2) (normal_sub nN2G)).\npose fG1 := [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\npose fG2 := [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\nhave i3 : perm_eq fG1 fG2.\n  rewrite (@perm_catCA _ [::_] [::_]) /mksrepr.\n  rewrite (@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso1).\n  rewrite -(@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso2).\n  exact: perm_refl.\napply: (perm_trans i1); apply: (perm_trans i3); rewrite perm_sym.\nby apply: perm_trans i2; apply: perm_refl.\nQed."
}
{
  "statement": "Lemma countable_field_extension (F : countFieldType) (p : {poly F}) :\n    size p > 1 ->\n  {E : countFieldType & {FtoE : {rmorphism F -> E} &\n  {w : E | root (map_poly FtoE p) w\n         & forall u : E, exists q, u = (map_poly FtoE q).[w]}}}.\n",
  "proof": "Proof.\npose fix d i :=\n  if i is i1.+1 then\n    let d1 := oapp (gcdp (d i1)) 0 (unpickle i1) in\n    if size d1 > 1 then d1 else d i1\n  else p.\nmove=> p_gt1; have sz_d i: size (d i) > 1 by elim: i => //= i IHi; case: ifP.\nhave dv_d i j: i <= j -> d j %| d i.\n  move/subnK <-; elim: {j}(j - i)%N => //= j IHj; case: ifP => //=.\n  case: (unpickle _) => /= [q _|]; last by rewrite size_poly0.\n  exact: dvdp_trans (dvdp_gcdl _ _) IHj.\npose I : pred {poly F} := [pred q | d (pickle q).+1 %| q].\nhave I'co q i: q \\notin I -> i > pickle q -> coprimep q (d i).\n  rewrite inE => I'q /dv_d/coprimep_dvdl-> //; apply: contraR I'q.\n  rewrite coprimep_sym /coprimep /= pickleK /= neq_ltn.\n  case: ifP => [_ _| ->]; first exact: dvdp_gcdr.\n  rewrite orbF ltnS leqn0 size_poly_eq0 gcdp_eq0 -size_poly_eq0.\n  by rewrite -leqn0 leqNgt ltnW //.\nhave memI q: reflect (exists i, d i %| q) (q \\in I).\n  apply: (iffP idP) => [|[i dv_di_q]]; first by exists (pickle q).+1.\n  have [le_i_q | /I'co i_co_q] := leqP i (pickle q).\n    rewrite inE /= pickleK /=; case: ifP => _; first exact: dvdp_gcdr.\n    exact: dvdp_trans (dv_d _ _ le_i_q) dv_di_q.\n  apply: contraR i_co_q _.\n  by rewrite /coprimep (eqp_size (dvdp_gcd_idr dv_di_q)) neq_ltn sz_d orbT.\nhave I_ideal : idealr_closed I.\n  split=> [||a q1 q2 Iq1 Iq2]; first exact: dvdp0.\n    by apply/memI=> [[i /idPn[]]]; rewrite dvdp1 neq_ltn sz_d orbT.\n  apply/memI; exists (maxn (pickle q1).+1 (pickle q2).+1); apply: dvdp_add.\n    by apply: dvdp_mull; apply: dvdp_trans Iq1; apply/dv_d/leq_maxl.\n  by apply: dvdp_trans Iq2; apply/dv_d/leq_maxr.\npose IaM := GRing.isAddClosed.Build _ I (idealr_closedB I_ideal).\npose IoM := GRing.isOppClosed.Build _ I (idealr_closedB I_ideal).\npose IpM := isProperIdeal.Build _ I (idealr_closed_nontrivial I_ideal).\npose Iid : idealr _ := HB.pack I IaM IoM IpM.\npose EMixin := GRing.PzRing_hasCommutativeMul.Build _ (@Quotient.mulqC _ Iid).\npose E : comNzRingType := (HB.pack _ EMixin : comPzRingType).\npose PtoE : {rmorphism {poly F} -> E} := \\pi_E%qT.\nhave PtoEd i: PtoE (d i) = 0.\n  by apply/eqP; rewrite piE Quotient.equivE subr0; apply/memI; exists i.\npose Einv (z : E) (q := repr z) (dq := d (pickle q).+1) :=\n  let q_unitP := Bezout_eq1_coprimepP q dq in\n  if q_unitP is ReflectT ex_uv then PtoE (sval (sig_eqW ex_uv)).1 else 0.\nhave Einv0 : Einv 0 = 0.\n  rewrite /Einv; case: Bezout_eq1_coprimepP => // ex_uv.\n  case/negP: (oner_neq0 E); rewrite [X in X == _]piE.\n  rewrite -[_ 1]/(PtoE 1); have [uv <-] := ex_uv.\n  by rewrite rmorphD !rmorphM [X in _ + _ * X]PtoEd /= reprK !mulr0 addr0.\nhave EmulV : forall x, x != 0 -> Einv x * x = 1.\n  rewrite /Einv=> z nz_z; case: Bezout_eq1_coprimepP => [ex_uv |]; last first.\n    move/Bezout_eq1_coprimepP; rewrite I'co //.\n    by rewrite piE -{1}[z]reprK -Quotient.idealrBE subr0 in nz_z.\n  apply/eqP; case: sig_eqW => {ex_uv} [uv uv1]; set i := _.+1 in uv1 *.\n  rewrite piE /= -[z]reprK -(rmorphM PtoE) -Quotient.idealrBE.\n  rewrite -[X in _ - X]uv1 opprD addNKr -mulNr.\n  by apply/memI; exists i; apply: dvdp_mull.\npose EfieldMixin := GRing.ComNzRing_isField.Build _ EmulV Einv0.\npose Efield : fieldType := HB.pack E EfieldMixin.\npose EIsCountable := isCountable.Build E (pcan_pickleK (can_pcan (reprK))).\npose Ecount : countFieldType := HB.pack E Efield EIsCountable.\npose FtoE : {rmorphism _ -> _} := PtoE \\o polyC; pose w : E := PtoE 'X.\nhave defPtoE q: (map_poly FtoE q).[w] = PtoE q.\n  by rewrite (map_poly_comp PtoE polyC) horner_map [_.['X]]comp_polyXr.\nexists Ecount, FtoE, w => [|u].\n  by rewrite /root defPtoE (PtoEd 0).\nby exists (repr u); rewrite defPtoE /= reprK.\nQed."
}
{
  "statement": "Lemma resultant_in_ideal (R : comNzRingType) (p q : {poly R}) :\n    size p > 1 -> size q > 1 ->\n  {uv : {poly R} * {poly R} | size uv.1 < size q /\\ size uv.2 < size p\n  & (resultant p q)%:P = uv.1 * p + uv.2 * q}.\n",
  "proof": "Proof.\nmove=> p_nc q_nc; pose dp := (size p).-1; pose dq := (size q).-1.\npose S := Sylvester_mx p q; pose dS := (dq + dp)%N.\nhave dS_gt0: dS > 0 by rewrite /dS /dq -(subnKC q_nc).\npose j0 := Ordinal dS_gt0.\npose Ss0 := col_mx (p *: \\col_(i < dq) 'X^i) (q *: \\col_(i < dp) 'X^i).\npose Ss := \\matrix_(i, j) (if j == j0 then Ss0 i 0 else (S i j)%:P).\npose u ds s := \\sum_(i < ds) cofactor Ss (s i) j0 * 'X^i.\nexists (u _ (lshift dp), u _ ((rshift dq) _)).\n  suffices sz_u ds s: ds > 1 -> size (u ds.-1 s) < ds by rewrite !sz_u.\n  move/ltn_predK=> {2}<-; apply: leq_trans (size_sum _ _ _) _.\n  apply/bigmax_leqP=> i _.\n  have ->: cofactor Ss (s i) j0 = (cofactor S (s i) j0)%:P.\n    rewrite rmorphM /= rmorph_sign -det_map_mx; congr (_ * \\det _).\n    by apply/matrixP=> i' j'; rewrite !mxE.\n  apply: leq_trans (size_polyMleq _ _) (leq_trans _ (valP i)).\n  by rewrite size_polyC size_polyXn addnS /= -add1n leq_add2r leq_b1.\ntransitivity (\\det Ss); last first.\n  rewrite (expand_det_col Ss j0) big_split_ord !big_distrl /=.\n  by congr (_ + _); apply: eq_bigr => i _;\n    rewrite mxE eqxx (col_mxEu, col_mxEd) !mxE mulrC mulrA mulrAC.\npose S_ j1 := map_mx polyC (\\matrix_(i, j) S i (if j == j0 then j1 else j)).\npose Ss0_ i dj := \\poly_(j < dj) S i (insubd j0 j).\npose Ss_ dj := \\matrix_(i, j) (if j == j0 then Ss0_ i dj else (S i j)%:P).\nhave{Ss u} ->: Ss = Ss_ dS.\n  apply/matrixP=> i j; rewrite mxE [in RHS]mxE; case: (j == j0) => {j}//.\n  apply/polyP=> k; rewrite coef_poly Sylvester_mxE mxE.\n  have [k_ge_dS | k_lt_dS] := leqP dS k.\n    case: (split i) => {}i; rewrite !mxE coefMXn;\n    case: ifP => // /negbT; rewrite -ltnNge ltnS => hi.\n      apply: (leq_sizeP _ _ (leqnn (size p))); rewrite -(ltn_predK p_nc).\n      by rewrite ltn_subRL (leq_trans _ k_ge_dS) // ltn_add2r.\n    - apply: (leq_sizeP _ _ (leqnn (size q))); rewrite -(ltn_predK q_nc).\n      by rewrite ltn_subRL (leq_trans _ k_ge_dS) // addnC ltn_add2l.\n  by rewrite insubdK //; case: (split i) => {}i;\n     rewrite !mxE coefMXn; case: leqP.\ncase: (ubnPgeq dS) (dS_gt0); elim=> // dj IHj ltjS _; pose j1 := Ordinal ltjS.\npose rj0T (A : 'M[{poly R}]_dS) := row j0 A^T.\nhave: rj0T (Ss_ dj.+1) = 'X^dj *: rj0T (S_ j1) + 1 *: rj0T (Ss_ dj).\n  apply/rowP=> i; apply/polyP=> k; rewrite scale1r !(Sylvester_mxE, mxE) eqxx.\n  rewrite coefD coefXnM coefC !coef_poly ltnS subn_eq0 ltn_neqAle andbC.\n  have [k_le_dj | k_gt_dj] /= := leqP k dj; last by rewrite addr0.\n  rewrite Sylvester_mxE insubdK; last exact: leq_ltn_trans (ltjS).\n  by have [->|] := eqP; rewrite (addr0, add0r).\nrewrite -det_tr => /determinant_multilinear->;\n  try by apply/matrixP=> i j; rewrite !mxE lift_eqF.\nhave [dj0 | dj_gt0] := posnP dj; rewrite ?dj0 !mul1r.\n  rewrite !det_tr det_map_mx addrC (expand_det_col _ j0) big1 => [|i _].\n    rewrite add0r; congr (\\det _)%:P.\n    apply/matrixP=> i j; rewrite [in RHS]mxE; case: eqP => // ->.\n    by congr (S i _); apply: val_inj.\n  by rewrite mxE /= [Ss0_ _ _]poly_def big_ord0 mul0r.\nhave /determinant_alternate->: j1 != j0 by rewrite -val_eqE -lt0n.\n  by rewrite mulr0 add0r det_tr IHj // ltnW.\nby move=> i; rewrite !mxE if_same.\nQed."
}
{
  "statement": "Theorem dvd_irr1_index_center gT (G : {group gT}) i :\n  ('chi[G]_i 1%g %| #|G : 'Z('chi_i)%CF|)%C.\n",
  "proof": "Proof.\nwithout loss fful: gT G i / cfaithful 'chi_i.\n  rewrite -{2}[i](quo_IirrK _ (subxx _)) 1?mod_IirrE ?cfModE ?cfker_normal //.\n  rewrite morph1; set i1 := quo_Iirr _ i => /(_ _ _ i1) IH.\n  have fful_i1: cfaithful 'chi_i1.\n    by rewrite quo_IirrE ?cfker_normal ?cfaithful_quo.\n  have:= IH fful_i1; rewrite cfcenter_fful_irr // -cfcenter_eq_center.\n  rewrite index_quotient_eq ?cfcenter_sub ?cfker_norm //.\n  by rewrite setIC subIset // normal_sub ?cfker_center_normal.\nhave [lambda lin_lambda Dlambda] := cfcenter_Res 'chi_i.\nhave DchiZ: {in G & 'Z(G), forall x y, 'chi_i (x * y)%g = 'chi_i x * lambda y}.\n  rewrite -(cfcenter_fful_irr fful) => x y Gx Zy.\n  apply: (mulfI (irr1_neq0 i)); rewrite mulrCA.\n  transitivity ('chi_i x * ('chi_i 1%g *: lambda) y); last by rewrite !cfunE.\n  rewrite -Dlambda cfResE ?cfcenter_sub //.\n  rewrite -irrRepr cfcenter_repr !cfunE in Zy *.\n  case/setIdP: Zy => Gy /is_scalar_mxP[e De].\n  rewrite repr_mx1 group1 (groupM Gx Gy) (repr_mxM _ Gx Gy) Gx Gy De.\n  by rewrite mul_mx_scalar mxtraceZ mulrCA mulrA mulrC -mxtraceZ scalemx1.\nhave inj_lambda: {in 'Z(G) &, injective lambda}.\n  rewrite -(cfcenter_fful_irr fful) => x y Zx Zy eq_xy.\n  apply/eqP; rewrite eq_mulVg1 -in_set1 (subsetP fful) // cfkerEirr inE.\n  apply/eqP; transitivity ('Res['Z('chi_i)%CF] 'chi_i (x^-1 * y)%g).\n    by rewrite cfResE ?cfcenter_sub // groupM ?groupV.\n  rewrite Dlambda !cfunE lin_charM ?groupV // -eq_xy -lin_charM ?groupV //.\n  by rewrite mulrC mulVg lin_char1 ?mul1r.\nrewrite unfold_in -if_neg irr1_neq0 Cint_rat_Aint //.\n  by rewrite rpred_div ?rpred_nat // rpred_nat_num ?Cnat_irr1.\nrewrite (cfcenter_fful_irr fful) nCdivE natf_indexg ?center_sub //=.\nhave ->: #|G|%:R = \\sum_(x in G) 'chi_i x * 'chi_i (x^-1)%g.\n  rewrite -[_%:R]mulr1; apply: canLR (mulVKf (neq0CG G)) _.\n  by rewrite first_orthogonality_relation eqxx.\nrewrite (big_setID [set x | 'chi_i x == 0]) /= -setIdE.\nrewrite big1 ?add0r => [| x /setIdP[_ /eqP->]]; last by rewrite mul0r.\npose h x := (x ^: G * 'Z(G))%g; rewrite (partition_big_imset h).\nrewrite !mulr_suml rpred_sum //= => _ /imsetP[x /setDP[Gx nz_chi_x] ->].\nhave: #|x ^: G|%:R * ('chi_i x * 'chi_i x^-1%g) / 'chi_i 1%g \\in Aint.\n  by rewrite !mulrA mulrAC rpredM ?Aint_irr ?Aint_class_div_irr1.\ncongr 2 (_ * _ \\in Aint); apply: canRL (mulfK (neq0CG _)) _.\nrewrite inE in nz_chi_x.\ntransitivity ('chi_i x * 'chi_i (x^-1)%g *+ #|h x|); last first.\n  rewrite -sumr_const.\n  apply: eq_big => [y | _ /mulsgP[_ z /imsetP[u Gu ->] Zz] ->].\n    rewrite !inE -andbA; apply/idP/and3P=> [|[_ _ /eqP <-]]; last first.\n      by rewrite -{1}[y]mulg1 mem_mulg ?class_refl.\n    case/mulsgP=> _ z /imsetP[u Gu ->] Zz ->; have /centerP[Gz cGz] := Zz.\n    rewrite groupM 1?DchiZ ?groupJ ?cfunJ //; split=> //.\n      by rewrite mulf_neq0 // lin_char_neq0 /= ?cfcenter_fful_irr.\n    rewrite -[z](mulKg u) -cGz // -conjMg /h classGidl {u Gu}//.\n    apply/eqP/setP=> w; apply/mulsgP/mulsgP=> [][_ z1 /imsetP[v Gv ->] Zz1 ->].\n      exists (x ^ v)%g (z * z1)%g; rewrite ?imset_f ?groupM //.\n      by rewrite conjMg -mulgA /(z ^ v)%g cGz // mulKg.\n    exists ((x * z) ^ v)%g (z^-1 * z1)%g; rewrite ?imset_f ?groupM ?groupV //.\n    by rewrite conjMg -mulgA /(z ^ v)%g cGz // mulKg mulKVg.\n  rewrite !irr_inv DchiZ ?groupJ ?cfunJ // rmorphM mulrACA -!normCK -exprMn.\n  by rewrite (normC_lin_char lin_lambda) ?mulr1 //= cfcenter_fful_irr.\nrewrite mulrAC -natrM mulr_natl; congr (_ *+ _).\nsymmetry; rewrite /h /mulg /= /set_mulg [in _ @2: (_, _)]unlock cardsE.\nrewrite -cardX card_in_image // => [] [y1 z1] [y2 z2] /=.\nmove=> /andP[/=/imsetP[u1 Gu1 ->] Zz1] /andP[/=/imsetP[u2 Gu2 ->] Zz2] {y1 y2}.\nmove=> eq12; have /eqP := congr1 'chi_i eq12.\nrewrite !(cfunJ, DchiZ) ?groupJ // (can_eq (mulKf nz_chi_x)).\nrewrite (inj_in_eq inj_lambda) // => /eqP eq_z12; rewrite eq_z12 in eq12 *.\nby rewrite (mulIg _ _ _ eq12).\nQed."
}
{
  "statement": "Lemma porbits_mul_tperm s x y : let t := tperm x y in\n  #|porbits (t * s)| + (x \\notin porbit s y).*2 = #|porbits s| + (x != y).\n",
  "proof": "Proof.\npose xf a b u := seq.find (pred2 a b) (traject u (u a) #|porbit u a|).\nhave xf_size a b u: xf a b u <= #|porbit u a|.\n  by rewrite (leq_trans (find_size _ _)) ?size_traject.\nhave lt_xf a b u n : n < xf a b u -> ~~ pred2 a b ((u ^+ n.+1) a).\n  move=> lt_n; apply: contraFN (before_find (u a) lt_n).\n  by rewrite permX iterSr nth_traject // (leq_trans lt_n).\npose t a b u := tperm a b * u.\nhave tC a b u : t a b u = t b a u by rewrite /t tpermC.\nhave tK a b: involutive (t a b) by move=> u; apply: tpermKg.\nhave tXC a b u n: n <= xf a b u -> (t a b u ^+ n.+1) b = (u ^+ n.+1) a.\n  elim: n => [|n IHn] lt_n_f; first by rewrite permM tpermR.\n  rewrite !(expgSr _ n.+1) !permM {}IHn 1?ltnW //; congr (u _).\n  by case/lt_xf/norP: lt_n_f => ne_a ne_b; rewrite tpermD // eq_sym.\nhave eq_xf a b u: pred2 a b ((u ^+ (xf a b u).+1) a).\n  have ua_a: a \\in porbit u (u a) by rewrite porbit_sym (mem_porbit _ 1).\n  have has_f: has (pred2 a b) (traject u (u a) #|porbit u (u a)|).\n    by apply/hasP; exists a; rewrite /= ?eqxx -?porbit_traject.\n  have:= nth_find (u a) has_f; rewrite has_find size_traject in has_f.\n  rewrite -eq_porbit_mem in ua_a.\n  by rewrite nth_traject // -iterSr -permX -(eqP ua_a).\nhave xfC a b u: xf b a (t a b u) = xf a b u.\n  without loss lt_a: a b u / xf b a (t a b u) < xf a b u.\n    move=> IHab; set m := xf b a _; set n := xf a b u.\n    by case: (ltngtP m n) => // ltx; [apply: IHab | rewrite -[m]IHab tC tK].\n  by move/lt_xf: (lt_a); rewrite -(tXC a b) 1?ltnW //= orbC [_ || _]eq_xf.\npose ts := t x y s; rewrite /= -[_ * s]/ts.\npose dp u := #|porbits u :\\ porbit u y :\\ porbit u x|.\nrewrite !(addnC #|_|) (cardsD1 (porbit ts y)) imset_f ?inE //.\nrewrite (cardsD1 (porbit ts x)) inE imset_f ?inE //= -/(dp ts) {}/ts.\nrewrite (cardsD1 (porbit s y)) (cardsD1 (porbit s x)) !(imset_f, inE) //.\nrewrite -/(dp s) !addnA !eq_porbit_mem andbT; congr (_ + _); last first.\n  wlog suffices: s / dp s <= dp (t x y s).\n    by move=> IHs; apply/eqP; rewrite eqn_leq -{2}(tK x y s) !IHs.\n  apply/subset_leq_card/subsetP=> {dp} C.\n  rewrite !inE andbA andbC !(eq_sym C) => /and3P[/imsetP[z _ ->{C}]].\n  rewrite 2!eq_porbit_mem => sxz syz.\n  suffices ts_z: porbit (t x y s) z = porbit s z.\n    by rewrite -ts_z !eq_porbit_mem {1 2}ts_z sxz syz imset_f ?inE.\n  suffices exp_id n: ((t x y s) ^+ n) z = (s ^+ n) z.\n    apply/porbit_setP => u; apply/idP/idP=> /porbitP[i ->].\n      by rewrite /aperm exp_id mem_porbit. \n    by rewrite /aperm -exp_id mem_porbit.\n  elim: n => // n IHn; rewrite !expgSr !permM {}IHn tpermD //.\n    by apply: contraNneq sxz => ->; apply: mem_porbit.\n  by apply: contraNneq syz => ->; apply: mem_porbit.\ncase: eqP {dp} => [<- | ne_xy]; first by rewrite /t tperm1 mul1g porbit_id.\nsuff ->: (x \\in porbit (t x y s) y) = (x \\notin porbit s y) by case: (x \\in _).\nwithout loss xf_x: s x y ne_xy / (s ^+ (xf x y s).+1) x = x.\n  move=> IHs; have ne_yx := nesym ne_xy; have:= eq_xf x y s; set n := xf x y s.\n  case/pred2P=> [|snx]; first exact: IHs.\n  by rewrite -[x \\in _]negbK ![x \\in _]porbit_sym -{}IHs ?xfC ?tXC // tC tK.\nrewrite -{1}xf_x -(tXC _ _ _ _ (leqnn _)) mem_porbit; symmetry.\nrewrite -eq_porbit_mem eq_sym eq_porbit_mem porbit_traject.\napply/trajectP=> [[n _ snx]].\nhave: looping s x (xf x y s).+1 by rewrite /looping -permX xf_x inE eqxx.\nmove/loopingP/(_ n); rewrite -{n}snx.\ncase/trajectP=> [[_|i]]; first exact: nesym; rewrite ltnS -permX => lt_i def_y.\nby move/lt_xf: lt_i; rewrite def_y /= eqxx orbT.\nQed."
}
{
  "statement": "Lemma mx_Jacobson_density : ('C(Hom_G) <= E_G)%MS.\n",
  "proof": "Proof.\napply/row_subP=> iB; rewrite -[row iB _]vec_mxK; move defB: (vec_mx _) => B.\nhave{defB} cBcE: (B \\in 'C(Hom_G))%MS by rewrite -defB vec_mxK row_sub.\nhave rGnP: mx_repr G (fun x => lin_mx (mulmxr (rG x)) : 'A_n).\n  split=> [|x y Gx Gy]; apply/row_matrixP=> i.\n    by rewrite !rowE mul_rV_lin repr_mx1 /= !mulmx1 vec_mxK.\n  by rewrite !rowE mulmxA !mul_rV_lin repr_mxM //= mxvecK mulmxA.\nmove def_rGn: (MxRepresentation rGnP) => rGn.\npose E_Gn := enveloping_algebra_mx rGn.\npose e1 : 'rV[F]_(n ^ 2) := mxvec 1%:M; pose U := cyclic_mx rGn e1.\nhave U_e1: (e1 <= U)%MS by rewrite cyclic_mx_id.\nhave modU: mxmodule rGn U by rewrite cyclic_mx_module.\npose Bn : 'M_(n ^ 2) := lin_mx (mulmxr B).\nsuffices U_e1Bn: (e1 *m Bn <= U)%MS.\n  rewrite mul_vec_lin /= mul1mx in U_e1Bn; apply: submx_trans U_e1Bn _.\n  rewrite genmxE; apply/row_subP=> i; rewrite row_mul rowK mul_vec_lin_row.\n  by rewrite -def_rGn mul_vec_lin /= mul1mx (eq_row_sub i) ?rowK.\nhave{cBcE} cBncEn A: centgmx rGn A -> A *m Bn = Bn *m A.\n  rewrite -def_rGn => cAG; apply/row_matrixP; case/mxvec_indexP=> j k /=.\n  rewrite !rowE !mulmxA -mxvec_delta -(mul_delta_mx (0 : 'I_1)).\n  rewrite mul_rV_lin mul_vec_lin /= -mulmxA; apply: (canLR vec_mxK).\n  apply/row_matrixP=> i; set dj0 := delta_mx j 0.\n  have /= defAij :=\n    mul_rV_lin1 (row i \\o vec_mx \\o mulmxr A \\o mxvec \\o mulmx dj0).\n  rewrite -defAij row_mul -defAij -!mulmxA (cent_mxP cBcE) {k}//.\n  rewrite memmx_cent_envelop; apply/centgmxP=> x Gx; apply/row_matrixP=> k.\n  rewrite !row_mul !rowE !{}defAij /= -row_mul mulmxA mul_delta_mx.\n  congr (row i _); rewrite -(mul_vec_lin (mulmxr (rG x))) -mulmxA.\n  by rewrite -(centgmxP cAG) // mulmxA mx_rV_lin.\nsuffices redGn: mx_completely_reducible rGn 1%:M.\n  have [V modV defUV] := redGn _ modU (submx1 _); move/mxdirect_addsP=> dxUV.\n  rewrite -(proj_mx_id dxUV U_e1) -mulmxA {}cBncEn 1?mulmxA ?proj_mx_sub //.\n  by rewrite -row_full_dom_hom -sub1mx -defUV proj_mx_hom.\npose W i : 'M[F]_(n ^ 2) := <<lin1_mx (mxvec \\o mulmx (delta_mx i 0))>>%MS.\nhave defW: (\\sum_i W i :=: 1%:M)%MS.\n  apply/eqmxP; rewrite submx1; apply/row_subP; case/mxvec_indexP=> i j.\n  rewrite row1 -mxvec_delta (sumsmx_sup i) // genmxE; apply/submxP.\n  by exists (delta_mx 0 j); rewrite mul_rV_lin1 /= mul_delta_mx.\napply: mxsemisimple_reducible; apply: (intro_mxsemisimple defW) => i _ nzWi.\nsplit=> // [|Vi modVi sViWi nzVi].\n  apply/mxmoduleP=> x Gx; rewrite genmxE (eqmxMr _ (genmxE _)) -def_rGn.\n  apply/row_subP=> j; rewrite rowE mulmxA !mul_rV_lin1 /= mxvecK -mulmxA.\n  by apply/submxP; move: (_ *m rG x) => v; exists v; rewrite mul_rV_lin1.\ndo [rewrite !genmxE; set f := lin1_mx _] in sViWi *.\nhave f_free: row_free f.\n  apply/row_freeP; exists (lin1_mx (row i \\o vec_mx)); apply/row_matrixP=> j.\n  by rewrite row1 rowE mulmxA !mul_rV_lin1 /= mxvecK rowE !mul_delta_mx.\npose V := <<Vi *m pinvmx f>>%MS; have Vidf := mulmxKpV sViWi.\nsuffices: (1%:M <= V)%MS by rewrite genmxE -(submxMfree _ _ f_free) mul1mx Vidf.\ncase: irrG => _ _ ->; rewrite ?submx1 //; last first.\n  by rewrite -mxrank_eq0 genmxE -(mxrankMfree _ f_free) Vidf mxrank_eq0.\napply/mxmoduleP=> x Gx; rewrite genmxE (eqmxMr _ (genmxE _)).\nrewrite -(submxMfree _ _ f_free) Vidf.\napply: submx_trans (mxmoduleP modVi x Gx); rewrite -{2}Vidf.\napply/row_subP=> j; apply: (eq_row_sub j); rewrite row_mul -def_rGn.\nby rewrite !(row_mul _ _ f) !mul_rV_lin1 /= mxvecK !row_mul !mulmxA.\nQed."
}
{
  "statement": "Theorem constt_Inertia_bijection :\n [/\\  {in calA, forall s, 'Ind[G] 'chi_s \\in irr G},\n      {in calA &, injective (Ind_Iirr G)},\n           Ind_Iirr G @: calA =i calB,\n      {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi),\n             [predI irr_constt ('Res chi) & calA] =i pred1 s}\n   &  {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi),\n             '['Res psi, theta] = '['Res chi, theta]}].\n",
  "proof": "Proof.\nhave [sHG sTG]: H \\subset G /\\ T \\subset G by rewrite subsetIl normal_sub.\nhave nsHT : H <| T := normal_Inertia theta sHG; have sHT := normal_sub nsHT.\nhave AtoB_P s (psi := 'chi_s) (chi := 'Ind[G] psi): s \\in calA ->\n  [/\\ chi \\in irr G, AtoB s \\in calB & '['Res psi, theta] = '['Res chi, theta]].\n- rewrite constt_Ind_Res => sHt; have [r sGr] := constt_cfInd_irr s sTG.\n  rewrite constt_Ind_Res.\n  have rTs: s \\in irr_constt ('Res[T] 'chi_r) by rewrite -constt_Ind_Res.\n  have NrT: 'Res[T] 'chi_r \\is a character by rewrite cfRes_char ?irr_char.\n  have rHt: t \\in irr_constt ('Res[H] 'chi_r).\n    by have:= constt_Res_trans NrT rTs sHt; rewrite cfResRes.\n  pose e := '['Res[H] 'chi_r, theta]; set f := '['Res[H] psi, theta].\n  have DrH: 'Res[H] 'chi_r = e *: \\sum_(xi <- (theta ^: G)%CF) xi.\n    exact: Clifford_Res_sum_cfclass.\n  have DpsiH: 'Res[H] psi = f *: theta.\n    rewrite (Clifford_Res_sum_cfclass nsHT sHt).\n    by rewrite cfclass_invariant ?subsetIr ?big_seq1.\n  have ub_chi_r: 'chi_r 1%g <= chi 1%g ?= iff ('chi_r == chi).\n    have Nchi: chi \\is a character by rewrite cfInd_char ?irr_char.\n    have [chi1 Nchi1->] := constt_charP _ Nchi sGr.\n    rewrite addrC cfunE -leifBLR subrr eq_sym -subr_eq0 addrK.\n    by split; rewrite ?char1_ge0 // eq_sym char1_eq0.\n  have lb_chi_r: chi 1%g <= 'chi_r 1%g ?= iff (f == e).\n    rewrite cfInd1 // -(cfRes1 H) DpsiH -(cfRes1 H 'chi_r) DrH !cfunE sum_cfunE.\n    rewrite (eq_big_seq (fun _ => theta 1%g)) => [|i]; last first.\n      by case/cfclassP=> y _ ->; rewrite cfConjg1.\n    rewrite reindex_cfclass //= sumr_const -(eq_card (cfclass_IirrE _ _)).\n    rewrite mulr_natl mulrnAr card_cfclass_Iirr //.\n    rewrite (mono_leif (ler_pMn2r (indexg_gt0 G T))).\n    rewrite (mono_leif (ler_pM2r (irr1_gt0 t))); apply: leif_eq.\n    by rewrite /e -(cfResRes _ sHT) ?cfdot_Res_ge_constt.\n  have [_ /esym] := leif_trans ub_chi_r lb_chi_r; rewrite eqxx.\n  by case/andP=> /eqP Dchi /eqP->; rewrite cfIirrE -/chi -?Dchi ?mem_irr.\nhave part_c: {in calA, forall s (chi := 'Ind[G] 'chi_s),\n  [predI irr_constt ('Res[T] chi) & calA] =i pred1 s}.\n- move=> s As chi s1; have [irr_chi _ /eqP Dchi_theta] := AtoB_P s As.\n  have chiTs: s \\in irr_constt ('Res[T] chi).\n    by rewrite irr_consttE cfdot_Res_l irrWnorm ?oner_eq0.\n  apply/andP/eqP=> [[/= chiTs1 As1] | -> //].\n  apply: contraTeq Dchi_theta => s's1; rewrite lt_eqF // -/chi.\n  have [|phi Nphi DchiT] := constt_charP _ _ chiTs.\n    by rewrite cfRes_char ?cfInd_char ?irr_char.\n  have [|phi1 Nphi1 Dphi] := constt_charP s1 Nphi _.\n    rewrite irr_consttE -(canLR (addKr _) DchiT) addrC cfdotBl cfdot_irr.\n    by rewrite mulrb ifN_eqC ?subr0.\n  rewrite -(cfResRes chi sHT sTG) DchiT Dphi !rmorphD !cfdotDl /=.\n  rewrite -ltrBDl subrr ltr_wpDr ?lt_def //;\n    rewrite natr_ge0 ?Cnat_cfdot_char ?cfRes_char ?irr_char //.\n  by rewrite andbT -irr_consttE -constt_Ind_Res.\ndo [split=> //; try by move=> s /AtoB_P[]] => [s1 s2 As1 As2 | r].\n  have [[irr_s1G _ _] [irr_s2G _ _]] := (AtoB_P _ As1, AtoB_P _ As2).\n  move/(congr1 (tnth (irr G))); rewrite !cfIirrE // => eq_s12_G.\n  apply/eqP; rewrite -[_ == _]part_c // inE /= As1 -eq_s12_G.\n  by rewrite -As1 [_ && _]part_c // inE /=.\napply/imsetP/idP=> [[s /AtoB_P[_ BsG _] -> //] | Br].\nhave /exists_inP[s rTs As]: [exists s in irr_constt ('Res 'chi_r), s \\in calA].\n  rewrite -negb_forall_in; apply: contra Br => /eqfun_inP => o_tT_rT.\n  rewrite -(cfIndInd _ sTG sHT) -cfdot_Res_r ['Res _]cfun_sum_constt.\n  by rewrite cfdot_sumr big1 // => i rTi; rewrite cfdotZr o_tT_rT ?mulr0.\nexists s => //; have [/irrP[r1 DsG] _ _] := AtoB_P s As.\nby apply/eqP; rewrite /AtoB -constt_Ind_Res DsG irrK constt_irr in rTs *.\nQed."
}
{
  "statement": "Lemma DecSocleType : socleType rG.\n",
  "proof": "Proof.\nhave [n0 | n_gt0] := posnP n.\n  by exists [::] => // M [_]; rewrite -mxrank_eq0 -leqn0 -n0 rank_leq_row.\nhave n2_gt0: n ^ 2 > 0 by rewrite muln_gt0 n_gt0.\npose span Ms := (\\sum_(M <- Ms) component_mx rG M)%MS.\nhave: {in [::], forall M, mxsimple rG M} by [].\nhave [m] := ubnP (n - \\rank (span [::])).\nelim: m [::] => // m IHm Ms /ltnSE-Ms_ge_n simMs.\npose V := span Ms; pose Vt := mx_term V.\npose Ut i := vec_mx (row_var F (n * n) i); pose Zt := mx_term (0 : 'M[F]_n).\npose exU i f := Exists_row_form (n * n) i (~ submx_form (Ut i) Zt /\\ f (Ut i)).\npose meetUVf U := exU 1 (fun W => submx_form W Vt /\\ submx_form W U)%T.\npose mx_sat := GRing.sat (@row_env F (n * n) [::]).\nhave ev_sub0 := GRing.qf_evalP _ (submx_form_qf _ Zt).\nhave ev_mod := GRing.qf_evalP _ (mxmodule_form_qf rG _).\npose ev := (eval_mxmodule, eval_submx, eval_vec_mx, eval_row_var, eval_mx_term).\ncase haveU: (mx_sat (exU 0 (fun U => mxmodule_form rG U /\\ ~ meetUVf _ U)%T)).\n  have [U modU]: {U : 'M_n | mxmodule rG U & (U != 0) && ((U :&: V)%MS == 0)}.\n    apply: sig2W; case/Exists_rowP: (satP haveU) => //= u [nzU [modU tiUV]].\n    exists (vec_mx u); first by move/ev_mod: modU; rewrite !ev.\n    set W := (_ :&: V)%MS; move/ev_sub0: nzU; rewrite !ev -!submx0 => -> /=.\n    apply/idPn=> nzW; case: tiUV; apply/Exists_rowP=> //; exists (mxvec W).\n    apply/GRing.qf_evalP; rewrite /= ?submx_form_qf // !ev mxvecK nzW /=.\n    by rewrite andbC -sub_capmx.\n  case/andP=> nzU tiUV; have [M simM sMU] := dec_mxsimple_exists modU nzU.\n  apply: (IHm (M :: Ms)) => [|M']; last first.\n    by case/predU1P=> [-> //|]; apply: simMs.\n  have [_ nzM _] := simM.\n  suffices ltVMV: \\rank V < \\rank (span (M :: Ms)).\n    rewrite (leq_trans _ Ms_ge_n) // ltn_sub2l ?(leq_trans ltVMV) //.\n    exact: rank_leq_row.\n  rewrite /span big_cons (ltn_leqif (mxrank_leqif_sup (addsmxSr _ _))).\n  apply: contra nzM; rewrite addsmx_sub -submx0 -(eqP tiUV) sub_capmx sMU.\n  by case/andP=> sMV _; rewrite (submx_trans _ sMV) ?component_mx_id.\nexists Ms => // M simM; have [modM nzM minM] := simM.\nhave sMV: (M <= V)%MS.\n  apply: contraFT haveU => not_sMV; apply/satP/Exists_rowP=> //.\n  exists (mxvec M); split; first by apply/ev_sub0; rewrite !ev mxvecK submx0.\n  split; first by apply/ev_mod; rewrite !ev mxvecK.\n  apply/Exists_rowP=> // [[w]].\n  apply/GRing.qf_evalP; rewrite /= ?submx_form_qf // !ev /= mxvecK submx0.\n  rewrite -nz_row_eq0 -(cyclic_mx_eq0 rG); set W := cyclic_mx _ _.\n  apply: contra not_sMV => /and3P[nzW Vw Mw].\n  have{Vw Mw} [sWV sWM]: (W <= V /\\ W <= M)%MS.\n    rewrite !cyclic_mx_sub ?(submx_trans (nz_row_sub _)) //.\n    by rewrite sumsmx_module // => M' _; apply: component_mx_module.\n  by rewrite (submx_trans _ sWV) // minM ?cyclic_mx_module.\nwlog sG: / socleType rG by apply: socle_exists.\nhave sVS: (V <= \\sum_(W : sG | has (fun Mi => Mi <= W) Ms) W)%MS.\n  rewrite [V](big_nth 0) big_mkord; apply/sumsmx_subP=> i _.\n  set Mi := Ms`_i; have MsMi: Mi \\in Ms by apply: mem_nth.\n  have simMi := simMs _ MsMi; have S_Mi := component_socle sG simMi.\n  rewrite (sumsmx_sup (PackSocle S_Mi)) ?PackSocleK //.\n  by apply/hasP; exists Mi; rewrite ?component_mx_id.\nhave [W MsW isoWM] := subSocle_iso simM (submx_trans sMV sVS).\nhave [Mi MsMi sMiW] := hasP MsW; apply/hasP; exists Mi => //.\nhave [simMi simW] := (simMs _ MsMi, socle_simple W); apply/mxsimple_isoP=> //.\nexact: mx_iso_trans (mx_iso_sym isoWM) (component_mx_iso simW simMi sMiW).\nQed."
}
{
  "statement": "Lemma transfer_cycle_expansion :\n   transfer g = \\sum_(x in X) fmalpha ((g ^+ n_ x) ^ (x^-1)).\n",
  "proof": "Proof.\npose Y := \\bigcup_(x in X) [set x * g ^+ i | i : 'I_(n_ x)].\npose rY := transversal_repr 1 Y.\npose pcyc x := porbit (actperm 'Rs g) (H :* x).\npose traj x := traject (actperm 'Rs g) (H :* x) #|pcyc x|.\nhave Hgr_eq x: H_g_rcosets x = pcyc x.\n  by rewrite /H_g_rcosets -orbitRs -porbit_actperm ?inE.\nhave pcyc_eq x: pcyc x =i traj x by apply: porbit_traject.\nhave uniq_traj x: uniq (traj x) by apply: uniq_traject_porbit.\nhave n_eq x: n_ x = #|pcyc x| by rewrite -Hgr_eq.\nhave size_traj x: size (traj x) = n_ x by rewrite n_eq size_traject.\nhave nth_traj x j: j < n_ x -> nth (H :* x) (traj x) j = H :* (x * g ^+ j).\n  move=> lt_j_x; rewrite nth_traject -?n_eq //.\n  by rewrite -permX -morphX ?inE // actpermE //= rcosetE rcosetM.\nhave sYG: Y \\subset G.\n  apply/bigcupsP=> x Xx; apply/subsetP=> _ /imsetP[i _ ->].\n  by rewrite groupM ?groupX // sXG.\nhave trY: is_transversal Y HG G.\n  apply/and3P; split=> //; apply/forall_inP=> Hy.\n  have /and3P[/eqP <- _ _] := partHGg; rewrite -defHgX cover_imset.\n  case/bigcupP=> x Xx; rewrite Hgr_eq pcyc_eq => /trajectP[i].\n  rewrite -n_eq -permX -morphX ?in_setT // actpermE /= rcosetE -rcosetM => lti.\n  set y := x * _ => ->{Hy}; pose oi := Ordinal lti.\n  have Yy: y \\in Y by apply/bigcupP; exists x => //; apply/imsetP; exists oi.\n  apply/cards1P; exists y; apply/esym/eqP.\n  rewrite eqEsubset sub1set inE Yy rcoset_refl.\n  apply/subsetP=> _ /setIP[/bigcupP[x' Xx' /imsetP[j _ ->]] Hy_x'gj].\n  have eq_xx': x = x'.\n    apply: (pblock_inj trX) => //; have /andP[/and3P[_ tiX _] _] := trX.\n    have HGgHyg: H :* y * <[g]> \\in HG :* <[g]>.\n      by rewrite mem_mulg ?set11 // -rcosetE imset_f ?(subsetP sYG).\n    rewrite !(def_pblock tiX HGgHyg) //.\n      by rewrite -[x'](mulgK (g ^+ j)) mem_mulg // groupV mem_cycle.\n    by rewrite -[x](mulgK (g ^+ i)) mem_mulg ?rcoset_refl // groupV mem_cycle.\n  apply/set1P; rewrite /y eq_xx'; congr (_ * _ ^+ _) => //; apply/eqP.\n  rewrite -(@nth_uniq _ (H :* x) (traj x)) ?size_traj // ?eq_xx' //.\n  by rewrite !nth_traj ?(rcoset_eqP Hy_x'gj) // -eq_xx'.\nhave rYE x i : x \\in X -> i < n_ x -> rY (H :* x :* g ^+ i) = x * g ^+ i.\n  move=> Xx lt_i_x; rewrite -rcosetM; apply: (canLR_in (pblockK trY 1)).\n    by apply/bigcupP; exists x => //; apply/imsetP; exists (Ordinal lt_i_x).\n  apply/esym/def_pblock; last exact: rcoset_refl; first by case/and3P: partHG.\n  by rewrite -rcosetE imset_f ?groupM ?groupX // sXG.\nrewrite (transfer_indep trY Gg) /V -/rY (set_partition_big _ partHGg) /=.\nrewrite -defHgX big_imset /=; last first.\n  apply/imset_injP; rewrite defHgX (card_transversal trX) defHGg.\n  by rewrite (card_in_imset injHGg).\napply eq_bigr=> x Xx; rewrite Hgr_eq (eq_bigl _ _ (pcyc_eq x)) -big_uniq //=.\nhave n_gt0: 0 < n_ x by rewrite indexg_gt0.\nrewrite /traj -n_eq; case def_n: (n_ x) (n_gt0) => // [n] _.\nrewrite conjgE invgK -{1}[H :* x]rcoset1 -{1}(expg0 g).\nelim: {1 3}n 0%N (addn0 n) => [|m IHm] i def_i /=.\n  rewrite big_seq1 {i}[i]def_i rYE // ?def_n //.\n  rewrite -(mulgA _ _ g) -rcosetM -expgSr -[(H :* x) :* _]rcosetE.\n  rewrite -actpermE morphX ?inE // permX // -{2}def_n n_eq iter_porbit mulgA.\n  by rewrite -[H :* x]rcoset1 (rYE _ 0) ?mulg1.\nrewrite big_cons rYE //; last by rewrite def_n -def_i ltnS leq_addl.\nrewrite permE /= rcosetE -rcosetM -(mulgA _ _ g) -expgSr.\nrewrite addSnnS in def_i; rewrite IHm //.\nrewrite rYE //; last by rewrite def_n -def_i ltnS leq_addl.\nby rewrite mulgV [fmalpha 1]morph1 add0r.\nQed."
}
{
  "statement": "Lemma sum_norm2_char_generators gT (G : {group gT}) (chi : 'CF(G)) :\n    let S := [pred s | generator G s] in\n    chi \\is a character -> {in S, forall s, chi s != 0} ->\n  \\sum_(s in S) `|chi s| ^+ 2 >= #|S|%:R.\n",
  "proof": "Proof.\nmove=> S Nchi nz_chi_S; pose n := #|G|.\nhave [g Sg | S_0] := pickP (generator G); last first.\n  by rewrite eq_card0 // big_pred0 ?lerr.\nhave defG: <[g]> = G by apply/esym/eqP.\nhave [cycG Gg]: cyclic G /\\ g \\in G by rewrite -defG cycle_cyclic cycle_id.\npose I := {k : 'I_n | coprime n k}; pose ItoS (k : I) := (g ^+ sval k)%g.\nhave imItoS: codom ItoS =i S.\n  move=> s; rewrite inE /= /ItoS /I /n /S -defG -orderE.\n  apply/codomP/idP=> [[[i cogi] ->] | Ss]; first by rewrite generator_coprime.\n  have [m ltmg Ds] := cyclePmin (cycle_generator Ss).\n  by rewrite Ds generator_coprime in Ss; apply: ex_intro (Sub (Sub m _) _) _.\nhave /injectiveP injItoS: injective ItoS.\n  move=> k1 k2 /eqP; apply: contraTeq.\n  by rewrite eq_expg_mod_order orderE defG -/n !modn_small.\nhave [Qn galQn [QnC gQnC [eps [pr_eps defQn] QnG]]] := group_num_field_exists G.\nhave{QnG} QnGg := QnG _ G _ _ g (order_dvdG Gg).\npose calG := 'Gal({:Qn} / 1).\nhave /fin_all_exists2[ItoQ inItoQ defItoQ] (k : I):\n  exists2 nu, nu \\in calG & nu eps = eps ^+ val k.\n- case: k => [[m _] /=]; rewrite coprime_sym => /Qn_aut_exists[nuC DnuC].\n  have [nuQ DnuQ] := restrict_aut_to_normal_num_field QnC nuC.\n  have hom_nu: kHom 1 {:Qn} (linfun nuQ).\n    rewrite k1HomE; apply/ahom_inP.\n    by split=> [u v | ]; rewrite !lfunE ?rmorphM ?rmorph1.\n  have [|nu cGnu Dnu] := kHom_to_gal _ (normalFieldf 1) hom_nu.\n    by rewrite !subvf.\n  exists nu => //; apply: (fmorph_inj QnC).\n  rewrite -Dnu ?memvf // lfunE DnuQ rmorphXn DnuC //.\n  by rewrite prim_expr_order // fmorph_primitive_root.\nhave{defQn} imItoQ: calG = ItoQ @: {:I}.\n  apply/setP=> nu; apply/idP/imsetP=> [cGnu | [k _ ->] //].\n  have pr_nu_e: n.-primitive_root (nu eps) by rewrite fmorph_primitive_root.\n  have [i Dnue] := prim_rootP pr_eps (prim_expr_order pr_nu_e).\n  rewrite Dnue prim_root_exp_coprime // coprime_sym in pr_nu_e.\n  apply: ex_intro2 (Sub i _) _ _ => //; apply/eqP.\n  rewrite /calG /= -defQn in ItoQ inItoQ defItoQ nu cGnu Dnue *.\n  by rewrite gal_adjoin_eq // defItoQ -Dnue.\nhave injItoQ: {in {:I} &, injective ItoQ}.\n  move=> k1 k2 _ _ /(congr1 (fun nu : gal_of _ => nu eps))/eqP.\n  by apply: contraTeq; rewrite !defItoQ (eq_prim_root_expr pr_eps) !modn_small.\npose pi1 := \\prod_(s in S) chi s; pose pi2 := \\prod_(s in S) `|chi s| ^+ 2.\nhave Qpi1: pi1 \\in Crat.\n  have [a Da] := QnGg _ Nchi; suffices ->: pi1 = QnC (galNorm 1 {:Qn} a).\n    have /vlineP[q ->] := mem_galNorm galQn (memvf a).\n    by rewrite rmorphZ_num rmorph1 mulr1 Crat_rat.\n  rewrite /galNorm rmorph_prod -/calG imItoQ big_imset //=.\n  rewrite /pi1 -(eq_bigl _ _ imItoS) -big_uniq // big_image /=.\n  apply: eq_bigr => k _; have [nuC DnuC] := gQnC (ItoQ k); rewrite DnuC Da.\n  have [r ->] := char_sum_irr Nchi; rewrite !sum_cfunE rmorph_sum.\n  apply: eq_bigr => i _; have /QnGg[b Db] := irr_char i.\n  have Lchi_i: 'chi_i \\is a linear_char by rewrite irr_cyclic_lin.\n  have /(prim_rootP pr_eps)[m Dem]: b ^+ n = 1.\n    apply/eqP; rewrite -(fmorph_eq1 QnC) rmorphXn /= Db -lin_charX //.\n    by rewrite -expg_mod_order orderE defG modnn lin_char1.\n  rewrite -Db /= -DnuC Dem rmorphXn /= defItoQ exprAC -{m}Dem rmorphXn /= {b}Db.\n  by rewrite lin_charX.\nclear I ItoS imItoS injItoS ItoQ inItoQ defItoQ imItoQ injItoQ.\nclear Qn galQn QnC gQnC eps pr_eps QnGg calG.\nhave{Qpi1} Zpi1: pi1 \\in Num.int.\n  by rewrite Cint_rat_Aint // rpred_prod // => s _; apply: Aint_char.\nhave{pi1 Zpi1} pi2_ge1: 1 <= pi2.\n  have ->: pi2 = `|pi1| ^+ 2.\n    by rewrite (big_morph Num.norm (@normrM _) (@normr1 _)) -prodrXl.\n  by rewrite intr_normK // sqr_intr_ge1 //; apply/prodf_neq0.\nhave Sgt0: (#|S| > 0)%N by rewrite (cardD1 g) [g \\in S]Sg.\nrewrite -mulr_natr -ler_pdivlMr ?ltr0n //.\nhave n2chi_ge0 s: s \\in S -> 0 <= `|chi s| ^+ 2 by rewrite exprn_ge0.\nrewrite -(expr_ge1 Sgt0); last by rewrite divr_ge0 ?ler0n ?sumr_ge0.\nby rewrite (le_trans pi2_ge1) // leif_AGM.\nQed."
}
{
  "statement": "Lemma Grp_pX1p2 :\n  p^{1+2} \\isog Grp (x : y : x ^+ p, y ^+ p, [~ x, y, x], [~ x, y, y]).\n",
  "proof": "Proof.\nrewrite [@gtype _]unlock; apply: intro_isoGrp => [|rT H].\n  apply/existsP; pose x := sdpair1 actp (0, 1)%R; pose y := sdpair2 actp 1%R.\n  exists (x, y); rewrite /= !xpair_eqE; set z := [~ x, y]; set G := _ <*> _.\n  have def_z: z = sdpair1 actp (1, 0)%R.\n    rewrite [z]commgEl -sdpair_act ?inE //=.\n    rewrite -morphV -?morphM ?inE //=; congr (sdpair1 _ (_, _)) => /=.\n      by rewrite mulr1 mulKg.\n    by rewrite mulVg.\n  have def_xi i: x ^+ i = sdpair1 actp (0, i%:R)%R.  \n    rewrite -morphX ?inE //; congr (sdpair1 _ _).\n    by apply/eqP; rewrite /eq_op /= !morphX ?inE ?expg1n //=.\n  have def_yi i: y ^+ i = sdpair2 actp i%:R.  \n    by rewrite -morphX ?inE //.\n  have def_zi i: z ^+ i = sdpair1 actp (i%:R, 0)%R.  \n    rewrite def_z -morphX ?inE //; congr (sdpair1 _ _).\n    by apply/eqP; rewrite /eq_op /= !morphX ?inE ?expg1n ?andbT //=.\n  rewrite def_xi def_yi pchar_Zp ?morph1 //.\n  rewrite def_z -morphR ?inE // !commgEl -sdpair_act ?inE //= mulr0 addr0.\n  rewrite mulVg -[_ * _]/(_ , _) /= !invg1 mulg1 !mul1g mulVg morph1 !andbT.\n  have Gx: x \\in G by rewrite -cycle_subG joing_subl.\n  have Gy: y \\in G by rewrite -cycle_subG joing_subr.\n  rewrite eqEsubset subsetT -im_sdpair mulG_subG /= -/G; apply/andP; split.\n    apply/subsetP=> u /morphimP[[i j] _ _ def_u].\n    suffices ->: u = z ^+ i * x ^+ j. \n      rewrite groupMl; apply/groupX; first exact: Gx.\n      by apply/groupR; first exact: Gx.\n    rewrite def_zi def_xi !natr_Zp -morphM ?inE // def_u.\n    by congr (sdpair1 _ (_, _)); rewrite ?mulg1 ?mul1g.\n  apply/subsetP=> v /morphimP[k _ _ def_v].\n  suffices ->: v = y ^+ k by rewrite groupX.\n  by rewrite def_yi natr_Zp.\ncase/existsP=> [[x y] /=]; set z := [~ x, y].\ncase/eqP=> defH xp yp /eqP/commgP czx /eqP/commgP czy.\nhave zp: z ^+ p = 1 by rewrite -commXg // xp comm1g.\npose f1 (ij : 'Z_p * 'Z_p) := let: (i, j) := ij in z ^+ i * x ^+ j.\nhave f1M: {in setT &, {morph f1 : u v / u * v}}.\n  case=> /= [i1 j1] [i2 j2] _ _ /=; rewrite {3 6}Zp_cast // !expg_mod //.\n  rewrite !expgD !mulgA; congr (_ * _); rewrite -!mulgA; congr (_ * _).\n  by apply: commuteX2.\npose f2 (k : 'Z_p) := y ^+ k.\nhave f2M: {in setT &, {morph f2 : u v / u * v}}.\n  by move=> k1 k2 _ _; rewrite /f2 /= {3}Zp_cast // expg_mod // expgD.\nhave actf: {in setT & setT, morph_act actp 'J (Morphism f1M) (Morphism f2M)}.\n  case=> /= i j k _ _; rewrite modnDmr {4}Zp_cast // expg_mod // expgD.\n  rewrite /f2 conjMg {1}/conjg (commuteX2 i k czy) mulKg -mulgA.\n  congr (_ * _); rewrite (commuteX2 _ _ czx) mulnC expgM.\n  by rewrite -commXg // -commgX ?mulKVg // commXg // /commute commuteX.\napply/homgP; exists (xsdprod_morphism actf).\napply/eqP; rewrite eqEsubset -{2}defH -genM_join gen_subG /= im_xsdprodm.\nhave Hx: x \\in H by rewrite -cycle_subG -defH joing_subl.\nhave Hy: y \\in H by rewrite -cycle_subG -defH joing_subr.\nrewrite mulG_subG -andbA; apply/and3P; split.\n- apply/subsetP=> _ /morphimP[[i j] _ _ -> /=].\n  by rewrite groupMl groupX ?groupR.\n- by apply/subsetP=> _ /morphimP[k _ _ ->]; rewrite groupX.\nrewrite mulgSS ?cycle_subG //= morphimEdom; apply/imsetP.\n  by exists (0, 1)%R; rewrite ?inE //= mul1g.\nby exists 1%R; rewrite ?inE.\nQed."
}
{
  "statement": "Lemma isog_abelian_type G H : isog G H -> abelian_type G = abelian_type H.\n",
  "proof": "Proof.\npose lnO p n gT (A : {set gT}) := logn p #|'Ohm_n.+1(A) : 'Ohm_n(A)|.\npose lni i p gT (A : {set gT}) := \\max_(e < logn p #|A| | i < lnO p e _ A) e.+1.\nsuffices{G} nth_abty gT (G : {group gT}) i:\n    abelian G -> i < size (abelian_type G) ->\n  nth 1%N (abelian_type G) i = (\\prod_(p < #|G|.+1) p ^ lni i p _ G)%N.\n- move=> isoGH; case cGG: (abelian G); last first.\n    rewrite /abelian_type -(prednK (cardG_gt0 G)) -(prednK (cardG_gt0 H)) /=.\n    by rewrite {1}(genGid G) {1}(genGid H) -(isog_abelian isoGH) cGG.\n  have cHH: abelian H by rewrite -(isog_abelian isoGH).\n  have eq_sz: size (abelian_type G) = size (abelian_type H).\n    by rewrite !size_abelian_type ?(isog_rank isoGH).\n  apply: (@eq_from_nth _ 1%N) => // i lt_i_G; rewrite !nth_abty // -?eq_sz //.\n  rewrite /lni (card_isog isoGH); apply: eq_bigr => p _; congr (p ^ _)%N.\n  apply: eq_bigl => e; rewrite /lnO -!divgS ?(Ohm_leq _ (leqnSn _)) //=.\n  by have:= card_isog (gFisog _ isoGH) => /= eqF; rewrite !eqF.\nmove=> cGG.\nhave (p): path leq 0 (map (logn p) (rev (abelian_type G))).\n  move: (abelian_type_gt1 G) (abelian_type_dvdn_sorted G).\n  case: abelian_type => //= m t; rewrite rev_cons map_rcons.\n  elim: t m => //= n t IHt m /andP[/ltnW m_gt0 nt_gt1].\n  rewrite -cats1 cat_path rev_cons map_rcons last_rcons /=.\n  by case/andP=> /dvdn_leq_log-> // /IHt->.\nhave{cGG} [b defG <- b_sorted] := abelian_structure cGG.\nrewrite size_map => ltib; rewrite (nth_map 1 _ _ ltib); set x := nth 1 b i.\nhave Gx: x \\in G.\n  have: x \\in b by rewrite mem_nth.\n  rewrite -(bigdprodWY defG); case/splitPr=> bl br.\n  by rewrite mem_gen // big_cat big_cons !inE cycle_id orbT.\nhave lexG: #[x] <= #|G| by rewrite dvdn_leq ?order_dvdG.\nrewrite -[#[x]]partn_pi // (widen_partn _ lexG) big_mkord big_mkcond.\napply: eq_bigr => p _; transitivity (p ^ logn p #[x])%N.\n  by rewrite -logn_gt0; case: posnP => // ->.\nsuffices lti_lnO e: (i < lnO p e _ G) = (e < logn p #[x]).\n  congr (p ^ _)%N; apply/eqP; rewrite eqn_leq andbC; apply/andP; split.\n    by apply/bigmax_leqP=> e; rewrite lti_lnO.\n  have [-> //|logx_gt0] := posnP (logn p #[x]).\n  have lexpG: (logn p #[x]).-1 < logn p #|G|.\n    by rewrite prednK // dvdn_leq_log ?order_dvdG.\n  by rewrite (bigmax_sup (Ordinal lexpG)) ?(prednK, lti_lnO).\nrewrite /lnO -(count_logn_dprod_cycle _ _ defG).\ncase: (ltnP e) (b_sorted p) => [lt_e_x | le_x_e].\n  rewrite -(cat_take_drop i.+1 b) -map_rev rev_cat !map_cat cat_path.\n  case/andP=> _ ordb; rewrite count_cat ((count _ _ =P i.+1) _) ?leq_addr //.\n  rewrite -{2}(size_takel ltib) -all_count.\n  move: ordb; rewrite (take_nth 1 ltib) -/x rev_rcons all_rcons /= lt_e_x.\n  case/andP=> _ /=; move/(order_path_min leq_trans); apply: contraLR.\n  rewrite -!has_predC !has_map; case/hasP=> y b_y /= le_y_e; apply/hasP.\n  by exists y; rewrite ?mem_rev //=; apply: contra le_y_e; apply: leq_trans.\nrewrite -(cat_take_drop i b) -map_rev rev_cat !map_cat cat_path.\ncase/andP=> ordb _; rewrite count_cat -{1}(size_takel (ltnW ltib)) ltnNge.\nrewrite addnC ((count _ _ =P 0) _) ?count_size //.\nrewrite eqn0Ngt -has_count; apply/hasPn=> y b_y /=; rewrite -leqNgt.\napply: leq_trans le_x_e; have ->: x = last x (rev (drop i b)).\n  by rewrite (drop_nth 1 ltib) rev_cons last_rcons.\nrewrite -mem_rev in b_y; case/splitPr: (rev _) / b_y ordb => b1 b2.\nrewrite !map_cat cat_path last_cat /=; case/and3P=> _ _.\nmove/(order_path_min leq_trans); case/lastP: b2 => // b3 x'.\nby move/allP; apply; rewrite ?map_f ?last_rcons ?mem_rcons ?mem_head.\nQed."
}
{
  "statement": "Lemma setXn_sol n (gT : 'I_n -> finGroupType) (G : forall i, {group gT i}) :\n  (forall i, solvable (G i)) -> solvable (setXn G).\n",
  "proof": "Proof.\nelim: n => [|n IHn] in gT G * => solG; first by rewrite groupX0 solvable1.\npose gT' (i : 'I_n) := gT (lift ord0 i).\npose prod_group_gT := [the finGroupType of {dffun forall i, gT i}].\npose prod_group_gT' := [the finGroupType of {dffun forall i, gT' i}].\npose f (x : prod_group_gT) : prod_group_gT' := [ffun i => x (lift ord0 i)].\nhave fm : morphic (setXn G) f.\n  apply/'forall_implyP => -[a b]; rewrite !inE/=.\n  by move=> /andP[/forallP aG /forallP bG]; apply/eqP/ffunP => i; rewrite !ffunE.\nrewrite (@series_sol _ [group of setXn G] ('ker (morphm fm))) ?ker_normal//=.\nrewrite (isog_sol (first_isog _))/=.\nhave -> : (morphm fm @* setXn G)%g = setXn (fun i => G (lift ord0 i)).\n  apply/setP => v; rewrite !inE morphimEdom; apply/idP/forallP => /=.\n    move=> /imsetP[/=x]; rewrite inE => /forallP/= xG ->.\n    by move=> i; rewrite morphmE ffunE xG.\n  move=> vG; apply/imsetP.\n  pose w := [ffun i : 'I_n.+1 =>\n             match unliftP ord0 i return (gT i) : Type with\n             | UnliftSome j i_eq => ecast i (gT i) (esym i_eq) (v j)\n             | UnliftNone i0 => 1%g\n             end].\n  have wl i : w (lift ord0 i) = v i.\n    rewrite ffunE; case: unliftP => //= j elij.\n    have eij : i = j by case: elij; apply/val_inj.\n    by rewrite [elij](eq_irrelevance _ (congr1 _ eij)); case: _ / eij.\n  have w0 : w ord0 = 1%g by rewrite ffunE; case: unliftP.\n  exists w; last by apply/ffunP => i; rewrite morphmE ffunE/= wl.\n  apply/setXnP => i.\n  case: (unliftP ord0 i) => [j|]->; rewrite ?wl ?w0 ?vG//.\nrewrite IHn ?andbT//; last by move=> i; apply: solG.\npose k (x : gT ord0) : prod_group_gT :=\n  [ffun i : 'I_n.+1 =>\n     match (ord0 =P i) return (gT i) : Type with\n     | ReflectT P => ecast i (gT i) P x\n     | _ => 1%g\n     end].\nhave km : morphic (G ord0) k.\n  apply/'forall_implyP => -[a b]; rewrite !inE/= => /andP[aG bG].\n  apply/eqP/ffunP => i; rewrite !ffunE; case: eqP => //; rewrite ?mulg1//.\n  by case: _ /.\nsuff -> : ('ker (morphm fm) = morphm km @* G ord0)%g by rewrite morphim_sol.\napply/setP => x; rewrite morphimEdom; apply/idP/imsetP => [xker|].\n  exists (x ord0).\n     by have := dom_ker xker; rewrite inE => /forallP/(_ ord0).\n  rewrite /= morphmE; apply/ffunP => i; rewrite ffunE; case: eqP => //=.\n    by case: _ /.\n  move/eqP; rewrite eq_sym; have /mker/= := xker; rewrite morphmE => /ffunP.\n  by case: (@unliftP _ ord0 i) => [j|] ->//= /(_ j); rewrite !ffunE.\nmove=> [x0 xG0 -> /=]; rewrite morphmE; apply/kerP; rewrite ?inE.\n  by apply/forallP => i; rewrite ffunE; case: eqP => //=; case: _ /.\nby rewrite /= morphmE; apply/ffunP => i; rewrite !ffunE; case: eqP.\nQed."
}
{
  "statement": "Theorem extend_linear_char_from_Sylow G N (lambda : 'CF(N)) :\n    N <| G -> lambda \\is a linear_char -> G \\subset 'I[lambda] ->\n    (forall p, p \\in \\pi('o(lambda)%CF) ->\n       exists2 Hp : {group gT},\n         [/\\ N \\subset Hp, Hp \\subset G & p.-Sylow(G / N) (Hp / N)%g]\n       & exists u, 'Res 'chi[Hp]_u = lambda) ->\n  exists u, 'Res[N, G] 'chi_u = lambda.\n",
  "proof": "Proof.\nset m := 'o(lambda)%CF => nsNG lam_lin IGlam p_ext_lam.\nhave [sNG nNG] := andP nsNG; have linN := @cfRes_lin_lin _ _ N.\nwlog [p p_lam]: lambda @m lam_lin IGlam p_ext_lam /\n  exists p : nat, \\pi(m) =i (p : nat_pred).\n- move=> IHp; have [linG [cf [inj_cf _ lin_cf onto_cf]]] := lin_char_group N.\n  case=> cf1 cfM cfX _ cf_order; have [lam cf_lam] := onto_cf _ lam_lin.\n  pose mu p := cf lam.`_p; pose pi_m p := p \\in \\pi(m).\n  have Dm: m = #[lam] by rewrite /m cfDet_order_lin // cf_lam cf_order.\n  have Dlambda: lambda = \\prod_(p < m.+1 | pi_m p) mu p.\n    rewrite -(big_morph cf cfM cf1) big_mkcond cf_lam /pi_m Dm; congr (cf _).\n    rewrite -{1}[lam]prod_constt big_mkord; apply: eq_bigr => p _.\n    by case: ifPn => // p'lam; apply/constt1P; rewrite /p_elt p'natEpi.\n  have lin_mu p: mu p \\is a linear_char by rewrite /mu cfX -cf_lam rpredX.\n  suffices /fin_all_exists [u uNlam] (p : 'I_m.+1):\n    exists u, pi_m p -> 'Res[N, G] 'chi_u = mu p.\n  - pose nu := \\prod_(p < m.+1 | pi_m p) 'chi_(u p).\n    have lin_nu: nu \\is a linear_char.\n      by apply: rpred_prod => p m_p; rewrite linN ?irr_char ?uNlam.\n    have /irrP[u1 Dnu] := lin_char_irr lin_nu.\n    by exists u1; rewrite Dlambda -Dnu rmorph_prod; apply: eq_bigr.\n  have [m_p | _] := boolP (pi_m p); last by exists 0.\n  have o_mu: \\pi('o(mu p)%CF) =i (p : nat_pred).\n    rewrite cfDet_order_lin // cf_order orderE /=.\n    have [|pr_p _ [k ->]] := pgroup_pdiv (p_elt_constt p lam).\n      by rewrite cycle_eq1 (sameP eqP constt1P) /p_elt p'natEpi // negbK -Dm.\n    by move=> q; rewrite pi_of_exp // pi_of_prime.\n  have IGmu: G \\subset 'I[mu p].\n    rewrite (subset_trans IGlam) // /mu cfX -cf_lam.\n    elim: (chinese _ _ _ _) => [|k IHk]; first by rewrite inertia1 norm_inertia.\n    by rewrite exprS (subset_trans _ (inertia_mul _ _)) // subsetIidl.\n  have [q||u] := IHp _ (lin_mu p) IGmu; [ | by exists p | by exists u].\n  rewrite o_mu => /eqnP-> {q}.\n  have [Hp sylHp [u uNlam]] := p_ext_lam p m_p; exists Hp => //.\n  rewrite /mu cfX -cf_lam -uNlam -rmorphXn /=; set nu := _ ^+ _.\n  have /lin_char_irr/irrP[v ->]: nu \\is a linear_char; last by exists v.\n  by rewrite rpredX // linN ?irr_char ?uNlam.\nhave pi_m_p: p \\in \\pi(m) by rewrite p_lam !inE.\nhave [pr_p mgt0]: prime p /\\ (m > 0)%N.\n  by have:= pi_m_p; rewrite mem_primes => /and3P[].\nhave p_m: p.-nat m by rewrite -(eq_pnat _ p_lam) pnat_pi.\nhave{p_ext_lam} [H [sNH sHG sylHbar] [v vNlam]] := p_ext_lam p pi_m_p.\nhave co_p_GH: coprime p #|G : H|.\n  rewrite -(index_quotient_eq _ sHG nNG) ?subIset ?sNH ?orbT //.\n  by rewrite (pnat_coprime (pnat_id pr_p)) //; have [] := and3P sylHbar.\nhave lin_v: 'chi_v \\is a linear_char by rewrite linN ?irr_char ?vNlam.\npose nuG := 'Ind[G] 'chi_v.\nhave [c vGc co_p_f]: exists2 c, c \\in irr_constt nuG & ~~ (p %| 'chi_c 1%g)%C.\n  apply/exists_inP; rewrite -negb_forall_in.\n  apply: contraL co_p_GH => /forall_inP p_dv_v1.\n  rewrite prime_coprime // negbK -dvdC_nat -[rhs in (_ %| rhs)%C]mulr1.\n  rewrite -(lin_char1 lin_v) -cfInd1 // ['Ind _]cfun_sum_constt /=.\n  rewrite sum_cfunE rpred_sum // => i /p_dv_v1 p_dv_chi1i.\n  rewrite cfunE dvdC_mull // intr_nat //.\n  by rewrite Cnat_cfdot_char ?cfInd_char ?irr_char.\npose f := Num.truncn ('chi_c 1%g); pose b := (egcdn f m).1.\nhave fK: f%:R = 'chi_c 1%g by rewrite truncnK ?Cnat_irr1.\nhave fb_mod_m: f * b = 1 %[mod m].\n  have co_m_f: coprime m f.\n    by rewrite (pnat_coprime p_m) ?p'natE // -dvdC_nat CdivE fK.\n  by rewrite -(chinese_modl co_m_f 1 0) /chinese !mul0n addn0 mul1n.\nhave /irrP[s Dlam] := lin_char_irr lam_lin.\nhave cHv: v \\in irr_constt ('Res[H] 'chi_c) by rewrite -constt_Ind_Res.\nhave{cHv} cNs: s \\in irr_constt ('Res[N] 'chi_c).\n  rewrite -(cfResRes _ sNH) ?(constt_Res_trans _ cHv) ?cfRes_char ?irr_char //.\n  by rewrite vNlam Dlam constt_irr !inE.\nhave DcN: 'Res[N] 'chi_c = lambda *+ f.\n  have:= Clifford_Res_sum_cfclass nsNG cNs.\n  rewrite cfclass_invariant -Dlam // big_seq1 Dlam => DcN.\n  have:= cfRes1 N 'chi_c; rewrite DcN cfunE -Dlam lin_char1 // mulr1 => ->.\n  by rewrite -scaler_nat fK.\nhave /lin_char_irr/irrP[d Dd]: cfDet 'chi_c ^+ b \\is a linear_char.\n  by rewrite rpredX // cfDet_lin_char.\nexists d; rewrite -{}Dd rmorphXn /= -cfDetRes ?irr_char // DcN.\nrewrite cfDetMn ?lin_charW // -exprM cfDet_id //.\nrewrite -(expr_mod _ (exp_cforder _)) -cfDet_order_lin // -/m.\nby rewrite fb_mod_m /m cfDet_order_lin // expr_mod ?exp_cforder.\nQed."
}
{
  "statement": "Lemma Frobenius_kernel_exists :\n  [Frobenius G with complement H] -> {K : {group gT} | [Frobenius G = K ><| H]}.\n",
  "proof": "Proof.\nmove=> frobG; have [_ ntiHG] := andP frobG.\nhave [[_ sHG regGH][_ tiHG /eqP defNH]] := (normedTI_memJ_P ntiHG, and3P ntiHG).\nsuffices /sigW[K defG]: exists K, gval K ><| H == G by exists K; apply/andP.\npose K1 := G :\\: cover (H^# :^: G).\nhave oK1: #|K1| = #|G : H|.\n  rewrite cardsD (setIidPr _); last first.\n    rewrite cover_imset; apply/bigcupsP=> x Gx.\n    by rewrite sub_conjg conjGid ?groupV // (subset_trans (subsetDl _ _)).\n  rewrite (cover_partition (partition_normedTI ntiHG)) -(Lagrange sHG).\n  by rewrite (card_support_normedTI ntiHG) (cardsD1 1%g) group1 mulSn addnK.\nsuffices extG i: {j | {in H, 'chi[G]_j =1 'chi[H]_i} & K1 \\subset cfker 'chi_j}.\n  pose K := [group of \\bigcap_i cfker 'chi_(s2val (extG i))].\n  have nKH: H \\subset 'N(K).\n    by apply/norms_bigcap/bigcapsP=> i _; apply: subset_trans (cfker_norm _).\n  have tiKH: K :&: H = 1%g.\n    apply/trivgP; rewrite -(TI_cfker_irr H) /= setIC; apply/bigcapsP=> i _.\n    apply/subsetP=> x /setIP[Hx /bigcapP/(_ i isT)/=]; rewrite !cfkerEirr !inE.\n    by case: (extG i) => /= j def_j _; rewrite !def_j.\n  exists K; rewrite sdprodE // eqEcard TI_cardMg // mul_subG //=; last first.\n    by rewrite (bigcap_min (0 : Iirr H)) ?cfker_sub.\n  rewrite -(Lagrange sHG) mulnC leq_pmul2r // -oK1 subset_leq_card //.\n  by apply/bigcapsP=> i _; case: (extG i).\ncase i0: (i == 0).\n  exists 0 => [x Hx|]; last by rewrite irr0 cfker_cfun1 subsetDl.\n  by rewrite (eqP i0) !irr0 !cfun1E // (subsetP sHG) ?Hx.\nhave ochi1: '['chi_i, 1] = 0 by rewrite -irr0 cfdot_irr i0.\npose a := 'chi_i 1%g; have Za: a \\in Num.int by rewrite intrE Cnat_irr1.\npose theta := 'chi_i - a%:A; pose phi := 'Ind[G] theta + a%:A.\nhave /cfun_onP theta0: theta \\in 'CF(H, H^#).\n  by rewrite cfunD1E !cfunE cfun11 mulr1 subrr.\nhave RItheta: 'Res ('Ind[G] theta) = theta.\n  apply/cfun_inP=> x Hx; rewrite cfResE ?cfIndE // (big_setID H) /= addrC.\n  apply: canLR (mulKf (neq0CG H)) _; rewrite (setIidPr sHG) mulr_natl.\n  rewrite big1 ?add0r => [|y /setDP[/regGH tiHy H'y]]; last first.\n    have [-> | ntx] := eqVneq x 1%g; first by rewrite conj1g theta0 ?inE ?eqxx.\n    by rewrite theta0 ?tiHy // !inE ntx.\n  by rewrite -sumr_const; apply: eq_bigr => y Hy; rewrite cfunJ.\nhave ophi1: '[phi, 1] = 0.\n  rewrite cfdotDl -cfdot_Res_r cfRes_cfun1 // cfdotBl !cfdotZl !cfnorm1.\n  by rewrite ochi1 add0r addNr.\nhave{ochi1} n1phi: '[phi] = 1.\n  have: '[phi - a%:A] = '[theta] by rewrite addrK -cfdot_Res_l RItheta.\n  rewrite !cfnormBd ?cfnormZ ?cfdotZr ?ophi1 ?ochi1 ?mulr0 //.\n  by rewrite !cfnorm1 cfnorm_irr => /addIr.\nhave Zphi: phi \\in 'Z[irr G].\n  by rewrite rpredD ?cfInd_vchar ?rpredB ?irr_vchar // scale_zchar ?rpred1.\nhave def_phi: {in H, phi =1 'chi_i}.\n  move=> x Hx /=; rewrite !cfunE -[_ x](cfResE _ sHG) ?RItheta //.\n  by rewrite !cfunE !cfun1E ?(subsetP sHG) ?Hx ?subrK.\nhave [j def_chi_j]: {j | 'chi_j = phi}.\n  apply/sig_eqW; have [[] [j]] := vchar_norm1P Zphi n1phi; last first.\n    by rewrite scale1r; exists j.\n  move/cfunP/(_ 1%g)/eqP; rewrite scaleN1r def_phi // cfunE -addr_eq0 eq_le.\n  by rewrite lt_geF // ltr_pDl ?irr1_gt0.\nexists j; rewrite ?cfkerEirr def_chi_j //; apply/subsetP => x /setDP[Gx notHx].\nrewrite inE cfunE def_phi // cfunE -/a cfun1E // Gx mulr1 cfIndE //.\nrewrite big1 ?mulr0 ?add0r // => y Gy; apply/theta0/(contra _ notHx) => Hxy.\nby rewrite -(conjgK y x) cover_imset -class_supportEr imset2_f ?groupV.\nQed."
}
{
  "statement": "Lemma split1_extraspecial x :\n    x \\in G :\\: 'Z(G) ->\n  {E : {group gT} & {R : {group gT} |\n    [/\\ #|E| = (p ^ 3)%N /\\ #|R| = #|G| %/ p ^ 2,\n        E \\* R = G /\\ E :&: R = 'Z(E),\n        'Z(E) = 'Z(G) /\\ 'Z(R) = 'Z(G),\n        extraspecial E /\\ x \\in E\n      & if abelian R then R :=: 'Z(G) else extraspecial R]}}.\n",
  "proof": "Proof.\ncase/setDP=> Gx notZx; rewrite inE Gx /= in notZx.\nhave [[defPhiG defG'] prZ] := esG.\nhave maxCx: maximal 'C_G[x] G.\n  by rewrite subcent1_extraspecial_maximal // inE notZx.\npose y := repr (G :\\: 'C[x]).\nhave [Gy not_cxy]: y \\in G /\\ y \\notin 'C[x].\n  move/maxgroupp: maxCx => /properP[_ [t Gt not_cyt]].\n  by apply/setDP; apply: (mem_repr t); rewrite !inE Gt andbT in not_cyt *.\npose E := <[x]> <*> <[y]>; pose R := 'C_G(E).\nexists [group of E]; exists [group of R] => /=.\nhave sEG: E \\subset G by rewrite join_subG !cycle_subG Gx.\nhave [Ex Ey]: x \\in E /\\ y \\in E by rewrite !mem_gen // inE cycle_id ?orbT.\nhave sZE: 'Z(G) \\subset E.\n  rewrite (('Z(G) =P E^`(1)) _) ?der_sub // eqEsubset -{2}defG' dergS // andbT.\n  apply: contraR not_cxy => /= not_sZE'.\n  rewrite (sameP cent1P commgP) -in_set1 -[[set 1]](prime_TIg prZ not_sZE').\n  by rewrite /= -defG' inE !mem_commg.\nhave ziER: E :&: R = 'Z(E) by rewrite setIA (setIidPl sEG).\nhave cER: R \\subset 'C(E) by rewrite subsetIr.\nhave iCxG: #|G : 'C_G[x]| = p by apply: p_maximal_index.\nhave maxR: maximal R 'C_G[x].\n  rewrite /R centY !cent_cycle setIA.\n  rewrite subcent1_extraspecial_maximal ?subsetIl // inE Gy andbT -sub_cent1.\n  by apply/subsetPn; exists x; rewrite 1?cent1C // inE Gx cent1id.\nhave sRCx: R \\subset 'C_G[x] by rewrite -cent_cycle setIS ?centS ?joing_subl.\nhave sCxG: 'C_G[x] \\subset G by rewrite subsetIl.\nhave sRG: R \\subset G by rewrite subsetIl.\nhave iRCx: #|'C_G[x] : R| = p by rewrite (p_maximal_index (pgroupS sCxG pG)).\nhave defG: E * R = G.\n  rewrite -cent_joinEr //= -/R joingC joingA.\n  have cGx_x: <[x]> \\subset 'C_G[x] by rewrite cycle_subG inE Gx cent1id.\n  have nsRcx := p_maximal_normal (pgroupS sCxG pG) maxR.\n  rewrite (norm_joinEr (subset_trans cGx_x (normal_norm nsRcx))).\n  rewrite (mulg_normal_maximal nsRcx) //=; last first.\n    by rewrite centY !cent_cycle cycle_subG !in_setI Gx cent1id cent1C.\n  have nsCxG := p_maximal_normal pG maxCx.\n  have syG: <[y]> \\subset G by rewrite cycle_subG.\n  rewrite (norm_joinEr (subset_trans syG (normal_norm nsCxG))).\n  by rewrite (mulg_normal_maximal nsCxG) //= cycle_subG inE Gy.\nhave defZR: 'Z(R) = 'Z(G) by rewrite -['Z(R)]setIA -centM defG.\nhave defZE: 'Z(E) = 'Z(G).\n  by rewrite -defG -center_prod ?mulGSid //= -ziER subsetI center_sub defZR sZE.\nhave [n oG] := p_natP pG.\nhave n_gt1: n > 1.\n   by rewrite ltnW // -(@leq_exp2l p) // -oG min_card_extraspecial.\nhave oR: #|R| = (p ^ n.-2)%N.\n  apply/eqP; rewrite -(divg_indexS sRCx) iRCx /= -(divg_indexS sCxG) iCxG /= oG.\n  by rewrite -{1}(subnKC n_gt1) subn2 !expnS !mulKn.\nhave oE: #|E| = (p ^ 3)%N.\n  apply/eqP; rewrite -(@eqn_pmul2r #|R|) ?cardG_gt0 // mul_cardG defG ziER.\n  by rewrite defZE oZ oG -{1}(subnKC n_gt1) oR -expnSr -expnD subn2.\nrewrite cprodE // oR oG -expnB ?subn2 //; split=> //.\n  by split=> //; apply: card_p3group_extraspecial _ oE _; rewrite // defZE.\ncase: ifP => [cRR | not_cRR]; first by rewrite -defZR (center_idP _).\nsplit; rewrite /special defZR //.\nhave ntR': R^`(1) != 1 by rewrite (sameP eqP commG1P) -abelianE not_cRR.\nhave pR: p.-group R := pgroupS sRG pG.\nhave pR': p.-group R^`(1) := pgroupS (der_sub 1 _) pR.\nhave defR': R^`(1) = 'Z(G).\n  apply/eqP; rewrite eqEcard -{1}defG' dergS //= oZ.\n  by have [_ _ [k ->]]:= pgroup_pdiv pR' ntR'; rewrite (leq_exp2l 1).\nsplit=> //; apply/eqP; rewrite eqEsubset -{1}defPhiG -defR' (PhiS pG) //=.\nby rewrite (Phi_joing pR) joing_subl.\nQed."
}
{
  "statement": "Lemma trans_prim_astab x :\n    x \\in S -> [transitive G, on S | to] ->\n  [primitive G, on S | to] = maximal_eq 'C_G[x | to] G.\n",
  "proof": "Proof.\nmove=> Sx trG; rewrite /primitive trG negb_exists.\napply/forallP/maximal_eqP=> /= [primG | [_ maxCx] Q].\n  split=> [|H sCH sHG]; first exact: subsetIl.\n  pose X := orbit to H x; pose Q := orbit (to^*)%act G X.\n  have Xx: x \\in X by apply: orbit_refl.\n  have defH: 'N_(G)(X | to) = H.\n    have trH: [transitive H, on X | to] by apply/imsetP; exists x.\n    have sHN: H \\subset 'N_G(X | to) by rewrite subsetI sHG atrans_acts.\n    move/(subgroup_transitiveP Xx sHN): (trH) => /= <-.\n      by rewrite mulSGid //= setIAC subIset ?sCH.\n    apply/imsetP; exists x => //; apply/eqP.\n    by rewrite eqEsubset imsetS // acts_sub_orbit ?subsetIr.\n  have [|/proper_card oCH] := eqVproper sCH; [by left | right].\n  apply/eqP; rewrite eqEcard sHG leqNgt.\n  apply: contra {primG}(primG Q) => oHG; apply/and3P; split; last first.\n  - rewrite card_orbit astab1_set defH -(@ltn_pmul2l #|H|) ?Lagrange // muln1.\n    rewrite oHG -(@ltn_pmul2l #|H|) ?Lagrange // -(card_orbit_stab to G x).\n    by rewrite -(atransP trG x Sx) mulnC card_orbit ltn_pmul2r.\n  - by apply/actsP=> a Ga Y; apply/orbit_transl/mem_orbit.\n  apply/and3P; split; last 1 first.\n  - rewrite orbit_sym; apply/imsetP=> [[a _]] /= defX.\n    by rewrite defX /setact imset0 inE in Xx.\n  - apply/eqP/setP=> y; apply/bigcupP/idP=> [[_ /imsetP[a Ga ->]] | Sy].\n      case/imsetP=> _ /imsetP[b Hb ->] ->.\n      by rewrite !(actsP (atrans_acts trG)) //; apply: subsetP Hb.\n    case: (atransP2 trG Sx Sy) => a Ga ->.\n    by exists ((to^*)%act X a); apply: imset_f; rewrite // orbit_refl.\n  apply/trivIsetP=> _ _ /imsetP[a Ga ->] /imsetP[b Gb ->].\n  apply: contraR => /exists_inP[_ /imsetP[_ /imsetP[a1 Ha1 ->] ->]].\n  case/imsetP=> _ /imsetP[b1 Hb1 ->] /(canLR (actK _ _)) /(canLR (actK _ _)).\n  rewrite -(canF_eq (actKV _ _)) -!actM (sameP eqP astab1P) => /astab1P Cab.\n  rewrite astab1_set (subsetP (subsetIr G _)) //= defH.\n  rewrite -(groupMr _ (groupVr Hb1)) -mulgA -(groupMl _ Ha1).\n  by rewrite (subsetP sCH) // inE Cab !groupM ?groupV // (subsetP sHG).\napply/and3P=> [[/and3P[/eqP defS tIQ ntQ]]]; set sto := (to^*)%act => actQ.\nrewrite !ltnNge -negb_or => /orP[].\npose X := pblock Q x; have Xx: x \\in X by rewrite mem_pblock defS.\nhave QX: X \\in Q by rewrite pblock_mem ?defS.\nhave toX Y a: Y \\in Q -> a \\in G -> to x a \\in Y -> sto X a = Y.\n  move=> QY Ga Yxa; rewrite -(contraNeq (trivIsetP tIQ Y (sto X a) _ _)) //.\n    by rewrite (actsP actQ).\n  by apply/existsP; exists (to x a); rewrite /= Yxa; apply: imset_f.\nhave defQ: Q = orbit (to^*)%act G X.\n  apply/eqP; rewrite eqEsubset andbC acts_sub_orbit // QX.\n  apply/subsetP=> Y QY.\n  have /set0Pn[y Yy]: Y != set0 by apply: contraNneq ntQ => <-.\n  have Sy: y \\in S by rewrite -defS; apply/bigcupP; exists Y.\n  have [a Ga def_y] := atransP2 trG Sx Sy.\n  by apply/imsetP; exists a; rewrite // (toX Y) // -def_y.\nrewrite defQ card_orbit; case: (maxCx 'C_G[X | sto]%G) => /= [||->|->].\n- apply/subsetP=> a /setIP[Ga cxa]; rewrite inE Ga /=.\n  by apply/astab1P; rewrite (toX X) // (astab1P cxa).\n- exact: subsetIl.\n- by right; rewrite -card_orbit (atransP trG).\nby left; rewrite indexgg.\nQed."
}
{
  "statement": "Lemma mx_JordanHolder U V compU compV :\n  let m := size U in (last 0 U :=: last 0 V)%MS ->\n  m = size V  /\\ (exists p : 'S_m, forall i : 'I_m,\n     mx_rsim (@series_repr U i compU) (@series_repr V (p i) compV)).\n",
  "proof": "Proof.\nmove Dr: {-}(size U) => r; move/eqP in Dr.\nelim: r U V Dr compU compV => /= [|r IHr] U V.\n  move/nilP->; case/lastP: V => [|V Vm] /= ? compVm; rewrite ?last_rcons => Vm0.\n    by split=> //; exists 1%g; case.\n  by case/mx_series_rcons: (compVm) => _ _ []; rewrite -(lt_eqmx Vm0) ltmx0.\ncase/lastP: U => // [U Um]; rewrite size_rcons eqSS => szUr compUm.\ncase/mx_series_rcons: (compUm); set Um' := last 0 U => compU modUm maxUm.\ncase/lastP: V => [|V Vm] compVm; rewrite ?last_rcons ?size_rcons /= => eqUVm.\n  by case/mx_series_rcons: (compUm) => _ _ []; rewrite (lt_eqmx eqUVm) ltmx0.\ncase/mx_series_rcons: (compVm); set Vm' := last 0 V => compV modVm maxVm.\nhave [modUm' modVm']: modG Um' * modG Vm' := (last_mod compU, last_mod compV).\npose i_m := @ord_max (size U).\nhave [eqUVm' | neqUVm'] := altP (@eqmxP _ _ _ _ Um' Vm').\n  have [szV [p sim_p]] := IHr U V szUr compU compV eqUVm'.\n  split; first by rewrite szV.\n  exists (lift_perm i_m i_m p) => i; case: (unliftP i_m i) => [j|] ->{i}.\n    apply: rsimT (rsimC _) (rsimT (sim_p j) _).\n      by rewrite lift_max; apply: rsim_rcons.\n    by rewrite lift_perm_lift lift_max; apply: rsim_rcons; rewrite -szV.\n  have simUVm := section_eqmx modUm' modVm' modUm modVm eqUVm' eqUVm.\n  apply: rsimT (rsimC _) (rsimT simUVm _); first exact: rsim_last.\n  by rewrite lift_perm_id /= szV; apply: rsim_last.\nhave maxVUm: max_submod Vm' Um by apply: max_submod_eqmx (eqmx_sym _) maxVm.\nhave:= mx_butterfly modUm' modVm' modUm neqUVm' maxUm maxVUm.\nmove: (capmx_module _ _); set Wm := (Um' :&: Vm')%MS => modWm [maxWUm simWVm].\nhave:= mx_butterfly modVm' modUm' modUm _ maxVUm maxUm.\nmove: (capmx_module _ _); rewrite andbC capmxC -/Wm => modWmV [// | maxWVm].\nrewrite {modWmV}(bool_irrelevance modWmV modWm) => simWUm.\nhave [W compW lastW] := mx_JordanHolder_exists compU modWm maxWUm.\nhave compWU: mx_series (rcons W Um') by apply/mx_series_rcons; rewrite lastW.\nhave compWV: mx_series (rcons W Vm') by apply/mx_series_rcons; rewrite lastW.\nhave [|szW [pU pUW]] := IHr U _ szUr compU compWU; first by rewrite last_rcons.\nrewrite size_rcons in szW; have ltWU: size W < size U by rewrite -szW.\nhave{IHr} := IHr _ V _ compWV compV; rewrite last_rcons size_rcons -szW.\ncase=> {r szUr}// szV [pV pWV]; split; first by rewrite szV.\npose j_m := Ordinal ltWU; pose i_m' := lift i_m j_m.\nexists (lift_perm i_m i_m pU * tperm i_m i_m' * lift_perm i_m i_m pV)%g => i.\nrewrite !permM; case: (unliftP i_m i) => [j {simWUm}|] ->{i}; last first.\n  rewrite lift_perm_id tpermL lift_perm_lift lift_max {simWVm}.\n  apply: rsimT (rsimT (pWV j_m) _); last by apply: rsim_rcons; rewrite -szV.\n  apply: rsimT (rsimC _) {simWUm}(rsimT simWUm _); first exact: rsim_last.\n  by rewrite -lastW in modWm *; apply: rsim_last.\napply: rsimT (rsimC _) {pUW}(rsimT (pUW j) _).\n  by rewrite lift_max; apply: rsim_rcons.\nrewrite lift_perm_lift; case: (unliftP j_m (pU j)) => [k|] ->{j pU}.\n  rewrite tpermD ?(inj_eq lift_inj) ?neq_lift //.\n  rewrite lift_perm_lift !lift_max; set j := lift j_m k.\n  have ltjW: j < size W by have:= ltn_ord k; rewrite -(lift_max k) /= {1 3}szW.\n  apply: rsimT (rsimT (pWV j) _); last by apply: rsim_rcons; rewrite -szV.\n  by apply: rsimT (rsimC _) (rsim_rcons compW _ _); first apply: rsim_rcons.\napply: rsimT {simWVm}(rsimC (rsimT simWVm _)) _.\n  by rewrite -lastW in modWm *; apply: rsim_last.\nrewrite tpermR lift_perm_id /= szV.\nby apply: rsimT (rsim_last modVm' modVm _); apply: section_eqmx.\nQed."
}
{
  "statement": "Theorem SchurZassenhaus_split gT (G H : {group gT}) :\n  Hall G H -> H <| G -> [splits G, over H].\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n => // n IHn in gT G H * => /ltnSE-Gn hallH nsHG.\nhave [sHG nHG] := andP nsHG.\nhave [-> | [p pr_p pH]] := trivgVpdiv H.\n  by apply/splitsP; exists G; rewrite inE -subG1 subsetIl mul1g eqxx.\nhave [P sylP] := Sylow_exists p H.\ncase nPG: (P <| G); last first.\n  pose N := ('N_G(P))%G; have sNG: N \\subset G by rewrite subsetIl.\n  have eqHN_G: H * N = G by apply: Frattini_arg sylP.\n  pose H' := (H :&: N)%G.\n  have nsH'N: H' <| N.\n    by rewrite /normal subsetIr normsI ?normG ?(subset_trans sNG).\n  have eq_iH: #|G : H| = #|N| %/ #|H'|.\n    rewrite -divgS // -(divnMl (cardG_gt0 H')) mulnC -eqHN_G.\n    by rewrite -mul_cardG (mulnC #|H'|) divnMl // cardG_gt0.\n  have hallH': Hall N H'.\n    rewrite /Hall -divgS subsetIr //= -eq_iH.\n    by case/andP: hallH => _; apply: coprimeSg; apply: subsetIl.\n  have: [splits N, over H'].\n    apply: IHn hallH' nsH'N; apply: {n}leq_trans Gn.\n    rewrite proper_card // properEneq sNG andbT; apply/eqP=> eqNG.\n    by rewrite -eqNG normal_subnorm (subset_trans (pHall_sub sylP)) in nPG.\n  case/splitsP=> K /complP[tiKN eqH'K].\n  have sKN: K \\subset N by rewrite -(mul1g K) -eqH'K mulSg ?sub1set.\n  apply/splitsP; exists K; rewrite inE -subG1; apply/andP; split.\n    by rewrite /= -(setIidPr sKN) setIA tiKN.\n  by rewrite eqEsubset -eqHN_G mulgS // -eqH'K mulGS mulSg ?subsetIl.\npose Z := 'Z(P); pose Gbar := G / Z; pose Hbar := H / Z.\nhave sZP: Z \\subset P by apply: center_sub.\nhave sZH: Z \\subset H by apply: subset_trans (pHall_sub sylP).\nhave sZG: Z \\subset G by apply: subset_trans sHG.\nhave nZG: Z <| G by apply: gFnormal_trans nPG.\nhave nZH: Z <| H by apply: normalS nZG.\nhave nHGbar: Hbar <| Gbar by apply: morphim_normal.\nhave hallHbar: Hall Gbar Hbar by apply: morphim_Hall (normal_norm _) _.\nhave: [splits Gbar, over Hbar].\n  apply: IHn => //; apply: {n}leq_trans Gn; rewrite ltn_quotient //.\n  apply/eqP=> /(trivg_center_pgroup (pHall_pgroup sylP))/eqP.\n  rewrite trivg_card1 (card_Hall sylP) p_part -(expn0 p).\n  by rewrite eqn_exp2l ?prime_gt1 // lognE pH pr_p cardG_gt0.\ncase/splitsP=> Kbar /complP[tiHKbar eqHKbar].\nhave: Kbar \\subset Gbar by rewrite -eqHKbar mulG_subr.\ncase/inv_quotientS=> //= ZK quoZK sZZK sZKG.\nhave nZZK: Z <| ZK by apply: normalS nZG.\nhave cardZK: #|ZK| = (#|Z| * #|G : H|)%N.\n  rewrite -(Lagrange sZZK); congr (_ * _)%N.\n  rewrite -card_quotient -?quoZK; last by case/andP: nZZK.\n  rewrite -(divgS sHG) -(Lagrange sZG) -(Lagrange sZH) divnMl //.\n  rewrite -!card_quotient ?normal_norm //= -/Gbar -/Hbar.\n  by rewrite -eqHKbar (TI_cardMg tiHKbar) mulKn.\nhave: [splits ZK, over Z].\n  rewrite (Gaschutz_split nZZK _ sZZK) ?center_abelian //; last first.\n    rewrite -divgS // cardZK mulKn ?cardG_gt0 //.\n    by case/andP: hallH => _; apply: coprimeSg.\n  by apply/splitsP; exists 1%G; rewrite inE -subG1 subsetIr mulg1 eqxx.\ncase/splitsP=> K /complP[tiZK eqZK].\nhave sKZK: K \\subset ZK by rewrite -(mul1g K) -eqZK mulSg ?sub1G.\nhave tiHK: H :&: K = 1.\n  apply/trivgP; rewrite /= -(setIidPr sKZK) setIA -tiZK setSI //.\n  rewrite -quotient_sub1; last by rewrite subIset 1?normal_norm.\n  by rewrite /= quotientGI //= -quoZK tiHKbar.\napply/splitsP; exists K; rewrite inE tiHK ?eqEcard subxx leqnn /=.\nrewrite mul_subG ?(subset_trans sKZK) //= TI_cardMg //.\nrewrite -(@mulKn #|K| #|Z|) ?cardG_gt0 // -TI_cardMg // eqZK.\nby rewrite cardZK mulKn ?cardG_gt0 // Lagrange.\nQed."
}
{
  "statement": "Lemma Ohm1_cent_max_normal_abelem Z :\n  odd p -> p.-group G -> [max Z | Z <| G & p.-abelem Z] -> 'Ohm_1('C_G(Z)) = Z.\n",
  "proof": "Proof.\nmove=> p_odd pG; set X := 'Ohm_1('C_G(Z)).\ncase/maxgroupP=> /andP[nsZG abelZ] maxZ.\nhave [sZG nZG] := andP nsZG; have [_ cZZ expZp] := and3P abelZ.\nhave{nZG} nsXG: X <| G by rewrite gFnormal_trans ?norm_normalI ?norms_cent.\nhave cZX : X \\subset 'C(Z) by apply/gFsub_trans/subsetIr.\nhave{sZG expZp} sZX: Z \\subset X.\n  rewrite [X](OhmE 1 (pgroupS _ pG)) ?subsetIl ?sub_gen //.\n  apply/subsetP=> x Zx; rewrite !inE  ?(subsetP sZG) ?(subsetP cZZ) //=.\n  by rewrite (exponentP expZp).\nsuffices{sZX} expXp: (exponent X %| p).\n  apply/eqP; rewrite eqEsubset sZX andbT -quotient_sub1 ?cents_norm //= -/X.\n  have pGq: p.-group (G / Z) by rewrite quotient_pgroup.\n  rewrite (TI_center_nil (pgroup_nil pGq)) ?quotient_normal //= -/X setIC.\n  apply/eqP/trivgPn=> [[Zd]]; rewrite inE -!cycle_subG -cycle_eq1 -subG1 /= -/X.\n  case/andP=> /sub_center_normal nsZdG.\n  have{nsZdG} [D defD sZD nsDG] := inv_quotientN nsZG nsZdG; rewrite defD.\n  have sDG := normal_sub nsDG; have nsZD := normalS sZD sDG nsZG.\n  rewrite quotientSGK ?quotient_sub1 ?normal_norm //= -/X => sDX /negP[].\n  rewrite (maxZ D) // nsDG andbA (pgroupS sDG) ?(dvdn_trans (exponentS sDX)) //.\n  have sZZD: Z \\subset 'Z(D) by rewrite subsetI sZD centsC (subset_trans sDX).\n  by rewrite (cyclic_factor_abelian sZZD) //= -defD cycle_cyclic.\npose normal_abelian := [pred A : {group gT} | A <| G & abelian A].\nhave{nsZG cZZ} normal_abelian_Z : normal_abelian Z by apply/andP.\nhave{normal_abelian_Z} [A maxA sZA] := maxgroup_exists normal_abelian_Z.\nhave SCN_A : A \\in 'SCN(G) by apply: max_SCN pG maxA.\nmove/maxgroupp: maxA => /andP[nsAG cAA] {normal_abelian}.\nhave pA := pgroupS (normal_sub nsAG) pG.\nhave{abelZ maxZ nsAG cAA sZA} defA1: 'Ohm_1(A) = Z.\n  have: Z \\subset 'Ohm_1(A) by rewrite -(Ohm1_id abelZ) OhmS.\n  by apply: maxZ; rewrite Ohm1_abelem ?gFnormal_trans.\nhave{SCN_A} sX'A: X^`(1) \\subset A.\n  have sX_CWA1 : X \\subset 'C('Ohm_1(A)) :&: 'C_G(A / 'Ohm_1(A) | 'Q).\n    rewrite subsetI /X -defA1 (Ohm1_stab_Ohm1_SCN_series _ p_odd) //=.\n    by rewrite gFsub_trans ?subsetIr.\n  by apply: subset_trans (der1_stab_Ohm1_SCN_series SCN_A); rewrite commgSS.\npose genXp := [pred U : {group gT} | 'Ohm_1(U) == U & ~~ (exponent U %| p)].\napply/idPn=> expXp'; have genXp_X: genXp [group of X] by rewrite /= Ohm_id eqxx.\nhave{genXp_X expXp'} [U] := mingroup_exists genXp_X; case/mingroupP; case/andP.\nmove/eqP=> defU1 expUp' minU sUX; case/negP: expUp'.\nhave{nsXG} pU := pgroupS (subset_trans sUX (normal_sub nsXG)) pG.\ncase gsetU1: (group_set 'Ldiv_p(U)).\n  by rewrite -defU1 (OhmE 1 pU) gen_set_id // -sub_LdivT subsetIr.\nmove: gsetU1; rewrite /group_set 2!inE group1 expg1n eqxx; case/subsetPn=> xy.\ncase/imset2P=> x y /[!inE] /andP[Ux xp1] /andP[Uy yp1] ->{xy}.\nrewrite groupM //= => nt_xyp; pose XY := <[x]> <*> <[y]>.\nhave{yp1 nt_xyp} defXY: XY = U.\n  have sXY_U: XY \\subset U by rewrite join_subG !cycle_subG Ux Uy.\n  rewrite [XY]minU //= eqEsubset Ohm_sub (OhmE 1 (pgroupS _ pU)) //.\n  rewrite /= joing_idl joing_idr genS; last first.\n    by rewrite subsetI subset_gen subUset !sub1set !inE xp1 yp1.\n  apply: contra nt_xyp => /exponentP-> //.\n  by rewrite groupMl mem_gen // (set21, set22).\nhave: <[x]> <|<| U by rewrite nilpotent_subnormal ?(pgroup_nil pU) ?cycle_subG.\ncase/subnormalEsupport=> [defU | /=].\n  by apply: dvdn_trans (exponent_dvdn U) _; rewrite -defU order_dvdn.\nset V := <<class_support <[x]> U>>; case/andP=> sVU ltVU.\nhave{genXp minU xp1 sVU ltVU} expVp: exponent V %| p.\n  apply: contraR ltVU => expVp'; rewrite [V]minU //= expVp' eqEsubset Ohm_sub.\n  rewrite (OhmE 1 (pgroupS sVU pU)) genS //= subsetI subset_gen class_supportEr.\n  apply/bigcupsP=> z _; apply/subsetP=> v Vv.\n  by rewrite inE -order_dvdn (dvdn_trans (order_dvdG Vv)) // cardJg order_dvdn.\nhave{A pA defA1 sX'A V expVp} Zxy: [~ x, y] \\in Z.\n  rewrite -defA1 (OhmE 1 pA) mem_gen // !inE (exponentP expVp).\n    by rewrite (subsetP sX'A) //= mem_commg ?(subsetP sUX).\n  by rewrite groupMl -1?[x^-1]conjg1 mem_gen // imset2_f // ?groupV cycle_id.\nhave{Zxy sUX cZX} cXYxy: [~ x, y] \\in 'C(XY).\n  by rewrite centsC in cZX; rewrite defXY (subsetP (centS sUX)) ?(subsetP cZX).\nrewrite -defU1 exponent_Ohm1_class2 // nil_class2 -defXY der1_joing_cycles //.\nby rewrite subsetI {1}defXY !cycle_subG groupR.\nQed."
}
{
  "statement": "Theorem Wilson p : p > 1 -> prime p = (p %| ((p.-1)`!).+1).\n",
  "proof": "Proof.\nhave dFact n: 0 < n -> (n.-1)`! = \\prod_(0 <= i < n | i != 0) i.\n  move=> n_gt0; rewrite -big_filter fact_prod; symmetry; apply: congr_big => //.\n  rewrite /index_iota subn1 -[n]prednK //=; apply/all_filterP.\n  by rewrite all_predC has_pred1 mem_iota.\nmove=> lt1p; have p_gt0 := ltnW lt1p.\napply/idP/idP=> [pr_p | dv_pF]; last first.\n  apply/primeP; split=> // d dv_dp; have: d <= p by apply: dvdn_leq.\n  rewrite orbC leq_eqVlt => /orP[-> // | ltdp].\n  have:= dvdn_trans dv_dp dv_pF; rewrite dFact // big_mkord.\n  rewrite (bigD1 (Ordinal ltdp)) /=; last by rewrite -lt0n (dvdn_gt0 p_gt0).\n  by rewrite orbC -addn1 dvdn_addr ?dvdn_mulr // dvdn1 => ->.\npose Fp1 := Ordinal lt1p; pose Fp0 := Ordinal p_gt0.\nhave ltp1p: p.-1 < p by [rewrite prednK]; pose Fpn1 := Ordinal ltp1p.\ncase eqF1n1: (Fp1 == Fpn1); first by rewrite -{1}[p]prednK -1?((1 =P p.-1) _).\nhave toFpP m: m %% p < p by rewrite ltn_mod.\npose toFp := Ordinal (toFpP _); pose mFp (i j : 'I_p) := toFp (i * j).\nhave Fp_mod (i : 'I_p) : i %% p = i by apply: modn_small.\nhave mFpA: associative mFp.\n  by move=> i j k; apply: val_inj; rewrite /= modnMml modnMmr mulnA.\nhave mFpC: commutative mFp by move=> i j; apply: val_inj; rewrite /= mulnC.\nhave mFp1: left_id Fp1 mFp by move=> i; apply: val_inj; rewrite /= mul1n.\nhave mFp1r: right_id Fp1 mFp by move=> i; apply: val_inj; rewrite /= muln1.\npose mFpcM := Monoid.isComLaw.Build 'I_p Fp1 mFp mFpA mFpC mFp1.\npose mFpCL : Monoid.com_law _ := HB.pack mFp mFpcM.\npose mFpM := Monoid.Law.sort mFpCL.\npose vFp (i : 'I_p) := toFp (egcdn i p).1.\nhave vFpV i: i != Fp0 -> mFp (vFp i) i = Fp1.\n  rewrite -val_eqE /= -lt0n => i_gt0; apply: val_inj => /=.\n  rewrite modnMml; case: egcdnP => //= _ km -> _; rewrite {km}modnMDl.\n  suffices: coprime i p by move/eqnP->; rewrite modn_small.\n  rewrite coprime_sym prime_coprime //; apply/negP=> /(dvdn_leq i_gt0).\n  by rewrite leqNgt ltn_ord.\nhave vFp0 i: i != Fp0 -> vFp i != Fp0.\n  by move/vFpV; apply/contra_eq_neq => ->; rewrite -val_eqE /= mul0n mod0n.\nhave vFpK: {in predC1 Fp0, involutive vFp}.\n  move=> i n0i; rewrite /= -[vFp _]mFp1r -(vFpV _ n0i) mFpA.\n  by rewrite vFpV (vFp0, mFp1).\nhave le_pmFp (i : 'I_p) m: i <= p + m.\n  by apply: leq_trans (ltnW _) (leq_addr _ _).\nhave eqFp (i j : 'I_p): (i == j) = (p %| p + i - j).\n  by rewrite -eqn_mod_dvd ?(modnDl, Fp_mod).\nhave vFpId i: (vFp i == i :> nat) = xpred2 Fp1 Fpn1 i.\n  have [->{i} | ni0] := eqVneq i Fp0.\n    by rewrite -!val_eqE /= egcd0n modn_small //= -(subnKC lt1p).\n  rewrite 2!eqFp -Euclid_dvdM // -[_ - p.-1]subSS prednK //.\n  have lt0i: 0 < i by rewrite lt0n.\n  rewrite -addnS addKn -addnBA // mulnDl -{2}(addn1 i) -subn_sqr.\n  rewrite addnBA ?leq_sqr // mulnS -addnA -mulnn -mulnDl.\n  rewrite -(subnK (le_pmFp (vFp i) i)) mulnDl addnCA.\n  rewrite -[1 ^ 2]/(Fp1 : nat) -addnBA // dvdn_addl.\n    by rewrite Euclid_dvdM // -eqFp eq_sym orbC /dvdn Fp_mod eqn0Ngt lt0i.\n  by rewrite -eqn_mod_dvd // Fp_mod modnDl -(vFpV _ ni0).\nsuffices [mod_fact]: toFp (p.-1)`! = Fpn1.\n  by rewrite /dvdn -addn1 -modnDml mod_fact addn1 prednK // modnn.\nrewrite dFact //; rewrite ((big_morph toFp) Fp1 mFpM) //; first last.\n- by apply: val_inj; rewrite /= modn_small.\n- by move=> i j; apply: val_inj; rewrite /= modnMm.\nrewrite big_mkord (eq_bigr id) => [|i _]; last by apply: val_inj => /=.\npose ltv i := vFp i < i; rewrite (bigID ltv) -/mFpM [mFpM _ _]mFpC.\nrewrite (bigD1 Fp1) -/mFpM; last by rewrite [ltv _]ltn_neqAle vFpId.\nrewrite [mFpM _ _]mFp1 (bigD1 Fpn1) -?mFpA -/mFpM; last first.\n  rewrite -lt0n -ltnS prednK // lt1p.\n  by rewrite [ltv _]ltn_neqAle vFpId eqxx orbT eq_sym eqF1n1.\nrewrite (reindex_onto vFp vFp) -/mFpM => [|i]; last by do 3!case/andP; auto.\nrewrite (eq_bigl (xpredD1 ltv Fp0)) => [|i]; last first.\n  rewrite andbC -!andbA -2!negb_or -vFpId orbC -leq_eqVlt -ltnNge.\n  have [->|ni0] := eqVneq i; last by rewrite vFpK // eqxx vFp0.\n  by case: eqP => // ->; rewrite !andbF.\nrewrite -{2}[mFp]/mFpM -[mFpM _ _]big_split -/mFpM.\nby rewrite big1 ?mFp1r //= => i /andP [/vFpV].\nQed."
}
{
  "statement": "Theorem Sylow's_theorem :\n  [/\\ forall P, [max P | p.-subgroup(G) P] = p.-Sylow(G) P,\n      [transitive G, on 'Syl_p(G) | 'JG],\n      forall P, p.-Sylow(G) P -> #|'Syl_p(G)| = #|G : 'N_G(P)|\n   &  prime p -> #|'Syl_p(G)| %% p = 1%N].\n",
  "proof": "Proof.\npose maxp A P := [max P | p.-subgroup(A) P]; pose S := [set P | maxp G P].\npose oG := orbit 'JG%act G.\nhave actS: [acts G, on S | 'JG].\n  apply/subsetP=> x Gx; rewrite 3!inE; apply/subsetP=> P; rewrite 3!inE.\n  exact: max_pgroupJ.\nhave S_pG P: P \\in S -> P \\subset G /\\ p.-group P.\n  by rewrite inE => /maxgroupp/andP[].\nhave SmaxN P Q: Q \\in S -> Q \\subset 'N(P) -> maxp 'N_G(P) Q.\n  rewrite inE => /maxgroupP[/andP[sQG pQ] maxQ] nPQ.\n  apply/maxgroupP; rewrite /psubgroup subsetI sQG nPQ.\n  by split=> // R; rewrite subsetI -andbA andbCA => /andP[_]; apply: maxQ.\nhave nrmG P: P \\subset G -> P <| 'N_G(P).\n  by move=> sPG; rewrite /normal subsetIr subsetI sPG normG.\nhave sylS P: P \\in S -> p.-Sylow('N_G(P)) P.\n  move=> S_P; have [sPG pP] := S_pG P S_P.\n  by rewrite normal_max_pgroup_Hall ?nrmG //; apply: SmaxN; rewrite ?normG.\nhave{SmaxN} defCS P: P \\in S -> 'Fix_(S |'JG)(P) = [set P].\n  move=> S_P; apply/setP=> Q; rewrite {1}in_setI {1}afixJG.\n  apply/andP/set1P=> [[S_Q nQP]|->{Q}]; last by rewrite normG.\n  apply/esym/val_inj; case: (S_pG Q) => //= sQG _.\n  by apply: uniq_normal_Hall (SmaxN Q _ _ _) => //=; rewrite ?sylS ?nrmG.\nhave{defCS} oG_mod: {in S &, forall P Q, #|oG P| = (Q \\in oG P) %[mod p]}.\n  move=> P Q S_P S_Q; have [sQG pQ] := S_pG _ S_Q.\n  have soP_S: oG P \\subset S by rewrite acts_sub_orbit.\n  have /pgroup_fix_mod-> //: [acts Q, on oG P | 'JG].\n    apply/actsP=> x /(subsetP sQG) Gx R; apply: orbit_transl.\n    exact: mem_orbit.\n  rewrite -{1}(setIidPl soP_S) -setIA defCS // (cardsD1 Q) setDE.\n  by rewrite -setIA setICr setI0 cards0 addn0 inE set11 andbT.\nhave [P S_P]: exists P, P \\in S.\n  have: p.-subgroup(G) 1 by rewrite /psubgroup sub1G pgroup1.\n  by case/(@maxgroup_exists _ (p.-subgroup(G))) => P; exists P; rewrite inE.\nhave trS: [transitive G, on S | 'JG].\n  apply/imsetP; exists P => //; apply/eqP.\n  rewrite eqEsubset andbC acts_sub_orbit // S_P; apply/subsetP=> Q S_Q.\n  have /[1!inE] /maxgroupP[/andP[_ pP]] := S_P.\n  have [-> max1 | ntP _] := eqVneq P 1%G.\n    move/andP/max1: (S_pG _ S_Q) => Q1.\n    by rewrite (group_inj (Q1 (sub1G Q))) orbit_refl.\n  have:= oG_mod _ _ S_P S_P; rewrite (oG_mod _ Q) // orbit_refl.\n  have p_gt1: p > 1 by apply: prime_gt1; case/pgroup_pdiv: pP.\n  by case: (Q \\in oG P) => //; rewrite mod0n modn_small.\nhave oS1: prime p -> #|S| %% p = 1%N.\n  move/prime_gt1 => p_gt1.\n  by rewrite -(atransP trS P S_P) (oG_mod P P) // orbit_refl modn_small.\nhave oSiN Q: Q \\in S -> #|S| = #|G : 'N_G(Q)|.\n  by move=> S_Q; rewrite -(atransP trS Q S_Q) card_orbit astab1JG.\nhave sylP: p.-Sylow(G) P.\n  rewrite pHallE; case: (S_pG P) => // -> /= pP.\n  case p_pr: (prime p); last first.\n    rewrite p_part lognE p_pr /= -trivg_card1; apply/idPn=> ntP.\n    by case/pgroup_pdiv: pP p_pr => // ->.\n  rewrite -(LagrangeI G 'N(P)) /= mulnC partnM ?cardG_gt0 // part_p'nat.\n    by rewrite mul1n (card_Hall (sylS P S_P)).\n  by rewrite p'natE // -indexgI -oSiN // /dvdn oS1.\nhave eqS Q: maxp G Q = p.-Sylow(G) Q.\n  apply/idP/idP=> [S_Q|]; last exact: Hall_max.\n  have{} S_Q: Q \\in S by rewrite inE.\n  rewrite pHallE -(card_Hall sylP); case: (S_pG Q) => // -> _ /=.\n  by case: (atransP2 trS S_P S_Q) => x _ ->; rewrite cardJg.\nhave ->: 'Syl_p(G) = S by apply/setP=> Q; rewrite 2!inE.\nby split=> // Q sylQ; rewrite -oSiN ?inE ?eqS.\nQed."
}
{
  "statement": "Lemma gal_matrix :\n  {w : #|A|.-tuple L | {subset w <= E} /\\ 0 \\notin w &\n    [/\\ \\matrix_(i, j < #|A|) enum_val i (tnth w j) \\in unitmx,\n        directv (\\sum_i K * <[tnth w i]>) &\n        group_set A -> (\\sum_i K * <[tnth w i]>)%VS = E] }.\n",
  "proof": "Proof.\npose nzE (w : #|A|.-tuple L) := {subset w <= E} /\\ 0 \\notin w.\npose M w := \\matrix_(i, j < #|A|) nth 1%g (enum A) i (tnth w j).\nhave [w [Ew nzw] uM]: {w : #|A|.-tuple L | nzE w & M w \\in unitmx}.\n  rewrite {}/nzE {}/M cardE; have: uniq (enum A) := enum_uniq _.\n  elim: (enum A) => [|x s IHs] Uxs.\n    by exists [tuple]; rewrite // flatmx0 -(flatmx0 1%:M) unitmx1.\n  have [s'x Us]: x \\notin s /\\ uniq s by apply/andP.\n  have{IHs} [w [Ew nzw] uM] := IHs Us; set M := \\matrix_(i, j) _ in uM.\n  pose a := \\row_i x (tnth w i) *m invmx M.\n  pose c_ y := oapp (a 0) (-1) (insub (index y s)).\n  have cx_n1 : c_ x = -1 by rewrite /c_ insubN ?index_mem.\n  have nz_cx : c_ x != 0 by rewrite cx_n1 oppr_eq0 oner_neq0.\n  have Px: [pred y in x :: s] x := mem_head x s.\n  have{Px nz_cx} /sig2W[w0 Ew0 nzS] := gal_independent_contra Px nz_cx.\n  exists [tuple of cons w0 w].\n    split; first by apply/allP; rewrite /= Ew0; apply/allP.\n    rewrite inE negb_or (contraNneq _ nzS) // => <-.\n    by rewrite big1 // => y _; rewrite rmorph0 mulr0.\n  rewrite unitmxE -[\\det _]mul1r; set M1 := \\matrix_(i, j < 1 + size s) _.\n  have <-: \\det (block_mx 1 (- a) 0 1%:M) = 1 by rewrite det_ublock !det1 mulr1.\n  rewrite -det_mulmx -[M1]submxK mulmx_block !mul0mx !mul1mx !add0r !mulNmx.\n  have ->: drsubmx M1 = M by apply/matrixP => i j; rewrite !mxE !(tnth_nth 0).\n  have ->: ursubmx M1 - a *m M = 0.\n    by apply/rowP=> i; rewrite mulmxKV // !mxE !(tnth_nth 0) subrr.\n  rewrite det_lblock unitrM andbC -unitmxE uM unitfE -oppr_eq0.\n  congr (_ != 0): nzS; rewrite [_ - _]mx11_scalar det_scalar !mxE opprB /=.\n  rewrite -big_uniq // big_cons /= cx_n1 mulN1r addrC; congr (_ + _).\n  rewrite (big_nth 1%g) big_mkord; apply: eq_bigr => j _.\n  by rewrite /c_ index_uniq // valK; congr (_ * _); rewrite !mxE.\nexists w => [//|]; split=> [||gA].\n- by congr (_ \\in unitmx): uM; apply/matrixP=> i j; rewrite !mxE -enum_val_nth.\n- apply/directv_sum_independent=> kw_ Kw_kw sum_kw_0 j _.\n  have /fin_all_exists2[k_ Kk_ Dk_] i := memv_cosetP (Kw_kw i isT).\n  pose kv := \\col_i k_ i.\n  transitivity (kv j 0 * tnth w j); first by rewrite !mxE.\n  suffices{j}/(canRL (mulKmx uM))->: M w *m kv = 0 by rewrite mulmx0 mxE mul0r.\n  apply/colP=> i /[!mxE]; pose Ai := nth 1%g (enum A) i.\n  transitivity (Ai (\\sum_j kw_ j)); last by rewrite sum_kw_0 rmorph0.\n  rewrite rmorph_sum; apply: eq_bigr => j _; rewrite !mxE /= -/Ai.\n  rewrite Dk_ mulrC rmorphM /=; congr (_ * _).\n  by have /mem_fixedFieldP[_ -> //] := Kk_ j; rewrite -mem_enum mem_nth -?cardE.\npose G := group gA; have G_1 := group1 G; pose iG := enum_rank_in G_1.\napply/eqP; rewrite eqEsubv; apply/andP; split.\n  apply/subv_sumP=> i _; apply: subv_trans (asubv _).\n  by rewrite prodvS ?capvSl // -memvE Ew ?mem_tnth.\napply/subvP=> w0 Ew0; apply/memv_sumP.\npose wv := \\col_(i < #|A|) enum_val i w0; pose v := invmx (M w) *m wv.\nexists (fun i => tnth w i * v i 0) => [i _|]; last first.\n  transitivity (wv (iG 1%g) 0); first by rewrite mxE enum_rankK_in ?gal_id.\n  rewrite -[wv](mulKVmx uM) -/v mxE; apply: eq_bigr => i _.\n  by congr (_ * _); rewrite !mxE -enum_val_nth enum_rankK_in ?gal_id.\nrewrite mulrC memv_mul ?memv_line //; apply/fixedFieldP=> [|x Gx].\n  rewrite mxE rpred_sum // => j _; rewrite !mxE rpredM //; last exact: memv_gal.\n  have E_M k l: M w k l \\in E by rewrite mxE memv_gal // Ew ?mem_tnth.\n  have Edet n (N : 'M_n) (E_N : forall i j, N i j \\in E): \\det N \\in E.\n    by apply: rpred_sum => sigma _; rewrite rpredMsign rpred_prod.\n  rewrite /invmx uM 2!mxE mulrC rpred_div ?Edet //.\n  by rewrite rpredMsign Edet // => k l; rewrite 2!mxE.\nsuffices{i} {2}<-: map_mx x v = v by rewrite [map_mx x v i 0]mxE.\nhave uMx: map_mx x (M w) \\in unitmx by rewrite map_unitmx.\nrewrite map_mxM map_invmx /=; apply: canLR {uMx}(mulKmx uMx) _.\napply/colP=> i /[!mxE]; pose ix := iG (enum_val i * x)%g.\nhave Dix b: b \\in E -> enum_val ix b = x (enum_val i b).\n  by move=> Eb; rewrite enum_rankK_in ?groupM ?enum_valP // galM ?lfunE.\ntransitivity ((M w *m v) ix 0); first by rewrite mulKVmx // mxE Dix.\nrewrite mxE; apply: eq_bigr => j _; congr (_ * _).\nby rewrite !mxE -!enum_val_nth Dix // ?Ew ?mem_tnth.\nQed."
}
{
  "statement": "Lemma isog_2extraspecial (gT : finGroupType) (G : {group gT}) n :\n  #|G| = (2 ^ n.*2.+1)%N -> extraspecial G -> G \\isog 'D^n \\/ G \\isog 'D^n.-1*Q.\n",
  "proof": "Proof.\nelim: n G => [|n IHn] G oG esG.\n  case/negP: (extraspecial_nonabelian esG).\n  by rewrite cyclic_abelian ?prime_cyclic ?oG.\nhave pG: 2.-group G by rewrite /pgroup oG pnatX.\nhave oZ:= card_center_extraspecial pG esG.\nhave: 'Z(G) \\subset 'Ohm_1(G).\n  apply/subsetP=> z Zz; rewrite (OhmE _ pG) mem_gen //.\n  by rewrite !inE -order_dvdn -oZ order_dvdG ?(subsetP (center_sub G)).\nrewrite subEproper; case/predU1P=> [defG1 | ltZG1].\n  have [n' n'_gt2 isoG]: exists2 n', n' > 2 & G \\isog 'Q_(2 ^ n').\n    apply/quaternion_classP; apply/eqP.\n    have not_cycG: ~~ cyclic G.\n      by apply: contra (extraspecial_nonabelian esG); apply: cyclic_abelian.\n    move: oZ; rewrite defG1; move/prime_Ohm1P; rewrite (negPf not_cycG) /=.\n    by apply=> //; apply: contra not_cycG; move/eqP->; apply: cyclic1.\n  have [n0 n'3]: n = 0 /\\ n' = 3.\n    have [[x y] genG _] := generators_quaternion n'_gt2 isoG.\n    have n'3: n' = 3.\n      have [_ [_ _ oG' _] _ _ _] := quaternion_structure n'_gt2 genG isoG.\n      apply/eqP; rewrite -(subnKC (ltnW n'_gt2)) subn2 !eqSS -(@eqn_exp2l 2) //.\n      by rewrite -oG' -oZ; case: esG => [[_ ->]].\n    by move/eqP: oG; have [-> _ _ _] := genG; rewrite n'3 eqn_exp2l //; case n.\n  right; rewrite (isog_trans isoG) // n'3 n0 /=.\n  case: DnQ_P => z isoZ; rewrite -im_cpair mulSGid ?sub_isog ?injm_cpair1g //.\n  apply/setIidPl; rewrite setI_im_cpair -injm_center ?injm_cpairg1 //.\n  by rewrite center_ncprod0.\ncase/andP: ltZG1 => _; rewrite (OhmE _ pG) gen_subG.\ncase/subsetPn=> x; case/LdivP=> Gx x2 notZx.\nhave ox: #[x] = 2 by apply: nt_prime_order (group1_contra notZx).\nhave Z'x: x \\in G :\\: 'Z(G) by rewrite inE notZx.\nhave [E [R [[oE oR] [defG ziER]]]] := split1_extraspecial pG esG Z'x.\ncase=> defZE defZR [esE Ex] esR.\nhave isoE: E \\isog 2^{1+2}.\n  apply: isog_trans (isog_symr isog_2X1p2).\n  case/orP: (card_isog8_extraspecial oE esE) => // isoE; case/negP: notZx.\n  have gt32: 3 > 2 by [].\n  have [[y z] genE _] := generators_quaternion gt32 isoE.\n  have [_ _ [defZx _ eq_y2 _ _] _ _] := quaternion_structure gt32 genE isoE.\n  by rewrite (eq_y2 x) // -cycle_subG -defZx defZE.\nrewrite oG doubleS 2!expnS divnMl ?mulKn // in oR.\ncase: ifP esR => [_ defR | _ esR].\n  have ->: n = 0 by move/eqP: oR; rewrite defR oZ (eqn_exp2l 1) //; case n.\n  left; apply: isog_trans (isog_symr (ncprod1 _)).\n  by rewrite -defG defR -defZE cprod_center_id.\nhave AutZin2_1p2: Aut_in (Aut 2^{1+2}) 'Z(2^{1+2}) \\isog Aut 'Z(2^{1+2}).\n  exact: Aut_extraspecial_full (pX1p2_pgroup _) (pX1p2_extraspecial _).\nhave [isoR | isoR] := IHn R oR esR.\n  by left; case: pX1p2S => gz isoZ; rewrite (isog_cprod_by _ defG).\nhave n_gt0: n > 0.\n  have pR: 2.-group R by rewrite /pgroup oR pnatX.\n  have:= min_card_extraspecial pR esR.\n  by rewrite oR leq_exp2l // ltnS (leq_double 1).\ncase: DnQ_P isoR => gR isoZR /=; rewrite isog_sym; case/isogP=> fR injfR im_fR.\nhave [injDn injQ] := (injm_cpairg1 isoZR, injm_cpair1g isoZR).\npose Dn1 := cpairg1 isoZR @* 'D^n.-1; pose Q := cpair1g isoZR @* 'Q_8.\nhave defR: fR @* Dn1 \\* fR @* Q = R.\n  rewrite cprodE ?morphim_cents ?im_cpair_cent //.\n  by rewrite -morphimMl ?subsetT ?im_cpair.\nrewrite -defR cprodA in defG.\nhave [[Dn _ defDn _] _ _] := cprodP defG; rewrite defDn in defG.\nhave isoDn: Dn \\isog 'D^n.\n  rewrite -(prednK n_gt0); case: pX1p2S => gz isoZ.\n  rewrite (isog_cprod_by _ defDn) //; last 1 first.\n    by rewrite isog_sym (isog_trans _ (sub_isog _ _)) ?subsetT // sub_isog.\n  rewrite /= -morphimIim im_fR setIA ziER; apply/setIidPl.\n  rewrite defZE -defZR -{1}im_fR -injm_center // morphimS //.\n  by rewrite -cpairg1_center morphimS // center_sub.\nright; case: DnQ_P => gz isoZ; rewrite (isog_cprod_by _ defG) //; first 1 last.\n- exact: Aut_extraspecial_full (pX1p2n_pgroup _ _) (pX1p2n_extraspecial _ _).\n- by rewrite isog_sym (isog_trans _ (sub_isog _ _)) ?subsetT // sub_isog.\nrewrite /= -morphimIim; case/cprodP: defDn => _ defDn cDn1E.\nrewrite setICA setIA -defDn -group_modr ?morphimS ?subsetT //.\nrewrite /= im_fR (setIC R) ziER -center_prod // defZE -defZR.\nrewrite mulSGid /=; last first.\n  by rewrite -{1}im_fR -injm_center // -cpairg1_center !morphimS ?center_sub.\nrewrite -injm_center ?subsetT // -injmI // setI_im_cpair.\nby rewrite -injm_center // cpairg1_center injm_center // im_fR mulGid.\nQed."
}
{
  "statement": "Lemma charsimple_dprod G : charsimple G ->\n  exists H : {group gT}, [/\\ H \\subset G, simple H\n                         & exists2 I : {set {perm gT}}, I \\subset Aut G\n                         & \\big[dprod/1]_(f in I) f @: H = G].\n",
  "proof": "Proof.\ncase/charsimpleP=> ntG simG.\nhave [H minH sHG]: {H : {group gT} | minnormal H G & H \\subset G}.\n  by apply: mingroup_exists; rewrite ntG normG.\ncase/mingroupP: minH => /andP[ntH nHG] minH.\npose Iok (I : {set {perm gT}}) :=\n  (I \\subset Aut G) &&\n  [exists (M : {group gT} | M <| G), \\big[dprod/1]_(f in I) f @: H == M].\nhave defH: (1 : {perm gT}) @: H = H.\n  apply/eqP; rewrite eqEcard card_imset ?leqnn; last exact: perm_inj.\n  by rewrite andbT; apply/subsetP=> _ /imsetP[x Hx ->]; rewrite perm1.\nhave [|I] := @maxset_exists _ Iok 1.\n  rewrite /Iok sub1G; apply/existsP; exists H.\n  by rewrite /normal sHG nHG (big_pred1 1) => [|f]; rewrite ?defH /= ?inE.\ncase/maxsetP=> /andP[Aut_I /exists_eq_inP[M /andP[sMG nMG] defM]] maxI.\nrewrite sub1set=> ntI; case/eqVproper: sMG => [defG | /andP[sMG not_sGM]].\n  exists H; split=> //; last by exists I; rewrite ?defM.\n  apply/mingroupP; rewrite ntH normG; split=> // N /andP[ntN nNH] sNH.\n  apply: minH => //; rewrite ntN /= -defG.\n  move: defM; rewrite (bigD1 1) //= defH; case/dprodP=> [[_ K _ ->] <- cHK _].\n  by rewrite mul_subG // cents_norm // (subset_trans cHK) ?centS.\nhave defG: <<\\bigcup_(f in Aut G) f @: H>> = G.\n  have sXG: \\bigcup_(f in Aut G) f @: H \\subset G.\n    by apply/bigcupsP=> f Af; rewrite -(im_autm Af) morphimEdom imsetS.\n  apply: simG.\n    apply: contra ntH; rewrite -!subG1; apply: subset_trans.\n    by rewrite sub_gen // (bigcup_max 1) ?group1 ?defH.\n  rewrite /characteristic gen_subG sXG; apply/forall_inP=> f Af.\n  rewrite -(autmE Af) -morphimEsub ?gen_subG ?morphim_gen // genS //.\n  rewrite morphimEsub //= autmE.\n  apply/subsetP=> _ /imsetP[_ /bigcupP[g Ag /imsetP[x Hx ->]] ->].\n  apply/bigcupP; exists (g * f); first exact: groupM.\n  by apply/imsetP; exists x; rewrite // permM.\nhave [f Af sfHM]: exists2 f, f \\in Aut G & ~~ (f @: H \\subset M).\n  move: not_sGM; rewrite -{1}defG gen_subG; case/subsetPn=> x.\n  by case/bigcupP=> f Af fHx Mx; exists f => //; apply/subsetPn; exists x.\ncase If: (f \\in I).\n  by case/negP: sfHM; rewrite -(bigdprodWY defM) sub_gen // (bigcup_max f).\ncase/idP: (If); rewrite -(maxI ([set f] :|: I)) ?subsetUr ?inE ?eqxx //.\nrewrite {maxI}/Iok subUset sub1set Af {}Aut_I; apply/existsP.\nhave sfHG: autm Af @* H \\subset G by rewrite -{4}(im_autm Af) morphimS.\nhave{minH nHG} /mingroupP[/andP[ntfH nfHG] minfH]: minnormal (autm Af @* H) G.\n  apply/mingroupP; rewrite andbC -{1}(im_autm Af) morphim_norms //=.\n  rewrite -subG1 sub_morphim_pre // -kerE ker_autm subG1.\n  split=> // N /andP[ntN nNG] sNfH.\n  have sNG: N \\subset G := subset_trans sNfH sfHG.\n  apply/eqP; rewrite eqEsubset sNfH sub_morphim_pre //=.\n  rewrite -(morphim_invmE (injm_autm Af)) [_ @* N]minH //=.\n    rewrite -subG1 sub_morphim_pre /= ?im_autm // morphpre_invm morphim1 subG1.\n    by rewrite ntN -{1}(im_invm (injm_autm Af)) /= {2}im_autm morphim_norms.\n  by rewrite sub_morphim_pre /= ?im_autm // morphpre_invm.\nhave{minfH sfHM} tifHM: autm Af @* H :&: M = 1.\n  apply/eqP/idPn=> ntMfH; case/setIidPl: sfHM.\n  rewrite -(autmE Af) -morphimEsub //.\n  by apply: minfH; rewrite ?subsetIl // ntMfH normsI.\nhave cfHM: M \\subset 'C(autm Af @* H).\n  rewrite centsC (sameP commG1P trivgP) -tifHM subsetI commg_subl commg_subr.\n  by rewrite (subset_trans sMG) // (subset_trans sfHG).\nexists (autm Af @* H <*> M)%G; rewrite /normal /= join_subG sMG sfHG normsY //=.\nrewrite (bigD1 f) ?inE ?eqxx // (eq_bigl [in I]) /= => [|g]; last first.\n  by rewrite /= !inE andbC; case: eqP => // ->.\nby rewrite defM -(autmE Af) -morphimEsub // dprodE // cent_joinEr ?eqxx.\nQed."
}
{
  "statement": "Lemma Hall_exists_subJ pi gT (G : {group gT}) :\n  solvable G -> exists2 H : {group gT}, pi.-Hall(G) H\n                & forall K : {group gT}, K \\subset G -> pi.-group K ->\n                  exists2 x, x \\in G & K \\subset H :^ x.\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n gT G => // n IHn gT G /ltnSE-leGn solG.\nhave [-> | ntG] := eqsVneq G 1.\n  exists 1%G => [|_ /trivGP-> _]; last by exists 1; rewrite ?set11 ?sub1G.\n  by rewrite pHallE sub1G cards1 part_p'nat.\ncase: (solvable_norm_abelem solG (normal_refl _)) => // M [sMG nsMG ntM].\ncase/is_abelemP=> p pr_p /and3P[pM cMM _].\npose Gb := (G / M)%G; case: (IHn _ Gb) => [||Hb]; try exact: quotient_sol.\n  by rewrite (leq_trans (ltn_quotient _ _)).\ncase/and3P=> [sHbGb piHb pi'Hb'] transHb.\ncase: (inv_quotientS nsMG sHbGb) => H def_H sMH sHG.\nhave nMG := normal_norm nsMG; have nMH := subset_trans sHG nMG.\nhave{transHb} transH (K : {group gT}):\n  K \\subset G -> pi.-group K -> exists2 x, x \\in G & K \\subset H :^ x.\n- move=> sKG piK; have nMK := subset_trans sKG nMG.\n  case: (transHb (K / M)%G) => [||xb Gxb sKHxb]; first exact: morphimS.\n    exact: morphim_pgroup.\n  case/morphimP: Gxb => x Nx Gx /= def_x; exists x => //.\n  apply/subsetP=> y Ky.\n  have: y \\in coset M y by rewrite val_coset (subsetP nMK, rcoset_refl).\n  have: coset M y \\in (H :^ x) / M.\n    rewrite /quotient morphimJ //=.\n    by rewrite def_x def_H in sKHxb; apply/(subsetP sKHxb)/mem_quotient.\n  case/morphimP=> z Nz Hxz ->.\n  rewrite val_coset //; case/rcosetP=> t Mt ->; rewrite groupMl //.\n  by rewrite mem_conjg (subsetP sMH) // -mem_conjg (normP Nx).\nhave{pi'Hb'} pi'H': pi^'.-nat #|G : H|.\n  move: pi'Hb'; rewrite -!divgS // def_H !card_quotient //.\n  by rewrite -(divnMl (cardG_gt0 M)) !Lagrange.\nhave [pi_p | pi'p] := boolP (p \\in pi).\n  exists H => //; apply/and3P; split=> //; rewrite /pgroup.\n  by rewrite -(Lagrange sMH) -card_quotient // pnatM -def_H (pi_pnat pM).\nhave [ltHG | leGH {n IHn leGn transH}] := ltnP #|H| #|G|.\n  case: (IHn _ H (leq_trans ltHG leGn)) => [|H1]; first exact: solvableS solG.\n  case/and3P=> sH1H piH1 pi'H1' transH1.\n  have sH1G: H1 \\subset G by apply: subset_trans sHG.\n  exists H1 => [|K sKG piK].\n    apply/and3P; split => //.\n    rewrite -divgS // -(Lagrange sHG) -(Lagrange sH1H) -mulnA.\n    by rewrite mulKn // pnatM pi'H1'.\n  case: (transH K sKG piK) => x Gx def_K.\n  case: (transH1 (K :^ x^-1)%G) => [||y Hy def_K1].\n  - by rewrite sub_conjgV.\n  - by rewrite /pgroup cardJg.\n  exists (y * x); first by rewrite groupMr // (subsetP sHG).\n  by rewrite -(conjsgKV x K) conjsgM conjSg.\nhave{leGH Gb sHbGb sHG sMH pi'H'} eqHG: H = G.\n  by apply/eqP; rewrite -val_eqE eqEcard sHG.\nhave{H Hb def_H eqHG piHb nMH} hallM: pi^'.-Hall(G) M.\n  rewrite /pHall /pgroup sMG pnatNK -card_quotient //=.\n  by rewrite -eqHG -def_H (pi_pnat pM).\ncase/splitsP: (SchurZassenhaus_split (pHall_Hall hallM) nsMG) => H.\ncase/complP=> trMH defG.\nhave sHG: H \\subset G by rewrite -defG mulG_subr.\nexists H => [|K sKG piK].\n  apply: etrans hallM; rewrite /pHall sMG sHG /= -!divgS // -defG andbC.\n  by rewrite (TI_cardMg trMH) mulKn ?mulnK // pnatNK.\npose G1 := (K <*> M)%G; pose K1 := (H :&: G1)%G.\nhave nMK: K \\subset 'N(M) by apply: subset_trans sKG nMG.\nhave defG1: M * K = G1 by rewrite -normC -?norm_joinEl.\nhave sK1G1: K1 \\subset M * K by rewrite defG1 subsetIr.\nhave coMK: coprime #|M| #|K|.\n  by rewrite coprime_sym (pnat_coprime piK) //; apply: (pHall_pgroup hallM).\ncase: (SchurZassenhaus_trans_sol _ nMK sK1G1 coMK) => [||x Mx defK1].\n- exact: solvableS solG.\n- apply/eqP; rewrite -(eqn_pmul2l (cardG_gt0 M)) -TI_cardMg //; last first.\n    by apply/trivgP; rewrite -trMH /= setIA subsetIl.\n  rewrite -coprime_cardMg // defG1; apply/eqP; congr #|(_ : {set _})|.\n  rewrite group_modl; last by rewrite -defG1 mulG_subl.\n  by apply/setIidPr; rewrite defG gen_subG subUset sKG.\nexists x^-1; first by rewrite groupV (subsetP sMG).\nby rewrite -(_ : K1 :^ x^-1 = K) ?(conjSg, subsetIl) // defK1 conjsgK.\nQed."
}
{
  "statement": "Lemma minCpoly_cyclotomic n z :\n  n.-primitive_root z -> minCpoly z = cyclotomic z n.\n",
  "proof": "Proof.\nmove=> prim_z; have n_gt0 := prim_order_gt0 prim_z.\nhave Dpz := Cintr_Cyclotomic prim_z; set pz := cyclotomic z n in Dpz *.\nhave mon_pz: pz \\is monic by apply: cyclotomic_monic.\nhave pz0: root pz z by rewrite root_cyclotomic.\nhave [pf [Dpf mon_pf] dv_pf] := minCpolyP z.\nhave /dvdpP_rat_int[f [af nz_af Df] [g /esym Dfg]]: pf %| pZtoQ 'Phi_n.\n  rewrite -dv_pf; congr (root _ z): pz0; rewrite -Dpz -map_poly_comp.\n  by apply: eq_map_poly => b; rewrite /= rmorph_int.\nwithout loss{nz_af} [mon_f mon_g]: af f g Df Dfg / f \\is monic /\\ g \\is monic.\n  move=> IH; pose cf := lead_coef f; pose cg := lead_coef g.\n  have cfg1: cf * cg = 1.\n    by rewrite -lead_coefM Dfg (monicP (Cyclotomic_monic n)).\n  apply: (IH (af *~ cf) (f *~ cg) (g *~ cf)).\n  - by rewrite rmorphMz -scalerMzr scalerMzl -mulrzA cfg1.\n  - by rewrite mulrzAl mulrzAr -mulrzA cfg1.\n  by rewrite !(intz, =^~ scaler_int) !monicE !lead_coefZ mulrC cfg1.\nhave{af} Df: pQtoC pf = pZtoC f.\n  have:= congr1 lead_coef Df.\n  rewrite lead_coefZ lead_coef_map_inj //; last exact: intr_inj.\n  rewrite !(monicP _) // mulr1 Df => <-; rewrite scale1r -map_poly_comp.\n  by apply: eq_map_poly => b; rewrite /= rmorph_int.\nhave [/size1_polyC Dg | g_gt1] := leqP (size g) 1.\n  rewrite monicE Dg lead_coefC in mon_g.\n  by rewrite -Dpz -Dfg Dg (eqP mon_g) mulr1 Dpf.\nhave [zk gzk0]: exists zk, root (pZtoC g) zk.\n  have [rg] := closed_field_poly_normal (pZtoC g).\n  rewrite lead_coef_map_inj // (monicP mon_g) scale1r => Dg.\n  rewrite -(size_map_inj_poly (can_inj intCK)) // Dg in g_gt1.\n  rewrite size_prod_XsubC in g_gt1.\n  by exists rg`_0; rewrite Dg root_prod_XsubC mem_nth.\nhave [k cokn Dzk]: exists2 k, coprime k n & zk = z ^+ k.\n  have: root pz zk by rewrite -Dpz -Dfg rmorphM rootM gzk0 orbT.\n  rewrite -[pz](big_image _ _ _ _ (fun r => 'X - r%:P)) root_prod_XsubC.\n  by case/imageP=> k; exists k.\nhave co_fg (R : idomainType): n%:R != 0 :> R -> @coprimep R (intrp f) (intrp g).\n  move=> nz_n; have: separable_poly (intrp ('X^n - 1) : {poly R}).\n    by rewrite rmorphB rmorph1 /= map_polyXn separable_Xn_sub_1.\n  rewrite -prod_Cyclotomic // (big_rem n) -?dvdn_divisors //= -Dfg.\n  by rewrite !rmorphM /= !separable_mul => /and3P[] /and3P[].\nsuffices fzk0: root (pZtoC f) zk.\n  have [] // := negP (coprimep_root (co_fg _ _) fzk0).\n  by rewrite pnatr_eq0 -lt0n.\nmove: gzk0 cokn; rewrite {zk}Dzk; elim/ltn_ind: k => k IHk gzk0 cokn.\nhave [|k_gt1] := leqP k 1; last have [p p_pr /dvdnP[k1 Dk]] := pdivP k_gt1.\n  rewrite -[leq k 1](mem_iota 0 2) !inE => /pred2P[k0 | ->]; last first.\n    by rewrite -Df dv_pf.\n  have /eqP := size_Cyclotomic n; rewrite -Dfg size_Mmonic ?monic_neq0 //.\n  rewrite k0 /coprime gcd0n in cokn; rewrite (eqP cokn).\n  rewrite -(size_map_inj_poly (can_inj intCK)) // -Df -Dpf.\n  by rewrite -(subnKC g_gt1) -(subnKC (size_minCpoly z)) !addnS.\nmove: cokn; rewrite Dk coprimeMl => /andP[cok1n].\nrewrite prime_coprime // (dvdn_pcharf (pchar_Fp p_pr)) => /co_fg {co_fg}.\nhave pcharFpX: p \\in [pchar {poly 'F_p}] by rewrite (rmorph_pchar polyC) ?pchar_Fp.\nrewrite -(coprimep_pexpr _ _ (prime_gt0 p_pr)) -(pFrobenius_autE pcharFpX).\nrewrite -[g]comp_polyXr map_comp_poly -horner_map /= pFrobenius_autE -rmorphXn.\nrewrite -!map_poly_comp (@eq_map_poly _ _ _ (polyC \\o *~%R 1)); last first.\n  by move=> a; rewrite /= !rmorph_int.\nrewrite map_poly_comp -[_.[_]]map_comp_poly /= => co_fg.\nsuffices: coprimep (pZtoC f) (pZtoC (g \\Po 'X^p)).\n  move/coprimep_root=> /=/(_ (z ^+ k1))/implyP.\n  rewrite map_comp_poly map_polyXn horner_comp hornerXn.\n  rewrite -exprM -Dk [_ == 0]gzk0 implybF => /negP[].\n  have: root pz (z ^+ k1).\n    by rewrite root_cyclotomic // prim_root_exp_coprime.\n  rewrite -Dpz -Dfg rmorphM rootM => /orP[] //= /IHk-> //.\n  rewrite -[k1]muln1 Dk ltn_pmul2l ?prime_gt1 //.\n  by have:= ltnW k_gt1; rewrite Dk muln_gt0 => /andP[].\nsuffices: coprimep f (g \\Po 'X^p).\n  case/Bezout_coprimepP=> [[u v]]; rewrite -size_poly_eq1.\n  rewrite -(size_map_inj_poly (can_inj intCK)) // rmorphD !rmorphM /=.\n  rewrite size_poly_eq1 => {}co_fg; apply/Bezout_coprimepP.\n  by exists (pZtoC u, pZtoC v).\napply: contraLR co_fg => /coprimepPn[|d]; first exact: monic_neq0.\nrewrite andbC -size_poly_eq1 dvdp_gcd => /and3P[sz_d].\npose d1 := zprimitive d.\nhave d_dv_mon h: d %| h -> h \\is monic -> exists h1, h = d1 * h1.\n  case/Pdiv.Idomain.dvdpP=> [[c h1] /= nz_c Dh] mon_h; exists (zprimitive h1).\n  by rewrite -zprimitiveM mulrC -Dh zprimitiveZ ?zprimitive_monic.\ncase/d_dv_mon=> // f1 Df1 /d_dv_mon[|f2 ->].\n  rewrite monicE lead_coefE size_comp_poly size_polyXn /=.\n  rewrite comp_polyE coef_sum polySpred ?monic_neq0 //= mulnC.\n  rewrite big_ord_recr /= -lead_coefE (monicP mon_g) scale1r.\n  rewrite -exprM coefXn eqxx big1 ?add0r // => i _.\n  rewrite coefZ -exprM coefXn eqn_pmul2l ?prime_gt0 //.\n  by rewrite eqn_leq leqNgt ltn_ord mulr0.\nhave monFp h: h \\is monic -> size (map_poly intr h) = size h.\n  by move=> mon_h; rewrite size_poly_eq // -lead_coefE (monicP mon_h) oner_eq0.\napply/coprimepPn; last exists (map_poly intr d1).\n  by rewrite -size_poly_eq0 monFp // size_poly_eq0 monic_neq0.\nrewrite Df1 !rmorphM dvdp_gcd !dvdp_mulr //= -size_poly_eq1.\nrewrite monFp ?size_zprimitive //.\nrewrite monicE [_ d1]intEsg sgz_lead_primitive -zprimitive_eq0 -/d1.\nrewrite -lead_coef_eq0 -absz_eq0.\nhave/esym/eqP := congr1 (absz \\o lead_coef) Df1.\nby rewrite /= (monicP mon_f) lead_coefM abszM muln_eq1 => /andP[/eqP-> _].\nQed."
}
{
  "statement": "Lemma to_rformP e f : holds e (to_rform f) <-> holds e f.\n",
  "proof": "Proof.\nsuffices{e f} equal0_equiv e t1 t2:\n  holds e (eq0_rform (t1 - t2)) <-> (eval e t1 == eval e t2).\n- elim: f e => /=; try tauto.\n  + move=> t1 t2 e.\n    by split; [move/equal0_equiv/eqP | move/eqP/equal0_equiv].\n  + by move=> t1 e; rewrite unitrE; apply: equal0_equiv.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 f2 IHf2 e; move: (IHf1 e) (IHf2 e); tauto.\n  + by move=> f1 IHf1 e; move: (IHf1 e); tauto.\n  + by move=> n f1 IHf1 e; split=> [] [x] /IHf1; exists x.\n  + by move=> n f1 IHf1 e; split=> Hx x; apply/IHf1.\nrewrite -(add0r (eval e t2)) -(can2_eq (subrK _) (addrK _)).\nrewrite -/(eval e (t1 - t2)); move: (t1 - t2)%T => {t1 t2} t.\nhave sub_var_tsubst s t0: s.1 >= ub_var t0 -> tsubst t0 s = t0.\n  elim: t0 {t} => //=.\n  - by move=> n; case: ltngtP.\n  - by move=> t1 IHt1 t2 IHt2; rewrite geq_max => /andP[/IHt1-> /IHt2->].\n  - by move=> t1 IHt1 /IHt1->.\n  - by move=> t1 IHt1 n /IHt1->.\n  - by move=> t1 IHt1 t2 IHt2; rewrite geq_max => /andP[/IHt1-> /IHt2->].\n  - by move=> t1 IHt1 /IHt1->.\n  - by move=> t1 IHt1 n /IHt1->.\npose fix rsub t' m r : term R :=\n  if r is u :: r' then tsubst (rsub t' m.+1 r') (m, u^-1)%T else t'.\npose fix ub_sub m r : Prop :=\n  if r is u :: r' then ub_var u <= m /\\ ub_sub m.+1 r' else true.\nsuffices{t} rsub_to_r t r0 m: m >= ub_var t -> ub_sub m r0 ->\n  let: (t', r) := to_rterm t r0 m in\n  [/\\ take (size r0) r = r0,\n      ub_var t' <= m + size r, ub_sub m r & rsub t' m r = t].\n- have:= rsub_to_r t [::] _ (leqnn _); rewrite /eq0_rform.\n  case: (to_rterm _ _ _) => [t1' r1] [//|_ _ ub_r1 def_t].\n  rewrite -{2}def_t {def_t}.\n  elim: r1 (ub_var t) e ub_r1 => [|u r1 IHr1] m e /= => [_|[ub_u ub_r1]].\n    by split=> /eqP.\n  rewrite eval_tsubst /=; set y := eval e u; split=> t_eq0.\n    apply/IHr1=> //; apply: t_eq0.\n    rewrite nth_set_nth /= eqxx -(eval_tsubst e u (m, Const _)).\n    rewrite sub_var_tsubst //= -/y.\n    case Uy: (y \\in unit); [left | right]; first by rewrite mulVr ?divrr.\n    split=> [|[z]]; first by rewrite invr_out ?Uy.\n    rewrite nth_set_nth /= eqxx.\n    rewrite -!(eval_tsubst _ _ (m, Const _)) !sub_var_tsubst // -/y => yz1.\n    by case/unitrP: Uy; exists z.\n  move=> x def_x; apply/IHr1=> //; suff ->: x = y^-1 by []; move: def_x.\n  rewrite nth_set_nth /= eqxx -(eval_tsubst e u (m, Const _)).\n  rewrite sub_var_tsubst //= -/y; case=> [[xy1 yx1] | [xy nUy]].\n    by rewrite -[y^-1]mul1r -[1]xy1 mulrK //; apply/unitrP; exists x.\n  rewrite invr_out //; apply/unitrP=> [[z yz1]]; case: nUy; exists z.\n  rewrite nth_set_nth /= eqxx -!(eval_tsubst _ _ (m, _%:T)%T).\n  by rewrite !sub_var_tsubst.\nhave rsub_id r t0 n: ub_var t0 <= n -> rsub t0 n r = t0.\n  by elim: r n => //= t1 r IHr n let0n; rewrite IHr ?sub_var_tsubst ?leqW.\nhave rsub_acc r s t1 m1:\n  ub_var t1 <= m1 + size r -> rsub t1 m1 (r ++ s) = rsub t1 m1 r.\n  elim: r t1 m1 => [|t1 r IHr] t2 m1 /=; first by rewrite addn0; apply: rsub_id.\n  by move=> letmr; rewrite IHr ?addSnnS.\nelim: t r0 m => /=; try do [\n  by move=> n r m hlt hub; rewrite take_size (ltn_addr _ hlt) rsub_id\n| by move=> n r m hlt hub; rewrite leq0n take_size rsub_id\n| move=> t1 IHt1 t2 IHt2 r m; rewrite geq_max; case/andP=> hub1 hub2 hmr;\n  case: to_rterm {hub1 hmr}(IHt1 r m hub1 hmr) => t1' r1;\n  case=> htake1 hub1' hsub1 <-;\n  case: to_rterm {IHt2 hub2 hsub1}(IHt2 r1 m hub2 hsub1) => t2' r2 /=;\n  rewrite geq_max; case=> htake2 -> hsub2 /= <-;\n  rewrite -{1 2}(cat_take_drop (size r1) r2) htake2; set r3 := drop _ _;\n  rewrite size_cat addnA (leq_trans _ (leq_addr _ _)) //;\n  split=> {hsub2}//;\n   first by [rewrite takel_cat // -htake1 size_take geq_min leqnn orbT];\n  rewrite -(rsub_acc r1 r3 t1') {hub1'}// -{htake1}htake2 {r3}cat_take_drop;\n  by elim: r2 m => //= u r2 IHr2 m; rewrite IHr2\n| do [ move=> t1 IHt1 r m; do 2!move=> /IHt1{}IHt1\n     | move=> t1 IHt1 n r m; do 2!move=> /IHt1{}IHt1];\n  case: to_rterm IHt1 => t1' r1 [-> -> hsub1 <-]; split=> {hsub1}//;\n  by elim: r1 m => //= u r1 IHr1 m; rewrite IHr1].\nmove=> t1 IH r m letm /IH {IH} /(_ letm) {letm}.\ncase: to_rterm => t1' r1 /= [def_r ub_t1' ub_r1 <-].\nrewrite size_rcons addnS leqnn -{1}cats1 takel_cat ?def_r; last first.\n  by rewrite -def_r size_take geq_min leqnn orbT.\nelim: r1 m ub_r1 ub_t1' {def_r} => /= [|u r1 IHr1] m => [_|[->]].\n  by rewrite addn0 eqxx.\nby rewrite -addSnnS => /IHr1 IH /IH[_ _ ub_r1 ->].\nQed."
}
{
  "statement": "Theorem Gaschutz_split : [splits G, over H] = [splits P, over H].\n",
  "proof": "Proof.\napply/splitsP/splitsP=> [[K /complP[tiHK eqHK]] | [Q /complP[tiHQ eqHQ]]].\n  exists (K :&: P)%G; rewrite inE setICA (setIidPl sHP) setIC tiHK eqxx.\n  by rewrite group_modl // eqHK (sameP eqP setIidPr).\nhave sQP: Q \\subset P by rewrite -eqHQ mulG_subr.\npose rP x := repr (P :* x); pose pP x := x * (rP x)^-1.\nhave PpP x: pP x \\in P by rewrite -mem_rcoset rcoset_repr rcoset_refl.\nhave rPmul x y: x \\in P -> rP (x * y) = rP y.\n  by move=> Px; rewrite /rP rcosetM rcoset_id.\npose pQ x := remgr H Q x; pose rH x := pQ (pP x) * rP x.\nhave pQhq: {in H & Q, forall h q, pQ (h * q) = q} by apply: remgrMid.\nhave pQmul: {in P &, {morph pQ : x y / x * y}}.\n  by apply: remgrM; [apply/complP | apply: normalS (nsHG)].\nhave HrH x: rH x \\in H :* x.\n  by rewrite rcoset_sym mem_rcoset invMg mulgA mem_divgr // eqHQ PpP.\nhave GrH x: x \\in G -> rH x \\in G.\n  move=> Gx; case/rcosetP: (HrH x) => y Hy ->.\n  by rewrite groupM // (subsetP sHG).\nhave rH_Pmul x y: x \\in P -> rH (x * y) = pQ x * rH y.\n  by move=> Px; rewrite /rH mulgA -pQmul; first by rewrite /pP rPmul ?mulgA.\nhave rH_Hmul h y: h \\in H -> rH (h * y) = rH y.\n  by move=> Hh; rewrite rH_Pmul ?(subsetP sHP) // -(mulg1 h) pQhq ?mul1g.\npose mu x y := fmod ((rH x * rH y)^-1 * rH (x * y)).\npose nu y := (\\sum_(Px in rcosets P G) mu (repr Px) y)%R.\nhave rHmul: {in G &, forall x y, rH (x * y) = rH x * rH y * val (mu x y)}.\n  move=> x y Gx Gy; rewrite /= fmodK ?mulKVg // -mem_lcoset lcoset_sym.\n  rewrite -norm_rlcoset; last by rewrite nHG ?GrH ?groupM.\n  by rewrite (rcoset_eqP (HrH _)) -rcoset_mul ?nHG ?GrH // mem_mulg.\nhave actrH a x: x \\in G -> (a ^@ rH x = a ^@ x)%R.\n  move=> Gx; apply: val_inj; rewrite /= !fmvalJ ?nHG ?GrH //.\n  case/rcosetP: (HrH x) => b /(fmodK abelH) <- ->; rewrite conjgM.\n  by congr (_ ^ _); rewrite conjgE -fmvalN -!fmvalA (addrC a) addKr.\nhave mu_Pmul x y z: x \\in P -> mu (x * y) z = mu y z.\n  move=> Px; congr fmod; rewrite -mulgA !(rH_Pmul x) ?rPmul //.\n  by rewrite -mulgA invMg -mulgA mulKg.\nhave mu_Hmul x y z: x \\in G -> y \\in H -> mu x (y * z) = mu x z.\n  move=> Gx Hy; congr fmod; rewrite (mulgA x) (conjgCV x) -mulgA 2?rH_Hmul //.\n  by rewrite -mem_conjg (normP _) ?nHG.\nhave{mu_Hmul} nu_Hmul y z: y \\in H -> nu (y * z) = nu z.\n  move=> Hy; apply: eq_bigr => _ /rcosetsP[x Gx ->]; apply: mu_Hmul y z _ Hy.\n  by rewrite -(groupMl _ (subsetP sPG _ (PpP x))) mulgKV.\nhave cocycle_mu: {in G & &, forall x y z,\n  mu (x * y)%g z + mu x y ^@ z = mu y z + mu x (y * z)%g}%R.\n- move=> x y z Gx Gy Gz; apply: val_inj.\n  apply: (mulgI (rH x * rH y * rH z)).\n  rewrite -(actrH _ _ Gz) addrC fmvalA fmvalJ ?nHG ?GrH //.\n  rewrite mulgA -(mulgA _ (rH z)) -conjgC mulgA -!rHmul ?groupM //.\n  by rewrite mulgA -mulgA -2!(mulgA (rH x)) -!rHmul ?groupM.\nmove: mu => mu in rHmul mu_Pmul cocycle_mu nu nu_Hmul.\nhave{cocycle_mu} cocycle_nu: {in G &, forall y z,\n  nu z + nu y ^@ z = mu y z *+ #|G : P| + nu (y * z)%g}%R.\n- move=> y z Gy Gz; rewrite /= (actr_sum z) /=.\n  have ->: (nu z = \\sum_(Px in rcosets P G) mu (repr Px * y)%g z)%R.\n    rewrite /nu (reindex_acts _ (actsRs_rcosets P G) Gy) /=.\n    apply: eq_bigr => _ /rcosetsP[x Gx /= ->].\n    rewrite rcosetE -rcosetM.\n    case: repr_rcosetP=> p1 Pp1; case: repr_rcosetP=> p2 Pp2.\n    by rewrite -mulgA [x * y]lock !mu_Pmul.\n  rewrite -sumr_const -!big_split /=; apply: eq_bigr => _ /rcosetsP[x Gx ->].\n  rewrite -cocycle_mu //; case: repr_rcosetP => p1 Pp1.\n  by rewrite groupMr // (subsetP sPG).\nmove: nu => nu in nu_Hmul cocycle_nu.\npose f x := rH x * val (nu x *+ m)%R.\nhave{cocycle_nu} fM: {in G &, {morph f : x y / x * y}}.\n  move=> x y Gx Gy; rewrite /f ?rHmul // -3!mulgA; congr (_ * _).\n  rewrite (mulgA _ (rH y)) (conjgC _ (rH y)) -mulgA; congr (_ * _).\n  rewrite -fmvalJ ?actrH ?nHG ?GrH // -!fmvalA actZr -mulrnDl.\n  rewrite -(addrC (nu y)) cocycle_nu // mulrnDl !fmvalA; congr (_ * _).\n  by rewrite !fmvalZ expgK ?fmodP.\nexists (Morphism fM @* G)%G; apply/complP; split.\n  apply/trivgP/subsetP=> x /setIP[Hx /morphimP[y _ Gy eq_x]].\n  apply/set1P; move: Hx; rewrite {x}eq_x /= groupMr ?subgP //.\n  rewrite -{1}(mulgKV y (rH y)) groupMl -?mem_rcoset // => Hy.\n  by rewrite -(mulg1 y) /f nu_Hmul // rH_Hmul //; apply: (morph1 (Morphism fM)).\napply/setP=> x; apply/mulsgP/idP=> [[h y Hh fy ->{x}] | Gx].\n  rewrite groupMl; last exact: (subsetP sHG).\n  case/morphimP: fy => z _ Gz ->{h Hh y}.\n  by rewrite /= /f groupMl ?GrH // (subsetP sHG) ?fmodP.\nexists (x * (f x)^-1) (f x); last first; first by rewrite mulgKV.\n  by apply/morphimP; exists x.\nrewrite -groupV invMg invgK -mulgA (conjgC (val _)) mulgA.\nby rewrite groupMl -(mem_rcoset, mem_conjg) // (normP _) ?nHG ?fmodP.\nQed."
}
{
  "statement": "Theorem finDomain_mulrC : @commutative R R *%R.\n",
  "proof": "Proof.\nhave fieldR := finDomain_field.\nhave [p p_pr pcharRp]: exists2 p, prime p & p \\in [pchar R].\n  have [e /prod_prime_decomp->]: {e | (e > 0)%N & e%:R == 0 :> R}.\n    by exists #|[set: R]%G|; rewrite // -order_dvdn order_dvdG ?inE.\n  rewrite big_seq; elim/big_rec: _ => [|[p m] /= n]; first by rewrite oner_eq0.\n  case/mem_prime_decomp=> p_pr _ _ IHn.\n  elim: m => [|m IHm]; rewrite ?mul1n {IHn}// expnS -mulnA natrM.\n  by case/eqP/domR/orP=> //; exists p; last apply/andP.\npose Rp := pPrimeCharType pcharRp; pose L : {vspace Rp} := fullv.\npose G := [set: {unit R}]; pose ofG : {unit R} -> Rp := val.\npose projG (E : {vspace Rp}) := [preim ofG of E].\nhave inG t nzt: Sub t (finDomain_field nzt) \\in G by rewrite inE.\nhave card_projG E: #|projG E| = (p ^ \\dim E - 1)%N.\n  transitivity #|E|.-1; last by rewrite subn1 card_vspace card_Fp.\n  rewrite (cardD1 0) mem0v (card_preim val_inj) /=.\n  apply: eq_card => x; congr (_ && _); rewrite [LHS]codom_val.\n  by apply/idP/idP=> [/(memPn _ _)-> | /fieldR]; rewrite ?unitr0.\npose C u := 'C[ofG u]%AS; pose Q := 'C(L)%AS; pose q := (p ^ \\dim Q)%N.\nhave defC u: 'C[u] =i projG (C u).\n  by move=> v; rewrite cent1E !inE (sameP cent1vP eqP).\nhave defQ: 'Z(G) =i projG Q.\n  move=> u /[!inE].\n  apply/centP/centvP=> cGu v _; last exact/val_inj/cGu/memvf.\n  by have [-> | /inG/cGu[]] := eqVneq v 0; first by rewrite commr0.\nhave q_gt1: (1 < q)%N by rewrite (ltn_exp2l 0) ?prime_gt1 ?adim_gt0.\npose n := \\dim_Q L; have oG: #|G| = (q ^ n - 1)%N.\n  rewrite -expnM mulnC divnK ?skew_field_dimS ?subvf // -card_projG.\n  by apply: eq_card => u; rewrite !inE memvf.\nhave oZ: #|'Z(G)| = (q - 1)%N by rewrite -card_projG; apply: eq_card.\nsuffices n_le1: (n <= 1)%N.\n  move=> u v; apply/centvsP: (memvf (u : Rp)) (memvf (v : Rp)) => {u v}.\n  rewrite -(geq_leqif (dimv_leqif_sup (subvf Q))) -/L.\n  by rewrite leq_divLR ?mul1n ?skew_field_dimS ?subvf in n_le1.\nwithout loss n_gt1: / (1 < n)%N by rewrite ltnNge; apply: wlog_neg.\nhave [q_gt0 n_gt0] := (ltnW q_gt1, ltnW n_gt1).\nhave [z z_prim] := C_prim_root_exists n_gt0.\nhave zn1: z ^+ n = 1 by apply: prim_expr_order.\nhave /eqP-n1z: `|z| == 1 by rewrite -(pexpr_eq1 n_gt0) // -normrX zn1 normr1.\nsuffices /eqP/normCBeq[t n1t [Dq Dz]]:\n  `|q%:R - z : algC| == `|q%:R : algC| - `|z|.\n  suffices z1: z == 1 by rewrite leq_eqVlt -dvdn1 (prim_order_dvd z_prim) z1.\n  by rewrite Dz n1z mul1r -(eqr_pMn2r q_gt0) Dq normr_nat mulr_natl.\npose aq d : algC := (cyclotomic (z ^+ (n %/ d)) d).[q%:R].\nsuffices: `|aq n| <= (q - 1)%:R.\n  rewrite eq_le lerB_dist andbT n1z normr_nat natrB //; apply: le_trans.\n  rewrite {}/aq horner_prod divnn n_gt0 expr1 normr_prod.\n  rewrite (bigD1 (Ordinal n_gt1)) ?coprime1n //= !hornerE ler_peMr //.\n  elim/big_ind: _ => // [|d _]; first exact: mulr_ege1.\n  rewrite !hornerE; apply: le_trans (lerB_dist _ _).\n  by rewrite normr_nat normrX n1z expr1n lerBDl (leC_nat 2).\nhave Zaq d: d %| n -> aq d \\in Num.int.\n  move/(dvdn_prim_root z_prim)=> zd_prim.\n  rewrite rpred_horner ?rpred_nat //= -Cintr_Cyclotomic //.\n  by apply/polyOverP=> i; rewrite coef_map ?rpred_int.\nsuffices: (aq n %| (q - 1)%:R)%C.\n  rewrite {1}[aq n]intrEsign ?Zaq // -(rpredMsign _ (aq n < 0)%R).\n  rewrite dvdC_mul2l ?signr_eq0 //.\n  have /natrP[m ->]: `|aq n| \\in Num.nat by rewrite natr_norm_int ?Zaq.\n  by rewrite leC_nat dvdC_nat; apply: dvdn_leq; rewrite subn_gt0.\nhave prod_aq m: m %| n -> \\prod_(d < n.+1 | d %| m) aq d = (q ^ m - 1)%:R.\n  move=> m_dv_n; transitivity ('X^m - 1).[q%:R : algC]; last first.\n    by rewrite !hornerE -natrX natrB ?expn_gt0 ?prime_gt0.\n  rewrite (prod_cyclotomic (dvdn_prim_root z_prim m_dv_n)).\n  have def_divm: perm_eq (divisors m) [seq d <- index_iota 0 n.+1 | d %| m].\n    rewrite uniq_perm ?divisors_uniq ?filter_uniq ?iota_uniq // => d.\n    rewrite -dvdn_divisors ?(dvdn_gt0 n_gt0) // mem_filter mem_iota ltnS /=.\n    by apply/esym/andb_idr=> d_dv_m; rewrite dvdn_leq ?(dvdn_trans d_dv_m).\n  rewrite (perm_big _ def_divm) big_filter big_mkord horner_prod.\n  by apply: eq_bigr => d d_dv_m; rewrite -exprM muln_divA ?divnK.\nhave /rpredBl<-: (aq n %| #|G|%:R)%C.\n  rewrite oG -prod_aq // (bigD1 ord_max) //= dvdC_mulr //.\n  by apply: rpred_prod => d /andP[/Zaq].\nrewrite center_class_formula addrC oZ natrD addKr natr_sum /=.\napply: rpred_sum => _ /imsetP[u /setDP[_ Z'u] ->]; rewrite -/G /=.\nhave sQC: (Q <= C u)%VS by apply/subvP=> v /centvP-cLv; apply/cent1vP/cLv/memvf.\nhave{sQC} /dvdnP[m Dm]: \\dim Q %| \\dim (C u) by apply: skew_field_dimS.\nhave m_dv_n: m %| n by rewrite dvdn_divRL // -?Dm ?skew_field_dimS ?subvf.\nhave m_gt0: (0 < m)%N := dvdn_gt0 n_gt0 m_dv_n.\nhave{Dm} oCu: #|'C[u]| = (q ^ m - 1)%N.\n  by rewrite -expnM mulnC -Dm (eq_card (defC u)) card_projG.\nhave ->: #|u ^: G|%:R = \\prod_(d < n.+1 | d %| n) (aq d / aq d ^+ (d %| m)).\n  rewrite -index_cent1 natf_indexg ?subsetT //= setTI prodf_div prod_aq // -oG.\n  congr (_ / _); rewrite big_mkcond oCu -prod_aq //= big_mkcond /=.\n  by apply: eq_bigr => d _; case: ifP => [/dvdn_trans->| _]; rewrite ?if_same.\nrewrite (bigD1 ord_max) //= [n %| m](contraNF _ Z'u) => [|n_dv_m]; last first.\n  rewrite -sub_cent1 subEproper eq_sym eqEcard subsetT oG oCu leq_sub2r //.\n  by rewrite leq_exp2l // dvdn_leq.\nrewrite divr1 dvdC_mulr //; apply/rpred_prod => d /andP[/Zaq-Zaqd _].\nhave [-> | nz_aqd] := eqVneq (aq d) 0; first by rewrite mul0r /=.\nby rewrite -[aq d]expr1 -exprB ?leq_b1 ?unitfE ?rpredX.\nQed."
}
{
  "statement": "Theorem invariant_chief_irr_cases G K L s (theta := 'chi[K]_s) :\n    chief_factor G L K -> abelian (K / L) -> G \\subset 'I[theta] ->\n  let t := #|K : L| in\n  [\\/ 'Res[L] theta \\in irr L,\n      exists2 e, exists p, 'Res[L] theta = e%:R *: 'chi_p & (e ^ 2)%N = t\n   |  exists2 p, injective p & 'Res[L] theta = \\sum_(i < t) 'chi_(p i)].\n",
  "proof": "Proof.\ncase/andP=> /maxgroupP[/andP[ltLK nLG] maxL] nsKG abKbar IGtheta t.\nhave [sKG nKG] := andP nsKG; have sLG := subset_trans (proper_sub ltLK) sKG.\nhave nsLG: L <| G by apply/andP.\nhave nsLK := normalS (proper_sub ltLK) sKG nsLG; have [sLK nLK] := andP nsLK.\nhave [p0 sLp0] := constt_cfRes_irr L s; rewrite -/theta in sLp0.\npose phi := 'chi_p0; pose T := 'I_G[phi].\nhave sTG: T \\subset G := subsetIl G _.\nhave /eqP mulKT: (K * T)%g == G.\n  rewrite eqEcard mulG_subG sKG sTG -LagrangeMr -indexgI -(Lagrange sTG) /= -/T.\n  rewrite mulnC leq_mul // setIA (setIidPl sKG) -!size_cfclass // -/phi.\n  rewrite uniq_leq_size ?cfclass_uniq // => _ /cfclassP[x Gx ->].\n  have: conjg_Iirr p0 x \\in irr_constt ('Res theta).\n    have /inertiaJ <-: x \\in 'I[theta] := subsetP IGtheta x Gx.\n    by rewrite -(cfConjgRes _ nsKG) // irr_consttE conjg_IirrE // cfConjg_iso.\n  apply: contraR; rewrite -conjg_IirrE // => not_sLp0x.\n  rewrite (Clifford_Res_sum_cfclass nsLK sLp0) cfdotZl cfdot_suml.\n  rewrite big1_seq ?mulr0 // => _ /cfclassP[y Ky ->]; rewrite -conjg_IirrE //.\n  rewrite cfdot_irr mulrb ifN_eq ?(contraNneq _ not_sLp0x) // => <-.\n  by rewrite conjg_IirrE //; apply/cfclassP; exists y.\nhave nsKT_G: K :&: T <| G.\n  rewrite /normal subIset ?sKG // -mulKT setIA (setIidPl sKG) mulG_subG.\n  rewrite normsIG // sub_der1_norm ?subsetIl //.\n  exact: subset_trans (der1_min nLK abKbar) (sub_Inertia _ sLK).\nhave [e DthL]: exists e, 'Res theta = e%:R *: \\sum_(xi <- (phi ^: K)%CF) xi.\n  rewrite (Clifford_Res_sum_cfclass nsLK sLp0) -/phi; set e := '[_, _].\n  exists (Num.truncn e).\n  by rewrite truncnK ?Cnat_cfdot_char ?cfRes_char ?irr_char.\nhave [defKT | ltKT_K] := eqVneq (K :&: T) K; last first.\n  have defKT: K :&: T = L.\n    apply: maxL; last by rewrite subsetI sLK sub_Inertia.\n    by rewrite normal_norm // properEneq ltKT_K subsetIl.\n  have t_cast: size (phi ^: K)%CF = t.\n    by rewrite size_cfclass //= -{2}(setIidPl sKG) -setIA defKT.\n  pose phiKt := Tuple (introT eqP t_cast); pose p i := cfIirr (tnth phiKt i).\n  have pK i: 'chi_(p i) = (phi ^: K)%CF`_i.\n    rewrite cfIirrE; first by rewrite (tnth_nth 0).\n    by have /cfclassP[y _ ->] := mem_tnth i phiKt; rewrite cfConjg_irr ?mem_irr.\n  constructor 3; exists p => [i j /(congr1 (tnth (irr L)))/eqP| ].\n    by apply: contraTeq; rewrite !pK !nth_uniq ?t_cast ?cfclass_uniq.\n  have{} DthL: 'Res theta = e%:R *: \\sum_(i < t) (phi ^: K)%CF`_i.\n    by rewrite DthL (big_nth 0) big_mkord t_cast.\n  suffices /eqP e1: e == 1 by rewrite DthL e1 scale1r; apply: eq_bigr.\n  have Dth1: theta 1%g = e%:R * t%:R * phi 1%g.\n    rewrite -[t]card_ord -mulrA -(cfRes1 L) DthL cfunE; congr (_ * _).\n    rewrite mulr_natl -sumr_const sum_cfunE -t_cast; apply: eq_bigr => i _.\n    by have /cfclassP[y _ ->] := mem_nth 0 (valP i); rewrite cfConjg1.\n  rewrite eqn_leq lt0n (contraNneq _ (irr1_neq0 s)); last first.\n    by rewrite Dth1 => ->; rewrite !mul0r.\n  rewrite -leC_nat -(ler_pM2r (gt0CiG K L)) -/t -(ler_pM2r (irr1_gt0 p0)).\n  rewrite mul1r -Dth1 -cfInd1 //.\n  by rewrite char1_ge_constt ?cfInd_char ?irr_char ?constt_Ind_Res.\nhave IKphi: 'I_K[phi] = K by rewrite -{1}(setIidPl sKG) -setIA.\nhave{} DthL: 'Res[L] theta = e%:R *: phi.\n  by rewrite DthL -[rhs in (_ ^: rhs)%CF]IKphi cfclass_inertia big_seq1.\npose mmLth := @mul_mod_Iirr K L s.\nhave linKbar := char_abelianP _ abKbar.\nhave LmodL i: ('chi_i %% L)%CF \\is a linear_char := cfMod_lin_char (linKbar i).\nhave mmLthE i: 'chi_(mmLth i) = ('chi_i %% L)%CF * theta.\n  by rewrite cfIirrE ?mod_IirrE // mul_lin_irr ?mem_irr.\nhave mmLthL i: 'Res[L] 'chi_(mmLth i) = 'Res[L] theta.\n  rewrite mmLthE rmorphM /= cfRes_sub_ker ?cfker_mod ?lin_char1 //.\n  by rewrite scale1r mul1r.\nhave [inj_Mphi | /injectivePn[i [j i'j eq_mm_ij]]] := boolP (injectiveb mmLth).\n  suffices /eqP e1: e == 1 by constructor 1; rewrite DthL e1 scale1r mem_irr.\n  rewrite eqn_leq lt0n (contraNneq _ (irr1_neq0 s)); last first.\n    by rewrite -(cfRes1 L) DthL cfunE => ->; rewrite !mul0r.\n  rewrite -leq_sqr -leC_nat natrX -(ler_pM2r (irr1_gt0 p0)) -mulrA mul1r.\n  have ->: e%:R * 'chi_p0 1%g = 'Res[L] theta 1%g by rewrite DthL cfunE.\n  rewrite cfRes1 -(ler_pM2l (gt0CiG K L)) -cfInd1 // -/phi.\n  rewrite -card_quotient // -card_Iirr_abelian // mulr_natl.\n  rewrite ['Ind phi]cfun_sum_cfdot sum_cfunE (bigID [in codom mmLth]) /=.\n  rewrite ler_wpDr ?sumr_ge0 // => [i _|].\n    by rewrite char1_ge0 ?rpredZ_nat ?Cnat_cfdot_char ?cfInd_char ?irr_char.\n  rewrite -big_uniq //= big_image -sumr_const ler_sum // => i _.\n  rewrite cfunE -[in leRHS](cfRes1 L) -cfdot_Res_r mmLthL cfRes1.\n  by rewrite DthL cfdotZr rmorph_nat cfnorm_irr mulr1.\nconstructor 2; exists e; first by exists p0.\npose mu := (('chi_i / 'chi_j)%R %% L)%CF; pose U := cfker mu.\nhave lin_mu: mu \\is a linear_char by rewrite cfMod_lin_char ?rpred_div.\nhave Uj := lin_char_unitr (linKbar j).\nhave ltUK: U \\proper K.\n  rewrite /proper cfker_sub /U; have /irrP[k Dmu] := lin_char_irr lin_mu.\n  rewrite Dmu subGcfker -irr_eq1 -Dmu cfMod_eq1 //.\n  by rewrite (can2_eq (divrK Uj) (mulrK Uj)) mul1r (inj_eq irr_inj).\nsuffices: theta \\in 'CF(K, L).\n  rewrite -cfnorm_Res_leif // DthL cfnormZ !cfnorm_irr !mulr1 normr_nat.\n  by rewrite -natrX eqC_nat => /eqP.\nhave <-: gcore U G = L.\n  apply: maxL; last by rewrite sub_gcore ?cfker_mod.\n  by rewrite gcore_norm (sub_proper_trans (gcore_sub _ _)).\napply/cfun_onP=> x; apply: contraNeq => nz_th_x.\napply/bigcapP=> y /(subsetP IGtheta)/setIdP[nKy /eqP th_y].\napply: contraR nz_th_x; rewrite mem_conjg -{}th_y cfConjgE {nKy}//.\nmove: {x y}(x ^ _) => x U'x; have [Kx | /cfun0-> //] := boolP (x \\in K).\nhave /eqP := congr1 (fun k => (('chi_j %% L)%CF^-1 * 'chi_k) x) eq_mm_ij.\nrewrite -rmorphV // !mmLthE !mulrA -!rmorphM mulVr // rmorph1 !cfunE.\nrewrite (mulrC _^-1) -/mu -subr_eq0 -mulrBl cfun1E Kx mulf_eq0 => /orP[]//.\nrewrite mulrb subr_eq0 -(lin_char1 lin_mu) [_ == _](contraNF _ U'x) //.\nby rewrite /U cfkerEchar ?lin_charW // inE Kx.\nQed."
}
{
  "statement": "Lemma Aut_extraspecial_full : Aut_in (Aut S) 'Z(S) \\isog Aut 'Z(S).\n",
  "proof": "Proof.\nhave [p_gt1 p_gt0] := (prime_gt1 p_pr, prime_gt0 p_pr).\nhave [Es] := extraspecial_structure pS esS.\nelim: Es S oZ => [T _ _ <-| E s IHs T oZT] /=.\n  rewrite big_nil cprod1g (center_idP (center_abelian T)).\n  by apply/Aut_sub_fullP=> // g injg gZ; exists g.\nrewrite -andbA big_cons -cprodA => /and3P[/eqP-oE /eqP-defZE es_s].\ncase/cprodP=> -[_ U _ defU]; rewrite defU => defT cEU.\nhave sUT: U \\subset T by rewrite -defT mulG_subr.\nhave sZU: 'Z(T) \\subset U.\n  by case/cprodP: defU => [[V _ -> _] <- _]; apply: mulG_subr.\nhave defZU: 'Z(E) = 'Z(U).\n  apply/eqP; rewrite eqEsubset defZE subsetI sZU subIset ?centS ?orbT //=.\n  by rewrite subsetI subIset ?sUT //= -defT centM setSI.\napply: (Aut_cprod_full _ defZU); rewrite ?cprodE //; last first.\n  by apply: IHs; rewrite -?defZU ?defZE.\nhave oZE: #|'Z(E)| = p by rewrite defZE.\nhave [p2 | odd_p] := even_prime p_pr.\n  suffices <-: restr_perm 'Z(E) @* Aut E = Aut 'Z(E) by apply: Aut_in_isog.\n  apply/eqP; rewrite eqEcard restr_perm_Aut ?center_sub //=.\n  by rewrite card_Aut_cyclic ?prime_cyclic ?oZE // {1}p2 cardG_gt0.\nhave pE: p.-group E by rewrite /pgroup oE pnatX pnat_id.\nhave nZE: E \\subset 'N('Z(E)) by rewrite normal_norm ?center_normal.\nhave esE: extraspecial E := card_p3group_extraspecial p_pr oE oZE.\nhave [[defPhiE defE'] prZ] := esE.\nhave{defPhiE} sEpZ x: x \\in E -> (x ^+ p)%g \\in 'Z(E).\n  move=> Ex; rewrite -defPhiE (Phi_joing pE) mem_gen // inE orbC.\n  by rewrite (Mho_p_elt 1) // (mem_p_elt pE).\nhave ltZE: 'Z(E) \\proper E by rewrite properEcard subsetIl oZE oE (ltn_exp2l 1).\nhave [x [Ex notZx oxp]]: exists x, [/\\ x \\in E, x \\notin 'Z(E) & #[x] %| p]%N.\n  have [_ [x Ex notZx]] := properP ltZE.\n  case: (prime_subgroupVti <[x ^+ p]> prZ) => [sZxp | ]; last first.\n    move/eqP; rewrite (setIidPl _) ?cycle_subG ?sEpZ //.\n    by rewrite cycle_eq1 -order_dvdn; exists x.\n  have [y Ey notxy]: exists2 y, y \\in E & y \\notin <[x]>.\n    apply/subsetPn; apply: contra (extraspecial_nonabelian esE) => sEx.\n    by rewrite (abelianS sEx) ?cycle_abelian.\n  have: (y ^+ p)%g \\in <[x ^+ p]> by rewrite (subsetP sZxp) ?sEpZ.\n  case/cycleP=> i def_yp; set xi := (x ^- i)%g.\n  have Exi: xi \\in E by rewrite groupV groupX.\n  exists (y * xi)%g; split; first by rewrite groupM.\n    have sxpx: <[x ^+ p]> \\subset <[x]> by rewrite cycle_subG mem_cycle.\n    apply: contra notxy; move/(subsetP (subset_trans sZxp sxpx)).\n    by rewrite groupMr // groupV mem_cycle.\n  pose z := [~ xi, y]; have Zz: z \\in 'Z(E) by rewrite -defE' mem_commg.\n  case: (setIP Zz) => _; move/centP=> cEz.\n  rewrite order_dvdn expMg_Rmul; try by apply: commute_sym; apply: cEz.\n  rewrite def_yp expgVn -!expgM mulnC mulgV mul1g -order_dvdn.\n  by rewrite (dvdn_trans (order_dvdG Zz)) //= oZE bin2odd // dvdn_mulr.\nhave{oxp} ox: #[x] = p.\n  apply/eqP; case/primeP: p_pr => _ dvd_p; case/orP: (dvd_p _ oxp) => //.\n  by rewrite order_eq1; case: eqP notZx => // ->; rewrite group1.\nhave [y Ey not_cxy]: exists2 y, y \\in E & y \\notin 'C[x].\n  by apply/subsetPn; rewrite sub_cent1; rewrite inE Ex in notZx.\nhave notZy: y \\notin 'Z(E).\n  apply: contra not_cxy; rewrite inE Ey; apply: subsetP.\n  by rewrite -cent_set1 centS ?sub1set.\npose K := 'C_E[y]; have maxK: maximal K E by apply: cent1_extraspecial_maximal.\nhave nsKE: K <| E := p_maximal_normal pE maxK; have [sKE nKE] := andP nsKE.\nhave oK: #|K| = (p ^ 2)%N.\n  by rewrite -(divg_indexS sKE) oE (p_maximal_index pE) ?mulKn.\nhave cKK: abelian K := card_p2group_abelian p_pr oK.\nhave sZK: 'Z(E) \\subset K by rewrite setIS // -cent_set1 centS ?sub1set.\nhave defE: K ><| <[x]> = E.\n  have notKx: x \\notin K by rewrite inE Ex cent1C.\n  rewrite sdprodE ?(mulg_normal_maximal nsKE) ?cycle_subG ?(subsetP nKE) //.\n  by rewrite setIC prime_TIg -?orderE ?ox ?cycle_subG.\nhave /cyclicP[z defZ]: cyclic 'Z(E) by rewrite prime_cyclic ?oZE.\napply/(Aut_sub_fullP (center_sub E)); rewrite /= defZ => g injg gZ.\npose k := invm (injm_Zp_unitm z) (aut injg gZ).\nhave fM: {in K &, {morph expgn^~ (val k): u v / u * v}}.\n  by move=> u v Ku Kv; rewrite /= expgMn // /commute (centsP cKK).\npose f := Morphism fM; have fK: f @* K = K.\n  apply/setP=> u; rewrite morphimEdom.\n  apply/imsetP/idP=> [[v Kv ->] | Ku]; first exact: groupX.\n  exists (u ^+ expg_invn K (val k)); first exact: groupX.\n  rewrite /f /= expgAC expgK // oK coprimeXl // -unitZpE //.\n  by case: (k) => /=; rewrite orderE -defZ oZE => j; rewrite natr_Zp.\nhave fMact: {in K & <[x]>, morph_act 'J 'J f (idm <[x]>)}.\n  by move=> u v _ _; rewrite /= conjXg.\nexists (sdprodm_morphism defE fMact).\nrewrite im_sdprodm injm_sdprodm injm_idm -card_im_injm im_idm fK.\nhave [_ -> _ ->] := sdprodP defE; rewrite !eqxx; split=> //= u Zu.\nrewrite sdprodmEl ?(subsetP sZK) ?defZ // -(autE injg gZ Zu).\nrewrite -[aut _ _](invmK (injm_Zp_unitm z)); first by rewrite permE Zu.\nby rewrite im_Zp_unitm Aut_aut.\nQed."
}
{
  "statement": "Lemma StrongJordanHolderUniqueness (G : {group rT}) (s1 s2 : seq {group rT}) :\n    G \\subset D -> acomps to G s1 -> acomps to G s2 ->\n  perm_eq (mkfactors G s1) (mkfactors G s2).\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n G => // n Hi G in s1 s2 * => cG hsD cs1 cs2.\ncase/orP: (orbN (G :==: 1)) => [tG | ntG].\n  have -> : s1 = [::] by apply/eqP; rewrite -(trivg_acomps cs1).\n  have -> : s2 = [::] by apply/eqP; rewrite -(trivg_acomps cs2).\n  by rewrite /= perm_refl.\ncase/orP: (orbN (asimple to G))=> [sG | nsG].\n  have -> : s1 = [:: 1%G ] by apply/(asimple_acompsP cs1).\n  have -> : s2 = [:: 1%G ] by apply/(asimple_acompsP cs2).\n  by rewrite /= perm_refl.\ncase es1: s1 cs1 => [|N1 st1] cs1.\n  by move: (trivg_comps cs1); rewrite eqxx; move/negP:ntG.\ncase es2: s2 cs2 => [|N2 st2] cs2 {s1 es1}.\n  by move: (trivg_comps cs2); rewrite eqxx; move/negP:ntG.\ncase/andP: cs1 => /= lst1; case/andP=> maxN_1 pst1.\ncase/andP: cs2 => /= lst2; case/andP=> maxN_2 pst2.\nhave sN1D : N1 \\subset D.\n  by apply: subset_trans hsD; apply: maxainv_sub maxN_1.\nhave sN2D : N2 \\subset D.\n  by apply: subset_trans hsD; apply: maxainv_sub maxN_2.\nhave cN1 : #|N1| < n.\n  by rewrite -ltnS (leq_trans _ cG) ?ltnS ?proper_card ?(maxainv_proper maxN_1).\nhave cN2 : #|N2| < n.\n  by rewrite -ltnS (leq_trans _ cG) ?ltnS ?proper_card ?(maxainv_proper maxN_2).\ncase: (N1 =P N2) {s2 es2} => [eN12 |].\n  by rewrite eN12 /= perm_cons Hi // /acomps ?lst2 //= -eN12 lst1.\nmove/eqP; rewrite -val_eqE /=; move/eqP=> neN12.\nhave nN1G : N1 <| G by apply: (maxainv_norm maxN_1).\nhave nN2G : N2 <| G by apply: (maxainv_norm maxN_2).\npose N := (N1 :&: N2)%G.\nhave nNG : N <| G.\n  by rewrite /normal subIset ?(normal_sub nN1G) //= normsI ?normal_norm.\nhave iso1 : (G / N1)%G \\isog (N2 / N)%G.\n  rewrite isog_sym /= -(maxainvM _ _ maxN_1 maxN_2) //.\n  rewrite (@normC _ N1 N2) ?(subset_trans (normal_sub nN1G)) ?normal_norm //.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN2G)) ?normal_norm.\nhave iso2 : (G / N2)%G \\isog (N1 / N)%G.\n  rewrite isog_sym /= -(maxainvM _ _ maxN_1 maxN_2) // setIC.\n  by rewrite weak_second_isog ?(subset_trans (normal_sub nN1G)) ?normal_norm.\ncase: (exists_acomps to N)=> sN; case/andP=> lsN csN.\nhave aN1 : [acts A, on N1 | to].\n  by case/maxgroupP: maxN_1; case/and3P.\nhave aN2 : [acts A, on N2 | to].\n  by case/maxgroupP: maxN_2; case/and3P.\nhave nNN1 : N <| N1.\n  by apply: (normalS _ _ nNG); rewrite ?subsetIl ?normal_sub.\nhave nNN2 : N <| N2.\n  by apply: (normalS _ _ nNG); rewrite ?subsetIr ?normal_sub.\nhave aN : [ acts A, on N1 :&: N2 | to].\n  apply/subsetP=> x Ax; rewrite !inE Ax /=; apply/subsetP=> y Ny; rewrite inE.\n  case/setIP: Ny=> N1y N2y. rewrite inE ?astabs_act  ?N1y ?N2y //.\n    by move/subsetP: aN2; move/(_ x Ax).\n  by move/subsetP: aN1; move/(_ x Ax).\nhave i1 : perm_eq (mksrepr G N1 :: mkfactors N1 st1)\n                  [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N1 [:: N & sN]).\n  apply: Hi=> //; rewrite /acomps ?lst1 //= lsN csN andbT /=.\n  apply: asimple_quo_maxainv=> //; first by apply: subIset; rewrite sN1D.\n  apply: asimpleI => //.\n    by apply: subset_trans (normal_norm nN2G); apply: normal_sub.\n  rewrite -quotientMidl (maxainvM _ _ maxN_2) //.\n    by apply: maxainv_asimple_quo.\n  by move=> e; apply: neN12.\nhave i2 : perm_eq (mksrepr G N2 :: mkfactors N2 st2)\n                  [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\n  rewrite perm_cons -[mksrepr _ _ :: _]/(mkfactors N2 [:: N & sN]).\n  apply: Hi=> //; rewrite /acomps ?lst2 //= lsN csN andbT /=.\n  apply: asimple_quo_maxainv=> //; first by apply: subIset; rewrite sN1D.\n  have e : N1 :&: N2 :=: N2 :&: N1 by rewrite setIC.\n  rewrite (group_inj (setIC N1 N2)); apply: asimpleI => //.\n    by apply: subset_trans (normal_norm nN1G); apply: normal_sub.\n  rewrite -quotientMidl (maxainvM _ _ maxN_1) //.\n  exact: maxainv_asimple_quo.\npose fG1 := [:: mksrepr G N1, mksrepr N1 N & mkfactors N sN].\npose fG2 := [:: mksrepr G N2, mksrepr N2 N & mkfactors N sN].\nhave i3 : perm_eq fG1 fG2.\n  rewrite (@perm_catCA _ [::_] [::_]) /mksrepr.\n  rewrite (@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso1).\n  rewrite -(@section_repr_isog _ (mkSec _ _) (mkSec _ _) iso2).\n  exact: perm_refl.\napply: (perm_trans i1); apply: (perm_trans i3); rewrite perm_sym.\nby apply: perm_trans i2; apply: perm_refl.\nQed."
}
{
  "statement": "Lemma extend_algC_subfield_aut (Qs : fieldExtType rat)\n  (QsC : {rmorphism Qs -> algC}) (phi : {rmorphism Qs -> Qs}) :\n  {nu : {rmorphism algC -> algC} | {morph QsC : x / phi x >-> nu x}}.\n",
  "proof": "Proof.\npose numF_inj (Qr : fieldExtType rat) := {rmorphism Qr -> algC}.\npose subAut := {Qr : _ & numF_inj Qr * {lrmorphism Qr -> Qr}}%type.\npose SubAut := existT _ _ (_, _) : subAut.\npose Sdom (mu : subAut) := projT1 mu.\npose Sinj (mu : subAut) : {rmorphism Sdom mu -> algC} := (projT2 mu).1.\npose Saut (mu : subAut) : {rmorphism Sdom mu -> Sdom mu} := (projT2 mu).2.\nhave Sinj_poly Qr (QrC : numF_inj Qr) p:\n  map_poly QrC (map_poly (in_alg Qr) p) = pQtoC p.\n- rewrite -map_poly_comp; apply: eq_map_poly => a.\n  by rewrite /= rmorphZ_num rmorph1 mulr1.\nhave ext1 mu0 x : {mu1 | exists y, x = Sinj mu1 y\n  & exists2 in01 : {lrmorphism _ -> _}, Sinj mu0 =1 Sinj mu1 \\o in01\n  & {morph in01: y / Saut mu0 y >-> Saut mu1 y}}.\n- pose b0 := vbasis {:Sdom mu0}.\n  have [z _ /sig_eqW[[|px ps] // [Dx Ds]]] := algC_PET (x :: map (Sinj mu0) b0).\n  have [p [_ mon_p] /(_ p) pz0] := minCpolyP z; rewrite dvdpp in pz0.\n  have [r Dr] := closed_field_poly_normal (pQtoC p : {poly algC}).\n  rewrite lead_coef_map {mon_p}(monicP mon_p) rmorph1 scale1r in Dr.\n  have{pz0} rz: z \\in r by rewrite -root_prod_XsubC -Dr.\n  have [Qr [QrC [rr Drr genQr]]] := num_field_exists r.\n  have{rz} [zz Dz]: {zz | QrC zz = z}.\n    by move: rz; rewrite -Drr => /mapP/sig2_eqW[zz]; exists zz.\n  have{ps Ds} [in01 Din01]:\n      {in01 : {lrmorphism _ -> _} | Sinj mu0 =1 QrC \\o in01}.\n    have in01P y: {yy | Sinj mu0 y = QrC yy}.\n      exists (\\sum_i coord b0 i y *: (map_poly (in_alg Qr) ps`_i).[zz]).\n      rewrite {1}(coord_vbasis (memvf y)) !rmorph_sum /=; apply: eq_bigr => i _.\n      rewrite 2!rmorphZ_num -(nth_map _ 0) ?size_tuple // Ds.\n      rewrite -horner_map Dz Sinj_poly (nth_map 0) //.\n      by have:= congr1 size Ds; rewrite !size_map size_tuple => <-.\n    pose in01 y := sval (in01P y).\n    have Din01 y: Sinj mu0 y = QrC (in01 y) by rewrite /in01; case: (in01P y).\n    pose rwM := (=^~ Din01, rmorphZ_num, rmorph1, rmorphB, rmorphM).\n    have in01a : additive in01.\n      by move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM.\n    have in01m : multiplicative in01.\n      by split; try move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM /= ?rwM.\n    have in01l : scalable in01.\n      by try move=> ? ?; apply: (fmorph_inj QrC); rewrite !rwM.\n    pose in01aM := GRing.isAdditive.Build _ _ in01 in01a.\n    pose in01mM := GRing.isMultiplicative.Build _ _ in01 in01m.\n    pose in01lM := GRing.isScalable.Build _ _  _ _ in01 in01l.\n    pose in01LRM : {lrmorphism _ -> _} := HB.pack in01\n      in01aM in01mM in01lM.\n    by exists in01LRM.\n  have {z zz Dz px} Dx: exists xx, x = QrC xx.\n    exists (map_poly (in_alg Qr) px).[zz].\n    by rewrite -horner_map Dz Sinj_poly Dx.\n  pose lin01 := linfun in01; pose K := (lin01 @: fullv)%VS.\n  have memK y: reflect (exists yy, y = in01 yy) (y \\in K).\n    apply: (iffP memv_imgP) => [[yy _ ->] | [yy ->]];\n      by exists yy; rewrite ?lfunE ?memvf.\n  have algK: is_aspace K.\n    rewrite /is_aspace has_algid1; last first.\n      by apply/memK; exists 1; rewrite rmorph1.\n    apply/prodvP=> _ _ /memK[y1 ->] /memK[y2 ->].\n    by apply/memK; exists (y1 * y2); rewrite rmorphM.\n  have ker_in01: lker lin01 == 0%VS.\n    by apply/lker0P=> y1 y2; rewrite !lfunE; apply: fmorph_inj.\n  pose f := (lin01 \\o linfun (Saut mu0) \\o lin01^-1)%VF.\n  have Df y: f (in01 y) = in01 (Saut mu0 y).\n    transitivity (f (lin01 y)); first by rewrite !lfunE.\n    by do 4!rewrite lfunE /=; rewrite lker0_lfunK.\n  have hom_f: kHom 1 (ASpace algK) f.\n    apply/kHomP; split=> [_ _ /memK[y1 ->] /memK[y2 ->] |_ /vlineP[a ->]].\n      by rewrite -rmorphM !Df !rmorphM.\n    by rewrite -(rmorph_alg in01) Df /= !rmorph_alg.\n  pose pr := map_poly (in_alg Qr) p.\n  have Qpr: pr \\is a polyOver 1%VS.\n    by apply/polyOverP=> i; rewrite coef_map memvZ ?memv_line.\n  have splitQr: splittingFieldFor K pr fullv.\n    apply: splittingFieldForS (sub1v (Sub K algK)) (subvf _) _; exists rr => //.\n    congr (_ %= _): (eqpxx pr); apply/(map_poly_inj QrC).\n    rewrite Sinj_poly Dr -Drr big_map rmorph_prod /=; apply: eq_bigr => zz _.\n    by rewrite map_polyXsubC.\n  have [f1 aut_f1 Df1]:= kHom_extends (sub1v (ASpace algK)) hom_f Qpr splitQr.\n  pose f1mM := GRing.isMultiplicative.Build _ _ f1 (kHom_lrmorphism aut_f1).\n  pose nu : {lrmorphism _ -> _} := HB.pack (fun_of_lfun f1) f1mM.\n  exists (SubAut Qr QrC nu) => //; exists in01 => //= y.\n  by rewrite -Df -Df1 //; apply/memK; exists y.\nhave phiZ: scalable phi.\n  by move=> a y; rewrite rmorphZ_num -alg_num_field mulr_algl.\npose philM := GRing.isScalable.Build _ _ _ _ phi phiZ.\npose phiLRM : {lrmorphism _ -> _} := HB.pack (GRing.RMorphism.sort phi) philM.\npose fix ext n :=\n  if n is i.+1 then oapp (fun x => s2val (ext1 (ext i) x)) (ext i) (unpickle i)\n  else SubAut Qs QsC phiLRM.\nhave mem_ext x n: (pickle x < n)%N -> {xx | Sinj (ext n) xx = x}.\n  move=> ltxn; apply: sig_eqW; elim: n ltxn => // n IHn.\n  rewrite ltnS leq_eqVlt => /predU1P[<- | /IHn[xx <-]] /=.\n    by rewrite pickleK /=; case: (ext1 _ x) => mu [xx]; exists xx.\n  case: (unpickle n) => /= [y|]; last by exists xx.\n  case: (ext1 _ y) => mu /= _ [in_mu inj_in_mu _].\n  by exists (in_mu xx); rewrite inj_in_mu.\npose nu x := Sinj _ (Saut _ (sval (mem_ext x _ (ltnSn _)))).\nhave nu_inj n y: nu (Sinj (ext n) y) = Sinj (ext n) (Saut (ext n) y).\n  rewrite /nu; case: (mem_ext _ _ _); move: _.+1 => n1 y1 Dy /=.\n  without loss /subnK Dn1: n n1 y y1 Dy / (n <= n1)%N.\n    by move=> IH; case/orP: (leq_total n n1) => /IH => [/(_ y) | /(_ y1)]->.\n  move: (n1 - n)%N => k in Dn1; elim: k => [|k IHk] in n Dn1 y Dy *.\n    by move: y1 Dy; rewrite -Dn1 => y1  /fmorph_inj ->.\n  rewrite addSnnS in Dn1; move/IHk: Dn1 => /=.\n  case: (unpickle _) => [z|] /=; last exact.\n  case: (ext1 _ _) => mu /= _ [in_mu Dinj Daut].\n  by rewrite Dy => /(_ _ (Dinj _))->; rewrite -Daut Dinj.\npose le_nu (x : algC) n := (pickle x < n)%N.\nhave max3 x1 x2 x3: exists n, [/\\ le_nu x1 n, le_nu x2 n & le_nu x3 n].\n  exists (maxn (pickle x1) (maxn (pickle x2) (pickle x3))).+1.\n  by apply/and3P; rewrite /le_nu !ltnS -!geq_max.\nhave nua : additive nu.\n  move=> x1 x2; have [n] := max3 (x1 - x2) x1 x2.\n  case=> /mem_ext[y Dx] /mem_ext[y1 Dx1] /mem_ext[y2 Dx2].\n  rewrite -Dx nu_inj; rewrite -Dx1 -Dx2 -rmorphB in Dx.\n  by rewrite (fmorph_inj _ Dx) !rmorphB -!nu_inj Dx1 Dx2.\nhave num : multiplicative nu.\n  split=> [x1 x2|]; last by rewrite -(rmorph1 QsC) (nu_inj 0) !rmorph1.\n  have [n] := max3 (x1 * x2) x1 x2.\n  case=> /mem_ext[y Dx] /mem_ext[y1 Dx1] /mem_ext[y2 Dx2].\n  rewrite -Dx nu_inj; rewrite -Dx1 -Dx2 -rmorphM in Dx.\n  by rewrite (fmorph_inj _ Dx) !rmorphM /= -!nu_inj Dx1 Dx2.\npose nuaM := GRing.isAdditive.Build _ _ nu nua.\npose numM := GRing.isMultiplicative.Build _ _ nu num.\npose nuRM : {rmorphism _ -> _} := HB.pack nu nuaM numM.\nby exists nuRM => x; rewrite /= (nu_inj 0).\nQed."
}
{
  "statement": "Lemma int_Smith_normal_form m n (M : 'M[int]_(m, n)) :\n  {L : 'M[int]_m & L \\in unitmx &\n  {R : 'M[int]_n & R \\in unitmx &\n  {d : seq int | sorted dvdz d &\n   M = L *m (\\matrix_(i, j) (d`_i *+ (i == j :> nat))) *m R}}}.\n",
  "proof": "Proof.\nmove: {2}_.+1 (ltnSn (m + n)) => mn.\nelim: mn => // mn IHmn in m n M *; rewrite ltnS => le_mn.\nhave [[i j] nzMij | no_ij] := pickP (fun k => M k.1 k.2 != 0); last first.\n  do 2![exists 1%:M; first exact: unitmx1]; exists nil => //=.\n  apply/matrixP=> i j; apply/eqP; rewrite mulmx1 mul1mx mxE nth_nil mul0rn.\n  exact: negbFE (no_ij (i, j)).\ndo [case: m i => [[]//|m] i; case: n j => [[]//|n] j /=] in M nzMij le_mn *.\nwlog Dj: j M nzMij / j = 0; last rewrite {j}Dj in nzMij.\n  case/(_ 0 (xcol j 0 M)); rewrite ?mxE ?tpermR // => L uL [R uR [d dvD dM]].\n  exists L => //; exists (xcol j 0 R); last exists d => //=.\n     by rewrite xcolE unitmx_mul uR unitmx_perm.\n  by rewrite xcolE !mulmxA -dM xcolE -mulmxA -perm_mxM tperm2 perm_mx1 mulmx1.\nmove Da: (M i 0) nzMij => a nz_a.\nhave [A leA] := ubnP `|a|; elim: A => // A IHa in a leA m n M i Da nz_a le_mn *.\nwlog [j a'Mij]: m n M i Da le_mn / {j | ~~ (a %| M i j)%Z}; last first.\n  have nz_j: j != 0 by apply: contraNneq a'Mij => ->; rewrite Da.\n  case: n => [[[]//]|n] in j le_mn nz_j M a'Mij Da *.\n  wlog{nz_j} Dj: j M a'Mij Da / j = 1; last rewrite {j}Dj in a'Mij.\n    case/(_ 1 (xcol j 1 M)); rewrite ?mxE ?tpermR ?tpermD //.\n    move=> L uL [R uR [d dvD dM]]; exists L => //.\n    exists (xcol j 1 R); first by rewrite xcolE unitmx_mul uR unitmx_perm.\n    exists d; rewrite //= xcolE !mulmxA -dM xcolE -mulmxA -perm_mxM tperm2.\n    by rewrite perm_mx1 mulmx1.\n  have [u [v]] := Bezoutz a (M i 1); set b := gcdz _ _ => Db.\n  have{leA} ltA: (`|b| < A)%N.\n    rewrite -ltnS (leq_trans _ leA) // ltnS ltn_neqAle andbC.\n    rewrite dvdn_leq ?absz_gt0 ? dvdn_gcdl //=.\n    by rewrite (contraNneq _ a'Mij) ?dvdzE // => <-; apply: dvdn_gcdr.\n  pose t2 := [fun j : 'I_2 => [tuple _; _]`_j : int]; pose a1 := M i 1.\n  pose Uul := \\matrix_(k, j) t2 (t2 u (- (a1 %/ b)%Z) j) (t2 v (a %/ b)%Z j) k.\n  pose U : 'M_(2 + n) := block_mx Uul 0 0 1%:M; pose M1 := M *m U.\n  have{nz_a} nz_b: b != 0 by rewrite gcdz_eq0 (negPf nz_a).\n  have uU: U \\in unitmx.\n    rewrite unitmxE det_ublock det1 (expand_det_col _ 0) big_ord_recl big_ord1.\n    do 2!rewrite /cofactor [row' _ _]mx11_scalar !mxE det_scalar1 /=.\n    rewrite mulr1 mul1r mulN1r opprK -[_ + _](mulzK _ nz_b) mulrDl.\n    by rewrite -!mulrA !divzK ?dvdz_gcdl ?dvdz_gcdr // Db divzz nz_b unitr1.\n  have{} Db: M1 i 0 = b.\n    rewrite /M1 -(lshift0 n 1) [U]block_mxEh mul_mx_row row_mxEl.\n    rewrite -[M](@hsubmxK _ _ 2) (@mul_row_col _ _ 2) mulmx0 addr0 !mxE /=.\n    rewrite big_ord_recl big_ord1 !mxE /= [lshift _ _]((_ =P 0) _) // Da.\n    by rewrite [lshift _ _]((_ =P 1) _) // mulrC -(mulrC v).\n  have [L uL [R uR [d dvD dM1]]] := IHa b ltA _ _ M1 i Db nz_b le_mn.\n  exists L => //; exists (R *m invmx U); last exists d => //.\n    by rewrite unitmx_mul uR unitmx_inv.\n  by rewrite mulmxA -dM1 mulmxK.\nmove=> {A leA}IHa; wlog Di: i M Da / i = 0; last rewrite {i}Di in Da.\n  case/(_ 0 (xrow i 0 M)); rewrite ?mxE ?tpermR // => L uL [R uR [d dvD dM]].\n  exists (xrow i 0 L); first by rewrite xrowE unitmx_mul unitmx_perm.\n  exists R => //; exists d; rewrite //= xrowE -!mulmxA (mulmxA L) -dM xrowE.\n  by rewrite mulmxA -perm_mxM tperm2 perm_mx1 mul1mx.\nwithout loss /forallP a_dvM0: / [forall j, a %| M 0%R j]%Z.\n  case: (altP forallP) => [_ IH|/forallPn/sigW/IHa IH _]; exact: IH.\nwithout loss{Da a_dvM0} Da: M / forall j, M 0 j = a.\n  pose Uur := col' 0 (\\row_j (1 - (M 0%R j %/ a)%Z)).\n  pose U : 'M_(1 + n) := block_mx 1 Uur 0 1%:M; pose M1 := M *m U.\n  have uU: U \\in unitmx by rewrite unitmxE det_ublock !det1 mulr1.\n  case/(_ (M *m U)) => [j | L uL [R uR [d dvD dM]]].\n    rewrite -(lshift0 m 0) -[M](@submxK _ 1 _ 1) (@mulmx_block _ 1 m 1).\n    rewrite (@col_mxEu _ 1) !mulmx1 mulmx0 addr0 [ulsubmx _]mx11_scalar.\n    rewrite mul_scalar_mx !mxE !lshift0 Da.\n    case: splitP => [j0 _ | j1 Dj]; rewrite ?ord1 !mxE // lshift0 rshift1.\n    by rewrite mulrBr mulr1 mulrC divzK ?subrK.\n  exists L => //; exists (R * U^-1); first by rewrite unitmx_mul uR unitmx_inv.\n  by exists d; rewrite //= mulmxA -dM mulmxK.\nwithout loss{IHa} /forallP/(_ (_, _))/= a_dvM: / [forall k, a %| M k.1 k.2]%Z.\n  case: (altP forallP) => [_|/forallPn/sigW [[i j] /= a'Mij] _]; first exact.\n  have [|||L uL [R uR [d dvD dM]]] := IHa _ _ M^T j; rewrite ?mxE 1?addnC //.\n    by exists i; rewrite mxE.\n  exists R^T; last exists L^T; rewrite ?unitmx_tr //; exists d => //.\n  rewrite -[M]trmxK dM !trmx_mul mulmxA; congr (_ *m _ *m _).\n  by apply/matrixP=> i1 j1 /[!mxE]; case: eqVneq => // ->.\nwithout loss{nz_a a_dvM} a1: M a Da / a = 1.\n  pose M1 := map_mx (divz^~ a) M; case/(_ M1 1)=> // [k|L uL [R uR [d dvD dM]]].\n    by rewrite !mxE Da divzz nz_a.\n  exists L => //; exists R => //; exists [seq a * x | x <- d].\n    case: d dvD {dM} => //= x d; elim: d x => //= y d IHd x /andP[dv_xy /IHd].\n    by rewrite [dvdz _ _]dvdz_mul2l ?[_ \\in _]dv_xy.\n  have ->: M = a *: M1 by apply/matrixP=> i j; rewrite !mxE mulrC divzK ?a_dvM.\n  rewrite dM scalemxAl scalemxAr; congr (_ *m _ *m _).\n  apply/matrixP=> i j; rewrite !mxE mulrnAr; congr (_ *+ _).\n  have [lt_i_d | le_d_i] := ltnP i (size d); first by rewrite (nth_map 0).\n  by rewrite !nth_default ?size_map ?mulr0.\nrewrite {a}a1 -[m.+1]/(1 + m)%N -[n.+1]/(1 + n)%N in M Da *.\npose Mu := ursubmx M; pose Ml := dlsubmx M.\nhave{} Da: ulsubmx M = 1 by rewrite [_ M]mx11_scalar !mxE !lshift0 Da.\npose M1 := - (Ml *m Mu) + drsubmx M.\nhave [|L uL [R uR [d dvD dM1]]] := IHmn m n M1; first by rewrite -addnS ltnW.\nexists (block_mx 1 0 Ml L).\n  by rewrite unitmxE det_lblock det_scalar1 mul1r.\nexists (block_mx 1 Mu 0 R).\n  by rewrite unitmxE det_ublock det_scalar1 mul1r.\nexists (1 :: d); set D1 := \\matrix_(i, j) _ in dM1.\n  by rewrite /= path_min_sorted //; apply/allP => g _; apply: dvd1n.\nrewrite [D in _ *m D *m _](_ : _ = block_mx 1 0 0 D1); last first.\n  by apply/matrixP=> i j; do 3?[rewrite ?mxE ?ord1 //=; case: splitP => ? ->].\nrewrite !mulmx_block !(mul0mx, mulmx0, addr0) !mulmx1 add0r mul1mx -Da -dM1.\nby rewrite addNKr submxK.\nQed."
}
{
  "statement": "Lemma splitting_field_normal K x :\n  exists r, minPoly K x == \\prod_(y <- r) ('X - y%:P).\n",
  "proof": "Proof.\npose q1 := minPoly 1 x; pose fx_root q (f : 'AEnd(L)) := root q (f x).\nhave [[p F0p splitLp] [autL DautL]] := (splittingFieldP, enum_AEnd).\nsuffices{K} autL_px q: q != 0 -> q %| q1 -> size q > 1 -> has (fx_root q) autL.\n  set q := minPoly K x; have: q \\is monic := monic_minPoly K x.\n  have: q %| q1 by rewrite minPolyS // sub1v.\n  have [d] := ubnP (size q); elim: d q => // d IHd q leqd q_dv_q1 mon_q.\n  have nz_q: q != 0 := monic_neq0 mon_q.\n  have [|q_gt1|q_1] := ltngtP (size q) 1; last first; last by rewrite polySpred.\n    by exists nil; rewrite big_nil -eqp_monic ?monic1 // -size_poly_eq1 q_1.\n  have /hasP[f autLf /factor_theorem[q2 Dq]] := autL_px q nz_q q_dv_q1 q_gt1.\n  have mon_q2: q2 \\is monic by rewrite -(monicMr _ (monicXsubC (f x))) -Dq.\n  rewrite Dq size_monicM -?size_poly_eq0 ?size_XsubC ?addn2 //= ltnS in leqd.\n  have q2_dv_q1: q2 %| q1 by rewrite (dvdp_trans _ q_dv_q1) // Dq dvdp_mulr.\n  rewrite Dq; have [r /eqP->] := IHd q2 leqd q2_dv_q1 mon_q2.\n  by exists (f x :: r); rewrite big_cons mulrC.\nhave [d] := ubnP (size q); elim: d q => // d IHd q leqd nz_q q_dv_q1 q_gt1.\nwithout loss{d leqd IHd nz_q q_gt1} irr_q: q q_dv_q1 / irreducible_poly q.\n  move=> IHq; apply: wlog_neg => not_autLx_q; apply: IHq => //.\n  split=> // q2 q2_neq1 q2_dv_q; rewrite -dvdp_size_eqp // eqn_leq dvdp_leq //=.\n  rewrite leqNgt; apply: contra not_autLx_q => ltq2q.\n  have nz_q2: q2 != 0 by apply: contraTneq q2_dv_q => ->; rewrite dvd0p.\n  have{q2_neq1} q2_gt1: size q2 > 1 by rewrite neq_ltn polySpred in q2_neq1 *.\n  have{leqd ltq2q} ltq2d: size q2 < d by apply: leq_trans ltq2q _.\n  apply: sub_has (IHd _ ltq2d nz_q2 (dvdp_trans q2_dv_q q_dv_q1) q2_gt1) => f.\n  by rewrite /fx_root !root_factor_theorem => /dvdp_trans->.\nhave{irr_q} [Lz [inLz [z qz0]]]: {Lz : fieldExtType F &\n  {inLz : 'AHom(L, Lz) & {z : Lz | root (map_poly inLz q) z}}}.\n- have [Lz0 _ [z qz0 defLz]] := irredp_FAdjoin irr_q.\n  pose Lz : fieldExtType _ := baseFieldType Lz0.\n  pose inLz : {rmorphism L -> Lz} := in_alg Lz0.\n  have inLzL_linear: linear (locked inLz).\n    by move=> a u v; rewrite -[in LHS]mulr_algl rmorphD rmorphM -lock mulr_algl.\n  pose inLzLlM := GRing.isLinear.Build _ _ _ _ _ inLzL_linear.\n  pose inLzLL : {linear _ -> _} := HB.pack (locked inLz : _ -> _) inLzLlM.\n  have ihLzZ: ahom_in {:L} (linfun inLzLL).\n    by apply/ahom_inP; split=> [u v|]; rewrite !lfunE (rmorphM, rmorph1).\n  exists Lz, (AHom ihLzZ), z; congr (root _ z): qz0.\n  by apply: eq_map_poly => y; rewrite lfunE /= -lock.\npose imL := [aspace of limg inLz]; pose pz := map_poly inLz p.\nhave in_imL u: inLz u \\in imL by rewrite memv_img ?memvf.\nhave F0pz: pz \\is a polyOver 1%VS.\n  apply/polyOverP=> i; rewrite -(aimg1 inLz) coef_map /= memv_img //.\n  exact: (polyOverP F0p).\nhave{splitLp} splitLpz: splittingFieldFor 1 pz imL.\n  have [r def_p defL] := splitLp; exists (map inLz r) => [|{def_p}].\n    move: def_p; rewrite -(eqp_map inLz) rmorph_prod.\n    rewrite big_map; congr (_ %= _); apply: eq_big => //= y _.\n    by rewrite rmorphB /= map_polyX map_polyC.\n  apply/eqP; rewrite eqEsubv /= -{2}defL {defL}; apply/andP; split.\n    by apply/Fadjoin_seqP; rewrite sub1v; split=> // _ /mapP[y r_y ->].\n  elim/last_ind: r => [|r y IHr] /=; first by rewrite !Fadjoin_nil aimg1.\n  rewrite map_rcons !adjoin_rcons /=.\n  apply/subvP=> _ /memv_imgP[_ /Fadjoin_polyP[p1 r_p1 ->] ->].\n  rewrite -horner_map /= mempx_Fadjoin //=; apply/polyOverP=> i.\n  by rewrite coef_map (subvP IHr) //= memv_img ?(polyOverP r_p1).\nhave [f homLf fxz]: exists2 f : 'End(Lz), kHom 1 imL f & f (inLz x) = z.\n  pose q1z := minPoly 1 (inLz x).\n  have Dq1z: map_poly inLz q1 %| q1z.\n    have F0q1z i: exists a, q1z`_i = a%:A by apply/vlineP/polyOverP/minPolyOver.\n    have [q2 Dq2]: exists q2, q1z = map_poly inLz q2.\n      exists (\\poly_(i < size q1z) (sval (sig_eqW (F0q1z i)))%:A).\n      rewrite -{1}[q1z]coefK; apply/polyP=> i; rewrite coef_map !{1}coef_poly.\n      by case: sig_eqW => a; case: ifP; rewrite /= ?rmorph0 ?rmorph_alg.\n    rewrite Dq2 dvdp_map minPoly_dvdp //.\n      apply/polyOverP=> i; have[a] := F0q1z i.\n      rewrite -(rmorph_alg inLz) Dq2 coef_map /= => /fmorph_inj->.\n      exact/rpredZ/mem1v.\n    by rewrite -(fmorph_root inLz) -Dq2 root_minPoly.\n  have q1z_z: root q1z z.\n    rewrite !root_factor_theorem in qz0 *.\n    by apply: dvdp_trans qz0 (dvdp_trans _ Dq1z); rewrite dvdp_map.\n  have map1q1z_z: root (map_poly \\1%VF q1z) z.\n    by rewrite map_poly_id => // ? _; rewrite lfunE.\n  pose f0 := kHomExtend 1 \\1 (inLz x) z.\n  have{map1q1z_z} hom_f0 : kHom 1 <<1; inLz x>> f0.\n    by apply: kHomExtendP map1q1z_z => //; apply: kHom1.\n  have{} splitLpz: splittingFieldFor <<1; inLz x>> pz imL.\n    have [r def_pz defLz] := splitLpz; exists r => //.\n    apply/eqP; rewrite eqEsubv -{2}defLz adjoin_seqSl ?sub1v // andbT.\n    apply/Fadjoin_seqP; split; last first.\n      by rewrite /= -[limg _]defLz; apply: seqv_sub_adjoin.\n    by apply/FadjoinP/andP; rewrite sub1v memv_img ?memvf.\n  have [f homLzf Df] := kHom_extends (sub1v _) hom_f0 F0pz splitLpz.\n  have [-> | x'z] := eqVneq (inLz x) z.\n    by exists \\1%VF; rewrite ?lfunE ?kHom1.\n  exists f => //; rewrite -Df ?memv_adjoin ?(kHomExtend_val (kHom1 1 1)) //.\n  by rewrite lfun1_poly.\npose f1 := (inLz^-1 \\o f \\o inLz)%VF; have /kHomP[fM fFid] := homLf.\nhave Df1 u: inLz (f1 u) = f (inLz u).\n  rewrite !comp_lfunE limg_lfunVK //= -[limg _]/(asval imL).\n  have [r def_pz defLz] := splitLpz; set r1 := r.\n  have: inLz u \\in <<1 & r1>>%VS by rewrite defLz.\n  have: all [in r] r1 by apply/allP.\n  elim/last_ind: r1 {u}(inLz u) => [|r1 y IHr1] u.\n    by rewrite Fadjoin_nil => _ Fu; rewrite fFid // (subvP (sub1v _)).\n  rewrite all_rcons adjoin_rcons => /andP[rr1 ry] /Fadjoin_polyP[pu r1pu ->].\n  rewrite (kHom_horner homLf) -defLz; last exact: seqv_sub_adjoin; last first.\n    by apply: polyOverS r1pu; apply/subvP/adjoin_seqSr/allP.\n  apply: rpred_horner.\n    by apply/polyOverP=> i; rewrite coef_map /= defLz IHr1 ?(polyOverP r1pu).\n  rewrite seqv_sub_adjoin // -root_prod_XsubC -(eqp_root def_pz).\n  rewrite (kHom_root_id _ homLf) ?sub1v //.\n    by rewrite -defLz seqv_sub_adjoin.\n  by rewrite (eqp_root def_pz) root_prod_XsubC.\nsuffices f1_is_ahom : ahom_in {:L} f1.\n  apply/hasP; exists (AHom f1_is_ahom); first exact: DautL.\n  by rewrite /fx_root -(fmorph_root inLz) /= Df1 fxz.\napply/ahom_inP; split=> [a b _ _|]; apply: (fmorph_inj inLz).\n  by rewrite rmorphM /= !Df1 rmorphM fM ?in_imL.\nby rewrite /= Df1 /= fFid ?rmorph1 ?mem1v.\nQed."
}
{
  "statement": "Lemma solve_Qint_span (vT : vectType rat) m (s : m.-tuple vT) v :\n  {b : int ^ m &\n  {p : seq (int ^ m) &\n  forall a : int ^ m,\n  v = \\sum_(i < m) s`_i *~ a i <->\n  exists c : seq int, a = b + \\sum_(i < size p) p`_i *~ c`_i}} +\n  (~ inIntSpan s v).\n",
  "proof": "Proof.\nhave s_s (i : 'I_m): s`_i \\in <<s>>%VS by rewrite memv_span ?memt_nth.\nhave s_Zs a: \\sum_(i < m) s`_i *~ a i \\in <<s>>%VS.\n  by apply/rpred_sum => i _; apply/rpredMz.\ncase s_v: (v \\in <<s>>%VS); last by right=> [[a Dv]]; rewrite Dv s_Zs in s_v.\nmove SE : (\\matrix_(i < m, j < _) coord (vbasis <<s>>) j s`_i) => S.\nmove rE : (\\rank S) => r; move kE : (m - r)%N => k.\nhave Dm: (m = k + r)%N by rewrite -kE -rE subnK ?rank_leq_row.\nrewrite Dm in s s_s s_Zs s_v S SE rE kE *.\nmove=> {Dm m}; pose m := (k + r)%N.\nhave [K kerK]: {K : 'M_(k, m) | map_mx intr K == kermx S}%MS.\n  move: (mxrank_ker S); rewrite rE kE => krk.\n  pose B := row_base (kermx S); pose d := \\prod_ij denq (B ij.1 ij.2).\n  exists (castmx (krk, erefl m) (map_mx numq (intr d *: B))).\n  rewrite map_castmx !eqmx_cast -map_mx_comp map_mx_id_in => [|i j]; last first.\n    rewrite mxE mulrC [d](bigD1 (i, j)) //= rmorphM mulrA.\n    by rewrite -numqE -rmorphM numq_int.\n  suff nz_d: d%:Q != 0 by rewrite !eqmx_scale // !eq_row_base andbb.\n  by rewrite intr_eq0; apply/prodf_neq0 => i _; apply: denq_neq0.\nhave [L _ [G uG [D _ defK]]] := int_Smith_normal_form K.\nhave {K L D defK kerK} [kerGu kerS_sub_Gu]: map_mx intr (usubmx G) *m S = 0 /\\\n    (kermx S <= map_mx intr (usubmx G))%MS.\n  pose Kl : 'M[rat]_k := map_mx intr (lsubmx (K *m invmx G)).\n  have {}defK: map_mx intr K = Kl *m map_mx intr (usubmx G).\n    rewrite /Kl -map_mxM; congr map_mx.\n    rewrite -[LHS](mulmxKV uG) -{2}[G]vsubmxK -{1}[K *m _]hsubmxK.\n    rewrite mul_row_col -[RHS]addr0; congr (_ + _).\n    rewrite defK mulmxK //= -[RHS](mul0mx _ (dsubmx G)); congr (_ *m _).\n    apply/matrixP => i j; rewrite !mxE big1 //= => j1 _.\n    rewrite mxE /= eqn_leq andbC.\n    by rewrite leqNgt (leq_trans (valP j1)) ?mulr0 ?leq_addr.\n  split; last by rewrite -(eqmxP kerK); apply/submxP; exists Kl.\n  suff /row_full_inj: row_full Kl.\n    by apply; rewrite mulmx0 mulmxA (sub_kermxP _) // -(eqmxP kerK) defK.\n  rewrite /row_full eqn_leq rank_leq_row /= -{1}kE -{2}rE -(mxrank_ker S).\n  by rewrite -(eqmxP kerK) defK mxrankM_maxl.\npose T := map_mx intr (dsubmx G) *m S.\nhave defS: map_mx intr (rsubmx (invmx G)) *m T = S.\n  rewrite mulmxA -map_mxM /=; move: (mulVmx uG).\n  rewrite -{2}[G]vsubmxK -{1}[invmx G]hsubmxK mul_row_col.\n  move/(canRL (addKr _)) ->; rewrite -mulNmx raddfD /= map_mx1 map_mxM /=.\n  by rewrite mulmxDl -mulmxA kerGu mulmx0 add0r mul1mx.\npose vv := \\row_j coord (vbasis <<s>>) j v.\nhave uS: row_full S.\n  apply/row_fullP; exists (\\matrix_(i, j) coord s j (vbasis <<s>>)`_i).\n  apply/matrixP => j1 j2; rewrite !mxE.\n  rewrite -(coord_free _ _ (basis_free (vbasisP _))).\n  rewrite -!tnth_nth (coord_span (vbasis_mem (mem_tnth j1 _))) linear_sum.\n  by apply: eq_bigr => /= i _; rewrite -SE !mxE (tnth_nth 0) !linearZ.\nhave eqST: (S :=: T)%MS by apply/eqmxP; rewrite -{1}defS !submxMl.\ncase Zv: (map_mx denq (vv *m pinvmx T) == const_mx 1); last first.\n  right=> [[a Dv]]; case/eqP: Zv; apply/rowP.\n  have ->: vv = map_mx intr (\\row_i a i) *m S.\n    apply/rowP => j; rewrite !mxE Dv linear_sum.\n    by apply: eq_bigr => i _; rewrite -SE -scaler_int linearZ !mxE.\n  rewrite -defS -2!mulmxA; have ->: T *m pinvmx T = 1%:M.\n    have uT: row_free T by rewrite /row_free -eqST rE.\n    by apply: (row_free_inj uT); rewrite mul1mx mulmxKpV.\n  by move=> i; rewrite mulmx1 -map_mxM 2!mxE denq_int mxE.\npose b := map_mx numq (vv *m pinvmx T) *m dsubmx G.\nleft; exists [ffun j => b 0 j], [seq [ffun j => (usubmx G) i j] | i : 'I_k].\nrewrite size_image card_ord => a; rewrite -[a](addNKr [ffun j => b 0 j]).\nmove: (_ + a) => h; under eq_bigr => i _ do rewrite !ffunE mulrzDr.\nrewrite big_split /=.\nhave <-: v = \\sum_(i < m) s`_i *~ b 0 i.\n  transitivity (\\sum_j (map_mx intr b *m S) 0 j *: (vbasis <<s>>)`_j).\n    rewrite {1}(coord_vbasis s_v); apply: eq_bigr => j _; congr (_ *: _).\n    suff ->: map_mx intr b = vv *m pinvmx T *m map_mx intr (dsubmx G).\n      by rewrite -(mulmxA _ _ S) mulmxKpV ?mxE // -eqST submx_full.\n    rewrite map_mxM /=; congr (_ *m _); apply/rowP => i; rewrite 2!mxE numqE.\n    by have /eqP/rowP/(_ i)/[!mxE] -> := Zv; rewrite mulr1.\n  rewrite (coord_vbasis (s_Zs _)); apply: eq_bigr => j _; congr (_ *: _).\n  rewrite linear_sum mxE; apply: eq_bigr => i _.\n  by rewrite -SE -scaler_int linearZ [b]lock !mxE.\nsplit.\n  rewrite -[LHS]addr0 => /addrI hP; pose c := \\row_i h i *m lsubmx (invmx G).\n  exists [seq c 0 i | i : 'I_k]; congr (_ + _).\n  have/sub_kermxP: map_mx intr (\\row_i h i) *m S = 0.\n    transitivity (\\row_j coord (vbasis <<s>>) j (\\sum_(i < m) s`_i *~ h i)).\n      apply/rowP => j; rewrite !mxE linear_sum; apply: eq_bigr => i _.\n      by rewrite -SE !mxE -scaler_int linearZ.\n    by apply/rowP => j; rewrite !mxE -hP linear0.\n  case/submx_trans/(_ kerS_sub_Gu)/submxP => c' /[dup].\n  move/(congr1 (mulmx^~ (map_mx intr (lsubmx (invmx G))))).\n  rewrite -mulmxA -!map_mxM [in RHS]mulmx_lsub mul_usub_mx -/c mulmxV //=.\n  rewrite scalar_mx_block -/(ulsubmx _) block_mxKul map_scalar_mx mulmx1.\n  move=> <- {c'}; rewrite -map_mxM /= => defh; apply/ffunP => j.\n  move/rowP/(_ j): defh; rewrite sum_ffunE !mxE => /intr_inj ->.\n  apply: eq_bigr => i _; rewrite ffunMzE mulrzz mulrC.\n  rewrite (nth_map i) ?size_enum_ord // nth_ord_enum ffunE.\n  by rewrite (nth_map i) ?size_enum_ord // nth_ord_enum.\ncase=> c /addrI -> {h}; rewrite -[LHS]addr0; congr (_ + _).\npose h := \\row_(j < k) c`_j *m usubmx G.\ntransitivity (\\sum_j (map_mx intr h *m S) 0 j *: (vbasis <<s>>)`_j).\n  by rewrite map_mxM -mulmxA kerGu mulmx0 big1 // => j _; rewrite mxE scale0r.\nrewrite (coord_vbasis (s_Zs _)); apply: eq_bigr => i _; congr (_ *: _).\nrewrite linear_sum -SE mxE; apply: eq_bigr => j _.\nrewrite -scaler_int linearZ !mxE sum_ffunE; congr (_%:~R * _).\napply: {i} eq_bigr => i _; rewrite mxE ffunMzE mulrzz mulrC.\nby rewrite (nth_map i) ?size_enum_ord // ffunE nth_ord_enum.\nQed."
}
{
  "statement": "Lemma modular_group_structure gT (G : {group gT}) x y :\n    extremal_generators G p n (x, y) ->\n    G \\isog 'Mod_m -> modular_group_generators (x, y) ->\n  let X := <[x]> in\n  [/\\ [/\\ X ><| <[y]> = G, ~~ abelian G\n        & {in X, forall z j, z ^ (y ^+ j) = z ^+ (j * r).+1}],\n      [/\\ 'Z(G) = <[x ^+ p]>, 'Phi(G) = 'Z(G) & #|'Z(G)| = r],\n      [/\\ G^`(1) = <[x ^+ r]>, #|G^`(1)| = p & nil_class G = 2],\n      forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (p ^ k)]>\n    & if (p, n) == (2, 3) then 'Ohm_1(G) = G else\n      forall k, 0 < k < n.-1 ->\n         <[x ^+ (p ^ (n - k.+1))]> \\x <[y]> = 'Ohm_k(G)\n      /\\ #|'Ohm_k(G)| = (p ^ k.+1)%N].\n",
  "proof": "Proof.\nmove=> genG isoG [oy xy] X.\nhave [oG Gx ox /setDP[Gy notXy]] := genG; rewrite -/m -/q in ox oG.\nhave [pG _ nsXG defXY nXY] := extremal_generators_facts p_pr genG.\nhave [sXG nXG] := andP nsXG; have sYG: <[y]> \\subset G by rewrite cycle_subG.\nhave n1_gt1: n.-1 > 1 by [rewrite def_n]; have n1_gt0 := ltnW n1_gt1.\nhave def_n1 := prednK n1_gt0.\nhave def_m: (q * p)%N = m by rewrite -expnSr /m def_n.\nhave notcxy: y \\notin 'C[x].\n  apply: contraL (introT eqP xy); move/cent1P=> cxy.\n  rewrite /conjg -cxy // eq_mulVg1 expgS !mulKg -order_dvdn ox.\n  by rewrite pfactor_dvdn ?expn_gt0 ?p_gt0 // pfactorK // -ltnNge prednK.\nhave tiXY: <[x]> :&: <[y]> = 1.\n  rewrite setIC prime_TIg -?orderE ?oy //; apply: contra notcxy.\n  by rewrite cycle_subG; apply: subsetP; rewrite cycle_subG cent1id.\nhave notcGG: ~~ abelian G.\n  by rewrite -defXY abelianM !cycle_abelian cent_cycle cycle_subG.\nhave cXpY: <[y]> \\subset 'C(<[x ^+ p]>).\n  rewrite cent_cycle cycle_subG cent1C (sameP cent1P commgP) /commg conjXg xy.\n  by rewrite -expgM mulSn expgD mulKg -expnSr def_n1 -/q -ox expg_order.\nhave oxp: #[x ^+ p] = r by rewrite orderXdiv ox ?dvdn_exp //.\nhave [sZG nZG] := andP (center_normal G).\nhave defZ: 'Z(G) = <[x ^+ p]>.\n  apply/eqP; rewrite eq_sym eqEcard subsetI -{2}defXY centM subsetI cent_cycle.\n  rewrite 2!cycle_subG !groupX ?cent1id //= centsC cXpY /= -orderE oxp leqNgt.\n  apply: contra notcGG => gtZr; apply: cyclic_center_factor_abelian.\n  rewrite (dvdn_prime_cyclic p_pr) // card_quotient //.\n  rewrite -(dvdn_pmul2l (cardG_gt0 'Z(G))) Lagrange // oG -def_m dvdn_pmul2r //.\n  case/p_natP: (pgroupS sZG pG) gtZr => k ->.\n  by rewrite ltn_exp2l // def_n1; apply: dvdn_exp2l.\nhave Zxr: x ^+ r \\in 'Z(G) by rewrite /r def_n expnS expgM defZ mem_cycle.\nhave rxy: [~ x, y] = x ^+ r by rewrite /commg xy expgS mulKg.\nhave defG': G^`(1) = <[x ^+ r]>.\n  case/setIP: Zxr => _; rewrite -rxy -defXY -(norm_joinEr nXY).\n  exact: der1_joing_cycles.\nhave oG': #|G^`(1)| = p.\n  by rewrite defG' -orderE orderXdiv ox /q -def_n1 ?dvdn_exp2l // expnS mulnK.\nhave sG'Z: G^`(1) \\subset 'Z(G) by rewrite defG' cycle_subG.\nhave nil2_G: nil_class G = 2.\n  by apply/eqP; rewrite eqn_leq andbC ltnNge nil_class1 notcGG nil_class2.\nhave XYp: {in X & <[y]>, forall z t,\n   (z * t) ^+ p \\in z ^+ p *: <[x ^+ r ^+ 'C(p, 2)]>}.\n- move=> z t Xz Yt; have Gz := subsetP sXG z Xz; have Gt := subsetP sYG t Yt.\n  have Rtz: [~ t, z] \\in G^`(1) by apply: mem_commg.\n  have cGtz: [~ t, z] \\in 'C(G) by case/setIP: (subsetP sG'Z _ Rtz).\n  rewrite expMg_Rmul /commute ?(centP cGtz) //.\n  have ->: t ^+ p = 1 by apply/eqP; rewrite -order_dvdn -oy order_dvdG.\n  rewrite defG' in Rtz; case/cycleP: Rtz => i ->.\n  by rewrite mem_lcoset mulg1 mulKg expgAC mem_cycle.\nhave defMho: 'Mho^1(G) = <[x ^+ p]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (Mho_p_elt 1) ?(mem_p_elt pG) //.\n  rewrite andbT (MhoE 1 pG) gen_subG -defXY; apply/subsetP=> ztp.\n  case/imsetP=> zt; case/imset2P=> z t Xz Yt -> -> {zt ztp}.\n  apply: subsetP (XYp z t Xz Yt); case/cycleP: Xz => i ->.\n  by rewrite expgAC mul_subG ?sub1set ?mem_cycle //= -defZ cycle_subG groupX.\nsplit=> //; try exact: extend_cyclic_Mho.\n- rewrite sdprodE //; split=> // z; case/cycleP=> i ->{z} j.\n  rewrite conjXg -expgM mulnC expgM actX; congr (_ ^+ i).\n  elim: j {i} => //= j ->; rewrite conjXg xy -!expgM mulnS mulSn addSn.\n  rewrite addnA -mulSn -addSn expgD mulnCA (mulnC j).\n  rewrite {3}/r def_n expnS mulnA -expnSr def_n1 -/q -ox -mulnA expgM.\n  by rewrite expg_order expg1n mulg1.\n- by rewrite (Phi_joing pG) defMho -defZ (joing_idPr _) ?defZ.\nhave G1y: y \\in 'Ohm_1(G).\n  by rewrite (OhmE _ pG) mem_gen // !inE Gy -order_dvdn oy /=.\ncase: eqP => [[p2 n3] | notG8 k]; last case/andP=> k_gt0 lt_k_n1.\n  apply/eqP; rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n  rewrite G1y -(groupMr _ G1y) /= (OhmE _ pG) mem_gen // !inE groupM //.\n  rewrite /q /r p2 n3 in oy ox xy *.\n  by rewrite expgS -mulgA -{1}(invg2id oy) -conjgE xy -expgS -order_dvdn ox.\nhave le_k_n2: k <= n.-2 by rewrite -def_n1 in lt_k_n1.\nsuffices{lt_k_n1} defGk: <[x ^+ (p ^ (n - k.+1))]> \\x <[y]> = 'Ohm_k(G).\n  split=> //; case/dprodP: defGk => _ <- _ tiXkY; rewrite expnSr TI_cardMg //.\n  rewrite -!orderE oy (subnDA 1) subn1 orderXdiv ox ?dvdn_exp2l ?leq_subr //.\n  by rewrite /q -{1}(subnK (ltnW lt_k_n1)) expnD mulKn // expn_gt0 p_gt0.\nsuffices{k k_gt0 le_k_n2} defGn2: <[x ^+ p]> \\x <[y]> = 'Ohm_(n.-2)(G).\n  have:= Ohm_dprod k defGn2; have p_xp := mem_p_elt pG (groupX p Gx).\n  rewrite (Ohm_p_cycle _ p_xp) (Ohm_p_cycle _ (mem_p_elt pG Gy)) oxp oy.\n  rewrite pfactorK ?(pfactorK 1) // (eqnP k_gt0) expg1 -expgM -expnS.\n  rewrite -subSn // -subSS def_n1 def_n => -> /=; rewrite ?add1n subnSK // subn2.\n  by apply/eqP; rewrite eqEsubset OhmS ?Ohm_sub //= -{1}Ohm_id OhmS ?Ohm_leq.\nrewrite dprodEY //=; last by apply/trivgP; rewrite -tiXY setSI ?cycleX.\napply/eqP; rewrite eqEsubset join_subG !cycle_subG /= [in y \\in _]def_n.\nrewrite (subsetP (Ohm_leq G (ltn0Sn _)) y) //= (OhmE _ pG) -/r.\nrewrite mem_gen /=; last by rewrite !inE -order_dvdn oxp groupX /=.\nrewrite gen_subG /= cent_joinEr // -defXY; apply/subsetP=> uv; case/setIP.\ncase/imset2P=> u v Xu Yv ->{uv}; rewrite /r inE def_n expnS expgM.\ncase/lcosetP: (XYp u v Xu Yv) => _ /cycleP[j ->] ->.\ncase/cycleP: Xu => i ->{u}; rewrite -!(expgM, expgD) -order_dvdn ox.\nrewrite (mulnC r) /r {1}def_n expnSr mulnA -mulnDl -mulnA -expnS.\nrewrite subnSK  // subn2 /q -def_n1 expnS dvdn_pmul2r // dvdn_addl.\n  by case/dvdnP=> k ->; rewrite mulnC expgM mem_mulg ?mem_cycle.\ncase: (ltngtP n 3) => [|n_gt3|n3]; first by rewrite ltnNge n_gt2.\n  by rewrite -subnSK // expnSr mulnA dvdn_mull.\ncase: (even_prime p_pr) notG8 => [-> | oddp _]; first by rewrite n3.\nby rewrite bin2odd // -!mulnA dvdn_mulr.\nQed."
}
{
  "statement": "Theorem Frobenius_Ldiv (gT : finGroupType) (G : {group gT}) n :\n  n %| #|G| -> n %| #|'Ldiv_n(G)|.\n",
  "proof": "Proof.\nmove=> nG; move: {2}_.+1 (ltnSn (#|G| %/ n)) => mq.\nelim: mq => // mq IHm in gT G n nG *; case/dvdnP: nG => q oG.\nhave [q_gt0 n_gt0] : 0 < q /\\ 0 < n by apply/andP; rewrite -muln_gt0 -oG.\nrewrite ltnS oG mulnK // => leqm.\nhave:= q_gt0; rewrite leq_eqVlt => /predU1P[q1 | lt1q].\n  rewrite -(mul1n n) q1 -oG (setIidPl _) //.\n  by apply/subsetP=> x Gx; rewrite inE -order_dvdn order_dvdG.\npose p := pdiv q; have pr_p: prime p by apply: pdiv_prime.\nhave lt1p: 1 < p := prime_gt1 pr_p; have p_gt0 := ltnW lt1p.\nhave{leqm} lt_qp_mq: q %/ p < mq by apply: leq_trans leqm; rewrite ltn_Pdiv.\nhave: n %| #|'Ldiv_(p * n)(G)|.\n  have: p * n %| #|G| by rewrite oG dvdn_pmul2r ?pdiv_dvd.\n  move/IHm=> IH; apply: dvdn_trans (IH _); first exact: dvdn_mull.\n  by rewrite oG divnMr.\nrewrite -(cardsID 'Ldiv_n()) dvdn_addl.\n  rewrite -setIA ['Ldiv_n(_)](setIidPr _) //.\n  by apply/subsetP=> x; rewrite !inE -!order_dvdn; apply: dvdn_mull.\nrewrite -setIDA; set A := _ :\\: _.\nhave pA x: x \\in A -> #[x]`_p = (n`_p * p)%N.\n  rewrite !inE -!order_dvdn => /andP[xn xnp].\n  rewrite !p_part // -expnSr; congr (p ^ _)%N; apply/eqP.\n  rewrite eqn_leq -{1}addn1 -(pfactorK 1 pr_p) -lognM ?expn1 // mulnC.\n  rewrite dvdn_leq_log ?muln_gt0 ?p_gt0 //= ltnNge; apply: contra xn => xn.\n  move: xnp; rewrite -[#[x]](partnC p) //.\n  rewrite !Gauss_dvd ?coprime_partC //; case/andP=> _.\n  rewrite p_part ?pfactor_dvdn // xn Gauss_dvdr // coprime_sym.\n  exact: pnat_coprime (pnat_id _) (part_pnat _ _).\nrewrite -(partnC p n_gt0) Gauss_dvd ?coprime_partC //; apply/andP; split.\n  rewrite -sum1_card (partition_big_imset (@cycle _)) /=.\n  apply: dvdn_sum => _ /imsetP[x /setIP[Gx Ax] ->].\n  rewrite (eq_bigl (generator <[x]>)) => [|y].\n    rewrite sum1dep_card -totient_gen -[#[x]](partnC p) //.\n    rewrite totient_coprime ?coprime_partC // dvdn_mulr // .\n    by rewrite (pA x Ax) p_part // -expnSr totient_pfactor // dvdn_mull.\n  rewrite /generator eq_sym andbC; case xy: {+}(_ == _) => //.\n  rewrite !inE -!order_dvdn in Ax *.\n  by rewrite -cycle_subG /order -(eqP xy) cycle_subG Gx.\nrewrite -sum1_card (partition_big_imset (fun x => x.`_p ^: G)) /=.\napply: dvdn_sum => _ /imsetP[x /setIP[Gx Ax] ->].\nset y := x.`_p; have oy: #[y] = (n`_p * p)%N by rewrite order_constt pA.\nrewrite (partition_big (fun x => x.`_p) [in y ^: G]) /= => [|z]; last first.\n  by case/andP=> _ /eqP <-; rewrite /= class_refl.\npose G' := ('C_G[y] / <[y]>)%G; pose n' := gcdn #|G'| n`_p^'.\nhave n'_gt0: 0 < n' by rewrite gcdn_gt0 cardG_gt0.\nrewrite (eq_bigr (fun _ => #|'Ldiv_n'(G')|)) => [|_ /imsetP[a Ga ->]].\n  rewrite sum_nat_const -index_cent1 indexgI.\n  rewrite -(dvdn_pmul2l (cardG_gt0 'C_G[y])) mulnA LagrangeI.\n  have oCy: #|'C_G[y]| = (#[y] * #|G'|)%N.\n    rewrite card_quotient ?subcent1_cycle_norm // Lagrange //.\n    by rewrite subcent1_cycle_sub ?groupX.\n  rewrite oCy -mulnA -(muln_lcm_gcd #|G'|) -/n' mulnA dvdn_mul //.\n    rewrite muln_lcmr -oCy order_constt pA // mulnAC partnC // dvdn_lcm.\n    by rewrite cardSg ?subsetIl // mulnC oG dvdn_pmul2r ?pdiv_dvd.\n  apply: IHm; [exact: dvdn_gcdl | apply: leq_ltn_trans lt_qp_mq].\n  rewrite -(@divnMr n`_p^') // -muln_lcm_gcd mulnC divnMl //.\n  rewrite leq_divRL // divn_mulAC ?leq_divLR ?dvdn_mulr ?dvdn_lcmr //.\n  rewrite dvdn_leq ?muln_gt0 ?q_gt0 //= mulnC muln_lcmr dvdn_lcm.\n  rewrite -(@dvdn_pmul2l n`_p) // mulnA -oy -oCy mulnCA partnC // -oG.\n  by rewrite cardSg ?subsetIl // dvdn_mul ?pdiv_dvd.\npose h := [fun z => coset <[y]> (z ^ a^-1)].\npose h' := [fun Z : coset_of <[y]> => (y * (repr Z).`_p^') ^ a].\nrewrite -sum1_card (reindex_onto h h') /= => [|Z]; last first.\n  rewrite conjgK coset_kerl ?cycle_id ?morph_constt ?repr_coset_norm //.\n  rewrite /= coset_reprK 2!inE -order_dvdn dvdn_gcd => /and3P[_ _ p'Z].\n  by apply: constt_p_elt (pnat_dvd p'Z _); apply: part_pnat.\napply: eq_bigl => z; apply/andP/andP=> [[]|[]].\n  rewrite inE -andbA => /and3P[Gz Az _] /eqP zp_ya.\n  have czy: z ^ a^-1 \\in 'C[y].\n    rewrite -mem_conjg -normJ conjg_set1 -zp_ya.\n    by apply/cent1P; apply: commuteX.\n  have Nz:  z ^ a^-1 \\in 'N(<[y]>) by apply: subsetP czy; apply: norm_gen.\n  have G'z: h z \\in G' by rewrite mem_morphim //= inE groupJ // groupV.\n  rewrite inE G'z inE -order_dvdn dvdn_gcd order_dvdG //=.\n  rewrite /order -morphim_cycle // -quotientE card_quotient ?cycle_subG //.\n  rewrite -(@dvdn_pmul2l #[y]) // Lagrange; last first.\n    by rewrite /= cycleJ cycle_subG mem_conjgV -zp_ya mem_cycle.\n  rewrite oy mulnAC partnC // [#|_|]orderJ; split.\n    by rewrite !inE -!order_dvdn mulnC in Az; case/andP: Az.\n  set Z := coset _ _; have NZ := repr_coset_norm Z; have:= coset_reprK Z.\n  case/kercoset_rcoset=> {NZ}// _ /cycleP[i ->] ->{Z}.\n  rewrite consttM; last exact/commute_sym/commuteX/cent1P.\n  rewrite (constt1P _) ?p_eltNK 1?p_eltX ?p_elt_constt // mul1g.\n  by rewrite conjMg consttJ conjgKV -zp_ya consttC.\nrewrite 2!inE -order_dvdn; set Z := coset _ _ => /andP[Cz n'Z] /eqP def_z.\nhave Nz: z ^ a^-1 \\in 'N(<[y]>).\n  rewrite -def_z conjgK groupMr; first by rewrite -(cycle_subG y) normG.\n  by rewrite groupX ?repr_coset_norm.\nhave{Cz} /setIP[Gz Cz]: z ^ a^-1 \\in 'C_G[y].\n  case/morphimP: Cz => u Nu Cu /kercoset_rcoset[] // _ /cycleP[i ->] ->.\n  by rewrite groupMr // groupX // inE groupX //; apply/cent1P.\nhave{def_z} zp_ya: z.`_p = y ^ a.\n  rewrite -def_z consttJ consttM.\n    rewrite constt_p_elt ?p_elt_constt //.\n    by rewrite (constt1P _) ?p_eltNK ?p_elt_constt ?mulg1.\n  apply: commute_sym; apply/cent1P.\n  by rewrite -def_z conjgK groupMl // in Cz; apply/cent1P.\nhave ozp: #[z ^ a^-1]`_p = #[y] by rewrite -order_constt consttJ zp_ya conjgK.\nsplit; rewrite zp_ya // -class_lcoset lcoset_id // eqxx andbT.\nrewrite -(conjgKV a z) !inE groupJ //= -!order_dvdn orderJ; apply/andP; split.\n  apply: contra (partn_dvd p n_gt0) _.\n  by rewrite ozp -(muln1 n`_p) oy dvdn_pmul2l // dvdn1 neq_ltn lt1p orbT.\nrewrite -(partnC p n_gt0) mulnCA mulnA -oy -(@partnC p #[_]) // ozp.\napply dvdn_mul => //; apply: dvdn_trans (dvdn_trans n'Z (dvdn_gcdr _ _)).\nrewrite {2}/order -morphim_cycle // -quotientE card_quotient ?cycle_subG //.\nrewrite -(@dvdn_pmul2l #|<[z ^ a^-1]> :&: <[y]>|) ?cardG_gt0 // LagrangeI.\nrewrite -[#|<[_]>|](partnC p) ?order_gt0 // dvdn_pmul2r // ozp.\nby rewrite cardSg ?subsetIr.\nQed."
}
{
  "statement": "Theorem Baer_Suzuki x G :\n    x \\in G -> (forall y, y \\in G -> p.-group <<[set x; x ^ y]>>) ->\n  x \\in 'O_p(G).\n",
  "proof": "Proof.\nhave [n] := ubnP #|G|; elim: n G x => // n IHn G x /ltnSE-leGn Gx pE.\nset E := x ^: G; have{} pE: {in E &, forall x1 x2, p.-group <<[set x1; x2]>>}.\n  move=> _ _ /imsetP[y1 Gy1 ->] /imsetP[y2 Gy2 ->].\n  rewrite -(mulgKV y1 y2) conjgM -2!conjg_set1 -conjUg genJ pgroupJ.\n  by rewrite pE // groupMl ?groupV.\nhave sEG: <<E>> \\subset G by rewrite gen_subG class_subG.\nhave nEG: G \\subset 'N(E) by apply: class_norm.\nhave Ex: x \\in E by apply: class_refl.\nhave [P Px sylP]: exists2 P : {group gT}, x \\in P & p.-Sylow(<<E>>) P.\n  have sxxE: <<[set x; x]>> \\subset <<E>> by rewrite genS // setUid sub1set.\n  have{sxxE} [P sylP sxxP] := Sylow_superset sxxE (pE _ _ Ex Ex).\n  by exists P => //; rewrite (subsetP sxxP) ?mem_gen ?setU11.\ncase sEP: (E \\subset P).\n  apply: subsetP Ex; rewrite -gen_subG; apply: pcore_max.\n    by apply: pgroupS (pHall_pgroup sylP); rewrite gen_subG.\n  by rewrite /normal gen_subG class_subG // norms_gen.\npose P_yD D := [pred y in E :\\: P | p.-group <<y |: D>>].\npose P_D := [pred D : {set gT} | D \\subset P :&: E & [exists y, P_yD D y]].\nhave{Ex Px}: P_D [set x].\n  rewrite /= sub1set inE Px Ex; apply/existsP=> /=.\n  by case/subsetPn: sEP => y Ey Py; exists y; rewrite inE Ey Py pE.\ncase/(@maxset_exists _ P_D)=> D /maxsetP[]; rewrite {P_yD P_D}/=.\nrewrite subsetI sub1set -andbA => /and3P[sDP sDE /existsP[y0]].\nset B := _ |: D; rewrite inE -andbA => /and3P[Py0 Ey0 pB] maxD Dx.\nhave sDgE: D \\subset <<E>> by apply: sub_gen.\nhave sDG: D \\subset G by apply: subset_trans sEG.\nhave sBE: B \\subset E by rewrite subUset sub1set Ey0.\nhave sBG: <<B>> \\subset G by apply: subset_trans (genS _) sEG.\nhave sDB: D \\subset B by rewrite subsetUr.\nhave defD: D :=: P :&: <<B>> :&: E.\n  apply/eqP; rewrite eqEsubset ?subsetI sDP sDE sub_gen //=.\n  apply/setUidPl; apply: maxD; last apply: subsetUl.\n  rewrite subUset subsetI sDP sDE setIAC subsetIl.\n  apply/existsP; exists y0; rewrite inE Py0 Ey0 /= setUA -/B.\n  by rewrite -[<<_>>]joing_idl joingE setKI genGid.\nhave nDD: D \\subset 'N(D).\n  apply/subsetP=> z Dz; rewrite inE defD.\n  apply/subsetP=> _ /imsetP[y /setIP[PBy Ey] ->].\n  rewrite inE groupJ // ?inE ?(subsetP sDP) ?mem_gen ?setU1r //= memJ_norm //.\n  exact: (subsetP (subset_trans sDG nEG)).\ncase nDG: (G \\subset 'N(D)).\n  apply: subsetP Dx; rewrite -gen_subG pcore_max ?(pgroupS (genS _) pB) //.\n  by rewrite /normal gen_subG sDG norms_gen.\nhave{n leGn IHn nDG} pN: p.-group <<'N_E(D)>>.\n  apply: pgroupS (pcore_pgroup p 'N_G(D)); rewrite gen_subG /=.\n  apply/subsetP=> x1 /setIP[Ex1 Nx1]; apply: IHn => [||y Ny].\n  - apply: leq_trans leGn; rewrite proper_card // /proper subsetIl.\n    by rewrite subsetI nDG andbF.\n  - by rewrite inE Nx1 (subsetP sEG) ?mem_gen.\n  have Ex1y: x1 ^ y \\in E.\n    by rewrite -mem_conjgV (normsP nEG) // groupV; case/setIP: Ny.\n  by apply: pgroupS (genS _) (pE _ _ Ex1 Ex1y); apply/subsetP => u /[!inE].\nhave [y1 Ny1 Py1]: exists2 y1, y1 \\in 'N_E(D) & y1 \\notin P.\n  case sNN: ('N_<<B>>('N_<<B>>(D)) \\subset 'N_<<B>>(D)).\n    exists y0 => //; have By0: y0 \\in <<B>> by rewrite mem_gen ?setU11.\n    rewrite inE Ey0 -By0 -in_setI.\n    by rewrite -['N__(D)](nilpotent_sub_norm (pgroup_nil pB)) ?subsetIl.\n  case/subsetPn: sNN => z /setIP[Bz NNz]; rewrite inE Bz inE.\n  case/subsetPn=> y; rewrite mem_conjg => Dzy Dy.\n  have:= Dzy; rewrite {1}defD; do 2![case/setIP]=> _ Bzy Ezy.\n  have Ey: y \\in E by rewrite -(normsP nEG _ (subsetP sBG z Bz)) mem_conjg.\n  have /setIP[By Ny]: y \\in 'N_<<B>>(D).\n    by rewrite -(normP NNz) mem_conjg inE Bzy ?(subsetP nDD).\n  exists y; first by rewrite inE Ey.\n  by rewrite defD 2!inE Ey By !andbT in Dy.\nhave [y2 Ny2 Dy2]: exists2 y2, y2 \\in 'N_(P :&: E)(D) & y2 \\notin D.\n  case sNN: ('N_P('N_P(D)) \\subset 'N_P(D)).\n    have [z /= Ez sEzP] := Sylow_Jsub sylP (genS sBE) pB.\n    have Gz: z \\in G by apply: subsetP Ez.\n    have /subsetPn[y Bzy Dy]: ~~ (B :^ z \\subset D).\n      apply/negP; move/subset_leq_card; rewrite cardJg cardsU1.\n      by rewrite {1}defD 2!inE (negPf Py0) ltnn.\n    exists y => //; apply: subsetP Bzy.\n    rewrite -setIA setICA subsetI sub_conjg (normsP nEG) ?groupV // sBE.\n    have nilP := pgroup_nil (pHall_pgroup sylP).\n    by rewrite -['N__(_)](nilpotent_sub_norm nilP) ?subsetIl // -gen_subG genJ.\n  case/subsetPn: sNN => z /setIP[Pz NNz]; rewrite 2!inE Pz.\n  case/subsetPn=> y Dzy Dy; exists y => //; apply: subsetP Dzy.\n  rewrite -setIA setICA subsetI sub_conjg (normsP nEG) ?groupV //.\n    by rewrite sDE -(normP NNz); rewrite conjSg subsetI sDP.\n  by apply: subsetP Pz; apply: (subset_trans (pHall_sub sylP)).\nsuff{Dy2} Dy2D: y2 |: D = D by rewrite -Dy2D setU11 in Dy2.\napply: maxD; last by rewrite subsetUr.\ncase/setIP: Ny2 => PEy2 Ny2; case/setIP: Ny1 => Ey1 Ny1.\nrewrite subUset sub1set PEy2 subsetI sDP sDE.\napply/existsP; exists y1; rewrite inE Ey1 Py1; apply: pgroupS pN.\nrewrite genS // !subUset !sub1set !in_setI Ey1 Ny1.\nby case/setIP: PEy2 => _ ->; rewrite Ny2 subsetI sDE.\nQed."
}
{
  "statement": "Lemma simple_Alt5_base (T : finType) : #|T| = 5 -> simple 'Alt_T.\n",
  "proof": "Proof.\nmove=> oT.\nhave F1: #|'Alt_T| = 60 by apply: double_inj; rewrite -mul2n card_Alt oT.\nhave FF (H : {group {perm T}}): H <| 'Alt_T -> H :<>: 1 -> 20 %| #|H|.\n- move=> Hh1 Hh3.\n  have [x _]: exists x, x \\in T by apply/existsP/eqP; rewrite oT.\n  have F2 := Alt_trans T; rewrite oT /= in F2.\n  have F3: [transitive 'Alt_T, on setT | 'P] by apply: ntransitive1 F2.\n  have F4: [primitive 'Alt_T, on setT | 'P] by apply: ntransitive_primitive F2.\n  case: (prim_trans_norm F4 Hh1) => F5.\n    by case: Hh3; apply/trivgP; apply: subset_trans F5 (aperm_faithful _).\n  have F6: 5 %| #|H| by rewrite -oT -cardsT (atrans_dvd F5).\n  have F7: 4 %| #|H|.\n    have F7: #|[set~ x]| = 4 by rewrite cardsC1 oT.\n    case: (pickP [in [set~ x]]) => [y Hy | ?]; last by rewrite eq_card0 in F7.\n    pose K := 'C_H[x | 'P]%G.\n    have F8 : K \\subset H by apply: subsetIl.\n    pose Gx := 'C_('Alt_T)[x | 'P]%G.\n    have F9: [transitive^2 Gx, on [set~ x] | 'P].\n      by rewrite -[[set~ x]]setTI -setDE stab_ntransitive ?inE.\n    have F10: [transitive Gx, on [set~ x] | 'P].\n      exact: ntransitive1 F9.\n    have F11: [primitive Gx, on [set~ x] | 'P].\n      exact: ntransitive_primitive F9.\n    have F12: K \\subset Gx by apply: setSI; apply: normal_sub.\n    have F13: K <| Gx by rewrite /(K <| _) F12 normsIG // normal_norm.\n    case: (prim_trans_norm F11 F13) => Ksub; last first.\n      by apply: dvdn_trans (cardSg F8); rewrite -F7; apply: atrans_dvd Ksub.\n    have F14: [faithful Gx, on [set~ x] | 'P].\n      apply/subsetP=> g; do 2![case/setIP] => Altg cgx cgx'.\n      apply: (subsetP (aperm_faithful 'Alt_T)).\n      rewrite inE Altg /=; apply/astabP=> z _.\n      case: (z =P x) => [->|]; first exact: (astab1P cgx).\n      by move/eqP=> nxz; rewrite (astabP cgx') ?inE //.\n    have Hreg g (z : T): g \\in H -> g z = z -> g = 1.\n      have F15 h: h \\in H -> h x = x -> h = 1.\n        move=> Hh Hhx; have: h \\in K by rewrite inE Hh; apply/astab1P.\n        by rewrite (trivGP (subset_trans Ksub F14)) => /set1P.\n      move=> Hg Hgz; have:= in_setT x; rewrite -(atransP F3 z) ?inE //.\n      case/imsetP=> g1 Hg1 Hg2; apply: (conjg_inj g1); rewrite conj1g.\n      apply: F15; last by rewrite Hg2 -permM mulKVg permM Hgz.\n      by case/normalP: Hh1 => _ nH1; rewrite -(nH1 _ Hg1) memJ_conjg.\n    clear K F8 F12 F13 Ksub F14.\n    case: (Cauchy _ F6) => // h Hh /eqP Horder.\n    have diff_hnx_x n: 0 < n -> n < 5 -> x != (h ^+ n) x.\n      move=> Hn1 Hn2; rewrite eq_sym; apply/negP => HH.\n      have: #[h ^+ n] = 5.\n        rewrite orderXgcd // (eqP Horder).\n        by move: Hn1 Hn2 {HH}; do 5 (case: n => [|n] //).\n      have Hhd2: h ^+ n \\in H by rewrite groupX.\n      by rewrite (Hreg _ _ Hhd2 (eqP HH)) order1.\n    pose S1 := [tuple x; h x; (h ^+ 3) x].\n    have DnS1: S1 \\in 3.-dtuple(setT).\n      rewrite inE memtE subset_all /= !inE /= !negb_or -!andbA /= andbT.\n      rewrite -{1}[h]expg1 !diff_hnx_x // expgSr permM.\n      by rewrite (inj_eq perm_inj) diff_hnx_x.\n    pose S2 := [tuple x; h x; (h ^+ 2) x].\n    have DnS2:  S2 \\in 3.-dtuple(setT).\n      rewrite inE memtE subset_all /= !inE /= !negb_or -!andbA /= andbT.\n      rewrite -{1}[h]expg1 !diff_hnx_x // expgSr permM.\n      by rewrite (inj_eq perm_inj) diff_hnx_x.\n    case: (atransP2 F2 DnS1 DnS2) => g Hg [/=].\n    rewrite /aperm => Hgx Hghx Hgh3x.\n    have h_g_com: h * g = g * h.\n      suff HH: (g * h * g^-1) * h^-1 = 1 by rewrite -[h * g]mul1g -HH !gnorm.\n      apply: (Hreg _ x); last first.\n        by rewrite !permM -Hgx Hghx -!permM mulKVg mulgV perm1.\n      rewrite groupM // ?groupV // (conjgCV g) mulgK -mem_conjg.\n      by case/normalP: Hh1 => _ ->.\n    have: (g * (h ^+ 2) * g ^-1) x = (h ^+ 3) x.\n      rewrite !permM -Hgx.\n      have ->: h (h x) = (h ^+ 2) x by rewrite /= permM.\n      by rewrite {1}Hgh3x -!permM /= mulgV mulg1 -expgSr.\n    rewrite commuteX // mulgK {1}[expgn]lock expgS permM -lock.\n    by move/perm_inj=> eqxhx; case/eqP: (diff_hnx_x 1%N isT isT); rewrite expg1.\n  by rewrite (@Gauss_dvd 4 5) // F7.\napply/simpleP; split => [|H Hnorm]; first by rewrite trivg_card1 F1.\ncase Hcard1: (#|H| == 1%N); move/eqP: Hcard1 => Hcard1.\n  by left; apply: card1_trivg; rewrite Hcard1.\nright; case Hcard60: (#|H| == 60); move/eqP: Hcard60 => Hcard60.\n  by apply/eqP; rewrite eqEcard Hcard60 F1 andbT; case/andP: Hnorm.\nhave {Hcard1 Hcard60} Hcard20: #|H| = 20.\n  have Hdiv: 20 %| #|H| by apply: FF => // HH; case Hcard1; rewrite HH cards1.\n  case H20: (#|H| == 20); first exact/eqP.\n  case: Hcard60; case/andP: Hnorm; move/cardSg; rewrite F1 => Hdiv1 _.\n  by case/dvdnP: Hdiv H20 Hdiv1 => n ->; move: n; do 4!case=> //.\nhave prime_5: prime 5 by [].\nhave nSyl5: #|'Syl_5(H)| = 1%N.\n  move: (card_Syl_dvd 5 H) (card_Syl_mod H prime_5).\n  rewrite Hcard20; case: (card _) => // n Hdiv.\n  move: (dvdn_leq  (isT: (0 < 20)%N) Hdiv).\n  by move: (n) Hdiv; do 20 (case=> //).\ncase: (Sylow_exists 5 H) => S; case/pHallP=> sSH oS.\nhave{} oS: #|S| = 5 by rewrite oS p_part Hcard20.\nsuff: 20 %| #|S| by rewrite oS.\napply: FF => [|S1]; last by rewrite S1 cards1 in oS.\napply: char_normal_trans Hnorm; apply: lone_subgroup_char => // Q sQH isoQS.\nrewrite subEproper; apply/norP=> [[nQS _]]; move: nSyl5.\nrewrite (cardsD1 S) (cardsD1 Q) 4!{1}inE nQS !pHallE sQH sSH Hcard20 p_part.\nby rewrite (card_isog isoQS) oS.\nQed."
}
{
  "statement": "Lemma integral_horner_root w (p q : {poly K}) :\n    p \\is monic -> root p w ->\n    {in p : seq K, integralRange RtoK} -> {in q : seq K, integralRange RtoK} ->\n  integralOver RtoK q.[w].\n",
  "proof": "Proof.\nmove=> mon_p pw0 intRp intRq.\npose memR y := exists x, y = RtoK x.\nhave memRid x: memR (RtoK x) by exists x.\nhave memR_nat n: memR n%:R by rewrite -(rmorph_nat RtoK) /=.\nhave [memR0 memR1]: memR 0 * memR 1 := (memR_nat 0, memR_nat 1).\nhave memRN1: memR (- 1) by exists (- 1); rewrite rmorphN1.\npose rVin (E : K -> Prop) n (a : 'rV[K]_n) := forall i, E (a 0 i).\npose pXin (E : K -> Prop) (r : {poly K}) := forall i, E r`_i.\npose memM E n (X : 'rV_n) y := exists a, rVin E n a /\\ y = (a *m X^T) 0 0.\npose finM E S := exists n, exists X, forall y, memM E n X y <-> S y.\nhave tensorM E n1 n2 X Y: finM E (memM (memM E n2 Y) n1 X).\n  exists (n1 * n2)%N, (mxvec (X^T *m Y)) => y.\n  split=> [[a [Ea Dy]] | [a1 [/fin_all_exists[a /all_and2[Ea Da1]] ->]]].\n    exists (Y *m (vec_mx a)^T); split=> [i|].\n      exists (row i (vec_mx a)); split=> [j|]; first by rewrite !mxE; apply: Ea.\n      by rewrite -row_mul -{1}[Y]trmxK -trmx_mul !mxE.\n    by rewrite -[Y]trmxK -!trmx_mul mulmxA -mxvec_dotmul trmx_mul trmxK vec_mxK.\n  exists (mxvec (\\matrix_i a i)); split.\n    by case/mxvec_indexP=> i j; rewrite mxvecE mxE; apply: Ea.\n  rewrite -[mxvec _]trmxK -trmx_mul mxvec_dotmul -mulmxA trmx_mul !mxE.\n  apply: eq_bigr => i _; rewrite Da1 !mxE; congr (_ * _).\n  by apply: eq_bigr => j _; rewrite !mxE.\nsuffices [m [X [[u [_ Du]] idealM]]]: exists m,\n  exists X, let M := memM memR m X in M 1 /\\ forall y, M y -> M (q.[w] * y).\n- do [set M := memM _ m X; move: q.[w] => z] in idealM *.\n  have MX i: M (X 0 i).\n    by exists (delta_mx 0 i); split=> [j|]; rewrite -?rowE !mxE.\n  have /fin_all_exists[a /all_and2[Fa Da1]] i := idealM _ (MX i).\n  have /fin_all_exists[r Dr] i := fin_all_exists (Fa i).\n  pose A := \\matrix_(i, j) r j i; pose B := z%:M - map_mx RtoK A.\n  have XB0: X *m B = 0.\n    apply/eqP; rewrite mulmxBr mul_mx_scalar subr_eq0; apply/eqP/rowP=> i.\n    by rewrite !mxE Da1 mxE; apply: eq_bigr=> j _; rewrite !mxE mulrC Dr.\n  exists (char_poly A); first exact: char_poly_monic.\n  have: (\\det B *: (u *m X^T)) 0 0 == 0.\n    rewrite scalemxAr -linearZ -mul_mx_scalar -mul_mx_adj mulmxA XB0 /=.\n    by rewrite mul0mx trmx0 mulmx0 mxE.\n  rewrite mxE -Du mulr1 rootE -horner_evalE -2!det_map_mx; congr (\\det _ == 0).\n  rewrite raddfB/= map_scalar_mx; apply/matrixP=> i j.\n  by rewrite !mxE raddfB raddfMn/= map_polyX map_polyC /horner_eval !hornerE.\npose gen1 x E y := exists2 r, pXin E r & y = r.[x]; pose gen := foldr gen1 memR.\nhave gen1S (E : K -> Prop) x y: E 0 -> E y -> gen1 x E y.\n  by exists y%:P => [i|]; rewrite ?hornerC ?coefC //; case: ifP.\nhave genR S y: memR y -> gen S y.\n  by elim: S => //= x S IH in y * => /IH; apply/gen1S/IH.\nhave gen0 := genR _ 0 memR0; have gen_1 := genR _ 1 memR1.\nhave{gen1S} genS S y: y \\in S -> gen S y.\n  elim: S => //= x S IH /predU1P[-> | /IH//]; last exact: gen1S.\n  by exists 'X => [i|]; rewrite ?hornerX // coefX; apply: genR.\npose propD (R : K -> Prop) := forall x y, R x -> R y -> R (x + y).\nhave memRD: propD memR.\n  by move=> _ _ [a ->] [b ->]; exists (a + b); rewrite rmorphD.\nhave genD S: propD (gen S).\n  elim: S => //= x S IH _ _ [r1 Sr1 ->] [r2 Sr2 ->]; rewrite -hornerD.\n  by exists (r1 + r2) => // i; rewrite coefD; apply: IH.\nhave gen_sum S := big_ind _ (gen0 S) (genD S).\npose propM (R : K -> Prop) := forall x y, R x -> R y -> R (x * y).\nhave memRM: propM memR.\n  by move=> _ _ [a ->] [b ->]; exists (a * b); rewrite rmorphM.\nhave genM S: propM (gen S).\n  elim: S => //= x S IH _ _ [r1 Sr1 ->] [r2 Sr2 ->]; rewrite -hornerM.\n  by exists (r1 * r2) => // i; rewrite coefM; apply: gen_sum => j _; apply: IH.\nhave gen_horner S r y: pXin (gen S) r -> gen S y -> gen S r.[y].\n  move=> Sq Sy; rewrite horner_coef; apply: gen_sum => [[i _] /= _].\n  by elim: {2}i => [|n IHn]; rewrite ?mulr1 // exprSr mulrA; apply: genM.\npose S := w :: q ++ p; suffices [m [X defX]]: finM memR (gen S).\n  exists m, X => M; split=> [|y /defX Xy]; first exact/defX.\n  apply/defX/genM => //; apply: gen_horner => // [i|]; last exact/genS/mem_head.\n  rewrite -[q]coefK coef_poly; case: ifP => // lt_i_q.\n  by apply: genS; rewrite inE mem_cat mem_nth ?orbT.\npose intR R y := exists r, [/\\ r \\is monic, root r y & pXin R r].\npose fix genI s := if s is y :: s1 then intR (gen s1) y /\\ genI s1 else True.\nhave{mon_p pw0 intRp intRq}: genI S.\n  split; set S1 := _ ++ _; first exists p.\n    split=> // i; rewrite -[p]coefK coef_poly; case: ifP => // lt_i_p.\n    by apply: genS; rewrite mem_cat orbC mem_nth.\n  set S2 := S1; have: all [in S1] S2 by apply/allP.\n  elim: S2 => //= y S2 IH /andP[S1y S12]; split; last exact: IH.\n  have{q S S1 IH S1y S12 intRp intRq} [q mon_q qx0]: integralOver RtoK y.\n    by move: S1y; rewrite mem_cat => /orP[]; [apply: intRq | apply: intRp].\n  exists (map_poly RtoK q); split=> // [|i]; first exact: monic_map.\n  by rewrite coef_map /=; apply: genR.\nelim: {w p q}S => /= [_|x S IH [[p [mon_p px0 Sp]] /IH{IH}[m2 [X2 defS]]]].\n  exists 1, 1 => y; split=> [[a [Fa ->]] | Fy].\n    by rewrite tr_scalar_mx mulmx1; apply: Fa.\n  by exists y%:M; split=> [i|]; rewrite 1?ord1 ?tr_scalar_mx ?mulmx1 mxE.\npose m1 := (size p).-1; pose X1 := \\row_(i < m1) x ^+ i.\nhave [m [X defM]] := tensorM memR m1 m2 X1 X2; set M := memM _ _ _ in defM.\nexists m, X => y; rewrite -/M; split=> [/defM[a [M2a]] | [q Sq]] -> {y}.\n  exists (rVpoly a) => [i|].\n    by rewrite coef_rVpoly; case/insub: i => // i; apply/defS/M2a.\n  rewrite mxE (horner_coef_wide _ (size_poly _ _)) -/(rVpoly a).\n  by apply: eq_bigr => i _; rewrite coef_rVpoly_ord !mxE.\nhave M_0: M 0 by exists 0; split=> [i|]; rewrite ?mul0mx mxE.\nhave M_D: propD M.\n  move=> _ _ [a [Fa ->]] [b [Fb ->]]; exists (a + b).\n  by rewrite mulmxDl !mxE; split=> // i /[1!mxE]; apply: memRD.\nhave{M_0 M_D} Msum := big_ind _ M_0 M_D.\nrewrite horner_coef; apply: (Msum) => i _; case: i q`_i {Sq}(Sq i) => /=.\nelim: {q}(size q) => // n IHn i i_le_n y Sy.\nhave [i_lt_m1 | m1_le_i] := ltnP i m1.\n  apply/defM; exists (y *: delta_mx 0 (Ordinal i_lt_m1)); split=> [j|].\n    by apply/defS; rewrite !mxE /= mulr_natr; case: eqP.\n  by rewrite -scalemxAl -rowE !mxE.\nrewrite -(subnK m1_le_i) exprD -[x ^+ m1]subr0 -(rootP px0) horner_coef.\nrewrite polySpred ?monic_neq0 // -/m1 big_ord_recr /= -lead_coefE.\nrewrite opprD addrC (monicP mon_p) mul1r subrK !mulrN -mulNr !mulr_sumr.\napply: Msum => j _; rewrite mulrA mulrACA -exprD; apply: IHn.\n  by rewrite -addnS addnC addnBA // leq_subLR leq_add.\nby rewrite -mulN1r; do 2!apply: (genM) => //; apply: genR.\nQed."
}
{
  "statement": "Lemma prime_decomp_correct :\n  let pd_val pd := \\prod_(f <- pd) pfactor f.1 f.2 in\n  let lb_dvd q m := ~~ has [pred d | d %| m] (index_iota 2 q) in\n  let pf_ok f := lb_dvd f.1 f.1 && (0 < f.2) in\n  let pd_ord q pd := path ltn q (unzip1 pd) in\n  let pd_ok q n pd := [/\\ n = pd_val pd, all pf_ok pd & pd_ord q pd] in\n  forall n, n > 0 -> pd_ok 1 n (prime_decomp n).\n",
  "proof": "Proof.\nrewrite unlock => pd_val lb_dvd pf_ok pd_ord pd_ok.\nhave leq_pd_ok m p q pd: q <= p -> pd_ok p m pd -> pd_ok q m pd.\n  rewrite /pd_ok /pd_ord; case: pd => [|[r _] pd] //= leqp [<- ->].\n  by case/andP=> /(leq_trans _)->.\nhave apd_ok m e q p pd: lb_dvd p p || (e == 0) -> q < p ->\n     pd_ok p m pd -> pd_ok q (p ^ e * m) (p ^? e :: pd).\n- case: e => [|e]; rewrite orbC /= => pr_p ltqp.\n    by rewrite mul1n; apply: leq_pd_ok; apply: ltnW.\n  by rewrite /pd_ok /pd_ord /pf_ok /= pr_p ltqp => [[<- -> ->]].\ncase=> // n _; rewrite /prime_decomp.\ncase: elogn2P => e2 m2 -> {n}; case: m2 => [|[|abc]]; try exact: apd_ok.\nrewrite [_.-2]/= !ltnS ltn0 natTrecE; case: edivnP => a bc ->{abc}.\ncase: edivnP => b c def_bc /= ltc2 ltbc3; apply: (apd_ok) => //.\nmove def_m: _.*2.+1 => m; set k := {2}1; rewrite -[2]/k.*2; set e := 0.\npose p := k.*2.+1; rewrite -{1}[m]mul1n -[1]/(p ^ e)%N.\nhave{def_m bc def_bc ltc2 ltbc3}:\n   let kb := (ifnz e k 1).*2 in\n   [&& k > 0, p < m, lb_dvd p m, c < kb & lb_dvd p p || (e == 0)]\n    /\\ m + (b * kb + c).*2 = p ^ 2 + (a * p).*2.\n- rewrite -def_m [in lb_dvd _ _]def_m; split=> //=; last first.\n    by rewrite -def_bc addSn -doubleD 2!addSn -addnA subnKC // addnC.\n  rewrite ltc2 /lb_dvd /index_iota /= dvdn2 -def_m.\n  by rewrite [_.+2]lock /= odd_double.\nhave [n] := ubnP a.\nelim: n => // n IHn in a (k) p m b c (e) * => /ltnSE-le_a_n [].\nset kb := _.*2; set d := _ + c => /and5P[lt0k ltpm leppm ltc pr_p def_m].\nhave def_k1: k.-1.+1 = k := ltn_predK lt0k.\nhave def_kb1: kb.-1.+1 = kb by rewrite /kb -def_k1; case e.\nhave eq_bc_0: (b == 0) && (c == 0) = (d == 0).\n  by rewrite addn_eq0 muln_eq0 orbC -def_kb1.\nhave lt1p: 1 < p by rewrite ltnS double_gt0.\nhave co_p_2: coprime p 2 by rewrite /coprime gcdnC gcdnE modn2 /= odd_double.\nhave if_d0: d = 0 -> [/\\ m = (p + a.*2) * p, lb_dvd p p & lb_dvd p (p + a.*2)].\n  move=> d0; have{d0} def_m: m = (p + a.*2) * p.\n    by rewrite d0 addn0 -!mul2n mulnA -mulnDl in def_m *.\n  split=> //; apply/hasPn=> r /(hasPn leppm); apply: contra => /= dv_r.\n    by rewrite def_m dvdn_mull.\n  by rewrite def_m dvdn_mulr.\ncase def_a: a => [|a'] /= in le_a_n *; rewrite !natTrecE -/p {}eq_bc_0.\n  case: d if_d0 def_m => [[//| def_m {}pr_p pr_m'] _ | d _ def_m] /=.\n    rewrite def_m def_a addn0 mulnA -2!expnSr.\n    by split; rewrite /pd_ord /pf_ok /= ?muln1 ?pr_p ?leqnn.\n  apply: apd_ok; rewrite // /pd_ok /= /pfactor expn1 muln1 /pd_ord /= ltpm.\n  rewrite /pf_ok !andbT /=; split=> //; apply: contra leppm.\n  case/hasP=> r /=; rewrite mem_index_iota => /andP[lt1r ltrm] dvrm; apply/hasP.\n  have [ltrp | lepr] := ltnP r p.\n    by exists r; rewrite // mem_index_iota lt1r.\n  case/dvdnP: dvrm => q def_q; exists q; last by rewrite def_q /= dvdn_mulr.\n  rewrite mem_index_iota -(ltn_pmul2r (ltnW lt1r)) -def_q mul1n ltrm.\n  move: def_m; rewrite def_a addn0 -(@ltn_pmul2r p) // mulnn => <-.\n  apply: (@leq_ltn_trans m); first by rewrite def_q leq_mul.\n  by rewrite -addn1 leq_add2l.\nhave def_k2: k.*2 = ifnz e 1 k * kb.\n  by rewrite /kb; case: (e) => [|e']; rewrite (mul1n, muln2).\ncase def_b': (b - _) => [|b']; last first.\n  have ->: ifnz e k.*2.-1 1 = kb.-1 by rewrite /kb; case e.\n  apply: IHn => {n le_a_n}//; rewrite -/p -/kb; split=> //.\n    rewrite lt0k ltpm leppm pr_p andbT /=.\n    by case: ifnzP; [move/ltn_predK->; apply: ltnW | rewrite def_kb1].\n  apply: (@addIn p.*2).\n  rewrite -2!addnA -!doubleD -addnA -mulSnr -def_a -def_m /d.\n  have ->: b * kb = b' * kb + (k.*2 - c * kb + kb).\n    rewrite addnCA addnC -mulSnr -def_b' def_k2 -mulnBl -mulnDl subnK //.\n    by rewrite ltnW // -subn_gt0 def_b'.\n  rewrite -addnA; congr (_ + (_ + _).*2).\n  case: (c) ltc; first by rewrite -addSnnS def_kb1 subn0 addn0 addnC.\n  rewrite /kb; case e => [[] // _ | e' c' _] /=; last first.\n    by rewrite subnDA subnn addnC addSnnS.\n  by rewrite mul1n -doubleB -doubleD subn1 !addn1 def_k1.\nhave ltdp: d < p.\n  move/eqP: def_b'; rewrite subn_eq0 -(@leq_pmul2r kb); last first.\n    by rewrite -def_kb1.\n  rewrite mulnBl -def_k2 ltnS -(leq_add2r c); move/leq_trans; apply.\n  have{} ltc: c < k.*2.\n    by apply: (leq_trans ltc); rewrite leq_double /kb; case e.\n  rewrite -{2}(subnK (ltnW ltc)) leq_add2r leq_sub2l //.\n  by rewrite -def_kb1 mulnS leq_addr.\ncase def_d: d if_d0 => [|d'] => [[//|{ltdp pr_p}def_m pr_p pr_m'] | _].\n  rewrite eqxx -doubleS -addnS -def_a doubleD -addSn -/p def_m.\n  rewrite mulnCA mulnC -expnSr.\n  apply: IHn => {n le_a_n}//; rewrite -/p -/kb; split.\n    rewrite lt0k -addn1 leq_add2l {1}def_a pr_m' pr_p /= def_k1 -addnn.\n    by rewrite leq_addr.\n  rewrite -addnA -doubleD addnCA def_a addSnnS def_k1 -(addnC k) -mulnSr.\n  by rewrite -[_.*2.+1]/p mulnDl doubleD addnA -mul2n mulnA mul2n -mulSn.\nhave next_pm: lb_dvd p.+2 m.\n  rewrite /lb_dvd /index_iota (addKn 2) -(subnK lt1p) iotaD has_cat.\n  apply/norP; split; rewrite //= orbF subnKC // orbC.\n  apply/norP; split; apply/dvdnP=> [[q def_q]].\n     case/hasP: leppm; exists 2; first by rewrite /p -(subnKC lt0k).\n    by rewrite /= def_q dvdn_mull // dvdn2 /= odd_double.\n  move/(congr1 (dvdn p)): def_m; rewrite -!mul2n mulnA -mulnDl.\n  rewrite dvdn_mull // dvdn_addr; last by rewrite def_q dvdn_mull.\n  case/dvdnP=> r; rewrite mul2n => def_r; move: ltdp (congr1 odd def_r).\n  rewrite odd_double -ltn_double def_r -mul2n ltn_pmul2r //.\n  by case: r def_r => [|[|[]]] //; rewrite def_d // mul1n /= odd_double.\napply: apd_ok => //; case: a' def_a le_a_n => [|a'] def_a => [_ | lta] /=.\n  rewrite /pd_ok /= /pfactor expn1 muln1 /pd_ord /= ltpm /pf_ok !andbT /=.\n  split=> //; apply: contra next_pm.\n  case/hasP=> q; rewrite mem_index_iota => /andP[lt1q ltqm] dvqm; apply/hasP.\n  have [ltqp | lepq] := ltnP q p.+2.\n    by exists q; rewrite // mem_index_iota lt1q.\n  case/dvdnP: dvqm => r def_r; exists r; last by rewrite def_r /= dvdn_mulr.\n  rewrite mem_index_iota -(ltn_pmul2r (ltnW lt1q)) -def_r mul1n ltqm /=.\n  rewrite -(@ltn_pmul2l p.+2) //; apply: (@leq_ltn_trans m).\n    by rewrite def_r mulnC leq_mul.\n  rewrite -addn2 mulnn sqrnD mul2n muln2 -addnn addnACA.\n  by rewrite def_a mul1n in def_m; rewrite -def_m addnS /= ltnS -addnA leq_addr.\nset bc := ifnz _ _ _; apply: leq_pd_ok (leqnSn _) _.\nrewrite -doubleS -{1}[m]mul1n -[1]/(k.+1.*2.+1 ^ 0)%N.\napply: IHn; first exact: ltnW.\nrewrite doubleS -/p [ifnz 0 _ _]/=; do 2?split => //.\n  rewrite orbT next_pm /= -(leq_add2r d.*2) def_m 2!addSnnS -doubleS leq_add.\n  - move: ltc; rewrite /kb {}/bc andbT; case e => //= e' _; case: ifnzP => //.\n    by case: edivn2P.\n  - by rewrite -[ltnLHS]muln1 ltn_pmul2l.\n  by rewrite leq_double def_a mulSn (leq_trans ltdp) ?leq_addr.\nrewrite mulnDl !muln2 -addnA addnCA doubleD addnCA.\nrewrite (_ : _ + bc.2 = d); last first.\n  rewrite /d {}/bc /kb -muln2.\n  case: (e) (b) def_b' => //= _ []; first by case: edivn2P.\n  by case c; do 2?case; rewrite // mul1n /= muln2.\nrewrite def_m 3!doubleS addnC -(addn2 p) sqrnD mul2n muln2 -3!addnA.\ncongr (_ + _); rewrite 4!addnS -!doubleD; congr _.*2.+2.+2.\nby rewrite def_a -add2n mulnDl -addnA -muln2 -mulnDr mul2n.\nQed."
}
{
  "statement": "Theorem extraspecial_repr_structure_pchar (sS : irrType F S) :\n  [/\\ #|linear_irr sS| = (p ^ n.*2)%N,\n      exists iphi : 'I_p.-1 -> sS, let phi i := irr_repr (iphi i) in\n        [/\\ injective iphi,\n            codom iphi =i ~: linear_irr sS,\n            forall i, mx_faithful (phi i),\n            forall z, z \\in 'Z(S)^# ->\n              exists2 w, primitive_root_of_unity p w\n                       & forall i, phi i z = (w ^+ i.+1)%:M\n          & forall i, irr_degree (iphi i) = (p ^ n)%N]\n    & #|sS| = (p ^ n.*2 + p.-1)%N].\n",
  "proof": "Proof.\nhave [[defPhiS defS'] prZ] := esS; set linS := linear_irr sS.\nhave nb_lin: #|linS| = (p ^ n.*2)%N.\n  rewrite card_linear_irr // -divgS ?der_sub //=.\n  by rewrite oSpn defS' oZp expnS mulKn.\nhave nb_irr: #|sS| = (p ^ n.*2 + p.-1)%N.\n  pose Zcl := classes S ::&: 'Z(S).\n  have cardZcl: #|Zcl| = p.\n    transitivity #|[set [set z] | z in 'Z(S)]|; last first.\n      by rewrite card_imset //; apply: set1_inj.\n    apply: eq_card => zS; apply/setIdP/imsetP=> [[] | [z]].\n      case/imsetP=> z Sz ->{zS} szSZ.\n      have Zz: z \\in 'Z(S) by rewrite (subsetP szSZ) ?class_refl.\n      exists z => //; rewrite inE Sz in Zz.\n      apply/eqP; rewrite eq_sym eqEcard sub1set class_refl cards1.\n      by rewrite -index_cent1 (setIidPl _) ?indexgg // sub_cent1.\n    case/setIP=> Sz cSz ->{zS}; rewrite sub1set inE Sz; split=> //.\n    apply/imsetP; exists z; rewrite //.\n    apply/eqP; rewrite eqEcard sub1set class_refl cards1.\n    by rewrite -index_cent1 (setIidPl _) ?indexgg // sub_cent1.\n  move/eqP: (class_formula S); rewrite (bigID [in Zcl]) /=.\n  rewrite (eq_bigr (fun _ => 1)) => [|zS]; last first.\n    case/andP=> _ /setIdP[/imsetP[z Sz ->{zS}] /subsetIP[_ cSzS]].\n    rewrite (setIidPl _) ?indexgg // sub_cent1 (subsetP cSzS) //.\n    exact: mem_repr (class_refl S z).\n  rewrite sum1dep_card setIdE (setIidPr _) 1?cardsE ?cardZcl; last first.\n    by apply/subsetP=> zS /[!inE] /andP[].\n  have pn_gt0: p ^ n.*2 > 0 by rewrite expn_gt0 p_gt0.\n  rewrite card_irr_pchar // oSpn expnS -(prednK pn_gt0) mulnS eqn_add2l.\n  rewrite (eq_bigr (fun _ => p)) => [|xS]; last first.\n    case/andP=> SxS; rewrite inE SxS; case/imsetP: SxS => x Sx ->{xS} notZxS.\n    have [y Sy ->] := repr_class S x; apply: p_maximal_index => //.\n    apply: cent1_extraspecial_maximal => //; first exact: groupJ.\n    apply: contra notZxS => Zxy; rewrite -{1}(lcoset_id Sy) class_lcoset.\n    rewrite ((_ ^: _ =P [set x ^ y])%g _) ?sub1set // eq_sym eqEcard.\n    rewrite sub1set class_refl cards1 -index_cent1 (setIidPl _) ?indexgg //.\n    by rewrite sub_cent1; apply: subsetP Zxy; apply: subsetIr.\n  rewrite sum_nat_cond_const mulnC eqn_pmul2l //; move/eqP <-.\n  rewrite addSnnS prednK // -cardZcl -[card _](cardsID Zcl) /= addnC.\n  by congr (_ + _)%N; apply: eq_card => t; rewrite !inE andbC // andbAC andbb.\nhave fful_nlin i: i \\in ~: linS -> mx_faithful (irr_repr i).\n  rewrite !inE => nlin_phi.\n  apply/trivgP; apply: (TI_center_nil (pgroup_nil pS) (rker_normal _)).\n  rewrite setIC; apply: (prime_TIg prZ); rewrite /= -defS' der1_sub_rker //.\n  exact: socle_irr.\nhave [i0 nlin_i0]: exists i0, i0 \\in ~: linS.\n  by apply/card_gt0P; rewrite cardsCs setCK nb_irr nb_lin addKn -subn1 subn_gt0.\nhave [z defZ]: exists z, 'Z(S) = <[z]> by apply/cyclicP; rewrite prime_cyclic.\nhave Zz: z \\in 'Z(S) by [rewrite defZ cycle_id]; have [Sz cSz] := setIP Zz.\nhave ozp: #[z] = p by rewrite -oZp defZ.\nhave ntz: z != 1%g by rewrite -order_gt1 ozp.\npose phi := irr_repr i0; have irr_phi: mx_irreducible phi := socle_irr i0.\npose w := irr_mode i0 z.\nhave phi_z: phi z = w%:M by rewrite /phi irr_center_scalar.\nhave phi_ze e: phi (z ^+ e)%g = (w ^+ e)%:M.\n  by rewrite /phi irr_center_scalar ?groupX ?irr_modeX.\nhave wp1: w ^+ p = 1 by rewrite -irr_modeX // -ozp expg_order irr_mode1.\nhave injw: {in 'Z(S) &, injective (irr_mode i0)}.\n  move=> x y Zx Zy /= eq_xy; have [[Sx _] [Sy _]] := (setIP Zx, setIP Zy).\n  apply: mx_faithful_inj (fful_nlin _ nlin_i0) _ _ Sx Sy _.\n  by rewrite !{1}irr_center_scalar ?eq_xy; first by split.\nhave prim_w e: 0 < e < p -> p.-primitive_root (w ^+ e).\n  case/andP=> e_gt0 lt_e_p; apply/andP; split=> //.\n  apply/eqfunP=> -[d ltdp] /=; rewrite unity_rootE -exprM.\n  rewrite -(irr_mode1 i0) -irr_modeX // (inj_in_eq injw) ?groupX ?group1 //.\n  rewrite -order_dvdn ozp Euclid_dvdM // gtnNdvd //=.\n  move: ltdp; rewrite leq_eqVlt.\n  by case: eqP => [-> _ | _ ltd1p]; rewrite (dvdnn, gtnNdvd).\nhave /cyclicP[a defAutZ]: cyclic (Aut 'Z(S)) by rewrite Aut_prime_cyclic ?ozp.\nhave phi_unitP (i : 'I_p.-1): (i.+1%:R : 'Z_#[z]) \\in GRing.unit.\n  by rewrite unitZpE ?order_gt1 // ozp prime_coprime // -lt0n !modIp'.\npose ephi i := invm (injm_Zpm a) (Zp_unitm (FinRing.Unit (phi_unitP i))).\npose j : 'Z_#[z] := val (invm (injm_Zp_unitm z) a).\nhave co_j_p: coprime j p.\n  rewrite coprime_sym /j; case: (invm _ a) => /=.\n  by rewrite ozp /GRing.unit /= Zp_cast.\nhave [alpha Aut_alpha alphaZ] := center_aut_extraspecial pS esS co_j_p.\nhave alpha_i_z i: ((alpha ^+ ephi i) z = z ^+ i.+1)%g.\n  transitivity ((a ^+ ephi i) z)%g.\n    elim: (ephi i : nat) => // e IHe; rewrite !expgS !permM alphaZ //.\n    have Aut_a: a \\in Aut 'Z(S) by rewrite defAutZ cycle_id.\n    rewrite -{2}[a](invmK (injm_Zp_unitm z)); last by rewrite im_Zp_unitm -defZ.\n    rewrite /= autE ?cycle_id // -/j /= /cyclem.\n    rewrite -(autmE (groupX _ Aut_a)) -(autmE (groupX _ Aut_alpha)).\n    by rewrite !morphX //= !autmE IHe.\n  rewrite [(a ^+ _)%g](invmK (injm_Zpm a)) /=; last first.\n    by rewrite im_Zpm -defAutZ defZ Aut_aut.\n  by rewrite autE ?cycle_id //= val_Zp_nat ozp ?modIp'.\nhave rphiP i: S :==: autm (groupX (ephi i) Aut_alpha) @* S by rewrite im_autm.\npose rphi i := morphim_repr (eqg_repr phi (rphiP i)) (subxx S).\nhave rphi_irr i: mx_irreducible (rphi i) by apply/morphim_mx_irr/eqg_mx_irr.\nhave rphi_fful i: mx_faithful (rphi i).\n  rewrite /mx_faithful rker_morphim rker_eqg.\n  by rewrite (trivgP (fful_nlin _ nlin_i0)) morphpreIdom; apply: injm_autm.\nhave rphi_z i: rphi i z = (w ^+ i.+1)%:M.\n  by rewrite /rphi [phi]lock /= /morphim_mx autmE alpha_i_z -lock phi_ze.\npose iphi i := irr_comp sS (rphi i); pose phi_ i := irr_repr (iphi i).\nhave{} phi_ze i e: phi_ i (z ^+ e)%g = (w ^+ (e * i.+1)%N)%:M.\n  rewrite /phi_ !{1}irr_center_scalar ?groupX ?irr_modeX //.\n  suffices ->: irr_mode (iphi i) z = w ^+ i.+1 by rewrite mulnC exprM.\n  have:= mx_rsim_sym (rsim_irr_comp_pchar sS F'S (rphi_irr i)).\n  case/mx_rsim_def=> B [B' _ homB]; rewrite /irr_mode homB // rphi_z.\n  rewrite -{1}scalemx1 -scalemxAr -scalemxAl -{1}(repr_mx1 (rphi i)).\n  by rewrite -homB // repr_mx1 scalemx1 mxE.\nhave inj_iphi: injective iphi.\n  move=> i1 i2 eqi12; apply/eqP.\n  move/eqP: (congr1 (fun i => irr_mode i (z ^+ 1)) eqi12).\n  rewrite /irr_mode !{1}[irr_repr _ _]phi_ze !{1}mxE !mul1n.\n  by rewrite (eq_prim_root_expr (prim_w 1 p_gt1)) !modIp'.\nhave deg_phi i: irr_degree (iphi i) = irr_degree i0.\n  by case: (rsim_irr_comp_pchar sS F'S (rphi_irr i)).\nhave im_iphi: codom iphi =i ~: linS.\n  apply/subset_cardP; last apply/subsetP=> _ /codomP[i ->].\n    by rewrite card_image // card_ord cardsCs setCK nb_irr nb_lin addKn.\n  by rewrite !inE /= (deg_phi i) in nlin_i0 *.\nsplit=> //; exists iphi; rewrite -/phi_.\nsplit=> // [i | ze | i].\n- have sim_i := rsim_irr_comp_pchar sS F'S (rphi_irr i).\n  by rewrite -(mx_rsim_faithful sim_i) rphi_fful.\n- rewrite {1}defZ 2!inE andbC; case/andP.\n  case/cyclePmin=> e; rewrite ozp => lt_e_p ->{ze}.\n  case: (posnP e) => [-> | e_gt0 _]; first by rewrite eqxx.\n  exists (w ^+ e) => [|i]; first by rewrite prim_w ?e_gt0.\n  by rewrite phi_ze exprM.\nrewrite deg_phi {i}; set d := irr_degree i0.\napply/eqP; move/eqP: (sum_irr_degree_pchar sS F'S splitF).\nrewrite (bigID [in linS]) /= -/irr_degree.\nrewrite (eq_bigr (fun=> 1)) => [|i]; last by rewrite !inE; move/eqP->.\nrewrite sum1_card nb_lin.\nrewrite (eq_bigl [in codom iphi]) // => [|i]; last first.\n  by rewrite -in_setC -im_iphi.\nrewrite (eq_bigr (fun=> d ^ 2))%N => [|_ /codomP[i ->]]; last first.\n  by rewrite deg_phi.\nrewrite sum_nat_const card_image // card_ord oSpn (expnS p) -{3}[p]prednK //.\nrewrite mulSn eqn_add2l eqn_pmul2l; last by rewrite -ltnS prednK.\nby rewrite -muln2 expnM eqn_sqr.\nQed."
}
{
  "statement": "Lemma simple_Alt5 (T : finType) : #|T| >= 5 -> simple 'Alt_T.\n",
  "proof": "Proof.\nsuff F1 n: #|T| = n + 5 -> simple 'Alt_T by move/subnK/esym/F1.\nelim: n T => [| n Hrec T Hde]; first exact: simple_Alt5_base.\nhave oT: 5 < #|T| by rewrite Hde addnC.\napply/simpleP; split=> [|H Hnorm]; last have [Hh1 nH] := andP Hnorm.\n  rewrite trivg_card1 -[#|_|]half_double -mul2n card_Alt Hde addnC //.\n  by rewrite addSn factS mulnC -(prednK (fact_gt0 _)).\ncase E1: (pred0b T); first by rewrite /pred0b in E1; rewrite (eqP E1) in oT.\ncase/pred0Pn: E1 => x _; have Hx := in_setT x.\nhave F2: [transitive^4 'Alt_T, on setT | 'P].\n  by apply: ntransitive_weak (Alt_trans T); rewrite -(subnKC oT).\nhave F3 := ntransitive1 (isT: 0 < 4) F2.\nhave F4 := ntransitive_primitive (isT: 1 < 4) F2.\ncase Hcard1: (#|H| == 1%N); move/eqP: Hcard1 => Hcard1.\n  by left; apply: card1_trivg; rewrite Hcard1.\nright; case: (prim_trans_norm F4 Hnorm) => F5.\n  by rewrite (trivGP (subset_trans F5 (aperm_faithful _))) cards1 in Hcard1.\ncase E1: (pred0b (predD1 T x)).\n  rewrite /pred0b in E1; move: oT.\n  by rewrite (cardD1 x) (eqP E1); case: (T x).\ncase/pred0Pn: E1 => y Hdy; case/andP: (Hdy) => diff_x_y Hy.\npose K := 'C_H[x | 'P]%G.\nhave F8: K \\subset H by apply: subsetIl.\npose Gx := 'C_('Alt_T)[x | 'P].\nhave F9: [transitive^3 Gx, on [set~ x] | 'P].\n  by rewrite -[[set~ x]]setTI -setDE stab_ntransitive ?inE.\nhave F10: [transitive Gx, on [set~ x] | 'P].\n  by apply: ntransitive1 F9.\nhave F11: [primitive Gx, on [set~ x] | 'P].\n  by apply: ntransitive_primitive F9.\nhave F12: K \\subset Gx by rewrite setSI // normal_sub.\nhave F13: K <| Gx by apply/andP; rewrite normsIG.\nhave:= prim_trans_norm F11; case/(_ K) => //= => Ksub; last first.\n  have F14: Gx * H = 'Alt_T by apply/(subgroup_transitiveP _ _ F3).\n  have: simple Gx.\n    by rewrite (isog_simple (rfd_iso x)) Hrec //= card_sig cardC1 Hde.\n  case/simpleP=> _ simGx; case/simGx: F13 => /= HH2.\n    case Ez: (pred0b (predD1 (predD1 T x) y)).\n      move: oT; rewrite /pred0b in Ez.\n      by rewrite (cardD1 x) (cardD1 y) (eqP Ez) inE /= inE /= diff_x_y.\n    case/pred0Pn: Ez => z; case/andP => diff_y_z Hdz.\n    have [diff_x_z Hz] := andP Hdz.\n    have: z \\in [set~ x] by rewrite !inE.\n    rewrite -(atransP Ksub y) ?inE //; case/imsetP => g.\n    rewrite /= HH2 inE; move/eqP=> -> HH4.\n    by case/negP: diff_y_z; rewrite HH4 act1.\n  by rewrite /= -F14 -[Gx]HH2 (mulSGid F8).\nhave F14: [faithful Gx, on [set~ x] | 'P].\n  apply: subset_trans (aperm_faithful 'Sym_T); rewrite subsetI subsetT.\n  apply/subsetP=> g; do 2![case/setIP]=> _ cgx cgx'; apply/astabP=> z _ /=.\n  case: (z =P x) => [->|]; first exact: (astab1P cgx).\n  by move/eqP=> zx; rewrite [_ g](astabP cgx') ?inE.\nhave Hreg g z: g \\in H -> g z = z -> g = 1.\n  have F15 h: h \\in H -> h x = x -> h = 1.\n    move=> Hh Hhx; have: h \\in K by rewrite inE Hh; apply/astab1P.\n    by rewrite [K](trivGP (subset_trans Ksub F14)) => /set1P.\n  move=> Hg Hgz; have:= in_setT x; rewrite -(atransP F3 z) ?inE //.\n  case/imsetP=> g1 Hg1 Hg2; apply: (conjg_inj g1); rewrite conj1g.\n  apply: F15; last by rewrite Hg2 -permM mulKVg permM Hgz.\n  by rewrite memJ_norm ?(subsetP nH).\nclear K F8 F12 F13 Ksub F14.\nhave Hcard: 5 < #|H|.\n  apply: (leq_trans oT); apply: dvdn_leq; first exact: cardG_gt0.\n  by rewrite -cardsT (atrans_dvd F5).\ncase Eh: (pred0b [predD1 H & 1]).\n  by move: Hcard; rewrite /pred0b in Eh; rewrite (cardD1 1) group1 (eqP Eh).\ncase/pred0Pn: Eh => h; case/andP => diff_1_h /= Hh.\ncase Eg: (pred0b (predD1 (predD1 [predD1 H & 1] h) h^-1)).\n  move: Hcard; rewrite ltnNge; case/negP.\n  rewrite (cardD1 1) group1 (cardD1 h) (cardD1 h^-1) (eqnP Eg).\n  by do 2!case: (_ \\in _).\ncase/pred0Pn: Eg => g; case/andP => diff_h1_g; case/andP => diff_h_g.\ncase/andP => diff_1_g /= Hg.\ncase diff_hx_x: (h x == x).\nby case/negP: diff_1_h; apply/eqP; apply: (Hreg _ _ Hh (eqP diff_hx_x)).\ncase diff_gx_x: (g x == x).\n  case/negP: diff_1_g; apply/eqP; apply: (Hreg _ _ Hg (eqP diff_gx_x)).\ncase diff_gx_hx: (g x == h x).\n  case/negP: diff_h_g; apply/eqP; symmetry; apply: (mulIg g^-1); rewrite gsimp.\n  apply: (Hreg _ x); first by rewrite groupM // groupV.\n  by rewrite permM -(eqP diff_gx_hx) -permM mulgV perm1.\ncase diff_hgx_x: ((h * g) x == x).\n  case/negP: diff_h1_g; apply/eqP; apply: (mulgI h); rewrite !gsimp.\n  by apply: (Hreg _ x); [apply: groupM | apply/eqP].\ncase diff_hgx_hx: ((h * g) x == h x).\n  case/negP: diff_1_g; apply/eqP.\n  by apply: (Hreg _ (h x)) => //; apply/eqP; rewrite -permM.\ncase diff_hgx_gx: ((h * g) x == g x).\n  by case/idP: diff_hx_x; rewrite -(can_eq (permK g)) -permM.\ncase Ez: (pred0b\n            (predD1 (predD1 (predD1 (predD1 T x) (h x)) (g x)) ((h * g) x))).\n- move: oT; rewrite /pred0b in Ez.\n  rewrite (cardD1 x) (cardD1 (h x)) (cardD1 (g x)) (cardD1 ((h * g) x)).\n  by rewrite (eqP Ez) addnC; do 3!case: (_ x \\in _).\ncase/pred0Pn: Ez => z.\ncase/and5P=> diff_hgx_z diff_gx_z diff_hx_z diff_x_z /= Hz.\npose S1 := [tuple x; h x; g x; z].\nhave DnS1: S1 \\in 4.-dtuple(setT).\n  rewrite inE memtE subset_all -!andbA !negb_or /= !inE !andbT.\n  rewrite -!(eq_sym z) diff_gx_z diff_x_z diff_hx_z.\n  by rewrite !(eq_sym x) diff_hx_x diff_gx_x eq_sym diff_gx_hx.\npose S2 := [tuple x; h x; g x; (h * g) x].\nhave DnS2: S2 \\in 4.-dtuple(setT).\n  rewrite inE memtE subset_all -!andbA !negb_or /= !inE !andbT !(eq_sym x).\n  rewrite diff_hx_x diff_gx_x diff_hgx_x.\n  by rewrite !(eq_sym (h x)) diff_gx_hx diff_hgx_hx eq_sym diff_hgx_gx.\ncase: (atransP2 F2 DnS1 DnS2) => k Hk [/=].\nrewrite /aperm => Hkx Hkhx Hkgx Hkhgx.\nhave h_k_com: h * k = k * h.\n  suff HH: (k * h * k^-1) * h^-1 = 1 by rewrite -[h * k]mul1g -HH !gnorm.\n  apply: (Hreg _ x); last first.\n    by rewrite !permM -Hkx Hkhx -!permM mulKVg mulgV perm1.\n  by rewrite groupM // ?groupV // (conjgCV k) mulgK -mem_conjg (normsP nH).\nhave g_k_com: g * k = k * g.\n  suff HH: (k * g * k^-1) * g^-1 = 1 by rewrite -[g * k]mul1g -HH !gnorm.\n  apply: (Hreg _ x); last first.\n    by rewrite !permM -Hkx Hkgx -!permM mulKVg mulgV perm1.\n  by rewrite groupM // ?groupV // (conjgCV k) mulgK -mem_conjg (normsP nH).\nhave HH: (k * (h * g) * k ^-1) x = z.\n   by rewrite 2!permM -Hkx Hkhgx -permM mulgV perm1.\ncase/negP: diff_hgx_z.\nrewrite -HH !mulgA -h_k_com -!mulgA [k * _]mulgA.\nby rewrite -g_k_com -!mulgA mulgV mulg1.\nQed."
}
{
  "statement": "Lemma countable_algebraic_closure (F : countFieldType) :\n  {K : countClosedFieldType & {FtoK : {rmorphism F -> K} | integralRange FtoK}}.\n",
  "proof": "Proof.\npose minXp (R : nzRingType) (p : {poly R}) := if size p > 1 then p else 'X.\nhave minXp_gt1 R p: size (minXp R p) > 1.\n  by rewrite /minXp; case: ifP => // _; rewrite size_polyX.\nhave minXpE (R : nzRingType) (p : {poly R}) : size p > 1 -> minXp R p = p.\n  by rewrite /minXp => ->.\nhave ext1 p := countable_field_extension (minXp_gt1 _ p).\npose ext1fT E p := tag (ext1 E p).\npose ext1to E p : {rmorphism _ -> ext1fT E p} := tag (tagged (ext1 E p)).\npose ext1w E p : ext1fT E p := s2val (tagged (tagged (ext1 E p))).\nhave ext1root E p: root (map_poly (ext1to E p) (minXp E p)) (ext1w E p).\n  by rewrite /ext1w; case: (tagged (tagged (ext1 E p))).\nhave ext1gen E p u: {q | u = (map_poly (ext1to E p) q).[ext1w E p]}.\n  by apply: sig_eqW; rewrite /ext1w; case: (tagged (tagged (ext1 E p))) u.\npose pExtEnum (E : countFieldType) := nat -> {poly E}.\npose Ext := {E : countFieldType & pExtEnum E}; pose MkExt : Ext := Tagged _ _.\npose EtoInc (E : Ext) i := ext1to (tag E) (tagged E i).\npose incEp E i j :=\n  let v := map_poly (EtoInc E i) (tagged E j) in\n  if decode j is [:: i1; k] then\n    if i1 == i then odflt v (unpickle k) else v\n  else v.\npose fix E_ i := if i is i1.+1 then MkExt _ (incEp (E_ i1) i1) else MkExt F \\0.\npose E i := tag (E_ i); pose Krep := {i : nat & E i}.\npose fix toEadd i k : {rmorphism E i -> E (k + i)%N} :=\n  if k isn't k1.+1 then idfun else EtoInc _ (k1 + i)%N \\o toEadd _ _.\npose toE i j (le_ij : i <= j) :=\n  ecast j {rmorphism E i -> E j} (subnK le_ij) (toEadd i (j - i)%N).\nhave toEeq i le_ii: toE i i le_ii =1 id.\n  by rewrite /toE; move: (subnK _); rewrite subnn => ?; rewrite eq_axiomK.\nhave toEleS i j leij leiSj z: toE i j.+1 leiSj z = EtoInc _ _ (toE i j leij z).\n  rewrite /toE; move: (j - i)%N {leij leiSj}(subnK _) (subnK _) => k.\n  by case: j /; rewrite (addnK i k.+1) => eq_kk; rewrite [eq_kk]eq_axiomK.\nhave toEirr := congr1 ((toE _ _)^~ _) (bool_irrelevance _ _).\nhave toEtrans j i k leij lejk leik z:\n  toE i k leik z = toE j k lejk (toE i j leij z).\n- elim: k leik lejk => [|k IHk] leiSk lejSk.\n    by case: j => // in leij lejSk *; rewrite toEeq.\n  have:= lejSk; rewrite {1}leq_eqVlt ltnS => /predU1P[Dk | lejk].\n    by rewrite -Dk in leiSk lejSk *; rewrite toEeq.\n  by have leik := leq_trans leij lejk; rewrite !toEleS -IHk.\nhave [leMl leMr] := (leq_maxl, leq_maxr); pose le_max := (leq_max, leqnn, orbT).\npose pairK (x y : Krep) (m := maxn _ _) :=\n  (toE _ m (leMl _ _) (tagged x), toE _ m (leMr _ _) (tagged y)).\npose eqKrep x y := uncurry (@eq_op _) (pairK x y).\nhave eqKrefl : reflexive eqKrep by move=> z; apply/eqP; apply: toEirr.\nhave eqKsym : symmetric eqKrep.\n  move=> z1 z2; rewrite {1}/eqKrep /= eq_sym; move: (leMl _ _) (leMr _ _).\n  by rewrite maxnC => lez1m lez2m; congr (_ == _); apply: toEirr.\nhave eqKtrans : transitive eqKrep.\n  rewrite /eqKrep /= => z2 z1 z3 /eqP eq_z12 /eqP eq_z23.\n  rewrite -(inj_eq (fmorph_inj (toE _ _ (leMr (tag z2) _)))).\n  rewrite -!toEtrans ?le_max // maxnCA maxnA => lez3m lez1m.\n  rewrite {lez1m}(toEtrans (maxn (tag z1) (tag z2))) // {}eq_z12.\n  do [rewrite -toEtrans ?le_max // -maxnA => lez2m] in lez3m *.\n  by rewrite (toEtrans (maxn (tag z2) (tag z3))) // eq_z23 -toEtrans.\npose K := {eq_quot EquivRel _ eqKrefl eqKsym eqKtrans}%qT.\npose cntK := isCountable.Build K (pcan_pickleK (can_pcan (reprK))).\npose EtoKrep i (x : E i) : K := \\pi%qT (Tagged E x).\nhave [EtoK piEtoK]: {EtoK | forall i, EtoKrep i =1 EtoK i} by exists EtoKrep.\npose FtoK := EtoK 0; rewrite {}/EtoKrep in piEtoK.\nhave eqEtoK i j x y:\n  toE i _ (leMl i j) x = toE j _ (leMr i j) y -> EtoK i x = EtoK j y.\n- by move/eqP=> eq_xy; rewrite -!piEtoK; apply/eqmodP.\nhave toEtoK j i leij x : EtoK j (toE i j leij x) = EtoK i x.\n  by apply: eqEtoK; rewrite -toEtrans.\nhave EtoK_0 i: EtoK i 0 = FtoK 0 by apply: eqEtoK; rewrite !rmorph0.\nhave EtoK_1 i: EtoK i 1 = FtoK 1 by apply: eqEtoK; rewrite !rmorph1.\nhave EtoKeq0 i x: (EtoK i x == FtoK 0) = (x == 0).\n  by rewrite /FtoK -!piEtoK eqmodE /= /eqKrep /= rmorph0 fmorph_eq0.\nhave toErepr m i leim x lerm:\n  toE _ m lerm (tagged (repr (EtoK i x))) = toE i m leim x.\n- have: (Tagged E x == repr (EtoK i x) %[mod K])%qT by rewrite reprK piEtoK.\n  rewrite eqmodE /= /eqKrep; case: (repr _) => j y /= in lerm * => /eqP /=.\n  have leijm: maxn i j <= m by rewrite geq_max leim.\n  by move/(congr1 (toE _ _ leijm)); rewrite -!toEtrans.\npose Kadd (x y : K) := EtoK _ (uncurry +%R (pairK (repr x) (repr y))).\npose Kopp (x : K) := EtoK _ (- tagged (repr x)).\npose Kmul (x y : K) := EtoK _ (uncurry *%R (pairK (repr x) (repr y))).\npose Kinv (x : K) := EtoK _ (tagged (repr x))^-1.\nhave EtoK_D i: {morph EtoK i : x y / x + y >-> Kadd x y}.\n  move=> x y; apply: eqEtoK; set j := maxn (tag _) _; rewrite !rmorphD.\n  rewrite -![X in _ = X + _]toEtrans ?le_max// => lexm.\n  rewrite -![X in _ = _ + X]toEtrans ?le_max// => leym.\n  by rewrite !toErepr.\nhave EtoK_N i: {morph EtoK i : x / - x >-> Kopp x}.\n  by move=> x; apply: eqEtoK; set j := tag _; rewrite !rmorphN toErepr.\nhave EtoK_M i: {morph EtoK i : x y / x * y >-> Kmul x y}.\n  move=> x y; apply: eqEtoK; set j := maxn (tag _) _; rewrite !rmorphM.\n  rewrite -![X in _ = X * _]toEtrans ?le_max// => lexm.\n  rewrite -![X in _ = _ * X]toEtrans ?le_max// => leym.\n  by rewrite !toErepr.\nhave EtoK_V i: {morph EtoK i : x / x^-1 >-> Kinv x}.\n  by move=> x; apply: eqEtoK; set j := tag _; rewrite !fmorphV toErepr.\ncase: {toErepr}I in (Kadd) (Kopp) (Kmul) (Kinv) EtoK_D EtoK_N EtoK_M EtoK_V.\npose inEi i z := {x : E i | z = EtoK i x}; have KtoE z: {i : nat & inEi i z}.\n  by elim/quotW: z => [[i x] /=]; exists i, x; rewrite piEtoK.\nhave inEle i j z: i <= j -> inEi i z -> inEi j z.\n  by move=> leij [x ->]; exists (toE i j leij x); rewrite toEtoK.\nhave KtoE2 z1 z2: {i : nat & inEi i z1 & inEi i z2}.\n  have [[i1 Ez1] [i2 Ez2]] := (KtoE z1, KtoE z2).\n  by exists (maxn i1 i2); [apply: inEle Ez1 | apply: inEle Ez2].\nhave KtoE3 z1 z2 z3: {i : nat & inEi i z1 & inEi i z2 * inEi i z3}%type.\n  have [[i1 Ez1] [i2 Ez2 Ez3]] := (KtoE z1, KtoE2 z2 z3).\n  by exists (maxn i1 i2); [apply: inEle Ez1 | split; apply: inEle (leMr _ _) _].\nhave KaddC: commutative Kadd.\n  by move=> u v; have [i [x ->] [y ->]] := KtoE2 u v; rewrite -!EtoK_D addrC.\nhave KaddA: associative Kadd.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!EtoK_D addrA.\nhave Kadd0: left_id (FtoK 0) Kadd.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -(EtoK_0 i) -EtoK_D add0r.\nhave KaddN: left_inverse (FtoK 0) Kopp Kadd.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -EtoK_N -EtoK_D addNr EtoK_0.\npose KzmodMixin := GRing.isZmodule.Build K KaddA KaddC Kadd0 KaddN.\npose Kzmod : countZmodType := HB.pack K KzmodMixin.\nhave KmulC: commutative Kmul.\n  by move=> u v; have [i [x ->] [y ->]] := KtoE2 u v; rewrite -!EtoK_M mulrC.\nhave KmulA: @associative Kzmod Kmul.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!EtoK_M mulrA.\nhave Kmul1: left_id (FtoK 1) Kmul.\n  by move=> u; have [i [x ->]] := KtoE u; rewrite -(EtoK_1 i) -EtoK_M mul1r.\nhave KmulD: left_distributive Kmul Kadd.\n  move=> u v w; have [i [x ->] [[y ->] [z ->]]] := KtoE3 u v w.\n  by rewrite -!(EtoK_M, EtoK_D) mulrDl.\nhave Kone_nz: FtoK 1 != FtoK 0 by rewrite EtoKeq0 oner_neq0.\npose KringMixin := GRing.Zmodule_isComNzRing.Build _\n  KmulA KmulC Kmul1 KmulD Kone_nz.\npose Kring : comNzRingType := HB.pack K Kzmod KringMixin cntK.\nhave KmulV: forall x : Kring, x != 0 -> (Kinv x : Kring) * x = 1.\n  move=> u; have [i [x ->]] := KtoE u; rewrite EtoKeq0 => nz_x.\n  by rewrite -EtoK_V -[_ * _]EtoK_M mulVf ?EtoK_1.\nhave Kinv0: Kinv (FtoK 0) = FtoK 0 by rewrite -EtoK_V invr0.\npose KfieldMixin := GRing.ComNzRing_isField.Build _ KmulV Kinv0.\npose Kfield : fieldType := HB.pack K Kring KfieldMixin.\nhave EtoKAdd i : additive (EtoK i : E i -> Kfield).\n  by move=> x y; rewrite EtoK_D EtoK_N.\nhave EtoKMul i : multiplicative (EtoK i : E i -> Kfield).\n  by split=> [x y|]; rewrite ?EtoK_M ?EtoK_1.\npose EtoKMa i := GRing.isAdditive.Build _ _ _ (EtoKAdd i).\npose EtoKMm i := GRing.isMultiplicative.Build _ _ _ (EtoKMul i).\npose EtoKM i : {rmorphism _ -> _} :=\n  HB.pack (EtoK i : E i -> Kfield) (EtoKMa i) (EtoKMm i).\nhave EtoK_E: EtoK _ = EtoKM _ by [].\nhave toEtoKp := @eq_map_poly _ Kring _ _(toEtoK _ _ _).\nhave Kclosed: GRing.closed_field_axiom Kfield.\n  move=> n pK n_gt0; pose m0 := \\max_(i < n) tag (KtoE (pK i)); pose m := m0.+1.\n  have /fin_all_exists[pE DpE] (i : 'I_n): exists y, EtoK m y = pK i.\n    pose u := KtoE (pK i); have leum0: tag u <= m0 by rewrite (bigmax_sup i).\n    by have [y ->] := tagged u; exists (toE _ _ (leqW leum0) y); rewrite toEtoK.\n  pose p := 'X^n - rVpoly (\\row_i pE i); pose j := code [:: m0; pickle p].\n  pose pj := tagged (E_ j) j; pose w : E j.+1 := ext1w (E j) pj.\n  have lemj: m <= j by rewrite (allP (ltn_code _)) ?mem_head.\n  exists (EtoKM j.+1 w); apply/eqP; rewrite -subr_eq0; apply/eqP.\n  transitivity (EtoKM j.+1 (map_poly (toE m j.+1 (leqW lemj)) p).[w]).\n    rewrite -horner_map -map_poly_comp toEtoKp EtoK_E.\n    move: (EtoKM j.+1 w) => {}w.\n    rewrite rmorphB [_ 'X^n]map_polyXn !hornerE; congr (_ - _ : Kring).\n    rewrite (@horner_coef_wide _ n) ?size_map_poly ?size_poly //.\n    by apply: eq_bigr => i _; rewrite coef_map coef_rVpoly valK mxE /= DpE.\n  suffices Dpj: map_poly (toE m j lemj) p = pj.\n    apply/eqP; rewrite EtoKeq0 (eq_map_poly (toEleS _ _ _ _)) map_poly_comp Dpj.\n    rewrite -rootE -[pj]minXpE ?ext1root // -Dpj size_map_poly.\n    by rewrite size_polyDl ?size_polyXn ltnS ?size_polyN ?size_poly.\n  rewrite {w}/pj; set j0 := (j in tagged (E_ _) j).\n  elim: {+}j lemj => // k IHk lemSk; rewrite {}/j0 in IHk *.\n  have:= lemSk; rewrite leq_eqVlt ltnS => /predU1P[Dm | lemk].\n    rewrite -{}Dm in lemSk *; rewrite {k IHk lemSk}(eq_map_poly (toEeq m _)).\n    by rewrite map_poly_id //= /incEp codeK eqxx pickleK.\n  rewrite (eq_map_poly (toEleS _ _ _ _)) map_poly_comp {}IHk //= /incEp codeK.\n  by rewrite -if_neg neq_ltn lemk.\nsuffices{Kclosed} algF_K: {FtoK : {rmorphism F -> Kfield} | integralRange FtoK}.\n  pose Kcc := Field_isAlgClosed.Build Kfield Kclosed.\n  by exists (HB.pack_for countClosedFieldType K Kfield Kcc).\nexists (EtoKM 0) => /= z; have [i [{}z ->]] := KtoE z.\nsuffices{z} /(_ z)[p mon_p]: integralRange (toE 0 i isT).\n  by rewrite -(fmorph_root (EtoKM i)) -map_poly_comp toEtoKp; exists p.\nrewrite /toE /E; clear - minXp_gt1 ext1root ext1gen.\nmove: (i - 0)%N (subnK _) => n; case: i /.\nelim: n => [|n IHn] /= z; first exact: integral_id.\nhave{z} [q ->] := ext1gen _ _ z; set pn := tagged (E_ _) _.\napply: integral_horner.\n  by apply/integral_poly=> i; rewrite coef_map; apply: integral_rmorph.\napply: integral_root (ext1root _ _) _.\n  by rewrite map_poly_eq0 -size_poly_gt0 ltnW.\nby apply/integral_poly=> i; rewrite coef_map; apply: integral_rmorph.\nQed."
}
{
  "statement": "Lemma maximal_cycle_extremal gT p (G X : {group gT}) :\n    p.-group G -> ~~ abelian G -> cyclic X -> X \\subset G -> #|G : X| = p ->\n  (extremal_class G == ModularGroup) || (p == 2) && extremal2 G.\n",
  "proof": "Proof.\nmove=> pG not_cGG cycX sXG iXG; rewrite /extremal2; set cG := extremal_class G.\nhave [|p_pr _ _] := pgroup_pdiv pG.\n  by case: eqP not_cGG => // ->; rewrite abelian1.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave [n oG] := p_natP pG; have n_gt2: n > 2.\n  apply: contraR not_cGG; rewrite -leqNgt => n_le2.\n  by rewrite (p2group_abelian pG) // oG pfactorK.\nhave def_n := subnKC n_gt2; have n_gt1 := ltnW n_gt2; have n_gt0 := ltnW n_gt1.\npose q := (p ^ n.-1)%N; pose r := (p ^ n.-2)%N.\nhave q_gt1: q > 1 by rewrite (ltn_exp2l 0) // -(subnKC n_gt2).\nhave r_gt0: r > 0 by rewrite expn_gt0 p_gt0.\nhave def_pr: (p * r)%N = q by rewrite /q /r -def_n.\nhave oX: #|X| = q by rewrite -(divg_indexS sXG) oG iXG /q -def_n mulKn.\nhave ntX: X :!=: 1 by rewrite -cardG_gt1 oX.\nhave maxX: maximal X G by rewrite p_index_maximal ?iXG.\nhave nsXG: X <| G := p_maximal_normal pG maxX; have [_ nXG] := andP nsXG.\nhave cXX: abelian X := cyclic_abelian cycX.\nhave scXG: 'C_G(X) = X.\n  apply/eqP; rewrite eqEsubset subsetI sXG -abelianE cXX !andbT.\n  apply: contraR not_cGG; case/subsetPn=> y; case/setIP=> Gy cXy notXy.\n  rewrite -!cycle_subG in Gy notXy; rewrite -(mulg_normal_maximal nsXG _ Gy) //.\n  by rewrite abelianM cycle_abelian cyclic_abelian ?cycle_subG.\nhave [x defX] := cyclicP cycX; have pX := pgroupS sXG pG.\nhave Xx: x \\in X by [rewrite defX cycle_id]; have Gx := subsetP sXG x Xx.\nhave [ox p_x]: #[x] = q /\\ p.-elt x by rewrite defX in pX oX.\npose Z := <[x ^+ r]>.\nhave defZ: Z = 'Ohm_1(X) by rewrite defX (Ohm_p_cycle _ p_x) ox subn1 pfactorK.\nhave oZ: #|Z| = p by rewrite -orderE orderXdiv ox -def_pr ?dvdn_mull ?mulnK.\nhave cGZ: Z \\subset 'C(G).\n  have nsZG: Z <| G by rewrite defZ gFnormal_trans.\n  move/implyP: (meet_center_nil (pgroup_nil pG) nsZG).\n  rewrite -cardG_gt1 oZ p_gt1 setIA (setIidPl (normal_sub nsZG)).\n  by apply: contraR; move/prime_TIg=> -> //; rewrite oZ.\nhave X_Gp y: y \\in G -> y ^+ p \\in X.\n  move=> Gy; have nXy: y \\in 'N(X) := subsetP nXG y Gy.\n  rewrite coset_idr ?groupX // morphX //; apply/eqP.\n  by rewrite -order_dvdn -iXG -card_quotient // order_dvdG ?mem_quotient.\nhave [y X'y]: exists2 y, y \\in G :\\: X &\n  (p == 2) + 3 <= n /\\ x ^ y = x ^+ r.+1 \\/ p = 2 /\\ x * x ^ y \\in Z.\n- have [y Gy notXy]: exists2 y, y \\in G & y \\notin X.\n    by apply/subsetPn; rewrite proper_subn ?(maxgroupp maxX).\n  have nXy: y \\in 'N(X) := subsetP nXG y Gy; pose ay := conj_aut X y.\n  have oay: #[ay] = p.\n    apply: nt_prime_order => //.\n      by rewrite -morphX // mker // ker_conj_aut (subsetP cXX) ?X_Gp.\n    rewrite (sameP eqP (kerP _ nXy)) ker_conj_aut.\n    by apply: contra notXy => cXy; rewrite -scXG inE Gy.\n  have [m []]:= cyclic_pgroup_Aut_structure pX cycX ntX.\n  set Ap := 'O_p(_); case=> def_m [m1 _] [m_inj _] _ _ _.\n  have sylAp: p.-Sylow(Aut X) Ap.\n    by rewrite nilpotent_pcore_Hall // abelian_nil // Aut_cyclic_abelian.\n  have Ap1ay: ay \\in 'Ohm_1(Ap).\n    rewrite (OhmE _ (pcore_pgroup _ _)) mem_gen // !inE -order_dvdn oay dvdnn.\n    rewrite (mem_normal_Hall sylAp) ?pcore_normal ?Aut_aut //.\n    by rewrite /p_elt oay pnat_id.\n  rewrite {1}oX pfactorK // -{1}def_n /=.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    rewrite (sameP eqP (prime_oddPn p_pr)) odd_p n_gt2.\n    case=> _ [_ _ _] [_ _ [s [As os m_s defAp1]]].\n    have [j def_s]: exists j, s = ay ^+ j.\n      apply/cycleP; rewrite -cycle_subG subEproper eq_sym eqEcard -!orderE.\n      by rewrite -defAp1 cycle_subG Ap1ay oay os leqnn .\n    exists (y ^+ j); last first.\n      left; rewrite -(norm_conj_autE _ Xx) ?groupX // morphX // -def_s.\n      by rewrite -def_m // m_s expg_znat // oX pfactorK ?eqxx.\n    rewrite -scXG !inE groupX //= andbT -ker_conj_aut !inE morphX // -def_s.\n    rewrite andbC -(inj_in_eq m_inj) ?group1 // m_s m1 oX pfactorK // -/r.\n    rewrite mulrSr -subr_eq0 addrK -val_eqE /= val_Zp_nat //.\n    by rewrite [_ == 0]dvdn_Pexp2l // -def_n ltnn.\n  rewrite {1}p2 /= => [[t [At ot m_t]]]; rewrite {1}oX pfactorK // -{1}def_n.\n  rewrite eqSS subn_eq0 => defA; exists y; rewrite ?inE ?notXy //.\n  rewrite p2 -(norm_conj_autE _ Xx) //= -/ay -def_m ?Aut_aut //.\n  case Tay: (ay \\in <[t]>).\n    rewrite cycle2g // !inE -order_eq1 oay p2 /= in Tay.\n    by right; rewrite (eqP Tay) m_t expg_zneg // mulgV group1.\n  case: leqP defA => [_ defA|le3n [a [Aa _ _ defA [s [As os m_s m_st defA1]]]]].\n    by rewrite -defA Aut_aut in Tay.\n  have: ay \\in [set s; s * t].\n    have: ay \\in 'Ohm_1(Aut X) := subsetP (OhmS 1 (pcore_sub _ _)) ay Ap1ay.\n    case/dprodP: (Ohm_dprod 1 defA) => _ <- _ _.\n    rewrite defA1 (@Ohm_p_cycle _ _ 2) /p_elt ot //= expg1 cycle2g //.\n    by rewrite mulUg mul1g inE Tay cycle2g // mulgU mulg1 mulg_set1.\n  case/set2P=> ->; [left | right].\n    by rewrite ?le3n m_s expg_znat // oX pfactorK // -p2.\n  by rewrite m_st expg_znat // oX pfactorK // -p2 -/r -expgS prednK ?cycle_id.\nhave [Gy notXy] := setDP X'y; have nXy := subsetP nXG y Gy.\nhave defG j: <[x]> <*> <[x ^+ j * y]> = G.\n  rewrite -defX -genM_join.\n  by rewrite (mulg_normal_maximal nsXG) ?cycle_subG ?groupMl ?groupX ?genGid.\nhave[i def_yp]: exists i, y ^- p = x ^+ i.\n  by apply/cycleP; rewrite -defX groupV X_Gp.\nhave p_i: p %| i.\n  apply: contraR notXy; rewrite -prime_coprime // => co_p_j.\n  have genX: generator X (y ^- p).\n    by rewrite def_yp defX generator_coprime ox coprimeXl.\n  rewrite -scXG (setIidPl _) // centsC ((X :=P: _) genX) cycle_subG groupV.\n  rewrite /= -(defG 0) mul1g centY inE -defX (subsetP cXX) ?X_Gp //.\n  by rewrite (subsetP (cycle_abelian y)) ?mem_cycle.\ncase=> [[n_gt23 xy] | [p2 Z_xxy]].\n  suffices ->: cG = ModularGroup by []; apply/modular_group_classP.\n  exists p => //; exists n => //; rewrite isogEcard card_modular_group //.\n  rewrite oG leqnn andbT Grp_modular_group // -/q -/r.\n  have{i def_yp p_i} [i def_yp]: exists i, y ^- p = x ^+ i ^+ p.\n    by case/dvdnP: p_i => j def_i; exists j; rewrite -expgM -def_i.\n  have Zyx: [~ y, x] \\in Z.\n    by rewrite -groupV invg_comm commgEl xy expgS mulKg cycle_id.\n  have def_yxj j: [~ y, x ^+ j] = [~ y, x] ^+ j.\n    by rewrite commgX /commute ?(centsP cGZ _ Zyx).\n  have Zyxj j: [~ y, x ^+ j] \\in Z by rewrite def_yxj groupX.\n  have x_xjy j: x ^ (x ^+ j * y) = x ^+ r.+1.\n    by rewrite conjgM {2}/conjg commuteX //= mulKg.\n  have [cyxi | not_cyxi] := eqVneq ([~ y, x ^+ i] ^+ 'C(p, 2)) 1.\n    apply/existsP; exists (x, x ^+ i * y); rewrite /= !xpair_eqE.\n    rewrite defG x_xjy -order_dvdn ox dvdnn !eqxx andbT /=.\n    rewrite expMg_Rmul /commute ?(centsP cGZ _ (Zyxj _)) ?groupX // cyxi.\n    by rewrite -def_yp -mulgA mulKg.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    by rewrite -order_dvdn bin2odd ?dvdn_mulr // -oZ order_dvdG in not_cyxi.\n  have def_yxi: [~ y, x ^+ i] = x ^+ r.\n    have:= Zyxj i; rewrite /Z cycle_traject orderE oZ p2 !inE mulg1.\n    by case/pred2P=> // cyxi; rewrite cyxi p2 eqxx in not_cyxi.\n  apply/existsP; exists (x, x ^+ (i + r %/ 2) * y); rewrite /= !xpair_eqE.\n  rewrite defG x_xjy -order_dvdn ox dvdnn !eqxx andbT /=.\n  rewrite expMg_Rmul /commute ?(centsP cGZ _ (Zyxj _)) ?groupX // def_yxj.\n  rewrite -expgM mulnDl addnC !expgD (expgM x i) -def_yp mulgKV.\n  rewrite -def_yxj def_yxi p2 mulgA -expgD in n_gt23 *.\n  rewrite -expg_mod_order ox /q /r p2 -(subnKC n_gt23) mulnC !expnS mulKn //.\n  rewrite addnn -mul2n modnn mul1g -order_dvdn dvdn_mulr //.\n  by rewrite -p2 -oZ order_dvdG.\nhave{i def_yp p_i} Zy2: y ^+ 2 \\in Z.\n  rewrite defZ (OhmE _ pX) -groupV -p2 def_yp mem_gen // !inE groupX //= p2.\n  rewrite expgS -{2}def_yp -(mulKg y y) -conjgE -conjXg -conjVg def_yp conjXg.\n  rewrite -expgMn //; last by apply: (centsP cXX); rewrite ?memJ_norm.\n  by rewrite -order_dvdn (dvdn_trans (order_dvdG Z_xxy)) ?oZ.\nrewrite !cycle_traject !orderE oZ p2 !inE !mulg1 /= in Z_xxy Zy2 *.\nrewrite -eq_invg_mul eq_sym -[r]prednK // expgS (inj_eq (mulgI _)) in Z_xxy.\ncase/pred2P: Z_xxy => xy; last first.\n  suffices ->: cG = SemiDihedral by []; apply/semidihedral_classP.\n  have n_gt3: n > 3.\n    case: ltngtP notXy => // [|n3]; first by rewrite ltnNge n_gt2.\n    rewrite -scXG inE Gy defX cent_cycle; case/cent1P; red.\n    by rewrite (conjgC x) xy /r p2 -n3.\n  exists n => //; rewrite isogEcard card_semidihedral // oG p2 leqnn andbT.\n  rewrite Grp_semidihedral //; apply/existsP=> /=.\n  case/pred2P: Zy2 => y2; [exists (x, y) | exists (x, x * y)].\n    by rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\n  rewrite /= (defG 1%N) conjgM {2}/conjg mulKg -p2 -/q -ox expg_order -xy.\n  rewrite !xpair_eqE !eqxx /= andbT p2 expgS {2}(conjgC x) xy mulgA -(mulgA x).\n  rewrite [y * y]y2 -expgS -expgD addSnnS prednK // addnn -mul2n -p2 def_pr.\n  by rewrite -ox expg_order.\ncase/pred2P: Zy2 => y2.\n  suffices ->: cG = Dihedral by []; apply/dihedral_classP.\n  exists n => //; rewrite isogEcard card_2dihedral // oG p2 leqnn andbT.\n  rewrite Grp_2dihedral //; apply/existsP; exists (x, y) => /=.\n  by rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\nsuffices ->: cG = Quaternion by []; apply/quaternion_classP.\nexists n => //; rewrite isogEcard card_quaternion // oG p2 leqnn andbT.\nrewrite Grp_quaternion //; apply/existsP; exists (x, y) => /=.\nby rewrite /= -{1}[y]mul1g (defG 0) y2 xy -p2 -/q -ox expg_order.\nQed."
}
{
  "statement": "Lemma cyclic_SCN gT p (G U : {group gT}) :\n    p.-group G -> U \\in 'SCN(G) -> ~~ abelian G -> cyclic U ->\n    [/\\ p = 2, #|G : U| = 2 & extremal2 G]\n\\/ exists M : {group gT},\n   [/\\ M :=: 'C_G('Mho^1(U)), #|M : U| = p, extremal_class M = ModularGroup,\n       'Ohm_1(M)%G \\in 'E_p^2(G) & 'Ohm_1(M) \\char G].\n",
  "proof": "Proof.\nmove=> pG /SCN_P[nsUG scUG] not_cGG cycU; have [sUG nUG] := andP nsUG.\nhave [cUU pU] := (cyclic_abelian cycU, pgroupS sUG pG).\nhave ltUG: ~~ (G \\subset U).\n  by apply: contra not_cGG => sGU; apply: abelianS cUU.\nhave ntU: U :!=: 1.\n  by apply: contraNneq ltUG => U1; rewrite -scUG subsetIidl U1 cents1.\nhave [p_pr _ [n oU]] := pgroup_pdiv pU ntU.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave [u defU] := cyclicP cycU; have Uu: u \\in U by rewrite defU cycle_id.\nhave Gu := subsetP sUG u Uu; have p_u := mem_p_elt pG Gu.\nhave defU1: 'Mho^1(U) = <[u ^+ p]> by rewrite defU (Mho_p_cycle _ p_u).\nhave modM1 (M : {group gT}):\n    [/\\ U \\subset M, #|M : U| = p & extremal_class M = ModularGroup] ->\n  M :=: 'C_M('Mho^1(U)) /\\ 'Ohm_1(M)%G \\in 'E_p^2(M).\n- case=> sUM iUM /modular_group_classP[q q_pr {n oU}[n n_gt23 isoM]].\n  have n_gt2: n > 2 by apply: leq_trans (leq_addl _ _) n_gt23.\n  have def_n: n = (n - 3).+3 by rewrite -{1}(subnKC n_gt2).\n  have oM: #|M| = (q ^ n)%N by rewrite (card_isog isoM) card_modular_group.\n  have pM: q.-group M by rewrite /pgroup oM pnatX pnat_id.\n  have def_q: q = p; last rewrite {q q_pr}def_q in oM pM isoM n_gt23.\n    by apply/eqP; rewrite eq_sym [p == q](pgroupP pM) // -iUM dvdn_indexg.\n  have [[x y] genM modM] := generators_modular_group p_pr n_gt2 isoM.\n  case/modular_group_structure: genM => // _ [defZ _ oZ] _ defMho.\n  have ->: 'Mho^1(U) = 'Z(M).\n    apply/eqP; rewrite eqEcard oZ defZ -(defMho 1%N) ?MhoS //= defU1 -orderE.\n    suff ou: #[u] = (p * p ^ n.-2)%N by rewrite orderXdiv ou ?dvdn_mulr ?mulKn.\n    by rewrite orderE -defU -(divg_indexS sUM) iUM oM def_n mulKn.\n  case: eqP => [[p2 n3] | _ defOhm]; first by rewrite p2 n3 in n_gt23.\n  have{defOhm} [|defM1 oM1] := defOhm 1%N; first by rewrite def_n.\n  split; rewrite ?(setIidPl _) //; first by rewrite centsC subsetIr.\n  rewrite inE oM1 pfactorK // andbT inE Ohm_sub abelem_Ohm1 //.\n  exact: (card_p2group_abelian p_pr oM1).\nhave ou: #[u] = (p ^ n.+1)%N by rewrite defU in oU.\npose Gs := G / U; have pGs: p.-group Gs by rewrite quotient_pgroup.\nhave ntGs: Gs != 1 by rewrite -subG1 quotient_sub1.\nhave [_ _ [[|k] oGs]] := pgroup_pdiv pGs ntGs.\n  have iUG: #|G : U| = p by rewrite -card_quotient ?oGs.\n  case: (predU1P (maximal_cycle_extremal _ _ _ _ iUG)) => // [modG | ext2G].\n    by right; exists G; case: (modM1 G) => // <- ->; rewrite Ohm_char.\n  by left; case: eqP ext2G => // <-.\npose M := 'C_G('Mho^1(U)); right; exists [group of M].\nhave sMG: M \\subset G by apply: subsetIl.\nhave [pM nUM] := (pgroupS sMG pG, subset_trans sMG nUG).\nhave sUM: U \\subset M by rewrite subsetI sUG sub_abelian_cent ?Mho_sub.\npose A := Aut U; have cAA: abelian A by rewrite Aut_cyclic_abelian.\nhave sylAp: p.-Sylow(A) 'O_p(A) by rewrite nilpotent_pcore_Hall ?abelian_nil.\nhave [f [injf sfGsA fG]]: exists f : {morphism Gs >-> {perm gT}},\n   [/\\ 'injm f, f @* Gs \\subset A & {in G, forall y, f (coset U y) u = u ^ y}].\n- have [] := first_isom_loc [morphism of conj_aut U] nUG.\n  rewrite ker_conj_aut scUG /= -/Gs => f injf im_f.\n  exists f; rewrite im_f ?Aut_conj_aut //.\n  split=> // y Gy; have nUy := subsetP nUG y Gy.\n  suffices ->: f (coset U y) = conj_aut U y by rewrite norm_conj_autE.\n  by apply: set1_inj; rewrite -!morphim_set1 ?mem_quotient // im_f ?sub1set.\nhave cGsGs: abelian Gs by rewrite -(injm_abelian injf) // (abelianS sfGsA).\nhave p_fGs: p.-group (f @* Gs) by rewrite morphim_pgroup.\nhave sfGsAp: f @* Gs \\subset 'O_p(A) by rewrite (sub_Hall_pcore sylAp).\nhave [a [fGa oa au n_gt01 cycGs]]: exists a,\n  [/\\ a \\in f @* Gs, #[a] = p, a u = u ^+ (p ^ n).+1, (p == 2) + 1 <= n\n    & cyclic Gs \\/ p = 2 /\\ (exists2 c, c \\in f @* Gs & c u = u^-1)].\n- have [m [[def_m _ _ _ _] _]] := cyclic_pgroup_Aut_structure pU cycU ntU.\n  have ->: logn p #|U| = n.+1 by rewrite oU pfactorK.\n  rewrite /= -/A; case: posnP => [_ defA | n_gt0 [c [Ac oc m_c defA]]].\n    have:= cardSg sfGsAp; rewrite (card_Hall sylAp) /= -/A defA card_injm //.\n    by rewrite oGs (part_p'nat (pcore_pgroup _ _)) pfactor_dvdn // logn1.\n  have [p2 | odd_p] := even_prime p_pr; last first.\n    case: eqP => [-> // | _] in odd_p *; rewrite odd_p in defA.\n    have [[cycA _] _ [a [Aa oa m_a defA1]]] := defA.\n    exists a; rewrite -def_m // oa m_a expg_znat //.\n    split=> //; last by left; rewrite -(injm_cyclic injf) ?(cyclicS sfGsA).\n    have: f @* Gs != 1 by rewrite morphim_injm_eq1.\n    rewrite -cycle_subG; apply: contraR => not_sfGs_a.\n    by rewrite -(setIidPl sfGsAp) TI_Ohm1 // defA1 setIC prime_TIg -?orderE ?oa.\n  do [rewrite {1}p2 /= eqn_leq n_gt0; case: leqP => /= [_ | n_gt1]] in defA.\n    have:= cardSg sfGsAp; rewrite (card_Hall sylAp) /= -/A defA -orderE oc p2.\n    by rewrite card_injm // oGs p2 pfactor_dvdn // p_part.\n  have{defA} [s [As os _ defA [a [Aa oa m_a _ defA1]]]] := defA; exists a.\n  have fGs_a: a \\in f @* Gs.\n    suffices: f @* Gs :&: <[s]> != 1.\n      apply: contraR => not_fGs_a; rewrite TI_Ohm1 // defA1 setIC.\n      by rewrite prime_TIg -?orderE ?oa // cycle_subG.\n    have: (f @* Gs) * <[s]> \\subset A by rewrite mulG_subG cycle_subG sfGsA.\n    move/subset_leq_card; apply: contraL; move/eqP; move/TI_cardMg->.\n    rewrite -(dprod_card defA) -ltnNge mulnC -!orderE ltn_pmul2r // oc.\n    by rewrite card_injm // oGs p2 (ltn_exp2l 1).\n  rewrite -def_m // oa m_a expg_znat // p2; split=> //.\n  rewrite abelian_rank1_cyclic // (rank_pgroup pGs) //.\n  rewrite -(injm_p_rank injf) // p_rank_abelian 1?morphim_abelian //= p2 -/Gs.\n  case: leqP => [|fGs1_gt1]; [by left | right].\n  split=> //; exists c; last by rewrite -def_m // m_c expg_zneg.\n  have{} defA1: <[a]> \\x <[c]> = 'Ohm_1(Aut U).\n    by rewrite -(Ohm_dprod 1 defA) defA1 (@Ohm_p_cycle 1 _ 2) /p_elt oc.\n  have def_fGs1: 'Ohm_1(f @* Gs) = 'Ohm_1(A).\n    apply/eqP; rewrite eqEcard OhmS // -(dprod_card defA1) -!orderE oa oc.\n    by rewrite dvdn_leq ?(@pfactor_dvdn 2 2) ?cardG_gt0.\n  rewrite (subsetP (Ohm_sub 1 _)) // def_fGs1 -cycle_subG.\n  by case/dprodP: defA1 => _ <- _ _; rewrite mulG_subr.\nhave n_gt0: n > 0 := leq_trans (leq_addl _ _) n_gt01.\nhave [ys Gys _ def_a] := morphimP fGa.\nhave oys: #[ys] = p by rewrite -(order_injm injf) // -def_a oa.\nhave defMs: M / U = <[ys]>.\n  apply/eqP; rewrite eq_sym eqEcard -orderE oys cycle_subG; apply/andP; split.\n    have [y nUy Gy /= def_ys] := morphimP Gys.\n    rewrite def_ys mem_quotient //= inE Gy defU1 cent_cycle cent1C.\n    rewrite (sameP cent1P commgP) commgEl conjXg -fG //= -def_ys -def_a au.\n    by rewrite -expgM mulSn expgD mulKg -expnSr -ou expg_order.\n  rewrite card_quotient // -(setIidPr sUM) -scUG setIA (setIidPl sMG).\n  rewrite defU cent_cycle index_cent1 -(card_imset _ (mulgI u^-1)) -imset_comp.\n  have <-: #|'Ohm_1(U)| = p.\n    rewrite defU (Ohm_p_cycle 1 p_u) -orderE (orderXexp _ ou) ou pfactorK //.\n    by rewrite subKn.\n  rewrite (OhmE 1 pU) subset_leq_card ?sub_gen //.\n  apply/subsetP=> _ /imsetP[z /setIP[/(subsetP nUG) nUz cU1z] ->].\n  have Uv' := groupVr Uu; have Uuz: u ^ z \\in U by rewrite memJ_norm.\n  rewrite !inE groupM // expgMn /commute 1?(centsP cUU u^-1) //= expgVn -conjXg.\n  by rewrite (sameP commgP cent1P) cent1C -cent_cycle -defU1.\nhave iUM: #|M : U| = p by rewrite -card_quotient ?defMs.\nhave not_cMM: ~~ abelian M.\n  apply: contraL p_pr => cMM; rewrite -iUM -indexgI /= -/M.\n  by rewrite (setIidPl _) ?indexgg // -scUG subsetI sMG sub_abelian_cent.\nhave modM: extremal_class M = ModularGroup.\n  have sU1Z: 'Mho^1(U) \\subset 'Z(M).\n    by rewrite subsetI gFsub_trans // centsC subsetIr.\n  have /maximal_cycle_extremal/predU1P[] //= := iUM; rewrite -/M.\n  case/andP=> /eqP-p2 ext2M; rewrite p2 add1n in n_gt01.\n  suffices{sU1Z}: #|'Z(M)| = 2.\n    move/eqP; rewrite eqn_leq leqNgt (leq_trans _ (subset_leq_card sU1Z)) //.\n    by rewrite defU1 -orderE (orderXexp 1 ou) subn1 p2 (ltn_exp2l 1).\n  move: ext2M; rewrite /extremal2 !inE orbC -orbA; case/or3P; move/eqP.\n  - case/semidihedral_classP=> m m_gt3 isoM.\n    have [[x z] genM [oz _]] := generators_semidihedral m_gt3 isoM.\n    by case/semidihedral_structure: genM => // _ _ [].\n  - case/quaternion_classP=> m m_gt2 isoM.\n    have [[x z] genM _] := generators_quaternion m_gt2 isoM.\n    by case/quaternion_structure: genM => // _ _ [].\n  case/dihedral_classP=> m m_gt1 isoM.\n  have [[x z] genM _] := generators_2dihedral m_gt1 isoM.\n  case/dihedral2_structure: genM not_cMM => // _ _ _ _.\n  by case: (m == 2) => [|[]//]; move/abelem_abelian->.\nsplit=> //.\n  have [//|_] := modM1 [group of M]; rewrite !inE -andbA /=.\n  by case/andP=> /subset_trans->.\nhave{cycGs} [cycGs | [p2 [c fGs_c u_c]]] := cycGs.\n  suffices ->: 'Ohm_1(M) = 'Ohm_1(G) by apply: Ohm_char.\n  suffices sG1M: 'Ohm_1(G) \\subset M.\n    by apply/eqP; rewrite eqEsubset -{2}(Ohm_id 1 G) !OhmS.\n  rewrite -(quotientSGK _ sUM) ?(subset_trans (Ohm_sub _ G)) //= defMs.\n  suffices ->: <[ys]> = 'Ohm_1(Gs) by rewrite morphim_Ohm.\n  apply/eqP; rewrite eqEcard -orderE cycle_subG /= {1}(OhmE 1 pGs) /=.\n  rewrite mem_gen ?inE ?Gys -?order_dvdn oys //=.\n  rewrite -(part_pnat_id (pgroupS (Ohm_sub _ _) pGs)) p_part (leq_exp2l _ 1) //.\n  by rewrite -p_rank_abelian -?rank_pgroup -?abelian_rank1_cyclic.\nsuffices charU1: 'Mho^1(U) \\char G^`(1).\n  by rewrite gFchar_trans // subcent_char ?(char_trans charU1) ?gFchar.\nsuffices sUiG': 'Mho^1(U) \\subset G^`(1).\n  have /cyclicP[zs cycG']: cyclic G^`(1) by rewrite (cyclicS _ cycU) ?der1_min.\n  by rewrite cycG' in sUiG' *; apply: cycle_subgroup_char.\nrewrite defU1 cycle_subG p2 -groupV invMg -{2}u_c.\nby have [_ _ /morphimP[z _ Gz ->] ->] := morphimP fGs_c; rewrite fG ?mem_commg.\nQed."
}
{
  "statement": "Theorem dihedral2_structure :\n    n > 1 -> extremal_generators G 2 n (x, y) -> G \\isog 'D_m ->\n  [/\\ [/\\ X ><| Y = G, {in G :\\: X, forall t, #[t] = 2}\n        & {in X & G :\\: X, forall z t, z ^ t = z^-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      'Ohm_1(G) = G /\\ (forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>),\n      [/\\ yG :|: xyG = G :\\: X, [disjoint yG & xyG]\n        & forall M, maximal M G = pred3 X My Mxy M]\n    & if n == 2 then (2.-abelem G : Prop) else\n  [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n       My \\isog 'D_q, Mxy \\isog 'D_q\n     & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\n",
  "proof": "Proof.\nmove=> n_gt1 genG isoG; have [def2q def2r ltqm ltrq] := def2qr n_gt1.\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave [[u v] [_ Gu ou U'v] [ov uv]] := generators_2dihedral n_gt1 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z^-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> z'; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv expgVn.\nhave oU': {in <[u]> :* v, forall t, #[t] = 2}.\n  move=> t Uvt; apply: nt_prime_order => //; last first.\n    by case: eqP Uvt => // ->; rewrite defUv !inE group1.\n  case/rcosetP: Uvt => z Uz ->{t}; rewrite expgS {1}(conjgC z) -mulgA.\n  by rewrite invUV ?rcoset_refl // mulKg -(expgS v 1) -ov expg_order.\nhave defU: n > 2 -> {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> n_gt2 z Gz oz; apply/eqP; rewrite eqEcard -!orderE oz cycle_subG.\n  apply: contraLR n_gt2; rewrite ou leqnn andbT -(ltn_predK n_gt1) => notUz.\n  by rewrite ltnS -(@ltn_exp2l 2) // -/q -oz oU' // defUv inE notUz.\nhave n2_abelG: (n > 2) || 2.-abelem G.\n  rewrite ltn_neqAle eq_sym n_gt1; case: eqP => //= n2.\n  apply/abelemP=> //; split=> [|z Gz].\n    by apply: (p2group_abelian pG); rewrite oG pfactorK ?n2.\n  case Uz: (z \\in <[u]>); last by rewrite -expg_mod_order oU' // defUv inE Uz.\n  apply/eqP; rewrite -order_dvdn (dvdn_trans (order_dvdG Uz)) // -orderE.\n  by rewrite ou /q n2.\nhave{oU'} oX': {in G :\\: X, forall t, #[t] = 2}.\n  have [n_gt2 | abelG] := orP n2_abelG; first by rewrite [X]defU // -defUv.\n  move=> t /setDP[Gt notXt]; apply: nt_prime_order (group1_contra notXt) => //.\n  by case/abelemP: abelG => // _ ->.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z^-1}.\n  have [n_gt2 | abelG] := orP n2_abelG; first by rewrite [X]defU // -defUv.\n  have [//|cGG oG2] := abelemP _ abelG.\n  move=> t z Xt /setDP[Gz _]; apply/eqP; rewrite eq_sym eq_invg_mul.\n  by rewrite /conjg -(centsP cGG z) // ?mulKg ?[t * t]oG2 ?(subsetP sXG).\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -groupV expnSr expgM invMg.\n  by rewrite -{2}(invXX' _ y) ?mem_cycle ?cycle_id ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X); last by rewrite -{1}(oX' z) ?expg_order ?group1 // inE Xz.\n  by case/cycleP: Xz => i ->; rewrite expgAC mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^- 2 * t}.\n    move=> z Xz; rewrite /= invMg -mulgA (conjgC _ t).\n    by rewrite (invXX' _ t) ?groupV ?invgK.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> _ z /cycleP[j ->] Xz -> -> {tz t'z}.\n    exists (z ^- 2); last by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite groupV -expgM mulnC expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}; exists (x ^- i); first by rewrite groupV groupX.\n  by rewrite defJt ?groupV ?mem_cycle // expgVn invgK expgAC.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> ><| <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite sdprodEY ?cycle_subG ?(subsetP (nXiG 2)) //; first 1 last.\n    rewrite setIC prime_TIg -?orderE ?oX' // cycle_subG.\n    by apply: contra notXt; apply: subsetP; rewrite cycleX.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't /=; rewrite -(sdprod_card (defMt t X't)) -!orderE ox2 oX' //.\n  by rewrite mulnC.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't /=; rewrite p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nsplit.\n- by rewrite ?sdprodE // setIC // prime_TIg ?cycle_subG // -orderE ?oX'.\n- rewrite defG'; split=> //.\n  apply/eqP; rewrite eqn_leq (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // geq_max leqnn -(subnKC n_gt1).\n  rewrite -(subnKC n_gt1) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- split; last exact: extend_cyclic_Mho.\n  have sX'G1: {subset G :\\: X <= 'Ohm_1(G)}.\n    move=> t X't; have [Gt _] := setDP X't.\n    by rewrite (OhmE 1 pG) mem_gen // !inE Gt -(oX' t) //= expg_order.\n  apply/eqP; rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n  by rewrite -(groupMr _ (sX'G1 y X'y)) !sX'G1.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => t Ht notXt.\n  have: t \\in yG :|: xyG by rewrite defX' inE notXt (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP; move/class_eqP <-; rewrite !class_sub_norm ?Ht ?orbT.\nrewrite eqn_leq n_gt1; case: leqP n2_abelG => //= n_gt2 _.\nhave ->: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> t; case/setIP=> Gt cGt.\n  case X't: (t \\in G :\\: X).\n    move/eqP: (invXX' _ _ (cycle_id x) X't).\n    rewrite /conjg -(centP cGt) // mulKg eq_sym eq_invg_mul -order_eq1 ox2.\n    by rewrite (eqn_exp2l _ 0) // -(subnKC n_gt2).\n  move/idPn: X't; rewrite inE Gt andbT negbK => Xt.\n  have:= Ohm_p_cycle 1 (mem_p_elt pG Gx); rewrite ox pfactorK // subn1 => <-.\n  rewrite (OhmE _ (pgroupS sXG pG)) mem_gen // !inE Xt /=.\n  by rewrite -eq_invg_mul -(invXX' _ y) // /conjg (centP cGt) // mulKg.\nhave isoMt: {in G :\\: X, forall t, <<t ^: G>> \\isog 'D_q}.\n  have n1_gt1: n.-1 > 1 by rewrite -(subnKC n_gt2).\n  move=> t X't /=; rewrite isogEcard card_2dihedral ?oMt // leqnn andbT.\n  rewrite Grp_2dihedral //; apply/existsP; exists (x ^+ 2, t) => /=.\n  have [_ <- nX2T _] := sdprodP (defMt t X't); rewrite norm_joinEr //.\n  rewrite -/q -/r !xpair_eqE eqxx -expgM def2r -ox -{1}(oX' t X't).\n  by rewrite !expg_order !eqxx /= invXX' ?mem_cycle.\nrewrite !isoMt //; split=> // C; case/cyclicP=> z ->{C} sCG iCG.\nrewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed."
}
{
  "statement": "Theorem semidihedral_structure :\n    n > 3 -> extremal_generators G 2 n (x, y) -> G \\isog 'SD_m -> #[y] = 2 ->\n  [/\\ [/\\ X ><| Y = G, #[x * y] = 4\n        & {in X & G :\\: X, forall z t, z ^ t = z ^+ r.-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n          'Ohm_1(G) = My /\\ 'Ohm_2(G) = G\n         & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n      [/\\ yG :|: xyG = G :\\: X /\\ [disjoint yG & xyG]\n        & forall H, maximal H G = pred3 X My Mxy H]\n    & [/\\ My \\isog 'D_q, Mxy \\isog 'Q_q\n       & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\n",
  "proof": "Proof.\nmove=> n_gt3 genG isoG oy.\nhave [def2q def2r ltqm ltrq] := def2qr (ltnW (ltnW n_gt3)).\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave [[u v] [_ Gu ou U'v] [ov uv]] := generators_semidihedral n_gt3 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z ^+ r.-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> ?; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv -!expgM mulnC.\nhave [vV yV]: v^-1 = v /\\ y^-1 = y by rewrite !invg_expg ov oy.\nhave defU: {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> z Gz /= oz; apply/eqP; rewrite eqEcard -!orderE oz ou leqnn andbT.\n  apply: contraLR (n_gt3) => notUz; rewrite -leqNgt -(ltn_predK n_gt3) ltnS.\n  rewrite -(@dvdn_Pexp2l 2) // -/q -{}oz order_dvdn expgM (expgS z).\n  have{Gz notUz} [z' Uz' ->{z}]: exists2 z', z' \\in <[u]> & z = z' * v.\n    by apply/rcosetP; rewrite defUv inE -cycle_subG notUz Gz.\n  rewrite {2}(conjgC z') invUV ?rcoset_refl // mulgA -{2}vV mulgK -expgS.\n  by rewrite prednK // -expgM mulnC def2r -order_dvdn /q -ou order_dvdG.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z ^+ r.-1}.\n  by rewrite /X defU -?defUv.\nhave xy2: (x * y) ^+ 2 = x ^+ r.\n  rewrite expgS {2}(conjgC x) invXX' ?cycle_id // mulgA -{2}yV mulgK -expgS.\n  by rewrite prednK.\nhave oxy: #[x * y] = 4 by rewrite (@orderXprime _ 2 2) ?xy2.\nhave r_gt2: r > 2 by rewrite (ltn_exp2l 1) // -(subnKC n_gt3).\nhave coXr1: coprime #[x] (2 ^ (n - 3)).-1.\n  rewrite ox coprimeXl // -(@coprime_pexpl (n - 3)) ?coprimenP ?subn_gt0 //.\n  by rewrite expn_gt0.\nhave def2r1: (2 * (2 ^ (n - 3)).-1).+1 = r.-1.\n  rewrite -!subn1 mulnBr -expnS [_.+1]subnSK ?(ltn_exp2l 0) //.\n  by rewrite /r -(subnKC n_gt3).\nhave defZ: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> z /setIP[Gz cGz].\n  case X'z: (z \\in G :\\: X).\n    move/eqP: (invXX' _ _ (cycle_id x) X'z).\n    rewrite /conjg -(centP cGz) // mulKg -def2r1 eq_mulVg1 expgS mulKg mulnC.\n    rewrite -order_dvdn Gauss_dvdr // order_dvdn -order_eq1.\n    by rewrite ox2 -(subnKC r_gt2).\n  move/idPn: X'z; rewrite inE Gz andbT negbK => Xz.\n  have:= Ohm_p_cycle 1 (mem_p_elt pG Gx); rewrite ox pfactorK // subn1 => <-.\n  rewrite (OhmE _ (mem_p_elt pG Gx)) mem_gen // !inE Xz /=.\n  rewrite -(expgK coXr1 Xz) -!expgM mulnCA -order_dvdn dvdn_mull //.\n  rewrite mulnC order_dvdn -(inj_eq (mulgI z)) -expgS mulg1 def2r1.\n  by rewrite -(invXX' z y) // /conjg (centP cGz) ?mulKg.\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -(expgK coXr1 (mem_cycle _ _)) groupX //.\n  rewrite -expgM expnSr -mulnA expgM -(mulKg (x ^+ (2 ^ i)) (_ ^+ _)).\n  by rewrite -expgS def2r1 -(invXX' _ y) ?mem_cycle ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X).\n    by case/cycleP: Xz => i ->; rewrite -expgM mulnC expgM mem_cycle.\n  have{Xz Gz} [xi Xxi ->{z}]: exists2 xi, xi \\in X & z = xi * y.\n    have Uvy: y \\in <[u]> :* v by rewrite defUv -(defU x).\n    apply/rcosetP; rewrite /X defU // (rcoset_eqP Uvy) defUv.\n    by rewrite inE -(defU x) ?Xz.\n  rewrite expn1 expgS {2}(conjgC xi) -{2}[y]/(y ^+ 2.-1) -{1}oy -invg_expg.\n  rewrite mulgA mulgK invXX' // -expgS prednK // /r -(subnKC n_gt3) expnS.\n  by case/cycleP: Xxi => i ->; rewrite -expgM mulnCA expgM mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^+ r.-2 * t}.\n    move=> z Xz /=; rewrite -(mulKg z (z ^+ _)) -expgS -subn2.\n    have X'tV: t^-1 \\in G :\\: X by rewrite inE !groupV notXt.\n    by rewrite subnSK 1?ltnW // subn1 -(invXX' _ t^-1) // -mulgA -conjgCV.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> t' z; case/cycleP=> j -> Xz -> -> {t' t'z tz}.\n    exists (z ^+ r.-2); last first.\n      by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite -def2r1 -expgM mulnCA expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}.\n  exists (x ^+ (i * expg_invn X (2 ^ (n - 3)).-1)); first by rewrite groupX.\n  rewrite defJt ?mem_cycle // -def2r1 -!expgM.\n  by rewrite mulnAC mulnA mulnC muln2 !expgM expgK ?mem_cycle.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> <*> <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite -defMt // -(Lagrange (joing_subl _ _)) -orderE ox2 -def2r mulnC.\n  congr (_ * r)%N; rewrite -card_quotient /=; last first.\n    by rewrite defMt // (subset_trans _ (nXiG 2)) ?sMtG.\n  rewrite joingC quotientYidr ?(subset_trans _ (nXiG 2)) ?cycle_subG //.\n  rewrite quotient_cycle ?(subsetP (nXiG 2)) //= -defPhi -orderE.\n  rewrite (abelem_order_p (Phi_quotient_abelem pG)) ?mem_quotient //.\n  apply: contraNneq notXt; move/coset_idr; move/implyP=> /=.\n  by rewrite /= defPhi (subsetP (nXiG 2)) //; apply: subsetP; apply: cycleX.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't /=; rewrite p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nsplit.\n- by rewrite sdprodE // setIC prime_TIg ?cycle_subG // -orderE oy.\n- rewrite defG'; split=> //.\n  apply/eqP; rewrite eqn_leq (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // -(subnKC n_gt3).\n  rewrite -(subnKC (ltnW (ltnW n_gt3))) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- rewrite defZ; split=> //; last exact: extend_cyclic_Mho.\n  split; apply/eqP; last first.\n    have sX'G2: {subset G :\\: X <= 'Ohm_2(G)}.\n      move=> t X't; have [Gt _] := setDP X't; rewrite -defX' in X't.\n      rewrite (OhmE 2 pG) mem_gen // !inE Gt -order_dvdn.\n      by case/setUP: X't; case/imsetP=> z _ ->; rewrite orderJ ?oy ?oxy.\n    rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n    by rewrite -(groupMr _ (sX'G2 y X'y)) !sX'G2.\n  rewrite eqEsubset andbC gen_subG class_sub_norm ?gFnorm //.\n  rewrite (OhmE 1 pG) mem_gen ?inE ?Gy -?order_dvdn ?oy // gen_subG /= -/My.\n  apply/subsetP=> t /[!inE]; case/andP=> Gt t2.\n  have pX := pgroupS sXG pG.\n  case Xt: (t \\in X).\n    have: t \\in 'Ohm_1(X) by rewrite (OhmE 1 pX) mem_gen // !inE Xt.\n    apply: subsetP; rewrite (Ohm_p_cycle 1 pX) ox pfactorK //.\n    rewrite -(subnKC n_gt3) expgM (subset_trans (cycleX _ _)) //.\n    by rewrite /My -defMt ?joing_subl.\n  have{Xt}: t \\in yG :|: xyG by rewrite defX' inE Xt.\n  case/setUP; first exact: mem_gen.\n  by case/imsetP=> z _ def_t; rewrite -order_dvdn def_t orderJ oxy in t2.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => t Ht notXt.\n  have: t \\in yG :|: xyG by rewrite defX' inE notXt (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP=> /class_eqP <-; rewrite !class_sub_norm ?Ht ?orbT.\nhave n1_gt2: n.-1 > 2 by [rewrite -(subnKC n_gt3)]; have n1_gt1 := ltnW n1_gt2.\nrewrite !isogEcard card_2dihedral ?card_quaternion ?oMt // leqnn !andbT.\nhave invX2X': {in G :\\: X, forall t, x ^+ 2 ^ t == x ^- 2}.\n  move=> t X't; rewrite /= invXX' ?mem_cycle // eq_sym eq_invg_mul -expgS.\n  by rewrite prednK // -order_dvdn ox2.\n  rewrite Grp_2dihedral ?Grp_quaternion //; split=> [||C].\n- apply/existsP; exists (x ^+ 2, y); rewrite /= defMt // !xpair_eqE.\n  by rewrite -!expgM def2r -!order_dvdn ox oy dvdnn eqxx /= invX2X'.\n- apply/existsP; exists (x ^+ 2, x * y); rewrite /= defMt // !xpair_eqE.\n  rewrite -!expgM def2r -order_dvdn ox xy2 dvdnn eqxx invX2X' //=.\n  by rewrite andbT /r -(subnKC n_gt3).\ncase/cyclicP=> z ->{C} sCG iCG; rewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed."
}
{
  "statement": "Lemma Ohm1_extraspecial_odd (gT : finGroupType) (G : {group gT}) :\n    p.-group G -> extraspecial G -> odd #|G| ->\n let Y := 'Ohm_1(G) in\n  [/\\ exponent Y = p, #|G : Y| %| p\n    & Y != G ->\n      exists E : {group gT},\n        [/\\ #|G : Y| = p, #|E| = p \\/ extraspecial E,\n            exists2 X : {group gT}, #|X| = p & X \\x E = Y\n          & exists M : {group gT},\n             [/\\ M \\isog 'Mod_(p ^ 3), M \\* E = G & M :&: E = 'Z(M)]]].\n",
  "proof": "Proof.\nmove=> pG esG oddG Y; have [spG _] := esG.\nhave [defPhiG defG'] := spG; set Z := 'Z(G) in defPhiG defG'.\nhave{spG} expG: exponent G %| p ^ 2 by apply: exponent_special.\nhave p_pr := extraspecial_prime pG esG.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave oZ: #|Z| = p := card_center_extraspecial pG esG.\nhave nsZG: Z <| G := center_normal G; have [sZG nZG] := andP nsZG.\nhave nsYG: Y <| G := Ohm_normal 1 G; have [sYG nYG] := andP nsYG.\nhave ntZ: Z != 1 by rewrite -cardG_gt1 oZ.\nhave sZY: Z \\subset Y.\n  by apply: contraR ntZ => ?; rewrite -(setIidPl sZG) TI_Ohm1 ?prime_TIg ?oZ.\nhave ntY: Y != 1 by apply: subG1_contra ntZ.\nhave p_odd: odd p by rewrite -oZ (oddSg sZG).\nhave expY: exponent Y %| p by rewrite exponent_Ohm1_class2 // nil_class2 defG'.\nrewrite (prime_nt_dvdP p_pr _ expY) -?dvdn1 -?trivg_exponent //.\nhave [-> | neYG] := eqVneq Y G; first by rewrite indexgg dvd1n; split.\nhave sG1Z: 'Mho^1(G) \\subset Z by rewrite -defPhiG (Phi_joing pG) joing_subr.\nhave Z_Gp: {in G, forall x, x ^+ p \\in Z}.\n  by move=> x Gx; rewrite /= (subsetP sG1Z) ?(Mho_p_elt 1) ?(mem_p_elt pG).\nhave{expG} oY': {in G :\\: Y, forall u, #[u] = (p ^ 2)%N}.\n  move=> u /setDP[Gu notYu]; apply/eqP.\n  have [k ou] := p_natP (mem_p_elt pG Gu).\n  rewrite eqn_dvd order_dvdn (exponentP expG) // eqxx ou dvdn_Pexp2l // ltnNge.\n  apply: contra notYu => k_le_1; rewrite [Y](OhmE _ pG) mem_gen // !inE Gu /=.\n  by rewrite -order_dvdn ou dvdn_exp2l.\nhave isoMod3 (M : {group gT}):\n    M \\subset G -> ~~ abelian M -> ~~ (M \\subset Y) -> #|M| = (p ^ 3)%N ->\n  M \\isog 'Mod_(p ^ 3).\n- move=> sMG not_cMM /subsetPn[u Mu notYu oM].\n  have pM := pgroupS sMG pG; have sUM: <[u]> \\subset M by rewrite cycle_subG.\n  have Y'u: u \\in G :\\: Y by rewrite inE notYu (subsetP sMG).\n  have iUM: #|M : <[u]>| = p by rewrite -divgS // oM expnS -(oY' u) ?mulnK.\n  have cM := maximal_cycle_extremal pM not_cMM (cycle_cyclic u) sUM iUM.\n  rewrite (sameP eqP (prime_oddPn p_pr)) p_odd orbF in cM.\n  rewrite /extremal_class oM pdiv_pfactor // pfactorK //= in cM.\n  by do 3!case: ifP => // _ in cM.\nhave iYG: #|G : Y| = p.\n  have [V maxV sYV]: {V : {group gT} | maximal V G & Y \\subset V}.\n    by apply: maxgroup_exists; rewrite properEneq neYG.\n  have [sVG [u Gu notVu]] := properP (maxgroupp maxV).\n  without loss [v Vv notYv]: / exists2 v, v \\in V & v \\notin Y.\n    have [->| ] := eqVneq Y V; first by rewrite (p_maximal_index pG).\n    by rewrite eqEsubset sYV => not_sVY; apply; apply/subsetPn.\n  pose U := <[u]> <*> <[v]>; have Gv := subsetP sVG v Vv.\n  have sUG: U \\subset G by rewrite join_subG !cycle_subG Gu.\n  have Uu: u \\in U by rewrite -cycle_subG joing_subl.\n  have Uv: v \\in U by rewrite -cycle_subG joing_subr.\n  have not_sUY: ~~ (U \\subset Y) by apply/subsetPn; exists v.\n  have sU1U: 'Ohm_1(U) \\subset U := Ohm_sub 1 _.\n  have sU1Y: 'Ohm_1(U) \\subset Y := OhmS 1 sUG.\n  suffices defUV: U :&: V = 'Ohm_1(U).\n    by rewrite (subsetP sU1Y) // -defUV inE Uv in notYv.\n  suffices iU1U: #|U : 'Ohm_1(U)| = p.\n    have: maximal 'Ohm_1(U) U by rewrite p_index_maximal ?Ohm_sub ?iU1U.\n    case/maxgroupP=> _; apply; rewrite /= -/U.\n      by apply/properP; split; last exists u; rewrite ?subsetIl ?inE ?Uu.\n    by rewrite subsetI Ohm_sub (subset_trans sU1Y).\n  apply/prime_nt_dvdP=> //.\n    by apply: contra not_sUY; rewrite /U; move/eqP; move/(index1g sU1U)=> <-.\n  have ov: #[v] = (p ^ 2)%N by rewrite oY' // inE notYv.\n  have sZv: Z \\subset <[v]>.\n    suffices defZ: <[v ^+ p]> == Z by rewrite -(eqP defZ) cycleX.\n    by rewrite eqEcard cycle_subG Z_Gp //= oZ -orderE (orderXexp 1 ov).\n  have nvG: G \\subset 'N(<[v]>) by rewrite sub_der1_norm ?cycle_subG // defG'.\n  have [cUU | not_cUU] := orP (orbN (abelian U)).\n    rewrite -divgS ?Ohm_sub // -(mul_card_Ohm_Mho_abelian 1 cUU) /= -/U.\n    by rewrite mulKn ?cardG_gt0 //= -oZ cardSg ?(subset_trans (MhoS 1 sUG)).\n  have oU: #|U| = (p ^ 3)%N.\n    have nvu := subsetP nvG u Gu; have nvU := subset_trans sUG nvG.\n    rewrite -(Lagrange (joing_subr _ _)) -orderE ov mulnC; congr (_ * _)%N.\n    rewrite -card_quotient //= quotientYidr ?cycle_subG //=.\n    rewrite quotient_cycle // -orderE; apply: nt_prime_order => //.\n      by rewrite -morphX //= coset_id // (subsetP sZv) // Z_Gp.\n    have svV: <[v]> \\subset V by rewrite cycle_subG.\n    by apply: contra notVu; move/eqP=> v_u; rewrite (subsetP svV) // coset_idr.\n  have isoU := isoMod3 _ sUG not_cUU not_sUY oU; rewrite /= -/U in isoU.\n  have [//|[x y] genU modU] := generators_modular_group p_pr _ isoU.\n  case/modular_group_structure: genU => // _ _ _ _.\n  case: eqP (p_odd) => [[-> //] | _ _]; case/(_ 1%N)=> // _ oU1.\n  by rewrite -divgS // oU oU1 mulnK // muln_gt0 p_gt0.\nhave iC1U (U : {group gT}) x:\n  U \\subset G -> x \\in G :\\: 'C(U) -> #|U : 'C_U[x]| = p.\n- move=> sUG /setDP[Gx not_cUx]; apply/prime_nt_dvdP=> //.\n    apply: contra not_cUx; rewrite -sub_cent1 => /eqP sUCx.\n    by rewrite -(index1g _ sUCx) ?subsetIl ?subsetIr.\n  rewrite -(@dvdn_pmul2l (#|U| * #|'C_G[x]|)) ?muln_gt0 ?cardG_gt0 //.\n  have maxCx: maximal 'C_G[x] G.\n    rewrite cent1_extraspecial_maximal //; apply: contra not_cUx.\n    by rewrite inE Gx; apply: subsetP (centS sUG) _.\n  rewrite {1}mul_cardG setIA (setIidPl sUG) -(p_maximal_index pG maxCx) -!mulnA.\n  rewrite !Lagrange ?subsetIl // mulnC dvdn_pmul2l //.\n  have [sCxG nCxG] := andP (p_maximal_normal pG maxCx).\n  by rewrite -norm_joinEl ?cardSg ?join_subG ?(subset_trans sUG).\nhave oCG (U : {group gT}):\n  Z \\subset U -> U \\subset G -> #|'C_G(U)| = (p * #|G : U|)%N.\n- have [m] := ubnP #|U|; elim: m U => // m IHm U leUm sZU sUG.\n  have [<- | neZU] := eqVneq Z U.\n    by rewrite -oZ Lagrange // (setIidPl _) // centsC subsetIr.\n  have{neZU} [x Gx not_cUx]: exists2 x, x \\in G & x \\notin 'C(U).\n    by apply/subsetPn; rewrite eqEsubset sZU subsetI sUG centsC in neZU.\n  pose W := 'C_U[x]; have iWU: #|U : W| = p by rewrite iC1U // inE not_cUx.\n  have maxW: maximal W U by rewrite p_index_maximal ?subsetIl ?iWU.\n  have ltWU: W \\proper U by apply: maxgroupp maxW.\n  have [sWU [u Uu notWu]] := properP ltWU.\n  have defU: W * <[u]> = U.\n    have nsWU: W <| U := p_maximal_normal (pgroupS sUG pG) maxW.\n    by rewrite (mulg_normal_maximal nsWU) ?cycle_subG.\n  have sWG := subset_trans sWU sUG.\n  have sZW: Z \\subset W.\n    by rewrite subsetI sZU -cent_set1 subIset ?centS ?orbT ?sub1set.\n  have iCW_CU: #|'C_G(W) : 'C_G(U)| = p.\n    rewrite -defU centM cent_cycle setIA /= -/W.\n    rewrite iC1U ?subsetIl ?setIS ?centS // inE andbC (subsetP sUG) //=.\n    rewrite -sub_cent1; apply/subsetPn; exists x.\n      by rewrite inE Gx -sub_cent1 subsetIr.\n    by rewrite -defU centM cent_cycle inE -sub_cent1 subsetIr in not_cUx.\n  apply/eqP; rewrite -(eqn_pmul2r p_gt0) -{1}iCW_CU Lagrange ?setIS ?centS //.\n  rewrite IHm ?(leq_trans (proper_card ltWU)) //= -/W.\n  by rewrite -(Lagrange_index sUG sWU) iWU mulnA.\nhave oCY: #|'C_G(Y)| = (p ^ 2)%N by rewrite oCG // iYG.\nhave [x cYx notZx]: exists2 x, x \\in 'C_G(Y) & x \\notin Z.\n  apply/subsetPn; rewrite proper_subn // properEcard setIS ?centS //=.\n  by rewrite oZ oCY (ltn_exp2l 1 2).\nhave{cYx} [Gx cYx] := setIP cYx; have nZx := subsetP nZG x Gx.\nhave defCx: 'C_G[x] = Y.\n  apply/eqP; rewrite eq_sym eqEcard subsetI sYG sub_cent1 cYx /=.\n  rewrite -(leq_pmul2r p_gt0) -{2}iYG -(iC1U G x) ?Lagrange ?subsetIl //.\n  by rewrite !inE Gx ?andbT in notZx *.\nhave Yx: x \\in Y by rewrite -defCx inE Gx cent1id.\nhave ox: #[x] = p.\n  by apply: nt_prime_order; rewrite ?(exponentP expY) // (group1_contra notZx).\nhave defCy: 'C_G(Y) = Z * <[x]>.\n  apply/eqP; rewrite eq_sym eqEcard mulG_subG setIS ?centS //=.\n  rewrite cycle_subG inE Gx cYx oCY TI_cardMg ?oZ -?orderE ?ox //=.\n  by rewrite setIC prime_TIg -?orderE ?ox ?cycle_subG.\nhave abelYt: p.-abelem (Y / Z).\n  by rewrite (abelemS (quotientS _ sYG)) //= -/Z -defPhiG Phi_quotient_abelem.\nhave Yxt: coset Z x \\in Y / Z by rewrite mem_quotient.\nhave{Yxt} [Et [sEtYt oEt defYt]] := p_abelem_split1 abelYt Yxt.\nhave nsZY: Z <| Y := normalS sZY sYG nsZG.\nhave [E defEt sZE sEY] := inv_quotientS nsZY sEtYt.\nhave{defYt} [_ defYt _ tiXEt] := dprodP defYt.\nhave defY: <[x]> \\x E = Y.\n  have nZX: <[x]> \\subset 'N(Z) by rewrite cycle_subG.\n  have TIxE: <[x]> :&: E = 1.\n    rewrite prime_TIg -?orderE ?ox // -(quotientSGK _ sZE) ?quotient_cycle //.\n    rewrite (sameP setIidPl eqP) eq_sym -defEt tiXEt -quotient_cycle //.\n    by rewrite -subG1 quotient_sub1 // cycle_subG.\n  rewrite dprodE //; last 1 first.\n    by rewrite cent_cycle (subset_trans sEY) //= -/Y -defCx subsetIr.\n  rewrite -[Y](quotientGK nsZY) -defYt cosetpreM -quotient_cycle //.\n  rewrite quotientK // -(normC nZX) defEt quotientGK ?(normalS _ sEY) //.\n  by rewrite -mulgA (mulSGid sZE).\nhave sEG := subset_trans sEY sYG; have nZE := subset_trans sEG nZG.\nhave defZE: 'Z(E) = Z.\n  apply/eqP; rewrite eqEsubset andbC subsetI sZE subIset ?centS ?orbT //.\n  rewrite -quotient_sub1 ?subIset ?nZE //= -tiXEt defEt subsetI andbC.\n  rewrite quotientS ?center_sub //= -quotient_cycle //.\n  rewrite -(quotientMidl _ <[x]>) /= -defCy quotientS // /Y.\n  by case/dprodP: defY => _ <- _ _; rewrite centM setIA cent_cycle defCx setSI.\nhave pE := pgroupS sEG pG.\nrewrite iYG; split=> // _; exists E.\nsplit=> //; first 2 [by exists [group of <[x]>]].\n  have:= sZE; rewrite subEproper; case/predU1P=> [<- | ltZE]; [by left | right].\n  split; rewrite /special defZE ?oZ // (Phi_joing pE).\n  have defE': E^`(1) = Z.\n    have sE'Z: E^`(1) \\subset Z by rewrite -defG' dergS.\n    apply/eqP; rewrite eqEcard sE'Z -(prime_nt_dvdP _ _ (cardSg sE'Z)) ?oZ //=.\n    rewrite -trivg_card1 (sameP eqP commG1P).\n    by rewrite /proper sZE /= -/Z -defZE subsetI subxx in ltZE.\n  split=> //; rewrite -defE'; apply/joing_idPl.\n  by rewrite /= defE' -defPhiG (Phi_joing pG) joingC sub_gen ?subsetU ?MhoS.\nhave iEG: #|G : E| = (p ^ 2)%N.\n  apply/eqP; rewrite -(@eqn_pmul2l #|E|) // Lagrange // -(Lagrange sYG) iYG.\n  by rewrite -(dprod_card defY) -mulnA mulnCA -orderE ox.\npose M := 'C_G(E); exists [group of M] => /=.\nhave sMG: M \\subset G := subsetIl _ _; have pM: p.-group M := pgroupS sMG pG.\nhave sZM: Z \\subset M by rewrite setIS ?centS.\nhave oM: #|M| = (p ^ 3)%N by rewrite oCG ?iEG.\nhave defME: M * E = G.\n  apply/eqP; rewrite eqEcard mulG_subG sMG sEG /= -(leq_pmul2r p_gt0).\n  rewrite -{2}oZ -defZE /('Z(E)) -{2}(setIidPr sEG) setIAC -mul_cardG /= -/M.\n  by rewrite -(Lagrange sEG) mulnAC -mulnA mulnC iEG oM.\nhave defZM: 'Z(M) = Z.\n  apply/eqP; rewrite eqEsubset andbC subsetI sZM subIset ?centS ?orbT //=.\n  by rewrite /Z /('Z(G)) -{2}defME centM setIA setIAC.\nrewrite cprodE 1?centsC ?subsetIr //.\nrewrite defME setIAC (setIidPr sEG) defZM isoMod3 //.\n  rewrite abelianE (sameP setIidPl eqP) eqEcard subsetIl /= -/('Z(M)) -/M.\n  by rewrite defZM oZ oM (leq_exp2l 3 1).\nby apply: contra neYG => sMY; rewrite eqEsubset sYG -defME mulG_subG sMY.\nQed."
}
{
  "statement": "Lemma cyclic_pgroup_Aut_structure gT p (G : {group gT}) :\n    p.-group G -> cyclic G -> G :!=: 1 ->\n  let q := #|G| in let n := (logn p q).-1 in\n  let A := Aut G in let P := 'O_p(A) in let F := 'O_p^'(A) in\n  exists m : {perm gT} -> 'Z_q,\n  [/\\ [/\\ {in A & G, forall a x, x ^+ m a = a x},\n          m 1 = 1%R /\\ {in A &, {morph m : a b / a * b >-> (a * b)%R}},\n          {in A &, injective m} /\\ image m A =i GRing.unit,\n          forall k, {in A, {morph m : a / a ^+ k >-> (a ^+ k)%R}}\n        & {in A, {morph m : a / a^-1 >-> (a^-1)%R}}],\n      [/\\ abelian A, cyclic F, #|F| = p.-1\n        & [faithful F, on 'Ohm_1(G) | [Aut G]]]\n    & if n == 0 then A = F else\n      exists t, [/\\ t \\in A, #[t] = 2, m t = (- 1)%R\n      & if odd p then\n        [/\\ cyclic A /\\ cyclic P,\n           exists s, [/\\ s \\in A, #[s] = (p ^ n)%N, m s = p.+1%:R & P = <[s]>]\n         & exists s0, [/\\ s0 \\in A, #[s0] = p, m s0 = (p ^ n).+1%:R\n                        & 'Ohm_1(P) = <[s0]>]]\n   else if n == 1%N then A = <[t]>\n   else exists s,\n        [/\\ s \\in A, #[s] = (2 ^ n.-1)%N, m s = 5%:R, <[s]> \\x <[t]> = A\n      & exists s0, [/\\ s0 \\in A, #[s0] = 2, m s0 = (2 ^ n).+1%:R,\n                       m (s0 * t) = (2 ^ n).-1%:R & 'Ohm_1(<[s]>) = <[s0]>]]]].\n",
  "proof": "Proof.\nmove=> pG cycG ntG q n0 A P F; have [p_pr p_dvd_G [n oG]] := pgroup_pdiv pG ntG.\nhave [x0 defG] := cyclicP cycG; have Gx0: x0 \\in G by rewrite defG cycle_id.\nrewrite {1}/q oG pfactorK //= in n0 *; rewrite {}/n0.\nhave [p_gt1 min_p] := primeP p_pr; have p_gt0 := ltnW p_gt1.\nhave q_gt1: q > 1 by rewrite cardG_gt1.\nhave cAA: abelian A := Aut_cyclic_abelian cycG; have nilA := abelian_nil cAA.\nhave oA: #|A| = (p.-1 * p ^ n)%N.\n  by rewrite card_Aut_cyclic // oG totient_pfactor.\nhave [sylP hallF]: p.-Sylow(A) P /\\ p^'.-Hall(A) F.\n  by rewrite !nilpotent_pcore_Hall.\nhave [defPF tiPF]: P * F = A /\\ P :&: F = 1.\n  by case/dprodP: (nilpotent_pcoreC p nilA).\nhave oP: #|P| = (p ^ n)%N.\n  by rewrite (card_Hall sylP) oA p_part logn_Gauss ?coprimenP ?pfactorK.\nhave oF: #|F| = p.-1.\n  apply/eqP; rewrite -(@eqn_pmul2l #|P|) ?cardG_gt0 // -TI_cardMg // defPF.\n  by rewrite oA oP mulnC.\nhave [m' [inj_m' defA def_m']]: exists m' : {morphism units_Zp q >-> {perm gT}},\n  [/\\ 'injm m', m' @* setT = A & {in G, forall x u, m' u x = x ^+ val u}].\n- rewrite /A /q defG; exists (Zp_unit_morphism x0).\n  by have [->]:= isomP (Zp_unit_isom x0); split=> // y Gy u; rewrite permE Gy.\npose m (a : {perm gT}) : 'Z_q := val (invm inj_m' a).\nhave{def_m'} def_m: {in A & G, forall a x, x ^+ m a = a x}.\n  by move=> a x Aa Gx /=; rewrite -{2}[a](invmK inj_m') ?defA ?def_m'.\nhave m1: m 1 = 1%R by rewrite /m morph1.\nhave mM: {in A &, {morph m : a b / a * b >-> (a * b)%R}}.\n  by move=> a b Aa Ab; rewrite /m morphM ?defA.\nhave mX k: {in A, {morph m : a / a ^+ k >-> (a ^+ k)%R}}.\n  by elim: k => // k IHk a Aa; rewrite expgS exprS mM ?groupX ?IHk.\nhave inj_m: {in A &, injective m}.\n  apply: can_in_inj (fun u => m' (insubd (1 : {unit 'Z_q}) u)) _ => a Aa.\n  by rewrite valKd invmK ?defA.\nhave{defA} im_m: image m A =i GRing.unit.\n  move=> u; apply/imageP/idP=> [[a Aa ->]| Uu]; first exact: valP.\n  exists (m' (Sub u Uu)) => /=; first by rewrite -defA mem_morphim ?inE.\n  by rewrite /m invmE ?inE.\nhave mV: {in A, {morph m : a / a^-1 >-> (a^-1)%R}}.\n  move=> a Aa /=; rewrite -div1r; apply: canRL (mulrK (valP _)) _.\n  by rewrite -mM ?groupV ?mulVg.\nhave inv_m (u : 'Z_q) : coprime q u -> {a | a \\in A & m a = u}.\n  rewrite -?unitZpE // natr_Zp -im_m => m_u.\n  by exists (iinv m_u); [apply: mem_iinv | rewrite f_iinv].\nhave [cycF ffulF]: cyclic F /\\ [faithful F, on 'Ohm_1(G) | [Aut G]].\n  have Um0 a: ((m a)%:R : 'F_p) \\in GRing.unit.\n    have: m a \\in GRing.unit by apply: valP.\n    by rewrite -{1}[m a]natr_Zp unitFpE ?unitZpE // {1}/q oG coprime_pexpl.\n  pose fm0 a := FinRing.unit 'F_p (Um0 a).\n  have natZqp u: (u%:R : 'Z_q)%:R = u %:R :> 'F_p.\n    by rewrite val_Zp_nat // -Fp_nat_mod // modn_dvdm ?Fp_nat_mod.\n  have m0M: {in A &, {morph fm0 : a b / a * b}}.\n    by move=> a b Aa Ab; apply: val_inj; rewrite /= -natrM mM //= -val_Zp_nat.\n  pose m0 : {morphism A >-> {unit 'F_p}} := Morphism m0M.\n  have im_m0: m0 @* A = [set: {unit 'F_p}].\n    apply/setP=> [[/= u Uu]]; rewrite in_setT morphimEdom; apply/imsetP.\n    have [|a Aa m_a] := inv_m u%:R.\n      by rewrite {1}[q]oG coprime_pexpl // -unitFpE // natZqp natr_Zp.\n    by exists a => //; apply: val_inj; rewrite /= m_a natZqp natr_Zp.\n  have [x1 defG1]: exists x1, 'Ohm_1(G) = <[x1]>.\n    by apply/cyclicP; apply: cyclicS (Ohm_sub _ _) cycG.\n  have ox1: #[x1] = p by rewrite orderE -defG1 (Ohm1_cyclic_pgroup_prime _ pG).\n  have Gx1: x1 \\in G by rewrite -cycle_subG -defG1 Ohm_sub.\n  have ker_m0: 'ker m0 = 'C('Ohm_1(G) | [Aut G]).\n    apply/setP=> a; rewrite inE in_setI; apply: andb_id2l => Aa.\n    rewrite 3!inE /= -2!val_eqE /= val_Fp_nat // [1 %% _]modn_small // defG1.\n    apply/idP/subsetP=> [ma1 x1i | ma1].\n      case/cycleP=> i ->{x1i}; rewrite inE gactX // -[_ a]def_m //.\n      by rewrite -(expg_mod_order x1) ox1 (eqP ma1).\n    have:= ma1 x1 (cycle_id x1); rewrite inE -[_ a]def_m //.\n    by rewrite (eq_expg_mod_order x1 _ 1) ox1 (modn_small p_gt1).\n  have card_units_Fp: #|[set: {unit 'F_p}]| = p.-1.\n    by rewrite card_units_Zp // pdiv_id // (@totient_pfactor p 1) ?muln1.\n  have ker_m0_P: 'ker m0 = P.\n    apply: nilpotent_Hall_pcore nilA _.\n    rewrite pHallE -(card_Hall sylP) oP subsetIl /=.\n    rewrite -(@eqn_pmul2r #|m0 @* A|) ?cardG_gt0 //; apply/eqP.\n    rewrite -{1}(card_isog (first_isog _)) card_quotient ?ker_norm //.\n    by rewrite Lagrange ?subsetIl // oA im_m0 mulnC card_units_Fp.\n  have inj_m0: 'ker_F m0 \\subset [1] by rewrite setIC ker_m0_P tiPF.\n  split; last by rewrite /faithful -ker_m0.\n  have isogF: F \\isog [set: {unit 'F_p}].\n    have sFA: F \\subset A by apply: pcore_sub.\n    apply/isogP; exists (restrm_morphism sFA m0); first by rewrite ker_restrm.\n    apply/eqP; rewrite eqEcard subsetT card_injm ?ker_restrm //= oF.\n    by rewrite card_units_Fp.\n  rewrite (isog_cyclic isogF) pdiv_id // -ox1 (isog_cyclic (Zp_unit_isog x1)).\n  by rewrite Aut_prime_cyclic // -orderE ox1.\nexists m; split=> {im_m mV}//; have [n0 | n_gt0] := posnP n.\n  by apply/eqP; rewrite eq_sym eqEcard pcore_sub oF oA n0 muln1 /=.\nhave [t At mt]: {t | t \\in A & m t = -1}%R.\n  apply: inv_m; rewrite /= Zp_cast // coprime_modr modn_small // subn1.\n  by rewrite coprimenP // ltnW.\nhave ot: #[t] = 2.\n  apply/eqP; rewrite eqn_leq order_gt1 dvdn_leq ?order_dvdn //=.\n    apply/eqP; move/(congr1 m); apply/eqP; rewrite mt m1 eq_sym -subr_eq0.\n    rewrite opprK -val_eqE /= Zp_cast ?modn_small // /q oG ltnW //.\n    by rewrite (leq_trans (_ : 2 ^ 2 <= p ^ 2)) ?leq_sqr ?leq_exp2l.\n  by apply/eqP; apply: inj_m; rewrite ?groupX ?group1 ?mX // mt -signr_odd.\nexists t; split=> //.\ncase G4: (~~ odd p && (n == 1%N)).\n  case: (even_prime p_pr) G4 => [p2 | -> //]; rewrite p2 /=; move/eqP=> n1.\n  rewrite n1 /=; apply/eqP; rewrite eq_sym eqEcard cycle_subG At /=.\n  by rewrite -orderE oA ot p2 n1.\npose e0 : nat := ~~ odd p.\nhave{inv_m} [s As ms]: {s | s \\in A & m s = (p ^ e0.+1).+1%:R}.\n  apply: inv_m; rewrite val_Zp_nat // coprime_modr /q oG coprime_pexpl //.\n  by rewrite -(@coprime_pexpl e0.+1) // coprimenS.\nhave lt_e0_n: e0 < n.\n  by rewrite /e0; case: (~~ _) G4 => //=; rewrite ltn_neqAle eq_sym => ->.\npose s0 := s ^+ (p ^ (n - e0.+1)).\nhave [ms0 os0]: m s0 = (p ^ n).+1%:R /\\ #[s0] = p.\n  have m_se e:\n    exists2 k, k = 1 %[mod p] & m (s ^+ (p ^ e)) = (k * p ^ (e + e0.+1)).+1%:R.\n  - elim: e => [|e [k k1 IHe]]; first by exists 1%N; rewrite ?mul1n.\n    rewrite expnSr expgM mX ?groupX // {}IHe -natrX -(add1n (k * _)).\n    rewrite expnDn -(prednK p_gt0) 2!big_ord_recl /= prednK // !exp1n bin1.\n    rewrite bin0 muln1 mul1n mulnCA -expnS (addSn e).\n    set f := (e + _)%N; set sum := (\\sum_i _)%N.\n    exists (sum %/ p ^ f.+2 * p + k)%N; first by rewrite modnMDl.\n    rewrite -(addnC k) mulnDl -mulnA -expnS divnK // {}/sum.\n    apply big_ind => [||[i _] /= _]; [exact: dvdn0 | exact: dvdn_add |].\n    rewrite exp1n mul1n /bump !add1n expnMn mulnCA dvdn_mull // -expnM.\n    case: (ltnP f.+1 (f * i.+2)) => [le_f_fi|].\n      by rewrite dvdn_mull ?dvdn_exp2l.\n    rewrite {1}mulnS -(addn1 f) leq_add2l {}/f addnS /e0.\n    case: i e => [] // [] //; case odd_p: (odd p) => //= _.\n    by rewrite bin2odd // mulnAC dvdn_mulr.\n  have [[|d]] := m_se (n - e0.+1)%N; first by rewrite mod0n modn_small.\n  move/eqP; rewrite -/s0 eqn_mod_dvd ?subn1 //=; case/dvdnP=> f -> {d}.\n  rewrite subnK // mulSn -mulnA -expnS -addSn natrD natrM -oG pchar_Zp //.\n  rewrite mulr0 addr0 => m_s0; split => //.\n  have [d _] := m_se (n - e0)%N; rewrite -subnSK // expnSr expgM -/s0.\n  rewrite addSn subnK // -oG  mulrS natrM pchar_Zp // {d}mulr0 addr0.\n  move/eqP; rewrite -m1 (inj_in_eq inj_m) ?group1 ?groupX // -order_dvdn.\n  move/min_p; rewrite order_eq1; case/predU1P=> [s0_1 | ]; last by move/eqP.\n  move/eqP: m_s0; rewrite eq_sym s0_1 m1 -subr_eq0 mulrSr addrK -val_eqE /=.\n  have pf_gt0: p ^ _ > 0 by move=> e; rewrite expn_gt0 p_gt0.\n  by rewrite val_Zp_nat // /q oG [_ == _]pfactor_dvdn // pfactorK ?ltnn.\nhave os: #[s] = (p ^ (n - e0))%N.\n  have: #[s] %| p ^ (n - e0).\n    by rewrite order_dvdn -subnSK // expnSr expgM -order_dvdn os0.\n  case/dvdn_pfactor=> // d; rewrite leq_eqVlt.\n  case/predU1P=> [-> // | lt_d os]; case/idPn: (p_gt1); rewrite -os0.\n  by rewrite order_gt1 negbK -order_dvdn os dvdn_exp2l // -ltnS -subSn.\nhave p_s: p.-elt s by rewrite /p_elt os pnatX ?pnat_id.\nhave defS1: 'Ohm_1(<[s]>) = <[s0]>.\n  apply/eqP; rewrite eq_sym eqEcard cycle_subG -orderE os0.\n  rewrite (Ohm1_cyclic_pgroup_prime _ p_s) ?cycle_cyclic ?leqnn ?cycle_eq1 //=.\n    rewrite (OhmE _ p_s) mem_gen ?groupX //= !inE mem_cycle //.\n    by rewrite -order_dvdn os0 ?dvdnn.\n  by apply/eqP=> s1; rewrite -os0 /s0 s1 expg1n order1 in p_gt1.\ncase: (even_prime p_pr) => [p2 | oddp]; last first.\n  rewrite {+}/e0 oddp subn0 in s0 os0 ms0 os ms defS1 *.\n  have [f defF] := cyclicP cycF; have defP: P = <[s]>.\n    apply/eqP; rewrite eq_sym eqEcard -orderE oP os leqnn andbT.\n    by rewrite cycle_subG (mem_normal_Hall sylP) ?pcore_normal.\n  rewrite defP; split; last 1 [by exists s | by exists s0; rewrite ?groupX].\n  rewrite -defPF defP defF -cycleM ?cycle_cyclic // /order.\n    by red; rewrite (centsP cAA) // -cycle_subG -defF pcore_sub.\n  by rewrite -defF -defP (pnat_coprime (pcore_pgroup _ _) (pcore_pgroup _ _)).\nrewrite {+}/e0 p2 subn1 /= in s0 os0 ms0 os ms G4 defS1 lt_e0_n *.\nrewrite G4; exists s; split=> //; last first.\n  exists s0; split; rewrite ?groupX //; apply/eqP; rewrite mM ?groupX //.\n  rewrite ms0 mt eq_sym mulrN1 -subr_eq0 opprK -natrD -addSnnS.\n  by rewrite prednK ?expn_gt0 // addnn -mul2n -expnS -p2 -oG pchar_Zp.\nsuffices TIst: <[s]> :&: <[t]> = 1.\n  rewrite dprodE //; last by rewrite (sub_abelian_cent2 cAA) ?cycle_subG.\n  apply/eqP; rewrite eqEcard mulG_subG !cycle_subG As At oA.\n  by rewrite TI_cardMg // -!orderE os ot p2 mul1n /= -expnSr prednK.\nrewrite setIC; apply: prime_TIg; first by rewrite -orderE ot.\nrewrite cycle_subG; apply/negP=> St.\nhave: t \\in <[s0]>.\n  by rewrite -defS1 (OhmE _ p_s) mem_gen // !inE St -order_dvdn ot p2.\nhave ->: <[s0]> = [set 1; s0].\n  apply/eqP; rewrite eq_sym eqEcard subUset !sub1set group1 cycle_id /=.\n  by rewrite -orderE cards2 eq_sym -order_gt1 os0.\nrewrite !inE -order_eq1 ot /=; move/eqP; move/(congr1 m); move/eqP.\nrewrite mt ms0 eq_sym -subr_eq0 opprK -mulrSr.\nrewrite -val_eqE [val _]val_Zp_nat //= /q oG p2 modn_small //.\nby rewrite -addn3 expnS mul2n -addnn leq_add2l (ltn_exp2l 1).\nQed."
}
{
  "statement": "Theorem quaternion_structure :\n    n > 2 -> extremal_generators G 2 n (x, y) -> G \\isog 'Q_m ->\n  [/\\ [/\\ pprod X Y = G, {in G :\\: X, forall t, #[t] = 4}\n        & {in X & G :\\: X, forall z t, z ^ t = z^-1}],\n      [/\\ G ^`(1) = <[x ^+ 2]>, 'Phi(G) = G ^`(1), #|G^`(1)| = r\n        & nil_class G = n.-1],\n      [/\\ 'Z(G) = <[x ^+ r]>, #|'Z(G)| = 2,\n          forall u, u \\in G -> #[u] = 2 -> u = x ^+ r,\n          'Ohm_1(G) = <[x ^+ r]> /\\ 'Ohm_2(G) = G\n         & forall k, k > 0 -> 'Mho^k(G) = <[x ^+ (2 ^ k)]>],\n      [/\\ yG :|: xyG = G :\\: X /\\ [disjoint yG & xyG]\n        & forall M, maximal M G = pred3 X My Mxy M]\n    & n > 3 ->\n     [/\\ My \\isog 'Q_q, Mxy \\isog 'Q_q\n       & forall U, cyclic U -> U \\subset G -> #|G : U| = 2 -> U = X]].\n",
  "proof": "Proof.\nmove=> n_gt2 genG isoG; have [def2q def2r ltqm ltrq] := def2qr (ltnW n_gt2).\nhave [oG Gx ox X'y] := genG; rewrite -/m -/q -/X in oG ox X'y.\ncase/extremal_generators_facts: genG; rewrite -/X // => pG maxX nsXG defXY nXY.\nhave [sXG nXG]:= andP nsXG; have [Gy notXy]:= setDP X'y.\nhave oxr: #[x ^+ r] = 2 by rewrite orderXdiv ox -def2r ?dvdn_mull ?mulnK.\nhave ox2: #[x ^+ 2] = r by rewrite orderXdiv ox -def2r ?dvdn_mulr ?mulKn.\nhave [[u v] [_ Gu ou U'v] [ov v2 uv]] := generators_quaternion n_gt2 isoG.\nhave defUv: <[u]> :* v = G :\\: <[u]>.\n  apply: rcoset_index2; rewrite -?divgS ?cycle_subG //.\n  by rewrite oG -orderE ou -def2q mulnK.\nhave invUV: {in <[u]> & <[u]> :* v, forall z t, z ^ t = z^-1}.\n  move=> z t; case/cycleP=> i ->; case/rcosetP=> ?; case/cycleP=> j -> ->{z t}.\n  by rewrite conjgM {2}/conjg commuteX2 // mulKg conjXg uv expgVn.\nhave U'2: {in <[u]> :* v, forall t, t ^+ 2 = u ^+ r}.\n  move=> t; case/rcosetP=> z Uz ->; rewrite expgS {1}(conjgC z) -mulgA.\n  by rewrite invUV ?rcoset_refl // mulKg -(expgS v 1) v2.\nhave our: #[u ^+ r] = 2 by rewrite orderXdiv ou -/q -def2r ?dvdn_mull ?mulnK.\nhave def_ur: {in G, forall t, #[t] = 2 -> t = u ^+ r}.\n  move=> t Gt /= ot; case Ut: (t \\in <[u]>); last first.\n    move/eqP: ot; rewrite eqn_dvd order_dvdn -order_eq1 U'2 ?our //.\n    by rewrite defUv inE Ut.\n  have p2u: 2.-elt u by rewrite /p_elt ou pnatX.\n  have: t \\in 'Ohm_1(<[u]>).\n    by rewrite (OhmE _ p2u) mem_gen // !inE Ut -order_dvdn ot.\n  rewrite (Ohm_p_cycle _ p2u) ou pfactorK // subn1 -/r cycle_traject our !inE.\n  by rewrite -order_eq1 ot /= mulg1; move/eqP.\nhave defU: n > 3 -> {in G, forall z, #[z] = q -> <[z]> = <[u]>}.\n  move=> n_gt3 z Gz oz; apply/eqP; rewrite eqEcard -!orderE oz cycle_subG.\n  rewrite ou leqnn andbT; apply: contraLR n_gt3 => notUz.\n  rewrite -(ltn_predK n_gt2) ltnS -(@ltn_exp2l 2) // -/q -oz.\n  by rewrite (@orderXprime _ 2 2) // U'2 // defUv inE notUz.\nhave def_xr: x ^+ r = u ^+ r by apply: def_ur; rewrite ?groupX.\nhave X'2: {in G :\\: X, forall t, t ^+ 2 = u ^+ r}.\n  case: (ltngtP n 3) => [|n_gt3|n3 t]; first by rewrite ltnNge n_gt2.\n    by rewrite /X defU // -defUv.\n  case/setDP=> Gt notXt.\n  case Ut: (t \\in <[u]>); last by rewrite U'2 // defUv inE Ut.\n  rewrite [t ^+ 2]def_ur ?groupX //.\n  have:= order_dvdG Ut; rewrite -orderE ou /q n3 dvdn_divisors ?inE //=.\n  rewrite order_eq1 (negbTE (group1_contra notXt)) /=.\n  case/pred2P=> oz; last by rewrite orderXdiv oz.\n  by rewrite [t]def_ur // -def_xr mem_cycle in notXt.\nhave oX': {in G :\\: X, forall z, #[z] = 4}.\n  by move=> t X't /=; rewrite (@orderXprime _ 2 2) // X'2.\nhave defZ: 'Z(G) = <[x ^+ r]>.\n  apply/eqP; rewrite eqEcard andbC -orderE oxr -{1}(setIidPr (center_sub G)).\n  rewrite cardG_gt1 /= meet_center_nil ?(pgroup_nil pG) //; last first.\n    by rewrite -cardG_gt1 oG (leq_trans _ ltqm).\n  apply/subsetP=> z; case/setIP=> Gz cGz; have [Gv _]:= setDP U'v.\n  case Uvz: (z \\in <[u]> :* v).\n    move/eqP: (invUV _ _ (cycle_id u) Uvz).\n    rewrite /conjg -(centP cGz) // mulKg eq_sym eq_invg_mul -(order_dvdn _ 2).\n    by rewrite ou pfactor_dvdn // -(subnKC n_gt2).\n  move/idPn: Uvz; rewrite defUv inE Gz andbT negbK def_xr => Uz.\n  have p_u: 2.-elt u := mem_p_elt pG Gu.\n  suff: z \\in 'Ohm_1(<[u]>) by rewrite (Ohm_p_cycle 1 p_u) ou pfactorK // subn1.\n  rewrite (OhmE _ p_u) mem_gen // !inE Uz /= -eq_invg_mul.\n  by rewrite -(invUV _ v) ?rcoset_refl // /conjg (centP cGz) ?mulKg.\nhave{invUV} invXX': {in X & G :\\: X, forall z t, z ^ t = z^-1}.\n  case: (ltngtP n 3) => [|n_gt3|n3 t z Xt]; first by rewrite ltnNge n_gt2.\n    by rewrite /X defU // -defUv.\n  case/setDP=> Gz notXz; rewrite /q /r n3 /= in oxr ox.\n  suff xz: x ^ z = x^-1 by case/cycleP: Xt => i ->; rewrite conjXg xz expgVn.\n  have: x ^ z \\in X by rewrite memJ_norm ?cycle_id ?(subsetP nXG).\n  rewrite invg_expg /X cycle_traject ox !inE /= !mulg1 -order_eq1 orderJ ox /=.\n  case/or3P; move/eqP=> //; last by move/(congr1 order); rewrite orderJ ox oxr.\n  move/conjg_fixP; rewrite (sameP commgP cent1P) cent1C -cent_cycle -/X => cXz.\n  have defXz: X * <[z]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  have: z \\in 'Z(G) by rewrite inE Gz -defXz centM inE cXz cent_cycle cent1id.\n  by rewrite defZ => Xr_z; rewrite (subsetP (cycleX x r)) in notXz.\nhave nXiG k: G \\subset 'N(<[x ^+ k]>).\n  apply: char_norm_trans nXG.\n  by rewrite cycle_subgroup_char // cycle_subG mem_cycle.\nhave memL i: x ^+ (2 ^ i) \\in 'L_i.+1(G).\n  elim: i => // i IHi; rewrite -groupV expnSr expgM invMg.\n  by rewrite -{2}(invXX' _ y) ?mem_cycle ?cycle_id ?mem_commg.\nhave defG': G^`(1) = <[x ^+ 2]>.\n  apply/eqP; rewrite eqEsubset cycle_subG (memL 1%N) ?der1_min //=.\n  rewrite (p2group_abelian (quotient_pgroup _ pG)) ?card_quotient //=.\n  rewrite -divgS ?cycle_subG ?groupX // oG -orderE ox2.\n  by rewrite -def2q -def2r mulnA mulnK.\nhave defG1: 'Mho^1(G) = <[x ^+ 2]>.\n  apply/eqP; rewrite (MhoE _ pG) eqEsubset !gen_subG sub1set andbC.\n  rewrite mem_gen; last exact: imset_f.\n  apply/subsetP=> z2; case/imsetP=> z Gz ->{z2}.\n  case Xz: (z \\in X).\n    by case/cycleP: Xz => i ->; rewrite -expgM mulnC expgM mem_cycle.\n  rewrite (X'2 z) ?inE ?Xz // -def_xr.\n  by rewrite /r -(subnKC n_gt2) expnS expgM mem_cycle.\nhave defPhi: 'Phi(G) = <[x ^+ 2]>.\n  by rewrite (Phi_joing pG) defG' defG1 (joing_idPl _).\nhave def_tG: {in G :\\: X, forall t, t ^: G = <[x ^+ 2]> :* t}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  have defJt: {in X, forall z, t ^ z = z ^- 2 * t}.\n    move=> z Xz; rewrite /= invMg -mulgA (conjgC _ t).\n    by rewrite (invXX' _ t) ?groupV ?invgK.\n  have defGt: X * <[t]> = G by rewrite (mulg_normal_maximal nsXG) ?cycle_subG.\n  apply/setP=> tz; apply/imsetP/rcosetP=> [[t'z] | [z]].\n    rewrite -defGt -normC ?cycle_subG ?(subsetP nXG) //.\n    case/imset2P=> t' z; case/cycleP=> j -> Xz -> -> {tz t'z t'}.\n    exists (z ^- 2); last by rewrite conjgM {2}/conjg commuteX // mulKg defJt.\n    case/cycleP: Xz => i ->{z}.\n    by rewrite groupV -expgM mulnC expgM mem_cycle.\n  case/cycleP=> i -> -> {z tz}; exists (x ^- i); first by rewrite groupV groupX.\n  by rewrite defJt ?groupV ?mem_cycle // expgVn invgK -!expgM mulnC.\nhave defMt: {in G :\\: X, forall t, <[x ^+ 2]> <*> <[t]> = <<t ^: G>>}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  apply/eqP; have: t \\in <<t ^: G>> by rewrite mem_gen ?class_refl.\n  rewrite def_tG // eqEsubset join_subG !cycle_subG !gen_subG => tGt.\n  rewrite tGt -(groupMr _ tGt) mem_gen ?mem_mulg ?cycle_id ?set11 //=.\n  by rewrite mul_subG ?joing_subl // -gen_subG joing_subr.\nhave sMtG: {in G :\\: X, forall t, <<t ^: G>> \\subset G}.\n  by move=> t; case/setDP=> Gt _; rewrite gen_subG class_subG.\nhave oMt: {in G :\\: X, forall t, #|<<t ^: G>>| = q}.\n  move=> t X't; have [Gt notXt] := setDP X't.\n  rewrite -defMt // -(Lagrange (joing_subl _ _)) -orderE ox2 -def2r mulnC.\n  congr (_ * r)%N; rewrite -card_quotient /=; last first.\n    by rewrite defMt // (subset_trans _ (nXiG 2)) ?sMtG.\n  rewrite joingC quotientYidr ?(subset_trans _ (nXiG 2)) ?cycle_subG //.\n  rewrite quotient_cycle ?(subsetP (nXiG 2)) //= -defPhi.\n  rewrite -orderE (abelem_order_p (Phi_quotient_abelem pG)) ?mem_quotient //.\n  apply: contraNneq notXt; move/coset_idr; move/implyP=> /=.\n  by rewrite defPhi ?(subsetP (nXiG 2)) //; apply: subsetP; apply: cycleX.\nhave maxMt: {in G :\\: X, forall t, maximal <<t ^: G>> G}.\n  move=> t X't; rewrite /= p_index_maximal -?divgS ?sMtG ?oMt //.\n  by rewrite oG -def2q mulnK.\nhave X'xy: x * y \\in G :\\: X by rewrite !inE !groupMl ?cycle_id ?notXy.\nhave ti_yG_xyG: [disjoint yG & xyG].\n  apply/pred0P=> t; rewrite /= /yG /xyG !def_tG //; apply/andP=> [[yGt]].\n  rewrite rcoset_sym (rcoset_eqP yGt) mem_rcoset mulgK; move/order_dvdG.\n  by rewrite -orderE ox2 ox gtnNdvd.\nhave s_tG_X': {in G :\\: X, forall t, t ^: G \\subset G :\\: X}.\n  by move=> t X't /=; rewrite class_sub_norm // normsD ?normG.\nhave defX': yG :|: xyG = G :\\: X.\n  apply/eqP; rewrite eqEcard subUset !s_tG_X' //= -(leq_add2l q) -{1}ox orderE.\n  rewrite -/X -{1}(setIidPr sXG) cardsID oG -def2q mul2n -addnn leq_add2l.\n  rewrite -(leq_add2r #|yG :&: xyG|) cardsUI disjoint_setI0 // cards0 addn0.\n  by rewrite /yG /xyG !def_tG // !card_rcoset addnn -mul2n -orderE ox2 def2r.\nrewrite pprodE //; split=> // [|||n_gt3].\n- rewrite defG'; split=> //; apply/eqP; rewrite eqn_leq.\n  rewrite (leq_trans (nil_class_pgroup pG)); last first.\n    by rewrite oG pfactorK // -(subnKC n_gt2).\n  rewrite -(subnKC (ltnW n_gt2)) subn2 ltnNge.\n  rewrite (sameP (lcn_nil_classP _ (pgroup_nil pG)) eqP).\n  by apply/trivgPn; exists (x ^+ r); rewrite ?memL // -order_gt1 oxr.\n- rewrite {2}def_xr defZ; split=> //; last exact: extend_cyclic_Mho.\n  split; apply/eqP; last first.\n    have sX'G2: {subset G :\\: X <= 'Ohm_2(G)}.\n      move=> z X'z; have [Gz _] := setDP X'z.\n      by rewrite (OhmE 2 pG) mem_gen // !inE Gz -order_dvdn oX'.\n    rewrite eqEsubset Ohm_sub -{1}defXY mulG_subG !cycle_subG.\n    by rewrite -(groupMr _ (sX'G2 y X'y)) !sX'G2.\n  rewrite eqEsubset (OhmE 1 pG) cycle_subG gen_subG andbC.\n  rewrite mem_gen ?inE ?groupX -?order_dvdn ?oxr //=.\n  apply/subsetP=> t; case/setIP=> Gt; rewrite inE -order_dvdn /=.\n  rewrite dvdn_divisors ?inE //= order_eq1.\n  case/pred2P=> [->|]; first exact: group1.\n  by move/def_ur=> -> //; rewrite def_xr cycle_id.\n- split=> //= H; apply/idP/idP=> [maxH |]; last first.\n    by case/or3P=> /eqP->; rewrite ?maxMt.\n  have [sHG nHG]:= andP (p_maximal_normal pG maxH).\n  have oH: #|H| = q.\n    apply: double_inj; rewrite -muln2 -(p_maximal_index pG maxH) Lagrange //.\n    by rewrite oG -mul2n.\n  rewrite !(eq_sym (gval H)) -eq_sym !eqEcard oH -orderE ox !oMt // !leqnn.\n  case sHX: (H \\subset X) => //=; case/subsetPn: sHX => z Hz notXz.\n  have: z \\in yG :|: xyG by rewrite defX' inE notXz (subsetP sHG).\n  rewrite !andbT !gen_subG /yG /xyG.\n  by case/setUP=> /class_eqP <-; rewrite !class_sub_norm ?Hz ?orbT.\nhave isoMt: {in G :\\: X, forall z, <<z ^: G>> \\isog 'Q_q}.\n  have n1_gt2: n.-1 > 2 by rewrite -(subnKC n_gt3).\n  move=> z X'z /=; rewrite isogEcard card_quaternion ?oMt // leqnn andbT.\n  rewrite Grp_quaternion //; apply/existsP; exists (x ^+ 2, z) => /=.\n  rewrite defMt // -/q -/r !xpair_eqE -!expgM def2r -order_dvdn ox dvdnn.\n  rewrite -expnS prednK; last by rewrite -subn2 subn_gt0.\n  by rewrite X'2 // def_xr !eqxx /= invXX' ?mem_cycle.\nrewrite !isoMt //; split=> // C; case/cyclicP=> z ->{C} sCG iCG.\nrewrite [X]defU // defU -?cycle_subG //.\nby apply: double_inj; rewrite -muln2 -iCG Lagrange // oG -mul2n.\nQed."
}
{
  "statement": "Theorem symplectic_type_group_structure gT p (G : {group gT}) :\n    p.-group G -> (forall X : {group gT}, X \\char G -> abelian X -> cyclic X) ->\n  exists2 E : {group gT}, E :=: 1 \\/ extraspecial E\n  & exists R : {group gT},\n    [/\\ cyclic R \\/ [/\\ p = 2, extremal2 R & #|R| >= 16],\n        E \\* R = G\n      & E :&: R = 'Z(E)].\n",
  "proof": "Proof.\nmove=> pG sympG; have [H [charH]] := Thompson_critical pG.\nhave sHG := char_sub charH; have pH := pgroupS sHG pG.\nset U := 'Z(H) => sPhiH_U sHG_U defU; set Z := 'Ohm_1(U).\nhave sZU: Z \\subset U by rewrite Ohm_sub.\nhave charU: U \\char G := gFchar_trans _ charH.\nhave cUU: abelian U := center_abelian H.\nhave cycU: cyclic U by apply: sympG.\nhave pU: p.-group U := pgroupS (char_sub charU) pG.\nhave cHU: U \\subset 'C(H) by rewrite subsetIr.\nhave cHsHs: abelian (H / Z).\n  rewrite sub_der1_abelian //= (OhmE _ pU) genS //= -/U.\n  apply/subsetP=> _ /imset2P[h k Hh Hk ->].\n  have Uhk: [~ h, k] \\in U by rewrite (subsetP sHG_U) ?mem_commg ?(subsetP sHG).\n  rewrite inE Uhk inE -commXg; last by red; rewrite -(centsP cHU).\n  apply/commgP; red; rewrite (centsP cHU) // (subsetP sPhiH_U) //.\n  by rewrite (Phi_joing pH) mem_gen // inE orbC (Mho_p_elt 1) ?(mem_p_elt pH).\nhave nsZH: Z <| H by rewrite sub_center_normal.\nhave [K /=] := inv_quotientS nsZH (Ohm_sub 1 (H / Z)); fold Z => defKs sZK sKH.\nhave nsZK: Z <| K := normalS sZK sKH nsZH; have [_ nZK] := andP nsZK.\nhave abelKs: p.-abelem (K / Z) by rewrite -defKs Ohm1_abelem ?quotient_pgroup.\nhave charK: K \\char G.\n  have charZ: Z \\char H := gFchar_trans _ (center_char H).\n  rewrite (char_trans _ charH) // (char_from_quotient nsZK) //.\n  by rewrite -defKs Ohm_char.\nhave cycZK: cyclic 'Z(K) by rewrite sympG ?center_abelian ?gFchar_trans.\nhave [cKK | not_cKK] := orP (orbN (abelian K)).\n  have defH: U = H.\n    apply: center_idP; apply: cyclic_factor_abelian (Ohm_sub 1 _) _.\n    rewrite /= -/Z abelian_rank1_cyclic //.\n    have cKsKs: abelian (K / Z) by rewrite -defKs (abelianS (Ohm_sub 1 _)).\n    have cycK: cyclic K by rewrite -(center_idP cKK).\n    by rewrite -rank_Ohm1 defKs -abelian_rank1_cyclic ?quotient_cyclic.\n  have scH: H \\in 'SCN(G) by apply/SCN_P; rewrite defU char_normal.\n  have [cGG | not_cGG] := orP (orbN (abelian G)).\n    exists 1%G; [by left | exists G; rewrite cprod1g (setIidPl _) ?sub1G //].\n    by split; first left; rewrite ?center1 // sympG ?char_refl.\n  have cycH: cyclic H by rewrite -{}defH.\n  have [[p2 _ cG2]|[M [_ _ _]]] := cyclic_SCN pG scH not_cGG cycH; last first.\n    do 2![case/setIdP] => _ abelE dimE_2 charE.\n    have:= sympG _ charE (abelem_abelian abelE).\n    by rewrite (abelem_cyclic abelE) (eqP dimE_2).\n  have [n oG] := p_natP pG; rewrite p2 in oG.\n  have [n_gt3 | n_le3] := ltnP 3 n.\n    exists 1%G; [by left | exists G; rewrite cprod1g (setIidPl _) ?sub1G //].\n    by split; first right; rewrite ?center1 // oG (@leq_exp2l 2 4).\n  have esG: extraspecial G.\n    by apply: (p3group_extraspecial pG); rewrite // p2 oG pfactorK.\n  exists G; [by right | exists ('Z(G))%G; rewrite cprod_center_id setIA setIid].\n  by split=> //; left; rewrite prime_cyclic; case: esG.\nhave ntK: K :!=: 1 by apply: contra not_cKK => /eqP->; apply: abelian1.\nhave [p_pr _ _] := pgroup_pdiv (pgroupS sKH pH) ntK.\nhave p_gt1 := prime_gt1 p_pr; have p_gt0 := ltnW p_gt1.\nhave oZ: #|Z| = p.\n  apply: Ohm1_cyclic_pgroup_prime => //=; apply: contra ntK; move/eqP.\n  by move/(trivg_center_pgroup pH)=> GH; rewrite -subG1 -GH.\nhave sZ_ZK: Z \\subset 'Z(K).\n  by rewrite subsetI sZK gFsub_trans // subIset ?centS ?orbT.\nhave sZsKs: 'Z(K) / Z \\subset K / Z by rewrite quotientS ?center_sub.\nhave [Es /= splitKs] := abelem_split_dprod abelKs sZsKs.\nhave [_ /= defEsZs cEsZs tiEsZs] := dprodP splitKs.\nhave sEsKs: Es \\subset K / Z by rewrite -defEsZs mulG_subr.\nhave [E defEs sZE sEK] := inv_quotientS nsZK sEsKs; rewrite /= -/Z in defEs sZE.\nhave [nZE nZ_ZK] := (subset_trans sEK nZK, subset_trans (center_sub K) nZK).\nhave defK: 'Z(K) * E = K.\n  rewrite -(mulSGid sZ_ZK) -mulgA -quotientK ?mul_subG ?quotientMl //.\n  by rewrite -defEs defEsZs quotientGK.\nhave defZE: 'Z(E) = Z.\n  have cEZK: 'Z(K) \\subset 'C(E) by rewrite subIset // orbC centS.\n  have cE_Z: E \\subset 'C(Z) by rewrite centsC (subset_trans sZ_ZK).\n  apply/eqP; rewrite eqEsubset andbC subsetI sZE centsC cE_Z /=.\n  rewrite -quotient_sub1 ?subIset ?nZE //= -/Z -tiEsZs subsetI defEs.\n  rewrite !quotientS ?center_sub //= subsetI subIset ?sEK //=.\n  by rewrite -defK centM setSI // centsC.\nhave sEH := subset_trans sEK sKH; have pE := pgroupS sEH pH.\nhave esE: extraspecial E.\n  split; last by rewrite defZE oZ.\n  have sPhiZ: 'Phi(E) \\subset Z.\n    rewrite -quotient_sub1 ?gFsub_trans ?(quotient_Phi pE) //.\n    rewrite subG1 (trivg_Phi (quotient_pgroup _ pE)) /= -defEs.\n    by rewrite (abelemS sEsKs) //= -defKs Ohm1_abelem ?quotient_pgroup.\n  have sE'Phi: E^`(1) \\subset 'Phi(E) by rewrite (Phi_joing pE) joing_subl.\n  have ntE': E^`(1) != 1.\n    rewrite (sameP eqP commG1P) -abelianE; apply: contra not_cKK => cEE.\n    by rewrite -defK mulGSid ?center_abelian // -(center_idP cEE) defZE.\n  have defE': E^`(1) = Z.\n    apply/eqP; rewrite eqEcard (subset_trans sE'Phi) //= oZ.\n    have [_ _ [n ->]] := pgroup_pdiv (pgroupS (der_sub _ _) pE) ntE'.\n    by rewrite (leq_exp2l 1) ?prime_gt1.\n  by split; rewrite defZE //; apply/eqP; rewrite eqEsubset sPhiZ -defE'.\nhave [spE _] := esE; have [defPhiE defE'] := spE.\nhave{defE'} sEG_E': [~: E, G] \\subset E^`(1).\n  rewrite defE' defZE /Z (OhmE _ pU) commGC genS //.\n  apply/subsetP=> _ /imset2P[g e Gg Ee ->].\n  have He: e \\in H by rewrite (subsetP sKH) ?(subsetP sEK).\n  have Uge: [~ g, e] \\in U by rewrite (subsetP sHG_U) ?mem_commg.\n  rewrite inE Uge inE -commgX; last by red; rewrite -(centsP cHU).\n  have sZ_ZG: Z \\subset 'Z(G).\n    have charZ: Z \\char G := gFchar_trans _ charU.\n    have/implyP:= meet_center_nil (pgroup_nil pG) (char_normal charZ).\n    rewrite -cardG_gt1 oZ prime_gt1 //=; apply: contraR => not_sZ_ZG.\n    by rewrite prime_TIg ?oZ.\n  have: e ^+ p \\in 'Z(G).\n    rewrite (subsetP sZ_ZG) // -defZE -defPhiE (Phi_joing pE) mem_gen //.\n    by rewrite inE orbC (Mho_p_elt 1) ?(mem_p_elt pE).\n  by case/setIP=> _ /centP cGep; apply/commgP; red; rewrite cGep.\nhave sEG: E \\subset G := subset_trans sEK (char_sub charK).\nset R := 'C_G(E).\nhave{sEG_E'} defG: E \\* R = G by apply: (critical_extraspecial pG).\nhave [_ defER cRE] := cprodP defG.\nhave defH: E \\* 'C_H(E) = H by rewrite -(setIidPr sHG) setIAC (cprod_modl defG).\nhave{defH} [_ defH cRH_E] := cprodP defH.\nhave cRH_RH: abelian 'C_H(E).\n  have sZ_ZRH: Z \\subset 'Z('C_H(E)).\n    rewrite subsetI -{1}defZE setSI //= (subset_trans sZU) // centsC.\n    by rewrite subIset // centsC cHU.\n  rewrite (cyclic_factor_abelian sZ_ZRH) //= -/Z.\n  have defHs: Es \\x ('C_H(E) / Z) = H / Z.\n    rewrite defEs dprodE ?quotient_cents // -?quotientMl ?defH -?quotientGI //=.\n    by rewrite setIA (setIidPl sEH) ['C_E(E)]defZE trivg_quotient.\n  have:= Ohm_dprod 1 defHs; rewrite /= defKs (Ohm1_id (abelemS sEsKs abelKs)).\n  rewrite dprodC; case/dprodP=> _ defEsRHs1 cRHs1Es tiRHs1Es.\n  have sRHsHs: 'C_H(E) / Z \\subset H / Z by rewrite quotientS ?subsetIl.\n  have cRHsRHs: abelian ('C_H(E) / Z) by apply: abelianS cHsHs.\n  have pHs: p.-group (H / Z) by rewrite quotient_pgroup.\n  rewrite abelian_rank1_cyclic // (rank_pgroup (pgroupS sRHsHs pHs)).\n  rewrite p_rank_abelian // -(leq_add2r (logn p #|Es|)) -lognM ?cardG_gt0 //.\n  rewrite -TI_cardMg // defEsRHs1 /= -defEsZs TI_cardMg ?lognM ?cardG_gt0 //.\n  by rewrite leq_add2r -abelem_cyclic ?(abelemS sZsKs) // quotient_cyclic.\nhave{cRH_RH} defRH: 'C_H(E) = U.\n  apply/eqP; rewrite eqEsubset andbC setIS ?centS // subsetI subsetIl /=.\n  by rewrite -{2}defH centM subsetI subsetIr.\nhave scUR: 'C_R(U) = U by rewrite -setIA -{1}defRH -centM defH.\nhave sUR: U \\subset R by rewrite -defRH setSI.\nhave tiER: E :&: R = 'Z(E) by rewrite setIA (setIidPl (subset_trans sEH sHG)).\nhave [cRR | not_cRR] := boolP (abelian R).\n  exists E; [by right | exists [group of R]; split=> //; left].\n  by rewrite /= -(setIidPl (sub_abelian_cent cRR sUR)) scUR.\nhave{} scUR: [group of U] \\in 'SCN(R).\n  by apply/SCN_P; rewrite (normalS sUR (subsetIl _ _)) // char_normal.\nhave pR: p.-group R := pgroupS (subsetIl _ _) pG.\nhave [R_le_3 | R_gt_3] := leqP (logn p #|R|) 3.\n  have esR: extraspecial R := p3group_extraspecial pR not_cRR R_le_3.\n  have esG: extraspecial G := cprod_extraspecial pG defG tiER esE esR.\n  exists G; [by right | exists ('Z(G))%G; rewrite cprod_center_id setIA setIid].\n  by split=> //; left; rewrite prime_cyclic; case: esG.\nhave [[p2 _ ext2R] | [M []]] := cyclic_SCN pR scUR not_cRR cycU.\n  exists E; [by right | exists [group of R]; split=> //; right].\n  by rewrite dvdn_leq ?(@pfactor_dvdn 2 4) ?cardG_gt0 // -{2}p2.\nrewrite /= -/R => defM iUM modM _ _; pose N := 'C_G('Mho^1(U)).\nhave charZN2: 'Z('Ohm_2(N)) \\char G by rewrite !(gFchar_trans, subcent_char).\nhave:= sympG _ charZN2 (center_abelian _).\nrewrite abelian_rank1_cyclic ?center_abelian // leqNgt; case/negP.\nhave defN: E \\* M = N.\n  rewrite defM (cprod_modl defG) // centsC gFsub_trans //= -/U.\n  by rewrite -defRH subsetIr.\ncase/modular_group_classP: modM => q q_pr [n n_gt23 isoM].\nhave{n_gt23} n_gt2 := leq_trans (leq_addl _ _) n_gt23.\nhave n_gt1 := ltnW n_gt2; have n_gt0 := ltnW n_gt1.\nhave [[x y] genM modM] := generators_modular_group q_pr n_gt2 isoM.\nhave{q_pr} defq: q = p; last rewrite {q}defq in genM modM isoM.\n  have: p %| #|M| by rewrite -iUM dvdn_indexg.\n  by have [-> _ _ _] := genM; rewrite Euclid_dvdX // dvdn_prime2 //; case: eqP.\nhave [oM Mx ox X'y] := genM; have [My _] := setDP X'y; have [oy _] := modM.\nhave [sUM sMR]: U \\subset M /\\ M \\subset R.\n  by rewrite defM subsetI sUR subsetIl centsC gFsub_trans.\nhave oU1: #|'Mho^1(U)| = (p ^ n.-2)%N.\n  have oU: #|U| = (p ^ n.-1)%N.\n    by rewrite -(divg_indexS sUM) iUM oM -subn1 expnB.\n  case/cyclicP: cycU pU oU => u -> p_u ou.\n  by rewrite (Mho_p_cycle 1 p_u) -orderE (orderXexp 1 ou) subn1.\nhave sZU1: Z \\subset 'Mho^1(U).\n  rewrite -(cardSg_cyclic cycU) ?gFsub // oZ oU1.\n  by rewrite -(subnKC n_gt2) expnS dvdn_mulr.\ncase/modular_group_structure: genM => // _ [defZM _ oZM] _ _.\nhave:= n_gt2; rewrite leq_eqVlt eq_sym !xpair_eqE andbC.\ncase: eqP => [n3 _ _ | _ /= n_gt3 defOhmM].\n  have eqZU1: Z = 'Mho^1(U) by apply/eqP; rewrite eqEcard sZU1 oZ oU1 n3 /=.\n  rewrite (setIidPl _) in defM; first by rewrite -defM oM n3 pfactorK in R_gt_3.\n  by rewrite -eqZU1 subIset ?centS ?orbT.\nhave{defOhmM} [|defM2 _] := defOhmM 2; first by rewrite -subn1 ltn_subRL.\ndo [set xpn3 := x ^+ _; set X2 := <[_]>] in defM2.\nhave oX2: #|X2| = (p ^ 2)%N.\n  by rewrite -orderE (orderXexp _ ox) -{1}(subnKC n_gt2) addSn addnK.\nhave sZX2: Z \\subset X2.\n  have cycXp: cyclic <[x ^+ p]> := cycle_cyclic _.\n  rewrite -(cardSg_cyclic cycXp) /=; first by rewrite oZ oX2 dvdn_mull.\n    rewrite -defZM subsetI (subset_trans (Ohm_sub _ _)) //=.\n    by rewrite (subset_trans sZU1) // centsC defM subsetIr.\n  by rewrite /xpn3 -subnSK //expnS expgM cycleX.\nhave{defM2} [_ /= defM2 cYX2 tiX2Y] := dprodP defM2.\nhave{defN} [_ defN cME] := cprodP defN.\nhave cEM2: E \\subset 'C('Ohm_2(M)).\n  by rewrite centsC (subset_trans _ cME) ?centS ?Ohm_sub.\nhave [cEX2 cYE]: X2 \\subset 'C(E) /\\ E \\subset 'C(<[y]>).\n by apply/andP; rewrite centsC -subsetI -centM defM2.\nhave pN: p.-group N := pgroupS (subsetIl _ _) pG.\nhave defN2: (E <*> X2) \\x <[y]> = 'Ohm_2(N).\n  rewrite dprodE ?centY ?subsetI 1?centsC ?cYE //=; last first.\n    rewrite -cycle_subG in My; rewrite joingC cent_joinEl //= -/X2.\n    rewrite -(setIidPr My) setIA -group_modl ?cycle_subG ?groupX //.\n    by rewrite mulGSid // (subset_trans _ sZX2) // -defZE -tiER setIS.\n  apply/eqP; rewrite cent_joinEr // -mulgA defM2 eqEsubset mulG_subG.\n  rewrite OhmS ?andbT; last by rewrite -defN mulG_subr.\n  have expE: exponent E %| p ^ 2 by rewrite exponent_special ?(pgroupS sEG).\n  rewrite /= (OhmE 2 pN) sub_gen /=; last 1 first.\n    by rewrite subsetI -defN mulG_subl sub_LdivT expE.\n  rewrite -cent_joinEl // -genM_join genS // -defN.\n  apply/subsetP=> _ /setIP[/imset2P[e z Ee Mz ->]].\n  rewrite inE expgMn; last by red; rewrite -(centsP cME).\n  rewrite (exponentP expE) // mul1g => zp2; rewrite mem_mulg //=.\n  by rewrite (OhmE 2 (pgroupS sMR pR)) mem_gen // !inE Mz.\nhave{defN2} defZN2: X2 \\x <[y]> = 'Z('Ohm_2(N)).\n  rewrite -[X2](mulSGid sZX2) /= -/Z -defZE -(center_dprod defN2).\n  do 2!rewrite -{1}(center_idP (cycle_abelian _)) -/X2; congr (_ \\x _).\n  by case/cprodP: (center_cprod (cprodEY cEX2)).\nhave{defZN2} strZN2: \\big[dprod/1]_(z <- [:: xpn3; y]) <[z]> = 'Z('Ohm_2(N)).\n  by rewrite unlock /= dprodg1.\nrewrite -size_abelian_type ?center_abelian //.\nhave pZN2: p.-group 'Z('Ohm_2(N)) by rewrite (pgroupS _ pN) // subIset ?Ohm_sub.\nrewrite (perm_size (abelian_type_pgroup pZN2 strZN2 _)) //= !inE.\nrewrite !(eq_sym 1) -!order_eq1 oy orderE oX2.\nby rewrite (eqn_exp2l 2 0) // (eqn_exp2l 1 0).\nQed."
}
{
  "statement": "Theorem Fundamental_Theorem_of_Algebraics :\n  {L : closedFieldType &\n     {conj : {rmorphism L -> L} | involutive conj & ~ conj =1 id}}.\n",
  "proof": "Proof.\nhave maxn3 n1 n2 n3: {m | [/\\ n1 <= m, n2 <= m & n3 <= m]%N}.\n  by exists (maxn n1 (maxn n2 n3)); apply/and3P; rewrite -!geq_max.\nhave [C [/= QtoC algC]] := countable_algebraic_closure rat.\nexists C; have [i Di2] := GRing.imaginary_exists C.\npose Qfield := fieldExtType rat.\npose Cmorph (L : Qfield) := {rmorphism L -> C}.\nhave pcharQ (L : Qfield): [pchar L] =i pred0 := ftrans (pchar_lalg L) (pchar_num _).\nhave sepQ  (L : Qfield) (K E : {subfield L}): separable K E.\n  by apply/separableP=> u _; apply: pcharf0_separable.\npose genQfield z L := {LtoC : Cmorph L & {u | LtoC u = z & <<1; u>> = fullv}}.\nhave /all_tag[Q /all_tag[ofQ genQz]] z: {Qz : Qfield & genQfield z Qz}.\n  have [|p [/monic_neq0 nzp pz0 irr_p]] := minPoly_decidable_closure _ (algC z).\n    exact: rat_algebraic_decidable.\n  pose Qz := SubFieldExtType pz0 irr_p.\n  pose QzC : {rmorphism _ -> _} := @subfx_inj _ _ QtoC z p.\n  exists Qz, QzC, (subfx_root QtoC z p); first exact: subfx_inj_root.\n  apply/vspaceP=> u; rewrite memvf; apply/Fadjoin1_polyP.\n  by have [q] := subfxEroot pz0 nzp u; exists q.\nhave pQof z p: p^@ ^ ofQ z = p ^ QtoC.\n  by rewrite -map_poly_comp; apply: eq_map_poly => x; rewrite !fmorph_eq_rat.\nhave pQof2 z p u: ofQ z p^@.[u] = (p ^ QtoC).[ofQ z u].\n  by rewrite -horner_map pQof.\nhave PET_Qz z (E : {subfield Q z}): {u | <<1; u>> = E}.\n  exists (separable_generator 1 E).\n  by rewrite -eq_adjoin_separable_generator ?sub1v.\npose gen z x := exists q, x = (q ^ QtoC).[z].\nhave PET2 x y: {z | gen z x & gen z y}.\n  pose Gxy := (x, y) = let: (p, q, z) := _ in ((p ^ QtoC).[z], (q ^ QtoC).[z]).\n  suffices [[[p q] z] []]: {w | Gxy w} by exists z; [exists p | exists q].\n  apply/sig_eqW; have /integral_algebraic[px nz_px pxx0] := algC x.\n  have /integral_algebraic[py nz_py pyy0] := algC y.\n  have [n [[p Dx] [q Dy]]] := pchar0_PET nz_px pxx0 nz_py pyy0 (pchar_num _).\n  by exists (p, q, y *+ n - x); congr (_, _).\nhave gen_inQ z x: gen z x -> {u | ofQ z u = x}.\n  have [u Dz _] := genQz z => /sig_eqW[q ->].\n  by exists q^@.[u]; rewrite pQof2 Dz.\nhave gen_ofP z u v: reflect (gen (ofQ z u) (ofQ z v)) (v \\in <<1; u>>).\n  apply: (iffP Fadjoin1_polyP) => [[q ->]|]; first by rewrite pQof2; exists q.\n  by case=> q; rewrite -pQof2 => /fmorph_inj->; exists q.\nhave /all_tag[sQ genP] z: {s : pred C & forall x, reflect (gen z x) (x \\in s)}.\n  apply: all_tag (fun x => reflect (gen z x)) _ => x.\n  have [w /gen_inQ[u <-] /gen_inQ[v <-]] := PET2 z x.\n  by exists (v \\in <<1; u>>)%VS; apply: gen_ofP.\nhave sQtrans: transitive (fun x z => x \\in sQ z).\n  move=> x y z /genP[p ->] /genP[q ->]; apply/genP; exists (p \\Po q).\n  by rewrite map_comp_poly horner_comp.\nhave sQid z: z \\in sQ z by apply/genP; exists 'X; rewrite map_polyX hornerX.\nhave{gen_ofP} sQof2 z u v: (ofQ z u \\in sQ (ofQ z v)) = (u \\in <<1; v>>%VS).\n  exact/genP/(gen_ofP z).\nhave sQof z v: ofQ z v \\in sQ z.\n  by have [u Dz defQz] := genQz z; rewrite -[in sQ z]Dz sQof2 defQz memvf.\nhave{gen_inQ} sQ_inQ z x z_x := gen_inQ z x (genP z x z_x).\nhave /all_sig[inQ inQ_K] z: {inQ | {in sQ z, cancel inQ (ofQ z)}}.\n  by apply: all_sig_cond (fun x u => ofQ z u = x) 0 _ => x /sQ_inQ.\nhave ofQ_K z: cancel (ofQ z) (inQ z).\n  by move=> x; have /inQ_K/fmorph_inj := sQof z x.\nhave sQring z: divring_closed (sQ z).\n  have sQ_1: 1 \\in sQ z by rewrite -(rmorph1 (ofQ z)) sQof.\n  by split=> // x y /inQ_K<- /inQ_K<- /=; rewrite -(rmorphB, fmorph_div) sQof.\npose sQoM z := GRing.isOppClosed.Build _ _ (sQring z).\npose sQaM z := GRing.isAddClosed.Build _ _ (sQring z).\npose sQmM z := GRing.isMulClosed.Build _ _ (sQring z).\npose sQiM z := GRing.isInvClosed.Build _ _ (sQring z).\npose sQC z : divringClosed _ := HB.pack (sQ z)\n  (sQaM z) (sQoM z) (sQmM z) (sQiM z).\npose morph_ofQ x z Qxz := forall u, ofQ z (Qxz u) = ofQ x u.\nhave QtoQ z x: x \\in sQ z -> {Qxz : 'AHom(Q x, Q z) | morph_ofQ x z Qxz}.\n  move=> z_x; pose Qxz u := inQ z (ofQ x u).\n  have QxzE u: ofQ z (Qxz u) = ofQ x u by apply/inQ_K/(sQtrans x).\n  have Qxza : additive Qxz.\n    by move=> u v; apply: (canLR (ofQ_K z)); rewrite !rmorphB !QxzE.\n  have Qxzm : multiplicative Qxz.\n    by split=> [u v|]; apply: (canLR (ofQ_K z));\n      rewrite ?rmorph1 ?rmorphM /= ?QxzE.\n  have QxzaM := GRing.isAdditive.Build _ _ _ Qxza.\n  have QxzmM := GRing.isMultiplicative.Build _ _ _ Qxzm.\n  have QxzlM := GRing.isScalable.Build _ _ _ _ _ (rat_linear Qxza).\n  pose QxzLRM : {lrmorphism _ -> _} := HB.pack Qxz QxzaM QxzmM QxzlM.\n  by exists (linfun_ahom QxzLRM) => u; rewrite lfunE QxzE.\npose sQs z s := all (mem (sQ z)) s.\nhave inQsK z s: sQs z s -> map (ofQ z) (map (inQ z) s) = s.\n  by rewrite -map_comp => /allP/(_ _ _)/inQ_K; apply: map_id_in.\nhave inQpK z p: p \\is a polyOver (sQ z) -> (p ^ inQ z) ^ ofQ z = p.\n  by move=> /allP/(_ _ _)/inQ_K/=/map_poly_id; rewrite -map_poly_comp.\nhave{gen PET2 genP} PET s: {z | sQs z s & <<1 & map (inQ z) s>>%VS = fullv}.\n  have [y /inQsK Ds]: {y | sQs y s}.\n    elim: s => [|x s /= [y IHs]]; first by exists 0.\n    have [z /genP z_x /genP z_y] := PET2 x y.\n    by exists z; rewrite /= {x}z_x; apply: sub_all IHs => x /sQtrans/= ->.\n  have [w defQs] := PET_Qz _ <<1 & map (inQ y) s>>%AS; pose z := ofQ y w.\n  have z_s: sQs z s.\n    rewrite -Ds /sQs all_map; apply/allP=> u s_u /=.\n    by rewrite sQof2 defQs seqv_sub_adjoin.\n  have [[u Dz defQz] [Qzy QzyE]] := (genQz z, QtoQ y z (sQof y w)).\n  exists z => //; apply/eqP; rewrite eqEsubv subvf /= -defQz.\n  rewrite -(limg_ker0 _ _ (AHom_lker0 Qzy)) aimg_adjoin_seq aimg_adjoin aimg1.\n  rewrite -[map _ _](mapK (ofQ_K y)) -(map_comp (ofQ y)) (eq_map QzyE) inQsK //.\n  by rewrite -defQs -(canLR (ofQ_K y) Dz) -QzyE ofQ_K.\npose rp s := \\prod_(z <- s) ('X - z%:P).\nhave map_rp (f : {rmorphism _ -> _}) s: rp _ s ^ f = rp _ (map f s).\n  rewrite rmorph_prod /rp big_map; apply: eq_bigr => x _ /=.\n  by rewrite rmorphB /= map_polyX map_polyC.\npose is_Gal z := SplittingField.axiom (Q z).\nhave galQ x: {z | x \\in sQ z & is_Gal z}.\n  have /sig2W[p mon_p pz0] := algC x.\n  have [s Dp] := closed_field_poly_normal (p ^ QtoC).\n  rewrite (monicP _) ?monic_map // scale1r in Dp; have [z z_s defQz] := PET s.\n  exists z; first by apply/(allP z_s); rewrite -root_prod_XsubC -Dp.\n  exists p^@; first exact: alg_polyOver.\n  exists (map (inQ z) s); last by apply/vspaceP=> u; rewrite defQz memvf.\n  by rewrite -(eqp_map (ofQ z)) pQof Dp map_rp inQsK ?eqpxx.\npose is_realC x := {R : archiRealFieldType & {rmorphism Q x -> R}}.\npose realC := {x : C & is_realC x}.\npose has_Rroot (xR : realC) p c (Rx := sQ (tag xR)) :=\n  [&& p \\is a polyOver Rx, p \\is monic, c \\in Rx & p.[0] == - c ^+ 2].\npose root_in (xR : realC) p := exists2 w, w \\in sQ (tag xR) & root p w.\npose extendsR (xR yR : realC) := tag xR \\in sQ (tag yR).\nhave add_Rroot xR p c: {yR | extendsR xR yR & has_Rroot xR p c -> root_in yR p}.\n  rewrite {}/extendsR; case: (has_Rroot xR p c) / and4P; last by exists xR.\n  case: xR => x [R QxR] /= [/inQpK <-]; move: (p ^ _) => {}p mon_p /inQ_K<- Dc.\n  have{c Dc} p0_le0: (p ^ QxR).[0] <= 0.\n    rewrite horner_coef0 coef_map -[p`_0]ofQ_K -coef_map -horner_coef0 (eqP Dc).\n    by rewrite -rmorphXn -rmorphN ofQ_K /= rmorphN rmorphXn oppr_le0 sqr_ge0.\n  have [s Dp] := closed_field_poly_normal (p ^ ofQ x).\n  have{Dp} /all_and2[s_p p_s] y: root (p ^ ofQ x) y <-> (y \\in s).\n    by rewrite Dp (monicP mon_p) scale1r root_prod_XsubC.\n  rewrite map_monic in mon_p; have [z /andP[z_x /allP/=z_s] _] := PET (x :: s).\n  have{z_x} [[Qxz QxzE] Dx] := (QtoQ z x z_x, inQ_K z x z_x).\n  pose Qx := <<1; inQ z x>>%AS.\n  have pQwx q1: q1 \\is a polyOver Qx -> {q | q1 = q ^ Qxz}.\n    move/polyOverP=> Qx_q1; exists ((q1 ^ ofQ z) ^ inQ x).\n    apply: (map_poly_inj (ofQ z)); rewrite -map_poly_comp (eq_map_poly QxzE).\n    by rewrite inQpK ?polyOver_poly // => j _; rewrite -Dx sQof2 Qx_q1.\n  have /all_sig[t_ Dt] u: {t | <<1; t>> = <<Qx; u>>} by apply: PET_Qz.\n  suffices{p_s}[u Ry px0]: {u : Q z & is_realC (ofQ z (t_ u)) & ofQ z u \\in s}.\n    exists (Tagged is_realC Ry) => [|_] /=.\n      by rewrite -Dx sQof2 Dt subvP_adjoin ?memv_adjoin.\n    by exists (ofQ z u); rewrite ?p_s // sQof2 Dt memv_adjoin.\n  without loss{z_s s_p} [u Dp s_y]: p mon_p p0_le0 /\n    {u | minPoly Qx u = p ^ Qxz & ofQ z u \\in s}.\n  - move=> IHp; move: {2}_.+1 (ltnSn (size p)) => d.\n    elim: d => // d IHd in p mon_p s_p p0_le0 *; rewrite ltnS => le_p_d.\n    have /closed_rootP/sig_eqW[y py0]: size (p ^ ofQ x) != 1.\n      rewrite size_map_poly size_poly_eq1 eqp_monic ?rpred1 //.\n      by apply: contraTneq p0_le0 => ->; rewrite rmorph1 hornerC lt_geF ?ltr01.\n    have /s_p s_y := py0; have /z_s/sQ_inQ[u Dy] := s_y.\n    have /pQwx[q Dq] := minPolyOver Qx u.\n    have mon_q: q \\is monic by have:= monic_minPoly Qx u; rewrite Dq map_monic.\n    have /dvdpP/sig_eqW[r Dp]: q %| p.\n      rewrite -(dvdp_map Qxz) -Dq minPoly_dvdp //.\n        by apply: polyOver_poly => j _; rewrite -sQof2 QxzE Dx.\n      by rewrite -(fmorph_root (ofQ z)) Dy -map_poly_comp (eq_map_poly QxzE).\n    have mon_r: r \\is monic by rewrite Dp monicMr in mon_p.\n    have [q0_le0 | q0_gt0] := lerP ((q ^ QxR).[0]) 0.\n      by apply: (IHp q) => //; exists u; rewrite ?Dy.\n    have r0_le0: (r ^ QxR).[0] <= 0.\n      by rewrite -(ler_pM2r q0_gt0) mul0r -hornerM -rmorphM -Dp.\n    apply: (IHd r mon_r) => // [w rw0|].\n      by rewrite s_p // Dp rmorphM rootM rw0.\n    apply: leq_trans le_p_d; rewrite Dp size_Mmonic ?monic_neq0 // addnC.\n    by rewrite -(size_map_poly Qxz q) -Dq size_minPoly !ltnS leq_addl.\n  exists u => {s s_y}//; set y := ofQ z (t_ u); set p1 := minPoly Qx u in Dp.\n  have /QtoQ[Qyz QyzE]: y \\in sQ z := sQof z (t_ u).\n  pose q1_ v := Fadjoin_poly Qx u (Qyz v).\n  have{} QyzE v: Qyz v = (q1_ v).[u].\n    by rewrite Fadjoin_poly_eq // -Dt -sQof2 QyzE sQof.\n  have /all_sig2[q_ coqp Dq] v: {q | v != 0 -> coprimep p q & q ^ Qxz = q1_ v}.\n    have /pQwx[q Dq]: q1_ v \\is a polyOver Qx by apply: Fadjoin_polyOver.\n    exists q => // nz_v; rewrite -(coprimep_map Qxz) -Dp -Dq -gcdp_eqp1.\n    have /minPoly_irr/orP[] // := dvdp_gcdl p1 (q1_ v).\n      by rewrite gcdp_polyOver ?minPolyOver ?Fadjoin_polyOver.\n    rewrite -/p1 {1}/eqp dvdp_gcd => /and3P[_ _ /dvdp_leq/=/implyP].\n    rewrite size_minPoly ltnNge size_poly (contraNneq _ nz_v) // => q1v0.\n    by rewrite -(fmorph_eq0 Qyz) /= QyzE q1v0 horner0.\n  pose h2 : R := 2^-1; have nz2: 2 != 0 :> R by rewrite pnatr_eq0.\n  pose itv ab := [pred c : R | ab.1 <= c <= ab.2].\n  pose wid ab : R := ab.2 - ab.1; pose mid ab := (ab.1 + ab.2) * h2.\n  pose sub_itv ab cd := cd.1 <= ab.1 :> R /\\ ab.2 <= cd.2 :> R.\n  pose xup q ab := [/\\ q.[ab.1] <= 0, q.[ab.2] >= 0 & ab.1 <= ab.2 :> R].\n  pose narrow q ab (c := mid ab) := if q.[c] >= 0 then (ab.1, c) else (c, ab.2).\n  pose find k q := iter k (narrow q).\n  have findP k q ab (cd := find k q ab):\n    xup q ab -> [/\\ xup q cd, sub_itv cd ab & wid cd = wid ab / (2 ^ k)%:R].\n  - rewrite {}/cd; case: ab => a b xq_ab.\n    elim: k => /= [|k]; first by rewrite divr1.\n    case: (find k q _) => c d [[/= qc_le0 qd_ge0 le_cd] [/= le_ac le_db] Dcd].\n    have [/= le_ce le_ed] := midf_le le_cd; set e := _ / _ in le_ce le_ed.\n    rewrite expnSr natrM invfM mulrA -{}Dcd /narrow /= -[mid _]/e.\n    have [qe_ge0 // | /ltW qe_le0] := lerP 0 q.[e].\n      do ?split=> //=; [exact: (le_trans le_ed) | apply: canRL (mulfK nz2) _].\n      by rewrite mulrBl divfK // mulr_natr opprD addrACA subrr add0r.\n    do ?split=> //=; [exact: (le_trans le_ac) | apply: canRL (mulfK nz2) _].\n    by rewrite mulrBl divfK // mulr_natr opprD addrACA subrr addr0.\n  have find_root r q ab:\n    xup q ab -> {n | forall x, x \\in itv (find n q ab) ->`|(r * q).[x]| < h2}.\n  - move=> xab; have ub_ab := poly_itv_bound _ ab.1 ab.2.\n    have [Mu MuP] := ub_ab r; have /all_sig[Mq MqP] j := ub_ab q^`N(j).\n    pose d := wid ab; pose dq := \\poly_(i < (size q).-1) Mq i.+1.\n    have d_ge0: 0 <= d by rewrite subr_ge0; case: xab.\n    have [Mdq MdqP] := poly_disk_bound dq d.\n    pose n := Num.bound (Mu * Mdq * d); exists n => c /andP[].\n    have{xab} [[]] := findP n _ _ xab; case: (find n q ab) => a1 b1 /=.\n    rewrite -/d => qa1_le0 qb1_ge0 le_ab1 [/= le_aa1 le_b1b] Dab1 le_a1c le_cb1.\n    have /MuP lbMu: c \\in itv ab.\n      by rewrite inE (le_trans le_aa1) ?(le_trans le_cb1).\n    have Mu_ge0: 0 <= Mu by rewrite (le_trans _ lbMu).\n    have Mdq_ge0: 0 <= Mdq.\n      by rewrite (le_trans _ (MdqP 0 _)) ?normr0.\n    suffices lb1 a2 b2 (ab1 := (a1, b1)) (ab2 := (a2, b2)) :\n      xup q ab2 /\\ sub_itv ab2 ab1 -> q.[b2] - q.[a2] <= Mdq * wid ab1.\n    + apply: le_lt_trans (_ : Mu * Mdq * wid (a1, b1) < h2); last first.\n        rewrite {}Dab1 mulrA ltr_pdivrMr ?ltr0n ?expn_gt0 //.\n        rewrite (lt_le_trans (archi_boundP _)) ?mulr_ge0 ?ltr_nat // -/n.\n        rewrite ler_pdivlMl ?ltr0n // -natrM ler_nat.\n        by case: n => // n; rewrite expnS leq_pmul2l // ltn_expl.\n      rewrite -mulrA hornerM normrM ler_pM //.\n      have [/ltW qc_le0 | qc_ge0] := ltrP q.[c] 0.\n        by apply: le_trans (lb1 c b1 _); rewrite ?ler0_norm ?ler_wpDl.\n      by apply: le_trans (lb1 a1 c _); rewrite ?ger0_norm ?ler_wpDr ?oppr_ge0.\n    case{c le_a1c le_cb1 lbMu}=> [[/=qa2_le0 qb2_ge0 le_ab2] [/=le_a12 le_b21]].\n    pose h := b2 - a2; have h_ge0: 0 <= h by rewrite subr_ge0.\n    have [-> | nz_q] := eqVneq q 0.\n      by rewrite !horner0 subrr mulr_ge0 ?subr_ge0.\n    rewrite -(subrK a2 b2) (addrC h) (nderiv_taylor q (mulrC a2 h)).\n    rewrite (polySpred nz_q) big_ord_recl /= mulr1 nderivn0 addrC addKr.\n    have [le_aa2 le_b2b] := (le_trans le_aa1 le_a12, le_trans le_b21 le_b1b).\n    have /MqP MqPx1: a2 \\in itv ab by rewrite inE le_aa2 (le_trans le_ab2).\n    apply: le_trans (le_trans (ler_norm _) (ler_norm_sum _ _ _)) _.\n    apply: le_trans (_ : `|dq.[h] * h| <= _); last first.\n      by rewrite normrM ler_pM ?normr_ge0 ?MdqP // ?ger0_norm ?lerB ?h_ge0.\n    rewrite horner_poly ger0_norm ?mulr_ge0 ?sumr_ge0 // => [|j _]; last first.\n      by rewrite mulr_ge0 ?exprn_ge0 // (le_trans _ (MqPx1 _)).\n    rewrite mulr_suml ler_sum // => j _; rewrite normrM -mulrA -exprSr.\n    by rewrite ler_pM // normrX ger0_norm.\n  have [ab0 xab0]: {ab | xup (p ^ QxR) ab}.\n    have /monic_Cauchy_bound[b pb_gt0]: p ^ QxR \\is monic by apply: monic_map.\n    by exists (0, `|b|); rewrite /xup normr_ge0 p0_le0 ltW ?pb_gt0 ?ler_norm.\n  pose ab_ n := find n (p ^ QxR) ab0; pose Iab_ n := itv (ab_ n).\n  pose lim v a := (q_ v ^ QxR).[a]; pose nlim v n := lim v (ab_ n).2.\n  have lim0 a: lim 0 a = 0.\n    rewrite /lim; suffices /eqP ->: q_ 0 == 0 by rewrite rmorph0 horner0.\n    by rewrite -(map_poly_eq0 Qxz) Dq /q1_ !raddf0.\n  have limN v a: lim (- v) a = - lim v a.\n    rewrite /lim; suffices ->: q_ (- v) = - q_ v by rewrite rmorphN hornerN.\n    apply: (map_poly_inj Qxz).\n    by rewrite Dq /q1_ (raddfN _ v) (raddfN _ (Qyz v)) [RHS]raddfN /= Dq.\n  pose lim_nz n v := exists2 e, e > 0 & {in Iab_ n, forall a, e < `|lim v a| }.\n  have /(all_sig_cond 0)[n_ nzP] v: v != 0 -> {n | lim_nz n v}.\n    move=> nz_v; do [move/(_ v nz_v); rewrite -(coprimep_map QxR)] in coqp.\n    have /sig_eqW[r r_pq_1] := Bezout_eq1_coprimepP _ _ coqp.\n    have /(find_root r.1)[n ub_rp] := xab0; exists n.\n    have [M Mgt0 ubM]: {M | 0 < M & {in Iab_ n, forall a, `|r.2.[a]| <= M}}.\n      have [M ubM] := poly_itv_bound r.2 (ab_ n).1 (ab_ n).2.\n      exists (Num.max 1 M) => [|s /ubM vM]; first by rewrite lt_max ltr01.\n      by rewrite le_max orbC vM.\n    exists (h2 / M) => [|a xn_a]; first by rewrite divr_gt0 ?invr_gt0 ?ltr0n.\n    rewrite ltr_pdivrMr // -(ltrD2l h2) -mulr2n -mulr_natl divff //.\n    rewrite -normr1 -(hornerC 1 a) -[1%:P]r_pq_1 hornerD.\n    rewrite ?(le_lt_trans (ler_normD _ _)) ?ltr_leD ?ub_rp //.\n    by rewrite mulrC hornerM normrM ler_wpM2l ?ubM.\n  have ab_le m n: (m <= n)%N -> (ab_ n).2 \\in Iab_ m.\n    move/subnKC=> <-; move: {n}(n - m)%N => n; rewrite /ab_.\n    have /(findP m)[/(findP n)[[_ _]]] := xab0.\n    rewrite /find -iterD -!/(find _ _) -!/(ab_ _) addnC !inE.\n    by move: (ab_ _) => /= ab_mn le_ab_mn [/le_trans->].\n  pose lt v w := 0 < nlim (w - v) (n_ (w - v)).\n  have posN v: lt 0 (- v) = lt v 0 by rewrite /lt subr0 add0r.\n  have posB v w: lt 0 (w - v) = lt v w by rewrite /lt subr0.\n  have posE n v: (n_ v <= n)%N -> lt 0 v = (0 < nlim v n).\n    rewrite /lt subr0 /nlim => /ab_le; set a := _.2; set b := _.2 => Iv_a.\n    have [-> | /nzP[e e_gt0]] := eqVneq v 0; first by rewrite !lim0 ltxx.\n    move: (n_ v) => m in Iv_a b * => v_gte.\n    without loss lt0v: v v_gte / 0 < lim v b.\n      move=> IHv; apply/idP/idP => [v_gt0 | /ltW]; first by rewrite -IHv.\n      rewrite lt_def -normr_gt0 ?(lt_trans _ (v_gte _ _)) ?ab_le //=.\n      rewrite !leNgt -!oppr_gt0 -!limN; apply: contra => v_lt0.\n      by rewrite -IHv // => c /v_gte; rewrite limN normrN.\n    rewrite lt0v (lt_trans e_gt0) ?(lt_le_trans (v_gte a Iv_a)) //.\n    rewrite ger0_norm // leNgt; apply/negP=> /ltW lev0.\n    have [le_a le_ab] : _ /\\ a <= b := andP Iv_a.\n    have xab: xup (q_ v ^ QxR) (a, b) by move/ltW in lt0v.\n    have /(find_root (h2 / e)%:P)[n1] := xab; have /(findP n1)[[_ _]] := xab.\n    case: (find _ _ _) => c d /= le_cd [/= le_ac le_db] _ /(_ c)/implyP.\n    rewrite inE lexx le_cd hornerM hornerC normrM le_gtF //.\n    rewrite ger0_norm ?divr_ge0 ?invr_ge0 ?ler0n ?(ltW e_gt0) // mulrAC.\n    rewrite ler_pdivlMr // ler_wpM2l ?invr_ge0 ?ler0n // ltW // v_gte //=.\n    by rewrite inE -/b (le_trans le_a) //= (le_trans le_cd).\n  pose lim_pos m v := exists2 e, e > 0 & forall n, (m <= n)%N -> e < nlim v n.\n  have posP v: reflect (exists m, lim_pos m v) (lt 0 v).\n    apply: (iffP idP) => [v_gt0|[m [e e_gt0 v_gte]]]; last first.\n      by rewrite (posE _ _ (leq_maxl _ m)) (lt_trans e_gt0) ?v_gte ?leq_maxr.\n    have [|e e_gt0 v_gte] := nzP v.\n      by apply: contraTneq v_gt0 => ->; rewrite /lt subr0 /nlim lim0 ltxx.\n    exists (n_ v), e => // n le_vn; rewrite (posE n) // in v_gt0.\n    by rewrite -(ger0_norm (ltW v_gt0)) v_gte ?ab_le.\n  have posNneg v: lt 0 v -> ~~ lt v 0.\n    case/posP=> m [d d_gt0 v_gtd]; rewrite -posN.\n    apply: contraL d_gt0 => /posP[n [e e_gt0 nv_gte]].\n    rewrite lt_gtF // (lt_trans (v_gtd _ (leq_maxl m n))) // -oppr_gt0.\n    by rewrite /nlim -limN (lt_trans e_gt0) ?nv_gte ?leq_maxr.\n  have posVneg v: v != 0 -> lt 0 v || lt v 0.\n    case/nzP=> e e_gt0 v_gte; rewrite -posN; set w := - v.\n    have [m [le_vm le_wm _]] := maxn3 (n_ v) (n_ w) 0; rewrite !(posE m) //.\n    by rewrite /nlim limN -ltr_normr (lt_trans e_gt0) ?v_gte ?ab_le.\n  have posD v w: lt 0 v -> lt 0 w -> lt 0 (v + w).\n    move=> /posP[m [d d_gt0 v_gtd]] /posP[n [e e_gt0 w_gte]].\n    apply/posP; exists (maxn m n), (d + e) => [|k]; first exact: addr_gt0.\n    rewrite geq_max => /andP[le_mk le_nk]; rewrite /nlim /lim.\n    have ->: q_ (v + w) = q_ v + q_ w.\n      by apply: (map_poly_inj Qxz); rewrite rmorphD /= !{1}Dq /q1_ !raddfD.\n    by rewrite rmorphD hornerD ltrD ?v_gtd ?w_gte.\n  have posM v w: lt 0 v -> lt 0 w -> lt 0 (v * w).\n    move=> /posP[m [d d_gt0 v_gtd]] /posP[n [e e_gt0 w_gte]].\n    have /dvdpP[r /(canRL (subrK _))Dqvw]: p %| q_ (v * w) - q_ v * q_ w.\n      rewrite -(dvdp_map Qxz) rmorphB rmorphM /= !Dq -Dp minPoly_dvdp //.\n        by rewrite rpredB 1?rpredM ?Fadjoin_polyOver.\n      by rewrite rootE !hornerE -!QyzE rmorphM subrr.\n    have /(find_root ((d * e)^-1 *: r ^ QxR))[N ub_rp] := xab0.\n    pose f := d * e * h2; apply/posP; exists (maxn N (maxn m n)), f => [|k].\n      by rewrite !mulr_gt0 ?invr_gt0 ?ltr0n.\n   rewrite !geq_max => /and3P[/ab_le/ub_rp{}ub_rp le_mk le_nk].\n    rewrite -(ltrD2r f) -mulr2n -mulr_natr divfK // /nlim /lim Dqvw.\n    rewrite rmorphD hornerD /= -addrA -ltrBlDl ler_ltD //.\n      by rewrite rmorphM hornerM ler_pM ?ltW ?v_gtd ?w_gte.\n    rewrite -ltr_pdivrMl ?mulr_gt0 // (le_lt_trans _ ub_rp) //.\n    by rewrite -scalerAl hornerZ -rmorphM mulrN -normrN ler_norm.\n  pose le v w := (v == w) || lt v w.\n  pose abs v := if le 0 v then v else - v.\n  have absN v: abs (- v) = abs v.\n    rewrite /abs /le !(eq_sym 0) oppr_eq0 opprK posN.\n    have [-> | /posVneg/orP[v_gt0 | v_lt0]] := eqVneq; first by rewrite oppr0.\n      by rewrite v_gt0 /= -if_neg posNneg.\n    by rewrite v_lt0 /= -if_neg -(opprK v) posN posNneg ?posN.\n  have absE v: le 0 v -> abs v = v by rewrite /abs => ->.\n  pose RyM := Num.IntegralDomain_isLtReal.Build (Q y) posD\n                posM posNneg posB posVneg absN absE (rrefl _).\n  pose Ry : realFieldType := HB.pack (Q y) RyM.\n  have QisArchi : Num.NumDomain_bounded_isArchimedean Ry.\n    by constructor; apply: (@rat_algebraic_archimedean Ry _ alg_integral).\n  exists (HB.pack_for archiRealFieldType _ QisArchi); apply: idfun.\nhave some_realC: realC.\n  suffices /all_sig[f QfK] x: {a | in_alg (Q 0) a = x}.\n    have fA : additive f.\n      exact: can2_additive (inj_can_sym QfK (fmorph_inj _)) QfK.\n    have fM : multiplicative f.\n      exact: can2_rmorphism (inj_can_sym QfK (fmorph_inj _)) QfK.\n    pose faM := GRing.isAdditive.Build _ _ _ fA.\n    pose fmM := GRing.isMultiplicative.Build _ _ _ fM.\n    pose fRM : {rmorphism _ -> _} := HB.pack f faM fmM.\n    by exists 0, rat; exact: fRM.\n  have /Fadjoin1_polyP/sig_eqW[q]: x \\in <<1; 0>>%VS by rewrite -sQof2 rmorph0.\n  by exists q.[0]; rewrite -horner_map rmorph0.\npose fix xR n : realC :=\n  if n isn't n'.+1 then some_realC else\n  if unpickle (nth 0 (CodeSeq.decode n') 1) isn't Some (p, c) then xR n' else\n  tag (add_Rroot (xR n') p c).\npose x_ n := tag (xR n).\nhave sRle m n: (m <= n)%N -> {subset sQ (x_ m) <= sQ (x_ n)}.\n  move/subnK <-; elim: {n}(n - m)%N => // n IHn x /IHn{IHn}Rx.\n  rewrite addSn /x_ /=; case: (unpickle _) => [[p c]|] //=.\n  by case: (add_Rroot _ _ _) => yR /= /(sQtrans _ x)->.\nhave xRroot n p c: has_Rroot (xR n) p c -> {m | n <= m & root_in (xR m) p}%N.\n  case/and4P=> Rp mon_p Rc Dc; pose m := CodeSeq.code [:: n; pickle (p, c)].\n  have le_n_m: (n <= m)%N by apply/ltnW/(allP (CodeSeq.ltn_code _))/mem_head.\n  exists m.+1; rewrite ?leqW /x_ //= CodeSeq.codeK pickleK.\n  case: (add_Rroot _ _ _) => yR /= _; apply; apply/and4P.\n  by split=> //; first apply: polyOverS Rp; apply: (sRle n).\nhave /all_sig[z_ /all_and3[Ri_R Ri_i defRi]] n (x := x_ n):\n  {z | [/\\ x \\in sQ z, i \\in sQ z & <<<<1; inQ z x>>; inQ z i>> = fullv]}.\n- have [z /and3P[z_x z_i _] Dzi] := PET [:: x; i].\n  by exists z; rewrite -adjoin_seq1 -adjoin_cons.\npose i_ n := inQ (z_ n) i; pose R_ n := <<1; inQ (z_ n) (x_ n)>>%AS.\nhave memRi n: <<R_ n; i_ n>> =i predT by move=> u; rewrite defRi memvf.\nhave sCle m n: (m <= n)%N -> {subset sQ (z_ m) <= sQ (z_ n)}.\n  move/sRle=> Rmn _ /sQ_inQ[u <-].\n  have /Fadjoin_polyP[p /polyOverP Rp ->] := memRi m u.\n  rewrite -horner_map inQ_K ?(@rpred_horner _ (sQC _)) //=.\n  apply/polyOver_poly=> j _.\n  by apply: sQtrans (Ri_R n); rewrite Rmn // -(inQ_K _ _ (Ri_R m)) sQof2.\nhave R'i n: i \\notin sQ (x_ n).\n  rewrite /x_; case: (xR n) => x [Rn QxR] /=.\n  apply: contraL (@ltr01 Rn) => /sQ_inQ[v Di].\n  suffices /eqP <-: - QxR v ^+ 2 == 1 by rewrite oppr_gt0 -leNgt sqr_ge0.\n  rewrite -rmorphXn -rmorphN fmorph_eq1 -(fmorph_eq1 (ofQ x)) rmorphN eqr_oppLR.\n  by rewrite rmorphXn /= Di Di2.\nhave szX2_1: size ('X^2 + 1) = 3%N.\n  by move=> R; rewrite size_polyDl ?size_polyXn ?size_poly1.\nhave minp_i n (p_i := minPoly (R_ n) (i_ n)): p_i = 'X^2 + 1.\n  have p_dv_X2_1: p_i %| 'X^2 + 1.\n    rewrite minPoly_dvdp ?rpredD ?rpredX ?rpred1 ?polyOverX //.\n    rewrite -(fmorph_root (ofQ _)) inQ_K // rmorphD rmorph1 /= map_polyXn.\n    by rewrite rootE hornerD hornerXn hornerC Di2 addNr.\n  apply/eqP; rewrite -eqp_monic ?monic_minPoly //; last first.\n    by rewrite monicE lead_coefE szX2_1 coefD coefXn coefC addr0.\n  rewrite -dvdp_size_eqp // eqn_leq dvdp_leq -?size_poly_eq0 ?szX2_1 //= ltnNge.\n  by rewrite size_minPoly ltnS leq_eqVlt orbF adjoin_deg_eq1 -sQof2 !inQ_K.\nhave /all_sig[n_ FTA] z: {n | z \\in sQ (z_ n)}.\n  without loss [z_i gal_z]: z / i \\in sQ z /\\ is_Gal z.\n    have [y /and3P[/sQtrans y_z /sQtrans y_i _] _] := PET [:: z; i].\n    have [t /sQtrans t_y gal_t] := galQ y.\n    by case/(_ t)=> [|n]; last exists n; rewrite ?y_z ?y_i ?t_y.\n  apply/sig_eqW; have n := 0%N.\n  have [p]: exists p, [&& p \\is monic, root p z & p \\is a polyOver (sQ (z_ n))].\n    have [p mon_p pz0] := algC z; exists (p ^ QtoC).\n    by rewrite map_monic mon_p pz0 -(pQof (z_ n)); apply/polyOver_poly.\n  have [d lepd] := ubnP (size p); elim: d => // d IHd in p n lepd * => pz0.\n  have [t [t_C t_z gal_t]]: exists t, [/\\ z_ n \\in sQ t, z \\in sQ t & is_Gal t].\n    have [y /and3P[y_C y_z _]] := PET [:: z_ n; z].\n    by have [t /(sQtrans y)t_y] := galQ y; exists t; rewrite !t_y.\n  pose QtMixin := FieldExt_isSplittingField.Build _ (Q t) gal_t.\n  pose Qt : splittingFieldType rat := HB.pack (Q t) QtMixin.\n  have /QtoQ[CnQt CnQtE] := t_C.\n  pose Rn : {subfield Qt} := (CnQt @: R_ n)%AS; pose i_t : Qt := CnQt (i_ n).\n  pose Cn : {subfield Qt} := <<Rn; i_t>>%AS.\n  have defCn: Cn = limg CnQt :> {vspace Q t} by rewrite /= -aimg_adjoin defRi.\n  have memRn u: (u \\in Rn) = (ofQ t u \\in sQ (x_ n)).\n    by rewrite /= aimg_adjoin aimg1 -sQof2 CnQtE inQ_K.\n  have memCn u: (u \\in Cn) = (ofQ t u \\in sQ (z_ n)).\n    have [v Dv genCn] := genQz (z_ n).\n    by rewrite -Dv -CnQtE sQof2 defCn -genCn aimg_adjoin aimg1.\n  have Dit: ofQ t i_t = i by rewrite CnQtE inQ_K.\n  have Dit2: i_t ^+ 2 = -1.\n    by apply: (fmorph_inj (ofQ t)); rewrite rmorphXn rmorphN1 /= Dit.\n  have dimCn: \\dim_Rn Cn = 2%N.\n    rewrite -adjoin_degreeE adjoin_degree_aimg.\n    by apply: succn_inj; rewrite -size_minPoly minp_i szX2_1.\n  have /sQ_inQ[u_z Dz] := t_z; pose Rz := <<Cn; u_z>>%AS.\n  have{p lepd pz0} le_Rz_d: (\\dim_Cn Rz < d)%N.\n    rewrite -ltnS -adjoin_degreeE -size_minPoly (leq_trans _ lepd) // !ltnS.\n    have{pz0} [mon_p pz0 Cp] := and3P pz0.\n    have{Cp} Dp: ((p ^ inQ (z_ n)) ^ CnQt) ^ ofQ t = p.\n      by rewrite -map_poly_comp (eq_map_poly CnQtE) inQpK.\n    rewrite -Dp size_map_poly dvdp_leq ?monic_neq0 -?(map_monic (ofQ _)) ?Dp //.\n    rewrite defCn minPoly_dvdp //; try by rewrite -(fmorph_root (ofQ t)) Dz Dp.\n    by apply/polyOver_poly=> j _; rewrite memv_img ?memvf.\n  have [sRCn sCnRz]: (Rn <= Cn)%VS /\\ (Cn <= Rz)%VS by rewrite !subv_adjoin.\n  have sRnRz := subv_trans sRCn sCnRz.\n  have{gal_z} galRz: galois Rn Rz.\n    apply/and3P; split; [by []|by apply: sepQ|].\n    apply/splitting_normalField=> //.\n    pose QzMixin := FieldExt_isSplittingField.Build _ (Q z) gal_z.\n    pose Qz : splittingFieldType _ := HB.pack (Q z) QzMixin.\n    pose u : Qz := inQ z z.\n    have /QtoQ[Qzt QztE] := t_z; exists (minPoly 1 u ^ Qzt).\n      have /polyOver1P[q ->] := minPolyOver 1 u; apply/polyOver_poly=> j _.\n      by rewrite coef_map linearZZ rmorph1 rpredZ ?rpred1.\n    have [s /eqP Ds] := splitting_field_normal 1 u.\n    rewrite Ds; exists (map Qzt s); first by rewrite map_rp eqpxx.\n    apply/eqP; rewrite eqEsubv; apply/andP; split.\n      apply/Fadjoin_seqP; split=> // _ /mapP[w s_w ->].\n      by rewrite (subvP (adjoinSl u_z (sub1v _))) // -sQof2 Dz QztE.\n    rewrite /= adjoinC (Fadjoin_idP _) -/Rz; last first.\n      by rewrite (subvP (adjoinSl _ (sub1v _))) // -sQof2 Dz Dit.\n    rewrite /= -adjoin_seq1 adjoin_seqSr //; apply/allP=> /=; rewrite andbT.\n    rewrite -(mem_map (fmorph_inj (ofQ _))) -map_comp (eq_map QztE); apply/mapP.\n    by exists u; rewrite ?inQ_K // -root_prod_XsubC -Ds root_minPoly.\n  have galCz: galois Cn Rz by rewrite (galoisS _ galRz) ?sRCn.\n  have [Cz | C'z]:= boolP (u_z \\in Cn); first by exists n; rewrite -Dz -memCn.\n  pose G := 'Gal(Rz / Cn)%G; have{C'z} ntG: G :!=: 1%g.\n    rewrite trivg_card1 -galois_dim 1?(galoisS _ galCz) ?subvv //=.\n    by rewrite -adjoin_degreeE adjoin_deg_eq1.\n  pose extRz m := exists2 w, ofQ t w \\in sQ (z_ m) & w \\in [predD Rz & Cn].\n  suffices [m le_n_m [w Cw /andP[C'w Rz_w]]]: exists2 m, (n <= m)%N & extRz m.\n    pose p := minPoly <<Cn; w>> u_z; apply: (IHd (p ^ ofQ t) m).\n      apply: leq_trans le_Rz_d; rewrite size_map_poly size_minPoly ltnS.\n      rewrite adjoin_degreeE adjoinC (addv_idPl Rz_w) agenv_id.\n      rewrite ltn_divLR ?adim_gt0 // mulnC.\n      rewrite muln_divCA ?field_dimS ?subv_adjoin // ltn_Pmulr ?adim_gt0 //.\n      by rewrite -adjoin_degreeE ltnNge leq_eqVlt orbF adjoin_deg_eq1.\n    rewrite map_monic monic_minPoly -Dz fmorph_root root_minPoly /=.\n    have /polyOverP Cw_p: p \\is a polyOver <<Cn; w>>%VS by apply: minPolyOver.\n    apply/polyOver_poly=> j _; have /Fadjoin_polyP[q Cq {j}->] := Cw_p j.\n    rewrite -horner_map (@rpred_horner _ (sQC _)) //.\n    apply/polyOver_poly=> j _.\n    by rewrite (sCle n) // -memCn (polyOverP Cq).\n  have [evenG | oddG] := boolP (2.-group G); last first.\n    have [P /and3P[sPG evenP oddPG]] := Sylow_exists 2 'Gal(Rz / Rn).\n    have [w defQw] := PET_Qz t [aspace of fixedField P].\n    pose pw := minPoly Rn w; pose p := (- pw * (pw \\Po - 'X)) ^ ofQ t.\n    have sz_pw: (size pw).-1 = #|'Gal(Rz / Rn) : P|.\n      rewrite size_minPoly adjoin_degreeE -dim_fixed_galois //= -defQw.\n      congr (\\dim_Rn _); apply/esym/eqP; rewrite eqEsubv adjoinSl ?sub1v //=.\n      by apply/FadjoinP; rewrite memv_adjoin /= defQw -galois_connection.\n    have mon_p: p \\is monic.\n      have mon_pw: pw \\is monic := monic_minPoly _ _.\n      rewrite map_monic mulNr -mulrN monicMl // monicE.\n      rewrite !(lead_coefN, lead_coef_comp) ?size_polyN ?size_polyX //.\n      by rewrite lead_coefX sz_pw -signr_odd odd_2'nat oddPG mulrN1 opprK.\n    have Dp0: p.[0] = - ofQ t pw.[0] ^+ 2.\n      rewrite -(rmorph0 (ofQ t)) horner_map hornerM rmorphM.\n      by rewrite horner_comp !hornerN hornerX oppr0 /= rmorphN mulNr.\n    have Rpw: pw \\is a polyOver Rn by apply: minPolyOver.\n    have Rp: p \\is a polyOver (sQ (x_ n)).\n      apply/polyOver_poly=> j _; rewrite -memRn; apply: polyOverP j => /=.\n      by rewrite rpredM 1?polyOver_comp ?rpredN ?polyOverX.\n    have Rp0: ofQ t pw.[0] \\in sQ (x_ n) by rewrite -memRn rpred_horner ?rpred0.\n    have [|{mon_p Rp Rp0 Dp0}m lenm p_Rm_0] := xRroot n p (ofQ t pw.[0]).\n      by rewrite /has_Rroot mon_p Rp Rp0 -Dp0 /=.\n    have{p_Rm_0} [y Ry pw_y]: {y | y \\in sQ (x_ m) & root (pw ^ ofQ t) y}.\n      apply/sig2W; have [y Ry] := p_Rm_0.\n      rewrite [p]rmorphM /= map_comp_poly !rmorphN /= map_polyX.\n      rewrite rootM rootN root_comp hornerN hornerX.\n      by case/orP; [exists y | exists (- y)]; rewrite ?(rpredN (sQC _)).\n    have [u Rz_u Dy]: exists2 u, u \\in Rz & y = ofQ t u.\n      have Rz_w: w \\in Rz by rewrite -sub_adjoin1v defQw capvSl.\n      have [sg [Gsg _ Dpw]] := galois_factors sRnRz galRz w Rz_w.\n      set s := map _ sg in Dpw.\n      have /mapP[u /mapP[g Gg Du] ->]: y \\in map (ofQ t) s.\n        by rewrite -root_prod_XsubC -/(rp C _) -map_rp -[rp _ _]Dpw.\n      by exists u; rewrite // Du memv_gal.\n    have{pw_y} pw_u: root pw u by rewrite -(fmorph_root (ofQ t)) -Dy.\n    exists m => //; exists u; first by rewrite -Dy; apply: sQtrans Ry _.\n    rewrite inE /= Rz_u andbT; apply: contra oddG => Cu.\n    suffices: 2.-group 'Gal(Rz / Rn).\n      apply: pnat_dvd; rewrite -!galois_dim // ?(galoisS _ galQr) ?sRCz //.\n      rewrite dvdn_divLR ?field_dimS ?adim_gt0 //.\n      by rewrite mulnC muln_divCA ?field_dimS ?dvdn_mulr.\n    congr (2.-group _): evenP; apply/eqP.\n    rewrite eqEsubset sPG -indexg_eq1 (pnat_1 _ oddPG) // -sz_pw.\n    have (pu := minPoly Rn u): (pu %= pw) || (pu %= 1).\n      by rewrite minPoly_irr ?minPoly_dvdp ?minPolyOver.\n    rewrite /= -size_poly_eq1 {1}size_minPoly orbF => /eqp_size <-.\n    rewrite size_minPoly /= adjoin_degreeE (@pnat_dvd _ 2) // -dimCn.\n    rewrite dvdn_divLR ?divnK ?adim_gt0 ?field_dimS ?subv_adjoin //.\n    exact/FadjoinP.\n  have [w Rz_w deg_w]: exists2 w, w \\in Rz & adjoin_degree Cn w = 2%N.\n    have [P sPG iPG]: exists2 P : {group gal_of Rz}, P \\subset G & #|G : P| = 2%N.\n      have [_ _ [k oG]] := pgroup_pdiv evenG ntG.\n      have [P [sPG _ oP]] := normal_pgroup evenG (normal_refl G) (leq_pred _).\n      by exists P => //; rewrite -divgS // oP oG pfactorK // -expnB ?subSnn.\n    have [w defQw] := PET_Qz _ [aspace of fixedField P].\n    exists w; first by rewrite -sub_adjoin1v defQw capvSl.\n    rewrite adjoin_degreeE -iPG -dim_fixed_galois // -defQw; congr (\\dim_Cn _).\n    apply/esym/eqP; rewrite eqEsubv adjoinSl ?sub1v //=; apply/FadjoinP.\n    by rewrite memv_adjoin /= defQw -galois_connection.\n  have nz2: 2 != 0 :> Qt by move/pcharf0P: (pcharQ (Q t)) => ->.\n  without loss{deg_w} [C'w Cw2]: w Rz_w / w \\notin Cn /\\ w ^+ 2 \\in Cn.\n    pose p := minPoly Cn w; pose v := p`_1 / 2.\n    have /polyOverP Cp: p \\is a polyOver Cn := minPolyOver Cn w.\n    have Cv: v \\in Cn by rewrite rpred_div ?rpred_nat ?Cp.\n    move/(_ (v + w)); apply; first by rewrite rpredD // subvP_adjoin.\n    split; first by rewrite rpredDl // -adjoin_deg_eq1 deg_w.\n    rewrite addrC -[_ ^+ 2]subr0 -(rootP (root_minPoly Cn w)) -/p.\n    rewrite sqrrD [_ - _]addrAC rpredD ?rpredX // -mulr_natr -mulrA divfK //.\n    rewrite [w ^+ 2 + _]addrC mulrC -rpredN opprB horner_coef.\n    have /monicP := monic_minPoly Cn w; rewrite lead_coefE size_minPoly deg_w.\n    by rewrite 2!big_ord_recl big_ord1 => ->; rewrite mulr1 mul1r addrK Cp.\n  without loss R'w2: w Rz_w C'w Cw2 / w ^+ 2 \\notin Rn.\n    move=> IHw; have [Rw2 | /IHw] := boolP (w ^+ 2 \\in Rn); last exact.\n    have R'it: i_t \\notin Rn by rewrite memRn Dit.\n    pose v := 1 + i_t; have R'v: v \\notin Rn by rewrite rpredDl ?rpred1.\n    have Cv: v \\in Cn by rewrite rpredD ?rpred1 ?memv_adjoin.\n    have nz_v: v != 0 by rewrite (memPnC R'v) ?rpred0.\n    apply: (IHw (v * w)); last 1 [|] || by rewrite fpredMl // subvP_adjoin.\n      by rewrite exprMn rpredM // rpredX.\n    rewrite exprMn fpredMr //=; last by rewrite expf_eq0 (memPnC C'w) ?rpred0.\n    by rewrite sqrrD Dit2 expr1n addrC addKr -mulrnAl fpredMl ?rpred_nat.\n  pose rect_w2 u v := [/\\ u \\in Rn, v \\in Rn & u + i_t * (v * 2) = w ^+ 2].\n  have{Cw2} [u [v [Ru Rv Dw2]]]: {u : Qt & {v | rect_w2 u v}}.\n    rewrite /rect_w2 -(Fadjoin_poly_eq Cw2); set p := Fadjoin_poly Rn i_t _.\n    have /polyOverP Rp: p \\is a polyOver Rn by apply: Fadjoin_polyOver.\n    exists p`_0, (p`_1 / 2); split; rewrite ?rpred_div ?rpred_nat //.\n    rewrite divfK // (horner_coef_wide _ (size_Fadjoin_poly _ _ _)) -/p.\n    by rewrite adjoin_degreeE dimCn big_ord_recl big_ord1 mulr1 mulrC.\n  pose p := Poly [:: - (ofQ t v ^+ 2); 0; - ofQ t u; 0; 1].\n  have [|m lenm [x Rx px0]] := xRroot n p (ofQ t v).\n    rewrite /has_Rroot 2!unfold_in/= lead_coefE horner_coef0 -memRn Rv.\n    rewrite (@PolyK _ 1) ?oner_eq0 //= !eqxx.\n    rewrite !(rpred0 (sQC _)) ?(rpred1 (sQC _)) ?(rpredN (sQC _)) //=.\n    by rewrite !andbT (@rpredX _ (sQC _)) -memRn.\n  suffices [y Cy Dy2]: {y | y \\in sQ (z_ m) & ofQ t w ^+ 2 == y ^+ 2}.\n    exists m => //; exists w; last by rewrite inE C'w.\n    by move: Dy2; rewrite eqf_sqr => /pred2P[]->; rewrite ?(rpredN (sQC _)).\n  exists (x + i * (ofQ t v / x)).\n    rewrite (@rpredD _ (sQC _)) 1?(@rpredM _ (sQC _)) //=.\n      exact: (sQtrans (x_ m)).\n    by rewrite (@rpred_div _ (sQC _)) // (sQtrans (x_ m)) // (sRle n) // -memRn.\n  rewrite rootE /horner (@PolyK _ 1) ?oner_eq0 //= ?addr0 ?mul0r in px0.\n  rewrite add0r mul1r -mulrA -expr2 subr_eq0 in px0.\n  have nz_x2: x ^+ 2 != 0.\n    apply: contraNneq R'w2 => y2_0; rewrite -Dw2 mulrCA.\n    suffices /eqP->: v == 0 by rewrite mul0r addr0.\n    by rewrite y2_0 mulr0 eq_sym sqrf_eq0 fmorph_eq0 in px0.\n  apply/eqP/esym/(mulIf nz_x2); rewrite -exprMn -rmorphXn -Dw2 rmorphD rmorphM.\n  rewrite /= Dit mulrDl -expr2 mulrA divfK; last by rewrite expf_eq0 in nz_x2.\n  rewrite mulr_natr addrC sqrrD exprMn Di2 mulN1r -(eqP px0) -mulNr opprB.\n  by rewrite -mulrnAl -mulrnAr -rmorphMn -!mulrDl addrAC subrK.\nhave inFTA n z: (n_ z <= n)%N -> z = ofQ (z_ n) (inQ (z_ n) z).\n  by move/sCle=> le_zn; rewrite inQ_K ?le_zn.\npose is_cj n cj := {in R_ n, cj =1 id} /\\ cj (i_ n) = - i_ n.\nhave /all_sig[cj_ /all_and2[cj_R cj_i]] n: {cj : 'AEnd(Q (z_ n)) | is_cj n cj}.\n  have cj_P: root (minPoly (R_ n) (i_ n) ^ \\1%VF) (- i_ n).\n    rewrite minp_i -(fmorph_root (ofQ _)) !rmorphD !rmorph1 /= !map_polyXn.\n    by rewrite rmorphN inQ_K // rootE hornerD hornerXn hornerC sqrrN Di2 addNr.\n  have cj_M: ahom_in fullv (kHomExtend (R_ n) \\1 (i_ n) (- i_ n)).\n    by rewrite -defRi -k1HomE kHomExtendP ?sub1v ?kHom1.\n  exists (AHom cj_M); split=> [y /kHomExtend_id->|]; first by rewrite ?id_lfunE.\n  by rewrite (kHomExtend_val (kHom1 1 _)).\npose conj_ n z := ofQ _ (cj_ n (inQ _ z)); pose conj z := conj_ (n_ z) z.\nhave conjK n m z: (n_ z <= n)%N -> (n <= m)%N -> conj_ m (conj_ n z) = z.\n  move/sCle=> le_z_n le_n_m; have /le_z_n/sQ_inQ[u <-] := FTA z.\n  have /QtoQ[Qmn QmnE]: z_ n \\in sQ (z_ m) by rewrite (sCle n).\n  rewrite /conj_ ofQ_K -!QmnE !ofQ_K -!comp_lfunE; congr (ofQ _ _).\n  move: u (memRi n u); apply/eqlfun_inP/FadjoinP; split=> /=.\n    apply/eqlfun_inP=> y Ry; rewrite !comp_lfunE !cj_R //.\n    by move: Ry; rewrite -!sQof2 QmnE !inQ_K //; apply: sRle.\n  apply/eqlfunP; rewrite !comp_lfunE cj_i !linearN /=.\n  suffices ->: Qmn (i_ n) = i_ m by rewrite cj_i ?opprK.\n  by apply: (fmorph_inj (ofQ _)); rewrite QmnE !inQ_K.\nhave conjE n z: (n_ z <= n)%N -> conj z = conj_ n z.\n  move/leq_trans=> le_zn; set x := conj z; set y := conj_ n z.\n  have [m [le_xm le_ym le_nm]] := maxn3 (n_ x) (n_ y) n.\n  by have /conjK/=/can_in_inj := leqnn m; apply; rewrite ?conjK // le_zn.\n  have conjA : additive conj.\n  move=> x y.\n  have [m [le_xm le_ym le_xym]] := maxn3 (n_ x) (n_ y) (n_ (x - y)).\n  by rewrite !(conjE m) // (inFTA m x) // (inFTA m y) -?rmorphB /conj_ ?ofQ_K.\nhave conjM : multiplicative conj.\n  split=> [x y|]; last pose n1 := n_ 1.\n    have [m [le_xm le_ym le_xym]] := maxn3 (n_ x) (n_ y) (n_ (x * y)).\n    by rewrite !(conjE m) // (inFTA m x) // (inFTA m y) -?rmorphM /conj_ ?ofQ_K.\n  by rewrite /conj -/n1 -(rmorph1 (ofQ (z_ n1))) /conj_ ofQ_K !rmorph1.\nhave conjaM := GRing.isAdditive.Build _ _ _ conjA.\nhave conjmM := GRing.isMultiplicative.Build _ _ _ conjM.\npose conjRM : {rmorphism _ -> _} := HB.pack conj conjaM conjmM.\nexists conjRM => [z | /(_ i)/eqP/idPn[]] /=.\n  by have [n [/conjE-> /(conjK (n_ z))->]] := maxn3 (n_ (conj z)) (n_ z) 0.\nrewrite /conj/conj_ cj_i rmorphN inQ_K // eq_sym -addr_eq0 -mulr2n -mulr_natl.\nrewrite mulf_neq0 ?(memPnC (R'i 0)) ?(rpred0 (sQC _)) //.\nby have /pcharf0P-> := ftrans (fmorph_pchar QtoC) (pchar_num _).\nQed."
}
