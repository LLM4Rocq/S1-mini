{
  "statement": "Lemma absz1 : `|1%R| = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma abszN1 : `|-1%R| = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma absz_id m : `|(`|m|)| = `|m|. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add3n m : 3 + m = m.+3. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add4n m : 4 + m = m.+4. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEprod x : ~` x = (~` x.1, ~` x.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEsubset A : ~` A = ~: A.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derg0 A : A^`(0) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivn0 p : p^`(0) = p.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma diffEprod x y : x `\\` y = (x.1 `\\` y.1, x.2 `\\` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma double0 : 0.*2 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr1z x : x ^ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma exprN1 x : x ^ (-1) = x^-1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fact0 : 0`! = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEprod x y : x `|` y = (x.1 `|` y.1, x.2 `|` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEsubset A B : A `|` B = A :|: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEbool x y : (x < y) = (x < y)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEprodlexi x y :\n  (x < y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 < y.2)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEprod x y : x `&` y = (x.1 `&` y.1, x.2 `&` y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEsubset A B : A `&` B = A :&: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natr0E : 0 = 0%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrDE n m : n + m = (n + m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrME n m : n * m = (n * m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natrXE n m : n ^+ m = (n ^ m)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nonzero1z : 1%Z != 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rat1 : 1%:Q = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma sdvdE (m n : t) : m %<| n = (n != m) && (m %| n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subEbool x y : x `\\` y = x && ~~ y. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subEsubset A B : A `\\` B = A :\\: B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmod1gE : 1%g = 0 :> U.            ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodVgE x : x^-1%g = - x.          ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEdual d (T : meetSemilatticeType d) (x y : T) :\n  ((x : T^d) `|^d` y) = (x `&` y).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn1 A : 'L_1(A) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEdual d (T : joinSemilatticeType d) (x y : T) :\n  ((x : T^d) `&^d` y) = (x `|` y).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat0E : nat0 = 0%N :> t. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat1E : nat1 = 1%N :> t. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ractE : raction =1 to. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma supportE x y f : (x \\in support_for y f) = (f x != y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactE : falling_factorial = ffact_rec. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma natr1E : 1 = 1%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma geE x y : ge x y = (y <= x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPeq m : ubn_eq_spec m m.      ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn0 A : 'L_0(A) = A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rat0 : 0%:Q = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add2n m : 2 + m = m.+2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ucn0 A : 'Z_0(A) = 1.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEprod x y : (x <= y) = (x.1 <= y.1) && (x.2 <= y.2). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEprodlexi x y :\n  (x <= y) = (x.1 <= y.1) && ((x.1 >= y.1) ==> (x.2 <= y.2)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcn2 A : 'L_2(A) = A^`(1). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPgeq m : ubn_geq_spec m m.    ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ubnPleq m : ubn_leq_spec m m.    ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eq_Mod8_D8 : 'Mod_8 = 'D_8. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivn1 p : p^`(1) = p^`().\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma horner_evalE x p : horner_eval x p = p.[x]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derg1 A : A^`(1) = [~: A, A]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodMgE x y : (x * y)%g = x + y.   ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expn0 m : m ^ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactnS n m : n ^_ m.+1 = n * n.-1 ^_ m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma modn0 m : m %% 0 = m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cat0s s : [::] ++ s = s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactn0 n : n ^_ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltn0Sn n : 0 < n.+1.              ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expg0 x : x ^+ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma derivnS p n : p^`(n.+1) = p^`(n)^`().\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zmodXgE n x : (x ^+ n)%g = x *+ n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma absz0 : `|0%R| = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leq0n n : 0 <= n.                 ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma divn0 m : m %/ 0 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma pFrobenius_autE x : x^f = x ^+ p. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nposrE x : (x \\is npos) = (x <= 0). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphpreE R : f @*^-1 R = D :&: f @^-1: R. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltnSE m n : m < n.+1 -> m <= n.   ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ffactSS n m : n.+1 ^_ m.+1 = n.+1 * n ^_ m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma comp_actE x e : comp_action x e = to x (f e). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma dergSn n A : A^`(n.+1) = [~: A^`(n), A^`(n)]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphimE A : f @* A = f @: (D :&: A). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma factS n : (n.+1)`!  = n.+1 * n`!. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma baseField_scaleE a (u : L) : a *: (u : L0) = a%:A *: u.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinGE G H : (G * H)%G = (G <*> H)%G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joingE A B : A <*> B = <<A :|: B>>. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma doubleS n : n.+1.*2 = n.*2.+2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commgEl x y : [~ x, y] = x^-1 * x ^ y. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEbool : compl = negb. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltnSn n : n < n.+1.               ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fmval0 : valA 0 = 1%g. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma iteriS n f x : iteri n.+1 f x = f n (iteri n f x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr1 x : x ^+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma binS n m : 'C(n.+1, m.+1) = 'C(n, m.+1) + 'C(n, m). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulr1n x : x *+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma setactJ A x : 'J^*%act A x = A :^ x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expg1 x : x ^+ 1 = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqSS m n : (m.+1 == n.+1) = (m == n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_algE a : in_alg A a = a%:A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expn1 m : m ^ 1 = m. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma equivE x y : (equiv x y) = (x - y \\in I). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcmz_ge0 m n : 0 <= lcmz m n.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr0z x : x ^ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <=^d y :> T^d) = (y <= x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEdual (d : disp_t) (T : porderType d) (x y : T) :\n  (x <^d y :> T^d) = (y < x).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cat1s x s : [:: x] ++ s = x :: s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma GL_1E : GLval 1 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma GL_MxE u v : GLval (u * v) = u *m v. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulr2n x : x *+ 2 = x + x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr2 x : x ^+ 2 = x * x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma applyrE x : applyr f x =1 f^~ x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subSS n m : m.+1 - n.+1 = m - n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma scalezrE n x : n *: (x : M^z) = x *~ n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma conjgE x y : x ^ y = y^-1 * (x * y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulSn m n : m.+1 * n = n + m * n.  ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_cons y s x : (x \\in y :: s) = (x == y) || (x \\in s).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma dvdzE d m : (d %| m)%Z = (`|d| %| `|m|)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulr0z x : x *~ 0 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma apermE x s : aperm x s = s x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma minusE : minus = subn.   ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subnE : subn = minus. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEnat : lt = ltn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add1n n : 1 + n = n.+1.            ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma equivfE x y : equivf x y = equivf_notation x y.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulr0n x : x *+ 0 = 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orderE x : #[x] = #|<[x]>|. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma negrE x : (x \\is neg) = (x < 0). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fieldOver_scaleE a (u : L) : a *: (u : L_F) = vsval a * u.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma irr_reprE i x : irr_repr i x = submod_mx (socle_module i) x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expgnE x n : x ^+ n = iterop n mulg x 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma GL_VE u : GLval u^-1 = (GLval u)^-1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subn_eq0 m n : (m - n == 0) = (m <= n).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma conjgmE A x y : conjgm A x y = y ^ x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqseqE : eqseq = eq_op. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqnE : eqn = eq_op. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma sum_eqE : sum_eq = eq_op. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma addSn m n : m.+1 + n = (m + n).+1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma agenvE U : agenv U = agenv_aspace U. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idfun_is_scalable : scalable (@idfun U). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqbE : eqb = eq_op. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma uphalfE n : uphalf n = n.+1./2.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma trunc_log0n n : trunc_log 0 n = 0.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma trunc_log1n n : trunc_log 1 n = 0.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulmxE : mulmx = *%R. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma tag_eqE : tag_eq = eq_op. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma s23_inv : s23^-1 = s23.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma algRval_is_multiplicative : multiplicative algRval. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma GL_ME u v : GLval (u * v) = GLval u * GLval v. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expr0 x : x ^+ 0 = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphim_conj A x B : conjgm A x @* B = (A :&: B) :^ x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma algRval_is_additive : additive algRval. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commute_refl x : commute x x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma codom_tffun f : codom (total_fun f) = tfgraph f. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma r05_inv : r05^-1 = r50.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma nnegrE x : (x \\is nneg) = (0 <= x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nnegrE x : (x \\is nneg) = (0 <= x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma r50_inv : r50^-1 = r05.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma r14_inv : r14^-1 = r41.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma r41_inv : r41^-1 = r14.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma posrE x : (x \\is pos) = (0 < x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma posrE x : (x \\is pos) = (0 < x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma comm_mx_refl f : comm_mx f f. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma addnE : addn = plus. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idGfun_monotonic : GFunctor.monotonic idGfun. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma plusE : plus = addn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma Zp_nontrivial : Zp1 != 0 :> 'I_p. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mulnE : muln = mult. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma multE : mult = muln. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma polyn_is_linear : linear (@polyn _ _ : {poly_n R} -> _).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma sub0n : left_zero 0 subn.    ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcmE : lcm = lcmn :> (t -> t -> t). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lteifT x y : x < y ?<= if true = (x <= y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idGfun_cont : GFunctor.continuous idGfun. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma andEbool : meet = andb. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orEbool : meet = andb. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEnat : le = leq. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma codom_ffun f : codom f = fgraph f. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma bound_le0x b : -oo <= b. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lfun_compE f g : (g \\o f)%VF = f * g. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idGfun_closed : GFunctor.closed idGfun. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma vsval_is_linear : linear vsval. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEdual d (T : tPOrderType d) : (dual_bottom : T^d) = \\top :> T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma trajectS x n : traject x n.+1 = x :: traject (f x) n.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expnE n m : expn m n = iterop n muln m 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEord : \\top = ord_max. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subseq0 s : subseq s [::] = (s == [::]). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commr_refl x : comm x x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mask0s s : mask [::] s = [::]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma autmE A a (AutAa : a \\in Aut A) : autm AutAa = a.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma gcdE : gcd = gcdn :> (t -> t -> t). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma oop1x_subdef : right_id None oop. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcnSn n A : 'L_n.+2(A) = [~: 'L_n.+1(A), A]. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEdual d (T : bPOrderType d) : (dual_top : T^d) = \\bot :> T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mul0n : left_zero 0 muln.          ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma GL_VxE u : GLval u^-1 = invmx u. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma dim_matrix : dim 'M[R]_(m, n) = m * n.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma kerE : 'ker f = f @*^-1 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma theadE x t : thead [tuple of x :: t] = x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commute_sym x y : commute x y -> commute y x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leqif_eq m n : m <= n -> m <= n ?= iff (m == n).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma dvdE : dvd = dvdn :> rel t. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma complEtprod t : ~` t = map_tuple Order.compl t.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma pair_eqE : pair_eq = eq_op :> rel _. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leif_eq x y : x <= y -> x <= y ?= iff (x == y).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma le0z_nat n : 0 <= n :> int. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma minn0 : right_zero 0 minn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma zCdivE (p : int) : p = p%:~R :> divisor. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orbitJ G x : orbit 'J G x = x ^: G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma maxn0 : right_id 0 maxn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lez_nat m n : (m <= n :> int) = (m <= n)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orbitE A x : orbit to A x = to x @: A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEord : \\bot = ord0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orbitJs G A : orbit 'Js G A = A :^: G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltnS m n : (m < n.+1) = (m <= n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma bool_fieldP : Field.axiom bool. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma add0n : left_id 0 addn.            ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idmxE : 1%:M = 1 :> 'M_n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEsig x y : x < y =\n  (tag x <= tag y) && ((tag x >= tag y) ==> (tagged x < tagged_as x y)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEsig x y : x <= y =\n  (tag x <= tag y) && ((tag x >= tag y) ==> (tagged x <= tagged_as x y)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma morphim_mxE x : morphim_mx sGD x = rGf (f x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma valG : val G = G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma polyC0 : 0%:P = 0 :> {poly R}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma unit_actE x u : unit_act x u = x * val u. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma scale_actE A a : scale_act A a = val a *: A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma polyC1 : 1%:P = 1 :> {poly R}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma val_unit1 : val (1%g : unit_of) = 1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqE (T : eqType) x : eq_op x = hasDecEq.eq_op (Equality.class T) x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma qpolyCE k : qpolyC k = k%:P :> {poly R}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma quotientE : quotient = coset @* Q. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nth0 s : nth s 0 = head s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma coprimezE m n : coprimez m n = coprime `|m| `|n|. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma Znat_def (n : int) : (n \\is a nat_num) = (0 <= n).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma commr_sym x y : comm x y -> comm y x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma afix_ract B : 'Fix_(to \\ sAD)(B) = 'Fix_to(B). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mem_root p x : x \\in root p = (p.[x] == 0).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma r1_inv : r1^-1 = r3.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma r3_inv : r3^-1 = r1.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma morphmE fM : morphm fM = f. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma iterS n f x : iter n.+1 f x = f (iter n f x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma memtE (t : n.-tuple T) : mem t = mem (tval t).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leBSide x y (b b' : bool) :\n  BSide b x <= BSide b' y = (x < y ?<= if b' ==> b).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltBSide x y (b b' : bool) :\n  BSide b x < BSide b' y = (x < y ?<= if b && ~~ b').\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_nil x : (x \\in [::]) = false.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lteifF x y : x < y ?<= if false = (x < y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma root0C x : 0.-root x = 0. ",
  "proof": "Proof. by case_rootC. Qed."
}
{
  "statement": "Lemma irr_degreeE i : 'n_i = \\rank (socle_base i). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subitvE b1l b1r b2l b2r :\n  (Interval b1l b1r <= Interval b2l b2r) = (b2l <= b1l) && (b1r <= b2r).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltn0 n : n < 0 = false.           ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma allrel0l ys : allrel [::] ys. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma col'Esub j : col' j = colsub (lift j). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rcons_cons x s z : rcons (x :: s) z = x :: rcons s z.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEbool : le = (leq : rel bool). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma monicE p : (p \\is monic) = (lead_coef p == 1). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma similar_diag_row_base m n (P : 'M[F]_(m, n)) (A : 'M_n) :\n  similar_diag (row_base P) A = is_diag_mx (restrictmx P A).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma diagonalizable_for_row_base m n (P : 'M[F]_(m, n)) (A : 'M_n) :\n  diagonalizable_for (row_base P) A = is_diag_mx (restrictmx P A).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma all_nil : all [::] = true. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma tnth0 x t : tnth [tuple of x :: t] ord0 = x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEsig : \\top = Tagged T' (\\top : T' \\top). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma directvE (S : addv_expr) :\n  directv (unwrap S) = (\\dim (unwrap S) == unwrap (addv_dim S)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma codiffEprod x y :\n  codiff x y = (Order.codiff x.1 y.1, Order.codiff x.2 y.2).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma oddS n : odd n.+1 = ~~ odd n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma orbitRs G A : orbit 'Rs G A = rcosets A G. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rem_cons y s : rem (y :: s) = if y == x then s else y :: rem s.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma itv_boundlr bl br x :\n  (x \\in Interval bl br) = (bl <= BLeft x) && (BRight x <= br).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma realE x : (x \\is real) = (0 <= x) || (x <= 0). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma realE x : (x \\is real) = (0 <= x) || (x <= 0). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma succnK : cancel succn predn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma r2_inv : r2^-1 = r2.\n",
  "proof": "Proof. by inv_tac. Qed."
}
{
  "statement": "Lemma abszE (m : int) : `|m| = `|m|%R :> int. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma gt_pinfty b : (+oo < b) = false. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma top_typ_spec T f (x : T) : Itv.spec f Itv.Top x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fmvalN : {morph valA : x / - x >-> x^-1%g}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma fmvalA : {morph valA : x y / x + y >-> (x * y)%g}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rcomplEprod x y z :\n  rcompl x y z = (Order.rcompl x.1 y.1 z.1, Order.rcompl x.2 y.2 z.2).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEord : (le : rel 'I_n) = leq. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma row_mx_const a : row_mx (const_mx a) (const_mx a) = const_mx a.\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma PoszM : {morph Posz : n m / (n * m)%N >-> n * m}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma col_mx_const a : col_mx (const_mx a) (const_mx a) = const_mx a.\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma gtE x y : gt x y = (y < x). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma PoszD : {morph Posz : m n / (m + n)%N >-> m + n}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma PoszD : {morph Posz : n m / (n + m)%N >-> n + m}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma has_nil : has [::] = false. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma colEsub j : col j = colsub (fun=> j). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ucnSn n A : 'Z_n.+1(A) = coset 'Z_n(A) @*^-1 'Z(A / 'Z_n(A)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma idm_morphM A : {in A & , {morph idm A : x y / x * y}}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma eqz_nat (m n : nat) : (m%:Z == n%:Z) = (m == n). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nCdivE (p : nat) : p = p%:R :> divisor. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma allpairs0l f t : [seq f x y | x <- [::], y <- t x] = [::].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma le0s s : [::] <= s :> seq _. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lexi0s s : [::] <= s :> seq T. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma maxEnat : max = maxn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_bseqE s : in_bseq s = s :> seq T. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma absz_nat (n : nat) : `|n| = n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma exprnP x (n : nat) : x ^+ n = x ^ n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma minEnat : min = minn. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEsig : \\bot = Tagged T' (\\bot : T' \\bot). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma abstrX1 (i : nat) : abstrX i 1%T = [::1%T].\n",
  "proof": "Proof. done. Qed."
}
{
  "statement": "Lemma mxdirectE m n (S : mxsum_expr m n) :\n  mxdirect (unwrap S) = (\\rank (unwrap S) == unwrap (mxsum_rank S)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lcnE n A : 'L_n.+1(A) = iter n (fun B => [~: B, A]) A.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma row'Esub i : row' i = rowsub (lift i). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma val_unitV x : val (x^-1 : unit_of)%g = (val x)^-1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma comm_mxE : comm_mx = @GRing.comm _. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma pmulrn (R : zmodType) (x : R) (n : nat) : x *+ n = x *~ n%:Z.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cast_perm_morphM m n eq_m_n :\n  {morph @cast_perm m n eq_m_n : x y / x * y >-> x * y}.\n",
  "proof": "Proof. by subst m. Qed."
}
{
  "statement": "Lemma map_reprE x : rGf x = (rG x)^f. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma membsE n (T : eqType) (bs : n.-bseq T) : mem bs = mem (bseqval bs).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma in_tupleE s : in_tuple s = s :> seq T. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEtlexi : \\top = [tuple \\top | _ < n] :> n.-tuple T. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEtprod : \\top = [tuple \\top | _ < n] :> n.-tuple T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat_spec_zero : nat_spec (Itv.Real `[0, 0]%Z) 0. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expv1 U : (U ^+ 1 = U)%VS. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expv2 U : (U ^+ 2 = U * U)%VS. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma NegzE (n : nat) : Negz n = - n.+1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma NegzE (n : nat) : Negz n = -(n.+1)%:Z. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma block_mxEv : A = col_mx (row_mx Aul Aur) (row_mx Adl Adr).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma expv0 U : (U ^+ 0 = 1)%VS. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rowEsub i : row i = rowsub (fun=> i). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma num_eq : {mono num : x y / x == y}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma codomE : codom f = map f (enum T).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma num_lt : {mono num : x y / (x < y)%O}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma Qint_def (x : rat) : (x \\is a Num.int) = (denq x == 1). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ceilErat (x : rat) : Num.ceil x = - (- numq x %/ denq x)%Z.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma gring_opE a : gring_op a = gring_mx rG (gring_row a).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma num_le : {mono num : x y / (x <= y)%O}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma oACE x y : oop (Some x) (Some y) = some (op x y). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma sgvalM : {in setT &, {morph sgval : x y / x * y}}. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma floorErat (x : rat) : Num.floor x = (numq x %/ denq x)%Z.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma memvE v U : (v \\in U) = (<[v]> <= U)%VS. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma map_cons x s : map (x :: s) = f x :: map s.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rconj_mxE x : rGB x = B *m rG x *m invmx B.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEtlexi : \\bot = [tuple \\bot | _ < n] :> n.-tuple T. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEtprod : \\bot = [tuple \\bot | _ < n] :> n.-tuple T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma block_mx_const a :\n  block_mx (const_mx a) (const_mx a) (const_mx a) (const_mx a) = const_mx a.\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma botEnat : \\bot = 0%N :> nat. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rootE p x : (root p x = (p.[x] == 0)) * ((x \\in root p) = (p.[x] == 0)).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma setactE S a : to^* S a = [set to x a | x in S].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma comparable0r x : (0 >=< x)%R = (x \\is Num.real). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEseq : \\bot = [::] :> seq T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rfix_eqg : rfix_mx rH = rfix_mx rG. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rfix_subg : rfix_mx rH = rfix_mx rG. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma minElt x y : min x y = if x < y then x else y. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEprod : \\top = (\\top, \\top) :> T1 * T2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma topEprodlexi : \\top = (\\top, \\top) :> T1 * T2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ltEord : (lt : rel 'I_n) = (fun m n => m < n)%N. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma maxElt x y : max x y = if x < y then y else x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cons_uniq x s : uniq (x :: s) = (x \\notin s) && uniq s.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma val_ord_tuple : val ord_tuple = enum 'I_n. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nat_pickleK : pcancel id (@Some nat). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma poly_of_qpolyZ (p : {poly %/ h}) a :\n  a *: p = a *: (p : {poly A})  :> {poly A}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma normal_ortho_mx p (A : 'M_(p, n)) : ((A^_|_) '_|_ A).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma poly_of_qpolyD (p q : {poly %/ h}) :\n  p + q= (p : {poly A}) + q :> {poly A}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma ucnE n A : 'Z_n(A) = iter n (fun B => coset B @*^-1 'Z(A / B)) 1.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cast_permKV m n eq_m_n :\n  cancel (cast_perm (esym eq_m_n)) (@cast_perm m n eq_m_n).\n",
  "proof": "Proof. by subst m. Qed."
}
{
  "statement": "Lemma val_unitM x y : val (x * y : unit_of)%g = val x * val y.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cast_permK m n eq_m_n :\n  cancel (@cast_perm m n eq_m_n) (cast_perm (esym eq_m_n)).\n",
  "proof": "Proof. by subst m. Qed."
}
{
  "statement": "Lemma botEprod : \\bot = (\\bot, \\bot) :> T1 * T2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma botEprodlexi : \\bot = (\\bot, \\bot) :> T1 * T2. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma valgM : {in setT &, {morph val : x y / (x : subg_of) * y >-> x * y}}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lift0 (i : 'I_n') : lift ord0 i = i.+1 :> nat. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma unitmxE A : (A \\in unitmx) = (\\det A \\is a GRing.unit).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma mactE x a : morph_action x a = phi a x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma abstrX_mulM (i : nat) : {morph abstrX i : x y / x * y >-> mulpT x y}%T.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma poly_of_qpolyM (p q : {poly %/ h}) :\n  p * q = rmodp ((p : {poly A}) * q) (mk_monic h) :> {poly A}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma vrefl : forall x, P x -> x = x. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma poly_invE p : p ^-1 = if p \\in GRing.unit then (p`_0)^-1%:P else p.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma find_pred0 s : find pred0 s = size s. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leqnSn n : n <= n.+1.             ",
  "proof": "Proof. by elim: n. Qed."
}
{
  "statement": "Lemma drop_cons x s :\n  drop n0 (x :: s) = if n0 is n.+1 then drop n s else x :: s.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma subnDl p m n : (p + m) - (p + n) = m - n.\n",
  "proof": "Proof. by elim: p. Qed."
}
{
  "statement": "Lemma xcfun_rE A chi : xcfun_r A chi = xcfun chi A. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma catrev_catl s t u : catrev (s ++ t) u = catrev t (catrev s u).\n",
  "proof": "Proof. by elim: s u => /=. Qed."
}
{
  "statement": "Lemma eqn_add2l p m n : (p + m == p + n) = (m == n).\n",
  "proof": "Proof. by elim: p. Qed."
}
{
  "statement": "Lemma ubnP m : {n | m < n}.             ",
  "proof": "Proof. by exists m.+1. Qed."
}
{
  "statement": "Lemma leq_add2l p m n : (p + m <= p + n) = (m <= n).\n",
  "proof": "Proof. by elim: p. Qed."
}
{
  "statement": "Lemma uphalf_double n : uphalf n.*2 = n.\n",
  "proof": "Proof. by elim: n => //= n ->. Qed."
}
{
  "statement": "Lemma cats0 s : s ++ [::] = s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma take_cons x s :\n  take n0 (x :: s) = if n0 is n.+1 then x :: (take n s) else [::].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma SubP u : Sub_spec u.\n",
  "proof": "Proof. by elim/(@Sub_rect _ _ sT) : u. Qed."
}
{
  "statement": "Lemma zip_unzip s : zip (unzip1 s) (unzip2 s) = s.\n",
  "proof": "Proof. by elim: s => [|[x y] s /= ->]. Qed."
}
{
  "statement": "Lemma subnn : self_inverse 0 subn. ",
  "proof": "Proof. by elim. Qed."
}
{
  "statement": "Lemma leqnn n : n <= n.                 ",
  "proof": "Proof. by elim: n. Qed."
}
{
  "statement": "Lemma kquo_mxE : kquo_mx = quo_mx (subxx (rker rG)) (rker_norm rG).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma lead_coefE p : lead_coef p = p`_(size p).-1. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma cat_nseq n x s : nseq n x ++ s = ncons n x s.\n",
  "proof": "Proof. by elim: n => //= n ->. Qed."
}
{
  "statement": "Lemma doubleB m n : (m - n).*2 = m.*2 - n.*2.\n",
  "proof": "Proof. by elim: m n => [|m IHm] []. Qed."
}
{
  "statement": "Lemma nat_typ_spec (x : nat) : nat_spec (Itv.Real `[0, +oo[) x.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma coprimep_def p q : coprimep p q = (size (gcdp p q) == 1).\n",
  "proof": "Proof. done. Qed."
}
{
  "statement": "Lemma muln0 : right_zero 0 muln.         ",
  "proof": "Proof. by elim. Qed."
}
{
  "statement": "Lemma leq_eqVlt m n : (m <= n) = (m == n) || (m < n).\n",
  "proof": "Proof. by elim: m n => [|m IHm] []. Qed."
}
{
  "statement": "Lemma filter_predT s : filter predT s = s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma subnDA m n p : n - (m + p) = (n - m) - p.\n",
  "proof": "Proof. by elim: m n => [|m IHm] []. Qed."
}
{
  "statement": "Lemma filter_pred0 s : filter pred0 s = [::]. ",
  "proof": "Proof. by elim: s. Qed."
}
{
  "statement": "Lemma cats1 s z : s ++ [:: z] = rcons s z.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma leqNgt m n : (m <= n) = ~~ (n < m).\n",
  "proof": "Proof. by elim: m n => [|m IHm] []. Qed."
}
{
  "statement": "Lemma pairwise_cons x xs : pairwise (x :: xs) = all (r x) xs && pairwise xs.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma leEsubset A B : (A <= B) = (A \\subset B).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma iterSr n f x : iter n.+1 f x = iter n f (f x).\n",
  "proof": "Proof. by elim: n => //= n <-. Qed."
}
{
  "statement": "Lemma eqn_leq m n : (m == n) = (m <= n <= m).\n",
  "proof": "Proof. by elim: m n => [|m IHm] []. Qed."
}
{
  "statement": "Lemma doubleK : cancel double half.\n",
  "proof": "Proof. by elim=> //= n ->. Qed."
}
{
  "statement": "Lemma last_cons x y s : last x (y :: s) = last y s.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rank_bij : bijective rank. ",
  "proof": "Proof. by exists sig. Qed."
}
{
  "statement": "Lemma sig_bij  : bijective sig.  ",
  "proof": "Proof. by exists rank. Qed."
}
{
  "statement": "Lemma ortho_ortho_mx p (A : 'M_(p, n)) : (A^! '_|_ A)%MS. ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma iterD n m f x : iter (n + m) f x = iter n f (iter m f x).\n",
  "proof": "Proof. by elim: n => //= n ->. Qed."
}
{
  "statement": "Lemma subnKC m n : m <= n -> m + (n - m) = n.\n",
  "proof": "Proof. by elim: m n => [|m IHm] [|n] // /(IHm n) {2}<-. Qed."
}
{
  "statement": "Lemma find_map a s : find a (map s) = find (preim f a) s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma abelianE A : abelian A = (A \\subset 'C(A)). ",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma allpairs0r f s : [seq f x y | x <- s, y <- [::]] = [::].\n",
  "proof": "Proof. by elim: s. Qed."
}
{
  "statement": "Lemma allpairs_cons f x s t :\n  [seq f x y | x <- x :: s, y <- t x] =\n    [seq f x y | y <- t x] ++ [seq f x y | x <- s, y <- t x].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma diffEtprod t1 t2 : t1 `\\` t2 = [tuple tnth t1 i `\\` tnth t2 i | i < n].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma joinEtprod t1 t2 : t1 `|` t2 = [tuple tnth t1 i `|` tnth t2 i | i < n].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma meetEtprod t1 t2 : t1 `&` t2 = [tuple tnth t1 i `&` tnth t2 i | i < n].\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma nconsK n x : cancel (ncons n x) (drop n).\n",
  "proof": "Proof. by elim: n => // -[]. Qed."
}
{
  "statement": "Lemma isom_im : f @* G = H. ",
  "proof": "Proof. by have /isomP[] := isoGH. Qed."
}
{
  "statement": "Lemma lexis0 s : s <= [::] = (s == [::]). ",
  "proof": "Proof. by rewrite leEseqlexi. Qed."
}
{
  "statement": "Lemma les0 s : s <= [::] = (s == [::]). ",
  "proof": "Proof. by rewrite leEseq. Qed."
}
{
  "statement": "Lemma prim_root_natf_neq0 : n%:R != 0 :> R.\n",
  "proof": "Proof. by rewrite prim_root_dvd_eq0. Qed."
}
{
  "statement": "Lemma tofrac_eq0 (p : R): (p%:F == 0) = (p == 0).\n",
  "proof": "Proof. by rewrite tofrac_eq. Qed."
}
{
  "statement": "Lemma eqn_sqr m n : (m ^ 2 == n ^ 2) = (m == n).\n",
  "proof": "Proof. by rewrite eqn_exp2r. Qed."
}
{
  "statement": "Lemma eqr_normN x : (`|x| == - x) = (x <= 0). ",
  "proof": "Proof. by rewrite ler0_def. Qed."
}
{
  "statement": "Lemma numNEsign x : -x = (-1) ^+ (0 < x)%R * `|x|.\n",
  "proof": "Proof. by rewrite -realNEsign. Qed."
}
{
  "statement": "Lemma nderivn1 p : p^`N(1) = p^`().\n",
  "proof": "Proof. by rewrite -[p^`N(1)](nderivn_def 1). Qed."
}
{
  "statement": "Lemma commg_normal G H : [~: G, H] <| G <*> H.\n",
  "proof": "Proof. by rewrite /(_ <| _) commg_sub commg_norm. Qed."
}
{
  "statement": "Lemma mulz2 n : n * 2%:Z = n + n. ",
  "proof": "Proof. by rewrite -mulrzz. Qed."
}
{
  "statement": "Lemma mulr_Nsign_norm x : (-1) ^+ (0 < x)%R * `|x| = - x.\n",
  "proof": "Proof. by rewrite real_mulr_Nsign_norm. Qed."
}
{
  "statement": "Lemma gerBl x y : (x - y <= x) = (0 <= y).\n",
  "proof": "Proof. by rewrite lerBlDl lerDr. Qed."
}
{
  "statement": "Lemma sqr_ge0 x : 0 <= x ^+ 2. ",
  "proof": "Proof. by rewrite exprn_even_ge0. Qed."
}
{
  "statement": "Lemma nderivn0 p : p^`N(0) = p.\n",
  "proof": "Proof. by rewrite -[p^`N(0)](nderivn_def 0). Qed."
}
{
  "statement": "Lemma astabs1 : 'N(1 | to) = D.\n",
  "proof": "Proof. by rewrite astabs_set1 astab1. Qed."
}
{
  "statement": "Lemma leq_sqr m n : (m ^ 2 <= n ^ 2) = (m <= n).\n",
  "proof": "Proof. by rewrite leq_exp2r. Qed."
}
{
  "statement": "Lemma subr_pchar2 x y : x - y = x + y. ",
  "proof": "Proof. by rewrite oppr_pchar2. Qed."
}
{
  "statement": "Lemma ltn_sqr m n : (m ^ 2 < n ^ 2) = (m < n).\n",
  "proof": "Proof. by rewrite ltn_exp2r. Qed."
}
{
  "statement": "Lemma der_normalS n G : G^`(n.+1) <| G^`(n).\n",
  "proof": "Proof. by rewrite sub_der1_normal // der_subS. Qed."
}
{
  "statement": "Lemma ltrz0 n : (n%:~R < 0 :> R) = (n < 0).\n",
  "proof": "Proof. by rewrite pmulrz_rlt0. Qed."
}
{
  "statement": "Lemma lerz0 n : (n%:~R <= 0 :> R) = (n <= 0).\n",
  "proof": "Proof. by rewrite pmulrz_rle0. Qed."
}
{
  "statement": "Lemma ltr0z n : (0 < n%:~R :> R) = (0 < n).\n",
  "proof": "Proof. by rewrite pmulrz_rgt0. Qed."
}
{
  "statement": "Lemma gtrBl x y : (x - y < x) = (0 < y).\n",
  "proof": "Proof. by rewrite ltrBlDl ltrDr. Qed."
}
{
  "statement": "Lemma normrEsign x : `|x| = (-1) ^+ (x < 0)%R * x.\n",
  "proof": "Proof. by rewrite -real_normrEsign. Qed."
}
{
  "statement": "Lemma card_iso2 : #|isometries2| = 2.\n",
  "proof": "Proof. by rewrite cards2 diff_id_sh. Qed."
}
{
  "statement": "Lemma dist0n n : `|0 - n| = n.\n",
  "proof": "Proof. by rewrite distnC distn0. Qed."
}
{
  "statement": "Lemma pFrobenius_aut_int n : (n%:~R)^f = n%:~R.\n",
  "proof": "Proof. by rewrite pFrobenius_autMz pFrobenius_aut1. Qed."
}
{
  "statement": "Lemma memv_pick U : vpick U \\in U. ",
  "proof": "Proof. by rewrite mem_r2v nz_row_sub. Qed."
}
{
  "statement": "Lemma ler0z n : (0 <= n%:~R :> R) = (0 <= n).\n",
  "proof": "Proof. by rewrite pmulrz_rge0. Qed."
}
{
  "statement": "Lemma mul_bin_left n m : m.+1 * 'C(n, m.+1) = (n - m) * 'C(n, m).\n",
  "proof": "Proof. by rewrite -mul_bin_diag mul_bin_down. Qed."
}
{
  "statement": "Lemma natr1 n : n%:R + 1 = n.+1%:R :> R. ",
  "proof": "Proof. by rewrite mulrSr. Qed."
}
{
  "statement": "Lemma dnorm_ge0 u : 0 <= '[u]. ",
  "proof": "Proof. by rewrite dnorm_geiff0. Qed."
}
{
  "statement": "Lemma topEsubset : \\top = setT :> {subset T}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma pFrobenius_aut_nat n : (n%:R)^f = n%:R.\n",
  "proof": "Proof. by rewrite pFrobenius_autMn pFrobenius_aut1. Qed."
}
{
  "statement": "Lemma dvd0z n : (0 %| n)%Z = (n == 0). ",
  "proof": "Proof. by rewrite -absz_eq0 -dvd0n. Qed."
}
{
  "statement": "Lemma lern1 n : n%:R <= 1 :> R = (n <= 1)%N. ",
  "proof": "Proof. by rewrite -ler_nat. Qed."
}
{
  "statement": "Lemma setUACA A B C D : (A :|: B) :|: (C :|: D) = (A :|: C) :|: (B :|: D).\n",
  "proof": "Proof. by rewrite -!setUA (setUCA B). Qed."
}
{
  "statement": "Lemma lerz1 n : (n%:~R <= 1 :> R) = (n <= 1).\n",
  "proof": "Proof. by rewrite -[1]/(1%:~R) ler_int. Qed."
}
{
  "statement": "Lemma mulr_absz (x : R) i : x *+ `|i| = x *~ `|i|.\n",
  "proof": "Proof. by rewrite -abszE. Qed."
}
{
  "statement": "Lemma natr_absz i : `|i|%:R = `|i|%:~R :> R.\n",
  "proof": "Proof. by rewrite -abszE. Qed."
}
{
  "statement": "Lemma eqmodE x y : x == y %[mod_eq e] = e x y.\n",
  "proof": "Proof. by rewrite pi_eq_quot. Qed."
}
{
  "statement": "Lemma dprodWsdC A B G : A \\x B = G -> B ><| A = G.\n",
  "proof": "Proof. by rewrite dprodC => /dprodWsd. Qed."
}
{
  "statement": "Lemma class_transl x y z : x \\in y ^: G -> (x \\in z ^: G) = (y \\in z ^: G).\n",
  "proof": "Proof. by rewrite -!(class_sym z) => /class_eqP->. Qed."
}
{
  "statement": "Lemma ltrz1 n : (n%:~R < 1 :> R) = (n < 1).\n",
  "proof": "Proof. by rewrite -[1]/(1%:~R) ltr_int. Qed."
}
{
  "statement": "Lemma class_rcoset x A y : x ^: (A :* y) = (x ^: A) :^ y.\n",
  "proof": "Proof. by rewrite -class_support_set1r classM. Qed."
}
{
  "statement": "Lemma lerN10 : -1 <= 0 :> R. ",
  "proof": "Proof. by rewrite oppr_le0. Qed."
}
{
  "statement": "Lemma actCJV a b x : to (to x a) b = to (to x (b ^ a^-1)) a.\n",
  "proof": "Proof. by rewrite (actCJ _ a) conjgKV. Qed."
}
{
  "statement": "Lemma leq_imset_card : #|f @: D| <= #|D|.\n",
  "proof": "Proof. by rewrite imset_card leq_image_card. Qed."
}
{
  "statement": "Lemma memV_rcosetV x y : (y^-1 \\in G :* x^-1) = (y \\in x *: G).\n",
  "proof": "Proof. by rewrite -invg_lcoset memV_invg. Qed."
}
{
  "statement": "Lemma class_lcoset x y A : x ^: (y *: A) = (x ^ y) ^: A.\n",
  "proof": "Proof. by rewrite classM class_set1 class_support_set1l. Qed."
}
{
  "statement": "Lemma map_mxB A B : (A - B)^f = A^f - B^f.\n",
  "proof": "Proof. by rewrite map_mxD map_mxN. Qed."
}
{
  "statement": "Lemma ler1n n : 1 <= n%:R :> R = (1 <= n)%N. ",
  "proof": "Proof. by rewrite -ler_nat. Qed."
}
{
  "statement": "Lemma mulr_sign_norm x : (-1) ^+ (x < 0)%R * `|x| = x.\n",
  "proof": "Proof. by rewrite -realEsign. Qed."
}
{
  "statement": "Lemma signr_scalq x : (scalq x < 0) = (x.2 < 0).\n",
  "proof": "Proof. by rewrite -!sgr_cp0 sgr_scalq. Qed."
}
{
  "statement": "Lemma ltr1n n : 1 < n%:R :> R = (1 < n)%N. ",
  "proof": "Proof. by rewrite -ltr_nat. Qed."
}
{
  "statement": "Lemma ltrn1 n : n%:R < 1 :> R = (n < 1)%N. ",
  "proof": "Proof. by rewrite -ltr_nat. Qed."
}
{
  "statement": "Lemma leC x y : (~` x <= ~` y) = (y <= x).\n",
  "proof": "Proof. by rewrite leCx complK. Qed."
}
{
  "statement": "Lemma mulz_Nsign_abs m : ((-1) ^+ (0 < m)%R * `|m|%:Z)%R = - m.\n",
  "proof": "Proof. by rewrite abszE mulr_Nsign_norm. Qed."
}
{
  "statement": "Lemma memV_lcosetV x y : (y^-1 \\in x^-1 *: G) = (y \\in G :* x).\n",
  "proof": "Proof. by rewrite -invg_rcoset memV_invg. Qed."
}
{
  "statement": "Lemma encoded_equivP x : e' (DE (ED x)) x.\n",
  "proof": "Proof. by rewrite /encoded_equiv /= encModEquivP. Qed."
}
{
  "statement": "Lemma subSKn m n : (m.+1 - n).-1 = m - n.\n",
  "proof": "Proof. by rewrite -subnS. Qed."
}
{
  "statement": "Lemma numEsign x : x = (-1) ^+ (x < 0)%R * `|x|.\n",
  "proof": "Proof. by rewrite -realEsign. Qed."
}
{
  "statement": "Lemma commMgR x y z : [~ x * y, z] = [~ x, z] * [~ x, z, y] * [~ y, z].\n",
  "proof": "Proof. by rewrite commMgJ conjg_mulR. Qed."
}
{
  "statement": "Lemma cent_normal A : 'C(A) <| 'N(A).\n",
  "proof": "Proof. by rewrite /(_ <| _) cent_sub cent_norm. Qed."
}
{
  "statement": "Lemma centY A B : 'C(A <*> B) = 'C(A) :&: 'C(B).\n",
  "proof": "Proof. by rewrite cent_gen centU. Qed."
}
{
  "statement": "Lemma all_comm_mx1 f : all_comm_mx [:: f].\n",
  "proof": "Proof. by rewrite /comm_mxb all2rel1. Qed."
}
{
  "statement": "Lemma ltz1D x y : (x < 1 + y) = (x <= y).\n",
  "proof": "Proof. by rewrite -lez1D lerD2l. Qed."
}
{
  "statement": "Lemma morphpreU R S : f @*^-1 (R :|: S) = f @*^-1 R :|: f @*^-1 S.\n",
  "proof": "Proof. by rewrite -setIUr -preimsetU. Qed."
}
{
  "statement": "Lemma rcoset_sym x y : (x \\in G :* y) = (y \\in G :* x).\n",
  "proof": "Proof. by rewrite -!memV_lcosetV lcoset_sym. Qed."
}
{
  "statement": "Lemma ler_distlC x y e : (`|x - y| <= e) = (x - e <= y <= x + e).\n",
  "proof": "Proof. by rewrite distrC ler_distl. Qed."
}
{
  "statement": "Lemma ltr_distlC x y e : (`|x - y| < e) = (x - e < y < x + e).\n",
  "proof": "Proof. by rewrite distrC ltr_distl. Qed."
}
{
  "statement": "Lemma leBC x y : x `\\` y <= ~` y.\n",
  "proof": "Proof. by rewrite leBLR joinxC lex1. Qed."
}
{
  "statement": "Lemma conjYg A B z : (A <*> B) :^z = A :^ z <*> B :^ z.\n",
  "proof": "Proof. by rewrite -genJ conjUg. Qed."
}
{
  "statement": "Lemma eqr_norm_id x : (`|x| == x) = (0 <= x). ",
  "proof": "Proof. by rewrite ger0_def. Qed."
}
{
  "statement": "Lemma natr_indexg_gt0 G B : #|G : B|%:R > 0 :> R.\n",
  "proof": "Proof. by rewrite ltr0n indexg_gt0. Qed."
}
{
  "statement": "Lemma fmod1 : fmod 1 = 0. ",
  "proof": "Proof. by rewrite -fmval0 fmvalK. Qed."
}
{
  "statement": "Lemma ltr_nat m n : (m%:R < n%:R :> R) = (m < n)%N.\n",
  "proof": "Proof. by rewrite ltr_pMn2l. Qed."
}
{
  "statement": "Lemma mem1v K : 1 \\in K. ",
  "proof": "Proof. by rewrite -algid_eq1 algid1. Qed."
}
{
  "statement": "Lemma conj_normC z : `|z|^* = `|z|.\n",
  "proof": "Proof. by rewrite conj_Creal ?normr_real. Qed."
}
{
  "statement": "Lemma intrM m n : (m * n)%:~R = m%:~R * n%:~R :> R.\n",
  "proof": "Proof. by rewrite mulrzA -mulrzr. Qed."
}
{
  "statement": "Lemma addrr_pchar2 x : x + x = 0. ",
  "proof": "Proof. by rewrite -mulr2n mulrn_pchar. Qed."
}
{
  "statement": "Lemma mulz_sign_abs m : ((-1) ^+ (m < 0)%R * `|m|%:Z)%R = m.\n",
  "proof": "Proof. by rewrite abszE mulr_sign_norm. Qed."
}
{
  "statement": "Lemma ltr_int m n : (m%:~R < n%:~R :> R) = (m < n).\n",
  "proof": "Proof. by rewrite ltr_pMz2l. Qed."
}
{
  "statement": "Lemma complB x y : ~` (x `\\` y) = ~` x `|` y.\n",
  "proof": "Proof. by rewrite diffE complI complK. Qed."
}
{
  "statement": "Lemma lcosetE A x : lcoset A x = x *: A.\n",
  "proof": "Proof. by rewrite [_ * _]imset2_set1l. Qed."
}
{
  "statement": "Lemma astab1J x : 'C[x |'J] = 'C[x].\n",
  "proof": "Proof. by rewrite astabJ cent_set1. Qed."
}
{
  "statement": "Lemma ler_nat m n : (m%:R <= n%:R :> R) = (m <= n)%N.\n",
  "proof": "Proof. by rewrite ler_pMn2l. Qed."
}
{
  "statement": "Lemma der_normal n G : G^`(n) <| G.\n",
  "proof": "Proof. by rewrite char_normal ?der_char. Qed."
}
{
  "statement": "Lemma mulrzBl x y n : (x - y) *~ n = x *~ n - y *~ n.\n",
  "proof": "Proof. by rewrite -scalezrE scalerBr. Qed."
}
{
  "statement": "Lemma conjCg A x : (~: A) :^ x = ~: A :^ x.\n",
  "proof": "Proof. by rewrite !conjg_preim preimsetC. Qed."
}
{
  "statement": "Lemma joingG1 G : G <*> 1 = G.\n",
  "proof": "Proof. by rewrite joingC joing1G. Qed."
}
{
  "statement": "Lemma joinBKC x y : (x `|` y) `\\` x = (y `\\` x).\n",
  "proof": "Proof. by rewrite diffUx diffxx join0x. Qed."
}
{
  "statement": "Lemma joinIB y x : (x `&` y) `|` (x `\\` y) = x.\n",
  "proof": "Proof. by rewrite diffErcompl rcomplKU. Qed."
}
{
  "statement": "Lemma conjg_mulR x y : x ^ y = x * [~ x, y].\n",
  "proof": "Proof. by rewrite mulKVg. Qed."
}
{
  "statement": "Lemma ler_int m n : (m%:~R <= n%:~R :> R) = (m <= n).\n",
  "proof": "Proof. by rewrite ler_pMz2l. Qed."
}
{
  "statement": "Lemma cent1J x y : 'C[x ^ y] = 'C[x] :^ y.\n",
  "proof": "Proof. by rewrite -conjg_set1 normJ. Qed."
}
{
  "statement": "Lemma expg_mod_order x i : x ^+ (i %% #[x]) = x ^+ i.\n",
  "proof": "Proof. by rewrite expg_mod // expg_order. Qed."
}
{
  "statement": "Lemma ltn_Sdouble m n : (m.*2.+1 < n.*2) = (m < n).\n",
  "proof": "Proof. by rewrite -doubleS leq_double. Qed."
}
{
  "statement": "Lemma joinxB x y z : x `|` (y `\\` z) = ((x `|` y) `\\` z) `|` (x `&` z).\n",
  "proof": "Proof. by rewrite diffUx joinAC joinBI. Qed."
}
{
  "statement": "Lemma binSn n : 'C(n.+1, n) = n.+1.\n",
  "proof": "Proof. by rewrite -bin_sub ?leqnSn // subSnn bin1. Qed."
}
{
  "statement": "Lemma conjD1g A x : A^# :^ x = (A :^ x)^#.\n",
  "proof": "Proof. by rewrite conjDg conjs1g. Qed."
}
{
  "statement": "Lemma hornerMXaddC p c x : (p * 'X + c%:P).[x] = p.[x] * x + c.\n",
  "proof": "Proof. by rewrite -cons_poly_def horner_cons. Qed."
}
{
  "statement": "Lemma setKUC B A : A :&: (A :|: B) = A.\n",
  "proof": "Proof. by rewrite setUC setKU. Qed."
}
{
  "statement": "Lemma setUUr A B C : A :|: (B :|: C) = (A :|: B) :|: (A :|: C).\n",
  "proof": "Proof. by rewrite !(setUC A) setUUl. Qed."
}
{
  "statement": "Lemma ltzD1 x y : (x < y + 1) = (x <= y).\n",
  "proof": "Proof. by rewrite -lezD1 lerD2r. Qed."
}
{
  "statement": "Lemma dvdp0 d : d %| 0. ",
  "proof": "Proof. by rewrite /dvdp mod0p. Qed."
}
{
  "statement": "Lemma map_poly0 : 0^f = 0.\n",
  "proof": "Proof. by rewrite map_polyE polyseq0. Qed."
}
{
  "statement": "Lemma complU x y : ~` (x `|` y) = ~` x `&` ~` y.\n",
  "proof": "Proof. by rewrite !complEdiff diffxU. Qed."
}
{
  "statement": "Lemma eq_invg1 x : (x^-1 == 1) = (x == 1).\n",
  "proof": "Proof. by rewrite eq_invg_sym invg1. Qed."
}
{
  "statement": "Lemma complI  x y : ~` (x `&` y) = ~` x `|` ~` y.\n",
  "proof": "Proof. by rewrite !complEdiff diffxI. Qed."
}
{
  "statement": "Lemma cycleJ x y : <[x ^ y]> = <[x]> :^ y.\n",
  "proof": "Proof. by rewrite -genJ conjg_set1. Qed."
}
{
  "statement": "Lemma lerB_dist v w : `|v| - `|w| <= `|v - w|.\n",
  "proof": "Proof. by rewrite -[`|w|]normrN lerB_normD. Qed."
}
{
  "statement": "Lemma morphimU A B : f @* (A :|: B) = f @* A :|: f @* B.\n",
  "proof": "Proof. by rewrite -imsetU -setIUr. Qed."
}
{
  "statement": "Lemma astab1_act x a : 'C[to x a | to] = 'C[x | to] :^ a.\n",
  "proof": "Proof. by rewrite -astab_setact /setact imset_set1. Qed."
}
{
  "statement": "Lemma lift0_perm_eq0 s i : (lift0_perm s i == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite (canF_eq (lift0_permK s)) lift0_perm0. Qed."
}
{
  "statement": "Lemma conjUg A B x : (A :|: B) :^ x = A :^ x :|: B :^ x.\n",
  "proof": "Proof. by rewrite !conjg_preim preimsetU. Qed."
}
{
  "statement": "Lemma setUUl A B C : A :|: B :|: C = (A :|: C) :|: (B :|: C).\n",
  "proof": "Proof. by rewrite setUA !(setUAC _ C) -(setUA _ C) setUid. Qed."
}
{
  "statement": "Lemma mulNrz x n : (- x) *~ n = - (x *~ n).\n",
  "proof": "Proof. by rewrite -scalezrE scalerN. Qed."
}
{
  "statement": "Lemma conjgC x y : x * y = y * x ^ y.\n",
  "proof": "Proof. by rewrite mulKVg. Qed."
}
{
  "statement": "Lemma ltrN10 : -1 < 0 :> R. ",
  "proof": "Proof. by rewrite oppr_lt0. Qed."
}
{
  "statement": "Lemma joinBK x y : (y `|` x) `\\` x = (y `\\` x).\n",
  "proof": "Proof. by rewrite diffUx diffxx joinx0. Qed."
}
{
  "statement": "Lemma scalerBr a u v : a *: (u - v) = a *: u - a *: v.\n",
  "proof": "Proof. by rewrite scalerDr scalerN. Qed."
}
{
  "statement": "Lemma morph_Iirr_eq0 i : (morph_Iirr i == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite -!irr_eq1 morph_IirrE cfMorph_eq1. Qed."
}
{
  "statement": "Lemma modnn d : d %% d = 0. ",
  "proof": "Proof. by rewrite [d %% d](modnDr 0) mod0n. Qed."
}
{
  "statement": "Lemma absz_sign s : `|(-1) ^+ s| = 1.\n",
  "proof": "Proof. by rewrite abszX exp1n. Qed."
}
{
  "statement": "Lemma dvd1p m : 1 %| m. ",
  "proof": "Proof. by rewrite /dvdp modp1. Qed."
}
{
  "statement": "Lemma actCJ a b x : to (to x a) b = to (to x b) (a ^ b).\n",
  "proof": "Proof. by rewrite !actM actK. Qed."
}
{
  "statement": "Lemma mulrzBr x m n : x *~ (m - n) = x *~ m - x *~ n.\n",
  "proof": "Proof. by rewrite -scalezrE scalerBl. Qed."
}
{
  "statement": "Lemma ltEprod x y : (x < y) = [&& x != y, x.1 <= y.1 & x.2 <= y.2].\n",
  "proof": "Proof. by rewrite lt_neqAle. Qed."
}
{
  "statement": "Lemma num_abs_eq0 (a : R) : (`|a|%:nng == 0%:nng) = (a == 0).\n",
  "proof": "Proof. by rewrite -normr_eq0. Qed."
}
{
  "statement": "Lemma conjJg x y z : (x ^ y) ^ z = (x ^ z) ^ y ^ z.\n",
  "proof": "Proof. by rewrite 2!conjMg conjVg. Qed."
}
{
  "statement": "Lemma quotient_astabQ H Abar : 'C(Abar | 'Q) / H = 'C(Abar).\n",
  "proof": "Proof. by rewrite astabQ cosetpreK. Qed."
}
{
  "statement": "Lemma map_divp p q : (p %/ q)^f = p^f %/ q^f.\n",
  "proof": "Proof. by rewrite /divp edivp_map edivp_def. Qed."
}
{
  "statement": "Lemma ltn_pmod m d : 0 < d -> m %% d < d.\n",
  "proof": "Proof. by rewrite ltn_mod. Qed."
}
{
  "statement": "Lemma mulrzz m n : m *~ n = m * n. ",
  "proof": "Proof. by rewrite -mulrzr intz. Qed."
}
{
  "statement": "Lemma comm1G A : [~: 1, A] = 1.\n",
  "proof": "Proof. by rewrite commGC commG1. Qed."
}
{
  "statement": "Lemma conjRg x y z : [~ x, y] ^ z = [~ x ^ z, y ^ z].\n",
  "proof": "Proof. by rewrite !conjMg !conjVg. Qed."
}
{
  "statement": "Lemma cardsI A B : #|A :&: B| = (#|A| + #|B| - #|A :|: B|)%N.\n",
  "proof": "Proof. by rewrite -cardsUI addKn. Qed."
}
{
  "statement": "Lemma order_eq1 x : (#[x] == 1%N) = (x == 1).\n",
  "proof": "Proof. by rewrite -trivg_card1 cycle_eq1. Qed."
}
{
  "statement": "Lemma morphpreI R S : f @*^-1 (R :&: S) = f @*^-1 R :&: f @*^-1 S.\n",
  "proof": "Proof. by rewrite -setIIr -preimsetI. Qed."
}
{
  "statement": "Lemma aut_Iirr_eq0 u i : (aut_Iirr u i == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite -!irr_eq1 aut_IirrE cfAut_eq1. Qed."
}
{
  "statement": "Lemma ltrBrDr x y z : (x < y - z) = (x + z < y).\n",
  "proof": "Proof. by rewrite (monoLR (addrNK _) (ltrD2r _)). Qed."
}
{
  "statement": "Lemma mem_Zp x : p > 1 -> x \\in Zp. ",
  "proof": "Proof. by rewrite /Zp => ->. Qed."
}
{
  "statement": "Lemma tcast_id n (eq_nn : n = n) t : tcast eq_nn t = t.\n",
  "proof": "Proof. by rewrite (eq_axiomK eq_nn). Qed."
}
{
  "statement": "Lemma actbyE x a : x \\in R -> a \\in A -> <[nRA]>%act x a = to x a.\n",
  "proof": "Proof. by rewrite /= /actby => -> ->. Qed."
}
{
  "statement": "Lemma cardsD A B : #|A :\\: B| = (#|A| - #|A :&: B|)%N.\n",
  "proof": "Proof. by rewrite -(cardsID B A) addKn. Qed."
}
{
  "statement": "Lemma setUAC A B C : A :|: B :|: C = A :|: C :|: B.\n",
  "proof": "Proof. by rewrite -!setUA (setUC B). Qed."
}
{
  "statement": "Lemma diffE x y : x `\\` y = x `&` ~` y.\n",
  "proof": "Proof. by rewrite complEdiff meetxB meetx1. Qed."
}
{
  "statement": "Lemma scalar_mx_is_trig a : is_trig_mx (a%:M).\n",
  "proof": "Proof. by rewrite is_diag_mx_is_trig// scalar_mx_is_diag. Qed."
}
{
  "statement": "Lemma setUCA A B C : A :|: (B :|: C) = B :|: (A :|: C).\n",
  "proof": "Proof. by rewrite !setUA (setUC B). Qed."
}
{
  "statement": "Lemma centM G H : 'C(G * H) = 'C(G) :&: 'C(H).\n",
  "proof": "Proof. by rewrite -cent_gen genM_join centY. Qed."
}
{
  "statement": "Lemma allrel_consl x xs ys : allrel (x :: xs) ys = all (r x) ys && allrel xs ys.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma Aint_int x : x%:~R \\in Aint. ",
  "proof": "Proof. by rewrite Aint_Cint. Qed."
}
{
  "statement": "Lemma dvdn_pred_predX n e : (n.-1 %| (n ^ e).-1)%N.\n",
  "proof": "Proof. by rewrite predn_exp dvdn_mulr. Qed."
}
{
  "statement": "Lemma rcosetE A x : rcoset A x = A :* x.\n",
  "proof": "Proof. by rewrite [_ * _]imset2_set1r. Qed."
}
{
  "statement": "Lemma lez1D x y : (1 + x <= y) = (x < y).\n",
  "proof": "Proof. by rewrite -subr_gt0 gtz0_ge1 lterBDr. Qed."
}
{
  "statement": "Lemma expr_div_n x y n : (x / y) ^+ n = x ^+ n / y ^+ n.\n",
  "proof": "Proof. by rewrite exprMn exprVn. Qed."
}
{
  "statement": "Lemma joing_idl A B : <<A>> <*> B = A <*> B.\n",
  "proof": "Proof. by rewrite -!(joingC B) joing_idr. Qed."
}
{
  "statement": "Lemma cent_cycle x : 'C(<[x]>) = 'C[x].\n",
  "proof": "Proof. by rewrite cent_gen cent_set1. Qed."
}
{
  "statement": "Lemma geq_uphalf_double m n : (m <= uphalf n) = (m.*2 <= n.+1).\n",
  "proof": "Proof. by rewrite uphalfE geq_half_double. Qed."
}
{
  "statement": "Lemma scalerBl a b v : (a - b) *: v = a *: v - b *: v.\n",
  "proof": "Proof. by rewrite scalerDl scaleNr. Qed."
}
{
  "statement": "Lemma cardsC A : #|A| + #|~: A| = #|T|.\n",
  "proof": "Proof. by rewrite cardsE cardC. Qed."
}
{
  "statement": "Lemma isom_Iirr_eq0 i : (isom_Iirr i == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite -!irr_eq1 isom_IirrE cfIsom_eq1. Qed."
}
{
  "statement": "Lemma divp_addl_mul q r : (q * d + r) %/ d = q + r %/ d.\n",
  "proof": "Proof. by rewrite divpD mulpK. Qed."
}
{
  "statement": "Lemma leq_uphalf_double m n : (uphalf m <= n) = (m <= n.*2).\n",
  "proof": "Proof. by rewrite uphalfE leq_half_double. Qed."
}
{
  "statement": "Lemma ltn_uphalf_double m n : (uphalf m < n) = (m.+1 < n.*2).\n",
  "proof": "Proof. by rewrite uphalfE ltn_half_double. Qed."
}
{
  "statement": "Lemma joinIKC x y : (y `|` x) `&` y = y. ",
  "proof": "Proof. by rewrite joinC joinIK. Qed."
}
{
  "statement": "Lemma cardsID B A : #|A :&: B| + #|A :\\: B| = #|A|.\n",
  "proof": "Proof. by rewrite !cardsE cardID. Qed."
}
{
  "statement": "Lemma meetKI y x : x `&` (x `&` y) = x `&` y.\n",
  "proof": "Proof. by rewrite meetA meetxx. Qed."
}
{
  "statement": "Lemma conjsg_eq1 A x : (A :^ x == 1%g) = (A == 1%g).\n",
  "proof": "Proof. by rewrite (canF_eq (conjsgK x)) conjs1g. Qed."
}
{
  "statement": "Lemma rpred_sign (S : smulClosed R) n : (-1) ^+ n \\in S.\n",
  "proof": "Proof. by rewrite rpredX ?rpredN1. Qed."
}
{
  "statement": "Lemma cardsUI A B : #|A :|: B| + #|A :&: B| = #|A| + #|B|.\n",
  "proof": "Proof. by rewrite !cardsE cardUI. Qed."
}
{
  "statement": "Lemma map_modp p q : (p %% q)^f = p^f %% q^f.\n",
  "proof": "Proof. by rewrite /modp edivp_map edivp_def. Qed."
}
{
  "statement": "Lemma flatten_seq1 s : flatten [seq [:: x] | x <- s] = s.\n",
  "proof": "Proof. by elim: s => //= s0 s ->. Qed."
}
{
  "statement": "Lemma card_Sym : #|Sym| = #|S|`!.\n",
  "proof": "Proof. by rewrite cardsE /= card_perm. Qed."
}
{
  "statement": "Lemma nat1r n : 1 + n%:R = n.+1%:R :> R. ",
  "proof": "Proof. by rewrite mulrS. Qed."
}
{
  "statement": "Lemma mulrN1z x : x *~ (- 1) = - x. ",
  "proof": "Proof. by rewrite -scalezrE scaleN1r. Qed."
}
{
  "statement": "Lemma gtn_uphalf_double m n : (n < uphalf m) = (n.*2 < m).\n",
  "proof": "Proof. by rewrite uphalfE gtn_half_double. Qed."
}
{
  "statement": "Lemma dvdp_map p q : (p^f %| q^f) = (p %| q).\n",
  "proof": "Proof. by rewrite /dvdp -map_modp map_poly_eq0. Qed."
}
{
  "statement": "Lemma card_conjugates A G : #|A :^: G| = #|G : 'N_G(A)|.\n",
  "proof": "Proof. by rewrite card_orbit astab1Js. Qed."
}
{
  "statement": "Lemma cardsCs A : #|A| = #|T| - #|~: A|.\n",
  "proof": "Proof. by rewrite -(cardsC A) addnK. Qed."
}
{
  "statement": "Lemma exprz_pintl m n (hn : 0 <= n) : m%:~R ^ n = (m ^ n)%:~R :> R.\n",
  "proof": "Proof. by rewrite exprz_pMzl // exp1rz. Qed."
}
{
  "statement": "Lemma card_pprimeChar : #|R| = (p ^ n)%N.\n",
  "proof": "Proof. by rewrite /n -cardsT {1}(card_pgroup pprimeChar_pgroup). Qed."
}
{
  "statement": "Lemma dvdnn m : m %| m.\n",
  "proof": "Proof. by rewrite /dvdn modnn. Qed."
}
{
  "statement": "Lemma normr_ge0 v : 0 <= `|v|. ",
  "proof": "Proof. by rewrite ger0_def normr_id. Qed."
}
{
  "statement": "Lemma meetKUC y x : x `|` (y `&` x) = x. ",
  "proof": "Proof. by rewrite joinC meetUK. Qed."
}
{
  "statement": "Lemma leBx x y : x `\\` y <= x.\n",
  "proof": "Proof. by rewrite -[leRHS](joinIB y) leUr. Qed."
}
{
  "statement": "Lemma meetIK y x : (x `&` y) `&` y = x `&` y.\n",
  "proof": "Proof. by rewrite -meetA meetxx. Qed."
}
{
  "statement": "Lemma conjg_Iirr_eq0 i y : (conjg_Iirr i y == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite -!irr_eq1 conjg_IirrE cfConjg_eq1. Qed."
}
{
  "statement": "Lemma cpairg1_center : cpairg1 @* 'Z(H) = 'Z(C).\n",
  "proof": "Proof. by rewrite -cpair1g_center !injm_center // cpair_center_id. Qed."
}
{
  "statement": "Lemma card_lcosets G H : #|lcosets H G| = #|G : H|.\n",
  "proof": "Proof. by rewrite -card_invg invg_lcosets !invGid. Qed."
}
{
  "statement": "Lemma count_map a s : count a (map s) = count (preim f a) s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma lerBrDr x y z : (x <= y - z) = (x + z <= y).\n",
  "proof": "Proof. by rewrite (monoLR (addrNK _) (lerD2r _)). Qed."
}
{
  "statement": "Lemma ler0n n : 0 <= n%:R :> R. ",
  "proof": "Proof. by rewrite -nnegrE rpred_nat. Qed."
}
{
  "statement": "Lemma cardsU A B : #|A :|: B| = (#|A| + #|B| - #|A :&: B|)%N.\n",
  "proof": "Proof. by rewrite -cardsUI addnK. Qed."
}
{
  "statement": "Lemma botEsubset : \\bot = set0 :> {subset T}.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma conjs1g x : 1 :^ x = 1.\n",
  "proof": "Proof. by rewrite conjg_set1 conj1g. Qed."
}
{
  "statement": "Lemma isom_card : #|G| = #|H|.\n",
  "proof": "Proof. by rewrite -isom_im card_injm ?isom_inj. Qed."
}
{
  "statement": "Lemma divrNN x y : (- x) / (- y) = x / y.\n",
  "proof": "Proof. by rewrite invrN mulrNN. Qed."
}
{
  "statement": "Lemma in_setT x : x \\in setTfor.\n",
  "proof": "Proof. by rewrite in_set. Qed."
}
{
  "statement": "Lemma lern0 n : (n%:R <= 0 :> R) = (n == 0).\n",
  "proof": "Proof. by rewrite -[0]/0%:R ler_nat leqn0. Qed."
}
{
  "statement": "Lemma conjIg A B x : (A :&: B) :^ x = A :^ x :&: B :^ x.\n",
  "proof": "Proof. by rewrite !conjg_preim preimsetI. Qed."
}
{
  "statement": "Lemma meetxB x y z : x `&` (y `\\` z) = (x `&` y) `\\` z.\n",
  "proof": "Proof. by rewrite diffIx -{1}[x](joinBI z) meetUl meetIB joinx0. Qed."
}
{
  "statement": "Lemma card_lcoset A x : #|x *: A| = #|A|.\n",
  "proof": "Proof. by rewrite -lcosetE (card_imset _ (mulgI _)). Qed."
}
{
  "statement": "Lemma skew_field_algid1 A : algid A = 1.\n",
  "proof": "Proof. by rewrite (unitr_algid1 (memv_algid A)) ?fieldT ?algid_neq0. Qed."
}
{
  "statement": "Lemma modzN m d : (m %% - d)%Z = (m %% d)%Z.\n",
  "proof": "Proof. by rewrite /modz divzN mulrNN. Qed."
}
{
  "statement": "Lemma mulrz_neq0 x n : x *~ n != 0 = ((n != 0) && (x != 0)).\n",
  "proof": "Proof. by rewrite mulrz_eq0 negb_or. Qed."
}
{
  "statement": "Lemma natrG_neq0 G : #|G|%:R != 0 :> R.\n",
  "proof": "Proof. by rewrite gt_eqF // natrG_gt0. Qed."
}
{
  "statement": "Lemma natr_indexg_neq0 G B : #|G : B|%:R != 0 :> R.\n",
  "proof": "Proof. by rewrite gt_eqF // natr_indexg_gt0. Qed."
}
{
  "statement": "Lemma swapXY_map_polyC p : swapXY p^:P = p%:P.\n",
  "proof": "Proof. by rewrite -swapXY_polyC swapXYK. Qed."
}
{
  "statement": "Lemma sdprod_Iirr_eq0 i : (sdprod_Iirr i == 0) = (i == 0).\n",
  "proof": "Proof. by rewrite -!irr_eq1 sdprod_IirrE cfSdprod_eq1. Qed."
}
{
  "statement": "Lemma setDUl A B C : (A :|: B) :\\: C = (A :\\: C) :|: (B :\\: C).\n",
  "proof": "Proof. by rewrite !setDE setIUl. Qed."
}
{
  "statement": "Lemma classM x A B : x ^: (A * B) = class_support (x ^: A) B.\n",
  "proof": "Proof. by rewrite -!class_support_set1l class_supportM. Qed."
}
{
  "statement": "Lemma meetBx x y z : (x `\\` y) `&` z = (x `&` z) `\\` y.\n",
  "proof": "Proof. by rewrite ![_ `&` z]meetC meetxB. Qed."
}
{
  "statement": "Lemma actmEfun a : a \\in D -> actm to a = to^~ a.\n",
  "proof": "Proof. by rewrite /actm => ->. Qed."
}
{
  "statement": "Lemma meetUKC x y : (y `&` x) `|` y = y. ",
  "proof": "Proof. by rewrite meetC meetUK. Qed."
}
{
  "statement": "Lemma mul_polyC a p : a%:P * p = a *: p.\n",
  "proof": "Proof. by rewrite -scale_polyE. Qed."
}
{
  "statement": "Lemma joinKI y x : x `&` (x `|` y) = x. ",
  "proof": "Proof. by rewrite joinC joinKIC. Qed."
}
{
  "statement": "Lemma finNzRing_gt1 : 1 < #|R|.\n",
  "proof": "Proof. by rewrite -cardsT cardG_gt1 finNzRing_nontrivial. Qed."
}
{
  "statement": "Lemma mul_mx_scalar m n a (A : 'M[R]_(m, n)) : A *m a%:M = a *: A.\n",
  "proof": "Proof. by rewrite scalar_mxC mul_scalar_mx. Qed."
}
{
  "statement": "Lemma cardJg A x : #|A :^ x| = #|A|.\n",
  "proof": "Proof. by rewrite (card_imset _ (conjg_inj x)). Qed."
}
{
  "statement": "Lemma mulrNz x n : x *~ (- n) = - (x *~ n).\n",
  "proof": "Proof. by rewrite -scalezrE scaleNr. Qed."
}
{
  "statement": "Lemma lexU x y z : (x <= join y z) = (x <= y) || (x <= z).\n",
  "proof": "Proof. by rewrite joinEtotal le_max. Qed."
}
{
  "statement": "Lemma joinKIC y x : x `&` (y `|` x) = x. ",
  "proof": "Proof. by rewrite meetC joinIK. Qed."
}
{
  "statement": "Lemma eqrMn2r n x y : (x *+ n == y *+ n) = (n == 0)%N || (x == y).\n",
  "proof": "Proof. by rewrite !(@eq_le _ R) !lerMn2r -orb_andr. Qed."
}
{
  "statement": "Lemma max_card A : #|A| <= #|T|.\n",
  "proof": "Proof. by rewrite -(cardC A) leq_addr. Qed."
}
{
  "statement": "Lemma divgr_eq A B x : x = divgr A B x * remgr A B x.\n",
  "proof": "Proof. by rewrite mulgKV. Qed."
}
{
  "statement": "Lemma joinBIC y x : (x `\\` y) `|` (y `&` x) = x.\n",
  "proof": "Proof. by rewrite meetC joinBI. Qed."
}
{
  "statement": "Lemma raddfZnat n u : h (n%:R *: u) = n%:R *: h u.\n",
  "proof": "Proof. by rewrite !scaler_nat raddfMn. Qed."
}
{
  "statement": "Lemma doubleD m n : (m + n).*2 = m.*2 + n.*2.\n",
  "proof": "Proof. by rewrite -!mul2n mulnDr. Qed."
}
{
  "statement": "Lemma bin2 n : 'C(n, 2) = (n * n.-1)./2.\n",
  "proof": "Proof. by rewrite -[n.-1]bin1 mul_bin_diag -divn2 mulKn. Qed."
}
{
  "statement": "Lemma comm1g x : [~ 1, x] = 1.\n",
  "proof": "Proof. by rewrite -invg_comm commg1 invg1. Qed."
}
{
  "statement": "Lemma dvdn_cardMg G H : #|G * H| %| #|G| * #|H|.\n",
  "proof": "Proof. by rewrite mul_cardG dvdn_mulr. Qed."
}
{
  "statement": "Lemma setDIl A B C : (A :&: B) :\\: C = (A :\\: C) :&: (B :\\: C).\n",
  "proof": "Proof. by rewrite !setDE setIIl. Qed."
}
{
  "statement": "Lemma im_sgval : sgval @* [subg G] = G.\n",
  "proof": "Proof. by rewrite -{2}im_subg subgmK. Qed."
}
{
  "statement": "Lemma leIx x y z : (meet y z <= x) = (y <= x) || (z <= x).\n",
  "proof": "Proof. by rewrite meetEtotal ge_min. Qed."
}
{
  "statement": "Lemma classes_gt0 : 0 < #|classes G|.\n",
  "proof": "Proof. by rewrite (cardsD1 1) classes1. Qed."
}
{
  "statement": "Lemma conjg_eq1 x y : (x ^ y == 1) = (x == 1).\n",
  "proof": "Proof. by rewrite (canF_eq (conjgK _)) conj1g. Qed."
}
{
  "statement": "Lemma lift0_mx_is_perm s : is_perm_mx (lift0_mx (perm_mx s)).\n",
  "proof": "Proof. by rewrite lift0_mx_perm perm_mx_is_perm. Qed."
}
{
  "statement": "Lemma deriv_mulC c p : (c%:P * p)^`() = c%:P * p^`().\n",
  "proof": "Proof. by rewrite !mul_polyC derivZ. Qed."
}
{
  "statement": "Lemma memJ_conjg A x y : (y ^ x \\in A :^ x) = (y \\in A).\n",
  "proof": "Proof. by rewrite mem_conjg conjgK. Qed."
}
{
  "statement": "Lemma numq_int n : numq n%:Q = n. ",
  "proof": "Proof. by rewrite -ratzE. Qed."
}
{
  "statement": "Lemma sgr_ge0 x : (sgr x >= 0) = (x >= 0).\n",
  "proof": "Proof. by rewrite !leNgt sgr_lt0. Qed."
}
{
  "statement": "Lemma dvd0p p : (0 %| p) = (p == 0). ",
  "proof": "Proof. by rewrite /dvdp modp0. Qed."
}
{
  "statement": "Lemma divg_index G H : #|G| %/ #|G : H| = #|G :&: H|.\n",
  "proof": "Proof. by rewrite -(LagrangeI G H) mulnK. Qed."
}
{
  "statement": "Lemma normrMz m (x : R) : `|x *~ m| = `|x| *~ `|m|.\n",
  "proof": "Proof. by rewrite -mulrzl normrM -intr_norm mulrzl. Qed."
}
{
  "statement": "Lemma dvdpp d : d %| d. ",
  "proof": "Proof. by rewrite /dvdp modpp. Qed."
}
{
  "statement": "Lemma natr_Zp (x : 'I_p) : x%:R = x.\n",
  "proof": "Proof. by rewrite Zp_nat valZpK. Qed."
}
{
  "statement": "Lemma horner_polyC u x : u.[x%:P] = swapXY u ^ eval x.\n",
  "proof": "Proof. by rewrite -horner_swapXY swapXYK. Qed."
}
{
  "statement": "Lemma drop_poly_divp n p : drop_poly n p = p %/ 'X^n.\n",
  "proof": "Proof. by rewrite RingMonic.drop_poly_rdivp divpE // monicXn. Qed."
}
{
  "statement": "Lemma meetKU y x : x `|` (x `&` y) = x. ",
  "proof": "Proof. by rewrite meetC meetKUC. Qed."
}
{
  "statement": "Lemma nngE x (uni : unify_itv i (Itv.Real `[0%Z, +oo[)) :\n  (widen_itv x%:num%:itv uni)%:num = x%:num.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma rgdcop0 q : rgdcop q 0 = (q == 0)%:R.\n",
  "proof": "Proof. by rewrite /rgdcop size_poly0. Qed."
}
{
  "statement": "Lemma ler0_def x : (x <= 0) = (`|x| == - x).\n",
  "proof": "Proof. by rewrite ler_def sub0r normrN. Qed."
}
{
  "statement": "Lemma raddfMnat n x : f (n%:R * x) = n%:R * f x.\n",
  "proof": "Proof. by rewrite !mulr_natl raddfMn. Qed."
}
{
  "statement": "Lemma injm_maximal_eq : maximal_eq (f @* M) (f @* G) = maximal_eq M G.\n",
  "proof": "Proof. by rewrite /maximal_eq injm_maximal // injm_eq. Qed."
}
{
  "statement": "Lemma bin_ffactd n m : 'C(n, m) = n ^_ m %/ m`!.\n",
  "proof": "Proof. by rewrite -bin_ffact mulnK ?fact_gt0. Qed."
}
{
  "statement": "Lemma rpred_int (R : pzRingType) (S : subringClosed R) m : m%:~R \\in S.\n",
  "proof": "Proof. by rewrite rpredMz ?rpred1. Qed."
}
{
  "statement": "Lemma sqrt_dnorm_gt0 u : (sqrtC '[u] > 0) = (u != 0).\n",
  "proof": "Proof. by rewrite sqrtC_gt0 dnorm_gt0. Qed."
}
{
  "statement": "Lemma rpred_rat (S : divringClosed R) a : ratr a \\in S.\n",
  "proof": "Proof. by rewrite rpred_div ?rpred_int. Qed."
}
{
  "statement": "Lemma dvd1n m : 1 %| m.\n",
  "proof": "Proof. by rewrite /dvdn modn1. Qed."
}
{
  "statement": "Lemma subr_comparable0 x y : (x - y >=< 0)%R = (x >=< y)%R.\n",
  "proof": "Proof. by rewrite /comparable subr_ge0 subr_le0. Qed."
}
{
  "statement": "Lemma neqr0_sign x : x != 0 -> (-1) ^+ (x < 0)%R = sgr x.\n",
  "proof": "Proof. by rewrite sgr_def  => ->. Qed."
}
{
  "statement": "Lemma gal_id E a : (1 : gal_of E)%g a = a.\n",
  "proof": "Proof. by rewrite /gal_repr repr_coset1 id_lfunE. Qed."
}
{
  "statement": "Lemma classes1 : [1] \\in classes G. ",
  "proof": "Proof. by rewrite -class1G mem_classes. Qed."
}
{
  "statement": "Lemma indexJg G H x : #|G :^ x : H :^ x| = #|G : H|.\n",
  "proof": "Proof. by rewrite -!divgI -conjIg !cardJg. Qed."
}
{
  "statement": "Lemma joinIBC y x : (y `&` x) `|` (x `\\` y) = x.\n",
  "proof": "Proof. by rewrite meetC joinIB. Qed."
}
{
  "statement": "Lemma joinBI y x : (x `\\` y) `|` (x `&` y) = x.\n",
  "proof": "Proof. by rewrite joinC joinIB. Qed."
}
{
  "statement": "Lemma denq_int n : denq n%:Q = 1. ",
  "proof": "Proof. by rewrite -ratzE. Qed."
}
{
  "statement": "Lemma suffix1s s x : suffix [:: x] s -> x \\in s.\n",
  "proof": "Proof. by rewrite -infix1s => /suffixW. Qed."
}
{
  "statement": "Lemma hornerZ c p x : (c *: p).[x] = c * p.[x].\n",
  "proof": "Proof. by rewrite -mul_polyC hornerCM. Qed."
}
{
  "statement": "Lemma adjoin0_deg : adjoin_degree K 0 = 1.\n",
  "proof": "Proof. by rewrite /adjoin_degree addv0 subfield_closed divnn adim_gt0. Qed."
}
{
  "statement": "Lemma scale_polyC a b : a *: b%:P = (a * b)%:P.\n",
  "proof": "Proof. by rewrite -mul_polyC polyCM. Qed."
}
{
  "statement": "Lemma order_dvdn a n : #[a] %| n = (a ^+ n == 1).\n",
  "proof": "Proof. by rewrite (eq_expg_mod_order a n 0) mod0n. Qed."
}
{
  "statement": "Lemma im_cpair_cprod : CH \\* CK = C. ",
  "proof": "Proof. by rewrite cprodE ?im_cpair. Qed."
}
{
  "statement": "Lemma intr_norm m : `|m|%:~R = `|m%:~R : R|.\n",
  "proof": "Proof. by rewrite {2}[m]intEsign rmorphMsign normrMsign abszE normr_nat. Qed."
}
{
  "statement": "Lemma coord_vecof i v : coord e i (vecof v) = v 0 i.\n",
  "proof": "Proof. by rewrite coord_rVof vecofK. Qed."
}
{
  "statement": "Lemma oppr_le0 x : (- x <= 0) = (0 <= x). ",
  "proof": "Proof. by rewrite lerNl oppr0. Qed."
}
{
  "statement": "Lemma subr_ge0 x y : (0 <= x - y) = (y <= x).\n  ",
  "proof": "Proof. by rewrite ge0_def -le_def. Qed."
}
{
  "statement": "Lemma subSn m n : m <= n -> n.+1 - m = (n - m).+1.\n",
  "proof": "Proof. by rewrite -add1n => /addnBA <-. Qed."
}
{
  "statement": "Lemma has_map a s : has a (map s) = has (preim f a) s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma setIDAC A B C : (A :\\: B) :&: C = (A :&: C) :\\: B.\n",
  "proof": "Proof. by rewrite !setDE setIAC. Qed."
}
{
  "statement": "Lemma astab_normal S : 'C(S | to) <| 'N(S | to).\n",
  "proof": "Proof. by rewrite /normal astab_sub astab_norm. Qed."
}
{
  "statement": "Lemma isom_inj : 'injm f. ",
  "proof": "Proof. by have /isomP[] := isoGH. Qed."
}
{
  "statement": "Lemma cfuniG : '1_G = 1.\n",
  "proof": "Proof. by rewrite -[G in '1_G]genGid. Qed."
}
{
  "statement": "Lemma leq_bump2 h i j : (bump h i <= bump h j) = (i <= j).\n",
  "proof": "Proof. by rewrite leq_bump bumpK. Qed."
}
{
  "statement": "Lemma mul_conjC_ge0 x : 0 <= x * x^*.\n",
  "proof": "Proof. by rewrite -normCK exprn_ge0. Qed."
}
{
  "statement": "Lemma path_map x s : path e' (f x) (map f s) = path (relpre f e') x s.\n",
  "proof": "Proof. by elim: s x => //= y s <-. Qed."
}
{
  "statement": "Lemma p_groupJ P x : p_group (P :^ x) = p_group P.\n",
  "proof": "Proof. by rewrite /p_group cardJg pgroupJ. Qed."
}
{
  "statement": "Lemma take_poly_modp n p : take_poly n p = p %% 'X^n.\n",
  "proof": "Proof. by rewrite RingMonic.take_poly_rmodp modpE // monicXn. Qed."
}
{
  "statement": "Lemma addNz : left_inverse (0:int) oppz addz. ",
  "proof": "Proof. by do 3?elim. Qed."
}
{
  "statement": "Lemma sqrt_dnorm_eq0 u : (sqrtC '[u] == 0) = (u == 0).\n",
  "proof": "Proof. by rewrite sqrtC_eq0 dnorm_eq0. Qed."
}
{
  "statement": "Lemma oppr_gt0 x : (0 < - x) = (x < 0). ",
  "proof": "Proof. by rewrite ltrNr oppr0. Qed."
}
{
  "statement": "Lemma group_set_rotations : group_set rotations.\n",
  "proof": "Proof. by rewrite -rot_is_rot group_set_rot. Qed."
}
{
  "statement": "Lemma permJ s t x : (s ^ t) (t x) = t (s x).\n",
  "proof": "Proof. by rewrite !permM permK. Qed."
}
{
  "statement": "Lemma sqrt_dnorm_ge0 u : 0 <= sqrtC '[u].\n",
  "proof": "Proof. by rewrite sqrtC_ge0 dnorm_ge0. Qed."
}
{
  "statement": "Lemma modZp x : x %% p = x.\n",
  "proof": "Proof. by rewrite modn_small ?ltn_ord. Qed."
}
{
  "statement": "Lemma linear0r : f z 0 = 0. ",
  "proof": "Proof. by rewrite raddf0. Qed."
}
{
  "statement": "Lemma map_polyC_eq0 p : (p^:P == 0) = (p == 0).\n",
  "proof": "Proof. by rewrite -!size_poly_eq0 size_map_polyC. Qed."
}
{
  "statement": "Lemma divrN x y : x / (- y) = - (x / y).\n",
  "proof": "Proof. by rewrite invrN mulrN. Qed."
}
{
  "statement": "Lemma scalar_mx_is_diag a : is_diag_mx (a%:M).\n",
  "proof": "Proof. by rewrite -diag_const_mx diag_mx_is_diag. Qed."
}
{
  "statement": "Lemma hornerXn x n : ('X^n).[x] = x ^+ n.\n",
  "proof": "Proof. by rewrite horner_exp_comm /comm_poly hornerX. Qed."
}
{
  "statement": "Lemma conjg1 x : x ^ 1 = x.\n",
  "proof": "Proof. by rewrite conjgE commute1 mulKg. Qed."
}
{
  "statement": "Lemma rmorph_sign n : f ((- 1) ^+ n) = (- 1) ^+ n.\n",
  "proof": "Proof. by rewrite rmorphXn /= rmorphN1. Qed."
}
{
  "statement": "Lemma egcdp0 p : egcdp p 0 = (1, 0). ",
  "proof": "Proof. by rewrite /egcdp size_poly0. Qed."
}
{
  "statement": "Lemma natrG_gt0 G : #|G|%:R > 0 :> R.\n",
  "proof": "Proof. by rewrite ltr0n cardG_gt0. Qed."
}
{
  "statement": "Lemma distn0 n : `|n - 0| = n.\n",
  "proof": "Proof. by rewrite subr0 absz_nat. Qed."
}
{
  "statement": "Lemma lez0_nat n : n <= 0 :> int = (n == 0 :> nat). ",
  "proof": "Proof. by elim: n. Qed."
}
{
  "statement": "Lemma pFrobenius_aut1 : 1^f = 1.\n",
  "proof": "Proof. by rewrite f'E expr1n. Qed."
}
{
  "statement": "Lemma rpred_nat (S : semiringClosed R) n : n%:R \\in S.\n",
  "proof": "Proof. by rewrite rpredMn ?rpred1. Qed."
}
{
  "statement": "Lemma card_rcoset A x : #|A :* x| = #|A|.\n",
  "proof": "Proof. by rewrite -rcosetE (card_imset _ (mulIg _)). Qed."
}
{
  "statement": "Lemma dvdn_indexg G H : #|G : H| %| #|G|.\n",
  "proof": "Proof. by rewrite -(LagrangeI G H) dvdn_mull. Qed."
}
{
  "statement": "Lemma rpredN1 (S : smulClosed R) : -1 \\in S.\n",
  "proof": "Proof. by rewrite rpredN rpred1. Qed."
}
{
  "statement": "Lemma prefix1s s x : prefix [:: x] s -> x \\in s.\n",
  "proof": "Proof. by rewrite -infix1s => /prefixW. Qed."
}
{
  "statement": "Lemma normr0 : `|0 : V| = 0.\n",
  "proof": "Proof. by rewrite -(mulr0n 0) normrMn mulr0n. Qed."
}
{
  "statement": "Lemma zpolyEprim p : p = zcontents p *: zprimitive p.\n",
  "proof": "Proof. by rewrite map_poly_divzK // -dvdz_contents. Qed."
}
{
  "statement": "Lemma comp_polyXr p : p \\Po 'X = p.\n",
  "proof": "Proof. by rewrite -{2}/(idfun p) poly_initial. Qed."
}
{
  "statement": "Lemma oppr_lt0 x : (- x < 0) = (0 < x). ",
  "proof": "Proof. by rewrite ltrNl oppr0. Qed."
}
{
  "statement": "Lemma prefix_refl s : prefix s s. ",
  "proof": "Proof. by rewrite prefixE take_size. Qed."
}
{
  "statement": "Lemma card_rVabelem L : #|rV_E @* L| = #|L|.\n",
  "proof": "Proof. by rewrite card_injm ?rVabelem_injm. Qed."
}
{
  "statement": "Lemma LdivJ n A x : 'Ldiv_n(A :^ x) = 'Ldiv_n(A) :^ x.\n",
  "proof": "Proof. by rewrite conjIg LdivT_J. Qed."
}
{
  "statement": "Lemma setKIC B A : A :|: (A :&: B) = A.\n",
  "proof": "Proof. by rewrite setIC setKI. Qed."
}
{
  "statement": "Lemma doubleMr m n : (m * n).*2 = m * n.*2.\n",
  "proof": "Proof. by rewrite -!muln2 mulnA. Qed."
}
{
  "statement": "Lemma setDIr A B C : A :\\: (B :&: C) = (A :\\: B) :|: (A :\\: C).\n",
  "proof": "Proof. by rewrite !setDE setCI setIUr. Qed."
}
{
  "statement": "Lemma subr_ge0 x y : (0 <= x - y) = (y <= x).\n",
  "proof": "Proof. by rewrite ger0_def -ler_def. Qed."
}
{
  "statement": "Lemma ltrBlDr x y z : (x - y < z) = (x < z + y).\n",
  "proof": "Proof. by rewrite (monoLR (addrK _) (ltrD2r _)). Qed."
}
{
  "statement": "Lemma k1AHom V (f : 'AEnd(L)) : kHom 1 V f.\n",
  "proof": "Proof. by rewrite k1HomE ahomWin. Qed."
}
{
  "statement": "Lemma poly_XmY_eq0 p : (poly_XmY p == 0) = (p == 0).\n",
  "proof": "Proof. by rewrite -!size_poly_eq0 size_poly_XmY. Qed."
}
{
  "statement": "Lemma odd_permV s : odd_perm s^-1 = odd_perm s.\n",
  "proof": "Proof. by rewrite -{2}(mulgK s s) !odd_permM -addbA addKb. Qed."
}
{
  "statement": "Lemma subfx_inj_root : subfx_inj subfx_root = z.\n",
  "proof": "Proof. by rewrite subfx_inj_eval // map_polyX hornerX. Qed."
}
{
  "statement": "Lemma meetIKC y x : y `&` x `&` y = x `&` y.\n",
  "proof": "Proof. by rewrite meetAC meetC meetxx. Qed."
}
{
  "statement": "Lemma addSnnS m n : m.+1 + n = m + n.+1. ",
  "proof": "Proof. by rewrite addnS. Qed."
}
{
  "statement": "Lemma setDUr A B C : A :\\: (B :|: C) = (A :\\: B) :&: (A :\\: C).\n",
  "proof": "Proof. by rewrite !setDE setCU setIIr. Qed."
}
{
  "statement": "Lemma mem_seq_sub_enum x : x \\in seq_sub_enum.\n",
  "proof": "Proof. by rewrite mem_undup mem_pmap -valK map_f ?ssvalP. Qed."
}
{
  "statement": "Lemma horner_morphX : horner_morph cfu 'X = u.\n",
  "proof": "Proof. by rewrite /horner_morph map_polyX hornerX. Qed."
}
{
  "statement": "Lemma mk_monic_neq0 : mk_monic h != 0.\n",
  "proof": "Proof. by rewrite -size_poly_gt0 size_mk_monic_gt0. Qed."
}
{
  "statement": "Lemma swapXY_Y : swapXY 'Y = 'X.\n",
  "proof": "Proof. by rewrite swapXY_polyC map_polyX. Qed."
}
{
  "statement": "Lemma im_eltm : eltm dvd_y_x @* <[x]> = <[y]>.\n",
  "proof": "Proof. by rewrite morphim_cycle ?cycle_id //= eltm_id. Qed."
}
{
  "statement": "Lemma poly_XaY_eq0 p : (poly_XaY p == 0) = (p == 0).\n",
  "proof": "Proof. by rewrite -!size_poly_eq0 size_poly_XaY. Qed."
}
{
  "statement": "Lemma comparablexx x : x >=< x.\n",
  "proof": "Proof. by rewrite /comparable lexx. Qed."
}
{
  "statement": "Lemma preim_permV s S : s^-1 @^-1: S = s @: S.\n",
  "proof": "Proof. by rewrite -im_permV invgK. Qed."
}
{
  "statement": "Lemma ceil_le_int x n : x <= n%:~R = (ceil x <= n).\n",
  "proof": "Proof. by rewrite real_ceil_le_int_tmp. Qed."
}
{
  "statement": "Lemma mulpz p n : p *~ n = n%:~R *: p.\n",
  "proof": "Proof. by rewrite -mul_polyC polyCMz polyC1 mulrzl. Qed."
}
{
  "statement": "Lemma mem_seq1 x y : (x \\in [:: y]) = (x == y).\n",
  "proof": "Proof. by rewrite in_cons orbF. Qed."
}
{
  "statement": "Lemma leq_mod m d : m %% d <= m.\n",
  "proof": "Proof. by rewrite [leqRHS](divn_eq m d) leq_addl. Qed."
}
{
  "statement": "Lemma porbit_id s x : x \\in porbit s x.\n",
  "proof": "Proof. by rewrite -{1}[x]perm1 (mem_porbit s 0). Qed."
}
{
  "statement": "Lemma leCx x y : (~` x <= y) = (~` y <= x).\n",
  "proof": "Proof. by rewrite !complEdiff !leBLR joinC. Qed."
}
{
  "statement": "Lemma formNl u v : '[- u, v] = - '[u, v].\n",
  "proof": "Proof. by rewrite -scaleN1r formZl mulN1r. Qed."
}
{
  "statement": "Lemma card2 x y : #|pred2 x y| = (x != y).+1.\n",
  "proof": "Proof. by rewrite cardU1 card1 addn1. Qed."
}
{
  "statement": "Lemma natrX n k : (n ^ k)%:R = n%:R ^+ k :> R.\n",
  "proof": "Proof. by rewrite exprMn_n expr1n. Qed."
}
{
  "statement": "Lemma map_polyXn n : ('X^n)^f = 'X^n.\n",
  "proof": "Proof. by rewrite rmorphXn /= map_polyX. Qed."
}
{
  "statement": "Lemma gdcop_map p q : (gdcop p q)^f = gdcop p^f q^f.\n",
  "proof": "Proof. by rewrite /gdcop gdcop_rec_map !size_map_poly. Qed."
}
{
  "statement": "Lemma block_mxKur : ursubmx A = Aur.\n",
  "proof": "Proof. by rewrite /ursubmx col_mxKu row_mxKr. Qed."
}
{
  "statement": "Lemma sgz_eq0 x : (sgz x == 0) = (x == 0).\n",
  "proof": "Proof. by rewrite sgz_cp0. Qed."
}
{
  "statement": "Lemma lerBlDr x y z : (x - y <= z) = (x <= z + y).\n",
  "proof": "Proof. by rewrite (monoLR (addrK _) (lerD2r _)). Qed."
}
{
  "statement": "Lemma sizeY_eq0 u : (sizeY u == 0) = (u == 0).\n",
  "proof": "Proof. by rewrite sizeYE size_poly_eq0 swapXY_eq0. Qed."
}
{
  "statement": "Lemma linear0l : f 0 z = 0. ",
  "proof": "Proof. by rewrite -applyrE raddf0. Qed."
}
{
  "statement": "Lemma eqseq_all (T : eqType) (s t : seq T) : (s == t) = all2 eq_op s t.\n",
  "proof": "Proof. by elim: s t => [|x s +] [|y t]//= => <-. Qed."
}
{
  "statement": "Lemma block_mxKdl : dlsubmx A = Adl.\n",
  "proof": "Proof. by rewrite /dlsubmx col_mxKd row_mxKl. Qed."
}
{
  "statement": "Lemma invr_le0 x : (x^-1 <= 0) = (x <= 0).\n",
  "proof": "Proof. by rewrite -oppr_cp0 -invrN invr_ge0 oppr_cp0. Qed."
}
{
  "statement": "Lemma sgr_le0 x : (sgr x <= 0) = (x <= 0).\n",
  "proof": "Proof. by rewrite !le_eqVlt sgr_eq0 sgr_lt0. Qed."
}
{
  "statement": "Lemma natr_int n : n%:R \\is a int_num.\n",
  "proof": "Proof. by rewrite intrE natr_nat. Qed."
}
{
  "statement": "Lemma vecof_mul M u : vecof e' (u *m M) = hommx M (vecof e u).\n",
  "proof": "Proof. by rewrite hommxE vecofK. Qed."
}
{
  "statement": "Lemma block_mxKdr : drsubmx A = Adr.\n",
  "proof": "Proof. by rewrite /drsubmx col_mxKd row_mxKr. Qed."
}
{
  "statement": "Lemma leq_subr m n : n - m <= n.\n",
  "proof": "Proof. by rewrite leq_subLR leq_addl. Qed."
}
{
  "statement": "Lemma sqrn_eq1 x : x <= 0 -> (x ^+ 2 == 1) = (x == -1).\n",
  "proof": "Proof. by rewrite -sqrrN -oppr_ge0 -eqr_oppLR => /sqrp_eq1. Qed."
}
{
  "statement": "Lemma ge0_def x : (0 <= x) = (`|x| == x).\n  ",
  "proof": "Proof. by rewrite le_def subr0. Qed."
}
{
  "statement": "Lemma algCreal_Im x : 'Im x \\is Creal.\n",
  "proof": "Proof. by rewrite Creal_Im. Qed."
}
{
  "statement": "Lemma index_cent1 x : #|G : 'C_G[x]| = #|x ^: G|.\n",
  "proof": "Proof. by rewrite -astab1J -card_orbit. Qed."
}
{
  "statement": "Lemma morphim_qisom A : qisom @* (A / G) = A / H.\n",
  "proof": "Proof. by rewrite morphim_restrm setTI morphim_factm. Qed."
}
{
  "statement": "Lemma comm_polyX x : comm_poly 'X x.\n",
  "proof": "Proof. by rewrite /comm_poly !hornerX. Qed."
}
{
  "statement": "Lemma sgzN1 : sgz (-1 : R) = -1. ",
  "proof": "Proof. by rewrite ltr0_sgz // ltrN10. Qed."
}
{
  "statement": "Lemma rVof_mul M u : rVof e u *m M = rVof e' (hommx M u).\n",
  "proof": "Proof. by rewrite hommxE vecofK. Qed."
}
{
  "statement": "Lemma NirrE : Nirr G = #|classes G|.\n",
  "proof": "Proof. by rewrite /pred_Nirr (cardD1 [1]) classes1. Qed."
}
{
  "statement": "Lemma abszEsg m : (`|m|%:Z = sgz m * m)%R.\n",
  "proof": "Proof. by rewrite -sgrz -normrEsg. Qed."
}
{
  "statement": "Lemma distrC v w : `|v - w| = `|w - v|.\n",
  "proof": "Proof. by rewrite -opprB normrN. Qed."
}
{
  "statement": "Lemma rpredBC u v : u - v \\in S = (v - u \\in S).\n",
  "proof": "Proof. by rewrite -rpredN opprB. Qed."
}
{
  "statement": "Lemma derivXsubC (a : R) : ('X - a%:P)^`() = 1.\n",
  "proof": "Proof. by rewrite derivB derivX derivC subr0. Qed."
}
{
  "statement": "Lemma invr_ge0 x : (0 <= x^-1) = (0 <= x).\n",
  "proof": "Proof. by rewrite !le0r invr_gt0 invr_eq0. Qed."
}
{
  "statement": "Lemma Sylow1 G : Sylow G 1.\n",
  "proof": "Proof. by rewrite /Sylow p_group1 Hall1. Qed."
}
{
  "statement": "Lemma conjDg A B x : (A :\\: B) :^ x = A :^ x :\\: B :^ x.\n",
  "proof": "Proof. by rewrite !setDE !(conjCg, conjIg). Qed."
}
{
  "statement": "Lemma distnn m : `|m - m| = 0.\n",
  "proof": "Proof. by rewrite subrr. Qed."
}
{
  "statement": "Lemma natrM m n : (m * n)%:R = m%:R * n%:R :> R.\n",
  "proof": "Proof. by rewrite mulrnA mulr_natr. Qed."
}
{
  "statement": "Lemma det_mx11  (M : 'M[R]_1) : \\det M = M 0 0.\n",
  "proof": "Proof. by rewrite {1}[M]mx11_scalar det_scalar. Qed."
}
{
  "statement": "Lemma expgSr x n : x ^+ n.+1 = x ^+ n * x.\n",
  "proof": "Proof. by rewrite -addn1 expgD expg1. Qed."
}
{
  "statement": "Lemma intEsg m : m = (sgz m * `|m|%:Z)%R.\n",
  "proof": "Proof. by rewrite -sgrz -numEsg. Qed."
}
{
  "statement": "Lemma mul_conjC_eq0 x : (x * x^* == 0) = (x == 0).\n",
  "proof": "Proof. by rewrite -normCK expf_eq0 normr_eq0. Qed."
}
{
  "statement": "Lemma map_char_poly : fp (char_poly A) = char_poly A^f.\n",
  "proof": "Proof. by rewrite -det_map_mx map_char_poly_mx. Qed."
}
{
  "statement": "Lemma sqrMi x: (i * x) ^+ 2 = - x ^+ 2.\n",
  "proof": "Proof. by rewrite exprMn sqrtK mulN1r. Qed."
}
{
  "statement": "Lemma pi_mono1 : p a = pq (equal_val x). ",
  "proof": "Proof. by rewrite !piE. Qed."
}
{
  "statement": "Lemma numq_gt0 x : (0 < numq x) = (0 < x).\n",
  "proof": "Proof. by rewrite !ltNge numq_le0. Qed."
}
{
  "statement": "Lemma cfun1Egen x : '1_G x = (x \\in G)%:R.\n",
  "proof": "Proof. by rewrite cfunElock andb_idr // => /class_subG->. Qed."
}
{
  "statement": "Lemma scalerCA k x y : k *: x * y = x * (k *: y).\n",
  "proof": "Proof. by rewrite -scalerAl scalerAr. Qed."
}
{
  "statement": "Lemma leqVgt m n : (m <= n) || (n < m). ",
  "proof": "Proof. by rewrite leqNgt orNb. Qed."
}
{
  "statement": "Lemma mem_cycle x i : x ^+ i \\in <[x]>.\n",
  "proof": "Proof. by rewrite groupX // cycle_id. Qed."
}
{
  "statement": "Lemma memv_pi1 U V w : (addv_pi1 U V) w \\in U.\n",
  "proof": "Proof. by rewrite (subvP (diffvSl U V)) ?memv_pi. Qed."
}
{
  "statement": "Lemma gdcop0 q : gdcop q 0 = (q == 0)%:R.\n",
  "proof": "Proof. by rewrite /gdcop size_poly0. Qed."
}
{
  "statement": "Lemma invg_rcoset x : (G :* x)^-1 = x^-1 *: G.\n",
  "proof": "Proof. by rewrite invMg invGid invg_set1. Qed."
}
{
  "statement": "Lemma preim_iinv A B y fAy : preim f B (@iinv A y fAy) = B y.\n",
  "proof": "Proof. by rewrite /= f_iinv. Qed."
}
{
  "statement": "Lemma genD1id A : <<A^#>> = <<A>>.\n",
  "proof": "Proof. by rewrite genD1 ?group1. Qed."
}
{
  "statement": "Lemma floor_ge_int x n : n%:~R <= x = (n <= floor x).\n",
  "proof": "Proof. by rewrite real_floor_ge_int_tmp. Qed."
}
{
  "statement": "Lemma infix_cons s x : infix s (x :: s).\n",
  "proof": "Proof. by rewrite -cat1s suffix_infix. Qed."
}
{
  "statement": "Lemma hornerX x : 'X.[x] = x.\n",
  "proof": "Proof. by rewrite /horner polyseqX /= !simp. Qed."
}
{
  "statement": "Lemma numq_lt0 x : (numq x < 0) = (x < 0).\n",
  "proof": "Proof. by rewrite !ltNge numq_ge0. Qed."
}
{
  "statement": "Lemma invg_lcoset x : (x *: G)^-1 = G :* x^-1.\n",
  "proof": "Proof. by rewrite invMg invGid invg_set1. Qed."
}
{
  "statement": "Lemma abelem_rV_1 : ErV 1 = 0%R. ",
  "proof": "Proof. by rewrite morph1. Qed."
}
{
  "statement": "Lemma cardC1 x : #|predC1 x| = #|T|.-1.\n",
  "proof": "Proof. by rewrite -(cardC (pred1 x)) card1. Qed."
}
{
  "statement": "Lemma invr0 : 0^-1 = 0 :> R.\n",
  "proof": "Proof. by rewrite invr_out ?unitr0. Qed."
}
{
  "statement": "Lemma mxval_grootXn k : mxval (groot ^+ k) = A ^+ k.\n",
  "proof": "Proof. by rewrite rmorphXn /= mxval_groot. Qed."
}
{
  "statement": "Lemma diffUK y x : (x `\\` y) `|` y = x `|` y.\n",
  "proof": "Proof. by rewrite joinC diffKU joinC. Qed."
}
{
  "statement": "Lemma algCreal_Re x : 'Re x \\is Creal.\n",
  "proof": "Proof. by rewrite Creal_Re. Qed."
}
{
  "statement": "Lemma ger0_def x : (0 <= x) = (`|x| == x).\n",
  "proof": "Proof. by rewrite ler_def subr0. Qed."
}
{
  "statement": "Lemma formNr u v : '[u, - v] = - '[u, v].\n",
  "proof": "Proof. by rewrite -scaleN1r formZr rmorphN1 mulN1r. Qed."
}
{
  "statement": "Lemma setTDsym A : ~: A = setT :\\: A.\n",
  "proof": "Proof. by rewrite setTD. Qed."
}
{
  "statement": "Lemma setIIr A B C : A :&: (B :&: C) = (A :&: B) :&: (A :&: C).\n",
  "proof": "Proof. by rewrite !(setIC A) setIIl. Qed."
}
{
  "statement": "Lemma sqrr_sign n : ((-1) ^+ n) ^+ 2 = 1 :> R.\n",
  "proof": "Proof. by rewrite exprAC sqrrN !expr1n. Qed."
}
{
  "statement": "Lemma block_mxKul : ulsubmx A = Aul.\n",
  "proof": "Proof. by rewrite /ulsubmx col_mxKu row_mxKl. Qed."
}
{
  "statement": "Lemma Crat_rat (a : rat) : QtoC a \\in Crat.\n",
  "proof": "Proof. by rewrite unfold_in ratCK. Qed."
}
{
  "statement": "Lemma joinBx x y z : (y `\\` z) `|` x = ((y `|` x) `\\` z) `|` (z `&` x).\n",
  "proof": "Proof. by rewrite ![_ `|` x]joinC ![_ `&` x]meetC joinxB. Qed."
}
{
  "statement": "Lemma lt01 : 0 < 1.\n  ",
  "proof": "Proof. by rewrite lt_def oner_neq0 le01. Qed."
}
{
  "statement": "Lemma pi_mono2 : r a b = rq (equal_val x) (equal_val y). ",
  "proof": "Proof. by rewrite !piE. Qed."
}
{
  "statement": "Lemma normr_sign s : `|(-1) ^+ s : R| = 1.\n",
  "proof": "Proof. by rewrite normrX normrN1 expr1n. Qed."
}
{
  "statement": "Lemma eq_mulVg1 x y : (x == y) = (x^-1 * y == 1 :> T).\n",
  "proof": "Proof. by rewrite -eq_invg_mul invgK. Qed."
}
{
  "statement": "Lemma rectC_mull x y z : z * (x + 'i * y) = z * x + 'i * (z * y).\n",
  "proof": "Proof. by rewrite mulrDr mulrCA. Qed."
}
{
  "statement": "Lemma map_poly_eq0 p : (p^f == 0) = (p == 0).\n",
  "proof": "Proof. by rewrite -!size_poly_eq0 size_map_poly. Qed."
}
{
  "statement": "Lemma froots_id (x : T) : froots id x.\n",
  "proof": "Proof. by rewrite /roots -fconnect_id connect_root. Qed."
}
{
  "statement": "Lemma mkseqP s : mkseq_spec s s.\n",
  "proof": "Proof. by rewrite -[s]mkseq_nth; constructor. Qed."
}
{
  "statement": "Lemma horner_morphC a : horner_morph cfu a%:P = f a.\n",
  "proof": "Proof. by rewrite /horner_morph map_polyC hornerC. Qed."
}
{
  "statement": "Lemma sqrrB x y : (x - y) ^+ 2 = x ^+ 2 - x * y *+ 2 + y ^+ 2.\n",
  "proof": "Proof. by rewrite sqrrD mulrN mulNrn sqrrN. Qed."
}
{
  "statement": "Lemma cardIg_divn G H : #|G :&: H| = (#|G| * #|H|) %/ #|G * H|.\n",
  "proof": "Proof. by rewrite mul_cardG mulKn // (cardD1 (1 * 1)) mem_mulg. Qed."
}
{
  "statement": "Lemma mk_monicE : mk_monic h = h.\n",
  "proof": "Proof. by rewrite /mk_monic !hI. Qed."
}
{
  "statement": "Lemma morphpre_invm A : invm @*^-1 A = f @* A.\n",
  "proof": "Proof. by rewrite morphpre_factm morphpre_idm morphimIdom. Qed."
}
{
  "statement": "Lemma scalerMzl a v n : (a *: v) *~ n = (a *~ n) *: v.\n",
  "proof": "Proof. by rewrite -mulrzl -scaler_int scalerA. Qed."
}
{
  "statement": "Lemma subxx (pT : predType T) (pA : pT) : pA \\subset pA.\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma poly_XmY0 : poly_XmY 0 = 0.\n",
  "proof": "Proof. by rewrite /poly_XmY rmorph0 comp_poly0. Qed."
}
{
  "statement": "Lemma setIACA A B C D : (A :&: B) :&: (C :&: D) = (A :&: C) :&: (B :&: D).\n",
  "proof": "Proof. by rewrite -!setIA (setICA B). Qed."
}
{
  "statement": "Lemma mem_ord_enum i : i \\in ord_enum.\n",
  "proof": "Proof. by rewrite -(mem_map ord_inj) val_ord_enum mem_iota ltn_ord. Qed."
}
{
  "statement": "Lemma mul0rz n : 0 *~ n = 0 :> M.\n",
  "proof": "Proof. by rewrite -scalezrE scaler0. Qed."
}
{
  "statement": "Lemma horner2_swapXY u x y : (swapXY u).[x, y] = u.[y, x].\n",
  "proof": "Proof. by rewrite horner_swapXY -{1}(hornerC y x) horner_map. Qed."
}
{
  "statement": "Lemma mulr_sg_norm x : sg x * `|x| = x. ",
  "proof": "Proof. by rewrite -numEsg. Qed."
}
{
  "statement": "Lemma setID A B : A :&: B :|: A :\\: B = A.\n",
  "proof": "Proof. by rewrite setDE -setIUr setUCr setIT. Qed."
}
{
  "statement": "Lemma polyOverXnsubC n c : ('X^n - c%:P \\is a polyOver S) = (c \\in S).\n",
  "proof": "Proof. by rewrite rpredBl ?polyOverXn// ?polyOverC. Qed."
}
{
  "statement": "Lemma root_minCpoly x : root (minCpoly x) x.\n",
  "proof": "Proof. by have [p [-> _] ->] := minCpolyP x. Qed."
}
{
  "statement": "Lemma setCD A B : ~: (A :\\: B) = ~: A :|: B.\n",
  "proof": "Proof. by rewrite !setDE setCI setCK. Qed."
}
{
  "statement": "Lemma invr_lt0 x : (x^-1 < 0) = (x < 0).\n",
  "proof": "Proof. by rewrite -oppr_cp0 -invrN invr_gt0 oppr_cp0. Qed."
}
{
  "statement": "Lemma alg_num_field (Qz : fieldExtType rat) a : a%:A = ratr a :> Qz.\n",
  "proof": "Proof. by rewrite -in_algE fmorph_eq_rat. Qed."
}
{
  "statement": "Lemma foldr_map s : foldr f z0 (map h s) = foldr (fun x z => f (h x) z) z0 s.\n",
  "proof": "Proof. by elim: s => //= x s ->. Qed."
}
{
  "statement": "Lemma group_set_conjG x : group_set (G :^ x).\n",
  "proof": "Proof. by rewrite group_setJ groupP. Qed."
}
{
  "statement": "Lemma doubleMl m n : (m * n).*2 = m.*2 * n.\n",
  "proof": "Proof. by rewrite -!mul2n mulnA. Qed."
}
{
  "statement": "Lemma mulrz_eq0 x n : (x *~ n == 0) = ((n == 0) || (x == 0)).\n",
  "proof": "Proof. by rewrite -mulrzl mulf_eq0 intr_eq0. Qed."
}
{
  "statement": "Lemma leIidl x y : (x <= x `&` y) = (x <= y).\n",
  "proof": "Proof. by rewrite lexI lexx. Qed."
}
{
  "statement": "Lemma commgV : [~ x, y^-1] = [~ x, y]^-1.\n",
  "proof": "Proof. by rewrite -invg_comm commVg -(invg_comm x y) ?invgK. Qed."
}
{
  "statement": "Lemma mem_rVabelem u : rV_E u \\in E.\n",
  "proof": "Proof. by rewrite -im_rVabelem mem_morphim. Qed."
}
{
  "statement": "Lemma leq_subLR m n p : (m - n <= p) = (m <= n + p).\n",
  "proof": "Proof. by rewrite -subn_eq0 -subnDA. Qed."
}
{
  "statement": "Lemma poly_XaY0 : poly_XaY 0 = 0.\n",
  "proof": "Proof. by rewrite /poly_XaY rmorph0 comp_poly0. Qed."
}
{
  "statement": "Lemma indexgg G : #|G : G| = 1%N.\n",
  "proof": "Proof. by rewrite -divgS // divnn cardG_gt0. Qed."
}
{
  "statement": "Lemma cycle_id x : x \\in <[x]>.\n",
  "proof": "Proof. by rewrite mem_gen // set11. Qed."
}
{
  "statement": "Lemma suffixs0 s : suffix s [::] = (s == [::]).\n",
  "proof": "Proof. by rewrite /suffix prefixs0 -!nilpE rev_nilp. Qed."
}
{
  "statement": "Lemma leq_divM m d : m %/ d * d <= m.\n",
  "proof": "Proof. by rewrite [leqRHS](divn_eq m d) leq_addr. Qed."
}
{
  "statement": "Lemma oppr_ge0 x : (0 <= - x) = (x <= 0). ",
  "proof": "Proof. by rewrite lerNr oppr0. Qed."
}
{
  "statement": "Lemma joing1G G : 1 <*> G = G.\n",
  "proof": "Proof. by rewrite -gen0 joing_idl /joing set0U genGid. Qed."
}
{
  "statement": "Lemma allrel0r xs : allrel xs [::]. ",
  "proof": "Proof. by elim: xs. Qed."
}
{
  "statement": "Lemma polyOverXnaddC n c : ('X^n + c%:P \\is a polyOver S) = (c \\in S).\n",
  "proof": "Proof. by rewrite rpredDl ?polyOverXn// ?polyOverC. Qed."
}
{
  "statement": "Lemma rdvd1p m : rdvdp 1 m. ",
  "proof": "Proof. by rewrite /rdvdp rmodp1. Qed."
}
{
  "statement": "Lemma pprimeChar_scaleAr (a : 'F_p) (x y : R) : a *: (x * y) = x * (a *: y).\n",
  "proof": "Proof. by rewrite ![a *: _]mulr_natl mulrnAr. Qed."
}
{
  "statement": "Lemma invr_eq1 x : (x^-1 == 1) = (x == 1).\n",
  "proof": "Proof. by rewrite (inv_eq invrK) invr1. Qed."
}
{
  "statement": "Lemma trace_mx11 (A : 'M_1) : \\tr A = A 0 0.\n",
  "proof": "Proof. by rewrite {1}[A]mx11_scalar mxtrace_scalar. Qed."
}
{
  "statement": "Lemma meetKIC y x : x `&` (y `&` x) = x `&` y.\n",
  "proof": "Proof. by rewrite meetC meetIK meetC. Qed."
}
{
  "statement": "Lemma kquo_mx_faithful : mx_faithful kquo_repr.\n",
  "proof": "Proof. by rewrite /mx_faithful rker_quo trivg_quotient. Qed."
}
{
  "statement": "Lemma ffunMnE f n x : (f *+ n) x = f x *+ n.\n",
  "proof": "Proof. by rewrite -[n]card_ord -!sumr_const sum_ffunE. Qed."
}
{
  "statement": "Lemma normC_def x : `|x| = sqrtC (x * x^* ).\n",
  "proof": "Proof. by rewrite -normCK sqrCK. Qed."
}
{
  "statement": "Lemma comparable_sym x y : (y >=< x) = (x >=< y).\n",
  "proof": "Proof. by rewrite /comparable orbC. Qed."
}
{
  "statement": "Lemma sgz1 : sgz (1 : R) = 1. ",
  "proof": "Proof. by rewrite gtr0_sgz // ltr01. Qed."
}
{
  "statement": "Lemma trivg_quotient : H / H = 1.\n",
  "proof": "Proof. by rewrite -[X in X / _]ker_coset /quotient morphim_ker. Qed."
}
{
  "statement": "Lemma normalG G : G <| 'N(G).\n",
  "proof": "Proof. by rewrite /(G <| _) normG subxx. Qed."
}
{
  "statement": "Lemma subrKA z x y : (x - z) + (z + y) = x + y.\n",
  "proof": "Proof. by rewrite addrA addrNK. Qed."
}
{
  "statement": "Lemma coprimeNz m n : coprimez (- m) n = coprimez m n.\n",
  "proof": "Proof. by rewrite coprimezE abszN. Qed."
}
{
  "statement": "Lemma coprimezN m n : coprimez m (- n) = coprimez m n.\n",
  "proof": "Proof. by rewrite coprimezE abszN. Qed."
}
{
  "statement": "Lemma mem_remgr K B x : x \\in K * B -> remgr K B x \\in B.\n",
  "proof": "Proof. by rewrite -remgrP => /setIP[]. Qed."
}
{
  "statement": "Lemma map_polyXsubC x : ('X - x%:P)^f = 'X - (f x)%:P.\n",
  "proof": "Proof. by rewrite raddfB/= map_polyX map_polyC. Qed."
}
{
  "statement": "Lemma normalJ A B x : (A :^ x <| B :^ x) = (A <| B).\n",
  "proof": "Proof. by rewrite /normal normJ !conjSg. Qed."
}
{
  "statement": "Lemma orderV x : #[x^-1] = #[x].\n",
  "proof": "Proof. by rewrite /order cycleV. Qed."
}
{
  "statement": "Lemma comp_poly0r p : p \\Po 0 = (p`_0)%:P.\n",
  "proof": "Proof. by rewrite comp_polyCr horner_coef0. Qed."
}
{
  "statement": "Lemma mem_sub_enum u : u \\in sub_enum.\n",
  "proof": "Proof. by rewrite mem_pmap_sub -enumT mem_enum. Qed."
}
{
  "statement": "Lemma infix_refl s : infix s s.\n",
  "proof": "Proof. by rewrite infixE infix_indexss// drop0 take_size. Qed."
}
{
  "statement": "Lemma conjg_Rmul x y : x ^ y = [~ y, x^-1] * x.\n",
  "proof": "Proof. by rewrite commgEr invgK mulgKV. Qed."
}
{
  "statement": "Lemma intr_sg m : (sgr m)%:~R = sgr (m%:~R) :> R.\n",
  "proof": "Proof. by rewrite sgrz -sgz_int -sgrEz. Qed."
}
{
  "statement": "Lemma sgrN1 : sg (-1) = -1 :> R. ",
  "proof": "Proof. by rewrite ltr0_sg // ltrN10. Qed."
}
{
  "statement": "Lemma leq_maxr m n : n <= maxn m n. ",
  "proof": "Proof. by rewrite maxnC leq_maxl. Qed."
}
{
  "statement": "Lemma ratr_int z : ratr z%:~R = z%:~R.\n",
  "proof": "Proof. by rewrite /ratr numq_int denq_int divr1. Qed."
}
{
  "statement": "Lemma amE u v : am u v = v * u. ",
  "proof": "Proof. by rewrite lfunE. Qed."
}
{
  "statement": "Lemma joinCx  x : ~` x `|` x = \\top.\n",
  "proof": "Proof. by rewrite joinC joinxC. Qed."
}
{
  "statement": "Lemma abszMsign s m : `|((-1) ^+ s * m)%R| = `|m|.\n",
  "proof": "Proof. by rewrite abszM absz_sign mul1n. Qed."
}
{
  "statement": "Lemma dom_qactJ H : qact_dom 'J H = 'N(H).\n",
  "proof": "Proof. by rewrite qact_domE ?subsetT ?astabsJ. Qed."
}
{
  "statement": "Lemma scalerMzr a v n : (a *: v) *~ n = a *: (v *~ n).\n",
  "proof": "Proof. by rewrite -!scaler_int !scalerA mulrzr mulrzl. Qed."
}
{
  "statement": "Lemma commgEr x y : [~ x, y] = y^-1 ^ x * y.\n",
  "proof": "Proof. by rewrite -!mulgA. Qed."
}
{
  "statement": "Lemma stablemxC x : stablemx V x%:M.\n",
  "proof": "Proof. by rewrite mul_mx_scalar scalemx_sub. Qed."
}
{
  "statement": "Lemma joinxC  x :  x `|` ~` x = \\top.\n",
  "proof": "Proof. by rewrite complEdiff diffKU joinx1. Qed."
}
{
  "statement": "Lemma polyOverXaddC c : ('X + c%:P \\in polyOver S) = (c \\in S).\n",
  "proof": "Proof. by rewrite rpredDl ?polyOverX ?polyOverC. Qed."
}
{
  "statement": "Lemma oppC_rect x y : - (x + 'i * y)  = - x + 'i * (- y).\n",
  "proof": "Proof. by rewrite mulrN -opprD. Qed."
}
{
  "statement": "Lemma Gauss_dvdzr m n p : coprimez m n -> (m %| n * p)%Z = (m %| p)%Z.\n",
  "proof": "Proof. by rewrite dvdzE abszM => /Gauss_dvdr->. Qed."
}
{
  "statement": "Lemma polyOverXsubC c : ('X - c%:P \\in polyOver S) = (c \\in S).\n",
  "proof": "Proof. by rewrite rpredBl ?polyOverX ?polyOverC. Qed."
}
{
  "statement": "Lemma normal_refl G : G <| G.\n",
  "proof": "Proof. by rewrite /(G <| _) normG subxx. Qed."
}
{
  "statement": "Lemma cardMg_divn G H : #|G * H| = (#|G| * #|H|) %/ #|G :&: H|.\n",
  "proof": "Proof. by rewrite mul_cardG mulnK ?cardG_gt0. Qed."
}
{
  "statement": "Lemma commgMR x y z : [~ x, y * z] = [~ x, z] * [~ x, y] * [~ x, y, z].\n",
  "proof": "Proof. by rewrite commgMJ conjg_mulR mulgA. Qed."
}
{
  "statement": "Lemma der_abelian n G : abelian (G^`(n) / G^`(n.+1)).\n",
  "proof": "Proof. by rewrite sub_der1_abelian // der_subS. Qed."
}
{
  "statement": "Lemma addv_pi2_proj U V w (pi2 := addv_pi2 U V) : pi2 (pi2 w) = pi2 w.\n",
  "proof": "Proof. by rewrite addv_pi2_id ?memv_pi2. Qed."
}
{
  "statement": "Lemma normrX n x : `|x ^+ n| = `|x| ^+ n.\n",
  "proof": "Proof. by rewrite -(card_ord n) -!prodr_const normr_prod. Qed."
}
{
  "statement": "Lemma hommx1 : hommx e e 1%:M = \\1%VF.\n",
  "proof": "Proof. by rewrite -mxof1 ?(basis_free e_basis)// mxofK. Qed."
}
{
  "statement": "Lemma rdvdp0 d : rdvdp d 0. ",
  "proof": "Proof. by rewrite /rdvdp rmod0p. Qed."
}
{
  "statement": "Lemma catrevE s t : catrev s t = rev s ++ t.\n",
  "proof": "Proof. by rewrite -catrev_catr. Qed."
}
{
  "statement": "Lemma npolyP (p q : {poly_n R}) : nth 0 p =1 nth 0 q <-> p = q.\n",
  "proof": "Proof. by split => [/polyP/val_inj|->]. Qed."
}
{
  "statement": "Lemma mem_conjgV A x y : (y \\in A :^ x^-1) = (y ^ x \\in A).\n",
  "proof": "Proof. by rewrite mem_conjg invgK. Qed."
}
{
  "statement": "Lemma cfReg_char : cfReg G \\is a character.\n",
  "proof": "Proof. by rewrite -cfReprReg cfRepr_char. Qed."
}
{
  "statement": "Lemma setDDr A B C : A :\\: (B :\\: C) = (A :\\: B) :|: (A :&: C).\n",
  "proof": "Proof. by rewrite !setDE setCI setIUr setCK. Qed."
}
{
  "statement": "Lemma mem_image A x : (f x \\in image f A) = (x \\in A).\n",
  "proof": "Proof. by rewrite mem_map ?mem_enum. Qed."
}
{
  "statement": "Lemma map_polyXaddC x :  ('X + x%:P)^f = 'X + (f x)%:P.\n",
  "proof": "Proof. by rewrite raddfD/= map_polyX map_polyC. Qed."
}
{
  "statement": "Lemma commgX : [~ x, y ^+ i] = [~ x, y] ^+ i.\n",
  "proof": "Proof. by rewrite -invg_comm commXg -(invg_comm x y) ?expgVn ?invgK. Qed."
}
{
  "statement": "Lemma disj_leC x y : (x `&` y == \\bot) = (x <= ~` y).\n",
  "proof": "Proof. by rewrite -diff_eq0 diffE complK. Qed."
}
{
  "statement": "Lemma oppr_ge0 x : (0 <= - x) = (x <= 0).\n",
  "proof": "Proof. by rewrite -sub0r subr_ge0. Qed."
}
{
  "statement": "Lemma rdvd0p n : rdvdp 0 n = (n == 0). ",
  "proof": "Proof. by rewrite /rdvdp rmodp0. Qed."
}
{
  "statement": "Lemma lcosetM A x y : (x * y) *: A = x *: (y *: A).\n",
  "proof": "Proof. by rewrite -mulg_set1 mulgA. Qed."
}
{
  "statement": "Lemma normr_denq x : `|denq x| = denq x. ",
  "proof": "Proof. by rewrite gtr0_norm. Qed."
}
{
  "statement": "Lemma rmorphN1 : f (- 1) = (- 1). ",
  "proof": "Proof. by rewrite rmorphN rmorph1. Qed."
}
{
  "statement": "Lemma normalField_normal : 'Gal(E / M) <| 'Gal(E / K).\n",
  "proof": "Proof. by rewrite -normalField_ker ker_normal. Qed."
}
{
  "statement": "Lemma faithfulR G : [faithful G, on G | 'R].\n",
  "proof": "Proof. by rewrite /faithful astabR subsetIr. Qed."
}
{
  "statement": "Lemma gcdp1 p : gcdp p 1 %= 1.\n",
  "proof": "Proof. by rewrite (eqp_ltrans (gcdpC _ _)) gcd1p. Qed."
}
{
  "statement": "Lemma rker_normal : rker <| G.\n",
  "proof": "Proof. by rewrite /normal rstab_sub rker_norm. Qed."
}
{
  "statement": "Lemma maptrmx_sesqui : M^t theta = (-1) ^+ eps *: M.\n",
  "proof": "Proof.\nby rewrite trmx_sesqui map_mxZ rmorph_sign -map_mx_comp eq_map_mx_id.\nQed."
}
{
  "statement": "Lemma denq_norm x : denq `|x| = denq x.\n",
  "proof": "Proof. by rewrite normrEsign denq_mulr_sign. Qed."
}
{
  "statement": "Lemma aspacef_subproof : is_aspace fullv.\n",
  "proof": "Proof. by rewrite /is_aspace subvf has_algid1 ?memvf. Qed."
}
{
  "statement": "Lemma exprSr x n : x ^+ n.+1 = x ^+ n * x.\n",
  "proof": "Proof. by rewrite -addn1 exprD expr1. Qed."
}
{
  "statement": "Lemma mulr_sign_lt0 (b : bool) x :\n  ((-1) ^+ b * x < 0) = (x != 0) && (b (+) (x < 0)%R).\n",
  "proof": "Proof. by rewrite mulr_lt0 signr_lt0 signr_eq0. Qed."
}
{
  "statement": "Lemma card_Fp : #|'F_p| = p.\n",
  "proof": "Proof. by rewrite card_ord Fp_cast. Qed."
}
{
  "statement": "Lemma perm_mxM n (s t : 'S_n) : perm_mx (s * t) = perm_mx s *m perm_mx t.\n",
  "proof": "Proof. by rewrite -row_permE -row_permM. Qed."
}
{
  "statement": "Lemma gal_cap U V : 'Gal(V / U) = 'Gal(V / U :&: V).\n",
  "proof": "Proof. by rewrite /galoisG -capvA capvv. Qed."
}
{
  "statement": "Lemma morphim1 : f @* 1 = 1.\n",
  "proof": "Proof. by rewrite morphim_set1 ?morph1. Qed."
}
{
  "statement": "Lemma scalp_map p q : scalp p^f q^f = scalp p q.\n",
  "proof": "Proof. by rewrite /scalp edivp_map edivp_def. Qed."
}
{
  "statement": "Lemma suffix_cons s x : suffix s (x :: s).\n",
  "proof": "Proof. by rewrite /suffix rev_cons prefix_rcons. Qed."
}
{
  "statement": "Lemma generator_order a b : generator <[a]> b -> #[a] = #[b].\n",
  "proof": "Proof. by rewrite /order => /(<[a]> =P _)->. Qed."
}
{
  "statement": "Lemma divgI G H : #|G| %/ #|G :&: H| = #|G : H|.\n",
  "proof": "Proof. by rewrite -(LagrangeI G H) mulKn ?cardG_gt0. Qed."
}
{
  "statement": "Lemma adjoin_degreeE : n = \\dim_K <<K; x>>.\n",
  "proof": "Proof. by rewrite [n]prednK // divn_gt0 ?adim_gt0 // dimvS ?subv_adjoin. Qed."
}
{
  "statement": "Lemma card_Aut_cycle : #|Aut <[a]>| = totient #[a].\n",
  "proof": "Proof. by rewrite -(card_isog Zp_unit_isog) card_units_Zp. Qed."
}
{
  "statement": "Lemma geq_minr m n : minn m n <= n. ",
  "proof": "Proof. by rewrite minnC geq_minl. Qed."
}
{
  "statement": "Lemma ltxU x y z : (x < join y z) = (x < y) || (x < z).\n",
  "proof": "Proof. by rewrite !ltNge leUx negb_and. Qed."
}
{
  "statement": "Lemma morph_dom_groupset : group_set (f @: D).\n",
  "proof": "Proof. by rewrite -morphimEdom groupP. Qed."
}
{
  "statement": "Lemma perm_mxEsub n s : @perm_mx n s = rowsub s 1%:M.\n",
  "proof": "Proof. by rewrite /perm_mx row_permEsub. Qed."
}
{
  "statement": "Lemma coprime0p p : coprimep 0 p = (p %= 1).\n",
  "proof": "Proof. by rewrite coprimep_sym coprimep0. Qed."
}
{
  "statement": "Lemma sort_Sub (x : qT) : x = Sub (sortPx x).\n",
  "proof": "Proof. by rewrite /Sub reprK. Qed."
}
{
  "statement": "Lemma ltUx x y z : (join y z < x) = (y < x) && (z < x).\n",
  "proof": "Proof. by rewrite !ltNge lexU negb_or. Qed."
}
{
  "statement": "Lemma mulrBr x y z : x * (y - z) = x * y - x * z.\n",
  "proof": "Proof. by rewrite mulrDr mulrN. Qed."
}
{
  "statement": "Lemma card0 : #|@pred0 T| = 0. ",
  "proof": "Proof. by rewrite cardE enum0. Qed."
}
{
  "statement": "Lemma hornerXsubC a x : ('X - a%:P).[x] = x - a.\n",
  "proof": "Proof. by rewrite hornerD hornerN hornerC hornerX. Qed."
}
{
  "statement": "Lemma morphim_quotm A : quotm @* (A / H) = f @* A / f @* H.\n",
  "proof": "Proof. by rewrite morphim_factm morphim_restrm morphim_comp morphimIdom. Qed."
}
{
  "statement": "Lemma swapXY_eq0 u : (swapXY u == 0) = (u == 0).\n",
  "proof": "Proof. by rewrite (inv_eq swapXYK) raddf0. Qed."
}
{
  "statement": "Lemma cardsXn : #|setXn| = \\prod_i #|A i|.\n",
  "proof": "Proof. by rewrite cardsE card_family foldrE big_map big_enum. Qed."
}
{
  "statement": "Lemma comm_poly0 x : comm_poly 0 x.\n",
  "proof": "Proof. by rewrite /comm_poly !horner0 !simp. Qed."
}
{
  "statement": "Lemma mul_vec_lin_row A u : mxvec A *m lin_mul_row u = u *m A.\n",
  "proof": "Proof. by rewrite mul_rV_lin1 /= mxvecK. Qed."
}
{
  "statement": "Lemma addn_gt0 m n : (0 < m + n) = (0 < m) || (0 < n).\n",
  "proof": "Proof. by rewrite !lt0n -negb_and addn_eq0. Qed."
}
{
  "statement": "Lemma horner_poly_XmY p v : (poly_XmY p).[v] = p \\Po (v * 'X).\n",
  "proof": "Proof. by rewrite horner_comp !hornerE. Qed."
}
{
  "statement": "Lemma meetxC  x :  x `&` ~` x = \\bot.\n",
  "proof": "Proof. by rewrite complEdiff diffKI. Qed."
}
{
  "statement": "Lemma formN u : '[- u] = '[u].\n",
  "proof": "Proof. by rewrite formNr formNl opprK. Qed."
}
{
  "statement": "Lemma lift_perm_id i j s : lift_perm i j s i = j.\n",
  "proof": "Proof. by rewrite permE /lift_perm_fun unlift_none. Qed."
}
{
  "statement": "Lemma invMG G H : (G * H)^-1 = H * G.\n",
  "proof": "Proof. by rewrite invMg !invGid. Qed."
}
{
  "statement": "Lemma splitr x : x = x / 2%:R + x / 2%:R.\n",
  "proof": "Proof. by rewrite -mulr2n -mulr_natr mulfVK //= pnatr_eq0. Qed."
}
{
  "statement": "Lemma setIDA A B C : A :&: (B :\\: C) = (A :&: B) :\\: C.\n",
  "proof": "Proof. by rewrite !setDE setIA. Qed."
}
{
  "statement": "Lemma mem_mask x m s : x \\in mask m s -> x \\in s.\n",
  "proof": "Proof. by rewrite -!has_pred1 => /has_mask. Qed."
}
{
  "statement": "Lemma ltxI x y z : (x < meet y z) = (x < y) && (x < z).\n",
  "proof": "Proof. by rewrite !ltNge leIx negb_or. Qed."
}
{
  "statement": "Lemma Iirr1_neq0 : G :!=: 1%g -> inord 1 != 0 :> Iirr G.\n",
  "proof": "Proof. by rewrite -classes_gt1 -NirrE -val_eqE /= => /inordK->. Qed."
}
{
  "statement": "Lemma hnormN u : '[- u] = '[u].\n",
  "proof": "Proof. by rewrite linearNl linearNr opprK. Qed."
}
{
  "statement": "Lemma horner_poly_XaY p v : (poly_XaY p).[v] = p \\Po (v + 'X).\n",
  "proof": "Proof. by rewrite horner_comp !hornerE. Qed."
}
{
  "statement": "Lemma form_eq0C u v : ('[u, v] == 0) = ('[v, u] == 0).\n",
  "proof": "Proof. by rewrite formC mulf_eq0 signr_eq0 /= fmorph_eq0. Qed."
}
{
  "statement": "Lemma addv_pi1_proj U V w (pi1 := addv_pi1 U V) : pi1 (pi1 w) = pi1 w.\n",
  "proof": "Proof. by rewrite daddv_pi_proj // capv_diff. Qed."
}
{
  "statement": "Lemma rcosetM A x y : A :* (x * y) = A :* x :* y.\n",
  "proof": "Proof. by rewrite -mulg_set1 mulgA. Qed."
}
{
  "statement": "Lemma invg_ffun i (x : gTn) : x^-1 i = (x i)^-1.\n",
  "proof": "Proof. by rewrite ffunE. Qed."
}
{
  "statement": "Lemma mulnn m : m * m = m ^ 2.\n",
  "proof": "Proof. by rewrite !expnS muln1. Qed."
}
{
  "statement": "Lemma sgr1 : sg 1 = 1 :> R. ",
  "proof": "Proof. by rewrite gtr0_sg // ltr01. Qed."
}
{
  "statement": "Lemma image_iinv A y (fTy : y \\in codom f) :\n  (y \\in image f A) = (iinv fTy \\in A).\n",
  "proof": "Proof. by rewrite -mem_image ?f_iinv. Qed."
}
{
  "statement": "Lemma fixsetKn k : iter k F fixset = fixset.\n",
  "proof": "Proof. by rewrite iter_fix. Qed."
}
{
  "statement": "Lemma scaleN1r v : - 1 *: v = - v.\n",
  "proof": "Proof. by rewrite scaleNr scale1r. Qed."
}
{
  "statement": "Lemma rVabelem_mK L : ErV @* (rV_E @* L) = L.\n",
  "proof": "Proof. by rewrite morphim_invmE morphpreK. Qed."
}
{
  "statement": "Lemma normr_sg x : `|sgr x| = (x != 0)%:~R.\n",
  "proof": "Proof. by rewrite sgr_def -mulr_natr normrMsign normr_nat. Qed."
}
{
  "statement": "Lemma ceil_lt0 x : (ceil x < 0) = (x <= -1).\n",
  "proof": "Proof. by rewrite ceilNfloor oppr_lt0 floor_gt0 lerNr. Qed."
}
{
  "statement": "Lemma normK x : norm x ^+ 2 = x * conj x.\n",
  "proof": "Proof. by rewrite exprMn -rmorphXn sqrtK. Qed."
}
{
  "statement": "Lemma norm_rlcoset G x : x \\in 'N(G) -> G :* x = x *: G.\n",
  "proof": "Proof. by rewrite -sub1set => /normC. Qed."
}
{
  "statement": "Lemma signr_ge0 (b : bool) : (0 <= (-1) ^+ b :> R) = ~~ b.\n",
  "proof": "Proof. by rewrite le0r signr_eq0 signr_gt0. Qed."
}
{
  "statement": "Lemma mulg_ffun i (x y : gTn) : (x * y) i = x i * y i.\n",
  "proof": "Proof. by rewrite ffunE. Qed."
}
{
  "statement": "Lemma oneg_ffun i : (1 : gTn) i = 1. ",
  "proof": "Proof. by rewrite ffunE. Qed."
}
{
  "statement": "Lemma divnAC m n p : m %/ n %/ p =  m %/ p %/ n.\n",
  "proof": "Proof. by rewrite -!divnMA mulnC. Qed."
}
{
  "statement": "Lemma cfDprod_cfun1 : cfDprod 1 1 = 1.\n",
  "proof": "Proof. by rewrite cfDprod_cfun1l rmorph1. Qed."
}
{
  "statement": "Lemma morphpreT : f @*^-1 setT = D.\n",
  "proof": "Proof. by rewrite morphpreE preimsetT setIT. Qed."
}
{
  "statement": "Lemma cprod_center_id G : G \\* 'Z(G) = G.\n",
  "proof": "Proof. by rewrite cprodE ?subsetIr // mulGSid ?center_sub. Qed."
}
