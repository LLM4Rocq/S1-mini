{
  "statement": "Lemma dvdC_zmod x : zmod_closed (dvdC x).\n",
  "proof": "Proof.\nsplit=> [| _ _ /dvdCP[y Zy ->] /dvdCP[z Zz ->]]; first exact: dvdC0.\nby rewrite -mulrBl dvdC_mull ?rpredB.\nQed."
}
{
  "statement": "Lemma dimv_leqif_eq U V : (U <= V)%VS -> \\dim U <= \\dim V ?= iff (U == V).\n",
  "proof": "Proof. by rewrite eqEsubv; apply: mxrank_leqif_eq. Qed."
}
{
  "statement": "Lemma eq_in_has s : {in s, a1 =1 a2} -> has a1 s = has a2 s.\n",
  "proof": "Proof. by move/eq_in_filter=> eq_a12; rewrite !has_filter eq_a12. Qed."
}
{
  "statement": "Lemma all_iffP P0 Ps :\n   all_iff P0 Ps -> forall m n, nth P0 (P0 :: Ps) m <-> nth P0 (P0 :: Ps) n.\n",
  "proof": "Proof. by move=> /all_iffLR-iffPs m n; split => /iffPs. Qed."
}
{
  "statement": "Lemma unzip2_zip s t : size t <= size s -> unzip2 (zip s t) = t.\n",
  "proof": "Proof. by elim: s t => [|x s IHs] [|y t] //= le_t_s; rewrite IHs. Qed."
}
{
  "statement": "Lemma memmx0 n A : (A \\in (0 : 'A_n)) -> A = 0.\n",
  "proof": "Proof. by rewrite submx0 mxvec_eq0; move/eqP. Qed."
}
{
  "statement": "Lemma exprMn n : {morph (fun x => x ^+ n) : x y / x * y}.\n",
  "proof": "Proof. by move=> x y; exact/exprMn_comm/mulrC. Qed."
}
{
  "statement": "Lemma pchar_lalg (A : lalgType F) : pchar A =i pchar F.\n",
  "proof": "Proof. by move=> p; rewrite inE -scaler_nat scaler_eq0 oner_eq0 orbF. Qed."
}
{
  "statement": "Lemma big_nat_recr n m F : m <= n ->\n  \\big[*%M/1]_(m <= i < n.+1) F i = (\\big[*%M/1]_(m <= i < n) F i) * F n.\n",
  "proof": "Proof. by move=> lemn; rewrite (@big_cat_nat n) ?leqnSn // big_nat1. Qed."
}
{
  "statement": "Lemma rev_rot s : rev (rot n0 s) = rotr n0 (rev s).\n",
  "proof": "Proof. by apply: canLR revK _; rewrite rev_rotr revK. Qed."
}
{
  "statement": "Lemma rfix_morphim (H : {set aT}) :\n  H \\subset D -> (rfix_mx rG H :=: rfix_mx rGf (f @* H))%MS.\n",
  "proof": "Proof. exact: rfix_morphpre. Qed."
}
{
  "statement": "Lemma unit_mulVu : left_inverse unit1 unit_inv unit_mul.\n",
  "proof": "Proof. by move=> u; apply/val_inj/(mulVr (valP u)). Qed."
}
{
  "statement": "Lemma ucn_nilpotent n G : nilpotent 'Z_n(G).\n",
  "proof": "Proof. by apply/ucnP; exists n; rewrite ucn_id. Qed."
}
{
  "statement": "Lemma unzip1_zip s t : size s <= size t -> unzip1 (zip s t) = s.\n",
  "proof": "Proof. by elim: s t => [|x s IHs] [|y t] //= le_s_t; rewrite IHs. Qed."
}
{
  "statement": "Lemma addn_minr : right_distributive addn minn.\n",
  "proof": "Proof. by move=> m1 m2 n; rewrite !minnE subnDl addnBA ?leq_subr. Qed."
}
{
  "statement": "Lemma has_predU a1 a2 s : has (predU a1 a2) s = has a1 s || has a2 s.\n",
  "proof": "Proof. by elim: s => //= x s ->; rewrite -!orbA; do !bool_congr. Qed."
}
{
  "statement": "Lemma qpolyXE : 2 < size h -> h \\is monic -> 'qX = 'X :> {poly R}.\n",
  "proof": "Proof.\nmove=> sh_gt2 h_mo.\nby rewrite in_qpoly_small // size_polyX /mk_monic ifT // (ltn_trans _ sh_gt2).\nQed."
}
{
  "statement": "Lemma tuple_eta n T (t : n.+1.-tuple T) : t = [tuple of thead t :: behead t].\n",
  "proof": "Proof. by case/tupleP: t => x t; apply: val_inj. Qed."
}
{
  "statement": "Lemma cprodEY G H : H \\subset 'C(G) -> G \\* H = G <*> H.\n",
  "proof": "Proof. by move=> cGH; rewrite cprodE ?cent_joinEr. Qed."
}
{
  "statement": "Lemma metacyclic1 : metacyclic 1.\n",
  "proof": "Proof.\nby apply/existsP; exists 1%G; rewrite normal1 trivg_quotient !cyclic1.\nQed."
}
{
  "statement": "Lemma dvdn_trans n d m : d %| n -> n %| m -> d %| m.\n",
  "proof": "Proof. by move=> d_dv_n /dvdnP[n1 ->]; apply: dvdn_mull. Qed."
}
{
  "statement": "Lemma maxainv_norm : maxainv K N -> N <| K.\n",
  "proof": "Proof. by move/maxgroupp; case/andP. Qed."
}
{
  "statement": "Lemma colP (u v : 'cV[R]_m) : u^~ 0 =1 v^~ 0 <-> u = v.\n",
  "proof": "Proof. by split=> [eq_uv | -> //]; apply/matrixP=> i j; rewrite ord1. Qed."
}
{
  "statement": "Lemma splitK {m n} : cancel (@split m n) unsplit.\n",
  "proof": "Proof. by move=> i; case: split_ordP. Qed."
}
{
  "statement": "Lemma in_factmod_eq0 m (W : 'M_(m, n)) : (in_factmod W == 0) = (W <= U)%MS.\n",
  "proof": "Proof.\nrewrite submxE -!mxrank_eq0 -{2}[_ U]mulmx_base mulmxA.\nby rewrite (mxrankMfree _ (row_base_free _)).\nQed."
}
{
  "statement": "Lemma minn_maxl : left_distributive minn maxn.\n",
  "proof": "Proof.\nby move=> m1 m2 n; rewrite maxn_minr !maxn_minl -minnA maxnn (maxnC _ n) !maxnK.\nQed."
}
{
  "statement": "Lemma in_take_leq x s i : i <= size s -> (x \\in take i s) = (index x s < i).\n",
  "proof": "Proof. by rewrite -?has_pred1; apply: has_take_leq. Qed."
}
{
  "statement": "Lemma min_minKx x y : min (min x y) y = min x y.\n",
  "proof": "Proof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed."
}
{
  "statement": "Lemma min_minxK x y : min x (min x y) = min x y.\n",
  "proof": "Proof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed."
}
{
  "statement": "Lemma tuple_map_ord U (t : n.-tuple U) : t = [tuple of map (tnth t) ord_tuple].\n",
  "proof": "Proof. by apply: val_inj => /=; rewrite map_tnth_enum. Qed."
}
{
  "statement": "Lemma divg_indexS G H : H \\subset G -> #|G| %/ #|G : H| = #|H|.\n",
  "proof": "Proof. by move/Lagrange <-; rewrite mulnK. Qed."
}
{
  "statement": "Lemma sub_in_sorted s : all P s -> sorted e s -> sorted e' s.\n",
  "proof": "Proof. by case: s => //; apply: sub_in_path. Qed."
}
{
  "statement": "Lemma map_trmx : A^f^T = A^T^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eq_in_count s : {in s, a1 =1 a2} -> count a1 s = count a2 s.\n",
  "proof": "Proof. by move/eq_in_filter=> eq_a12; rewrite -!size_filter eq_a12. Qed."
}
{
  "statement": "Lemma enum_rankK : cancel enum_rank enum_val.\n",
  "proof": "Proof. by move=> x; apply: enum_rankK_in. Qed."
}
{
  "statement": "Lemma enum_rankK : cancel enum_rank enum_val.\n",
  "proof": "Proof. by move=> x; apply: enum_rankK_in. Qed."
}
{
  "statement": "Lemma real_ceilDrz : {in Rreal & int_num, {morph ceil : x y / x + y}}.\n",
  "proof": "Proof. by move=> x y xr yz; rewrite addrC real_ceilDzr // addrC. Qed."
}
{
  "statement": "Lemma setI_transversal_pblock x0 B :\n  B \\in P -> X :&: B = [set transversal_repr x0 X B].\n",
  "proof": "Proof.\nby case/trX/cards1P=> x defXB; rewrite /transversal_repr defXB /pick enum_set1.\nQed."
}
{
  "statement": "Lemma lcosetP A x y : reflect (exists2 a, a \\in A & y = x * a) (y \\in x *: A).\n",
  "proof": "Proof. by rewrite -lcosetE; apply: imsetP. Qed."
}
{
  "statement": "Lemma transversal_reprK x0 : {in P, cancel (transversal_repr x0 X) (pblock P)}.\n",
  "proof": "Proof. by move=> B PB; rewrite /= (def_pblock tiP PB) ?repr_mem_pblock. Qed."
}
{
  "statement": "Lemma card_uniq_tuple n (t : n.-tuple sT) : uniq t -> #|t| = n.\n",
  "proof": "Proof. by move/card_uniqP->; apply: size_tuple. Qed."
}
{
  "statement": "Lemma ler_wpM2l x : 0 <= x -> {homo *%R x : y z / y <= z}.\n",
  "proof": "Proof.\nby rewrite le0r => /orP[/eqP-> y z | /ler_pM2l/mono2W//]; rewrite !mul0r.\nQed."
}
{
  "statement": "Lemma ceilDrz x y : y \\is a int_num -> ceil (x + y) = ceil x + ceil y.\n",
  "proof": "Proof. by move=> yz; apply/real_ceilDrz/yz/num_real. Qed."
}
{
  "statement": "Lemma irr_basis : basis_of 'CF(G)%VS (irr G).\n",
  "proof": "Proof.\nrewrite /basis_of irr_free andbT -dimv_leqif_eq ?subvf //.\nby rewrite dim_cfun (eqnP irr_free) size_tuple NirrE.\nQed."
}
{
  "statement": "Lemma factmod_mx_repr : mx_repr G (factmod_mx Umod).\n",
  "proof": "Proof.\nsplit=> [|x y Gx Gy /=].\n  by rewrite /factmod_mx repr_mx1 mulmx1 val_factmodK.\nby rewrite -in_factmodJ // -mulmxA -repr_mxM.\nQed."
}
{
  "statement": "Lemma bigmaxID a P F : \\big[max/x]_(i <- r | P i) F i =\n  max (\\big[max/x]_(i <- r | P i && a i) F i)\n      (\\big[max/x]_(i <- r | P i && ~~ a i) F i).\n",
  "proof": "Proof. by rewrite (bigID_idem _ _ a) //= maxxx. Qed."
}
{
  "statement": "Lemma fmvalZ n : {morph valA : x / x *+ n >-> (x ^+ n)%g}.\n",
  "proof": "Proof. by move=> u; rewrite /= morphX ?inE. Qed."
}
{
  "statement": "Lemma real_floorDrz : {in Rreal & int_num, {morph floor : x y / x + y}}.\n",
  "proof": "Proof. by move=> x y xr yz; rewrite addrC real_floorDzr // addrC. Qed."
}
{
  "statement": "Lemma cfBigdprodi_inj i : P i -> injective (@cfBigdprodi i).\n",
  "proof": "Proof. by move/cfBigdprodiK; apply: can_inj. Qed."
}
{
  "statement": "Lemma adds0mx_id m1 n (B : 'M_n) : ((0 : 'M_(m1, n)) + B)%MS = B.\n",
  "proof": "Proof. by rewrite unlock eqxx addsmx_nop_id. Qed."
}
{
  "statement": "Lemma trmxCK {C : numClosedFieldType} m n (A : 'M[C]_(m, n)) : A ^t* ^t* = A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE conjCK. Qed."
}
{
  "statement": "Lemma inj_nhomo_lt :\n  injective f -> {homo f : x y /~ x <= y} -> {homo f : x y /~ x < y}.\n",
  "proof": "Proof. by apply: inj_homo=> // x y; rewrite eq_sym. Qed."
}
{
  "statement": "Lemma arg_minP: extremum_spec <=%O P F (arg_min i0 P F).\n",
  "proof": "Proof. by apply: extremumP => //; apply: le_trans. Qed."
}
{
  "statement": "Lemma real_minrN x : x \\is real -> min x (- x) = - `|x|.\n",
  "proof": "Proof.\nby move=> x_real; rewrite -[LHS]opprK real_oppr_min ?opprK ?real_maxNr ?realN.\nQed."
}
{
  "statement": "Lemma dvdC0 x : (x %| 0)%C.\n",
  "proof": "Proof. by apply/dvdCP; exists 0; rewrite ?mul0r. Qed."
}
{
  "statement": "Lemma divgS G H : H \\subset G -> #|G| %/ #|H| = #|G : H|.\n",
  "proof": "Proof. by move/Lagrange <-; rewrite mulKn. Qed."
}
{
  "statement": "Lemma max_maxKx x y : max (max x y) y = max x y.\n",
  "proof": "Proof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed."
}
{
  "statement": "Lemma max_maxxK x y : max x (max x y) = max x y.\n",
  "proof": "Proof. by rewrite !(fun_if, if_arg) ltxx/=; case: comparableP. Qed."
}
{
  "statement": "Lemma cosetpre_set1 x :\n  x \\in 'N(H) -> coset H @*^-1 [set coset H x] = H :* x.\n",
  "proof": "Proof. by rewrite -{9}ker_coset; apply: morphpre_set1. Qed."
}
{
  "statement": "Lemma map_drsubmx : (drsubmx B)^f = drsubmx B^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map_ursubmx : (ursubmx B)^f = ursubmx B^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma real_minNr x : x \\is real ->  min (- x) x = - `|x|.\n",
  "proof": "Proof.\nby move=> x_real; rewrite -[LHS]opprK real_oppr_min ?opprK ?real_maxrN ?realN.\nQed."
}
{
  "statement": "Lemma map_dlsubmx : (dlsubmx B)^f = dlsubmx B^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma order_cycle : order x = size p.\n",
  "proof": "Proof. by rewrite -(card_uniqP Up); apply: (eq_card fconnect_cycle). Qed."
}
{
  "statement": "Lemma trmx_drsub : (drsubmx A)^T = drsubmx A^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma conjmxVK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx V (conjmx (invmx V) f) = f.\n",
  "proof": "Proof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulmxV ?conj1mx. Qed."
}
{
  "statement": "Lemma conjmxVK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx V (conjmx (invmx V) f) = f.\n",
  "proof": "Proof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulmxV ?conj1mx. Qed."
}
{
  "statement": "Lemma map_ulsubmx : (ulsubmx B)^f = ulsubmx B^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma trmx_dlsub : (dlsubmx A)^T = ursubmx A^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma inj_nhomo_lt_in :\n    {in D & D', injective f} -> {in D & D', {homo f : x y /~ x <= y}} ->\n  {in D & D', {homo f : x y /~ x < y}}.\n",
  "proof": "Proof. by apply: inj_homo_in=> // x y; rewrite eq_sym. Qed."
}
{
  "statement": "Lemma trmx_ursub : (ursubmx A)^T = dlsubmx A^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma conjmxK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx (invmx V) (conjmx V f) = f.\n",
  "proof": "Proof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulVmx ?conj1mx. Qed."
}
{
  "statement": "Lemma conjmxK (n : nat) (V f : 'M[F]_n) :\n  V \\in unitmx -> conjmx (invmx V) (conjmx V f) = f.\n",
  "proof": "Proof. by move=> Vu; rewrite -conjuMumx ?unitmx_inv// mulVmx ?conj1mx. Qed."
}
{
  "statement": "Lemma imaginary_exists : {i : F | i ^+ 2 = -1}.\n",
  "proof": "Proof.\nhave /sig_eqW[i Di2] := @solve_monicpoly F 2 (nth 0 [:: -1]) isT.\nby exists i; rewrite Di2 !big_ord_recl big_ord0 mul0r mulr1 !addr0.\nQed."
}
{
  "statement": "Lemma memt_nth x0 (t : n.-tuple T) i : i < n -> nth x0 t i \\in t.\n",
  "proof": "Proof. by move=> i_lt_n; rewrite mem_nth ?size_tuple. Qed."
}
{
  "statement": "Lemma pprodEY K H : H \\subset 'N(K) -> pprod K H = K <*> H.\n",
  "proof": "Proof. by move=> nKH; rewrite pprodE ?norm_joinEr. Qed."
}
{
  "statement": "Lemma quotientYidl G : G \\subset 'N(H) -> H <*> G / H = G / H.\n",
  "proof": "Proof. by move=> nHG; rewrite joingC quotientYidr. Qed."
}
{
  "statement": "Lemma map_mxN A : (- A)^f = - A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE raddfN. Qed."
}
{
  "statement": "Lemma trmx_ulsub : (ulsubmx A)^T = ulsubmx A^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma allPn a s : reflect (exists2 x, x \\in s & ~~ a x) (~~ all a s).\n",
  "proof": "Proof. by rewrite -has_predC; apply: hasP. Qed."
}
{
  "statement": "Lemma rconj_mx_repr : mx_repr G (rconj_mx uB).\n",
  "proof": "Proof.\nsplit=> [|x y Gx Gy]; rewrite /rconj_mx ?repr_mx1 ?mulmx1 ?mulmxV ?repr_mxM //.\nby rewrite !mulmxA mulmxKV.\nQed."
}
{
  "statement": "Lemma exponent_morphim G : exponent (f @* G) %| exponent G.\n",
  "proof": "Proof.\napply/exponentP=> _ /morphimP[x Dx Gx ->].\nby rewrite -morphX // expg_exponent // morph1.\nQed."
}
{
  "statement": "Lemma perm_mact a : actperm morph_action a = phi a.\n",
  "proof": "Proof. by apply/permP=> x; rewrite permE. Qed."
}
{
  "statement": "Lemma extprod_mulgA : associative extprod_mulg.\n",
  "proof": "Proof. by move=> x y z; congr (_, _); apply: mulgA. Qed."
}
{
  "statement": "Lemma real_ler_norm x : x \\is real -> x <= `|x|.\n",
  "proof": "Proof.\nby case/real_ge0P=> hx //; rewrite (le_trans (ltW hx)) // oppr_ge0 ltW.\nQed."
}
{
  "statement": "Lemma rcosetP A x y : reflect (exists2 a, a \\in A & y = a * x) (y \\in A :* x).\n",
  "proof": "Proof. by rewrite -rcosetE; apply: imsetP. Qed."
}
{
  "statement": "Lemma separableSl K M E : (K <= M)%VS -> separable K E -> separable M E.\n",
  "proof": "Proof. by move/separableS; apply. Qed."
}
{
  "statement": "Lemma map_mxCK {C : numClosedFieldType}  m n (A : 'M[C]_(m, n)) :\n  (A ^ conjC) ^ conjC = A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE conjCK. Qed."
}
{
  "statement": "Lemma minr_pMl x y z : 0 <= x -> min y z * x = min (y * x) (z * x).\n",
  "proof": "Proof. by move=> *; rewrite mulrC minr_pMr // ![_ * x]mulrC. Qed."
}
{
  "statement": "Lemma cfdotZl xi a phi : '[a *: phi, xi] = a * '[phi, xi].\n",
  "proof": "Proof. by rewrite -!cfdotrE linearZ. Qed."
}
{
  "statement": "Lemma partition0 P D : partition P D -> set0 \\in P = false.\n",
  "proof": "Proof. case/and3P => _ _. by apply: contraNF. Qed."
}
{
  "statement": "Lemma sdprodEY K H : H \\subset 'N(K) -> K :&: H = 1 -> K ><| H = K <*> H.\n",
  "proof": "Proof. by move=> nKH tiKH; rewrite sdprodE ?norm_joinEr. Qed."
}
{
  "statement": "Lemma big_nat1_cond_eq (F : nat -> R) (P : pred nat) i m n :\n  \\big[op/idx]_(m <= j < n | P j && (j == i)) F j =\n    if (m <= i < n) && P i then F i else idx.\n",
  "proof": "Proof. by rewrite big_mkcondl big_nat1_eq -if_and. Qed."
}
{
  "statement": "Lemma capv0 : right_zero 0%VS capV.\n",
  "proof": "Proof. by move=> U; apply/capv_idPr/sub0v. Qed."
}
{
  "statement": "Lemma floorDrz x y : y \\is a int_num -> floor (x + y) = floor x + floor y.\n",
  "proof": "Proof. by move=> yz; apply/real_floorDrz/yz/num_real. Qed."
}
{
  "statement": "Lemma algR_normrN x : algR_norm (- x) = algR_norm x.\n",
  "proof": "Proof. by apply/val_inj; apply: normrN. Qed."
}
{
  "statement": "Lemma tr_submxblock (A : 'M[T]_sp) i j :\n  (submxblock A i j)^T = (submxblock A^T j i).\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma mxtrace_tr A : \\tr A^T = \\tr A.\n",
  "proof": "Proof. by apply: eq_bigr=> i _; rewrite mxE. Qed."
}
{
  "statement": "Lemma map_row_perm s : (row_perm s A)^f = row_perm s A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map_col_perm s : (col_perm s A)^f = col_perm s A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma pseriesJ pis gT (G : {group gT}) x :\n  pseries pis (G :^ x) = pseries pis G :^ x.\n",
  "proof": "Proof.\nrewrite -{1}(setIid G) -morphim_conj -(injmF _ (injm_conj G x)) //=.\nby rewrite morphim_conj (setIidPr (pseries_sub _ _)).\nQed."
}
{
  "statement": "Lemma cap0v : left_zero 0%VS capV.\n",
  "proof": "Proof. by move=> U; apply/capv_idPl/sub0v. Qed."
}
{
  "statement": "Lemma cardSg G H : H \\subset G -> #|H| %| #|G|.\n",
  "proof": "Proof. by move/Lagrange <-; rewrite dvdn_mulr. Qed."
}
{
  "statement": "Lemma rdivpp : rdivp d d = 1.\n",
  "proof": "Proof.\nby case: (monic_comreg mond) => hc hr; rewrite rdivpp // (eqP mond) expr1n.\nQed."
}
{
  "statement": "Lemma pnElemPcard p n A E :\n  E \\in 'E_p^n(A) -> [/\\ E \\subset A, p.-abelem E & #|E| = p ^ n]%N.\n",
  "proof": "Proof.\nby case/pnElemP=> -> abelE <-; rewrite -card_pgroup // abelem_pgroup.\nQed."
}
{
  "statement": "Lemma grank_min B : 'm(<<B>>) <= #|B|.\n",
  "proof": "Proof.\nby rewrite /gen_rank; case: arg_minnP => [|_ _ -> //]; rewrite genGid.\nQed."
}
{
  "statement": "Lemma subset_gen A : A \\subset <<A>>.\n",
  "proof": "Proof. rewrite [@generated]unlock; exact/bigcapsP. Qed."
}
{
  "statement": "Lemma scalemxDr x A B : x *m: (A + B) = x *m: A + x *m: B.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE mulrDr. Qed."
}
{
  "statement": "Lemma poly0Vpos p : {p = 0} + {size p > 0}.\n",
  "proof": "Proof. by rewrite lt0n size_poly_eq0; case: eqVneq; [left | right]. Qed."
}
{
  "statement": "Lemma insubF x : P x = false -> insub x = None.\n",
  "proof": "Proof. by move/idP; case: insubP. Qed."
}
{
  "statement": "Lemma eq_limg_ker0 f U V : lker f == 0%VS -> (f @: U == f @: V)%VS = (U == V).\n",
  "proof": "Proof. by move=> injf; rewrite !eqEsubv !limg_ker0. Qed."
}
{
  "statement": "Lemma properUl A B : ~~ (B \\subset A) ->  A \\proper A :|: B.\n",
  "proof": "Proof. by move=> not_sBA; rewrite setUC properUr. Qed."
}
{
  "statement": "Lemma morphpre_ifactm C : ifactm @*^-1 C = f @* (g @*^-1 C).\n",
  "proof": "Proof.\nrewrite /ifactm; case: domP => _ /= [_ _ -> _].\nby rewrite morphpre_comp morphpre_invm.\nQed."
}
{
  "statement": "Lemma map2_mxvec : map2_mx (mxvec A) (mxvec B) = mxvec (map2_mx A B).\n",
  "proof": "Proof. by apply/rowP=> i; rewrite !(castmxE, mxE). Qed."
}
{
  "statement": "Lemma dvdC_refl x : (x %| x)%C.\n",
  "proof": "Proof. by apply/dvdCP; exists 1; rewrite ?mul1r. Qed."
}
{
  "statement": "Lemma map_mxD A B : (A + B)^f = A^f + B^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE raddfD. Qed."
}
{
  "statement": "Lemma lshift_subproof m n (i : 'I_m) : i < m + n.\n",
  "proof": "Proof. by apply: leq_trans (valP i) _; apply: leq_addr. Qed."
}
{
  "statement": "Lemma scalar_mx_sum_delta n a : a%:M = \\sum_i a *: delta_mx i i :> 'M_n.\n",
  "proof": "Proof.\nby rewrite -diag_const_mx diag_mx_sum_delta; under eq_bigr do rewrite mxE.\nQed."
}
{
  "statement": "Lemma sdprod_mul_proof (u v : sdT) :\n  (u.1 * v.1, to u.2 v.1 * v.2) \\in setX D R.\n",
  "proof": "Proof.\ncase: u v => [[a x] /= /setXP[Da Rx]] [[b y] /= /setXP[Db Ry]].\nby rewrite inE !groupM //= gact_stable.\nQed."
}
{
  "statement": "Lemma similarPp m n {P : 'M[F]_(m, n)} {A B} :\n  stablemx P A -> similar P A B -> P *m A = B *m P.\n",
  "proof": "Proof. by move=> stablemxPA /eqP <-; rewrite mulmxKpV. Qed."
}
{
  "statement": "Lemma col_perm1 A : col_perm 1 A = A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite mxE perm1. Qed."
}
{
  "statement": "Lemma maxr_pMl x y z : 0 <= x -> max y z * x = max (y * x) (z * x).\n",
  "proof": "Proof. by move=> *; rewrite mulrC maxr_pMr // ![_ * x]mulrC. Qed."
}
{
  "statement": "Lemma fmvalJcond u x :\n  val (u ^@ x) = if x \\in 'N(A) then val u ^ x else val u.\n",
  "proof": "Proof. by case: ifP => Nx; rewrite /actr Nx ?fmodK // memJ_norm ?fmodP. Qed."
}
{
  "statement": "Lemma xcprodmEl : {in H, forall x, xcprodm (cpairg1 x) = fH x}.\n",
  "proof": "Proof. by move=> x Hx; rewrite /xcprodm cprodmEl ?mem_morphim ?ifactmE. Qed."
}
{
  "statement": "Lemma maxnMl : left_distributive muln maxn.\n",
  "proof": "Proof. by move=> m1 m2 n; rewrite -!(mulnC n) maxnMr. Qed."
}
{
  "statement": "Lemma odd_permJ s1 s2 : odd_perm (s1 ^ s2) = odd_perm s1.\n",
  "proof": "Proof. by rewrite !odd_permM odd_permV addbC addbK. Qed."
}
{
  "statement": "Lemma free_not0 v X : free X -> v \\in X -> v != 0.\n",
  "proof": "Proof. by rewrite free_directv andbC => /andP[_ /memPn]; apply. Qed."
}
{
  "statement": "Lemma contra_orbit G x y : x \\notin orbit to G y -> x != y.\n",
  "proof": "Proof. by apply: contraNneq => ->; apply: orbit_refl. Qed."
}
{
  "statement": "Lemma tofrac_is_multiplicative: multiplicative tofrac.\n",
  "proof": "Proof.\nsplit=> [p q|//]; unlock tofrac; rewrite -[RHS]pi_mul.\nby rewrite /mulf /= !numden_Ratio ?(oner_neq0, mul1r, mulr1).\nQed."
}
{
  "statement": "Lemma map_usubmx : (usubmx Bv)^f = usubmx Bv^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma form_of_matrixK : matrix_of_form (form_of_matrix theta M) = M.\n",
  "proof": "Proof. by apply/matrixP => i j; rewrite !mxE rV_formee. Qed."
}
{
  "statement": "Lemma morphim_invm A : A \\subset G -> invm @* (f @* A) = A.\n",
  "proof": "Proof. by move=> sAG; rewrite morphim_factm morphim_idm. Qed."
}
{
  "statement": "Lemma leq_rot_add n m s : rot_add s n m <= size s.\n",
  "proof": "Proof.\nby unlock rot_add; case: ifP; rewrite // leq_subLR leq_add // geq_minr.\nQed."
}
{
  "statement": "Lemma row_perm1 A : row_perm 1 A = A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite mxE perm1. Qed."
}
{
  "statement": "Lemma eqAmod_addl_mul e : {in Aint, forall x y, x * e + y == y %[mod e]}%A.\n",
  "proof": "Proof. by move=> x Zx y; rewrite -{2}[y]add0r eqAmodDr eqAmodMl0. Qed."
}
{
  "statement": "Lemma map_dsubmx : (dsubmx Bv)^f = dsubmx Bv^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma scanl_rcons x s1 y  :\n  scanl x (rcons s1 y) =  rcons (scanl x s1) (foldl g x (rcons s1 y)).\n",
  "proof": "Proof. by rewrite -!cats1 scanl_cat foldl_cat. Qed."
}
{
  "statement": "Lemma eqAmodMl0 e : {in Aint, forall x, x * e == 0 %[mod e]}%A.\n",
  "proof": "Proof. by move=> x Zx; rewrite -(mulr0 x) eqAmodMl. Qed."
}
{
  "statement": "Lemma pairwise_mask m xs : pairwise xs -> pairwise (mask m xs).\n",
  "proof": "Proof.\nby elim: m xs => [|[] m IHm] [|x xs] //= /andP [? ?]; rewrite ?IHm // all_mask.\nQed."
}
{
  "statement": "Lemma anti_leq : antisymmetric leq.\n",
  "proof": "Proof. by move=> m n; rewrite -eqn_leq => /eqP. Qed."
}
{
  "statement": "Lemma commrX x y n : comm x y -> comm x (y ^+ n).\n",
  "proof": "Proof.\nrewrite /comm => com_xy.\nby elim: n => [|n IHn]; rewrite ?commr1 // exprS commrM.\nQed."
}
{
  "statement": "Lemma PackSocleK W e0W : @PackSocle W e0W = W :> 'M_n.\n",
  "proof": "Proof.\nrewrite /socle_val /= in e0W *; rewrite -(nth_map _ 0) ?nth_index //.\nby rewrite -(size_map component_mx) index_mem.\nQed."
}
{
  "statement": "Lemma map_rsubmx : (rsubmx Bh)^f = rsubmx Bh^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma filter_id s : filter (filter s) = filter s.\n",
  "proof": "Proof. by apply/all_filterP; apply: filter_all. Qed."
}
{
  "statement": "Lemma raddfN : {morph f : x / - x}.\n",
  "proof": "Proof.\nmove=> x.\nby rewrite -[LHS]addr0 -(subrr (f x)) addrA -raddfD addNr raddf0 sub0r.\nQed."
}
{
  "statement": "Lemma mem_belast s y : {subset belast y s <= y :: s}.\n",
  "proof": "Proof. by move=> x ys'x; rewrite lastI mem_rcons mem_behead. Qed."
}
{
  "statement": "Lemma mulnC : commutative muln.\n",
  "proof": "Proof.\nby move=> m n; elim: m => [|m]; rewrite (muln0, mulnS) // mulSn => ->.\nQed."
}
{
  "statement": "Lemma scalemxDl A x y : (x + y) *m: A = x *m: A + y *m: A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE mulrDl. Qed."
}
{
  "statement": "Lemma genGidG G : <<G>>%G = G.\n",
  "proof": "Proof. by apply: val_inj; apply: genGid. Qed."
}
{
  "statement": "Lemma atrans_orbit G x : [transitive G, on orbit to G x | to].\n",
  "proof": "Proof. by apply: imset_f; apply: orbit_refl. Qed."
}
{
  "statement": "Lemma submxrow0 m j : submxrow (0 : 'M[V]_(m, sq)) j = 0.\n",
  "proof": "Proof. by apply/matrixP=> i i'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma predC_itvr a : [predC Interval a +oo] =i Interval -oo a.\n",
  "proof": "Proof. by move=> y; rewrite inE/= -predC_itvl negbK. Qed."
}
{
  "statement": "Lemma lt_pair (x1 y1 : T1) (x2 y2 : T2) : (x1, x2) < (y1, y2) :> T1 * T2 =\n  [&& (x1 != y1) || (x2 != y2), x1 <= y1 & x2 <= y2].\n",
  "proof": "Proof. by rewrite ltEprod negb_and. Qed."
}
{
  "statement": "Lemma dprodEY G H : H \\subset 'C(G) -> G :&: H = 1 -> G \\x H = G <*> H.\n",
  "proof": "Proof. by move=> cGH trGH; rewrite /dprod trGH subxx cprodEY. Qed."
}
{
  "statement": "Lemma map_lsubmx : (lsubmx Bh)^f = lsubmx Bh^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma minnMl : left_distributive muln minn.\n",
  "proof": "Proof. by move=> m1 m2 n; rewrite -!(mulnC n) minnMr. Qed."
}
{
  "statement": "Lemma cprodE G H : H \\subset 'C(G) -> G \\* H = G * H.\n",
  "proof": "Proof. by move=> cGH; rewrite /cprod cGH pprodE ?cents_norm. Qed."
}
{
  "statement": "Lemma subv_trans : transitive subV.\n",
  "proof": "Proof. by move=> U V W /subvP sUV /subvP sVW; apply/subvP=> u /sUV/sVW. Qed."
}
{
  "statement": "Lemma tnth_map f t i : tnth [tuple of map f t] i = f (tnth t i) :> rT.\n",
  "proof": "Proof. by apply: nth_map; rewrite size_tuple. Qed."
}
{
  "statement": "Lemma map2_col j : map2_mx (col j A) (col j B) = col j (map2_mx A B).\n",
  "proof": "Proof. by apply/colP=> i; rewrite !mxE. Qed."
}
{
  "statement": "Lemma rcoset_kercosetP x y :\n  x \\in 'N(H) -> y \\in 'N(H) -> reflect (coset H x = coset H y) (x \\in H :* y).\n",
  "proof": "Proof. by rewrite -{6}ker_coset; apply: rcoset_kerP. Qed."
}
{
  "statement": "Lemma big_image I (J : finType) (h : J -> I) (A : pred J) F :\n  \\big[op/x]_(i <- [seq h j | j in A]) F i = \\big[op/x]_(j in A) F (h j).\n",
  "proof": "Proof. by rewrite big_map big_enum. Qed."
}
{
  "statement": "Lemma addv0 : right_id 0%VS addV.\n",
  "proof": "Proof. by move=> U; apply/addv_idPl/sub0v. Qed."
}
{
  "statement": "Lemma Cyclotomic0 : 'Phi_0 = 1.\n",
  "proof": "Proof.\nrewrite /'Phi_0; case: (C_prim_root_exists _) => z /= _.\nby rewrite -[1]polyseqK /cyclotomic big_ord0 map_polyE !polyseq1 /= (intCK 1).\nQed."
}
{
  "statement": "Lemma isom_Iirr0 : isom_Iirr 0 = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite isom_Iirr_eq0. Qed."
}
{
  "statement": "Lemma Inertia_sub phi : 'I_G[phi] \\subset G.\n",
  "proof": "Proof. exact: subsetIl. Qed."
}
{
  "statement": "Lemma rcomplKI x y z : x <= y -> (x `|` z) `&` rcompl x y z = x.\n",
  "proof": "Proof. by move=> lexy; have := rcomplPmeet x y z; rewrite (meet_l lexy). Qed."
}
{
  "statement": "Lemma abelem_mx_irrP : reflect (mx_irreducible rG) (minnormal E G).\n",
  "proof": "Proof.\nby rewrite -[E in minnormal E G]im_rVabelem -rowg1; apply: mxsimple_abelemP.\nQed."
}
{
  "statement": "Lemma conjg_Iirr0 x : conjg_Iirr 0 x = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite conjg_Iirr_eq0. Qed."
}
{
  "statement": "Lemma rcomplKU x y z : x <= y -> (y `&` z) `|` rcompl x y z = y.\n",
  "proof": "Proof. by move=> lexy; have := rcomplPjoin x y z; rewrite (join_l lexy). Qed."
}
{
  "statement": "Lemma cfRepr_dsum I r (P : pred I) rG :\n  cfRepr (\\big[dadd_grepr/grepr0]_(i <- r | P i) rG i)\n    = \\sum_(i <- r | P i) cfRepr (rG i).\n",
  "proof": "Proof. exact: (big_morph _ cfRepr_dadd cfRepr0). Qed."
}
{
  "statement": "Lemma rshift1 n : @rshift 1 n =1 lift (0 : 'I_n.+1).\n",
  "proof": "Proof. by move=> i; apply: val_inj. Qed."
}
{
  "statement": "Lemma astab1Js A : 'C[A | 'Js] = 'N(A).\n",
  "proof": "Proof. by apply/setP=> x; apply/astab1P/normP. Qed."
}
{
  "statement": "Lemma pmap_filter s : map g (pmap s) = filter [eta f] s.\n",
  "proof": "Proof. by elim: s => //= x s <-; rewrite -{3}(fK x); case: (f _). Qed."
}
{
  "statement": "Lemma unit_muluA : associative unit_mul.\n",
  "proof": "Proof. by move=> u v w; apply/val_inj/mulrA. Qed."
}
{
  "statement": "Lemma isog_Phi rT G (H : {group rT}) : G \\isog H -> 'Phi(G) \\isog 'Phi(H).\n",
  "proof": "Proof. exact: gFisog. Qed."
}
{
  "statement": "Lemma isog_nil_class rT G (L : {group rT}) :\n  G \\isog L -> nil_class G = nil_class L.\n",
  "proof": "Proof. by case/isogP=> f injf <-; rewrite nil_class_injm. Qed."
}
{
  "statement": "Lemma submxblockEv A i j : submxblock A i j = submxrow (submxcol A i) j.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma class_refl x : x \\in x ^: G.\n",
  "proof": "Proof. by apply/imsetP; exists 1; rewrite ?conjg1. Qed."
}
{
  "statement": "Lemma add0v : left_id 0%VS addV.\n",
  "proof": "Proof. by move=> U; apply/addv_idPr/sub0v. Qed."
}
{
  "statement": "Lemma scalerI a : a != 0 -> injective ( *:%R a : V -> V).\n",
  "proof": "Proof. by move=> nz_a; apply: can_inj (scalerK nz_a). Qed."
}
{
  "statement": "Lemma mulnb (b1 b2 : bool) : b1 * b2 = b1 && b2.\n",
  "proof": "Proof. by case: b1; case: b2. Qed."
}
{
  "statement": "Lemma addn_minl : left_distributive addn minn.\n",
  "proof": "Proof. by move=> m1 m2 n; rewrite -!(addnC n) addn_minr. Qed."
}
{
  "statement": "Lemma submxblockEh A i j : submxblock A i j = submxcol (submxrow A j) i.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma irr_cfcenterE i x :\n  x \\in G -> (x \\in 'Z('chi[G]_i)%CF) = (`|'chi_i x| == 'chi_i 1%g).\n",
  "proof": "Proof. by move/char_cfcenterE->; rewrite ?irr_char. Qed."
}
{
  "statement": "Lemma lfun1_poly (p : {poly aT}) : map_poly \\1%VF p = p.\n",
  "proof": "Proof. by apply: map_poly_id => u _; apply: id_lfunE. Qed."
}
{
  "statement": "Lemma map_vec_mx (v : 'rV_(m * n)) : (vec_mx v)^f = vec_mx v^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eq_ltLR x y z t :\n  (x < y -> z < t) -> (y <= x -> t <= z) -> (x < y) = (z < t).\n",
  "proof": "Proof. by rewrite !leNgt => ? /contraTT ?; apply/idP/idP. Qed."
}
{
  "statement": "Lemma sdprod_Iirr0 : sdprod_Iirr 0 = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite sdprod_Iirr_eq0. Qed."
}
{
  "statement": "Lemma forall_inPn D P :\n  reflect (exists2 x, x \\in D & ~~ P x) (~~ [forall x in D, P x]).\n",
  "proof": "Proof. rewrite negb_forall_in. exact: exists_inP. Qed."
}
{
  "statement": "Lemma submxblockK A : \\mxblock_(i, j) (submxblock A i j) = A.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed."
}
{
  "statement": "Lemma gtr0_norm_neq0 v : `|v| > 0 -> (v != 0).\n",
  "proof": "Proof. by apply: contra_ltN => /eqP->; rewrite normr0. Qed."
}
{
  "statement": "Lemma mxrow0 m : \\mxrow_j (0 : 'M[V]_(m, q_ j)) = 0.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma conjsg_inj : @left_injective _ gT _ conjugate.\n",
  "proof": "Proof. by move=> x; apply: can_inj (conjsgK x). Qed."
}
{
  "statement": "Lemma char1_gt0 chi : chi \\is a character -> (0 < chi 1%g) = (chi != 0).\n",
  "proof": "Proof. by move=> Nchi; rewrite -char1_eq0 // natr_gt0 ?Cnat_char1. Qed."
}
{
  "statement": "Lemma pi_of_exp p n : n > 0 -> \\pi(p ^ n) = \\pi(p).\n",
  "proof": "Proof. by move=> n_gt0; rewrite /pi_of primesX. Qed."
}
{
  "statement": "Lemma simmxPp m n {P : 'M[F]_(m, n)} {A B} :\n  stablemx P A -> A ~_P B -> P *m A = B *m P.\n",
  "proof": "Proof. by move=> stablemxPA /eqP <-; rewrite mulmxKpV. Qed."
}
{
  "statement": "Lemma ltr_eXn2l x :\n  1 < x -> {mono (GRing.exp x) : m n / (m < n)%N >-> m < n}.\n",
  "proof": "Proof. by move=> xgt1; apply: (leW_mono (ler_eXn2l _)). Qed."
}
{
  "statement": "Lemma reprP K (PK : forall x Px, K (@Sub x Px)) u : K u.\n",
  "proof": "Proof. by rewrite (sort_Sub u); apply: PK. Qed."
}
{
  "statement": "Lemma card_quotient A : A \\subset 'N(H) -> #|A / H| = #|A : H|.\n",
  "proof": "Proof. by move=> nHA; rewrite card_quotient_subnorm (setIidPl nHA). Qed."
}
{
  "statement": "Lemma pnat_pi n : n > 0 -> \\pi(n).-nat n.\n",
  "proof": "Proof. by rewrite /pnat => ->; apply/allP. Qed."
}
{
  "statement": "Lemma sorted_subseq_sort t s :\n  subseq t s -> sorted leT t -> subseq t (sort leT s).\n",
  "proof": "Proof. by move=> subseq_ts /(sorted_sort leT_tr) <-; exact: subseq_sort. Qed."
}
{
  "statement": "Lemma ltr_iXn2l x :\n  0 < x -> x < 1 -> {mono GRing.exp x : m n / (n < m)%N >-> m < n}.\n",
  "proof": "Proof. by move=> xgt0 xlt1; apply: (leW_nmono (ler_iXn2l _ _)). Qed."
}
{
  "statement": "Lemma proj_mx_proj n (U V : 'M_n) :\n  let P := proj_mx U V in (U :&: V = 0)%MS -> P *m P = P.\n",
  "proof": "Proof.\nby move=> P dxUV; rewrite -[P in P *m _]mul1mx proj_mx_id ?proj_mx_sub ?mul1mx.\nQed."
}
{
  "statement": "Lemma astab1JG G : 'C[G | 'JG] = 'N(G).\n",
  "proof": "Proof.\nby apply/setP=> x; apply/astab1P/normP=> [/congr_group | /group_inj].\nQed."
}
{
  "statement": "Lemma orbitP A x y :\n  reflect (exists2 a, a \\in A & to x a = y) (y \\in orbit to A x).\n",
  "proof": "Proof. by apply: (iffP imsetP) => [] [a]; exists a. Qed."
}
{
  "statement": "Lemma map_capmx_gen m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) :\n  (capmx_gen A B)^f = capmx_gen A^f B^f.\n",
  "proof": "Proof. by rewrite map_mxM map_lsubmx map_kermx map_col_mx. Qed."
}
{
  "statement": "Lemma eq_mxrow m (A_ B_ : forall j, 'M[T]_(m, q_ j)) :\n  (forall j, A_ j = B_ j) -> (\\mxrow_j A_ j = \\mxrow_j B_ j).\n",
  "proof": "Proof. by move=> /eq_mxrowP. Qed."
}
{
  "statement": "Lemma submxrowN m (B : 'M[V]_(m, sq)) j :\n submxrow (- B) j = - submxrow B j.\n",
  "proof": "Proof. by apply/matrixP => i i'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eqp0 p : (p %= 0) = (p == 0).\n",
  "proof": "Proof. by apply/idP/eqP => [/andP [_ /dvd0pP] | -> //]. Qed."
}
{
  "statement": "Lemma ceilDzr : {in @int_num R, {morph ceil : x y / x + y}}.\n",
  "proof": "Proof. by move=> x xz y; apply/real_ceilDzr/num_real. Qed."
}
{
  "statement": "Lemma abelem_rV_inj : {in E &, injective ErV}.\n",
  "proof": "Proof. by apply/injmP; apply: abelem_rV_injm. Qed."
}
{
  "statement": "Lemma ler_dist_dist v w : `| `|v| - `|w| | <= `|v - w|.\n",
  "proof": "Proof.\nhave [||_|_] // := @real_leP `|v| `|w|; last by rewrite lerB_dist.\nby rewrite distrC lerB_dist.\nQed."
}
{
  "statement": "Lemma allpairs_bseqP f s (s' : m.-bseq U) : @size rT (allpairs f s s') <= n * m.\n",
  "proof": "Proof. by rewrite size_allpairs; apply/leq_mul/size_bseq/size_bseq. Qed."
}
{
  "statement": "Lemma col_row_permC s t A :\n  col_perm s (row_perm t A) = row_perm t (col_perm s A).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma zcontents0 : zcontents 0 = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite zcontents_eq0. Qed."
}
{
  "statement": "Lemma maxnC : commutative maxn.\n",
  "proof": "Proof. by rewrite /maxn; elim=> [|m ih] [] // n; rewrite !ltnS -!fun_if ih. Qed."
}
{
  "statement": "Lemma subcent1C x y G : x \\in G -> y \\in 'C_G[x] -> x \\in 'C_G[y].\n",
  "proof": "Proof. by move=> Gx /subcent1P[_ cxy]; apply/subcent1P. Qed."
}
{
  "statement": "Lemma minACA : interchange (min : T -> T -> T) min.\n",
  "proof": "Proof. by move=> x y z t; apply: comparable_minACA. Qed."
}
{
  "statement": "Lemma unit_mul1u : left_id unit1 unit_mul.\n",
  "proof": "Proof. by move=> u; apply/val_inj/mul1r. Qed."
}
{
  "statement": "Lemma algR_normr0_eq0 x : algR_norm x = 0 -> x = 0.\n",
  "proof": "Proof. by move=> /(congr1 val)/normr0_eq0 ?; apply/val_inj. Qed."
}
{
  "statement": "Lemma maxr_nMl x y z : x <= 0 -> max y z * x = min (y * x) (z * x).\n",
  "proof": "Proof. by move=> x_le0; apply: real_maxr_nMl. Qed."
}
{
  "statement": "Lemma minr_nMl x y z : x <= 0 -> min y z * x = max (y * x) (z * x).\n",
  "proof": "Proof. by move=> x_le0; apply: real_minr_nMl. Qed."
}
{
  "statement": "Lemma sdprod_inv_proof (u : sdT) : (u.1^-1, to u.2^-1 u.1^-1) \\in setX D R.\n",
  "proof": "Proof.\nby case: u => [[a x]] /= /setXP[Da Rx]; rewrite inE gact_stable !groupV ?Da.\nQed."
}
{
  "statement": "Lemma map_mxsub m' n' g h : (@mxsub _ _ _  m' n' g h A)^f = mxsub g h A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma bigcup_sup j P F : P j -> F j \\subset \\bigcup_(i | P i) F i.\n",
  "proof": "Proof. by move=> Pj; rewrite (bigD1 j) //= subsetUl. Qed."
}
{
  "statement": "Lemma submxcol0 m i : submxcol (0 : 'M[V]_(sp, m)) i = 0.\n",
  "proof": "Proof. by apply/matrixP=> j j'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma cfdotMnr xi phi n : '[xi, phi *+ n] = '[xi, phi] *+ n.\n",
  "proof": "Proof. exact: raddfMn. Qed."
}
{
  "statement": "Lemma invC_rect :\n  {in real &, forall x y, (x + 'i * y)^-1  = (x - 'i * y) / (x ^+ 2 + y ^+ 2)}.\n",
  "proof": "Proof. by move=> x y Rx Ry; rewrite invC_Crect normC2_rect ?conj_Creal. Qed."
}
{
  "statement": "Lemma disjoint_setI0 A B : [disjoint A & B] -> A :&: B = set0.\n",
  "proof": "Proof. by rewrite -setI_eq0; move/eqP. Qed."
}
{
  "statement": "Lemma maxr_nMr x y z : x <= 0 -> x * max y z = min (x * y) (x * z).\n",
  "proof": "Proof. by move=> x_le0; apply: real_maxr_nMr. Qed."
}
{
  "statement": "Lemma minr_nMr x y z : x <= 0 -> x * min y z = max (x * y) (x * z).\n",
  "proof": "Proof. by move=> x_le0; apply: real_minr_nMr. Qed."
}
{
  "statement": "Lemma kHom_root K E f p x :\n    kHom K E f -> p \\is a polyOver E -> x \\in E -> root p x ->\n  root (map_poly f p) (f x).\n",
  "proof": "Proof.\nby move/kHom_horner=> homKf Ep Ex /rootP px0; rewrite /root -homKf ?px0 ?raddf0.\nQed."
}
{
  "statement": "Lemma sub_msof : {mono msof : V V' / (V <= V')%VS >-> (V <= V')%MS}.\n",
  "proof": "Proof. by move=> V V'; rewrite msof_sub msofK. Qed."
}
{
  "statement": "Lemma PhiJ G x : 'Phi(G :^ x) = 'Phi(G) :^ x.\n",
  "proof": "Proof.\nrewrite -{1}(setIid G) -(setIidPr (Phi_sub G)) -!morphim_conj.\nby rewrite injm_Phi ?injm_conj.\nQed."
}
{
  "statement": "Lemma eq_leLR x y z t :\n  (x <= y -> z <= t) -> (y < x -> t < z) -> (x <= y) = (z <= t).\n",
  "proof": "Proof. by rewrite !ltNge => ? /contraTT ?; apply/idP/idP. Qed."
}
{
  "statement": "Lemma gt_eqF x y : y < x -> x == y = false.\n",
  "proof": "Proof. by rewrite lt_def; case: eqP. Qed."
}
{
  "statement": "Lemma xcfunZr a phi A : xcfun phi (a *: A) = a * xcfun phi A.\n",
  "proof": "Proof. by rewrite /xcfun linearZ -scalemxAl mxE. Qed."
}
{
  "statement": "Lemma cat_path x p1 p2 : path x (p1 ++ p2) = path x p1 && path (last x p1) p2.\n",
  "proof": "Proof. by elim: p1 x => [|y p1 Hrec] x //=; rewrite Hrec -!andbA. Qed."
}
{
  "statement": "Lemma Nreal_gtF x y : y \\is real -> x \\notin real -> (y < x) = false.\n",
  "proof": "Proof. by move=> yR xNR; rewrite lt_def Nreal_geF ?andbF. Qed."
}
{
  "statement": "Lemma capvS U1 U2 V1 V2 : (U1 <= U2 -> V1 <= V2 -> U1 :&: V1 <= U2 :&: V2)%VS.\n",
  "proof": "Proof. by rewrite /subV !vs2mxI; apply: capmxS. Qed."
}
{
  "statement": "Lemma gen_dim_ub_proof nA :\n  [exists B : 'rV_nA, row_free (subbase B)] -> (nA <= n)%N.\n",
  "proof": "Proof.\ncase/existsP=> B /eqnP def_nAd.\nby rewrite (leq_trans _ (rank_leq_col (subbase B))) // def_nAd leq_pmulr.\nQed."
}
{
  "statement": "Lemma floorDzr : {in @int_num R, {morph floor : x y / x + y}}.\n",
  "proof": "Proof. by move=> x xz y; apply/real_floorDzr/num_real. Qed."
}
{
  "statement": "Lemma zcharD1E phi S : (phi \\in 'Z[S, G^#]) = (phi \\in 'Z[S]) && (phi 1%g == 0).\n",
  "proof": "Proof. by rewrite zchar_split cfunD1E. Qed."
}
{
  "statement": "Lemma Nreal_ltF x y : y \\is real -> x \\notin real -> (x < y) = false.\n",
  "proof": "Proof. by move=> yR xNR; rewrite lt_def Nreal_leF ?andbF. Qed."
}
{
  "statement": "Lemma aut_closed : f @: G \\subset G.\n",
  "proof": "Proof. by rewrite -morphimEdom; apply/morphim_fixP. Qed."
}
{
  "statement": "Lemma ltr_nMn2l x :\n  x < 0 -> {mono (@GRing.natmul R x) : m n / (n < m)%N >-> m < n}.\n",
  "proof": "Proof. by move=> x_lt0; apply: leW_nmono (ler_nMn2l _). Qed."
}
{
  "statement": "Lemma order_finv : order (finv f) =1 order f.\n",
  "proof": "Proof. by move=> x; apply: eq_card (@same_fconnect_finv _ _ injf x). Qed."
}
{
  "statement": "Lemma suffix_suffix s1 s2 : suffix s2 (s1 ++ s2).\n",
  "proof": "Proof. by rewrite /suffix rev_cat prefix_prefix. Qed."
}
{
  "statement": "Lemma mulrnA x m n : x *+ (m * n) = x *+ m *+ n.\n",
  "proof": "Proof.\nby rewrite mulnC; elim: n => //= n IHn; rewrite mulrS mulrnDr IHn.\nQed."
}
{
  "statement": "Lemma coord_basis U n (X : n.-tuple vT) v :\n  basis_of U X -> v \\in U -> v = \\sum_i coord X i v *: X`_i.\n",
  "proof": "Proof. by move/span_basis <-; apply: coord_span. Qed."
}
{
  "statement": "Lemma inertia_irr_prime p i :\n  #|H| = p -> prime p -> i != 0 -> 'I['chi[H]_i] = 'C(H).\n",
  "proof": "Proof. by move=> <- pr_H /(irr_prime_injP pr_H); apply: inertia_injective. Qed."
}
{
  "statement": "Lemma map_perm_mx (s : 'S_n) : (perm_mx s)^f = perm_mx s.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE rmorph_nat. Qed."
}
{
  "statement": "Lemma existsb_tnth a t : [exists i, a (tnth t i)] = has a t.\n",
  "proof": "Proof. by apply: negb_inj; rewrite negb_exists -all_predC -forallb_tnth. Qed."
}
{
  "statement": "Lemma invmx_out : {in [predC unitmx], invmx =1 id}.\n",
  "proof": "Proof. by move=> A; rewrite inE /= /invmx -if_neg => ->. Qed."
}
{
  "statement": "Lemma rpredV x : (x^-1 \\in S) = (x \\in S).\n",
  "proof": "Proof. by apply/idP/idP=> /rpredVr; rewrite ?invrK. Qed."
}
{
  "statement": "Lemma subsetUl A B : A \\subset A :|: B.\n",
  "proof": "Proof. by apply/subsetP=> x /[!inE] ->. Qed."
}
{
  "statement": "Lemma leq_fact : {homo factorial : m n / m <= n}.\n",
  "proof": "Proof.\nby move=> [m|m n mn]; rewrite ?fact_gt0// leq_pfact// inE (leq_trans _ mn).\nQed."
}
{
  "statement": "Lemma normCi : `|'i| = 1 :> C.\n",
  "proof": "Proof. by apply/eqP; rewrite -(@pexpr_eq1 _ _ 2) // -normrX sqrCi normrN1. Qed."
}
{
  "statement": "Lemma truncnM : {in nat_num &, {morph truncn : x y / x * y >-> (x * y)%N}}.\n",
  "proof": "Proof. by move=> _ _ /natrP[n1 ->] /natrP[n2 ->]; rewrite -natrM !natrK. Qed."
}
{
  "statement": "Lemma addvS U1 U2 V1 V2 : (U1 <= U2 -> V1 <= V2 -> U1 + V1 <= U2 + V2)%VS.\n",
  "proof": "Proof. by rewrite /subV !vs2mxD; apply: addsmxS. Qed."
}
{
  "statement": "Lemma maxACA : interchange (max : T -> T -> T) max.\n",
  "proof": "Proof. by move=> x y z t; apply: comparable_maxACA. Qed."
}
{
  "statement": "Lemma cfRepr0 : cfRepr grepr0 = 0.\n",
  "proof": "Proof. by apply/cfun_inP=> x Gx; rewrite !cfunE Gx mxtrace1. Qed."
}
{
  "statement": "Lemma allrelT {T S : Type} (xs : seq T) (ys : seq S) :\n  allrel (fun _ _ => true) xs ys = true.\n",
  "proof": "Proof. by elim: xs => //= ? ?; rewrite allrel_consl all_predT. Qed."
}
{
  "statement": "Lemma intr_nat : {subset nat_num <= int_num}.\n",
  "proof": "Proof. by move=> _ /natrP[n ->]; rewrite pmulrn intr_int. Qed."
}
{
  "statement": "Lemma bigdprodWcp I (r : seq I) P F G :\n  \\big[dprod/1]_(i <- r | P i) F i = G -> \\big[cprod/1]_(i <- r | P i) F i = G.\n",
  "proof": "Proof.\nelim/big_rec2: _ G => // i A B _ IH G /dprodP[[K H -> defB] <- cKH _].\nby rewrite (IH H) // cprodE -defB.\nQed."
}
{
  "statement": "Lemma allrel_filterl a xs ys : allrel xs ys -> allrel (filter a xs) ys.\n",
  "proof": "Proof. by rewrite filter_mask; apply: allrel_maskl. Qed."
}
{
  "statement": "Lemma allrel_filterr a xs ys : allrel xs ys -> allrel xs (filter a ys).\n",
  "proof": "Proof. by rewrite filter_mask; apply: allrel_maskr. Qed."
}
{
  "statement": "Lemma prod_mx_repr : mx_repr G (fun g => tprod (rG1 g) (rG2 g)).\n",
  "proof": "Proof.\nsplit=>[|i j InG JnG]; first by rewrite !repr_mx1 tprod1.\nby rewrite !repr_mxM // tprodE.\nQed."
}
{
  "statement": "Lemma col_permM s t A : col_perm (s * t) A = col_perm s (col_perm t A).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE permM. Qed."
}
{
  "statement": "Lemma eval_vec_mx e m n (u : 'rV_(m * n)) :\n  eval_mx e (vec_mx u) = vec_mx (eval_mx e u).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma R3_inj : injective R3.\n",
  "proof": "Proof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed."
}
{
  "statement": "Lemma scalemx_const a b : a *: const_mx b = const_mx (a * b).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma gen_set_id A : group_set A -> <<A>> = A.\n",
  "proof": "Proof. by move=> gA; apply: (genGid (group gA)). Qed."
}
{
  "statement": "Lemma central_factor_central H K :\n  central_factor G H K -> (K / H) \\subset 'Z(G / H).\n",
  "proof": "Proof. by case/and3P=> /quotient_cents2r *; rewrite subsetI quotientS. Qed."
}
{
  "statement": "Lemma eq_map_all I (T : eqType) (f g : I -> T) (s : seq I) :\n  (map f s == map g s) = all [pred xy | xy.1 == xy.2] [seq (f i, g i) | i <- s].\n",
  "proof": "Proof. by rewrite eqseq_all all2E !size_map eqxx zip_map. Qed."
}
{
  "statement": "Lemma minnC : commutative minn.\n",
  "proof": "Proof. by rewrite /minn; elim=> [|m ih] [] // n; rewrite !ltnS -!fun_if ih. Qed."
}
{
  "statement": "Lemma submxrowK m (A : 'M[T]_(m, sq)) : \\mxrow_j (submxrow A j) = A.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed."
}
{
  "statement": "Lemma posxP x : eq0_xor_gt0 x (x == \\bot) (\\bot < x).\n",
  "proof": "Proof. by rewrite lt0x; have [] := eqVneq; constructor; rewrite ?lt0x. Qed."
}
{
  "statement": "Lemma row_permM s t A : row_perm (s * t) A = row_perm s (row_perm t A).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE permM. Qed."
}
{
  "statement": "Lemma cfMod_iso H G : H <| G -> isometry (@cfMod _ G H).\n",
  "proof": "Proof. by case/andP=> _; apply: cfMorph_iso. Qed."
}
{
  "statement": "Lemma dprodE G H : H \\subset 'C(G) -> G :&: H = 1 -> G \\x H = G * H.\n",
  "proof": "Proof. by move=> cGH trGH; rewrite /dprod trGH sub1G cprodE. Qed."
}
{
  "statement": "Lemma rem_uniq s : uniq s -> uniq (rem s).\n",
  "proof": "Proof. by apply: subseq_uniq; apply: rem_subseq. Qed."
}
{
  "statement": "Lemma mact_is_action : is_action D mact.\n",
  "proof": "Proof.\nsplit=> [a x y | x a b Da Db]; first exact: perm_inj.\nby rewrite /mact morphM //= permM.\nQed."
}
{
  "statement": "Lemma submxrowB m (B B' : 'M[V]_(m, sq)) j :\n submxrow (B - B') j = submxrow B j - submxrow B' j.\n",
  "proof": "Proof. by apply/matrixP => i i'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma submxrowD m (B B' : 'M[V]_(m, sq)) j :\n submxrow (B + B') j = submxrow B j + submxrow B' j.\n",
  "proof": "Proof. by apply/matrixP => i i'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma sqrtCM : {in Num.nneg &, {morph sqrtC : x y / x * y}}.\n",
  "proof": "Proof. by move=> x y _; apply: rootCMr. Qed."
}
{
  "statement": "Lemma size_rev s : size (rev s) = size s.\n",
  "proof": "Proof. by elim: s => // x s IHs; rewrite rev_cons size_rcons IHs. Qed."
}
{
  "statement": "Lemma eq_pairwise {T : Type} (r r' : rel T) :\n  r =2 r' -> pairwise r =i pairwise r'.\n",
  "proof": "Proof. by move=> rr' xs; apply/eq_in_pairwise/all_predT. Qed."
}
{
  "statement": "Lemma cfdotNr xi phi : '[xi, - phi] = - '[xi, phi].\n",
  "proof": "Proof. exact: raddfN. Qed."
}
{
  "statement": "Lemma fconnect_id (x : T) : fconnect id x =1 xpred1 x.\n",
  "proof": "Proof. by move=> y; rewrite (@fconnect_cycle _ _ [:: x]) //= ?inE ?eqxx. Qed."
}
{
  "statement": "Lemma logn1 p : logn p 1 = 0.\n",
  "proof": "Proof. by rewrite lognE dvdn1 /= andbC; case: eqP => // ->. Qed."
}
{
  "statement": "Lemma max_minr : right_distributive (max : T -> T -> T) min.\n",
  "proof": "Proof. by move=> x y z; apply: comparable_max_minr. Qed."
}
{
  "statement": "Lemma min_maxr : right_distributive (min : T -> T -> T) max.\n",
  "proof": "Proof. by move=> x y z; apply: comparable_min_maxr. Qed."
}
{
  "statement": "Lemma conjC_vcharAut chi x : chi \\in 'Z[irr G] -> (u (chi x))^* = u (chi x)^*.\n",
  "proof": "Proof.\ncase/vcharP=> chi1 Nchi1 [chi2 Nchi2 ->].\nby rewrite !cfunE !rmorphB !conjC_charAut.\nQed."
}
{
  "statement": "Lemma rowg_mxK (L : {group rVn}) : rowg (rowg_mx L) = L.\n",
  "proof": "Proof. by apply: stable_rowg_mxK; apply: mx_Fp_stable. Qed."
}
{
  "statement": "Lemma setIK A B : (A :&: B) :|: A = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbK. Qed."
}
{
  "statement": "Lemma setUIl A B C : (A :&: B) :|: C = (A :|: C) :&: (B :|: C).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE orb_andl. Qed."
}
{
  "statement": "Lemma vsvalK : cancel vsval vsproj.\n",
  "proof": "Proof. by move=> w; apply/val_inj/vsprojK/subvsP. Qed."
}
{
  "statement": "Lemma big_endo I r (P : pred I) F :\n  f (\\big[op/idx]_(i <- r | P i) F i) = \\big[op/idx]_(i <- r | P i) f (F i).\n",
  "proof": "Proof. exact: big_morph. Qed."
}
{
  "statement": "Lemma submxcolN m (B : 'M[V]_(sp, m)) i :\n submxcol (- B) i = - submxcol B i.\n",
  "proof": "Proof. by apply/matrixP => j j'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma nat_of_mul_pos p q : Pos.mul p q = p * q :> nat.\n",
  "proof": "Proof.\nelim: p => [p IHp|p IHp|] /=; rewrite ?mul1n //;\n  by rewrite ?nat_of_add_pos /= !natTrecE IHp doubleMl.\nQed."
}
{
  "statement": "Lemma cprodP A B G :\n  A \\* B = G -> [/\\ are_groups A B, A * B = G & B \\subset 'C(A)].\n",
  "proof": "Proof. by rewrite /cprod; case: ifP => [cAB /pprodP[] | _ /group_not0[]]. Qed."
}
{
  "statement": "Lemma map_mxZ a A : (a *: A)^f = f a *: A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE rmorphM. Qed."
}
{
  "statement": "Lemma trmx_const a : trmx (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma horner_cons p c x : (cons_poly c p).[x] = p.[x] * x + c.\n",
  "proof": "Proof.\nrewrite /horner polyseq_cons; case: nilP => //= ->.\nby rewrite !simp -/(_.[x]) hornerC.\nQed."
}
{
  "statement": "Lemma ltr_pMn2l x :\n  0 < x -> {mono (@GRing.natmul R x) : m n / (m < n)%N >-> m < n}.\n",
  "proof": "Proof. by move=> x_gt0; apply: leW_mono (ler_pMn2l _). Qed."
}
{
  "statement": "Lemma tr_submxcol n (A : 'M[T]_(sp, n)) i :\n  (submxcol A i)^T = (submxrow A^T i).\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma tr_submxrow n (A : 'M[T]_(n, sp)) j :\n  (submxrow A j)^T = (submxcol A^T j).\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma mulrI : {in @unit R, right_injective *%R}.\n",
  "proof": "Proof. by move=> x Ux; apply: can_inj (mulKr Ux). Qed."
}
{
  "statement": "Lemma min_maxl : left_distributive (min : T -> T -> T) max.\n",
  "proof": "Proof. by move=> x y z; apply: comparable_min_maxl. Qed."
}
{
  "statement": "Lemma enum_val_inj A : injective (@enum_val A).\n",
  "proof": "Proof. by move=> i; apply: can_inj (enum_valK_in (enum_valP i)) (i). Qed."
}
{
  "statement": "Lemma enum_val_inj A : injective (@enum_val A).\n",
  "proof": "Proof. by move=> i; apply: can_inj (enum_valK_in (enum_valP i)) (i). Qed."
}
{
  "statement": "Lemma max_minl : left_distributive (max : T -> T -> T) min.\n",
  "proof": "Proof. by move=> x y z; apply: comparable_max_minl. Qed."
}
{
  "statement": "Lemma realrM x y : y != 0 -> y \\is real -> (x * y \\is real) = (x \\is real).\n",
  "proof": "Proof. by move=> y_neq0 yR; rewrite mulrC realMr. Qed."
}
{
  "statement": "Lemma injm_subnorm A B : B \\subset D -> f @* 'N_A(B) = 'N_(f @* A)(f @* B).\n",
  "proof": "Proof. by move=> sBD; rewrite injmI injm_norm // setICA setIA morphimIim. Qed."
}
{
  "statement": "Lemma setUK A B : (A :|: B) :&: A = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE orbK. Qed."
}
{
  "statement": "Lemma sdprodE K H : H \\subset 'N(K) -> K :&: H = 1 -> K ><| H = K * H.\n",
  "proof": "Proof. by move=> nKH tiKH; rewrite /sdprod tiKH subxx pprodE. Qed."
}
{
  "statement": "Lemma setKU A B : A :&: (B :|: A) = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE orKb. Qed."
}
{
  "statement": "Lemma rquot_IdomainAxiom (x y : {quot I}): x * y = 0 -> (x == 0) || (y == 0).\n",
  "proof": "Proof.\nby move=> /eqP; rewrite -[x]reprK -[y]reprK !piE !equivE !subr0 prime_idealrM.\nQed."
}
{
  "statement": "Lemma subset_itv_co_cc x y : {subset `[x, y[ <= `[x, y]}.\n",
  "proof": "Proof. by apply: subset_itv; rewrite bnd_simp. Qed."
}
{
  "statement": "Lemma subset_itv_oc_cc x y : {subset `]x, y] <= `[x, y]}.\n",
  "proof": "Proof. by apply: subset_itv; rewrite bnd_simp. Qed."
}
{
  "statement": "Lemma subset_itv_oo_cc x y : {subset `]x, y[ <= `[x, y]}.\n",
  "proof": "Proof. by apply: subset_itv; rewrite bnd_simp. Qed."
}
{
  "statement": "Lemma subset_itv_oo_co x y : {subset `]x, y[ <= `[x, y[}.\n",
  "proof": "Proof. by apply: subset_itv; rewrite bnd_simp. Qed."
}
{
  "statement": "Lemma subset_itv_oo_oc x y : {subset `]x, y[ <= `]x, y]}.\n",
  "proof": "Proof. by apply: subset_itv; rewrite bnd_simp. Qed."
}
{
  "statement": "Lemma divpN p q : (- p) %/ q = - (p %/ q).\n",
  "proof": "Proof. by apply/eqP; rewrite -addr_eq0 -divpD addNr div0p. Qed."
}
{
  "statement": "Lemma conjumx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx V f = V *m f *m invmx V.\n",
  "proof": "Proof. by move=> uV; rewrite /conjmx pinvmxE. Qed."
}
{
  "statement": "Lemma conjumx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx V f = V *m f *m invmx V.\n",
  "proof": "Proof. by move=> uV; rewrite /conjmx pinvmxE. Qed."
}
{
  "statement": "Lemma mulIr : {in @unit R, left_injective *%R}.\n",
  "proof": "Proof. by move=> x Ux; apply: can_inj (mulrK Ux). Qed."
}
{
  "statement": "Lemma setIUl A B C : (A :|: B) :&: C = (A :&: C) :|: (B :&: C).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andb_orl. Qed."
}
{
  "statement": "Lemma quotientDG A G : H \\subset G -> (A :\\: G) / H = A / H :\\: G / H.\n",
  "proof": "Proof. by rewrite -{1}ker_coset; apply: morphimDG. Qed."
}
{
  "statement": "Lemma lead_coefC c : lead_coef c%:P = c.\n",
  "proof": "Proof. by rewrite /lead_coef polyseqC; case: eqP. Qed."
}
{
  "statement": "Lemma card_homg (aT rT : finGroupType) (G : {group aT}) (R : {group rT}) :\n  G \\homg R -> #|G| %| #|R|.\n",
  "proof": "Proof. by case/homgP=> f <-; rewrite card_morphim setIid dvdn_indexg. Qed."
}
{
  "statement": "Lemma cfAutZ_Cnat z phi : z \\in Num.nat -> (z *: phi)^u = z *: phi^u.\n",
  "proof": "Proof. exact: raddfZ_nat. Qed."
}
{
  "statement": "Lemma gal_kHom K E x : (K <= E)%VS -> (x \\in 'Gal(E / K)) = kHom K E x.\n",
  "proof": "Proof. by move/gal_kAut->; rewrite /kAut limg_gal eqxx andbT. Qed."
}
{
  "statement": "Lemma mxcol0 m : \\mxcol_i (0 : 'M[V]_(p_ i, m)) = 0.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma setKI A B : A :|: (B :&: A) = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andKb. Qed."
}
{
  "statement": "Lemma submxblock0 i j : submxblock (0 : 'M[V]_(sp, sq)) i j = 0.\n",
  "proof": "Proof. by apply/matrixP=> k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma divpK d p : d %| p -> p %/ d * d = (lead_coef d ^+ scalp p d) *: p.\n",
  "proof": "Proof. by rewrite dvdp_eq; move/eqP->. Qed."
}
{
  "statement": "Lemma setUIr A B C : A :|: (B :&: C) = (A :|: B) :&: (A :|: C).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE orb_andr. Qed."
}
{
  "statement": "Lemma dirr_constt_oppl (phi: 'CF(G)) i :\n  i \\in dirr_constt phi -> (ndirr i) \\notin dirr_constt phi.\n",
  "proof": "Proof.\nby rewrite !dirr_consttE dchi_ndirrE cfdotNr oppr_gt0 => /ltW /le_gtF ->.\nQed."
}
{
  "statement": "Lemma porbit_perm s i x : porbit s ((s ^+ i) x) = porbit s x.\n",
  "proof": "Proof. by apply/eqP; rewrite eq_porbit_mem mem_porbit. Qed."
}
{
  "statement": "Lemma exprn_ege1 n x : 1 <= x -> 1 <= x ^+ n.\n",
  "proof": "Proof.\nby move=> x_ge1; elim: n=> [|n ihn]; rewrite ?expr0 // exprS mulr_ege1.\nQed."
}
{
  "statement": "Lemma in_gen0 : in_gen 0 = 0.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE !(mul0mx, linear0). Qed."
}
{
  "statement": "Lemma divring_closedBM : divring_closed -> subring_closed S.\n",
  "proof": "Proof. by case=> S1 SB Sdiv; split=> //; case: divr_closedM. Qed."
}
{
  "statement": "Lemma eq_in_all s : {in s, a1 =1 a2} -> all a1 s = all a2 s.\n",
  "proof": "Proof. by move=> eq_a12; rewrite !all_count eq_in_count. Qed."
}
{
  "statement": "Lemma modpN p q : (- p) %% q = - (p %% q).\n",
  "proof": "Proof. by apply/eqP; rewrite -addr_eq0 -modpD addNr mod0p. Qed."
}
{
  "statement": "Lemma quotientGI G A : H \\subset G -> (G :&: A) / H = G / H :&: A / H.\n",
  "proof": "Proof. by rewrite -{1}ker_coset; apply: morphimGI. Qed."
}
{
  "statement": "Lemma consr_infix s1 s2 x : infix (x :: s1) s2 -> infix [:: x] s2.\n",
  "proof": "Proof. by rewrite -cat1s => /catr_infix. Qed."
}
{
  "statement": "Lemma quotientIG A G : H \\subset G -> (A :&: G) / H = A / H :&: G / H.\n",
  "proof": "Proof. by rewrite -{1}ker_coset; apply: morphimIG. Qed."
}
{
  "statement": "Lemma isSome_insub : ([eta insub] : pred T) =1 P.\n",
  "proof": "Proof. by apply: fsym => x; case: insubP => // /negPf. Qed."
}
{
  "statement": "Lemma mulKVmx m : {in unitmx, @rev_left_loop _ 'M_(n, m) invmx mulmx}.\n",
  "proof": "Proof. by move=> A uA /= B; rewrite mulmxA mulmxV ?mul1mx. Qed."
}
{
  "statement": "Lemma conjuMumx (n : nat) (V W f : 'M[F]_n) :\n  V \\in unitmx -> W \\in unitmx ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\n",
  "proof": "Proof. by move=> Vu Wu; rewrite conjuMmx ?stablemx_unit ?row_free_unit. Qed."
}
{
  "statement": "Lemma conjuMumx (n : nat) (V W f : 'M[F]_n) :\n  V \\in unitmx -> W \\in unitmx ->\n  conjmx (V *m W) f = conjmx V (conjmx W f).\n",
  "proof": "Proof. by move=> Vu Wu; rewrite conjuMmx ?stablemx_unit ?row_free_unit. Qed."
}
{
  "statement": "Lemma mulKmx m : {in unitmx, @left_loop _ 'M_(n, m) invmx mulmx}.\n",
  "proof": "Proof. by move=> A uA /= B; rewrite mulmxA mulVmx ?mul1mx. Qed."
}
{
  "statement": "Lemma divKr x : x \\is a unit -> {in unit, involutive (fun y => x / y)}.\n",
  "proof": "Proof. by move=> Ux y Uy; rewrite /= invrM ?unitrV // invrK mulrC divrK. Qed."
}
{
  "statement": "Lemma map2_trmx : (map2_mx A B)^T = map2_mx A^T B^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma isog_nil rT G (L : {group rT}) : G \\isog L -> nilpotent G = nilpotent L.\n",
  "proof": "Proof. by case/isogP=> f injf <-; rewrite injm_nil. Qed."
}
{
  "statement": "Lemma lift_permV i j s : (lift_perm i j s)^-1 = lift_perm j i s^-1.\n",
  "proof": "Proof. by apply/eqP; rewrite eq_invg_mul lift_permM mulgV lift_perm1. Qed."
}
{
  "statement": "Lemma sum_lfunE I (r : seq I) (P : pred I) (fs : I -> 'Hom(aT, rT)) x :\n  (\\sum_(i <- r | P i) fs i) x = \\sum_(i <- r | P i) fs i x.\n",
  "proof": "Proof. by elim/big_rec2: _ => [|i _ f _ <-]; rewrite lfunE. Qed."
}
{
  "statement": "Lemma scalemxA x y A : x *m: (y *m: A) = (x * y) *m: A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE mulrA. Qed."
}
{
  "statement": "Lemma gcdp_modl m n : gcdp (m %% n) n %= gcdp m n.\n",
  "proof": "Proof.\nhave [/modp_small -> // | lenm] := ltnP (size m) (size n).\nby rewrite (gcdpE m n) ltnNge lenm.\nQed."
}
{
  "statement": "Lemma injmK A : A \\subset D -> f @*^-1 (f @* A) = A.\n",
  "proof": "Proof. by move=> sAD; rewrite morphimK // ker_injm // mul1g. Qed."
}
{
  "statement": "Lemma hnorm_sign n u : '[(-1) ^+ n *: u] = '[u].\n",
  "proof": "Proof. by rewrite -signr_odd scaler_sign; case: (odd n); rewrite ?hnormN. Qed."
}
{
  "statement": "Lemma form_sign m u : '[(-1) ^+ m *: u] = '[u].\n",
  "proof": "Proof. by rewrite -signr_odd scaler_sign; case: odd; rewrite ?formN. Qed."
}
{
  "statement": "Lemma setI_powerset P A : P :&: powerset A = P ::&: A.\n",
  "proof": "Proof. by apply/setP=> B; rewrite !inE. Qed."
}
{
  "statement": "Lemma row_perm_const s a : row_perm s (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma setUid A : A :|: A = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite inE orbb. Qed."
}
{
  "statement": "Lemma col_perm_const s a : col_perm s (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eq_row_sub m n v (A : 'M_(m, n)) i : row i A = v -> (v <= A)%MS.\n",
  "proof": "Proof. by move <-; rewrite row_sub. Qed."
}
{
  "statement": "Lemma eqAmodMr0 e : {in Aint, forall x, e * x == 0 %[mod e]}%A.\n",
  "proof": "Proof. by move=> x Zx; rewrite /= mulrC eqAmodMl0. Qed."
}
{
  "statement": "Lemma map_regular_mx x : (regular_mx aR G x)^f = regular_mx rR G x.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE rmorph_nat. Qed."
}
{
  "statement": "Lemma bseq_tagged_tupleK {n T} :\n  cancel (@bseq_tagged_tuple n T) tagged_tuple_bseq.\n",
  "proof": "Proof. by move=> bs; apply/val_inj. Qed."
}
{
  "statement": "Lemma eq_map (f g : S -> T) : f =1 g -> map f =1 map g.\n",
  "proof": "Proof. by move=> Ef; elim=> //= x s ->; rewrite Ef. Qed."
}
{
  "statement": "Lemma conjVmx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx (invmx V) f = invmx V *m f *m V.\n",
  "proof": "Proof. by move=> Vunit; rewrite conjumx ?invmxK ?unitmx_inv. Qed."
}
{
  "statement": "Lemma conjVmx (n : nat) (V : 'M_n) (f : 'M[F]_n) : V \\in unitmx ->\n  conjmx (invmx V) f = invmx V *m f *m V.\n",
  "proof": "Proof. by move=> Vunit; rewrite conjumx ?invmxK ?unitmx_inv. Qed."
}
{
  "statement": "Lemma mulmx1_min_rank r m n (A : 'M_(m, n)) M N :\n  M *m A *m N = 1%:M :> 'M_r -> r <= \\rank A.\n",
  "proof": "Proof. by rewrite -{1}(mulmx_base A) mulmxA -mulmxA; move/mulmx1_min. Qed."
}
{
  "statement": "Lemma cprod_modr A B G H :\n  A \\* B = G -> B \\subset H -> (H :&: A) \\* B = H :&: G.\n",
  "proof": "Proof. by rewrite -!(cprodC B) !(setIC H); apply: cprod_modl. Qed."
}
{
  "statement": "Lemma cfker_sub phi : cfker phi \\subset G.\n",
  "proof": "Proof. by rewrite /cfker setIdE subsetIl. Qed."
}
{
  "statement": "Lemma dprod_modr A B G H :\n  A \\x B = G -> B \\subset H -> (H :&: A) \\x B = H :&: G.\n",
  "proof": "Proof. by rewrite -!(dprodC B) !(setIC H); apply: dprod_modl. Qed."
}
{
  "statement": "Lemma widen_bseqK m n (lemn : m <= n) (lenm : n <= m) :\n   cancel (@widen_bseq m n lemn) (widen_bseq lenm).\n",
  "proof": "Proof. by move=> t; apply: val_inj. Qed."
}
{
  "statement": "Lemma eq_mxcol n (A_ B_ : forall i, 'M[T]_(p_ i, n)) :\n  (forall i, A_ i = B_ i) -> (\\mxcol_i A_ i = \\mxcol_i B_ i).\n",
  "proof": "Proof. by move=> /eq_mxcolP. Qed."
}
{
  "statement": "Lemma setIUr A B C : A :&: (B :|: C) = (A :&: B) :|: (A :&: C).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andb_orr. Qed."
}
{
  "statement": "Lemma all_pmap (p : pred rT) s :\n  all p (pmap s) = all [pred i | oapp p true (f i)] s.\n",
  "proof": "Proof. by elim: s => //= x s <-; case: f. Qed."
}
{
  "statement": "Lemma submxcolB m (B B' : 'M[V]_(sp, m)) i :\n submxcol (B - B') i = submxcol B i - submxcol B' i.\n",
  "proof": "Proof. by apply/matrixP => j j'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma submxcolD m (B B' : 'M[V]_(sp, m)) i :\n submxcol (B + B') i = submxcol B i + submxcol B' i.\n",
  "proof": "Proof. by apply/matrixP => j j'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eval_opppT (p : polyF) (e : seq F) :\n  eval_poly e (opppT p) = - eval_poly e p.\n",
  "proof": "Proof.\nby elim: p; rewrite /= ?oppr0 // => ? ? ->; rewrite !mulNr opprD polyCN mul1r.\nQed."
}
{
  "statement": "Lemma nth_enum_ord i0 m : m < n -> nth i0 (enum 'I_n) m = m :> nat.\n",
  "proof": "Proof.\nby move=> ?; rewrite -(nth_map _ 0) (size_enum_ord, val_enum_ord) // nth_iota.\nQed."
}
{
  "statement": "Lemma submxcolK n (A : 'M[T]_(sp, n)) : \\mxcol_i (submxcol A i) = A.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE !sig2K. Qed."
}
{
  "statement": "Lemma rootCMr n x z : 0 <= x -> n.-root (z * x) = n.-root z * n.-root x.\n",
  "proof": "Proof. by move=> x_ge0; rewrite mulrC rootCMl // mulrC. Qed."
}
{
  "statement": "Lemma atransP2in G S :\n    G \\subset D -> [transitive G, on S | to] ->\n  {in S &, forall x y, exists2 a, a \\in G & y = to x a}.\n",
  "proof": "Proof. by move=> sGD transG x y /(atransPin sGD transG) <- /imsetP. Qed."
}
{
  "statement": "Lemma scaler_injl : {in unit, @right_injective R A A *:%R}.\n",
  "proof": "Proof.\nmove=> k Uk x1 x2 Hx1x2.\nby rewrite -[x1]scale1r -(mulVr Uk) -scalerA Hx1x2 scalerA mulVr // scale1r.\nQed."
}
{
  "statement": "Lemma conjg_prod I r (P : pred I) F z :\n  (\\prod_(i <- r | P i) F i) ^ z = \\prod_(i <- r | P i) (F i ^ z).\n",
  "proof": "Proof.\nby apply: (big_morph (conjg^~ z)) => [x y|]; rewrite ?conj1g ?conjMg.\nQed."
}
{
  "statement": "Lemma modn2 m : m %% 2 = odd m.\n",
  "proof": "Proof. by elim: m => //= m IHm; rewrite -addn1 -modnDml IHm; case odd. Qed."
}
{
  "statement": "Lemma setUA A B C : A :|: (B :|: C) = A :|: B :|: C.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE orbA. Qed."
}
{
  "statement": "Lemma Ind_irr_neq0 i : H \\subset G -> 'Ind[G, H] 'chi_i != 0.\n",
  "proof": "Proof. by move/cfInd_eq0->; rewrite ?irr_neq0 ?irr_char. Qed."
}
{
  "statement": "Lemma cycle_relI s :\n  cycle [rel x y | e x y && e' x y] s = cycle e s && cycle e' s.\n",
  "proof": "Proof. by case: s => [|? ?]; last apply: path_relI. Qed."
}
{
  "statement": "Lemma big_enum_val (I : finType) (A : pred I) F :\n  \\big[op/idx]_(x in A) F x = \\big[op/idx]_(i < #|A|) F (enum_val i).\n",
  "proof": "Proof. by rewrite -(big_enum_val_cond predT) big_mkcondr. Qed."
}
{
  "statement": "Lemma cent_norm A : 'N(A) \\subset 'N('C(A)).\n",
  "proof": "Proof. by apply/normsP=> x nCx; rewrite -centJ (normP nCx). Qed."
}
{
  "statement": "Lemma cprod_normal2 A B G : A \\* B = G -> A <| G /\\ B <| G.\n",
  "proof": "Proof.\ncase/cprodP=> [[K H -> ->] <- cKH]; rewrite -cent_joinEr //.\nby rewrite normalYl normalYr !cents_norm // centsC.\nQed."
}
{
  "statement": "Lemma scale1mx A : 1 *m: A = A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE mul1r. Qed."
}
{
  "statement": "Lemma cfunJ phi x y : y \\in G -> phi (x ^ y) = phi x.\n",
  "proof": "Proof. by rewrite -{1}(genGid G) => /(cfunJgen phi)->. Qed."
}
{
  "statement": "Lemma undup_uniq s : uniq (undup s).\n",
  "proof": "Proof.\nby elim: s => //= x s IHs; case s_x: (x \\in s); rewrite //= mem_undup s_x.\nQed."
}
{
  "statement": "Lemma meets_inf_seq T (r : seq T) (P : {pred T}) (F : T -> L) (x : T) :\n  x \\in r -> P x -> \\meet_(i <- r | P i) F i <= F x.\n",
  "proof": "Proof. by move=> xr Px; rewrite (big_rem x) ?Px //= leIl. Qed."
}
{
  "statement": "Lemma rpredXsign (R : unitRingType) (S : divClosed R) n x :\n  (x ^ ((-1) ^+ n) \\in S) = (x \\in S).\n",
  "proof": "Proof. by rewrite -signr_odd; case: (odd n); rewrite ?rpredV. Qed."
}
{
  "statement": "Lemma submxblockN (B : 'M[V]_(sp, sq)) i j :\n submxblock (- B) i j = - submxblock B i j.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma mulg_nil G H :\n  H \\subset 'C(G) -> nilpotent (G * H) = nilpotent G && nilpotent H.\n",
  "proof": "Proof. by move=> cGH; rewrite -(cprod_nil (cprodEY cGH)) /= cent_joinEr. Qed."
}
{
  "statement": "Lemma adjZ n a (A : 'M[R]_n) : \\adj (a *: A) = a^+n.-1 *: \\adj A.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE cofactorZ. Qed."
}
{
  "statement": "Lemma morphim_center : GFunctor.pcontinuous (@center).\n",
  "proof": "Proof. by move=> gT rT G D f; apply: morphim_subcent. Qed."
}
{
  "statement": "Lemma morphim_injm_eq1 A : A \\subset D -> (f @* A == 1) = (A == 1).\n",
  "proof": "Proof. by move=> sAD; rewrite -morphim1 injm_eq ?sub1G. Qed."
}
{
  "statement": "Lemma Euclid_dvd1 p : prime p -> (p %| 1) = false.\n",
  "proof": "Proof. by rewrite dvdn1; case: eqP => // ->. Qed."
}
{
  "statement": "Lemma set_enum A : [set x | x \\in enum A] = A.\n",
  "proof": "Proof. by apply/setP => x; rewrite in_set mem_enum. Qed."
}
{
  "statement": "Lemma cfMod_eq1 psi : B <| G -> (psi %% B == 1)%CF = (psi == 1).\n",
  "proof": "Proof. by move/cfModK/can_eq <-; rewrite rmorph1. Qed."
}
{
  "statement": "Lemma scaler_nat n v : n%:R *: v = v *+ n.\n",
  "proof": "Proof.\nelim: n => /= [|n]; first by rewrite scale0r.\nby rewrite !mulrS scalerDl ?scale1r => ->.\nQed."
}
{
  "statement": "Lemma cycleX x i : <[x ^+ i]> \\subset <[x]>.\n",
  "proof": "Proof. by rewrite cycle_subG; apply: mem_cycle. Qed."
}
{
  "statement": "Lemma eqfunP f1 f2 : reflect (forall x, f1 x = f2 x) [forall x, f1 x == f2 x].\n",
  "proof": "Proof. exact: 'forall_eqP. Qed."
}
{
  "statement": "Lemma subg_default x : (x \\in G) = false -> val (subg x) = 1.\n",
  "proof": "Proof. by move=> Gx; rewrite val_insubd Gx. Qed."
}
{
  "statement": "Lemma cfConjg_char (chi : 'CF(H)) y :\n  chi \\is a character -> (chi ^ y)%CF \\is a character.\n",
  "proof": "Proof.\nhave [nHy Nchi | /cfConjgEout-> //] := boolP (y \\in 'N(H)).\nby rewrite cfConjgEin cfIsom_char.\nQed."
}
{
  "statement": "Lemma trmx_adj n (A : 'M[R]_n) : (\\adj A)^T = \\adj A^T.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE cofactor_tr. Qed."
}
{
  "statement": "Lemma sgr_denq x : sgr (denq x) = 1. ",
  "proof": "Proof. by apply/eqP; rewrite sgr_cp0. Qed."
}
{
  "statement": "Lemma constt_p_elt pi x : pi.-elt x -> x.`_pi = x.\n",
  "proof": "Proof.\nby rewrite -p_eltNK -{3}(consttC pi x) => /constt1P->; rewrite mulg1.\nQed."
}
{
  "statement": "Lemma mxsub_const m' n' f g a : @mxsub m' n' f g (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP => i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma cfdot_conjC phi psi : '[phi^*, psi^*] = '[phi, psi]^*.\n",
  "proof": "Proof. by rewrite cfdot_cfAut. Qed."
}
{
  "statement": "Lemma map_mx_adj (A : 'M_n) : (\\adj A)^f = \\adj A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE cofactor_map_mx. Qed."
}
{
  "statement": "Lemma acts_in_orbit A S x y :\n  [acts A, on S | to] -> y \\in orbit to A x -> x \\in S -> y \\in S.\n",
  "proof": "Proof.\nby move=> nSA/imsetP[a Aa ->{y}] Sx; rewrite (astabs_act _ (subsetP nSA a Aa)).\nQed."
}
{
  "statement": "Lemma mulmxKV m : {in unitmx, @rev_right_loop 'M_(m, n) _ invmx mulmx}.\n",
  "proof": "Proof. by move=> A uA /= B; rewrite -mulmxA mulVmx ?mulmx1. Qed."
}
{
  "statement": "Lemma mulmxK m : {in unitmx, @right_loop 'M_(m, n) _ invmx mulmx}.\n",
  "proof": "Proof. by move=> A uA /= B; rewrite -mulmxA mulmxV ?mulmx1. Qed."
}
{
  "statement": "Lemma modz_abs m d : (m %% `|d|%N)%Z = (m %% d)%Z.\n",
  "proof": "Proof. by rewrite {2}[d]intEsign mulr_sign; case: ifP; rewrite ?modzN. Qed."
}
{
  "statement": "Lemma morphpre_idm A B : idm A @*^-1 B = A :&: B.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE. Qed."
}
{
  "statement": "Lemma cfdot_conjCl phi psi : '[phi^*, psi] = '[phi, psi^*]^*.\n",
  "proof": "Proof. by rewrite -cfdot_conjC cfConjCK. Qed."
}
{
  "statement": "Lemma cfdot_conjCr phi psi : '[phi, psi^*] = '[phi^*, psi]^*.\n",
  "proof": "Proof. by rewrite -cfdot_conjC cfConjCK. Qed."
}
{
  "statement": "Lemma fcycle_undup : fcycle f (undup p).\n",
  "proof": "Proof.\ncase: p f_p => [//|x q] f_q; rewrite undup_cycle_cons//.\nby rewrite (cycle_orbit_in (mem_fcycle f_q) (inj_cycle f_q)) ?mem_head.\nQed."
}
{
  "statement": "Lemma normC_rect :\n  {in real &, forall x y, `|x + 'i * y| = sqrtC (x ^+ 2 + y ^+ 2)}.\n",
  "proof": "Proof. by move=> x y Rx Ry; rewrite /= normC_def -normCK normC2_rect. Qed."
}
{
  "statement": "Lemma rmodp_sum (I : Type) (r : seq I) (P : pred I) (F : I -> {poly R}) :\n   rmodp (\\sum_(i <- r | P i) F i) d = (\\sum_(i <- r | P i) (rmodp (F i) d)).\n",
  "proof": "Proof.\nby elim/big_rec2: _ => [|i p q _ <-]; rewrite ?(rmod0p, rmodpD).\nQed."
}
{
  "statement": "Lemma p_natP p n : p.-nat n -> {k | n = p ^ k}.\n",
  "proof": "Proof. by move=> p_n; exists (logn p n); rewrite -p_part part_pnat_id. Qed."
}
{
  "statement": "Lemma ucn_group_set gT (G : {group gT}) : group_set 'Z_n(G).\n",
  "proof": "Proof. by have [hZ ->] := ucn_pmap; apply: groupP. Qed."
}
{
  "statement": "Lemma qpoly_nontrivial : qpoly1 != 0.\n",
  "proof": "Proof. by apply/eqP/val_eqP; rewrite /= oner_eq0. Qed."
}
{
  "statement": "Lemma HallJ G H x : x \\in G -> Hall G (H :^ x) = Hall G H.\n",
  "proof": "Proof.\nby move=> Gx; rewrite /Hall -!divgI -{1 3}(conjGid Gx) conjSg -conjIg !cardJg.\nQed."
}
{
  "statement": "Lemma map_scalar_mx a : a%:M^f = (f a)%:M :> 'M_n.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE rmorphMn. Qed."
}
{
  "statement": "Lemma redivp_rec_loopP  (q : {poly F}) (c : nat) (qq r : {poly F}) (n : nat) :\n  redivp_rec q c qq r n = redivp_rec_loop q (size q) (lead_coef q) c qq r n.\n",
  "proof": "Proof. by elim: n c qq r => [| n Pn] c qq r //=; rewrite Pn. Qed."
}
{
  "statement": "Lemma subseq_sort_le : {homo sort <=%O : s1 s2 / @subseq T s1 s2}.\n",
  "proof": "Proof. exact/subseq_sort/le_trans/le_total. Qed."
}
{
  "statement": "Lemma setCI A B : ~: (A :&: B) = ~: A :|: ~: B.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE negb_and. Qed."
}
{
  "statement": "Lemma funsetC_mono : {homo funsetC : X Y / X \\subset Y}.\n",
  "proof": "Proof. by move=> *; rewrite subCset setCK F_mono// subCset setCK. Qed."
}
{
  "statement": "Lemma invr_sign n : ((-1) ^- n) = (-1) ^+ n :> R.\n",
  "proof": "Proof. by rewrite -signr_odd; case: (odd n); rewrite (invr1, invrN1). Qed."
}
{
  "statement": "Lemma dprodm_cprod : H \\* K = G.\n",
  "proof": "Proof.\nby rewrite -eqHK_G /dprod; case/dprodP: eqHK_G => _ _ _ ->; rewrite subxx.\nQed."
}
{
  "statement": "Lemma pnatNK pi n : pi^'^'.-nat n = pi.-nat n.\n",
  "proof": "Proof. exact: eq_pnat (negnK pi). Qed."
}
{
  "statement": "Lemma undup_map_inj s : undup (map f s) = map f (undup s).\n",
  "proof": "Proof. by elim: s => //= s0 s ->; rewrite mem_map //; case: (_ \\in _). Qed."
}
{
  "statement": "Lemma subg_mx_irr : mx_irreducible rH -> mx_irreducible rG.\n",
  "proof": "Proof. by apply: mxsimple_subg; apply: mxmodule1. Qed."
}
{
  "statement": "Lemma inj_tperm (T T' : finType) (f : T -> T') x y z :\n  injective f -> f (tperm x y z) = tperm (f x) (f y) (f z).\n",
  "proof": "Proof. by move=> injf; rewrite !permE /= !(inj_eq injf) !(fun_if f). Qed."
}
{
  "statement": "Lemma scale_col_mx m1 m2 n a (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  a *: col_mx A1 A2 = col_mx (a *: A1) (a *: A2).\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma lognSg p G H : G \\subset H -> logn p #|G| <= logn p #|H|.\n",
  "proof": "Proof. by move=> sGH; rewrite dvdn_leq_log ?cardSg. Qed."
}
{
  "statement": "Lemma opp_col_mx m1 m2 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  - col_mx A1 A2 = col_mx (- A1) (- A2).\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma gactX : {in D, forall a n, {in R, {morph to^~ a : x / x ^+ n}}}.\n",
  "proof": "Proof. by move=> a Da /= n x Rx; rewrite -!actmE // morphX. Qed."
}
{
  "statement": "Lemma proper_card A B : A \\proper B -> #|A| < #|B|.\n",
  "proof": "Proof.\nby case/andP=> sAB nsBA; rewrite ltn_neqAle !(subset_leqif_card sAB) andbT.\nQed."
}
{
  "statement": "Lemma exponent_dvdn G : exponent G %| #|G|.\n",
  "proof": "Proof. by apply/dvdn_biglcmP=> x Gx; apply: order_dvdG. Qed."
}
{
  "statement": "Lemma regular_norm_coprime K H :\n  H \\subset 'N(K) -> semiregular K H -> coprime #|K| #|H|.\n",
  "proof": "Proof.\nmove=> nKH regH.\nby rewrite (coprime_dvdr (regular_norm_dvd_pred nKH regH)) ?coprimenP.\nQed."
}
{
  "statement": "Lemma rowg_mx1 : rowg_mx 1%g = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite -submx0 -(rowg0 0) rowgK sub0mx. Qed."
}
{
  "statement": "Lemma group_not0 G : set0 <> G.\n",
  "proof": "Proof. by move/setP/(_ 1); rewrite inE group1. Qed."
}
{
  "statement": "Lemma submxblockB (B B' : 'M[V]_(sp, sq)) i j :\n submxblock (B - B') i j = submxblock B i j - submxblock B' i j.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma submxblockD (B B' : 'M[V]_(sp, sq)) i j :\n submxblock (B + B') i j = submxblock B i j + submxblock B' i j.\n",
  "proof": "Proof. by apply/matrixP => k l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma eq_block_mx Aul Aur Adl Adr Bul Bur Bdl Bdr :\n block_mx Aul Aur Adl Adr = block_mx Bul Bur Bdl Bdr ->\n  [/\\ Aul = Bul, Aur = Bur, Adl = Bdl & Adr = Bdr].\n",
  "proof": "Proof. by case/eq_col_mx; do 2!case/eq_row_mx=> -> ->. Qed."
}
{
  "statement": "Lemma mxblock0 : \\mxblock_(i, j) (0 : 'M[V]_(p_ i, q_ j)) = 0.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma quotient_Phi P H :\n  p.-group P -> P \\subset 'N(H) -> 'Phi(P) / H = 'Phi(P / H).\n",
  "proof": "Proof. exact: morphim_Phi. Qed."
}
{
  "statement": "Lemma divr_closedM : divr_closed -> mulr_closed S.\n",
  "proof": "Proof.\nby case=> S1 Sdiv; split=> // x y Sx Sy; rewrite -[y]invrK -[y^-1]mul1r !Sdiv.\nQed."
}
{
  "statement": "Lemma morphim_cent1 x : x \\in D -> f @* 'C[x] \\subset 'C[f x].\n",
  "proof": "Proof. by move=> Dx; rewrite -(morphim_set1 Dx) morphim_norm. Qed."
}
{
  "statement": "Lemma invg_expg x : x^-1 = x ^+ #[x].-1.\n",
  "proof": "Proof. by apply/eqP; rewrite eq_invg_mul -expgS prednK ?expg_order. Qed."
}
{
  "statement": "Lemma sub_vsof : {mono vsof : M M' / (M <= M')%MS >-> (M <= M')%VS}.\n",
  "proof": "Proof. by move=> M M'; rewrite vsof_sub (eqmxP (vsofK _)). Qed."
}
{
  "statement": "Lemma size_poly_eq n E : E n.-1 != 0 -> size (\\poly_(i < n) E i) = n.\n",
  "proof": "Proof. by move/polyseq_poly->; apply: size_mkseq. Qed."
}
{
  "statement": "Lemma setCU A B : ~: (A :|: B) = ~: A :&: ~: B.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE negb_or. Qed."
}
{
  "statement": "Lemma bigcapJ I r (P : pred I) (B : I -> {set gT}) x :\n  \\bigcap_(i <- r | P i) (B i :^ x) = (\\bigcap_(i <- r | P i) B i) :^ x.\n",
  "proof": "Proof.\nby rewrite (big_endo (conjugate^~ x)) => // [B1 B2|]; rewrite (conjTg, conjIg).\nQed."
}
{
  "statement": "Lemma subfield_closed K : agenv K = K.\n",
  "proof": "Proof.\nby apply/eqP; rewrite eqEsubv sub_agenv agenv_sub_modr ?sub1v ?asubv.\nQed."
}
{
  "statement": "Lemma tr_col_mx m1 m2 n (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) :\n  (col_mx A1 A2)^T = row_mx A1^T A2^T.\n",
  "proof": "Proof. by split_mxE. Qed."
}
{
  "statement": "Lemma map2_drsubmx : map2_mx (drsubmx B) (drsubmx B') = drsubmx (map2_mx B B').\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map2_ursubmx : map2_mx (ursubmx B) (ursubmx B') = ursubmx (map2_mx B B').\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma quotientYK G : G \\subset 'N(H) -> coset H @*^-1 (G / H) = H <*> G.\n",
  "proof": "Proof. by move=> nHG; rewrite quotientK ?norm_joinEr. Qed."
}
{
  "statement": "Lemma map2_dlsubmx : map2_mx (dlsubmx B) (dlsubmx B') = dlsubmx (map2_mx B B').\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma cforder_rmorph phi : #[f phi]%CF %| #[phi]%CF.\n",
  "proof": "Proof. by rewrite dvdn_cforder -rmorphXn exp_cforder rmorph1. Qed."
}
{
  "statement": "Lemma inj_onth_map {T S} n (s : seq T) (f : T -> S) x :\n  injective f -> onth (map f s) n = Some (f x) -> onth s n = Some x.\n",
  "proof": "Proof. by rewrite onth_map => /inj_omap + fs; apply. Qed."
}
{
  "statement": "Lemma dvdp_separable p q : q %| p -> separable p -> separable q.\n",
  "proof": "Proof.\nmove=> /(dvdp_trans _)q_dv_p /separable_polyP[sq'p nz_der1p].\nby apply/separable_polyP; split=> [u v /q_dv_p/sq'p | u /q_dv_p/nz_der1p].\nQed."
}
{
  "statement": "Lemma map2_ulsubmx : map2_mx (ulsubmx B) (ulsubmx B') = ulsubmx (map2_mx B B').\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma all_mask a m s : all a s -> all a (mask m s).\n",
  "proof": "Proof. by elim: s m => [|x s IHs] [|[] m]//= /andP[ax /IHs->]; rewrite ?ax. Qed."
}
{
  "statement": "Lemma tr_scalar_mx a : (a%:M)^T = a%:M.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE eq_sym. Qed."
}
{
  "statement": "Lemma sorted_mask_sort s m :\n  sorted leT (mask m s) -> {m_s | mask m_s (sort leT s) = mask m s}.\n",
  "proof": "Proof. by move/(sorted_sort leT_tr) <-; exact: mask_sort. Qed."
}
{
  "statement": "Lemma sub_kermx p m n (A : 'M_(m, n)) (B : 'M_(p, m)) :\n  (B <= kermx A)%MS = (B *m A == 0).\n",
  "proof": "Proof. exact/sub_kermxP/eqP. Qed."
}
{
  "statement": "Lemma gactR : {in D, forall a, {in R &, {morph to^~ a : x y / [~ x, y]}}}.\n",
  "proof": "Proof. by move=> a Da /= x Rx y Ry; rewrite -!actmE // morphR. Qed."
}
{
  "statement": "Lemma section_reprP s : section_repr s \\isog s.\n",
  "proof": "Proof.\nby rewrite /section_repr; case: pickP => //= /(_ s); rewrite isog_refl.\nQed."
}
{
  "statement": "Lemma xcprodmE :\n  {in H & K, forall x y, xcprodm (cpairg1 x * cpair1g y) = fH x * fK y}.\n",
  "proof": "Proof.\nby move=> x y Hx Ky; rewrite /xcprodm cprodmE ?mem_morphim ?ifactmE.\nQed."
}
{
  "statement": "Lemma expand_det_col n (A : 'M[R]_n) j0 :\n  \\det A = \\sum_i (A i j0 * cofactor A i j0).\n",
  "proof": "Proof.\nrewrite -det_tr (expand_det_row _ j0).\nby under eq_bigr do rewrite cofactor_tr mxE.\nQed."
}
{
  "statement": "Lemma invr_signM n x : ((-1) ^+ n * x)^-1 = (-1) ^+ n * x^-1.\n",
  "proof": "Proof. by rewrite -signr_odd !mulr_sign; case: ifP => // _; rewrite invrN. Qed."
}
{
  "statement": "Lemma sgrP x :\n  sgr_val x `|x| (0 == x) (x <= 0) (0 <= x) (x == 0) (x < 0) (0 < x)\n                 (0 == sg x) (-1 == sg x) (1 == sg x)\n                 (sg x == 0)  (sg x == -1) (sg x == 1) (sg x).\n",
  "proof": "Proof.\nby rewrite ![_ == sg _]eq_sym !sgr_cp0 /sg; case: ltrgt0P; constructor.\nQed."
}
{
  "statement": "Lemma R2_inj :  injective R2.\n",
  "proof": "Proof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed."
}
{
  "statement": "Lemma seq_sub_default s : size s > 0 -> seq_sub s.\n",
  "proof": "Proof. by case: s => // x s _; exists x; rewrite mem_head. Qed."
}
{
  "statement": "Lemma real_neqr_lt : {in real &, forall x y, (x != y) = (x < y) || (y < x)}.\n",
  "proof": "Proof. by move=> * /=; case: real_ltgtP. Qed."
}
{
  "statement": "Lemma sqrtr1 : sqrt 1 = 1 :> R.\n",
  "proof": "Proof. by move: (sqrtr_sqr 1); rewrite expr1n => ->; rewrite normr1. Qed."
}
{
  "statement": "Lemma mxrow_const m a : \\mxrow_j (const_mx a : 'M[V]_(m, q_ j)) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma conj_cfConjg phi y : (phi ^ y)^*%CF = (phi^* ^ y)%CF.\n",
  "proof": "Proof. exact: cfAutConjg. Qed."
}
{
  "statement": "Lemma comps_cons G H s : comps G (H :: s) -> comps H s.\n",
  "proof": "Proof. by case/andP => /= ls /andP[_]; rewrite /comps ls. Qed."
}
{
  "statement": "Lemma exists_eqP f1 f2 :\n  reflect (exists x, f1 x = f2 x) [exists x, f1 x == f2 x].\n",
  "proof": "Proof. exact: 'exists_eqP. Qed."
}
{
  "statement": "Lemma norm_normalI G A : G \\subset 'N(A) -> G :&: A <| G.\n",
  "proof": "Proof. by move=> nAG; rewrite /normal subsetIl normsI ?normG. Qed."
}
{
  "statement": "Lemma injm_subcent A B : B \\subset D -> f @* 'C_A(B) = 'C_(f @* A)(f @* B).\n",
  "proof": "Proof. by move=> sBD; rewrite injmI injm_cent // setICA setIA morphimIim. Qed."
}
{
  "statement": "Lemma enum_ord0 : enum 'I_0 = [::].\n",
  "proof": "Proof. by apply/eqP; rewrite -size_eq0 size_enum_ord. Qed."
}
{
  "statement": "Lemma map_rotr s : map (rotr n0 s) = rotr n0 (map s).\n",
  "proof": "Proof. by apply: canRL (rotK n0) _; rewrite -map_rot rotrK. Qed."
}
{
  "statement": "Lemma rowP (u v : 'rV[R]_n) : u 0 =1 v 0 <-> u = v.\n",
  "proof": "Proof. by split=> [eq_uv | -> //]; apply/matrixP=> i; rewrite ord1. Qed."
}
{
  "statement": "Lemma separable_root_der : separable_element K x (+) root (minPoly K x)^`() x.\n",
  "proof": "Proof.\nhave KpKx': _^`() \\is a polyOver K := polyOver_deriv (minPolyOver K x).\nrewrite separable_nz_der addNb (root_small_adjoin_poly KpKx') ?addbb //.\nby rewrite (leq_trans (size_poly _ _)) ?size_minPoly.\nQed."
}
{
  "statement": "Lemma row_const i0 a : row i0 (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/rowP=> j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma dirr_norm1 phi : phi \\in 'Z[irr G] -> '[phi] = 1 -> phi \\in dirr G.\n",
  "proof": "Proof. by rewrite dirrE => -> -> /=. Qed."
}
{
  "statement": "Lemma val_reprGLm x : x \\in G -> val (reprGLm x) = rG x.\n",
  "proof": "Proof. by move=> Gx; rewrite val_insubd (repr_mx_unitr rG). Qed."
}
{
  "statement": "Lemma mem_index_iota m n i : i \\in index_iota m n = (m <= i < n).\n",
  "proof": "Proof.\nrewrite mem_iota; case le_m_i: (m <= i) => //=.\nby rewrite -leq_subLR subSn // -subn_gt0 -subnDA subnKC // subn_gt0.\nQed."
}
{
  "statement": "Lemma enum_ord n : enum 'I_n = fintype.enum 'I_n.\n",
  "proof": "Proof.\nrewrite (sorted_sort le_trans)// -(@sorted_map _ _ (val : 'I_n -> nat))/=.\nby rewrite val_enum_ord iota_sorted.\nQed."
}
{
  "statement": "Lemma pair_big (I J : finType) (P : pred I) (Q : pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[*%M/1]_(j | Q j) F i j =\n    \\big[*%M/1]_(p | P p.1 && Q p.2) F p.1 p.2.\n",
  "proof": "Proof. exact/pair_big_idem/mul1m. Qed."
}
{
  "statement": "Lemma oppr_pchar2 x : - x = x.\n",
  "proof": "Proof. by apply/esym/eqP; rewrite -addr_eq0 addrr_pchar2. Qed."
}
{
  "statement": "Lemma gactJ : {in D, forall a, {in R &, {morph to^~ a : x y / x ^ y}}}.\n",
  "proof": "Proof. by move=> a Da /= x Rx y Ry; rewrite -!actmE // morphJ. Qed."
}
{
  "statement": "Lemma R1_inj :  injective R1.\n",
  "proof": "Proof. by inj_tac; repeat (destruct val => //=; first by apply/eqP). Qed."
}
{
  "statement": "Lemma pnat_id p : prime p -> p.-nat p.\n",
  "proof": "Proof. by move=> pr_p; rewrite pnatE ?inE /=. Qed."
}
{
  "statement": "Lemma prefix_prefix s1 s2 : prefix s1 (s1 ++ s2).\n",
  "proof": "Proof. by rewrite prefixE take_cat ltnn subnn take0 cats0. Qed."
}
{
  "statement": "Lemma mxval_is_multiplicative : multiplicative mxval.\n",
  "proof": "Proof. by split; [apply: mxvalM | apply: mxval1]. Qed."
}
{
  "statement": "Lemma irr_comp'_op0_pchar j A : j != iG -> (A \\in 'R_j)%MS -> gring_op rG A = 0.\n",
  "proof": "Proof. by rewrite eq_sym; apply: not_rsim_op0_pchar rsim_irr_comp_pchar. Qed."
}
{
  "statement": "Lemma disjoint_lexUr z x y : x `&` z = \\bot -> (x <= z `|` y) = (x <= y).\n",
  "proof": "Proof. by move=> xz0; rewrite joinC; rewrite disjoint_lexUl. Qed."
}
{
  "statement": "Lemma galoisS K M E : (K <= M <= E)%VS -> galois K E -> galois M E.\n",
  "proof": "Proof.\ncase/andP=> sKM sME /and3P[_ sepUV nUV].\nby rewrite /galois sME (separableSl sKM) ?(normalFieldS sKM).\nQed."
}
{
  "statement": "Lemma pair_big_dep (I J : finType) (P : pred I) (Q : I -> pred J) F :\n  \\big[*%M/1]_(i | P i) \\big[*%M/1]_(j | Q i j) F i j =\n    \\big[*%M/1]_(p | P p.1 && Q p.1 p.2) F p.1 p.2.\n",
  "proof": "Proof. exact/pair_big_dep_idem/mul1m. Qed."
}
{
  "statement": "Lemma pid_mx_id m n p r :\n  r <= n -> (pid_mx r : 'M_(m, n)) *m (pid_mx r : 'M_(n, p)) = pid_mx r.\n",
  "proof": "Proof. by move=> le_r_n; rewrite mul_pid_mx minnn (minn_idPr _). Qed."
}
{
  "statement": "Lemma map2_row_perm s :\n  map2_mx (row_perm s A) (row_perm s B) = row_perm s (map2_mx A B).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma mxcol_const m a : \\mxcol_j (const_mx a : 'M[V]_(p_ j, m)) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map2_col_perm s :\n  map2_mx (col_perm s A) (col_perm s B) = col_perm s (map2_mx A B).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma Socle_iso M : mxsimple M -> {W : sG | mx_iso (socle_base W) M}.\n",
  "proof": "Proof.\nby move=> simM; case/subSocle_iso: (simple_Socle simM) => // W _; exists W.\nQed."
}
{
  "statement": "Lemma inj_map : injective f -> injective map.\n",
  "proof": "Proof. by move=> injf; elim=> [|x s IHs] [|y t] //= [/injf-> /IHs->]. Qed."
}
{
  "statement": "Lemma zcharD1 phi S A :\n  (phi \\in 'Z[S, A^#]) = (phi \\in 'Z[S, A]) && (phi 1%g == 0).\n",
  "proof": "Proof. by rewrite zchar_split cfun_onD1 andbA -zchar_split. Qed."
}
{
  "statement": "Lemma mxvec_indexP k : is_mxvec_index k.\n",
  "proof": "Proof.\nrewrite -[k](cast_ordK (esym mxvec_cast)) esymK.\nby rewrite -[_ k]enum_valK; case: (enum_val _).\nQed."
}
{
  "statement": "Lemma exponent_cycle x : exponent <[x]> = #[x].\n",
  "proof": "Proof. by apply/eqP; rewrite eqn_dvd exponent_dvdn dvdn_exponent ?cycle_id. Qed."
}
{
  "statement": "Lemma tvalK n (t : n.-tuple T) : in_tuple t = tcast (esym (size_tuple t)) t.\n",
  "proof": "Proof. by apply: val_inj => /=; case: _ / (esym _). Qed."
}
{
  "statement": "Lemma some_big_AC_mk_monoid [I : Type] r P (F : I -> T) :\n  Some (\\big[op/x]_(i <- r | P i) F i) =\n    oop (\\big[oop/None]_(i <- r | P i) Some (F i)) (Some x).\n",
  "proof": "Proof. by elim/big_rec2 : _ => //= i [y|] _ Pi [] -> //=; rewrite opA. Qed."
}
{
  "statement": "Lemma cforder_aut phi : #[phi^u]%CF = #[phi]%CF.\n",
  "proof": "Proof. exact: cforder_inj_rmorph cfAut_inj. Qed."
}
{
  "statement": "Lemma p_rank_le_logn p G : 'r_p(G) <= logn p #|G|.\n",
  "proof": "Proof.\nhave [E EpE] := p_rank_witness p G.\nby have [sEG _ <-] := pnElemP EpE; apply: lognSg.\nQed."
}
{
  "statement": "Lemma uniq_roots_rdvdp p rs :\n  all (root p) rs -> uniq_roots rs -> rdvdp (\\prod_(z <- rs) ('X - z%:P)) p.\n",
  "proof": "Proof.\nmove=> rrs /(uniq_roots_prod_XsubC rrs) [q ->].\nexact/RingMonic.rdvdp_mull/monic_prod_XsubC.\nQed."
}
{
  "statement": "Lemma cfAut_lin_char u (xi : 'CF(G)) :\n  (cfAut u xi \\is a linear_char) = (xi \\is a linear_char).\n",
  "proof": "Proof. by rewrite qualifE/= cfAut_char; apply/andb_id2l=> /cfAut_char1->. Qed."
}
{
  "statement": "Lemma remE s : rem s = take (index x s) s ++ drop (index x s).+1 s.\n",
  "proof": "Proof. by elim: s => //= y s ->; case: eqVneq; rewrite ?drop0. Qed."
}
{
  "statement": "Lemma map2_row i : map2_mx (row i A) (row i B) = row i (map2_mx A B).\n",
  "proof": "Proof. by apply/rowP=> j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma big_enum_rank (I : finType) (A : pred I) x (xA : x \\in A) F\n  (h := enum_rank_in xA) :\n  \\big[op/idx]_(i < #|A|) F i = \\big[op/idx]_(s in A) F (h s).\n",
  "proof": "Proof. by rewrite (big_enum_rank_cond xA) big_mkcondr. Qed."
}
{
  "statement": "Lemma astab_comp S : 'C(S | comp_action) = f @*^-1 'C(S | to).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE -andbA. Qed."
}
{
  "statement": "Lemma astabs_comp S : 'N(S | comp_action) = f @*^-1 'N(S | to).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE -andbA. Qed."
}
{
  "statement": "Lemma idealr_closed_nontrivial R S : @idealr_closed R S -> proper_ideal S.\n",
  "proof": "Proof. by case=> S0 S1 hS; split => // a x xS; rewrite -[_ * _]addr0 hS. Qed."
}
{
  "statement": "Lemma extprod_mul1g : left_id (1, 1) extprod_mulg.\n",
  "proof": "Proof. by case=> x1 x2; congr (_, _); apply: mul1g. Qed."
}
{
  "statement": "Lemma bigcap_inf j P F : P j -> \\bigcap_(i | P i) F i \\subset F j.\n",
  "proof": "Proof. by move=> Pj; rewrite (bigD1 j) //= subsetIl. Qed."
}
{
  "statement": "Lemma morphim_pElem p G E : E \\in 'E_p(G) -> (f @* E)%G \\in 'E_p(f @* G).\n",
  "proof": "Proof.\nby rewrite !inE => /andP[sEG abelE]; rewrite morphimS // morphim_abelem.\nQed."
}
{
  "statement": "Lemma itv01_subdef : num_spec (Itv.Real `[0%Z, 1%Z]) x.\n",
  "proof": "Proof. by apply/and3P; split; rewrite ?bnd_simp// ger0_real. Qed."
}
{
  "statement": "Lemma vspaceOver_refBase V : vspaceOver F1 (baseVspace V) =i V.\n",
  "proof": "Proof.\nmove=> v; rewrite mem_vspaceOver field_module_eq ?baseVspace_module //.\nby rewrite mem_baseVspace.\nQed."
}
{
  "statement": "Lemma mulmx_diag n (d e : 'rV_n) :\n  diag_mx d *m diag_mx e = diag_mx (\\row_j (d 0 j * e 0 j)).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite mul_diag_mx !mxE mulrnAr. Qed."
}
{
  "statement": "Lemma morphpre_cent A : 'C_D(A) \\subset f @*^-1 'C(f @* A).\n",
  "proof": "Proof.\nrewrite -sub_morphim_pre ?subsetIl // morphimGI ?(subsetIl, subIset) // orbC.\nby rewrite (subset_trans (morphim_cent _)).\nQed."
}
{
  "statement": "Lemma map2_usubmx : map2_mx (usubmx Bv) (usubmx B'v) = usubmx (map2_mx Bv B'v).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma sub_all s : all a1 s -> all a2 s.\n",
  "proof": "Proof.\nby rewrite !all_count !eqn_leq !count_size => /leq_trans-> //; apply: sub_count.\nQed."
}
{
  "statement": "Lemma lin_charV x : x \\in G -> xi x^-1%g = (xi x)^-1.\n",
  "proof": "Proof. by move=> Gx; rewrite -[_^-1]mulr1 -(xiMV Gx) mulKf ?lin_char_neq0. Qed."
}
{
  "statement": "Lemma setD0 A : A :\\: set0 = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE. Qed."
}
{
  "statement": "Lemma setUC A B : A :|: B = B :|: A.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE orbC. Qed."
}
{
  "statement": "Lemma mem2l_cat {p1 p2 x} : x \\notin p1 -> mem2 (p1 ++ p2) x =1 mem2 p2 x.\n",
  "proof": "Proof. by move=> p1'x y; rewrite mem2_cat (negPf p1'x) mem2lf ?orbF. Qed."
}
{
  "statement": "Lemma dimv_add_leqif U V :\n  \\dim (U + V) <= \\dim U + \\dim V ?= iff (U :&: V <= 0)%VS.\n",
  "proof": "Proof.\nby rewrite /dimv /subV !mxrank_gen vs2mx0 genmxE; apply: mxrank_adds_leqif.\nQed."
}
{
  "statement": "Lemma rpredMsign (S : opprClosed R) n x : ((-1) ^+ n * x \\in S) = (x \\in S).\n",
  "proof": "Proof. by rewrite -signr_odd mulr_sign; case: ifP => // _; rewrite rpredN. Qed."
}
{
  "statement": "Lemma map2_dsubmx : map2_mx (dsubmx Bv) (dsubmx B'v) = dsubmx (map2_mx Bv B'v).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map2_rsubmx : map2_mx (rsubmx Bh) (rsubmx B'h) = rsubmx (map2_mx Bh B'h).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma map2_lsubmx : map2_mx (lsubmx Bh) (lsubmx B'h) = lsubmx (map2_mx Bh B'h).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma similar_mxminpoly {n} {p f g : 'M[F]_n.+1} : p \\in unitmx ->\n  similar p f g -> mxminpoly f = mxminpoly g.\n",
  "proof": "Proof. by move=> pu /eqP<-; rewrite mxminpoly_uconj. Qed."
}
{
  "statement": "Lemma in_factmod_module m (V : 'M_(m, n)) :\n  mxmodule rU' (in_factmod U V) = mxmodule rG (U + V)%MS.\n",
  "proof": "Proof.\nrewrite -(eqmx_module _ (in_factmodsK (addsmxSl U V))).\nby rewrite val_factmod_module (eqmx_module _ (in_factmod_addsK _ _)).\nQed."
}
{
  "statement": "Lemma setUCr A : A :|: ~: A = setT.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE orbN. Qed."
}
{
  "statement": "Lemma setIid A : A :&: A = A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite inE andbb. Qed."
}
{
  "statement": "Lemma map_col' j0 : (col' j0 A)^f = col' j0 A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma class_support_id : class_support G G = G.\n",
  "proof": "Proof.\nby apply/eqP; rewrite eqEsubset sub_class_support class_support_subG.\nQed."
}
{
  "statement": "Lemma horner_mod p q x : root q x -> (p %% q).[x] = p.[x].\n",
  "proof": "Proof.\nby rewrite [in RHS](divp_eq p q) !hornerE => /eqP->; rewrite mulr0 add0r.\nQed."
}
{
  "statement": "Lemma setDv A : A :\\: A = set0.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andNb. Qed."
}
{
  "statement": "Lemma cforder_dprodl phi : #[cfDprodl phi]%CF = #[phi]%CF.\n",
  "proof": "Proof. exact: cforder_sdprod. Qed."
}
{
  "statement": "Lemma trmx_delta m n i j : (delta_mx i j)^T = delta_mx j i :> 'M[R]_(n, m).\n",
  "proof": "Proof. by apply/matrixP=> i' j'; rewrite !mxE andbC. Qed."
}
{
  "statement": "Lemma set0U A : set0 :|: A = A.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE orFb. Qed."
}
{
  "statement": "Lemma sdprod_Res_IirrK i :\n  K \\subset cfker 'chi_i -> sdprod_Iirr (Res_Iirr H i) = i.\n",
  "proof": "Proof.\nby move=> kerK; rewrite /sdprod_Iirr sdprod_Res_IirrE ?cfRes_sdprodK ?irrK.\nQed."
}
{
  "statement": "Lemma map_xcol j1 j2 : (xcol j1 j2 A)^f = xcol j1 j2 A^f.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma expn_gt0 m n : (0 < m ^ n) = (0 < m) || (n == 0).\n",
  "proof": "Proof.\nby case: m => [|m]; elim: n => //= n IHn; rewrite expnS // addn_gt0 IHn.\nQed."
}
{
  "statement": "Lemma seq_subE s (s_gt0 : size s > 0) :\n  s = map val (map (insubd (seq_sub_default s_gt0)) s : seq (seq_sub s)).\n",
  "proof": "Proof. by rewrite -map_comp map_id_in// => x x_in_s /=; rewrite insubdK. Qed."
}
{
  "statement": "Lemma setICr A : A :&: ~: A = set0.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbN. Qed."
}
{
  "statement": "Lemma setTI A : setT :&: A = A.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE andTb. Qed."
}
{
  "statement": "Lemma filter_flatten ss (P : pred T) :\n  filter P (flatten ss) = flatten [seq filter P i | i <- ss].\n",
  "proof": "Proof. by elim: ss => // s ss /= <-; apply: filter_cat. Qed."
}
{
  "statement": "Lemma cfdotZr a xi phi : '[xi, a *: phi] = a^* * '[xi, phi].\n",
  "proof": "Proof. by rewrite !(cfdotC xi) cfdotZl rmorphM. Qed."
}
{
  "statement": "Lemma Crat_spanM b : {in Crat & Crat_span b, forall a x, a * x \\in Crat_span b}.\n",
  "proof": "Proof. by move=> _ x /CratP[a ->]; apply: Crat_spanZ. Qed."
}
{
  "statement": "Lemma permP s t : s =1 t <-> s = t.\n",
  "proof": "Proof. by split=> [| -> //]; rewrite unlock => eq_sv; apply/val_inj/ffunP. Qed."
}
{
  "statement": "Lemma prefix_infix s1 s2 : infix s1 (s1 ++ s2).\n",
  "proof": "Proof. exact: prefixW. Qed."
}
{
  "statement": "Lemma cfQuo1 (phi : 'CF(G)) : (phi / B)%CF 1%g = phi 1%g.\n",
  "proof": "Proof. by rewrite cfunElock repr_coset1 group1 if_same. Qed."
}
{
  "statement": "Lemma comparable_ltP x y : x >=< y ->\n  lt_xor_ge x y (min y x) (min x y) (max y x) (max x y) (y <= x) (x < y).\n",
  "proof": "Proof. by move=> /comparable_ltgtP [?|?|->]; constructor; rewrite // ltW. Qed."
}
{
  "statement": "Lemma setC_bigcap J r (P : pred J) (F : J -> {set T}) :\n  ~: (\\bigcap_(j <- r | P j) F j) = \\bigcup_(j <- r | P j) ~: F j.\n",
  "proof": "Proof. by apply: big_morph => [A B|]; rewrite ?setCT ?setCI. Qed."
}
{
  "statement": "Lemma imset_injP : reflect {in D &, injective f} (#|f @: D| == #|D|).\n",
  "proof": "Proof. by rewrite [@imset]unlock cardsE; apply: image_injP. Qed."
}
{
  "statement": "Lemma mulg_subl A B : 1 \\in B -> A \\subset A * B.\n",
  "proof": "Proof. by move=> B1; rewrite -{1}(mulg1 A) mulgS ?sub1set. Qed."
}
{
  "statement": "Lemma integral_horner (p : {poly K}) u :\n    {in p : seq K, integralRange RtoK} -> integralOver RtoK u ->\n  integralOver RtoK p.[u].\n",
  "proof": "Proof. by move=> ? /integral_opp/intR_XsubC/integral_horner_root; apply. Qed."
}
{
  "statement": "Lemma in_qpoly1 : in_qpoly h 1 = 1.\n",
  "proof": "Proof.\napply/val_eqP/eqP/in_qpoly_small.\nby rewrite size_polyC oner_eq0 /= size_mk_monic_gt1.\nQed."
}
{
  "statement": "Lemma suffix_trans : transitive suffix.\n",
  "proof": "Proof. by move=> _ s2 _ /suffixP[s1 ->] /suffixP[s3 ->]; rewrite catA. Qed."
}
{
  "statement": "Lemma setC_bigcup J r (P : pred J) (F : J -> {set T}) :\n  ~: (\\bigcup_(j <- r | P j) F j) = \\bigcap_(j <- r | P j) ~: F j.\n",
  "proof": "Proof. by apply: big_morph => [A B|]; rewrite ?setC0 ?setCU. Qed."
}
{
  "statement": "Lemma morphimIG A G : 'ker f \\subset G -> f @* (A :&: G) = f @* A :&: f @* G.\n",
  "proof": "Proof. by move=> sKG; rewrite setIC morphimGI // setIC. Qed."
}
{
  "statement": "Lemma map_mx_id (f : R -> R) : f =1 id -> forall M : 'M_(m, n), M ^ f = M.\n",
  "proof": "Proof. by move=> fid M; rewrite map_mx_id_in. Qed."
}
{
  "statement": "Lemma eqr_sum_div I r P (f : I -> F) c a : c != 0 ->\n  \\big[+%R/0]_(x <- r | P x) (f x / c) == a\n  = (\\big[+%R/0]_(x <- r | P x) f x == a * c).\n",
  "proof": "Proof.\nby move=> ?; rewrite -mulr_suml -(divr1 a) eqr_div ?oner_eq0// mulr1 divr1.\nQed."
}
{
  "statement": "Lemma gcore_normal A G : A \\subset G -> gcore A G <| G.\n",
  "proof": "Proof.\nby move=> sAG; rewrite /normal gcore_norm (subset_trans (gcore_sub A G)).\nQed."
}
{
  "statement": "Lemma take_poly_rmodp n p : take_poly n p = rmodp p 'X^n.\n",
  "proof": "Proof.\nhave mX := monicXn R n; rewrite -[p in RHS](poly_take_drop n) rmodpD//.\nby rewrite rmodp_small ?rmodp_mull ?addr0// size_polyXn ltnS size_take_poly.\nQed."
}
{
  "statement": "Lemma predC_itvl a : [predC Interval -oo a] =i Interval a +oo.\n",
  "proof": "Proof.\ncase: a => [b x|[]//] y.\nby rewrite !inE !subitvE/= bnd_simp andbT !lteBSide/= lteifNE negbK.\nQed."
}
{
  "statement": "Lemma cforder_morph phi : #[cfMorph phi]%CF = #[phi]%CF.\n",
  "proof": "Proof. exact/cforder_inj_rmorph/cfMorph_inj. Qed."
}
{
  "statement": "Lemma eq_allrel {T S : Type} (r r' : T -> S -> bool) :\n  r =2 r' -> allrel r =2 allrel r'.\n",
  "proof": "Proof. by move=> rr' xs ys; apply/eq_in_allrel/all_predT/all_predT. Qed."
}
{
  "statement": "Lemma free_uniq X : free X -> uniq X.\n",
  "proof": "Proof.\nelim: X => //= v b IH_X; rewrite free_cons => /andP[X'v /IH_X->].\nby rewrite (contra _ X'v) // => /memv_span.\nQed."
}
{
  "statement": "Lemma mxmodule_subg : mxmodule rG U -> mxmodule rH U.\n",
  "proof": "Proof. by rewrite /mxmodule rstabs_subg subsetI subxx; apply: subset_trans. Qed."
}
{
  "statement": "Lemma cforder_sdprod phi : #[cfSdprod phi]%CF = #[phi]%CF.\n",
  "proof": "Proof. exact: cforder_inj_rmorph cfSdprod_inj. Qed."
}
{
  "statement": "Lemma nmono_leif (f : T -> T) C : {mono f : x y /~ x <= y} ->\n  forall x y, (f x <= f y ?= iff C) = (y <= x ?= iff C).\n",
  "proof": "Proof. by move=> mf x y; rewrite /leif !eq_le !mf. Qed."
}
{
  "statement": "Lemma imset_perm1 (S : {set T}) : [set (1 : {perm T}) x | x in S] = S.\n",
  "proof": "Proof. apply: im_perm_on; exact: perm_on1. Qed."
}
{
  "statement": "Lemma prefix_trans : transitive prefix.\n",
  "proof": "Proof. by move=> _ s2 _ /prefixP[s1 ->] /prefixP[s3 ->]; rewrite -catA. Qed."
}
{
  "statement": "Lemma abelem_rV_J : {in E & G, forall x y, ErV (x ^ y) = ErV x *m rG y}.\n",
  "proof": "Proof.\nby move=> x y Ex Gy; rewrite -{1}(abelem_rV_K Ex) -rVabelemJ ?rVabelemK.\nQed."
}
{
  "statement": "Lemma mono_leqif f : {mono f : m n / m <= n} ->\n  forall m n C, (f m <= f n ?= iff C) = (m <= n ?= iff C).\n",
  "proof": "Proof. by move=> f_mono m n C; rewrite /leqif !eqn_leq !f_mono. Qed."
}
{
  "statement": "Lemma card_pX1p2 : #|p^{1+2}| = (p ^ 3)%N.\n",
  "proof": "Proof.\nrewrite [@gtype _]unlock -(sdprod_card (sdprod_sdpair _)).\nrewrite !card_injm ?injm_sdpair1 ?injm_sdpair2 // !cardsT card_prod card_ord.\nby rewrite -mulnA Zp_cast.\nQed."
}
{
  "statement": "Lemma normJ A x : 'N(A :^ x) = 'N(A) :^ x.\n",
  "proof": "Proof.\nby apply/setP=> y; rewrite mem_conjg !inE -conjsgM conjgCV conjsgM conjSg.\nQed."
}
{
  "statement": "Lemma comparable_leP x y : x >=< y ->\n  le_xor_gt x y (min y x) (min x y) (max y x) (max x y) (x <= y) (y < x).\n",
  "proof": "Proof. by move=> /comparable_ltgtP [?|?|->]; constructor; rewrite // ltW. Qed."
}
{
  "statement": "Lemma le_def' x y : (x <= y) = (x == y) || (x < y).\n  ",
  "proof": "Proof. by rewrite lt_def; case: eqVneq => //= ->; rewrite lerr. Qed."
}
{
  "statement": "Lemma sub_rVabelem_im L (H : {set gT}) :\n  (rV_E @* L \\subset H) = (L \\subset ErV @* H).\n",
  "proof": "Proof. by rewrite sub_morphim_pre ?morphpre_invm. Qed."
}
{
  "statement": "Lemma morphimEsub A : A \\subset D -> f @* A = f @: A.\n",
  "proof": "Proof. by move=> sAD; rewrite /morphim (setIidPr sAD). Qed."
}
{
  "statement": "Lemma map2_vec_mx (v : 'rV_(m * n)) (w : 'rV_(m * n)) :\n  map2_mx (vec_mx v) (vec_mx w) = vec_mx (map2_mx v w).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma coset_norm xbar : xbar \\subset 'N(H).\n",
  "proof": "Proof.\ncase: xbar => /= _ /rcosetsP[x Nx ->].\nby rewrite genGid mul_subG ?sub1set ?normG.\nQed."
}
{
  "statement": "Lemma xcprodP : 'Z(H) \\isog 'Z(K) -> xcprod_spec xcprod.\n",
  "proof": "Proof. by rewrite /xcprod => isoZ; move: xcprod_subproof; rewrite isoZ. Qed."
}
{
  "statement": "Lemma map_pK : pcancel g f -> cancel (map g) pmap.\n",
  "proof": "Proof. by move=> gK; elim=> //= x s ->; rewrite gK. Qed."
}
{
  "statement": "Lemma invGid : G^-1 = G. ",
  "proof": "Proof. by apply/setP=> x; rewrite inE groupV. Qed."
}
{
  "statement": "Lemma conjugates_conj A x B : (A :^ x) :^: B = A :^: (x *: B).\n",
  "proof": "Proof.\nrewrite /conjugates [x *: B]imset2_set1l -imset_comp.\nby apply: eq_imset => y /=; rewrite conjsgM.\nQed."
}
{
  "statement": "Lemma scalpE p q :\n  scalp p q = if lead_coef q \\in GRing.unit then 0 else rscalp p q.\n",
  "proof": "Proof. by case: ifP; rewrite /scalp unlock redivp_def => ->. Qed."
}
{
  "statement": "Lemma mono_leif (f : T -> T) C :\n    {mono f : x y / x <= y} ->\n  forall x y, (f x <= f y ?= iff C) = (x <= y ?= iff C).\n",
  "proof": "Proof. by move=> mf x y; rewrite /leif !eq_le !mf. Qed."
}
{
  "statement": "Lemma row1 n i : row i (1%:M : 'M_n) = delta_mx 0 i.\n",
  "proof": "Proof. by apply/rowP=> j; rewrite !mxE eq_sym. Qed."
}
{
  "statement": "Lemma simmx_minpoly {n} {P A B : 'M[F]_n.+1} : P \\in unitmx ->\n  A ~_P B -> mxminpoly A = mxminpoly B.\n",
  "proof": "Proof. by move=> Pu /eqP<-; rewrite mxminpoly_uconj. Qed."
}
{
  "statement": "Lemma out_perm S u x : perm_on S u -> x \\notin S -> u x = x.\n",
  "proof": "Proof. by move=> uS; apply: contraNeq (subsetP uS x). Qed."
}
{
  "statement": "Lemma commXg : [~ x ^+ i, y] = [~ x, y] ^+ i.\n",
  "proof": "Proof.\nelim: i => [|i' IHi]; first exact: comm1g.\nby rewrite !expgS commMgJ /conjg commuteX // mulKg IHi.\nQed."
}
{
  "statement": "Lemma sposD x y : lt 0 x -> lt 0 y -> lt 0 (x + y).\n",
  "proof": "Proof.\n  by move=> x_gt0 /andP[_]; apply: sposDl.\nQed."
}
{
  "statement": "Lemma scalar_mx_cent m n a (R : 'A_(m, n)) : (a%:M \\in 'C(R))%MS.\n",
  "proof": "Proof. by apply/cent_mxP=> A _; apply: scalar_mxC. Qed."
}
{
  "statement": "Lemma rowK u_ i0 : row i0 (\\matrix_i u_ i) = u_ i0.\n",
  "proof": "Proof. by apply/rowP=> i'; rewrite !mxE. Qed."
}
{
  "statement": "Lemma kHom_root_id K E f p x :\n   (K <= E)%VS -> kHom K E f -> p \\is a polyOver K -> x \\in E -> root p x ->\n  root p (f x).\n",
  "proof": "Proof.\nmove=> sKE homKf Kp Ex /(kHom_root homKf (polyOverSv sKE Kp) Ex).\nby rewrite (kHom_poly_id homKf).\nQed."
}
{
  "statement": "Lemma ltn_mod m d : (m %% d < d) = (0 < d).\n",
  "proof": "Proof. by case: d => // d; rewrite modn_def; case: edivnP. Qed."
}
{
  "statement": "Lemma sub_eigenspace_conjmx V f a W : stablemx V f -> row_free V ->\n  (W <= eigenspace (conjmx V f) a)%MS = (W *m V <= eigenspace f a)%MS.\n",
  "proof": "Proof. by move=> fV rfV; rewrite !eigenspace_poly sub_kermxpoly_conjmx. Qed."
}
{
  "statement": "Lemma sub_eigenspace_conjmx V f a W : stablemx V f -> row_free V ->\n  (W <= eigenspace (conjmx V f) a)%MS = (W *m V <= eigenspace f a)%MS.\n",
  "proof": "Proof. by move=> fV rfV; rewrite !eigenspace_poly sub_kermxpoly_conjmx. Qed."
}
{
  "statement": "Lemma pnatI pi rho n : [predI pi & rho].-nat n = pi.-nat n && rho.-nat n.\n",
  "proof": "Proof. by rewrite /pnat andbCA all_predI !andbA andbb. Qed."
}
{
  "statement": "Lemma eqp_mod p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> p1 %% q1 %= p2 %% q2.\n",
  "proof": "Proof. move=> e1 e2; exact: eqp_trans (eqp_modpl _ e1) (eqp_modpr _ e2). Qed."
}
{
  "statement": "Lemma big_map_id J (h : J -> R) r (P : pred R) :\n  \\big[op/idx]_(i <- map h r | P i) i\n     = \\big[op/idx]_(j <- r | P (h j)) h j.\n",
  "proof": "Proof. exact: big_map. Qed."
}
{
  "statement": "Lemma size_char_poly : size char_poly = n.+1.\n",
  "proof": "Proof.\nhave [q <- lt_q_n] := split_diagA; have le_q_n := leq_trans lt_q_n (leq_pred n).\nby rewrite size_polyDl size_prod_XsubC size_diagA.\nQed."
}
{
  "statement": "Lemma map_diag_mx d : (diag_mx d)^f = diag_mx d^f :> 'M_n.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE rmorphMn. Qed."
}
{
  "statement": "Lemma eqp_div p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> p1 %/ q1 %= p2 %/ q2.\n",
  "proof": "Proof. move=> e1 e2; exact: eqp_trans (eqp_divl _ e1) (eqp_divr _ e2). Qed."
}
{
  "statement": "Lemma modactE x a :\n  a \\in D -> a \\in 'N(H) -> x \\in range ->  modact x (coset H a) = to x a.\n",
  "proof": "Proof. by move=> Da Na Rx; rewrite modactEcond ?Rx // inE Da. Qed."
}
{
  "statement": "Lemma CauchySchwarz_sqrt u v :\n  `|'[u, v]| <= sqrtC '[u] * sqrtC '[v] ?= iff ~~ free [:: u; v].\n",
  "proof": "Proof.\nrewrite -(sqrCK (normr_ge0 _)) -sqrtCM ?nnegrE//.\nrewrite (mono_in_leif (@ler_sqrtC _)) 1?rpredM//= ?nnegrE//=.\nexact: CauchySchwarz.\nQed."
}
{
  "statement": "Lemma normal_rfix_mx_module H : H <| G -> mxmodule (rfix_mx H).\n",
  "proof": "Proof.\ncase/andP=> sHG nHG.\nby rewrite /mxmodule -{1}(setIidPl nHG) norm_sub_rstabs_rfix_mx.\nQed."
}
{
  "statement": "Lemma unitr1 : 1 \\in @unit R.\n",
  "proof": "Proof. by apply/unitrP; exists 1; rewrite mulr1. Qed."
}
{
  "statement": "Lemma big_split I r (P : pred I) F1 F2 :\n  \\big[*%M/1]_(i <- r | P i) (F1 i * F2 i) =\n    \\big[*%M/1]_(i <- r | P i) F1 i * \\big[*%M/1]_(i <- r | P i) F2 i.\n",
  "proof": "Proof. exact/big_split_idem/mul1m. Qed."
}
{
  "statement": "Lemma coef0_prod I rI (F : I -> {poly R}) P :\n  (\\prod_(i <- rI| P i) F i)`_0 = \\prod_(i <- rI | P i) (F i)`_0.\n",
  "proof": "Proof. by apply: (big_morph _ coef0M); rewrite coef1 eqxx. Qed."
}
{
  "statement": "Lemma map_id_in (T : eqType) f (s : seq T) : {in s, f =1 id} -> map f s = s.\n",
  "proof": "Proof. by move/eq_in_map->; apply: map_id. Qed."
}
{
  "statement": "Lemma incomparable_eqF x y : (x >< y) -> (x == y) = false.\n",
  "proof": "Proof. by apply: contraNF => /eqP ->; rewrite comparablexx. Qed."
}
{
  "statement": "Lemma diag_const_mx a : diag_mx (const_mx a) = a%:M :> 'M_n.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma morphpre_inj :\n  {in [pred R : {set rT} | R \\subset f @* D] &, injective (fun R => f @*^-1 R)}.\n",
  "proof": "Proof. exact: can_in_inj morphpreK. Qed."
}
{
  "statement": "Lemma properIr A B : ~~ (B \\subset A) -> A :&: B \\proper B.\n",
  "proof": "Proof. by move=> nsAB; rewrite properE subsetIr subsetI negb_and nsAB. Qed."
}
{
  "statement": "Lemma lift_permK i j s :\n  cancel (lift_perm_fun i j s) (lift_perm_fun j i s^-1).\n",
  "proof": "Proof.\nrewrite /lift_perm_fun => k.\nby case: (unliftP i k) => [j'|] ->; rewrite (liftK, unlift_none) ?permK.\nQed."
}
{
  "statement": "Lemma ltn_quotient A : H :!=: 1 -> H \\subset A -> #|A / H| < #|A|.\n",
  "proof": "Proof.\nby move=> ntH sHA; rewrite ltn_morphim // ker_coset (setIidPr sHA) proper1G.\nQed."
}
{
  "statement": "Lemma cfun_inP phi psi : {in G, phi =1 psi} -> phi = psi.\n",
  "proof": "Proof. by rewrite -{1}genGid => /cfun_in_genP. Qed."
}
{
  "statement": "Lemma equivf_l x : \\n_(repr (\\pi_type x)) * \\d_x = \\d_(repr (\\pi_type x)) * \\n_x.\n",
  "proof": "Proof. by apply/eqP; rewrite -equivf_def reprK. Qed."
}
{
  "statement": "Lemma sub_cosetpre M : H \\subset coset H @*^-1 M.\n",
  "proof": "Proof. by rewrite -{1}ker_coset; apply: ker_sub_pre. Qed."
}
{
  "statement": "Lemma powersetI A B : powerset (A :&: B) = powerset A :&: powerset B.\n",
  "proof": "Proof. by apply/setP=> C; rewrite !inE subsetI. Qed."
}
{
  "statement": "Lemma equivf_r x : \\n_x * \\d_(repr (\\pi_type x)) = \\d_x * \\n_(repr (\\pi_type x)).\n",
  "proof": "Proof. by apply/eqP; rewrite -equivf_def reprK. Qed."
}
{
  "statement": "Lemma unlift_none n (h : 'I_n) : unlift h h = None.\n",
  "proof": "Proof. by case: unliftP => // j Dh; case/eqP: (neq_lift h j). Qed."
}
{
  "statement": "Lemma cforder_Res phi : #['Res[H] phi]%CF %| #[phi]%CF.\n",
  "proof": "Proof. exact: cforder_rmorph. Qed."
}
{
  "statement": "Lemma monic_neq0 p : p \\is monic -> p != 0.\n",
  "proof": "Proof. by rewrite -lead_coef_eq0 => /eqP->; apply: oner_neq0. Qed."
}
{
  "statement": "Lemma cforder_isom phi : #[cfIsom isoGR phi]%CF = #[phi]%CF.\n",
  "proof": "Proof. exact: cforder_inj_rmorph cfIsom_inj. Qed."
}
{
  "statement": "Lemma astabsJ A : 'N(A | 'J) = 'N(A).\n",
  "proof": "Proof. by apply/setP=> x; rewrite -2!groupV !inE -conjg_preim -sub_conjg. Qed."
}
{
  "statement": "Lemma prodrMn (I : Type) (s : seq I) (P : pred I) (F : I -> R) (g : I -> nat) :\n  \\prod_(i <- s | P i) (F i *+ g i) =\n  \\prod_(i <- s | P i) (F i) *+ \\prod_(i <- s | P i) g i.\n",
  "proof": "Proof.\nby elim/big_rec3: _ => // i y1 y2 y3 _ ->; rewrite mulrnAr mulrnAl -mulrnA.\nQed."
}
{
  "statement": "Lemma lt_in_itv bl br x : x \\in Interval bl br -> bl < br.\n",
  "proof": "Proof. by case/andP; apply/le_lt_trans. Qed."
}
{
  "statement": "Lemma unitrN1 : -1 \\is a @unit R.\n",
  "proof": "Proof. by apply/unitrP; exists (-1); rewrite mulrNN mulr1. Qed."
}
{
  "statement": "Lemma sdivr_closedM : sdivr_closed -> smulr_closed S.\n",
  "proof": "Proof.\nby move=> Sdiv; have [_ SM] := divr_closedM (sdivr_closed_div Sdiv); case: Sdiv.\nQed."
}
{
  "statement": "Lemma cent_set1 x : 'C([set x]) = 'C[x].\n",
  "proof": "Proof. by apply: big_pred1 => y /=; rewrite !inE. Qed."
}
{
  "statement": "Lemma eqmx_iso U V : (U :=: V)%MS -> mx_iso U V.\n",
  "proof": "Proof.\nby move=> eqUV; exists 1%:M; rewrite ?unitmx1 ?scalar_mx_hom ?mulmx1.\nQed."
}
{
  "statement": "Lemma setIA A B C : A :&: (B :&: C) = A :&: B :&: C.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbA. Qed."
}
{
  "statement": "Lemma normCs A : 'N(~: A) = 'N(A).\n",
  "proof": "Proof. by apply/setP=> x; rewrite -groupV !inE conjCg setCS sub_conjg. Qed."
}
{
  "statement": "Lemma test_addn (a b c d : nat) : a + b + c + d = a + c + b + d.\nProof. time by rewrite -addnA addnAC addnA addnAC. Restart.\nProof. time by rewrite (ACl (1*3*2*4)). Restart.\n",
  "proof": "Proof. time by rewrite addn.[ACl 1*3*2*4]. Qed."
}
{
  "statement": "Lemma perm_prime_orbit x : orbit 'P <[c]> x = [set: T].\n",
  "proof": "Proof. by apply: atransP => //; apply: perm_prime_atrans. Qed."
}
{
  "statement": "Lemma allrel_maskl m xs ys : allrel xs ys -> allrel (mask m xs) ys.\n",
  "proof": "Proof.\nby elim: m xs => [|[] m IHm] [|x xs] //= /andP [xys /IHm->]; rewrite ?xys.\nQed."
}
{
  "statement": "Lemma rpredZ_nat (S : addrClosed V) :\n  {in nat_num & S, forall z u, z *: u \\in S}.\n",
  "proof": "Proof. by move=> _ u /natrP[n ->]; apply: rpredZnat. Qed."
}
{
  "statement": "Lemma cfDprod_split phi psi : cfDprod phi psi = cfDprod phi 1 * cfDprod 1 psi.\n",
  "proof": "Proof. by rewrite cfDprod_cfun1l cfDprod_cfun1r. Qed."
}
{
  "statement": "Lemma eqAmodMl e :\n  {in Aint, forall z x y, x == y %[mod e] -> z * x == z * y %[mod e]}%A.\n",
  "proof": "Proof. by move=> z Zz x y Exy; rewrite !(mulrC z) eqAmodMr. Qed."
}
{
  "statement": "Lemma quotientK A : A \\subset 'N(H) -> coset H @*^-1 (A / H) = H * A.\n",
  "proof": "Proof. by rewrite -{8}ker_coset; apply: morphimK. Qed."
}
{
  "statement": "Lemma num_spec_norm {V : normedZmodType R} (x : V) :\n  num_spec (Itv.Real `[0, +oo[) `|x|.\n",
  "proof": "Proof. by apply/and3P; split; rewrite //= ?normr_real ?bnd_simp ?normr_ge0. Qed."
}
{
  "statement": "Lemma ler_leVge x y : x <= 0 -> y <= 0 -> (x <= y) || (y <= x).\n",
  "proof": "Proof. by rewrite -!oppr_ge0 => /(ger_leVge _) /[apply]; rewrite !lerN2. Qed."
}
{
  "statement": "Lemma morphim_subcent1 A x : x \\in D -> f @* 'C_A[x] \\subset 'C_(f @* A)[f x].\n",
  "proof": "Proof. by move=> Dx; rewrite -(morphim_set1 Dx) morphim_subnorm. Qed."
}
{
  "statement": "Lemma comp_lfunDl f1 f2 g : ((f1 + f2) \\o g = (f1 \\o g) + (f2 \\o g))%VF.\n",
  "proof": "Proof. by apply/lfunP=> u; do !rewrite lfunE /=. Qed."
}
{
  "statement": "Lemma zmod_abelian (A : {set U}) : abelian A.\n",
  "proof": "Proof. by apply/centsP=> x _ y _; apply: zmod_mulgC. Qed."
}
{
  "statement": "Lemma sqrnD_sub m n : n <= m -> (m + n) ^ 2 - 4 * (m * n) = (m - n) ^ 2.\n",
  "proof": "Proof.\nmove=> le_nm; rewrite -[4]/(2 * 2) -mulnA mul2n -addnn subnDA.\nby rewrite sqrnD addnK sqrnB.\nQed."
}
{
  "statement": "Lemma pcoreNK pi G : 'O_pi^'^'(G) = 'O_pi(G).\n",
  "proof": "Proof. by apply: eq_pcore; apply: negnK. Qed."
}
{
  "statement": "Lemma pid_mx_1 r : pid_mx r = 1%:M :> 'M_r.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE ltn_ord andbT. Qed."
}
{
  "statement": "Lemma is_perm_mxMr n (A B : 'M_n) :\n  is_perm_mx B -> is_perm_mx (A *m B) = is_perm_mx A.\n",
  "proof": "Proof.\ncase/is_perm_mxP=> s ->.\nrewrite -[s]invgK -col_permE -is_perm_mx_tr tr_col_perm row_permE.\nby rewrite is_perm_mxMl (perm_mx_is_perm, is_perm_mx_tr).\nQed."
}
{
  "statement": "Lemma eqCmod_addl_mul e : {in Num.int, forall x y, x * e + y == y %[mod e]}%C.\n",
  "proof": "Proof. by move=> x Zx y; rewrite -{2}[y]add0r eqCmodDr eqCmodMl0. Qed."
}
{
  "statement": "Lemma map2_mxsub m' n' g h :\n  map2_mx (@mxsub _ _ _  m' n' g h A) (@mxsub _ _ _  m' n' g h B) =\n  mxsub g h (map2_mx A B).\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma partnNK pi n : n`_pi^'^' = n`_pi.\n",
  "proof": "Proof. by apply: eq_partn; apply: negnK. Qed."
}
{
  "statement": "Lemma eqCmodMl0 e : {in Num.int, forall x, x * e == 0 %[mod e]}%C.\n",
  "proof": "Proof. by move=> x Zx; rewrite -(mulr0 x) eqCmodMl. Qed."
}
{
  "statement": "Lemma cfdot_aut_irr u phi i :\n  '[cfAut u phi, cfAut u 'chi[G]_i] = u '[phi, 'chi_i].\n",
  "proof": "Proof. exact: cfdot_aut_char (irr_char i). Qed."
}
{
  "statement": "Lemma sorted_leq_nth x0 s : sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i <= j >-> leT i j}}.\n",
  "proof": "Proof. exact/sorted_leq_nth_in/all_predT. Qed."
}
{
  "statement": "Lemma sesquiP : reflect (M = (-1) ^+ eps *: M ^t theta)\n                        (M \\is (eps, theta).-sesqui).\n",
  "proof": "Proof. by rewrite sesquiE; exact/eqP. Qed."
}
{
  "statement": "Lemma norm_gen A : 'N(A) \\subset 'N(<<A>>).\n",
  "proof": "Proof. by apply/normsP=> x Nx; rewrite -genJ (normP Nx). Qed."
}
{
  "statement": "Lemma eq_sum_nth_irr a : \\sum_i a i *: 'chi[G]_i = \\sum_i a i *: (irr G)`_i.\n",
  "proof": "Proof. by apply: eq_bigr => i; rewrite -tnth_nth. Qed."
}
{
  "statement": "Lemma sorted_ltn_nth x0 s : sorted leT s ->\n  {in [pred n | n < size s] &, {homo nth x0 s : i j / i < j >-> leT i j}}.\n",
  "proof": "Proof. exact/sorted_ltn_nth_in/all_predT. Qed."
}
{
  "statement": "Lemma pexpIrn n : (0 < n)%N -> {in nneg &, injective ((@GRing.exp R)^~ n)}.\n",
  "proof": "Proof. by move=> n_gt0; apply: inc_inj_in (ler_pXn2r _). Qed."
}
{
  "statement": "Lemma rowg1 : rowg 1%:M = setT.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE submx1. Qed."
}
{
  "statement": "Lemma ceilK : {in int_num, cancel ceil intr}.\n",
  "proof": "Proof. by move=> z; rewrite intrEceil => /eqP. Qed."
}
{
  "statement": "Lemma cfDprod1 phi psi : cfDprod phi psi 1%g = phi 1%g * psi 1%g.\n",
  "proof": "Proof. by rewrite cfunE /= !cfSdprod1. Qed."
}
{
  "statement": "Lemma big_bool R (idx : R) (op : Monoid.com_law idx) (F : bool -> R):\n  \\big[op/idx]_(i : bool) F i = op (F true) (F false).\n",
  "proof": "Proof. by rewrite /index_enum !unlock /= Monoid.mulm1. Qed."
}
{
  "statement": "Lemma col_mxsub m1 m2 n1 n2\n    (f : 'I_m2 -> 'I_m1) (g : 'I_n2 -> 'I_n1) (A : 'M_(m1, n1)) i :\n col i (mxsub f g A) = col (g i) (rowsub f A).\n",
  "proof": "Proof. by rewrite !colEsub -!mxsub_comp. Qed."
}
{
  "statement": "Lemma mxblock_const a :\n  \\mxblock_(i, j) (const_mx a : 'M[V]_(p_ i, q_ j)) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma muln_lcm_gcd m n : lcmn m n * gcdn m n = m * n.\n",
  "proof": "Proof. by apply/eqP; rewrite divnK ?dvdn_mull ?dvdn_gcdr. Qed."
}
{
  "statement": "Lemma algC'G_pchar G : [pchar algC]^'.-group G.\n",
  "proof": "Proof. by apply/pgroupP=> p _; rewrite inE /= pchar_num. Qed."
}
{
  "statement": "Lemma adjoin_seqSr U rs1 rs2 :\n  {subset rs1 <= rs2} -> (<<U & rs1>> <= <<U & rs2>>)%VS.\n",
  "proof": "Proof. by move/sub_span=> s_rs12; rewrite agenvS ?addvS. Qed."
}
{
  "statement": "Lemma genmx_sums P n (B_ : I -> 'M_n) :\n  <<(\\sum_(i | P i) B_ i)%MS>>%MS = (\\sum_(i | P i) <<B_ i>>)%MS.\n",
  "proof": "Proof. exact: (big_morph _ (@genmx_adds n n n) (@genmx0 n n)). Qed."
}
{
  "statement": "Lemma expgM x n m : x ^+ (n * m) = x ^+ n ^+ m.\n",
  "proof": "Proof.\nelim: m => [|m IHm]; first by rewrite muln0 expg0.\nby rewrite mulnS expgD IHm expgS.\nQed."
}
{
  "statement": "Lemma tpermP x y z : tperm_spec x y z (tperm x y z).\n",
  "proof": "Proof. by rewrite permE /=; do 2?[case: eqP => /=]; constructor; auto. Qed."
}
{
  "statement": "Lemma setTU A : setT :|: A = setT.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE orTb. Qed."
}
{
  "statement": "Lemma preimsetT : f @^-1: setT = setT.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE. Qed."
}
{
  "statement": "Lemma eq_cardT (A : {pred T}) : A =i predT -> #|A| = size (enum T).\n",
  "proof": "Proof. by move=> /eq_enum<-; rewrite cardE. Qed."
}
{
  "statement": "Lemma pchar_prim_root : [pchar R]^'.-nat n.\n",
  "proof": "Proof. by apply/pnatP=> // p pp pn; rewrite inE/= prim_root_pcharF. Qed."
}
{
  "statement": "Lemma gacent_actby B :\n  'C_(|actby_groupAction)(B) = 'C_(G | to)(A :&: B).\n",
  "proof": "Proof.\nrewrite /gacent afix_actby !setIA setIid setIUr setICr set0U.\nby have [nAG sGR] := nGAg; rewrite (setIidPr (acts_dom nAG)) (setIidPl sGR).\nQed."
}
{
  "statement": "Lemma gFsub gT (G : {group gT}) : F gT G \\subset G.\n",
  "proof": "Proof. by case: F gT G. Qed."
}
{
  "statement": "Lemma setDE A B : A :\\: B = A :&: ~: B.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE andbC. Qed."
}
{
  "statement": "Lemma gcdnC : commutative gcdn.\n",
  "proof": "Proof.\nmove=> m n; wlog lt_nm: m n / n < m by have [? ->|? <-|-> //] := ltngtP n m.\nby rewrite gcdnE -[in m == 0](ltn_predK lt_nm) modn_small.\nQed."
}
{
  "statement": "Lemma uphalfK n : (uphalf n).*2 = odd n + n.\n",
  "proof": "Proof. by rewrite uphalfE halfK/=; case: odd; rewrite ?subn1. Qed."
}
{
  "statement": "Lemma char_normal_trans H G K : K \\char H -> H <| G -> K <| G.\n",
  "proof": "Proof.\nmove=> chKH /andP[sHG nHG].\nby rewrite /normal (subset_trans (char_sub chKH)) // (char_norm_trans chKH).\nQed."
}
{
  "statement": "Lemma col'_const j0 a : col' j0 (const_mx a) = const_mx a.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma conjC_rect : {in real &, forall x y, (x + 'i * y)^* = x - 'i * y}.\n",
  "proof": "Proof.\nby move=> x y Rx Ry; rewrite /= rmorphD rmorphM /= conjCi mulNr !conj_Creal.\nQed."
}
{
  "statement": "Lemma map_inj_uniq s : uniq (map f s) = uniq s.\n",
  "proof": "Proof. by apply: map_inj_in_uniq; apply: in2W. Qed."
}
{
  "statement": "Lemma rank_Sylow p G P : p.-Sylow(G) P -> 'r(P) = 'r_p(G).\n",
  "proof": "Proof.\nmove=> sylP; have pP := pHall_pgroup sylP.\nby rewrite -(p_rank_Sylow sylP) -(rank_pgroup pP).\nQed."
}
{
  "statement": "Lemma pair_bigA_idem (I J : finType) (F : I -> J -> R) :\n  \\big[op/x]_i \\big[op/x]_j F i j = \\big[op/x]_p F p.1 p.2.\n",
  "proof": "Proof. exact: pair_big_dep_idem. Qed."
}
{
  "statement": "Lemma cfdot_Res_l psi phi : '['Res[H] psi, phi] = '[psi, 'Ind[G] phi].\n",
  "proof": "Proof. by rewrite cfdotC cfdot_Res_r -cfdotC. Qed."
}
{
  "statement": "Lemma setDT A : A :\\: setT = set0.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE. Qed."
}
{
  "statement": "Lemma coefMC c p i : (p * c%:P)`_i = p`_i * c.\n",
  "proof": "Proof.\nrewrite coefMr big_ord_recl subn0.\nby rewrite big1 => [|j _]; rewrite coefC !simp.\nQed."
}
{
  "statement": "Lemma cyclicY K H :\n    cyclic K -> cyclic H -> H \\subset 'C(K) -> coprime #|K| #|H| ->\n  cyclic (K <*> H).\n",
  "proof": "Proof. by move=> cycK cycH cKH coKH; rewrite cent_joinEr // cyclicM. Qed."
}
{
  "statement": "Lemma morphim_pprodml A : A \\subset H -> f @* A = fH @* A.\n",
  "proof": "Proof.\nby move=> sAH; rewrite -{1}(mulg1 A) morphim_pprodm ?sub1G // morphim1 mulg1.\nQed."
}
{
  "statement": "Lemma dfwithP i (x : T i) (j : I) : dfwith_spec x (dfwith x j).\n",
  "proof": "Proof.\nby case: (eqVneq i j) => [<-|nij];\n   [rewrite dfwith_in|rewrite dfwith_out//]; constructor.\nQed."
}
{
  "statement": "Lemma memv_suml I r (P : pred I) vs U :\n  (forall i, P i -> vs i \\in U) -> \\sum_(i <- r | P i) vs i \\in U.\n",
  "proof": "Proof. exact: rpred_sum. Qed."
}
{
  "statement": "Lemma pi_p'group p pi A : pi.-group A -> p \\in pi^' -> p^'.-group A.\n",
  "proof": "Proof. exact: pi_p'nat. Qed."
}
{
  "statement": "Lemma row_full_castmx m1 m2 n (A : 'M_(m1, n)) e :\n  row_full (castmx e A  : 'M_(m2, n)) = row_full A.\n",
  "proof": "Proof. exact/eq_row_full/eqmx_cast. Qed."
}
{
  "statement": "Lemma add0_l : left_id 0%:F add.\n",
  "proof": "Proof.\nelim/quotW=> x; rewrite !piE /addf !numden_Ratio ?oner_eq0 //.\nby rewrite mul0r mul1r mulr1 add0r Ratio_numden.\nQed."
}
{
  "statement": "Lemma homg_refl aT (A : {set aT}) : homg A A.\n",
  "proof": "Proof. by apply/homgP; exists (idm_morphism A); rewrite im_idm. Qed."
}
{
  "statement": "Lemma floorK : {in int_num, cancel floor intr}.\n",
  "proof": "Proof. by move=> z; rewrite intrEfloor => /eqP. Qed."
}
{
  "statement": "Lemma eq_orthonormal R S : perm_eq R S -> orthonormal R = orthonormal S.\n",
  "proof": "Proof.\nmove=> eqRS; rewrite !orthonormalE (eq_all_r (perm_mem eqRS)).\nby rewrite (eq_pairwise_orthogonal eqRS).\nQed."
}
{
  "statement": "Lemma prodr_ge0 I r (P : pred I) (E : I -> R) :\n  (forall i, P i -> 0 <= E i) -> 0 <= \\prod_(i <- r | P i) E i.\n",
  "proof": "Proof. by move=> Ege0; rewrite -nnegrE rpred_prod. Qed."
}
{
  "statement": "Lemma afixU A B : 'Fix_to(A :|: B) = 'Fix_to(A) :&: 'Fix_to(B).\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE subUset. Qed."
}
{
  "statement": "Lemma le_bigmax_nat [x0] n m n' m' P (F : nat -> T) :\n    (n' <= n)%N -> (m <= m')%N ->\n  \\big[max/x0]_(n <= i < m | P i) F i <= \\big[max/x0]_(n' <= i < m' | P i) F i.\n",
  "proof": "Proof. exact: le_big_nat. Qed."
}
{
  "statement": "Lemma Fitting_eq_pcore p G : 'O_p^'(G) = 1 -> 'F(G) = 'O_p(G).\n",
  "proof": "Proof.\nmove=> p'G1; have /dprodP[_  /= <- _ _] := nilpotent_pcoreC p (Fitting_nil G).\nby rewrite p_core_Fitting ['O_p^'(_)](trivgP _) ?mulg1 // -p'G1 pcore_Fitting.\nQed."
}
{
  "statement": "Lemma prodr_gt0 I r (P : pred I) (E : I -> R) :\n  (forall i, P i -> 0 < E i) -> 0 < \\prod_(i <- r | P i) E i.\n",
  "proof": "Proof. by move=> Ege0; rewrite -posrE rpred_prod. Qed."
}
{
  "statement": "Lemma coefCM c p i : (c%:P * p)`_i = c * p`_i.\n",
  "proof": "Proof.\nrewrite coefM big_ord_recl subn0.\nby rewrite big1 => [|j _]; rewrite coefC !simp.\nQed."
}
{
  "statement": "Lemma le_bigmin_nat [x0] n m n' m' P (F : nat -> T) :\n    (n <= n')%N -> (m' <= m)%N ->\n  \\big[min/x0]_(n <= i < m | P i) F i <= \\big[min/x0]_(n' <= i < m' | P i) F i.\n",
  "proof": "Proof. exact: (le_big_nat ge_refl). Qed."
}
{
  "statement": "Lemma isog_special G (R : {group rT}) :\n  G \\isog R -> special G -> special R.\n",
  "proof": "Proof. by case/isogP=> f injf <-; apply: injm_special. Qed."
}
{
  "statement": "Lemma split_ordP m n (i : 'I_(m + n)) : split_ord_spec i (split i) (i < m).\n",
  "proof": "Proof. by case: splitP; [left|right]; apply: val_inj. Qed."
}
{
  "statement": "Lemma ltr_wMn2r x y n : x < y -> (x *+ n < y *+ n) = (0 < n)%N.\n",
  "proof": "Proof. by move=> ltxy; case: n=> // n; rewrite ltr_pMn2r. Qed."
}
{
  "statement": "Lemma findex_iter x i : i < order x -> findex x (iter i f x) = i.\n",
  "proof": "Proof.\nmove=> lt_ix; rewrite -(nth_traject f lt_ix) /findex index_uniq ?orbit_uniq //.\nby rewrite size_orbit.\nQed."
}
{
  "statement": "Lemma eqCmodMr e :\n  {in Num.int, forall z x y, x == y %[mod e] -> x * z == y * z %[mod e]}%C.\n",
  "proof": "Proof. by move=> z Zz x y; rewrite /eqCmod -mulrBl => /dvdC_mulr->. Qed."
}
{
  "statement": "Lemma morphim_sdprodml A : A \\subset H -> sdprodm @* A = fH @* A.\n",
  "proof": "Proof.\nby move=> sHA; rewrite -{1}(mulg1 A) morphim_sdprodm ?sub1G // morphim1 mulg1.\nQed."
}
{
  "statement": "Lemma memv_line u : u \\in <[u]>%VS.\n",
  "proof": "Proof. by apply/vlineP; exists 1; rewrite scale1r. Qed."
}
{
  "statement": "Lemma oppr_max : {morph -%R : x y / max x y >-> min x y : R}.\n",
  "proof": "Proof. by move=> x y; apply: real_oppr_max. Qed."
}
{
  "statement": "Lemma mem2r_cat {p1 p2 x y} : y \\notin p2 -> mem2 (p1 ++ p2) x y = mem2 p1 x y.\n",
  "proof": "Proof.\nby move=> p2'y; rewrite mem2_cat (negPf p2'y) -orbA orbC andbF mem2rf.\nQed."
}
{
  "statement": "Lemma codomP y : reflect (exists x, y = f x) (y \\in codom f).\n",
  "proof": "Proof. by apply: (iffP (imageP _ y)) => [][x]; exists x. Qed."
}
{
  "statement": "Lemma pHall_sub pi A B : pi.-Hall(A) B -> B \\subset A.\n",
  "proof": "Proof. by case/andP. Qed."
}
{
  "statement": "Lemma oppr_min : {morph -%R : x y / min x y >-> max x y : R}.\n",
  "proof": "Proof. by move=> x y; apply: real_oppr_min. Qed."
}
{
  "statement": "Lemma morphim_set1 x : x \\in D -> f @* [set x] = [set f x].\n",
  "proof": "Proof. by rewrite /morphim -sub1set => /setIidPr->; apply: imset_set1. Qed."
}
{
  "statement": "Lemma preimset0 : f @^-1: set0 = set0.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE. Qed."
}
{
  "statement": "Lemma mxtrace_diag D : \\tr (diag_mx D) = \\sum_j D 0 j.\n",
  "proof": "Proof. by apply: eq_bigr => j _; rewrite mxE eqxx. Qed."
}
{
  "statement": "Lemma minsetinf P A B : minset P A -> P B -> B \\subset A -> B = A.\n",
  "proof": "Proof. by case/minsetP=> _; apply. Qed."
}
{
  "statement": "Lemma pexprz_eq1 x n (x0 : 0 <= x) : (x ^ n == 1) = ((n == 0) || (x == 1)).\n",
  "proof": "Proof.\ncase: n=> n; rewrite ?NegzE -?exprz_inv ?oppr_eq0 pexprn_eq1 // ?invr_eq1 //.\nby rewrite invr_ge0.\nQed."
}
{
  "statement": "Lemma subseq_pairwise xs ys : subseq xs ys -> pairwise r ys -> pairwise r xs.\n",
  "proof": "Proof. by case/subseqP => m _ ->; apply: pairwise_mask. Qed."
}
{
  "statement": "Lemma set0I A : set0 :&: A = set0.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE andFb. Qed."
}
{
  "statement": "Lemma orthomxZ p m a (A : 'M[R]_(p, n)) (B : 'M[R]_(m, n)) : a != 0 ->\n  (A '_|_ (a *: B))%MS = (A '_|_ B)%MS.\n",
  "proof": "Proof. by move=> a_neq0; rewrite ![(A '_|_ _)%MS]orthomx_sym orthoZmx. Qed."
}
{
  "statement": "Lemma rev_unitrP (x y : R^c) : y * x = 1 /\\ x * y = 1 -> x \\is a unit.\n",
  "proof": "Proof. by case=> [yx1 xy1]; apply/unitrP; exists y. Qed."
}
{
  "statement": "Lemma big_id_idem I (r : seq I) P F :\n  op (\\big[op/x]_(i <- r | P i) F i) x = \\big[op/x]_(i <- r | P i) F i.\n",
  "proof": "Proof. by elim/big_rec : _ => // ? ? ?; rewrite -opA => ->. Qed."
}
{
  "statement": "Lemma exprzMl x y n (ux : x \\is a GRing.unit) (uy : y \\is a GRing.unit) :\n  (x * y) ^ n = x ^ n * y ^ n.\n",
  "proof": "Proof. by rewrite exprMz_comm //; apply: mulrC. Qed."
}
{
  "statement": "Lemma norms_norm : A \\subset 'N('N(B)).\n",
  "proof": "Proof. by apply/normsP=> x Ax; rewrite -normJ (normsP nBA). Qed."
}
{
  "statement": "Lemma morphim_cprodml A : A \\subset H -> cprodm @* A = fH @* A.\n",
  "proof": "Proof.\nby move=> sHA; rewrite -{1}(mulg1 A) morphim_cprodm ?sub1G // morphim1 mulg1.\nQed."
}
{
  "statement": "Lemma maxsetsup P A B : maxset P A -> P B -> A \\subset B -> B = A.\n",
  "proof": "Proof. by case/maxsetP=> _; apply. Qed."
}
{
  "statement": "Lemma setIC A B : A :&: B = B :&: A.\n",
  "proof": "Proof. by apply/setP => x; rewrite !inE andbC. Qed."
}
{
  "statement": "Lemma cardG_gt0 : 0 < #|G|.\n",
  "proof": "Proof. by rewrite lt0n; apply/existsP; exists (1 : gT). Qed."
}
{
  "statement": "Lemma le_sorted_ltn_nth (x0 : T) (s : seq T) : sorted <=%O s ->\n {in [pred n | (n < size s)%N] &,\n    {homo nth x0 s : i j / (i < j)%N >-> i <= j}}.\n",
  "proof": "Proof. exact/sorted_ltn_nth/le_trans. Qed."
}
{
  "statement": "Lemma filter_subseq a s : subseq (filter a s) s.\n",
  "proof": "Proof. by apply/subseqP; exists (map a s); rewrite ?size_map ?filter_mask. Qed."
}
{
  "statement": "Lemma dvdpNl d p : (- d) %| p = (d %| p).\n",
  "proof": "Proof.\nby rewrite -scaleN1r; apply/eqp_dvdl/eqp_scale; rewrite oppr_eq0 oner_neq0.\nQed."
}
{
  "statement": "Lemma pseries_rcons pi pis gT (A : {set gT}) :\n  pseries (rcons pis pi) A = pcore_mod A pi (pseries pis A).\n",
  "proof": "Proof. by rewrite /pseries rev_rcons. Qed."
}
{
  "statement": "Lemma injm_pair1g : 'injm pair1g.\n",
  "proof": "Proof. by apply/subsetP=> x /morphpreP[_ /set1P[->]]; apply: set11. Qed."
}
{
  "statement": "Lemma injm_pairg1 : 'injm pairg1.\n",
  "proof": "Proof. by apply/subsetP=> x /morphpreP[_ /set1P[->]]; apply: set11. Qed."
}
{
  "statement": "Lemma repr_mxKV m x :\n  x \\in G -> cancel ((@mulmx R m n n)^~ (rG x^-1)) (mulmx^~ (rG x)).\n",
  "proof": "Proof. by rewrite -groupV -{3}[x]invgK; apply: repr_mxK. Qed."
}
{
  "statement": "Lemma Zp_cycle : setT = <[Zp1]>.\n",
  "proof": "Proof. by apply/setP=> x; rewrite -[x]Zp1_expgz inE groupX ?mem_gen ?set11. Qed."
}
{
  "statement": "Lemma ceilM : {in int_num &, {morph ceil : x y / x * y}}.\n",
  "proof": "Proof.\nby move=> _ _ /intrP[m1 ->] /intrP[m2 ->]; rewrite -rmorphM !intrKceil.\nQed."
}
{
  "statement": "Lemma mxrank_mul_min m n p (A : 'M_(m, n)) (B : 'M_(n, p)) :\n  \\rank A + \\rank B - n <= \\rank (A *m B).\n",
  "proof": "Proof.\nby have:= mxrank_Frobenius A 1%:M B; rewrite mulmx1 mul1mx mxrank1 leq_subLR.\nQed."
}
{
  "statement": "Lemma coset_reprK : cancel (fun xbar => repr xbar) coset.\n",
  "proof": "Proof. by move=> xbar; apply: coset_mem (mem_repr_coset xbar). Qed."
}
{
  "statement": "Lemma mulg_subr A B : 1 \\in A -> B \\subset A * B.\n",
  "proof": "Proof. by move=> A1; rewrite -{1}(mul1g B) mulSg ?sub1set. Qed."
}
{
  "statement": "Lemma aut_unity_rootC u v z n : n > 0 -> z ^+ n = 1 -> u (v z) = v (u z).\n",
  "proof": "Proof.\nmove=> n_gt0 /(aut_unity_rootP _ n_gt0) def_z.\nhave [[i def_uz] [j def_vz]] := (def_z u, def_z v).\nby rewrite def_vz def_uz !rmorphXn /= def_vz def_uz exprAC.\nQed."
}
{
  "statement": "Lemma Ratio0 x : Ratio x 0 = ratio0.\n",
  "proof": "Proof. by rewrite /Ratio /insubd; case: insubP; rewrite //= eqxx. Qed."
}
{
  "statement": "Lemma le_sorted_leq_nth (x0 : T) (s : seq T) : sorted <=%O s ->\n  {in [pred n | (n < size s)%N] &,\n    {homo nth x0 s : i j / (i <= j)%N >-> i <= j}}.\n",
  "proof": "Proof. exact/sorted_leq_nth/le_refl/le_trans. Qed."
}
{
  "statement": "Lemma normalM G A B : A <| G -> B <| G -> A * B <| G.\n",
  "proof": "Proof.\nby case/andP=> sAG nAG /andP[sBG nBG]; rewrite /normal mul_subG ?normsM.\nQed."
}
{
  "statement": "Lemma orthomxE u v : (u '_|_ v)%MS = ('[u, v] == 0).\n",
  "proof": "Proof.\nrewrite (sameP sub_kermxP eqP) mulmxA.\nby rewrite [_ *m _^t _]mx11_scalar -trace_mx11 fmorph_eq0.\nQed."
}
{
  "statement": "Lemma isog_extraspecial G (R : {group rT}) :\n  G \\isog R -> extraspecial G -> extraspecial R.\n",
  "proof": "Proof. by case/isogP=> f injf <-; apply: injm_extraspecial. Qed."
}
{
  "statement": "Lemma bij_eq : bijective f -> forall x y, (f x == f y) = (x == y).\n",
  "proof": "Proof. by move/bij_inj; apply: inj_eq. Qed."
}
{
  "statement": "Lemma sub_act_proof u Na : sP (to (val u) (val Na)).\n",
  "proof": "Proof. by case: Na => a /= /(astabs_act (val u)); rewrite !inE valP. Qed."
}
{
  "statement": "Lemma mem_behead s : {subset behead s <= s}.\n",
  "proof": "Proof. by case: s => // y s x; apply: predU1r. Qed."
}
{
  "statement": "Lemma midf_lt x y : x < y -> (x < mid x y) * (mid x y < y).\n",
  "proof": "Proof.\nmove=> ltxy; rewrite ltr_pdivlMr ?ltr_pdivrMr ?ltr0Sn //.\nby rewrite !mulrDr !mulr1 !ltrD2.\nQed."
}
{
  "statement": "Lemma fcycle_rconsE : rcons (x :: p) x = traject f x (size p).+2.\n",
  "proof": "Proof. by rewrite rcons_cons; have /fpathE-> := f_p; rewrite size_rcons. Qed."
}
{
  "statement": "Lemma rgdcopT_qf (p : polyF) (q : polyF) :\n  rpoly p -> rpoly q -> qf_cps rpoly (rgdcopT p q).\n",
  "proof": "Proof.\nby move=> rp rq k kP; rewrite sizeT_qf => //*; rewrite rgdcop_recT_qf.\nQed."
}
{
  "statement": "Lemma kermx0 m n : (kermx (0 : 'M_(m, n)) :=: 1%:M)%MS.\n",
  "proof": "Proof. by apply/eqmxP; rewrite submx1/= sub_kermx mulmx0. Qed."
}
{
  "statement": "Lemma mulG_subG G H K : (G * H \\subset K) = (G \\subset K) && (H \\subset K).\n",
  "proof": "Proof. by rewrite -gen_subG genM_join join_subG. Qed."
}
{
  "statement": "Lemma centsP A B : reflect {in A, centralised B} (A \\subset 'C(B)).\n",
  "proof": "Proof. by apply: (iffP subsetP) => cAB x /cAB/centP. Qed."
}
{
  "statement": "Lemma eq_iteri f f' : f =2 f' -> forall n, iteri n f =1 iteri n f'.\n",
  "proof": "Proof. by move=> eq_f n x; elim: n => //= n ->; rewrite eq_f. Qed."
}
{
  "statement": "Lemma setU1P x a B : reflect (x = a \\/ x \\in B) (x \\in a |: B).\n",
  "proof": "Proof. by rewrite !inE; apply: predU1P. Qed."
}
{
  "statement": "Lemma real_leNgt : {in real &, forall x y, (x <= y) = ~~ (y < x)}.\n",
  "proof": "Proof. by move=> x y xR yR /=; case: real_leP. Qed."
}
{
  "statement": "Lemma join_subG A B G : (A <*> B \\subset G) = (A \\subset G) && (B \\subset G).\n",
  "proof": "Proof. by rewrite gen_subG subUset. Qed."
}
{
  "statement": "Lemma GLmx_faithful : mx_faithful GLrepr.\n",
  "proof": "Proof. by apply/subsetP=> A; rewrite !inE mul1mx. Qed."
}
{
  "statement": "Lemma mkseq_uniq (f : nat -> T) n : injective f -> uniq (mkseq f n).\n",
  "proof": "Proof. by move/map_inj_uniq->; apply: iota_uniq. Qed."
}
{
  "statement": "Lemma modp_addl_mul_small d q r : size r < size d -> (q * d + r) %% d = r.\n",
  "proof": "Proof. by move=> srd; rewrite modpD modp_mull add0r modp_small. Qed."
}
{
  "statement": "Lemma modp_addl_mul_small q r : size r < size d -> (q * d + r) %% d = r.\n",
  "proof": "Proof. by move=> srd; rewrite modpD modp_mull add0r modp_small. Qed."
}
{
  "statement": "Lemma row_mxsub m1 m2 n1 n2\n    (f : 'I_m2 -> 'I_m1) (g : 'I_n2 -> 'I_n1) (A : 'M_(m1, n1)) i :\n  row i (mxsub f g A) = row (f i) (colsub g A).\n",
  "proof": "Proof. by rewrite !rowEsub -!mxsub_comp. Qed."
}
{
  "statement": "Lemma morphim_pprodmr B : B \\subset K -> f @* B = fK @* B.\n",
  "proof": "Proof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_pprodm ?sub1G // morphim1 mul1g.\nQed."
}
{
  "statement": "Lemma setCP x A : reflect (~ x \\in A) (x \\in ~: A).\n",
  "proof": "Proof. by rewrite !inE; apply: negP. Qed."
}
{
  "statement": "Lemma floorM : {in int_num &, {morph floor : x y / x * y}}.\n",
  "proof": "Proof.\nby move=> _ _ /intrP[m1 ->] /intrP[m2 ->]; rewrite -rmorphM !intrKfloor.\nQed."
}
{
  "statement": "Lemma invr_gt1 x : x \\is a GRing.unit -> 0 < x -> (1 < x^-1) = (x < 1).\n",
  "proof": "Proof.\nby move=> Ux xgt0; rewrite -{1}[1]invr1 ltr_pV2 ?inE ?unitr1 ?ltr01 ?Ux.\nQed."
}
{
  "statement": "Lemma coset_one_proof : coset_range H.\n",
  "proof": "Proof. by apply/rcosetsP; exists (1 : gT); rewrite (group1, mulg1). Qed."
}
{
  "statement": "Lemma disjoint_sym A B : [disjoint A & B] = [disjoint B & A].\n",
  "proof": "Proof. by congr (_ == 0); apply: eq_card => x; apply: andbC. Qed."
}
{
  "statement": "Lemma horner_mxZ : scalable horner_mx.\n",
  "proof": "Proof.\nmove=> a p /=; rewrite -mul_polyC rmorphM /=.\nby rewrite horner_mx_C [_ * _]mul_scalar_mx.\nQed."
}
{
  "statement": "Lemma index_map s x : index (f x) (map f s) = index x s.\n",
  "proof": "Proof. by rewrite /index; elim: s => //= y s IHs; rewrite (inj_eq Hf) IHs. Qed."
}
{
  "statement": "Lemma real_ltNge : {in real &, forall x y, (x < y) = ~~ (y <= x)}.\n",
  "proof": "Proof. by move=> x y xR yR /=; case: real_leP. Qed."
}
{
  "statement": "Lemma dvdC_mul2r x y z : y != 0 -> (x * y %| z * y)%C = (x %| z)%C.\n",
  "proof": "Proof.\nmove=> nz_y; rewrite !unfold_in !(mulIr_eq0 _ (mulIf nz_y)).\nby rewrite mulrAC invfM mulrA divfK.\nQed."
}
{
  "statement": "Lemma sgz_def x : sgz x = (-1) ^+ (x < 0)%R *+ (x != 0).\n",
  "proof": "Proof. by rewrite /sgz; case: (_ == _); case: (_ < _). Qed."
}
{
  "statement": "Lemma morphpre_subcent R A : 'C_(f @*^-1 R)(A) \\subset f @*^-1 'C_R(f @* A).\n",
  "proof": "Proof.\nby rewrite -morphpreIdom -setIA setICA morphpreI setIS //; apply: morphpre_cent.\nQed."
}
{
  "statement": "Lemma invr_ge1 x : x \\is a GRing.unit -> 0 < x -> (1 <= x^-1) = (x <= 1).\n",
  "proof": "Proof.\nby move=> Ux xgt0; rewrite -{1}[1]invr1 ler_pV2 ?inE ?unitr1 ?ltr01 // Ux.\nQed."
}
{
  "statement": "Lemma coprime_pi' m n : m > 0 -> n > 0 -> coprime m n = \\pi(m)^'.-nat n.\n",
  "proof": "Proof.\nby move=> m_gt0 n_gt0; rewrite /pnat n_gt0 all_predC coprime_has_primes.\nQed."
}
{
  "statement": "Lemma morphpreD R S : f @*^-1 (R :\\: S) = f @*^-1 R :\\: f @*^-1 S.\n",
  "proof": "Proof. by apply/setP=> x /[!inE]; case: (x \\in D). Qed."
}
{
  "statement": "Lemma subalg_closedBM : subalg_closed -> subring_closed S.\n",
  "proof": "Proof. by case=> S1 Slin SM; split=> //; apply: linear_closedB. Qed."
}
{
  "statement": "Lemma tallyP s : tally s \\is a wf_tally.\n",
  "proof": "Proof.\nrewrite /tally; set bs := [::]; have: bs \\in wf_tally by [].\nby elim: s bs => //= x s IHs bs /(incr_tallyP x)/IHs.\nQed."
}
{
  "statement": "Lemma deg2_poly_root2 : root p r2.\n",
  "proof": "Proof.\napply/factor_theorem.\nby exists (a *: ('X - r1%:P)); rewrite deg2_poly_factor -!scalerAl.\nQed."
}
{
  "statement": "Lemma zchar_on S A : {subset 'Z[S, A] <= 'CF(G, A)}.\n",
  "proof": "Proof. by move=> phi /andP[]. Qed."
}
{
  "statement": "Lemma horner_coef0 p : p.[0] = p`_0.\n",
  "proof": "Proof. by rewrite /horner; case: (p : seq R) => //= c p'; rewrite !simp. Qed."
}
{
  "statement": "Lemma injm_abelian A : A \\subset D -> abelian (f @* A) = abelian A.\n",
  "proof": "Proof.\nby move=> sAD; rewrite /abelian -subsetIidl -injm_subcent // injmSK ?subsetIidl.\nQed."
}
{
  "statement": "Lemma unitfE x : (x \\in unit) = (x != 0).\n",
  "proof": "Proof. by apply/idP/idP=> [/(memPn _)-> | /fieldP]; rewrite ?unitr0. Qed."
}
{
  "statement": "Lemma path_le x x' s : leT x x' -> path leT x' s -> path leT x s.\n",
  "proof": "Proof.\nby case: s => [//| x'' s xlex' /= /andP[x'lex'' ->]]; rewrite (leT_tr xlex').\nQed."
}
{
  "statement": "Lemma eqseq_cons x1 x2 s1 s2 :\n  (x1 :: s1 == x2 :: s2) = (x1 == x2) && (s1 == s2).\n",
  "proof": "Proof. by []. Qed."
}
{
  "statement": "Lemma maxainv_ainvar : maxainv K N -> A \\subset 'N(N | to).\n",
  "proof": "Proof. by move/maxgroupp; case/and3P. Qed."
}
{
  "statement": "Lemma swizzle_mx_is_semi_additive k : semi_additive (swizzle_mx k).\n",
  "proof": "Proof. by split=> [|A B]; apply/matrixP => i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma cfcenter_sub phi : ('Z(phi))%CF \\subset G.\n",
  "proof": "Proof. by rewrite /cfcenter /cfker !setIdE -fun_if subsetIl. Qed."
}
{
  "statement": "Lemma divp_addl_mul_small q r : size r < size d -> (q * d + r) %/ d = q.\n",
  "proof": "Proof. by move=> srd; rewrite divpD (divp_small srd) addr0 mulpK. Qed."
}
{
  "statement": "Lemma sqrtr0 : sqrt 0 = 0 :> R.\n",
  "proof": "Proof. by move: (sqrtr_sqr 0); rewrite exprS mul0r => ->; rewrite normr0. Qed."
}
{
  "statement": "Lemma perm_nilP s : reflect (s = [::]) (perm_eq s [::]).\n",
  "proof": "Proof. by apply: (iffP idP) => [/perm_size/eqP/nilP | ->]. Qed."
}
{
  "statement": "Lemma col_mxblock B_ j :\n  col j (\\mxblock_(i, j) B_ i j) = \\mxcol_i col (sig2 j) (B_ i (sig1 j)).\n",
  "proof": "Proof. by apply/colP => l; rewrite !mxE. Qed."
}
{
  "statement": "Lemma qlogp0 : qlogp 0 = 0%N.\n",
  "proof": "Proof.\nrewrite /qlogp; case: pickP => //= x.\nby rewrite (expf_eq0 ('qX : qT))  (negPf qX_neq0) andbF.\nQed."
}
{
  "statement": "Lemma ltEtprod n T (t1 t2 : n.-tuple T) :\n  t1 < t2 = [exists i, tnth t1 i != tnth t2 i] &&\n            [forall i, tnth t1 i <= tnth t2 i].\n",
  "proof": "Proof. by rewrite lt_neqAle leEtprod eqEtuple negb_forall. Qed."
}
{
  "statement": "Lemma subcent1_cycle_sub x G : x \\in G -> <[x]> \\subset 'C_G[x].\n",
  "proof": "Proof. by move=> Gx; rewrite cycle_subG ?subcent1_id. Qed."
}
{
  "statement": "Lemma boundP x : 0 <= x -> x < (bound x)%:R.\n  ",
  "proof": "Proof. by move/ger0_norm=> {1}<-; rewrite /bound; case: (sigW _). Qed."
}
{
  "statement": "Lemma genJ A z : <<A :^z>> = <<A>> :^ z.\n",
  "proof": "Proof.\nby apply/eqP; rewrite eqEsubset sub_conjg !gen_subG conjSg -?sub_conjg !sub_gen.\nQed."
}
{
  "statement": "Lemma mem_pmap s u : (u \\in pmap f s) = (Some u \\in map f s).\n",
  "proof": "Proof. by elim: s => //= x s IHs; rewrite in_cons -IHs; case: (f x). Qed."
}
{
  "statement": "Lemma iterX (T : Type) (n m : nat) (f : T -> T) :\n  iter (n ^ m) f =1 iter m (iter n) f.\n",
  "proof": "Proof. elim: m => //= m ihm x; rewrite expnS iterM; exact/eq_iter. Qed."
}
{
  "statement": "Lemma morphim_sdprodmr B : B \\subset K -> sdprodm @* B = fK @* B.\n",
  "proof": "Proof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_sdprodm ?sub1G // morphim1 mul1g.\nQed."
}
{
  "statement": "Lemma cyclic_mx_id u : (u <= cyclic_mx u)%MS.\n",
  "proof": "Proof. by apply/cyclic_mxP; exists 1%:M; rewrite ?mulmx1 ?envelop_mx1. Qed."
}
{
  "statement": "Lemma muln_lcmr : right_distributive muln lcmn.\n",
  "proof": "Proof.\ncase=> // m n p; rewrite /lcmn -muln_gcdr -!mulnA divnMl // mulnCA.\nby rewrite muln_divA ?dvdn_mull ?dvdn_gcdr.\nQed."
}
{
  "statement": "Lemma mono_sorted_in s : {in P &, {mono f : x y / e x y >-> e' x y}} ->\n  all P s -> sorted e' (map f s) = sorted e s.\n",
  "proof": "Proof. by case: s => // x s; apply: mono_path_in. Qed."
}
{
  "statement": "Lemma normalY G A B : A <| G -> B <| G -> A <*> B <| G.\n",
  "proof": "Proof.\nby case/andP=> sAG ? /andP[sBG ?]; rewrite /normal join_subG sAG sBG ?normsY.\nQed."
}
{
  "statement": "Lemma hermitianmxE (M : hermitian_matrix) :\n  M = ((-1) ^+ eps) *: M ^t theta :> 'M__.\n",
  "proof": "Proof. by apply/eqP; case: M. Qed."
}
{
  "statement": "Lemma midf_le x y : x <= y -> (x <= mid x y) * (mid x y <= y).\n",
  "proof": "Proof.\nmove=> lexy; rewrite ler_pdivlMr ?ler_pdivrMr ?ltr0Sn //.\nby rewrite !mulrDr !mulr1 !lerD2.\nQed."
}
{
  "statement": "Lemma component_mx_semisimple : mxsemisimple compU.\n",
  "proof": "Proof.\nhave [I [W isoUW ->]] := component_mx_def.\napply: intro_mxsemisimple (eqmx_refl _) _ => i _ _.\nexact: mx_iso_simple (isoUW i) simU.\nQed."
}
{
  "statement": "Lemma horner_mxK p : mx_inv_horner (horner_mx A p) = p %% p_A.\n",
  "proof": "Proof.\nrewrite {1}(Pdiv.IdomainMonic.divp_eq mxminpoly_monic p) rmorphD rmorphM /=.\nrewrite mx_root_minpoly mulr0 add0r.\nby rewrite -(poly_rV_K (size_mod_mxminpoly _)) horner_rVpolyK.\nQed."
}
{
  "statement": "Lemma morphim_cprod : K \\* H = G -> f @* K \\* f @* H = f @* G.\n",
  "proof": "Proof.\ncase/cprodP=> _ defG cKH; rewrite /cprod morphim_cents // morphim_pprod //.\nby rewrite pprodE // cents_norm // centsC.\nQed."
}
{
  "statement": "Lemma denqVz (i : int) : i != 0 -> denq (i%:~R^-1) = `|i|.\n",
  "proof": "Proof.\nmove=> h; rewrite -div1r -[1]/(1%:~R).\nby rewrite coprimeq_den /= ?coprime1n // (negPf h).\nQed."
}
{
  "statement": "Lemma lastr_eq0 (s : seq R) x : x != 0 -> (last x s == 0) = (last 1 s == 0).\n",
  "proof": "Proof. by case: s => [|y s] /negPf // ->; rewrite oner_eq0. Qed."
}
{
  "statement": "Lemma msofK : cancel msof vsof.\n",
  "proof": "Proof. by rewrite /msof /vsof; move=> V; rewrite mxofK// limg_proj. Qed."
}
{
  "statement": "Lemma coef_rVpoly v k : (rVpoly v)`_k = if insub k is Some i then v 0 i else 0.\n",
  "proof": "Proof. by rewrite coef_poly; case: insubP => [i ->|]; rewrite ?if_same. Qed."
}
{
  "statement": "Lemma exists_inP D P : reflect (exists2 x, D x & P x) [exists (x | D x), P x].\n",
  "proof": "Proof. by apply: (iffP 'exists_andP) => [[x []] | [x]]; exists x. Qed."
}
{
  "statement": "Lemma le_enum_rank_in x0 A (Ax0 : x0 \\in A) :\n  {in A &, {mono enum_rank_in Ax0 : x y / x <= y}}.\n",
  "proof": "Proof.\napply: can_mono_in (@in2W _ _ predT predT _ (@le_enum_val A)) => //.\nexact/onW_can_in/enum_rankK_in.\nQed."
}
{
  "statement": "Lemma morphim_cprodmr B : B \\subset K -> cprodm @* B = fK @* B.\n",
  "proof": "Proof.\nby move=> sBK; rewrite -{1}(mul1g B) morphim_cprodm ?sub1G // morphim1 mul1g.\nQed."
}
{
  "statement": "Lemma zcontents_monic p : p \\is monic -> zcontents p = 1.\n",
  "proof": "Proof.\nmove=> mon_p; rewrite /zcontents polySpred ?monic_neq0 //.\nby rewrite big_ord_recr /= -lead_coefE (monicP mon_p) gcdn1.\nQed."
}
{
  "statement": "Lemma iinv_f x fTfx : @iinv T (f x) fTfx = x.\n",
  "proof": "Proof. by apply: in_iinv_f; first apply: in2W. Qed."
}
{
  "statement": "Lemma pinvmx_free m n (A : 'M[F]_(m, n)) : row_full A -> row_free (pinvmx A).\n",
  "proof": "Proof. by move=> /mulVpmx pAA1; apply/row_freeP; exists A. Qed."
}
{
  "statement": "Lemma eqCmodMr0 e : {in Num.int, forall x, e * x == 0 %[mod e]}%C.\n",
  "proof": "Proof. by move=> x Zx; rewrite /= mulrC eqCmodMl0. Qed."
}
{
  "statement": "Lemma pinvmx_full m n (A : 'M[F]_(m, n)) : row_free A -> row_full (pinvmx A).\n",
  "proof": "Proof. by move=> /mulmxVp ApA1; apply/row_fullP; exists A. Qed."
}
{
  "statement": "Lemma map_genmx m n (A : 'M_(m, n)) : (<<A>>^f :=: <<A^f>>)%MS.\n",
  "proof": "Proof. by apply/eqmxP; rewrite !(genmxE, map_submx) andbb. Qed."
}
{
  "statement": "Lemma setUP x A B : reflect (x \\in A \\/ x \\in B) (x \\in A :|: B).\n",
  "proof": "Proof. by rewrite !inE; apply: orP. Qed."
}
{
  "statement": "Lemma lcnSnS n G : [~: 'L_n(G), G] \\subset 'L_n.+1(G).\n",
  "proof": "Proof. by case: n => //; apply: der1_subG. Qed."
}
{
  "statement": "Lemma limgS f U V : (U <= V)%VS -> (f @: U <= f @: V)%VS.\n",
  "proof": "Proof. by rewrite unlock /subsetv !genmxE; apply: submxMr. Qed."
}
{
  "statement": "Lemma mem_rem_uniqF s : uniq s -> x \\in rem s = false.\n",
  "proof": "Proof. by move/mem_rem_uniq->; rewrite inE eqxx. Qed."
}
{
  "statement": "Lemma card_gt0P A : reflect (exists i, i \\in A) (#|A| > 0).\n",
  "proof": "Proof. by rewrite lt0n; apply: pred0Pn. Qed."
}
{
  "statement": "Lemma ler_rootC n : (n > 0)%N -> {in Num.nneg &, {mono n.-root : x y / x <= y}}.\n",
  "proof": "Proof. by move=> n_gt0 x y x_ge0 _; apply: ler_rootCl. Qed."
}
{
  "statement": "Lemma mulgSS A B C D : A \\subset B -> C \\subset D -> A * C \\subset B * D.\n",
  "proof": "Proof. exact: imset2S. Qed."
}
{
  "statement": "Lemma cardX (A1 : {pred T1}) (A2 : {pred T2}) :\n  #|[predX A1 & A2]| = #|A1| * #|A2|.\n",
  "proof": "Proof. by rewrite -predX_prod_enum unlock size_filter unlock. Qed."
}
{
  "statement": "Lemma inv_eq f : involutive f -> forall x y : T, (f x == y) = (x == f y).\n",
  "proof": "Proof. by move=> fK; apply: can2_eq. Qed."
}
{
  "statement": "Lemma irr_degree_abelian : abelian G -> forall i, 'n_i = 1.\n",
  "proof": "Proof. by move=> cGG i; apply: mxsimple_abelian_linear (socle_simple i). Qed."
}
{
  "statement": "Lemma eq_count a1 a2 : a1 =1 a2 -> count a1 =1 count a2.\n",
  "proof": "Proof. by move=> Ea s; rewrite -!size_filter (eq_filter Ea). Qed."
}
{
  "statement": "Lemma disjointWl A B C :\n   A \\subset B -> [disjoint B & C] -> [disjoint A & C].\n",
  "proof": "Proof. by rewrite 2!disjoint_subset; apply: subset_trans. Qed."
}
{
  "statement": "Lemma card_2dihedral n : n > 1 -> #|'D_(2 ^ n)| = (2 ^ n)%N.\n",
  "proof": "Proof.\nmove=> n_gt1; rewrite -(ltn_predK n_gt1) expnS mul2n /= card_dihedral //.\nby rewrite (ltn_exp2l 0) // -(subnKC n_gt1).\nQed."
}
{
  "statement": "Lemma incn_inP : {in D, forall i, i.+1 \\in D -> f i < f i.+1} ->\n  {in D &, {mono f : i j / i <= j}}.\n",
  "proof": "Proof. by move=> f_inc; apply/le_mono_in/homo_ltn_lt_in. Qed."
}
{
  "statement": "Lemma mem_mulg A B x y : x \\in A -> y \\in B -> x * y \\in A * B.\n",
  "proof": "Proof. by move=> Ax By; apply/mulsgP; exists x y. Qed."
}
{
  "statement": "Lemma exponent_injm : exponent (f @* G) = exponent G.\n",
  "proof": "Proof. by apply/eqP; rewrite eqn_dvd -{3}defG !exponent_morphim. Qed."
}
{
  "statement": "Lemma acts_dom A S : [acts A, on S | to] -> A \\subset D.\n",
  "proof": "Proof. by move=> nSA; rewrite (subset_trans nSA) ?subsetIl. Qed."
}
{
  "statement": "Lemma incnP : (forall i, f i < f i.+1) -> {mono f : i j / i <= j}.\n",
  "proof": "Proof. by move=> f_inc; apply/le_mono/homo_ltn_lt. Qed."
}
{
  "statement": "Lemma rdivp_addl_mul q r : rdivp (q * d + r) d = q + rdivp r d.\n",
  "proof": "Proof.\ncase: (monic_comreg mond)=> Hc Hr; rewrite [r in _ * _ + r]rdivp_eq addrA.\nby rewrite -mulrDl rdivp_addl_mul_small // ltn_rmodp monic_neq0.\nQed."
}
{
  "statement": "Lemma muln_modr p m d : p * (m %% d) = (p * m) %% (p * d).\n",
  "proof": "Proof.\nhave [->//|p_gt0] := posnP p; apply: (@addnI (p * (m %/ d * d))).\nby rewrite -mulnDr -divn_eq mulnCA -(divnMl p_gt0) -divn_eq.\nQed."
}
{
  "statement": "Lemma eq_has a1 a2 : a1 =1 a2 -> has a1 =1 has a2.\n",
  "proof": "Proof. by move=> Ea s; rewrite !has_count (eq_count Ea). Qed."
}
{
  "statement": "Lemma divz_abs (m d : int) : (m %/ `|d|)%Z = (-1) ^+ (d < 0)%R * (m %/ d)%Z.\n",
  "proof": "Proof.\nby rewrite {3}[d]intEsign !mulr_sign; case: ifP => -> //; rewrite divzN opprK.\nQed."
}
{
  "statement": "Lemma injm_grank : 'm(f @* G) = 'm(G).\n",
  "proof": "Proof. by apply/eqP; rewrite eqn_leq -{3}defG !morphim_grank ?morphimS. Qed."
}
{
  "statement": "Lemma pblock_inj : {in X &, injective (pblock P)}.\n",
  "proof": "Proof. by move=> x0; apply: (can_in_inj (pblockK x0)). Qed."
}
{
  "statement": "Lemma bin_factd n m : 0 < n -> 'C(n, m) = n`! %/ (m`! * (n - m)`!).\n",
  "proof": "Proof.\nhave [/bin_fact<-|*] := leqP m n; first by rewrite mulnK ?muln_gt0 ?fact_gt0.\nby rewrite divnMA bin_small ?divn_small ?fact_gt0 ?ltn_fact.\nQed."
}
{
  "statement": "Lemma predD1P : reflect (x <> y /\\ b) ((x != y) && b).\n",
  "proof": "Proof. by apply: (iffP andP)=> [] [] // /eqP. Qed."
}
{
  "statement": "Lemma dvdn_add_eq d m n : d %| m + n -> (d %| m) = (d %| n).\n",
  "proof": "Proof. by move=> dv_d_mn; apply/idP/idP => [/dvdn_addr | /dvdn_addl] <-. Qed."
}
{
  "statement": "Lemma nth_last s : nth s (size s).-1 = last x0 s.\n",
  "proof": "Proof. by case: s => //= x s; rewrite last_nth. Qed."
}
{
  "statement": "Lemma subsetD1 A B x : (A \\subset B :\\ x) = (A \\subset B) && (x \\notin A).\n",
  "proof": "Proof. by rewrite setDE subsetI subsetC sub1set inE. Qed."
}
{
  "statement": "Lemma addNr : left_inverse 0 opp +%R.\n",
  "proof": "Proof.\nmove=> v; suff : scale (-1 + 1) v = 0 by rewrite scalerDl scale1r.\nby rewrite addNr scale0r.\nQed."
}
{
  "statement": "Lemma center_cprod A B G : A \\* B = G -> 'Z(A) \\* 'Z(B) = 'Z(G).\n",
  "proof": "Proof.\ncase/cprodP => [[H K -> ->] <- cHK].\nrewrite cprodE ?center_prod //= subIset ?(subset_trans cHK) //.\nby rewrite centS ?center_sub.\nQed."
}
{
  "statement": "Lemma pElemI p A B : 'E_p(A :&: B) = 'E_p(A) :&: subgroups B.\n",
  "proof": "Proof. by apply/setP=> E; rewrite !inE subsetI andbAC. Qed."
}
{
  "statement": "Lemma mask_true s n : size s <= n -> mask (nseq n true) s = s.\n",
  "proof": "Proof. by elim: s n => [|x s IHs] [|n] //= Hn; congr (_ :: _); apply: IHs. Qed."
}
{
  "statement": "Lemma decnP : (forall i, f i > f i.+1) -> {mono f : i j /~ i <= j}.\n",
  "proof": "Proof. by move=> f_dec; apply/le_nmono/nhomo_ltn_lt. Qed."
}
{
  "statement": "Lemma coef_nderivn n p i : p^`N(n)`_i = p`_(n + i) *+  'C(n + i, n).\n",
  "proof": "Proof.\nrewrite coef_poly ltn_subRL; case: leqP => // le_p_ni.\nby rewrite nth_default ?mul0rn.\nQed."
}
{
  "statement": "Lemma flatmx0 n : all_equal_to (0 : 'M_(0, n)).\n",
  "proof": "Proof. by move=> A; apply/matrixP=> [] []. Qed."
}
{
  "statement": "Lemma repr_mx_unit x : x \\in G -> rG x \\in unitmx.\n",
  "proof": "Proof. by move=> Gx; case/mulmx1_unit: (repr_mxKV Gx 1%:M). Qed."
}
{
  "statement": "Lemma pid_mxEcol m n (le_mn : m <= n) :\n  pid_mx n = colsub (widen_ord le_mn) 1%:M.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE -!val_eqE/= ltn_ord andbT. Qed."
}
{
  "statement": "Lemma decn_inP : {in D, forall i, i.+1 \\in D -> f i > f i.+1} ->\n  {in D &, {mono f : i j /~ i <= j}}.\n",
  "proof": "Proof. by move=> f_dec; apply/le_nmono_in/nhomo_ltn_lt_in. Qed."
}
{
  "statement": "Lemma cfRes_id A psi : 'Res[A] psi = psi.\n",
  "proof": "Proof. by apply/cfun_in_genP=> x Ax; rewrite cfunElock Ax subxx. Qed."
}
{
  "statement": "Lemma eqVneq (T : eqType) (x y : T) : eq_xor_neq x y (y == x) (x == y).\n",
  "proof": "Proof. by rewrite eq_sym; case: (altP eqP); constructor. Qed."
}
{
  "statement": "Lemma set1Ul x A b : x \\in A -> x \\in A :|: [set b].\n",
  "proof": "Proof. by move=> Ax; rewrite !inE Ax. Qed."
}
{
  "statement": "Lemma set0D A : set0 :\\: A = set0.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbF. Qed."
}
{
  "statement": "Lemma rot_minn n s : rot n s = rot (minn n (size s)) s.\n",
  "proof": "Proof.\nby case: (leqP n (size s)) => // /leqW ?; rewrite rot_size rot_oversize.\nQed."
}
{
  "statement": "Lemma kAHomP {U V} {f : 'AEnd(L)} :\n  reflect {in U, forall x, f x = x} (kHom U V f).\n",
  "proof": "Proof. by rewrite /kHom ahomWin; apply: fixedSpacesP. Qed."
}
{
  "statement": "Lemma thinmx0 n : all_equal_to (0 : 'M_(n, 0)).\n",
  "proof": "Proof. by move=> A; apply/matrixP=> i []. Qed."
}
{
  "statement": "Lemma cfMorphE phi x : G \\subset D -> x \\in G -> cfMorph phi x = phi (f x).\n",
  "proof": "Proof. by rewrite cfunElock => -> ->. Qed."
}
{
  "statement": "Lemma gacent_gen A : A \\subset D -> 'C_(|to)(<<A>>) = 'C_(|to)(A).\n",
  "proof": "Proof.\nby move=> sAD; rewrite /gacent ![D :&: _](setIidPr _) ?gen_subG ?afix_gen_in.\nQed."
}
{
  "statement": "Lemma properIl A B : ~~ (A \\subset B) -> A :&: B \\proper A.\n",
  "proof": "Proof. by move=> nsBA; rewrite properE subsetIl subsetI negb_and nsBA orbT. Qed."
}
{
  "statement": "Lemma capv_idPr {U V} : reflect (U :&: V = V)%VS (V <= U)%VS.\n",
  "proof": "Proof. by rewrite capvC; apply: capv_idPl. Qed."
}
{
  "statement": "Lemma real_addr_minr : {in real & real & real, @right_distributive R R +%R min}.\n",
  "proof": "Proof. by move=> x y z xr yr zr; rewrite !(addrC x) real_addr_minl. Qed."
}
{
  "statement": "Lemma addv_idPr {U V} : reflect (U + V = V)%VS (U <= V)%VS.\n",
  "proof": "Proof. by rewrite addvC; apply: addv_idPl. Qed."
}
{
  "statement": "Lemma iterM (T : Type) (n m : nat) (f : T -> T) :\n  iter (n * m) f =1 iter n (iter m f).\n",
  "proof": "Proof. by move=> x; elim: n => //= n <-; rewrite mulSn iterD. Qed."
}
{
  "statement": "Lemma p_rankJ p A x : 'r_p(A :^ x) = 'r_p(A).\n",
  "proof": "Proof.\nrewrite /p_rank (reindex_inj (act_inj 'JG x)).\nby apply: eq_big => [E | E _]; rewrite ?cardJg ?pElemJ.\nQed."
}
{
  "statement": "Lemma bigdprodWY I (r : seq I) P F G :\n  \\big[dprod/1]_(i <- r | P i) F i = G -> << \\bigcup_(i <- r | P i) F i >> = G.\n",
  "proof": "Proof. by move/bigdprodWcp; apply: bigcprodWY. Qed."
}
{
  "statement": "Lemma LagrangeMl G H : (#|G| * #|H : G|)%N = #|G * H|.\n",
  "proof": "Proof.\nrewrite mulnC -(card_uniform_partition _ (rcosets_partition_mul H G)) //.\nby move=> _ /rcosetsP[x Hx ->]; rewrite card_rcoset.\nQed."
}
{
  "statement": "Lemma image_f A x : x \\in A -> f x \\in image f A.\n",
  "proof": "Proof. by move=> Ax; apply/imageP; exists x. Qed."
}
{
  "statement": "Lemma normalI G A B : A <| G -> B <| G -> A :&: B <| G.\n",
  "proof": "Proof.\nby case/andP=> sAG nAG /andP[_ nBG]; rewrite /normal subIset ?sAG // normsI.\nQed."
}
{
  "statement": "Lemma fcard_id (a : {pred T}) : fcard id a = #|a|.\n",
  "proof": "Proof. by apply: eq_card => x; rewrite inE froots_id. Qed."
}
{
  "statement": "Lemma perm_prime_astab x : 'C_<[c]>[x | 'P]%g = 1%g.\n",
  "proof": "Proof.\nby apply/card1_trivg/eqP; rewrite -(@eqn_pmul2l #|orbit 'P <[c]> x|)\n   ?card_orbit_stab ?perm_prime_orbit ?cardsT ?muln1 ?prime_gt0// -cc.\nQed."
}
{
  "statement": "Lemma monic_map p : p \\is monic -> p^f \\is monic.\n",
  "proof": "Proof.\nmove/monicP=> mon_p; rewrite monicE.\nby rewrite lead_coef_map_eq mon_p /= rmorph1 ?oner_neq0.\nQed."
}
{
  "statement": "Lemma real_addr_maxr : {in real & real & real, @right_distributive R R +%R max}.\n",
  "proof": "Proof. by move=> x y z xr yr zr; rewrite !(addrC x) real_addr_maxl. Qed."
}
{
  "statement": "Lemma ker_comp : 'ker gof = f @*^-1 'ker g.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbA. Qed."
}
{
  "statement": "Lemma subUset A B C : (B :|: C \\subset A) = (B \\subset A) && (C \\subset A).\n",
  "proof": "Proof. by rewrite -setCS setCU subsetI !setCS. Qed."
}
{
  "statement": "Lemma semiprimeJ K H x : semiprime K H -> semiprime (K :^ x) (H :^ x).\n",
  "proof": "Proof.\nmove=> prH yx; rewrite -conjD1g => /imsetP[y Hy ->].\nby rewrite cent1J centJ -!conjIg prH.\nQed."
}
{
  "statement": "Lemma const_mx_is_semi_additive : semi_additive const_mx.\n",
  "proof": "Proof. by split=> [|a b]; apply/matrixP => // i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma ltn_odd_Frobenius_ker : odd #|G| -> #|H|.*2 < #|K|.\n",
  "proof": "Proof.\nmove/oddSg=> oddG.\nhave [/sdprodW/mulG_sub[sKG sHG] ntK _ _ _] := Frobenius_context.\nby rewrite dvdn_double_ltn ?oddG ?cardG_gt1 ?Frobenius_dvd_ker1.\nQed."
}
{
  "statement": "Lemma modpP p q d r : p = q * d + r -> size r < size d -> r = (p %% d).\n",
  "proof": "Proof. by move/divp_modpP=> h; case/h. Qed."
}
{
  "statement": "Lemma ltxi_lehead x s1 y s2 : x :: s1 < y :: s2 :> seq T -> x <= y.\n",
  "proof": "Proof. by rewrite ltxi_cons => /andP[]. Qed."
}
{
  "statement": "Lemma size_insub_bseq n T (s : seq T) : size (insub_bseq n s) <= size s.\n",
  "proof": "Proof. by rewrite /insub_bseq /insubd; case: insubP => // ? ? ->. Qed."
}
{
  "statement": "Lemma lexi_lehead x s1 y s2 : x :: s1 <= y :: s2 :> seq T -> x <= y.\n",
  "proof": "Proof. by rewrite lexi_cons => /andP[]. Qed."
}
{
  "statement": "Lemma divpP p q d r : p = q * d + r -> size r < size d ->\n  q = (p %/ d).\n",
  "proof": "Proof. by move/divp_modpP=> h; case/h. Qed."
}
{
  "statement": "Lemma cfRepr_dadd rG1 rG2 :\n  cfRepr (dadd_grepr rG1 rG2) = cfRepr rG1 + cfRepr rG2.\n",
  "proof": "Proof. by apply/cfun_inP=> x Gx; rewrite !cfunE Gx mxtrace_block. Qed."
}
{
  "statement": "Lemma lcn_char n G : 'L_n(G) \\char G.\n",
  "proof": "Proof. by case: n; last elim=> [|n IHn]; rewrite ?char_refl ?lcnSn ?charR. Qed."
}
{
  "statement": "Lemma diffmxSl m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :\\: B <= A)%MS.\n",
  "proof": "Proof. by rewrite diffmxE capmxSl. Qed."
}
{
  "statement": "Lemma map_poly_div_inj : injective (map_poly (qpolyC h)).\n",
  "proof": "Proof.\napply: map_inj_poly => [x y /val_eqP /eqP /polyC_inj //|].\nby rewrite qpolyC0.\nQed."
}
{
  "statement": "Lemma pid_mxErow m n (le_mn : m <= n) :\n  pid_mx m = rowsub (widen_ord le_mn) 1%:M.\n",
  "proof": "Proof. by apply/matrixP=> i j; rewrite !mxE -!val_eqE/= ltn_ord andbT. Qed."
}
{
  "statement": "Lemma reshapeKr sh s : size s <= sumn sh -> flatten (reshape sh s) = s.\n",
  "proof": "Proof.\nelim: sh s => [[]|n sh IHsh] //= s sz_s; rewrite IHsh ?cat_take_drop //.\nby rewrite size_drop leq_subLR.\nQed."
}
{
  "statement": "Lemma mulrnDr x m n : x *+ (m + n) = x *+ m + x *+ n.\n",
  "proof": "Proof.\nelim: m => [|m IHm]; first by rewrite add0r.\nby rewrite !mulrS IHm addrA.\nQed."
}
{
  "statement": "Lemma setTD A : setT :\\: A = ~: A.\n",
  "proof": "Proof. by apply/setP=> x; rewrite !inE andbT. Qed."
}
{
  "statement": "Lemma contraPneq P x y : (x = y -> ~ P) -> P -> x != y.\n",
  "proof": "Proof. by move=> imp; apply: contraPN => /eqP. Qed."
}
{
  "statement": "Lemma contra_eq_not P x y : (P -> x != y) -> x = y -> ~ P.\n",
  "proof": "Proof. by move=> imp /eqP; apply: contraTnot. Qed."
}
{
  "statement": "Lemma bin_ffact n m : 'C(n, m) * m`! = n ^_ m.\n",
  "proof": "Proof.\nhave [lt_n_m | le_m_n] := ltnP n m; first by rewrite bin_small ?ffact_small.\nby rewrite ffact_factd // -(bin_fact le_m_n) mulnA mulnK ?fact_gt0.\nQed."
}
{
  "statement": "Lemma modpP p q r : p = q * d + r -> size r < size d -> r = (p %% d).\n",
  "proof": "Proof. by move/edivpP=> h; case/h. Qed."
}
{
  "statement": "Lemma cpair_center_id : 'Z(CH) = 'Z(CK).\n",
  "proof": "Proof.\nrewrite -!injm_center // -gzZ -morphim_comp; apply: eq_in_morphim eq_cpairZ.\nby rewrite !(setIidPr _) // -sub_morphim_pre.\nQed."
}
{
  "statement": "Lemma contra_not_neq P x y : (x = y -> P) -> ~ P -> x != y.\n",
  "proof": "Proof. by move=> imp; apply: contra_notN => /eqP. Qed."
}
{
  "statement": "Lemma quotient_pcore_mod pi gT (G : {group gT}) (B : {set gT}) :\n  pcore_mod G pi B / B = 'O_pi(G / B).\n",
  "proof": "Proof. exact/morphpreK/gFsub_trans/morphim_sub. Qed."
}
{
  "statement": "Lemma map_group_ring : (group_ring aR G)^f = group_ring rR G.\n",
  "proof": "Proof.\nrewrite map_enveloping_algebra_mx; apply/row_matrixP=> i.\nby rewrite !rowK map_regular_repr.\nQed."
}
{
  "statement": "Lemma divpP p q r : p = q * d + r -> size r < size d -> q = (p %/ d).\n",
  "proof": "Proof. by move/edivpP=> h; case/h. Qed."
}
{
  "statement": "Lemma rmorph_root p x : root p x -> root p^f (f x).\n",
  "proof": "Proof. by move/eqP=> px0; rewrite rootE horner_map px0 rmorph0. Qed."
}
{
  "statement": "Lemma divpE p q :\n  p %/ q = if lead_coef q \\in GRing.unit\n    then lead_coef q ^- rscalp p q *: rdivp p q\n    else rdivp p q.\n",
  "proof": "Proof. by case: ifP; rewrite /divp unlock redivp_def => ->. Qed."
}
{
  "statement": "Lemma itv_bound_total : total (<=%O : rel (itv_bound T)).\n",
  "proof": "Proof. by move=> [[]?|[]][[]?|[]]; rewrite /<=%O //=; case: ltgtP. Qed."
}
{
  "statement": "Lemma coprimep_modl p q : coprimep (p %% q) q = coprimep p q.\n",
  "proof": "Proof.\nrewrite !coprimep_def [in RHS]gcdpE.\nby case: ltnP => // hpq; rewrite modp_small // gcdpE hpq.\nQed."
}
{
  "statement": "Lemma dirr_consttE (phi : 'CF(G)) (i : dIirr G) :\n  (i \\in dirr_constt phi) = (0 < '[phi, dchi i]).\n",
  "proof": "Proof. by rewrite inE. Qed."
}
{
  "statement": "Lemma FrobeniusW : [Frobenius G].\n",
  "proof": "Proof. by apply/existsP; exists H; apply: FrobeniusWcompl. Qed."
}
{
  "statement": "Lemma normsR : A \\subset 'N([~: B, C]).\n",
  "proof": "Proof. by apply/normsP=> x Ax; rewrite conjsRg !(normsP _ x Ax). Qed."
}
{
  "statement": "Lemma catr2_infix s s1 s2 : infix (s ++ s1) (s ++ s2) -> infix s1 s2.\n",
  "proof": "Proof. by elim: s => //= x s IHs /cons2_infix. Qed."
}
{
  "statement": "Lemma eqp_gcd p1 p2 q1 q2 : p1 %= p2 -> q1 %= q2 -> gcdp p1 q1 %= gcdp p2 q2.\n",
  "proof": "Proof. move=> e1 e2; exact: eqp_trans (eqp_gcdr _ e2) (eqp_gcdl _ e1). Qed."
}
{
  "statement": "Lemma connect_root x : connect x (root x).\n",
  "proof": "Proof. by rewrite /root; case: pickP; rewrite ?connect0. Qed."
}
{
  "statement": "Lemma sorted_pairwise_in s : all P s -> sorted leT s = pairwise leT s.\n",
  "proof": "Proof.\nby elim: s => //= x s IHs /andP [Px Ps]; rewrite path_sorted_inE ?IHs //= Px.\nQed."
}
{
  "statement": "Lemma rsim_abelem_subg : mx_rsim rHG rH.\n",
  "proof": "Proof.\nexists 1%:M => [//| |x Hx]; first by rewrite row_free_unit unitmx1.\nby rewrite mul1mx mulmx1 eq_abelem_subg_repr.\nQed."
}
{
  "statement": "Lemma big_image_cond I (J : finType) (h : J -> I) (A : pred J) (P : pred I) F :\n  \\big[op/x]_(i <- [seq h j | j in A] | P i) F i\n     = \\big[op/x]_(j in A | P (h j)) F (h j).\n",
  "proof": "Proof. by rewrite big_map big_enum_cond. Qed."
}
{
  "statement": "Lemma contra_eqT b x y : (~~ b -> x != y) -> x = y -> b.\n",
  "proof": "Proof. by move=> imp /eqP; apply: contraLR. Qed."
}
{
  "statement": "Lemma all_comm_mx2P f g : reflect (f *m g = g *m f) (all_comm_mx [:: f; g]).\n",
  "proof": "Proof. by rewrite /comm_mxb /= all2rel2 ?eqxx //; exact: eqP. Qed."
}
{
  "statement": "Lemma extraspecial_prime : prime p.\n",
  "proof": "Proof.\nby case: esS => _ /prime_gt1; rewrite cardG_gt1; case/(pgroup_pdiv pZ).\nQed."
}
{
  "statement": "Lemma can_in_eq :\n  {in D, cancel f g} -> {in D &, forall x y, (f x == f y) = (x == y)}.\n",
  "proof": "Proof. by move/can_in_inj; apply: inj_in_eq. Qed."
}
{
  "statement": "Lemma normsD : A \\subset 'N(B :\\: C).\n",
  "proof": "Proof. by apply/normsP=> x Ax; rewrite conjDg !(normsP _ x Ax). Qed."
}
{
  "statement": "Lemma p_rank1 p : 'r_p([1 gT]) = 0.\n",
  "proof": "Proof. by apply/eqP; rewrite eqn0Ngt p_rank_gt0 /= cards1. Qed."
}
{
  "statement": "Lemma normsM : A \\subset 'N(B * C).\n",
  "proof": "Proof. by apply/normsP=> x Ax; rewrite conjsMg !(normsP _ x Ax). Qed."
}
{
  "statement": "Lemma negb_forall_in D P :\n  ~~ [forall (x | D x), P x] = [exists (x | D x), ~~ P x].\n",
  "proof": "Proof. by apply: eq_existsb => x; rewrite negb_imply. Qed."
}
{
  "statement": "Lemma normsU : A \\subset 'N(B :|: C).\n",
  "proof": "Proof. by apply/normsP=> x Ax; rewrite conjUg !(normsP _ x Ax). Qed."
}
{
  "statement": "Lemma bigmin_inf j P m F : P j -> F j <= m -> \\big[min/x]_(i | P i) F i <= m.\n",
  "proof": "Proof. by move=> Pj ?; apply: le_trans (bigmin_le_cond _ Pj) _. Qed."
}
{
  "statement": "Lemma cfMorph_lin_char chi :\n  chi \\is a linear_char -> cfMorph chi \\is a linear_char.\n",
  "proof": "Proof. by case/andP=> Nchi; rewrite qualifE/= cfMorph1 cfMorph_char. Qed."
}
{
  "statement": "Lemma cfAut_char1 u (chi : 'CF(G)) :\n  chi \\is a character -> cfAut u chi 1%g = chi 1%g.\n",
  "proof": "Proof. by move/Cnat_char1=> Nchi1; rewrite cfunE /= aut_natr. Qed."
}
{
  "statement": "Lemma coprimep_sym p q : coprimep p q = coprimep q p.\n",
  "proof": "Proof. by rewrite -!gcdp_eqp1; apply: eqp_ltrans; rewrite gcdpC. Qed."
}
{
  "statement": "Lemma quotient_cfker_mod (A : {set gT}) K (psi : 'CF(G / K)) :\n  K <| G -> (cfker (psi %% K) / K)%g = cfker psi.\n",
  "proof": "Proof. by case/andP=> _ /cfker_morph_im <-. Qed."
}
{
  "statement": "Lemma comp_polyA p q r : p \\Po (q \\Po r) = (p \\Po q) \\Po r.\n",
  "proof": "Proof.\nelim/poly_ind: p => [|p c IHp]; first by rewrite !comp_polyC.\nby rewrite !comp_polyD !comp_polyM !comp_polyX IHp !comp_polyC.\nQed."
}
{
  "statement": "Lemma map_mx_comp (f : R -> S) (g : S -> T)\n  (M : 'M_(m, n)) : M ^ (g \\o f) = (M ^ f) ^ g.\n",
  "proof": "Proof. by apply/matrixP => i j; rewrite !mxE. Qed."
}
{
  "statement": "Lemma cfnorm_ge0 phi : 0 <= '[phi].\n",
  "proof": "Proof.\nby rewrite mulr_ge0 ?invr_ge0 ?ler0n ?sumr_ge0 // => x _; apply: mul_conjC_ge0.\nQed."
}
{
  "statement": "Lemma norm_joinEr G H : H \\subset 'N(G) -> G <*> H = G * H.\n",
  "proof": "Proof. by move/normC=> cHG; apply: comm_joingE. Qed."
}
{
  "statement": "Lemma signr_eq0 n : ((-1) ^+ n == 0 :> R) = false.\n",
  "proof": "Proof. by rewrite -signr_odd; case: odd; rewrite ?oppr_eq0 oner_eq0. Qed."
}
{
  "statement": "Lemma sorted_map s : sorted e' (map f s) = sorted (relpre f e') s.\n",
  "proof": "Proof. by case: s; last apply: path_map. Qed."
}
{
  "statement": "Lemma pcore_mod_sub pi gT (G : {group gT}) : pcore_mod G pi (F _ G) \\subset G.\n",
  "proof": "Proof.\nby rewrite sub_morphpre_im ?gFsub_trans ?morphimS ?gFnorm //= ker_coset gFsub.\nQed."
}
{
  "statement": "Lemma mxsemisimple_module U : mxsemisimple U -> mxmodule U.\n",
  "proof": "Proof.\ncase=> I W /= simW defU _.\nby rewrite -(eqmx_module defU) sumsmx_module // => i _; case: (simW i).\nQed."
}
{
  "statement": "Lemma eqmodP x y : reflect (x = y %[mod qT]) (eD x y).\n",
  "proof": "Proof. by apply: (iffP (pi_DC _ _)); rewrite !unlock. Qed."
}
{
  "statement": "Lemma contra_eqN b x y : (b -> x != y) -> x = y -> ~~ b.\n",
  "proof": "Proof. by move=> imp /eqP; apply: contraL. Qed."
}
{
  "statement": "Lemma capmxSr m1 m2 n (A : 'M_(m1, n)) (B : 'M_(m2, n)) : (A :&: B <= B)%MS.\n",
  "proof": "Proof. by rewrite capmxC capmxSl. Qed."
}
{
  "statement": "Lemma sorted_relI s :\n  sorted [rel x y | e x y && e' x y] s = sorted e s && sorted e' s.\n",
  "proof": "Proof. by case: s; last apply: path_relI. Qed."
}
{
  "statement": "Lemma finv_bij : bijective finv.\n",
  "proof": "Proof. by exists f; [apply: f_finv|apply: finv_f]. Qed."
}
{
  "statement": "Lemma rmorph_unity_root n z : n.-unity_root z -> n.-unity_root (f z).\n",
  "proof": "Proof.\nmove/rmorph_root; rewrite rootE rmorphB hornerD hornerN.\nby rewrite /= map_polyXn rmorph1 hornerC hornerXn subr_eq0 unity_rootE.\nQed."
}
{
  "statement": "Lemma injm_Phi rT D G (f : {morphism D >-> rT}) :\n  'injm f -> G \\subset D -> f @* 'Phi(G) = 'Phi(f @* G).\n",
  "proof": "Proof. exact: injmF. Qed."
}
{
  "statement": "Lemma normM x y : norm (x * y) = norm x * norm y.\n",
  "proof": "Proof.\n  by rewrite mulrACA -rmorphM; apply: normE; rewrite exprMn !sqrtK.\nQed."
}
{
  "statement": "Lemma coprimepP (p q : {poly F}) :\n  reflect (forall x, root p x -> q.[x] != 0) (coprimep p q).\n",
  "proof": "Proof. by apply: (iffP idP)=> [/coprimep_root|/root_coprimep]. Qed."
}
